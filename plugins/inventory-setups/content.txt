/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import inventorysetups.serialization.InventorySetupPortable;
import inventorysetups.ui.InventorySetupsPluginPanel;
import inventorysetups.ui.InventorySetupsSlot;
import java.awt.Color;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.KeyCode;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.ScriptID;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.vars.InputType;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.game.chatbox.ChatboxItemSearch;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.game.chatbox.ChatboxTextInput;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.bank.BankSearch;
import net.runelite.client.plugins.banktags.TagManager;
import net.runelite.client.plugins.banktags.tabs.LayoutManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.plugins.banktags.BankTagsPlugin;
import net.runelite.client.plugins.banktags.BankTagsService;
import net.runelite.client.plugins.banktags.tabs.Layout;

import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.SwingConstants;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.io.File;
import java.io.FileOutputStream;
import java.util.stream.IntStream;

import static inventorysetups.ui.InventorySetupsRunePouchPanel.RUNE_POUCH_AMOUNT_VARBITS;
import static inventorysetups.ui.InventorySetupsRunePouchPanel.RUNE_POUCH_RUNE_VARBITS;


@PluginDescriptor(
	name = "Inventory Setups",
	description = "Save gear setups for specific activities"
)

@PluginDependency(BankTagsPlugin.class)
@Slf4j
public class InventorySetupsPlugin extends Plugin
{

	public static final String CONFIG_GROUP = "inventorysetups";

	public static final String CONFIG_KEY_SECTION_MODE = "sectionMode";
	public static final String CONFIG_KEY_PANEL_VIEW = "panelView";
	public static final String CONFIG_KEY_SORTING_MODE = "sortingMode";
	public static final String CONFIG_KEY_SECTION_SORTING = "sectionSorting";
	public static final String CONFIG_KEY_HIDE_BUTTON = "hideHelpButton";
	public static final String CONFIG_KEY_VERSION_STR = "version";
	public static final String CONFIG_KEY_UNASSIGNED_MAXIMIZED = "unassignedMaximized";
	public static final String CONFIG_KEY_MANUAL_BANK_FILTER = "manualBankFilter";
	public static final String CONFIG_KEY_PERSIST_HOTKEYS = "persistHotKeysOutsideBank";
	public static final String CONFIG_KEY_PERSIST_HOTKEYS_CHAT_INPUT = "persistHotKeysDuringChatInput";
	public static final String CONFIG_KEY_USE_LAYOUTS = "useLayouts";
	public static final String CONFIG_KEY_LAYOUT_DEFAULT = "defaultLayout";
	public static final String CONFIG_KEY_ZIGZAG_TYPE = "zigZagType";
	public static final String CONFIG_KEY_LAYOUT_DUPLICATES = "addDuplicatesInLayouts";
	public static final String CONFIG_KEY_ENABLE_LAYOUT_WARNING = "enableLayoutWarning";
	public static final String CONFIG_GROUP_HUB_BTL = "banktaglayouts";
	// Bank tags will standardize tag names so this must not be modified by that standardization.
	// DO NOT CHANGE THIS. CHANGING THIS WOULD REQUIRE MIGRATION OF USER DATA.
	// IF CHANGING, HUB BTL MUST BE UPDATED AS WELL.
	public static final String LAYOUT_PREFIX_MARKER = "_invsetup_";
	public static final String TUTORIAL_LINK = "https://github.com/dillydill123/inventory-setups#inventory-setups";
	public static final String SUGGESTION_LINK = "https://github.com/dillydill123/inventory-setups/issues";
	public static final int NUM_INVENTORY_ITEMS = 28;
	public static final int NUM_EQUIPMENT_ITEMS = 14;
	public static final int MAX_SETUP_NAME_LENGTH = 50;
	private static final String OPEN_SECTION_MENU_ENTRY = "Open Section";
	private static final String OPEN_SETUP_MENU_ENTRY = "Open setup";
	private static final String RETURN_TO_OVERVIEW_ENTRY = "Close current setup";
	private static final String AUTO_LAYOUT_PRESET_ENTRY = "Auto layout: Preset";
	private static final String AUTO_LAYOUT_ZIGZAG_ENTRY = "Auto layout: ZigZag";
	private static final String ADD_TO_ADDITIONAL_ENTRY = "Add to Additional Filtered Items";
	private static final String UNASSIGNED_SECTION_SETUP_MENU_ENTRY = "Unassigned";
	private static final String ITEM_SEARCH_TAG = "item:";
	private static final String NOTES_SEARCH_TAG = "notes:";
	private static final int SPELLBOOK_VARBIT = 4070;
	private static final int BANK_TAG_OPTIONS = BankTagsService.OPTION_ALLOW_MODIFICATIONS | BankTagsService.OPTION_HIDE_TAG_NAME;

	@Inject
	@Getter
	private Client client;

	@Inject
	@Getter
	private ItemManager itemManager;

	@Inject
	@Getter
	private SpriteManager spriteManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	@Getter
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	@Getter
	private InventorySetupsConfig config;

	@Inject
	private Gson gson;

	@Inject
	private PluginManager pluginManager;

	@Inject
	@Getter
	private ColorPickerManager colorPickerManager;

	private InventorySetupsPluginPanel panel;

	@Getter
	private List<InventorySetup> inventorySetups;

	@Getter
	private List<InventorySetupsSection> sections;

	@Getter
	private InventorySetupsCache cache;

	private NavigationButton navButton;

	@Inject
	private BankTagsService bankTagsService;

	@Inject
	private BankTagsPlugin bankTagsPlugin;

	@Inject
	private BankSearch bankSearch;

	@Inject
	@Getter
	private LayoutManager layoutManager;

	@Inject
	@Getter
	private TagManager tagManager;

	@Inject
	private KeyManager keyManager;

	@Getter
	private InventorySetupLayoutUtilities layoutUtilities;

	@Getter
	private Boolean canUseLayouts;

	@Inject
	@Getter
	private ChatboxItemSearch itemSearch;

	@Inject
	private ChatboxPanelManager chatboxPanelManager;

	private ChatboxTextInput searchInput;

	@Setter
	@Getter
	private boolean navButtonIsSelected;

	// current version of the plugin
	private String currentVersion;

	@Getter
	private InventorySetupsPersistentDataManager dataManager;

	@Getter
	private InventorySetupsAmmoHandler ammoHandler;

	// Used to defer highlighting to GameTick
	private boolean shouldTriggerInventoryHighlightOnGameTick;

	// Whether a search input of any kind (bank, seed vault, item search, etc.) is happening
	private boolean chatBoxInputIsOpen;

	// Whether hot keys are registered
	private boolean hotkeysAreRegistered;

	private final HotkeyListener returnToSetupsHotkeyListener = new HotkeyListener(() -> config.returnToSetupsHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			panel.returnToOverviewPanel(false);
		}
	};

	private final HotkeyListener filterBankHotkeyListener = new HotkeyListener(() -> config.filterBankHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			triggerBankSearchFromHotKey();
		}
	};

	private final HotkeyListener sectionModeHotkeyListener = new HotkeyListener(() -> config.sectionModeHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			panel.toggleSectionMode();
		}
	};

	@Override
	public void startUp()
	{
		// get current version of the plugin using properties file generated by build.gradle
		try
		{
			final Properties props = new Properties();
			InputStream is = InventorySetupsPlugin.class.getResourceAsStream("/invsetups_version.txt");
			props.load(is);
			this.currentVersion = props.getProperty("version");
		}
		catch (Exception e)
		{
			log.warn("Could not determine current plugin version", e);
			this.currentVersion = "";
		}

		this.panel = new InventorySetupsPluginPanel(this, itemManager);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/inventorysetups_icon.png");

		this.navButtonIsSelected = false;
		navButton = NavigationButton.builder()
				.tooltip("Inventory Setups")
				.icon(icon)
				.priority(6)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);

		this.shouldTriggerInventoryHighlightOnGameTick = false;
		this.chatBoxInputIsOpen = false;
		this.hotkeysAreRegistered = false;
		this.cache = new InventorySetupsCache();
		this.inventorySetups = new ArrayList<>();
		this.sections = new ArrayList<>();
		this.dataManager = new InventorySetupsPersistentDataManager(this, configManager, cache, gson, inventorySetups, sections);
		this.ammoHandler = new InventorySetupsAmmoHandler(this, client, itemManager, panel, config);
		this.layoutUtilities = new InventorySetupLayoutUtilities(itemManager, tagManager, layoutManager, config, client);
		this.canUseLayouts = canUseLayouts();

		// load all the inventory setups from the config file
		clientThread.invokeLater(() ->
		{
			switch (client.getGameState())
			{
				case STARTING:
				case UNKNOWN:
				case LOADING:
					return false;
			}

			clientThread.invokeLater(() ->
			{
				dataManager.loadConfig();
				handleRegistrationOfHotkeys();
				SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(true));
			});

			return true;
		});

	}

	@Override
	public void shutDown()
	{
		resetBankSearch();
		clientToolbar.removeNavigation(navButton);
	}

	public String getSavedVersionString()
	{
		final String versionStr = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_VERSION_STR);
		return versionStr == null ? "" : versionStr;
	}

	public void setSavedVersionString(final String newVersion)
	{
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_VERSION_STR, newVersion);
	}

	public String getCurrentVersionString()
	{
		return currentVersion;
	}

	private boolean canUseLayouts()
	{
		// If Bank Tags is off, layouts will not work.
		return pluginManager.isPluginEnabled(bankTagsPlugin);
	}

	public void enableLayouts()
	{
		// Turn on Bank Tags and configure hub plugin bank tag layouts setting to be off.
		if (!pluginManager.isPluginEnabled(bankTagsPlugin))
		{
			log.info("Turning on Bank Tags plugin");
			pluginManager.setPluginEnabled(bankTagsPlugin, true);
			try
			{
				pluginManager.startPlugin(bankTagsPlugin);
			}
			catch (Exception e)
			{
				log.error("Failed to start Bank Tags plugin.");
				log.error(e.toString());
			}
		}
	}

	@Subscribe
	public void onPluginChanged(PluginChanged pluginChanged)
	{
		if (pluginChanged.getPlugin() == bankTagsPlugin)
		{
			this.canUseLayouts = canUseLayouts();
		}
	}

	private void registerHotkeys()
	{
		if (!this.hotkeysAreRegistered)
		{
			keyManager.registerKeyListener(returnToSetupsHotkeyListener);
			keyManager.registerKeyListener(filterBankHotkeyListener);
			keyManager.registerKeyListener(sectionModeHotkeyListener);
			this.hotkeysAreRegistered = true;
		}
	}

	private void unregisterHotkeys()
	{
		if (this.hotkeysAreRegistered)
		{
			keyManager.unregisterKeyListener(returnToSetupsHotkeyListener);
			keyManager.unregisterKeyListener(filterBankHotkeyListener);
			keyManager.unregisterKeyListener(sectionModeHotkeyListener);
			this.hotkeysAreRegistered = false;
		}
	}

	private void handleRegistrationOfHotkeys()
	{
		Widget bankContainer = client.getWidget(InterfaceID.Bankmain.ITEMS);
		boolean bankIsOpen = bankContainer != null && !bankContainer.isHidden();

		// Bank takes priority if hotkeys are disabled.
		boolean shouldRegisterKeys = bankIsOpen || config.persistHotKeysOutsideBank();
		if (!shouldRegisterKeys)
		{
			unregisterHotkeys();
			return;
		}

		// If the bank wants to enable hotkeys, then ensure chat input will allow it as well.
		shouldRegisterKeys = !this.chatBoxInputIsOpen || config.persistHotKeysDuringChatInput();
		if (shouldRegisterKeys)
		{
			registerHotkeys();
		}
		else
		{
			unregisterHotkeys();
		}
	}

	@Provides
	InventorySetupsConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(InventorySetupsConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals(CONFIG_GROUP))
		{
			if (event.getKey().equals(CONFIG_KEY_PANEL_VIEW) || event.getKey().equals(CONFIG_KEY_SECTION_MODE) ||
				event.getKey().equals(CONFIG_KEY_SORTING_MODE) || event.getKey().equals(CONFIG_KEY_HIDE_BUTTON) ||
				event.getKey().equals(CONFIG_KEY_UNASSIGNED_MAXIMIZED) || event.getKey().equals(CONFIG_KEY_SECTION_SORTING))
			{
				SwingUtilities.invokeLater(() ->
				{
					panel.redrawOverviewPanel(false);
				});
			}
			else if (event.getKey().equals(CONFIG_KEY_PERSIST_HOTKEYS) || event.getKey().equals(CONFIG_KEY_PERSIST_HOTKEYS_CHAT_INPUT))
			{
				clientThread.invokeLater(this::handleRegistrationOfHotkeys);
			}
			else if (event.getKey().equals(CONFIG_KEY_USE_LAYOUTS))
			{
				doBankSearch();
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (shouldTriggerInventoryHighlightOnGameTick)
		{
			shouldTriggerInventoryHighlightOnGameTick = false;
			clientThread.invokeLater(panel::doHighlighting);
		}
	}

	@Subscribe(priority = -1)
	public void onPostMenuSort(PostMenuSort postMenuSort)
	{
		// The menu is not rebuilt when it is open, so don't swap or else it will
		// repeatedly swap entries
		if (client.isMenuOpen())
		{
			return;
		}

		if (panel.getCurrentSelectedSetup() != null && (config.groundItemMenuSwap() || config.groundItemMenuHighlight()))
		{
			MenuEntry[] clientEntries = client.getMenu().getMenuEntries();

			// We want to be sure to preserve menu entry order while only sorting the "Take" menu options
			int firstTakeIndex = IntStream.range(0, clientEntries.length)
								.filter(i -> clientEntries[i].getOption().equals("Take"))
								.findFirst().orElse(-1);

			if (firstTakeIndex == -1)
			{
				// no work to be done if no "Take" options are present
				return;
			}

			int lastTakeIndex = IntStream.range(firstTakeIndex, clientEntries.length)
								.map(i -> firstTakeIndex + (clientEntries.length - 1 - i))
								.filter(i -> clientEntries[i].getOption().equals("Take"))
								.findFirst().orElse(-1);

			List<MenuEntry> takeEntriesInSetup = new ArrayList<>();
			List<MenuEntry> takeEntriesNotInSetup = new ArrayList<>();

			// Bucket sort the "Take" entries
			String colorHex = ColorUtil.colorToHexCode(config.groundItemMenuHighlightColor());
			String replacementColorText = "<col=" + colorHex + ">";
			for (int i = firstTakeIndex; i < lastTakeIndex + 1; i++)
			{
				MenuEntry oldEntry = clientEntries[i];
				int itemID = oldEntry.getIdentifier();
				// If the item is a graceful or weight reducing equipment, we must canonicalize.
				// For items on the ground, it will be the inventory version of the item, so the inverse of worn items must be used.
				boolean canonicalize = InventorySetupsVariationMapping.INVERTED_WORN_ITEMS.containsKey(itemID);
				boolean setupContainsItem = setupContainsItem(panel.getCurrentSelectedSetup(), itemID, true, canonicalize);
				if (setupContainsItem)
				{
					if (config.groundItemMenuHighlight())
					{
						// Change the color of the item to indicate it's in the setup.
						final String newTarget = oldEntry.getTarget().replaceFirst("<col=[a-fA-F0-9]+>", replacementColorText);
						oldEntry.setTarget(newTarget);
					}
					takeEntriesInSetup.add(oldEntry);
				}
				else
				{
					takeEntriesNotInSetup.add(oldEntry);
				}
			}

			if (config.groundItemMenuSwap())
			{
				// Based on the swap priority config, figure out the starting indexes for the entries in and not in the setup
				boolean putNonSetupEntriesOnTop = config.groundItemMenuSwapPriority() == InventorySetupsGroundItemMenuSwapPriority.OUT;
				int entriesInSetupStartIndex = firstTakeIndex + takeEntriesNotInSetup.size();
				int entriesNotInSetupStartIndex = firstTakeIndex;
				if (putNonSetupEntriesOnTop)
				{
					entriesInSetupStartIndex = firstTakeIndex;
					entriesNotInSetupStartIndex = firstTakeIndex + takeEntriesInSetup.size();
				}

				for (int i = 0; i < takeEntriesInSetup.size(); i++)
				{
					clientEntries[entriesInSetupStartIndex + i] = takeEntriesInSetup.get(i);
				}

				for (int i = 0; i < takeEntriesNotInSetup.size(); i++)
				{
					clientEntries[entriesNotInSetupStartIndex + i] = takeEntriesNotInSetup.get(i);
				}
			}

			client.getMenu().setMenuEntries(clientEntries);

		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{

		Widget bankWidget = client.getWidget(InterfaceID.Bankmain.TITLE);
		if (bankWidget == null || bankWidget.isHidden())
		{
			return;
		}

		// Adds menu entries to show worn items button
		if (event.getOption().equals("Show worn items"))
		{
			createMenuEntriesForWornItems();
		}
		// If shift is held and item is right-clicked in the bank while a setup is active,
		// add item to additional filtered items
		else if (panel.getCurrentSelectedSetup() != null
				&& bankTagsService.getActiveLayout() == null // If there is an active layout, then the real item behind the fake layout item may be added. So just disallow this menu.
				&& event.getActionParam1() == InterfaceID.Bankmain.ITEMS
				&& client.isKeyPressed(KeyCode.KC_SHIFT)
				&& event.getOption().equals("Examine"))
		{
			createMenuEntryToAddAdditionalFilteredItem(event.getActionParam0());
		}
	}

	private void createMenuEntriesForWornItems()
	{
		List<InventorySetup> filteredSetups = panel.getFilteredInventorysetups();
		List<InventorySetup> setupsToShowOnWornItemsList;
		switch (config.showWornItemsFilter())
		{
			case BANK_FILTERED:
				setupsToShowOnWornItemsList = inventorySetups.stream()
						.filter(InventorySetup::isFilterBank)
						.collect(Collectors.toList());
				break;
			case FAVORITED:
				setupsToShowOnWornItemsList = inventorySetups.stream()
						.filter(InventorySetup::isFavorite)
						.collect(Collectors.toList());
				break;
			default:
				setupsToShowOnWornItemsList = filteredSetups;
				break;
		}

		// Section mode creates the section entries and sub menus
		if (config.sectionMode() && config.wornItemSelectionSubmenu())
		{

			List<InventorySetup> unassignedSetups = new ArrayList<>();
			HashMap<String, List<InventorySetup>> sectionsToDisplay = new HashMap<>();

			// If the sorting mode is default, then the order to appear on the worn items list
			// should be the order they appear in the section, which may not be the filtered order.
			if (config.sortingMode() == InventorySetupsSortingID.DEFAULT)
			{
				Set<String> setupsToShowOnWornItemsListCache = setupsToShowOnWornItemsList.stream()
						.map(InventorySetup::getName)
						.collect(Collectors.toSet());
				sections.forEach(section ->
				{
					List<String> setupsInSection =  section.getSetups();
					setupsInSection.forEach(setupName ->
					{
						if (setupsToShowOnWornItemsListCache.contains(setupName))
						{
							if (!sectionsToDisplay.containsKey(section.getName()))
							{
								sectionsToDisplay.put(section.getName(), new ArrayList<>());
							}
							final InventorySetup inventorySetup = cache.getInventorySetupNames().get(setupName);
							sectionsToDisplay.get(section.getName()).add(inventorySetup);
						}
					});
				});

				setupsToShowOnWornItemsList.forEach(setupToShow ->
				{
					Map<String, InventorySetupsSection> sectionsOfSetup = cache.getSetupSectionsMap().get(setupToShow.getName());
					if (sectionsOfSetup.isEmpty())
					{
						unassignedSetups.add(setupToShow);
					}
				});
			}
			else
			{
				setupsToShowOnWornItemsList.forEach(setupToShow ->
				{
					Map<String, InventorySetupsSection> sectionsOfSetup = cache.getSetupSectionsMap().get(setupToShow.getName());
					if (sectionsOfSetup.isEmpty())
					{
						unassignedSetups.add(setupToShow);
					}
					else
					{
						for (final InventorySetupsSection section : sectionsOfSetup.values())
						{
							if (!sectionsToDisplay.containsKey(section.getName()))
							{
								sectionsToDisplay.put(section.getName(), new ArrayList<>());
							}
							sectionsToDisplay.get(section.getName()).add(setupToShow);
						}
					}
				});
			}

			sections.forEach(section ->
			{

				if (!sectionsToDisplay.containsKey(section.getName()))
				{
					return;
				}

				Color sectionMenuTargetColor = section.getDisplayColor() == null ? JagexColors.MENU_TARGET : section.getDisplayColor();
				createSectionSubMenuOnWornItems(sectionsToDisplay.get(section.getName()), section.getName(), sectionMenuTargetColor);

			});

			if (!unassignedSetups.isEmpty())
			{
				createSectionSubMenuOnWornItems(unassignedSetups, UNASSIGNED_SECTION_SETUP_MENU_ENTRY, JagexColors.MENU_TARGET);
			}

		}
		else
		{
			for (int i = 0; i < setupsToShowOnWornItemsList.size(); i++)
			{
				final InventorySetup setupToShow = setupsToShowOnWornItemsList.get(setupsToShowOnWornItemsList.size() - 1 - i);
				Color menuTargetColor = setupToShow.getDisplayColor() == null ? JagexColors.MENU_TARGET : setupToShow.getDisplayColor();
				client.getMenu()
						.createMenuEntry(-1)
						.setOption(OPEN_SETUP_MENU_ENTRY)
						.setTarget(ColorUtil.prependColorTag(setupToShow.getName(), menuTargetColor))
						.setType(MenuAction.RUNELITE)
						.onClick(e -> panel.setCurrentInventorySetup(setupToShow, true));
			}
		}

		if (panel.getCurrentSelectedSetup() != null)
		{
			if (panel.getCurrentSelectedSetup().isFilterBank())
			{
				if (this.canUseLayouts && config.useLayouts())
				{
					// Add Auto layouts
					createAutoLayoutSubMenuOnWornItems();
				}

				// add menu entry to re-filter/layout setup
				client.getMenu()
						.createMenuEntry(-1)
						.setOption("Filter Bank")
						.setType(MenuAction.RUNELITE)
						.onClick(e -> doBankSearch());
			}

			// add menu entry to close setup
			client.getMenu()
					.createMenuEntry(-1)
					.setOption(RETURN_TO_OVERVIEW_ENTRY)
					.setType(MenuAction.RUNELITE)
					.onClick(e -> panel.returnToOverviewPanel(false));
		}
	}

	private void createAutoLayoutSubMenuOnWornItems()
	{
		Menu parentMenu = client.getMenu()
				.createMenuEntry(-1)
				.setOption("Auto Layout")
				.setType(MenuAction.RUNELITE)
				.createSubMenu();
		parentMenu.createMenuEntry(0)
				.setOption(AUTO_LAYOUT_PRESET_ENTRY)
				.setType(MenuAction.RUNELITE)
				.onClick(e -> previewNewLayout(panel.getCurrentSelectedSetup(), InventorySetupLayoutType.PRESET));
		parentMenu.createMenuEntry(0)
				.setOption(AUTO_LAYOUT_ZIGZAG_ENTRY)
				.setType(MenuAction.RUNELITE)
				.onClick(e -> previewNewLayout(panel.getCurrentSelectedSetup(), InventorySetupLayoutType.ZIGZAG));

	}

	private void previewNewLayout(final InventorySetup setup, final InventorySetupLayoutType type)
	{
		clientThread.invoke(() ->
		{
			final Layout old = layoutUtilities.getSetupLayout(setup);

			// Don't add any items to the tag yet. We just want to display a layout
			// We can add tags after if the user likes the layout.
			// This stops the case that somebody removed a tag from the inventory setup
			// And this layout won't accidentally bring it back if they decide not to use it.
			final Layout new_ = layoutUtilities.createSetupLayout(setup, type, false);

			// Temporarily save the new layout to open the tag.
			layoutManager.saveLayout(new_);
			bankTagsService.openBankTag(new_.getTag(), BankTagsService.OPTION_HIDE_TAG_NAME);
			resetBankScrollBar();

			// Save the old layout again in case the user hits escape on the menu.
			// The bank will still show the temporary new layout.
			layoutManager.saveLayout(old);

			chatboxPanelManager.openTextMenuInput("Tab laid out using the '" + type.getName() + "' layout.")
					.option("1. Keep", () ->
					{
						// Tag all the items in the setup now since the user likes it.
						clientThread.invoke(() ->
						{
							// Need this to be in a client thread invoke in case the user types 1 instead.
							layoutUtilities.createSetupLayout(setup, type, true);
							layoutManager.saveLayout(new_);
						});

					})
					.option("2. Undo", () ->
					{
						// The old layout is already saved, no need to do anything.
					})
					// If this is not done with invokeLater, I get crashing...
					.onClose(() -> clientThread.invokeLater(() -> bankTagsService.openBankTag(old.getTag(), BANK_TAG_OPTIONS)))
					.build();
		});
	}

	private void createSectionSubMenuOnWornItems(Collection<InventorySetup> setups, String name, Color color)
	{
		Menu subMenu = client.getMenu()
			.createMenuEntry(1)
			.setOption(OPEN_SECTION_MENU_ENTRY)
			.setTarget(ColorUtil.prependColorTag(name, color))
			.setType(MenuAction.RUNELITE)
			.createSubMenu();

		for (final InventorySetup inventorySetup : setups)
		{
			try
			{
				createSectionSubMenuEntryOnWornItems(inventorySetup, subMenu);
			}
			catch (IllegalStateException ignored)
			{
				// This can be thrown if the menu exceeds the menu entry limit,
				// at which point we can just move on to the next section.
				// Each submenu has its own internal limit, so hitting this once
				// does not mean we cannot insert more menu entries elsewhere.
				break;
			}
		}
	}

	private void createSectionSubMenuEntryOnWornItems(InventorySetup setup, Menu parentMenu)
	{
		Color setupMenuTargetColor = setup.getDisplayColor() == null ? JagexColors.MENU_TARGET : setup.getDisplayColor();

		parentMenu.createMenuEntry(0)
				.setOption(OPEN_SETUP_MENU_ENTRY)
				.setTarget(ColorUtil.prependColorTag(setup.getName(), setupMenuTargetColor))
				.setType(MenuAction.RUNELITE)
				.onClick(e ->
				{
					resetBankSearch();
					panel.setCurrentInventorySetup(setup, true);
				});
	}

	private void createMenuEntryToAddAdditionalFilteredItem(int inventoryIndex)
	{
		client.getMenu()
			.createMenuEntry(-1)
			.setOption(ADD_TO_ADDITIONAL_ENTRY)
			.onClick(e ->
			{
				final Item newItem = retrieveItemFromBankMenuEntry(inventoryIndex);
				if (newItem == null)
				{
					return;
				}

				final Map<Integer, InventorySetupsItem> additionalFilteredItems =
						panel.getCurrentSelectedSetup().getAdditionalFilteredItems();

				// Item already exists, don't add it again
				if (!additionalFilteredItemsHasItem(newItem.getId(), additionalFilteredItems))
				{
					addAdditionalFilteredItem(newItem.getId(), panel.getCurrentSelectedSetup(), additionalFilteredItems);
				}
			});
	}

	// Retrieve an item from a selected menu entry in the bank
	private Item retrieveItemFromBankMenuEntry(int inventoryIndex)
	{
		// This should never be hit, as the option only appears when the panel isn't null
		if (panel.getCurrentSelectedSetup() == null)
		{
			return null;
		}

		ItemContainer bankContainer = client.getItemContainer(InventoryID.BANK);
		if (bankContainer == null)
		{
			return null;
		}
		Item[] items = bankContainer.getItems();
		if (inventoryIndex < 0 || inventoryIndex >= items.length)
		{
			return null;
		}
		return bankContainer.getItems()[inventoryIndex];
	}

	@Subscribe
	private void onWidgetClosed(WidgetClosed event)
	{
		if (event.getGroupId() == InterfaceID.BANKMAIN)
		{
			clientThread.invokeLater(this::handleRegistrationOfHotkeys);

			if (isInventorySetupTagOpen())
			{
				// Close the bank tag for those who use manual bank filter
				clientThread.invokeLater(() -> bankTagsService.closeBankTag());
			}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == InterfaceID.BANKMAIN)
		{
			clientThread.invokeLater(this::handleRegistrationOfHotkeys);
		}
	}

	public void setConfigValue(final String key, boolean on)
	{
		configManager.setConfiguration(CONFIG_GROUP, key, on);
	}

	public void setConfigValue(final String key, final String value)
	{
		configManager.setConfiguration(CONFIG_GROUP, key, value);
	}

	public boolean getBooleanConfigValue(final String key)
	{
		try
		{
			String value = configManager.getConfiguration(CONFIG_GROUP, key);
			return Boolean.parseBoolean(value);
		}
		catch (Exception e)
		{
			log.error("Couldn't retrieve config value with key " + key, e);
			return false;
		}
	}

	public void toggleAlphabeticalMode(InventorySetupsSortingID mode)
	{
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_SORTING_MODE, mode);
	}


	public void addInventorySetup()
	{
		final String msg = "Enter the name of this setup (max " + MAX_SETUP_NAME_LENGTH + " chars).";
		String name = JOptionPane.showInputDialog(panel,
			msg,
			"Add New Setup",
			JOptionPane.PLAIN_MESSAGE);

		// cancel button was clicked
		if (name == null || name.isEmpty())
		{
			return;
		}

		if (name.length() > MAX_SETUP_NAME_LENGTH)
		{
			name = name.substring(0, MAX_SETUP_NAME_LENGTH);
		}

		if (cache.getInventorySetupNames().containsKey(name))
		{
			JOptionPane.showMessageDialog(panel,
					"A setup with the name " + name + " already exists",
					"Setup Already Exists",
					JOptionPane.ERROR_MESSAGE);
			return;
		}

		final String newName = name;

		clientThread.invokeLater(() ->
		{
			List<InventorySetupsItem> inv = getNormalizedContainer(InventoryID.INV);
			List<InventorySetupsItem> eqp = getNormalizedContainer(InventoryID.WORN);

			List<InventorySetupsItem> runePouchData = ammoHandler.getRunePouchDataIfInContainer(inv);
			List<InventorySetupsItem> boltPouchData = ammoHandler.getBoltPouchDataIfInContainer(inv);
			List<InventorySetupsItem> quiverData = ammoHandler.getQuiverDataIfInSetup(inv, eqp);

			int spellbook = getCurrentSpellbook();

			final InventorySetup invSetup = new InventorySetup(inv, eqp, runePouchData, boltPouchData, quiverData,
				new HashMap<>(),
				newName,
				"",
				config.highlightColor(),
				config.highlightDifference(),
				config.enableDisplayColor() ? config.displayColor() : null,
				config.bankFilter(),
				config.highlightUnorderedDifference(),
				spellbook, false, -1);

			cache.addSetup(invSetup);
			inventorySetups.add(invSetup);
			dataManager.updateConfig(true, false);

			Layout setupLayout = layoutUtilities.createSetupLayout(invSetup);
			layoutManager.saveLayout(setupLayout);
			tagManager.setHidden(setupLayout.getTag(), true);

			SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(false));

		});
	}

	public void addSection()
	{
		final String msg = "Enter the name of this section (max " + MAX_SETUP_NAME_LENGTH + " chars).";
		String name = JOptionPane.showInputDialog(panel,
				msg,
				"Add New Section",
				JOptionPane.PLAIN_MESSAGE);

		// cancel button was clicked
		if (name == null || name.isEmpty())
		{
			return;
		}

		if (name.length() > MAX_SETUP_NAME_LENGTH)
		{
			name = name.substring(0, MAX_SETUP_NAME_LENGTH);
		}

		if (cache.getSectionNames().containsKey(name))
		{
			JOptionPane.showMessageDialog(panel,
					"A section with the name " + name + " already exists",
					"Section Already Exists",
					JOptionPane.ERROR_MESSAGE);
			return;
		}

		final String newName = name;
		InventorySetupsSection newSection = new InventorySetupsSection(newName);
		cache.addSection(newSection);
		sections.add(newSection);

		dataManager.updateConfig(false, true);
		SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(false));

	}

	public void addSetupToSections(final InventorySetup setup, final List<String> sectionNames)
	{
		for (final String sectionName : sectionNames)
		{
			// Don't add the setup if it's already part of this section
			if (!cache.getSectionSetupsMap().get(sectionName).containsKey(setup.getName()))
			{
				final InventorySetupsSection section = cache.getSectionNames().get(sectionName);
				cache.addSetupToSection(section, setup);
				section.getSetups().add(setup.getName());
			}
		}

		dataManager.updateConfig(false, true);
		panel.redrawOverviewPanel(false);
	}

	public void addSetupsToSection(final InventorySetupsSection section, final List<String> setupNames)
	{
		for (final String setupName : setupNames)
		{
			// Don't add the setup if it's already part of this section
			if (!cache.getSectionSetupsMap().get(section.getName()).containsKey(setupName))
			{
				final InventorySetup setup = cache.getInventorySetupNames().get(setupName);
				cache.addSetupToSection(section, setup);
				section.getSetups().add(setupName);
			}
		}
		dataManager.updateConfig(false, true);
		panel.redrawOverviewPanel(false);
	}

	public void moveSetup(int invIndex, int newPosition)
	{
		// Setup is already in the specified position or is out of position
		if (isNewPositionInvalid(invIndex, newPosition, inventorySetups.size()))
		{
			return;
		}
		InventorySetup setup = inventorySetups.remove(invIndex);
		inventorySetups.add(newPosition, setup);
		panel.redrawOverviewPanel(false);
		dataManager.updateConfig(true, false);
	}

	public void moveSection(int sectionIndex, int newPosition)
	{
		// Setup is already in the specified position or is out of position
		if (isNewPositionInvalid(sectionIndex, newPosition, sections.size()))
		{
			return;
		}
		InventorySetupsSection section = sections.remove(sectionIndex);
		sections.add(newPosition, section);
		panel.redrawOverviewPanel(false);
		dataManager.updateConfig(false, true);
	}

	public void moveSetupWithinSection(final InventorySetupsSection section, int invIndex, int newPosition)
	{
		// Setup is already in the specified position or is out of position
		if (isNewPositionInvalid(invIndex, newPosition, section.getSetups().size()))
		{
			return;
		}
		final String setupName = section.getSetups().remove(invIndex);
		section.getSetups().add(newPosition, setupName);
		panel.redrawOverviewPanel(false);
		dataManager.updateConfig(false, true);
	}

	private boolean isNewPositionInvalid(int oldPosition, int newPosition, int size)
	{
		return oldPosition == newPosition || newPosition < 0 || newPosition >= size;
	}

	public List<InventorySetup> filterSetups(String textToFilter)
	{
		return inventorySetups.stream()
			.filter(inventorySetup -> shouldDisplaySetup(inventorySetup, textToFilter.trim().toLowerCase()))
			.collect(Collectors.toList());
	}

	private static boolean shouldDisplaySetup(InventorySetup inventorySetup, String trimmedTextToFilterLower)
	{
		if (trimmedTextToFilterLower.startsWith(ITEM_SEARCH_TAG) && trimmedTextToFilterLower.length() > ITEM_SEARCH_TAG.length())
		{
			String itemName = trimmedTextToFilterLower.substring(ITEM_SEARCH_TAG.length()).trim();
			// Find setups containing the given item name
			return containerContainsItemByName(inventorySetup.getInventory(), itemName) || containerContainsItemByName(inventorySetup.getEquipment(), itemName)
				|| containerContainsItemByName(inventorySetup.getRune_pouch(), itemName) || containerContainsItemByName(inventorySetup.getAdditionalFilteredItems().values(), itemName)
				|| containerContainsItemByName(inventorySetup.getBoltPouch(), itemName);
		}
		else if (trimmedTextToFilterLower.startsWith(NOTES_SEARCH_TAG) && trimmedTextToFilterLower.length() > NOTES_SEARCH_TAG.length())
		{
			String noteText = trimmedTextToFilterLower.substring(NOTES_SEARCH_TAG.length()).trim();
			return inventorySetup.getNotes().toLowerCase().contains(noteText);
		}
		// Find setups containing the given setup name (default behaviour)
		return inventorySetup.getName().toLowerCase().contains(trimmedTextToFilterLower);
	}

	private static boolean containerContainsItemByName(Collection<InventorySetupsItem> itemsInContainer, String textToFilterLower)
	{
		if (itemsInContainer == null)
		{
			return false;
		}
		return itemsInContainer.stream()
			.map(item -> item.getName().toLowerCase())
			.anyMatch(itemName -> itemName.contains(textToFilterLower));
	}

	public void doBankSearch()
	{
		clientThread.invoke(() ->
		{
			final InventorySetup currentSelectedSetup = panel.getCurrentSelectedSetup();

			if (currentSelectedSetup == null || !currentSelectedSetup.isFilterBank() || !isFilteringAllowed())
			{
				return;
			}

			if (client.getWidget(InterfaceID.Bankmain.UNIVERSE) == null)
			{
				return;
			}

			final String tagName = InventorySetupLayoutUtilities.getTagNameForLayout(currentSelectedSetup.getName());
			if (!config.useLayouts())
			{
				bankTagsService.openBankTag(tagName, BANK_TAG_OPTIONS | BankTagsService.OPTION_NO_LAYOUT);
			}
			else
			{
				bankTagsService.openBankTag(tagName, BANK_TAG_OPTIONS);
				resetBankScrollBar();
			}

		});
	}

	public void resetBankScrollBar()
	{
		// Reset the scroll bar position to 0
		Widget widget = client.getWidget(InterfaceID.Bankmain.SCROLLBAR);
		if (widget != null)
		{
			widget.setScrollY(0);
			client.setVarcIntValue(VarClientID.BANK_SCROLLPOS, 0);
		}
	}

	private void triggerBankSearchFromHotKey()
	{
		// you must wait at least one game tick otherwise
		// the bank filter will work but then go back to the previous tab.
		// For some reason this can still happen but it is very rare,
		// and only when the user clicks a tab and the hot key extremely shortly after.
		int gameTick = client.getTickCount();
		clientThread.invokeLater(() ->
		{
			int gameTick2 = client.getTickCount();
			if (gameTick2 <= gameTick)
			{
				return false;
			}

			doBankSearch();
			return true;
		});
	}


	private boolean additionalFilteredItemsHasItem(int itemId, final Map<Integer, InventorySetupsItem> additionalFilteredItems)
	{
		return additionalFilteredItemsHasItem(itemId, additionalFilteredItems, true, true);
	}

	private boolean additionalFilteredItemsHasItem(int itemId, final Map<Integer, InventorySetupsItem> additionalFilteredItems, boolean allowFuzzy, boolean canonicalize)
	{
		for (final Integer additionalItemKey : additionalFilteredItems.keySet())
		{
			boolean isFuzzy = additionalFilteredItems.get(additionalItemKey).isFuzzy();
			int addItemId = additionalFilteredItems.get(additionalItemKey).getId();

			addItemId = getProcessedID(isFuzzy, allowFuzzy, canonicalize, addItemId);
			int finalItemId = getProcessedID(isFuzzy, allowFuzzy, canonicalize, itemId);
			if (addItemId == finalItemId)
			{
				return true;
			}
		}
		return false;
	}

	private void addAdditionalFilteredItem(int itemId, final InventorySetup setup, final Map<Integer, InventorySetupsItem> additionalFilteredItems)
	{
		// un-noted, un-placeholdered ID
		final int processedItemId = itemManager.canonicalize(itemId);

		clientThread.invokeLater(() ->
		{
			final String name = itemManager.getItemComposition(processedItemId).getName();
			InventorySetupsStackCompareID stackCompareType = panel.isStackCompareForSlotAllowed(InventorySetupsSlotID.ADDITIONAL_ITEMS, 0) ? config.stackCompareType() : InventorySetupsStackCompareID.None;
			final InventorySetupsItem setupItem = new InventorySetupsItem(processedItemId, name, 1, config.fuzzy(), stackCompareType);

			additionalFilteredItems.put(processedItemId, setupItem);
			layoutUtilities.recalculateLayout(setup);
			dataManager.updateConfig(true, false);
			panel.refreshCurrentSetup();
		});
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		// Spellbook changed
		if (event.getVarpId() == 439 && client.getGameState() == GameState.LOGGED_IN)
		{
			// must be invoked later otherwise causes freezing.
			clientThread.invokeLater(panel::doHighlighting);
			return;
		}

		Widget bankContainer = client.getWidget(InterfaceID.Bankmain.ITEMS);
		boolean bankIsOpen = bankContainer != null && !bankContainer.isHidden();
		// Avoid extra highlighting calls by deferring the highlighting to GameTick after a bunch of varbit changes come
		// If the bank is closed, then onItemContainerChanged will handle the highlighting
		if (bankIsOpen &&
			(RUNE_POUCH_RUNE_VARBITS.contains(event.getVarbitId()) || RUNE_POUCH_AMOUNT_VARBITS.contains(event.getVarbitId())))
		{
			shouldTriggerInventoryHighlightOnGameTick = true;
			return;
		}
	}

	public void resetBankSearch()
	{
		// We only reset the bank search if the active tag is an inventory setup
		// This stops it from closing an open bank tag tab or other plugins opening bank tags.
		if (isInventorySetupTagOpen())
		{
			clientThread.invoke(() -> bankTagsService.closeBankTag());
		}
	}

	public boolean isInventorySetupTagOpen()
	{
		return bankTagsService.getActiveTag() != null && bankTagsService.getActiveTag().startsWith(LAYOUT_PREFIX_MARKER);
	}

	@Subscribe(priority = -1) // Make sure this runs AFTER bank tags plugin.
	public void onScriptPreFired(ScriptPreFired event)
	{
		if (event.getScriptId() == ScriptID.BANKMAIN_INIT)
		{
			// Do a bank search when the bank is opened
			// This will set the proper layout
			if (!config.manualBankFilter())
			{
				// Only do the filter if manual bank filter is not set.
				doBankSearch();
			}
		}
		else if (event.getScriptId() == ScriptID.BANKMAIN_FINISHBUILDING)
		{
			// Bankmain_build will reset the bank title to "The Bank of Gielinor". So apply our own title.
			// We should only do this if the active tag is an inventory setup tag
			if (panel.getCurrentSelectedSetup() != null && isInventorySetupTagOpen())
			{
				Widget bankTitle = client.getWidget(InterfaceID.Bankmain.TITLE);
				bankTitle.setText("Inventory Setup <col=ff0000>" + panel.getCurrentSelectedSetup().getName() + "</col>");
			}
		}
		else if (event.getScriptId() == ScriptID.BANKMAIN_SEARCH_TOGGLE)
		{
			// cancel the current filtering if the search button is clicked
			resetBankSearch();
		}
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged intChanged)
	{
		if (intChanged.getIndex() != VarClientID.MESLAYERMODE)
		{
			return;
		}
		boolean chatBoxInputOpened = client.getVarcIntValue(VarClientID.MESLAYERMODE) != InputType.NONE.getType();
		if (chatBoxInputOpened)
		{
			this.chatBoxInputIsOpen = true;
			clientThread.invokeLater(this::handleRegistrationOfHotkeys);
		}
		else if (this.chatBoxInputIsOpen)
		{

			this.chatBoxInputIsOpen = false;
			clientThread.invokeLater(this::handleRegistrationOfHotkeys);
		}
	}

	public void updateCurrentSetup(InventorySetup setup)
	{
		int confirm = JOptionPane.showConfirmDialog(panel,
			"Are you sure you want update this inventory setup?",
			"Warning", JOptionPane.OK_CANCEL_OPTION);

		// cancel button was clicked
		if (confirm != JOptionPane.YES_OPTION)
		{
			return;
		}

		// must be on client thread to get names
		clientThread.invokeLater(() ->
		{
			List<InventorySetupsItem> inv = getNormalizedContainer(InventoryID.INV);
			List<InventorySetupsItem> eqp = getNormalizedContainer(InventoryID.WORN);

			// copy over fuzzy attributes
			for (int i = 0; i < inv.size(); i++)
			{
				inv.get(i).setFuzzy(setup.getInventory().get(i).isFuzzy());
				inv.get(i).setStackCompare(setup.getInventory().get(i).getStackCompare());
			}
			for (int i = 0; i < eqp.size(); i++)
			{
				eqp.get(i).setFuzzy(setup.getEquipment().get(i).isFuzzy());
				eqp.get(i).setStackCompare(setup.getEquipment().get(i).getStackCompare());
			}

			ammoHandler.updateSpecialContainersInSetup(setup, inv, eqp);

			setup.updateInventory(inv);
			setup.updateEquipment(eqp);
			setup.updateSpellbook(getCurrentSpellbook());

			// Regenerate the layout and tag.
			clientThread.invoke(() ->
			{
				String tagName = InventorySetupLayoutUtilities.getTagNameForLayout(setup.getName());
				tagManager.removeTag(tagName);
				layoutManager.removeLayout(tagName);

				Layout newLayout = layoutUtilities.createSetupLayout(setup);
				layoutManager.saveLayout(newLayout);
			});

			dataManager.updateConfig(true, false);
			panel.refreshCurrentSetup();
		});
	}

	private boolean updateAllInstancesInContainerSetupWithNewItem(final InventorySetup inventorySetup, List<InventorySetupsItem> containerToUpdate,
																final InventorySetupsItem oldItem, final InventorySetupsItem newItem, final InventorySetupsSlotID id)
	{
		boolean updated = false;
		for (int i = 0; i < containerToUpdate.size(); i++)
		{
			final InventorySetupsItem item = containerToUpdate.get(i);
			if (item.getId() == oldItem.getId())
			{
				ammoHandler.handleSpecialAmmo(inventorySetup, containerToUpdate.get(i), newItem);
				containerToUpdate.set(i, newItem);
				updated = true;
			}
		}
		return updated;
	}

	private void updateAllInstancesInSetupWithNewItem(final InventorySetupsItem oldItem, final InventorySetupsItem newItem)
	{
		if (oldItem.getId() == -1 || newItem.getId() == -1)
		{
			SwingUtilities.invokeLater(() ->
					JOptionPane.showMessageDialog(panel,
							"You cannot update empty slots or replace all slots with this item with an empty slot",
							"Cannot Update Setups",
							JOptionPane.ERROR_MESSAGE));

			return;
		}

		for (final InventorySetup inventorySetup : inventorySetups)
		{
			boolean invUpdated = updateAllInstancesInContainerSetupWithNewItem(inventorySetup, inventorySetup.getInventory(), oldItem, newItem, InventorySetupsSlotID.INVENTORY);
			boolean eqpUpdated = updateAllInstancesInContainerSetupWithNewItem(inventorySetup, inventorySetup.getEquipment(), oldItem, newItem, InventorySetupsSlotID.EQUIPMENT);
			if (invUpdated || eqpUpdated)
			{
				layoutUtilities.recalculateLayout(inventorySetup);
			}
		}
	}

	public void updateSlotFromContainer(final InventorySetupsSlot slot, boolean updateAllInstances)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			JOptionPane.showMessageDialog(panel,
				"You must be logged in to update from " + (slot.getSlotID().toString().toLowerCase() + "."),
				"Cannot Update Item",
				JOptionPane.ERROR_MESSAGE);
			return;
		}

		final InventorySetupsItem oldItem = getContainerFromSlot(slot).get(slot.getIndexInSlot());
		final boolean isFuzzy = oldItem.isFuzzy();
		final InventorySetupsStackCompareID stackCompareType = oldItem.getStackCompare();

		// must be invoked on client thread to get the name
		clientThread.invokeLater(() ->
		{
			final List<InventorySetupsItem> playerContainer = getNormalizedContainer(slot.getSlotID());
			final InventorySetupsItem newItem = playerContainer.get(slot.getIndexInSlot());
			newItem.setFuzzy(isFuzzy);
			newItem.setStackCompare(stackCompareType);

			if (updateAllInstances)
			{
				updateAllInstancesInSetupWithNewItem(oldItem, newItem);
			}
			else
			{
				List<InventorySetupsItem> containerToUpdate =  getContainerFromID(slot.getParentSetup(), slot.getSlotID());
				ammoHandler.handleSpecialAmmo(slot.getParentSetup(), oldItem, newItem);
				containerToUpdate.set(slot.getIndexInSlot(), newItem);
				layoutUtilities.recalculateLayout(slot.getParentSetup());
			}

			dataManager.updateConfig(true, false);
			panel.refreshCurrentSetup();
		});

	}

	public void updateSlotFromSearch(final InventorySetupsSlot slot, boolean allowStackable, boolean updateAllInstances)
	{

		if (client.getGameState() != GameState.LOGGED_IN)
		{
			JOptionPane.showMessageDialog(panel,
				"You must be logged in to search.",
				"Cannot Search for Item",
				JOptionPane.ERROR_MESSAGE);
			return;
		}

		itemSearch
			.tooltipText("Set slot to")
			.onItemSelected((itemId) ->
			{
				clientThread.invokeLater(() ->
				{
					int finalId = itemManager.canonicalize(itemId);

					if (slot.getSlotID() == InventorySetupsSlotID.ADDITIONAL_ITEMS)
					{
						final Map<Integer, InventorySetupsItem> additionalFilteredItems =
								panel.getCurrentSelectedSetup().getAdditionalFilteredItems();
						if (!additionalFilteredItemsHasItem(finalId, additionalFilteredItems))
						{
							removeAdditionalFilteredItem(slot, additionalFilteredItems);
							addAdditionalFilteredItem(finalId, slot.getParentSetup(), additionalFilteredItems);
						}
						return;
					}

					final String itemName = itemManager.getItemComposition(finalId).getName();
					final List<InventorySetupsItem> container = getContainerFromSlot(slot);
					final InventorySetupsItem itemToBeReplaced = container.get(slot.getIndexInSlot());
					final InventorySetupsItem newItem = new InventorySetupsItem(finalId, itemName, 1, itemToBeReplaced.isFuzzy(), itemToBeReplaced.getStackCompare());

					// NOTE: the itemSearch shows items from skill guides which can be selected, which may be highlighted

					// if the item is stackable, ask for a quantity
					if (allowStackable && itemManager.getItemComposition(finalId).isStackable())
					{
						searchInput = chatboxPanelManager.openTextInput("Enter amount")
							// only allow numbers and k, m, b (if 1 value is available)
							// stop once k, m, or b is seen
							.addCharValidator(this::validateCharFromItemSearch)
							.onDone((input) ->
							{
								int quantity = InventorySetupUtilities.parseTextInputAmount(input);
								newItem.setQuantity(quantity);
								updateSlotFromSearchHelper(slot, itemToBeReplaced, newItem, container, updateAllInstances);
							}).build();
					}
					else
					{
						updateSlotFromSearchHelper(slot, itemToBeReplaced, newItem, container, updateAllInstances);
					}
				});
			})
			.build();
	}

	private void updateSlotFromSearchHelper(final InventorySetupsSlot slot, final InventorySetupsItem itemToBeReplaced,
										final InventorySetupsItem newItem, final List<InventorySetupsItem> container,
										boolean updateAllInstances)
	{
		clientThread.invokeLater(() ->
		{
			if (updateAllInstances)
			{
				updateAllInstancesInSetupWithNewItem(itemToBeReplaced, newItem);
			}
			else
			{
				ammoHandler.handleSpecialAmmo(slot.getParentSetup(), itemToBeReplaced, newItem);
				container.set(slot.getIndexInSlot(), newItem);
				layoutUtilities.recalculateLayout(slot.getParentSetup());
			}

			SwingUtilities.invokeLater(() ->
			{
				dataManager.updateConfig(true, false);
				panel.refreshCurrentSetup();
			});
		});
	}

	private boolean validateCharFromItemSearch(int arg)
	{
		// allow more numbers to be put in if a letter hasn't been detected
		boolean stillInputtingNumbers = arg >= '0' && arg <= '9' &&
			!searchInput.getValue().toLowerCase().contains("k") &&
			!searchInput.getValue().toLowerCase().contains("m") &&
			!searchInput.getValue().toLowerCase().contains("b");

		// if a letter is input, check if there isn't one already and the length is not 0
		boolean letterIsInput = (arg == 'b' || arg == 'B' ||
				arg == 'k' || arg == 'K' ||
				arg == 'm' || arg == 'M') &&
				!searchInput.getValue().isEmpty() &&
				!searchInput.getValue().toLowerCase().contains("k") &&
				!searchInput.getValue().toLowerCase().contains("m") &&
				!searchInput.getValue().toLowerCase().contains("b");

		return stillInputtingNumbers || letterIsInput;
	}

	public void updateInventorySetupIcon(final InventorySetup setup)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			JOptionPane.showMessageDialog(panel,
				"You must be logged in to search.",
				"Cannot Search for Item",
				JOptionPane.ERROR_MESSAGE);
			return;
		}

		itemSearch
			.tooltipText("Set slot to")
			.onItemSelected((itemId) ->
			{
				int finalId = itemManager.canonicalize(itemId);
				setup.setIconID(finalId);
				dataManager.updateConfig(true, false);
				SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(false));
			}).build();
	}

	public void removeItemFromSlot(final InventorySetupsSlot slot)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			JOptionPane.showMessageDialog(panel,
				"You must be logged in to remove item from the slot.",
				"Cannot Remove Item",
				JOptionPane.ERROR_MESSAGE);
			return;
		}

		// must be invoked on client thread to get the name
		clientThread.invokeLater(() ->
		{

			if (slot.getSlotID() == InventorySetupsSlotID.ADDITIONAL_ITEMS)
			{
				removeAdditionalFilteredItem(slot, panel.getCurrentSelectedSetup().getAdditionalFilteredItems());
				layoutUtilities.recalculateLayout(panel.getCurrentSelectedSetup());
				dataManager.updateConfig(true, false);
				panel.refreshCurrentSetup();
				return;
			}

			final List<InventorySetupsItem> container = getContainerFromSlot(slot);

			// update special containers
			final InventorySetupsItem itemToBeReplaced = container.get(slot.getIndexInSlot());
			final InventorySetupsItem dummyItem = new InventorySetupsItem(-1, "", 0, itemToBeReplaced.isFuzzy(), itemToBeReplaced.getStackCompare());
			ammoHandler.handleSpecialAmmo(slot.getParentSetup(), itemToBeReplaced, dummyItem);

			container.set(slot.getIndexInSlot(), dummyItem);

			// Update the layout
			if (itemToBeReplaced.getId() != -1)
			{
				layoutUtilities.recalculateLayout(slot.getParentSetup());
			}

			dataManager.updateConfig(true, false);
			panel.refreshCurrentSetup();
		});
	}

	public void toggleFuzzyOnSlot(final InventorySetupsSlot slot)
	{
		if (panel.getCurrentSelectedSetup() == null)
		{
			return;
		}

		InventorySetupsItem item = null;

		if (slot.getSlotID() == InventorySetupsSlotID.ADDITIONAL_ITEMS)
		{
			// Empty slot was selected to be toggled, don't do anything
			if (slot.getIndexInSlot() >= slot.getParentSetup().getAdditionalFilteredItems().size())
			{
				return;
			}

			final Map<Integer, InventorySetupsItem> additionalFilteredItems = slot.getParentSetup().getAdditionalFilteredItems();
			final int slotID = slot.getIndexInSlot();
			int j = 0;
			Integer keyToMakeFuzzy = null;
			for (final Integer key : additionalFilteredItems.keySet())
			{
				if (slotID == j)
				{
					keyToMakeFuzzy = key;
					break;
				}
				j++;
			}
			item = additionalFilteredItems.get(keyToMakeFuzzy);
		}
		else
		{
			final List<InventorySetupsItem> container = getContainerFromSlot(slot);
			item = container.get(slot.getIndexInSlot());
		}
		item.toggleIsFuzzy();
		final int itemId = item.getId();
		clientThread.invoke(() ->
		{
			if (itemId == -1)
			{
				return;
			}
			layoutUtilities.recalculateLayout(slot.getParentSetup());
		});

		dataManager.updateConfig(true, false);
		panel.refreshCurrentSetup();
	}

	public void setStackCompareOnSlot(final InventorySetupsSlot slot, final InventorySetupsStackCompareID newStackCompare)
	{
		if (panel.getCurrentSelectedSetup() == null)
		{
			return;
		}

		final List<InventorySetupsItem> container = getContainerFromSlot(slot);
		container.get(slot.getIndexInSlot()).setStackCompare(newStackCompare);

		dataManager.updateConfig(true, false);
		panel.refreshCurrentSetup();
	}

	private void removeAdditionalFilteredItem(final InventorySetupsSlot slot, final Map<Integer, InventorySetupsItem> additionalFilteredItems)
	{

		assert panel.getCurrentSelectedSetup() != null : "Current setup is null";

		final int slotID = slot.getIndexInSlot();

		// Empty slot was selected to be removed, don't do anything
		if (slotID >= additionalFilteredItems.size())
		{
			return;
		}

		int j = 0;
		Integer keyToDelete = null;
		for (final Integer key : additionalFilteredItems.keySet())
		{
			if (slotID == j)
			{
				keyToDelete = key;
				break;
			}
			j++;
		}

		additionalFilteredItems.remove(keyToDelete);
		// None of the data functions are called here because the callee does it.
		// If an item is swapped (removed + added) this would result in a double data process
		// Which isn't bad, just a minor optimization

	}

	public void updateSpellbookInSetup(int newSpellbook)
	{
		assert panel.getCurrentSelectedSetup() != null : "Setup is null";
		assert newSpellbook >= 0 && newSpellbook < 5 : "New spellbook out of range";

		clientThread.invokeLater(() ->
		{
			panel.getCurrentSelectedSetup().updateSpellbook(newSpellbook);
			dataManager.updateConfig(true, false);
			panel.refreshCurrentSetup();
		});

	}

	public void updateNotesInSetup(final InventorySetup setup, final String text)
	{
		clientThread.invokeLater(() ->
		{
			setup.updateNotes(text);
			dataManager.updateConfig(true, false);
		});
	}

	public void removeInventorySetup(final InventorySetup setup)
	{
		if (isDeletionConfirmed("Are you sure you want to permanently delete this inventory setup?", "Warning"))
		{

			// Remove the setup from any sections which have it
			for (final InventorySetupsSection section : sections)
			{
				if (cache.getSectionSetupsMap().get(section.getName()).containsKey(setup.getName()))
				{
					section.getSetups().remove(setup.getName());
				}
			}
			cache.removeSetup(setup);
			inventorySetups.remove(setup);

			// Remove the layout and tag
			clientThread.invoke(() ->
			{
				String tagName = InventorySetupLayoutUtilities.getTagNameForLayout(setup.getName());
				tagManager.removeTag(tagName);
				layoutManager.removeLayout(tagName);
			});

			panel.redrawOverviewPanel(false);
			dataManager.updateConfig(true, true);
		}
	}

	public void removeSection(final InventorySetupsSection section)
	{
		if (isDeletionConfirmed("Are you sure you want to permanently delete this section? This will not delete the setups in this section.", "Warning"))
		{
			cache.removeSection(section);
			sections.remove(section);
			panel.redrawOverviewPanel(false);
			dataManager.updateConfig(false, true);
		}
	}

	public void removeInventorySetupFromSection(final InventorySetup setup, final InventorySetupsSection section)
	{
		// No confirmation needed
		cache.removeSetupFromSection(section, setup);
		section.getSetups().remove(setup.getName());

		panel.redrawOverviewPanel(false);
		dataManager.updateConfig(false, true);
	}

	private boolean isDeletionConfirmed(final String message, final String title)
	{
		int confirm = JOptionPane.showConfirmDialog(panel,
				message, title, JOptionPane.OK_CANCEL_OPTION);

		return confirm == JOptionPane.YES_OPTION;
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged e)
	{
		switchProfile();
	}

	private void switchProfile()
	{
		// config will have changed to local file
		clientThread.invokeLater(() ->
		{
			dataManager.loadConfig();
			// We may need to display the warning for this profile so reset it.
			panel.setHasDisplayedLayoutWarning(false);
			SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(true));
			return true;
		});
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{

		// check to see that the container is the equipment or inventory
		ItemContainer container = event.getItemContainer();

		if (container == client.getItemContainer(InventoryID.INV) || container == client.getItemContainer(InventoryID.WORN))
		{
			panel.doHighlighting();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		panel.doHighlighting();
	}

	// Must be called on client thread!
	public int getCurrentSpellbook()
	{
		assert client.isClientThread() : "getCurrentSpellbook must be called on Client Thread";
		return client.getVarbitValue(SPELLBOOK_VARBIT);
	}

	public List<InventorySetupsItem> getNormalizedContainer(final InventorySetupsSlotID id)
	{
		switch (id)
		{
			case INVENTORY:
				return getNormalizedContainer(InventoryID.INV);
			case EQUIPMENT:
				return getNormalizedContainer(InventoryID.WORN);
			default:
				return ammoHandler.getNormalizedSpecialContainer(id);
		}
	}

	public List<InventorySetupsItem> getNormalizedContainer(final int id)
	{
		assert id == InventoryID.INV || id == InventoryID.WORN : "invalid inventory ID";

		final ItemContainer container = client.getItemContainer(id);

		List<InventorySetupsItem> newContainer = new ArrayList<>();

		Item[] items = null;
		if (container != null)
		{
			items = container.getItems();
		}

		int size = id == InventoryID.INV ? NUM_INVENTORY_ITEMS : NUM_EQUIPMENT_ITEMS;

		for (int i = 0; i < size; i++)
		{

			final InventorySetupsStackCompareID stackCompareType = panel != null && panel.isStackCompareForSlotAllowed(InventorySetupsSlotID.fromInventoryID(id), i) ?
				config.stackCompareType() : InventorySetupsStackCompareID.None;
			if (items == null || i >= items.length || items[i].getId() == -1)
			{
				// add a "dummy" item to fill the normalized container to the right size
				// this will be useful to compare when no item is in a slot
				newContainer.add(InventorySetupsItem.getDummyItem());
			}
			else
			{
				final Item item = items[i];
				String itemName = "";

				// only the client thread can retrieve the name. Therefore, do not use names to compare!
				if (client.isClientThread())
				{
					itemName = itemManager.getItemComposition(item.getId()).getName();
				}
				newContainer.add(new InventorySetupsItem(item.getId(), itemName, item.getQuantity(), config.fuzzy(), stackCompareType));
			}
		}

		return newContainer;
	}

	public void exportSetup(final InventorySetup setup)
	{
		InventorySetupPortable portableSetup = InventorySetupPortable.convertFromInventorySetup(setup, layoutUtilities);
		final String json = gson.toJson(portableSetup);
		final StringSelection contents = new StringSelection(json);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);

		JOptionPane.showMessageDialog(panel,
			"Setup data was copied to clipboard.",
			"Export Setup Succeeded",
			JOptionPane.PLAIN_MESSAGE);
	}

	public void exportSection(final InventorySetupsSection section)
	{
		final String json = gson.toJson(section);
		final StringSelection contents = new StringSelection(json);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);

		JOptionPane.showMessageDialog(panel,
				"Section data was copied to clipboard.",
				"Export Setup Succeeded",
				JOptionPane.PLAIN_MESSAGE);
	}

	public <T> void massExport(List<T> data, final String type, final String file_prefix)
	{

		final JFileChooser fileChooser = new JFileChooser();
		fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		fileChooser.setDialogTitle("Choose Directory to Export " + type);
		fileChooser.setCurrentDirectory(new File(System.getProperty("user.home")));

		int returnValue = fileChooser.showSaveDialog(panel);
		if (returnValue == JFileChooser.APPROVE_OPTION)
		{
			final File directory = fileChooser.getSelectedFile();
			String login_name = client.getLocalPlayer() != null ? "_" + client.getLocalPlayer().getName() : "";
			login_name = login_name.replace(" ", "_");
			String newFileName = directory.getAbsolutePath() + "/" + file_prefix + login_name + ".json";
			newFileName = newFileName.replace("\\", "/");
			try
			{
				final String json = gson.toJson(data);
				FileOutputStream outputStream = new FileOutputStream(newFileName);
				outputStream.write(json.getBytes());
				outputStream.close();
			}
			catch (Exception e)
			{
				log.error("Couldn't mass export " + type, e);
				JOptionPane.showMessageDialog(panel,
						"Failed to export " + type + ".",
						"Mass Export Failed",
						JOptionPane.PLAIN_MESSAGE);
				return;
			}

			JLabel messageLabel = new JLabel("<html><center>All " + type + " were exported successfully to<br>" + newFileName);
			messageLabel.setHorizontalAlignment(SwingConstants.CENTER);
			JOptionPane.showMessageDialog(panel,
					messageLabel,
					"Mass Export Succeeded",
					JOptionPane.PLAIN_MESSAGE);
		}
	}

	public void importSetup()
	{
		try
		{
			final String setup = JOptionPane.showInputDialog(panel,
				"Enter setup data",
				"Import New Setup",
				JOptionPane.PLAIN_MESSAGE);

			// cancel button was clicked
			if (setup == null)
			{
				return;
			}

			Type type = new TypeToken<InventorySetupPortable>()
			{

			}.getType();

			final InventorySetupPortable newSetupPortable = gson.fromJson(setup, type);

			if (isSetupPortableInvalid(newSetupPortable))
			{
				throw new RuntimeException("Setup has invalid data.");
			}

			final InventorySetup newSetup = newSetupPortable.getSerializedSetup();

			if (isImportedSetupInvalid(newSetup))
			{
				throw new RuntimeException("Imported setup was missing required fields");
			}

			clientThread.invoke(() ->
			{
				preProcessNewSetup(newSetup);
				cache.addSetup(newSetup);
				inventorySetups.add(newSetup);
				// This will tag all the items in the setup for us, but don't use the layout.
				// Use what's stored in the import.
				Layout temp_layout_ = layoutUtilities.createSetupLayout(newSetup);
				Layout newLayout = new Layout(temp_layout_.getTag(), newSetupPortable.getLayout());
				layoutManager.saveLayout(newLayout);
				tagManager.setHidden(newLayout.getTag(), true);

				dataManager.updateConfig(true, false);
				SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(false));
			});
		}
		catch (Exception e)
		{
			log.error("Couldn't import setup", e);
			JOptionPane.showMessageDialog(panel,
				"Invalid setup data.",
				"Import Setup Failed",
				JOptionPane.ERROR_MESSAGE);
		}
	}

	public void massImportSetups()
	{
		try
		{
			final Path path = showMassImportFolderDialog();
			if (path == null)
			{
				return;
			}
			final String json = new String(Files.readAllBytes(path));

			Type typeSetups = new TypeToken<ArrayList<InventorySetupPortable>>()
			{

			}.getType();

			final ArrayList<InventorySetupPortable> newSetupPortables = gson.fromJson(json, typeSetups);

			final ArrayList<InventorySetup> newUnprocessedSetups = new ArrayList<>();
			final ArrayList<int[]> newUnprocessedLayouts = new ArrayList<>();
			for (final InventorySetupPortable portable : newSetupPortables)
			{
				if (isSetupPortableInvalid(portable))
				{
					throw new RuntimeException("Setup has invalid data.");
				}

				final InventorySetup setup = portable.getSerializedSetup();
				// Do some additional checking for required fields
				if (isImportedSetupInvalid(setup))
				{
					throw new RuntimeException("Mass import section file was missing required fields");
				}
				newUnprocessedSetups.add(setup);
				newUnprocessedLayouts.add(portable.getLayout());
			}

			clientThread.invoke(() ->
			{
				for (int i = 0; i < newUnprocessedSetups.size(); i++)
				{
					final InventorySetup inventorySetup = newUnprocessedSetups.get(i);
					preProcessNewSetup(inventorySetup);
					cache.addSetup(inventorySetup);
					inventorySetups.add(inventorySetup);

					// This will tag all the items in the setup for us, but don't use the layout.
					// Use what's stored in the import.
					Layout temp_layout_ = layoutUtilities.createSetupLayout(inventorySetup);
					Layout newLayout = new Layout(temp_layout_.getTag(), newUnprocessedLayouts.get(i));
					layoutManager.saveLayout(newLayout);
					tagManager.setHidden(newLayout.getTag(), true);
				}

				dataManager.updateConfig(true, false);
				SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(false));
			});

		}
		catch (Exception e)
		{
			log.error("Couldn't mass import setups", e);
			JOptionPane.showMessageDialog(panel,
					"Invalid setup data.",
					"Mass Import Setup Failed",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	private boolean isImportedSetupInvalid(final InventorySetup setup)
	{
		return setup.getName() == null || setup.getInventory() == null || setup.getEquipment() == null || setup.getAdditionalFilteredItems() == null;
	}

	private boolean isSetupPortableInvalid(final InventorySetupPortable portable)
	{
		return portable.getSetup() == null || portable.getLayout() == null;
	}

	public void importSection()
	{
		try
		{
			final String section = JOptionPane.showInputDialog(panel,
					"Enter section data",
					"Import New Section",
					JOptionPane.PLAIN_MESSAGE);

			// cancel button was clicked
			if (section == null)
			{
				return;
			}

			Type type = new TypeToken<InventorySetupsSection>()
			{

			}.getType();

			final InventorySetupsSection newSection = gson.fromJson(section, type);

			if (isImportedSectionValid(newSection))
			{
				throw new RuntimeException("Imported section was missing required fields");
			}

			preProcessNewSection(newSection);
			cache.addSection(newSection);
			sections.add(newSection);

			dataManager.updateConfig(false, true);
			SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(false));
		}
		catch (Exception e)
		{
			log.error("Couldn't import setup", e);
			JOptionPane.showMessageDialog(panel,
					"Invalid section data.",
					"Import section Failed",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	public void massImportSections()
	{
		try
		{
			final Path path = showMassImportFolderDialog();
			if (path == null)
			{
				return;
			}
			final String json = new String(Files.readAllBytes(path));

			Type typeSetups = new TypeToken<ArrayList<InventorySetupsSection>>()
			{

			}.getType();

			final ArrayList<InventorySetupsSection> newSections = gson.fromJson(json, typeSetups);

			// It's possible that the gson call succeeds but returns sections that have basically nothing
			// This can occur if trying to import an inventory setup file instead of a section file, since they share fields
			// Therefore, do some additional checking for required fields
			for (final InventorySetupsSection section : newSections)
			{
				if (isImportedSectionValid(section))
				{
					throw new RuntimeException("Mass import section file was missing required fields");
				}
			}

			for (final InventorySetupsSection section : newSections)
			{
				preProcessNewSection(section);
				cache.addSection(section);
				sections.add(section);
			}

			dataManager.updateConfig(false, true);
			SwingUtilities.invokeLater(() -> panel.redrawOverviewPanel(false));

		}
		catch (Exception e)
		{
			log.error("Couldn't mass import sections", e);
			JOptionPane.showMessageDialog(panel,
					"Invalid section data.",
					"Mass Import Section Failed",
					JOptionPane.ERROR_MESSAGE);
		}
	}

	private boolean isImportedSectionValid(final InventorySetupsSection section)
	{
		return section.getName() == null || section.getSetups() == null;
	}

	private void preProcessNewSection(final InventorySetupsSection newSection)
	{
		final String newName = InventorySetupUtilities.findNewName(newSection.getName(), cache.getSectionNames().keySet());
		newSection.setName(newName);

		// Remove any duplicates that came in when importing
		newSection.setSetups(newSection.getSetups().stream().distinct().collect(Collectors.toList()));

		// Remove setups which don't exist
		newSection.getSetups().removeIf(s -> !cache.getInventorySetupNames().containsKey(s));

	}

	private void preProcessNewSetup(final InventorySetup newSetup)
	{
		final String newName = InventorySetupUtilities.findNewName(newSetup.getName(), cache.getInventorySetupNames().keySet());
		newSetup.setName(newName);
	}

	private Path showMassImportFolderDialog()
	{
		final JFileChooser fileChooser = new JFileChooser();
		fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
		fileChooser.setDialogTitle("Choose Import File");
		FileFilter jsonFilter = new FileNameExtensionFilter("JSON files", "json");
		fileChooser.setFileFilter(jsonFilter);
		fileChooser.setCurrentDirectory(new File(System.getProperty("user.home")));

		int returnValue = fileChooser.showOpenDialog(panel);

		if (returnValue == JFileChooser.APPROVE_OPTION)
		{
			return Paths.get(fileChooser.getSelectedFile().getAbsolutePath());
		}
		else
		{
			return null;
		}
	}

	public boolean isHighlightingAllowed()
	{
		return client.getGameState() == GameState.LOGGED_IN;
	}

	public boolean isFilteringAllowed()
	{
		return navButtonIsSelected || !config.requireActivePanelFilter();
	}

	private List<InventorySetupsItem> getContainerFromSlot(final InventorySetupsSlot slot)
	{
		assert slot.getParentSetup() == panel.getCurrentSelectedSetup() : "Setup Mismatch";
		return getContainerFromID(slot.getParentSetup(), slot.getSlotID());
	}

	private List<InventorySetupsItem> getContainerFromID(final InventorySetup inventorySetup, InventorySetupsSlotID ID)
	{
		switch (ID)
		{
			case INVENTORY:
				return inventorySetup.getInventory();
			case EQUIPMENT:
				return inventorySetup.getEquipment();
			default:
				return ammoHandler.getSpecialContainerFromID(inventorySetup, ID);
		}
	}

	public boolean setupContainsItem(final InventorySetup setup, int itemID, boolean allowFuzzy, boolean canonicalize)
	{
		if (additionalFilteredItemsHasItem(itemID, setup.getAdditionalFilteredItems(), allowFuzzy, canonicalize))
		{
			return true;
		}
		if (ammoHandler.specialContainersContainItem(setup, itemID, allowFuzzy, canonicalize))
		{
			return true;
		}
		if (containerContainsItem(itemID, setup.getInventory(), allowFuzzy, canonicalize))
		{
			return true;
		}
		if (containerContainsItem(itemID, setup.getEquipment(), allowFuzzy, canonicalize))
		{
			return true;
		}
		return false;
	}

	public boolean containerContainsItem(int itemID, final List<InventorySetupsItem> setupContainer, boolean allowFuzzy, boolean canonicalize)
	{
		if (setupContainer == null)
		{
			return false;
		}

		for (final InventorySetupsItem item : setupContainer)
		{

			int processedSetupItemId = getProcessedID(item.isFuzzy(), allowFuzzy, canonicalize, item.getId());
			int processedItemId = getProcessedID(item.isFuzzy(), allowFuzzy, canonicalize, itemID);

			if (processedSetupItemId == processedItemId)
			{
				return true;
			}
		}

		return false;
	}

	public boolean containerContainsItemFromSet(final Set<Integer> itemIDs, final List<InventorySetupsItem> setupContainer, boolean allowFuzzy, boolean canonicalize)
	{
		if (setupContainer == null)
		{
			return false;
		}

		for (final InventorySetupsItem item : setupContainer)
		{

			int processedSetupItemId = getProcessedID(item.isFuzzy(), allowFuzzy, canonicalize, item.getId());

			if (itemIDs.contains(processedSetupItemId))
			{
				return true;
			}
		}

		return false;
	}

	private int getProcessedID(boolean itemIsFuzzy, boolean allowFuzzy, boolean canonicalize, int itemId)
	{
		// For equipped weight reducing items or noted items in the inventory
		if (canonicalize || itemIsFuzzy)
		{
			itemId = itemManager.canonicalize(itemId);
		}

		// use fuzzy mapping if needed
		if (itemIsFuzzy && allowFuzzy)
		{
			return InventorySetupsVariationMapping.map(itemId);
		}

		return itemId;
	}

	public void openColorPicker(String title, Color startingColor, Consumer<Color> onColorChange)
	{

		RuneliteColorPicker colorPicker = getColorPickerManager().create(
				SwingUtilities.windowForComponent(panel),
				startingColor,
				title,
				false);

		colorPicker.setLocation(panel.getLocationOnScreen());
		colorPicker.setOnColorChange(onColorChange);

		colorPicker.addWindowListener(new WindowAdapter()
		{
			@Override
			public void windowClosing(WindowEvent e)
			{
				dataManager.updateConfig(true, true);
			}
		});

		colorPicker.setVisible(true);
	}

	public void updateSetupName(final InventorySetup setup, final String newName)
	{
		final String originalName = setup.getName();
		for (final InventorySetupsSection section : sections)
		{
			if (cache.getSectionSetupsMap().get(section.getName()).containsKey(originalName))
			{
				final List<String> names = section.getSetups();
				int indexOf = names.indexOf(originalName);
				names.set(indexOf, newName);
			}
		}
		// Make sure not to set the new name of the setup before allowing the cache to update
		final String oldTag = InventorySetupLayoutUtilities.getTagNameForLayout(setup.getName());
		cache.updateSetupName(setup, newName);
		setup.setName(newName);

		// Update the tag and layout info
		clientThread.invoke(() ->
		{
			// Rename the tag
			String newTag = InventorySetupLayoutUtilities.getTagNameForLayout(setup.getName());
			tagManager.renameTag(oldTag, newTag);

			// Construct the new Layout using the new tag but the old layout info.
			Layout oldLayout = layoutManager.loadLayout(oldTag);
			assert oldLayout != null : "Setup did not have a layout!";
			Layout newLayout = new Layout(newTag, oldLayout.getLayout());

			layoutManager.removeLayout(oldTag);
			layoutManager.saveLayout(newLayout);
			tagManager.setHidden(newLayout.getTag(), true);
		});

		// config will already be updated by caller so no need to update it here
	}

	public void updateSectionName(final InventorySetupsSection section, final String newName)
	{
		// Make sure not to set the new name of the section before allowing the cache to update
		cache.updateSectionName(section, newName);
		section.setName(newName);
		// config will already be updated by caller so no need to update it here
	}

}

package inventorysetups;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum InventorySetupsPanelViewID
{
	STANDARD("STANDARD", 0),
	COMPACT("COMPACT", 1),
	ICON("ICON", 2);

	@Override
	public String toString()
	{
		return name;
	}

	private static final List<InventorySetupsPanelViewID> VALUES;

	static
	{
		VALUES = new ArrayList<>();
		Collections.addAll(VALUES, InventorySetupsPanelViewID.values());
	}

	public static List<InventorySetupsPanelViewID> getValues()
	{
		return VALUES;
	}

	private final String name;
	private final int identifier;
}

package inventorysetups;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public enum InventorySetupsRunePouchType
{
	// None
	NONE(0),

	// 3 slots
	NORMAL(3),

	// 4 slots
	DIVINE(4);

	private final int size;

	private static final List<InventorySetupsRunePouchType> VALUES;

	static
	{
		VALUES = new ArrayList<>();
		Collections.addAll(VALUES, InventorySetupsRunePouchType.values());
	}

	InventorySetupsRunePouchType(int size)
	{
		this.size = size;
	}

	public int getSize()
	{
		return size;
	}

	public static List<InventorySetupsRunePouchType> getValues()
	{
		return VALUES;
	}
}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import net.runelite.api.gameval.InventoryID;

public enum InventorySetupsSlotID
{

	INVENTORY(0),

	EQUIPMENT(1),

	RUNE_POUCH(2),

	BOLT_POUCH(3),

	SPELL_BOOK(4),

	ADDITIONAL_ITEMS(5),

	QUIVER(6);

	private final int id;

	InventorySetupsSlotID(int id)
	{
		this.id = id;
	}

	public int getId()
	{
		return id;
	}

	public static InventorySetupsSlotID fromInventoryID(final int inventoryId)
	{
		if (inventoryId == 0)
		{
			return null;
		}

		switch (inventoryId)
		{
			case InventoryID.INV:
				return INVENTORY;
			case InventoryID.WORN:
				return EQUIPMENT;
		}

		return null;
	}

}

package inventorysetups;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.banktags.TagManager;
import net.runelite.client.plugins.banktags.tabs.Layout;
import net.runelite.client.plugins.banktags.tabs.LayoutManager;
import net.runelite.client.util.Text;

import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static inventorysetups.InventorySetupsPlugin.LAYOUT_PREFIX_MARKER;

public class InventorySetupLayoutUtilities
{
	private final ItemManager itemManager;

	private final TagManager tagManager;

	private final LayoutManager layoutManager;

	private final InventorySetupsConfig config;

	private final Client client;

	public InventorySetupLayoutUtilities(final ItemManager itemManager, final TagManager tagManager, final LayoutManager layoutManager, final InventorySetupsConfig config, final Client client)
	{
		this.itemManager = itemManager;
		this.tagManager = tagManager;
		this.layoutManager = layoutManager;
		this.config = config;
		this.client = client;
	}

	public static String getTagNameForLayout(final String inventorySetupName)
	{
		String hashOfName = InventorySetupsPersistentDataManager.hashFunction.hashUnencodedChars(inventorySetupName).toString();
		return LAYOUT_PREFIX_MARKER + hashOfName;
	}

	public Layout getSetupLayout(final InventorySetup setup)
	{
		final String tagName = getTagNameForLayout(setup.getName());
		final Layout layout = layoutManager.loadLayout(tagName);
		assert layout != null : "Layout for " + setup.getName() + " is null.";
		return layout;
	}

	public Layout createSetupLayout(final InventorySetup setup)
	{
		InventorySetupLayoutType type = config.defaultLayout();
		return createSetupLayout(setup, type, true);
	}

	public Layout createSetupLayout(final InventorySetup setup, InventorySetupLayoutType type, final boolean addToTag)
	{
		if (type.equals(InventorySetupLayoutType.PRESET))
		{
			return getPresetLayout(setup, addToTag);
		}
		else
		{
			return getZigZagLayout(setup, addToTag);
		}
	}

	public Layout getZigZagLayout(final InventorySetup setup, final boolean addToTag)
	{
		final String tag = getTagNameForLayout(setup.getName());
		final Layout layout = new Layout(tag);

		int startOfEquipment = 0;
		int startOfInventory = 16;
		int startOfRunePouch = 48;
		int startOfBoltPouch = 52;
		int startOfAdditionalItems = 56;

		int newSizeGuess = setup.getAdditionalFilteredItems().size() + startOfAdditionalItems;
		layout.resize(newSizeGuess);
		final HashMap<Integer, Integer> counter = new HashMap<>();

		int nextPos = layoutZigZagContainer(setup.getEquipment(), layout, tag, addToTag, startOfEquipment, counter);
		if (setup.getQuiver() != null && !setup.getQuiver().isEmpty())
		{
			addItemToLayout(layout, tag, setup.getQuiver().get(0), nextPos, addToTag, counter);
		}
		layoutZigZagContainer(setup.getInventory(), layout, tag, addToTag, startOfInventory, counter);

		// Layout the rune pouch
		if (setup.getRune_pouch() != null)
		{
			for (int i = 0; i < setup.getRune_pouch().size(); i++)
			{
				addItemToLayout(layout, tag, setup.getRune_pouch().get(i), i + startOfRunePouch, addToTag, counter);
			}
		}

		// Bolt pouch below the rune pouch
		if (setup.getBoltPouch() != null)
		{
			for (int i = 0; i < setup.getBoltPouch().size(); i++)
			{
				addItemToLayout(layout, tag, setup.getBoltPouch().get(i), i + startOfBoltPouch, addToTag, counter);
			}
		}

		// Additional items
		int additionalItemsCounter = 0;
		Collection<InventorySetupsItem> additionalItems = setup.getAdditionalFilteredItems().values();
		for (final InventorySetupsItem item : additionalItems)
		{
			boolean added = addItemToLayout(layout, tag, item, additionalItemsCounter + startOfAdditionalItems, addToTag, counter);
			if (added)
			{
				additionalItemsCounter++;
			}
		}

		// If duplicate items are disabled, this will ensure fuzzy items get added to the bottom row after
		trimLayout(layout);
		if (layout.size() < startOfAdditionalItems)
		{
			layout.resize(startOfAdditionalItems);
		}
		addFuzzyItemsToEndOfLayout(layout, setup);

		return layout;
	}

	private int layoutZigZagContainer(final List<InventorySetupsItem> container, final Layout layout, final String tag, boolean addToTag, final int start, final Map<Integer, Integer> counter)
	{
		// Note, this might not work if the start is not a multiple of the row size (8)...
		// But this is not needed, so I won't spend time over engineering this function.

		int doubleRowStart = 0;
		boolean topToBottom = config.zigZagType().equals(InventorySetupsZigZagTypeID.TOP_TO_BOTTOM);
		final int rowSize = 8;

		int nextPos = topToBottom ? 0 : 8;

		for (final InventorySetupsItem item : container)
		{
			boolean added = addItemToLayout(layout, tag, item, nextPos + start, addToTag, counter);
			if (!added)
			{
				continue;
			}

			if (topToBottom)
			{
				if (nextPos == ((doubleRowStart * rowSize) + (2 * rowSize) - 1))
				{
					// We hit the end of a double row, we need to start a new one.
					doubleRowStart += 2;
					nextPos = doubleRowStart * rowSize;
				}
				else if (nextPos < ((doubleRowStart * rowSize) + rowSize))
				{
					// We are in the top half of a double row. Go down directly one.
					nextPos += rowSize;
				}
				else
				{
					// We are in the bottom half of a double. Go back up and add one to move to the right.
					nextPos = (nextPos - rowSize) + 1;
				}
			}
			else
			{
				if (nextPos == ((doubleRowStart * rowSize) + rowSize - 1))
				{
					// We hit the end of a double row, we need to start a new one.
					doubleRowStart += 2;
					nextPos = (doubleRowStart * rowSize) + rowSize;
				}
				else if (nextPos > ((doubleRowStart * rowSize) + rowSize) - 1)
				{
					// We are in the bottom half of a double. Go up directly one.
					nextPos -= rowSize;
				}
				else
				{
					// We are in the top half of a double row. Go back down and add one to move to the right.
					nextPos = nextPos + rowSize + 1;
				}
			}
		}

		return nextPos;
	}

	public Layout getPresetLayout(final InventorySetup setup, final boolean addToTag)
	{
		// This generates a "Preset" layout based on an InventorySetup
		// It will have the equipment on the left and inventory on the right
		// This must be called on the clientThread

		// Note: Core Layout API does not support custom variation mappings, so even if fuzzy is marked,
		// custom mappings will not work in the layout.

		final String tag = getTagNameForLayout(setup.getName());
		final Layout layout = new Layout(tag);

		// Determine size to help reduce amount of copy overs.
		// Since the inventory will be a 4x7 on the right side of the bank, it will end at position 55.
		int startOfAdditionalItems = 56;
		int startOfBoltPouch = 48;
		int startOfRunePouch = 40;

		int newSizeGuess = setup.getAdditionalFilteredItems().size() + startOfAdditionalItems;
		layout.resize(newSizeGuess);

		final HashMap<Integer, Integer> counter = new HashMap<>();

		// Layout the equipment on left side
		final List<InventorySetupsItem> eqp = setup.getEquipment();
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.HEAD.getSlotIdx()), 1, addToTag, counter);
		if (setup.getQuiver() != null && !setup.getQuiver().isEmpty())
		{
			addItemToLayout(layout, tag, setup.getQuiver().get(0), 2, addToTag, counter);
		}
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.CAPE.getSlotIdx()), 8, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.AMULET.getSlotIdx()), 9, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.AMMO.getSlotIdx()), 10, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.WEAPON.getSlotIdx()), 16, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.BODY.getSlotIdx()), 17, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.SHIELD.getSlotIdx()), 18, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.LEGS.getSlotIdx()), 25, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.GLOVES.getSlotIdx()), 32, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.BOOTS.getSlotIdx()), 33, addToTag, counter);
		addItemToLayout(layout, tag, eqp.get(EquipmentInventorySlot.RING.getSlotIdx()), 34, addToTag, counter);

		// Layout the inventory on the right side
		int invRow = 0;
		int invCol = 4;
		int width = 8;
		for (final InventorySetupsItem item: setup.getInventory())
		{
			addItemToLayout(layout, tag, item, invCol + (invRow * width), addToTag, counter);
			if (invCol == 7)
			{
				invCol = 4;
				invRow++;
			}
			else
			{
				invCol++;
			}
		}

		// Rune pouch below equipment
		if (setup.getRune_pouch() != null)
		{
			for (int i = 0; i < setup.getRune_pouch().size(); i++)
			{
				addItemToLayout(layout, tag, setup.getRune_pouch().get(i), i + startOfRunePouch, addToTag, counter);
			}
		}

		// Bolt pouch below the rune pouch
		if (setup.getBoltPouch() != null)
		{
			for (int i = 0; i < setup.getBoltPouch().size(); i++)
			{
				addItemToLayout(layout, tag, setup.getBoltPouch().get(i), i + startOfBoltPouch, addToTag, counter);
			}
		}

		// Additional items
		int additionalItemsCounter = 0;
		Collection<InventorySetupsItem> additionalItems = setup.getAdditionalFilteredItems().values();
		for (final InventorySetupsItem item : additionalItems)
		{
			boolean added = addItemToLayout(layout, tag, item, additionalItemsCounter + startOfAdditionalItems, addToTag, counter);
			if (added)
			{
				additionalItemsCounter++;
			}
		}

		// If duplicate items are disabled, this will ensure fuzzy items get added to the bottom row after
		trimLayout(layout);
		if (layout.size() < startOfAdditionalItems)
		{
			layout.resize(startOfAdditionalItems);
		}
		addFuzzyItemsToEndOfLayout(layout, setup);

		return layout;
	}

	private boolean addItemToLayout(final Layout layout, final String tagName, final InventorySetupsItem item, final int pos, final boolean addToTag, final Map<Integer, Integer> counter)
	{
		if (item.getId() == -1)
		{
			return false;
		}
		int id = itemManager.canonicalize(item.getId());
		if (!config.layoutDuplicates() && counter.containsKey(id))
		{
			return false;
		}
		layout.setItemAtPos(id, pos);
		// We may not want to add to the tag if we just want to create a layout but not update tags.
		// Useful for displaying a temporary layout.
		if (addToTag)
		{
			tagManager.addTag(id, tagName, item.isFuzzy());
		}
		counter.put(id, counter.getOrDefault(id, 0) + 1);

		return true;
	}

	public void recalculateLayout(final InventorySetup setup)
	{
		// Recalculate all the items that should be in the layout

		final List<InventorySetupsItem> itemsInSetup = InventorySetup.getSetupItems(setup);
		final String tagName = getTagNameForLayout(setup.getName());
		final Layout layout = layoutManager.loadLayout(tagName);
		assert layout != null : "Setup " + setup.getName() + " has no layout.";

		// Remove the tag entirely.
		tagManager.removeTag(tagName);

		// Re-add every item in the tag.
		Set<Integer> idsInSetup = new LinkedHashSet<>();
		Set<Integer> idsInSetupNoFuzzy = new LinkedHashSet<>();
		for (InventorySetupsItem item : itemsInSetup)
		{
			int processedId = itemManager.canonicalize(item.getId());
			if (processedId == -1)
			{
				continue;
			}

			// Fuzzy tags and non-fuzzy tags are actually stored separate, so a non-fuzzy item can't override
			// The same fuzzy item that came before it (even though this would be a rare case).
			// I don't know the effect of the fuzzy and non-fuzzy items being part of both tags.
			tagManager.addTag(processedId, tagName, item.isFuzzy());

			// Track all the IDs in the setup
			idsInSetup.add(processedId);
			idsInSetupNoFuzzy.add(processedId);
			if (item.isFuzzy())
			{
				final int baseProcessedId = InventorySetupsVariationMapping.map(processedId);
				idsInSetup.addAll(InventorySetupsVariationMapping.getVariations(baseProcessedId));
			}
		}

		// Remove any items that do not belong in the layout.
		// This won't potentially remove an item if there are multiple copies of it in the setup.
		// It's possible that some users would want one of the instances of the item to be replaced
		// But for now, we avoid that. If this is needed, it's probably better to do it in the caller of this function
		// Since it knows if an item was removed or not, while this is catch all recalculation of the layout.
		Set<Integer> idsInLayout = new HashSet<>();
		for (int i = 0; i < layout.size(); i++)
		{
			int layoutId = layout.getItemAtPos(i);
			if (layoutId == -1)
			{
				continue;
			}

			// Make sure to convert placeholders to the actual value otherwise we might delete
			// The placeholder in the layout.
			ItemComposition itemComp = itemManager.getItemComposition(layoutId);
			boolean itemIsPlaceholder = itemComp.getPlaceholderTemplateId() > -1;
			int processedId = layoutId;
			if (itemIsPlaceholder)
			{
				processedId = itemComp.getPlaceholderId();
			}

			if (!idsInSetup.contains(processedId))
			{
				layout.removeItemAtPos(i);
				continue;
			}

			idsInLayout.add(layoutId);
		}

		// Add any items that should belong in the layout based on the setup to the first available position
		// So it's easy to find.
		// Do not include fuzzy items in the setup because we can add those at the bottom.
		for (final Integer idInSetup : idsInSetupNoFuzzy)
		{
			if (!idsInLayout.contains(idInSetup))
			{
				layout.addItem(idInSetup);
				idsInLayout.add(idInSetup);
			}
		}

		addFuzzyItemsToEndOfLayout(layout, idsInSetup, idsInSetupNoFuzzy, idsInLayout);

		trimLayout(layout);

		layoutManager.saveLayout(layout);
		tagManager.setHidden(layout.getTag(), true);
	}

	private void addFuzzyItemsToEndOfLayout(final Layout layout, final InventorySetup setup)
	{
		List<InventorySetupsItem> itemsInSetup = InventorySetup.getSetupItems(setup);
		Set<Integer> idsInSetup = new LinkedHashSet<>();
		Set<Integer> idsInSetupNoFuzzy = new LinkedHashSet<>();
		for (InventorySetupsItem item : itemsInSetup)
		{
			int processedId = itemManager.canonicalize(item.getId());
			if (processedId == -1)
			{
				continue;
			}

			idsInSetup.add(processedId);
			idsInSetupNoFuzzy.add(processedId);
			if (item.isFuzzy())
			{
				final int baseProcessedId = InventorySetupsVariationMapping.map(processedId);
				idsInSetup.addAll(InventorySetupsVariationMapping.getVariations(baseProcessedId));
			}
		}

		Set<Integer> idsInLayout = new LinkedHashSet<>();
		for (int i = 0; i < layout.size(); i++)
		{
			idsInLayout.add(layout.getItemAtPos(i));
		}

		addFuzzyItemsToEndOfLayout(layout, idsInSetup, idsInSetupNoFuzzy, idsInLayout);
	}

	private void addFuzzyItemsToEndOfLayout(final Layout layout, final Set<Integer> idsInSetup, final Set<Integer> idsInSetupNoFuzzy, final Set<Integer> idsInLayout)
	{
		// Try our best at adding fuzzy items to the bottom of the layout
		// Only add those that exist in the bank, otherwise we would add every possible variation which is not ideal.
		// Any missed items will be added by the layout manager from core bank tags.
		//
		// Core bank tags will also place variation mapped items in an existing placeholder if available for us. However,
		// this does not support our custom variation mappings in those placeholders. Our custom variation mappings will
		// show up in the layout if it is in the bank, but not fill an empty variation placeholder slot. It will occupy
		// a new slot in the bank.
		//
		// This will only work if the bank is open, but still worth doing for things like auto layouts.
		//
		// NOTE: Placeholders take precedence over variants, so core bank tags will still show a placeholder if the actual
		// placeholder item exists in the players bank.
		ItemContainer bankContainer = client.getItemContainer(InventoryID.BANK);
		if (bankContainer == null)
		{
			return;
		}

		Set<Integer> idsInSetupOnlyFuzzy = new LinkedHashSet<>(idsInSetup);
		idsInSetupOnlyFuzzy.removeAll(idsInSetupNoFuzzy);
		if (idsInSetupOnlyFuzzy.isEmpty())
		{
			return;
		}

		Set<Integer> bankItems = new LinkedHashSet<>();
		for (int i = 0; i < bankContainer.size(); i++)
		{
			Item item = bankContainer.getItem(i);
			if (item != null && item.getId() > -1 && item.getId() != ItemID.BLANKOBJECT)
			{
				bankItems.add(item.getId());
			}
		}

		Set<Integer> variantsSeen = new LinkedHashSet<>();
		for (final Integer id : idsInSetupOnlyFuzzy)
		{

			// For all fuzzy items, we need to decide if we should add it to the layout now, or let core bank tags do it
			// If core bank tags adds the item, it will be at the top, unless there is an item that matches the placeholder
			// if it is marked as fuzzy.
			int baseId = InventorySetupsVariationMapping.map(id);
			boolean hasPlaceHolderVariant = false;
			for (int variationId : InventorySetupsVariationMapping.getVariations(baseId))
			{
				// Protects against the case the fuzzy item is the base variant.
				// Bank Tags does not appear to fill a base item with a variant, so it will place the fuzzy item at the
				// top of the bank, while we want it at the bottom. So we avoid allowing the base id as a fuzzy option.
				if (baseId == variationId)
				{
					continue;
				}

				// If a variation is in the layout but not in the bank, and this fuzzy item is not in the layout but in the bank,
				// Then this is a placeholder in the layout that bank tags can place a variation mapped item. For this
				// reason we will skip adding this fuzzy item to the bottom of the layout.
				if (idsInLayout.contains(variationId) &&
					!bankItems.contains(variationId) &&
					!idsInLayout.contains(id) && bankItems.contains(id) &&
					!variantsSeen.contains(variationId))
				{
					// Add this to variants seen. We don't want this item to be considered an option for other items,
					// otherwise we would not put this fuzzy item at the bottom and bank tags will put it at the top.
					variantsSeen.add(variationId);
					hasPlaceHolderVariant = true;
					break;
				}
			}

			if (hasPlaceHolderVariant)
			{
				continue;
			}

			if (bankItems.contains(id) && !idsInLayout.contains(id))
			{
				layout.addItemAfter(id, layout.size());
				continue;
			}

			// Try to add the placeholder IDs at the bottom of the layout if the actual item doesn't exist.
			// Bank Tags will add the placeholder ID rather than the item ID, so we should add the placeholder as well.
			int placeholderID = itemManager.getItemComposition(id).getPlaceholderId();
			if (bankItems.contains(placeholderID) && !idsInLayout.contains(placeholderID))
			{
				layout.addItemAfter(placeholderID, layout.size());
			}
		}
	}

	public void exportSetupToBankTagTab(final InventorySetup setup, final Component component)
	{
		final List<String> data = new ArrayList<>();
		final Layout layout = getSetupLayout(setup);
		data.add("banktags");
		data.add("1");

		// Instead of the super long marked name, just use the standardized name for the setup.
		data.add(Text.standardize(setup.getName()));
		int icon = setup.getIconID();
		if (icon <= 0)
		{
			// try to use the current weapon
			icon = setup.getEquipment().get(EquipmentInventorySlot.WEAPON.getSlotIdx()).getId();
		}
		if (icon <= 0)
		{
			icon = ItemID.SPADE;
		}

		data.add(String.valueOf(icon));

		for (Integer item : tagManager.getItemsForTag(layout.getTag()))
		{
			if (layout.count(item) == 0)
			{
				data.add(String.valueOf(item));
			}
		}

		data.add("layout");
		int[] l = layout.getLayout();
		for (int idx = 0; idx < l.length; ++idx)
		{
			if (l[idx] != -1)
			{
				data.add(String.valueOf(idx));
				data.add(String.valueOf(l[idx]));
			}
		}

		final StringSelection stringSelection = new StringSelection(Text.toCSV(data));
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(stringSelection, null);

		SwingUtilities.invokeLater(() ->
				JOptionPane.showMessageDialog(component,
						"Bank tag tab data was copied to clipboard.",
						"Export Setup To Bank Tag Tab Succeeded",
						JOptionPane.PLAIN_MESSAGE));
	}

	public Layout convertHubBankTagLayoutToCoreBankTagLayout(final String hubBankTagLayoutData, final String tag)
	{
		try
		{
			final Layout layout = new Layout(tag);
			final String[] pairs = hubBankTagLayoutData.split(",");
			for (final String pair : pairs)
			{
				String[] numbers = pair.split(":");
				int id = Integer.parseInt(numbers[0]);
				int pos = Integer.parseInt(numbers[1]);

				// Bank Tag Layout setups might have item placeholder id which won't play nice with bank tags
				int processedID = itemManager.canonicalize(id);
				layout.setItemAtPos(processedID, pos);
			}
			return layout;
		}
		catch (Exception e)
		{
			return null;
		}
	}

	private void trimLayout(final Layout layout)
	{
		// Remove all trailing `-1`s in a layout.
		if (layout.size() == 0)
		{
			return;
		}
		final int[] layoutArr = layout.getLayout();
		if (layoutArr[layoutArr.length - 1] != -1)
		{
			return;
		}

		int indexToTrimTo = layoutArr.length - 2;
		while (indexToTrimTo >= 0 && layoutArr[indexToTrimTo] == -1)
		{
			indexToTrimTo--;
		}
		layout.resize(indexToTrimTo + 1);
	}

}
package inventorysetups;

import java.awt.Color;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

// A section is a collection of inventory setups that show up when setups are sorted by section
public class InventorySetupsSection implements InventorySetupsDisplayAttributes
{

	public InventorySetupsSection(final String name)
	{
		this.name = name;
		this.displayColor = null;
		this.isMaximized = false;
		setups = new ArrayList<>();
	}

	@Getter
	@Setter
	private String name;

	// The list of setups
	@Getter
	@Setter
	private List<String> setups;

	@Getter
	@Setter
	private Color displayColor;

	// Whether the section is maximized (showing the collection of setups or not)
	@Getter
	@Setter
	private boolean isMaximized;
}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
public class InventorySetup implements InventorySetupsDisplayAttributes
{
	@Getter
	private List<InventorySetupsItem> inventory;

	@Getter
	private List<InventorySetupsItem> equipment;

	@Getter
	private List<InventorySetupsItem> rune_pouch;

	@Getter
	private List<InventorySetupsItem> boltPouch;

	@Getter
	private List<InventorySetupsItem> quiver;

	@Getter
	private Map<Integer, InventorySetupsItem> additionalFilteredItems;

	@Getter
	@Setter
	private String name;

	@Getter
	@Setter
	private String notes;

	@Getter
	@Setter
	private Color highlightColor;

	@Getter
	@Setter
	private boolean highlightDifference;

	@Getter
	@Setter
	private Color displayColor;

	@Getter
	@Setter
	private boolean filterBank;

	@Getter
	@Setter
	private boolean unorderedHighlight;

	/*
		0 = Standard
		1 = Ancient
		2 = Lunar
		3 = Arceuus
		4 = NONE

		Avoiding Enum because won't work well with GSON (defaults to null)
	*/
	@Getter
	@Setter
	private int spellBook;

	@Getter
	@Setter
	private boolean favorite;

	@Getter
	@Setter
	private int iconID;

	public void updateInventory(final List<InventorySetupsItem> inv)
	{
		inventory = inv;
	}

	public void updateEquipment(final List<InventorySetupsItem> eqp)
	{
		equipment = eqp;
	}

	public void updateRunePouch(final List<InventorySetupsItem> rp)
	{
		rune_pouch = rp;
	}

	public void updateBoltPouch(final List<InventorySetupsItem> bp)
	{
		boltPouch = bp;
	}

	public void updateQuiver(final List<InventorySetupsItem> q)
	{
		quiver = q;
	}

	public void updateAdditionalItems(final Map<Integer, InventorySetupsItem> ai)
	{
		additionalFilteredItems = ai;
	}

	public void updateSpellbook(final int sb)
	{
		spellBook = sb;
	}

	public void updateNotes(final String text)
	{
		notes = text;
	}

	public static List<InventorySetupsItem> getSetupItems(final InventorySetup setup)
	{
		List<InventorySetupsItem> itemsInSetup = new ArrayList<>();
		itemsInSetup.addAll(setup.getInventory());
		itemsInSetup.addAll(setup.getEquipment());
		itemsInSetup.addAll(setup.getAdditionalFilteredItems().values());
		if (setup.getRune_pouch() != null)
		{
			itemsInSetup.addAll(setup.getRune_pouch());
		}
		if (setup.getBoltPouch() != null)
		{
			itemsInSetup.addAll(setup.getBoltPouch());
		}
		if (setup.getQuiver() != null)
		{
			itemsInSetup.addAll(setup.getQuiver());
		}
		return itemsInSetup;
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum InventorySetupsSortingID
{
	DEFAULT("Default", 0),
	ALPHABETICAL("Alphabetical", 1);

	@Override
	public String toString()
	{
		return name;
	}

	private final String name;
	private final int identifier;
}

/*
 * Copyright (c) 2022, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import java.awt.Color;

public interface InventorySetupsValidName
{
	boolean isNameValid(final String name, final Color displayColor);

	void updateName(final String newName);
}

package inventorysetups;

import java.awt.Component;
import java.awt.Container;
import java.util.Set;
import javax.swing.SwingUtilities;
import net.runelite.client.util.SwingUtil;
import static inventorysetups.InventorySetupsPlugin.MAX_SETUP_NAME_LENGTH;


public class InventorySetupUtilities
{
	private InventorySetupUtilities()
	{

	}

	static public int parseTextInputAmount(String input)
	{
		// only take the first 10 characters (max amount is 2.147B which is only 10 digits)
		if (input.length() > 10)
		{
			return Integer.MAX_VALUE;
		}
		input = input.toLowerCase();

		char finalChar = input.charAt(input.length() - 1);
		int factor = 1;
		if (Character.isLetter(finalChar))
		{
			input = input.substring(0, input.length() - 1);
			switch (finalChar)
			{
				case 'k':
					factor = 1000;
					break;
				case 'm':
					factor = 1000000;
					break;
				case 'b':
					factor = 1000000000;
					break;
			}
		}

		// limit to max int value
		long quantityLong = Long.parseLong(input) * factor;
		int quantity = (int) Math.min(quantityLong, Integer.MAX_VALUE);
		quantity = Math.max(quantity, 1);

		return quantity;
	}

	static public String findNewName(String originalName, final Set<String> objects)
	{
		// Do not allow names of more than MAX_SETUP_NAME_LENGTH chars
		if (originalName.length() > MAX_SETUP_NAME_LENGTH)
		{
			originalName = originalName.substring(0, MAX_SETUP_NAME_LENGTH);
		}

		// Fix duplicate name by adding an incrementing number to the duplicate
		String newName = originalName;
		int i = 1;
		while (objects.contains(newName) || newName.isEmpty())
		{
			String i_str = String.valueOf(i);
			if (originalName.length() + i_str.length() > MAX_SETUP_NAME_LENGTH)
			{
				int chars_to_cut_off = i_str.length() - (MAX_SETUP_NAME_LENGTH - originalName.length());
				newName = originalName.substring(0, MAX_SETUP_NAME_LENGTH - chars_to_cut_off) + i++;
			}
			else
			{
				newName = originalName + i++;
			}
		}
		return newName;
	}

	public static void fastRemoveAll(Container c)
	{
		fastRemoveAll(c, true);
	}

	private static void fastRemoveAll(Container c, boolean isMainParent)
	{
		// If we are not on the EDT this will deadlock, in addition to being totally unsafe
		assert SwingUtilities.isEventDispatchThread();

		// when a component is removed it has to be resized for some reason, but only if it's valid
		// so we make sure to invalidate everything before removing it
		c.invalidate();
		for (int i = 0; i < c.getComponentCount(); i++)
		{
			Component ic = c.getComponent(i);

			// removeAll and removeNotify are both recursive, so we have to recurse before them
			if (ic instanceof Container)
			{
				fastRemoveAll((Container) ic, false);
			}

			// each removeNotify needs to remove anything from the event queue that is for that widget
			// this however requires taking a lock, and is moderately slow, so we just execute all of
			// those events with a secondary event loop
			SwingUtil.pumpPendingEvents();

			// call removeNotify early; this is most of the work in removeAll, and generates events that
			// the next secondaryLoop will pickup
			ic.removeNotify();
		}

		if (isMainParent)
		{
			// Actually remove anything
			c.removeAll();
		}
	}
}
package inventorysetups;

import com.google.common.collect.ImmutableMap;
import java.awt.image.BufferedImage;
import java.util.Map;
import lombok.Getter;
import lombok.Setter;
import static net.runelite.api.gameval.ItemID.*;

/**
 * @author robbie, created on 19/09/2021 12:34
 */
public enum Bolts
{
	BRONZE(1, BOLT),
	BLURITE(2, XBOWS_CROSSBOW_BOLTS_BLURITE),
	IRON(3, XBOWS_CROSSBOW_BOLTS_IRON),
	STEEL(4, XBOWS_CROSSBOW_BOLTS_STEEL),
	MITHRIL(5, XBOWS_CROSSBOW_BOLTS_MITHRIL),
	ADAMANT(6, XBOWS_CROSSBOW_BOLTS_ADAMANTITE),
	RUNITE(7, XBOWS_CROSSBOW_BOLTS_RUNITE),
	SILVER(8, XBOWS_CROSSBOW_BOLTS_SILVER),

	BRONZE_POISON1(9, POISON_BOLT),
	BLURITE_POISON1(10, XBOWS_CROSSBOW_BOLTS_BLURITE_POISONED),
	IRON_POISON1(11, XBOWS_CROSSBOW_BOLTS_IRON_POISONED),
	STEEL_POISON1(12, XBOWS_CROSSBOW_BOLTS_STEEL_POISONED),
	MITHRIL_POISON1(13, XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED),
	ADAMANT_POISON1(14, XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED),
	RUNITE_POISON1(15, XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED),
	SILVER_POISON1(16, XBOWS_CROSSBOW_BOLTS_SILVER_POISONED),

	BRONZE_POISON2(17, POISON_BOLT_),
	BLURITE_POISON2(18, XBOWS_CROSSBOW_BOLTS_BLURITE_POISONED_),
	IRON_POISON2(19, XBOWS_CROSSBOW_BOLTS_IRON_POISONED_),
	STEEL_POISON2(20, XBOWS_CROSSBOW_BOLTS_STEEL_POISONED_),
	MITHRIL_POISON2(21, XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED_),
	ADAMANT_POISON2(22, XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED_),
	RUNITE_POISON2(23, XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED_),
	SILVER_POISON2(24, XBOWS_CROSSBOW_BOLTS_SILVER_POISONED_),

	BRONZE_POISON3(25, POISON_BOLT__),
	BLURITE_POISON3(26, XBOWS_CROSSBOW_BOLTS_BLURITE_POISONED__),
	IRON_POISON3(27, XBOWS_CROSSBOW_BOLTS_IRON_POISONED__),
	STEEL_POISON3(28, XBOWS_CROSSBOW_BOLTS_STEEL_POISONED__),
	MITHRIL_POISON3(29, XBOWS_CROSSBOW_BOLTS_MITHRIL_POISONED__),
	ADAMANT_POISON3(30, XBOWS_CROSSBOW_BOLTS_ADAMANTITE_POISONED__),
	RUNITE_POISON3(31, XBOWS_CROSSBOW_BOLTS_RUNITE_POISONED__),
	SILVER_POISON3(32, XBOWS_CROSSBOW_BOLTS_SILVER_POISONED__),

	OPAL(33, OPAL_BOLT),
	JADE(34, XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE),
	PEARL(35, PEARL_BOLT),
	TOPAZ(36, XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ),
	SAPPHIRE(37, XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE),
	EMERALD(38, XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD),
	RUBY(39, XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY),
	DIAMOND(40, XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND),
	DRAGONSTONE(41, XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE),
	ONYX(42, XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX),

	OPAL_E(43, XBOWS_CROSSBOW_BOLTS_BRONZE_TIPPED_OPAL_ENCHANTED),
	JADE_E(44, XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE_ENCHANTED),
	PEARL_E(45, XBOWS_CROSSBOW_BOLTS_IRON_TIPPED_PEARL_ENCHANTED),
	TOPAZ_E(46, XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ_ENCHANTED),
	SAPPHIRE_E(47, XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE_ENCHANTED),
	EMERALD_E(48, XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD_ENCHANTED),
	RUBY_E(49, XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY_ENCHANTED),
	DIAMOND_E(50, XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND_ENCHANTED),
	DRAGONSTONE_E(51, XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE_ENCHANTED),
	ONYX_E(52, XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX_ENCHANTED),

	MITH_GRAPPLE(53,  XBOWS_GRAPPLE_TIP_BOLT_MITHRIL_ROPE),
	BARBED(54, BARBED_BOLT),
	BONE(55, DTTD_BONE_CROSSBOW_BOLT),
	BROAD(56, SLAYER_BROAD_BOLT),
	AMETHYST_BROAD(57, SLAYER_BROAD_BOLT_AMETHYST),

	DRAGON(58, DRAGON_BOLTS),
	DRAGON_POISON1(59, DRAGON_BOLTS_P),
	DRAGON_POISON2(60, DRAGON_BOLTS_P_),
	DRAGON_POISON3(61, DRAGON_BOLTS_P__),
	OPAL_DRAGON(62, DRAGON_BOLTS_UNENCHANTED_OPAL),
	JADE_DRAGON(63, DRAGON_BOLTS_UNENCHANTED_JADE),
	PEARL_DRAGON(64, DRAGON_BOLTS_UNENCHANTED_PEARL),
	TOPAZ_DRAGON(65, DRAGON_BOLTS_UNENCHANTED_TOPAZ),
	SAPPHIRE_DRAGON(66, DRAGON_BOLTS_UNENCHANTED_SAPPHIRE),
	EMERALD_DRAGON(67, DRAGON_BOLTS_UNENCHANTED_EMERALD),
	RUBY_DRAGON(68, DRAGON_BOLTS_UNENCHANTED_RUBY),
	DIAMOND_DRAGON(69, DRAGON_BOLTS_UNENCHANTED_DIAMOND),
	DRAGONSTONE_DRAGON(70, DRAGON_BOLTS_UNENCHANTED_DRAGONSTONE),
	ONYX_DRAGON(71, DRAGON_BOLTS_UNENCHANTED_ONYX),

	OPAL_DRAGON_E(72, DRAGON_BOLTS_ENCHANTED_OPAL),
	JADE_DRAGON_E(73, DRAGON_BOLTS_ENCHANTED_JADE),
	PEARL_DRAGON_E(74, DRAGON_BOLTS_ENCHANTED_PEARL),
	TOPAZ_DRAGON_E(75, DRAGON_BOLTS_ENCHANTED_TOPAZ),
	SAPPHIRE_DRAGON_E(76, DRAGON_BOLTS_ENCHANTED_SAPPHIRE),
	EMERALD_DRAGON_E(77, DRAGON_BOLTS_ENCHANTED_EMERALD),
	RUBY_DRAGON_E(78, DRAGON_BOLTS_ENCHANTED_RUBY),
	DIAMOND_DRAGON_E(79, DRAGON_BOLTS_ENCHANTED_DIAMOND),
	DRAGONSTONE_DRAGON_E(80, DRAGON_BOLTS_ENCHANTED_DRAGONSTONE),
	ONYX_DRAGON_E(81, DRAGON_BOLTS_ENCHANTED_ONYX),

	BOLT_RACK(82, BARROWS_KARIL_AMMO);

	@Getter
	private final int id;
	@Getter
	private final int itemId;

	@Getter
	@Setter
	private BufferedImage image;

	private static final Map<Integer, Bolts> bolts;

	static
	{
		ImmutableMap.Builder<Integer, Bolts> builder = new ImmutableMap.Builder<>();
		for (Bolts bolt : values())
		{
			builder.put(bolt.getId(), bolt);
		}
		bolts = builder.build();
	}

	Bolts(int id, int itemId)
	{
		this.id = id;
		this.itemId = itemId;
	}

	public static Bolts getBolt(int varbit)
	{
		return bolts.get(varbit);
	}

}

package inventorysetups;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum InventorySetupLayoutType
{
	// None
	PRESET("Preset", 0),

	// 3 slots
	ZIGZAG("ZigZag", 1);

	@Override
	public String toString()
	{
		return name;
	}

	private final String name;
	private final int identifier;
}

package inventorysetups;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public enum InventorySetupsGroundItemMenuSwapPriority
{
	// Items not in the setup will be moved to the top
	OUT(0),

	// Items in the setup will be moved to the top
	IN(1);

	private final int type;

	private static final List<InventorySetupsGroundItemMenuSwapPriority> VALUES;

	static
	{
		VALUES = new ArrayList<>();
		Collections.addAll(VALUES, InventorySetupsGroundItemMenuSwapPriority.values());
	}

	InventorySetupsGroundItemMenuSwapPriority(int type)
	{
		this.type = type;
	}

	public int getType()
	{
		return type;
	}

	public static List<InventorySetupsGroundItemMenuSwapPriority> getValues()
	{
		return VALUES;
	}
}

package inventorysetups;

import java.util.HashMap;
import java.util.Map;
import lombok.Getter;

// Class to assist with speeding up operations by caching names when the config is loaded
public class InventorySetupsCache
{
	public InventorySetupsCache()
	{
		this.inventorySetupNames = new HashMap<>();
		this.sectionNames = new HashMap<>();
		this.setupSectionsMap = new HashMap<>();
		this.sectionSetupsMap = new HashMap<>();
	}

	public void addSetup(final InventorySetup setup)
	{
		inventorySetupNames.put(setup.getName(), setup);
		setupSectionsMap.put(setup.getName(), new HashMap<>());
	}

	public void addSection(final InventorySetupsSection section)
	{
		sectionNames.put(section.getName(), section);
		sectionSetupsMap.put(section.getName(), new HashMap<>());

		// If we are importing a section, it can have setups already associated with it
		// In this case, this function assumes the setups already exist
		for (final String setupName : section.getSetups())
		{
			addSetupToSection(section, inventorySetupNames.get(setupName));
		}
	}

	public void updateSetupName(final InventorySetup setup, final String newName)
	{
		inventorySetupNames.remove(setup.getName());
		inventorySetupNames.put(newName, setup);

		// Update the setup in each section -> setups map
		for (final String sectionName : sectionSetupsMap.keySet())
		{
			if (sectionSetupsMap.get(sectionName).containsKey(setup.getName()))
			{
				sectionSetupsMap.get(sectionName).remove(setup.getName());
				sectionSetupsMap.get(sectionName).put(newName, setup);
			}
		}

		// Update the key with the new name
		setupSectionsMap.put(newName, setupSectionsMap.remove(setup.getName()));
	}

	public void updateSectionName(final InventorySetupsSection section, final String newName)
	{
		sectionNames.remove(section.getName());
		sectionNames.put(newName, section);

		// Update the section in each setup -> section map
		for (final String setupName : setupSectionsMap.keySet())
		{
			if (setupSectionsMap.get(setupName).containsKey(section.getName()))
			{
				setupSectionsMap.get(setupName).remove(section.getName());
				setupSectionsMap.get(setupName).put(newName, section);
			}
		}

		// Update the key with the new name
		sectionSetupsMap.put(newName, sectionSetupsMap.remove(section.getName()));
	}

	public void removeSetup(final InventorySetup setup)
	{
		inventorySetupNames.remove(setup.getName());
		setupSectionsMap.remove(setup.getName());

		// Remove the setup for each section in the section -> setups map
		for (final String sectionName : sectionSetupsMap.keySet())
		{
			sectionSetupsMap.get(sectionName).remove(setup.getName());
		}
	}

	public void removeSection(final InventorySetupsSection section)
	{
		sectionNames.remove(section.getName());
		sectionSetupsMap.remove(section.getName());

		// Remove the section for each setup in the setup -> sections map
		for (final String setupName : section.getSetups())
		{
			setupSectionsMap.get(setupName).remove(section.getName());
		}
	}

	public void addSetupToSection(final InventorySetupsSection section, final InventorySetup setup)
	{
		setupSectionsMap.get(setup.getName()).put(section.getName(), section);
		sectionSetupsMap.get(section.getName()).put(setup.getName(), setup);
	}

	public void removeSetupFromSection(final InventorySetupsSection section, final InventorySetup setup)
	{
		setupSectionsMap.get(setup.getName()).remove(section.getName());
		sectionSetupsMap.get(section.getName()).remove(setup.getName());
	}

	public void clearAll()
	{
		inventorySetupNames.clear();
		sectionNames.clear();
		setupSectionsMap.clear();
		sectionSetupsMap.clear();
	}

	// Mapping from inventory setup name -> inventory setup object
	@Getter
	private final Map<String, InventorySetup> inventorySetupNames;

	// Mapping from section name -> section object
	@Getter
	private final Map<String, InventorySetupsSection> sectionNames;

	// Mapping from setup name -> Map of name to section for each section the setup is a part of
	// Useful for determining if it should be added to the "unassigned" section
	@Getter
	private final Map<String, Map<String, InventorySetupsSection>> setupSectionsMap;

	// Mapping from section -> Map of name to setup for each setup that is part of the section
	// Useful for determining the intersection of setups to display and setups in a section
	@Getter
	private final Map<String, Map<String, InventorySetup>> sectionSetupsMap;
}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetupUtilities;
import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPanelViewID;
import inventorysetups.InventorySetupsPlugin;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_PANEL_VIEW;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_SECTION_MODE;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_UNASSIGNED_MAXIMIZED;
import static inventorysetups.InventorySetupsPlugin.TUTORIAL_LINK;

import inventorysetups.InventorySetupsSection;
import inventorysetups.InventorySetupsSlotID;
import inventorysetups.InventorySetupsSortingID;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import inventorysetups.serialization.InventorySetupPortable;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.stream.Collectors;

// The main panel of the plugin that contains all viewing components
public class InventorySetupsPluginPanel extends PluginPanel
{

	private static ImageIcon HELP_ICON;
	private static ImageIcon HELP_HOVER_ICON;
	private static ImageIcon STANDARD_VIEW_ICON;
	private static ImageIcon STANDARD_VIEW_HOVER_ICON;
	private static ImageIcon COMPACT_VIEW_ICON;
	private static ImageIcon COMPACT_VIEW_HOVER_ICON;
	private static ImageIcon ICON_VIEW_ICON;
	private static ImageIcon ICON_VIEW_HOVER_ICON;
	private static ImageIcon SECTION_VIEW_ICON;
	private static ImageIcon SECTION_VIEW_HOVER_ICON;
	private static ImageIcon NO_SECTION_VIEW_ICON;
	private static ImageIcon NO_SECTION_VIEW_HOVER_ICON;
	private static ImageIcon ALPHABETICAL_ICON;
	private static ImageIcon ALPHABETICAL_HOVER_ICON;
	private static ImageIcon NO_ALPHABETICAL_ICON;
	private static ImageIcon NO_ALPHABETICAL_HOVER_ICON;
	private static ImageIcon ADD_ICON;
	private static ImageIcon ADD_HOVER_ICON;
	private static ImageIcon BACK_ICON;
	private static ImageIcon BACK_HOVER_ICON;
	private static ImageIcon IMPORT_ICON;
	private static ImageIcon IMPORT_HOVER_ICON;
	private static ImageIcon UPDATE_ICON;
	private static ImageIcon UPDATE_HOVER_ICON;

	private static String MAIN_TITLE;

	private final JPanel noSetupsPanel; // Panel that is displayed when there are no setups
	private final JPanel updateNewsPanel; // Panel that is displayed for plugin update/news
	private final JPanel setupDisplayPanel; // Panel that is displayed when a setup is selected
	private final JPanel overviewPanel; // Panel that is displayed during overview, contains all setups
	private final JPanel northAnchoredPanel; // Anchored panel in the north that won't scroll
	private final JScrollPane contentWrapperPane; // Panel for wrapping any content so it can scroll

	// The top panel which will have the title and add/import and change views
	private final JPanel overviewTopPanel;

	// The top panel when veiwing a setup
	private final JPanel setupTopPanel;

	private final JLabel mainTitle;
	private final JLabel setupTitle;
	private final JLabel helpButton;
	private final InventorySetupsCycleButton<InventorySetupsPanelViewID> panelViewMarker;
	private final JLabel sortingMarker;
	private final JLabel sectionViewMarker;
	private final JLabel addMarker;
	private final JLabel importMarker;
	private final JLabel updateMarker;
	private final JLabel backMarker;

	private final IconTextField searchBar;

	private final InventorySetupsInventoryPanel inventoryPanel;
	private final InventorySetupsEquipmentPanel equipmentPanel;
	@Getter
	private final InventorySetupsRunePouchPanel runePouchPanel;
	@Getter
	private final InventorySetupsBoltPouchPanel boltPouchPanel;

	private final InventorySetupsSpellbookPanel spellbookPanel;

	private final InventorySetupsAdditionalItemsPanel additionalFilteredItemsPanel;
	private final InventorySetupsNotesPanel notesPanel;

	private final JPanel updateNewsPanelWrapper;

	@Getter
	private InventorySetup currentSelectedSetup;

	private int overviewPanelScrollPosition;

	private final InventorySetupsPlugin plugin;

	@Getter
	@Setter
	private boolean hasDisplayedLayoutWarning;

	private final JPanel layoutWarningPanel;

	@Getter
	private List<InventorySetup> filteredInventorysetups;

	static
	{
		final BufferedImage helpIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/help_button.png");
		HELP_ICON = new ImageIcon(helpIcon);
		HELP_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(helpIcon, 0.53f));

		final BufferedImage sectionIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/section_mode_icon.png");
		final BufferedImage sectionIconHover = ImageUtil.luminanceOffset(sectionIcon, -150);
		SECTION_VIEW_ICON = new ImageIcon(sectionIcon);
		SECTION_VIEW_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(sectionIcon, 0.53f));

		NO_SECTION_VIEW_ICON = new ImageIcon(sectionIconHover);
		NO_SECTION_VIEW_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(sectionIconHover, -100));

		final BufferedImage standardIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/standard_mode_icon.png");
		STANDARD_VIEW_ICON = new ImageIcon(standardIcon);
		STANDARD_VIEW_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(standardIcon, -100));

		final BufferedImage compactIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/compact_mode_icon.png");
		COMPACT_VIEW_ICON = new ImageIcon(compactIcon);
		COMPACT_VIEW_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(compactIcon, 0.53f));

		final BufferedImage iconIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/icon_mode_icon.png");
		ICON_VIEW_ICON = new ImageIcon(iconIcon);
		ICON_VIEW_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(iconIcon, 0.53f));

		final BufferedImage alphabeticalIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/alphabetical_icon.png");
		final BufferedImage alphabeticalIconHover = ImageUtil.luminanceOffset(alphabeticalIcon, -150);
		ALPHABETICAL_ICON = new ImageIcon(alphabeticalIcon);
		ALPHABETICAL_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(alphabeticalIcon, 0.53f));

		NO_ALPHABETICAL_ICON = new ImageIcon(alphabeticalIconHover);
		NO_ALPHABETICAL_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(alphabeticalIconHover, -100));

		final BufferedImage addIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/add_icon.png");
		ADD_ICON = new ImageIcon(addIcon);
		ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));

		final BufferedImage importIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/import_icon.png");
		IMPORT_ICON = new ImageIcon(importIcon);
		IMPORT_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(importIcon, 0.53f));

		final BufferedImage updateIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/update_icon.png");
		UPDATE_ICON = new ImageIcon(updateIcon);
		UPDATE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(updateIcon, 0.53f));

		final BufferedImage backIcon = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/back_arrow_icon.png");
		BACK_ICON = new ImageIcon(backIcon);
		BACK_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(backIcon, 0.53f));

		MAIN_TITLE = "Inventory Setups";
	}

	public InventorySetupsPluginPanel(final InventorySetupsPlugin plugin, final ItemManager itemManager)
	{
		super(false);
		this.currentSelectedSetup = null;
		this.plugin = plugin;
		this.runePouchPanel = new InventorySetupsRunePouchPanel(itemManager, plugin);
		this.boltPouchPanel = new InventorySetupsBoltPouchPanel(itemManager, plugin);
		this.inventoryPanel = new InventorySetupsInventoryPanel(itemManager, plugin, runePouchPanel, boltPouchPanel);
		this.equipmentPanel = new InventorySetupsEquipmentPanel(itemManager, plugin);
		this.spellbookPanel = new InventorySetupsSpellbookPanel(itemManager, plugin);
		this.additionalFilteredItemsPanel = new InventorySetupsAdditionalItemsPanel(itemManager, plugin);
		this.notesPanel = new InventorySetupsNotesPanel(itemManager, plugin);
		this.noSetupsPanel = new JPanel();
		this.updateNewsPanel = new InventorySetupsUpdateNewsPanel(plugin, this);
		this.layoutWarningPanel = new InventorySetupsLayoutWarningPanel(plugin, this);
		this.setupDisplayPanel = new JPanel();
		this.overviewPanel = new JPanel();
		this.overviewTopPanel = new JPanel();
		this.overviewPanelScrollPosition = 0;
		this.filteredInventorysetups = new ArrayList<>();
		this.hasDisplayedLayoutWarning = false;

		// setup the title
		this.mainTitle = new JLabel();
		mainTitle.setText(MAIN_TITLE);
		mainTitle.setForeground(Color.WHITE);

		this.helpButton = new JLabel(HELP_ICON);
		helpButton.setToolTipText("Click for help. This button can be hidden in the config.");
		helpButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					LinkBrowser.browse(TUTORIAL_LINK);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				helpButton.setIcon(HELP_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				helpButton.setIcon(HELP_ICON);
			}
		});

		this.sortingMarker = new JLabel(ALPHABETICAL_ICON);
		sortingMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					boolean isAlphabeticalMode = plugin.getConfig().sortingMode() == InventorySetupsSortingID.ALPHABETICAL;
					plugin.toggleAlphabeticalMode(isAlphabeticalMode ? InventorySetupsSortingID.DEFAULT : InventorySetupsSortingID.ALPHABETICAL);
					updateSortingMarker();
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				boolean isAlphabeticalMode = plugin.getConfig().sortingMode() == InventorySetupsSortingID.ALPHABETICAL;
				sortingMarker.setIcon(isAlphabeticalMode ? ALPHABETICAL_HOVER_ICON : NO_ALPHABETICAL_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				boolean isAlphabeticalMode = plugin.getConfig().sortingMode() == InventorySetupsSortingID.ALPHABETICAL;
				sortingMarker.setIcon(isAlphabeticalMode ? ALPHABETICAL_ICON : NO_ALPHABETICAL_ICON);
			}
		});

		List<ImageIcon> icons = new ArrayList<>(Arrays.asList(STANDARD_VIEW_ICON, COMPACT_VIEW_ICON, ICON_VIEW_ICON));
		List<ImageIcon> hoverIcons = new ArrayList<>(Arrays.asList(STANDARD_VIEW_HOVER_ICON, COMPACT_VIEW_HOVER_ICON, ICON_VIEW_HOVER_ICON));
		List<String> tooltips = new ArrayList<>(Arrays.asList("Switch to compact mode", "Switch to icon mode", "Switch to standard mode"));
		this.panelViewMarker = new InventorySetupsCycleButton<>(plugin, InventorySetupsPanelViewID.getValues(), icons, hoverIcons, tooltips);
		Runnable r = () -> plugin.setConfigValue(CONFIG_KEY_PANEL_VIEW, panelViewMarker.getCurrentState().toString());
		this.panelViewMarker.setRunnable(r);

		JPopupMenu massImportExportMenu = new JPopupMenu();
		JMenuItem massImportSetupsMenu = new JMenuItem("Mass Import Setups");
		JMenuItem massExportSetupsMenu = new JMenuItem("Mass Export Setups");
		JMenuItem massImportSectionsMenu = new JMenuItem("Mass Import Sections");
		JMenuItem massExportSectionsMenu = new JMenuItem("Mass Export Sections");
		massImportExportMenu.add(massImportSetupsMenu);
		massImportExportMenu.add(massExportSetupsMenu);
		massImportExportMenu.add(massImportSectionsMenu);
		massImportExportMenu.add(massExportSectionsMenu);
		// set mass export/import options
		massImportSetupsMenu.addActionListener(e ->
		{
			plugin.massImportSetups();
		});
		massExportSetupsMenu.addActionListener(e ->
		{
			ArrayList<InventorySetupPortable> portables = InventorySetupPortable.convertFromListOfSetups(plugin.getInventorySetups(), plugin.getLayoutUtilities());
			plugin.massExport(portables, "Setups", "inventory_setups");
		});
		massImportSectionsMenu.addActionListener(e ->
		{
			plugin.massImportSections();
		});
		massExportSectionsMenu.addActionListener(e ->
		{
			plugin.massExport(plugin.getSections(), "Sections", "sections");
		});

		JPopupMenu singleImportExportMenu = new JPopupMenu();
		JMenuItem singleImportSetupMenu = new JMenuItem("Import setup..");
		JMenuItem singleImportSectionMenu = new JMenuItem("Import section..");
		singleImportExportMenu.add(singleImportSetupMenu);
		singleImportExportMenu.add(singleImportSectionMenu);
		// set single import options
		singleImportSetupMenu.addActionListener(e ->
		{
			plugin.importSetup();
		});
		singleImportSectionMenu.addActionListener(e ->
		{
			plugin.importSection();
		});

		this.importMarker = new JLabel(IMPORT_ICON);
		importMarker.setToolTipText("Import a new setup or section");
		importMarker.setComponentPopupMenu(massImportExportMenu);
		importMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					final Point location = MouseInfo.getPointerInfo().getLocation();
					SwingUtilities.convertPointFromScreen(location, importMarker);
					singleImportExportMenu.show(importMarker, location.x, location.y);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				importMarker.setIcon(IMPORT_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				importMarker.setIcon(IMPORT_ICON);
			}
		});

		
		// set up the add marker (+ sign)
		this.addMarker = new JLabel(ADD_ICON);
		addMarker.setToolTipText("Add new setup or section");
		final JPopupMenu addMarkerMenu = new JPopupMenu();
		final JMenuItem addMarkerAddNewSetup = new JMenuItem("Add new setup..");
		final JMenuItem addMarkerAddNewSection = new JMenuItem("Add new section..");
		addMarkerMenu.add(addMarkerAddNewSetup);
		addMarkerMenu.add(addMarkerAddNewSection);
		addMarkerAddNewSetup.addActionListener(e ->
		{
			plugin.addInventorySetup();
		});
		addMarkerAddNewSection.addActionListener(e ->
		{
			plugin.addSection();
		});

		addMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					final Point location = MouseInfo.getPointerInfo().getLocation();
					SwingUtilities.convertPointFromScreen(location, addMarker);
					addMarkerMenu.show(addMarker, location.x, location.y);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				addMarker.setIcon(ADD_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				addMarker.setIcon(ADD_ICON);
			}
		});

		this.updateMarker = new JLabel(UPDATE_ICON);
		updateMarker.setToolTipText("Update setup with current inventory and equipment");
		updateMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					plugin.updateCurrentSetup(currentSelectedSetup);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				updateMarker.setIcon(UPDATE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				updateMarker.setIcon(UPDATE_ICON);
			}
		});

		this.backMarker = new JLabel(BACK_ICON);
		backMarker.setToolTipText("Return to setups");
		backMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					redrawOverviewPanel(false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				backMarker.setIcon(BACK_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				backMarker.setIcon(BACK_ICON);
			}
		});

		this.sectionViewMarker = new JLabel(COMPACT_VIEW_ICON);
		sectionViewMarker.setToolTipText("Switch to section mode");
		sectionViewMarker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					toggleSectionMode();
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				sectionViewMarker.setIcon(plugin.getConfig().sectionMode() ? SECTION_VIEW_HOVER_ICON : NO_SECTION_VIEW_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				sectionViewMarker.setIcon(plugin.getConfig().sectionMode() ? SECTION_VIEW_ICON : NO_SECTION_VIEW_ICON);
			}
		});

		JPanel overViewMarkers = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		overViewMarkers.add(sectionViewMarker);
		overViewMarkers.add(sortingMarker);
		overViewMarkers.add(panelViewMarker);
		overViewMarkers.add(importMarker);
		overViewMarkers.add(addMarker);
		sortingMarker.setBorder(new EmptyBorder(0, 8, 0, 0));
		panelViewMarker.setBorder(new EmptyBorder(0, 8, 0, 0));
		importMarker.setBorder(new EmptyBorder(0, 8, 0, 0));
		addMarker.setBorder(new EmptyBorder(0, 8, 0, 0));

		final JPanel overviewTitleAndHelpButton = new JPanel();
		overviewTitleAndHelpButton.setLayout(new BorderLayout());
		overviewTitleAndHelpButton.add(mainTitle, BorderLayout.WEST);
		overviewTitleAndHelpButton.add(helpButton, BorderLayout.EAST);

		final JPanel setupViewMarkers = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
		setupViewMarkers.add(updateMarker);
		setupViewMarkers.add(backMarker);
		backMarker.setBorder(new EmptyBorder(0, 8, 0, 0));

		this.setupTitle = new JLabel();
		setupTitle.setForeground(Color.WHITE);
		final JPanel setupTitleAndButtons = new JPanel();
		setupTitleAndButtons.setLayout(new BorderLayout());
		setupTitleAndButtons.add(setupTitle, BorderLayout.WEST);
		setupTitleAndButtons.add(setupViewMarkers, BorderLayout.EAST);

		this.setupTopPanel = new JPanel(new BorderLayout());
		setupTopPanel.add(setupTitleAndButtons, BorderLayout.CENTER);

		// the panel on the top that holds the title and buttons
		overviewTopPanel.setLayout(new BorderLayout());
		overviewTopPanel.add(overviewTitleAndHelpButton, BorderLayout.NORTH);
		overviewTopPanel.add(Box.createRigidArea(new Dimension(0, 3)), BorderLayout.CENTER);
		overviewTopPanel.add(overViewMarkers, BorderLayout.SOUTH);

		overviewTopPanel.setVisible(true);
		setupTopPanel.setVisible(false);

		this.searchBar = new IconTextField();
		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		searchBar.setMinimumSize(new Dimension(0, 30));
		searchBar.addKeyListener(new KeyListener()
		{
			@Override
			public void keyTyped(KeyEvent e)
			{
			}

			@Override
			public void keyPressed(KeyEvent e)
			{
			}

			@Override
			public void keyReleased(KeyEvent e)
			{
				redrawOverviewPanel(true);
			}
		});
		searchBar.addClearListener(() -> redrawOverviewPanel(true));

		final JPanel topPanel = new JPanel();
		topPanel.setLayout(new BorderLayout());
		topPanel.add(overviewTopPanel, BorderLayout.NORTH);
		topPanel.add(setupTopPanel, BorderLayout.SOUTH);

		// the panel that stays at the top and doesn't scroll
		// contains the title and buttons
		this.northAnchoredPanel = new JPanel();
		northAnchoredPanel.setLayout(new BoxLayout(northAnchoredPanel, BoxLayout.Y_AXIS));
		northAnchoredPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		northAnchoredPanel.add(topPanel);
		northAnchoredPanel.add(Box.createRigidArea(new Dimension(0, 10)));
		northAnchoredPanel.add(searchBar);

		// the panel that holds the inventory and equipment panels
		final BoxLayout invEqLayout = new BoxLayout(setupDisplayPanel, BoxLayout.Y_AXIS);
		setupDisplayPanel.setLayout(invEqLayout);
		setupDisplayPanel.add(inventoryPanel);
		setupDisplayPanel.add(Box.createRigidArea(new Dimension(0, 10)));
		setupDisplayPanel.add(runePouchPanel);
		setupDisplayPanel.add(Box.createRigidArea(new Dimension(0, 10)));
		setupDisplayPanel.add(boltPouchPanel);
		setupDisplayPanel.add(Box.createRigidArea(new Dimension(0, 10)));
		setupDisplayPanel.add(equipmentPanel);
		setupDisplayPanel.add(Box.createRigidArea(new Dimension(0, 10)));
		setupDisplayPanel.add(spellbookPanel);
		setupDisplayPanel.add(Box.createRigidArea(new Dimension(0, 10)));
		setupDisplayPanel.add(additionalFilteredItemsPanel);
		setupDisplayPanel.add(Box.createRigidArea(new Dimension(0, 10)));
		setupDisplayPanel.add(notesPanel);

		// setup the error panel. It's wrapped around a normal panel
		// so it doesn't stretch to fill the parent panel
		final PluginErrorPanel errorPanel = new PluginErrorPanel();
		errorPanel.setContent("Inventory Setups", "Create an inventory setup.");
		noSetupsPanel.add(errorPanel);

		// the panel that holds the inventory panels, error panel, and the overview panel
		final JPanel contentPanel = new JPanel();
		final BoxLayout contentLayout = new BoxLayout(contentPanel, BoxLayout.Y_AXIS);
		contentPanel.setLayout(contentLayout);
		contentPanel.add(setupDisplayPanel);
		contentPanel.add(noSetupsPanel);
		contentPanel.add(overviewPanel);

		// wrapper for the main content panel to stop it from stretching
		final JPanel contentWrapper = new JPanel(new BorderLayout());
		contentWrapper.add(contentPanel, BorderLayout.NORTH);
		this.contentWrapperPane = new JScrollPane(contentWrapper);
		this.contentWrapperPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

		// Wrapper for the update news panel to stop it from stretching
		this.updateNewsPanelWrapper = new JPanel(new BorderLayout());
		updateNewsPanelWrapper.add(Box.createGlue(), BorderLayout.CENTER);
		updateNewsPanelWrapper.add(updateNewsPanel, BorderLayout.NORTH);

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		add(northAnchoredPanel, BorderLayout.NORTH);

		JPanel extraPanelsWrapper = new JPanel();
		extraPanelsWrapper.setLayout(new BoxLayout(extraPanelsWrapper, BoxLayout.Y_AXIS));
		extraPanelsWrapper.add(updateNewsPanelWrapper);
		extraPanelsWrapper.add(layoutWarningPanel);

		JPanel southPanel = new JPanel(new BorderLayout());
		southPanel.add(extraPanelsWrapper, BorderLayout.NORTH);
		southPanel.add(contentWrapperPane, BorderLayout.CENTER);

		add(southPanel, BorderLayout.CENTER);

		// make sure the invEq panel isn't visible upon startup
		setupDisplayPanel.setVisible(false);
		helpButton.setVisible(!plugin.getConfig().hideButton());
		updateSectionViewMarker();
		updatePanelViewMarker();
		updateSortingMarker();
	}

	@Override
	public void onActivate()
	{
		plugin.setNavButtonIsSelected(true);
		if (!plugin.getConfig().manualBankFilter())
		{
			plugin.doBankSearch();
		}
	}

	@Override
	public void onDeactivate()
	{
		plugin.setNavButtonIsSelected(false);
		if (plugin.getConfig().requireActivePanelFilter())
		{
			plugin.resetBankSearch();
		}
	}

	// Redraw the entire overview panel, considering the text in the search bar
	public void redrawOverviewPanel(boolean resetScrollBar)
	{
		InventorySetupUtilities.fastRemoveAll(overviewPanel);
		updateSectionViewMarker();
		updatePanelViewMarker();
		updateSortingMarker();

		filteredInventorysetups.clear();
		if (!searchBar.getText().isEmpty())
		{
			filteredInventorysetups = plugin.filterSetups(searchBar.getText());
		}
		else
		{
			filteredInventorysetups = new ArrayList<>(plugin.getInventorySetups());
			moveFavoriteSetupsToTopOfList(filteredInventorysetups);
		}

		if (plugin.getConfig().sortingMode() == InventorySetupsSortingID.ALPHABETICAL)
		{
			filteredInventorysetups.sort(Comparator.comparing(InventorySetup::getName, String.CASE_INSENSITIVE_ORDER));
		}

		layoutSetups(filteredInventorysetups);
		returnToOverviewPanel(resetScrollBar);

		showCorrectPanel();

		revalidate();
		repaint();
	}

	public InventorySetupsQuiverPanel getQuiverPanel()
	{
		return equipmentPanel.getQuiverPanel();
	}

	public void showCorrectPanel()
	{

		if (!plugin.getSavedVersionString().equals(plugin.getCurrentVersionString()))
		{
			layoutWarningPanel.setVisible(false);
			updateNewsPanelWrapper.setVisible(true);
			northAnchoredPanel.setVisible(false);
			contentWrapperPane.setVisible(false);
		}
		else if (!hasDisplayedLayoutWarning && !plugin.getCanUseLayouts() && plugin.getConfig().enableLayoutWarning())
		{
			layoutWarningPanel.setVisible(true);
			updateNewsPanelWrapper.setVisible(false);
			northAnchoredPanel.setVisible(false);
			contentWrapperPane.setVisible(false);
		}
		else
		{
			layoutWarningPanel.setVisible(false);
			updateNewsPanelWrapper.setVisible(false);
			northAnchoredPanel.setVisible(true);
			contentWrapperPane.setVisible(true);

			// We set this to true now because we only want this menu to show up on startup.
			// If someone modifies settings after startup, just continue.
			hasDisplayedLayoutWarning = true;
		}
	}

	public void moveFavoriteSetupsToTopOfList(final List<InventorySetup> setupsToAdd)
	{
		List<InventorySetup> favSetups = setupsToAdd.stream().filter(InventorySetup::isFavorite).collect(Collectors.toList());
		setupsToAdd.removeAll(favSetups);
		for (int i = favSetups.size() - 1; i >= 0; i--)
		{
			setupsToAdd.add(0, favSetups.get(i));
		}
	}

	public void refreshCurrentSetup()
	{
		if (currentSelectedSetup != null)
		{
			setCurrentInventorySetup(currentSelectedSetup, false);
		}
	}

	public void setCurrentInventorySetup(final InventorySetup inventorySetup, boolean resetScrollBar)
	{
		overviewPanelScrollPosition = contentWrapperPane.getVerticalScrollBar().getValue();
		currentSelectedSetup = inventorySetup;
		inventoryPanel.updatePanelWithSetupInformation(inventorySetup);
		runePouchPanel.updatePanelWithSetupInformation(inventorySetup);
		boltPouchPanel.updatePanelWithSetupInformation(inventorySetup);
		equipmentPanel.updatePanelWithSetupInformation(inventorySetup);
		spellbookPanel.updatePanelWithSetupInformation(inventorySetup);
		additionalFilteredItemsPanel.updatePanelWithSetupInformation(inventorySetup);
		notesPanel.updatePanelWithSetupInformation(inventorySetup);

		overviewTopPanel.setVisible(false);
		setupTopPanel.setVisible(true);

		setupDisplayPanel.setVisible(true);
		noSetupsPanel.setVisible(false);
		overviewPanel.setVisible(false);

		setupTitle.setText(inventorySetup.getName());
		helpButton.setVisible(false);
		searchBar.setVisible(false);

		// only show the rune pouch if the setup has a rune pouch
		runePouchPanel.setVisible(currentSelectedSetup.getRune_pouch() != null);
		boltPouchPanel.setVisible(currentSelectedSetup.getBoltPouch() != null);

		plugin.getClientThread().invoke(this::doHighlighting);

		if (resetScrollBar)
		{
			// reset scrollbar back to top
			setScrollBarPosition(0);
		}

		plugin.doBankSearch();

		validate();
		repaint();

	}

	public void doHighlighting()
	{
		if (currentSelectedSetup == null)
		{
			return;
		}

		if (!setupDisplayPanel.isVisible())
		{
			return;
		}

		final List<InventorySetupsItem> inv = plugin.getNormalizedContainer(InventoryID.INV);
		final List<InventorySetupsItem> eqp = plugin.getNormalizedContainer(InventoryID.WORN);

		highlightContainerPanel(inv, inventoryPanel);
		highlightContainerPanel(eqp, equipmentPanel);
		// pass spellbook a dummy container because it only needs the current selected setup
		highlightContainerPanel(null, spellbookPanel);
		plugin.getAmmoHandler().handleSpecialHighlighting(currentSelectedSetup, inv, eqp);

	}

	public void highlightContainerPanel(final List<InventorySetupsItem> container, final InventorySetupsContainerPanel containerPanel)
	{
		// if the panel is visible, check if highlighting is enabled on the setup and globally
		// if any of the two, reset the slots so they aren't highlighted
		if (!currentSelectedSetup.isHighlightDifference() || !plugin.isHighlightingAllowed())
		{
			containerPanel.resetSlotColors();
			return;
		}

		containerPanel.highlightSlots(container, currentSelectedSetup);
	}

	public void highlightInventory()
	{
		final List<InventorySetupsItem> inv = plugin.getNormalizedContainer(InventoryID.INV);
		highlightContainerPanel(inv, inventoryPanel);
	}

	public void highlightEquipment()
	{
		final List<InventorySetupsItem> eqp = plugin.getNormalizedContainer(InventoryID.WORN);
		highlightContainerPanel(eqp, equipmentPanel);
	}

	public void highlightSpellbook()
	{
		highlightContainerPanel(null, spellbookPanel);
	}

	// returns to the overview panel
	public void returnToOverviewPanel(boolean shouldResetScrollBar)
	{
		noSetupsPanel.setVisible(plugin.getInventorySetups().isEmpty() && !plugin.getConfig().sectionMode());
		overviewPanel.setVisible(!plugin.getInventorySetups().isEmpty() || plugin.getConfig().sectionMode());
		setupDisplayPanel.setVisible(false);
		overviewTopPanel.setVisible(true);
		setupTopPanel.setVisible(false);
		helpButton.setVisible(!plugin.getConfig().hideButton());
		searchBar.setVisible(true);

		if (shouldResetScrollBar)
		{
			overviewPanelScrollPosition = 0;
			setScrollBarPosition(overviewPanelScrollPosition);
		}
		else if (currentSelectedSetup != null)
		{
			setScrollBarPosition(overviewPanelScrollPosition);
		}

		currentSelectedSetup = null;

		plugin.resetBankSearch();

	}

	public boolean isStackCompareForSlotAllowed(final InventorySetupsSlotID inventoryID, final int slotId)
	{
		switch (inventoryID)
		{
			case INVENTORY:
				return inventoryPanel.isStackCompareForSlotAllowed(slotId);
			case EQUIPMENT:
				return equipmentPanel.isStackCompareForSlotAllowed(slotId);
			case ADDITIONAL_ITEMS:
				return additionalFilteredItemsPanel.isStackCompareForSlotAllowed(slotId);
			case SPELL_BOOK:
				return spellbookPanel.isStackCompareForSlotAllowed(slotId);
			default:
				return plugin.getAmmoHandler().isStackCompareForSpecialSlotAllowed(inventoryID, slotId);
		}
	}

	public void toggleSectionMode()
	{
		plugin.setConfigValue(CONFIG_KEY_SECTION_MODE, !plugin.getConfig().sectionMode());
		updateSectionViewMarker();
	}

	private void updateSectionViewMarker()
	{
		sectionViewMarker.setIcon(plugin.getConfig().sectionMode() ? SECTION_VIEW_ICON : NO_SECTION_VIEW_ICON);
		sectionViewMarker.setToolTipText("Switch to " + (plugin.getConfig().sectionMode() ? "standard mode" : "section mode"));
	}

	private void updatePanelViewMarker()
	{
		panelViewMarker.setCurrentState(plugin.getConfig().panelView());
	}

	private void updateSortingMarker()
	{
		boolean isAlphabeticalMode = plugin.getConfig().sortingMode() == InventorySetupsSortingID.ALPHABETICAL;
		sortingMarker.setIcon(isAlphabeticalMode ? ALPHABETICAL_ICON : NO_ALPHABETICAL_ICON);
		sortingMarker.setToolTipText(isAlphabeticalMode ? "Remove alphabetical sorting" : "Alphabetically sort setups");
	}

	private void setScrollBarPosition(int scrollbarValue)
	{
		validate();
		repaint();
		contentWrapperPane.getVerticalScrollBar().setValue(scrollbarValue);
	}

	// Layout setups according
	private void layoutSetups(List<InventorySetup> originalFilteredSetups)
	{
		overviewPanel.setLayout(new GridBagLayout());
		overviewPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		GridBagConstraints constraints = new GridBagConstraints();
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		if (plugin.getConfig().sectionMode())
		{
			layoutSections(originalFilteredSetups, constraints);
		}
		else
		{
			if (plugin.getConfig().panelView() == InventorySetupsPanelViewID.ICON)
			{
				// Don't pass a whitelist to indicate we want to include all of the filtered setups given
				JPanel iconGridPanel = InventorySetupsSectionPanel.createIconPanelGrid(plugin, this, originalFilteredSetups, InventorySetupsSectionPanel.MAX_ICONS_PER_ROW, null, null, true);
				overviewPanel.add(iconGridPanel, constraints);
				constraints.gridy++;
			}
			else
			{
				for (final InventorySetup setup : originalFilteredSetups)
				{
					constraints.fill = GridBagConstraints.HORIZONTAL;
					InventorySetupsPanel newPanel = null;
					if (plugin.getConfig().panelView() == InventorySetupsPanelViewID.COMPACT)
					{
						newPanel = new InventorySetupsCompactPanel(plugin, this, setup, null);
					}
					else
					{
						newPanel = new InventorySetupsStandardPanel(plugin, this, setup, null);
					}
					overviewPanel.add(newPanel, constraints);
					constraints.gridy++;

					overviewPanel.add(Box.createRigidArea(new Dimension(0, 10)), constraints);
					constraints.gridy++;
				}
			}
		}

		setupDisplayPanel.setVisible(false);
	}

	private void layoutSections(final List<InventorySetup> setups, final GridBagConstraints constraints)
	{
		Set<String> setupNamesToBeIncluded = setups.stream().map(InventorySetup::getName).collect(Collectors.toSet());
		List<InventorySetupsSection> sections = new ArrayList<>(plugin.getSections());
		if (plugin.getConfig().sortingMode() == InventorySetupsSortingID.ALPHABETICAL && plugin.getConfig().sectionSorting())
		{
			sections.sort(Comparator.comparing(InventorySetupsSection::getName));
		}
		for (final InventorySetupsSection section : sections)
		{
			// For quick look up
			Set<String> setupsInSection = plugin.getCache().getSectionSetupsMap().get(section.getName()).keySet();
			if (sectionShouldBeHidden(setupNamesToBeIncluded, setupsInSection))
			{
				continue;
			}

			boolean forceMaximization = !searchBar.getText().isEmpty();
			InventorySetupsSectionPanel sectionPanel = new InventorySetupsSectionPanel(plugin, this, section, forceMaximization, true, setupNamesToBeIncluded, setupsInSection, setups);
			overviewPanel.add(sectionPanel, constraints);
			constraints.gridy++;
			overviewPanel.add(Box.createRigidArea(new Dimension(0, 5)), constraints);
			constraints.gridy++;
		}
		// Create the bottom unassigned section
		createUnassignedSection(setups, constraints, setupNamesToBeIncluded);

	}

	private void createUnassignedSection(final List<InventorySetup> setups, final GridBagConstraints constraints, final Set<String> setupNamesToBeDisplayed)
	{
		InventorySetupsSection unassignedSection = new InventorySetupsSection("Unassigned");
		unassignedSection.setMaximized(plugin.getBooleanConfigValue(CONFIG_KEY_UNASSIGNED_MAXIMIZED));

		// For quick look up
		Set<String> setupsInSection = new HashSet<>();
		// Always output the unassigned setups in the defined order of the provided setups
		for (final InventorySetup setup : setups)
		{
			if (plugin.getCache().getSetupSectionsMap().get(setup.getName()).size() == 0)
			{
				unassignedSection.getSetups().add(setup.getName());
				setupsInSection.add(setup.getName());
			}
		}

		// don't show the unassigned section if there are no unassigned setups
		if (unassignedSection.getSetups().isEmpty() || sectionShouldBeHidden(setupNamesToBeDisplayed, setupsInSection))
		{
			return;
		}

		boolean forceMaximization = !searchBar.getText().isEmpty();

		InventorySetupsSectionPanel sectionPanel = new InventorySetupsSectionPanel(plugin, this, unassignedSection, forceMaximization, false, setupNamesToBeDisplayed, setupsInSection, setups);
		overviewPanel.add(sectionPanel, constraints);
		constraints.gridy++;
	}

	public boolean sectionShouldBeHidden(final Set<String> setupNamesToBeIncluded, final Set<String> setupsInSection)
	{
		// If the search bar is not empty, do not to show empty sections
		if (!searchBar.getText().isEmpty())
		{
			Set<String> intersection = new HashSet<>(setupsInSection);
			intersection.retainAll(setupNamesToBeIncluded);
			return intersection.isEmpty();
		}

		return false;
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import java.awt.BorderLayout;
import java.util.List;
import javax.swing.*;

import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.client.game.ItemManager;

public abstract class InventorySetupsContainerPanel extends JPanel
{

	protected ItemManager itemManager;

	protected boolean isHighlighted;

	protected final InventorySetupsPlugin plugin;

	@Getter(AccessLevel.PROTECTED)
	private final JPanel containerSlotsPanel;

	InventorySetupsContainerPanel(final ItemManager itemManager, final InventorySetupsPlugin plugin, String captionText)
	{
		this.itemManager = itemManager;
		this.plugin = plugin;
		this.isHighlighted = false;
		JPanel containerPanel = new JPanel();

		this.containerSlotsPanel = new JPanel();

		// sets up the custom container panel
		setupContainerPanel(containerSlotsPanel);

		// caption
		final JLabel caption = new JLabel(captionText);
		caption.setHorizontalAlignment(JLabel.CENTER);
		caption.setVerticalAlignment(JLabel.CENTER);

		// panel that holds the caption and any other graphics
		final JPanel captionPanel = new JPanel();
		captionPanel.add(caption);

		containerPanel.setLayout(new BorderLayout());
		containerPanel.add(captionPanel, BorderLayout.NORTH);
		containerPanel.add(containerSlotsPanel, BorderLayout.CENTER);

		add(containerPanel);
	}

	abstract public boolean isStackCompareForSlotAllowed(final int id);

	abstract public void setupContainerPanel(final JPanel containerSlotsPanel);

	abstract public void highlightSlots(final List<InventorySetupsItem> currContainer, final InventorySetup inventorySetup);

	abstract public void updatePanelWithSetupInformation(final InventorySetup setup);

	abstract public void resetSlotColors();
}

package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSection;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;

public class InventorySetupsIconPanel extends InventorySetupsPanel
{
	InventorySetupsIconPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel, InventorySetup invSetup, InventorySetupsSection section)
	{
		this(plugin, panel, invSetup, section, true);
	}

	InventorySetupsIconPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel, InventorySetup invSetup, InventorySetupsSection section, boolean allowEditable)
	{
		super(plugin, panel, invSetup, section, allowEditable);

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		//final int sizeOfImage = 33;
		//setPreferredSize(new Dimension(sizeOfImage + 4, sizeOfImage + 2));
		setPreferredSize(new Dimension(46, 42));

		JLabel imageLabel = new JLabel();
		imageLabel.setHorizontalAlignment(JLabel.CENTER);
		imageLabel.setVerticalAlignment(JLabel.CENTER);
		int itemIDForImage = invSetup.getIconID();
		// ID 0 is "Dwarf Remains" meaning setups saved before iconID was added will default to 0
		// and a picture of "Dwarf Remains" will be used. So exclude 0 as well and select a weapon
		// Since most people will probably not want Dwarf Remains as the icon...
		if (itemIDForImage <= 0)
		{
			itemIDForImage = invSetup.getEquipment().get(EquipmentInventorySlot.WEAPON.getSlotIdx()).getId();
			if (itemIDForImage <= 0)
			{
				itemIDForImage = ItemID._100GUIDE_GUIDECAKE;
			}
		}

		add(imageLabel, BorderLayout.CENTER);
		AsyncBufferedImage itemImg = plugin.getItemManager().getImage(itemIDForImage, 1, false);
		Runnable r = () ->
		{
			// Use 33 width for 5 items per row, else just used the AsyncBufferedImage if no scaling with 4
			// Might need to set a preferred width to get the exact size you want
			//Image scaledItemImg = itemImg.getScaledInstance(sizeOfImage, -1, Image.SCALE_SMOOTH);
			imageLabel.setIcon(new ImageIcon(itemImg));
			this.repaint();
		};
		itemImg.onLoaded(r); // transforms if loaded later
		r.run(); // transforms if already loaded

		imageLabel.setBorder(new EmptyBorder(2, 2, 2, 2));

		setToolTipText(invSetup.getName());
		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					panel.setCurrentInventorySetup(invSetup, true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		JMenuItem updateIcon = new JMenuItem("Update Icon..");
		updateIcon.addActionListener(e -> plugin.updateInventorySetupIcon(invSetup));
		popupMenu.add(updateIcon);
	}
}

/*
 * Copyright (c) 2022, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetupsDisplayAttributes;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsValidName;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.components.FlatTextField;

import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static inventorysetups.ui.InventorySetupsStandardPanel.DISPLAY_COLOR_HOVER_ICON;
import static inventorysetups.ui.InventorySetupsStandardPanel.DISPLAY_COLOR_ICON;

public class InventorySetupsNameActions<T extends InventorySetupsDisplayAttributes> extends JPanel
{
	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));


	public final T datum;
	private final JLabel save = new JLabel("Save");
	private final JLabel cancel = new JLabel("Cancel");
	private final JLabel edit = new JLabel("Edit");
	private final JLabel displayColorIndicator = new JLabel();
	@Getter
	private final FlatTextField nameInput = new FlatTextField();

	private final InventorySetupsValidName validNameImplementer;

	public InventorySetupsNameActions(final T datum,
										final InventorySetupsPlugin plugin,
										final InventorySetupsPluginPanel panel,
										final InventorySetupsValidName validNameImplementer,
										final JPopupMenu movePopupMenu, int maxLength,
										final Color panelColor, boolean allowEditable,
										final MouseAdapter flatTextFieldMouseAdapter)
	{
		setLayout(new BorderLayout());

		this.datum = datum;
		this.validNameImplementer = validNameImplementer;

		setBackground(panelColor);

		Color currentDisplayColor;
		if (datum.getDisplayColor() == null)
		{
			setBorder(NAME_BOTTOM_BORDER);
			currentDisplayColor = null;
		}
		else
		{
			setBorder(new CompoundBorder(
					BorderFactory.createMatteBorder(0, 0, 2, 0, datum.getDisplayColor()),
					BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR)));
			currentDisplayColor = datum.getDisplayColor();
		}

		JPanel nameActions = new JPanel(new BorderLayout(3, 0));
		nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
		nameActions.setBackground(panelColor);

		// Limit character input
		AbstractDocument doc = (AbstractDocument)nameInput.getDocument();
		doc.setDocumentFilter(new DocumentFilter()
		{
			@Override
			public void insertString(FilterBypass fb, int offset, String str, AttributeSet a) throws BadLocationException
			{
				if ((fb.getDocument().getLength() + str.length()) <= maxLength)
				{
					super.insertString(fb, offset, str, a);
				}
			}

			// Replace handles pasting
			@Override
			public void replace(FilterBypass fb, int offset, int length, String str, AttributeSet a) throws BadLocationException
			{
				if ((fb.getDocument().getLength() + str.length() - length) >= maxLength)
				{
					// If the user pastes a huge amount of text, cut it out until the maximum length is achieved
					int chars_available = maxLength - (fb.getDocument().getLength() - length);
					int chars_to_cut = str.length() - chars_available;
					str = str.substring(0, str.length() - chars_to_cut);
				}
				super.replace(fb, offset, length, str, a);
			}
		});

		// Add document listener to disable save button when the name isn't valid
		nameInput.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				updateSaveButtonDuringEditing();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				updateSaveButtonDuringEditing();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				updateSaveButtonDuringEditing();
			}
		});
		
		nameInput.getTextField().addMouseListener(flatTextFieldMouseAdapter);

		save.setVisible(false);
		save.setFont(FontManager.getRunescapeSmallFont());
		save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		save.setBackground(panelColor);
		save.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent) && save.isEnabled())
				{
					nameInput.getTextField().addMouseListener(flatTextFieldMouseAdapter);
					validNameImplementer.updateName(nameInput.getText());
					Color newDisplayColor = null;
					if (displayColorIndicator.getBorder() != null)
					{
						Color currentDisplayColor = ((MatteBorder)((CompoundBorder) displayColorIndicator.getBorder()).getInsideBorder()).getMatteColor();
						if (currentDisplayColor != JagexColors.MENU_TARGET)
						{
							newDisplayColor = currentDisplayColor;
						}
					}

					datum.setDisplayColor(newDisplayColor);

					plugin.getDataManager().updateConfig(true, true);

					nameInput.setEditable(false);
					updateNameActions(false);
					requestFocusInWindow();
					panel.redrawOverviewPanel(false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				if (save.isEnabled())
				{
					save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
				}
				else
				{
					save.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
				}
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				if (save.isEnabled())
				{
					save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
				}
				else
				{
					save.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
				}
			}
		});

		cancel.setVisible(false);
		cancel.setFont(FontManager.getRunescapeSmallFont());
		cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		cancel.setBackground(panelColor);
		cancel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					nameInput.getTextField().addMouseListener(flatTextFieldMouseAdapter);
					nameInput.setEditable(false);
					nameInput.setText(datum.getName());
					nameInput.getTextField().setCaretPosition(0);
					updateNameActions(false);
					requestFocusInWindow();
					updateDisplayColorLabel(currentDisplayColor);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}
		});

		edit.setFont(FontManager.getRunescapeSmallFont());
		edit.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		edit.setBackground(panelColor);
		edit.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					// Remove the mouse listener so clicking it doesn't exit the edit screen
					nameInput.getTextField().removeMouseListener(flatTextFieldMouseAdapter);
					nameInput.setEditable(true);
					updateNameActions(true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				edit.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				edit.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			}
		});

		nameActions.add(save, BorderLayout.EAST);
		nameActions.add(cancel, BorderLayout.WEST);
		nameActions.add(edit, BorderLayout.CENTER);

		nameInput.setText(datum.getName());
		nameInput.setBorder(null);
		nameInput.setEditable(false);
		nameInput.setBackground(panelColor);
		nameInput.setPreferredSize(new Dimension(0, 24));
		nameInput.getTextField().setForeground(Color.WHITE);
		nameInput.getTextField().setBackground(panelColor);
		nameInput.getTextField().setBorder(new EmptyBorder(0, 6, 0, 0));
		if (allowEditable)
		{
			nameInput.getTextField().setComponentPopupMenu(movePopupMenu);
		}
		nameInput.getTextField().setCaretPosition(0);

		displayColorIndicator.setToolTipText("Edit the color of the name");
		displayColorIndicator.setIcon(DISPLAY_COLOR_ICON);
		displayColorIndicator.setBackground(panelColor);
		displayColorIndicator.setVisible(false);

		// Right click menu to remove the color on the setup
		JPopupMenu displayColorMenu = new JPopupMenu();
		JMenuItem removeColor = new JMenuItem("Remove the color of the name");
		displayColorMenu.add(removeColor);
		removeColor.addActionListener(e -> updateDisplayColorLabel(null));

		displayColorIndicator.setComponentPopupMenu(displayColorMenu);

		updateDisplayColorLabel(currentDisplayColor);
		displayColorIndicator.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					plugin.openColorPicker("Choose a Display color", currentDisplayColor == null ? JagexColors.MENU_TARGET : currentDisplayColor,
							c ->
							{
								Color newColor = new Color(c.getRed(), c.getGreen(), c.getBlue(), 255);
								updateDisplayColorLabel(newColor);
							}
					);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				displayColorIndicator.setIcon(DISPLAY_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				displayColorIndicator.setIcon(DISPLAY_COLOR_ICON);
			}
		});

		final JPanel wrapper = new JPanel();
		wrapper.setBackground(panelColor);
		wrapper.setLayout(new BorderLayout());
		wrapper.add(nameInput, BorderLayout.CENTER);
		wrapper.add(displayColorIndicator, BorderLayout.WEST);
		if (allowEditable)
		{
			wrapper.add(nameActions, BorderLayout.EAST);
		}
		add(wrapper, BorderLayout.CENTER);

		// Any modifications to the name actions can be done with border layouts

	}

	private void updateNameActions(boolean saveAndCancel)
	{
		save.setVisible(saveAndCancel);
		cancel.setVisible(saveAndCancel);
		edit.setVisible(!saveAndCancel);
		displayColorIndicator.setVisible(saveAndCancel);

		if (saveAndCancel)
		{
			nameInput.getTextField().requestFocusInWindow();
			nameInput.getTextField().selectAll();
		}
	}

	private void updateDisplayColorLabel(Color color)
	{
		displayColorIndicator.setBorder(new CompoundBorder(
				new EmptyBorder(0, 4, 0, 0),
				new MatteBorder(0, 0, 3, 0, color)));

		// Update the save button
		updateSaveButtonDuringEditing();
	}

	private void updateSaveButtonDuringEditing()
	{
		Color newDisplayColor = null;
		if (displayColorIndicator.getBorder() != null)
		{
			newDisplayColor = ((MatteBorder)((CompoundBorder) displayColorIndicator.getBorder()).getInsideBorder()).getMatteColor();
		}

		if (!validNameImplementer.isNameValid(nameInput.getText(), newDisplayColor))
		{
			save.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			save.setEnabled(false);
			return;
		}

		save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		save.setEnabled(true);

	}

}

/*
 * Copyright (c) 2022, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.FontMetrics;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingConstants;
import net.runelite.client.ui.ColorScheme;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class InventorySetupsSelectionPanel
{
	private final JList<String> list;
	private ActionListener okEvent, cancelEvent;
	private final JDialog dialog;

	public InventorySetupsSelectionPanel(JPanel parent, String title, String message, String[] options)
	{
		this.list = new JList<>(options);
		this.list.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
		JLabel label = new JLabel(message);
		JLabel ctrlClickLabel = new JLabel("Ctrl + Click to select multiple");
		JPanel topLabels = new JPanel(new BorderLayout());
		label.setHorizontalAlignment(SwingConstants.CENTER);
		ctrlClickLabel.setHorizontalAlignment(SwingConstants.CENTER);
		topLabels.add(label, BorderLayout.NORTH);
		topLabels.add(ctrlClickLabel, BorderLayout.CENTER);

		JButton okButton = new JButton("Ok");
		okButton.addActionListener(this::handleOkButtonClick);

		JButton cancelButton = new JButton("Cancel");
		cancelButton.addActionListener(this::handleCancelButtonClick);

		// Center the list elements
		DefaultListCellRenderer renderer = (DefaultListCellRenderer) list.getCellRenderer();
		renderer.setHorizontalAlignment(SwingConstants.CENTER);

		JPanel panel = new JPanel(new BorderLayout(5, 5));
		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setViewportView(list);
		panel.add(topLabels, BorderLayout.NORTH);
		panel.add(scrollPane, BorderLayout.CENTER);

		// Compute width and height
		// width is based on longest option, with a maximum
		FontMetrics metrics = new FontMetrics(list.getFont())
		{

		} ;
		String longestWidthString = Arrays.stream(options).max(Comparator.comparingInt(s -> (int)Math.ceil(metrics.getStringBounds(s, null).getWidth()))).get();

		Rectangle2D bounds = metrics.getStringBounds(longestWidthString, null);
		list.setFixedCellHeight((int)Math.ceil(bounds.getHeight() + 1));
		int widthInPixels = (int)Math.ceil(bounds.getWidth()) + 25;
		int max_char_height = metrics.getMaxAscent() + metrics.getMaxDescent();
		int heightInPixels = max_char_height * options.length + 50;

		int maxHeight = 400;
		int maxWidth = 500;
		panel.setPreferredSize(new Dimension(Math.min(widthInPixels, maxWidth), Math.min(heightInPixels, maxHeight)));

		JOptionPane optionPane = new JOptionPane(panel);
		optionPane.setOptions(new Object[]{okButton, cancelButton});

		dialog = optionPane.createDialog(parent, "Select option");
		dialog.setIconImage(new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB_PRE));
		dialog.setTitle(title);
	}

	public void setOnOk(ActionListener event)
	{
		okEvent = event;
	}

	public void setOnClose(ActionListener event)
	{
		cancelEvent  = event;
	}

	private void handleOkButtonClick(ActionEvent e)
	{
		if (okEvent != null)
		{
			okEvent.actionPerformed(e);
		}
		hide();
	}

	private void handleCancelButtonClick(ActionEvent e)
	{
		if (cancelEvent != null)
		{
			cancelEvent.actionPerformed(e);
		}
		hide();
	}

	public void show()
	{
		dialog.setVisible(true);
	}

	private void hide()
	{
		dialog.setVisible(false);
	}

	public List<String> getSelectedItems()
	{
		return list.getSelectedValuesList();
	}
}
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSlotID;
import java.awt.GridLayout;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.JPanel;

import lombok.Getter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

// The panel that contains the equipment slots
public class InventorySetupsEquipmentPanel extends InventorySetupsContainerPanel
{
	private Map<EquipmentInventorySlot, InventorySetupsSlot> equipmentSlots;

	@Getter
	private InventorySetupsQuiverPanel quiverPanel;

	InventorySetupsEquipmentPanel(final ItemManager itemManager, final InventorySetupsPlugin plugin)
	{
		super(itemManager, plugin, "Equipment");
	}

	@Override
	public void setupContainerPanel(final JPanel containerSlotsPanel)
	{
		this.equipmentSlots = new HashMap<>();
		for (final EquipmentInventorySlot slot : EquipmentInventorySlot.values())
		{
			final InventorySetupsSlot setupSlot = new InventorySetupsSlot(ColorScheme.DARKER_GRAY_COLOR, InventorySetupsSlotID.EQUIPMENT, slot.getSlotIdx());
			InventorySetupsSlot.addFuzzyMouseListenerToSlot(plugin, setupSlot);

			// add stackable configurations for ammo and weapon slots
			if (slot == EquipmentInventorySlot.AMMO || slot == EquipmentInventorySlot.WEAPON)
			{
				InventorySetupsSlot.addStackMouseListenerToSlot(plugin, setupSlot);
			}

			InventorySetupsSlot.addUpdateFromContainerMouseListenerToSlot(plugin, setupSlot);
			InventorySetupsSlot.addUpdateFromSearchMouseListenerToSlot(plugin, setupSlot, true);
			InventorySetupsSlot.addRemoveMouseListenerToSlot(plugin, setupSlot);

			// Shift menu
			InventorySetupsSlot.addUpdateFromContainerToAllInstancesMouseListenerToSlot(this, plugin, setupSlot);
			InventorySetupsSlot.addUpdateFromSearchToAllInstancesMouseListenerToSlot(this, plugin, setupSlot, true);

			equipmentSlots.put(slot, setupSlot);
		}

		final GridLayout gridLayout = new GridLayout(5, 3, 1, 1);
		containerSlotsPanel.setLayout(gridLayout);

		this.quiverPanel = new InventorySetupsQuiverPanel(itemManager, plugin);

		// add the grid layouts, including invisible ones
		containerSlotsPanel.add(new InventorySetupsSlot(ColorScheme.DARK_GRAY_COLOR, InventorySetupsSlotID.EQUIPMENT, -1));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.HEAD));
		// This slot (to the right of the HEAD) is the quiver slot. It will only show up if a user has a quiver.
		containerSlotsPanel.add(quiverPanel.getQuiverSlot());
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.CAPE));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.AMULET));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.AMMO));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.WEAPON));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.BODY));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.SHIELD));
		containerSlotsPanel.add(new InventorySetupsSlot(ColorScheme.DARK_GRAY_COLOR, InventorySetupsSlotID.EQUIPMENT, -1));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.LEGS));
		containerSlotsPanel.add(new InventorySetupsSlot(ColorScheme.DARK_GRAY_COLOR, InventorySetupsSlotID.EQUIPMENT, -1));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.GLOVES));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.BOOTS));
		containerSlotsPanel.add(equipmentSlots.get(EquipmentInventorySlot.RING));

	}

	@Override
	public void updatePanelWithSetupInformation(final InventorySetup setup)
	{
		for (final EquipmentInventorySlot slot : EquipmentInventorySlot.values())
		{
			int i = slot.getSlotIdx();
			InventorySetupsSlot.setSlotImageAndText(itemManager, equipmentSlots.get(slot), setup, setup.getEquipment().get(i));
		}

		validate();
		repaint();
	}

	@Override
	public void highlightSlots(final List<InventorySetupsItem> currentEquipment, final InventorySetup inventorySetup)
	{
		final List<InventorySetupsItem> savedEquipmentFromSetup = inventorySetup.getEquipment();

		assert currentEquipment.size() == savedEquipmentFromSetup.size() : "size mismatch";

		isHighlighted = true;

		for (final EquipmentInventorySlot slot : EquipmentInventorySlot.values())
		{
			int slotIdx = slot.getSlotIdx();
			InventorySetupsSlot.highlightSlot(inventorySetup, savedEquipmentFromSetup.get(slotIdx), currentEquipment.get(slotIdx), equipmentSlots.get(slot));
		}
	}

	@Override
	public void resetSlotColors()
	{
		// Don't waste time resetting if we were never highlighted to begin with
		if (!isHighlighted)
		{
			return;
		}

		for (final EquipmentInventorySlot slot : EquipmentInventorySlot.values())
		{
			equipmentSlots.get(slot).setBackground(ColorScheme.DARKER_GRAY_COLOR);
		}

		isHighlighted = false;
	}

	public boolean isStackCompareForSlotAllowed(final int id)
	{
		return id == EquipmentInventorySlot.AMMO.getSlotIdx() || id == EquipmentInventorySlot.WEAPON.getSlotIdx();
	}
}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.util.List;
import javax.swing.AbstractAction;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.KeyStroke;
import javax.swing.border.EmptyBorder;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultCaret;
import javax.swing.text.Document;
import javax.swing.undo.CannotUndoException;
import javax.swing.undo.UndoManager;
import lombok.Setter;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

public class InventorySetupsNotesPanel extends InventorySetupsContainerPanel
{

	private JTextArea notesEditor;
	private UndoManager undoRedo;

	@Setter
	private InventorySetup currentInventorySetup;

	InventorySetupsNotesPanel(ItemManager itemManager, InventorySetupsPlugin plugin)
	{
		super(itemManager, plugin, "Notes");
	}

	@Override
	public void setupContainerPanel(JPanel containerSlotsPanel)
	{
		this.notesEditor = new JTextArea(10, 0);
		this.undoRedo = new UndoManager();
		this.currentInventorySetup = null;

		notesEditor.setTabSize(2);
		notesEditor.setLineWrap(true);
		notesEditor.setWrapStyleWord(true);
		notesEditor.setOpaque(false);

		// setting the limit to a 500 as UndoManager registers every key press,
		// which means that be default we would be able to undo only a sentence.
		// note: the default limit is 100
		undoRedo.setLimit(500);
		notesEditor.getDocument().addUndoableEditListener(e -> undoRedo.addEdit(e.getEdit()));
		notesEditor.getInputMap().put(KeyStroke.getKeyStroke("control Z"), "Undo");
		notesEditor.getInputMap().put(KeyStroke.getKeyStroke("control Y"), "Redo");

		notesEditor.getActionMap().put("Undo", new AbstractAction("Undo")
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				try
				{
					if (undoRedo.canUndo())
					{
						undoRedo.undo();
					}
				}
				catch (CannotUndoException ex)
				{
				}
			}
		});

		notesEditor.getActionMap().put("Redo", new AbstractAction("Redo")
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				try
				{
					if (undoRedo.canRedo())
					{
						undoRedo.redo();
					}
				}
				catch (CannotUndoException ex)
				{
				}
			}
		});

		notesEditor.addFocusListener(new FocusListener()
		{

			@Override
			public void focusGained(FocusEvent e)
			{

			}

			@Override
			public void focusLost(FocusEvent e)
			{
				notesChanged(getNotes());
			}

			private void notesChanged(String data)
			{
				plugin.updateNotesInSetup(currentInventorySetup, data);
			}
		});

		int width = 46 * 4 + 3;
		containerSlotsPanel.setLayout(new BorderLayout());
		containerSlotsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		containerSlotsPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		notesEditor.setSize(new Dimension(width, 200));
		containerSlotsPanel.add(notesEditor);
	}

	@Override
	public void highlightSlots(List<InventorySetupsItem> currContainer, InventorySetup inventorySetup)
	{
	}

	@Override
	public void updatePanelWithSetupInformation(InventorySetup setup)
	{
		// Set the caret to not update right before setting the text
		// this stops it from scrolling down the parent scroll pane
		DefaultCaret caret = (DefaultCaret)notesEditor.getCaret();
		caret.setUpdatePolicy(DefaultCaret.NEVER_UPDATE);
		notesEditor.setText(setup.getNotes());
		caret.setUpdatePolicy(DefaultCaret.ALWAYS_UPDATE);

		currentInventorySetup = setup;
	}

	@Override
	public void resetSlotColors()
	{
	}

	public String getNotes()
	{
		try
		{
			Document doc = notesEditor.getDocument();
			return notesEditor.getDocument().getText(0, doc.getLength());
		}
		catch (BadLocationException ex)
		{
		}

		return "getNotes() Failed";
	}

	public boolean isStackCompareForSlotAllowed(final int id)
	{
		return false;
	}
}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsAmmoHandler;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSlotID;
import inventorysetups.InventorySetupsStackCompareID;
import inventorysetups.InventorySetupsVariationMapping;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.AsyncBufferedImage;

import javax.swing.*;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class InventorySetupsSlot extends JPanel
{
	@Getter
	private final JLabel imageLabel;

	@Getter
	private final InventorySetupsSlotID slotID;

	@Getter
	@Setter
	private InventorySetup parentSetup;

	@Getter
	private int indexInSlot;

	@Getter
	private JLabel fuzzyIndicator;

	@Getter
	private JLabel stackIndicator;

	@Getter
	private JPopupMenu rightClickMenu;

	@Getter
	private JPopupMenu shiftRightClickMenu;

	public InventorySetupsSlot(Color color, InventorySetupsSlotID id, int indexInSlot)
	{
		this(color, id, indexInSlot, 46, 42);
	}

	public InventorySetupsSlot(Color color, InventorySetupsSlotID id, int indexInSlot, int width, int height)
	{
		this.slotID = id;
		this.imageLabel = new JLabel();
		this.parentSetup = null;
		this.fuzzyIndicator = new JLabel();
		this.stackIndicator = new JLabel();
		fuzzyIndicator.setFont(FontManager.getRunescapeSmallFont());
		stackIndicator.setFont(FontManager.getRunescapeSmallFont());
		this.indexInSlot = indexInSlot;
		this.rightClickMenu = new JPopupMenu();
		this.shiftRightClickMenu = new JPopupMenu();

		MouseAdapter menuAdapter = new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				showPopupMenu(e);
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				showPopupMenu(e);
			}

			private void showPopupMenu(MouseEvent e)
			{
				if (e.isPopupTrigger())
				{
					if ((e.getModifiersEx() & MouseEvent.SHIFT_DOWN_MASK) != 0)
					{
						shiftRightClickMenu.show(e.getComponent(), e.getX(), e.getY());
					}
					else
					{
						rightClickMenu.show(e.getComponent(), e.getX(), e.getY());
					}
				}
			}
		};
		this.addMouseListener(menuAdapter);
		this.imageLabel.addMouseListener(menuAdapter);

		setPreferredSize(new Dimension(width, height));
		setBackground(color);
		setLayout(new GridBagLayout());
		// Set constraints to put it in the north east (top right)
		GridBagConstraints fuzzyConstraints = new GridBagConstraints(0, 0, 1, 1, 1, 1,
																		GridBagConstraints.NORTHEAST, GridBagConstraints.NONE,
																		new Insets(0, 0, 0, 0), 0, 0);
		// Set constraints for the bottom right
		GridBagConstraints stackConstraints = new GridBagConstraints(0, 0, 1, 1, 1, 1,
																		GridBagConstraints.SOUTHEAST, GridBagConstraints.NONE,
																		new Insets(0, 0, 0, 0), 0, 0);
		add(imageLabel);
		add(fuzzyIndicator, fuzzyConstraints);
		add(stackIndicator, stackConstraints);
	}

	public void setImageLabel(String toolTip, BufferedImage itemImage, boolean isFuzzy, InventorySetupsStackCompareID stackCompare)
	{
		if (itemImage == null || toolTip == null)
		{
			imageLabel.setToolTipText("");
			imageLabel.setIcon(null);
			imageLabel.revalidate();
		}
		else
		{
			imageLabel.setToolTipText(toolTip);
			if (itemImage instanceof AsyncBufferedImage) // if the slot is a spellbook, use these
			{
				AsyncBufferedImage itemImageAsync = (AsyncBufferedImage)itemImage;
				itemImageAsync.addTo(imageLabel);
			}
			else
			{
				imageLabel.setIcon(new ImageIcon(itemImage));
			}

		}

		fuzzyIndicator.setText(isFuzzy ? "*" : "");
		stackIndicator.setText(InventorySetupsStackCompareID.getStringFromValue(stackCompare));

		validate();
		repaint();
	}

	public void setImageLabel(String toolTip, BufferedImage itemImage)
	{
		setImageLabel(toolTip, itemImage, false, InventorySetupsStackCompareID.None);
	}

	// adds the menu option to update a slot from the container it presides in
	public static void addUpdateFromContainerMouseListenerToSlot(final InventorySetupsPlugin plugin, final InventorySetupsSlot slot)
	{
		String updateContainerFrom = getContainerString(slot);
		JMenuItem updateFromContainer = new JMenuItem("Update Slot from " + updateContainerFrom);
		slot.getRightClickMenu().add(updateFromContainer);
		updateFromContainer.addActionListener(e ->
		{
			plugin.updateSlotFromContainer(slot, false);
		});
	}

	// adds the option replace all slots containing the old item with the new item in all setups
	public static void addUpdateFromContainerToAllInstancesMouseListenerToSlot(final JPanel parentPanel, final InventorySetupsPlugin plugin, final InventorySetupsSlot slot)
	{
		String updateContainerFrom = getContainerString(slot);
		JMenuItem updateFromContainer = new JMenuItem("Update ALL Slots from " + updateContainerFrom);
		slot.getShiftRightClickMenu().add(updateFromContainer);
		updateFromContainer.addActionListener(e ->
		{
			int confirm = JOptionPane.showConfirmDialog(parentPanel,
					"Do you want to update ALL setups which have this item to the new item?",
					"Update ALL Setups", JOptionPane.OK_CANCEL_OPTION);

			if (confirm == JOptionPane.YES_OPTION)
			{
				plugin.updateSlotFromContainer(slot, true);
			}
		});
	}

	// adds the menu option to update a slot from item search
	public static void addUpdateFromSearchMouseListenerToSlot(final InventorySetupsPlugin plugin, final InventorySetupsSlot slot, boolean allowStackable)
	{
		JMenuItem updateFromSearch = new JMenuItem("Update Slot from Search");
		slot.getRightClickMenu().add(updateFromSearch);
		updateFromSearch.addActionListener(e ->
		{
			plugin.updateSlotFromSearch(slot, allowStackable, false);
		});
	}

	// adds the option replace all slots containing the old item with the newly searched item in all setups
	public static void addUpdateFromSearchToAllInstancesMouseListenerToSlot(final JPanel parentPanel, final InventorySetupsPlugin plugin, final InventorySetupsSlot slot, boolean allowStackable)
	{
		JMenuItem updateFromContainer = new JMenuItem("Update ALL Slots from Search");
		slot.getShiftRightClickMenu().add(updateFromContainer);
		updateFromContainer.addActionListener(e ->
		{
			int confirm = JOptionPane.showConfirmDialog(parentPanel,
					"Do you want to update ALL setups which have this item to the new item?",
					"Update ALL Setups", JOptionPane.OK_CANCEL_OPTION);

			if (confirm == JOptionPane.YES_OPTION)
			{
				plugin.updateSlotFromSearch(slot, allowStackable, true);
			}
		});
	}

	// adds the menu option to clear a slot
	public static void addRemoveMouseListenerToSlot(final InventorySetupsPlugin plugin, final InventorySetupsSlot slot)
	{
		JMenuItem removeSlot = new JMenuItem("Remove Item from Slot");
		slot.getRightClickMenu().add(removeSlot);
		removeSlot.addActionListener(e ->
		{
			plugin.removeItemFromSlot(slot);
		});
	}

	// adds the menu option to update set a slot to fuzzy
	public static void addFuzzyMouseListenerToSlot(final InventorySetupsPlugin plugin, final InventorySetupsSlot slot)
	{
		JMenuItem makeSlotFuzzy = new JMenuItem("Toggle Fuzzy");
		slot.getRightClickMenu().add(makeSlotFuzzy);
		makeSlotFuzzy.addActionListener(e ->
		{
			plugin.toggleFuzzyOnSlot(slot);
		});
	}

	// adds the menu option to update set a slot to fuzzy
	public static void addStackMouseListenerToSlot(final InventorySetupsPlugin plugin, final InventorySetupsSlot slot)
	{
		JMenuItem stackIndicatorNone = new JMenuItem("Stack Difference None");
		stackIndicatorNone.addActionListener(e ->
		{
			plugin.setStackCompareOnSlot(slot, InventorySetupsStackCompareID.None);
		});

		JMenuItem stackIndicatorStandard = new JMenuItem("Stack Difference Standard");
		stackIndicatorStandard.addActionListener(e ->
		{
			plugin.setStackCompareOnSlot(slot, InventorySetupsStackCompareID.Standard);
		});

		JMenuItem stackIndicatorGreaterThan = new JMenuItem("Stack Difference Greater Than");
		stackIndicatorGreaterThan.addActionListener(e ->
		{
			plugin.setStackCompareOnSlot(slot, InventorySetupsStackCompareID.Greater_Than);
		});

		JMenuItem stackIndicatorLessThan = new JMenuItem("Stack Difference Less Than");
		stackIndicatorLessThan.addActionListener(e ->
		{
			plugin.setStackCompareOnSlot(slot, InventorySetupsStackCompareID.Less_Than);
		});

		JMenu stackIndicatorMainMenu = new JMenu("Stack Indicator");
		stackIndicatorMainMenu.add(stackIndicatorNone);
		stackIndicatorMainMenu.add(stackIndicatorStandard);
		stackIndicatorMainMenu.add(stackIndicatorLessThan);
		stackIndicatorMainMenu.add(stackIndicatorGreaterThan);
		slot.getRightClickMenu().add(stackIndicatorMainMenu);
	}

	public static String getContainerString(final InventorySetupsSlot slot)
	{
		String updateContainerFrom = "";
		switch (slot.getSlotID())
		{
			case INVENTORY:
				updateContainerFrom = "Inventory";
				break;
			case EQUIPMENT:
				updateContainerFrom = "Equipment";
				break;
			default:
				return InventorySetupsAmmoHandler.getSpecialContainerString(slot);
		}
		return updateContainerFrom;
	}

	// Sets the image and tooltip text for a slot
	public static void setSlotImageAndText(final ItemManager itemManager, final InventorySetupsSlot containerSlot, final InventorySetup setup, final InventorySetupsItem item)
	{
		containerSlot.setParentSetup(setup);

		if (item.getId() == -1)
		{
			containerSlot.setImageLabel(null, null, item.isFuzzy(), item.getStackCompare());
			return;
		}

		int itemId = item.getId();
		int quantity = item.getQuantity();
		final String itemName = item.getName();
		AsyncBufferedImage itemImg = itemManager.getImage(itemId, quantity, quantity > 1);
		String toolTip = itemName;
		if (quantity > 1)
		{
			toolTip += " (" + quantity + ")";
		}
		containerSlot.setImageLabel(toolTip, itemImg, item.isFuzzy(), item.getStackCompare());
	}

	// highlights the slot based on the configuration and the saved item vs item in the slot
	public static void highlightSlot(final InventorySetup setup, InventorySetupsItem savedItemFromSetup, InventorySetupsItem currentItemFromContainer, final InventorySetupsSlot containerSlot)
	{
		// important note: do not use item names for comparisons
		// they are all empty to avoid clientThread usage when highlighting

		// first check if stack differences are enabled and compare quantities
		if (shouldHighlightSlotBasedOnStack(savedItemFromSetup.getStackCompare(), savedItemFromSetup.getQuantity(), currentItemFromContainer.getQuantity()))
		{
			containerSlot.setBackground(setup.getHighlightColor());
			return;
		}

		// obtain the correct item ids using fuzzy mapping if applicable
		int currentItemId = currentItemFromContainer.getId();
		int savedItemId = savedItemFromSetup.getId();

		if (savedItemFromSetup.isFuzzy())
		{
			currentItemId = InventorySetupsVariationMapping.map(currentItemId);
			savedItemId = InventorySetupsVariationMapping.map(savedItemId);
		}

		// if the ids don't match, highlight the container slot
		if (currentItemId != savedItemId)
		{
			containerSlot.setBackground(setup.getHighlightColor());
			return;
		}

		// set the color back to the original, because they match
		containerSlot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
	}

	public static boolean shouldHighlightSlotBasedOnStack(final InventorySetupsStackCompareID stackCompareType, final Integer savedItemQty, final Integer currItemQty)
	{
		final int stackCompareResult = Integer.compare(currItemQty, savedItemQty);
		return stackCompareType == InventorySetupsStackCompareID.Less_Than && stackCompareResult < 0 ||
				stackCompareType == InventorySetupsStackCompareID.Greater_Than && stackCompareResult > 0 ||
				stackCompareType == InventorySetupsStackCompareID.Standard && stackCompareResult != 0;
	}

}

package inventorysetups.ui;

import inventorysetups.InventorySetupsPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;


// Displays a warning that layouts will not work.
public class InventorySetupsLayoutWarningPanel extends JPanel
{

	InventorySetupsLayoutWarningPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel)
	{
		final String warningText = "Inventory Setups has detected that layouts will not work with your current settings.\n\n" +
				"The Bank Tags Plugin must be ON to use bank filtering and layouts.\n\n" +
				"Inventory Setups can turn it on for you. This is recommended so you can use all features of Inventory Setups.\n\n" +
				"Hub Plugin \"Bank Tag Layouts\" is not required with Inventory Setups. If you only used it with Inventory Setups, you can safely uninstall it.\n\n" +
				"You can disable this warning in the settings.";

		JTextArea textArea = new JTextArea(2, 20);
		textArea.setText(warningText);
		textArea.setWrapStyleWord(true);
		textArea.setLineWrap(true);
		textArea.setOpaque(false);
		textArea.setEditable(false);
		textArea.setFocusable(false);
		textArea.setBackground(ColorScheme.DARK_GRAY_COLOR);
		Font textAreaFont = FontManager.getRunescapeFont();
		textAreaFont = textAreaFont.deriveFont(textAreaFont.getStyle(), (float)textAreaFont.getSize() - (float)0.1);
		textArea.setFont(textAreaFont);

		textArea.setBorder(new EmptyBorder(0, 0, 0, 0));

		final JLabel configureSettings = new JLabel("Do you want Inventory Setups to ");
		final JLabel configureSettings2 = new JLabel("change your settings to use layouts?");
		final JButton configureSettingsButton = new JButton("Turn on Bank Tags.");
		configureSettingsButton.setForeground(Color.GREEN);
		configureSettingsButton.addActionListener(e ->
		{
			plugin.enableLayouts();
			panel.setHasDisplayedLayoutWarning(true);
			panel.showCorrectPanel();
		});
		configureSettings.setFont(FontManager.getRunescapeSmallFont());
		configureSettings2.setFont(FontManager.getRunescapeSmallFont());
		configureSettings.setHorizontalAlignment(JLabel.CENTER);
		configureSettings2.setHorizontalAlignment(JLabel.CENTER);

		final JPanel configureSettingsPanelInfo = new JPanel();
		configureSettingsPanelInfo.setLayout(new BorderLayout());
		configureSettingsPanelInfo.add(configureSettings, BorderLayout.NORTH);
		configureSettingsPanelInfo.add(configureSettings2, BorderLayout.CENTER);
		configureSettingsPanelInfo.add(configureSettingsButton, BorderLayout.SOUTH);

		final JLabel noConfigureSettings = new JLabel("Use Inventory Setups without layouts.");
		final JPanel noConfigureSettingsPanel = new JPanel(new BorderLayout());
		final JButton noConfigureSettingsButton = new JButton("Do not use layouts.");
		noConfigureSettingsButton.setForeground(Color.RED);
		noConfigureSettingsButton.addActionListener(e ->
		{
			panel.setHasDisplayedLayoutWarning(true);
			panel.showCorrectPanel();
		});
		noConfigureSettings.setFont(FontManager.getRunescapeSmallFont());
		noConfigureSettings.setHorizontalAlignment(JLabel.CENTER);
		noConfigureSettingsPanel.add(noConfigureSettings, BorderLayout.NORTH);
		noConfigureSettingsPanel.add(noConfigureSettingsButton, BorderLayout.SOUTH);


		final JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.add(textArea);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 24)));
		contentPanel.add(configureSettingsPanelInfo);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 16)));
		contentPanel.add(noConfigureSettingsPanel);

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 10, 5, 10));
		add(contentPanel, BorderLayout.NORTH);
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsSection;
import inventorysetups.InventorySetupsPlugin;

import java.util.Arrays;
import java.util.List;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;

// The base class for panels that each display a setup
public class InventorySetupsPanel extends JPanel implements InventorySetupsMoveHandler<InventorySetup>
{

	protected final InventorySetupsPlugin plugin;
	protected final InventorySetupsPluginPanel panel;
	protected final InventorySetup inventorySetup;
	protected InventorySetupsSection section;
	protected final JPopupMenu popupMenu;

	InventorySetupsPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel, InventorySetup invSetup, InventorySetupsSection section)
	{
		this(plugin, panel, invSetup, section, true);
	}

	InventorySetupsPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel, InventorySetup invSetup, InventorySetupsSection section, boolean allowEditable)
	{
		this.plugin = plugin;
		this.panel = panel;
		this.inventorySetup = invSetup;
		this.section = section;

		if (allowEditable)
		{
			this.popupMenu = new InventorySetupsMoveMenu<>(plugin, panel, this, "Inventory Setup", invSetup);
		}
		else
		{
			this.popupMenu = new JPopupMenu();
		}

		JMenuItem addToSection = new JMenuItem("Add Setup to Sections..");
		popupMenu.add(addToSection);

		// If the section is not null, then add a menu to remove this setup from that section
		if (this.section != null && allowEditable)
		{
			JMenuItem removeFromSection = new JMenuItem("Remove from section");
			removeFromSection.addActionListener(e ->
			{
				plugin.removeInventorySetupFromSection(invSetup, section);
			});

			popupMenu.add(removeFromSection);
		}

		addToSection.addActionListener(e ->
		{
			if (plugin.getSections().isEmpty())
			{
				JOptionPane.showMessageDialog(panel,
					"You must create a section first",
					"No Sections to Add Setup To",
					JOptionPane.ERROR_MESSAGE);
				return;
			}

			final String[] sectionNames = plugin.getSections().stream().map(InventorySetupsSection::getName).toArray(String[]::new);
			Arrays.sort(sectionNames, String.CASE_INSENSITIVE_ORDER);
			final String message = "Select sections to add this setup to";
			final String title = "Select Sections";
			InventorySetupsSelectionPanel selectionDialog = new InventorySetupsSelectionPanel(panel, title, message, sectionNames);
			selectionDialog.setOnOk(e1 ->
			{
				List<String> selectedSections = selectionDialog.getSelectedItems();

				if (!selectedSections.isEmpty())
				{
					plugin.addSetupToSections(invSetup, selectedSections);
				}
			});
			selectionDialog.show();
		});

		JMenuItem deleteSetup = new JMenuItem("Delete Setup..");
		deleteSetup.addActionListener(e -> plugin.removeInventorySetup(inventorySetup));

		popupMenu.add(deleteSetup);
		setComponentPopupMenu(popupMenu);
	}

	@Override
	public void moveUp(final InventorySetup invSetup)
	{
		if (plugin.getConfig().sectionMode())
		{
			int invIndex = section.getSetups().indexOf(invSetup.getName());
			plugin.moveSetupWithinSection(section, invIndex, invIndex - 1);
		}
		else
		{
			int invIndex = plugin.getInventorySetups().indexOf(invSetup);
			plugin.moveSetup(invIndex, invIndex - 1);
		}

	}

	@Override
	public void moveDown(final InventorySetup invSetup)
	{
		if (plugin.getConfig().sectionMode())
		{
			int invIndex = section.getSetups().indexOf(invSetup.getName());
			plugin.moveSetupWithinSection(section, invIndex, invIndex + 1);
		}
		else
		{
			int invIndex = plugin.getInventorySetups().indexOf(invSetup);
			plugin.moveSetup(invIndex, invIndex + 1);
		}

	}

	@Override
	public void moveToTop(final InventorySetup invSetup)
	{
		if (plugin.getConfig().sectionMode())
		{
			int invIndex = section.getSetups().indexOf(invSetup.getName());
			plugin.moveSetupWithinSection(section, invIndex, 0);
		}
		else
		{
			int invIndex = plugin.getInventorySetups().indexOf(invSetup);
			plugin.moveSetup(invIndex, 0);
		}

	}

	@Override
	public void moveToBottom(final InventorySetup invSetup)
	{
		if (plugin.getConfig().sectionMode())
		{
			int invIndex = section.getSetups().indexOf(invSetup.getName());
			plugin.moveSetupWithinSection(section, invIndex, section.getSetups().size() - 1);
		}
		else
		{
			int invIndex = plugin.getInventorySetups().indexOf(invSetup);
			plugin.moveSetup(invIndex, plugin.getInventorySetups().size() - 1);
		}
	}

	@Override
	public void moveToPosition(final InventorySetup invSetup)
	{
		boolean sectionMode = plugin.getConfig().sectionMode();
		int invIndex = sectionMode ? section.getSetups().indexOf(invSetup.getName()) :
										plugin.getInventorySetups().indexOf(invSetup);
		int size = sectionMode ? section.getSetups().size() : plugin.getInventorySetups().size();

		final String posDialog = "Enter a position between 1 and " + size +
				". Current setup is in position " + (invIndex + 1) + ".";
		final String newPositionStr = JOptionPane.showInputDialog(panel,
				posDialog,
				"Move Setup",
				JOptionPane.PLAIN_MESSAGE);

		// cancel button was clicked
		if (newPositionStr == null)
		{
			return;
		}

		try
		{
			int newPosition = Integer.parseInt(newPositionStr);
			if (newPosition < 1 || newPosition > size)
			{
				JOptionPane.showMessageDialog(panel,
						"Invalid position.",
						"Move Setup Failed",
						JOptionPane.ERROR_MESSAGE);
				return;
			}

			if (sectionMode)
			{
				plugin.moveSetupWithinSection(section, invIndex, newPosition - 1);
			}
			else
			{
				plugin.moveSetup(invIndex, newPosition - 1);
			}

		}
		catch (NumberFormatException ex)
		{
			JOptionPane.showMessageDialog(panel,
					"Invalid position.",
					"Move Setup Failed",
					JOptionPane.ERROR_MESSAGE);
		}
	}

}

package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSlotID;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

import javax.swing.JPopupMenu;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;


public class InventorySetupsQuiverPanel
{
	// Shows up when a quiver is equipped or in inventory
	@Getter
	private InventorySetupsSlot quiverSlot;

	@Getter
	private final int QUIVER_SLOT_IDX = 0;

	private JPopupMenu quiverSlotRightClickMenu;
	private final JPopupMenu emptyJPopMenu = new JPopupMenu();
	private final InventorySetupsPlugin plugin;
	private final ItemManager itemManager;

	public static final List<Integer> DIZANA_QUIVER_IDS = Arrays.asList(ItemID.DIZANAS_QUIVER_CHARGED,
			ItemID.DIZANAS_QUIVER_CHARGED_TROUVER,
			ItemID.DIZANAS_QUIVER_UNCHARGED,
			ItemID.DIZANAS_QUIVER_UNCHARGED_TROUVER,
			ItemID.SKILLCAPE_MAX_DIZANAS,
			ItemID.SKILLCAPE_MAX_DIZANAS_TROUVER,
			ItemID.DIZANAS_QUIVER_INFINITE,
			ItemID.DIZANAS_QUIVER_INFINITE_TROUVER);

	public static final Set<Integer> DIZANA_QUIVER_IDS_SET = new HashSet<>(DIZANA_QUIVER_IDS);


	InventorySetupsQuiverPanel(final ItemManager itemManager, final InventorySetupsPlugin plugin)
	{
		this.plugin = plugin;
		this.itemManager = itemManager;
		quiverSlot = new InventorySetupsSlot(ColorScheme.DARKER_GRAY_COLOR, InventorySetupsSlotID.QUIVER, QUIVER_SLOT_IDX);
		InventorySetupsSlot.addFuzzyMouseListenerToSlot(plugin, quiverSlot);
		InventorySetupsSlot.addStackMouseListenerToSlot(plugin, quiverSlot);
		InventorySetupsSlot.addUpdateFromContainerMouseListenerToSlot(plugin, quiverSlot);
		InventorySetupsSlot.addUpdateFromSearchMouseListenerToSlot(plugin, quiverSlot, true);
		InventorySetupsSlot.addRemoveMouseListenerToSlot(plugin, quiverSlot);
		this.quiverSlotRightClickMenu = quiverSlot.getRightClickMenu();
		quiverSlot.setComponentPopupMenu(new JPopupMenu());
	}

	public void handleQuiverHighlighting(final InventorySetup setup, boolean doesCurrentInventoryHaveQuiver)
	{
		this.quiverSlot.setParentSetup(setup);
		// This must be run on the client thread!
		if (setup.getQuiver() != null)
		{
			InventorySetupsSlot.setSlotImageAndText(itemManager, quiverSlot, setup, setup.getQuiver().get(0));
			quiverSlot.setComponentPopupMenu(quiverSlotRightClickMenu);

			if (!setup.isHighlightDifference() || !plugin.isHighlightingAllowed())
			{
				quiverSlot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
			else if (doesCurrentInventoryHaveQuiver)
			{
				List<InventorySetupsItem> currentQuiverDataInInvEqp = plugin.getAmmoHandler().getQuiverData();
				final int indexInSlot = quiverSlot.getIndexInSlot();
				InventorySetupsSlot.highlightSlot(setup, setup.getQuiver().get(indexInSlot), currentQuiverDataInInvEqp.get(indexInSlot), quiverSlot);
			}
			else
			{
				quiverSlot.setBackground(setup.getHighlightColor());
			}
		}
		else
		{
			InventorySetupsSlot.setSlotImageAndText(itemManager, quiverSlot, setup, InventorySetupsItem.getDummyItem());
			quiverSlot.setBackground(ColorScheme.DARK_GRAY_COLOR);
			quiverSlot.setComponentPopupMenu(emptyJPopMenu);
		}
	}


}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSlotID;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

// The additional filtered items panel that contains the additional filtered items list
public class InventorySetupsAdditionalItemsPanel extends InventorySetupsContainerPanel
{
	private final List<InventorySetupsSlot> additionalFilteredSlots;

	InventorySetupsAdditionalItemsPanel(ItemManager itemManager, InventorySetupsPlugin plugin)
	{
		super(itemManager, plugin, "Additional Filtered Items");
		additionalFilteredSlots = new ArrayList<>();
	}

	@Override
	public void setupContainerPanel(JPanel containerSlotsPanel)
	{
		containerSlotsPanel.setLayout(new GridLayout(0, 4, 1, 1));
	}

	@Override
	public void highlightSlots(List<InventorySetupsItem> currContainer, InventorySetup inventorySetup)
	{
		// No highlighting for this panel
	}

	@Override
	public void updatePanelWithSetupInformation(InventorySetup setup)
	{
		final Map<Integer, InventorySetupsItem> setupAdditionalItems = setup.getAdditionalFilteredItems();
		final JPanel containerSlotsPanel = this.getContainerSlotsPanel();

		// Make final size a multiple of 4
		int totalNumberOfSlots = setupAdditionalItems.size();
		int remainder = totalNumberOfSlots % 4;
		if (totalNumberOfSlots % 4 != 0)
		{
			totalNumberOfSlots = totalNumberOfSlots + 4 - remainder;
		}

		// saturated the row, increase it now
		if (totalNumberOfSlots == setupAdditionalItems.size())
		{
			totalNumberOfSlots += 4;
		}

		// new component creation must be on event dispatch thread, hence invoke later
		final int totalNumberOfSlotsLambda = totalNumberOfSlots;
		SwingUtilities.invokeLater(() ->
		{

			// add new slots if the final size is larger than the number of slots
			for (int i = additionalFilteredSlots.size(); i < totalNumberOfSlotsLambda; i++)
			{
				final InventorySetupsSlot newSlot = new InventorySetupsSlot(ColorScheme.DARKER_GRAY_COLOR, InventorySetupsSlotID.ADDITIONAL_ITEMS, i);
				InventorySetupsSlot.addFuzzyMouseListenerToSlot(plugin, newSlot);
				InventorySetupsSlot.addUpdateFromSearchMouseListenerToSlot(plugin, newSlot, false);
				InventorySetupsSlot.addRemoveMouseListenerToSlot(plugin, newSlot);
				additionalFilteredSlots.add(newSlot);
			}

			// remove the extra slots from the layout if needed so the panel fits as small as possible
			for (int i = containerSlotsPanel.getComponentCount() - 1; i >= totalNumberOfSlotsLambda; i--)
			{
				containerSlotsPanel.remove(i);
			}

			// remove the images and tool tips for the inventory slots that are not part of this setup
			for (int i = totalNumberOfSlotsLambda - 1; i >= setupAdditionalItems.size(); i--)
			{
				InventorySetupsSlot.setSlotImageAndText(itemManager, additionalFilteredSlots.get(i), setup, InventorySetupsItem.getDummyItem());
			}

			// add slots back to the layout if we need to
			for (int i = containerSlotsPanel.getComponentCount(); i < totalNumberOfSlotsLambda; i++)
			{
				containerSlotsPanel.add(additionalFilteredSlots.get(i));
			}

			// finally set the slots with the items and tool tips
			int j = 0;
			for (final Integer itemId : setupAdditionalItems.keySet())
			{
				InventorySetupsSlot.setSlotImageAndText(itemManager, additionalFilteredSlots.get(j), setup, setupAdditionalItems.get(itemId));
				j++;
			}

			validate();
			repaint();
		});

	}

	@Override
	public void resetSlotColors()
	{
	}

	public boolean isStackCompareForSlotAllowed(final int id)
	{
		return false;
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSlotID;
import java.awt.GridLayout;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;


public class InventorySetupsSpellbookPanel extends InventorySetupsContainerPanel
{

	private InventorySetupsSlot spellbookSlot;
	private List<BufferedImage> spellbookImages;

	InventorySetupsSpellbookPanel(ItemManager itemManager, InventorySetupsPlugin plugin)
	{
		super(itemManager, plugin, "Spellbook");
		spellbookImages = new ArrayList<>();

		plugin.getClientThread().invokeLater(() ->
		{

			BufferedImage standardSpellbook = plugin.getSpriteManager().getSprite(SpriteID.SideiconsInterface.MAGIC, 0);
			BufferedImage ancientsSpellbook = plugin.getSpriteManager().getSprite(SpriteID.SideiconsInterface.SPELLBOOK_ANCIENT_MAGICKS, 0);
			BufferedImage lunarSpellbook = plugin.getSpriteManager().getSprite(SpriteID.SideiconsInterface.SPELLBOOK_LUNAR, 0);
			BufferedImage arceuusSpellbook = plugin.getSpriteManager().getSprite(SpriteID.SideiconsInterface.SPELLBOOK_ARCEUUS, 0);
			BufferedImage noneSpellbook = null;

			// might be null depending on game state
			if (standardSpellbook == null || ancientsSpellbook == null || lunarSpellbook == null || arceuusSpellbook == null)
			{
				return false;
			}

			spellbookImages.add(standardSpellbook);
			spellbookImages.add(ancientsSpellbook);
			spellbookImages.add(lunarSpellbook);
			spellbookImages.add(arceuusSpellbook);
			spellbookImages.add(noneSpellbook);

			return true;
		});

	}

	@Override
	public void setupContainerPanel(JPanel containerSlotsPanel)
	{
		final GridLayout gridLayout = new GridLayout(1, 2, 3, 1);
		containerSlotsPanel.setLayout(gridLayout);

		spellbookSlot = new InventorySetupsSlot(ColorScheme.DARKER_GRAY_COLOR, InventorySetupsSlotID.SPELL_BOOK, 0);

		// add options to easily change spellbook without having to do it manually in game
		JPopupMenu popupMenu = new JPopupMenu();
		JMenuItem updateToStandard = new JMenuItem("Update Slot to Standard");
		JMenuItem updateToAncient = new JMenuItem("Update Slot to Ancient");
		JMenuItem updateToLunar = new JMenuItem("Update Slot to Lunar");
		JMenuItem updateToArceuus = new JMenuItem("Update Slot to Arceuus");
		JMenuItem updateToNone = new JMenuItem("Update Slot to None");

		popupMenu.add(updateToStandard);
		popupMenu.add(updateToAncient);
		popupMenu.add(updateToLunar);
		popupMenu.add(updateToArceuus);
		popupMenu.add(updateToNone);

		for (int i = 0; i < 5; i++)
		{
			JMenuItem item = (JMenuItem)popupMenu.getComponent(i);
			final int newSpellbook = i;
			item.addActionListener(e ->
			{
				plugin.updateSpellbookInSetup(newSpellbook);
			});
		}

		spellbookSlot.setComponentPopupMenu(popupMenu);
		spellbookSlot.getImageLabel().setComponentPopupMenu(popupMenu);
		containerSlotsPanel.add(spellbookSlot);
	}

	@Override
	public void highlightSlots(List<InventorySetupsItem> currContainer, InventorySetup inventorySetup)
	{
		plugin.getClientThread().invokeLater(() ->
		{
			if (inventorySetup.getSpellBook() != 4 && inventorySetup.getSpellBook() != plugin.getCurrentSpellbook())
			{
				spellbookSlot.setBackground(inventorySetup.getHighlightColor());
			}
			else
			{
				resetSlotColors();
			}
		});
	}

	@Override
	public void updatePanelWithSetupInformation(InventorySetup setup)
	{
		/* 0 = Standard
		   1 = Ancient
		   2 = Lunar
		   3 = Arceuus */
		String spellbookStr = "";
		switch (setup.getSpellBook())
		{
			case 0:
				spellbookStr = "Standard";
				break;
			case 1:
				spellbookStr = "Ancient";
				break;
			case 2:
				spellbookStr = "Lunar";
				break;
			case 3:
				spellbookStr = "Arceuus";
				break;
			case 4:
				spellbookStr = "None";
				break;
			default:
				spellbookStr = "Incorrect";
				break;
		}

		spellbookSlot.setImageLabel(spellbookStr + " Spellbook", spellbookImages.get(setup.getSpellBook()));

		validate();
		repaint();
	}

	@Override
	public void resetSlotColors()
	{
		spellbookSlot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
	}

	public boolean isStackCompareForSlotAllowed(final int id)
	{
		return false;
	}

}

package inventorysetups.ui;

import inventorysetups.InventorySetupsPlugin;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSeparator;
import javax.swing.JTextArea;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;

import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;

import static inventorysetups.InventorySetupsPlugin.SUGGESTION_LINK;
import static inventorysetups.InventorySetupsPlugin.TUTORIAL_LINK;

public class InventorySetupsUpdateNewsPanel extends JPanel
{

	private static final String DONATION_LINK = "https://www.buymeacoffee.com/dillydill123";

	InventorySetupsUpdateNewsPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel)
	{
		final JLabel welcomeText = new JLabel("Inventory Setups " + plugin.getCurrentVersionString());
		welcomeText.setFont(FontManager.getRunescapeBoldFont());
		welcomeText.setHorizontalAlignment(JLabel.CENTER);

		final JPanel welcomePanel = new JPanel(new BorderLayout());
		welcomePanel.add(welcomeText, BorderLayout.NORTH);

		final JPanel latestUpdatePanelInfo = getLatestUpdateInfoPanel();

		final JLabel newUser = new JLabel("Are you a new user?");
		final JLabel newUser2 = new JLabel("For help and support, click here");
		final JButton linkToHelp = new JButton("View Guide");
		linkToHelp.addActionListener(e ->
		{
			LinkBrowser.browse(TUTORIAL_LINK);
		});
		newUser.setFont(FontManager.getRunescapeSmallFont());
		newUser2.setFont(FontManager.getRunescapeSmallFont());
		newUser.setHorizontalAlignment(JLabel.CENTER);
		newUser2.setHorizontalAlignment(JLabel.CENTER);

		final JPanel newUserPanelInfo = new JPanel();
		newUserPanelInfo.setLayout(new BorderLayout());
		newUserPanelInfo.add(newUser, BorderLayout.NORTH);
		newUserPanelInfo.add(newUser2, BorderLayout.CENTER);
		newUserPanelInfo.add(linkToHelp, BorderLayout.SOUTH);

		final JLabel suggestions = new JLabel("Have a suggestion? Found a bug?");
		final JLabel suggestions2 = new JLabel("Click here to create an issue");
		final JButton linkToSuggestion = new JButton("Make a Suggestion");
		linkToSuggestion.addActionListener(e ->
		{
			LinkBrowser.browse(SUGGESTION_LINK);
		});
		suggestions.setFont(FontManager.getRunescapeSmallFont());
		suggestions2.setFont(FontManager.getRunescapeSmallFont());
		suggestions.setHorizontalAlignment(JLabel.CENTER);
		suggestions2.setHorizontalAlignment(JLabel.CENTER);

		final JPanel suggestionPanelInfo = new JPanel();
		suggestionPanelInfo.setLayout(new BorderLayout());
		suggestionPanelInfo.add(suggestions, BorderLayout.NORTH);
		suggestionPanelInfo.add(suggestions2, BorderLayout.CENTER);
		suggestionPanelInfo.add(linkToSuggestion, BorderLayout.SOUTH);

		final JPanel closePanel = new JPanel(new BorderLayout());
		final JButton returnToSetups = new JButton("Return to Setups");
		returnToSetups.addActionListener(e ->
		{
			plugin.setSavedVersionString(plugin.getCurrentVersionString());
			panel.showCorrectPanel();
		});
		final JLabel clickButtonToLeave = new JLabel("Click here to hide this window");
		final JLabel clickButtonToLeave2 = new JLabel("until the next update");
		clickButtonToLeave.setFont(FontManager.getRunescapeSmallFont());
		clickButtonToLeave2.setFont(FontManager.getRunescapeSmallFont());
		clickButtonToLeave.setHorizontalAlignment(JLabel.CENTER);
		clickButtonToLeave2.setHorizontalAlignment(JLabel.CENTER);
		closePanel.add(clickButtonToLeave, BorderLayout.NORTH);
		closePanel.add(clickButtonToLeave2, BorderLayout.CENTER);
		closePanel.add(returnToSetups, BorderLayout.SOUTH);

		final JLabel donations = new JLabel("Want to make a donation?");
		final JLabel donations2 = new JLabel("Click here to buy me a coffee");
		final JButton linkToDonations = new JButton("Donate");
		linkToDonations.addActionListener(e ->
		{
			LinkBrowser.browse(DONATION_LINK);
		});
		donations.setFont(FontManager.getRunescapeSmallFont());
		donations2.setFont(FontManager.getRunescapeSmallFont());
		donations.setHorizontalAlignment(JLabel.CENTER);
		donations2.setHorizontalAlignment(JLabel.CENTER);

		final JPanel donationPanelInfo = new JPanel();
		donationPanelInfo.setLayout(new BorderLayout());
		donationPanelInfo.add(donations, BorderLayout.NORTH);
		donationPanelInfo.add(donations2, BorderLayout.CENTER);
		donationPanelInfo.add(linkToDonations, BorderLayout.SOUTH);

		final JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.add(welcomePanel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		contentPanel.add(latestUpdatePanelInfo);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		contentPanel.add(closePanel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		contentPanel.add(newUserPanelInfo);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		contentPanel.add(suggestionPanelInfo);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		contentPanel.add(donationPanelInfo);

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(5, 10, 5, 10));
		add(contentPanel, BorderLayout.NORTH);
	}


	private JPanel getLatestUpdateInfoPanel()
	{
		final JLabel patchNotesLabel = new JLabel("Patch Notes");
		patchNotesLabel.setFont(FontManager.getRunescapeSmallFont());
		patchNotesLabel.setHorizontalAlignment(JLabel.CENTER);

		final JPanel patchTitlePanel = new JPanel(new BorderLayout());
		patchTitlePanel.add(patchNotesLabel, BorderLayout.NORTH);

		String updateText =	"Added a config option for bottom to top ZigZag layouts.\n\n" +
							"Hotkeys are now disabled during chat box inputs (bank searches, PMs, etc.) by default. A new config option has been added to revert this.\n\n" +
							"Fixed some issues with fuzzy items adding a placeholder incorrectly.\n\n" +
							"As a reminder, layouts can be reset by right clicking the \"Show worn items\" button in the bank and navigating to \"Auto Layout\". Items can be moved freely in layouts without affecting their real positions in the bank.";

		JTextArea textArea = new JTextArea(2, 20);
		textArea.setText(updateText);
		textArea.setWrapStyleWord(true);
		textArea.setLineWrap(true);
		textArea.setOpaque(false);
		textArea.setEditable(false);
		textArea.setFocusable(false);
		textArea.setBackground(ColorScheme.DARK_GRAY_COLOR);
		Font textAreaFont = FontManager.getRunescapeSmallFont();
		textAreaFont = textAreaFont.deriveFont(textAreaFont.getStyle(), (float)textAreaFont.getSize() - (float)0.1);
		textArea.setFont(textAreaFont);

		textArea.setBorder(new EmptyBorder(0, 0, 0, 0));

		final JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.add(patchTitlePanel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 3)));
		contentPanel.add(getJSeparator(ColorScheme.LIGHT_GRAY_COLOR));
		contentPanel.add(Box.createRigidArea(new Dimension(0, 3)));
		contentPanel.add(textArea);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 3)));
		contentPanel.add(getJSeparator(ColorScheme.LIGHT_GRAY_COLOR));

		final JPanel updatePanel = new JPanel(new BorderLayout());
		updatePanel.add(contentPanel, BorderLayout.CENTER);

		// DO NOT TOUCH - For some reason this stops the panel from expanding
		updatePanel.getPreferredSize();

		return updatePanel;
	}

	private JSeparator getJSeparator(Color color)
	{
		JSeparator sep = new JSeparator();
		sep.setBackground(color);
		sep.setForeground(color);
		return sep;
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetupsPlugin;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.SwingUtilities;
import lombok.Setter;

// Implementation of a cycle button which provides a way to cycle through multiple states in one button (JLabel)
// When clicked, the cycle button will properly set the icons, tooltips, and execute the provided runnable for any necessary logic
public class InventorySetupsCycleButton<T> extends JLabel
{
	private final InventorySetupsPlugin plugin;
	private final List<T> states;
	private final List<ImageIcon> icons;
	private final List<ImageIcon> hoverIcons;
	private final List<String> tooltips;
	@Setter
	private int currentIndex;
	private MouseAdapter runnableAdapter;

	InventorySetupsCycleButton(final InventorySetupsPlugin plugin, final List<T> states,
							final List<ImageIcon> icons, final List<ImageIcon> hoverIcons,
							final List<String> tooltips)
	{
		this(plugin, states, icons, hoverIcons, tooltips, () ->
		{

		});
	}

	InventorySetupsCycleButton(final InventorySetupsPlugin plugin, final List<T> states,
								final List<ImageIcon> icons, final List<ImageIcon> hoverIcons,
								final List<String> tooltips, final Runnable runnable)
	{
		super();
		this.plugin = plugin;
		this.states = states;
		this.icons = icons;
		this.hoverIcons = hoverIcons;
		this.tooltips = tooltips;
		this.currentIndex = 0;

		// sizes must be equal
		assert this.states.size() == this.icons.size();
		assert this.icons.size() == this.hoverIcons.size();
		assert this.hoverIcons.size() == this.tooltips.size();

		setRunnable(runnable);
	}

	public void setCurrentState(final T state)
	{
		for (int i = 0; i < this.states.size(); i++)
		{
			if (this.states.get(i) == state)
			{
				this.currentIndex = i;
				break;
			}
		}
		setIcon(icons.get(currentIndex));
		setToolTipText(tooltips.get(currentIndex));
	}

	public void setRunnable(final Runnable r)
	{
		removeMouseListener(runnableAdapter);
		this.runnableAdapter = new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					currentIndex = (currentIndex + 1) % states.size();
					r.run();
					setToolTipText(tooltips.get(currentIndex));
					setIcon(icons.get(currentIndex));
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				setIcon(hoverIcons.get(currentIndex));
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				setIcon(icons.get(currentIndex));
			}
		};
		addMouseListener(runnableAdapter);
	}

	public T getCurrentState()
	{
		return states.get(this.currentIndex);
	}
}

/*
 * Copyright (c) 2022, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSortingID;

import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;

public class InventorySetupsMoveMenu<T> extends JPopupMenu
{
	private final InventorySetupsPluginPanel panel;
	private final InventorySetupsPlugin plugin;

	public InventorySetupsMoveMenu(final InventorySetupsPlugin plugin, final InventorySetupsPluginPanel panel, InventorySetupsMoveHandler<T> moveHandler, final String type, final T datum)
	{
		this.panel = panel;
		this.plugin = plugin;
		JMenuItem moveUp = new JMenuItem("Move " + type + " Up");
		JMenuItem moveDown = new JMenuItem("Move " + type + " Down");
		JMenuItem moveToTop = new JMenuItem("Move " + type + " to Top");
		JMenuItem moveToBottom = new JMenuItem("Move " + type + " to Bottom");
		JMenuItem moveToPosition = new JMenuItem("Move " + type + " to Position..");
		add(moveUp);
		add(moveDown);
		add(moveToTop);
		add(moveToBottom);
		add(moveToPosition);

		moveUp.addActionListener(e ->
		{
			if (!checkSortingMode())
			{
				return;
			}
			moveHandler.moveUp(datum);
		});

		moveDown.addActionListener(e ->
		{
			if (!checkSortingMode())
			{
				return;
			}
			moveHandler.moveDown(datum);
		});

		moveToTop.addActionListener(e ->
		{
			if (!checkSortingMode())
			{
				return;
			}
			moveHandler.moveToTop(datum);
		});
		moveToBottom.addActionListener(e ->
		{
			if (!checkSortingMode())
			{
				return;
			}
			moveHandler.moveToBottom(datum);
		});
		moveToPosition.addActionListener(e ->
		{
			if (!checkSortingMode())
			{
				return;
			}
			moveHandler.moveToPosition(datum);
		});

	}

	private boolean checkSortingMode()
	{
		if (plugin.getConfig().sortingMode() != InventorySetupsSortingID.DEFAULT)
		{
			JOptionPane.showMessageDialog(panel,
					"You cannot move this while a sorting mode is enabled.",
					"Move Failed",
					JOptionPane.ERROR_MESSAGE);
			return false;
		}

		return true;
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSlotID;
import inventorysetups.InventorySetupsVariationMapping;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.JPanel;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

// The panel that contains the inventory slots
public class InventorySetupsInventoryPanel extends InventorySetupsContainerPanel
{

	private static final int ITEMS_PER_ROW = 4;
	private static final int NUM_INVENTORY_ITEMS = 28;

	private List<InventorySetupsSlot> inventorySlots;
	private final InventorySetupsRunePouchPanel runePouchPanel;
	private final InventorySetupsBoltPouchPanel boltPouchPanel;

	InventorySetupsInventoryPanel(final ItemManager itemManager, final InventorySetupsPlugin plugin,
									final InventorySetupsRunePouchPanel runePouchPanel,
									final InventorySetupsBoltPouchPanel boltPouchPanel)
	{
		super(itemManager, plugin, "Inventory");
		this.runePouchPanel = runePouchPanel;
		this.boltPouchPanel = boltPouchPanel;
	}

	@Override
	public void setupContainerPanel(final JPanel containerSlotsPanel)
	{
		this.inventorySlots = new ArrayList<>();
		for (int i = 0; i < NUM_INVENTORY_ITEMS; i++)
		{
			inventorySlots.add(new InventorySetupsSlot(ColorScheme.DARKER_GRAY_COLOR, InventorySetupsSlotID.INVENTORY, i));
		}

		int numRows = (NUM_INVENTORY_ITEMS + ITEMS_PER_ROW - 1) / ITEMS_PER_ROW;
		containerSlotsPanel.setLayout(new GridLayout(numRows, ITEMS_PER_ROW, 1, 1));
		for (int i = 0; i < NUM_INVENTORY_ITEMS; i++)
		{
			containerSlotsPanel.add(inventorySlots.get(i));
			InventorySetupsSlot.addFuzzyMouseListenerToSlot(plugin, inventorySlots.get(i));
			InventorySetupsSlot.addStackMouseListenerToSlot(plugin, inventorySlots.get(i));
			InventorySetupsSlot.addUpdateFromContainerMouseListenerToSlot(plugin, inventorySlots.get(i));
			InventorySetupsSlot.addUpdateFromSearchMouseListenerToSlot(plugin, inventorySlots.get(i), true);
			InventorySetupsSlot.addRemoveMouseListenerToSlot(plugin, inventorySlots.get(i));

			// Shift menu
			InventorySetupsSlot.addUpdateFromContainerToAllInstancesMouseListenerToSlot(this, plugin, inventorySlots.get(i));
			InventorySetupsSlot.addUpdateFromSearchToAllInstancesMouseListenerToSlot(this, plugin, inventorySlots.get(i), true);
		}
	}

	@Override
	public void updatePanelWithSetupInformation(final InventorySetup setup)
	{
		for (int i = 0; i < NUM_INVENTORY_ITEMS; i++)
		{
			InventorySetupsSlot.setSlotImageAndText(itemManager, inventorySlots.get(i), setup, setup.getInventory().get(i));
		}

		validate();
		repaint();
	}

	@Override
	public void highlightSlots(final List<InventorySetupsItem> currInventory, final InventorySetup inventorySetup)
	{
		final List<InventorySetupsItem> inventoryToCheck = inventorySetup.getInventory();

		assert currInventory.size() == inventoryToCheck.size() : "size mismatch";

		isHighlighted = true;

		if (inventorySetup.isUnorderedHighlight())
		{
			doUnorderedHighlighting(currInventory, inventorySetup);
			return;
		}

		for (int i = 0; i < NUM_INVENTORY_ITEMS; i++)
		{
			InventorySetupsSlot.highlightSlot(inventorySetup, inventoryToCheck.get(i), currInventory.get(i), inventorySlots.get(i));
		}
	}

	@Override
	public void resetSlotColors()
	{
		// Don't waste time resetting if we were never highlighted to begin with
		if (!isHighlighted)
		{
			return;
		}

		for (InventorySetupsSlot inventorySlot : inventorySlots)
		{
			inventorySlot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		}

		runePouchPanel.resetSlotColors();
		boltPouchPanel.resetSlotColors();

		isHighlighted = false;
	}

	public boolean isStackCompareForSlotAllowed(final int id)
	{
		return true;
	}

	private void doUnorderedHighlighting(final List<InventorySetupsItem> currInventory, final InventorySetup inventorySetup)
	{
		Map<Integer, List<Integer>> currentInventoryMapping = new HashMap<>();

		// collect items in current inventory in the form of a Map -> List of stack sizes
		for (final InventorySetupsItem item : currInventory)
		{
			List<Integer> currentItemList = currentInventoryMapping.get(item.getId());
			if (currentItemList == null)
			{
				currentItemList = new ArrayList<>();
				currentInventoryMapping.put(item.getId(), currentItemList);
			}
			currentItemList.add(item.getQuantity());
		}

		final List<InventorySetupsItem> setupInventory = inventorySetup.getInventory();

		List<Boolean> processedInventoryItems = new ArrayList<>(Arrays.asList(new Boolean[setupInventory.size()]));
		Collections.fill(processedInventoryItems, Boolean.FALSE);

		// First process non fuzzy exact items, then fuzzy exact items
		processExactItems(inventorySetup, currentInventoryMapping, processedInventoryItems, false);
		processExactItems(inventorySetup, currentInventoryMapping, processedInventoryItems, true);

		// now process any items left which may use fuzzy mappings
		for (int i = 0; i < setupInventory.size(); i++)
		{
			// the item was already processed above using exact match
			if (processedInventoryItems.get(i))
			{
				continue;
			}

			final InventorySetupsItem savedItemFromInventory = setupInventory.get(i);

			// Exact items have been handled, try to find fuzzy items
			int savedItemId = savedItemFromInventory.getId();
			List<Integer> currentItemListForSpecificId = currentInventoryMapping.get(savedItemId);
			if (currentItemListForSpecificId == null && savedItemFromInventory.isFuzzy()) // item list should always return null, exact matches handled above
			{
				// if the item is fuzzy, attempt to find a suitable item
				for (final int currentItemIdFromMapping : currentInventoryMapping.keySet())
				{
					if (InventorySetupsVariationMapping.map(currentItemIdFromMapping) == InventorySetupsVariationMapping.map(savedItemId))
					{
						currentItemListForSpecificId = currentInventoryMapping.get(currentItemIdFromMapping);
						savedItemId = currentItemIdFromMapping; // Needed to delete the correct list later
						break;
					}
				}
			}

			// if we could not find a item Id that is sufficient for that item, highlight it
			if (currentItemListForSpecificId == null)
			{
				inventorySlots.get(i).setBackground(inventorySetup.getHighlightColor());
				continue;
			}

			updateCurrentUnorderedSlot(savedItemId, inventorySetup, inventorySlots.get(i), savedItemFromInventory, currentItemListForSpecificId, currentInventoryMapping);
		}
	}

	private void processExactItems(final InventorySetup inventorySetup,
									final Map<Integer, List<Integer>> currentInventoryMapping,
									final List<Boolean> processedInvItems,
									final boolean allowFuzzy)
	{
		List<InventorySetupsItem> setupInventory = inventorySetup.getInventory();

		// Handle exact non fuzzy items first
		// Exact items will be preferred first
		for (int i = 0; i < setupInventory.size(); i++)
		{
			if (processedInvItems.get(i))
			{
				continue;
			}

			final InventorySetupsItem savedItemFromInventory = setupInventory.get(i);

			// don't count empty spaces. We only want to show items that are missing, not "extra items"
			// that would be indicated by highlighting empty slots.
			if (savedItemFromInventory.getId() == -1)
			{
				inventorySlots.get(i).setBackground(ColorScheme.DARKER_GRAY_COLOR);
				processedInvItems.set(i, Boolean.TRUE);
				continue;
			}

			// Only mark it as processed if the item exists. If it doesn't there may be a fuzzy variant available
			List<Integer> currentItemListForSpecificId = currentInventoryMapping.get(savedItemFromInventory.getId());
			if (currentItemListForSpecificId != null && (allowFuzzy || !savedItemFromInventory.isFuzzy()))
			{
				updateCurrentUnorderedSlot(savedItemFromInventory.getId(), inventorySetup, inventorySlots.get(i), savedItemFromInventory, currentItemListForSpecificId, currentInventoryMapping);
				processedInvItems.set(i, Boolean.TRUE);
			}

		}
	}


	private void updateCurrentUnorderedSlot(int itemId, final InventorySetup inventorySetup,
											final InventorySetupsSlot currentSlot,
											final InventorySetupsItem savedItemFromInventory,
											final List<Integer> currentItemListForSpecificId,
											final Map<Integer, List<Integer>> currentInventoryMapping)
	{
		// This assumes the last item contains the correct quantity. This is done because
		// in the actual game, you can't have two stacks of stackable items. This assumption
		// is fine for stackable items as well.
		Integer currentInventoryItemQty = currentItemListForSpecificId.get(currentItemListForSpecificId.size() - 1);

		// delete the list if it's empty to simplify things
		currentItemListForSpecificId.remove(currentItemListForSpecificId.size() - 1);
		if (currentItemListForSpecificId.isEmpty())
		{
			currentInventoryMapping.remove(itemId);
		}

		if (InventorySetupsSlot.shouldHighlightSlotBasedOnStack(savedItemFromInventory.getStackCompare(), savedItemFromInventory.getQuantity(), currentInventoryItemQty))
		{
			currentSlot.setBackground(inventorySetup.getHighlightColor());
		}
		else
		{
			currentSlot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		}
	}
}

/*
 * Copyright (c) 2022, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

public interface InventorySetupsMoveHandler<T>
{
	void moveUp(final T datum);
	void moveDown(final T datum);
	void moveToTop(final T datum);
	void moveToBottom(final T datum);
	void moveToPosition(final T datum);
}

/*
 * Copyright (c) 2022, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsPanelViewID;
import inventorysetups.InventorySetupsPlugin;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_UNASSIGNED_MAXIMIZED;
import inventorysetups.InventorySetupsSection;
import inventorysetups.InventorySetupsSlotID;
import inventorysetups.InventorySetupsSortingID;
import inventorysetups.InventorySetupsValidName;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.util.Arrays;
import java.util.Objects;
import java.util.Set;
import javax.swing.Box;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.stream.Collectors;

import static inventorysetups.InventorySetupsPlugin.MAX_SETUP_NAME_LENGTH;

public class InventorySetupsSectionPanel extends JPanel implements InventorySetupsValidName, InventorySetupsMoveHandler<InventorySetupsSection>
{
	protected final InventorySetupsPlugin plugin;
	protected final InventorySetupsPluginPanel panel;
	private final InventorySetupsSection section;

	private final JPanel panelWithSetups;
	private final JLabel minMaxLabel;

	private static final ImageIcon MIN_MAX_SECTION_ICON;
	private static final ImageIcon MIN_MAX_SECTION_HOVER_ICON;
	private static final ImageIcon NO_MIN_MAX_SECTION_ICON;
	private static final ImageIcon NO_MIN_MAX_SECTION_HOVER_ICON;
	private boolean forceMaximization;
	private boolean allowEditable;

	public static final int MAX_ICONS_PER_ROW = 4;

	static
	{
		final BufferedImage minMaxSectionImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/down_arrow.png");
		final BufferedImage minMaxSectionHoverImg = ImageUtil.luminanceOffset(minMaxSectionImg, -150);
		MIN_MAX_SECTION_ICON = new ImageIcon(minMaxSectionImg);
		MIN_MAX_SECTION_HOVER_ICON = new ImageIcon(minMaxSectionHoverImg);

		final BufferedImage noMinMaxSectionImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/right_arrow.png");
		final BufferedImage noMaxSectionHoverImg = ImageUtil.luminanceOffset(noMinMaxSectionImg, -150);
		NO_MIN_MAX_SECTION_ICON = new ImageIcon(noMinMaxSectionImg);
		NO_MIN_MAX_SECTION_HOVER_ICON = new ImageIcon(noMaxSectionHoverImg);
	}

	InventorySetupsSectionPanel(InventorySetupsPlugin plugin,
								InventorySetupsPluginPanel panel,
								InventorySetupsSection section,
								boolean forceMaximization, boolean allowEdits,
								final Set<String> setupNamesToBeDisplayed,
								Set<String> setupsInSection,
								final List<InventorySetup> originalFilteredSetups)
	{
		this.plugin = plugin;
		this.panel = panel;
		this.section = section;
		this.forceMaximization = forceMaximization;
		this.allowEditable = allowEdits;
		this.panelWithSetups = new JPanel();

		this.setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Label that will be used to minimize or maximize setups in section
		this.minMaxLabel = new JLabel();
		updateMinMaxLabel();
		minMaxLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				maximizationRequest(mouseEvent);
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (forceMaximization)
				{
					return;
				}

				minMaxLabel.setIcon(section.isMaximized() ? MIN_MAX_SECTION_HOVER_ICON : NO_MIN_MAX_SECTION_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (forceMaximization)
				{
					return;
				}

				minMaxLabel.setIcon(section.isMaximized() ? MIN_MAX_SECTION_ICON : NO_MIN_MAX_SECTION_ICON);
			}
		});

		// Add the right click menu to delete sections
		JPopupMenu popupMenu = new InventorySetupsMoveMenu<>(plugin, panel, this, "Section", section);
		JMenuItem exportSection = new JMenuItem("Export Section");
		JMenuItem addSetupsToSection = new JMenuItem("Add setups to section..");
		JMenuItem deleteSection = new JMenuItem("Delete Section..");
		exportSection.addActionListener(e ->
		{
			plugin.exportSection(section);
		});
		addSetupsToSection.addActionListener(e ->
		{
			final String[] setupNames = plugin.getInventorySetups().stream().map(InventorySetup::getName).toArray(String[]::new);
			Arrays.sort(setupNames, String.CASE_INSENSITIVE_ORDER);
			final String message = "Select setups to add to this section";
			final String title = "Select Setups";
			InventorySetupsSelectionPanel selectionDialog = new InventorySetupsSelectionPanel(panel, title, message, setupNames);
			selectionDialog.setOnOk(e1 ->
			{
				List<String> selectedSetups = selectionDialog.getSelectedItems();
				if (!selectedSetups.isEmpty())
				{
					plugin.addSetupsToSection(section, selectedSetups);
				}
			});
			selectionDialog.show();

		});
		deleteSection.addActionListener(e ->
		{
			plugin.removeSection(section);
		});
		popupMenu.add(addSetupsToSection);
		popupMenu.add(exportSection);
		popupMenu.add(deleteSection);

		final MouseAdapter flatTextFieldMouseAdapter = new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				maximizationRequest(mouseEvent);
			}
		};
		// Add the button to nameActions so the color border will reach it as well
		final Color nameWrapperColor = new Color(20, 20, 20);
		final InventorySetupsNameActions<InventorySetupsSection> nameActions = new InventorySetupsNameActions<>(section,
																					plugin, panel, this,
																					popupMenu, MAX_SETUP_NAME_LENGTH,
																					nameWrapperColor, allowEditable, flatTextFieldMouseAdapter);
		final JPanel westNameActions = new JPanel(new BorderLayout());
		westNameActions.setBackground(nameWrapperColor);
		westNameActions.add(Box.createRigidArea(new Dimension(6, 0)), BorderLayout.WEST);
		westNameActions.add(minMaxLabel, BorderLayout.CENTER);

		nameActions.add(westNameActions, BorderLayout.WEST);

		JPanel nameWrapper = new JPanel();
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setLayout(new BorderLayout());
		nameWrapper.add(nameActions, BorderLayout.CENTER);

		// If we are in unassigned mode, don't allow the user to edit with the right click pop menu
		if (allowEditable)
		{
			nameWrapper.setComponentPopupMenu(popupMenu);
		}

		add(nameWrapper, BorderLayout.NORTH);
		addSetups(setupNamesToBeDisplayed, setupsInSection, originalFilteredSetups, allowEditable);

	}

	private void maximizationRequest(MouseEvent e)
	{
		if (SwingUtilities.isLeftMouseButton(e))
		{
			if (allowEditable && !forceMaximization)
			{
				section.setMaximized(!section.isMaximized());
				plugin.getDataManager().updateConfig(false, true);
				panel.redrawOverviewPanel(false);
			}
			else
			{
				// This is for the unassigned section.
				plugin.setConfigValue(CONFIG_KEY_UNASSIGNED_MAXIMIZED, !section.isMaximized());
			}
		}
	}

	private void addSetups(final Set<String> setupNamesToBeDisplayed, Set<String> setupsInSection, final List<InventorySetup> originalFilteredSetups, boolean allowEditable)
	{
		// Only add the setups if it's maximized. If we are searching, force maximization.
		if (section.isMaximized() || forceMaximization)
		{
			panelWithSetups.setLayout(new GridBagLayout());
			GridBagConstraints constraints = new GridBagConstraints();
			constraints.fill = GridBagConstraints.HORIZONTAL;
			constraints.weightx = 1;
			constraints.gridx = 0;
			constraints.gridy = 0;

			// If it's the default sorting mode (i.e., no sorting mode, use the order of setups in the section
			// Else use the order of the passed in setups, as they will be sorted according to the sorting mode
			if (plugin.getConfig().sortingMode() == InventorySetupsSortingID.DEFAULT)
			{
				if (plugin.getConfig().panelView() == InventorySetupsPanelViewID.ICON)
				{
					List<InventorySetup> setupObjectsInSection = section.getSetups().stream().map(setupName -> plugin.getCache().getInventorySetupNames().get(setupName)).collect(Collectors.toList());
					final JPanel iconGridPanel = createIconPanelGrid(plugin, panel, setupObjectsInSection, MAX_ICONS_PER_ROW, setupNamesToBeDisplayed, section, allowEditable);
					panelWithSetups.add(iconGridPanel, constraints);
					constraints.gridy++;
				}
				else
				{
					panelWithSetups.add(Box.createRigidArea(new Dimension(0, 10)), constraints);
					constraints.gridy++;
					for (final String name : section.getSetups())
					{
						// If we are searching and the setup doesn't match the search, don't add setup
						if (!setupNamesToBeDisplayed.contains(name))
						{
							continue;
						}
						final InventorySetup setupInSection = plugin.getCache().getInventorySetupNames().get(name);
						createSetupPanelForSection(setupInSection, section, constraints, allowEditable);
					}
				}
			}
			else
			{
				// Sorting mode is being used, so use the original setup array to determine the order.
				if (plugin.getConfig().panelView() == InventorySetupsPanelViewID.ICON)
				{
					// Use the original list of setups because this contains the order of the sorting mode
					final JPanel iconGridPanel = createIconPanelGrid(plugin, panel, originalFilteredSetups, MAX_ICONS_PER_ROW, setupsInSection, section, allowEditable);
					panelWithSetups.add(iconGridPanel, constraints);
					constraints.gridy++;
				}
				else
				{
					panelWithSetups.add(Box.createRigidArea(new Dimension(0, 10)), constraints);
					constraints.gridy++;
					// Use the original list of setups because this contains the order of the sorting mode
					for (final InventorySetup setup : originalFilteredSetups)
					{
						if (!setupsInSection.contains(setup.getName()))
						{
							continue;
						}
						createSetupPanelForSection(setup, section, constraints, allowEditable);
					}
				}
			}

			add(panelWithSetups, BorderLayout.SOUTH);
		}
	}

	private void createSetupPanelForSection(final InventorySetup setupInSection, final InventorySetupsSection section, final GridBagConstraints constraints, boolean allowEditable)
	{
		final JPanel wrapperPanelForSetup = new JPanel();
		wrapperPanelForSetup.setLayout(new BorderLayout());

		InventorySetupsPanel newPanel = null;
		if (plugin.getConfig().panelView() == InventorySetupsPanelViewID.COMPACT)
		{
			newPanel = new InventorySetupsCompactPanel(plugin, panel, setupInSection, section, allowEditable);
		}
		else
		{
			newPanel = new InventorySetupsStandardPanel(plugin, panel, setupInSection, section, allowEditable);
		}

		// Add an indentation to the setup
		wrapperPanelForSetup.add(Box.createRigidArea(new Dimension(12, 0)), BorderLayout.WEST);
		wrapperPanelForSetup.add(newPanel, BorderLayout.CENTER);

		panelWithSetups.add(wrapperPanelForSetup, constraints);
		constraints.gridy++;

		panelWithSetups.add(Box.createRigidArea(new Dimension(0, 10)), constraints);
		constraints.gridy++;
	}

	public static JPanel createIconPanelGrid(final InventorySetupsPlugin plugin, final InventorySetupsPluginPanel panel, final List<InventorySetup> setups, int maxColSize, final Set<String> whitelistedNames, final InventorySetupsSection section, boolean allowEditable)
	{
		int added = 0;
		int width = 0;
		int height = 0;
		JPanel wrapperPanel = new JPanel(new GridLayout(0, maxColSize, 5, 5));
		for (final InventorySetup setup : setups)
		{
			// if whitelistedNames is null, don't attempt to filter at all
			if (whitelistedNames != null && !whitelistedNames.contains(setup.getName()))
			{
				continue;
			}
			InventorySetupsPanel newPanel = new InventorySetupsIconPanel(plugin, panel, setup, section, allowEditable);
			width = newPanel.getWidth();
			height = newPanel.getHeight();
			wrapperPanel.add(newPanel);
			added++;
		}
		return addExtraIconSlotsAndExpansionStopper(wrapperPanel, added, maxColSize, width, height);
	}

	public static JPanel addExtraIconSlotsAndExpansionStopper(final JPanel iconGridPanel, int size, int maxColSize, int width, int height)
	{
		// Add empty slots
		for (int i = size; i % maxColSize != 0; i++)
		{
			iconGridPanel.add(new InventorySetupsSlot(ColorScheme.DARK_GRAY_COLOR, InventorySetupsSlotID.INVENTORY, -1, width, height));
		}

		// This stops the Slots in the gridlayout from expanding to fill space
		JPanel stopExpansionLayout = new JPanel(new FlowLayout());
		stopExpansionLayout.add(iconGridPanel);
		return stopExpansionLayout;
	}

	@Override
	public boolean isNameValid(final String name, final Color displayColor)
	{
		boolean nameExistsAlready = plugin.getCache().getSectionNames().containsKey(name);
		boolean nameHasChanged = !section.getName().equals(name);
		boolean displayColorHasChanged = !Objects.equals(section.getDisplayColor(), displayColor);
		boolean nothingHasChanged = !nameHasChanged && !displayColorHasChanged;

		if (nothingHasChanged || name.isEmpty())
		{
			return false;
		}

		if (nameHasChanged && nameExistsAlready)
		{
			return false;
		}

		return true;
	}

	@Override
	public void updateName(final String newName)
	{
		plugin.updateSectionName(section, newName);
	}

	private void updateMinMaxLabel()
	{
		if (forceMaximization)
		{
			minMaxLabel.setToolTipText("");
			minMaxLabel.setIcon(MIN_MAX_SECTION_ICON);
		}
		else
		{
			minMaxLabel.setToolTipText(section.isMaximized() ? "Minimize section" : "Maximize section");
			minMaxLabel.setIcon(section.isMaximized() ? MIN_MAX_SECTION_ICON : NO_MIN_MAX_SECTION_ICON);
		}
	}

	@Override
	public void moveUp(final InventorySetupsSection section)
	{
		int sectionIndex = plugin.getSections().indexOf(section);
		plugin.moveSection(sectionIndex, sectionIndex - 1);
	}

	@Override
	public void moveDown(final InventorySetupsSection section)
	{
		int sectionIndex = plugin.getSections().indexOf(section);
		plugin.moveSection(sectionIndex, sectionIndex + 1);
	}

	@Override
	public void moveToTop(final InventorySetupsSection section)
	{
		int sectionIndex = plugin.getSections().indexOf(section);
		plugin.moveSection(sectionIndex, 0);
	}

	@Override
	public void moveToBottom(final InventorySetupsSection section)
	{
		int sectionIndex = plugin.getSections().indexOf(section);
		plugin.moveSection(sectionIndex, plugin.getSections().size() - 1);
	}

	@Override
	public void moveToPosition(final InventorySetupsSection section)
	{
		int sectionIndex = plugin.getSections().indexOf(section);
		final String posDialog = "Enter a position between 1 and " + String.valueOf(plugin.getSections().size()) +
				". Current section is in position " + String.valueOf(sectionIndex + 1) + ".";
		final String newPositionStr = JOptionPane.showInputDialog(panel,
				posDialog,
				"Move Section",
				JOptionPane.PLAIN_MESSAGE);

		// cancel button was clicked
		if (newPositionStr == null)
		{
			return;
		}

		try
		{
			int newPosition = Integer.parseInt(newPositionStr);
			if (newPosition < 1 || newPosition > plugin.getSections().size())
			{
				JOptionPane.showMessageDialog(panel,
						"Invalid position.",
						"Move Section Failed",
						JOptionPane.ERROR_MESSAGE);
				return;
			}
			plugin.moveSection(sectionIndex, newPosition - 1);
		}
		catch (NumberFormatException ex)
		{
			JOptionPane.showMessageDialog(panel,
					"Invalid position.",
					"Move Section Failed",
					JOptionPane.ERROR_MESSAGE);
		}
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSlotID;

import java.util.Arrays;
import java.util.List;
import net.runelite.client.game.ItemManager;

public class InventorySetupsBoltPouchPanel extends InventorySetupsAmmunitionPanel
{
	public static final int BOLT_POUCH_AMOUNT1 = 2469;
	public static final int BOLT_POUCH_AMOUNT2 = 2470;
	public static final int BOLT_POUCH_AMOUNT3 = 2471;
	public static final int BOLT_POUCH_EXTRA_AMMO_AMOUNT = 2472;
	public static final int BOLT_POUCH_BOLT1 = 2473;
	public static final int BOLT_POUCH_BOLT2 = 2474;
	public static final int BOLT_POUCH_BOLT3 = 2475;
	public static final int BOLT_POUCH_EXTRA_AMMO = 2476;

	public static final List<Integer> BOLT_POUCH_AMOUNT_VARBIT_IDS = Arrays.asList(BOLT_POUCH_AMOUNT1, BOLT_POUCH_AMOUNT2, BOLT_POUCH_AMOUNT3, BOLT_POUCH_EXTRA_AMMO_AMOUNT);

	public static final List<Integer> BOLT_POUCH_BOLT_VARBIT_IDS = Arrays.asList(BOLT_POUCH_BOLT1, BOLT_POUCH_BOLT2, BOLT_POUCH_BOLT3, BOLT_POUCH_EXTRA_AMMO);

	InventorySetupsBoltPouchPanel(ItemManager itemManager, InventorySetupsPlugin plugin)
	{
		super(itemManager, plugin, "Bolt Pouch");
	}

	@Override
	protected InventorySetupsSlotID getSlotId()
	{
		return InventorySetupsSlotID.BOLT_POUCH;
	}

	@Override
	protected int getSlotsCount()
	{
		return 4;
	}

	@Override
	protected List<InventorySetupsItem> getContainer(InventorySetup inventorySetup)
	{
		return inventorySetup.getBoltPouch();
	}

	public void handleBoltPouchHighlighting(final InventorySetup inventorySetup, boolean doesCurrentInventoryHaveBoltPouch)
	{
		if (!inventorySetup.isHighlightDifference() || !plugin.isHighlightingAllowed())
		{
			super.resetSlotColors();
			return;
		}

		if (inventorySetup.getBoltPouch() != null)
		{
			// attempt to highlight if bolt pouch is available
			if (doesCurrentInventoryHaveBoltPouch)
			{
				List<InventorySetupsItem> boltPouchToCheck = plugin.getAmmoHandler().getBoltPouchData();
				super.highlightSlots(boltPouchToCheck, inventorySetup);
			}
			else // if the current inventory doesn't have a bolt pouch but the setup does, highlight the pouch
			{
				super.highlightAllSlots(inventorySetup);
			}
		}
		else
		{
			super.resetSlotColors();
		}
	}
}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsRunePouchType;
import inventorysetups.InventorySetupsSlotID;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;

public class InventorySetupsRunePouchPanel extends InventorySetupsAmmunitionPanel
{
	// 23650 is what shows up when selecting a RunePouch from ChatBoxItemSearch, 27086 is likely lms
	public static final List<Integer> RUNE_POUCH_IDS = Arrays.asList(ItemID.BH_RUNE_POUCH, ItemID.BH_RUNE_POUCH_TROUVER, ItemID.BR_RUNE_REPLACEMENT, ItemID.PVPA_RUNE_REPLACEMENT);

	public static final Set<Integer> RUNE_POUCH_IDS_SET = new HashSet<>(RUNE_POUCH_IDS);

	public static final List<Integer> RUNE_POUCH_DIVINE_IDS = Arrays.asList(ItemID.DIVINE_RUNE_POUCH, ItemID.DIVINE_RUNE_POUCH_TROUVER);

	public static final Set<Integer> RUNE_POUCH_DIVINE_IDS_SET = new HashSet<>(RUNE_POUCH_DIVINE_IDS);

	public static final List<Integer> RUNE_POUCH_AMOUNT_VARBITS = Arrays.asList(VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2, VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4);

	public static final List<Integer> RUNE_POUCH_RUNE_VARBITS = Arrays.asList(VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2, VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4);

	InventorySetupsRunePouchPanel(ItemManager itemManager, InventorySetupsPlugin plugin)
	{
		super(itemManager, plugin, "Rune Pouch");
	}

	@Override
	protected InventorySetupsSlotID getSlotId()
	{
		return InventorySetupsSlotID.RUNE_POUCH;
	}

	@Override
	protected int getSlotsCount()
	{
		return 4;
	}

	@Override
	protected List<InventorySetupsItem> getContainer(InventorySetup inventorySetup)
	{
		return inventorySetup.getRune_pouch();
	}

	public void handleRunePouchHighlighting(final InventorySetup inventorySetup, final InventorySetupsRunePouchType runePouchType)
	{
		if (!inventorySetup.isHighlightDifference() || !plugin.isHighlightingAllowed())
		{
			super.resetSlotColors();
			return;
		}

		// This must be run on the client thread!
		if (inventorySetup.getRune_pouch() != null)
		{
			// attempt to highlight if rune pouch is available
			if (runePouchType != InventorySetupsRunePouchType.NONE)
			{
				List<InventorySetupsItem> runePouchToCheck = plugin.getAmmoHandler().getRunePouchData(runePouchType);
				super.highlightSlots(runePouchToCheck, inventorySetup);
			}
			else // if the current inventory doesn't have a rune pouch but the setup does, highlight the RP pouch
			{
				super.highlightAllSlots(inventorySetup);
			}
		}
		else
		{
			super.resetSlotColors();
		}
	}
}

/*
 * Copyright (c) 2021, rbbi <https://github.com/rbbi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSlotID;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JPanel;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

/**
 * @author robbie, created on 23/09/2021 20:34
 */
public abstract class InventorySetupsAmmunitionPanel extends InventorySetupsContainerPanel
{

	private List<InventorySetupsSlot> ammoSlots;

	private GridLayout gridLayout;

	private List<Boolean> ammoSlotsAddedToPanel;

	InventorySetupsAmmunitionPanel(ItemManager itemManager, InventorySetupsPlugin plugin, String captionText)
	{
		super(itemManager, plugin, captionText);
	}

	@Override
	public boolean isStackCompareForSlotAllowed(int id)
	{
		return true;
	}

	@Override
	public void setupContainerPanel(JPanel containerSlotsPanel)
	{
		ammoSlots = new ArrayList<>();
		ammoSlotsAddedToPanel = new ArrayList<>();
		for (int i = 0; i < getSlotsCount(); i++)
		{
			ammoSlots.add(new InventorySetupsSlot(ColorScheme.DARKER_GRAY_COLOR, getSlotId(), i));
			ammoSlotsAddedToPanel.add(Boolean.TRUE);
		}

		this.gridLayout = new GridLayout(1, 4, 1, 1);
		containerSlotsPanel.setLayout(gridLayout);

		for (final InventorySetupsSlot slot : ammoSlots)
		{
			containerSlotsPanel.add(slot);
			InventorySetupsSlot.addStackMouseListenerToSlot(plugin, slot);
			InventorySetupsSlot.addUpdateFromContainerMouseListenerToSlot(plugin, slot);
			InventorySetupsSlot.addUpdateFromSearchMouseListenerToSlot(plugin, slot, true);
			InventorySetupsSlot.addRemoveMouseListenerToSlot(plugin, slot);
		}
	}

	protected abstract InventorySetupsSlotID getSlotId();

	protected abstract int getSlotsCount();

	@Override
	public void highlightSlots(List<InventorySetupsItem> currentContainer, InventorySetup inventorySetup)
	{
		assert getContainer(inventorySetup) != null : "Container is null.";

		int slotsCount = getSlotsCount();
		assert slotsCount == getSlotsCount() : "Incorrect size";

		isHighlighted = true;

		final List<InventorySetupsItem> ammoContainer = getContainer(inventorySetup);

		List<InventorySetupsItem> currentContainerReference = currentContainer;

		if (currentContainer.size() < ammoContainer.size())
		{
			// Fill the current container to the size of the saved container for easier comparison
			final List<InventorySetupsItem> currentContainerCopy = new ArrayList<>(currentContainer);
			for (int i = currentContainerCopy.size(); i < ammoContainer.size(); i++)
			{
				currentContainerCopy.add(InventorySetupsItem.getDummyItem());
			}
			currentContainerReference = currentContainerCopy;
		}


		for (int i = 0; i < ammoContainer.size(); i++)
		{
			boolean shouldHighlightSlot = false;
			boolean foundAmmo = false;
			int currentContainerIndex = -1;
			for (int j = 0; j < currentContainerReference.size(); j++)
			{
				if (ammoContainer.get(i).getId() == currentContainerReference.get(j).getId())
				{
					foundAmmo = true;
					currentContainerIndex = j;
					break;
				}
			}

			if (foundAmmo)
			{
				int savedQuantity = ammoContainer.get(i).getQuantity();
				int currentQuantity = currentContainerReference.get(currentContainerIndex).getQuantity();
				if (InventorySetupsSlot.shouldHighlightSlotBasedOnStack(ammoContainer.get(i).getStackCompare(), savedQuantity, currentQuantity))
				{
					shouldHighlightSlot = true;
				}
			}
			else
			{
				shouldHighlightSlot = true;
			}

			if (shouldHighlightSlot)
			{
				ammoSlots.get(i).setBackground(inventorySetup.getHighlightColor());
			}
			else
			{
				ammoSlots.get(i).setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}

		}

	}

	protected abstract List<InventorySetupsItem> getContainer(InventorySetup inventorySetup);

	@Override
	public void updatePanelWithSetupInformation(InventorySetup setup)
	{
		List<InventorySetupsItem> container = getContainer(setup);
		if (container != null)
		{
			// grid layout is dumb, it won't center the panel if a slot is invisible, so we have to remove the slot instead...
			// Make sure to set the columns as well.
			gridLayout.setColumns(container.size());
			for (int i = 0; i < ammoSlots.size(); i++)
			{
				if (i >= container.size())
				{
					if (ammoSlotsAddedToPanel.get(i))
					{
						ammoSlotsAddedToPanel.set(i, Boolean.FALSE);
						this.getContainerSlotsPanel().remove(ammoSlots.get(i));
					}
				}
				else
				{
					if (!ammoSlotsAddedToPanel.get(i))
					{
						ammoSlotsAddedToPanel.set(i, Boolean.TRUE);
						this.getContainerSlotsPanel().add(ammoSlots.get(i));
					}
					InventorySetupsSlot.setSlotImageAndText(itemManager, ammoSlots.get(i), setup, container.get(i));
				}
			}
		}
		else
		{
			for (int i = 0; i < ammoSlots.size(); i++)
			{
				InventorySetupsSlot.setSlotImageAndText(itemManager, ammoSlots.get(i), setup, InventorySetupsItem.getDummyItem());
			}
		}

		validate();
		repaint();
	}

	@Override
	public void resetSlotColors()
	{
		if (!isHighlighted)
		{
			return;
		}
		for (final InventorySetupsSlot slot : ammoSlots)
		{
			slot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		}
		isHighlighted = false;
	}

	public void highlightAllSlots(final InventorySetup setup)
	{
		for (final InventorySetupsSlot slot : ammoSlots)
		{
			slot.setBackground(setup.getHighlightColor());
		}
		isHighlighted = true;
	}
}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsPlugin;

import inventorysetups.InventorySetupsSection;
import inventorysetups.InventorySetupsValidName;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.image.BufferedImage;
import java.util.Objects;

import static inventorysetups.InventorySetupsPlugin.MAX_SETUP_NAME_LENGTH;

// Standard panel for inventory setups, which contains all the configuration buttons
public class InventorySetupsStandardPanel extends InventorySetupsPanel implements InventorySetupsValidName
{

	private static final int H_GAP_BTN = 4;

	private static final ImageIcon BANK_FILTER_ICON;
	private static final ImageIcon BANK_FILTER_HOVER_ICON;
	private static final ImageIcon NO_BANK_FILTER_ICON;
	private static final ImageIcon NO_BANK_FILTER_HOVER_ICON;

	private static final ImageIcon HIGHLIGHT_COLOR_ICON;
	private static final ImageIcon HIGHLIGHT_COLOR_HOVER_ICON;
	private static final ImageIcon NO_HIGHLIGHT_COLOR_ICON;
	private static final ImageIcon NO_HIGHLIGHT_COLOR_HOVER_ICON;

	private static final ImageIcon TOGGLE_HIGHLIGHT_ICON;
	private static final ImageIcon TOGGLE_HIGHLIGHT_HOVER_ICON;
	private static final ImageIcon NO_TOGGLE_HIGHLIGHT_ICON;
	private static final ImageIcon NO_TOGGLE_HIGHLIGHT_HOVER_ICON;

	private static final ImageIcon UNORDERED_HIGHLIGHT_ICON;
	private static final ImageIcon UNORDERED_HIGHLIGHT_HOVER_ICON;
	private static final ImageIcon NO_UNORDERED_HIGHLIGHT_ICON;
	private static final ImageIcon NO_UNORDERED_HIGHLIGHT_HOVER_ICON;

	private static final ImageIcon FAVORITE_ICON;
	private static final ImageIcon FAVORITE_HOVER_ICON;
	private static final ImageIcon NO_FAVORITE_ICON;
	private static final ImageIcon NO_FAVORITE_HOVER_ICON;

	private static final ImageIcon VIEW_SETUP_ICON;
	private static final ImageIcon VIEW_SETUP_HOVER_ICON;

	private static final ImageIcon DELETE_ICON;
	private static final ImageIcon DELETE_HOVER_ICON;

	private static final ImageIcon EXPORT_ICON;
	private static final ImageIcon EXPORT_HOVER_ICON;

	public static final ImageIcon DISPLAY_COLOR_ICON;
	public static final ImageIcon DISPLAY_COLOR_HOVER_ICON;

	private final JLabel bankFilterIndicator = new JLabel();
	private final JLabel highlightColorIndicator = new JLabel();
	private final JLabel unorderedHighlightIndicator = new JLabel();
	private final JLabel favoriteIndicator = new JLabel();
	private final JLabel highlightIndicator = new JLabel();
	private final JLabel viewSetupLabel = new JLabel();
	private final JLabel exportLabel = new JLabel();
	private final JLabel deleteLabel = new JLabel();

	static
	{
		final BufferedImage bankFilterImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/filter_icon.png");
		final BufferedImage bankFilterHover = ImageUtil.luminanceOffset(bankFilterImg, -150);
		BANK_FILTER_ICON = new ImageIcon(bankFilterImg);
		BANK_FILTER_HOVER_ICON = new ImageIcon(bankFilterHover);

		NO_BANK_FILTER_ICON = new ImageIcon(bankFilterHover);
		NO_BANK_FILTER_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(bankFilterHover, -100));

		final BufferedImage unorderedHighlightImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/unordered_highlight_icon.png");
		final BufferedImage unorderedHighlightHover = ImageUtil.luminanceOffset(unorderedHighlightImg, -150);
		UNORDERED_HIGHLIGHT_ICON = new ImageIcon(unorderedHighlightImg);
		UNORDERED_HIGHLIGHT_HOVER_ICON = new ImageIcon(unorderedHighlightHover);

		NO_UNORDERED_HIGHLIGHT_ICON = new ImageIcon(unorderedHighlightHover);
		NO_UNORDERED_HIGHLIGHT_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(unorderedHighlightHover, -100));

		final BufferedImage favoriteImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/favorite_icon.png");
		final BufferedImage favoriteHover = ImageUtil.luminanceOffset(favoriteImg, -150);
		FAVORITE_ICON = new ImageIcon(favoriteImg);
		FAVORITE_HOVER_ICON = new ImageIcon(favoriteHover);

		NO_FAVORITE_ICON = new ImageIcon(favoriteHover);
		NO_FAVORITE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(favoriteHover, -100));

		final BufferedImage highlightToggleImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/highlight_icon.png");
		final BufferedImage highlightToggleHover = ImageUtil.luminanceOffset(highlightToggleImg, -150);
		TOGGLE_HIGHLIGHT_ICON = new ImageIcon(highlightToggleImg);
		TOGGLE_HIGHLIGHT_HOVER_ICON = new ImageIcon(highlightToggleHover);

		NO_TOGGLE_HIGHLIGHT_ICON = new ImageIcon(highlightToggleHover);
		NO_TOGGLE_HIGHLIGHT_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(highlightToggleHover, -100));

		final BufferedImage highlightImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/highlight_color_icon.png");
		final BufferedImage highlightHover = ImageUtil.luminanceOffset(highlightImg, -150);
		HIGHLIGHT_COLOR_ICON = new ImageIcon(highlightImg);
		HIGHLIGHT_COLOR_HOVER_ICON = new ImageIcon(highlightHover);

		NO_HIGHLIGHT_COLOR_ICON = new ImageIcon(highlightHover);
		NO_HIGHLIGHT_COLOR_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(highlightHover, -100));

		final BufferedImage viewImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/visible_icon.png");
		final BufferedImage viewImgHover = ImageUtil.luminanceOffset(viewImg, -150);
		VIEW_SETUP_ICON = new ImageIcon(viewImg);
		VIEW_SETUP_HOVER_ICON = new ImageIcon(viewImgHover);

		final BufferedImage exportImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/export_icon.png");
		final BufferedImage exportImgHover = ImageUtil.luminanceOffset(exportImg, -150);
		EXPORT_ICON = new ImageIcon(exportImg);
		EXPORT_HOVER_ICON = new ImageIcon(exportImgHover);

		final BufferedImage deleteImg = ImageUtil.loadImageResource(InventorySetupsPlugin.class, "/delete_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.luminanceOffset(deleteImg, -100));

		DISPLAY_COLOR_ICON = new ImageIcon(highlightImg);
		DISPLAY_COLOR_HOVER_ICON = new ImageIcon(highlightHover);
	}

	InventorySetupsStandardPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel, InventorySetup invSetup, InventorySetupsSection section)
	{
		this(plugin, panel, invSetup, section, true);
	}

	InventorySetupsStandardPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel, InventorySetup invSetup, InventorySetupsSection section, boolean allowEditable)
	{
		super(plugin, panel, invSetup, section, allowEditable);

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Always allow the name actions to work for the standard panel
		JPanel nameActions = new InventorySetupsNameActions<>(invSetup, plugin, panel, this,
																popupMenu, MAX_SETUP_NAME_LENGTH,
																ColorScheme.DARKER_GRAY_COLOR, true, null);

		JPanel bottomContainer = new JPanel(new BorderLayout());
		bottomContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
		bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		bankFilterIndicator.setToolTipText("Enable bank filtering");
		bankFilterIndicator.setIcon(inventorySetup.isFilterBank() ? BANK_FILTER_ICON : NO_BANK_FILTER_ICON);
		bankFilterIndicator.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					inventorySetup.setFilterBank(!inventorySetup.isFilterBank());
					bankFilterIndicator.setToolTipText(inventorySetup.isFilterBank() ? "Disable bank filtering" : "Enable bank filtering");
					updateBankFilterLabel();
					plugin.getDataManager().updateConfig(true, false);
					panel.redrawOverviewPanel(false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				bankFilterIndicator.setIcon(inventorySetup.isFilterBank() ? BANK_FILTER_HOVER_ICON : NO_BANK_FILTER_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				bankFilterIndicator.setIcon(inventorySetup.isFilterBank() ? BANK_FILTER_ICON : NO_BANK_FILTER_ICON);
			}
		});

		unorderedHighlightIndicator.setToolTipText("Only highlight items that are missing from the inventory and ignore order");
		unorderedHighlightIndicator.setIcon(inventorySetup.isUnorderedHighlight() ? UNORDERED_HIGHLIGHT_ICON : NO_UNORDERED_HIGHLIGHT_ICON);
		unorderedHighlightIndicator.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					inventorySetup.setUnorderedHighlight(!inventorySetup.isUnorderedHighlight());
					unorderedHighlightIndicator.setToolTipText(inventorySetup.isUnorderedHighlight() ? "Enable default ordered highlighting" : "Only highlight items that are missing from the inventory and ignore order");
					updateUnorderedHighlightIndicator();
					plugin.getDataManager().updateConfig(true, false);
					panel.redrawOverviewPanel(false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				unorderedHighlightIndicator.setIcon(inventorySetup.isUnorderedHighlight() ? UNORDERED_HIGHLIGHT_HOVER_ICON : NO_UNORDERED_HIGHLIGHT_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				unorderedHighlightIndicator.setIcon(inventorySetup.isUnorderedHighlight() ? UNORDERED_HIGHLIGHT_ICON : NO_UNORDERED_HIGHLIGHT_ICON);
			}
		});

		favoriteIndicator.setToolTipText(inventorySetup.isFavorite() ? "Remove this setup from the list of favorites" : "Favorite this setup so it appears at the top of the list");
		favoriteIndicator.setIcon(inventorySetup.isFavorite() ? FAVORITE_ICON : NO_FAVORITE_ICON);
		favoriteIndicator.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					inventorySetup.setFavorite(!inventorySetup.isFavorite());
					favoriteIndicator.setToolTipText(inventorySetup.isFavorite() ? "Remove this setup from the list of favorites" : "Favorite this setup so it appears at the top of the list");
					updateFavoriteIndicator();
					plugin.getDataManager().updateConfig(true, false);
					// rebuild the panel so this panel will move positions from being favorited/unfavorited
					panel.redrawOverviewPanel(false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				favoriteIndicator.setIcon(inventorySetup.isFavorite() ? FAVORITE_HOVER_ICON : NO_FAVORITE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				favoriteIndicator.setIcon(inventorySetup.isFavorite() ? FAVORITE_ICON : NO_FAVORITE_ICON);
			}
		});

		highlightIndicator.setToolTipText("Enable highlighting");
		highlightIndicator.setIcon(inventorySetup.isHighlightDifference() ? TOGGLE_HIGHLIGHT_ICON : NO_TOGGLE_HIGHLIGHT_ICON);
		highlightIndicator.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					inventorySetup.setHighlightDifference(!inventorySetup.isHighlightDifference());
					highlightIndicator.setToolTipText(inventorySetup.isHighlightDifference() ? "Disable highlighting" : "Enable highlighting");
					updateToggleHighlightLabel();
					updateHighlightColorLabel();
					plugin.getDataManager().updateConfig(true, false);
					panel.redrawOverviewPanel(false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				highlightIndicator.setIcon(inventorySetup.isHighlightDifference() ? TOGGLE_HIGHLIGHT_HOVER_ICON : NO_TOGGLE_HIGHLIGHT_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				highlightIndicator.setIcon(inventorySetup.isHighlightDifference() ? TOGGLE_HIGHLIGHT_ICON : NO_TOGGLE_HIGHLIGHT_ICON);
			}
		});

		highlightColorIndicator.setToolTipText("Edit highlight color");
		highlightColorIndicator.setIcon(inventorySetup.isHighlightDifference() ? HIGHLIGHT_COLOR_ICON : NO_HIGHLIGHT_COLOR_ICON);
		highlightColorIndicator.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					plugin.openColorPicker("Choose a Highlight color", invSetup.getHighlightColor(),
						c ->
						{
							// Don't consider the transparency component
							Color newColor = new Color(c.getRed(), c.getGreen(), c.getBlue(), 255);
							inventorySetup.setHighlightColor(newColor);
							updateHighlightColorLabel();
						}
					);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				highlightColorIndicator.setIcon(inventorySetup.isHighlightDifference() ? HIGHLIGHT_COLOR_HOVER_ICON : NO_HIGHLIGHT_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				highlightColorIndicator.setIcon(inventorySetup.isHighlightDifference() ? HIGHLIGHT_COLOR_ICON : NO_HIGHLIGHT_COLOR_ICON);
			}
		});

		JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, H_GAP_BTN, 0));
		leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		leftActions.add(bankFilterIndicator);
		leftActions.add(unorderedHighlightIndicator);
		leftActions.add(highlightIndicator);
		leftActions.add(highlightColorIndicator);
		leftActions.add(favoriteIndicator);

		viewSetupLabel.setToolTipText("View setup");
		viewSetupLabel.setIcon(VIEW_SETUP_ICON);
		viewSetupLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					panel.setCurrentInventorySetup(inventorySetup, true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				viewSetupLabel.setIcon(VIEW_SETUP_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				viewSetupLabel.setIcon(VIEW_SETUP_ICON);
			}
		});

		JPopupMenu singleExportBankTagTabMenu = new JPopupMenu();
		JMenuItem singleExportBankTagTabMenuItem = new JMenuItem("Export setup to Bank Tag Tab");
		singleExportBankTagTabMenuItem.addActionListener(e -> plugin.getClientThread().invokeLater(() -> plugin.getLayoutUtilities().exportSetupToBankTagTab(inventorySetup, panel)));
		singleExportBankTagTabMenu.add(singleExportBankTagTabMenuItem);
		exportLabel.setToolTipText("Export setup");
		exportLabel.setIcon(EXPORT_ICON);
		exportLabel.setComponentPopupMenu(singleExportBankTagTabMenu);
		exportLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					plugin.exportSetup(inventorySetup);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				exportLabel.setIcon(EXPORT_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				exportLabel.setIcon(EXPORT_ICON);
			}
		});

		deleteLabel.setToolTipText("Delete setup");
		deleteLabel.setIcon(DELETE_ICON);
		deleteLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (SwingUtilities.isLeftMouseButton(mouseEvent))
				{
					plugin.removeInventorySetup(inventorySetup);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				deleteLabel.setIcon(DELETE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				deleteLabel.setIcon(DELETE_ICON);
			}
		});

		JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, H_GAP_BTN, 0));
		rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		rightActions.add(viewSetupLabel);
		rightActions.add(exportLabel);
		rightActions.add(deleteLabel);

		bottomContainer.add(leftActions, BorderLayout.WEST);
		bottomContainer.add(rightActions, BorderLayout.EAST);

		add(nameActions, BorderLayout.NORTH);
		add(bottomContainer, BorderLayout.CENTER);

		updateHighlightColorLabel();
		updateToggleHighlightLabel();
		updateFavoriteIndicator();

	}

	@Override
	public boolean isNameValid(final String name, final Color displayColor)
	{

		boolean nameExistsAlready = plugin.getCache().getInventorySetupNames().containsKey(name);
		boolean nameHasChanged = !inventorySetup.getName().equals(name);
		boolean displayColorHasChanged = !Objects.equals(inventorySetup.getDisplayColor(), displayColor);
		boolean nothingHasChanged = !nameHasChanged && !displayColorHasChanged;

		if (nothingHasChanged || name.isEmpty())
		{
			return false;
		}

		if (nameHasChanged && nameExistsAlready)
		{
			return false;
		}

		return true;
	}

	@Override
	public void updateName(final String newName)
	{
		plugin.updateSetupName(inventorySetup, newName);

	}

	private void updateHighlightColorLabel()
	{
		Color color = inventorySetup.getHighlightColor();
		highlightColorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, color));
		highlightColorIndicator.setIcon(inventorySetup.isHighlightDifference() ? HIGHLIGHT_COLOR_ICON : NO_HIGHLIGHT_COLOR_ICON);
	}

	private void updateBankFilterLabel()
	{
		bankFilterIndicator.setIcon(inventorySetup.isFilterBank() ? BANK_FILTER_ICON : NO_BANK_FILTER_ICON);
	}

	private void updateUnorderedHighlightIndicator()
	{
		unorderedHighlightIndicator.setIcon(inventorySetup.isUnorderedHighlight() ? UNORDERED_HIGHLIGHT_ICON : NO_UNORDERED_HIGHLIGHT_ICON);
	}

	private void updateFavoriteIndicator()
	{
		favoriteIndicator.setIcon(inventorySetup.isFavorite() ? FAVORITE_ICON : NO_FAVORITE_ICON);
	}

	private void updateToggleHighlightLabel()
	{
		highlightIndicator.setIcon(inventorySetup.isHighlightDifference() ? TOGGLE_HIGHLIGHT_ICON : NO_TOGGLE_HIGHLIGHT_ICON);
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups.ui;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsPlugin;
import inventorysetups.InventorySetupsSection;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;

import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

// The compact setup panel that only contains the name of the setup
public class InventorySetupsCompactPanel extends InventorySetupsPanel
{

	InventorySetupsCompactPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel, InventorySetup invSetup, InventorySetupsSection section)
	{
		this(plugin, panel, invSetup, section, true);
	}

	InventorySetupsCompactPanel(InventorySetupsPlugin plugin, InventorySetupsPluginPanel panel, InventorySetup invSetup, InventorySetupsSection section, boolean allowEditable)
	{
		super(plugin, panel, invSetup, section, allowEditable);

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		setPreferredSize(new Dimension(0, 24));

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		final FlatTextField nameInput = new FlatTextField();
		nameInput.setText(inventorySetup.getName());
		nameInput.setBorder(new MatteBorder(0, 2, 0, 0, invSetup.getDisplayColor()));
		nameInput.setEditable(false);
		nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameInput.setPreferredSize(new Dimension(0, 24));
		nameInput.getTextField().setForeground(Color.WHITE);
		nameInput.getTextField().setBorder(new EmptyBorder(0, 6, 0, 0));
		nameInput.getTextField().setCaretPosition(0);

		nameWrapper.add(nameInput, BorderLayout.CENTER);

		add(nameWrapper, BorderLayout.NORTH);

		nameInput.getTextField().setComponentPopupMenu(popupMenu);
		nameInput.getTextField().addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					panel.setCurrentInventorySetup(inventorySetup, true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				nameInput.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

	}
}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_ENABLE_LAYOUT_WARNING;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_HIDE_BUTTON;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_LAYOUT_DEFAULT;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_PERSIST_HOTKEYS_CHAT_INPUT;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_ZIGZAG_TYPE;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_LAYOUT_DUPLICATES;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_MANUAL_BANK_FILTER;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_PANEL_VIEW;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_PERSIST_HOTKEYS;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_SECTION_MODE;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_SECTION_SORTING;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_SORTING_MODE;
import static inventorysetups.InventorySetupsPlugin.CONFIG_KEY_USE_LAYOUTS;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup(InventorySetupsPlugin.CONFIG_GROUP)
public interface InventorySetupsConfig extends Config
{

	@ConfigSection(
			name = "Default Options",
			description = "Default options for new setups",
			position = 0
	)
	String defaultSection = "defaultSection";

	@ConfigSection(
			name = "Hotkey Options",
			description = "Options for hot keys",
			position = 1
	)
	String hotkeySection = "hotkeysection";

	@ConfigSection(
			name = "Layout Options",
			description = "Options for bank layouts",
			position = 2
	)
	String layoutSection = "layoutSection";

	@ConfigSection(
			name = "Ground Item Menu Options",
			description = "Options for ground item menus (Useful for UIM)",
			position = 3
	)
	String groundItemSection = "groundItemSection";

	@ConfigSection(
			name = "Other",
			description = "Other options",
			position = 4
	)
	String otherSection = "otherSection";

	@ConfigItem(
			keyName = "bankFilter",
			name = "Default Filter Bank",
			description = "Configures the default setting for bank filtering in new setups",
			section = defaultSection
	)
	default boolean bankFilter()
	{
		return false;
	}

	@ConfigItem(
			keyName = "highlightStackDifference",
			name = "Default Highlight Stack Difference",
			description = "Configures the default setting for highlighting stack differences in new setups",
			hidden = true,
			section = defaultSection
	)
	default boolean highlightStackDifferenceOld()
	{
		return false;
	}

	@ConfigItem(
			keyName = "highlightStackDifferenceEnum",
			name = "Default Highlight Stack Difference",
			description = "Configures the default setting for highlighting stack differences in new setups",
			hidden = true,
			section = defaultSection
	)
	default InventorySetupsStackCompareID highlightStackDifference()
	{
		return InventorySetupsStackCompareID.None;
	}

	@ConfigItem(
			keyName = "highlightVarianceDifference",
			name = "Default Highlight Variation Difference",
			description = "Configures the default setting for highlighting variations in new setups",
			hidden = true,
			section = defaultSection
	)
	default boolean highlightVariationDifference()
	{
		return false;
	}

	@ConfigItem(
			keyName = "highlightUnorderedDifference",
			name = "Default Highlight Unordered Difference",
			description = "Configures the default setting for unordered highlighting in new setups",
			section = defaultSection
	)
	default boolean highlightUnorderedDifference()
	{
		return false;
	}

	@ConfigItem(
			keyName = "highlightDifference",
			name = "Default Highlight",
			description = "Configures the default setting for highlighting differences in new setups",
			section = defaultSection
	)
	default boolean highlightDifference()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
			keyName = "highlightColor",
			name = "Default Highlight Color",
			description = "Configures the default highlighting color in new setups",
			section = defaultSection
	)
	default Color highlightColor()
	{
		return Color.RED;
	}

	@ConfigItem(
			keyName = "enableDisplayColor",
			name = "Default Enable Display Color",
			description = "Configures the default display color in new setups",
			section = defaultSection
	)
	default boolean enableDisplayColor()
	{
		return false;
	}


	@ConfigItem(
			keyName = "displayColor",
			name = "Default Display Color",
			description = "Configures the default display color in new setups",
			section = defaultSection
	)
	default Color displayColor()
	{
		return Color.RED;
	}

	@ConfigItem(
			keyName = "fuzzy",
			name = "Default Fuzzy",
			description = "Configures the default setting for fuzziness in new setups",
			section = defaultSection
	)
	default boolean fuzzy()
	{
		return false;
	}

	@ConfigItem(
			keyName = "stackCompare",
			name = "Default Stack Compare",
			description = "Configures the default setting for stack compare in new setups",
			section = defaultSection
	)
	default InventorySetupsStackCompareID stackCompareType()
	{
		return InventorySetupsStackCompareID.None;
	}

	@ConfigItem(
			keyName = "returnToSetupsHotkey",
			name = "Return To Setups Hotkey",
			description = "Configures the hotkey for returning to setups",
			section = hotkeySection
	)
	default Keybind returnToSetupsHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "filterBankHotkey",
			name = "Filter Bank Hotkey",
			description = "Configures the hotkey for filtering all items in the bank",
			section = hotkeySection
	)
	default Keybind filterBankHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "filterBankInventoryOnlyHotkey",
			name = "Filter Inventory Hotkey",
			description = "Configures the hotkey for filtering the inventory in the bank",
			section = hotkeySection,
			hidden = true
	)
	default Keybind filterInventoryHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "filterBankEquipmentOnlyHotkey",
			name = "Filter Equipment Hotkey",
			description = "Configures the hotkey for filtering the equipment in the bank",
			section = hotkeySection,
			hidden = true
	)
	default Keybind filterEquipmentHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "filterBankAddItemstOnlyHotkey",
			name = "Filter Additional Items Hotkey",
			description = "Configures the hotkey for filtering the additional items in the bank",
			section = hotkeySection,
			hidden = true
	)
	default Keybind filterAddItemsHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "sectionModeHotkey",
			name = "Toggle section mode",
			description = "Configures the hotkey for toggling section mode",
			section = hotkeySection
	)
	default Keybind sectionModeHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_PERSIST_HOTKEYS,
			name = "Persist Hotkeys Outside Bank",
			description = "Configures hotkeys to persist even outside the bank",
			section = hotkeySection,
			position = 1
	)
	default boolean persistHotKeysOutsideBank()
	{
		return false;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_PERSIST_HOTKEYS_CHAT_INPUT,
			name = "Persist Hotkeys In Chat Inputs",
			description = "Configures hotkeys to persist even during a chat input (searching the bank, PMs, etc.)",
			section = hotkeySection,
			position = 2
	)
	default boolean persistHotKeysDuringChatInput()
	{
		return false;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_USE_LAYOUTS,
			name = "Use Layouts",
			description = "Use customizable layouts when filtering the bank. Uncheck this for classic bank filtering",
			section = layoutSection
	)
	default boolean useLayouts()
	{
		return true;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_LAYOUT_DEFAULT,
			name = "Default Layout",
			description = "Configures default bank layout when creating or updating a setup",
			section = layoutSection
	)
	default InventorySetupLayoutType defaultLayout()
	{
		return InventorySetupLayoutType.PRESET;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_ZIGZAG_TYPE,
			name = "ZigZag Type",
			description = "Configures ZigZag type when creating or updating a setup",
			section = layoutSection
	)
	default InventorySetupsZigZagTypeID zigZagType()
	{
		return InventorySetupsZigZagTypeID.TOP_TO_BOTTOM;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_LAYOUT_DUPLICATES,
			name = "Add Duplicates",
			description = "Configures layouts to create duplicates of items if you have multiple of that item in your setup",
			section = layoutSection
	)
	default boolean layoutDuplicates()
	{
		return true;
	}

	@ConfigItem(
			keyName = "groundItemMenuHighlight",
			name = "Highlight Menu Entries on Ground Items",
			description = "Highlights menu entries on ground items which are in the current setup",
			section = groundItemSection
	)
	default boolean groundItemMenuHighlight()
	{
		return false;
	}


	@ConfigItem(
			keyName = "groundItemMenuHighlightColor",
			name = "Highlight Menu Entries Color",
			description = "Highlight color for menu entries on ground items which are in the current setup",
			section = groundItemSection
	)
	default Color groundItemMenuHighlightColor()
	{
		return Color.decode("#87CEFA");
	}

	@ConfigItem(
			keyName = "groundItemMenuSwap",
			name = "Swap Menu Entries on Ground Items",
			description = "Swaps menu entries on ground items which are in the current setup",
			section = groundItemSection
	)
	default boolean groundItemMenuSwap()
	{
		return false;
	}

	@ConfigItem(
			keyName = "groundItemMenuSwapPriority",
			name = "Menu Entries Priority on Ground Items",
			description = "Choose which entries to swap to the top based on if ground items are in or not in the current setup",
			section = groundItemSection
	)
	default InventorySetupsGroundItemMenuSwapPriority groundItemMenuSwapPriority()
	{
		return InventorySetupsGroundItemMenuSwapPriority.OUT;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_SECTION_MODE,
			name = "Section Mode",
			description = "Configures the view to be in section mode",
			section = otherSection
	)
	default boolean sectionMode()
	{
		return false;
	}

	@ConfigItem(
		keyName = CONFIG_KEY_PANEL_VIEW,
		name = "Panel View",
		description = "Configures which type of panels are displayed for setups",
		section = otherSection
	)
	default InventorySetupsPanelViewID panelView()
	{
		return InventorySetupsPanelViewID.STANDARD;
	}

	@ConfigItem(
			keyName = "Deprecated",
			name = "Compact Mode",
			description = "Configures the setup panels to be compact",
			hidden = true
	)
	default boolean compactMode()
	{
		return false;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_SORTING_MODE,
			name = "Sorting Mode",
			description = "Configures the sorting of setups",
			section = otherSection
	)
	default InventorySetupsSortingID sortingMode()
	{
		return InventorySetupsSortingID.DEFAULT;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_SECTION_SORTING,
			name = "Section Sorting",
			description = "Sorts sections according to the sorting mode.",
			section = otherSection
	)
	default boolean sectionSorting()
	{
		return false;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_HIDE_BUTTON,
			name = "Hide Help Button",
			description = "Hide the help button",
			section = otherSection
	)
	default boolean hideButton()
	{
		return false;
	}

	@ConfigItem(
			keyName = "disableBankTabBarDeprecated",
			name = "Disable Bank Tab Separator",
			description = "Stops the thin bank tab separator from removing the bank filter when clicked",
			hidden = true
	)
	default boolean disableBankTabBar()
	{
		return false;
	}

	@ConfigItem(
			keyName = "removeBankTabSeparatorDeprecated",
			name = "Remove Bank Tab Separator",
			description = "Removes the thin bank tab separators from the bank filter",
			hidden = true
	)
	default boolean removeBankTabSeparator()
	{
		return false;
	}

	@ConfigItem(
			keyName = "requireActivePanelFilter",
			name = "Require Active Panel for Filtering",
			description = "Only allow filtering if the Inventory Setups panel is active",
			section = otherSection
	)
	default boolean requireActivePanelFilter()
	{
		return false;
	}

	@ConfigItem(
			keyName = "showWornItemsFilter",
			name = "Show Worn Items Filter",
			description = "Determines which setups show up when right clicking the show worn items menu",
			section = otherSection
	)
	default InventorySetupsShowWornItemsFilterID showWornItemsFilter()
	{
		return InventorySetupsShowWornItemsFilterID.All;
	}

	@ConfigItem(
			keyName = "showSectionSubmenusWornItems",
			name = "Worn Items Section Submenus",
			description = "Enable section submenus on the worn items button when section mode is enabled",
			section = otherSection
	)
	default boolean wornItemSelectionSubmenu()
	{
		return true;
	}


	@ConfigItem(
			keyName = CONFIG_KEY_MANUAL_BANK_FILTER,
			name = "Manual Bank Filter",
			description = "Disable automatic bank filtering when opening the bank",
			section = otherSection
	)
	default boolean manualBankFilter()
	{
		return false;
	}

	@ConfigItem(
			keyName = CONFIG_KEY_ENABLE_LAYOUT_WARNING,
			name = "Enable Layout Warning",
			description = "Show a warning panel upon startup if layouts will not work",
			section = otherSection
	)
	default boolean enableLayoutWarning()
	{
		return true;
	}



}

package inventorysetups;

import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.reflect.TypeToken;
import inventorysetups.serialization.InventorySetupItemSerializable;
import inventorysetups.serialization.InventorySetupItemSerializableTypeAdapter;
import inventorysetups.serialization.InventorySetupSerializable;
import inventorysetups.serialization.LongTypeAdapter;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static inventorysetups.InventorySetupsPlugin.CONFIG_GROUP;
import static inventorysetups.InventorySetupsPlugin.CONFIG_GROUP_HUB_BTL;
import static inventorysetups.InventorySetupsPlugin.LAYOUT_PREFIX_MARKER;
import net.runelite.client.plugins.banktags.BankTagsPlugin;
import net.runelite.client.plugins.banktags.tabs.Layout;

@Slf4j
public class InventorySetupsPersistentDataManager
{

	private final InventorySetupsPlugin plugin;
	private final ConfigManager configManager;
	private final InventorySetupsCache cache;

	private Gson gson;

	private final List<InventorySetup> inventorySetups;
	private final List<InventorySetupsSection> sections;


	// Fast non-cryptographic hash with relatively short output. Could use murmur3_32_fixed instead; but being extra cautious of collisions.
	public static final HashFunction hashFunction = Hashing.murmur3_128();

	public static final String CONFIG_KEY_SETUPS_MIGRATED_V2 = "migratedV2";
	public static final String CONFIG_KEY_SETUPS_MIGRATED_V3 = "migratedV3";
	public static final String CONFIG_KEY_SETUPS_MIGRATED_CORE_BTL = "migratedCoreBTL";
	public static final String CONFIG_KEY_SETUPS = "setups";
	public static final String CONFIG_KEY_SETUPS_V2 = "setupsV2";
	public static final String CONFIG_KEY_SETUPS_V3_PREFIX = "setupsV3_";
	public static final String CONFIG_KEY_SETUPS_ORDER_V3 = "setupsOrderV3_";
	public static final String CONFIG_KEY_SECTIONS = "sections";

	@Inject
	public InventorySetupsPersistentDataManager(final InventorySetupsPlugin plugin,
												final ConfigManager manager,
												final InventorySetupsCache cache,
												final Gson gson,
												final List<InventorySetup> inventorySetups,
												final List<InventorySetupsSection> sections)
	{
		this.plugin = plugin;
		this.configManager = manager;
		this.cache = cache;
		this.gson = gson;
		this.inventorySetups = inventorySetups;
		this.sections = sections;

		this.gson = this.gson.newBuilder().registerTypeAdapter(long.class, new LongTypeAdapter()).create();
		this.gson = this.gson.newBuilder().registerTypeAdapter(InventorySetupItemSerializable.class, new InventorySetupItemSerializableTypeAdapter()).create();
	}

	public void loadConfig()
	{
		inventorySetups.clear();
		sections.clear();
		cache.clearAll();

		// Handles migration of old setup data
		handleMigrationOfOldData();

		final List<InventorySetup> setupsFromConfig = loadV3Setups();
		inventorySetups.addAll(setupsFromConfig);
		processSetupsFromConfig();

		cleanSetupLayouts();
		Type sectionType = new TypeToken<ArrayList<InventorySetupsSection>>()
		{

		}.getType();
		sections.addAll(loadData(CONFIG_KEY_SECTIONS, sectionType));
		for (final InventorySetupsSection section : sections)
		{
			// Remove any duplicates that exist
			List<String> uniqueSetups = section.getSetups().stream().distinct().collect(Collectors.toList());
			section.setSetups(uniqueSetups);

			// Remove setups which don't exist in a section
			section.getSetups().removeIf(s -> !cache.getInventorySetupNames().containsKey(s));
			cache.addSection(section);
		}
	}

	public void updateConfig(boolean updateSetups, boolean updateSections)
	{
		if (updateSetups)
		{
			// Rather than escaping the name to pick a config key, instead use hash of the name. Benefits:
			//   Changes to the escaping function or supported characters in the name string don't affect config keys.
			//   Standardizes length; preventing overflow issues from extremely long names
			//   Keeps json as the single source of truth for names; other plugins won't try to grab names from config keys.
			final String wholePrefix = ConfigManager.getWholeKey(CONFIG_GROUP, null, CONFIG_KEY_SETUPS_V3_PREFIX);
			final List<String> oldSetupKeys = configManager.getConfigurationKeys(wholePrefix);
			Set<String> oldSetupHashes = oldSetupKeys.stream().map(key -> key.substring(wholePrefix.length())).collect(Collectors.toSet());

			final List<String> setupsOrder = new ArrayList<>();
			for (final InventorySetup setup : inventorySetups)
			{
				final String hash = hashFunction.hashUnencodedChars(setup.getName()).toString();
				setupsOrder.add(hash);
				oldSetupHashes.remove(hash);
				final String data = gson.toJson(InventorySetupSerializable.convertFromInventorySetup(setup));
				configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_V3_PREFIX + hash, data);
			}

			for (final String removedSetupHash : oldSetupHashes)
			{
				// Any hashes still in the oldSetupHashes set were for setups that were either renamed (and saved to a new hash above) or deleted.
				configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_V3_PREFIX + removedSetupHash);
			}

			final String setupsOrderJson = gson.toJson(setupsOrder);
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_ORDER_V3, setupsOrderJson);
		}

		if (updateSections)
		{
			final String jsonSections = gson.toJson(sections);
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_SECTIONS, jsonSections);
		}

	}

	private <T> List<T> loadData(final String configKey, Type type)
	{
		final String storedData = configManager.getConfiguration(CONFIG_GROUP, configKey);
		if (Strings.isNullOrEmpty(storedData))
		{
			return new ArrayList<>();
		}
		else
		{
			try
			{
				// serialize the internal data structure from the json in the configuration
				return gson.fromJson(storedData, type);
			}
			catch (Exception e)
			{
				log.error("Exception occurred while loading data", e);
				return new ArrayList<>();
			}
		}
	}

	private List<InventorySetup> loadV1Setups()
	{
		Type setupTypeV1 = new TypeToken<ArrayList<InventorySetup>>()
		{

		}.getType();
		return loadData(CONFIG_KEY_SETUPS, setupTypeV1);
	}

	private List<InventorySetup> loadV2Setups()
	{
		Type setupTypeV2 = new TypeToken<ArrayList<InventorySetupSerializable>>()
		{

		}.getType();
		List<InventorySetupSerializable> issList = new ArrayList<>(loadData(CONFIG_KEY_SETUPS_V2, setupTypeV2));
		List<InventorySetup> isList = new ArrayList<>();
		for (final InventorySetupSerializable iss : issList)
		{
			isList.add(InventorySetupSerializable.convertToInventorySetup(iss));
		}
		return isList;
	}

	private InventorySetup loadV3Setup(String configKey)
	{
		final String storedData = configManager.getConfiguration(CONFIG_GROUP, configKey);
		try
		{
			return InventorySetupSerializable.convertToInventorySetup(gson.fromJson(storedData, InventorySetupSerializable.class));
		}
		catch (Exception e)
		{
			log.error(String.format("Exception occurred while loading %s", configKey), e);
			throw e;
		}
	}

	private List<InventorySetup> loadV3Setups()
	{
		final String wholePrefix = ConfigManager.getWholeKey(CONFIG_GROUP, null, CONFIG_KEY_SETUPS_V3_PREFIX);
		final List<String> loadedSetupWholeKeys = configManager.getConfigurationKeys(wholePrefix);
		Set<String> loadedSetupKeys = loadedSetupWholeKeys.stream().map(
			key -> key.substring(wholePrefix.length() - CONFIG_KEY_SETUPS_V3_PREFIX.length())
		).collect(Collectors.toSet());

		Type setupsOrderType = new TypeToken<ArrayList<String>>()
		{

		}.getType();
		final String setupsOrderJson = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_ORDER_V3);
		List<String> setupsOrder = gson.fromJson(setupsOrderJson, setupsOrderType);
		if (setupsOrder == null)
		{
			setupsOrder = new ArrayList<>();
		}

		List<InventorySetup> loadedSetups = new ArrayList<>();
		for (final String configHash : setupsOrder)
		{
			final String configKey = CONFIG_KEY_SETUPS_V3_PREFIX + configHash;
			if (loadedSetupKeys.remove(configKey))
			{ // Handles if hash is present only in configOrder.
				final InventorySetup setup = loadV3Setup(configKey);
				loadedSetups.add(setup);
			}
		}
		for (final String configKey : loadedSetupKeys)
		{
			// Load any remaining setups not present in setupsOrder. Useful if updateConfig crashes midway.
			log.info("Loading setup that was missing from Order key: " + configKey);
			final InventorySetup setup = loadV3Setup(configKey);
			loadedSetups.add(setup);
		}
		return loadedSetups;
	}

	private void processSetupsFromConfig()
	{
		final String migratedCoreBTL = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_MIGRATED_CORE_BTL);
		final boolean hasMigratedToCoreBTL = !Strings.isNullOrEmpty(migratedCoreBTL) && migratedCoreBTL.equals("true");
		for (final InventorySetup setup : inventorySetups)
		{
			final List<InventorySetupsItem> potentialRunePouch = plugin.getAmmoHandler().getRunePouchDataIfInContainer(setup.getInventory());
			if (setup.getRune_pouch() == null && potentialRunePouch != null)
			{
				setup.updateRunePouch(potentialRunePouch);
			}
			final List<InventorySetupsItem> potentialBoltPouch = plugin.getAmmoHandler().getBoltPouchDataIfInContainer(setup.getInventory());
			if (setup.getBoltPouch() == null && potentialBoltPouch != null)
			{
				setup.updateBoltPouch(potentialBoltPouch);
			}
			final List<InventorySetupsItem> potentialQuiver = plugin.getAmmoHandler().getQuiverDataIfInSetup(setup.getInventory(), setup.getEquipment());
			if (setup.getQuiver() == null && potentialQuiver != null)
			{
				setup.updateQuiver(potentialQuiver);
			}
			if (setup.getNotes() == null)
			{
				setup.updateNotes("");
			}
			if (setup.getAdditionalFilteredItems() == null)
			{
				setup.updateAdditionalItems(new HashMap<>());
			}

			// Fix layouts
			processSetupLayout(setup, hasMigratedToCoreBTL);

			// Makes sure all tags are hidden. This should be done as the plugin manages tags but this acts as
			// a safeguard in case somehow it's missed.
			final String tag = InventorySetupLayoutUtilities.getTagNameForLayout(setup.getName());
			plugin.getTagManager().setHidden(tag, true);

			cache.addSetup(setup);

			// add Item names to all the items in the setup.
			InventorySetup.getSetupItems(setup).forEach(this::addItemName);
		}

		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_MIGRATED_CORE_BTL, "true");

	}

	private void processSetupLayout(final InventorySetup setup, final boolean hasMigratedToCoreBTL)
	{
		// Fix any issues with layouts this setup might have.
		final String tag = InventorySetupLayoutUtilities.getTagNameForLayout(setup.getName());
		final Layout setupLayout = plugin.getLayoutManager().loadLayout(tag);
		if (setupLayout != null)
		{
			return;
		}

		// No layout exists for this setup, let's create one. This will add the tag too.
		final Layout newLayout = plugin.getLayoutUtilities().createSetupLayout(setup);

		if (hasMigratedToCoreBTL)
		{
			// Somehow this setup doesn't have a layout even though it's not the first time using the plugin.
			// This shouldn't be hit unless some config surgery was done. Save the layout and be done.
			plugin.getLayoutManager().saveLayout(newLayout);
			return;
		}

		// This is the first time using the plugin since the core BTL migration. Check for a BTL Layout in the config.
		// Sanitization code was taken from bank tag layouts
		final String sanitizedSetupName = setup.getName().replaceAll("&", "&amp;").replaceAll(":", "&#58;");
		final String expectedHubBTLKey = "inventory_setups_layout_" + sanitizedSetupName;
		final String btlHubLayoutData = configManager.getConfiguration(CONFIG_GROUP_HUB_BTL, expectedHubBTLKey);
		if (Strings.isNullOrEmpty(btlHubLayoutData))
		{
			// No BTL Hub data found to migrate, just save the layout and finish.
			plugin.getLayoutManager().saveLayout(newLayout);
			return;
		}

		log.info("Found Hub Bank Tag Layout for setup " + setup.getName());

		// A BTL hub layout was found, convert it!
		final Layout hubBankTagLayout = plugin.getLayoutUtilities().convertHubBankTagLayoutToCoreBankTagLayout(btlHubLayoutData, tag);
		if (hubBankTagLayout == null)
		{
			log.warn("Failed to convert Hub Bank Tag Layout for setup " + setup.getName());
			// Some problem occurred during the conversion, just save the layout and finish.
			plugin.getLayoutManager().saveLayout(newLayout);
		}
		else
		{
			log.info("Migrating Hub Bank Tag Layout for setup " + setup.getName());
			// This could possibly have some weird items in the layout, but the recalculate method will fix these
			// When a user updates the layout.
			plugin.getLayoutManager().saveLayout(hubBankTagLayout);

			// Someday we might want to delete the hubBTL config key, but not until the migration is stable.
			// This could be done in the caller of this function. Not a huge priority.
		}
	}

	private void cleanSetupLayouts()
	{
		final String layoutKeyPrefix = ConfigManager.getWholeKey(BankTagsPlugin.CONFIG_GROUP, null, BankTagsPlugin.TAG_LAYOUT_PREFIX);
		final List<String> layoutKeys = configManager.getConfigurationKeys(layoutKeyPrefix);

		Set<String> inventorySetupLayoutKeys = layoutKeys.stream()
				.filter(key -> key.contains(LAYOUT_PREFIX_MARKER))
				.collect(Collectors.toSet());

		for (final InventorySetup setup: inventorySetups)
		{
			String key = layoutKeyPrefix + InventorySetupLayoutUtilities.getTagNameForLayout(setup.getName());
			inventorySetupLayoutKeys.remove(key);
		}

		// The remaining keys are those which have the inventory setup layout prefix but no setup exists for them.
		// Meaning they are dangling layouts. Remove them.
		int keyLengthMinusHash = (layoutKeyPrefix + LAYOUT_PREFIX_MARKER).length();
		for (final String key : inventorySetupLayoutKeys)
		{
			String removedSetupHash = key.substring(keyLengthMinusHash);

			// This will remove the "banktag.layouts_" key and remove the tag from every "banktags.item_" that references this tag.
			// Due to the nature of this cleanup algorithm, if a "banktags.item_" key refers to a tag
			// that doesn't have a "banktag.layouts_" key, then it will not be found and remain dangling.
			// This will likely never be the case. This cleanup is primarily to ensure no rogue inventory setup tags appear
			// in the Bank or chat UI when users edit or see tags.
			plugin.getTagManager().removeTag(LAYOUT_PREFIX_MARKER + removedSetupHash);
		}
	}

	private void addItemName(final InventorySetupsItem item)
	{
		item.setName(plugin.getItemManager().getItemComposition(item.getId()).getName());
	}

	private void handleMigrationOfOldData()
	{
		String hasMigratedToV2 = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_MIGRATED_V2);
		if (Strings.isNullOrEmpty(hasMigratedToV2))
		{
			log.info("Migrating data from V1 to V3");
			inventorySetups.addAll(loadV1Setups());
			updateConfig(true, false);
			inventorySetups.clear();
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_MIGRATED_V2, "True");
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_MIGRATED_V3, "True");
		}

		String oldV1Data = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS);
		if (oldV1Data != null)
		{
			log.info("Removing old v1 data key");
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS);
		}

		String hasMigratedToV3 = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_MIGRATED_V3);
		if (Strings.isNullOrEmpty(hasMigratedToV3))
		{
			log.info("Migrating data from V2 to V3");
			inventorySetups.addAll(loadV2Setups());
			updateConfig(true, false);
			inventorySetups.clear();
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_MIGRATED_V3, "True");
		}

		String oldV2Data = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_V2);
		if (oldV2Data != null)
		{
			log.info("Removing old v2 data key");
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_V2);
		}
	}

	private String fixOldJSONData(final String json)
	{
		JsonElement je = this.gson.fromJson(json, JsonElement.class);
		JsonArray ja = je.getAsJsonArray();
		for (JsonElement elem : ja)
		{
			JsonObject setup = elem.getAsJsonObject();

			// Example if needed in the future
//			if (setup.getAsJsonPrimitive("stackDifference").isBoolean())
//			{
//				int stackDiff = setup.get("stackDifference").getAsBoolean() ? 1 : 0;
//				setup.remove("stackDifference");
//				setup.addProperty("stackDifference", stackDiff);
//			}
		}
		return je.toString();
	}


}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public enum InventorySetupsStackCompareID
{
	// Don't highlight at all
	None(0),

	// Only highlight if stacks are equal
	Standard(1),

	// Only highlight if stack is less than what is in the setup
	Less_Than(2),

	// Only highlight if stack is greater than what is in the setup
	Greater_Than(3);

	private final int type;

	private static final List<InventorySetupsStackCompareID> VALUES;

	static
	{
		VALUES = new ArrayList<>();
		Collections.addAll(VALUES, InventorySetupsStackCompareID.values());
	}

	InventorySetupsStackCompareID(int type)
	{
		this.type = type;
	}

	public int getType()
	{
		return type;
	}

	public static List<InventorySetupsStackCompareID> getValues()
	{
		return VALUES;
	}

	public static String getStringFromValue(final InventorySetupsStackCompareID stackCompare)
	{
		if (stackCompare == null)
		{
			return "";
		}

		switch (stackCompare)
		{
			case None:
				return "";
			case Standard:
				return "!=";
			case Less_Than:
				return "<";
			case Greater_Than:
				return ">";
		}

		return "";
	}

}

/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
public class InventorySetupsItem
{
	@Getter
	private final int id;
	@Getter
	@Setter
	private String name;
	@Getter
	@Setter
	private int quantity;
	@Getter
	@Setter
	private boolean fuzzy;
	@Getter
	@Setter
	private InventorySetupsStackCompareID stackCompare;

	public void toggleIsFuzzy()
	{
		fuzzy = !fuzzy;
	}

	public static InventorySetupsItem getDummyItem()
	{
		return new InventorySetupsItem(-1, "", 0, false, InventorySetupsStackCompareID.None);
	}

	public static boolean itemIsDummy(final InventorySetupsItem item)
	{
		// Don't use the name to compare
		return item.getId() == -1 &&
				item.getQuantity() == 0 &&
				!item.isFuzzy() &&
				(item.getStackCompare() == InventorySetupsStackCompareID.None || item.getStackCompare() == null);
	}

}

/*
 * Copyright (c) 2022, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package inventorysetups;

import java.awt.Color;

public interface InventorySetupsDisplayAttributes
{
	String getName();
	void setName(final String name);
	Color getDisplayColor();
	void setDisplayColor(final Color color);
}

package inventorysetups;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static net.runelite.api.gameval.ItemID.*;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;
import net.runelite.client.game.ItemVariationMapping;

public class InventorySetupsVariationMapping
{
	private static final Map<Integer, Integer> mappings;

	private static final Multimap<Integer, Integer> invertedMappings;


	// Worn items with weight reducing property have a different worn and inventory ItemID
	// Copy of ItemManger::WORN_ITEMS. Use that instead if it becomes a publicly usable member.
	private static final ImmutableMap<Integer, Integer> WORN_ITEMS = ImmutableMap.<Integer, Integer>builder().
			put(IKOV_BOOTSOFLIGHTNESSWORN, IKOV_BOOTSOFLIGHTNESS).
			put(BARBASSAULT_PENANCE_GLOVES_WORN, BARBASSAULT_PENANCE_GLOVES).

			put(GRACEFUL_HOOD_WORN, GRACEFUL_HOOD).
			put(GRACEFUL_CAPE_WORN, GRACEFUL_CAPE).
			put(GRACEFUL_TOP_WORN, GRACEFUL_TOP).
			put(GRACEFUL_LEGS_WORN, GRACEFUL_LEGS).
			put(GRACEFUL_GLOVES_WORN, GRACEFUL_GLOVES).
			put(GRACEFUL_BOOTS_WORN, GRACEFUL_BOOTS).
			put(ZEAH_GRACEFUL_HOOD_ARCEUUS_WORN, ZEAH_GRACEFUL_HOOD_ARCEUUS).
			put(ZEAH_GRACEFUL_CAPE_ARCEUUS_WORN, ZEAH_GRACEFUL_CAPE_ARCEUUS).
			put(ZEAH_GRACEFUL_TOP_ARCEUUS_WORN, ZEAH_GRACEFUL_TOP_ARCEUUS).
			put(ZEAH_GRACEFUL_LEGS_ARCEUUS_WORN, ZEAH_GRACEFUL_LEGS_ARCEUUS).
			put(ZEAH_GRACEFUL_GLOVES_ARCEUUS_WORN, ZEAH_GRACEFUL_GLOVES_ARCEUUS).
			put(ZEAH_GRACEFUL_BOOTS_ARCEUUS_WORN, ZEAH_GRACEFUL_BOOTS_ARCEUUS).
			put(ZEAH_GRACEFUL_HOOD_PISCARILIUS_WORN, ZEAH_GRACEFUL_HOOD_PISCARILIUS).
			put(ZEAH_GRACEFUL_CAPE_PISCARILIUS_WORN, ZEAH_GRACEFUL_CAPE_PISCARILIUS).
			put(ZEAH_GRACEFUL_TOP_PISCARILIUS_WORN, ZEAH_GRACEFUL_TOP_PISCARILIUS).
			put(ZEAH_GRACEFUL_LEGS_PISCARILIUS_WORN, ZEAH_GRACEFUL_LEGS_PISCARILIUS).
			put(ZEAH_GRACEFUL_GLOVES_PISCARILIUS_WORN, ZEAH_GRACEFUL_GLOVES_PISCARILIUS).
			put(ZEAH_GRACEFUL_BOOTS_PISCARILIUS_WORN, ZEAH_GRACEFUL_BOOTS_PISCARILIUS).
			put(ZEAH_GRACEFUL_HOOD_LOVAKENGJ_WORN, ZEAH_GRACEFUL_HOOD_LOVAKENGJ).
			put(ZEAH_GRACEFUL_CAPE_LOVAKENGJ_WORN, ZEAH_GRACEFUL_CAPE_LOVAKENGJ).
			put(ZEAH_GRACEFUL_TOP_LOVAKENGJ_WORN, ZEAH_GRACEFUL_TOP_LOVAKENGJ).
			put(ZEAH_GRACEFUL_LEGS_LOVAKENGJ_WORN, ZEAH_GRACEFUL_LEGS_LOVAKENGJ).
			put(ZEAH_GRACEFUL_GLOVES_LOVAKENGJ_WORN, ZEAH_GRACEFUL_GLOVES_LOVAKENGJ).
			put(ZEAH_GRACEFUL_BOOTS_LOVAKENGJ_WORN, ZEAH_GRACEFUL_BOOTS_LOVAKENGJ).
			put(ZEAH_GRACEFUL_HOOD_SHAYZIEN_WORN, ZEAH_GRACEFUL_HOOD_SHAYZIEN).
			put(ZEAH_GRACEFUL_CAPE_SHAYZIEN_WORN, ZEAH_GRACEFUL_CAPE_SHAYZIEN).
			put(ZEAH_GRACEFUL_TOP_SHAYZIEN_WORN, ZEAH_GRACEFUL_TOP_SHAYZIEN).
			put(ZEAH_GRACEFUL_LEGS_SHAYZIEN_WORN, ZEAH_GRACEFUL_LEGS_SHAYZIEN).
			put(ZEAH_GRACEFUL_GLOVES_SHAYZIEN_WORN, ZEAH_GRACEFUL_GLOVES_SHAYZIEN).
			put(ZEAH_GRACEFUL_BOOTS_SHAYZIEN_WORN, ZEAH_GRACEFUL_BOOTS_SHAYZIEN).
			put(ZEAH_GRACEFUL_HOOD_HOSIDIUS_WORN, ZEAH_GRACEFUL_HOOD_HOSIDIUS).
			put(ZEAH_GRACEFUL_CAPE_HOSIDIUS_WORN, ZEAH_GRACEFUL_CAPE_HOSIDIUS).
			put(ZEAH_GRACEFUL_TOP_HOSIDIUS_WORN, ZEAH_GRACEFUL_TOP_HOSIDIUS).
			put(ZEAH_GRACEFUL_LEGS_HOSIDIUS_WORN, ZEAH_GRACEFUL_LEGS_HOSIDIUS).
			put(ZEAH_GRACEFUL_GLOVES_HOSIDIUS_WORN, ZEAH_GRACEFUL_GLOVES_HOSIDIUS).
			put(ZEAH_GRACEFUL_BOOTS_HOSIDIUS_WORN, ZEAH_GRACEFUL_BOOTS_HOSIDIUS).
			put(ZEAH_GRACEFUL_HOOD_KOUREND_WORN, ZEAH_GRACEFUL_HOOD_KOUREND).
			put(ZEAH_GRACEFUL_CAPE_KOUREND_WORN, ZEAH_GRACEFUL_CAPE_KOUREND).
			put(ZEAH_GRACEFUL_TOP_KOUREND_WORN, ZEAH_GRACEFUL_TOP_KOUREND).
			put(ZEAH_GRACEFUL_LEGS_KOUREND_WORN, ZEAH_GRACEFUL_LEGS_KOUREND).
			put(ZEAH_GRACEFUL_GLOVES_KOUREND_WORN, ZEAH_GRACEFUL_GLOVES_KOUREND).
			put(ZEAH_GRACEFUL_BOOTS_KOUREND_WORN, ZEAH_GRACEFUL_BOOTS_KOUREND).
			put(GRACEFUL_HOOD_SKILLCAPECOLOUR_WORN, GRACEFUL_HOOD_SKILLCAPECOLOUR).
			put(GRACEFUL_CAPE_SKILLCAPECOLOUR_WORN, GRACEFUL_CAPE_SKILLCAPECOLOUR).
			put(GRACEFUL_TOP_SKILLCAPECOLOUR_WORN, GRACEFUL_TOP_SKILLCAPECOLOUR).
			put(GRACEFUL_LEGS_SKILLCAPECOLOUR_WORN, GRACEFUL_LEGS_SKILLCAPECOLOUR).
			put(GRACEFUL_GLOVES_SKILLCAPECOLOUR_WORN, GRACEFUL_GLOVES_SKILLCAPECOLOUR).
			put(GRACEFUL_BOOTS_SKILLCAPECOLOUR_WORN, GRACEFUL_BOOTS_SKILLCAPECOLOUR).
			put(GRACEFUL_HOOD_HALLOWED_WORN, GRACEFUL_HOOD_HALLOWED).
			put(GRACEFUL_CAPE_HALLOWED_WORN, GRACEFUL_CAPE_HALLOWED).
			put(GRACEFUL_TOP_HALLOWED_WORN, GRACEFUL_TOP_HALLOWED).
			put(GRACEFUL_LEGS_HALLOWED_WORN, GRACEFUL_LEGS_HALLOWED).
			put(GRACEFUL_GLOVES_HALLOWED_WORN, GRACEFUL_GLOVES_HALLOWED).
			put(GRACEFUL_BOOTS_HALLOWED_WORN, GRACEFUL_BOOTS_HALLOWED).
			put(GRACEFUL_HOOD_TRAILBLAZER_WORN, GRACEFUL_HOOD_TRAILBLAZER).
			put(GRACEFUL_CAPE_TRAILBLAZER_WORN, GRACEFUL_CAPE_TRAILBLAZER).
			put(GRACEFUL_TOP_TRAILBLAZER_WORN, GRACEFUL_TOP_TRAILBLAZER).
			put(GRACEFUL_LEGS_TRAILBLAZER_WORN, GRACEFUL_LEGS_TRAILBLAZER).
			put(GRACEFUL_GLOVES_TRAILBLAZER_WORN, GRACEFUL_GLOVES_TRAILBLAZER).
			put(GRACEFUL_BOOTS_TRAILBLAZER_WORN, GRACEFUL_BOOTS_TRAILBLAZER).
			put(GRACEFUL_HOOD_ADVENTURER_WORN, GRACEFUL_HOOD_ADVENTURER).
			put(GRACEFUL_CAPE_ADVENTURER_WORN, GRACEFUL_CAPE_ADVENTURER).
			put(GRACEFUL_TOP_ADVENTURER_WORN, GRACEFUL_TOP_ADVENTURER).
			put(GRACEFUL_LEGS_ADVENTURER_WORN, GRACEFUL_LEGS_ADVENTURER).
			put(GRACEFUL_GLOVES_ADVENTURER_WORN, GRACEFUL_GLOVES_ADVENTURER).
			put(GRACEFUL_BOOTS_ADVENTURER_WORN, GRACEFUL_BOOTS_ADVENTURER).
			put(GRACEFUL_HOOD_WYRM_WORN, GRACEFUL_HOOD_WYRM).
			put(GRACEFUL_CAPE_WYRM_WORN, GRACEFUL_CAPE_WYRM).
			put(GRACEFUL_TOP_WYRM_WORN, GRACEFUL_TOP_WYRM).
			put(GRACEFUL_LEGS_WYRM_WORN, GRACEFUL_LEGS_WYRM).
			put(GRACEFUL_GLOVES_WYRM_WORN, GRACEFUL_GLOVES_WYRM).
			put(GRACEFUL_BOOTS_WYRM_WORN, GRACEFUL_BOOTS_WYRM).

			put(SKILLCAPE_MAX_WORN, SKILLCAPE_MAX).

			put(HUNTING_LIGHT_CAPE_WORN, HUNTING_LIGHT_CAPE).
			put(HUNTING_LIGHTER_CAPE_WORN, HUNTING_LIGHTER_CAPE).

			put(SKILLCAPE_AGILITY_TRIMMED_WORN, SKILLCAPE_AGILITY_TRIMMED).
			put(SKILLCAPE_AGILITY_WORN, SKILLCAPE_AGILITY).

			put(HUNTING_CAMOFLAUGE_ROBE_WOOD_WORN, HUNTING_CAMOFLAUGE_ROBE_WOOD).
			put(HUNTING_TROUSERS_WOOD_WORN, HUNTING_TROUSERS_WOOD).
			put(HUNTING_CAMOFLAUGE_ROBE_JUNGLE_WORN, HUNTING_CAMOFLAUGE_ROBE_JUNGLE).
			put(HUNTING_TROUSERS_JUNGLE_WORN, HUNTING_TROUSERS_JUNGLE).
			put(HUNTING_CAMOFLAUGE_ROBE_DESERT_WORN, HUNTING_CAMOFLAUGE_ROBE_DESERT).
			put(HUNTING_TROUSERS_DESERT_WORN, HUNTING_TROUSERS_DESERT).
			put(HUNTING_CAMOFLAUGE_ROBE_POLAR_WORN, HUNTING_CAMOFLAUGE_ROBE_POLAR).
			put(HUNTING_TROUSERS_POLAR_WORN, HUNTING_TROUSERS_POLAR).
			build();

	public static final Map<Integer, Integer> INVERTED_WORN_ITEMS;

	public InventorySetupsVariationMapping()
	{
	}

	public static int map(final Integer id)
	{
		int mappedId = ItemVariationMapping.map(id);

		// if the mapped ID is equal to the original id
		// this means there was no mapping for this id. Try the extra custom mappings
		if (mappedId == id)
		{
			mappedId = mappings.getOrDefault(id, id);
		}

		return mappedId;
	}

	public static Collection<Integer> getVariations(int itemId)
	{
		Collection<Integer> baseMappings = ItemVariationMapping.getVariations(itemId);
		Collection<Integer> customMappings = invertedMappings.asMap().getOrDefault(itemId, Collections.singletonList(itemId));
		Collection<Integer> allMappings = new LinkedHashSet<>(baseMappings);
		allMappings.addAll(customMappings);
		return allMappings;
	}

	static
	{
		mappings = new HashMap<>();

		// Granite Cannonball -> Cannonball
		mappings.put(GRANITE_CANNONBALL, MCANNONBALL);

		// Smith Gloves (i) act as ice gloves
		mappings.put(SMITHING_UNIFORM_GLOVES_ICE, ICE_GLOVES);

		// Divine rune pouch -> Rune Pouch
		mappings.put(DIVINE_RUNE_POUCH, BH_RUNE_POUCH);

		// Make god capes the same
		final int itemIDGodCape = 1000000001;
		mappings.put(SARADOMIN_CAPE, itemIDGodCape);
		mappings.put(GUTHIX_CAPE, itemIDGodCape);
		mappings.put(ZAMORAK_CAPE, itemIDGodCape);
		final int itemIDImbuedGodCape = 1000000002;
		mappings.put(MA2_SARADOMIN_CAPE, itemIDImbuedGodCape);
		mappings.put(MA2_GUTHIX_CAPE, itemIDImbuedGodCape);
		mappings.put(MA2_ZAMORAK_CAPE, itemIDImbuedGodCape);
		mappings.put(MA2_SARADOMIN_CAPE_TROUVER, itemIDImbuedGodCape);
		mappings.put(MA2_GUTHIX_CAPE_TROUVER, itemIDImbuedGodCape);
		mappings.put(MA2_ZAMORAK_CAPE_TROUVER, itemIDImbuedGodCape);
		final int itemIDGodMaxCape = 1000000003;
		mappings.put(SKILLCAPE_MAX_SARADOMIN, itemIDGodMaxCape);
		mappings.put(SKILLCAPE_MAX_GUTHIX, itemIDGodMaxCape);
		mappings.put(SKILLCAPE_MAX_ZAMORAK, itemIDGodMaxCape);
		final int itemIDImbuedGodMaxCape = 1000000004;
		mappings.put(SKILLCAPE_MAX_SARADOMIN2, itemIDImbuedGodMaxCape);
		mappings.put(SKILLCAPE_MAX_GUTHIX2, itemIDImbuedGodMaxCape);
		mappings.put(SKILLCAPE_MAX_ZAMORAK2, itemIDImbuedGodMaxCape);
		mappings.put(SKILLCAPE_MAX_SARADOMIN2_TROUVER, itemIDImbuedGodMaxCape);
		mappings.put(SKILLCAPE_MAX_GUTHIX2_TROUVER, itemIDImbuedGodMaxCape);
		mappings.put(SKILLCAPE_MAX_ZAMORAK2_TROUVER, itemIDImbuedGodMaxCape);

		// Make god d'hides the same
		final int itemIDGodCoif = 1000000005;
		mappings.put(TRAIL_ANCIENT_COIF, itemIDGodCoif);
		mappings.put(TRAIL_ARMADYL_COIF, itemIDGodCoif);
		mappings.put(TRAIL_BANDOS_COIF, itemIDGodCoif);
		mappings.put(TRAIL_GUTHIX_COIF, itemIDGodCoif);
		mappings.put(TRAIL_SARADOMIN_COIF, itemIDGodCoif);
		mappings.put(TRAIL_ZAMORAK_COIF, itemIDGodCoif);

		final int itemIDGodDhideBody = 1000000006;
		mappings.put(TRAIL_ANCIENT_CHEST, itemIDGodDhideBody);
		mappings.put(TRAIL_ARMADYL_CHEST , itemIDGodDhideBody);
		mappings.put(TRAIL_BANDOS_CHEST, itemIDGodDhideBody);
		mappings.put(TRAIL_GUTHIX_CHEST, itemIDGodDhideBody);
		mappings.put(TRAIL_SARADOMIN_CHEST, itemIDGodDhideBody);
		mappings.put(TRAIL_ZAMORAK_CHEST, itemIDGodDhideBody);

		final int itemIDGodChaps = 1000000007;
		mappings.put(TRAIL_ANCIENT_CHAPS, itemIDGodChaps);
		mappings.put(TRAIL_ARMADYL_CHAPS, itemIDGodChaps);
		mappings.put(TRAIL_BANDOS_CHAPS, itemIDGodChaps);
		mappings.put(TRAIL_GUTHIX_CHAPS, itemIDGodChaps);
		mappings.put(TRAIL_SARADOMIN_CHAPS, itemIDGodChaps);
		mappings.put(TRAIL_ZAMORAK_CHAPS, itemIDGodChaps);

		final int itemIDGodBracers = 1000000008;
		mappings.put(TRAIL_ANCIENT_VAMBRACES, itemIDGodBracers);
		mappings.put(TRAIL_ARMADYL_VAMBRACES, itemIDGodBracers);
		mappings.put(TRAIL_BANDOS_VAMBRACES, itemIDGodBracers);
		mappings.put(TRAIL_GUTHIX_VAMBRACES, itemIDGodBracers);
		mappings.put(TRAIL_SARADOMIN_VAMBRACES, itemIDGodBracers);
		mappings.put(TRAIL_ZAMORAK_VAMBRACES, itemIDGodBracers);

		final int itemIDGodDhideBoots = 1000000009;
		mappings.put(BLESSED_BOOTS_ANCIENT, itemIDGodDhideBoots);
		mappings.put(BLESSED_BOOTS_ARMADYL, itemIDGodDhideBoots);
		mappings.put(BLESSED_BOOTS_BANDOS, itemIDGodDhideBoots);
		mappings.put(BLESSED_BOOTS_GUTHIX, itemIDGodDhideBoots);
		mappings.put(BLESSED_BOOTS_SARADOMIN, itemIDGodDhideBoots);
		mappings.put(BLESSED_BOOTS_ZAMORAK, itemIDGodDhideBoots);

		final int itemIDGodDhideShield = 1000000010;
		mappings.put(BLESSED_DHIDE_SHIELD_ANCIENT, itemIDGodDhideShield);
		mappings.put(BLESSED_DHIDE_SHIELD_ARMADYL, itemIDGodDhideShield);
		mappings.put(BLESSED_DHIDE_SHIELD_BANDOS, itemIDGodDhideShield);
		mappings.put(BLESSED_DHIDE_SHIELD_GUTHIX, itemIDGodDhideShield);
		mappings.put(BLESSED_DHIDE_SHIELD_SARADOMIN, itemIDGodDhideShield);
		mappings.put(BLESSED_DHIDE_SHIELD_ZAMORAK, itemIDGodDhideShield);

		// Twisted Ancestral -> Regular Ancestral
		mappings.put(ANCESTRAL_HAT_TWISTED, ANCESTRAL_HAT);
		mappings.put(ANCESTRAL_ROBE_BOTTOM_TWISTED, ANCESTRAL_ROBE_BOTTOM);
		mappings.put(ANCESTRAL_ROBE_TOP_TWISTED, ANCESTRAL_ROBE_TOP);

		// Golden Prospectors -> Regular Prospectors
		mappings.put(MOTHERLODE_REWARD_BOOTS_GOLD, MOTHERLODE_REWARD_BOOTS);
		mappings.put(MOTHERLODE_REWARD_HAT_GOLD, MOTHERLODE_REWARD_HAT);
		mappings.put(MOTHERLODE_REWARD_TOP_GOLD, MOTHERLODE_REWARD_TOP);
		mappings.put(MOTHERLODE_REWARD_LEGS_GOLD, MOTHERLODE_REWARD_LEGS);

		// Spirit Anglers -> Regular Anglers
		mappings.put(SPIRIT_ANGLER_BOOTS, TRAWLER_REWARD_BOOTS);
		mappings.put(SPIRIT_ANGLER_HAT, TRAWLER_REWARD_HAT);
		mappings.put(SPIRIT_ANGLER_TOP, TRAWLER_REWARD_TOP);
		mappings.put(SPIRIT_ANGLER_LEGS, TRAWLER_REWARD_LEGS);
		
		// ToB ornament kits -> base version
		mappings.put(SCYTHE_OF_VITUR_BL, SCYTHE_OF_VITUR);
		mappings.put(SCYTHE_OF_VITUR_OR, SCYTHE_OF_VITUR);
		mappings.put(SANGUINESTI_STAFF_OR, SANGUINESTI_STAFF);
		mappings.put(GHRAZI_RAPIER_OR, GHRAZI_RAPIER);

		mappings.put(INFERNAL_DEFENDER_GHOMMAL_5, INFERNAL_DEFENDER);
		mappings.put(INFERNAL_DEFENDER_GHOMMAL_5_TROUVER, INFERNAL_DEFENDER);
		mappings.put(INFERNAL_DEFENDER_GHOMMAL_6 , INFERNAL_DEFENDER);
		mappings.put(INFERNAL_DEFENDER_GHOMMAL_6_TROUVER, INFERNAL_DEFENDER);

		// Blazing blowpipe -> toxic blowpipe
		mappings.put(TOXIC_BLOWPIPE_ORNAMENT, TOXIC_BLOWPIPE);
		mappings.put(TOXIC_BLOWPIPE_LOADED_ORNAMENT, TOXIC_BLOWPIPE_LOADED);

		// Locked fire/infernal cape -> regular capes
		mappings.put(TZHAAR_CAPE_FIRE_TROUVER, TZHAAR_CAPE_FIRE);
		mappings.put(INFERNAL_CAPE_TROUVER, INFERNAL_CAPE);

		// Blood Torva -> Regular Torva
		mappings.put(TORVA_HELM_SANGUINE, TORVA_HELM);
		mappings.put(TORVA_CHEST_SANGUINE, TORVA_CHEST);
		mappings.put(TORVA_LEGS_SANGUINE, TORVA_LEGS);

		ImmutableMultimap.Builder<Integer, Integer> invertedBuilder = new ImmutableMultimap.Builder<>();
		Set<Integer> addedValues = new HashSet<>();
		for (Integer key : mappings.keySet())
		{
			Integer value = mappings.get(key);
			invertedBuilder.put(value, key);
			if (addedValues.add(value))
			{
				invertedBuilder.put(value, value);
			}
		}
		invertedMappings = invertedBuilder.build();

		// INVERTED_WORN_ITEMS mapping
		INVERTED_WORN_ITEMS = WORN_ITEMS.entrySet()
										.stream()
										.collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));

	}



}

package inventorysetups.serialization;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupLayoutUtilities;
import lombok.Value;
import net.runelite.client.plugins.banktags.tabs.Layout;

import java.util.ArrayList;
import java.util.List;

// a class intended to be imported and exported.
// The reason for this is to include data that inventory setups may not handle, such as layouts.
@Value
public class InventorySetupPortable
{

	InventorySetupSerializable setup;

	// We don't store the layout tag info since it might change when importing. The name is not guaranteed.
	int[] layout;

	static public InventorySetupPortable convertFromInventorySetup(final InventorySetup setup, final InventorySetupLayoutUtilities layoutUtilities)
	{
		final Layout layout = layoutUtilities.getSetupLayout(setup);
		InventorySetupSerializable serializable = InventorySetupSerializable.convertFromInventorySetup(setup);
		return new InventorySetupPortable(serializable, layout.getLayout());
	}

	static public ArrayList<InventorySetupPortable> convertFromListOfSetups(final List<InventorySetup> setups, final InventorySetupLayoutUtilities layoutUtilities)
	{
		ArrayList<InventorySetupPortable> portables = new ArrayList<>();
		for (final InventorySetup setup : setups)
		{
			portables.add(convertFromInventorySetup(setup, layoutUtilities));
		}
		return portables;
	}

	public InventorySetup getSerializedSetup()
	{
		return InventorySetupSerializable.convertToInventorySetup(setup);
	}
}

package inventorysetups.serialization;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import inventorysetups.InventorySetupsStackCompareID;

import java.io.IOException;

public class InventorySetupItemSerializableTypeAdapter extends TypeAdapter<InventorySetupItemSerializable>
{
	@Override
	public void write(JsonWriter out, InventorySetupItemSerializable iss) throws IOException
	{
		if (iss == null)
		{
			out.setSerializeNulls(true);
			out.nullValue();
			out.setSerializeNulls(false);
		}
		else
		{
			out.beginObject();
			out.name("id");
			out.value(iss.getId());
			if (iss.getQ() != null)
			{
				out.name("q");
				out.value(iss.getQ());
			}
			if (iss.getF() != null)
			{
				out.name("f");
				out.value(iss.getF());
			}
			if (iss.getSc() != null)
			{
				out.name("sc");
				out.value(iss.getSc().toString());
			}
			out.endObject();
		}

	}

	@Override
	public InventorySetupItemSerializable read(JsonReader in) throws IOException
	{
		if (in.peek() == JsonToken.NULL)
		{
			in.nextNull();
			return null;
		}

		int id = -1;
		Integer q = null;
		Boolean f = null;
		InventorySetupsStackCompareID sc = null;

		in.beginObject();
		while (in.hasNext())
		{
			JsonToken token = in.peek();
			if (token.equals(JsonToken.NAME))
			{
				//get the current token
				String fieldName = in.nextName();
				switch (fieldName)
				{
					case "id":
						id = in.nextInt();
						break;
					case "q":
						q = in.nextInt();
						break;
					case "f":
						f = in.nextBoolean();
						break;
					case "sc":
						sc = InventorySetupsStackCompareID.valueOf(in.nextString());
						break;
					default:
						break;
				}
			}
		}

		in.endObject();
		return new InventorySetupItemSerializable(id, q, f, sc);
	}
}

package inventorysetups.serialization;

import inventorysetups.InventorySetupsItem;
import inventorysetups.InventorySetupsStackCompareID;

import lombok.Value;

import javax.annotation.Nullable;

@Value
public class InventorySetupItemSerializable
{
	int id;
	@Nullable
	Integer q;		// Quantity (null = 1)
	@Nullable
	Boolean f;		// Fuzzy (null = FALSE)
	@Nullable
	InventorySetupsStackCompareID sc;	// Stack Compare (null = NONE)

	static public InventorySetupItemSerializable convertFromInventorySetupItem(final InventorySetupsItem item)
	{
		if (item == null || InventorySetupsItem.itemIsDummy(item))
		{
			return null;
		}
		Integer quantity = item.getQuantity() != 1 ? item.getQuantity() : null;
		Boolean fuzzy = item.isFuzzy() ? Boolean.TRUE : null;
		InventorySetupsStackCompareID sc = item.getStackCompare() != InventorySetupsStackCompareID.None ? item.getStackCompare() : null;
		return new InventorySetupItemSerializable(item.getId(), quantity, fuzzy, sc);
	}

	static public InventorySetupsItem convertToInventorySetupItem(final InventorySetupItemSerializable is)
	{
		if (is == null)
		{
			return InventorySetupsItem.getDummyItem();
		}
		int id = is.getId();
		// Name is not saved in the serializable object. It must be obtained from the item manager at runtime
		String name = "";
		int quantity = is.getQ() != null ? is.getQ() : 1;
		boolean fuzzy = is.getF() != null ? is.getF() : Boolean.FALSE;
		InventorySetupsStackCompareID sc = is.getSc() != null ? is.getSc() : InventorySetupsStackCompareID.None;
		return new InventorySetupsItem(id, name, quantity, fuzzy, sc);
	}
}

package inventorysetups.serialization;

import inventorysetups.InventorySetup;
import inventorysetups.InventorySetupsItem;
import joptsimple.internal.Strings;
import lombok.Value;

import javax.annotation.Nullable;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Value
public class InventorySetupSerializable
{

	List<InventorySetupItemSerializable> inv;	// inventory
	List<InventorySetupItemSerializable> eq;	// equipment
	@Nullable
	List<InventorySetupItemSerializable> rp;	// rune pouch (null = No rp)
	@Nullable
	List<InventorySetupItemSerializable> bp;	// bolt pouch (null = No bp)
	@Nullable
	List<InventorySetupItemSerializable> qv;	// quiver (null = No qv)
	@Nullable
	Map<Integer, InventorySetupItemSerializable> afi;		// additional filtered items (null = No afi)
	String name;	// name of setup
	@Nullable
	String notes;	// notes (null = empty notes)
	Color hc; 		// highlight color
	@Nullable
	Boolean hd;		// highlight difference (null = false)
	@Nullable
	Color dc;		// display color (null = no color)
	@Nullable
	Boolean fb;		// filter bank (null = false)
	@Nullable
	Boolean uh;		// unordered highlight (null = false)
	@Nullable
	Integer sb;		// Spell book (null = 0 standard)
	@Nullable
	Boolean fv;		// favorite (null = false)
	@Nullable
	Integer iId;	// iconID (null = default item ID for icon view)

	static public InventorySetupSerializable convertFromInventorySetup(final InventorySetup inventorySetup)
	{

		List<InventorySetupItemSerializable> inv = convertListFromInventorySetup(inventorySetup.getInventory());
		List<InventorySetupItemSerializable> eq = convertListFromInventorySetup(inventorySetup.getEquipment());
		List<InventorySetupItemSerializable> rp = convertListFromInventorySetup(inventorySetup.getRune_pouch());
		List<InventorySetupItemSerializable> bp = convertListFromInventorySetup(inventorySetup.getBoltPouch());
		List<InventorySetupItemSerializable> qv = convertListFromInventorySetup(inventorySetup.getQuiver());

		Map<Integer, InventorySetupItemSerializable> afi = null;
		if (inventorySetup.getAdditionalFilteredItems() != null && !inventorySetup.getAdditionalFilteredItems().isEmpty())
		{
			afi = new HashMap<>();
			for (final Integer key : inventorySetup.getAdditionalFilteredItems().keySet())
			{
				afi.put(key, InventorySetupItemSerializable.convertFromInventorySetupItem(inventorySetup.getAdditionalFilteredItems().get(key)));
			}
		}

		String name = inventorySetup.getName();
		String notes = !Strings.isNullOrEmpty(inventorySetup.getNotes()) ? inventorySetup.getNotes() : null;
		Color hc = inventorySetup.getHighlightColor();
		Boolean hd = inventorySetup.isHighlightDifference() ? Boolean.TRUE : null;
		Color dc = inventorySetup.getDisplayColor();
		Boolean fb = inventorySetup.isFilterBank() ? Boolean.TRUE : null;
		Boolean uh = inventorySetup.isUnorderedHighlight() ? Boolean.TRUE : null;
		Integer sb = inventorySetup.getSpellBook() != 0 ? inventorySetup.getSpellBook() : null;
		Boolean fv = inventorySetup.isFavorite() ? Boolean.TRUE : null;
		Integer iId = inventorySetup.getIconID() > 0 ? inventorySetup.getIconID() : null;

		return new InventorySetupSerializable(inv, eq, rp, bp, qv, afi, name, notes, hc, hd, dc, fb, uh, sb, fv, iId);
	}

	static private List<InventorySetupItemSerializable> convertListFromInventorySetup(final List<InventorySetupsItem> items)
	{
		List<InventorySetupItemSerializable> iss_list = null;
		if (items != null)
		{
			iss_list = new ArrayList<>();
			for (final InventorySetupsItem item : items)
			{
				iss_list.add(InventorySetupItemSerializable.convertFromInventorySetupItem(item));
			}
		}
		return iss_list;
	}

	static private List<InventorySetupsItem> convertListToInventorySetup(final List<InventorySetupItemSerializable> iss_items)
	{
		List<InventorySetupsItem> itemList = null;
		if (iss_items != null)
		{
			itemList = new ArrayList<>();
			for (final InventorySetupItemSerializable iss_item : iss_items)
			{
				itemList.add(InventorySetupItemSerializable.convertToInventorySetupItem(iss_item));
			}
		}
		return itemList;
	}

	static public InventorySetup convertToInventorySetup(final InventorySetupSerializable iss)
	{

		// Note that items will not have a name. They will need to be retrieved from the item manager
		// Either immediately after or delayed when a setup is opened
		List<InventorySetupsItem> inv = convertListToInventorySetup(iss.getInv());
		List<InventorySetupsItem> eq = convertListToInventorySetup(iss.getEq());
		List<InventorySetupsItem> rp = convertListToInventorySetup(iss.getRp());
		List<InventorySetupsItem> bp = convertListToInventorySetup(iss.getBp());
		List<InventorySetupsItem> qv = convertListToInventorySetup(iss.getQv());
		Map<Integer, InventorySetupsItem> afi = new HashMap<>();
		if (iss.getAfi() != null)
		{
			for (final Integer key : iss.getAfi().keySet())
			{
				afi.put(key, InventorySetupItemSerializable.convertToInventorySetupItem(iss.getAfi().get(key)));
			}
		}
		String name = iss.getName();
		String notes = iss.getNotes() != null ? iss.getNotes() : "";
		Color hc = iss.getHc();
		boolean hd = iss.getHd() != null ? iss.getHd() : Boolean.FALSE;
		Color dc = iss.getDc();
		boolean fb = iss.getFb() != null ? iss.getFb() : Boolean.FALSE;
		boolean uh = iss.getUh() != null ? iss.getUh() : Boolean.FALSE;
		int sb = iss.getSb() != null ? iss.getSb() : 0;
		boolean fv = iss.getFv() != null ? iss.getFv() : Boolean.FALSE;
		int iId = iss.getIId() != null ? iss.getIId() : -1;

		return new InventorySetup(inv, eq, rp, bp, qv, afi, name, notes, hc, hd, dc, fb, uh, sb, fv, iId);
	}


}

package inventorysetups.serialization;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;

public class LongTypeAdapter extends TypeAdapter<Long>
{

	@Override
	public Long read(JsonReader reader) throws IOException
	{
		if (reader.peek() == JsonToken.NULL)
		{
			reader.nextNull();
			return null;
		}
		String stringValue = reader.nextString();
		try
		{
			return Long.valueOf(stringValue);
		}
		catch (NumberFormatException e)
		{
			return Long.MAX_VALUE;
		}
	}

	@Override
	public void write(JsonWriter writer, Long value) throws IOException
	{
		if (value == null)
		{
			writer.nullValue();
			return;
		}
		writer.value(value);
	}
}
package inventorysetups;

import inventorysetups.ui.InventorySetupsPluginPanel;
import inventorysetups.ui.InventorySetupsRunePouchPanel;
import inventorysetups.ui.InventorySetupsSlot;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.game.ItemManager;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static inventorysetups.ui.InventorySetupsBoltPouchPanel.BOLT_POUCH_AMOUNT_VARBIT_IDS;
import static inventorysetups.ui.InventorySetupsBoltPouchPanel.BOLT_POUCH_BOLT_VARBIT_IDS;
import static inventorysetups.ui.InventorySetupsQuiverPanel.DIZANA_QUIVER_IDS;
import static inventorysetups.ui.InventorySetupsQuiverPanel.DIZANA_QUIVER_IDS_SET;
import static inventorysetups.ui.InventorySetupsRunePouchPanel.RUNE_POUCH_AMOUNT_VARBITS;
import static inventorysetups.ui.InventorySetupsRunePouchPanel.RUNE_POUCH_DIVINE_IDS_SET;
import static inventorysetups.ui.InventorySetupsRunePouchPanel.RUNE_POUCH_IDS_SET;
import static inventorysetups.ui.InventorySetupsRunePouchPanel.RUNE_POUCH_RUNE_VARBITS;

// Handles special containers like rune pouches, bolt pouches, and quivers
public class InventorySetupsAmmoHandler
{

	private Map<Integer, Consumer<InventorySetup>> updateDataHandler;

	private Map<Integer, Consumer<InventorySetup>> removeDataHandler;

	private final InventorySetupsPlugin plugin;
	private final Client client;

	private final ItemManager itemManager;

	private final InventorySetupsPluginPanel panel;

	private final InventorySetupsConfig config;

	public InventorySetupsAmmoHandler(InventorySetupsPlugin plugin, Client client, ItemManager itemManager,
										InventorySetupsPluginPanel panel, InventorySetupsConfig config)
	{
		this.plugin = plugin;
		this.client = client;
		this.itemManager = itemManager;
		this.panel = panel;
		this.config = config;

		this.updateDataHandler = new HashMap<>();
		this.removeDataHandler = new HashMap<>();

		// Handler for when an item being replaced is a rune pouch
		for (final int itemID : InventorySetupsRunePouchPanel.RUNE_POUCH_IDS)
		{
			updateDataHandler.put(itemID, (setup) -> setup.updateRunePouch(getRunePouchData(InventorySetupsRunePouchType.NORMAL)));
			removeDataHandler.put(itemID, (setup) -> setup.updateRunePouch(null));
		}
		for (final int itemID : InventorySetupsRunePouchPanel.RUNE_POUCH_DIVINE_IDS)
		{
			updateDataHandler.put(itemID, (setup) -> setup.updateRunePouch(getRunePouchData(InventorySetupsRunePouchType.DIVINE)));
			removeDataHandler.put(itemID, (setup) -> setup.updateRunePouch(null));
		}

		// Handler for when an item being replaced is a bolt pouch
		updateDataHandler.put(ItemID.XBOWS_BOLT_POUCH, (setup) -> setup.updateBoltPouch(getBoltPouchData()));
		removeDataHandler.put(ItemID.XBOWS_BOLT_POUCH, (setup) -> setup.updateBoltPouch(null));

		// Handler for when an item being replaced is a quiver
		for (final int itemID : DIZANA_QUIVER_IDS)
		{
			updateDataHandler.put(itemID, (setup) -> setup.updateQuiver(getQuiverData()));
			removeDataHandler.put(itemID, (setup) -> setup.updateQuiver(null));
		}
	}

	// Checks when updating a slot in a setup that it is part of a special ammo. If so, handle it.
	public void handleSpecialAmmo(final InventorySetup inventorySetup,
									final InventorySetupsItem oldItem, final InventorySetupsItem newItem)
	{
		int newID = newItem.getId();
		int oldID = oldItem.getId();
		if (updateDataHandler.containsKey(newID))
		{
			updateDataHandler.get(newID).accept(inventorySetup);
		}
		else if (updateDataHandler.containsKey(oldID))
		{
			removeDataHandler.get(oldID).accept(inventorySetup);
		}
	}

	public void handleSpecialHighlighting(final InventorySetup setup, final List<InventorySetupsItem> inventory, final List<InventorySetupsItem> equipment)
	{
		Set<Integer> combinedIds = inventory.stream().map(InventorySetupsItem::getId).collect(Collectors.toSet());
		combinedIds.addAll(equipment.stream().map(InventorySetupsItem::getId).collect(Collectors.toSet()));

		Set<Integer> divine_rune_pouch_intersection = new HashSet<>(RUNE_POUCH_DIVINE_IDS_SET);
		divine_rune_pouch_intersection.retainAll(combinedIds);
		Set<Integer> rune_pouch_intersection = new HashSet<>(RUNE_POUCH_IDS_SET);
		rune_pouch_intersection.retainAll(combinedIds);
		if (!divine_rune_pouch_intersection.isEmpty())
		{
			plugin.getClientThread().invoke(() ->
					panel.getRunePouchPanel().handleRunePouchHighlighting(setup, InventorySetupsRunePouchType.DIVINE));
		}
		else if (!rune_pouch_intersection.isEmpty())
		{
			plugin.getClientThread().invoke(() ->
					panel.getRunePouchPanel().handleRunePouchHighlighting(setup, InventorySetupsRunePouchType.NORMAL));
		}
		else
		{
			plugin.getClientThread().invoke(() ->
					panel.getRunePouchPanel().handleRunePouchHighlighting(setup, InventorySetupsRunePouchType.NONE));
		}

		Set<Integer> quiver_intersection = new HashSet<>(DIZANA_QUIVER_IDS_SET);
		quiver_intersection.retainAll(combinedIds);
		plugin.getClientThread().invoke(() ->
				panel.getQuiverPanel().handleQuiverHighlighting(setup, !quiver_intersection.isEmpty()));

		boolean currentInventoryHasBoltPouch = combinedIds.contains(ItemID.XBOWS_BOLT_POUCH);
		plugin.getClientThread().invoke(() ->
				panel.getBoltPouchPanel().handleBoltPouchHighlighting(setup, currentInventoryHasBoltPouch));
	}

	public InventorySetupsRunePouchType getRunePouchTypeFromContainer(final List<InventorySetupsItem> container)
	{
		// Don't allow fuzzy when checking because it will incorrectly assume the type
		if (plugin.containerContainsItemFromSet(RUNE_POUCH_IDS_SET, container, false, true))
		{
			return InventorySetupsRunePouchType.NORMAL;
		}
		if (plugin.containerContainsItemFromSet(RUNE_POUCH_DIVINE_IDS_SET, container, false, true))
		{
			return InventorySetupsRunePouchType.DIVINE;
		}
		return InventorySetupsRunePouchType.NONE;
	}

	public List<InventorySetupsItem> getRunePouchDataIfInContainer(final List<InventorySetupsItem> container)
	{
		InventorySetupsRunePouchType runePouchType = getRunePouchTypeFromContainer(container);
		return runePouchType != InventorySetupsRunePouchType.NONE ? getRunePouchData(runePouchType) : null;
	}

	// Must be run on client thread!
	public List<InventorySetupsItem> getRunePouchData(final InventorySetupsRunePouchType runePouchType)
	{
		List<InventorySetupsItem> runePouchData = new ArrayList<>();
		EnumComposition runepouchEnum = client.getEnum(982);
		for (int i = 0; i < runePouchType.getSize(); i++)
		{
			final int varbitVal = client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS.get(i));
			if (varbitVal == 0)
			{
				runePouchData.add(InventorySetupsItem.getDummyItem());
			}
			else
			{
				final int runeId = runepouchEnum.getIntValue(varbitVal);
				int runeAmount = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS.get(i));
				String runeName = itemManager.getItemComposition(runeId).getName();
				InventorySetupsStackCompareID stackCompareType = panel.isStackCompareForSlotAllowed(InventorySetupsSlotID.RUNE_POUCH, i) ? config.stackCompareType() : InventorySetupsStackCompareID.None;
				runePouchData.add(new InventorySetupsItem(runeId, runeName, runeAmount, false, stackCompareType));
			}
		}

		return runePouchData;
	}

	public boolean containerContainsBoltPouch(final List<InventorySetupsItem> container)
	{
		return plugin.containerContainsItem(ItemID.XBOWS_BOLT_POUCH, container, false, true);
	}

	public List<InventorySetupsItem> getBoltPouchDataIfInContainer(final List<InventorySetupsItem> container)
	{
		return containerContainsBoltPouch(container) ? getBoltPouchData() : null;
	}

	// Must be run on client thread!
	public List<InventorySetupsItem> getBoltPouchData()
	{
		List<InventorySetupsItem> boltPouchData = new ArrayList<>();

		for (int i = 0; i < BOLT_POUCH_BOLT_VARBIT_IDS.size(); i++)
		{
			int boltVarbitId = client.getVarbitValue(BOLT_POUCH_BOLT_VARBIT_IDS.get(i));
			Bolts bolt = Bolts.getBolt(boltVarbitId);
			boolean boltNotFound = bolt == null;
			int boltAmount = boltNotFound ? 0 : client.getVarbitValue(BOLT_POUCH_AMOUNT_VARBIT_IDS.get(i));
			String boltName = boltNotFound ? "" : itemManager.getItemComposition(bolt.getItemId()).getName();
			int boltItemId = boltNotFound ? -1 : bolt.getItemId();

			if (boltItemId == -1)
			{
				boltPouchData.add(InventorySetupsItem.getDummyItem());
			}
			else
			{
				InventorySetupsStackCompareID stackCompareType =
						panel.isStackCompareForSlotAllowed(InventorySetupsSlotID.BOLT_POUCH, i)
								? config.stackCompareType() : InventorySetupsStackCompareID.None;
				boltPouchData.add(new InventorySetupsItem(boltItemId, boltName, boltAmount, false, stackCompareType));
			}
		}

		return boltPouchData;
	}

	public boolean setupContainsQuiver(final List<InventorySetupsItem> inv, final List<InventorySetupsItem> eq)
	{
		boolean inventoryHasQuiver = plugin.containerContainsItemFromSet(DIZANA_QUIVER_IDS_SET, inv, false, true);
		return inventoryHasQuiver || plugin.containerContainsItemFromSet(DIZANA_QUIVER_IDS_SET, eq, false, true);
	}

	public List<InventorySetupsItem> getQuiverDataIfInSetup(final List<InventorySetupsItem> inv, final List<InventorySetupsItem> eq)
	{
		return setupContainsQuiver(inv, eq) ? getQuiverData() : null;
	}

	// Must be run on client thread!
	public List<InventorySetupsItem> getQuiverData()
	{
		List<InventorySetupsItem> quiverData = new ArrayList<>();
		final int quiverAmmoId = client.getVarpValue(VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO);
		final int quiverAmmoCount = Math.max(0, client.getVarpValue(VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO_AMOUNT));

		if (quiverAmmoId == -1 || quiverAmmoCount == 0)
		{
			quiverData.add(InventorySetupsItem.getDummyItem());
		}
		else
		{
			final String ammoName = itemManager.getItemComposition(quiverAmmoId).getName();

			InventorySetupsStackCompareID stackCompareType =
					panel.isStackCompareForSlotAllowed(InventorySetupsSlotID.QUIVER, 0)
							? config.stackCompareType() : InventorySetupsStackCompareID.None;

			final InventorySetupsItem quiverItem = new InventorySetupsItem(quiverAmmoId, ammoName,
					quiverAmmoCount, false, stackCompareType);
			quiverData.add(quiverItem);
		}

		return quiverData;
	}

	public static String getSpecialContainerString(final InventorySetupsSlot slot)
	{
		String specialContainerString = "";
		switch (slot.getSlotID())
		{
			case RUNE_POUCH:
				specialContainerString = "Rune Pouch";
				break;
			case BOLT_POUCH:
				specialContainerString = "Bolt Pouch";
				break;
			case QUIVER:
				specialContainerString = "Quiver";
				break;
			default:
				assert false : "Wrong slot ID!";
				break;
		}
		return specialContainerString;
	}

	public boolean isStackCompareForSpecialSlotAllowed(final InventorySetupsSlotID inventoryID, final int slotId)
	{
		switch (inventoryID)
		{
			case RUNE_POUCH:
				return panel.getRunePouchPanel().isStackCompareForSlotAllowed(slotId);
			case BOLT_POUCH:
				return panel.getBoltPouchPanel().isStackCompareForSlotAllowed(slotId);
			case QUIVER:
				return true;
			default:
				assert false : "Wrong Slot ID!";
				return false;
		}
	}

	public List<InventorySetupsItem> getNormalizedSpecialContainer(final InventorySetupsSlotID id)
	{
		switch (id)
		{
			case RUNE_POUCH:
				return getRunePouchData(InventorySetupsRunePouchType.DIVINE);
			case BOLT_POUCH:
				return getBoltPouchData();
			case QUIVER:
				return getQuiverData();
			default:
				assert false : "Wrong slot ID!";
				return null;
		}
	}

	public List<InventorySetupsItem> getSpecialContainerFromID(final InventorySetup inventorySetup, InventorySetupsSlotID ID)
	{
		switch (ID)
		{
			case RUNE_POUCH:
				return inventorySetup.getRune_pouch();
			case BOLT_POUCH:
				return inventorySetup.getBoltPouch();
			case QUIVER:
				return inventorySetup.getQuiver();
			default:
				assert false : "Invalid ID given";
				return null;
		}
	}

	public boolean specialContainersContainItem(final InventorySetup setup, int itemID, boolean allowFuzzy, boolean canonicalize)
	{
		if (plugin.containerContainsItem(itemID, setup.getRune_pouch(), allowFuzzy, canonicalize))
		{
			return true;
		}
		if (plugin.containerContainsItem(itemID, setup.getBoltPouch(), allowFuzzy, canonicalize))
		{
			return true;
		}
		return plugin.containerContainsItem(itemID, setup.getQuiver(), allowFuzzy, canonicalize);
	}

	public void updateSpecialContainersInSetup(final InventorySetup setup, final List<InventorySetupsItem> inv, final List<InventorySetupsItem> eqp)
	{
		List<InventorySetupsItem> runePouchData = getRunePouchDataIfInContainer(inv);
		List<InventorySetupsItem> boltPouchData = getBoltPouchDataIfInContainer(inv);
		List<InventorySetupsItem> quiverData = getQuiverDataIfInSetup(inv, eqp);

		setup.updateRunePouch(runePouchData);
		setup.updateBoltPouch(boltPouchData);
		setup.updateQuiver(quiverData);
	}
}

package inventorysetups;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/*
* Enum that determines which setups show up when the "show worn items" button is right clicked
*/
public enum InventorySetupsShowWornItemsFilterID
{
	// Show all. This is the default
	All(0),

	// Show only the setups that are bank filtered
	BANK_FILTERED(1),

	// Show only the setups that favorited
	FAVORITED(2);

	private final int type;

	private static final List<InventorySetupsShowWornItemsFilterID> VALUES;

	static
	{
		VALUES = new ArrayList<>();
		Collections.addAll(VALUES, InventorySetupsShowWornItemsFilterID.values());
	}

	InventorySetupsShowWornItemsFilterID(int type)
	{
		this.type = type;
	}

	public int getType()
	{
		return type;
	}

	public static List<InventorySetupsShowWornItemsFilterID> getValues()
	{
		return VALUES;
	}
}

package inventorysetups;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public enum InventorySetupsZigZagTypeID
{
	// Use if you want to withdraw using a top to bottom zigzag pattern
	TOP_TO_BOTTOM("Top to Bottom", 0),

	// Use if you want to withdraw using a bottom to top zigzag pattern
	BOTTOM_TO_TOP("Bottom to Top", 1);

	private final int type;

	private static final List<InventorySetupsZigZagTypeID> VALUES;

	static
	{
		VALUES = new ArrayList<>();
		Collections.addAll(VALUES, InventorySetupsZigZagTypeID.values());
	}

	InventorySetupsZigZagTypeID(String s, int type)
	{
		this.type = type;
	}

	public static List<InventorySetupsZigZagTypeID> getValues()
	{
		return VALUES;
	}
}

package inventorysetups;

import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

import net.runelite.client.plugins.banktags.BankTagsConfig;
import net.runelite.client.plugins.banktags.BankTagsPlugin;


import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.banktags.BankTagsService;
import net.runelite.client.plugins.banktags.TagManager;
import net.runelite.client.plugins.banktags.tabs.LayoutManager;
import net.runelite.client.plugins.banktags.tabs.TabInterface;
import net.runelite.client.ui.ClientToolbar;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.when;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class InventorySetupsUnitTest
{
	@Mock
	@Bind
	private Client client;

	@Mock
	@Bind
	private ItemManager itemManager;

	@Mock
	@Bind
	private InventorySetupsConfig inventorySetupsConfig;

	@Mock
	@Bind
	private RuneLiteConfig runeLiteConfig;

	@Mock
	@Bind
	private PluginManager pluginManager;

	@Mock
	@Bind
	private ClientToolbar clientToolbar;

	@Mock
	@Bind
	private BankTagsPlugin bankTagsPlugin;

	@Mock
	@Bind
	private BankTagsConfig bankTagsConfig;

	@Mock
	@Bind
	private TabInterface tabInterface;

	@Mock
	@Bind
	private BankTagsService bankTagsService;

	@Mock
	@Bind
	private LayoutManager layoutManager;

	@Mock
	@Bind
	private TagManager tagManager;

	@Mock
	@Bind
	private ConfigManager configManager;

	@Inject
	private InventorySetupsPlugin inventorySetupsPlugin;

	@Before
	public void before()
	{
		Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
		when(itemManager.canonicalize(ItemID.COAL)).thenReturn(ItemID.COAL);
	}

	@Test
	public void testInputText()
	{
		assertEquals(InventorySetupUtilities.parseTextInputAmount("1"), 1);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("0"), 1);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("1K"), 1000);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("10K"), 10000);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("1k"), 1000);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("1m"), 1000000);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("1M"), 1000000);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("1b"), 1000000000);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("1B"), 1000000000);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("10b"), 2147483647);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("10000M"), 2147483647);
		assertEquals(InventorySetupUtilities.parseTextInputAmount("102391273213291"), 2147483647);
	}

	@Test
	public void testSetupContainsItem()
	{
		List<InventorySetupsItem> inventory = new ArrayList<>(Collections.nCopies(28, InventorySetupsItem.getDummyItem()));
		List<InventorySetupsItem> equipment = new ArrayList<>(Collections.nCopies(13, InventorySetupsItem.getDummyItem()));
		List<InventorySetupsItem> runePouch = null;
		List<InventorySetupsItem> boltPouch = null;
		List<InventorySetupsItem> quiver = null;
		Map<Integer, InventorySetupsItem> addItems = new HashMap<>();
		InventorySetup setup = new InventorySetup(inventory, equipment, runePouch, boltPouch, quiver, addItems, "Test",
												"", inventorySetupsConfig.highlightColor(), false,
												inventorySetupsConfig.displayColor(), false,false, 0, false, -1);
		inventorySetupsPlugin.startUp();
		assertFalse(inventorySetupsPlugin.setupContainsItem(setup, ItemID.COAL, true, true));
	}
}

package inventorysetups;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class InventorySetupsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(InventorySetupsPlugin.class);
		RuneLite.main(args);
	}
}
