package eu.jodelahithit;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SkillingNotificationsTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SkillingNotificationsPlugin.class);
		RuneLite.main(args);
	}
}
package eu.jodelahithit;

import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.event.KeyEvent;

import net.runelite.client.input.KeyListener;
import net.runelite.client.util.SwingUtil;

public class SkillingNotificationsListener implements KeyListener {
    @Inject
    SkillingNotificationsPlugin plugin;
    @Inject
    SkillingNotificationsConfig config;
    @Inject
    SkillingNotificationsOverlay overlay;
    @Inject
    ConfigManager configManager;

    @Override
    public void keyPressed(KeyEvent e) {
        if (config.toggle().matches(e)) {
            boolean enabled = !Boolean.parseBoolean(configManager.getConfiguration("Skilling Notifications", "enabled"));
            configManager.setConfiguration("Skilling Notifications", "enabled", enabled);
            plugin.panel.repaintConfigButtons();
            overlay.Notify(enabled ? "Enabled skilling notifications" : "Disabled skilling notifications");
        } else if (config.toggleFlash().matches(e)) {
            boolean enabled = !Boolean.parseBoolean(configManager.getConfiguration("Skilling Notifications", "notificationFlash"));
            configManager.setConfiguration("Skilling Notifications", "notificationFlash", enabled);
            plugin.panel.repaintConfigButtons();
            overlay.Notify(enabled ? "Enabled notification flash" : "Disabled notification flash");

        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }
}

package eu.jodelahithit;

import com.google.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;

import java.awt.*;
import java.time.Duration;
import java.time.Instant;

public class SkillingNotificationsOverlay extends Overlay {
    private final Client client;
    private final SkillingNotificationsPlugin plugin;
    private final SkillingNotificationsConfig config;
    private final float TEXT_COLOR_LERP = 0.75f;
    private Instant fadeInstant = Instant.now();
    private static Instant notificationInstant = Instant.now();
    private static String notificationText;
    private boolean previousShouldRender = false;

    @Inject
    private SkillingNotificationsOverlay(Client client, SkillingNotificationsPlugin plugin, SkillingNotificationsConfig config) {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    float fadeValue = 0.0f;

    private Color getFadedColor(Color input, boolean overlayEnabled) {
        int fadeDuration = config.notificationFade();
        if (fadeDuration == 0) {
            fadeValue = 0.0f;
            return input;
        }

        Instant now = Instant.now();
        float difference = (float) Duration.between(fadeInstant, now).toMillis() / fadeDuration;

        fadeValue += overlayEnabled ? difference : -difference;
        fadeInstant = now;

        fadeValue = Utils.clamp01(fadeValue);

        int r = input.getRed();
        int g = input.getGreen();
        int b = input.getBlue();
        int a = input.getAlpha();
        return new Color(r, g, b, (int) (a * fadeValue));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        boolean shouldRender = plugin.shouldRenderOverlay();
        if(config.notificationSound() && shouldRender && !previousShouldRender){
            Toolkit.getDefaultToolkit().beep();
        }
        previousShouldRender = shouldRender;

        Color fadedColor = getFadedColor(config.overlayColor(), shouldRender);
        if (shouldRender || fadeValue > 0.05f) {
            boolean canFlash = fadeValue > 0.95f || config.notificationFade() == 0;
            if (canFlash && config.flash() && client.getGameCycle() % 40 >= 20) return null;
            Color color = graphics.getColor();
            graphics.setColor(fadedColor);
            graphics.fill(new Rectangle(client.getCanvas().getSize()));
            graphics.setColor(color);
            if (!config.disableOverlayText()) {
                Point locationOffset = new Point(client.getCanvasWidth() / 2, client.getCanvasHeight() / 8 + Utils.getStringHeight(graphics));
                Utils.renderTextCentered(graphics, locationOffset, "Skilling Notification", ColorUtil.colorLerp(Color.white, config.overlayColor(), TEXT_COLOR_LERP));
            }
        }
        if (Session.checkInstant(notificationInstant, 2000)) {
            Point location = new Point(client.getCanvasWidth() / 2, client.getCanvasHeight() / 8);
            Utils.renderTextCentered(graphics, location, notificationText, ColorUtil.colorLerp(Color.white, config.overlayColor(), TEXT_COLOR_LERP));
        }
        return null;
    }

    public void Notify(String text) {
        notificationInstant = Instant.now();
        notificationText = text;
    }
}

package eu.jodelahithit;

import java.util.Set;

public enum NotificationType {
    NONE(null, null),
    COOKING(Constants.COOKING_ANIMATIONS, null),
    CRAFTING(Constants.CRAFTING_ANIMATIONS, null),
    FISHING(Constants.FISHING_ANIMATIONS, null),
    FIREMAKING(Constants.FIREMAKING_ANIMATIONS, null),
    FLETCHING(Constants.FLETCHING_ANIMATIONS, null),
    HERBLORE(Constants.HERBLORE_ANIMATIONS, null),
    MINING(Constants.MINING_ANIMATIONS, null),
    WOODCUTTING(Constants.WOODCUTTING_ANIMATIONS, null),
    SMITHING(Constants.SMITHING_ANIMATIONS, null),
    MANIACALMONKEYS(null, "/eu/jodelahithit/monkey.png"),
    LUNAR(Constants.LUNAR_ANIMATIONS, "/eu/jodelahithit/lunar.png"),
    COMBAT(null, null),
    CUSTOMXP(null, null);


    Set<Integer> animations;
    String customImage;

    NotificationType(Set<Integer> animations, String customImage) {
        this.animations = animations;
        this.customImage = customImage;
    }
}
package eu.jodelahithit;

import java.time.Duration;
import java.time.Instant;
import java.util.Dictionary;
import java.util.Hashtable;

public class Session {
    private Dictionary<NotificationType, Instant> skillInstants = new Hashtable<>();
    private SkillingNotificationsPlugin plugin;
    private Instant walkingInstant = Instant.now();

    public Session(SkillingNotificationsPlugin plugin) {
        this.plugin = plugin;
    }

    public static boolean checkInstant(Instant instant, float timeout) {
        return Duration.between(instant, Instant.now()).toMillis() < timeout;
    }

    public void updateInstant(NotificationType notificationType) {
        skillInstants.put(notificationType, Instant.now());
    }

    public boolean isSkillActive(NotificationType notificationType) {
        Instant instant = skillInstants.get(notificationType);
        if (instant != null) {
            return checkInstant(instant, 500 + Math.max(plugin.getExtraSkillDelay(notificationType), 0));
        }
        return false;
    }

    public void updateWalkingInstant(){
        walkingInstant = Instant.now();
    }

    public boolean isWalking(float extraTimeout){
       return checkInstant(walkingInstant, 1.0f + extraTimeout);
    }
}

package eu.jodelahithit;

import com.google.inject.Provides;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@PluginDescriptor(
        name = "Skilling Notifications",
        tags = {"notifications", "skilling"},
        description = "Provides visual notifications when no longer actively performing the selected skill"
)
public class SkillingNotificationsPlugin extends Plugin {
    private static final String WALK_HERE = "Walk here";
    private static final int MANIACAL_MONKEYS_REGION_ID = 11662;
    private LocalPoint lastPlayerLocation;
    private Session session;
    private NavigationButton navigationButton;
    private List<NotificationType> selectedNotificationTypes = new ArrayList<>();
    public Tile lastManiacalMonkeyRockTile = null;
    private int[] xpCache;
    public SkillingNotificationsPanel panel;

    @Inject
    Client client;
    @Inject
    ConfigManager configManager;
    @Inject
    SkillingNotificationsConfig config;
    @Inject
    OverlayManager overlayManager;
    @Inject
    SkillingNotificationsOverlay overlay;
    @Inject
    SkillingNotificationsListener inputListener;
    @Inject
    ClientToolbar clientToolbar;
    @Inject
    ItemManager itemManager;
    @Inject
    KeyManager keyManager;

    public final BufferedImage ICON = ImageUtil.loadImageResource(SkillingNotificationsPlugin.class, "icon.png");

    @Override
    protected void startUp() throws Exception {
        xpCache = new int[Skill.values().length];
        keyManager.registerKeyListener(inputListener);
        updateSelectedSkills();
        panel = new SkillingNotificationsPanel(configManager);
        navigationButton = NavigationButton.builder()
                .tooltip("Skilling Notifications")
                .icon(ICON).priority(10).panel(panel)
                .build();

        clientToolbar.addNavigation(navigationButton);
        overlayManager.add(overlay);
        session = new Session(this);
    }

    @Override
    protected void shutDown() throws Exception {
        clientToolbar.removeNavigation(navigationButton);
        overlayManager.remove(overlay);
        keyManager.unregisterKeyListener(inputListener);
    }

    @Provides
    SkillingNotificationsConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(SkillingNotificationsConfig.class);
    }

    @Subscribe
    public void onClientTick(ClientTick clientTick) {
        if (!config.enabled()) return;
        for (NotificationType notificationType : selectedNotificationTypes) {
            if (Utils.isInAnimation(notificationType, client)) session.updateInstant(notificationType);
        }
        Player player = client.getLocalPlayer();
        if (player != null) {
            LocalPoint playerLocation = player.getLocalLocation();
            if (!playerLocation.equals(lastPlayerLocation)) {
                session.updateWalkingInstant();
            }
            lastPlayerLocation = playerLocation;
        }

        boolean isInManiacalMonkeysArea = isInManiacalMonkeysArea();
        if(!isInManiacalMonkeysArea() || (isInManiacalMonkeysArea && lastManiacalMonkeyRockTile != null))
            session.updateInstant(NotificationType.MANIACALMONKEYS);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (configChanged.getGroup().equals("Skilling Notifications")) {
            updateSelectedSkills();
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        Skill skill = statChanged.getSkill();
        int currentXp = statChanged.getXp();
        int skillIdx = skill.ordinal();
        int cachedXP = xpCache[skillIdx];
        if (cachedXP < currentXp) {
            int xpAmount = currentXp - cachedXP;
            if (xpAmount >= config.customXPValue()) {
                session.updateInstant(NotificationType.CUSTOMXP);
            }
        }

        xpCache[skillIdx] = currentXp;
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        if (!config.enabled()) return;
        Actor actor = hitsplatApplied.getActor();
        Hitsplat hitsplat = hitsplatApplied.getHitsplat();
        if (hitsplat.isMine()) {
            session.updateInstant(NotificationType.COMBAT);
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        final GameObject gameObject = event.getGameObject();
        final int id = gameObject.getId();
        final WorldPoint trapLocation = gameObject.getWorldLocation();

        if (id == ObjectID.MONKEY_TRAP || id == ObjectID.LARGE_BOULDER_28825) {
            if (client.getLocalPlayer().getWorldLocation().distanceTo(trapLocation) <= 2) {
                lastManiacalMonkeyRockTile = event.getTile();
            }
            return;
        }

        if (Constants.MONKEY_ROCKS.contains(id)) {
            if (lastManiacalMonkeyRockTile != null && event.getTile() == lastManiacalMonkeyRockTile)
                lastManiacalMonkeyRockTile = null;
        }
    }

    @Subscribe
    private void onWorldChanged(WorldChanged ev) {
        lastManiacalMonkeyRockTile = null;
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals(WALK_HERE)) session.updateWalkingInstant();
    }

    boolean areSelectedSkillsActive() {
        boolean isActive = false;
        for (NotificationType notificationType : selectedNotificationTypes) {
            isActive |= session.isSkillActive(notificationType);
        }
        return isActive;
    }

    boolean shouldRenderOverlay() {
        if (!config.enabled()) return false;
        final boolean skills = !selectedNotificationTypes.isEmpty() && !areSelectedSkillsActive();
        final boolean notWalking = !(config.disableWhenWalking() && session.isWalking(config.walkDelay()));
        return skills && notWalking;
    }

    public List<NotificationType> getSelectedSkills() {
        return selectedNotificationTypes;
    }

    void updateSelectedSkills() {
        selectedNotificationTypes.clear();
        for (NotificationType notificationType : NotificationType.values()) {
            if (Boolean.parseBoolean(configManager.getConfiguration("Skilling Notifications", notificationType.name().toUpperCase()))) {
                selectedNotificationTypes.add(notificationType);
            }
        }

    }

    int getExtraSkillDelay(NotificationType notificationType) {
        int delay = Integer.parseInt(configManager.getConfiguration("Skilling Notifications", notificationType.name() + "DELAYV2"));
        if (notificationType == NotificationType.COMBAT) return Utils.getAttackSpeed(client, itemManager) * 600 + delay;
        return delay;
    }

    void setSkillInConfig(NotificationType notificationType) {
        configManager.setConfiguration("Skilling Notifications", "selectedSkill", notificationType);
    }

    boolean isInManiacalMonkeysArea() {
        return ArrayUtils.contains(client.getMapRegions(), MANIACAL_MONKEYS_REGION_ID);
    }
}
package eu.jodelahithit;

import com.google.common.collect.ImmutableSet;
import net.runelite.api.ObjectID;

import java.util.Set;

import static net.runelite.api.AnimationID.*;


public class Constants {
    static final Set<Integer> LUNAR_ANIMATIONS = ImmutableSet.of(
            MAGIC_LUNAR_SHARED,
            MAGIC_LUNAR_PLANK_MAKE,
            MAGIC_LUNAR_STRING_JEWELRY
    );

    static final Set<Integer> COOKING_ANIMATIONS = ImmutableSet.of(
            COOKING_FIRE,
            COOKING_RANGE,
            COOKING_WINE
    );

    static final Set<Integer> FIREMAKING_ANIMATIONS = ImmutableSet.of(
            FIREMAKING,
            FIREMAKING_FORESTERS_CAMPFIRE_ARCTIC_PINE,
            FIREMAKING_FORESTERS_CAMPFIRE_BLISTERWOOD,
            FIREMAKING_FORESTERS_CAMPFIRE_LOGS,
            FIREMAKING_FORESTERS_CAMPFIRE_MAGIC,
            FIREMAKING_FORESTERS_CAMPFIRE_MAHOGANY,
            FIREMAKING_FORESTERS_CAMPFIRE_MAPLE,
            FIREMAKING_FORESTERS_CAMPFIRE_OAK,
            FIREMAKING_FORESTERS_CAMPFIRE_REDWOOD,
            FIREMAKING_FORESTERS_CAMPFIRE_TEAK,
            FIREMAKING_FORESTERS_CAMPFIRE_WILLOW,
            FIREMAKING_FORESTERS_CAMPFIRE_YEW
    );

    static final Set<Integer> FISHING_ANIMATIONS = ImmutableSet.of(
            FISHING_BIG_NET,
            FISHING_NET,
            FISHING_POLE_CAST,
            FISHING_CAGE,
            FISHING_HARPOON,
            FISHING_BARBTAIL_HARPOON,
            FISHING_DRAGON_HARPOON,
            FISHING_DRAGON_HARPOON_OR,
            FISHING_CRYSTAL_HARPOON,
            FISHING_INFERNAL_HARPOON,
            FISHING_TRAILBLAZER_HARPOON,
            FISHING_KARAMBWAN,
            FISHING_OILY_ROD,
            FISHING_CRUSHING_INFERNAL_EELS,
            FISHING_CUTTING_SACRED_EELS,
            FISHING_BAREHAND,
            FISHING_BAREHAND_CAUGHT_SHARK_1,
            FISHING_BAREHAND_CAUGHT_SHARK_2,
            FISHING_BAREHAND_CAUGHT_SWORDFISH_1,
            FISHING_BAREHAND_CAUGHT_SWORDFISH_2,
            FISHING_BAREHAND_CAUGHT_TUNA_1,
            FISHING_BAREHAND_CAUGHT_TUNA_2,
            FISHING_BAREHAND_WINDUP_1,
            FISHING_BAREHAND_WINDUP_2,
            FISHING_PEARL_ROD,
            FISHING_PEARL_FLY_ROD,
            FISHING_PEARL_BARBARIAN_ROD,
            FISHING_PEARL_ROD_2,
            FISHING_PEARL_FLY_ROD_2,
            FISHING_PEARL_BARBARIAN_ROD_2,
            FISHING_PEARL_OILY_ROD,
            FISHING_BARBARIAN_ROD
    );

    static final Set<Integer> MINING_ANIMATIONS = ImmutableSet.of(
            MINING_BRONZE_PICKAXE,
            MINING_IRON_PICKAXE,
            MINING_STEEL_PICKAXE,
            MINING_BLACK_PICKAXE,
            MINING_MITHRIL_PICKAXE,
            MINING_ADAMANT_PICKAXE,
            MINING_RUNE_PICKAXE,
            MINING_GILDED_PICKAXE,
            MINING_DRAGON_PICKAXE,
            MINING_DRAGON_PICKAXE_OR,
            MINING_DRAGON_PICKAXE_UPGRADED,
            MINING_INFERNAL_PICKAXE,
            MINING_3A_PICKAXE,
            MINING_CRYSTAL_PICKAXE,
            MINING_MOTHERLODE_BRONZE,
            MINING_MOTHERLODE_IRON,
            MINING_MOTHERLODE_STEEL,
            MINING_MOTHERLODE_BLACK,
            MINING_MOTHERLODE_MITHRIL,
            MINING_MOTHERLODE_ADAMANT,
            MINING_MOTHERLODE_RUNE,
            MINING_MOTHERLODE_GILDED,
            MINING_MOTHERLODE_DRAGON,
            MINING_MOTHERLODE_DRAGON_OR,
            MINING_MOTHERLODE_DRAGON_UPGRADED,
            MINING_MOTHERLODE_INFERNAL,
            MINING_MOTHERLODE_3A,
            MINING_DRAGON_PICKAXE_OR_TRAILBLAZER,
            MINING_TRAILBLAZER_PICKAXE,
            MINING_TRAILBLAZER_PICKAXE_2,
            MINING_TRAILBLAZER_PICKAXE_3,
            MINING_MOTHERLODE_DRAGON_OR_TRAILBLAZER,
            MINING_MOTHERLODE_TRAILBLAZER,
            MINING_MOTHERLODE_CRYSTAL,
            DENSE_ESSENCE_CHIPPING,
            MINING_CRASHEDSTAR_BRONZE,
            MINING_CRASHEDSTAR_IRON,
            MINING_CRASHEDSTAR_STEEL,
            MINING_CRASHEDSTAR_BLACK,
            MINING_CRASHEDSTAR_MITHRIL,
            MINING_CRASHEDSTAR_ADAMANT,
            MINING_CRASHEDSTAR_RUNE,
            MINING_CRASHEDSTAR_GILDED,
            MINING_CRASHEDSTAR_DRAGON,
            MINING_CRASHEDSTAR_DRAGON_UPGRADED,
            MINING_CRASHEDSTAR_DRAGON_OR,
            MINING_CRASHEDSTAR_DRAGON_OR_TRAILBLAZER,
            MINING_CRASHEDSTAR_INFERNAL,
            MINING_CRASHEDSTAR_3A,
            MINING_CRASHEDSTAR_CRYSTAL
    );

    static final Set<Integer> WOODCUTTING_ANIMATIONS = ImmutableSet.of(
            WOODCUTTING_BRONZE,
            WOODCUTTING_IRON,
            WOODCUTTING_STEEL,
            WOODCUTTING_BLACK,
            WOODCUTTING_MITHRIL,
            WOODCUTTING_ADAMANT,
            WOODCUTTING_RUNE,
            WOODCUTTING_GILDED,
            WOODCUTTING_DRAGON,
            WOODCUTTING_DRAGON_OR,
            WOODCUTTING_INFERNAL,
            WOODCUTTING_3A_AXE,
            WOODCUTTING_CRYSTAL,
            WOODCUTTING_TRAILBLAZER,
            WOODCUTTING_2H_BRONZE,
            WOODCUTTING_2H_IRON,
            WOODCUTTING_2H_STEEL,
            WOODCUTTING_2H_BLACK,
            WOODCUTTING_2H_MITHRIL,
            WOODCUTTING_2H_ADAMANT,
            WOODCUTTING_2H_RUNE,
            WOODCUTTING_2H_DRAGON,
            WOODCUTTING_2H_3A,
            WOODCUTTING_2H_CRYSTAL
    );

    static final Set<Integer> FLETCHING_ANIMATIONS = ImmutableSet.of(
            FLETCHING_BOW_CUTTING,
            FLETCHING_STRING_NORMAL_SHORTBOW,
            FLETCHING_STRING_NORMAL_LONGBOW,
            FLETCHING_STRING_OAK_SHORTBOW,
            FLETCHING_STRING_OAK_LONGBOW,
            FLETCHING_STRING_WILLOW_SHORTBOW,
            FLETCHING_STRING_WILLOW_LONGBOW,
            FLETCHING_STRING_MAPLE_SHORTBOW,
            FLETCHING_STRING_MAPLE_LONGBOW,
            FLETCHING_STRING_YEW_SHORTBOW,
            FLETCHING_STRING_YEW_LONGBOW,
            FLETCHING_STRING_MAGIC_SHORTBOW,
            FLETCHING_STRING_MAGIC_LONGBOW,
            FLETCHING_ATTACH_BOLT_TIPS_TO_BRONZE_BOLT,
            FLETCHING_ATTACH_BOLT_TIPS_TO_IRON_BROAD_BOLT,
            FLETCHING_ATTACH_BOLT_TIPS_TO_BLURITE_BOLT,
            FLETCHING_ATTACH_BOLT_TIPS_TO_STEEL_BOLT,
            FLETCHING_ATTACH_BOLT_TIPS_TO_MITHRIL_BOLT,
            FLETCHING_ATTACH_BOLT_TIPS_TO_ADAMANT_BOLT,
            FLETCHING_ATTACH_BOLT_TIPS_TO_RUNE_BOLT,
            FLETCHING_ATTACH_BOLT_TIPS_TO_DRAGON_BOLT,
            FLETCHING_ATTACH_HEADS,
            FLETCHING_ATTACH_FEATHERS_TO_ARROWSHAFT
    );

    static final Set<Integer> HERBLORE_ANIMATIONS = ImmutableSet.of(
            HERBLORE_MAKE_TAR,
            HERBLORE_POTIONMAKING,
            HERBLORE_PESTLE_AND_MORTAR
    );

    static final Set<Integer> CRAFTING_ANIMATIONS = ImmutableSet.of(
            GEM_CUTTING_OPAL,
            GEM_CUTTING_JADE,
            GEM_CUTTING_REDTOPAZ,
            GEM_CUTTING_SAPPHIRE,
            GEM_CUTTING_EMERALD,
            GEM_CUTTING_RUBY,
            GEM_CUTTING_DIAMOND,
            GEM_CUTTING_AMETHYST,
            CRAFTING_GLASSBLOWING,
            CRAFTING_SPINNING,
            CRAFTING_LOOM,
            CRAFTING_BATTLESTAVES,
            CRAFTING_LEATHER,
            CRAFTING_POTTERS_WHEEL,
            CRAFTING_POTTERY_OVEN,
            DENSE_ESSENCE_CHISELING,
            SMITHING_SMELTING
    );

    static final Set<Integer> SMITHING_ANIMATIONS = ImmutableSet.of(
            SMITHING_ANVIL,
            SMITHING_SMELTING,
            SMITHING_CANNONBALL,
            SMITHING_IMCANDO_HAMMER
    );

    static final Set<Integer> MONKEY_ROCKS = ImmutableSet.of(
            ObjectID.LARGE_BOULDER,
            ObjectID.LARGE_BOULDER_28830,
            ObjectID.LARGE_BOULDER_28831
            //ObjectID.MONKEY_TRAP_28828,
            //ObjectID.MONKEY_TRAP_28829
    );
}

package eu.jodelahithit;

import com.google.common.base.Strings;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.http.api.item.ItemStats;

import java.awt.*;

public class Utils {
    static boolean isInAnimation(NotificationType notificationType, Client client) {
        if(notificationType == NotificationType.NONE) return false;
        if(notificationType.animations == null) return false;
        Player player = client.getLocalPlayer();
        if(player == null) return false;
        int anim = player.getAnimation();
        return notificationType.animations.contains(anim);
    }

    public static int getStringWidth(Graphics graphics, String text) {
        FontMetrics metrics = graphics.getFontMetrics();
        return metrics.stringWidth(text);
    }

    public static int getStringHeight(Graphics graphics) {
        FontMetrics metrics = graphics.getFontMetrics();
        return metrics.getHeight();
    }

    public static void renderTextCentered(Graphics2D graphics, Point txtLoc, String text, Color color) {
        if (!Strings.isNullOrEmpty(text)) {
            int x = txtLoc.getX();
            int y = txtLoc.getY();
            int halfStringWidth = getStringWidth(graphics, text) / 2;
            graphics.setColor(Color.BLACK);
            graphics.drawString(text, x - halfStringWidth+ 1, y + 1);
            graphics.setColor(ColorUtil.colorWithAlpha(color, 255));
            graphics.drawString(text, x - halfStringWidth, y);
        }
    }

    public static int getAttackSpeed(Client client, ItemManager itemManager) {
        final ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
        if (equipment != null) {
            Item[] items = equipment.getItems();
            if (items.length >= 9) {
                int weaponID = items[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId();
                final ItemStats stats = itemManager.getItemStats(weaponID, false);
                if (stats != null) {
                    return stats.getEquipment().getAspeed();
                }
            }
        }
        return 4;
    }

    public static float clamp(float val, float min, float max) {
        return Math.max(min, Math.min(max, val));
    }

    public static float clamp01(float val) {
        return Math.max(0.0f, Math.min(1.0f, val));
    }
}

package eu.jodelahithit;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.StringUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.Dictionary;
import java.util.Hashtable;

public class SkillingNotificationsPanel extends PluginPanel {
    private final Dictionary<String, BufferedImage> iconsCache = new Hashtable<>();
    private final ConfigManager configManager;
    private final JPanel skillsPanel, enabledPanel, flashingPanel, soundPanel, walkingPanel, customPanel;

    @Inject
    SkillingNotificationsPanel(ConfigManager configManager) {
        super();
        this.configManager = configManager;
        setBorder(new EmptyBorder(5, 5, 5, 5));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.weighty = 0;
        c.insets = new Insets(0, 0, 10, 0);

        final JLabel welcomeText = new JLabel("Skilling Notifications");
        welcomeText.setFont(FontManager.getRunescapeBoldFont());
        welcomeText.setHorizontalAlignment(JLabel.CENTER);

        skillsPanel = new JPanel();
        skillsPanel.setLayout(new GridLayout(0, 2 , 7, 7));

        enabledPanel = new JPanel();
        enabledPanel.setLayout(new GridLayout(1, 1, 0, 0));
        flashingPanel = new JPanel();
        flashingPanel.setLayout(new GridLayout(1, 1, 0, 0));
        walkingPanel = new JPanel();
        walkingPanel.setLayout(new GridLayout(1, 1, 0, 0));
        soundPanel = new JPanel();
        soundPanel.setLayout(new GridLayout(1, 2, 0, 0));
        customPanel = new JPanel();
        customPanel.setLayout(new GridLayout(1, 2, 0, 0));

        JPanel descriptionPanel = new JPanel();
        descriptionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        descriptionPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        JTextArea description = new JTextArea(0, 25);
        description.setText("This plugin will display an overlay when the player is not actively performing any of the following selected skills.\n\nExtra notification delays can be configured in the plugin configuration.");
        description.setWrapStyleWord(true);
        description.setLineWrap(true);
        description.setOpaque(false);
        description.setEditable(false);
        description.setFocusable(false);
        description.setBackground(ColorScheme.DARK_GRAY_COLOR);
        description.setFont(FontManager.getRunescapeSmallFont());
        description.setBorder(new EmptyBorder(0, 0, 0, 0));

        descriptionPanel.add(description);

        repaintConfigButtons();

        add(welcomeText, c);
        c.gridy++;
        add(descriptionPanel, c);
        c.gridy++;
        add(enabledPanel, c);
        c.gridy++;
        add(walkingPanel, c);
        c.gridy++;
        add(flashingPanel, c);
        c.gridy++;
        add(soundPanel, c);
        c.gridy++;
        add(skillsPanel, c);
        c.gridy++;
        add(customPanel, c);
    }

    @Override
    public void onActivate() {
        repaintConfigButtons();
    }

    public void repaintConfigButtons() {
        setVisible(false);
        skillsPanel.removeAll();
        for (NotificationType notificationType : NotificationType.values()) {
            if (notificationType == NotificationType.NONE || notificationType == NotificationType.CUSTOMXP) continue;
            String skillIcon = "/skill_icons/" + notificationType.name().toLowerCase() + ".png";
            ImageIcon icon = new ImageIcon(GetIcon(notificationType.customImage == null ? skillIcon : notificationType.customImage));
            boolean isActive = Boolean.parseBoolean(configManager.getConfiguration("Skilling Notifications", notificationType.name()));
            JToggleButton toggleButton = new JToggleButton(icon, isActive);
            toggleButton.setToolTipText(StringUtils.capitalize(notificationType.name().toLowerCase()));
            toggleButton.setFocusable(false);
            toggleButton.addItemListener(ev -> configManager.setConfiguration("Skilling Notifications", notificationType.name(), ev.getStateChange() == ItemEvent.SELECTED));
            skillsPanel.add(toggleButton);
        }

        AddButton(enabledPanel, "enabled", "Enabled", "Toggles the overlay and plugin functionality");
        AddButton(walkingPanel, "disableWhenWalking", "Disable overlay while walking", "Forces the notification overlay to be disabled while walking or running");
        AddButton(flashingPanel, "notificationFlash", "Notification flash", "Flashes notifications at the configured interval");
        AddButton(soundPanel, "notificationSound", "Notification sound", "Plays a sound when the player is idle");
        AddButton(customPanel, "CUSTOMXP", "Custom XP", "Displays notifications when XP drops of the configured threshold are not received");

        SpinnerModel model = new SpinnerNumberModel(Integer.parseInt(configManager.getConfiguration("Skilling Notifications", "customXPValue")), 1, Integer.MAX_VALUE, 10);
        JSpinner spinner = new JSpinner(model);
        spinner.addChangeListener(ev -> configManager.setConfiguration("Skilling Notifications", "customXPValue", spinner.getValue()));
        customPanel.add(spinner);

        setVisible(true);
    }

    private void AddButton(JPanel panel, String configKey, String name, String description){
        panel.removeAll();
        JToggleButton button = new JToggleButton(name, Boolean.parseBoolean(configManager.getConfiguration("Skilling Notifications", configKey)));
        button.setFocusable(false);
        button.setToolTipText(description);
        button.addItemListener(ev -> configManager.setConfiguration("Skilling Notifications", configKey, ev.getStateChange() == ItemEvent.SELECTED));
        panel.add(button);
    }

    private BufferedImage GetIcon(String path) {
        BufferedImage iconImage = iconsCache.get(path);
        if (iconImage != null) return iconImage;
        iconImage = ImageUtil.loadImageResource(getClass(), path);
        iconsCache.put(path, iconImage);
        return iconImage;
    }
}

package eu.jodelahithit;

import net.runelite.client.config.*;

import java.awt.*;
import java.awt.event.KeyEvent;

@ConfigGroup("Skilling Notifications")
public interface SkillingNotificationsConfig extends Config {
    @ConfigItem(
            hidden = true,
            keyName = "enabled",
            name = "Enabled",
            description = "Toggles the overlay and plugin functionality",
            position = 0
    )
    default boolean enabled() {
        return true;
    }

    @ConfigItem(
            keyName = "toggle",
            name = "Toggle keybind",
            description = "The key which will toggle the overlay and plugin functionality",
            position = 1

    )
    default ModifierlessKeybind toggle()
    {
        return new ModifierlessKeybind(KeyEvent.VK_F5, 0);
    }

    @ConfigItem(
            keyName = "toggleFlash",
            name = "Toggle flash keybind",
            description = "The key which will toggle the notifcation flash",
            position = 2

    )
    default ModifierlessKeybind toggleFlash()
    {
        return new ModifierlessKeybind(KeyEvent.VK_F6, 0);
    }


    @Alpha
    @ConfigItem(
            keyName = "overlayColor",
            name = "Notification color",
            description = "Set the notification overlay color",
            position = 3
    )
    default Color overlayColor() {
        return new Color(1.0f, 0.0f, 0.0f, 0.5f);
    }

    @ConfigItem(
            keyName = "notificationFlash",
            name = "Notification flash",
            description = "Flash the idle overlay",
            position = 4
    )
    default boolean flash() {
        return false;
    }

    @ConfigItem(
            keyName = "notificationFade",
            name = "Notification fade duration",
            description = "Duration of the idle overlay fade",
            position = 5
    )
    default int notificationFade() {
        return 0;
    }

    @ConfigItem(
            keyName = "disableOverlayText",
            name = "Disable overlay text",
            description = "Disable the \"Skill Notification\" text on the overlay",
            position = 6
    )
    default boolean disableOverlayText() {
        return false;
    }

    @ConfigItem(
            keyName = "disableWhenWalking",
            name = "Disable overlay while walking",
            description = "Disable the idle overlay when the player is walking or running",
            position = 7
    )
    default boolean disableWhenWalking() {
        return true;
    }


    @ConfigItem(
            keyName = "notificationSound",
            name = "Notification sound",
            description = "Plays a sound when the player is idle",
            position = 8
    )
    default boolean notificationSound() {return false;}

    @ConfigSection(
            name = "Selected skills",
            description = "Set the selected skills that will cause a notification when idling",
            position = 20
    )
    String selectedSkills = "Selected skills";

    @ConfigItem(
            keyName = "COOKING",
            name = "Cooking",
            description = "Causes notifications when the player is not actively cooking",
            position = 21,
            section = selectedSkills
    )
    default boolean cooking() {
        return false;
    }


    @ConfigItem(
            keyName = "CRAFTING",
            name = "Crafting",
            description = "Displays notifications when the player is not actively crafting",
            position = 22,
            section = selectedSkills
    )
    default boolean crafting() {
        return false;
    }

    @ConfigItem(
            keyName = "FISHING",
            name = "Fishing",
            description = "Displays notifications when the player is not actively fishing",
            position = 23,
            section = selectedSkills
    )
    default boolean fishing() {
        return false;
    }

    @ConfigItem(
            keyName = "FIREMAKING",
            name = "Firemaking",
            description = "Displays notifications when the player is not actively firemaking",
            position = 24,
            section = selectedSkills
    )
    default boolean firemaking() {
        return false;
    }

    @ConfigItem(
            keyName = "FLETCHING",
            name = "Fletching ",
            description = "Displays notifications when the player is not actively fletching",
            position = 25,
            section = selectedSkills
    )
    default boolean fletching() {
        return false;
    }

    @ConfigItem(
            keyName = "HERBLORE",
            name = "Herblore",
            description = "Displays notifications when the player is not actively doing herblore",
            position = 26,
            section = selectedSkills
    )
    default boolean herblore() {
        return false;
    }

    @ConfigItem(
            keyName = "MINING",
            name = "Mining",
            description = "Displays notifications when the player is not actively mining",
            position = 27,
            section = selectedSkills
    )
    default boolean mining() {
        return false;
    }

    @ConfigItem(
            keyName = "WOODCUTTING",
            name = "Woodcutting",
            description = "Displays notifications when the player is not actively woodcutting",
            position = 28,
            section = selectedSkills
    )
    default boolean woodcutting() {
        return false;
    }

    @ConfigItem(
            keyName = "SMITHING",
            name = "Smithing",
            description = "Displays notifications when the player is not actively smithing",
            position = 29,
            section = selectedSkills
    )
    default boolean smithing() {
        return false;
    }

    @ConfigItem(
            keyName = "COMBAT",
            name = "Combat",
            description = "Displays notifications when the player is not in combat",
            position = 30,
            section = selectedSkills
    )
    default boolean combat() {
        return false;
    }

    @ConfigItem(
            keyName = "MANIACALMONKEYS",
            name = "Maniacal monkeys",
            description = "Displays notifications when the player is not catching maniacal monkeys",
            position = 31,
            section = selectedSkills
    )
    default boolean maniacalMonkeys() {
        return false;
    }

    @ConfigItem(
            keyName = "LUNAR",
            name = "Lunar",
            description = "Displays notifications when the player is not casting Lunar crafting spells",
            position = 32,
            section = selectedSkills
    )
    default boolean lunar() {
        return false;
    }

    @ConfigItem(
            keyName = "CUSTOMXP",
            name = "Custom XP",
            description = "Displays notifications when the player is not receiving xp drops of the configured threshold",
            position = 47,
            section = selectedSkills
    )
    default boolean customXP() {
        return false;
    }

    @ConfigItem(
            keyName = "customXPValue",
            name = "Custom XP Amount",
            description = "The amount of XP that needs to be received in order to disable the custom xp notification",
            position = 48,
            section = selectedSkills
    )
    default int customXPValue() {
        return 20;
    }

    @ConfigSection(
            name = "Extra Delays",
            description = "Set notification delays in milliseconds for individual skills. This means that it'll take longer for the notification to appear after the player started idling",
            position = 49
    )
    String delays = "Extra Delays";

    @ConfigItem(
            keyName = "WALKINGDELAYV2",
            name = "Walking delay",
            description = "Add an extra delay to notifications after walking when 'disable overlay while walking' is enabled",
            position = 50,
            section = delays
    )
    default int walkDelay() {
        return 2000;
    }

    @ConfigItem(
            keyName = "COOKINGDELAYV2",
            name = "Cooking delay",
            description = "Add an extra delay before the cooking notification",
            position = 51,
            section = delays
    )
    default int cookingDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "CRAFTINGDELAYV2",
            name = "Crafting delay",
            description = "Add an extra delay before the crafting notification",
            position = 52,
            section = delays
    )
    default int craftingDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "FISHINGDELAYV2",
            name = "Fishing delay",
            description = "Add an extra delay before the fishing notification",
            position = 53,
            section = delays
    )
    default int fishingDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "FIREMAKINGDELAYV2",
            name = "Firemaking delay",
            description = "Add an extra delay before the firemaking notification",
            position = 54,
            section = delays
    )
    default int firemakingDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "FLETCHINGDELAYV2",
            name = "Fletching delay",
            description = "Add an extra delay before the fletching notification",
            position = 55,
            section = delays
    )
    default int fletchingDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "HERBLOREDELAYV2",
            name = "Herblore delay",
            description = "Add an extra delay before the herblore notification",
            position = 56,
            section = delays
    )
    default int herbloreDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "MININGDELAYV2",
            name = "Mining delay",
            description = "Add an extra delay before the mining notification",
            position = 57,
            section = delays
    )
    default int miningDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "WOODCUTTINGDELAYV2",
            name = "Woodcutting delay",
            description = "Add an extra delay before the woodcutting notification",
            position = 58,
            section = delays
    )
    default int woodcuttingDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "SMITHINGDELAYV2",
            name = "Smithing delay",
            description = "Add an extra delay before the smithing notification",
            position = 59,
            section = delays
    )
    default int smithingDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "MANIACALMONKEYSDELAYV2",
            name = "Maniacal monkeys delay",
            description = "Add an extra delay before the maniacal monkey notification",
            position = 60,
            section = delays
    )
    default int maniacalMonkeysDelay() {
        return 0;
    }
    @ConfigItem(
            keyName = "LUNARDELAYV2",
            name = "Lunar delay",
            description = "Add an extra delay before the Lunar spell notification",
            position = 61,
            section = delays
    )
    default int lunarDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "COMBATDELAYV2",
            name = "Combat delay",
            description = "Add an extra delay before the combat notification",
            position = 62,
            section = delays
    )
    default int combatDelay() {
        return 0;
    }

    @ConfigItem(
            keyName = "CUSTOMXPDELAYV2",
            name = "Custom XP delay",
            description = "Add an extra delay before the custom XP notification",
            position = 63,
            section = delays
    )
    default int customXPDelay() {
        return 1000;
    }
}

