package com.gimptracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GimpTrackerPlugin.class);
		RuneLite.main(args);
	}
}
package com.gimptracker;

import net.runelite.api.Item;

public class DataItem
{
    public int id = DataBuilder.DataInventoryID.NOT_SET;
    public int quantity = 0;

    public DataItem(){

    }

    public DataItem(int id, int quantity){
        this.id = id;
        this.quantity = quantity;
    }

    @Override
    public boolean equals(Object o)
    {
        if(o instanceof Item)
        {
            Item other = (Item)o;
            return other != null && id == other.getId() && quantity == other.getQuantity();
        }

        DataItem other = (DataItem)o;
        return other != null && id == other.id && quantity == other.quantity;
    }
}

package com.gimptracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;

import javax.swing.*;

@ConfigGroup("gimptracker")
public interface GimpTrackerConfig extends Config
{
    @ConfigItem(
            position = 1,
            keyName = "url",
            name = "URL",
            description = "URL to backend"
    )
    default String url()
    {
        return "localhost";
    }

    @ConfigItem(
            position = 2,
            keyName = "password",
            name = "Password",
            description = "Password to backend"
    )
    default String password()
    {
        return "123";
    }

    @ConfigItem
    (
            position = 3,
            keyName = "sendData",
            name = "Send data",
            description = "Should we send data to the GIMP Tracker website or not"
    )
    default boolean sendData() { return true; }

    @ConfigItem
    (
            position = 4,
            keyName = "connectOnLogin",
            name = "Connect on login",
            description = "Should automatically connect to the tracker backend upon login"
    )
    default boolean connectOnLogin() { return true; }

    @ConfigItem
    (
            position = 5,
            keyName = "sendInventory",
            name = "Send inventory data",
            description = "Should we update our inventory on the GIMP Tracker website or not"
    )
    default boolean sendInventory() { return true; }

    @ConfigItem
    (
            position = 6,
            keyName = "sendEquipment",
            name = "Send equipment data",
            description = "Should we update our equipment on the GIMP Tracker website or not"
    )
    default boolean sendEquipment() { return true; }

    @ConfigItem
    (
            position = 7,
            keyName = "sendSkill",
            name = "Send skill data",
            description = "Should we update our skills/experience on the GIMP Tracker website or not"
    )
    default boolean sendSkill() { return true; }

    @ConfigItem
    (
            position = 8,
            keyName = "sendHealth",
            name = "Send health data",
            description = "Should we update our health on the GIMP Tracker website or not"
    )
    default boolean sendHealth() { return true; }

    @ConfigItem
    (
            position = 9,
            keyName = "sendPrayer",
            name = "Send prayer data",
            description = "Should we update our prayer on the GIMP Tracker website or not"
    )
    default boolean sendPrayer() { return true; }

    @ConfigItem
    (
            position = 10,
            keyName = "sendEnergy",
            name = "Send energy data",
            description = "Should we update our run energy on the GIMP Tracker website or not"
    )
    default boolean sendEnergy() { return true; }
}

//package net.runelite.client.plugins.gimptracker;
package com.gimptracker;

import com.google.gson.*;
import com.google.inject.Provides;
import io.socket.client.IO;
import io.socket.client.Manager;
import io.socket.client.Socket;
import io.socket.emitter.Emitter;
import io.socket.engineio.client.transports.Polling;
import io.socket.engineio.client.transports.WebSocket;
import lombok.Getter;
import lombok.SneakyThrows;
import lombok.NonNull;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.vars.AccountType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigDescriptor;
import net.runelite.client.config.ConfigItemDescriptor;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.FishingSpot;
import net.runelite.client.game.WorldService;

import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Collection;
import java.util.Collections;
import java.util.stream.Collectors;

/**
 * Sends data to a backend which then relays it further to frontend
 * which displays live data of the player
 */
@PluginDescriptor(
        name = "GIMP Tracker",
        description = "Tracks players movement/inventory/skills etc..",
        tags = {"tracker", "gimp"},
        enabledByDefault = true
)

@Getter
public class GimpTrackerPlugin extends Plugin implements ActionListener, ConnectionManager.ConnectionListener
{
    private static final String VERSION = "1.0.2";
    private static final String CONFIG_GROUP = "gimptracker";

    private WorldPoint previousTile = new WorldPoint(0, 0, 0);
    private int previousHealth = 99;
    private int previousPrayer = 99;
    private int previousEnergy = 100;

    private int tickCountSinceLogged = 0;

    // I need to be able to check tripple gamestates lol
    // so we can check if this user actually logged in or if it was just a chunk change
    public GameState previousGameState = GameState.UNKNOWN;
    public GameState previousGameState2 = GameState.UNKNOWN;

    public JButton connectButton;
    public JLabel connectButtonLabel;
    public JButton debugButton;

    private NavigationButton navButton;

    private DataManager dataManager;
    private ConnectionManager connectionManager;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ConfigManager configManager;

    @Inject
    private GimpTrackerConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Provides
    private GimpTrackerConfig getConfig(ConfigManager configManager)
    {
        return configManager.getConfig(GimpTrackerConfig.class);
    }

    @Override
    public void onConnectionStatusChanged(ConnectionManager.ConnectionStatus status) {
        updateConnectButton();

        switch(status)
        {
            case DISCONNECTED:
                // we need to reset packets once a client disconnects from the backend
                // so he sends full information again once he connets
                dataManager.resetPackets();
                break;
        }
    }

    @Override
    public void onConnectionErrorChanged(ConnectionManager.ConnectionError status) {
        updateConnectButton();

        switch(status)
        {
            case AUTHORIZED:
                queueFullPacket();
                break;
        }
    }

    public void queueFullPacket()
    {
        WorldPoint point = client.getLocalPlayer().getWorldLocation();
        dataManager.getCurrentPacket().setName(client.getLocalPlayer().getName()); // NAME
        dataManager.getCurrentPacket().setPosition(point.getX(), point.getY(), point.getPlane());  // POS

        // these 3 flags are mandatory, if not, you might aswell not run the plugin
        int flags = DataBuilder.DataFlags.POSITION | DataBuilder.DataFlags.NAME | DataBuilder.DataFlags.WORLD | DataBuilder.DataFlags.ACCOUNT_TYPE;

        dataManager.getCurrentPacket().setWorld(client.getWorld());
        queueAccountType();

        if(config.sendInventory())
        {
            flags |= DataBuilder.DataFlags.INVENTORY;
            queueInventoryData(); // INVENTORY
        }

        if(config.sendSkill())
        {
            flags |= DataBuilder.DataFlags.SKILLS;
            queueSkillData(); // SKILLS
        }

        if(config.sendEquipment())
        {
            flags |= DataBuilder.DataFlags.EQUIPMENT;
            queueEquipmentData(); // EQUIPMENT
        }

        // a game tick should always run before we start sending packets
        // so getting previous Health/Prayer/Energy should be safe here
        if(config.sendHealth())
        {
            flags |= DataBuilder.DataFlags.HEALTH;
            dataManager.getCurrentPacket().setHealth(previousHealth);
        }

        if(config.sendPrayer())
        {
            flags |= DataBuilder.DataFlags.PRAYER;
            dataManager.getCurrentPacket().setPrayer(previousPrayer);
        }

        if(config.sendEnergy())
        {
            flags |= DataBuilder.DataFlags.ENERGY;
            dataManager.getCurrentPacket().setEnergy(previousEnergy);
        }

        dataManager.getCurrentPacket().setGoalFlags(flags);
    }

    // queues inventory data to next packet
    public void queueInventoryData()
    {
        clientThread.invokeLater(() ->
        {
            ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
            Item[] items = null;
            if(inventory != null)
                items = inventory.getItems();

            dataManager.getCurrentPacket().setInventory(items);
        });
    }

    // queues skill data to next packet
    public void queueSkillData()
    {
        clientThread.invokeLater(() ->
        {
            DataSkill[] skills = new DataSkill[Skill.values().length - 1];
            for(int i = 0; i < Skill.values().length - 1; i++)
            {
                int xp = client.getSkillExperience(Skill.values()[i]);
                skills[i] = new DataSkill(i, xp);
            }

            dataManager.getCurrentPacket().setSkills(skills);
        });
    }

    // queues equipment data to next packet
    public void queueEquipmentData()
    {
        clientThread.invokeLater(() ->
        {
            ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
            Item[] items = null;
            if(equipment != null)
                items = equipment.getItems();

            dataManager.getCurrentPacket().setEquipment(items);
        });
    }

    public void queueAccountType()
    {
        clientThread.invokeLater(() ->
        {
            int accType = client.getVar(Varbits.ACCOUNT_TYPE);
            dataManager.getCurrentPacket().setAccountType(accType);
        });
    }

    // connect indicates if it was the clients first packet (connect)
    public void updateClient(boolean connect)
    {
        if(!dataManager.getCurrentPacket().hasReachedGoal())
            return;

        dataManager.getCurrentPacket().resetGoal(); // set packet building goal to nothing, so send any packet from now on
        DataBuilder builder = dataManager.finalizePacket();
        if(builder.wasChanged)
        {
            String evt = connect?ConnectionManager.SocketEvent.CONNECT:ConnectionManager.SocketEvent.UPDATE;
            connectionManager.sendData(evt, builder.build());
        }
    }

    private void updateConnectButton()
    {
        switch(connectionManager.getConnectionStatus())
        {
            case CONNECTING:
                connectButton.setText("Connecting...");
                connectButton.setEnabled(true);
                break;

            case DISCONNECTING:
                connectButton.setText("Disconnecting...");
                connectButton.setEnabled(false);
                break;

            case CONNECTED:
                connectButton.setEnabled(true);
                connectButton.setText("Disconnect");
                break;

            case DISCONNECTED:
                connectButton.setEnabled(client.getGameState() == GameState.LOGGED_IN);
                // if we're trying to reconnect after dc
                if(connectionManager.isConnecting())
                    connectButton.setText("Connecting...");
                else
                    connectButton.setText("Connect");
                break;
            default:
                break;
        }

        connectButtonLabel.setText(ConnectionManager.connectionErrorStrings[connectionManager.getConnectionError().ordinal()]);
        switch(connectionManager.connectionError)
        {
            case NONE:
                connectButtonLabel.setForeground(Color.WHITE);
                break;
            case AUTHORIZED:
                connectButtonLabel.setForeground(Color.GREEN);
                break;
            case UNAUTHORIZED:
            case TIMED_OUT:
            case BAD_URL:
            case LOST_CONNECTION:
                connectButtonLabel.setForeground(Color.RED);
                break;
        }
    }

    public void actionPerformed(ActionEvent arg0)
    {
        JButton btn = (JButton)arg0.getSource();
        //String buttonName = btn.getActionCommand();

        if(btn == connectButton)
        {
            if(connectionManager.isConnecting() || connectionManager.isConnected())
            {
                connectionManager.disconnect();
            }
            else
            {
                connectionManager.connect();
            }
        }
        else if(btn == debugButton)
        {
            clientThread.invokeLater(() ->
            {
                int accType = client.getVar(Varbits.ACCOUNT_TYPE);
                System.out.println(accType);
            });
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if(event.getContainerId() == InventoryID.INVENTORY.getId())
        {
            if(config.sendInventory())
                queueInventoryData();
        }
        else if(event.getContainerId() == InventoryID.EQUIPMENT.getId())
        {
            if(config.sendEquipment())
                queueEquipmentData();
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged)
    {
        if(config.sendSkill())
            queueSkillData();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN)
        {
            dataManager.getCurrentPacket().setWorld(client.getWorld());
            // LOGGED_IN is called on chunk changes aswell so, need a double check here for previous state
            if(previousGameState == GameState.LOADING && previousGameState2 == GameState.LOGGING_IN) {
                tickCountSinceLogged = 0;
                updateConnectButton();
            }
        }
        else if(event.getGameState() == GameState.CONNECTION_LOST || event.getGameState() == GameState.LOGIN_SCREEN)
        {
            // when we lose connection or log out, disconnect socket
            connectionManager.disconnect();
        }

        previousGameState2 = previousGameState;
        previousGameState = event.getGameState();
    }

    public void postLogInTick()
    {
        // when user logged in lets connect to socket
        tickCountSinceLogged = -1;

        if(config.connectOnLogin())
            connectionManager.connect();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!CONFIG_GROUP.equals(event.getGroup()))
            return;

        // if we change password, update options builder for the socket
        switch (event.getKey())
        {
            case "password":
                connectionManager.setSocketBuilderOptions(true, -1, config.password());
                break;
        }
    }

    @Override
    protected void startUp() throws Exception
    {
        connectionManager = new ConnectionManager(this);
        dataManager = new DataManager();

        connectionManager.init();
        connectionManager.addConnectionListener(this);

        connectButton = new JButton("Connect");
        connectButton.addActionListener(this);

        //debugButton = new JButton("Debug");
        //debugButton.addActionListener(this);

        connectButtonLabel = new JLabel("");

        final GimpTrackerPanel panel = injector.getInstance(GimpTrackerPanel.class);

        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/gimptracker.png");

        navButton = NavigationButton.builder()
                .tooltip("GIMP Tracker")
                .icon(icon)
                .priority(1)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);
    }

    @Override
    protected void shutDown() throws Exception
    {
        connectionManager.disconnect();
        clientToolbar.removeNavigation(navButton);
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) throws Exception{

        if(config.sendData() && connectionManager.isConnected() && connectionManager.isAuthorized()) // dataManager.shouldSendPacket() &&
        {
            this.updateClient(connectionManager.isFirstPacket());
        }

        if(tickCountSinceLogged >= 1)
            postLogInTick();

        if(tickCountSinceLogged >= 0)
            tickCountSinceLogged++;

        WorldPoint currentTile = client.getLocalPlayer().getWorldLocation();
        int currentHealth = client.getBoostedSkillLevel(Skill.HITPOINTS);
        int currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
        int currentEnergy = client.getEnergy();

        // tile same as last time, no need to update
        if( currentTile.getX() != previousTile.getX() ||
            currentTile.getY() != previousTile.getY() ||
            currentTile.getPlane() != previousTile.getPlane())
        {
            dataManager.getCurrentPacket().setPosition(currentTile.getX(), currentTile.getY(), currentTile.getPlane());
            previousTile = currentTile;
        }

        if(currentHealth != previousHealth)
        {
            previousHealth = currentHealth;

            if(config.sendHealth())
                dataManager.getCurrentPacket().setHealth(currentHealth);
        }

        if(currentPrayer != previousPrayer)
        {
            previousPrayer = currentPrayer;
            if(config.sendPrayer())
                dataManager.getCurrentPacket().setPrayer(currentPrayer);
        }

        if(currentEnergy != previousEnergy)
        {
            previousEnergy = currentEnergy;
            if(config.sendEnergy())
                dataManager.getCurrentPacket().setEnergy(currentEnergy);
        }
    }

    private static Collection<DataItem> toGameItems(Collection<ItemStack> items)
    {
        return items.stream()
                .map(item -> new DataItem(item.getId(), item.getQuantity()))
                .collect(Collectors.toList());
    }

    void addLoot(@NonNull String name, int combatLevel, LootRecordType type, Object metadata, Collection<ItemStack> items)
    {
        Collection<DataItem> drop_items = toGameItems(items);
        DataItem item[] = drop_items.toArray(new DataItem[drop_items.size()]);
        DataLoot loot = new DataLoot((int)metadata, combatLevel, name, type, ""+Instant.now().toEpochMilli());

        loot.items = item;
        dataManager.getCurrentPacket().addLoot(loot);
    }

    @Subscribe
    public void onNpcLootReceived(final NpcLootReceived npcLootReceived)
    {
        final NPC npc = npcLootReceived.getNpc();
        final Collection<ItemStack> items = npcLootReceived.getItems();
        final String name = npc.getName();
        final int combat = npc.getCombatLevel();

        addLoot(name, combat, LootRecordType.NPC, npc.getId(), items);
    }

    @Subscribe
    public void onPlayerLootReceived(final PlayerLootReceived playerLootReceived)
    {
        final Player player = playerLootReceived.getPlayer();
        final Collection<ItemStack> items = playerLootReceived.getItems();
        final String name = player.getName();
        final int combat = player.getCombatLevel();

        addLoot(name, combat, LootRecordType.PLAYER, null, items);
    }
}

package com.gimptracker;

import com.google.gson.JsonObject;
import com.google.gson.JsonArray;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class DataBuilder {

    public class DataInventoryID
    {
        public final static int NOT_SET = -2;
        public final static int EMPTY = -1;
    }

    public class DataFlags
    {
        public final static int UNDEFINED = 0; // if set to undefined goal, the packet will send no matter what the upcomming tick
        public final static int NAME = 1;
        public final static int WORLD = 2;
        public final static int POSITION = 4;
        public final static int INVENTORY = 8;
        public final static int SKILLS = 16;
        public final static int EQUIPMENT = 32;
        public final static int HEALTH = 64;
        public final static int PRAYER = 128;
        public final static int ENERGY = 256;
        public final static int LOOT = 512;
        public final static int ACCOUNT_TYPE = 1024;

        public final static int ALL = NAME | WORLD | POSITION | HEALTH | PRAYER | ENERGY | INVENTORY | SKILLS | EQUIPMENT | ACCOUNT_TYPE; // | LOOT;
    }

    public final static int INVENTORY_SIZE = 28;
    public final static int EQUIPMENT_SIZE = 14; // 11 & 6 & 8 is missing for some reason, idk :D
    public final static int INVALID_WORLD  = -1;

    public String name = null;
    public int world = INVALID_WORLD;
    public WorldPoint pos = null;
    public DataItem[] inventory = null;
    public DataSkill[] skills = null;
    public DataItem[] equipment = null;
    public LinkedList<DataLoot> loot = new LinkedList<DataLoot>();
    int health = -1;
    int prayer = -1;
    int energy = -1;
    int accountType = -1;

    public JsonObject data = null;

    public int goalProgress = DataFlags.UNDEFINED;
    public int goal = DataFlags.UNDEFINED;

    // indicates if data was modified
    public boolean wasChanged = false;

    public DataBuilder()
    {

    }

    public DataBuilder(DataBuilder other)
    {
        this.health = other.health;
        this.prayer = other.prayer;
        this.energy = other.energy;
        this.name = other.name;
        this.world = other.world;
        this.pos = other.pos;
        this.accountType = other.accountType;

        if(other.inventory != null)
        {
            this.inventory = new DataItem[INVENTORY_SIZE];
            System.arraycopy(other.inventory, 0, this.inventory, 0, other.inventory.length);
        }

        if(other.skills != null)
        {
            this.skills = new DataSkill[Skill.values().length - 1];
            System.arraycopy(other.skills, 0, this.skills, 0, other.skills.length);
        }

        if(other.equipment != null)
        {
            this.equipment = new DataItem[EQUIPMENT_SIZE];
            System.arraycopy(other.equipment, 0, this.equipment, 0, other.equipment.length);
        }

        if(other.loot != null && other.loot.size() > 0)
        {
            this.loot = new LinkedList<>();
            for(int i = 0; i < other.loot.size(); i++)
            {
                DataLoot otherLoot = other.loot.get(i);
                DataLoot newLoot = new DataLoot();
                newLoot.metadata = otherLoot.metadata;
                newLoot.combatLevel = otherLoot.combatLevel;
                newLoot.name = otherLoot.name;
                newLoot.timestamp = otherLoot.timestamp;
                newLoot.items = new DataItem[otherLoot.items.length];
                System.arraycopy(otherLoot.items, 0, newLoot.items, 0, otherLoot.items.length);
                this.loot.add(newLoot);
            }

        }

        if(other.data != null)
            this.data = other.data.deepCopy();

        this.wasChanged = other.wasChanged;
    }

    public void setHealth(int health)
    {
        setGoalProgressFlag(DataFlags.HEALTH);
        wasChanged = true;
        this.health = health;
    }

    public void setPrayer(int prayer)
    {
        setGoalProgressFlag(DataFlags.PRAYER);
        wasChanged = true;
        this.prayer = prayer;
    }

    public void setEnergy(int energy)
    {
        setGoalProgressFlag(DataFlags.ENERGY);
        wasChanged = true;
        this.energy = energy;
    }

    public void setName(String name)
    {
        setGoalProgressFlag(DataFlags.NAME);
        wasChanged = true;
        this.name = name;
    }

    public void setWorld(int world)
    {
        setGoalProgressFlag(DataFlags.WORLD);
        wasChanged = true;
        this.world = world;
    }

    public void setAccountType(int accountType)
    {
        setGoalProgressFlag(DataFlags.ACCOUNT_TYPE);
        wasChanged = true;
        this.accountType = accountType;
    }

    public void setPosition(int x, int y, int plane)
    {
        setGoalProgressFlag(DataFlags.POSITION);
        wasChanged = true;
        this.pos = new WorldPoint(x, y, plane);
    }

    public void setInventory(Item[] inventory)
    {
        setGoalProgressFlag(DataFlags.INVENTORY);
        if(inventory == null)
            return;

        wasChanged = true;
        this.inventory = new DataItem[INVENTORY_SIZE];

        for(int i = 0; i < this.inventory.length; i++)
        {
            Item item = null;
            if(i < inventory.length)
                item = inventory[i];

            this.inventory[i] = new DataItem();
            if(item == null)
            {
                this.inventory[i].id = DataInventoryID.EMPTY;
                this.inventory[i].quantity = 0;
            }
            else
            {
                this.inventory[i].id = item.getId();
                this.inventory[i].quantity = item.getQuantity();
            }
        }
    }

    public void setInventory(DataItem[] inventory)
    {
        setGoalProgressFlag(DataFlags.INVENTORY);
        if(inventory == null)
            return;

        wasChanged = true;
        this.inventory = new DataItem[INVENTORY_SIZE];

        for(int i = 0; i < this.inventory.length; i++)
        {
            DataItem item = null;
            if(i < inventory.length)
                item = inventory[i];

            this.inventory[i] = new DataItem();
            if(item == null)
            {
                this.inventory[i].id = DataInventoryID.NOT_SET;
                this.inventory[i].quantity = 0;
            }
            else
            {
                this.inventory[i].id = item.id;
                this.inventory[i].quantity = item.quantity;
            }
        }
    }

    public void setEquipment(Item[] equipment)
    {
        setGoalProgressFlag(DataFlags.EQUIPMENT);
        if(equipment == null)
            return;

        wasChanged = true;
        this.equipment = new DataItem[EQUIPMENT_SIZE];

        for(int i = 0; i < this.equipment.length; i++)
        {
            Item item = null;
            if(i < equipment.length)
                item = equipment[i];

            this.equipment[i] = new DataItem();
            if(item == null)
            {
                this.equipment[i].id = DataInventoryID.EMPTY;
                this.equipment[i].quantity = 0;
            }
            else
            {
                this.equipment[i].id = item.getId();
                this.equipment[i].quantity = item.getQuantity();
            }
        }
    }

    public void setEquipment(DataItem[] equipment)
    {
        setGoalProgressFlag(DataFlags.EQUIPMENT);
        if(equipment == null)
            return;

        wasChanged = true;
        this.equipment = new DataItem[EQUIPMENT_SIZE];

        for(int i = 0; i < this.equipment.length; i++)
        {
            DataItem item = null;
            if(i < equipment.length)
                item = equipment[i];

            this.equipment[i] = new DataItem();
            if(item == null)
            {
                this.equipment[i].id = DataInventoryID.NOT_SET;
                this.equipment[i].quantity = 0;
            }
            else
            {
                this.equipment[i].id = item.id;
                this.equipment[i].quantity = item.quantity;
            }
        }
    }

    public void setSkills(DataSkill[] skills)
    {
        setGoalProgressFlag(DataFlags.SKILLS);
        if(skills == null)
            return;

        wasChanged = true;
        this.skills = skills;
    }

    public void setLoot(LinkedList<DataLoot> loot) {
        setGoalProgressFlag(DataFlags.LOOT);

        if(loot == null)
            return;

        wasChanged = true;
        this.loot = loot;
    }

    public void addLoot(DataLoot loot) {
        setGoalProgressFlag(DataFlags.LOOT);

        if(loot == null)
            return;

        wasChanged = true;
        this.loot.add(loot);
    }

    public JsonObject build()
    {
        data = new JsonObject();

        if(health != -1)
            data.addProperty("health", health);

        if(prayer != -1)
            data.addProperty("prayer", prayer);

        if(energy != -1)
            data.addProperty("energy", energy);

        if(name != null)
            data.addProperty("name", name);

        if(world != INVALID_WORLD)
            data.addProperty("world", world);

        if(accountType != -1)
            data.addProperty("accountType", accountType);

        if(pos != null)
        {
            JsonObject jsonPos = new JsonObject();
            jsonPos.addProperty("x", this.pos.getX());
            jsonPos.addProperty("y", this.pos.getY());
            jsonPos.addProperty("plane", this.pos.getPlane());

            data.add("pos", jsonPos);
        }

        JsonObject jsonInventory = new JsonObject();

        if(inventory != null)
        {
            for(int i = 0; i < INVENTORY_SIZE; i++)
            {
                if(this.inventory[i].id == DataInventoryID.NOT_SET)
                    continue;

                JsonObject jsonInvSlotData = new JsonObject();
                jsonInvSlotData.addProperty("id", this.inventory[i].id);
                jsonInvSlotData.addProperty("quantity", this.inventory[i].quantity);

                jsonInventory.add(String.valueOf(i), jsonInvSlotData);
            }

            data.add("inventory", jsonInventory);
        }

        JsonObject jsonSkills = new JsonObject();
        if(skills != null)
        {
            for(int i = 0; i < Skill.values().length - 1; i++)
            {
                if(this.skills[i].id == -1)
                    continue;

                JsonObject jsonSkillData = new JsonObject();
                jsonSkillData.addProperty("id", this.skills[i].id);
                jsonSkillData.addProperty("experience", this.skills[i].experience);

                jsonSkills.add(String.valueOf(i), jsonSkillData);
            }

            data.add("skills", jsonSkills);
        }

        JsonObject jsonEquipment = new JsonObject();
        if(equipment != null)
        {
            for(int i = 0; i < EQUIPMENT_SIZE; i++)
            {
                if(this.equipment[i].id == DataInventoryID.NOT_SET)
                    continue;

                JsonObject jsonEqpSlotData = new JsonObject();
                jsonEqpSlotData.addProperty("id", this.equipment[i].id);
                jsonEqpSlotData.addProperty("quantity", this.equipment[i].quantity);

                jsonEquipment.add(String.valueOf(i), jsonEqpSlotData);
            }

            data.add("equipment", jsonEquipment);
        }

        JsonArray jsonLootArray = new JsonArray();
        JsonObject jsonLoot= new JsonObject();
        long lootLength = loot.size();
        if(loot != null && lootLength > 0)
        {
            for(int j = 0; j < lootLength; j++)
            {
                DataLoot currentLoot = loot.remove();
                jsonLoot.addProperty("metadata", currentLoot.metadata);
                jsonLoot.addProperty("combatLevel", currentLoot.combatLevel);
                jsonLoot.addProperty("name", currentLoot.name);
                jsonLoot.addProperty("type", currentLoot.type.name());
                jsonLoot.addProperty("timestamp", currentLoot.timestamp);
                JsonArray jsonLootItems = new JsonArray();
                for(int i = 0; i < currentLoot.items.length; i++)
                {
                    JsonObject jsonLootSlotData = new JsonObject();
                    jsonLootSlotData.addProperty("id", currentLoot.items[i].id);
                    jsonLootSlotData.addProperty("quantity", currentLoot.items[i].quantity);
                    jsonLootItems.add(jsonLootSlotData);
                }
                jsonLoot.add("items", jsonLootItems);
                jsonLootArray.add(jsonLoot);
            }

            data.add("loot", jsonLootArray);
        }

        wasChanged = false;
        return data;
    }

    public JsonObject getBuiltData()
    {
        return data;
    }

    public void setGoalProgressFlag(int dataFlag)
    {
        goalProgress |= dataFlag;
    }

    public void setGoalFlags(int dataFlag)
    {
        goal = dataFlag;
    }

    public boolean hasReachedGoal()
    {
        return (goalProgress & goal) == goal;
    }

    public void resetGoal()
    {
        goal = DataFlags.UNDEFINED;
    }

    @Override
    public boolean equals(Object o)
    {
        DataBuilder other = (DataBuilder) o;
        return  health == other.health &&
                prayer == other.prayer &&
                energy == other.energy &&
                name.equals(other.name) &&
                world == other.world &&
                accountType == other.accountType &&
                pos.getX() == other.pos.getX() &&
                pos.getY() == other.pos.getY() &&
                pos.getPlane() == other.pos.getPlane() &&
                Arrays.equals(inventory, other.inventory) &&
                Arrays.equals(skills, other.skills) &&
                Arrays.equals(equipment, other.equipment) &&
                loot.equals(other.loot);
    }
}

package com.gimptracker;

import com.google.gson.JsonObject;
import io.socket.client.IO;
import io.socket.client.Socket;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.client.config.Config;
import net.runelite.client.plugins.Plugin;

import java.awt.*;
import java.lang.reflect.Method;
import java.net.URI;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.function.Function;

@Getter
public class ConnectionManager {

    public class SocketEvent
    {
        public final static String CONNECT = "RL_CONNECT_STATE";
        public final static String UPDATE = "RL_UPDATE_STATE";
    }

    public enum ConnectionStatus
    {
        CONNECTING,
        DISCONNECTING,
        CONNECTED,
        DISCONNECTED,

        MAX
    }

    public enum ConnectionError
    {
        NONE,
        AUTHORIZED,
        UNAUTHORIZED,
        TIMED_OUT,
        BAD_URL,
        LOST_CONNECTION,

        MAX,
    }

    public static final String[] connectionStatusStrings =
    {
            "Connecting",
            "Disconnecting",
            "Connected",
            "Disconnected",
    };

    public static final String[] connectionErrorStrings =
    {
            "",
            "Authorized",
            "Unauthorized",
            "Could not connect to URL",
            "Invalid URL",
            "Lost connection"
    };

    public interface ConnectionListener
    {
        public void onConnectionStatusChanged(ConnectionStatus status);
        public void onConnectionErrorChanged(ConnectionError status);
    }

    private URI uri = null;
    public IO.Options options = null;
    public Socket socket = null;
    private SocketEventConnect socketConnectEvent;
    private SocketEventDisconnect socketDisconnectEvent;
    private SocketEventTimeout socketTimeoutEvent;
    private SocketEventAuth socketAuthEvent;

    public ConnectionStatus connectionStatus = ConnectionStatus.DISCONNECTED;
    public ConnectionError connectionError = ConnectionError.NONE;

    public ArrayList<ConnectionListener> listeners = new ArrayList<ConnectionListener>();

    public boolean firstPacket = true;
    public boolean authorized = false;

    private GimpTrackerPlugin plugin = null;

    public ConnectionManager(GimpTrackerPlugin plugin)
    {
        this.plugin = plugin;
    }

    public void setConnectionStatus(ConnectionStatus status)
    {
        if(status == ConnectionStatus.DISCONNECTED)
        {
            firstPacket = true;
            authorized = false;
        }
        connectionStatus = status;
        for(int i = 0; i < listeners.size(); i++)
            listeners.get(i).onConnectionStatusChanged(status);
    }

    public void setConnectionError(ConnectionError error)
    {
        if(error == ConnectionError.AUTHORIZED)
            authorized = true;

        connectionError = error;
        for(int i = 0; i < listeners.size(); i++)
            listeners.get(i).onConnectionErrorChanged(error);
    }

    public void addConnectionListener(ConnectionListener listener)
    {
        listeners.add(listener);
    }

    public void init()
    {
        socketConnectEvent = new SocketEventConnect(this.plugin);
        socketDisconnectEvent = new SocketEventDisconnect(this.plugin);
        socketTimeoutEvent = new SocketEventTimeout(this.plugin);
        socketAuthEvent = new SocketEventAuth(this.plugin);

        setSocketBuilderOptions(true, -1, this.plugin.getConfig().password());
    }

    public void setSocketBuilderOptions(boolean reconnect, int timeout, String password)
    {
        options = IO.Options.builder().
                setQuery("system=runelite").
                setReconnection(reconnect).
                setTimeout(timeout).
                setReconnectionDelay(5_000). // attempt to reconnect every 5 seconds
                setAuth(Collections.singletonMap("token", password)).
                build();
    }

    public boolean isConnected()
    {
        return socket != null && socket.connected();
    }

    public boolean isConnecting()
    {
        return socket != null && socket.isActive() && !socket.connected();
    }

    public boolean connect()
    {
        disconnect();

        // check if URL is not complete gibberish
        try {
            uri = URI.create(plugin.getConfig().url());
        }catch (IllegalArgumentException e) {
            setConnectionError(ConnectionError.BAD_URL);
            return false;
        }

        // check if we can connect to given URL
        try {
            socket = IO.socket(uri, options);
        }catch(RuntimeException e) {
            setConnectionError(ConnectionError.BAD_URL);
            return false;
        }

        setConnectionError(ConnectionError.NONE);

        socket.on(Socket.EVENT_CONNECT, socketConnectEvent);
        socket.on(Socket.EVENT_DISCONNECT, socketDisconnectEvent);
        socket.on(Socket.EVENT_CONNECT_ERROR, socketTimeoutEvent);
        socket.on("authorize", socketAuthEvent);

        socket.connect();

        setConnectionStatus(ConnectionStatus.CONNECTING);
        return true;
    }

    public void disconnect()
    {
        if(socket != null)
        {
            if(socket.connected())
            {
                setConnectionStatus(ConnectionStatus.DISCONNECTING);

                socket.disconnect();
                socket.close();
                socket = null;
                return;
            }
            else
            {
                socket.close();
            }
        }

        socket = null;
        setConnectionStatus(ConnectionStatus.DISCONNECTED);
    }

    public void sendData(String event, JsonObject json)
    {

        socket.emit(event, json.toString());
        firstPacket = false;
    }
}

package com.gimptracker;

import net.runelite.http.api.loottracker.LootRecordType;

public class DataLoot {
    public int metadata;
    public int combatLevel;
    public String name;
    public LootRecordType type;
    public String timestamp;
    public DataItem items[];

    public DataLoot(){

    }

    public DataLoot(int metadata, int combatLevel, String name, LootRecordType type, String timestamp)
    {
        this.metadata = metadata;
        this.combatLevel = combatLevel;
        this.name = name;
        this.type = type;
        this.timestamp = timestamp;
    }

    @Override
    public boolean equals(Object o)
    {
        DataLoot other = (DataLoot) o;
        return other != null && metadata == other.metadata &&
                combatLevel == other.combatLevel && name.equals(other.name) &&
                type == other.type && timestamp.equals(other.timestamp);
    }
}

package com.gimptracker;

import io.socket.emitter.Emitter;

import java.sql.Connection;

public class SocketEventAuth implements Emitter.Listener
{
    private GimpTrackerPlugin plugin;

    SocketEventAuth(GimpTrackerPlugin plugin)
    {
        this.plugin = plugin;
    }

    @Override
    public void call(Object... objects)
    {
        // received after backend has authorized client
        if(objects.length != 1)
            return;

        boolean authorized = objects[0].equals("success");

        if(authorized)
        {

            plugin.getConnectionManager().setConnectionError(ConnectionManager.ConnectionError.AUTHORIZED);
        }
    }
}

package com.gimptracker;

import com.google.inject.ProvisionException;
import java.awt.GridLayout;
import java.awt.TrayIcon;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import javax.swing.JButton;
import javax.swing.JPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.infobox.Counter;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
class GimpTrackerPanel extends PluginPanel
{
    private final Client client;
    private final GimpTrackerPlugin plugin;

    @Inject
    private GimpTrackerPanel(
            Client client,
            GimpTrackerPlugin plugin)
    {
        super();
        this.client = client;
        this.plugin = plugin;

        setBackground(ColorScheme.DARK_GRAY_COLOR);

        add(createOptionsPanel());
    }

    private JPanel createOptionsPanel()
    {
        final JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setLayout(new GridLayout(0, 1, 3, 3));

        container.add(plugin.getConnectButtonLabel());
        container.add(plugin.getConnectButton());
        //container.add(plugin.getDebugButton());

        return container;
    }
}

package com.gimptracker;

import io.socket.emitter.Emitter;

public class SocketEventTimeout implements Emitter.Listener
{
    private GimpTrackerPlugin plugin;

    SocketEventTimeout(GimpTrackerPlugin plugin)
    {
        this.plugin = plugin;
    }

    @Override
    public void call(Object... objects)
    {
        // on client timeout (5 seconds after connect by default)
        plugin.getConnectionManager().setConnectionError(ConnectionManager.ConnectionError.TIMED_OUT);
    }
}

package com.gimptracker;

import com.google.gson.JsonObject;
import io.socket.client.IO;
import io.socket.client.Socket;
import lombok.Getter;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import org.json.JSONObject;

import java.awt.*;
import java.net.URI;
import java.util.Arrays;

@Getter
public class DataManager {

    public DataBuilder currentPacket;
    public DataBuilder previousPacket;

    public DataManager()
    {
        currentPacket = new DataBuilder();
        previousPacket = new DataBuilder();
    }

    // compare 2 packets and remove unchanged values from previous packet
    public DataBuilder finalizePacket()
    {
        DataBuilder builder = new DataBuilder();
        if(!currentPacket.wasChanged)
            return currentPacket;

        currentPacket.wasChanged = false;
        builder.wasChanged = false;

        // name was changed since last packet, keep it
        if(currentPacket.name != previousPacket.name)
            builder.setName(currentPacket.name);

        if(currentPacket.health != previousPacket.health)
            builder.setHealth(currentPacket.health);

        if(currentPacket.prayer != previousPacket.prayer)
            builder.setPrayer(currentPacket.prayer);

        if(currentPacket.energy != previousPacket.energy)
            builder.setEnergy(currentPacket.energy);

        if(currentPacket.world != previousPacket.world)
            builder.setWorld(currentPacket.world);

        if(currentPacket.accountType != previousPacket.accountType)
            builder.setAccountType(currentPacket.accountType);

        if(currentPacket.pos != null && !currentPacket.pos.equals(previousPacket.pos))
            builder.setPosition(currentPacket.pos.getX(), currentPacket.pos.getY(), currentPacket.pos.getPlane());

        if(currentPacket.inventory != null && !Arrays.equals(currentPacket.inventory, previousPacket.inventory))
        {
            if(previousPacket.inventory == null)
                builder.setInventory(currentPacket.inventory);
            else
            {
                DataItem[] items = new DataItem[DataBuilder.INVENTORY_SIZE];
                for(int i = 0; i < DataBuilder.INVENTORY_SIZE; i++)
                {
                    items[i] = new DataItem();
                    if(currentPacket.inventory[i].id != previousPacket.inventory[i].id ||
                        currentPacket.inventory[i].quantity != previousPacket.inventory[i].quantity)
                    {
                        items[i].id = currentPacket.inventory[i].id;
                        items[i].quantity = currentPacket.inventory[i].quantity;
                    }
                }
                builder.setInventory(items);
            }
        }

        if(currentPacket.skills != null && !Arrays.equals(currentPacket.skills, previousPacket.skills))
        {
            if(previousPacket.skills == null)
                builder.setSkills(currentPacket.skills);
            else
            {
                DataSkill[] skills = new DataSkill[Skill.values().length - 1];
                for(int i = 0; i < Skill.values().length - 1; i++)
                {
                    skills[i] = new DataSkill(-1, 0);
                    if(currentPacket.skills[i].experience != previousPacket.skills[i].experience)
                    {
                        skills[i].id = currentPacket.skills[i].id;
                        skills[i].experience = currentPacket.skills[i].experience;
                    }
                }
                builder.setSkills(skills);
            }
        }

        if(currentPacket.equipment != null && !Arrays.equals(currentPacket.equipment, previousPacket.equipment))
        {
            if(previousPacket.equipment == null)
                builder.setEquipment(currentPacket.equipment);
            else
            {
                DataItem[] items = new DataItem[DataBuilder.EQUIPMENT_SIZE];
                for(int i = 0; i < DataBuilder.EQUIPMENT_SIZE; i++)
                {
                    items[i] = new DataItem();
                    if(currentPacket.equipment[i].id != previousPacket.equipment[i].id ||
                            currentPacket.equipment[i].quantity != previousPacket.equipment[i].quantity)
                    {
                        items[i].id = currentPacket.equipment[i].id;
                        items[i].quantity = currentPacket.equipment[i].quantity;
                    }
                }
                builder.setEquipment(items);
            }
        }

        if(currentPacket.loot != null && currentPacket.loot.size() > 0)
        {
            builder.setLoot(currentPacket.loot);
        }

        if(builder.wasChanged)
            previousPacket = new DataBuilder(currentPacket);

        return builder;
    }

    public void resetPackets()
    {
        currentPacket = new DataBuilder();
        previousPacket = new DataBuilder();
    }
}

package com.gimptracker;

import io.socket.emitter.Emitter;

public class SocketEventConnect implements Emitter.Listener
{
    private GimpTrackerPlugin plugin;

    SocketEventConnect(GimpTrackerPlugin plugin)
    {
        this.plugin = plugin;
    }

    @Override
    public void call(Object... objects)
    {
        // on client connected
        plugin.getConnectionManager().setConnectionStatus(ConnectionManager.ConnectionStatus.CONNECTED);

        // after we're connected, we will get a callback from the server wether or not we
        // were authorized, and then instantly disconnect us, so wait for this response before
        // we do anything
    }
}

package com.gimptracker;

import net.runelite.api.Item;

public class DataSkill {
    public int id = 0;
    public int experience = 0;

    DataSkill(int id, int experience)
    {
        this.id = id;
        this.experience = experience;
    }

    @Override
    public boolean equals(Object o)
    {
        DataSkill other = (DataSkill)o;
        return other != null && id == other.id && experience == other.experience;
    }
}

package com.gimptracker;

import io.socket.emitter.Emitter;

import java.sql.Connection;

public class SocketEventDisconnect implements Emitter.Listener
{
    private GimpTrackerPlugin plugin;

    SocketEventDisconnect(GimpTrackerPlugin plugin)
    {
        this.plugin = plugin;
    }

    @Override
    public void call(Object... objects)
    {
        // on client disconnect
        if(objects.length > 0)
        {
            String reason = (String)objects[0];
            if(reason.equals("io server disconnect")) // server disconnected the socket force fully which means unauthorized
                plugin.getConnectionManager().setConnectionError(ConnectionManager.ConnectionError.UNAUTHORIZED);
            else if(reason.equals("transport error"))  // server crashed or lost connection to the server
                plugin.getConnectionManager().setConnectionError(ConnectionManager.ConnectionError.LOST_CONNECTION);
        }

        plugin.getConnectionManager().setConnectionStatus(ConnectionManager.ConnectionStatus.DISCONNECTED);
    }
}

