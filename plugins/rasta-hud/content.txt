package RastaXP;

import RHUD.RHUD_Plugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RHUD_Plugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2019, Rheon <https://github.com/Rheon-D>
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.util.EnumMap;
import java.util.Locale;
import java.util.Map;
import javax.inject.Inject;
import RHUD.helpers.OverlayManager;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.MenuEntry;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.game.AlternateSprites;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.plugins.xptracker.XpActionType;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.util.ImageUtil;
import RHUD.helpers.ModeSet;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import net.runelite.client.plugins.xptracker.XpTrackerService;
import net.runelite.client.ui.overlay.components.TitleComponent;
import static RHUD.helpers.VertTrackerPlacement.Tracker_Bottom;
import static RHUD.helpers.VertTrackerPlacement.Tracker_Top;


public class RHUD_Overlay extends OverlayPanel {

    private static final Color ACTIVE_PRAYER_COLOR = new Color(43, 234, 159, 255);
    private static final Color POISONED_COLOR = new Color(0, 145, 0, 255);
    private static final Color VENOMED_COLOR = new Color(0, 65, 0, 255);
    private static final Color HEAL_COLOR = new Color(255, 112, 6, 150);
    private static final Color PRAYER_HEAL_COLOR = new Color(57, 255, 186, 75);
    private static final Color ENERGY_HEAL_COLOR = new Color(199, 118, 0, 218);
    private static final Color RUN_STAMINA_COLOR = new Color(168, 124, 62, 255);
    private static final Color SPECIAL_ACTIVE = new Color(4, 173, 1, 255);
    private static final Color RUN_ACTIVE = new Color(185, 187, 0, 255);
    private static final Color DISEASE_COLOR = new Color(176, 134, 53, 255);
    private static final Color PARASITE_COLOR = new Color(196, 62, 109, 255);
    private static final Color BACKGROUND = new Color(0, 0, 0, 120);
    private static final int BORDER_SIZE = 1;
    private static final int IMAGE_SIZE = 17;
    private static final Dimension ICON_DIMENSIONS = new Dimension(18, 17);
    private static final int MAX_SPECIAL_ATTACK_VALUE = 100;
    private static final int MAX_RUN_ENERGY_VALUE = 100;

    private final Client client;
    private final RHUD_Plugin plugin;
    private final RHUD_Config config;
    private final ItemStatChangesService itemStatService;
    private final SpriteManager spriteManager;

    private final Image prayerIcon;
    private final Image heartDisease;
    private final Image heartPoison;
    private final Image heartVenom;
    private Image heartIcon;
    private Image specialIcon;
    private Image energyIcon;
    private final XpTrackerService xpTrackerService;

    private int currentXP;
    private int currentLevel;
    private int nextLevelXP;
    private final Map<ModeSet, RHUD_StatusRender> modeSet = new EnumMap<>(ModeSet.class);

    private final RHUD.helpers.FontHandler FontHandler = new RHUD.helpers.FontHandler();

    @Inject
    private RHUD_Overlay(Client client, RHUD_Plugin plugin, RHUD_Config config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager, OverlayManager overlayManager, XpTrackerService xpTrackerService) {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.itemStatService = itemstatservice;
        this.spriteManager = spriteManager;
        this.xpTrackerService = xpTrackerService;
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        prayerIcon = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(Skill.PRAYER, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
        heartDisease = ImageUtil.resizeCanvas(ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.DISEASE_HEART), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
        heartPoison = ImageUtil.resizeCanvas(ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.POISON_HEART), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
        heartVenom = ImageUtil.resizeCanvas(ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.VENOM_HEART), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);

        initModes();
    }

    private void initModes() {
        modeSet.put(ModeSet.DISABLED, null);
        modeSet.put(ModeSet.HITPOINTS, new RHUD_StatusRender(
                () -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.HITPOINTS),
                () -> client.getBoostedSkillLevel(Skill.HITPOINTS),
                () -> getRestoreValue(Skill.HITPOINTS.getName()),
                () ->
                {
                    final int poisonState = client.getVarpValue(VarPlayer.POISON);

                    if (poisonState >= 1000000) {
                        return VENOMED_COLOR;
                    }

                    if (poisonState > 0) {
                        return POISONED_COLOR;
                    }

                    if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0) {
                        return DISEASE_COLOR;
                    }

                    if (client.getVarbitValue(Varbits.PARASITE) >= 1) {
                        return PARASITE_COLOR;
                    }

                    return config.colorHealthBar();
                },
                () -> HEAL_COLOR,
                () ->
                {
                    final int poisonState = client.getVarpValue(VarPlayer.POISON);

                    if (poisonState > 0 && poisonState < 50) {
                        return heartPoison;
                    }

                    if (poisonState >= 1000000) {
                        return heartVenom;
                    }

                    if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0) {
                        return heartDisease;
                    }

                    return heartIcon;
                }
        ));
        modeSet.put(ModeSet.PRAYER, new RHUD_StatusRender(
                () -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.PRAYER),
                () -> client.getBoostedSkillLevel(Skill.PRAYER),
                () -> getRestoreValue(Skill.PRAYER.getName()),
                () ->
                {
                    Color prayerColor = config.colorPrayBar();

                    for (Prayer pray : Prayer.values()) {
                        if (client.isPrayerActive(pray)) {
                            prayerColor = ACTIVE_PRAYER_COLOR;
                            break;
                        }
                    }

                    return prayerColor;
                },
                () -> PRAYER_HEAL_COLOR,
                () -> prayerIcon
        ));
        modeSet.put(ModeSet.RUN_ENERGY, new RHUD_StatusRender(
                () -> MAX_RUN_ENERGY_VALUE,
                () -> client.getEnergy() / 100,
                () -> getRestoreValue("Run Energy"),
                () ->
                {
                    if (client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE) != 0) {
                        return RUN_STAMINA_COLOR;
                    } else if (client.getVarpValue(173) == 1) {
                        return RUN_ACTIVE;
                    } else {
                        return config.colorRunBar();
                    }
                },
                () -> ENERGY_HEAL_COLOR,
                () -> energyIcon
        ));
        modeSet.put(ModeSet.SPECIAL_ATTACK, new RHUD_StatusRender(
                () -> MAX_SPECIAL_ATTACK_VALUE,
                () -> client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) / 10,
                () -> 0,
                () ->
                {
                    if (client.getVarpValue(301) == 1) {
                        return SPECIAL_ACTIVE;
                    } else {
                        return config.colorSpecialBar();
                    }
                },
                config::colorSpecialBar,
                () -> specialIcon
        ));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        Dimension dimension = null;
        Widget bankContainer = client.getWidget(WidgetInfo.BANK_ITEM_CONTAINER);
        client.getWidget(WidgetInfo.FIXED_VIEWPORT_INVENTORY_CONTAINER);
        if (bankContainer == null || bankContainer.isHidden()) {
            int width = RHUD_StatusRender.DEFAULT_WIDTH, adjustedX = 0, adjustedY = 0;
            int height = RHUD_StatusRender.DEFAULT_HEIGHT;
            if (config.XPtracker()) {
                if (config.mostRecentSkill()) {
                    renderBar(graphics);
                }
                if (!config.mostRecentSkill()) {
                    renderBarRecent(graphics);
                }
            }
            if (config.enableTip()) {
                renderTrackerOverlay(graphics);
                renderTrackerIcons(config, graphics, width, height, new SkillIconManager());
            }
            if (!config.vertBars() && !config.SidebySide()) {
                dimension = new Dimension(config.barWidth(), width);
            } else if (config.vertBars()) {
                dimension = new Dimension(width, config.barWidth());
            } else {
                dimension = new Dimension(500, width);
            }
            if (!plugin.isBarsDisplayed()) {
                return null;
            }
            FontHandler.updateFont(config.fontName(), config.fontSize(), config.fontStyle());
            FontHandler.handleFont(graphics);

            buildIcons();

            RHUD_StatusRender Bar1 = modeSet.get(config.bar1BarMode());
            RHUD_StatusRender Bar2 = modeSet.get(config.bar2BarMode());
            RHUD_StatusRender Bar3 = modeSet.get(config.bar3BarMode());
            RHUD_StatusRender Bar4 = modeSet.get(config.bar4BarMode());

            if (Bar1 != null) {
                if (config.vertBars()) {
                    Bar1.renderBar(config, graphics, adjustedX + 11, adjustedY, width);
                    dimension = new Dimension(width + 11, config.barWidth());
                } else if (config.SidebySide()) {
                    Bar1.renderBar(config, graphics, adjustedX, adjustedY + 20, width);
                    dimension = new Dimension(500, width + 20);
                } else {
                    Bar1.renderBar(config, graphics, adjustedX, adjustedY + 20, width);
                    dimension = new Dimension(config.barWidth(), width + 20);
                }
            }

            if (Bar2 != null) {
                if (config.vertBars()) {
                    Bar2.renderBar(config, graphics, adjustedX + 31, adjustedY, width);
                    dimension = new Dimension(width + 31, config.barWidth());
                } else if (config.SidebySide()) {
                    Bar2.renderBar(config, graphics, adjustedX + 250, adjustedY + 20, width);
                    dimension = new Dimension(500, width + 20);
                } else {
                    Bar2.renderBar(config, graphics, adjustedX, adjustedY + 40, width);
                    dimension = new Dimension(config.barWidth(), width + 40);
                }
            }

            if (Bar3 != null) {
                if (config.vertBars()) {
                    Bar3.renderBar(config, graphics, adjustedX + 51, adjustedY, width);
                    dimension = new Dimension(width + 51, config.barWidth());
                } else if (config.SidebySide()) {
                    Bar3.renderBar(config, graphics, adjustedX, adjustedY + 40, width);
                    dimension = new Dimension(500, width + 40);
                } else {
                    Bar3.renderBar(config, graphics, adjustedX, adjustedY + 60, width);
                    dimension = new Dimension(config.barWidth(), width + 60);
                }
            }

            if (Bar4 != null) {
                if (config.vertBars()) {
                    Bar4.renderBar(config, graphics, adjustedX + 71, adjustedY, width);
                    dimension = new Dimension(width + 71, config.barWidth());
                } else if (config.SidebySide()) {
                    Bar4.renderBar(config, graphics, adjustedX + 250, adjustedY + 40, width);
                    dimension = new Dimension(500, width + 40);
                } else {
                    Bar4.renderBar(config, graphics, adjustedX, adjustedY + 80, width);
                    dimension = new Dimension(config.barWidth(), width + 80);
                }
            }
        }
        return dimension;
    }


    private int getRestoreValue(String skill) {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0) {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == WidgetInfo.INVENTORY.getId()) {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null) {
                for (final StatChange c : change.calculate(client).getStatChanges()) {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill)) {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    private void buildIcons() {
        if (heartIcon == null) {
            heartIcon = loadAndResize(SpriteID.MINIMAP_ORB_HITPOINTS_ICON);
        }
        if (energyIcon == null) {
            energyIcon = loadAndResize(SpriteID.MINIMAP_ORB_WALK_ICON);
        }
        if (specialIcon == null) {
            specialIcon = loadAndResize(SpriteID.MINIMAP_ORB_SPECIAL_ICON);
        }
    }

    private BufferedImage loadAndResize(int spriteId) {
        BufferedImage image = spriteManager.getSprite(spriteId, 0);
        if (image == null) {
            return null;
        }

        return ImageUtil.resizeCanvas(image, 15, ICON_DIMENSIONS.height);
    }

    private boolean inLms() {
        return client.getWidget(WidgetInfo.LMS_KDA) != null;
    }

    private void renderBar(Graphics2D graphics) {
        //Get info for experience
        Skill skill;
        if (config.mostRecentSkill()) {
            if (plugin.getCurrentSkill() == null) {
                skill = config.skill();
            } else skill = plugin.getCurrentSkill();
            currentXP = client.getSkillExperience(skill);
            currentLevel = Experience.getLevelForXp(currentXP);
            nextLevelXP = Experience.getXpForLevel(currentLevel + 1);
            int currentLevelXP = Experience.getXpForLevel(currentLevel);

            //Calc starting position for bar
            int adjustedY;
            int adjustedWidth;
            adjustedY = 8;

            if (config.SidebySide() && !config.vertBars()) {
                adjustedWidth = 500;
            } else {
                adjustedWidth = config.barWidth();
            }

            final int filledHeight = getBarHeight(nextLevelXP - currentLevelXP, currentXP - currentLevelXP, adjustedWidth);

            //Render the overlay
            Color barColor = config.colorXP();

            Widget bankContainer = client.getWidget(WidgetInfo.BANK_ITEM_CONTAINER);
            if (bankContainer == null || bankContainer.isHidden()) {
                drawBarLarge(graphics, 0, adjustedY, adjustedWidth, filledHeight, barColor, config.colorXPNotches());
            }
        }
    }

    private void drawBarLarge(Graphics graphics, int adjustedX, int adjustedY, int adjustedWidth, int fill, Color barColor, Color notchColor) {

        Skill skill;
        int adjustedHeight;
        if (config.mostRecentSkill()) {
            if (plugin.getCurrentSkill() == null) {
                skill = config.skill();
            } else skill = plugin.getCurrentSkill();
            currentXP = client.getSkillExperience(skill);
        }
        currentLevel = Experience.getLevelForXp(currentXP);
        nextLevelXP = Experience.getXpForLevel(currentLevel + 1);
        int currentLevelXP = Experience.getXpForLevel(currentLevel);
        final int filledWidth = getBarHeight(nextLevelXP - currentLevelXP, currentXP - currentLevelXP, adjustedWidth);
        if (config.SidebySide() && !config.vertBars()) {
            adjustedHeight = 500;
        } else {
            adjustedHeight = config.barWidth();
        }

        graphics.setColor(BACKGROUND);

        if (config.vertBars()) {
            graphics.drawRect(adjustedX, adjustedY - 8, 12 - BORDER_SIZE, adjustedWidth - BORDER_SIZE);
            graphics.fillRect(adjustedX, adjustedY - 8, 12, adjustedWidth);
        } else {
            graphics.drawRect(adjustedX, adjustedY, adjustedWidth - BORDER_SIZE, 12 - BORDER_SIZE);
            graphics.fillRect(adjustedX, adjustedY, adjustedWidth, 12);
        }

        graphics.setColor(barColor);
        if (config.vertBars()) {
            graphics.fillRect(adjustedX + BORDER_SIZE, adjustedY + BORDER_SIZE + (config.barWidth() - filledWidth) - 8, 12 - BORDER_SIZE * 2, filledWidth - BORDER_SIZE * 2);
        } else {
            graphics.fillRect(adjustedX + BORDER_SIZE, adjustedY + BORDER_SIZE, filledWidth - BORDER_SIZE * 2, 12 - BORDER_SIZE * 2);
        }

        graphics.setColor(notchColor);
        if (!config.vertBars()) {
            graphics.fillRect(adjustedX + (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
            graphics.fillRect(adjustedX + 2 * (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
            graphics.fillRect(adjustedX + 3 * (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
            graphics.fillRect(adjustedX + 4 * (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
            graphics.fillRect(adjustedX + 5 * (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
            graphics.fillRect(adjustedX + 6 * (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
            graphics.fillRect(adjustedX + 7 * (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
            graphics.fillRect(adjustedX + 8 * (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
            graphics.fillRect(adjustedX + 9 * (adjustedHeight / 10), adjustedY + 1, 1, 12 - BORDER_SIZE * 2);
        } else {
            graphics.fillRect(adjustedX + 1, adjustedY + (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
            graphics.fillRect(adjustedX + 1, adjustedY + 2 * (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
            graphics.fillRect(adjustedX + 1, adjustedY + 3 * (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
            graphics.fillRect(adjustedX + 1, adjustedY + 4 * (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
            graphics.fillRect(adjustedX + 1, adjustedY + 5 * (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
            graphics.fillRect(adjustedX + 1, adjustedY + 6 * (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
            graphics.fillRect(adjustedX + 1, adjustedY + 7 * (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
            graphics.fillRect(adjustedX + 1, adjustedY + 8 * (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
            graphics.fillRect(adjustedX + 1, adjustedY + 9 * (adjustedHeight / 10) - 8, 12 - BORDER_SIZE * 2, 1);
        }
    }


    private void renderBarRecent(Graphics2D graphics) {
        //Get info for experience
        Skill skill;
        skill = config.skill();
        currentXP = client.getSkillExperience(skill);
        currentLevel = Experience.getLevelForXp(currentXP);
        nextLevelXP = Experience.getXpForLevel(currentLevel + 1);
        int currentLevelXP = Experience.getXpForLevel(currentLevel);

        //Calc starting position for bar
        int adjustedX = 0;
        int adjustedY = 8;
        int adjustedWidth;

        if (config.SidebySide() && !config.vertBars()) {
            adjustedWidth = 500;
        } else {
            adjustedWidth = config.barWidth();
        }

        final int filledWidth = getBarWidth(nextLevelXP - currentLevelXP, currentXP - currentLevelXP, adjustedWidth);

        //Render the overlay
        Color barColor = config.colorXP();
        Widget bankContainer = client.getWidget(WidgetInfo.BANK_ITEM_CONTAINER);
        if (bankContainer == null || bankContainer.isHidden()) {
            drawBarLarge(graphics, adjustedX, adjustedY, adjustedWidth, filledWidth, barColor, config.colorXPNotches());
        }
    }

    private void renderTrackerOverlay(Graphics2D graphics) {
        Skill skill;
        String name;

        if (config.mostRecentSkill() && plugin.getCurrentSkill() == null || !config.mostRecentSkill()) {
                skill = config.skill();
                name = config.skill().getName();
            } else if (config.mostRecentSkill()) {
                skill = plugin.getCurrentSkill();
                name = plugin.getCurrentSkill().getName();
            } else {
            skill = plugin.getCurrentSkill();
            name = plugin.getCurrentSkill().getName();

        }
                currentXP = client.getSkillExperience(skill);
                currentLevel = Experience.getLevelForXp(currentXP);
                nextLevelXP = Experience.getXpForLevel(currentLevel + 1);
                final int counterLevel = client.getBoostedSkillLevel(skill);
                final String counterLevelText = Integer.toString(counterLevel);
                int startXp = xpTrackerService.getStartGoalXp(skill);
                int goalXp = xpTrackerService.getEndGoalXp(skill);
                int xpNeeded = nextLevelXP - currentXP;
                NumberFormat f = NumberFormat.getNumberInstance(Locale.US);
                String skillCurrentXp = f.format(currentXP);

                Color BODY_COLOUR = null;
                Color LEFT_TEXT;

                switch (name) {
                    case "Cooking":
                        BODY_COLOUR = new Color(0x5B266A);
                        break;
                    case "Attack":
                        BODY_COLOUR = new Color(0xC20404);
                        break;
                    case "Strength":
                        BODY_COLOUR = new Color(0x0D704A);
                        break;
                    case "Defence":
                        BODY_COLOUR = new Color(0x687AB8);
                        break;
                    case "Ranged":
                        BODY_COLOUR = new Color(0x5D761D);
                        break;
                    case "Prayer":
                        BODY_COLOUR = new Color(0xFFFFFF);
                        break;
                    case "Magic":
                        BODY_COLOUR = new Color(0x343791);
                        break;
                    case "Runecraft":
                        BODY_COLOUR = new Color(0xD28735);
                        break;
                    case "Construction":
                        BODY_COLOUR = new Color(0xA39782);
                        break;
                    case "Hitpoints":
                        BODY_COLOUR = new Color(0xCFCEC9);
                        break;
                    case "Agility":
                        BODY_COLOUR = new Color(0x2A2C74);
                        break;
                    case "Herblore":
                        BODY_COLOUR = new Color(0x119E3F);
                        break;
                    case "Thieving":
                        BODY_COLOUR = new Color(0x734161);
                        break;
                    case "Crafting":
                        BODY_COLOUR = new Color(0x997140);
                        break;
                    case "Fletching":
                        BODY_COLOUR = new Color(0x094C4D);
                        break;
                    case "Slayer":
                        BODY_COLOUR = new Color(0x5F1109);
                        break;
                    case "Hunter":
                        BODY_COLOUR = new Color(0x6F694B);
                        break;
                    case "Mining":
                        BODY_COLOUR = new Color(0x75BEE1);
                        break;
                    case "Smithing":
                        BODY_COLOUR = new Color(0x86867C);
                        break;
                    case "Fishing":
                        BODY_COLOUR = new Color(0x728FAA);
                        break;
                    case "Woodcutting":
                        BODY_COLOUR = new Color(0x455E37);
                        break;
                    case "Firemaking":
                        BODY_COLOUR = new Color(0xD16F1A);
                        break;
                    case "Farming":
                        BODY_COLOUR = new Color(0x2A5A2A);
                        break;
                }

                LEFT_TEXT = new Color(0xFFDC02);



            FontHandler.updateFont(config.fontName(), 14, config.fontStyle());
            FontHandler.handleFont(graphics);
            panelComponent.setPreferredSize(new Dimension(config.trackerWidth(), 100));
            panelComponent.getChildren().clear();
            if (config.placement() == Tracker_Bottom && config.vertBars()) {
                panelComponent.setPreferredLocation(new Point(0, config.barWidth() + 4));
            } else if (config.placement() == Tracker_Top && config.vertBars()) {
                panelComponent.setPreferredLocation(new Point(0, -140));
            } else if (config.SidebySide()) {
                panelComponent.setPreferredLocation(new Point(504, 8));
            } else {
                panelComponent.setPreferredLocation(new Point(config.barWidth() + 4, 8));
            }
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Xp Tracking")
                    .color(BODY_COLOUR)
                    .build());

            panelComponent.getChildren().add(LineComponent.builder()
                    .left(name)
                    .leftColor(BODY_COLOUR)
                    .right(counterLevelText)
                    .rightColor(Color.GREEN)
                    .build());

            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Current XP:")
                    .leftColor(LEFT_TEXT)
                    .right(skillCurrentXp)
                    .build());

            if (config.xpNeeded()) {
                String skillXpToLevel = f.format(xpNeeded);
                panelComponent.getChildren().add(LineComponent.builder()
                        .left("Exp Needed:")
                        .leftColor(LEFT_TEXT)
                        .right(skillXpToLevel)
                        .build());
            }

            if (goalXp > currentXP) {
                XpActionType xpActionType = xpTrackerService.getActionType(skill);

                if (config.actionsNeeded()) {
                    int actionsLeft = xpTrackerService.getActionsLeft(skill);
                    if (actionsLeft != Integer.MAX_VALUE) {
                        String actionsLeftString = f.format(actionsLeft);
                        panelComponent.getChildren().add(LineComponent.builder()
                                .left(xpActionType.getLabel() + " Needed:")
                                .leftColor(LEFT_TEXT)
                                .right(actionsLeftString)
                                .build());
                    }
                }

                if (config.xpHour()) {
                    int xpHr = xpTrackerService.getXpHr(skill);
                    if (xpHr != 0) {
                        String xpHrString = f.format(xpHr);
                        panelComponent.getChildren().add(LineComponent.builder()
                                .left("Exp Per/h:")
                                .leftColor(LEFT_TEXT)
                                .right(xpHrString)
                                .build());
                    }
                }

                if (config.showTTG()) {
                    String timeLeft = xpTrackerService.getTimeTilGoal(skill);
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left("Time till lvl:")
                            .leftColor(LEFT_TEXT)
                            .right(timeLeft)
                            .build());
                }

                if (config.showPercent()) {
                    String progress = (int) (getSkillProgress(startXp, currentXP, goalXp)) + "%";
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left("Percent:")
                            .leftColor(LEFT_TEXT)
                            .right(progress)
                            .build());
                }
            }
            panelComponent.render(graphics);
        }

    private void renderTrackerIcons(RHUD_Config config, Graphics2D graphics, int width, int height, SkillIconManager skillIconManager) {
        // Icons and counters overlap the bar at small widths, so they are not drawn when the bars are too small

        final boolean skillIconEnabled = config.enableTip();
        Skill currentSkill;
        if (skillIconEnabled) {
            if (!config.mostRecentSkill()) {
                currentSkill = config.skill();
            } else if (plugin.getCurrentSkill() == null) {
                    currentSkill = config.skill();
                } else {
                    currentSkill = plugin.getCurrentSkill();
                }
                    final Image skill = ImageUtil.resizeCanvas(ImageUtil.resizeImage(skillIconManager.getSkillImage(currentSkill, true), IMAGE_SIZE, IMAGE_SIZE), ICON_DIMENSIONS.width, ICON_DIMENSIONS.height);
                    final int xDraw = 5 + (width / 2) - (skill.getWidth(null) / 2);
                    final int yDraw = 5 + (width / 2) - (skill.getWidth(null) / 2) + 504;
                        if (config.placement() == Tracker_Bottom && config.vertBars()) {
                            graphics.drawImage(skill, xDraw, config.barWidth() + 8, null);
                        } else if (config.placement() == Tracker_Top && config.vertBars()) {
                            graphics.drawImage(skill, xDraw, -136, null);
                        } else if (config.SidebySide()) {
                            graphics.drawImage(skill, yDraw , 12, null);
                        } else {
                            graphics.drawImage(skill, config.barWidth() + 10, 12, null);
                        }
                    }
                }



    private double getSkillProgress(int startXp, int currentXp, int goalXp)
    {
        double xpGained = currentXp - startXp;
        double xpGoal = goalXp - startXp;

        return ((xpGained / xpGoal) * 100);
    }


    private static int getBarWidth(int base, int current, int size) {
        final double ratio = (double) current / base;

        if (ratio >= 1) {
            return size;
        }

        return (int) Math.round(ratio * size);
    }

    private static int getBarHeight(int base, int current, int size) {
        final double ratio = (double) current / base;

        if (ratio >= 1) {
            return size;
        }

        return (int) Math.round(ratio * size);
    }
}
/*
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2019, Rheon <https://github.com/Rheon-D>
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD;

import RHUD.helpers.TextComponentWithAlpha;
import lombok.RequiredArgsConstructor;
import net.runelite.client.util.ImageUtil;
import java.awt.*;
import java.util.function.Supplier;

import static RHUD.helpers.BarTextMode.*;


@RequiredArgsConstructor
class RHUD_StatusRender {
    private static final Color BACKGROUND = new Color(30, 30, 30, 150);
    private static final Color OVERHEAL_COLOR = new Color(216, 255, 139, 150);
    private static final int SKILL_ICON_HEIGHT = 24;
    //private static final int COUNTER_ICON_HEIGHT = 7;
    private static final int BORDER_SIZE = 1;
    private static final int MIN_ICON_AND_COUNTER_WIDTH = 16;
    static final int DEFAULT_WIDTH = 20;

    static final int DEFAULT_HEIGHT = 20;
    static final int MIN_WIDTH = 60;
    static final int MAX_WIDTH = 500;
    private final Supplier<Integer> maxValueSupplier;
    private final Supplier<Integer> currentValueSupplier;
    private final Supplier<Integer> healSupplier;
    private final Supplier<Color> colorSupplier;
    private final Supplier<Color> healColorSupplier;
    private final Supplier<Image> iconSupplier;
    private int maxValue;
    private int currentValue;


    private final RHUD.helpers.FontHandler FontHandler = new RHUD.helpers.FontHandler();

    private void refreshSkills() {
        maxValue = maxValueSupplier.get();
        currentValue = currentValueSupplier.get();
    }

    public void renderBar(RHUD_Config config, Graphics2D graphics, int x, int y, int width) {
        final int filledHeight = getBarHeight(maxValue, currentValue, config.barWidth());
        final int filledWidth = getBarHeight(maxValue, currentValue, 250);
        final Color fill = colorSupplier.get();
        refreshSkills();

        //Calc starting position for bar
        int adjustedX;
        int adjustedY;
        adjustedY = y;
        adjustedX = x;

        graphics.setColor(BACKGROUND);
        if (config.vertBars()) {
            graphics.drawRect(adjustedX, adjustedY, width - BORDER_SIZE, config.barWidth() - BORDER_SIZE);
            graphics.fillRect(adjustedX, adjustedY, width, config.barWidth());

        } else if (config.SidebySide()) {
            graphics.drawRect(adjustedX, adjustedY, 250 - BORDER_SIZE, width - BORDER_SIZE);
            graphics.fillRect(adjustedX, adjustedY, 250, width);

        } else {
            graphics.drawRect(adjustedX, adjustedY, config.barWidth() - BORDER_SIZE, width - BORDER_SIZE);
            graphics.fillRect(adjustedX, adjustedY, config.barWidth(), width);
        }

        graphics.setColor(fill);
        if (config.vertBars()) {
            graphics.fillRect(adjustedX + BORDER_SIZE, adjustedY + BORDER_SIZE + (config.barWidth() - filledHeight), width - BORDER_SIZE * 2, filledHeight - BORDER_SIZE * 2);
        } else  if (config.SidebySide()) {
            graphics.fillRect(adjustedX + BORDER_SIZE, adjustedY + BORDER_SIZE, filledWidth - BORDER_SIZE * 2, width - BORDER_SIZE * 2);
        } else {
            graphics.fillRect(adjustedX + BORDER_SIZE, adjustedY + BORDER_SIZE, filledHeight - BORDER_SIZE * 2, width - BORDER_SIZE * 2);
        }

        if (config.enableRestorationBars()) {
            renderRestore(config, graphics, adjustedX, adjustedY, width);
        }

        if (config.enableSkillIcon() || config.enableCounter()) {
            renderIconsAndCounters(config, graphics, adjustedX, adjustedY, width);
        }
    }



    private void renderIconsAndCounters(RHUD.RHUD_Config config, Graphics2D graphics, int x, int y, int width) {
        // Icons and counters overlap the bar at small widths, so they are not drawn when the bars are too small
        if (width < MIN_ICON_AND_COUNTER_WIDTH) {
            return;
        }

        final boolean skillIconEnabled = config.enableSkillIcon();

        if (skillIconEnabled) {
            final Image icon = iconSupplier.get();
            final int xDraw = x + (width / 2) - (icon.getWidth(null) / 2);
            if (config.vertBars()) {
                if (config.textMode() == Icon_top_Text_bottom) {
                    graphics.drawImage(icon, xDraw, y + 4, null);
                } else if (config.textMode() == Both_Bottom) {
                    graphics.drawImage(icon, xDraw, config.barWidth() - 21, null);
                } else if (config.textMode() == Text_top_Icon_bottom) {
                    graphics.drawImage(icon, xDraw, config.barWidth() - 21, null);
                } else if (config.textMode() == Both_Top) {
                    graphics.drawImage(icon, xDraw, y + 4, null);
                }
            } else {
                graphics.drawImage(icon, xDraw, y + 2 , null);
            }
        }

        if (config.enableCounter()) {
            FontHandler.updateFont(config.fontName(), config.fontSize(), config.fontStyle());
            FontHandler.handleFont(graphics);
            final String counterText = Integer.toString(currentValue);
            final int widthOfCounter = graphics.getFontMetrics().stringWidth(counterText);
            final int centerText = (width / 2) - (widthOfCounter / 2);
            final int xOffset = skillIconEnabled ? 36 : 21;
            final int hOffset = skillIconEnabled ? SKILL_ICON_HEIGHT : 8;
            final int yOffset = skillIconEnabled ? config.barWidth() - 27 : config.barWidth() - 10;
            final int eOffset = config.barWidth() - 10;

            final TextComponentWithAlpha textComponent = new TextComponentWithAlpha();
            textComponent.setColor(config.counterColor());
            textComponent.setOutline(true);
            textComponent.setText(counterText);
            if (config.vertBars()) {
                if (config.textMode() == Icon_top_Text_bottom) {
                    textComponent.setPosition(new Point(x + centerText, y + eOffset));
                } else if (config.textMode() == Both_Bottom) {
                    textComponent.setPosition(new Point(x + centerText, y + yOffset));
                } else if (config.textMode() == Text_top_Icon_bottom) {
                    textComponent.setPosition(new Point(x + centerText, y + 17));
                } else if (config.textMode() == Both_Top) {
                    textComponent.setPosition(new Point(x + centerText, y + xOffset));
                }
            } else {
                textComponent.setPosition(new Point(x + hOffset + centerText, y + 15));
            }
            textComponent.render(graphics);
        }
    }

    private void renderRestore(RHUD.RHUD_Config config, Graphics2D graphics, int x, int y, int width) {
        final Color color = healColorSupplier.get();
        final int heal = healSupplier.get();

        if (heal <= 0) {
            return;
        }

        final int filledCurrentHeight = getBarHeight(maxValue, currentValue, config.barWidth());
        final int filledHealHeight = getBarHeight(maxValue, heal, config.barWidth());
        final int filledCurrentWidth = getBarWidth(maxValue, currentValue, config.barWidth());
        final int filledHealWidth = getBarHeight(maxValue, heal, config.barWidth());
        final int filledCurrentLeft = getBarWidth(maxValue, currentValue, 250);
        final int filledHealLeft = getBarHeight(maxValue, heal, 250);
        final int fillY, fillX, fillH, fillHeight, fillWidth, fillLeft;
        graphics.setColor(color);

        if (!config.vertBars() && !config.SidebySide()) {
            if (filledHealWidth + filledCurrentWidth > config.barWidth()) {
                graphics.setColor(OVERHEAL_COLOR);
                fillX = x - BORDER_SIZE + filledCurrentWidth;
                fillWidth = config.barWidth() - filledCurrentWidth - BORDER_SIZE;
            } else {
                fillX = x - BORDER_SIZE + (filledCurrentWidth - filledHealWidth) + filledHealWidth;
                fillWidth = filledHealWidth;
            }
            graphics.fillRect(fillX, y + BORDER_SIZE, fillWidth, width - BORDER_SIZE * 2);
        }

        if (config.SidebySide()) {
            if (filledHealLeft + filledCurrentLeft > 250) {
                graphics.setColor(OVERHEAL_COLOR);
                fillH = x - BORDER_SIZE + filledCurrentLeft;
                fillLeft = 250 - filledCurrentLeft - BORDER_SIZE;
            } else {
                fillH = x - BORDER_SIZE + (filledCurrentLeft - filledHealLeft) + filledHealLeft;
                fillLeft = filledHealLeft;
            }
            graphics.fillRect(fillH, y + BORDER_SIZE, fillLeft, width - BORDER_SIZE * 2);
        }

        if (config.vertBars()) {
            if (filledHealHeight + filledCurrentHeight > config.barWidth()) {
                graphics.setColor(OVERHEAL_COLOR);
                fillY = y + BORDER_SIZE;
                fillHeight = config.barWidth() - filledCurrentHeight + BORDER_SIZE;
            } else {
                fillY = y + BORDER_SIZE + config.barWidth() - (filledCurrentHeight + filledHealHeight * 2) + filledHealHeight;
                fillHeight = filledHealHeight;
            }
            graphics.fillRect(x + BORDER_SIZE, fillY, width - BORDER_SIZE * 2, fillHeight);
        }
    }

    private static int getBarHeight ( int base, int current, int size)
    {
        final double ratio = (double) current / base;

        if (ratio >= 1) {
            return size;
        }

        return (int) Math.round(ratio * size);
    }

    private static int getBarWidth ( int base, int current, int size)
    {
        final double ratio = (double) current / base;

        if (ratio >= 1) {
            return size;
        }

        return (int) Math.round(ratio * size);
    }
}

/*
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD.helpers;

import RHUD.RHUD_Config;
import net.runelite.client.ui.FontManager;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.RenderingHints;

public class FontHandler
{
    private String lastFont = "";
    private int lastFontSize = 0;
    private boolean useRunescapeFont = true;
    private RHUD_Config.FontStyle lastFontStyle = RHUD_Config.FontStyle.DEFAULT;
    private Font font = null;

    public void handleFont(Graphics2D graphics)
    {
        if (font != null)
        {
            graphics.setFont(font);
            if (useRunescapeFont)
            {
                graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
            }
        }
    }

    public void updateFont(String fontName, int fontSize,  RHUD_Config.FontStyle fontStyle)
    {
        if (!lastFont.equals(fontName) || lastFontSize != fontSize || lastFontStyle != fontStyle)
        {
            lastFont = fontName;
            lastFontSize = fontSize;
            lastFontStyle = fontStyle;

            int style = fontStyle.getStyle();
            // default to runescape fonts
            if ("".equals(fontName))
            {

                if (fontSize < 16)
                {
                    font = FontManager.getRunescapeSmallFont();
                }
                if (fontStyle == RHUD_Config.FontStyle.BOLD
                        || fontStyle == RHUD_Config.FontStyle.BOLD_ITALICS)
                {
                    font = RHUD.helpers.OverlayManager.RUNESCAPE_BOLD_FONT;
                    style ^= Font.BOLD; // Bold is implicit for this Font object, we do not want to derive using bold again.
                }
                else
                {
                    font = FontManager.getRunescapeFont();
                }

                font = font.deriveFont(style);

                useRunescapeFont = true;
                return;
            }

            // use a system wide font
            font = new Font(fontName, style,fontSize);
            useRunescapeFont = false;
        }
    }
}
/*
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD.helpers;

import javax.inject.Singleton;

@Singleton
public enum BarTextMode
{
    Text_top_Icon_bottom,
    Icon_top_Text_bottom,
    Both_Bottom,
    Both_Top,
}


/*
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD.helpers;

import javax.inject.Singleton;

@Singleton
public enum ModeSet
{
    DISABLED,
    HITPOINTS,
    PRAYER,
    RUN_ENERGY,
    SPECIAL_ATTACK,
}

/*
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package RHUD.helpers;

import javax.inject.Singleton;

@Singleton
public enum VertTrackerPlacement {
    Tracker_Top,
    Tracker_Bottom,
}

/*
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD.helpers;

import javax.inject.Singleton;
import java.awt.*;


@Singleton
public class OverlayManager
{
    public static final Font RUNESCAPE_BOLD_FONT = OverlayUtilities.initRuneScapeBold();

}

/*
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD.helpers;

import RHUD.RHUD_Overlay;
import lombok.extern.slf4j.Slf4j;
import java.awt.*;
import java.io.IOException;
import java.io.InputStream;

@Slf4j
public class OverlayUtilities {
    // Find and init RuneScape Bold font
    public static Font initRuneScapeBold() {
        Font boldFont;

        try (InputStream inRunescapeBold = RHUD_Overlay.class.getResourceAsStream("RuneScape-Bold-12.ttf")) {
            if (inRunescapeBold == null) {
                log.warn("Font file could not be loaded.");
                boldFont = new Font(Font.DIALOG, Font.BOLD, 16);
            } else {
                boldFont = Font.createFont(Font.TRUETYPE_FONT, inRunescapeBold)
                        .deriveFont(Font.PLAIN, 16);
            }
        } catch (FontFormatException ex) {
            log.warn("Font loaded, but format incorrect.", ex);
            boldFont = new Font(Font.DIALOG, Font.BOLD, 16);
        } catch (IOException ex) {
            log.warn("Font file not found.", ex);
            boldFont = new Font(Font.DIALOG, Font.BOLD, 16);
        }
        return boldFont;
    }
}
/*
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD.helpers;

import lombok.Setter;
import net.runelite.client.ui.overlay.RenderableEntity;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;
import javax.annotation.Nullable;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.regex.Pattern;

// Copy of TextComponent
@Setter
public class TextComponentWithAlpha implements RenderableEntity
{

    public void setOutline(boolean b) {
    }

    public enum Background
    {
        SHADOW,
        OUTLINE
    }

    int alphaOverride = 255;

    private static final String COL_TAG_REGEX = "(<col=([0-9a-fA-F]){2,8}>)";
    private static final Pattern COL_TAG_PATTERN_W_LOOKAHEAD = Pattern.compile("(?=" + COL_TAG_REGEX + ")");

    String text;
    Point position = new Point();
    Color color = Color.WHITE;
    RHUD.helpers.TextComponentWithAlpha.Background background = RHUD.helpers.TextComponentWithAlpha.Background.SHADOW;
    /**
     * The text font.
     */
    @Nullable
    Font font;

    private static int calculateAlpha(String colorString, int _defaultAlpha)
    {
        int alpha = _defaultAlpha;
        if (colorString.length() > 6)
        {
            try
            {
                alpha = Math.min(Integer.decode("#" + colorString.substring(0, 2)), alpha);
            }
            catch (NumberFormatException ignored) { }
        }
        return alpha;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        Font originalFont = null;
        if (font != null)
        {
            originalFont = graphics.getFont();
            graphics.setFont(font);
        }

        final FontMetrics fontMetrics = graphics.getFontMetrics();

        if (COL_TAG_PATTERN_W_LOOKAHEAD.matcher(text).find())
        {
            final String[] parts = COL_TAG_PATTERN_W_LOOKAHEAD.split(text);
            int x = position.x;

            for (String textSplitOnCol : parts)
            {
                final String textWithoutCol = Text.removeTags(textSplitOnCol);
                final String argbString = textSplitOnCol.substring(textSplitOnCol.indexOf("=") + 1, textSplitOnCol.indexOf(">"));
                final String rgbString = argbString.length() > 6 ? argbString.substring(2) : argbString;
                final int alpha = calculateAlpha(argbString, alphaOverride);

                graphics.setColor(ColorUtil.colorWithAlpha(Color.BLACK, alpha));

                switch (background)
                {
                    case OUTLINE :
                    {
                        graphics.drawString(textWithoutCol, x, position.y + 1);
                        graphics.drawString(textWithoutCol, x, position.y - 1);
                        graphics.drawString(textWithoutCol, x + 1, position.y);
                        graphics.drawString(textWithoutCol, x - 1, position.y);
                        break;
                    }
                    case SHADOW:
                    {
                        graphics.drawString(textWithoutCol, x + 1, position.y + 1);
                        break;
                    }
                    default:
                        break;
                }

                 //actual text
                graphics.setColor(ColorUtil.colorWithAlpha(Color.decode("#" + rgbString), alpha));
                graphics.drawString(textWithoutCol, x, position.y);

                x += fontMetrics.stringWidth(textWithoutCol);
            }
        }
        else
        {
            graphics.setColor(ColorUtil.colorWithAlpha(Color.BLACK, alphaOverride));

            switch (background)
            {
                case OUTLINE :
                {
                    graphics.drawString(text, position.x, position.y + 1);
                    graphics.drawString(text, position.x, position.y - 1);
                    graphics.drawString(text, position.x + 1, position.y);
                    graphics.drawString(text, position.x - 1, position.y);
                    break;
                }
                case SHADOW:
                {
                    graphics.drawString(text, position.x + 1, position.y + 1);
                    break;
                }
                default:
                    break;
            }

            // actual text
            graphics.setColor(ColorUtil.colorWithAlpha(color, alphaOverride));
            graphics.drawString(text, position.x, position.y);
        }

        int width = fontMetrics.stringWidth(text);
        int height = fontMetrics.getHeight();

        if (originalFont != null)
        {
            graphics.setFont(originalFont);
        }

        return new Dimension(width, height);
    }
}
/*
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD;

import RHUD.helpers.VertTrackerPlacement;
import net.runelite.api.Skill;
import net.runelite.client.config.*;
import RHUD.helpers.ModeSet;
import RHUD.helpers.BarTextMode;
import lombok.Getter;
import java.awt.*;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
@ConfigGroup(RHUD.RHUD_Config.GROUP)
public interface RHUD_Config extends Config {
	String GROUP = "SB";
	Color COUNTER_COLOR = new Color(255, 255, 255, 255);
	Color EXP_COLOR = new Color(130, 60, 170, 195);
	Color HEALTH_COLOR = new Color(169, 28, 1, 255);
	Color PRAY_COLOR = new Color(38, 157, 157, 255);
	Color RUN_COLOR = new Color(140, 125, 29, 255);
	Color SPECIAL_COLOR = new Color(73, 143, 71, 255);


	enum FontStyle {
		BOLD("Bold", Font.BOLD),
		ITALICS("Italics", Font.ITALIC),
		BOLD_ITALICS("Bold and italics", Font.BOLD | Font.ITALIC),
		DEFAULT("Default", Font.PLAIN);

		String name;
		@Getter
		private int style;

		FontStyle(String name, int style) {
			this.style = style;
			this.name = name;
		}
	}

	@ConfigSection(
			name = "Experience Options",
			description = "Configure the Experience Bar.",
			position = 97
	)
	String expSection = "experience";

	@ConfigSection(
			name = "Status Options",
			description = "Configure the Status Bars.",
			position = 98
	)
	String statusSection = "status";

	@ConfigSection(
			name = "Font and Misc",
			description = "Font options and miscellaneous.",
			position = 99
	)
	String fontSection = "font";

	@ConfigSection(
			name = "Color Options",
			description = "Status bar color config settings.",
			position = 100
	)
	String colorSection = "color";

	@ConfigItem(
			position = 1,
			keyName = "expBar",
			name = "Experience Bar",
			description = "Enables the experience bar.",
			section = expSection
	)
	default boolean XPtracker() { return true; }

	@ConfigItem(
			position = 2,
			keyName = "mostRecentSkill",
			name = "Recent Skill",
			description = "Display the most recent skill trained.",
			section = expSection
	)
	default boolean mostRecentSkill() { return false; }

	@ConfigItem(
			position = 3,
			keyName = "skill",
			name = "Active Skill",
			description = "Choose which skill to track when Recent Skill setting is disabled.",
			section = expSection
	)
	default Skill skill()
	{
		return Skill.ATTACK;
	}

	@Alpha
	@ConfigItem(
			position = 4,
			keyName = "xpbarColor",
			name = "Experience Color",
			description = "Configures the color of the Experience bar",
			section = expSection
	)
	default Color colorXP()
	{
		return EXP_COLOR;
	}

	@Alpha
	@ConfigItem(
			position = 5,
			keyName = "xpbarNotchColor",
			name = "Segment Color",
			description = "Configures the color of the experience segments.",
			section = expSection
	)
	default Color colorXPNotches()
	{
		return new Color(0x6C6C6C);
	}

	@ConfigItem(
			position = 6,
			keyName = "trackerWidth",
			name = "XP Tracker Width",
			description = "The width of the xp tracker.",
			section = expSection
	)
	default int trackerWidth() {
		return 125;
	}

	@ConfigItem(
			position = 7,
			keyName = "enableTip",
			name = "XP Tracker",
			description = "Displays the experience tracker info panel.",
			section = expSection
	)
	default boolean enableTip()
	{
		return false;
	}

	@ConfigItem(
			position = 8,
			keyName = "actionsNeeded",
			name = "Actions Needed",
			description = "Shows the number of actions needed to level-up.",
			section = expSection
	)
	default boolean actionsNeeded()
	{
		return true;
	}

	@ConfigItem(
			position = 9,
			keyName = "xpNeeded",
			name = "Exp Needed",
			description = "Shows the number of xp needed to level-up.",
			section = expSection
	)
	default boolean xpNeeded()
	{
		return true;
	}

	@ConfigItem(
			position = 10,
			keyName = "xpHour",
			name = "Exp/hr",
			description = "Shows Experience per hour.",
			section = expSection
	)
	default boolean xpHour()
	{
		return true;
	}

	@ConfigItem(
			position = 11,
			keyName = "showTTG",
			name = "Time to Level",
			description = "Shows the amount of time until goal lvl reached.",
			section = expSection
	)
	default boolean showTTG()
	{
		return true;
	}

	@ConfigItem(
			position = 12,
			keyName = "showPercent",
			name = "Percent",
			description = "Shows the percentage leveled.",
			section = expSection
	)
	default boolean showPercent()
	{
		return true;
	}

	@ConfigItem(
			position = 13,
			keyName = "placement",
			name = "Position",
			description = "Sets the position of the tracker when in vertical enabled.",
			section = expSection
	)
	default VertTrackerPlacement placement() {
		return VertTrackerPlacement.Tracker_Top;
	}

	@ConfigItem(
			position = 14,
			keyName = "bar1BarMode",
			name = "Bar One",
			description = "Configures the first status bar",
			section = statusSection
	)
	default ModeSet bar1BarMode() {
		return ModeSet.HITPOINTS;
	}

	@ConfigItem(
			position = 15,
			keyName = "bar2BarMode",
			name = "Bar Two",
			description = "Configures the second status bar",
			section = statusSection
	)
	default ModeSet bar2BarMode() {
		return ModeSet.PRAYER;
	}

	@ConfigItem(
			position = 16,
			keyName = "bar3BarMode",
			name = "Bar Three",
			description = "Configures the third status bar",
			section = statusSection
	)
	default ModeSet bar3BarMode() {
		return ModeSet.RUN_ENERGY;
	}


	@ConfigItem(
			position = 17,
			keyName = "bar4BarMode",
			name = "Bar Four",
			description = "Configures the fourth status bar",
			section = statusSection
	)
	default ModeSet bar4BarMode() {
		return ModeSet.SPECIAL_ATTACK;
	}

	@Range(
			min = RHUD_StatusRender.MIN_WIDTH,
			max = RHUD_StatusRender.MAX_WIDTH
	)
	@ConfigItem(
			position = 18,
			keyName = "barWidth",
			name = "Bar Width",
			description = "The width of the status bars in the modern resizeable layout.",
			section = statusSection
	)
	default int barWidth() {
		return 252;
	}

	@ConfigItem(
			position = 19,
			keyName = "vertBars",
			name = "Vertical Bars",
			description = "Displays vertical bars.",
			section = statusSection
	)
	default boolean vertBars() { return false ; }

	@ConfigItem(
			position = 20,
			keyName = "2x2Bars",
			name = "2x2 Bars",
			description = "Displays bars stacked 2 x 2. By request from T...",
			section = statusSection
	)
	default boolean SidebySide() { return false ; }

	@ConfigItem(
			position = 21,
			keyName = "textMode",
			name = "Icon & Text",
			description = "Sets the position of the text and the icon.",
			section = statusSection
	)
	default BarTextMode textMode() {
		return BarTextMode.Both_Bottom;
	}

	@ConfigItem(
			position = 22,
			keyName = "enableText",
			name = "Show Text",
			description = "Show # value on the status bars.",
			section = statusSection
	)
	default boolean enableCounter() {
		return true;
	}

	@ConfigItem(
			position = 23,
			keyName = "enableSkillIcon",
			name = "Show Icons",
			description = "Adds Icon to the status bars.",
			section = statusSection
	)
	default boolean enableSkillIcon() {
		return true;
	}

	@ConfigItem(
			position = 24,
			keyName = "enableRestorationBars",
			name = "Show Restores",
			description = "Highlights status bar with consumable regen amount.",
			section = statusSection
	)
	default boolean enableRestorationBars() {
		return true;
	}

	@ConfigItem(
			position = 25,
			keyName = "fontName",
			name = "Font",
			description = "Name of the font to use for XP drops. Leave blank to use RuneLite setting.",
			section = fontSection
	)
	default String fontName() {
		return "Impact";
	}

	@ConfigItem(
			position = 26,
			keyName = "fontStyle",
			name = "Font style",
			description = "Style of the font to use for XP drops. Only works with custom font.",
			section = fontSection
	)
	default FontStyle fontStyle() {
		return RHUD.RHUD_Config.FontStyle.DEFAULT;
	}

	@ConfigItem(
			position = 27,
			keyName = "fontSize",
			name = "Font size",
			description = "Size of the font to use for XP drops. Only works with custom font.",
			section = fontSection
	)
	default int fontSize()
	{
		return 12;
	}


	@ConfigItem(
			position = 28,
			keyName = "hideAfterCombatDelay",
			name = "Hide after combat delay",
			description = "Amount of ticks before hiding status bars after no longer in combat. 0 = always show status bars.",
			section = fontSection
	)
	@Units(Units.TICKS)
	default int hideAfterCombatDelay() {
		return 0;
	}


	@Alpha
	@ConfigItem(
			position = 29,
			keyName = "counterColor",
			name = "Text Color",
			description = "Configures the color of the counter Text.",
			section = colorSection
	)
	default Color counterColor() {
		return COUNTER_COLOR;
	}

	@Alpha
	@ConfigItem(
			position = 30,
			keyName = "colorHealthBar",
			name = "Health Color",
			description = "Configures the color of the health bar.",
			section = colorSection
	)
	default Color colorHealthBar()
	{
		return (HEALTH_COLOR);
	}

	@Alpha
	@ConfigItem(
			position = 31,
			keyName = "colorPrayBar",
			name = "Pray Color",
			description = "Configures the color of the prayer bar.",
			section = colorSection
	)
	default Color colorPrayBar()
	{
		return (PRAY_COLOR);
	}

	@Alpha
	@ConfigItem(
			position = 32,
			keyName = "colorRunBar",
			name = "Run Color",
			description = "Configures the color of the energy bar.",
			section = colorSection
	)
	default Color colorRunBar()
	{
		return (RUN_COLOR);
	}

	@Alpha
	@ConfigItem(
			position = 33,
			keyName = "colorSpecialBar",
			name = "Special Color",
			description = "Configures the color of the special attack bar.",
			section = colorSection
	)
	default Color colorSpecialBar()
	{
		return (SPECIAL_COLOR);
	}
}

/*
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package RHUD;

import java.awt.image.BufferedImage;
import java.time.Instant;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Skill;

@Getter
@Setter
class RHUD_TrackerHandler
{
    private Skill skill;
    private int currentXp;
    private int currentLevel;
    private Instant time;
    private int size;
    private BufferedImage skillIcon;

    RHUD_TrackerHandler(Skill skill, int currentXp, int currentLevel, Instant time)
    {
        this.skill = skill;
        this.currentXp = currentXp;
        this.currentLevel = currentLevel;
        this.time = time;
    }
}
/*
 * Copyright (c) 2018, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2023, Beardedrasta <Beardedrasta@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package RHUD;

import com.google.inject.Provides;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.itemstats.ItemStatPlugin;
import net.runelite.client.plugins.xptracker.XpTrackerPlugin;
import net.runelite.client.ui.overlay.OverlayManager;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.util.EnumMap;
import java.util.Map;


@PluginDescriptor(
		name = "RHUD",
		description = "Experience and Status bar hud for combat and skilling.",
		tags = {"exp", "xp", "tracker", "status", "bar"}
)
@PluginDependency(XpTrackerPlugin.class)
@PluginDependency(ItemStatPlugin.class)
public class RHUD_Plugin extends Plugin
{
	@Inject
	private RHUD_Overlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Client client;

	@Inject
	private RHUD_Config config;

	@Inject
	private ClientThread clientThread;

	@Getter(AccessLevel.PACKAGE)
	private boolean barsDisplayed;

	@Getter(AccessLevel.PACKAGE)
	public Skill currentSkill;

	private final Map<Skill, Integer> skillList = new EnumMap<>(Skill.class);

	private int lastCombatActionTickCount;

	@Override
	protected void startUp()
	{
		clientThread.invokeLater(this::checkStatusBars);
		overlayManager.add(overlay);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(overlay);
		barsDisplayed = false;
	}

	@Provides
	RHUD_Config provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RHUD_Config.class);
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		checkStatusBars();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (RHUD_Config.GROUP.equals(event.getGroup()) && event.getKey().equals("hideAfterCombatDelay"))
		{
			clientThread.invokeLater(this::checkStatusBars);
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged) {

		Integer lastXP = skillList.put(statChanged.getSkill(), statChanged.getXp());

		if (lastXP != null && lastXP != statChanged.getXp())
		{
			currentSkill = statChanged.getSkill();
		}
	}

	public void checkStatusBars()
	{
		final Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return;
		}

		final Actor interacting = localPlayer.getInteracting();

		if (config.hideAfterCombatDelay() == 0)
		{
			barsDisplayed = true;
		}
		else if ((interacting instanceof NPC && ArrayUtils.contains(((NPC) interacting).getComposition().getActions(), "Attack"))
				|| (interacting instanceof Player && client.getVarbitValue(Varbits.PVP_SPEC_ORB) == 1))
		{
			lastCombatActionTickCount = client.getTickCount();
			barsDisplayed = true;
		}
		else if (client.getTickCount() - lastCombatActionTickCount >= config.hideAfterCombatDelay())
		{
			barsDisplayed = false;
		}
	}
}

