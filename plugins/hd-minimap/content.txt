package io.mark.hdminimap.utils;

import net.runelite.api.IndexedSprite;

import java.awt.image.BufferedImage;

public class ImageUtils {

    public static BufferedImage toBufferedImage(IndexedSprite indexedSprite) {
        int width = indexedSprite.getWidth();
        int height = indexedSprite.getHeight();

        if (width <= 0 || height <= 0) {
            return null;
        }

        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        int[] palette = indexedSprite.getPalette();
        byte[] pixels = indexedSprite.getPixels();

        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                int i = x + y * width;
                int colour = palette[pixels[i] & 0xFF];
                if (colour != 0) {
                    bi.setRGB(x, y, 0xFF000000 | colour);
                }
            }
        }

        return bi;
    }
}

package io.mark.hdminimap;

import io.mark.hdminimap.render.MinimapStyle;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

/**
 * Configuration interface for the HD Minimap plugin
 */
@ConfigGroup(HDMinimapConfig.CONFIG_GROUP)
public interface HDMinimapConfig extends Config {

    String CONFIG_GROUP = "hdminimap";

    @ConfigItem(
            keyName = "minimapStyle",
            name = "Minimap Style",
            description = "Choose the rendering style for the minimap",
            position = 1
    )
    default MinimapStyle minimapStyle() {
        return MinimapStyle.HD;
    }
}
package io.mark.hdminimap.render;

public final class MinimapRenderUtils {

    public static int blend(int baseColor, int blendColor) {
        int saturation = (baseColor & 127) * blendColor >> 7;
        saturation = Math.max(2, saturation);
        saturation = Math.min(126, saturation);
        return (baseColor & 0xFF80) + saturation;
    }
}
package io.mark.hdminimap.render;

import net.runelite.api.Client;
import net.runelite.api.Rasterizer;
import net.runelite.api.Tile;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public abstract class MinimapRenderer {

    protected final int[] tmpScreenX = new int[6];
    protected final int[] tmpScreenY = new int[6];

    @Inject
    protected Client client;

    public abstract void drawMapTile(Tile tile, int tx, int ty, int px0, int py0, int px1, int py1);

    protected void fillGradient(int px0, int py0, int px1, int py1, int c00, int c10, int c01, int c11) {
        Rasterizer g3d = client.getRasterizer();
        g3d.rasterGouraud(py0, py0, py1, px0, px1, px0, c00, c10, c01);
        g3d.rasterGouraud(py0, py1, py1, px1, px0, px1, c10, c01, c11);
    }
}
package io.mark.hdminimap.render.impl;

import io.mark.hdminimap.render.MinimapRenderer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import javax.inject.Singleton;

import static io.mark.hdminimap.render.MinimapRenderUtils.blend;

@Singleton
@Slf4j
public class HDRenderer extends MinimapRenderer {

    private static final int DEFAULT_COLOR = 12345678;

    @Override
    public void drawMapTile(Tile tile, int tx, int ty, int px0, int py0, int px1, int py1) {
        client.getRasterizer().setRasterGouraudLowRes(false);
        if (tile != null) {
            try {
                renderTilePaint(tile, px0, py0, px1, py1);
                renderTileModel(tile, tx, ty, px0, py0, px1, py1);
            } catch (Exception e) {
                client.getRasterizer().setRasterGouraudLowRes(true);
                log.error("Minimap Tile Rendering", e);
            }
        }
    }

    private void renderTilePaint(Tile tile, int px0, int py0, int px1, int py1) {
        SceneTilePaint paint = tile.getSceneTilePaint();
        if (paint == null) {
            return;
        }

        int textureId = paint.getTexture();
        if (textureId == -1) {
            int nw = paint.getNwColor();
            if (nw != DEFAULT_COLOR) {
                fillGradient(px0, py0, px1, py1, nw, paint.getNeColor(), paint.getSwColor(), paint.getSeColor());
            } else {
                client.getRasterizer().fillRectangle(px0, py0, px1 - px0, py1 - py0, paint.getRBG());
            }
        } else {
            int hsl = client.getTextureProvider().getDefaultColor(textureId);
            fillGradient(
                    px0, py0, px1, py1,
                    blend(hsl, paint.getNwColor()),
                    blend(hsl, paint.getNeColor()),
                    blend(hsl, paint.getSwColor()),
                    blend(hsl, paint.getSeColor())
            );
        }
    }

    private void renderTileModel(Tile tile, int tx, int ty, int px0, int py0, int px1, int py1) {
        SceneTileModel model = tile.getSceneTileModel();
        if (model == null) {
            return;
        }

        int[] vertexX = model.getVertexX();
        int[] vertexZ = model.getVertexZ();
        int[] indices1 = model.getFaceX();
        int[] indices2 = model.getFaceY();
        int[] indices3 = model.getFaceZ();
        int[] color1 = model.getTriangleColorA();
        int[] color2 = model.getTriangleColorB();
        int[] color3 = model.getTriangleColorC();
        int[] textures = model.getTriangleTextureId();

        int localX = tx << Perspective.LOCAL_COORD_BITS;
        int localY = ty << Perspective.LOCAL_COORD_BITS;
        int width = px1 - px0;
        int height = py1 - py0;

        for (int vert = 0; vert < vertexX.length; ++vert) {
            tmpScreenX[vert] = px0 + (((vertexX[vert] - localX) * width) >> Perspective.LOCAL_COORD_BITS);
            tmpScreenY[vert] = py0 + (((Perspective.LOCAL_TILE_SIZE - (vertexZ[vert] - localY)) * height) >> Perspective.LOCAL_COORD_BITS);
        }

        for (int face = 0; face < indices1.length; ++face) {
            int idx1 = indices1[face];
            int idx2 = indices2[face];
            int idx3 = indices3[face];

            int c1 = color1[face];
            int c2 = color2[face];
            int c3 = color3[face];

            if (textures != null && textures[face] != -1) {
                int hsl = client.getTextureProvider().getDefaultColor(textures[face]);
                client.getRasterizer().rasterGouraud(
                        tmpScreenY[idx1], tmpScreenY[idx2], tmpScreenY[idx3],
                        tmpScreenX[idx1], tmpScreenX[idx2], tmpScreenX[idx3],
                        blend(hsl, c1), blend(hsl, c2), blend(hsl, c3)
                );
            } else if (c1 != DEFAULT_COLOR) {
                client.getRasterizer().rasterGouraud(
                        tmpScreenY[idx1], tmpScreenY[idx2], tmpScreenY[idx3],
                        tmpScreenX[idx1], tmpScreenX[idx2], tmpScreenX[idx3],
                        c1, c2, c3
                );
            }
        }
    }
}
package io.mark.hdminimap.render;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum MinimapStyle {
    DEFAULT("OSRS"),
    HD("HD");

    private final String displayName;

    @Override
    public String toString() {
        return displayName;
    }
}
package io.mark.hdminimap.ui;

import io.mark.hdminimap.mapelement.MapElementManager;
import io.mark.hdminimap.mapelement.MapElementType;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class MinimapPanel extends PluginPanel {

    @Inject
    private MinimapPanel(MapElementManager mapElementManager, Client client)
    {
        super(false);

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel display = new JPanel();
        MaterialTabGroup tabGroup = new MaterialTabGroup(display);

        MaterialTab mapFunctionTab = new MaterialTab("Map Functions", tabGroup, new MapIconViewer(mapElementManager,client, MapElementType.MAP_FUNCTION));
        MaterialTab mapSceneTab = new MaterialTab("Map Scenes", tabGroup, new MapIconViewer(mapElementManager,client, MapElementType.MAP_ICON));

        tabGroup.setBorder(new EmptyBorder(5, 0, 0, 0));
        tabGroup.addTab(mapFunctionTab);
        tabGroup.addTab(mapSceneTab);
        tabGroup.select(mapFunctionTab);

        add(tabGroup, BorderLayout.NORTH);
        add(display, BorderLayout.CENTER);
    }

}

package io.mark.hdminimap.ui;

import io.mark.hdminimap.HDMinimapPlugin;
import io.mark.hdminimap.mapelement.MapElementEntry;
import io.mark.hdminimap.mapelement.MapElementManager;
import io.mark.hdminimap.mapelement.MapElementType;
import io.mark.hdminimap.utils.ImageUtils;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;

public class MapIconViewer extends JPanel
{

    private final JButton[] buttons;
    private final MapElementType mapElementType;
    private final MapElementManager mapElementManager;

    private static final int BUTTON_SIZE = 27;
    private static final boolean SHOW_SORT_DROPDOWN = false;

    private final JPanel buttonPanel;
    private final JPanel buttonsFlowPanel;
    private final JPanel inlineConfigPanel;
    private final JLabel selectedLabel;
    private final JComboBox<String> scaleComboBox;

    private static final Float[] ALLOWED_SCALES = new Float[]{
            null,
            2.0f, 2.25f, 2.5f, 2.75f,
            3.0f, 3.25f, 3.5f, 3.75f,
            4.0f, 4.25f, 4.5f, 4.75f,
            5.0f, 5.25f, 5.5f,
            6.0f, 6.5f, 6.75f,
            7.75f, 8.0f
    };

    private MapElementEntry currentEntry;

    @Inject
    public MapIconViewer(MapElementManager mapElementManager, Client client, MapElementType mapElementType)
    {

        this.mapElementManager = mapElementManager;
        this.mapElementType = mapElementType;

        int totalButtons = mapElementManager.getEntryCount(mapElementType);
        this.buttons = new JButton[totalButtons];

        setLayout(new BorderLayout(5, 5));
        add(createHeader(), BorderLayout.NORTH);

        buttonPanel = new JPanel(new BorderLayout());
        buttonsFlowPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 6, 6));

        int index = 0;
        for (MapElementEntry entry : mapElementManager.getAll(mapElementType))
        {
            BufferedImage original = null;

            if (mapElementType == MapElementType.MAP_FUNCTION) {
                if (Objects.equals(entry.getCategory(), "Fairy Rings")) {
                    original = ImageUtil.loadImageResource(HDMinimapPlugin.class, "ring.png");
                } else {
                    original = client.getMapElementConfig(entry.getMapId()).getMapIcon(false).toBufferedImage();
                }
            } else {
                int mapId = entry.getMapId();
                if (mapId <= 200) {
                    original = ImageUtils.toBufferedImage(client.getMapScene()[mapId]);
                }
            }

            if (original != null) {
                JButton btn = createButton(entry, original);
                buttonsFlowPanel.add(btn);
                buttons[index++] = btn;
            }
        }

        inlineConfigPanel = new JPanel(new BorderLayout());
        inlineConfigPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        inlineConfigPanel.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));
        inlineConfigPanel.setVisible(false);

        selectedLabel = new JLabel("Selected: None");
        selectedLabel.setForeground(Color.WHITE);
        selectedLabel.setHorizontalAlignment(SwingConstants.CENTER);
        selectedLabel.setBorder(BorderFactory.createEmptyBorder(8, 0, 8, 0));

        JPanel scalePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 6, 0));
        scalePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scalePanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 8, 0));
        scalePanel.add(new JLabel("Scale:"));

        scaleComboBox = new JComboBox<>();
        for (Float f : ALLOWED_SCALES)
        {
            scaleComboBox.addItem(f == null ? "Any" : f.toString());
        }

        scaleComboBox.addActionListener(e -> {
            if (currentEntry != null)
            {
                String selected = (String) scaleComboBox.getSelectedItem();
                Float scale = "Any".equals(selected) ? null : Float.parseFloat(selected);
                mapElementManager.setScale(currentEntry.getCategory(), scale);
            }
        });

        scalePanel.add(scaleComboBox);

        inlineConfigPanel.add(selectedLabel, BorderLayout.NORTH);
        inlineConfigPanel.add(scalePanel, BorderLayout.SOUTH);

        buttonPanel.add(buttonsFlowPanel, BorderLayout.CENTER);
        buttonPanel.add(inlineConfigPanel, BorderLayout.SOUTH);
        add(buttonPanel, BorderLayout.CENTER);
    }

    private JPanel createHeader()
    {
        JPanel headerPanel = new JPanel(new BorderLayout(5, 5));
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        headerPanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 5, 5));

        JPanel toolbar = new JPanel();
        toolbar.setLayout(new BoxLayout(toolbar, BoxLayout.X_AXIS));
        toolbar.setBackground(ColorScheme.DARK_GRAY_COLOR);

        int elementHeight = 28;

        IconTextField searchBar = new IconTextField();
        searchBar.setIcon(IconTextField.Icon.SEARCH);
        searchBar.setPreferredSize(new Dimension(300, elementHeight));  // expanded
        searchBar.setMaximumSize(new Dimension(Integer.MAX_VALUE, elementHeight));
        searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        toolbar.add(searchBar);
        toolbar.add(Box.createRigidArea(new Dimension(5, 0)));

        JComboBox<String> sortDropdown = getStringJComboBox(elementHeight);

        if (SHOW_SORT_DROPDOWN) {
            toolbar.add(sortDropdown);
        }

        searchBar.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
            private void update() {
                filterAndSortButtons(searchBar.getText(), (String) sortDropdown.getSelectedItem());
            }
            public void insertUpdate(javax.swing.event.DocumentEvent e) { update(); }
            public void removeUpdate(javax.swing.event.DocumentEvent e) { update(); }
            public void changedUpdate(javax.swing.event.DocumentEvent e) { update(); }
        });
        searchBar.addClearListener(() -> filterAndSortButtons("", (String) sortDropdown.getSelectedItem()));
        sortDropdown.addActionListener(e -> filterAndSortButtons(searchBar.getText(), (String) sortDropdown.getSelectedItem()));

        headerPanel.add(toolbar, BorderLayout.NORTH);

        if (mapElementType != MapElementType.MAP_ICON) {
            PluginErrorPanel errorPanel = new PluginErrorPanel();
            errorPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
            errorPanel.setContent("Info", "Right-click a map function button to adjust its scale. Function will only be hidde if their current scale is equal to or above the selected value");

            headerPanel.add(errorPanel, BorderLayout.SOUTH);
        }

        return headerPanel;
    }

    private static JComboBox<String> getStringJComboBox(int elementHeight) {
        String[] sortOptions = new String[]{"Alphabetical"};
        JComboBox<String> sortDropdown = new JComboBox<>(sortOptions);

        FontMetrics fm = sortDropdown.getFontMetrics(sortDropdown.getFont());
        int maxWidth = 0;
        for (String item : sortOptions)
        {
            int width = fm.stringWidth(item);
            if (width > maxWidth) maxWidth = width;
        }
        maxWidth += 40; // extra padding for arrow + margin
        sortDropdown.setPreferredSize(new Dimension(maxWidth, elementHeight));
        sortDropdown.setMaximumSize(new Dimension(maxWidth, elementHeight));
        return sortDropdown;
    }

    private void filterAndSortButtons(String query, String sortOption)
    {
        query = query.toLowerCase();

        Map<String, JButton> categoryButtonMap = new HashMap<>();
        List<String> categories = new ArrayList<>(mapElementManager.getAllCategories(mapElementType));
        for (int i = 0; i < buttons.length; i++)
        {
            categoryButtonMap.put(categories.get(i), buttons[i]);
        }

        List<String> filtered = new ArrayList<>();
        for (String cat : categories)
        {
            if (cat.toLowerCase().contains(query))
            {
                filtered.add(cat);
            }
        }

        if ("Alphabetical".equals(sortOption))
        {
            filtered.sort(String::compareToIgnoreCase);
        }

        buttonsFlowPanel.removeAll();
        for (String cat : filtered)
        {
            JButton btn = categoryButtonMap.get(cat);
            buttonsFlowPanel.add(btn);
        }

        buttonPanel.revalidate();
        buttonPanel.repaint();
    }

    private JButton createButton(MapElementEntry entry, BufferedImage image)
    {
        JButton button = new JButton();
        button.setPreferredSize(new Dimension(BUTTON_SIZE, BUTTON_SIZE));
        button.setBorder(BorderFactory.createLineBorder(Color.GRAY));
        button.setFocusPainted(false);
        button.setOpaque(true);
        button.setIcon(new ImageIcon(image));

        button.setToolTipText(entry.getCategory());

        boolean isDisabled = mapElementManager.getSetting(entry.getCategory()).isDisabled();
        button.setBackground(isDisabled ? new Color(255, 0, 0, 120) : ColorScheme.DARKER_GRAY_COLOR);

        button.addActionListener(e -> {
            boolean active = !isActive(button);
            button.setBackground(active ? new Color(255, 0, 0, 120) : ColorScheme.DARKER_GRAY_COLOR);
            boolean newState = !mapElementManager.getSetting(entry.getCategory()).isDisabled();
            mapElementManager.setDisabled(entry.getCategory(), newState);

            hideInlineConfig();
        });

        button.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                if (SwingUtilities.isRightMouseButton(e) && isActive(button))
                {
                    showInlineConfig(entry);
                }
            }
        });

        return button;
    }



    private boolean isActive(JButton button)
    {
        return button.getBackground().equals(new Color(255, 0, 0, 120));
    }

    private void showInlineConfig(MapElementEntry entry)
    {
        if (mapElementType == MapElementType.MAP_ICON) {
            return;
        }
        currentEntry = entry;
        selectedLabel.setText(entry.getCategory() + ": ");

        Float currentScale = mapElementManager.getSetting(entry.getCategory()).getScale();
        if (currentScale == null)
        {
            scaleComboBox.setSelectedIndex(0);
        }
        else
        {
            for (int i = 0; i < ALLOWED_SCALES.length; i++)
            {
                if (ALLOWED_SCALES[i] != null && ALLOWED_SCALES[i].equals(currentScale))
                {
                    scaleComboBox.setSelectedIndex(i);
                    break;
                }
            }
        }

        inlineConfigPanel.setVisible(true);
        revalidate();
        repaint();
    }

    private void hideInlineConfig()
    {
        currentEntry = null;
        selectedLabel.setText("Selected: None");
        inlineConfigPanel.setVisible(false);
        revalidate();
        repaint();
    }
}

package io.mark.hdminimap.mapelement;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class MapElementEntry {
    private String category;
    private int mapId;
    private int categoryID;
}
package io.mark.hdminimap.mapelement;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import io.mark.hdminimap.HDMinimapPlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Tile;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.util.*;

import static net.runelite.api.Constants.EXTENDED_SCENE_SIZE;
import static net.runelite.api.Constants.MAX_Z;

@Slf4j
@Singleton
public class MapElementManager {
    private static final Type LIST_TYPE = new TypeToken<List<MapElementEntry>>() {}.getType();
    public static final String CONFIG_GROUP = "hdminimap-json";

    private final Map<MapElementType, List<MapElementEntry>> typeToEntriesMap = new EnumMap<>(MapElementType.class);
    private final Map<Integer, String> enumMapIconNames = new HashMap<>();

    @Inject
    private Gson gson;
    @Inject
    private Client client;
    @Inject
    private ConfigManager configManager;
    @Inject
    private ClientThread clientThread;

    public void start() {
        for (MapElementType type : MapElementType.values()) {
            typeToEntriesMap.put(type, new ArrayList<>());
        }
        loadMapElements();
    }

    private void loadMapElements() {
        loadMapIconNames();

        for (MapElementType type : MapElementType.values()) {
            List<MapElementEntry> entries = loadEntriesForType(type);
            typeToEntriesMap.put(type, entries);
            log.info("Loaded {} entries for {}", entries.size(), type);
        }

        List<MapElementEntry> mapIcons = new ArrayList<>();
        for (int i = 0; i < client.getMapScene().length; i++) {
            mapIcons.add(new MapElementEntry("Icon" + i, i,-1));
        }
        typeToEntriesMap.put(MapElementType.MAP_ICON, mapIcons);

    }

    private List<MapElementEntry> loadEntriesForType(MapElementType type) {
        String fileName = type.getFileName() + ".json";

        try (InputStream in = HDMinimapPlugin.class.getResourceAsStream(fileName)) {
            if (in == null) {
                log.warn("Missing resource for type {}: {}", type, fileName);
                return Collections.emptyList();
            }

            try (InputStreamReader reader = new InputStreamReader(in)) {
                List<MapElementEntry> entries = gson.fromJson(reader, LIST_TYPE);
                if (entries == null) {
                    return Collections.emptyList();
                }

                if (type == MapElementType.MAP_FUNCTION) {
                    for (MapElementEntry entry : entries) {
                        if (entry.getCategory() == null) {
                            String fallback = enumMapIconNames.get(entry.getCategoryID());
                            if (fallback != null) {
                                entry.setCategory(fallback);
                            }
                        }
                    }
                }

                return entries;
            }
        } catch (Exception e) {
            log.error("Failed to load map elements for {}", type, e);
            return Collections.emptyList();
        }
    }

    private void loadMapIconNames() {
        int[] ids = client.getEnum(1713).getKeys();
        String[] names = client.getEnum(1713).getStringVals();

        for (int i = 0; i < Math.min(ids.length, names.length); i++) {
            String name = names[i];
            if (name != null && !name.isBlank()) {
                enumMapIconNames.put(ids[i], name);
            }
        }
    }

    public void clear() {
        typeToEntriesMap.clear();
    }

    public String getCategoryForMapAreaId(MapElementType type, int objectId) {
        List<MapElementEntry> entries = typeToEntriesMap.getOrDefault(type, Collections.emptyList());
        for (MapElementEntry entry : entries) {
            if (entry.getMapId() == objectId) {
                return entry.getCategory();
            }
        }
        return "unknown";
    }

    public List<MapElementEntry> getAll(MapElementType type) {
        return typeToEntriesMap.getOrDefault(type, Collections.emptyList());
    }

    public Set<String> getAllCategories(MapElementType type) {
        List<MapElementEntry> entries = typeToEntriesMap.getOrDefault(type, Collections.emptyList());
        Set<String> categories = new LinkedHashSet<>();
        for (MapElementEntry entry : entries) {
            categories.add(entry.getCategory());
        }
        return categories;
    }

    public int getEntryCount(MapElementType type) {
        List<MapElementEntry> entries = typeToEntriesMap.getOrDefault(type, Collections.emptyList());
        return entries.size();
    }

    public void updateIcons() {
        currentAreaCategories.clear();
        
        Tile[][][] tiles = client.getTopLevelWorldView().getScene().getExtendedTiles();

        for (int z = 0; z < MAX_Z; z++) {
            for (int x = 0; x < EXTENDED_SCENE_SIZE; x++) {
                for (int y = 0; y < EXTENDED_SCENE_SIZE; y++) {
                    Tile tile = tiles[z][x][y];
                    if (tile == null) {
                        continue;
                    }

                    if (tile.getGroundObject() != null) {
                        int id = tile.getGroundObject().getId();
                        processMapElement(id, MapElementType.MAP_FUNCTION);
                        processMapElement(id, MapElementType.MAP_ICON);
                    }

                    GameObject[] gameObjects = tile.getGameObjects();
                    if (gameObjects != null) {
                        for (GameObject obj : gameObjects) {
                            if (obj != null) {
                                processMapElement(obj.getId(), MapElementType.MAP_ICON);
                            }
                        }
                    }
                }
            }
        }
    }

    private void processMapElement(int objectId, MapElementType type) {
        ObjectComposition def = client.getObjectDefinition(objectId);
        int mapId = (type == MapElementType.MAP_FUNCTION) ? def.getMapIconId() : def.getMapSceneId();

        if (mapId == -1) {
            return;
        }

        String category = getCategoryForMapAreaId(type, mapId);
        currentAreaCategories.add(category);
        
        MapElementSetting setting = getSetting(category);

        boolean matchesZoom = setting.getScale() == null || setting.getScale() >= (float) client.getMinimapZoom();
        boolean shouldHide = setting.isDisabled() && matchesZoom;

        if (!shouldHide) {
            return;
        }

        if (type == MapElementType.MAP_FUNCTION) {
            def.setMapIconId(-1);
        } else if (type == MapElementType.MAP_ICON) {
            def.setMapSceneId(-1);
        }
    }

    public MapElementSetting getSetting(String category) {
        String json = configManager.getConfiguration(CONFIG_GROUP, category);
        if (json == null) {
            return MapElementSetting.defaults();
        }

        MapElementSetting setting = gson.fromJson(json, MapElementSetting.class);
        return setting != null ? setting : MapElementSetting.defaults();
    }

    public void saveSetting(String category, MapElementSetting setting) {
        configManager.setConfiguration(CONFIG_GROUP, category, gson.toJson(setting));
    }

    public void setDisabled(String category, boolean disabled) {
        MapElementSetting current = getSetting(category);
        saveSetting(category, new MapElementSetting(disabled, current.getScale()));
    }

    public void setScale(String category, Float scale) {
        MapElementSetting current = getSetting(category);
        saveSetting(category, new MapElementSetting(current.isDisabled(), scale));
    }

    public final Set<String> currentAreaCategories = new HashSet<>();

    public Set<String> getCurrentAreaCategories() {
        return new HashSet<>(currentAreaCategories);
    }

    public boolean isCategoryInCurrentArea(String category) {
        return currentAreaCategories.contains(category);
    }

}

/*
 * Copyright (c) 2025, Mark
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.mark.hdminimap.mapelement;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Enum representing different types of map elements that can be managed
 */
@Getter
@RequiredArgsConstructor
public enum MapElementType {
    MAP_FUNCTION("map function", "mapfunctions","mapFunctions"),
    MAP_ICON("map icon", "mapicons","mapIcons");

    private final String displayName;
    private final String configPrefix;
    private final String fileName;
}
package io.mark.hdminimap.mapelement;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class MapElementSetting {
    private boolean disabled;
    private Float scale;

    public static MapElementSetting defaults() {
        return new MapElementSetting(false, null);
    }
}



/*
 * Copyright (c) 2022, Abex
 * Copyright (c) 2022, Mark
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.mark.hdminimap;

import com.google.inject.Provides;
import io.mark.hdminimap.mapelement.MapElementManager;
import io.mark.hdminimap.mapelement.MapElementSetting;
import io.mark.hdminimap.mapelement.MapElementType;
import io.mark.hdminimap.render.MinimapStyle;
import io.mark.hdminimap.render.impl.HDRenderer;
import io.mark.hdminimap.ui.MinimapPanel;
import lombok.AccessLevel;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.worldmap.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.Objects;

@PluginDescriptor(
	name = "HD Minimap",
	description = "Adds a HD Minimap from 2008!",
	tags = {"hd", "minimap"}
)

@Slf4j
public class HDMinimapPlugin extends Plugin {

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private HDRenderer hdRenderer;

    @Inject
    private HDMinimapConfig config;

    @Inject
    private MapElementManager mapElementManager;

    private MinimapStyle currentStyle;

    @Setter(AccessLevel.PACKAGE)
    private MinimapPanel panel;

    private NavigationButton button;

    @Inject
    private ClientToolbar clientToolbar;

    private Double lastZoom = null;


    @Provides
    HDMinimapConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(HDMinimapConfig.class);
    }

    @Override
	protected void startUp() {
        clientThread.invoke((() -> {
            mapElementManager.start();
            panel = injector.getInstance(MinimapPanel.class);

            final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");

            button = NavigationButton.builder()
                    .tooltip("Enhanced Minimap")
                    .icon(icon)
                    .priority(3)
                    .panel(panel)
                    .build();

            clientToolbar.addNavigation(button);
        }));

        currentStyle = config.minimapStyle();
        setMinimapDrawer();
        reloadGame();
        lastZoom = client.getMinimapZoom();
	}


	@Inject
	private PluginManager pluginManager;

	@Override
	public void shutDown() {
        clientToolbar.removeNavigation(button);
        client.setMinimapTileDrawer(null);
        client.getObjectCompositionCache().reset();
        reloadGame();
        mapElementManager.clear();
	}

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (event.getGroup().equals(HDMinimapConfig.CONFIG_GROUP)) {
            if (Objects.equals(event.getKey(), "minimapStyle")) {
                currentStyle = config.minimapStyle();
                setMinimapDrawer();
                log.debug("Minimap style changed to: {}", currentStyle);
            }
        }
        if (event.getGroup().equals(MapElementManager.CONFIG_GROUP)) {
            if (mapElementManager.isCategoryInCurrentArea(event.getKey())) {
                client.getObjectCompositionCache().reset();
                reloadGame();
            }
        }
    }

    public void setMinimapDrawer() {
        if (currentStyle != MinimapStyle.DEFAULT) {
            client.setMinimapTileDrawer(this::drawMapTile);
        } else {
            client.setMinimapTileDrawer(null);
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        double zoom = client.getMinimapZoom();
        if (lastZoom != zoom) {
            lastZoom = zoom;

            for (String category : mapElementManager.getCurrentAreaCategories()) {
                MapElementSetting setting = mapElementManager.getSetting(category);
                if (setting.isDisabled() && setting.getScale() != null) {
                    client.getObjectCompositionCache().reset();
                    reloadGame();
                    return;
                }
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged stateChanged) {
        if (stateChanged.getGameState() == GameState.LOGGED_IN) {
            mapElementManager.updateIcons();
        }
    }

    /**
     * Refreshes the game state if needed when switching to HD117 minimap style
     */
    private void reloadGame() {
        clientThread.invoke(() -> {
            if (client.getGameState() == GameState.LOGGED_IN) {
                client.setGameState(GameState.LOADING);
                if (client.getWorldMap().getWorldMapRenderer().isLoaded()) {
                    client.getWorldMap().initializeWorldMap(client.getWorldMap().getWorldMapData());
                }
            }
        });
    }

    /**
     * Draws a minimap tile using the currently selected renderer
     *
     * @param tile the tile to draw
     * @param tx   tile x coordinate
     * @param ty   tile y coordinate
     * @param px0  pixel x start coordinate
     * @param py0  pixel y start coordinate
     * @param px1  pixel x end coordinate
     * @param py1  pixel y end coordinate
     */
    public void drawMapTile(Tile tile, int tx, int ty, int px0, int py0, int px1, int py1) {
        hdRenderer.drawMapTile(tile, tx, ty, px0, py0, px1, py1);
    }

}

package io.mark.hdminimap;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.externalplugins.ExternalPluginManager;

import java.io.InputStream;
import java.util.Properties;

@Slf4j
public class HDMinimapPluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		useLatestPluginHub();
		ExternalPluginManager.loadBuiltin(HDMinimapPlugin.class);
		RuneLite.main(args);
	}

	private static void useLatestPluginHub()
	{
		if (System.getProperty("runelite.pluginhub.version") == null)
		{
			try
			{
				Properties props = new Properties();
				try (InputStream in = RuneLiteProperties.class.getResourceAsStream("runelite.properties"))
				{
					props.load(in);
				}

				String version = props.getProperty("runelite.pluginhub.version");
				String[] parts = version.split("[.-]");
				if (parts.length > 3 && parts[3].equals("SNAPSHOT"))
				{
					int patch = Integer.parseInt(parts[2]) - 1;
					version = parts[0] + "." + parts[1] + "." + patch;
					log.info("Detected SNAPSHOT version with no manually specified plugin-hub version. " +
							"Setting runelite.pluginhub.version to {}", version);
					System.setProperty("runelite.pluginhub.version", version);
				}
			}
			catch (Exception ex)
			{
				log.error("Failed to automatically use latest plugin-hub version", ex);
			}
		}
	}

}
