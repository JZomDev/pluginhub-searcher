package com.onetickflick;

import javax.inject.Inject;
import java.awt.*;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;

public class OneTickFlickOverlay extends Overlay
{
	private static final int MIN_BAR_HEIGHT = 12;
	private static final int TEXT_SPACE = 20;
	private static final int X_SIZE = 4;
	private static final int TICK_LENGTH = 600;
	private static final Dimension MIN_SIZE = new Dimension(50, MIN_BAR_HEIGHT + TEXT_SPACE);
	private static final Dimension DEFAULT_SIZE = new Dimension(150, MIN_BAR_HEIGHT + TEXT_SPACE);

	private final OneTickFlickPlugin plugin;
	private final OneTickFlickConfig config;
	private final List<Integer> clickOffsets = new CopyOnWriteArrayList<>();
	private volatile boolean visible = true;

	@Inject
	OneTickFlickOverlay(OneTickFlickPlugin plugin, OneTickFlickConfig config)
	{
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.BOTTOM_LEFT);
		setPreferredSize(DEFAULT_SIZE);
		setResizable(true);
	}

	void recordClick(int offset)
	{
		clickOffsets.add(offset);
	}

	void newTick()
	{
		clickOffsets.clear();
	}

	void setVisible(boolean v)
	{
		visible = v;
	}

	boolean isVisible()
	{
		return visible;
	}

	@Override
	public Dimension render(Graphics2D g)
	{
		if (!visible)
		{
			return null;
		}

		Rectangle bounds = getBounds();
		Dimension size = getPreferredSize() == null ? DEFAULT_SIZE : getPreferredSize();

		int width = size.width;
		int height = size.height;
		if (bounds != null && bounds.width > 0 && bounds.height > 0)
		{
			width = Math.max(bounds.width, MIN_SIZE.width);
			height = Math.max(bounds.height, MIN_SIZE.height);
		}

		int barHeight = Math.max(MIN_BAR_HEIGHT, height - TEXT_SPACE);

		g.setColor(Color.RED);
		g.fillRect(0, 0, width, barHeight);

		int greenX1 = width * config.greenStart() / TICK_LENGTH;
		int greenX2 = width * config.greenEnd() / TICK_LENGTH;

		g.setColor(Color.GREEN);
		g.fillRect(greenX1, 0, greenX2 - greenX1, barHeight);

		long ms = plugin.millisSinceTick();
		int barX = (int) (width * ms / (double) TICK_LENGTH);

		g.setColor(Color.BLACK);
		g.drawLine(barX, 0, barX, barHeight);

		g.drawRect(0, 0, width, barHeight);

		int y1 = barHeight / 2 - X_SIZE;
		int y2 = barHeight / 2 + X_SIZE;
		for (int offset : clickOffsets)
		{
			int x = width * offset / TICK_LENGTH;
			g.drawLine(x - X_SIZE, y1, x + X_SIZE, y2);
			g.drawLine(x - X_SIZE, y2, x + X_SIZE, y1);
		}

		if (config.showCombo())
		{
			g.setColor(Color.WHITE);
			String text = "Combo: " + plugin.getCombo();
			int tx = (width - g.getFontMetrics().stringWidth(text)) / 2;
			int ty = barHeight + g.getFontMetrics().getAscent() + 2;
			g.drawString(text, tx, ty);
		}

		return new Dimension(width, height);
	}
}

package com.onetickflick;

import net.runelite.client.config.*;

@ConfigGroup("onetickflick")
public interface OneTickFlickConfig extends Config
{
	@Units(Units.MILLISECONDS)
	@ConfigItem(
			keyName = "greenStart",
			name = "Green start",
			description = "How long into the tick the green bar starts. Used as a visual aid and to determine the combo counter.",
			position = 0
	)
	@Range(min = 0, max = 600)
	default int greenStart()
	{
		return 100;
	}

	@Units(Units.MILLISECONDS)
	@ConfigItem(
			keyName = "greenEnd",
			name = "Green end",
			description = "How long into the tick the green bar ends. Used as a visual aid and to determine the combo counter.",
			position = 1
	)
	@Range(min = 0, max = 600)
	default int greenEnd()
	{
		return 500;
	}

	@ConfigItem(
			keyName = "showCombo",
			name = "Show combo counter",
			position = 2,
			description = "Whether to show the combo counter in the overlay. Combo counter is the number of consecutive double clicks within the green bar.")
	default boolean showCombo()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableTimeout",
			name = "Enable overlay timeout",
			position = 3,
			description = "Whether the overlay should automatically hide after a period without clicking the quick prayer orb.")
	default boolean enableTimeout()
	{
		return false;
	}

	@Units(Units.SECONDS)
	@ConfigItem(
			keyName = "overlayTimeoutSeconds",
			name = "Overlay timeout",
			position = 4,
			description = "How long after last clicking the quick prayer orb the overlay should remain visible")
	@Range(min = 1, max = 600)
	default int overlayTimeoutSeconds()
	{
		return 30;
	}

	@Units(Units.MILLISECONDS)
	@ConfigItem(
			keyName = "clickDelayMilliseconds",
			name = "Click delay - latency",
			position = 5,
			description = "Add a delay to your clicks to account for latency (ping).")
	@Range(min = 0, max = 500)
	default int clickDelayMilliseconds()
	{
		return 0;
	}
}

package com.onetickflick;

import com.google.inject.Provides;

import javax.inject.Inject;

import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.MenuAction;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

@PluginDescriptor(
		name = "1 Tick Flick",
		description = "Visual tick bar and combo counter for 1-tick prayer flicking with the quick prayer orb",
		tags = {"1", "one", "tick", "flick", "prayer", "metronome", "visual", "quick", "orb"}
)
public class OneTickFlickPlugin extends Plugin
{
	private static final int TICK_LENGTH = 600;

	@Inject
	private OverlayManager overlayManager;
	@Inject
	private OneTickFlickOverlay overlay;
	@Inject
	private OneTickFlickConfig config;

	private long lastTickTime;
	private long lastInteraction;
	private final List<Integer> currentTickClicks = new CopyOnWriteArrayList<>(); // A list of times the quick prayer orb was clicked, in milliseconds since the last onGameTick.
	private final List<Integer> nextTickClicks = new CopyOnWriteArrayList<>(); // Only used if the click delay config option causes the click to fall into the next tick.

	@Getter(AccessLevel.PACKAGE)
	private int combo;

	@Override
	protected void startUp()
	{
		lastTickTime = System.currentTimeMillis();
		lastInteraction = lastTickTime;
		combo = 0;

		overlay.setVisible(true);
		overlayManager.add(overlay);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(overlay);
		currentTickClicks.clear();
		nextTickClicks.clear();
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		if (currentTickClicks.size() == 2 && currentTickClicks.stream().allMatch(this::inGreenZone))
		{
			combo++;
		}
		else
		{
			combo = 0;
		}

		currentTickClicks.clear();
		overlay.newTick();
		lastTickTime = System.currentTimeMillis();

		if (!nextTickClicks.isEmpty())
		{
			for (Integer offset : nextTickClicks)
			{
				currentTickClicks.add(offset);
				overlay.recordClick(offset);
			}
			nextTickClicks.clear();
		}

		if (config.enableTimeout() && overlay.isVisible())
		{
			long elapsed = System.currentTimeMillis() - lastInteraction;
			if (elapsed > config.overlayTimeoutSeconds() * 1000L)
			{
				overlay.setVisible(false);
			}
		}
		else if (!config.enableTimeout() && !overlay.isVisible())
		{
			overlay.setVisible(true);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked e)
	{
		Widget widget = e.getWidget();
		if (widget == null || widget.getId() != InterfaceID.Orbs.PRAYERBUTTON)
		{
			return;
		}

		if (e.getMenuAction() != MenuAction.CC_OP && e.getMenuAction() != MenuAction.CC_OP_LOW_PRIORITY)
		{
			return;
		}

		int offset = (int) (System.currentTimeMillis() - lastTickTime);
		offset += config.clickDelayMilliseconds();

		if (offset >= TICK_LENGTH)
		{
			// If the click is past the current tick, we add it for the next tick instead. It will be added to the overlay on the next onGameTick.
			nextTickClicks.add(offset - TICK_LENGTH);
		}
		else
		{
			currentTickClicks.add(offset);
			overlay.recordClick(offset);
		}

		lastInteraction = System.currentTimeMillis();
		if (!overlay.isVisible())
		{
			// No matter what the overlay timeout options are, we want to show the overlay when the player clicks the quick prayer orb
			overlay.setVisible(true);
		}
	}

	/**
	 * Returns the number of milliseconds since the last tick.
	 */
	long millisSinceTick()
	{
		return System.currentTimeMillis() - lastTickTime;
	}

	/**
	 * Checks if the given milliseconds are within the green zone defined by the config.
	 *
	 * @param ms
	 * @return
	 */
	private boolean inGreenZone(int ms)
	{
		return ms >= config.greenStart() && ms <= config.greenEnd();
	}

	@Provides
	OneTickFlickConfig provideConfig(ConfigManager cm)
	{
		return cm.getConfig(OneTickFlickConfig.class);
	}
}

package com.onetickflick;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class OneTickFlickPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(OneTickFlickPlugin.class);
		RuneLite.main(args);
	}
}
