package com.wildyqol.ikodparchmentrisk;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.util.Text;
import com.wildyqol.WildyQoLConfig;

@Singleton
public class IkodParchmentRiskOverlay extends Overlay
{
    private static final int BASELINE_MARGIN = 4;
    private static final int LINE_SPACING = 4;

    private final Client client;
    private final WildyQoLConfig config;

    private boolean ikodOpen;
    private long surcharge;
    private long baseRisk;
    private Color labelColor = Color.WHITE;

    @Inject
    private IkodParchmentRiskOverlay(Client client, WildyQoLConfig config)
    {
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    public void update(boolean ikodOpen, int lockedCount, long perItemCost, long surcharge, long baseRisk, Color labelColor)
    {
        this.ikodOpen = ikodOpen;
        this.surcharge = surcharge;
        this.baseRisk = baseRisk;
        this.labelColor = labelColor != null ? labelColor : Color.WHITE;
    }

    public void reset()
    {
        update(false, 0, 0L, 0L, 0L, Color.WHITE);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.showIkodTrouverOverlay() || !ikodOpen)
        {
            return null;
        }

        Widget riskWidget = client.getWidget(InterfaceID.Deathkeep.VALUE);
        if (riskWidget == null || riskWidget.isHidden())
        {
            return null;
        }

        Rectangle bounds = riskWidget.getBounds();
        Widget messageWidget = client.getWidget(InterfaceID.Deathkeep.TOPAREA);
        Rectangle messageBounds = messageWidget != null ? messageWidget.getBounds() : null;
        boolean condensed = hasAdditionalMessage(messageWidget);

        if (bounds == null)
        {
            return null;
        }

        Font font = FontManager.getRunescapeSmallFont();
        graphics.setFont(font);

        String surchargeText = QuantityFormatter.formatNumber(surcharge);
        long totalRisk = baseRisk + surcharge;
        String totalRiskText = QuantityFormatter.formatNumber(totalRisk);

        String[] lines = condensed
            ? new String[] { "Total risk:", totalRiskText }
            : new String[] { "Trouver cost:", surchargeText, "Total risk:", totalRiskText };

        Color[] colors = condensed
            ? new Color[] { labelColor, Color.WHITE }
            : new Color[] { labelColor, Color.WHITE, labelColor, Color.WHITE };

        int centerX = bounds.x + bounds.width / 2;
        int lineHeight = graphics.getFontMetrics().getHeight();
        int spacing = condensed ? 1 : LINE_SPACING;
        int step = lineHeight + spacing;
        int bottomY = bounds.y - BASELINE_MARGIN;

        if (condensed && messageBounds != null)
        {
            int requiredBottom = messageBounds.y + messageBounds.height + BASELINE_MARGIN + (lines.length - 1) * step;
            bottomY = Math.max(bottomY, requiredBottom);
            bottomY += 4;
        }

        int y = bottomY;

        for (int i = lines.length - 1; i >= 0; i--)
        {
            String line = lines[i];
            int textWidth = graphics.getFontMetrics().stringWidth(line);
            int textX = centerX - textWidth / 2;
            int textY = y;
            if (condensed)
            {
                if (i == 0)
                {
                    textY += 5;
                }
                else
                {
                    textY += 2;
                }
            }
            Point location = new Point(textX, textY);
            OverlayUtil.renderTextLocation(graphics, location, lines[i], colors[i]);
            y -= step;
        }

        return null;
    }

    private boolean hasAdditionalMessage(Widget messageWidget)
    {
        if (messageWidget == null)
        {
            return false;
        }

        StringBuilder textBuilder = new StringBuilder();
        appendWidgetText(textBuilder, messageWidget);

        Widget[] dynamicChildren = messageWidget.getDynamicChildren();
        if (dynamicChildren != null)
        {
            for (Widget child : dynamicChildren)
            {
                appendWidgetText(textBuilder, child);
            }
        }

        if (textBuilder.length() == 0)
        {
            return false;
        }

        String sanitized = Text.removeTags(textBuilder.toString()).toLowerCase();
        return sanitized.contains("player-owned house")
            || sanitized.contains("gravestone")
            || sanitized.contains("safe area");
    }

    private void appendWidgetText(StringBuilder builder, Widget widget)
    {
        if (widget == null)
        {
            return;
        }

        String text = widget.getText();
        if (text == null || text.isEmpty())
        {
            return;
        }

        if (builder.length() > 0)
        {
            builder.append('\n');
        }

        builder.append(text);
    }
}

package com.wildyqol;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("wildyqol")
public interface WildyQoLConfig extends Config
{
	@ConfigSection(
		name = "Misclick prevention",
		description = "Settings to help avoid dangerous misclicks",
		position = 0,
		closedByDefault = false
	)
	String MISCLICK_PREVENTION_SECTION = "misclickPreventionSection";

	@ConfigSection(
		name = "Items Kept on Death",
		description = "Settings for the Items Kept on Death widget",
		position = 1,
		closedByDefault = false
	)
	String ITEMS_KEPT_ON_DEATH_SECTION = "itemsKeptOnDeathSection";

	@ConfigSection(
		name = "Menaphite proc timer",
		description = "Settings for tracking the next menaphite remedy proc",
		position = 2,
		closedByDefault = false
	)
	String MENAPHITE_PROC_TIMER_SECTION = "menaphiteProcTimerSection";

	@ConfigSection(
		name = "Freeze timers",
		description = "Extended freeze timer settings",
		position = 3,
		closedByDefault = false
	)
	String FREEZE_TIMERS_SECTION = "freezeTimersSection";

	@ConfigSection(
		name = "Misc",
		description = "Miscellaneous settings",
		position = 4,
		closedByDefault = false
	)
	String MISC_SECTION = "miscSection";

	@ConfigItem(
		keyName = "runePouchBlocker",
		name = "Rune Pouch Blocker",
		description = "Block left-click on rune pouches (PvP areas only)",
		position = 0,
		section = MISCLICK_PREVENTION_SECTION
	)
	default boolean runePouchBlocker()
	{
		return true;
	}

	@ConfigItem(
		keyName = "petSpellBlocker",
		name = "Pet Spell Blocker",
		description = "Removes spell-cast menu entries on pets and suppresses pet examine while a spell is selected",
		position = 1,
		section = MISCLICK_PREVENTION_SECTION
	)
	default boolean petSpellBlocker()
	{
		return true;
	}

	@ConfigItem(
		keyName = "emptyVialBlocker",
		name = "Empty Vial Blocker",
		description = "Prevents left-clicking 'Use' on empty vials",
		position = 2,
		section = MISCLICK_PREVENTION_SECTION
	)
	default boolean emptyVialBlocker()
	{
		return false;
	}

	@ConfigItem(
		keyName = "marlinEqualsAnglerfish",
		name = "Marlin = Anglerfish",
		description = "Replace marlin inventory icon with anglerfish (PvP areas only)",
		position = 3,
		section = MISCLICK_PREVENTION_SECTION
	)
	default boolean marlinEqualsAnglerfish()
	{
		return false;
	}

	@ConfigItem(
		keyName = "halibutEqualsKarambwan",
		name = "Halibut = Karambwan",
		description = "Replace halibut inventory icon with karambwan (PvP areas only)",
		position = 4,
		section = MISCLICK_PREVENTION_SECTION
	)
	default boolean halibutEqualsKarambwan()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showIkodTrouverOverlay",
		name = "Trouver Cost Overlay",
		description = "Show Trouver parchment cost + 500k gp in the Items Kept on Death interface",
		position = 0,
		section = ITEMS_KEPT_ON_DEATH_SECTION
	)
	default boolean showIkodTrouverOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "updateMessageShown130",
		name = "Update Message Shown v1.3.0",
		description = "Internal flag to track if the v1.3.0 update message has been shown",
		hidden = true,
        position = 3
	)
	default boolean updateMessageShown130()
	{
		return false;
	}

	@ConfigItem(
		keyName = "menaphiteProcTimerDisplayTicks",
		name = "Show in ticks",
		description = "Display the menaphite proc countdown using game ticks instead of seconds",
		position = 1,
		section = MENAPHITE_PROC_TIMER_SECTION
	)
	default boolean menaphiteProcTimerDisplayTicks()
	{
		return false;
	}

	enum MenaphiteProcStatusBarMode
	{
		OFF,
		LEFT,
		RIGHT
	}

	@ConfigItem(
		keyName = "menaphiteProcTimerShowInfoBox",
		name = "Show infobox",
		description = "Display the menaphite proc timer as an info box",
		position = 0,
		section = MENAPHITE_PROC_TIMER_SECTION
	)
	default boolean menaphiteProcTimerShowInfoBox()
	{
		return true;
	}

	@ConfigItem(
		keyName = "menaphiteProcTimerStatusBarMode",
		name = "Status bar position",
		description = "Display the menaphite proc timer as a status bar next to the inventory",
		position = 2,
		section = MENAPHITE_PROC_TIMER_SECTION
	)
	default MenaphiteProcStatusBarMode menaphiteProcTimerStatusBarMode()
	{
		return MenaphiteProcStatusBarMode.OFF;
	}

	@ConfigItem(
		keyName = "protectItemInfoBox",
		name = "Protect Item Infobox",
		description = "Show an infobox when in PvP area and Protect Item is not active",
		section = MISC_SECTION
	)
	default boolean protectItemInfoBox()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableExtendedFreezeTimersV2",
		name = "Extended freeze timers",
		description = "Use extended freeze timers that account for opponent gear (Ancient sceptres and Swampbark)",
		position = 0,
		section = FREEZE_TIMERS_SECTION
	)
	default boolean enableExtendedFreezeTimers()
	{
		return true;
	}

	@ConfigItem(
		keyName = "warnDuplicateFreezeTimers",
		name = "Warn about duplicates",
		description = "Warn in chat if the core Timers & Buffs freeze timer stays enabled",
		position = 1,
		section = FREEZE_TIMERS_SECTION
	)
	default boolean warnDuplicateFreezeTimers()
	{
		return true;
	}

	@ConfigItem(
		keyName = "preserveFreezeTimerOnForcedMovement",
		name = "Ignore forced movement",
		description = "Keep the freeze timer running when you move because of mithril/adamant seeds or dragon spear/hasta special attacks",
		position = 2,
		section = FREEZE_TIMERS_SECTION
	)
	default boolean preserveFreezeTimerOnForcedMovement()
	{
		return true;
	}
}

package com.wildyqol.menaphite;

import com.wildyqol.WildyQoLConfig;
import java.awt.Color;
import java.awt.image.BufferedImage;
import net.runelite.api.Client;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

public class MenaphiteProcInfoBox extends InfoBox
{
	private final MenaphiteProcTimerService timerService;
	private final WildyQoLConfig config;
	private final Client client;

	public MenaphiteProcInfoBox(BufferedImage image, Plugin plugin, MenaphiteProcTimerService timerService, WildyQoLConfig config, Client client)
	{
		super(image, plugin);
		this.timerService = timerService;
		this.config = config;
		this.client = client;
	}

	@Override
	public String getText()
	{
		final int ticksRemaining = timerService.getTicksUntilNextProc(client.getTickCount());
		if (ticksRemaining < 0)
		{
			return "";
		}

		if (config.menaphiteProcTimerDisplayTicks())
		{
			return Integer.toString(ticksRemaining);
		}

		double secondsRemaining = timerService.getSecondsUntilNextProc();
		if (secondsRemaining < 0)
		{
			return "";
		}

		int seconds = (int) secondsRemaining;
		if (seconds < 0)
		{
			seconds = 0;
		}

		return Integer.toString(seconds);
	}

	@Override
	public Color getTextColor()
	{
		int ticksRemaining = timerService.getTicksUntilNextProc(client.getTickCount());
		if (config.menaphiteProcTimerDisplayTicks())
		{
			if (ticksRemaining >= 0 && ticksRemaining <= 5)
			{
				return Color.RED;
			}
		}
		else
		{
			double secondsRemaining = timerService.getSecondsUntilNextProc();
			if (secondsRemaining >= 0 && secondsRemaining <= 3)
			{
				return Color.RED;
			}
		}

		return Color.WHITE;
	}
}

package com.wildyqol.menaphite;

import java.time.Duration;
import java.time.Instant;
import javax.inject.Singleton;

@Singleton
public class MenaphiteProcTimerService
{
	private static final int MENAPHITE_PROC_INTERVAL_TICKS = 25;
	private static final double TICK_LENGTH_SECONDS = 0.6d;
	private static final Duration MENAPHITE_PROC_INTERVAL_DURATION = Duration.ofMillis((long) (MENAPHITE_PROC_INTERVAL_TICKS * TICK_LENGTH_SECONDS * 1000));

	private boolean active;
	private int nextProcTick = -1;
	private int lastVarbitValue = -1;
	private Instant nextProcInstant;

	public void reset()
	{
		active = false;
		nextProcTick = -1;
		lastVarbitValue = -1;
		nextProcInstant = null;
	}

	public void handleVarbitUpdate(int varbitValue, int currentTick)
	{
		if (varbitValue <= 0)
		{
			reset();
			return;
		}

		if (varbitValue <= 1)
		{
			active = false;
			nextProcTick = -1;
			lastVarbitValue = varbitValue;
			nextProcInstant = null;
			return;
		}

		if (!active || varbitValue != lastVarbitValue)
		{
			nextProcTick = currentTick + MENAPHITE_PROC_INTERVAL_TICKS;
			nextProcInstant = Instant.now().plus(MENAPHITE_PROC_INTERVAL_DURATION);
			active = true;
		}

		lastVarbitValue = varbitValue;
	}

	public int getTicksUntilNextProc(int currentTick)
	{
		if (!active || nextProcTick < 0)
		{
			return -1;
		}

		return Math.max(0, nextProcTick - currentTick);
	}

	public double getSecondsUntilNextProc()
	{
		if (!active || nextProcInstant == null)
		{
			return -1;
		}

		Duration remaining = Duration.between(Instant.now(), nextProcInstant);
		if (remaining.isNegative())
		{
			return 0.0;
		}

		return remaining.toMillis() / 1000.0;
	}

	public boolean isActive()
	{
		return active;
	}

	public double getProcIntervalSeconds()
	{
		return MENAPHITE_PROC_INTERVAL_DURATION.toMillis() / 1000.0;
	}

	public int getProcIntervalTicks()
	{
		return MENAPHITE_PROC_INTERVAL_TICKS;
	}

	public double getFractionRemaining()
	{
		if (!active || nextProcInstant == null)
		{
			return -1;
		}

		final double totalMillis = MENAPHITE_PROC_INTERVAL_DURATION.toMillis();
		if (totalMillis <= 0)
		{
			return -1;
		}

		final Duration remaining = Duration.between(Instant.now(), nextProcInstant);
		final double millisRemaining = remaining.toMillis();

		if (millisRemaining <= 0)
		{
			return 0.0;
		}

		final double fraction = millisRemaining / totalMillis;
		if (fraction <= 0)
		{
			return 0.0;
		}

		if (fraction >= 1)
		{
			return 1.0;
		}

		return fraction;
	}

	@SuppressWarnings("unused")
	public double getFractionRemainingTicks(int currentTick)
	{
		if (!active || nextProcTick < 0)
		{
			return -1;
		}

		final int intervalTicks = MENAPHITE_PROC_INTERVAL_TICKS;
		if (intervalTicks <= 0)
		{
			return -1;
		}

		int ticksRemaining = Math.max(0, nextProcTick - currentTick);
		if (ticksRemaining <= 0)
		{
			return 0.0;
		}

		double fraction = (double) ticksRemaining / intervalTicks;
		if (fraction <= 0)
		{
			return 0.0;
		}

		if (fraction >= 1)
		{
			return 1.0;
		}

		return fraction;
	}
}

package com.wildyqol.menaphite;

import com.wildyqol.WildyQoLConfig;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.components.TextComponent;

@Singleton
public class MenaphiteProcStatusBarOverlay extends Overlay
{
	private static final Color BACKGROUND = new Color(0, 0, 0, 150);
	private static final Color FALLBACK_BAR_COLOR = new Color(0x4BA1FA);
	private static final Color COUNTER_COLOR = Color.WHITE;
	private static final int BORDER_SIZE = 1;
	private static final int BAR_WIDTH = 20;
	private static final int HEIGHT = 252;
	private static final int RESIZED_BOTTOM_HEIGHT = 272;
	private static final int RESIZED_BOTTOM_OFFSET_Y = 12;
	private static final int RESIZED_BOTTOM_OFFSET_X = 10;
	private static final int ICON_MAX_HEIGHT = 32;
	private static final int ICON_HORIZONTAL_PADDING = 2;
	private static final int ICON_TOP_PADDING = 4;
	private static final int SKILL_ICON_HEIGHT = 35;
	private static final int COUNTER_ONLY_HEIGHT = 18;

	public enum MenaphiteStatusBarPosition
	{
		LEFT,
		RIGHT
	}

	private final Client client;
	private final MenaphiteProcTimerService timerService;
	private final WildyQoLConfig config;

	private BufferedImage menaphiteIcon;
	private BufferedImage cachedScaledIcon;
	private Color barColor = FALLBACK_BAR_COLOR;
	private MenaphiteStatusBarPosition position = MenaphiteStatusBarPosition.LEFT;

	@Inject
	private MenaphiteProcStatusBarOverlay(Client client, MenaphiteProcTimerService timerService, WildyQoLConfig config)
	{
		this.client = client;
		this.timerService = timerService;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	public void setMenaphiteImage(BufferedImage icon)
	{
		this.menaphiteIcon = icon;
		this.cachedScaledIcon = null;
		this.barColor = deriveBarColor(icon);
	}

	public void clearMenaphiteImage()
	{
		this.menaphiteIcon = null;
		this.cachedScaledIcon = null;
		this.barColor = FALLBACK_BAR_COLOR;
	}

	public void setPosition(MenaphiteStatusBarPosition position)
	{
		this.position = position != null ? position : MenaphiteStatusBarPosition.LEFT;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		WildyQoLConfig.MenaphiteProcStatusBarMode mode = config.menaphiteProcTimerStatusBarMode();
		if (mode == null)
		{
			return null;
		}
		if (mode == WildyQoLConfig.MenaphiteProcStatusBarMode.OFF)
		{
			return null;
		}

		MenaphiteStatusBarPosition desiredPosition =
			mode == WildyQoLConfig.MenaphiteProcStatusBarMode.LEFT
				? MenaphiteStatusBarPosition.LEFT
				: MenaphiteStatusBarPosition.RIGHT;
		if (desiredPosition != position)
		{
			position = desiredPosition;
		}

		if (!timerService.isActive())
		{
			return null;
		}

		double fractionRemaining = config.menaphiteProcTimerDisplayTicks()
			? timerService.getFractionRemainingTicks(client.getTickCount())
			: timerService.getFractionRemaining();
		if (fractionRemaining < 0)
		{
			return null;
		}

		double fillFraction = clamp01(1.0 - fractionRemaining);

		ViewportMatch viewportMatch = locateViewport();
		if (viewportMatch == null)
		{
			return null;
		}

		renderStatusBar(graphics, viewportMatch, fillFraction);
		return null;
	}

	private void renderStatusBar(Graphics2D graphics, ViewportMatch viewportMatch, double fillFraction)
	{
		Point widgetLocation = viewportMatch.widget.getCanvasLocation();
		if (widgetLocation == null)
		{
			return;
		}

		int width = BAR_WIDTH;
		int height = viewportMatch.viewport == MenaphiteViewport.RESIZED_BOTTOM ? RESIZED_BOTTOM_HEIGHT : HEIGHT;
		int x;
		int y;

		if (viewportMatch.viewport == MenaphiteViewport.RESIZED_BOTTOM)
		{
			int barWidthOffset = width - BAR_WIDTH;
			if (position == MenaphiteStatusBarPosition.LEFT)
			{
				x = widgetLocation.getX() + RESIZED_BOTTOM_OFFSET_X - viewportMatch.viewport.getOffsetLeft().getX() - 2 * barWidthOffset;
				y = widgetLocation.getY() - RESIZED_BOTTOM_OFFSET_Y - viewportMatch.viewport.getOffsetLeft().getY();
			}
			else
			{
				x = widgetLocation.getX() + RESIZED_BOTTOM_OFFSET_X - viewportMatch.viewport.getOffsetRight().getX() - barWidthOffset;
				y = widgetLocation.getY() - RESIZED_BOTTOM_OFFSET_Y - viewportMatch.viewport.getOffsetRight().getY();
			}
		}
		else
		{
			if (position == MenaphiteStatusBarPosition.LEFT)
			{
				x = widgetLocation.getX() - viewportMatch.viewport.getOffsetLeft().getX();
				y = widgetLocation.getY() - viewportMatch.viewport.getOffsetLeft().getY();
			}
			else
			{
				x = widgetLocation.getX() - viewportMatch.viewport.getOffsetRight().getX() + viewportMatch.widget.getWidth();
				y = widgetLocation.getY() - viewportMatch.viewport.getOffsetRight().getY();
			}
		}

		drawBar(graphics, x, y, width, height, fillFraction);
		boolean iconDrawn = drawIcon(graphics, x, y, width);
		drawCounter(graphics, x, y, width, iconDrawn);
	}

	private void drawBar(Graphics2D graphics, int x, int y, int width, int height, double fillFraction)
	{
		int fillHeight = (int) Math.round(height * clamp01(fillFraction));
		fillHeight = Math.max(0, Math.min(height, fillHeight));

		graphics.setColor(BACKGROUND);
		graphics.drawRect(x, y, width - BORDER_SIZE, height - BORDER_SIZE);
		graphics.fillRect(x, y, width, height);

		int innerHeight = fillHeight - BORDER_SIZE * 2;
		if (innerHeight <= 0)
		{
			return;
		}

		graphics.setColor(barColor);
		graphics.fillRect(
			x + BORDER_SIZE,
			y + BORDER_SIZE + (height - fillHeight),
			width - BORDER_SIZE * 2,
			innerHeight
		);
	}

	private boolean drawIcon(Graphics2D graphics, int x, int y, int width)
	{
		BufferedImage icon = getIconForWidth(width);
		if (icon == null)
		{
			return false;
		}

		int drawX = x + (width - icon.getWidth()) / 2;
		int drawY = y + ICON_TOP_PADDING;
		graphics.drawImage(icon, drawX, drawY, null);
		return true;
	}

	private void drawCounter(Graphics2D graphics, int x, int y, int width, boolean iconDrawn)
	{
		String counterText = getCounterText();
		if (counterText == null)
		{
			return;
		}

		graphics.setFont(FontManager.getRunescapeFont());
		FontMetrics metrics = graphics.getFontMetrics();
		int textWidth = metrics.stringWidth(counterText);
		int textX = x + (width / 2) - (textWidth / 2);
		int yOffset = iconDrawn ? SKILL_ICON_HEIGHT : COUNTER_ONLY_HEIGHT;
		int textY = y + yOffset;

		TextComponent textComponent = new TextComponent();
		textComponent.setText(counterText);
		textComponent.setColor(COUNTER_COLOR);
		textComponent.setPosition(new java.awt.Point(textX, textY));
		textComponent.render(graphics);
	}

	private BufferedImage getIconForWidth(int width)
	{
		if (menaphiteIcon == null)
		{
			return null;
		}

		int availableWidth = Math.max(1, width - BORDER_SIZE * 2 - ICON_HORIZONTAL_PADDING);
		int availableHeight = Math.max(1, ICON_MAX_HEIGHT);

		int iconWidth = menaphiteIcon.getWidth();
		int iconHeight = menaphiteIcon.getHeight();

		if (iconWidth <= availableWidth && iconHeight <= availableHeight)
		{
			return menaphiteIcon;
		}

		double scale = Math.min((double) availableWidth / iconWidth, (double) availableHeight / iconHeight);
		int scaledWidth = Math.max(1, (int) Math.round(iconWidth * scale));
		int scaledHeight = Math.max(1, (int) Math.round(iconHeight * scale));

		if (cachedScaledIcon != null
			&& cachedScaledIcon.getWidth() == scaledWidth
			&& cachedScaledIcon.getHeight() == scaledHeight)
		{
			return cachedScaledIcon;
		}

		cachedScaledIcon = ImageUtil.resizeImage(menaphiteIcon, scaledWidth, scaledHeight);
		return cachedScaledIcon;
	}

	private Color deriveBarColor(BufferedImage icon)
	{
		if (icon == null)
		{
			return FALLBACK_BAR_COLOR;
		}

		long sumR = 0;
		long sumG = 0;
		long sumB = 0;
		int count = 0;
		long fallbackSumR = 0;
		long fallbackSumG = 0;
		long fallbackSumB = 0;
		int fallbackCount = 0;

		for (int y = 0; y < icon.getHeight(); y++)
		{
			for (int x = 0; x < icon.getWidth(); x++)
			{
				int argb = icon.getRGB(x, y);
				int alpha = (argb >>> 24) & 0xFF;
				if (alpha < 64)
				{
					continue;
				}

				int red = (argb >> 16) & 0xFF;
				int green = (argb >> 8) & 0xFF;
				int blue = argb & 0xFF;

				if (blue > red + 15 && blue > green + 15)
				{
					sumR += red;
					sumG += green;
					sumB += blue;
					count++;
				}

				fallbackSumR += red;
				fallbackSumG += green;
				fallbackSumB += blue;
				fallbackCount++;
			}
		}

		if (count == 0)
		{
			if (fallbackCount == 0)
			{
				return FALLBACK_BAR_COLOR;
			}

			int fr = (int) (fallbackSumR / fallbackCount);
			int fg = (int) (fallbackSumG / fallbackCount);
			int fb = (int) (fallbackSumB / fallbackCount);
			return new Color(fr, fg, fb, 220);
		}

		int r = (int) (sumR / count);
		int g = (int) (sumG / count);
		int b = (int) (sumB / count);
		return new Color(r, g, b, 220);
	}

	private String getCounterText()
	{
		if (!timerService.isActive())
		{
			return null;
		}

		if (config.menaphiteProcTimerDisplayTicks())
		{
			int ticksRemaining = timerService.getTicksUntilNextProc(client.getTickCount());
			if (ticksRemaining < 0)
			{
				return null;
			}

			return Integer.toString(ticksRemaining);
		}

		double secondsRemaining = timerService.getSecondsUntilNextProc();
		if (secondsRemaining < 0)
		{
			return null;
		}

		int seconds = (int) secondsRemaining;
		if (seconds < 0)
		{
			seconds = 0;
		}

		return Integer.toString(seconds);
	}

	private ViewportMatch locateViewport()
	{
		for (MenaphiteViewport viewport : MenaphiteViewport.values())
		{
			Widget viewportWidget = client.getWidget(viewport.getInterfaceId());
			if (viewportWidget != null && !viewportWidget.isHidden())
			{
				return new ViewportMatch(viewport, viewportWidget);
			}
		}

		return null;
	}

	private static double clamp01(double value)
	{
		if (value <= 0)
		{
			return 0.0;
		}

		if (value >= 1)
		{
			return 1.0;
		}

		return value;
	}

	private static final class ViewportMatch
	{
		private final MenaphiteViewport viewport;
		private final Widget widget;

		private ViewportMatch(MenaphiteViewport viewport, Widget widget)
		{
			this.viewport = viewport;
			this.widget = widget;
		}
	}

	private enum MenaphiteViewport
	{
		RESIZED_BOX(InterfaceID.ToplevelOsrsStretch.SIDE_CONTAINER, new Point(20, -4), new Point(0, -4)),
		RESIZED_BOTTOM(InterfaceID.ToplevelPreEoc.SIDE_BACKGROUND, new Point(61, -12), new Point(35, -12)),
		FIXED(InterfaceID.Toplevel.SIDE_PANELS, new Point(20, -4), new Point(0, -4)),
		FIXED_BANK(InterfaceID.Bankside.ITEMS, new Point(20, -4), new Point(0, -4));

		private final int interfaceId;
		private final Point offsetLeft;
		private final Point offsetRight;

		MenaphiteViewport(int interfaceId, Point offsetLeft, Point offsetRight)
		{
			this.interfaceId = interfaceId;
			this.offsetLeft = offsetLeft;
			this.offsetRight = offsetRight;
		}

		int getInterfaceId()
		{
			return interfaceId;
		}

		Point getOffsetLeft()
		{
			return offsetLeft;
		}

		Point getOffsetRight()
		{
			return offsetRight;
		}
	}
}

package com.wildyqol;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import net.runelite.api.Client;
import net.runelite.api.WorldType;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

public class ProtectItemInfoBox extends InfoBox
{
	private static final int SPRITE_PRAYER_PROTECT_ITEM = 123;
	private static final int VARBIT_IN_WILDERNESS = 5963;
	private static final int VARBIT_PVP_AREA_CLIENT = 8121;
	private static final int VARBIT_PRAYER_PROTECT_ITEM = 4112;

	private final Client client;
	private final WildyQoLConfig config;

	public ProtectItemInfoBox(WildyQoLConfig config, Client client, Plugin plugin, SpriteManager spriteManager)
	{
		super(null, plugin);
		this.config = config;
		this.client = client;
		spriteManager.getSpriteAsync(SPRITE_PRAYER_PROTECT_ITEM, 0, this);
	}

	@Override
	public String getText()
	{
		return null;
	}

	@Override
	public Color getTextColor()
	{
		return null;
	}

	@Override
	public String getTooltip()
	{
		return "Enable Protect Item!";
	}

	@Override
	public void setImage(BufferedImage image)
	{
		if (image == null)
		{
			super.setImage(null);
			return;
		}

		BufferedImage combined = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = combined.createGraphics();
		g.drawImage(image, 0, 0, null);

		// Draw red cross in bottom right
		g.setColor(Color.RED);
		int w = combined.getWidth();
		int h = combined.getHeight();

		// Thick red cross
		// \
		g.drawLine(w - 10, h - 10, w - 2, h - 2);
		g.drawLine(w - 10, h - 9, w - 3, h - 2); // thickness

		// /
		g.drawLine(w - 10, h - 2, w - 2, h - 10);
		g.drawLine(w - 9, h - 2, w - 2, h - 9); // thickness

		g.dispose();
		super.setImage(combined);
	}

	@Override
	public boolean render()
	{
		if (!config.protectItemInfoBox() || !shouldNotifyProtectItem())
		{
			return false;
		}

		return super.render();
	}

	private boolean shouldNotifyProtectItem()
	{
		if (client.getWorldType().contains(WorldType.DEADMAN))
		{
			return false;
		}

		// Check if in PvP area
		boolean inPvp = client.getVarbitValue(VARBIT_IN_WILDERNESS) == 1
			|| client.getVarbitValue(VARBIT_PVP_AREA_CLIENT) == 1;

		if (!inPvp)
		{
			return false;
		}

		// Check if Protect Item is active
		boolean protectItemActive = client.getVarbitValue(VARBIT_PRAYER_PROTECT_ITEM) == 1;

		return !protectItemActive;
	}
}

package com.wildyqol;

import com.google.inject.Provides;
import com.wildyqol.freezetimers.ExtendedFreezeTimersService;
import com.wildyqol.ikodparchmentrisk.IkodParchmentRiskOverlay;
import com.wildyqol.menaphite.MenaphiteProcInfoBox;
import com.wildyqol.menaphite.MenaphiteProcStatusBarOverlay;
import com.wildyqol.menaphite.MenaphiteProcTimerService;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Deque;
import java.util.IdentityHashMap;
import java.util.Set;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;
import net.runelite.client.util.Text;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.game.SpriteManager;



@Slf4j
@PluginDescriptor(
        name = "Wildy QoL",
        description = "Quality of life improvements for wilderness activities"
)
public class WildyQoLPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private ConfigManager configManager;

    @Inject
    private WildyQoLConfig config;

    @Inject
    private ChatMessageManager chatMessageManager;

    private boolean shouldShowUpdateMessage = false;

    @Inject
    private ItemManager itemManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private IkodParchmentRiskOverlay ikodParchmentRiskOverlay;

    @Inject
    private MenaphiteProcTimerService menaphiteProcTimerService;

    @Inject
    private InfoBoxManager infoBoxManager;

    @Inject
    private MenaphiteProcStatusBarOverlay menaphiteProcStatusBarOverlay;

    @Inject
    private FishInventoryIconOverlay fishInventoryIconOverlay;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ExtendedFreezeTimersService extendedFreezeTimersService;

    private ProtectItemInfoBox protectItemInfoBox;

    private static final Set<Integer> RUNE_POUCH_ITEM_IDS = Set.of(
        ItemID.BH_RUNE_POUCH,
        ItemID.BH_RUNE_POUCH_TROUVER,
        ItemID.DIVINE_RUNE_POUCH,
        ItemID.DIVINE_RUNE_POUCH_TROUVER
    );

    private static final long TROUVER_REPARCH_COST = 500_000L;

    private MenaphiteProcInfoBox menaphiteProcInfoBox;
    private BufferedImage menaphiteImage;
    private boolean menaphiteStatusBarOverlayAdded;

    @Override
    protected void startUp()
    {
        log.debug("Pet Spell Blocker enabled: {}", config.petSpellBlocker());
        log.debug("Empty Vial Blocker enabled: {}", config.emptyVialBlocker());

        overlayManager.add(ikodParchmentRiskOverlay);
        overlayManager.add(fishInventoryIconOverlay);
        removeMenaphiteProcInfoBox();
        removeMenaphiteStatusBarOverlay();
        menaphiteImage = loadMenaphiteImage();
        menaphiteProcStatusBarOverlay.setMenaphiteImage(menaphiteImage);
        menaphiteProcTimerService.reset();
        updateMenaphiteStatusBarOverlay();

        clientThread.invokeLater(() ->
        {
            updateTrouverSurcharge();
        });

        protectItemInfoBox = new ProtectItemInfoBox(config, client, this, spriteManager);
        infoBoxManager.addInfoBox(protectItemInfoBox);

        extendedFreezeTimersService.startUp(this);

        // Check if we should show update message (but don't show it yet)
        if (!config.updateMessageShown130())
        {
            shouldShowUpdateMessage = true;
        }
    }

    @Override
    protected void shutDown()
    {
        log.debug("Wildy QoL stopped");
        overlayManager.remove(ikodParchmentRiskOverlay);
        overlayManager.remove(fishInventoryIconOverlay);
        ikodParchmentRiskOverlay.reset();
        menaphiteProcTimerService.reset();
        removeMenaphiteProcInfoBox();
        removeMenaphiteStatusBarOverlay();
        menaphiteProcStatusBarOverlay.clearMenaphiteImage();
        menaphiteImage = null;
        infoBoxManager.removeInfoBox(protectItemInfoBox);
        protectItemInfoBox = null;
        extendedFreezeTimersService.shutDown();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
        extendedFreezeTimersService.onGameStateChanged(gameStateChanged);

        if (gameStateChanged.getGameState() != GameState.LOGGED_IN)
        {
            menaphiteProcTimerService.reset();
            removeMenaphiteProcInfoBox();
            removeMenaphiteStatusBarOverlay();
            return;
        }

        // Show update message if needed
        if (shouldShowUpdateMessage)
        {
            showUpdateMessage();
            configManager.setConfiguration("wildyqol", "updateMessageShown130", true);
            shouldShowUpdateMessage = false;
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event)
    {

        if (config.petSpellBlocker())
        {
            handlePetSpellBlock(event);
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
        if (handleRunePouchLeftClick(event))
        {
            return;
        }

        handleEmptyVialBlocker(event);
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        if (event.getGroupId() == InterfaceID.DEATHKEEP)
        {
            updateTrouverSurcharge();
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event)
    {
        if (event.getGroupId() == InterfaceID.DEATHKEEP)
        {
            ikodParchmentRiskOverlay.reset();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (isIkodOpen())
        {
            updateTrouverSurcharge();
        }

        extendedFreezeTimersService.onItemContainerChanged(event);
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (isIkodOpen())
        {
            updateTrouverSurcharge();
        }

        if (event.getVarbitId() == VarbitID.STATRENEWAL_POTION_TIMER)
        {
            handleMenaphiteVarbit(event.getValue());
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!"wildyqol".equals(event.getGroup()))
        {
            return;
        }

        if ("enableExtendedFreezeTimersV2".equals(event.getKey()))
        {
            extendedFreezeTimersService.onConfigChanged();
        }

        if ("menaphiteProcTimerShowInfoBox".equals(event.getKey()))
        {
            if (!config.menaphiteProcTimerShowInfoBox())
            {
                removeMenaphiteProcInfoBox();
            }
            else if (menaphiteProcTimerService.isActive())
            {
                ensureMenaphiteProcInfoBox();
            }

            clientThread.invokeLater(() ->
            {
                int varbitValue = client.getVarbitValue(VarbitID.STATRENEWAL_POTION_TIMER);
                handleMenaphiteVarbit(varbitValue);
            });
        }

        if ("menaphiteProcTimerStatusBarMode".equals(event.getKey()))
        {
            clientThread.invokeLater(() ->
            {
                int varbitValue = client.getVarbitValue(VarbitID.STATRENEWAL_POTION_TIMER);
                handleMenaphiteVarbit(varbitValue);
            });
        }


    }

    @Subscribe
    public void onGraphicChanged(GraphicChanged event)
    {
        extendedFreezeTimersService.onGraphicChanged(event);
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        extendedFreezeTimersService.onGameTick(event);
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged event)
    {
        extendedFreezeTimersService.onInteractingChanged(event);
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event)
    {
        extendedFreezeTimersService.onAnimationChanged(event);
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event)
    {
        extendedFreezeTimersService.onHitsplatApplied(event);
    }

    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        extendedFreezeTimersService.onChatMessage(event);
    }

    @Subscribe
    public void onPlayerDespawned(PlayerDespawned event)
    {
        extendedFreezeTimersService.onPlayerDespawned(event);
    }



    private void handlePetSpellBlock(MenuEntryAdded event)
    {
        boolean isCastOption = "Cast".equals(event.getOption());
        boolean isExamineNpc = event.getMenuEntry().getType() == MenuAction.EXAMINE_NPC;
        boolean isSpellSelected = isSpellSelected();

        // Block spell casts and suppress pet examine while a spell is selected.
        if (!isCastOption && (!isSpellSelected || !isExamineNpc))
        {
            return;
        }

        // Get the target NPC
        int npcIndex = event.getIdentifier();
        if (npcIndex < 0)
        {
            return;
        }

        // Get NPC from the scene using the new API
        NPC npc = client.getTopLevelWorldView().npcs().byIndex(npcIndex);
        
        if (npc == null)
        {
            return;
        }

        // Check if the NPC is a follower (pet)
        NPCComposition comp = npc.getComposition();
        if (comp != null && comp.isFollower())
        {
            // Remove the menu entry using the new API
            // Use the new Menu API to remove the entry
            client.getMenu().removeMenuEntry(event.getMenuEntry());
            log.debug("Removed spell cast menu entry for pet: {}", npc.getName());
        }
    }

    private boolean isSpellSelected()
    {
        if (!client.isWidgetSelected())
        {
            return false;
        }

        Widget selectedWidget = client.getSelectedWidget();
        return selectedWidget != null
            && WidgetUtil.componentToInterface(selectedWidget.getId()) == InterfaceID.MAGIC_SPELLBOOK;
    }

    private boolean handleRunePouchLeftClick(MenuOptionClicked event)
    {
        if (!config.runePouchBlocker() || client.isMenuOpen())
        {
            return false;
        }

        if (!isInPvpArea())
        {
            return false;
        }

        MenuEntry clicked = event.getMenuEntry();
        if (!isRunePouch(clicked.getItemId()) || clicked.getType() == MenuAction.EXAMINE_ITEM)
        {
            return false;
        }

        event.consume();
        return true;
    }

    private boolean isRunePouch(int itemId)
    {
        int canonicalId = itemManager.canonicalize(itemId);
        return canonicalId > 0 && RUNE_POUCH_ITEM_IDS.contains(canonicalId);
    }

    private boolean isInPvpArea()
    {
        return client.getVarbitValue(VarbitID.INSIDE_WILDERNESS) == 1
            || client.getVarbitValue(VarbitID.PVP_AREA_CLIENT) == 1;
    }


    private void handleEmptyVialBlocker(MenuOptionClicked event)
    {
        if (!config.emptyVialBlocker() || !isInPvpArea())
        {
            return;
        }

        if (!"Use".equals(event.getMenuEntry().getOption()))
        {
            return;
        }

        if (event.getMenuEntry().getItemId() == ItemID.VIAL_EMPTY)
        {
            event.consume();
        }
    }

    private void showUpdateMessage()
    {
        chatMessageManager.queue(QueuedMessage.builder()
            .type(ChatMessageType.GAMEMESSAGE)
            .runeLiteFormattedMessage("<col=00ff00>Wildy QoL:</col> v1.3.0: added remapping for new fish icons, extended freeze timers (ancient sceptres, swampbark), and rune pouch misclick prevention. Check plugin settings for details.")
            .build());
    }

    private void updateTrouverSurcharge()
    {
        if (!config.showIkodTrouverOverlay())
        {
            ikodParchmentRiskOverlay.reset();
            return;
        }

        boolean ikodOpen = isIkodOpen();
        if (!ikodOpen)
        {
            ikodParchmentRiskOverlay.reset();
            return;
        }

        Widget riskWidget = client.getWidget(InterfaceID.Deathkeep.VALUE);
        if (riskWidget == null || riskWidget.isHidden())
        {
            ikodParchmentRiskOverlay.reset();
            return;
        }

        int lockedCount = countLockedItems();
        long perItemCost = getPerItemCost();
        long surcharge = lockedCount * perItemCost;
        long baseRisk = getGuideRiskValue(riskWidget);
        Color labelColor = deriveLabelColor(riskWidget);

        ikodParchmentRiskOverlay.update(true, lockedCount, perItemCost, surcharge, baseRisk, labelColor);
    }

    private boolean isIkodOpen()
    {
        Widget root = client.getWidget(InterfaceID.Deathkeep.CONTENTS);
        return root != null && !root.isHidden();
    }

    private int countLockedItems()
    {
        Set<Widget> visited = Collections.newSetFromMap(new IdentityHashMap<>());
        Deque<Widget> stack = new ArrayDeque<>();
        pushRoot(stack, client.getWidget(InterfaceID.Deathkeep.KEPT));
        pushRoot(stack, client.getWidget(InterfaceID.Deathkeep.GRAVE));

        if (stack.isEmpty())
        {
            pushRoot(stack, client.getWidget(InterfaceID.Deathkeep.ITEMS));
        }

        int lockedCount = 0;

        while (!stack.isEmpty())
        {
            Widget widget = stack.pop();

            if (widget == null || !visited.add(widget) || widget.isHidden())
            {
                continue;
            }

            lockedCount += countLockedItemsForWidget(widget);

            pushChildren(stack, widget.getDynamicChildren());
            pushChildren(stack, widget.getStaticChildren());
            pushChildren(stack, widget.getNestedChildren());
            pushChildren(stack, widget.getChildren());
        }

        return lockedCount;
    }

    private void pushRoot(Deque<Widget> stack, Widget widget)
    {
        if (widget != null && !widget.isHidden())
        {
            stack.push(widget);
        }
    }

    private int countLockedItemsForWidget(Widget widget)
    {
        int itemId = widget.getItemId();
        if (itemId <= 0)
        {
            return 0;
        }

        if (widget.getBorderType() != 2)
        {
            return 0;
        }

        int canonicalId = itemManager.canonicalize(itemId);
        ItemComposition composition = itemManager.getItemComposition(canonicalId);

        if (composition == null || !composition.getName().endsWith(" (l)"))
        {
            return 0;
        }

        int quantity = Math.max(1, widget.getItemQuantity());
        return quantity;
    }

    private void pushChildren(Deque<Widget> stack, Widget[] children)
    {
        if (children == null)
        {
            return;
        }

        for (Widget child : children)
        {
            if (child != null)
            {
                stack.push(child);
            }
        }
    }

    private long getPerItemCost()
    {
        long parchmentPrice = itemManager.getItemPrice(ItemID.TROUVER_PARCHMENT);
        return parchmentPrice + TROUVER_REPARCH_COST;
    }

    private long getGuideRiskValue(Widget riskWidget)
    {
        String rawText = riskWidget.getText();
        if (rawText == null)
        {
            return 0L;
        }

        String sanitized = Text.removeTags(rawText).replaceAll("[^0-9]", "");
        if (sanitized.isEmpty())
        {
            return 0L;
        }

        try
        {
            return Long.parseLong(sanitized);
        }
        catch (NumberFormatException ex)
        {
            return 0L;
        }
    }

    private Color deriveLabelColor(Widget riskWidget)
    {
        int color = riskWidget.getTextColor();
        if (color == 0)
        {
            return Color.WHITE;
        }

        return new Color(color | 0xFF000000, true);
    }

    private void handleMenaphiteVarbit(int varbitValue)
    {
        if (!isMenaphiteTimerEnabled())
        {
            menaphiteProcTimerService.reset();
            removeMenaphiteProcInfoBox();
            removeMenaphiteStatusBarOverlay();
            return;
        }

        menaphiteProcTimerService.handleVarbitUpdate(varbitValue, client.getTickCount());

        if (menaphiteProcTimerService.isActive() && config.menaphiteProcTimerShowInfoBox())
        {
            ensureMenaphiteProcInfoBox();
        }
        else
        {
            removeMenaphiteProcInfoBox();
        }

        updateMenaphiteStatusBarOverlay();
    }

    private void ensureMenaphiteProcInfoBox()
    {
        if (!config.menaphiteProcTimerShowInfoBox())
        {
            removeMenaphiteProcInfoBox();
            return;
        }

        if (menaphiteProcInfoBox != null)
        {
            return;
        }

        if (menaphiteImage == null)
        {
            menaphiteImage = loadMenaphiteImage();
        }

        menaphiteProcInfoBox = new MenaphiteProcInfoBox(menaphiteImage, this, menaphiteProcTimerService, config, client);
        menaphiteProcInfoBox.setTooltip("Time until next menaphite remedy proc");
        menaphiteProcInfoBox.setPriority(InfoBoxPriority.MED);
        infoBoxManager.addInfoBox(menaphiteProcInfoBox);
        menaphiteProcStatusBarOverlay.setMenaphiteImage(menaphiteImage);
    }

    private void removeMenaphiteProcInfoBox()
    {
        if (menaphiteProcInfoBox == null)
        {
            return;
        }

        infoBoxManager.removeInfoBox(menaphiteProcInfoBox);
        menaphiteProcInfoBox = null;
    }

    private BufferedImage loadMenaphiteImage()
    {
        BufferedImage image = itemManager.getImage(ItemID._4DOSESTATRENEWAL);
        if (image != null)
        {
            return image;
        }

        return new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
    }

    private void ensureMenaphiteStatusBarOverlay()
    {
        if (menaphiteStatusBarOverlayAdded)
        {
            return;
        }

        overlayManager.add(menaphiteProcStatusBarOverlay);
        menaphiteStatusBarOverlayAdded = true;
    }

    private void removeMenaphiteStatusBarOverlay()
    {
        if (!menaphiteStatusBarOverlayAdded)
        {
            return;
        }

        overlayManager.remove(menaphiteProcStatusBarOverlay);
        menaphiteStatusBarOverlayAdded = false;
    }

    private void updateMenaphiteStatusBarOverlay()
    {
        WildyQoLConfig.MenaphiteProcStatusBarMode mode = config.menaphiteProcTimerStatusBarMode();
        if (mode == null || mode == WildyQoLConfig.MenaphiteProcStatusBarMode.OFF)
        {
            removeMenaphiteStatusBarOverlay();
            return;
        }

        MenaphiteProcStatusBarOverlay.MenaphiteStatusBarPosition position =
            mode == WildyQoLConfig.MenaphiteProcStatusBarMode.LEFT
                ? MenaphiteProcStatusBarOverlay.MenaphiteStatusBarPosition.LEFT
                : MenaphiteProcStatusBarOverlay.MenaphiteStatusBarPosition.RIGHT;
        menaphiteProcStatusBarOverlay.setPosition(position);
        ensureMenaphiteStatusBarOverlay();
        if (menaphiteImage == null)
        {
            menaphiteImage = loadMenaphiteImage();
        }
        menaphiteProcStatusBarOverlay.setMenaphiteImage(menaphiteImage);
    }

    @Provides
    WildyQoLConfig provideConfig(ConfigManager configManager)
    {
        WildyQoLConfig cfg = configManager.getConfig(WildyQoLConfig.class);
        configManager.setDefaultConfiguration(cfg, false);
        return cfg;
    }

    private boolean isMenaphiteTimerEnabled()
    {
        WildyQoLConfig.MenaphiteProcStatusBarMode mode = config.menaphiteProcTimerStatusBarMode();
        boolean statusBarEnabled = mode != null && mode != WildyQoLConfig.MenaphiteProcStatusBarMode.OFF;
        return config.menaphiteProcTimerShowInfoBox() || statusBarEnabled;
    }


}

package com.wildyqol;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;

@Singleton
public class FishInventoryIconOverlay extends WidgetItemOverlay
{
    private static final Color INVENTORY_BACKGROUND_RESIZABLE = new Color(62, 53, 41);
    private static final Color INVENTORY_BACKGROUND_FIXED = new Color(66, 58, 45);
    private static final float ACTIVE_ALPHA = 0.55f;
    private static final int ACTIVE_LINGER_CYCLES = 10;

    private final Client client;
    private final ItemManager itemManager;
    private final WildyQoLConfig config;
    private final Map<Long, ActiveState> recentActiveStates = new HashMap<>();
    private boolean wasDragging;

    @Inject
    private FishInventoryIconOverlay(Client client, ItemManager itemManager, WildyQoLConfig config)
    {
        this.client = client;
        this.itemManager = itemManager;
        this.config = config;
        drawAfterInterface(InterfaceID.INVENTORY);
    }

    @Override
    public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
    {
        if (!isInPvpArea())
        {
            return;
        }

        int replacementId = getReplacementId(itemId);
        if (replacementId == -1)
        {
            return;
        }

        Widget widget = widgetItem.getWidget();
        if (widget == null || widget.getParentId() != InterfaceID.Inventory.ITEMS)
        {
            return;
        }

        Rectangle bounds = widgetItem.getCanvasBounds();
        if (bounds == null)
        {
            return;
        }

        BufferedImage replacementImage = itemManager.getImage(replacementId, widgetItem.getQuantity(), false);
        if (replacementImage == null)
        {
            return;
        }

        BufferedImage originalImage = itemManager.getImage(itemId, widgetItem.getQuantity(), false);
        if (originalImage != null)
        {
            int clearX = bounds.x + (bounds.width - originalImage.getWidth()) / 2;
            int clearY = bounds.y + (bounds.height - originalImage.getHeight()) / 2;
            BufferedImage mask = maskWithBackground(originalImage, getInventoryBackgroundColor());
            graphics.drawImage(mask, clearX, clearY, null);
        }

        int drawX = bounds.x + (bounds.width - replacementImage.getWidth()) / 2;
        int drawY = bounds.y + (bounds.height - replacementImage.getHeight()) / 2;
        Graphics2D imageGraphics = (Graphics2D) graphics.create();
        if (isActiveWidget(widgetItem, bounds))
        {
            imageGraphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, ACTIVE_ALPHA));
        }
        imageGraphics.drawImage(replacementImage, drawX, drawY, null);
        imageGraphics.dispose();
    }

    private int getReplacementId(int itemId)
    {
        if (itemId == ItemID.MARLIN && config.marlinEqualsAnglerfish())
        {
            return ItemID.ANGLERFISH;
        }

        if (itemId == ItemID.HALIBUT && config.halibutEqualsKarambwan())
        {
            return ItemID.TBWT_COOKED_KARAMBWAN;
        }

        return -1;
    }

    private boolean isInPvpArea()
    {
        return client.getVarbitValue(VarbitID.INSIDE_WILDERNESS) == 1
            || client.getVarbitValue(VarbitID.PVP_AREA_CLIENT) == 1;
    }

    private BufferedImage maskWithBackground(BufferedImage source, Color background)
    {
        int width = source.getWidth();
        int height = source.getHeight();
        BufferedImage masked = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        int backgroundRgb = background.getRGB() & 0x00FFFFFF;

        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                int argb = source.getRGB(x, y);
                int alpha = (argb >>> 24) & 0xFF;
                if (alpha == 0)
                {
                    continue;
                }
                masked.setRGB(x, y, (alpha << 24) | backgroundRgb);
            }
        }

        return masked;
    }

    private Color getInventoryBackgroundColor()
    {
        return client.isResized() ? INVENTORY_BACKGROUND_RESIZABLE : INVENTORY_BACKGROUND_FIXED;
    }

    private boolean isActiveWidget(WidgetItem widgetItem, Rectangle bounds)
    {
        boolean dragging = updateDragState();
        Widget widget = widgetItem.getWidget();
        long key = widgetKey(widget);
        int cycle = client.getGameCycle();
        int itemId = widgetItem.getId();
        int quantity = widgetItem.getQuantity();

        if (isSelectedWidget(widget) || isDraggedWidget(widget))
        {
            if (!dragging)
            {
                rememberActive(key, cycle, itemId, quantity);
            }
            return true;
        }

        if (dragging)
        {
            return false;
        }

        if (client.getMouseCurrentButton() != 1)
        {
            return isRecentlyActive(key, cycle, itemId, quantity);
        }

        Point mouse = client.getMouseCanvasPosition();
        if (mouse == null)
        {
            return isRecentlyActive(key, cycle, itemId, quantity);
        }

        if (bounds.contains(mouse.getX(), mouse.getY()))
        {
            rememberActive(key, cycle, itemId, quantity);
            return true;
        }

        return isRecentlyActive(key, cycle, itemId, quantity);
    }

    private boolean isDraggedWidget(Widget widget)
    {
        Widget dragged = client.getDraggedWidget();
        if (dragged == null)
        {
            return false;
        }

        return dragged == widget
            || (dragged.getId() == widget.getId() && dragged.getIndex() == widget.getIndex());
    }

    private boolean isSelectedWidget(Widget widget)
    {
        if (!client.isWidgetSelected())
        {
            return false;
        }

        Widget selected = client.getSelectedWidget();
        if (selected == null)
        {
            return false;
        }

        return selected == widget
            || (selected.getId() == widget.getId() && selected.getIndex() == widget.getIndex());
    }

    private boolean isRecentlyActive(long key, int currentCycle, int itemId, int quantity)
    {
        ActiveState state = recentActiveStates.get(key);
        if (state == null)
        {
            return false;
        }

        if (state.itemId != itemId || state.quantity != quantity)
        {
            recentActiveStates.remove(key);
            return false;
        }

        if (currentCycle - state.lastCycle <= ACTIVE_LINGER_CYCLES)
        {
            return true;
        }

        recentActiveStates.remove(key);
        return false;
    }

    private long widgetKey(Widget widget)
    {
        return ((long) widget.getId() << 32) | (widget.getIndex() & 0xffffffffL);
    }

    private void rememberActive(long key, int cycle, int itemId, int quantity)
    {
        recentActiveStates.put(key, new ActiveState(cycle, itemId, quantity));
    }

    private boolean updateDragState()
    {
        boolean dragging = client.getDraggedWidget() != null;
        if (dragging)
        {
            recentActiveStates.clear();
            wasDragging = true;
        }
        else if (wasDragging)
        {
            recentActiveStates.clear();
            wasDragging = false;
        }
        return dragging;
    }

    private static final class ActiveState
    {
        private final int lastCycle;
        private final int itemId;
        private final int quantity;

        private ActiveState(int lastCycle, int itemId, int quantity)
        {
            this.lastCycle = lastCycle;
            this.itemId = itemId;
            this.quantity = quantity;
        }
    }

}

package com.wildyqol.freezetimers;

import com.google.common.collect.ImmutableSet;
import com.wildyqol.WildyQoLConfig;
import com.wildyqol.WildyQoLPlugin;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.gameval.SpotanimID;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;
import net.runelite.client.ui.overlay.infobox.Timer;
import net.runelite.client.util.RSTimeUnit;
import net.runelite.client.util.Text;

@Singleton
public class ExtendedFreezeTimersService
{
	private static final String CORE_TIMERS_GROUP = "timers";
	private static final String CORE_SHOW_FREEZES_KEY = "showFreezes";
	private static final int INACTIVITY_TIMEOUT_TICKS = 50;

	private static final Set<Integer> ANCIENT_SCEPTRES = buildAncientSceptres();
	private static final Set<Integer> SWAMPBARK_ITEMS = buildSwampbarkItems();
	private static final Map<Integer, FreezeType> GRAPHIC_TO_TYPE = buildGraphicMap();
	private static final Set<Integer> FORCED_MOVEMENT_SEEDS = buildForcedMovementSeeds();
	private static final int SPEAR_GRAPHIC_ID = SpotanimID.STUNNED_SHOVE;

	private final Client client;
	private final ConfigManager configManager;
	private final ChatMessageManager chatMessageManager;
	private final SpriteManager spriteManager;
	private final InfoBoxManager infoBoxManager;
	private final WildyQoLConfig config;

	private WildyQoLPlugin plugin;
	private Player currentOpponent;
	private String currentOpponentName;
	private int lastActivityTick = -1;
	private FreezeTimer activeTimer;
	private int freezeAppliedTick = -1;
	private int lastFrozenMessageTick = -1;
	private WorldPoint lastPoint;
	private boolean warnedDuplicate;
	private int lastSeedCount = -1;
	private boolean pendingForcedMovement;
	private int forcedMovementTick = -1;
	private final Set<Integer> lastStandardSpotAnims = new HashSet<>();

	@Inject
	public ExtendedFreezeTimersService(
		Client client,
		ConfigManager configManager,
		ChatMessageManager chatMessageManager,
		SpriteManager spriteManager,
		InfoBoxManager infoBoxManager,
		WildyQoLConfig config)
	{
		this.client = client;
		this.configManager = configManager;
		this.chatMessageManager = chatMessageManager;
		this.spriteManager = spriteManager;
		this.infoBoxManager = infoBoxManager;
		this.config = config;
	}

	public void startUp(WildyQoLPlugin plugin)
	{
		this.plugin = plugin;
		warnedDuplicate = false;
		lastSeedCount = -1;
		pendingForcedMovement = false;
		forcedMovementTick = -1;
		resetStandardSpotAnimTracking();
		if (!isEnabled())
		{
			return;
		}

		warnDuplicateTimersIfNeeded();
	}

	public void shutDown()
	{
		removeActiveTimer();
		removeFreezeTimerInfoBox();
		clearOpponent();
		resetStandardSpotAnimTracking();
		plugin = null;
		warnedDuplicate = false;
		pendingForcedMovement = false;
		forcedMovementTick = -1;
		lastSeedCount = -1;
	}

	public void onConfigChanged()
	{
		if (config.enableExtendedFreezeTimers())
		{
			warnedDuplicate = false;
			warnDuplicateTimersIfNeeded();
			lastSeedCount = -1;
			pendingForcedMovement = false;
			forcedMovementTick = -1;
			resetStandardSpotAnimTracking();
		}
		else
		{
			removeActiveTimer();
			clearOpponent();
			pendingForcedMovement = false;
			forcedMovementTick = -1;
			resetStandardSpotAnimTracking();
		}
	}

	public void onGameStateChanged(GameStateChanged event)
	{
		GameState state = event.getGameState();
		if (state == GameState.LOGGING_IN || state == GameState.HOPPING || state == GameState.CONNECTION_LOST || state == GameState.LOGIN_SCREEN)
		{
			removeActiveTimer();
			clearOpponent();
			pendingForcedMovement = false;
			forcedMovementTick = -1;
			lastSeedCount = -1;
			resetStandardSpotAnimTracking();
			return;
		}

		if (!isEnabled())
		{
			return;
		}

		if (state == GameState.LOGGED_IN)
		{
			lastSeedCount = -1;
		}
	}

	public void onInteractingChanged(InteractingChanged event)
	{
		if (!isEnabled())
		{
			return;
		}

		if (!(event.getSource() instanceof Player) || !(event.getTarget() instanceof Player))
		{
			return;
		}

		Player local = client.getLocalPlayer();
		if (local == null)
		{
			return;
		}

		Player candidate = null;
		if (event.getSource() == local)
		{
			candidate = (Player) event.getTarget();
		}
		else if (event.getTarget() == local)
		{
			candidate = (Player) event.getSource();
		}

		if (candidate == null)
		{
			return;
		}

		if (currentOpponent != null && Objects.equals(currentOpponentName, candidate.getName()))
		{
			refreshActivity();
			return;
		}

		setOpponent(candidate);
	}

	public void onAnimationChanged(AnimationChanged event)
	{
		if (!isEnabled())
		{
			return;
		}

		Actor actor = event.getActor();
		if (actor == null)
		{
			return;
		}

		if (actor == client.getLocalPlayer() || isOpponent(actor))
		{
			refreshActivity();
		}
	}

	public void onHitsplatApplied(HitsplatApplied event)
	{
		if (!isEnabled())
		{
			return;
		}

		Actor actor = event.getActor();
		if (actor == null)
		{
			return;
		}

		if (actor == client.getLocalPlayer() || isOpponent(actor))
		{
			refreshActivity();
		}
	}

	public void onPlayerDespawned(PlayerDespawned event)
	{
		if (!isEnabled())
		{
			return;
		}

		if (isOpponent(event.getPlayer()))
		{
			clearOpponent();
		}
	}

	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (event.getContainerId() != InventoryID.INV)
		{
			return;
		}

		ItemContainer container = event.getItemContainer();
		int currentSeedCount = countSeeds(container);
		if (lastSeedCount < 0)
		{
			lastSeedCount = currentSeedCount;
			return;
		}

		int previousSeedCount = lastSeedCount;
		lastSeedCount = currentSeedCount;

		if (!isForcedMovementProtectionEnabled())
		{
			return;
		}

		if (isFreezeTimerActive() && previousSeedCount >= 0 && currentSeedCount < previousSeedCount)
		{
			registerForcedMovement();
		}
	}

	public void onGraphicChanged(GraphicChanged event)
	{
		if (!isEnabled())
		{
			return;
		}

		Actor actor = event.getActor();
		if (actor != client.getLocalPlayer())
		{
			return;
		}

		int graphicId = actor.getGraphic();

		if (isForcedMovementProtectionEnabled() && isFreezeTimerActive() && actor.hasSpotAnim(SPEAR_GRAPHIC_ID))
		{
			registerForcedMovement();
		}

		FreezeType type = GRAPHIC_TO_TYPE.get(graphicId);
		if (type == null)
		{
			return;
		}

		int tickCount = client.getTickCount();

		if (!type.isAncient())
		{
			return;
		}

		// For ancient freezes, only allow processing on the same tick as the freeze chat message.
		if (type.isAncient() && lastFrozenMessageTick != tickCount)
		{
			return;
		}

		refreshActivity();

		// Replace with shorter freeze if a downgrade is detected on the same tick.
		if (isFreezeTimerActive() && freezeAppliedTick == tickCount && type.getBaseTicks() < activeTimer.getFreezeType().getBaseTicks())
		{
			startTimer(type);
			return;
		}

		// Reapply if we got frozen again.
		if (!isFreezeTimerActive() || type.getBaseTicks() >= activeTimer.getFreezeType().getBaseTicks() || freezeAppliedTick != tickCount)
		{
			startTimer(type);
		}
	}

	public void onGameTick(GameTick event)
	{
		if (!isEnabled())
		{
			return;
		}

		Player local = client.getLocalPlayer();
		if (local == null)
		{
			removeActiveTimer();
			clearOpponent();
			resetStandardSpotAnimTracking();
			return;
		}

		int tickCount = client.getTickCount();
		checkStandardFreezeSpotAnims(local);
		if (isForcedMovementProtectionEnabled() && isFreezeTimerActive() && local.hasSpotAnim(SPEAR_GRAPHIC_ID))
		{
			registerForcedMovement();
		}

		if (isFreezeTimerActive() && freezeAppliedTick != tickCount)
		{
			WorldPoint current = local.getWorldLocation();
			if (current != null && lastPoint != null && !current.equals(lastPoint))
			{
				if (!shouldIgnoreMovementClear(tickCount))
				{
					removeActiveTimer();
				}
			}
		}

		if (currentOpponent != null && lastActivityTick > -1 && tickCount - lastActivityTick > INACTIVITY_TIMEOUT_TICKS)
		{
			clearOpponent();
		}

		lastPoint = local.getWorldLocation();
	}

	public void onChatMessage(ChatMessage event)
	{
		if (!isEnabled())
		{
			return;
		}

		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		String message = Text.removeTags(event.getMessage());
		if ("You have been frozen!".equals(message))
		{
			lastFrozenMessageTick = client.getTickCount();
			startTimer(FreezeType.ICE_BARRAGE);
		}
	}

	private void startTimer(FreezeType type)
	{
		removeActiveTimer();

		Duration duration = calculateDuration(type);
		activeTimer = new FreezeTimer(type, duration, plugin);
		infoBoxManager.addInfoBox(activeTimer);
		activeTimer.setActive(true);
		spriteManager.getSpriteAsync(type.getSpriteId(), 0, activeTimer);
		activeTimer.setTooltip(type.getDisplayName());
		freezeAppliedTick = client.getTickCount();

		// If the core timer is still on, warn once.
		warnDuplicateTimersIfNeeded();
	}

	private Duration calculateDuration(FreezeType type)
	{
		long ticks = type.getBaseTicks();
		if (type.isAncient())
		{
			if (opponentHasAncientSceptre())
			{
				ticks = Math.round(ticks * 1.1d);
			}
		}
		else
		{
			ticks += countSwampbarkPieces();
		}

		ticks = Math.max(1L, ticks);
		return Duration.of(ticks, RSTimeUnit.GAME_TICKS);
	}

	private void removeActiveTimer()
	{
		if (activeTimer != null)
		{
			activeTimer.setActive(false);
			infoBoxManager.removeInfoBox(activeTimer);
			activeTimer = null;
		}

		freezeAppliedTick = -1;
		pendingForcedMovement = false;
		forcedMovementTick = -1;
	}

	private boolean isFreezeTimerActive()
	{
		return activeTimer != null && activeTimer.isActive();
	}

	private void removeFreezeTimerInfoBox()
	{
		if (activeTimer == null)
		{
			return;
		}

		infoBoxManager.removeInfoBox(activeTimer);
		activeTimer = null;
	}

	private void setOpponent(Player opponent)
	{
		currentOpponent = opponent;
		currentOpponentName = opponent != null ? opponent.getName() : null;
		refreshActivity();
	}

	private void clearOpponent()
	{
		currentOpponent = null;
		currentOpponentName = null;
		lastActivityTick = -1;
	}

	private boolean isOpponent(Actor actor)
	{
		return actor instanceof Player && currentOpponent != null && currentOpponent == actor;
	}

	private void refreshActivity()
	{
		lastActivityTick = client.getTickCount();
	}

	private void checkStandardFreezeSpotAnims(Player local)
	{
		Set<Integer> current = new HashSet<>();
		FreezeType newType = null;

		for (FreezeType type : FreezeType.values())
		{
			if (type.isAncient())
			{
				continue;
			}

			int graphicId = type.getGraphicId();
			if (!local.hasSpotAnim(graphicId))
			{
				continue;
			}

			current.add(graphicId);
			if (!lastStandardSpotAnims.contains(graphicId))
			{
				if (newType == null || type.getBaseTicks() > newType.getBaseTicks())
				{
					newType = type;
				}
			}
		}

		if (newType != null)
		{
			refreshActivity();
			startTimer(newType);
		}

		lastStandardSpotAnims.clear();
		lastStandardSpotAnims.addAll(current);
	}

	private void resetStandardSpotAnimTracking()
	{
		lastStandardSpotAnims.clear();
	}

	private boolean shouldIgnoreMovementClear(int tickCount)
	{
		if (!isForcedMovementProtectionEnabled() || !pendingForcedMovement)
		{
			return false;
		}

		if (forcedMovementTick != -1 && tickCount - forcedMovementTick > 1)
		{
			pendingForcedMovement = false;
			forcedMovementTick = -1;
			return false;
		}

		pendingForcedMovement = false;
		forcedMovementTick = -1;
		return true;
	}

	private void registerForcedMovement()
	{
		pendingForcedMovement = true;
		forcedMovementTick = client.getTickCount();
	}

	private int countSeeds(ItemContainer container)
	{
		if (container == null)
		{
			return 0;
		}

		int count = 0;
		Item[] items = container.getItems();
		if (items == null)
		{
			return 0;
		}

		for (Item item : items)
		{
			if (item == null)
			{
				continue;
			}

			int itemId = item.getId();
			if (itemId <= 0)
			{
				continue;
			}

			if (FORCED_MOVEMENT_SEEDS.contains(itemId))
			{
				count += item.getQuantity();
			}
		}

		return count;
	}

	private boolean opponentHasAncientSceptre()
	{
		Player opponent = currentOpponent;
		if (opponent == null)
		{
			return false;
		}

		for (int itemId : getEquipmentIds(opponent))
		{
			if (ANCIENT_SCEPTRES.contains(itemId))
			{
				return true;
			}
		}

		return false;
	}

	private int countSwampbarkPieces()
	{
		Player opponent = currentOpponent;
		if (opponent == null)
		{
			return 0;
		}

		int count = 0;
		for (int itemId : getEquipmentIds(opponent))
		{
			if (SWAMPBARK_ITEMS.contains(itemId))
			{
				count++;
			}
		}

		return count;
	}

	private int[] getEquipmentIds(Player player)
	{
		PlayerComposition comp = player.getPlayerComposition();
		if (comp == null || comp.getEquipmentIds() == null)
		{
			return new int[0];
		}

		int[] equipmentIds = comp.getEquipmentIds();
		int[] fixed = new int[equipmentIds.length];
		for (int i = 0; i < equipmentIds.length; i++)
		{
			int id = equipmentIds[i];
			fixed[i] = id > PlayerComposition.ITEM_OFFSET ? id - PlayerComposition.ITEM_OFFSET : id;
		}

		return fixed;
	}

	private boolean isForcedMovementProtectionEnabled()
	{
		return isEnabled() && config.preserveFreezeTimerOnForcedMovement();
	}

	private boolean isEnabled()
	{
		return plugin != null && config.enableExtendedFreezeTimers();
	}

	private void warnDuplicateTimersIfNeeded()
	{
		if (warnedDuplicate || !config.warnDuplicateFreezeTimers())
		{
			return;
		}

		Boolean coreFreeze = configManager.getConfiguration(CORE_TIMERS_GROUP, CORE_SHOW_FREEZES_KEY, Boolean.class);
		if (coreFreeze != null && !coreFreeze)
		{
			return;
		}

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.runeLiteFormattedMessage("<col=ff9040>Wildy QoL:</col> Extended freeze timers are active, but Timers & Buffs freeze timers are still enabled. Disable \"Freeze timer\" in Timers & Buffs to avoid duplicates.")
			.build());
		warnedDuplicate = true;
	}

	private static Set<Integer> buildAncientSceptres()
	{
		Set<Integer> ids = new HashSet<>();
		addVariations(ids, ItemID.ANCIENT_SCEPTRE);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_BLOOD);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_ICE);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_SMOKE);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_SHADOW);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_TROUVER);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_BLOOD_TROUVER);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_ICE_TROUVER);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_SMOKE_TROUVER);
		addVariations(ids, ItemID.ANCIENT_SCEPTRE_SHADOW_TROUVER);
		return ids;
	}

	private static Set<Integer> buildSwampbarkItems()
	{
		return ImmutableSet.of(
			ItemID.SWAMPBARK_HELM,
			ItemID.SWAMPBARK_BODY,
			ItemID.SWAMPBARK_LEGS
		);
	}

	private static Set<Integer> buildForcedMovementSeeds()
	{
		Set<Integer> seeds = new HashSet<>();
		addVariations(seeds, ItemID.MITHRIL_SEED);
		addVariations(seeds, ItemID.ADAMANT_SEED);
		return seeds;
	}

	private static Map<Integer, FreezeType> buildGraphicMap()
	{
		Map<Integer, FreezeType> map = new HashMap<>();
		for (FreezeType type : FreezeType.values())
		{
			map.put(type.getGraphicId(), type);
		}
		return map;
	}

	private static void addVariations(Set<Integer> ids, int itemId)
	{
		ids.add(itemId);
		ids.addAll(ItemVariationMapping.getVariations(itemId));
	}

	private enum FreezeType
	{
		BIND("Bind", SpriteID.Magicon2.BIND, SpotanimID.BIND_IMPACT, 8, false),
		SNARE("Snare", SpriteID.Magicon2.SNARE, SpotanimID.SNARE_IMPACT, 16, false),
		ENTANGLE("Entangle", SpriteID.Magicon2.ENTANGLE, SpotanimID.ENTANGLE_IMPACT, 24, false),
		ICE_RUSH("Ice rush", SpriteID.Magicon2.ICE_RUSH, SpotanimID.ICE_RUSH_IMPACT, 8, true),
		ICE_BURST("Ice burst", SpriteID.Magicon2.ICE_BURST, SpotanimID.ICE_BLITZ_IMPACT, 16, true),
		ICE_BLITZ("Ice blitz", SpriteID.Magicon2.ICE_BLITZ, SpotanimID.ICE_BURST_IMPACT, 24, true),
		ICE_BARRAGE("Ice barrage", SpriteID.Magicon2.ICE_BARRAGE, SpotanimID.ICE_BARRAGE_IMPACT, 32, true);

		private final String displayName;
		private final int spriteId;
		private final int graphicId;
		private final int baseTicks;
		private final boolean ancient;

		FreezeType(String displayName, int spriteId, int graphicId, int baseTicks, boolean ancient)
		{
			this.displayName = displayName;
			this.spriteId = spriteId;
			this.graphicId = graphicId;
			this.baseTicks = baseTicks;
			this.ancient = ancient;
		}

		int getSpriteId()
		{
			return spriteId;
		}

		int getGraphicId()
		{
			return graphicId;
		}

		int getBaseTicks()
		{
			return baseTicks;
		}

		boolean isAncient()
		{
			return ancient;
		}

		String getDisplayName()
		{
			return displayName;
		}
	}

	private class FreezeTimer extends Timer
	{
		private FreezeType freezeType;
		private boolean active;

		FreezeTimer(FreezeType freezeType, Duration duration, WildyQoLPlugin plugin)
		{
			super(duration.toMillis(), ChronoUnit.MILLIS, null, plugin);
			this.freezeType = freezeType;
			setPriority(InfoBoxPriority.MED);
		}

		void setFreezeType(FreezeType freezeType)
		{
			this.freezeType = freezeType;
		}

		void setActive(boolean active)
		{
			this.active = active;
		}

		boolean isActive()
		{
			return active && super.render();
		}

		FreezeType getFreezeType()
		{
			return freezeType;
		}

		@Override
		public boolean render()
		{
			return isEnabled()
				&& active
				&& client.getGameState() == GameState.LOGGED_IN
				&& super.render();
		}

		@Override
		public boolean cull()
		{
			return false;
		}

		@Override
		public String getName()
		{
			return freezeType.getDisplayName();
		}
	}
}

package com.wildyqol;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class WildyQoLPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(WildyQoLPlugin.class);
		RuneLite.main(args);
	}
} 
