/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

import java.lang.reflect.Method;
import net.runelite.client.config.ConfigItem;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.feature.Feature;
import no.elg.ii.inventory.InventoryState;
import org.junit.Test;

public abstract class FeatureTestMother<T extends Feature> {

  /**
   * @return A {@link org.mockito.Spy} instance of this feature
   */
  public abstract T createNewInstance();

  @Test
  public void configTest() {
    Feature feature = createNewInstance();

    try {
      Method method = InstantInventoryConfig.class.getMethod(feature.getConfigKey());
      ConfigItem configItemAnnotation = method.getAnnotation(ConfigItem.class);
      assertNotNull(configItemAnnotation);
      assertEquals("key name in ConfigItem must match feature.getConfigKey()",
        feature.getConfigKey(), configItemAnnotation.keyName());
    } catch (NoSuchMethodException e) {
      fail("Failed to find a field in " + InstantInventoryConfig.class.getSimpleName()
        + " which matches the config key: " + feature.getConfigKey());
    }
  }

  @Test
  public void reset_calls_state_resetAll() {
    Feature feature = createNewInstance();
    InventoryState mockState = mock(InventoryState.class);
    doReturn(mockState).when(feature).getState();
    doNothing().when(mockState).resetAll();

    feature.reset();
    verify(mockState).resetAll();
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.test;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

import java.util.function.BooleanSupplier;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.InstantInventoryPlugin;
import no.elg.ii.feature.CleanHerbFeature;
import no.elg.ii.feature.DepositFeature;
import no.elg.ii.feature.DropFeature;
import no.elg.ii.feature.EquipFeature;
import no.elg.ii.feature.Feature;
import no.elg.ii.feature.HideFeature;
import no.elg.ii.feature.WithdrawFeature;
import no.elg.ii.inventory.InventoryService;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.service.WidgetService;
import org.mockito.stubbing.Answer;

public class TestSetup {

  public static CleanHerbFeature createNewCleanHerbFeature() {
    CleanHerbFeature feature = spy(new CleanHerbFeature());
    feature.client = mock(Client.class);

    setupCommonFeature(feature, feature.client);
    return feature;
  }

  public static DropFeature createNewDropFeature() {
    DropFeature feature = spy(new DropFeature());
    setupHideFeature(feature);
    return feature;
  }

  public static DepositFeature createNewDepositFeature() {
    DepositFeature feature = spy(new DepositFeature());
    setupHideFeature(feature);
    return feature;
  }

  public static EquipFeature createNewEquipFeature() {
    EquipFeature feature = spy(new EquipFeature());
    return feature;
  }

  public static WithdrawFeature createNewWithdrawFeature() {
    WithdrawFeature feature = spy(new WithdrawFeature());
    return feature;
  }

  private static void setupCommonFeature(Feature feature, Client client) {
    var inventoryService = mock(InventoryService.class);
    var widgetService = mock(WidgetService.class);

    InventoryState inventoryState = new InventoryState(spy(new InstantInventoryConfig() {
    }), client, inventoryService, widgetService);
    doReturn(inventoryState).when(feature).getState();
  }

  private static void setupHideFeature(HideFeature feature) {
    setupCommonFeature(feature, mock(Client.class));
    feature.clientThread = TestSetup.mockedClientThread();
    InstantInventoryPlugin plugin = feature.plugin = mock(InstantInventoryPlugin.class);
//    doReturn(EMPTY_WIDGET).when(plugin).inventoryItems(any());
  }

  public static ClientThread mockedClientThread() {
    ClientThread clientThread = mock(ClientThread.class);

    Answer<Void> runnableAnswer = invocation -> {
      invocation.getArgument(0, Runnable.class).run();
      return null;
    };
    doAnswer(runnableAnswer).when(clientThread).invoke(any(Runnable.class));
    doAnswer(runnableAnswer).when(clientThread).invokeLater(any(Runnable.class));

    doAnswer(it -> it.getArgument(0, BooleanSupplier.class).getAsBoolean()).when(clientThread)
      .invoke(any(BooleanSupplier.class));
    doAnswer(it -> it.getArgument(0, BooleanSupplier.class).getAsBoolean()).when(clientThread)
      .invokeLater(any(BooleanSupplier.class));

    return clientThread;
  }

}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.test;

import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;

import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import no.elg.ii.FeatureManager;
import no.elg.ii.Features;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.InstantInventoryPlugin;
import no.elg.ii.feature.CleanHerbFeature;
import no.elg.ii.feature.DepositFeature;
import no.elg.ii.feature.DropFeature;
import no.elg.ii.feature.EquipFeature;
import no.elg.ii.feature.WithdrawFeature;
import no.elg.ii.inventory.InventoryService;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.service.WidgetService;
import org.junit.Before;
import org.mockito.Answers;
import org.mockito.Mock;

public class IntegrationTestHelper {

  protected InstantInventoryPlugin plugin;
  @Mock(answer = Answers.CALLS_REAL_METHODS)
  protected InstantInventoryConfig instantInventoryConfig;
  @Mock
  protected EventBus eventBus;
  @Mock
  protected Client client;
  @Mock
  protected InventoryService inventoryService;
  @Mock
  protected WidgetService widgetService;

  protected FeatureManager featureManager;
  protected Features features;

  protected DropFeature dropFeature;
  protected CleanHerbFeature cleanHerbFeature;
  protected DepositFeature depositFeature;
  protected EquipFeature equipFeature;
  protected WithdrawFeature withdrawFeature;
  protected InventoryState inventoryState;
  protected ClientThread clientThread;

  @Before
  public void setUp() {
    features = new Features(
      TestSetup.createNewDropFeature(),
      TestSetup.createNewCleanHerbFeature(),
      TestSetup.createNewDepositFeature(),
      TestSetup.createNewEquipFeature(),
      TestSetup.createNewWithdrawFeature()
    );
    dropFeature = features.getDropFeature();
    cleanHerbFeature = features.getCleanHerbFeature();
    depositFeature = features.getDepositFeature();
    equipFeature = features.getEquipFeature();
    withdrawFeature = features.getWithdrawFeature();

    featureManager = spy(new FeatureManager(eventBus, instantInventoryConfig, features, clientThread));

    inventoryState = new InventoryState(instantInventoryConfig, client, inventoryService, widgetService);
    doReturn(inventoryState).when(dropFeature).getState();
    doReturn(inventoryState).when(cleanHerbFeature).getState();
    doReturn(inventoryState).when(depositFeature).getState();

    plugin = spy(new InstantInventoryPlugin(client, eventBus, instantInventoryConfig, featureManager, inventoryState, clientThread, inventoryService));
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature;

import static no.elg.ii.feature.DropFeature.DROP_CONFIG_KEY;
import static no.elg.ii.inventory.InventoryState.DEFAULT_MAX_UNMODIFIED_TICKS;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.inventory.InventoryService;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.service.WidgetService;
import no.elg.ii.test.FeatureTestMother;
import no.elg.ii.test.TestSetup;
import org.junit.Test;

public class DropFeatureTest extends FeatureTestMother<DropFeature> {

  @Override
  public DropFeature createNewInstance() {
    return TestSetup.createNewDropFeature();
  }

  @Test
  public void onMenuOptionClicked_doNothingWhenWidgetIsNull() {
    int index = 1;
    int itemId = 2;
    DropFeature dropFeature = createNewInstance();

    MenuEntry menuEntry = mock(MenuEntry.class);
    doReturn(DropFeature.DROP_OPTION).when(menuEntry).getOption();
    doReturn(itemId).when(menuEntry).getItemId();
    doReturn(null).when(menuEntry).getWidget();

    MenuOptionClicked event = new MenuOptionClicked(menuEntry);

    assertFalse(dropFeature.getState().getSlot(index).hasValidItemId());
    dropFeature.onMenuOptionClicked(event);
    assertFalse(dropFeature.getState().getSlot(index).hasValidItemId());
  }

  @Test
  public void onMenuOptionClicked_different_menuEntry_clicked_does_not_update_state() {
    int index = 1;
    int itemId = 2;
    DropFeature dropFeature = createNewInstance();

    Widget widget = mock(Widget.class);
    doReturn(index).when(widget).getIndex();

    MenuEntry menuEntry = mock(MenuEntry.class);
    doReturn("not drop").when(menuEntry).getOption();
    doReturn(itemId).when(menuEntry).getItemId();
    doReturn(widget).when(menuEntry).getWidget();

    MenuOptionClicked event = new MenuOptionClicked(menuEntry);

    assertFalse(dropFeature.getState().getSlot(index).hasValidItemId());
    dropFeature.onMenuOptionClicked(event);
    assertFalse(dropFeature.getState().getSlot(index).hasValidItemId());
  }

  @Test
  public void stateResetWhenItemNotDropped() {
    int index = 1;
    int itemId = 2;
    DropFeature feature = createNewInstance();

    Widget widget = mock(Widget.class);
    doReturn(index).when(widget).getIndex();
    doReturn(itemId).when(widget).getItemId();

    MenuEntry menuEntry = mock(MenuEntry.class);
    doReturn(DropFeature.DROP_OPTION).when(menuEntry).getOption();
    doReturn(itemId).when(menuEntry).getItemId();
    doReturn(widget).when(menuEntry).getWidget();

    InstantInventoryConfig config = spy(new InstantInventoryConfig() {
    });
    Client client = mock(Client.class);
    var inventoryService = mock(InventoryService.class);
    var widgetService = mock(WidgetService.class);
    InventoryState inventoryState = new InventoryState(config, client, inventoryService, widgetService);
    doReturn(inventoryState).when(feature).getState();

    MenuOptionClicked event = new MenuOptionClicked(menuEntry);

    assertFalse(feature.getState().getSlot(index).hasValidItemId());
    feature.onMenuOptionClicked(event);
    assertTrue(feature.getState().getSlot(index).hasValidItemId());
    assertEquals(itemId, feature.getState().getSlot(index).getItemId());

    feature.getState().validateState(index, null);
    assertTrue("State was reset when it should not have been", feature.getState().getSlot(index).hasValidItemId());

    doReturn(DEFAULT_MAX_UNMODIFIED_TICKS).when(client).getTickCount();
    feature.getState().validateState(index, null);
    assertFalse("State was NOT reset when it should have been", feature.getState().getSlot(index).hasValidItemId());
  }

  @Test
  public void configKey_is_CLEAN_CONFIG_KEY() {
    DropFeature feature = createNewInstance();
    assertEquals(DROP_CONFIG_KEY, feature.getConfigKey());
  }

  @Test
  public void afterEnablingItWillBeShownOnSomeWidget() {
    HideFeature dropFeature = createNewInstance();
//    assertFalse(dropFeature.getWidgets().isEmpty());
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature;

import no.elg.ii.test.FeatureTestMother;
import no.elg.ii.test.TestSetup;
import org.junit.Test;

public class DepositFeatureTest extends FeatureTestMother<DepositFeature> {

  @Override
  public DepositFeature createNewInstance() {
    return TestSetup.createNewDepositFeature();
  }

  @Test
  public void afterEnablingItWillBeShownOnSomeWidget() {
    DepositFeature dropFeature = createNewInstance();
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature;

import static net.runelite.api.ItemID.FIRE_CAPE;
import static net.runelite.api.ItemID.GRIMY_GUAM_LEAF;
import static no.elg.ii.feature.CleanHerbFeature.CLEAN_CONFIG_KEY;
import static no.elg.ii.feature.CleanHerbFeature.CLEAN_OPTION;
import static no.elg.ii.inventory.slot.InventorySlot.INVALID_ITEM_ID;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;

import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import no.elg.ii.test.FeatureTestMother;
import no.elg.ii.test.TestSetup;
import org.junit.Test;

public class CleanHerbFeatureTest extends FeatureTestMother<CleanHerbFeature> {

  @Override
  public CleanHerbFeature createNewInstance() {
    return TestSetup.createNewCleanHerbFeature();
  }

  @Test
  public void configKey_is_CLEAN_CONFIG_KEY() {
    CleanHerbFeature feature = createNewInstance();
    assertEquals(CLEAN_CONFIG_KEY, feature.getConfigKey());
  }

  @Test
  public void onMenuOptionClicked_happy_path() {
    onMenuOptionClicked_test(GRIMY_GUAM_LEAF, GRIMY_GUAM_LEAF, true, CLEAN_OPTION, 99);
  }

  @Test
  public void onMenuOptionClicked_no_widget() {
    onMenuOptionClicked_test(INVALID_ITEM_ID, GRIMY_GUAM_LEAF, false, CLEAN_OPTION, 99);
  }

  @Test
  public void onMenuOptionClicked_not_clean_option() {
    onMenuOptionClicked_test(INVALID_ITEM_ID, GRIMY_GUAM_LEAF, true, "not clean", 99);
  }

  @Test
  public void onMenuOptionClicked_not_a_herb() {
    onMenuOptionClicked_test(INVALID_ITEM_ID, FIRE_CAPE, true, CLEAN_OPTION, 99);
  }

  @Test
  public void onMenuOptionClicked_too_low_level() {
    onMenuOptionClicked_test(INVALID_ITEM_ID, GRIMY_GUAM_LEAF, true, CLEAN_OPTION, 1);
  }

  private void onMenuOptionClicked_test(int stateItemId, int itemId, boolean hasWidget, String menuEntryOption, int level) {
    int index = 1;
    CleanHerbFeature feature = createNewInstance();

    Widget widget = mock(Widget.class);
    doReturn(index).when(widget).getIndex();

    MenuEntry menuEntry = mock(MenuEntry.class);
    doReturn(menuEntryOption).when(menuEntry).getOption();
    doReturn(itemId).when(menuEntry).getItemId();
    doReturn(hasWidget ? widget : null).when(menuEntry).getWidget();
    Client client = feature.client;
    doReturn(level).when(client).getBoostedSkillLevel(any());

    MenuOptionClicked event = new MenuOptionClicked(menuEntry);

    assertFalse(feature.getState().getSlot(index).hasValidItemId());
    feature.onMenuOptionClicked(event);
    assertEquals(stateItemId, feature.getState().getSlot(index).getItemId());
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import no.elg.ii.test.IntegrationTestHelper;
import org.junit.Test;

public class FeatureManagerTest extends IntegrationTestHelper {


  @Test
  public void updateFeatureStatus() {
    featureManager.updateFeatureStatus(dropFeature, false);
    verify(dropFeature, never()).onEnable();
    featureManager.updateFeatureStatus(dropFeature, false);
    verify(dropFeature, never()).onEnable();
    featureManager.updateFeatureStatus(dropFeature, true);
    verify(dropFeature).onEnable();
    featureManager.updateFeatureStatus(dropFeature, true);
    verify(dropFeature).onEnable();

    verify(dropFeature, never()).onDisable();
    featureManager.updateFeatureStatus(dropFeature, false);
    verify(dropFeature).onDisable();
    featureManager.updateFeatureStatus(dropFeature, false);
    verify(dropFeature).onDisable();
  }

  @Test
  public void enableFeature() {
    featureManager.enableFeature(dropFeature);

    verify(eventBus).register(dropFeature);
    verify(dropFeature).onEnable();
    verify(dropFeature).reset();
    assertEquals(1, featureManager.getActiveFeatures().size());
    assertTrue(featureManager.getActiveFeatures().contains(dropFeature));
  }

  @Test
  public void disableFeature() {
    featureManager.enableFeature(dropFeature);
    featureManager.disableFeature(dropFeature);

    verify(eventBus).unregister(dropFeature);
    verify(dropFeature).onDisable();
    //Once to enable, once to disable
    verify(dropFeature, times(2)).reset();
    assertTrue(featureManager.getActiveFeatures().isEmpty());
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.inventory;

import static no.elg.ii.inventory.InventoryState.DEFAULT_MAX_UNMODIFIED_TICKS;
import static no.elg.ii.inventory.slot.InventorySlot.INVALID_ITEM_ID;
import static no.elg.ii.inventory.slot.InventorySlot.NO_CHANGED_TICK;
import static no.elg.ii.inventory.slot.InventorySlot.RESET_ITEM_ID;
import static no.elg.ii.inventory.slot.InventorySlot.RESET_SLOT;
import static no.elg.ii.util.InventoryUtil.INVENTORY_SIZE;
import static no.elg.ii.util.WidgetUtils.FULLY_OPAQUE;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

import net.runelite.api.Client;
import net.runelite.api.Item;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.service.WidgetService;
import org.junit.Before;
import org.junit.Test;

public class InventoryStateTest {

  private InventoryState inventoryState;
  private InstantInventoryConfig config;
  private Client client;

  private final int index = 3;
  private final int itemId = 1;
  private final int quantity = 2;
  private final Item item = new Item(itemId, quantity);

  @Before
  public void setUp() {
    config = spy(InstantInventoryConfig.class);
    client = mock(Client.class);
    var inventoryService = mock(InventoryService.class);
    var widgetService = mock(WidgetService.class);

    inventoryState = new InventoryState(config, client, inventoryService, widgetService);
  }

  private void setAll(int itemId) {
    for (int index = 0; index < INVENTORY_SIZE; index++) {
      inventoryState.setSlot(index, itemId, 0, FULLY_OPAQUE);
    }
  }

  @Test
  public void initially_invalid() {
    int index = 0;
    assertSame(inventoryState.getSlot(index), InventorySlot.UNMODIFIED_SLOT);
  }

  @Test
  public void resetAll_makesAllIndexesInvalid() {
    doReturn(123).when(client).getTickCount();
    setAll(1234);

    for (int i = 0; i < INVENTORY_SIZE; i++) {
      InventorySlot slot = inventoryState.getSlot(i);

      assertTrue(slot.hasValidItemId());
      assertTrue(slot.hasChangedTick());
    }

    inventoryState.resetAll();

    for (int i = 0; i < INVENTORY_SIZE; i++) {
      InventorySlot slot = inventoryState.getSlot(i);

      assertFalse(slot.hasValidItemId());
      assertFalse(slot.hasChangedTick());
      assertSame(slot, RESET_SLOT);
    }
  }

  @Test
  public void validateState_differentItemIdFromCurrent_resets() {
    doReturn(2).when(client).getTickCount();
    inventoryState.setSlot(index, itemId, 0, FULLY_OPAQUE);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(2, inventoryState.getSlot(index).getChangedTick());

    inventoryState.validateState(index, item);

    assertEquals(RESET_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_timeout_resets_default_is_2() {
    inventoryState.setSlot(index, itemId, quantity, FULLY_OPAQUE);

    assertEquals(1, inventoryState.getSlot(index).getItemId());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());

    doReturn(DEFAULT_MAX_UNMODIFIED_TICKS).when(client).getTickCount();

    inventoryState.validateState(index, item);

    assertEquals(RESET_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_timeout_resets_not_before_configurable_ticks() {

    doReturn(DEFAULT_MAX_UNMODIFIED_TICKS + 1).when(config).maxUnmodifiedTicks();
    inventoryState.setSlot(index, itemId, quantity, FULLY_OPAQUE);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());

    doReturn(DEFAULT_MAX_UNMODIFIED_TICKS).when(client).getTickCount();

    inventoryState.validateState(index, item);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_timeout_resets_customizable_time() {
    int maxUnmodifiedTicks = DEFAULT_MAX_UNMODIFIED_TICKS + 1;
    doReturn(maxUnmodifiedTicks).when(config).maxUnmodifiedTicks();
    inventoryState.setSlot(index, itemId, 0, FULLY_OPAQUE);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());

    doReturn(maxUnmodifiedTicks).when(client).getTickCount();

    inventoryState.validateState(index, item);

    assertEquals(RESET_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_new_item_when_invalid_does_not_change_state() {
    int index = 0;

    assertEquals(INVALID_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());

    inventoryState.validateState(index, item);

    assertEquals(INVALID_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_not_timeout_and_same_item_does_not_reset() {
    inventoryState.setSlot(index, itemId, quantity, FULLY_OPAQUE);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(quantity, inventoryState.getSlot(index).getQuantity());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());

    inventoryState.validateState(0, item);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(quantity, inventoryState.getSlot(index).getQuantity());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii;

import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import net.runelite.api.events.GameStateChanged;
import net.runelite.client.events.ConfigChanged;
import no.elg.ii.test.IntegrationTestHelper;
import org.junit.Test;

public class InstantInventoryPluginTest extends IntegrationTestHelper {

  @Test
  public void startUp_calls_updateAllFeatures() {
    plugin.startUp();
    verify(featureManager).updateAllFeatureStatus();
  }

  @Test
  public void shutDown_disables_all_features() {
    plugin.shutDown();
    verify(featureManager).disableAllFeatures();
  }

  @Test
  public void onGameStateChanged_calls_nothing_on_incorrect_group() {
    plugin.startUp();
    plugin.onGameStateChanged(new GameStateChanged());

    verify(dropFeature, times(2)).reset();
    verify(cleanHerbFeature, times(2)).reset();
  }

  @Test
  public void onConfigChanged_calls_updateAllFeatureStatus_on_correct_group() {
    ConfigChanged configChanged = new ConfigChanged();
    configChanged.setGroup(InstantInventoryConfig.GROUP);
    plugin.onConfigChanged(configChanged);
    verify(featureManager).updateAllFeatureStatus();
  }

  @Test
  public void onConfigChanged_calls_nothing_on_incorrect_group() {
    ConfigChanged configChanged = new ConfigChanged();
    configChanged.setGroup("");
    plugin.onConfigChanged(configChanged);
    verify(featureManager, never()).updateAllFeatureStatus();
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import java.util.Arrays;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import org.slf4j.LoggerFactory;

public class LivePluginTest {

  @SuppressWarnings("unchecked")
  public static void main(String[] args) throws Exception {
    ExternalPluginManager.loadBuiltin(InstantInventoryPlugin.class);
    var argsList = Arrays.asList(args);
    if (argsList.contains("--trace")) {

      final Logger logger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
      logger.setLevel(Level.TRACE);

      //Spams too much
      final Logger taskScheduler = (Logger) LoggerFactory.getLogger("net.runelite.client.task.Scheduler");
      taskScheduler.setLevel(Level.DEBUG);

      String[] argsNoTrace = Arrays.stream(args).filter(s -> !s.equalsIgnoreCase("--trace")).toArray(String[]::new);
      RuneLite.main(argsNoTrace);
    } else {
      RuneLite.main(args);
    }
  }
}
/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.util;

import java.util.HashMap;
import java.util.Map;
import lombok.Data;
import net.runelite.api.ItemID;

@Data
public class HerbInfo {

  /**
   * Map of {@link ItemID} from grimy herbs to cleaned herbs
   */
  public static Map<Integer, HerbInfo> HERBS = new HashMap<>();

  static {
    HERBS.put(ItemID.GRIMY_ROGUES_PURSE, new HerbInfo(ItemID.ROGUES_PURSE, 3));
    HERBS.put(ItemID.GRIMY_SNAKE_WEED, new HerbInfo(ItemID.SNAKE_WEED, 3));
    HERBS.put(ItemID.GRIMY_ARDRIGAL, new HerbInfo(ItemID.ARDRIGAL, 3));
    HERBS.put(ItemID.GRIMY_SITO_FOIL, new HerbInfo(ItemID.SITO_FOIL, 3));
    HERBS.put(ItemID.GRIMY_VOLENCIA_MOSS, new HerbInfo(ItemID.VOLENCIA_MOSS, 3));
    HERBS.put(ItemID.GRIMY_GUAM_LEAF, new HerbInfo(ItemID.GUAM_LEAF, 3));
    HERBS.put(ItemID.GRIMY_MARRENTILL, new HerbInfo(ItemID.MARRENTILL, 5));
    HERBS.put(ItemID.GRIMY_TARROMIN, new HerbInfo(ItemID.TARROMIN, 11));
    HERBS.put(ItemID.GRIMY_HARRALANDER, new HerbInfo(ItemID.HARRALANDER, 20));
    HERBS.put(ItemID.GRIMY_RANARR_WEED, new HerbInfo(ItemID.RANARR_WEED, 25));
    HERBS.put(ItemID.GRIMY_IRIT_LEAF, new HerbInfo(ItemID.IRIT_LEAF, 40));
    HERBS.put(ItemID.GRIMY_AVANTOE, new HerbInfo(ItemID.AVANTOE, 48));
    HERBS.put(ItemID.GRIMY_KWUARM, new HerbInfo(ItemID.KWUARM, 54));
    HERBS.put(ItemID.GRIMY_SNAPDRAGON, new HerbInfo(ItemID.SNAPDRAGON, 59));
    HERBS.put(ItemID.GRIMY_CADANTINE, new HerbInfo(ItemID.CADANTINE, 65));
    HERBS.put(ItemID.GRIMY_DWARF_WEED, new HerbInfo(ItemID.DWARF_WEED, 70));
    HERBS.put(ItemID.GRIMY_TORSTOL, new HerbInfo(ItemID.TORSTOL, 75));
    HERBS.put(ItemID.GRIMY_LANTADYME, new HerbInfo(ItemID.LANTADYME, 67));
    HERBS.put(ItemID.GRIMY_TOADFLAX, new HerbInfo(ItemID.TOADFLAX, 30));

    // Chambers of Xeric herbs
    HERBS.put(ItemID.GRIMY_GOLPAR, new HerbInfo(ItemID.GOLPAR, 47));
    HERBS.put(ItemID.GRIMY_BUCHU_LEAF, new HerbInfo(ItemID.BUCHU_LEAF, 52));
    HERBS.put(ItemID.GRIMY_NOXIFER, new HerbInfo(ItemID.NOXIFER, 60));
  }

  private final int cleanItemId;
  private final int minLevel;


}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.Data;
import net.runelite.api.Item;

@Data
public class IndexedItem {
  private final int index;
  @Nonnull
  private final Item item;

  @Nullable
  public static IndexedItem of(int index, @Nullable Item item) {
    if (item == null) {
      return null;
    }
    return new IndexedItem(index, item);
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import javax.annotation.Nonnull;
import net.runelite.api.widgets.Widget;

public class Util {
  public static final int NO_MENU_OPTION_NUMBER = -1;
  public static final int TICK_LENGTH_MS = 600;

  public static int getNumberFromMenuOption(String text, @Nonnull Widget widget) {
    try {
      String substring = text.substring(text.indexOf('-') + 1);
      int quantity;
      if ("All".equals(substring)) {
        quantity = Integer.MAX_VALUE;
      } else if ("All-but-1".equalsIgnoreCase(substring)) {
        quantity = widget.getItemQuantity() - 1;
      } else {
        quantity = Integer.parseInt(substring);
      }
      assert quantity > 0;
      return quantity;
    } catch (NumberFormatException | IndexOutOfBoundsException e) {
      return NO_MENU_OPTION_NUMBER;
    }
  }

  public static int coerceIn(int value, int min, int max) {
    return Math.max(min, Math.min(max, value));
  }

  private Util() {
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import com.google.common.collect.Streams;
import lombok.Data;
import net.runelite.api.widgets.Widget;

@Data
public class IndexedWidget implements Comparable<IndexedWidget> {

  private final int index;
  private final Widget widget;

  @Override
  public int compareTo(IndexedWidget o) {
    return Integer.compare(index, o.index);
  }

  @SuppressWarnings("UnstableApiUsage")
  public static final Streams.FunctionWithIndex<Widget, IndexedWidget> indexWidget = (from, index) -> new IndexedWidget((int) index, from);
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import javax.annotation.Nonnull;
import net.runelite.api.Item;
import net.runelite.api.NullItemID;
import net.runelite.api.widgets.Widget;

public final class WidgetUtils {
  private WidgetUtils() {
  }

  /**
   * Item is fully transparent, i.e., not visible
   */
  public static final int FULLY_TRANSPARENT = 255;

  /**
   * The opacity of a bank item with a quantity of zero
   */
  public static final int ZERO_QUANTITY_BANK_ITEM_OPACITY = 120;

  /**
   * Item is fully opaque, i.e., visible
   */
  public static final int FULLY_OPAQUE = 0;

  /**
   * This is the item id used by {@code clientscript}s to set a slot as empty
   *
   * @see <a href="https://github.com/runelite/runelite/wiki/Working-with-client-scripts">Working with client scripts</a>
   * @see <a href="https://github.com/Joshua-F/cs2-scripts">cs2-scripts</a>
   * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,bankmain_drawitem%5D.cs2#L41">Example: [proc,bankmain_drawitem].cs2</a>
   */
  public static final int THE_EMPTY_ITEM_ID = NullItemID.NULL_6512;

  @Nonnull
  public static String debugInfo(@Nonnull Widget widget) {
    return widget.getName() + " id: " + widget.getItemId() + ", index: " + widget.getIndex() + ", quantity: " + widget.getItemQuantity() + " opacity: " + widget.getOpacity();
  }

  @Nonnull
  public static String debugInfo(@Nonnull Item item) {
    return "id: " + item.getId() + ", quantity: " + item.getQuantity();
  }

  /**
   * There is no method to call to check if a slot is not empty, so we just check if they appear to be empty
   */
  public static boolean isEmpty(@Nonnull Widget widget) {
    return widget.isHidden()
      || widget.getName().isEmpty()
      || widget.getOpacity() == FULLY_TRANSPARENT
      || widget.getItemId() == THE_EMPTY_ITEM_ID;
  }

  public static boolean isNotEmpty(@Nonnull Widget widget) {
    return !isEmpty(widget);
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import java.util.List;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import net.runelite.api.Client;
import net.runelite.api.annotations.Component;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;

public final class InventoryUtil {
  /**
   * Number of items in an inventory
   */
  public static final int INVENTORY_SIZE = 28;

  public interface Filter<T> {
    boolean filter(T t);
  }

  @Nullable
  public static Widget findFirst(@Nonnull Client client, @Component int componentId, @Nonnull Filter<Widget> filter) {
    Widget invWidget = client.getWidget(componentId);
    if (invWidget == null) {
      return null;
    }
    Widget[] inventoryWidgets = invWidget.getDynamicChildren();
    for (Widget widget : inventoryWidgets) {
      if (filter.filter(widget)) {
        return widget;
      }
    }
    return null;
  }

  @Nullable
  public static Widget findFirstEmptySlot(@Nonnull Client client, @Component int componentId) {
    return findFirst(client, componentId, WidgetUtils::isEmpty);
  }

  public static final int GROUP_ITEM_CONTAINER = WidgetUtil.packComponentId(InterfaceID.GROUP_STORAGE_INVENTORY, 0);
  public static final int DEPOSIT_BOX_ITEM_CONTAINER = WidgetUtil.packComponentId(268, 0);
  public static final int BANK_WITHDRAW_AS_ITEM = WidgetUtil.packComponentId(InterfaceID.BANK, 22);
  public static final int BANK_WITHDRAW_AS_NOTE = WidgetUtil.packComponentId(InterfaceID.BANK, 24);

  public static final List<Integer> INVENTORY_ITEMS_CONTAINERS = List.of(
    ComponentID.INVENTORY_CONTAINER,
    ComponentID.EQUIPMENT_INVENTORY_ITEM_CONTAINER,
    ComponentID.BANK_INVENTORY_ITEM_CONTAINER,
    ComponentID.GRAND_EXCHANGE_INVENTORY_INVENTORY_ITEM_CONTAINER,
    ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER,
    ComponentID.SHOP_INVENTORY_ITEM_CONTAINER,
    ComponentID.SMITHING_INVENTORY_ITEM_CONTAINER,
    ComponentID.GUIDE_PRICES_INVENTORY_ITEM_CONTAINER,
    ComponentID.SEED_VAULT_INVENTORY_ITEM_CONTAINER,
    GROUP_ITEM_CONTAINER,
    DEPOSIT_BOX_ITEM_CONTAINER
  );

  private InventoryUtil() {
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;

/**
 * Holds various varbits used by this plugin which are not documented in the RuneLite API.
 * <p></p>
 * Each varbit is written in the format <code>VARBIT_{type}_{name}</code>. Where <code>{type}</code> is the type the
 * varbit stores and <code>{name}</code> is the name of the varbit.
 *
 * @see net.runelite.api.Varbits
 */
@Singleton
public class VarbitsService {

  @Inject
  private Client client;
  @Inject
  private ItemManager itemManager;

  /**
   * When enabled, if you go to drop an item that has a higher value than the threshold you set, a warning will appear.
   * <p>
   * Can be toggled in <i>All Settings</i> under the <i>Warnings</i> tab with the name <i>Drop item warning</i>
   *
   * @see #INT_MINIMUM_ITEM_VALUE_FOR_DROP_WARNING
   */
  public static final int BOOLEAN_DROP_ITEM_WARNING = 5411;

  /**
   * If you  go to drop an item that is worth more than this value, a warning will appear.
   * <p>
   * Can be toggled in <i>All Settings</i> under the <i>Warnings</i> tab with the name <i>Minimum item value needed for drop item warning</i>
   *
   * @see #BOOLEAN_DROP_ITEM_WARNING
   */
  public static final int INT_MINIMUM_ITEM_VALUE_FOR_DROP_WARNING = 5412;
  public static final int INT_MINIMUM_ITEM_VALUE_FOR_ALCH_WARNING = 6091;
  public static final int BOOLEAN_ALWAYS_WARN_WHEN_ALCHING_UNTRADEABLE = 6092;

  /**
   * Whether items from the bank will be withdrawn as notes
   */
  public static final int BOOLEAN_WITHDRAW_AS_NOTE = 3958;

  /**
   * How much will be withdrawn from the bank by default (i.e., left clicking and item)
   *
   * <p>0 = 1 at a time
   * <p>1 = 5 at a time
   * <p>2 = 10 at a time
   * <p>3 = X at a time
   * <p>4 = All items
   */
  public static final int ENUM_WITHDRAW_DEFAULT_QUANTITY = 8354;

  /**
   * The quantity of items to withdraw when <code>X</code> is selected
   */
  public static final int INT_DEFAULT_X_QUANTITY = 3960;

  /**
   * Whether placeholders will be shown in the bank
   */
  public static final int BOOLEAN_ALWAYS_SET_BANK_PLACEHOLDER = 3755;

  public static final int VARBIT_VALUE_TRUE = 1;
  public static final int VARBIT_VALUE_FALSE = 0;

  /**
   * @param varbit the varbit to test
   * @return Whether the value of the varbit is true, i.e., 1
   */
  public boolean isVarbitTrue(int varbit) {
    return client.getVarbitValue(varbit) == VARBIT_VALUE_TRUE;
  }

  /**
   * @param varbit the varbit to test
   * @return Whether the value of the varbit is false, i.e., 0
   */
  public boolean isVarbitFalse(int varbit) {
    return client.getVarbitValue(varbit) == VARBIT_VALUE_FALSE;
  }

  public int varbitValue(int varbit) {
    return client.getVarbitValue(varbit);
  }

  public boolean willDropWarningBeShownForItem(int itemId, int quantity) {
    if (isVarbitFalse(BOOLEAN_DROP_ITEM_WARNING)) {
      return false;
    }
    var canonItemId = itemManager.canonicalize(itemId);
    var price = itemManager.getItemPrice(canonItemId);
    return varbitValue(INT_MINIMUM_ITEM_VALUE_FOR_DROP_WARNING) < price * quantity;
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.service;

import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import javax.inject.Inject;
import net.runelite.api.widgets.Widget;
import no.elg.ii.inventory.InventoryService;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.inventory.slot.InventorySlot;

public class EnsureWidgetStateService {
  @Inject
  InventoryService inventoryService;

  @Inject
  InventoryState state;

  /**
   * Force widget to look a certain way. Sometimes the widgets get updated by client code, but this will override
   * any other (clientside) changes to inventory widgets.
   * <p>
   * If this is not actively corrected the item will be fully visible.
   * This only applies to the clicked item, but it is not known <b>when</b> the item was clicked.
   * So this is a brute-force method to ensure that the item is hidden.
   */
  public void forceWidgetState(BiPredicate<Widget, InventorySlot> widgetFilter, BiConsumer<Widget, InventorySlot> force) {
    state.getActiveSlots()
      .forEach(iis -> inventoryService.getAllInventoryWidgets()
        .filter(slotWidget -> slotWidget.getIndex() == iis.getIndex() && widgetFilter.test(slotWidget.getWidget(), iis.getSlot()))
        .forEach(slotWidget -> force.accept(slotWidget.getWidget(), iis.getSlot())));
  }

}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.service;

import static no.elg.ii.util.WidgetUtils.FULLY_OPAQUE;
import static no.elg.ii.util.WidgetUtils.FULLY_TRANSPARENT;
import static no.elg.ii.util.WidgetUtils.THE_EMPTY_ITEM_ID;

import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Item;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.util.Util;
import no.elg.ii.util.WidgetUtils;

@Singleton
public class WidgetService {

  @Inject
  private InstantInventoryConfig config;

  private static final int FULLY_OPAQUE_INT_PERCENT = 100;
  private static final int FULLY_TRANSPARENT_INT_PERCENT = 0;

  /**
   * Convert a number between {@link #FULLY_TRANSPARENT_INT_PERCENT} and {@link #FULLY_OPAQUE_INT_PERCENT} to the
   * corresponding opacity value between {@link WidgetUtils#FULLY_OPAQUE} and {@link WidgetUtils#FULLY_TRANSPARENT}
   */
  private static int intPercentToOpacityValue(int opacityPercent) {
    int validOpacityIntPercent = Util.coerceIn(opacityPercent, FULLY_TRANSPARENT_INT_PERCENT, FULLY_OPAQUE_INT_PERCENT);
    double percent = validOpacityIntPercent / (double) FULLY_OPAQUE_INT_PERCENT;
    return (int) ((1d - percent) * FULLY_TRANSPARENT);
  }

  public int getChangeOpacity() {
    return intPercentToOpacityValue(config.changeOpacityPercent());
  }

  public int getHideOpacity() {
    return intPercentToOpacityValue(config.hideOpacityPercent());
  }

  /**
   * Set the opacity of the widget to the user specified change opacity
   *
   * @param hideFully If the widget item id can be changed if the opacity is fully transparent
   */
  public void setAsChangeOpacity(@Nonnull Widget widget, boolean hideFully) {
    setOpacity(widget, getChangeOpacity(), hideFully);
  }

  /**
   * Set the opacity of the widget to the user specified hide opacity
   *
   * @param hideFully If the widget item id can be changed if the opacity is fully transparent
   */
  public void setAsHideOpacity(@Nonnull Widget widget, boolean hideFully) {
    setOpacity(widget, getHideOpacity(), hideFully);
  }

  /**
   * Make the widget fully visible
   */
  public void setAsFullyOpaque(@Nonnull Widget widget) {
    setOpacity(widget, FULLY_OPAQUE, false);
  }

  /**
   * Change the opacity of the widget to {@code opacity}
   *
   * @param hideFully If the widget item id can be changed if the opacity is fully transparent
   */
  public void setOpacity(@Nonnull Widget widget, int opacity, boolean hideFully) {
    if (hideFully && opacity == FULLY_TRANSPARENT) {
      //When the opacity should be fully transparent we want to change the widget to not display overlay for the given item
      setEmptyItem(widget);
    }
    widget.setHidden(false);
    widget.setOpacity(opacity);
  }

  /**
   * Set the itemId and quantity of a widget without changing the opacity or any other attributes
   */
  public void updateVisibleWidget(@Nonnull Widget dstWidget, int itemId, int amount) {
    dstWidget.setItemId(itemId);
    dstWidget.setItemQuantity(amount);
  }

  public void updateVisibleWidget(@Nonnull Widget dstWidget, @Nonnull Item srcItem) {
    updateVisibleWidget(dstWidget, srcItem.getId(), srcItem.getQuantity());
  }

  public void setEmptyItem(@Nonnull Widget widget) {
    widget.setItemQuantityMode(ItemQuantityMode.NEVER);
    setFakeWidgetItem(widget, THE_EMPTY_ITEM_ID, 1);
  }

  public void setFakeWidgetItem(@Nonnull Widget dstWidget, int itemId, int amount) {
    updateVisibleWidget(dstWidget, itemId, amount);
    setAsChangeOpacity(dstWidget, false); //this can never be true as it will cause an infinite loop
  }

  public void setFakeWidgetItem(@Nonnull Widget dstWidget, @Nonnull Item srcItem) {
    setFakeWidgetItem(dstWidget, srcItem.getId(), srcItem.getQuantity());
  }

  /**
   * Add {@code delta} from the quantity of {@code widget}
   *
   * @param widget the widget to update
   * @param delta  the amount to add
   */
  public void updateQuantity(@Nonnull Widget widget, int delta) {
    setQuantity(widget, widget.getItemQuantity() + delta);
  }

  /**
   * Set the quantity of {@code widget} to {@code quantity}
   */
  public void setQuantity(@Nonnull Widget widget, int quantity) {
    widget.setItemQuantity(quantity);
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii;

import com.google.common.annotations.VisibleForTesting;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import no.elg.ii.feature.Feature;

@Slf4j
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FeatureManager {

  /**
   * The currently loaded features
   */
  @VisibleForTesting
  protected final Set<Feature> activeFeatures = ConcurrentHashMap.newKeySet();
  private final Set<Feature> activeFeaturesView = Collections.unmodifiableSet(activeFeatures);


  @Inject
  @VisibleForTesting
  protected EventBus eventBus;

  @Inject
  @VisibleForTesting
  protected InstantInventoryConfig config;

  @Inject
  protected Features featureInstances;

  @Inject
  protected ClientThread clientThread;

  /**
   * Make sure all features are in its correct state
   */
  @VisibleForTesting
  protected void updateAllFeatureStatus() {
    updateFeatureStatus(featureInstances.getDropFeature(), config.instantDrop());
    updateFeatureStatus(featureInstances.getCleanHerbFeature(), config.instantClean());
    updateFeatureStatus(featureInstances.getDepositFeature(), config.instantDeposit());
    updateFeatureStatus(featureInstances.getEquipFeature(), config.instantEquip());
    updateFeatureStatus(featureInstances.getWithdrawFeature(), config.instantWithdraw());
  }

  public void disableAllFeatures() {
    HashSet<Feature> copy = new HashSet<>(activeFeatures);
    for (Feature feature : copy) {
      disableFeature(feature);
    }
  }

  /**
   * @return Thread safe view of the currently active features
   */
  public Set<Feature> getActiveFeatures() {
    return activeFeaturesView;
  }

  /**
   * Make sure a feature is in its correct state, that is disabled when disabled in the config and
   * vice versa
   *
   * @param feature           The feature to check
   * @param isEnabledInConfig Whether the feature is currently enable in the config
   */
  @VisibleForTesting
  void updateFeatureStatus(@Nonnull Feature feature, boolean isEnabledInConfig) {
    boolean wasEnabled = activeFeatures.contains(feature);

    if (!wasEnabled && isEnabledInConfig) {
      enableFeature(feature);
    } else if (wasEnabled && !isEnabledInConfig) {
      disableFeature(feature);
    }
  }

  /**
   * Enable a feature, meaning it is listing to events and generally acting as a mini-plugin
   *
   * @param feature The feature to enable
   */
  @VisibleForTesting
  void enableFeature(@Nonnull Feature feature) {
    clientThread.invoke(() -> {
      log.debug("Enabling " + feature.getConfigKey());
      eventBus.register(feature);
      activeFeatures.add(feature);
      feature.onEnable();
      feature.reset();
    });
  }

  /**
   * Disable a feature, it will no longer receive events
   *
   * @param feature The feature to disable
   */
  @VisibleForTesting
  void disableFeature(@Nonnull Feature feature) {
    clientThread.invoke(() -> {
      log.debug("Disabling " + feature.getConfigKey());
      eventBus.unregister(feature);
      activeFeatures.remove(feature);
      feature.onDisable();
      feature.reset();
    });
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature;

import static no.elg.ii.util.InventoryUtil.findFirst;
import static no.elg.ii.util.WidgetUtils.ZERO_QUANTITY_BANK_ITEM_OPACITY;
import static no.elg.ii.util.WidgetUtils.isEmpty;

import com.google.common.annotations.VisibleForTesting;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.service.WidgetService;
import no.elg.ii.util.Util;
import no.elg.ii.util.VarbitsService;
import no.elg.ii.util.WidgetUtils;

@Slf4j
public class WithdrawFeature implements Feature {

  public static final String WITHDRAW_PREFIX_OPTION = "Withdraw-";
  public static final String WITHDRAW_CONFIG_KEY = "instantWithdraw";

  @Inject
  @VisibleForTesting
  Client client;

  @Inject
  @VisibleForTesting
  public ItemManager itemManager;

  @Inject
  @Getter
  private InventoryState state;
  @Inject
  private WidgetService widgetService;
  @Inject
  private VarbitsService varbitsService;

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget bankWidget = event.getWidget();
    if (bankWidget != null) {
      String menuOption = event.getMenuOption();
      if (menuOption != null && menuOption.startsWith(WITHDRAW_PREFIX_OPTION)) {
        int amount = Util.getNumberFromMenuOption(menuOption, bankWidget);
        if (amount == Util.NO_MENU_OPTION_NUMBER) {
          return;
        }
        log.debug("Withdrawing item {}", WidgetUtils.debugInfo(bankWidget));
        withdraw(bankWidget, amount);
      }
    }
  }

  private void withdraw(Widget bankWidget, int amount) {
    int originalItemId = bankWidget.getItemId();
    ItemComposition originalComposition = itemManager.getItemComposition(originalItemId);

    //If we're withdrawing as a note, we need to get the item id of the note as the banked item is never the noted item
    int bankWidgetItemId;
    ItemComposition bankWidgetComposition;
    if (isWithdrawingAsNote() && isItemNotable(originalComposition)) {
      bankWidgetItemId = originalComposition.getLinkedNoteId();
      bankWidgetComposition = itemManager.getItemComposition(bankWidgetItemId);
    } else {
      bankWidgetItemId = originalItemId;
      bankWidgetComposition = originalComposition;
    }

    //Only withdraw the amount that is available
    int quantityToWithdraw = Math.min(bankWidget.getItemQuantity(), amount);

    if (bankWidgetComposition.isStackable()) {
      Widget inventoryWidget = findFirst(client, ComponentID.BANK_INVENTORY_ITEM_CONTAINER, w -> w.getItemId() == bankWidgetItemId);
      if (inventoryWidget != null) {
        //There is a matching widget, so we can just update the quantity
        updateBankItem(bankWidget, quantityToWithdraw);
        widgetService.updateQuantity(inventoryWidget, quantityToWithdraw);
        getState().setSlot(inventoryWidget.getIndex(), bankWidgetItemId, inventoryWidget.getItemQuantity(), widgetService.getChangeOpacity());
      } else {
        fillFirstEmpty(bankWidget, bankWidgetItemId, quantityToWithdraw);
      }
    } else {
      //Item is not stackable, so we have to fill the inventory with the item until we run out of space or items
      for (int i = 0; i < quantityToWithdraw; i++) {
        boolean outOfSpace = fillFirstEmpty(bankWidget, bankWidgetItemId, 1);
        if (outOfSpace) {
          break;
        }
      }
    }
  }

  /**
   * @return Whether the item can be noted
   */
  private boolean isItemNotable(ItemComposition itemComposition) {
    return itemComposition.getLinkedNoteId() > 0;
  }

  /**
   * @return {@code false} if there is no more space in the inventory, {@code true} otherwise
   */
  private boolean fillFirstEmpty(Widget bankWidget, int actualItemId, int quantityToWithdraw) {
    var emptyWidget = findFirst(client, ComponentID.BANK_INVENTORY_ITEM_CONTAINER, widget -> {
      @Nullable
      InventorySlot slot = getState().getSlot(widget.getIndex());
      return isEmpty(widget) && slot != null && !slot.hasValidItemId();
    });
    if (emptyWidget != null) {
      widgetService.setFakeWidgetItem(emptyWidget, actualItemId, quantityToWithdraw);
      updateBankItem(bankWidget, quantityToWithdraw);
      getState().setSlot(emptyWidget.getIndex(), bankWidget.getItemId(), quantityToWithdraw, widgetService.getChangeOpacity());
      return false;
    }
    return true;
  }

  private void updateBankItem(@Nonnull Widget bankWidget, int quantityToWithdraw) {
    widgetService.updateQuantity(bankWidget, -quantityToWithdraw);
    log.debug("Removing {} from bank widget {}", quantityToWithdraw, WidgetUtils.debugInfo(bankWidget));
    if (bankWidget.getItemQuantity() == 0) {
      if (isPlaceholdersDisabled()) {
        log.debug("Hiding bank widget, new quantity is 0 and placeholders are disabled");
        widgetService.setAsHideOpacity(bankWidget, false);
      } else {
        widgetService.setOpacity(bankWidget, ZERO_QUANTITY_BANK_ITEM_OPACITY, false);
      }
    } else {
      widgetService.setAsChangeOpacity(bankWidget, false);
    }
  }

  /**
   * @return Whether the bank is set to withdraw as a note
   */
  private boolean isWithdrawingAsNote() {
    return varbitsService.isVarbitTrue(VarbitsService.BOOLEAN_WITHDRAW_AS_NOTE);
  }

  private boolean isPlaceholdersDisabled() {
    return varbitsService.isVarbitFalse(VarbitsService.BOOLEAN_ALWAYS_SET_BANK_PLACEHOLDER);
  }

  @Nonnull
  @Override
  public String getConfigKey() {
    return WITHDRAW_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature;


import javax.annotation.Nonnull;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import no.elg.ii.inventory.InventoryState;

/**
 * A feature of the instant inventory plugin. Features have a {@link #getState()} and modifies how
 * the inventory is rendered based on that.
 */
public interface Feature {

  /**
   * @return The state of the feature
   */
  @Nonnull
  InventoryState getState();

  @Nonnull
  String getConfigKey();

  /**
   * Method run when this feature is loaded in, either on {@link Plugin#startUp()} or when
   * {@link ConfigChanged} and this feature is enabled in the config and not already loaded.
   */
  default void onEnable() {
  }


  /**
   * Method run when this feature is disabled, either on {@link Plugin#shutDown()} or when
   * {@link ConfigChanged} and this feature is disabled in the config and is loaded.
   */
  default void onDisable() {
  }

  /**
   * Reset the feature to its initial state.
   * <p>
   * In the default implementation {@link InventoryState#resetAll()} is called.
   */
  default void reset() {
    getState().resetAll();
  }
}

/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature;

import javax.annotation.Nonnull;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import no.elg.ii.util.VarbitsService;
import no.elg.ii.util.WidgetUtils;

@Slf4j
public class DropFeature extends HideFeature {

  public static final String DROP_OPTION = "Drop";
  public static final String DROP_CONFIG_KEY = "instantDrop";

  @Inject
  private VarbitsService varbitsService;

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null) {
      String menuOption = event.getMenuOption();
      if (DROP_OPTION.equals(menuOption)) {
        log.debug("Dropped item {}", WidgetUtils.debugInfo(widget));
        if (varbitsService.willDropWarningBeShownForItem(widget.getItemId(), widget.getItemQuantity())) {
          log.debug("Drop warning will be shown, will not hide item");
        } else {
          hide(widget);
        }
      }
    }
  }

  @Nonnull
  @Override
  public String getConfigKey() {
    return DROP_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature;

import com.google.common.annotations.VisibleForTesting;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.InstantInventoryPlugin;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.service.WidgetService;

@Slf4j
public abstract class HideFeature implements Feature {

  @Inject
  public InstantInventoryPlugin plugin;

  @Inject
  @VisibleForTesting
  protected InstantInventoryConfig config;

  @Inject
  public ClientThread clientThread;

  @Inject
  @Getter
  private InventoryState state;

  @Inject
  public Client client;

  @Inject
  public WidgetService widgetService;

  protected void hide(@Nonnull Widget widget) {
    getState().setSlot(widget, widgetService.getHideOpacity());
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature;

import static no.elg.ii.util.InventoryUtil.findFirstEmptySlot;

import com.google.common.annotations.VisibleForTesting;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.http.api.item.ItemEquipmentStats;
import net.runelite.http.api.item.ItemStats;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.service.WidgetService;
import no.elg.ii.util.WidgetUtils;
import org.apache.commons.lang3.tuple.Pair;

@Singleton
@Slf4j
public class EquipFeature implements Feature {

  public static final List<String> EQUIP_OPTIONS = List.of("Wear", "Wield", "Equip");
  public static final String EQUIP_CONFIG_KEY = "instantEquip";

  @Inject
  @VisibleForTesting
  ItemManager itemManager;

  @Inject
  @VisibleForTesting
  Client client;
  @Inject
  @VisibleForTesting
  ClientThread clientThread;

  @Inject
  @Getter
  private InventoryState state;
  @Inject
  private WidgetService widgetService;

  /**
   * The last tick each slot was equipped
   */
  private final Map</*slotIdx*/ Integer, /*last tick count changed*/ Integer> lastEquipped = new HashMap<>(EquipmentInventorySlot.values().length);

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null) {
      String menuOption = event.getMenuOption();
      if (EQUIP_OPTIONS.contains(menuOption)) {
        log.debug("'{}' item {}", menuOption, WidgetUtils.debugInfo(widget));
        clientThread.invokeAtTickEnd(() -> equip(widget));
      }
    }
  }

  @Subscribe
  public void onChatMessage(ChatMessage event) {
    if (event.getType() == ChatMessageType.GAMEMESSAGE && Objects.equals(event.getMessage(), "You are not a high enough level to use this item.")) {
      log.debug("Failed to equip item?");
      getState().getActiveSlots().filter(is -> is.getSlot().getChangedTick() == client.getTickCount()).forEach(is -> getState().resetState(is.getIndex()));
    }
  }

  protected void equip(@Nonnull Widget widget) {
    ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INVENTORY);
    if (inventoryContainer == null) {
      log.debug("Failed to find the inventory container");
      return;
    }
    @Nullable Pair<Item, Item> itemIds = getEquipmentToReplace(widget);
    if (itemIds == null) {
      return;
    }

    @Nullable Item toReplaceItem = itemIds.getLeft();
    int opacity;
    if (toReplaceItem != null) {
      log.trace("An item was equipped in the slot (to replace: {}), will replace it with {}", WidgetUtils.debugInfo(toReplaceItem), WidgetUtils.debugInfo(widget));
      Item extraItem = itemIds.getRight();
      if (extraItem != null) {
        log.trace("There is also something in the off-slot ({}), will replace that too", WidgetUtils.debugInfo(extraItem));
        @Nullable Widget offhandWidget = findFirstEmptySlot(client, ComponentID.INVENTORY_CONTAINER);
        if (offhandWidget != null) {
          widgetService.setFakeWidgetItem(widget, toReplaceItem);
          widgetService.setFakeWidgetItem(offhandWidget, extraItem);
        } else {
          //There was no slot to put the offhand item in, so the items will not be equipped
          log.debug("Will not equip two-handed item, as there is no slot to put the offhand item in");
          return;
        }
      } else {
        log.trace("No off-hand item to replace, will only change the clicked slot");
        widgetService.setFakeWidgetItem(widget, toReplaceItem);
      }
      opacity = widgetService.getChangeOpacity();
    } else {
      log.trace("No other item to replace, will show the slot as empty");
      widgetService.setEmptyItem(widget);
      opacity = widgetService.getHideOpacity();
    }
    getState().setSlot(widget, opacity);
  }

  /**
   * @param widget the widget to equip
   * @return The item that was equipped (left) and potentially the off-hand item that was equipped (right) if it will be unequipped
   */
  @VisibleForTesting
  @Nullable
  public Pair<Item, Item> getEquipmentToReplace(Widget widget) {
    final ItemStats itemStats = itemManager.getItemStats(widget.getItemId(), false);
    if (itemStats == null || !itemStats.isEquipable()) {
      return null;
    }
    Item toReplace = null;
    Item extra = null;

    final ItemEquipmentStats clickedEquipment = itemStats.getEquipment();

    ItemContainer equipmentContainer = client.getItemContainer(InventoryID.EQUIPMENT);
    if (clickedEquipment != null && equipmentContainer != null) {
      if (lastEquipped.getOrDefault(clickedEquipment.getSlot(), 0) == client.getTickCount()) {
        log.debug("We have already equipped an item in the same slot this tick, will not replace it");
        return null;
      }
      final int slotOfClickedItem = clickedEquipment.getSlot();
      toReplace = equipmentContainer.getItem(slotOfClickedItem);

      if (isWeaponSlot(slotOfClickedItem)) {
        if (clickedEquipment.isTwoHanded()) {
          extra = equipmentContainer.getItem(EquipmentInventorySlot.SHIELD.getSlotIdx());
        }
      } else if (isShieldSlot(slotOfClickedItem)) {
        var weaponItem = equipmentContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
        if (weaponItem != null) {
          ItemStats weaponStat = itemManager.getItemStats(weaponItem.getId(), false);
          if (weaponStat != null && weaponStat.isEquipable()) {
            ItemEquipmentStats weaponStatEquipment = weaponStat.getEquipment();
            if (weaponStatEquipment != null && weaponStatEquipment.isTwoHanded()) {
              //If we click a shield while have a two-handed weapon equipped, the weapon get unequipped
              extra = weaponItem;
            }
          }
        }
      }
      lastEquipped.put(clickedEquipment.getSlot(), client.getTickCount());
    }
    if (extra != null && toReplace == null) {
      //
      return Pair.of(extra, null);
    }
    return Pair.of(toReplace, extra);
  }

  private static boolean isShieldSlot(int index) {
    return index == EquipmentInventorySlot.SHIELD.getSlotIdx();
  }

  private static boolean isWeaponSlot(int index) {
    return index == EquipmentInventorySlot.WEAPON.getSlotIdx();
  }

  @Nonnull
  @Override
  public String getConfigKey() {
    return EQUIP_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature;

import com.google.common.annotations.VisibleForTesting;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.service.WidgetService;
import no.elg.ii.util.HerbInfo;

public class CleanHerbFeature implements Feature {

  public static final String CLEAN_OPTION = "Clean";
  public static final String CLEAN_CONFIG_KEY = "instantClean";

  @Inject
  @VisibleForTesting
  public Client client;

  @Inject
  private InventoryState state;
  @Inject
  private WidgetService widgetService;

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null) {
      String menuOption = event.getMenuOption();
      if (CLEAN_OPTION.equals(menuOption)) {
        int itemId = event.getItemId();
        HerbInfo herbInfo = HerbInfo.HERBS.get(itemId);
        if (herbInfo == null) {
          return;
        }
        int herbloreLevel = client.getBoostedSkillLevel(Skill.HERBLORE);
        if (herbloreLevel >= herbInfo.getMinLevel()) {
          getState().setSlot(widget.getIndex(), herbInfo.getCleanItemId(), widget.getItemQuantity(), widgetService.getChangeOpacity());
        }
      }
    }
  }

  @Override
  @Nonnull
  public InventoryState getState() {
    return state;
  }

  @Nonnull
  @Override
  public String getConfigKey() {
    return CLEAN_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature;

import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import no.elg.ii.inventory.InventoryService;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.util.IndexedWidget;
import no.elg.ii.util.Util;
import no.elg.ii.util.WidgetUtils;

@Slf4j
public class DepositFeature extends HideFeature {

  public static final String DEPOSIT_PREFIX_OPTION = "Deposit-";
  public static final String DEPOSIT_ALL_OPTION = "Deposit inventory";
  public static final String ADD_ALL_OPTION = "Add all";
  public static final String DEPOSIT_CONFIG_KEY = "instantDeposit";

  @Inject
  private InventoryService inventoryService;

  @Inject
  private ItemManager itemManager;
  @Inject
  private InventoryState inventoryState;

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null) {
      String menuOption = event.getMenuOption();
      if (DEPOSIT_ALL_OPTION.equals(menuOption) || ADD_ALL_OPTION.equals(menuOption)) {
        log.debug("Hiding all items");
        inventoryService.getAllInventoryWidgets()
          .filter(iw -> WidgetUtils.isNotEmpty(iw.getWidget()))
          .forEach(indexedWidget -> hide(indexedWidget.getWidget()));
        return;
      }
      int eventItemId = event.getItemId();
      int clickedIndex = widget.getIndex();
      if (menuOption != null && (menuOption.startsWith(DEPOSIT_PREFIX_OPTION))) {
        int toTake = Util.getNumberFromMenuOption(menuOption, widget);
        if (toTake == Util.NO_MENU_OPTION_NUMBER) {
          return;
        }
        int actualTaken;
        if (toTake >= widget.getItemQuantity()) {
          log.debug("Hiding " + toTake + " items");

          Set<IndexedWidget> itemToTake = inventoryService.getAllInventoryWidgets()
            .filter(it -> {
              InventorySlot slot = inventoryState.getSlot(it.getWidget().getIndex());
              return it.getIndex() == clickedIndex || slot != null && !slot.hasValidItemId() && it.getWidget().getItemId() == eventItemId;
            })
            .sorted()
            .limit(toTake)
            .collect(Collectors.toUnmodifiableSet());
          itemToTake.forEach(indexedWidget -> hide(indexedWidget.getWidget()));
          actualTaken = itemToTake.stream().mapToInt(iw -> iw.getWidget().getItemQuantity()).sum();
        } else {
          int ui = widget.getItemQuantity() - toTake;
          log.debug("Updating item quantity from " + widget.getItemQuantity() + " be " + ui);
          getState().setSlot(widget.getIndex(), widget.getItemId(), ui, widgetService.getChangeOpacity());
          actualTaken = toTake;
        }

        int canonItemId = itemManager.canonicalize(eventItemId);
        //Update widget in bank
        Widget bankInventoryContainer = client.getWidget(ComponentID.BANK_ITEM_CONTAINER);
        if (bankInventoryContainer != null) {
          for (Widget bankWidget : bankInventoryContainer.getDynamicChildren()) {
            if (itemManager.canonicalize(bankWidget.getItemId()) == canonItemId) {
              widgetService.setQuantity(bankWidget, bankWidget.getItemQuantity() + actualTaken);
              return;
            }
          }
        }
      }
    }
  }

  @Nonnull
  @Override
  public String getConfigKey() {
    return DEPOSIT_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii;

import static no.elg.ii.util.InventoryUtil.INVENTORY_SIZE;

import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;
import java.util.Set;
import javax.inject.Inject;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import no.elg.ii.feature.Feature;
import no.elg.ii.inventory.InventoryService;
import no.elg.ii.inventory.InventoryState;

@Slf4j
@AllArgsConstructor
@NoArgsConstructor
@PluginDescriptor(name = "Instant Inventory")
public class InstantInventoryPlugin extends Plugin {

  @Inject
  @VisibleForTesting
  protected Client client;

  @Inject
  @VisibleForTesting
  protected EventBus eventBus;

  @Inject
  @VisibleForTesting
  protected InstantInventoryConfig config;

  @Inject
  @VisibleForTesting
  protected FeatureManager featureManager;

  @Inject
  protected InventoryState inventoryState;
  @Inject
  protected ClientThread clientThread;

  @Inject
  InventoryService inventoryService;

  @Override
  protected void startUp() {
    featureManager.updateAllFeatureStatus();
    eventBus.register(inventoryService);
  }

  @Override
  protected void shutDown() {
    // Disable all features when the plugin shuts down
    featureManager.disableAllFeatures();
    eventBus.unregister(inventoryService);
  }

  /* (non-javadoc)
   * When an item is different in the inventory, unmark it as being hidden.
   *
   * This should run after client ticking to prevent flickering of items
   */
  @Subscribe(priority = Integer.MAX_VALUE)
  public void onGameTick(GameTick event) {
    clientThread.invokeLater(() -> {
      ItemContainer itemContainer = inventoryService.getCurrentInventoryContainer();
      if (itemContainer != null) {
        for (int index = 0; index < INVENTORY_SIZE; index++) {
          Item item = itemContainer.getItem(index);
          inventoryState.validateState(index, item);
        }
      }
    });
  }

  /* (non-javadoc)
   * Reset features when the state change as we do not want to operate on stale data
   */
  @Subscribe
  public void onGameStateChanged(GameStateChanged event) {
    if (event.getGameState() == GameState.LOGGED_IN) {
      log.debug("Resetting features as the GameState changed to {}", event.getGameState());
      Set<Feature> activeFeatures = featureManager.getActiveFeatures();
      for (Feature feature : activeFeatures) {
        feature.reset();
      }
    }
  }

  @Subscribe
  public void onConfigChanged(ConfigChanged configChanged) {
    if (InstantInventoryConfig.GROUP.equals(configChanged.getGroup())) {
      featureManager.updateAllFeatureStatus();
    }
  }

  @Provides
  InstantInventoryConfig provideConfig(ConfigManager configManager) {
    return configManager.getConfig(InstantInventoryConfig.class);
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii;

import com.google.common.annotations.VisibleForTesting;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import no.elg.ii.feature.CleanHerbFeature;
import no.elg.ii.feature.DepositFeature;
import no.elg.ii.feature.DropFeature;
import no.elg.ii.feature.EquipFeature;
import no.elg.ii.feature.WithdrawFeature;

@Singleton
@Data
@AllArgsConstructor
@NoArgsConstructor
public final class Features {

  @Inject
  @VisibleForTesting
  private DropFeature dropFeature;

  @Inject
  @VisibleForTesting
  private CleanHerbFeature cleanHerbFeature;

  @Inject
  @VisibleForTesting
  private DepositFeature depositFeature;

  @Inject
  @VisibleForTesting
  private EquipFeature equipFeature;

  @Inject
  @VisibleForTesting
  private WithdrawFeature withdrawFeature;
}

/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.inventory;

import static no.elg.ii.inventory.slot.InventorySlot.INVALID_ITEM_ID;
import static no.elg.ii.util.InventoryUtil.INVENTORY_SIZE;

import com.google.common.annotations.VisibleForTesting;
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.InstantInventoryPlugin;
import no.elg.ii.feature.Feature;
import no.elg.ii.inventory.slot.IndexedInventorySlot;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.service.WidgetService;
import no.elg.ii.util.IndexedWidget;

/**
 * Hold the state of the players inventory. The state is checked every server tick in
 * {@link InstantInventoryPlugin#onGameTick(GameTick)}
 * <p>
 * A {@link Feature} uses this class to handle how to render the changes on the client. Typically, a
 * feature will modify the rendering of a given item in the inventory of the player when the
 * {@link #getSlot(int)} is different to {@link InventorySlot#INVALID_ITEM_ID}.
 * <p>
 * The state should only be modified by the client thread
 */
@EqualsAndHashCode
@Slf4j
@AllArgsConstructor
@NoArgsConstructor
@Singleton
public class InventoryState {

  /**
   * Maximum number of ticks an item should be displayed as something else
   */
  public static final int DEFAULT_MAX_UNMODIFIED_TICKS = 1;

  /**
   * The tick the item was modified
   */
  private final InventorySlot[] slots = new InventorySlot[INVENTORY_SIZE];

  @Inject
  @VisibleForTesting
  InstantInventoryConfig config;

  @Inject
  @VisibleForTesting
  Client client;

  @Inject
  private InventoryService inventoryService;

  @Inject
  private WidgetService widgetService;

  {
    Arrays.fill(slots, InventorySlot.UNMODIFIED_SLOT);
  }

  /**
   * Update the {@code itemId} at {@code index} will also update which tick the item was modified
   */
  public void setSlot(Widget widget, int opacity) {
    int index = widget.getIndex();
    setSlot(index, new InventorySlot(client.getTickCount(), widget.getItemId(), widget.getItemQuantity(), opacity));
  }

  /**
   * Update the {@code itemId} at {@code index} will also update which tick the item was modified
   *
   * @param index  The index of the item
   * @param itemId The new itemId, intended to be the current item in the players inventory
   */
  public void setSlot(int index, int itemId, int quantity, int opacity) {
    setSlot(index, new InventorySlot(client.getTickCount(), itemId, quantity, opacity));
  }

  private void setSlot(int index, @Nonnull InventorySlot slot) {
    assert this.client.isClientThread();
    if (isValidIndex(index)) {
      log.trace("Setting index {} to {}", index, slot);
      slots[index] = slot;
    } else {
      log.debug("Tried to set invalid index {} to {}", index, slot);
    }
  }

  @Nullable
  public InventorySlot getSlot(int index) {
    assert this.client.isClientThread();
    if (isInvalidIndex(index)) {
      log.debug("Tried to get invalid index {}", index);
      return null;
    }
    return slots[index];
  }

  public static boolean isValidIndex(int index) {
    return index >= 0 && index < INVENTORY_SIZE;
  }

  public static boolean isInvalidIndex(int index) {
    return index < 0 || index >= INVENTORY_SIZE;
  }

  /**
   * @return The slots and its index we're currently modifying
   */
  public Stream<IndexedInventorySlot> getActiveSlots() {
    assert this.client.isClientThread();
    //noinspection DataFlowIssue Safe as we are always within the size of the inventory
    return IntStream.range(0, slots.length).mapToObj(i -> new IndexedInventorySlot(i, getSlot(i))).filter((iis) -> iis.getSlot().hasValidItemId());
  }

  /**
   * Reset the state to its initial state
   */
  public void resetAll() {
    for (int i = 0; i < INVENTORY_SIZE; i++) {
      resetState(i);
    }
  }

  /**
   * Reset a given index to the initial state
   *
   * @param index The index of the item
   */
  public void resetState(int index) {
    resetState(index, null, false);
  }

  /**
   * Reset a given index to the initial state
   *
   * @param index The index of the item
   */
  private void resetState(int index, @Nullable Item item, boolean hasItem) {
    assert this.client.isClientThread();
    if (isValidIndex(index)) {
      log.trace("Resetting index {}", index);
      slots[index] = InventorySlot.RESET_SLOT;
      resetWidgetInSlot(index, item, hasItem);
    } else {
      log.debug("Tried to reset invalid index {}", index);
    }
  }

  /**
   * Update all inventory widgets to reflect the actual state of the inventory
   */
  private void resetWidgetInSlot(int index, @Nullable Item maybeItem, boolean hasItem) {
    assert this.client.isClientThread();
    Item item;
    if (hasItem) {
      item = maybeItem;
    } else {
      ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INVENTORY);
      if (inventoryContainer == null) {
        return;
      }
      item = inventoryContainer.getItem(index);
    }

    Stream<IndexedWidget> indexedWidgetStream = inventoryService.getAllInventoryWidgets().filter(it -> it.getIndex() == index);
    if (item == null || item.getId() < 0) {
      //There is no item at this index, so we hide the widget
      //Make sure items that are not in the inventory are hidden
      indexedWidgetStream.forEach(it -> widgetService.setAsFullyOpaque(it.getWidget()));
    } else {
      //Update the item to the actual item
      indexedWidgetStream.forEach(it -> {
        widgetService.setAsFullyOpaque(it.getWidget());
        widgetService.updateVisibleWidget(it.getWidget(), item);
      });
    }
  }

  public long msSinceChange(InventorySlot slot) {
    return System.currentTimeMillis() - slot.getChangedMs();
  }

  /**
   * @return If this inventory slot has still "Invulnerability Frames" left
   */
  public boolean isTooEarlyToReset(InventorySlot slot) {
    return msSinceChange(slot) < config.minChangedMs();
  }

  /**
   * Validate and modify the state of an item for a given index.
   * <p>
   * The state will be reset when the {@code actualItemId} indicates a different item exists in at
   * the index's inventory slot. Additionally, if too much time have passed without an item change,
   * the state will also be reset to not operate on stale data
   *
   * @param index The index of the item
   * @param item  The actual item which is in the inventory
   */
  public void validateState(int index, @Nullable Item item) {
    assert this.client.isClientThread();
    InventorySlot slot = getSlot(index);
    if (slot == null || slot == InventorySlot.UNMODIFIED_SLOT || slot == InventorySlot.RESET_SLOT) {
      // This item is not modified (or at least not by us) so we do not need to do anything
      return;
    }

    if (isTooEarlyToReset(slot)) {
      log.debug("Not resetting slot {} as it is too early", index);
      return;
    }
    int actualItemId = item == null ? INVALID_ITEM_ID : item.getId();
    int actualQuantity = item == null ? INVALID_ITEM_ID : item.getQuantity();

    int itemId = slot.getItemId();
    int quantity = slot.getQuantity();
    int modifiedTick = slot.getChangedTick();
    // Item at index changed so we must reset the slot
    if (slot.hasValidItemId() && (itemId != actualItemId || quantity != actualQuantity)) {
      log.debug("Item at index {} changed from item id {} to {} or from quantity {} to {}, resetting the item", index, itemId, actualItemId, quantity, actualQuantity);
      resetState(index, item, true);
      return;
    }

    // The item at the given index have not changes in some time, we reset to
    int ticksSinceModified = client.getTickCount() - modifiedTick;
    if (slot.hasChangedTick() && ticksSinceModified >= config.maxUnmodifiedTicks()) {
      log.debug("Item at index {} has not changed in {} tick ({} ms}, resetting the item", index, ticksSinceModified, msSinceChange(slot));
      resetState(index, item, true);
    }
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.inventory.slot;

import javax.annotation.Nonnull;
import lombok.Data;

@Data
public class IndexedInventorySlot {

  private final int index;
  private final @Nonnull InventorySlot slot;
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.inventory.slot;

import static no.elg.ii.util.WidgetUtils.FULLY_TRANSPARENT;

import lombok.Data;

@Data
public class InventorySlot {

  /**
   * Indicate that the item is not a real item, but rather a placeholder
   */
  public static final int INVALID_ITEM_ID = -1;
  public static final int RESET_ITEM_ID = -2;

  /**
   * Indicate the item has not been modified
   */
  public static final int NO_CHANGED_TICK = -1;

  public static final InventorySlot UNMODIFIED_SLOT = new InventorySlot(NO_CHANGED_TICK, INVALID_ITEM_ID, 0, FULLY_TRANSPARENT);
  public static final InventorySlot RESET_SLOT = new InventorySlot(NO_CHANGED_TICK, RESET_ITEM_ID, 0, FULLY_TRANSPARENT);

  /**
   * When this slot was modified, or {@link InventorySlot#NO_CHANGED_TICK} if it has not been (or cannot be) modified
   */
  private final int changedTick;
  /**
   * When this slot was modified in milliseconds. This is to remove flickering
   */
  private final long changedMs = System.currentTimeMillis();
  /**
   * The item id of this slot, or {@link InventorySlot#INVALID_ITEM_ID} if this slot is not a real item
   */
  private final int itemId;
  /**
   * How many of the item in this slot
   */
  private final int quantity;
  /**
   * The opacity this slot should be rendered with
   */
  private final int opacity;

  /**
   * @return Whether this slot is valid, i.e. has an item id
   */
  public boolean hasValidItemId() {
    return getItemId() >= 0;
  }

  /**
   * @return Whether this slot has been modified, if so when it was will be reflected in {@link #getChangedTick()}
   */
  public boolean hasChangedTick() {
    return getChangedTick() >= 0;
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.inventory;

import static no.elg.ii.util.IndexedWidget.indexWidget;
import static no.elg.ii.util.InventoryUtil.GROUP_ITEM_CONTAINER;
import static no.elg.ii.util.InventoryUtil.INVENTORY_ITEMS_CONTAINERS;

import com.google.common.collect.Streams;
import com.google.inject.Singleton;
import java.util.Arrays;
import java.util.stream.Stream;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.service.EnsureWidgetStateService;
import no.elg.ii.service.WidgetService;
import no.elg.ii.util.IndexedWidget;
import no.elg.ii.util.WidgetUtils;

@Singleton
@Slf4j
public class InventoryService {

  @Inject
  private Client client;
  @Inject
  private EnsureWidgetStateService ensureWidgetStateService;
  @Inject
  private WidgetService widgetService;

  @Nullable
  public ItemContainer getCurrentInventoryContainer() {
    Widget widget = client.getWidget(GROUP_ITEM_CONTAINER);
    InventoryID itemContainer;
    if (widget != null && !widget.isHidden()) {
      itemContainer = InventoryID.GROUP_STORAGE_INV;
    } else {
      itemContainer = InventoryID.INVENTORY;
    }
    return client.getItemContainer(itemContainer);
  }

  @Nonnull
  private Stream<Widget> getOpenWidgetItemContainer() {
    return INVENTORY_ITEMS_CONTAINERS.stream()
      .map(componentId -> client.getWidget(componentId))
      .filter(widget -> widget != null && !widget.isHidden());
  }

  @Nonnull
  @SuppressWarnings("UnstableApiUsage")
  public final Stream<IndexedWidget> getAllInventoryWidgets() {
    return getOpenWidgetItemContainer()
      .flatMap(container -> Streams.mapWithIndex(Arrays.stream(container.getDynamicChildren()), indexWidget));
  }

  public boolean isDifferent(Widget widget, InventorySlot slot) {
    return slot.hasValidItemId() && !WidgetUtils.isEmpty(widget)
      && (widget.getItemId() != slot.getItemId()
      || widget.getItemQuantity() != slot.getQuantity()
      || widget.getOpacity() != slot.getOpacity());
  }

  public void setWidgetFromSlot(Widget widget, InventorySlot slot) {
    widgetService.updateVisibleWidget(widget, slot.getItemId(), slot.getQuantity());
    widgetService.setOpacity(widget, slot.getOpacity(), true);
  }

  @Subscribe
  public void onBeforeRender(BeforeRender event) {
    ensureWidgetStateService.forceWidgetState(this::isDifferent, this::setWidgetFromSlot);
  }
}

/*
 * Copyright (c) 2022-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii;

import static no.elg.ii.InstantInventoryConfig.GROUP;
import static no.elg.ii.feature.CleanHerbFeature.CLEAN_CONFIG_KEY;
import static no.elg.ii.feature.DepositFeature.DEPOSIT_CONFIG_KEY;
import static no.elg.ii.feature.DropFeature.DROP_CONFIG_KEY;
import static no.elg.ii.feature.EquipFeature.EQUIP_CONFIG_KEY;
import static no.elg.ii.feature.WithdrawFeature.WITHDRAW_CONFIG_KEY;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import no.elg.ii.inventory.InventoryState;
import no.elg.ii.util.Util;

@ConfigGroup(GROUP)
public interface InstantInventoryConfig extends Config {

  String GROUP = "instant-inventory";

  @ConfigSection(
    name = "Features",
    description = "Toggle different features of the plugin",
    position = 0
  )
  String FEATURE_SECTION = "instant-inventory-features";

  @ConfigSection(
    name = "Appearance",
    description = "How predicted widget will look",
    position = 10
  )
  String APPEARANCE_SECTION = "instant-inventory-appearance";

  @ConfigSection(
    name = "Advanced",
    description = "Advanced settings for all features",
    position = 20,
    closedByDefault = true
  )
  String ADVANCED_SECTION = "instant-inventory-advanced";

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

  @ConfigItem(
    keyName = DROP_CONFIG_KEY,
    name = "Drop Items Instantly",
    section = FEATURE_SECTION,
    description = "Drop items from the inventory instantly",
    position = 0
  )
  default boolean instantDrop() {
    return true;
  }

  @ConfigItem(
    keyName = CLEAN_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Clean Herbs Instantly",
    description = "Show the cleaned herb instantly",
    position = 1
  )
  default boolean instantClean() {
    return true;
  }

  @ConfigItem(
    keyName = DEPOSIT_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Deposit Items Instantly",
    description = "Deposit items into your bank instantly."
      + "<p>"
      + "<p>Note that how many items that can be deposited at a time is limited by how osrs works. It appears"
      + "<p>that only four items can be deposited in a single game tick, so if you deposit more than four items at "
      + "<p>once, you have to wait for the next game tick before the rest of the items are deposited.",
    position = 2
  )
  default boolean instantDeposit() {
    return true;
  }

  @ConfigItem(
    keyName = EQUIP_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Equip Items Instantly",
    description = "Equip wearable/wieldable items instantly",
    position = 3
  )
  default boolean instantEquip() {
    return true;
  }

  @ConfigItem(
    keyName = WITHDRAW_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Withdraw Items Instantly",
    description = "Withdraw items from your bank instantly",
    position = 4
  )
  default boolean instantWithdraw() {
    return true;
  }


  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////


  @ConfigItem(
    section = APPEARANCE_SECTION,
    keyName = "hideOpacityPercent",
    name = "Hidden items opacity",
    description = "How transparent items are when removed from the inventory or bank" +
      "<p>A lower value will cause items to be more transparent",
    position = 10
  )
  @Range(max = 100)
  @Units(Units.PERCENT)
  default int hideOpacityPercent() {
    return 20; //% transparent
  }

  @ConfigItem(
    section = APPEARANCE_SECTION,
    keyName = "changeOpacityPercent",
    name = "Changed items opacity",
    description = "How transparent items are when replaced with another item." +
      "<p>A lower value will cause items to be more transparent",
    position = 20
  )
  @Range(max = 100)
  @Units(Units.PERCENT)
  default int changeOpacityPercent() {
    return 75; //% transparent
  }


  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////


  @ConfigItem(
    section = ADVANCED_SECTION,
    keyName = "maxUnmodifiedTicks",
    name = "Max Unmodified Ticks",
    description =
      "How many game ticks (0.6s) an item should be displayed as something else before being reverted back."
        + "<p>"
        + "<p>If this is zero the item will always flicker back into existence,"
        + "<p>when this is 1 items will occasionally flicker back into view when the servers are unstable,"
        + "<p>and when this is 2+ flickering rarely happens (i.e., only when the server lags)."
        + "<p>"
        + "<p>When in PvP or Bossing it is recommended to set this to 1.",
    position = 10
  )
  @Units(Units.TICKS)
  default int maxUnmodifiedTicks() {
    return InventoryState.DEFAULT_MAX_UNMODIFIED_TICKS;
  }

  @ConfigItem(
    section = ADVANCED_SECTION,
    keyName = "minChangedMs",
    name = "Min Changed Millis",
    description =
      "How many milliseconds a clicked item should minimum stay hidden/changed before it can be reverted back to what it really is."
        + "<p>"
        + "<p>This setting is affected by the ping and performance of the server. If you see items flicker back into existence, increase this value."
        + "<p>"
        + "<p>This overwrites the \"Max Unmodified Ticks\" setting.",
    position = 20
  )
  @Units(Units.MILLISECONDS)
  default int minChangedMs() {
    return Util.TICK_LENGTH_MS / 2;
  }

}

