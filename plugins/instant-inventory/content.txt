/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature;


import lombok.NonNull;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import no.elg.ii.feature.state.FeatureState;

/**
 * A feature of the instant inventory plugin. Features have a {@link #getState()} which hold how the client know the difference between server and client.
 */
public interface Feature {

  /**
   * @return The state of the feature
   */
  @NonNull
  FeatureState getState();

  @NonNull
  String getConfigKey();

  /**
   * Method run when this feature is loaded in, either on {@link Plugin#startUp()} or when
   * {@link ConfigChanged} and this feature is enabled in the config and not already loaded.
   */
  default void onEnable() {
  }

  /**
   * Method run when this feature is disabled, either on {@link Plugin#shutDown()} or when
   * {@link ConfigChanged} and this feature is disabled in the config and is loaded.
   */
  default void onDisable() {
  }

  /**
   * Reset the feature to its initial state.
   * <p>
   * In the default implementation {@link FeatureState#resetAll()} is called.
   */
  default void reset() {
    getState().resetAll();
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature;

import com.google.common.annotations.VisibleForTesting;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import no.elg.ii.InstantInventoryConfig;

@Slf4j
@Singleton
@NoArgsConstructor
@AllArgsConstructor
public class FeatureManager {

  /**
   * The currently loaded features
   */
  @VisibleForTesting
  protected final Set<Feature> activeFeatures = ConcurrentHashMap.newKeySet();

  @Inject
  @VisibleForTesting
  protected EventBus eventBus;

  @Inject
  @VisibleForTesting
  protected InstantInventoryConfig config;

  @Inject
  protected Features featureInstances;

  @Inject
  protected ClientThread clientThread;

  /**
   * Make sure all features are in its correct state
   */
  public void updateAllFeatureStatus() {
    updateFeatureStatus(featureInstances.getDropFeature(), config.instantDrop());
    updateFeatureStatus(featureInstances.getCleanHerbFeature(), config.instantClean());
    updateFeatureStatus(featureInstances.getDepositFeature(), config.instantDeposit());
    updateFeatureStatus(featureInstances.getEquipFeature(), config.instantEquip());
    updateFeatureStatus(featureInstances.getWithdrawFeature(), config.instantWithdraw());
    updateFeatureStatus(featureInstances.getPrayerFeature(), config.instantPrayer());
  }

  public void disableAllFeatures() {
    for (Feature feature : getActiveFeatures()) {
      disableFeature(feature);
    }
  }

  /**
   * @return Thread safe view of the currently active features
   */
  public Set<Feature> getActiveFeatures() {
    return Set.copyOf(activeFeatures);
  }

  /**
   * Make sure a feature is in its correct state, that is disabled when disabled in the config and
   * vice versa
   *
   * @param feature           The feature to check
   * @param isEnabledInConfig Whether the feature is currently enable in the config
   */
  @VisibleForTesting
  void updateFeatureStatus(@Nonnull Feature feature, boolean isEnabledInConfig) {
    boolean wasEnabled = activeFeatures.contains(feature);

    if (!wasEnabled && isEnabledInConfig) {
      enableFeature(feature);
    } else if (wasEnabled && !isEnabledInConfig) {
      disableFeature(feature);
    }
  }

  /**
   * Enable a feature, meaning it is listing to events and generally acting as a mini-plugin
   *
   * @param feature The feature to enable
   */
  @VisibleForTesting
  void enableFeature(@Nonnull Feature feature) {
    clientThread.invoke(() -> {
      log.debug("Enabling {}", feature.getConfigKey());
      eventBus.register(feature);
      activeFeatures.add(feature);
      feature.onEnable();
      feature.reset();
    });
  }

  /**
   * Disable a feature, it will no longer receive events
   *
   * @param feature The feature to disable
   */
  @VisibleForTesting
  void disableFeature(@Nonnull Feature feature) {
    clientThread.invoke(() -> {
      log.debug("Disabling {}", feature.getConfigKey());
      eventBus.unregister(feature);
      activeFeatures.remove(feature);
      feature.onDisable();
      feature.reset();
    });
  }
}

/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature.features;

import com.google.common.annotations.VisibleForTesting;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import no.elg.ii.feature.Feature;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.model.HerbInfo;
import no.elg.ii.service.WidgetService;

@Singleton
@NoArgsConstructor
public class CleanHerbFeature implements Feature {

  public static final String CLEAN_OPTION = "Clean";
  public static final String CLEAN_CONFIG_KEY = "instantClean";

  @Inject
  @VisibleForTesting
  public Client client;

  @Inject
  @Getter
  private InventoryState state;

  @Inject
  private WidgetService widgetService;

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null && !event.isConsumed()) {
      String menuOption = event.getMenuOption();
      if (CLEAN_OPTION.equals(menuOption)) {
        int itemId = event.getItemId();
        HerbInfo herbInfo = HerbInfo.HERBS.get(itemId);
        if (herbInfo == null) {
          return;
        }
        int herbloreLevel = client.getBoostedSkillLevel(Skill.HERBLORE);
        if (herbloreLevel >= herbInfo.getMinLevel()) {
          state.setSlot(widget.getIndex(), herbInfo.getCleanItemId(), widget.getItemQuantity(), widgetService.getChangeOpacity());
        }
      }
    }
  }

  @Override
  @NonNull
  public String getConfigKey() {
    return CLEAN_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature.features;

import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import no.elg.ii.feature.HideFeature;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.model.IndexedWidget;
import no.elg.ii.service.InventoryService;
import no.elg.ii.service.VarService;
import no.elg.ii.util.Util;
import no.elg.ii.util.WidgetUtils;

@Slf4j
@Singleton
@NoArgsConstructor
public class DepositFeature extends HideFeature {

  public static final String DEPOSIT_PREFIX_OPTION = "Deposit-";
  public static final String DEPOSIT_ALL_OPTION = "Deposit inventory";
  public static final String ADD_ALL_OPTION = "Add all";
  public static final String DEPOSIT_CONFIG_KEY = "instantDeposit";

  @Inject
  private InventoryService inventoryService;
  @Inject
  private ItemManager itemManager;
  @Inject
  private InventoryState inventoryState;
  @Inject
  private VarService varService;

  /**
   * @param indexedWidget The indexed widget to check
   * @return If this slot is unlocked or bank slot locks are disabled
   */
  public boolean isSlotUnlocked(IndexedWidget indexedWidget) {
    int slotIndex = indexedWidget.getIndex();

    if (varService.isVarbitTrue(VarbitID.BANK_SIDE_SLOT_IGNOREINVLOCKS)) {
      return true;
    }
    int slotMask = (1 << slotIndex); // Bit that should be set for the slot
    return (slotMask & varService.varbitValue(VarbitID.BANK_SIDE_SLOT_OVERVIEW)) == 0;
  }

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null && !event.isConsumed()) {
      String menuOption = event.getMenuOption();
      if (DEPOSIT_ALL_OPTION.equals(menuOption) || ADD_ALL_OPTION.equals(menuOption)) {
        log.debug("Hiding all items");
        inventoryService.getAllOpenInventoryWidgets()
          .filter(iw -> WidgetUtils.isNotEmpty(iw.getWidget()))
          .filter(this::isSlotUnlocked)
          .forEach(indexedWidget -> hide(indexedWidget.getWidget()));
        return;
      }
      int eventItemId = event.getItemId();
      int clickedIndex = widget.getIndex();
      if (menuOption != null && (menuOption.startsWith(DEPOSIT_PREFIX_OPTION))) {
        int toTake = Util.getNumberFromMenuOption(menuOption, widget);
        if (toTake == Util.NO_MENU_OPTION_NUMBER) {
          return;
        }
        int actualTaken;
        if (toTake >= widget.getItemQuantity()) {
          log.debug("Hiding {} items", toTake);

          Set<IndexedWidget> itemToTake = inventoryService.getAllOpenInventoryWidgets()
            .filter(it -> {
              InventorySlot slot = inventoryState.getSlot(it.getWidget().getIndex());
              return it.getIndex() == clickedIndex || slot != null && !slot.hasValidItemId() && it.getWidget().getItemId() == eventItemId;
            })
            .filter(this::isSlotUnlocked)
            .sorted()
            .limit(toTake)
            .collect(Collectors.toUnmodifiableSet());
          itemToTake.forEach(indexedWidget -> hide(indexedWidget.getWidget()));
          actualTaken = itemToTake.stream().mapToInt(iw -> iw.getWidget().getItemQuantity()).sum();
        } else {
          int ui = widget.getItemQuantity() - toTake;
          log.debug("Updating item quantity from {} be {}", widget.getItemQuantity(), ui);
          getState().setSlot(widget.getIndex(), widget.getItemId(), ui, widgetService.getChangeOpacity());
          actualTaken = toTake;
        }

        int canonItemId = itemManager.canonicalize(eventItemId);
        //Update widget in bank
        Widget bankInventoryContainer = client.getWidget(ComponentID.BANK_ITEM_CONTAINER);
        if (bankInventoryContainer != null) {
          for (Widget bankWidget : bankInventoryContainer.getDynamicChildren()) {
            if (itemManager.canonicalize(bankWidget.getItemId()) == canonItemId) {
              widgetService.setQuantity(bankWidget, bankWidget.getItemQuantity() + actualTaken);
              return;
            }
          }
        }
      }
    }
  }

  @Override
  public @NonNull String getConfigKey() {
    return DEPOSIT_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature.features;

import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import no.elg.ii.feature.HideFeature;
import no.elg.ii.service.VarService;
import no.elg.ii.util.WidgetUtils;

@Slf4j
@Singleton
@NoArgsConstructor
public class DropFeature extends HideFeature {

  public static final String DROP_OPTION = "Drop";
  public static final String DROP_CONFIG_KEY = "instantDrop";

  @Inject
  private ItemManager itemManager;

  @Inject
  private VarService varService;

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null && !event.isConsumed()) {
      String menuOption = event.getMenuOption();
      if (DROP_OPTION.equals(menuOption)) {
        log.debug("Dropped item {}", WidgetUtils.debugInfo(widget));
        if (willDropWarningBeShownForItem(widget.getItemId(), widget.getItemQuantity())) {
          log.debug("Drop warning will be shown, will not hide item");
        } else {
          hide(widget);
        }
      }
    }
  }

  public boolean willDropWarningBeShownForItem(int itemId, int quantity) {
    if (varService.isVarbitFalse(VarbitID.OPTION_DROPWARNING_ON)) {
      return false;
    }
    var canonItemId = itemManager.canonicalize(itemId);
    var price = itemManager.getItemPriceWithSource(canonItemId, false);
    return varService.varbitValue(VarbitID.OPTION_DROPWARNING_VALUE) < price * quantity;
  }

  @Override
  public @NonNull String getConfigKey() {
    return DROP_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.features;

import com.google.common.annotations.VisibleForTesting;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemEquipmentStats;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;
import no.elg.ii.feature.Feature;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.model.IndexedWidget;
import no.elg.ii.service.InventoryService;
import no.elg.ii.service.WidgetService;
import no.elg.ii.util.WidgetUtils;
import org.apache.commons.lang3.tuple.Pair;


@Slf4j
@Singleton
@NoArgsConstructor
public class EquipFeature implements Feature {

  public static final Set<String> EQUIP_OPTIONS = Set.of("Wear", "Wield", "Equip");
  public static final String EQUIP_CONFIG_KEY = "instantEquip";

  @Inject
  @VisibleForTesting
  ItemManager itemManager;

  @Inject
  @VisibleForTesting
  Client client;
  @Inject
  @VisibleForTesting
  ClientThread clientThread;

  @Inject
  @Getter
  private InventoryState state;
  @Inject
  private WidgetService widgetService;
  @Inject
  private InventoryService inventoryService;

  /**
   * The last tick each slot was equipped
   */
  private final Map</*slotIdx*/ Integer, /*last tick count changed*/ Integer> lastEquipped = new HashMap<>(EquipmentInventorySlot.values().length);

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null && !event.isConsumed()) {
      String menuOption = event.getMenuOption();
      if (EQUIP_OPTIONS.contains(menuOption)) {
        log.debug("'{}' item {}", menuOption, WidgetUtils.debugInfo(widget));
        clientThread.invokeAtTickEnd(() -> equip(widget));
      }
    }
  }

  private static final String TOO_LOW_LEVEL_MESSAGE = "You are not a high enough level to use this item.";

  @Subscribe
  public void onChatMessage(ChatMessage event) {
    if (event.getType() == ChatMessageType.GAMEMESSAGE && TOO_LOW_LEVEL_MESSAGE.equals(event.getMessage())) {
      log.debug("Failed to equip item");
      state.getActiveSlots().filter(is -> is.getSlot().getChangedTick() == client.getTickCount()).forEach(is -> state.resetState(is.getIndex()));
    }
  }

  protected void equip(@Nonnull Widget widget) {
    ItemContainer inventoryContainer = inventoryService.getCurrentInventoryContainer();
    if (inventoryContainer == null) {
      log.debug("Failed to find the inventory container");
      return;
    }
    @Nullable Pair<Item, Item> itemIds = getEquipmentToReplace(widget);
    if (itemIds == null) {
      return;
    }

    @Nullable Item toReplaceItem = itemIds.getLeft();
    int opacity;
    if (toReplaceItem != null) {
      log.trace("An item was equipped in the slot (to replace: {}), will replace it with {}", WidgetUtils.debugInfo(toReplaceItem), WidgetUtils.debugInfo(widget));
      Item extraItem = itemIds.getRight();
      if (extraItem != null) {
        log.trace("There is also something in the off-slot ({}), will replace that too", WidgetUtils.debugInfo(extraItem));
        Optional<Widget> offhandWidget = inventoryService.getAllOpenInventoryWidgets().filter(WidgetUtils::isEmpty).findFirst().map(IndexedWidget::getWidget);
        if (offhandWidget.isPresent()) {
          widgetService.setFakeWidgetItem(widget, toReplaceItem);
          widgetService.setFakeWidgetItem(offhandWidget.get(), extraItem);
        } else {
          //There was no slot to put the offhand item in, so the items will not be equipped
          log.debug("Will not equip two-handed item, as there is no slot to put the offhand item in");
          return;
        }
      } else {
        log.trace("No off-hand item to replace, will only change the clicked slot");
        widgetService.setFakeWidgetItem(widget, toReplaceItem);
      }
      opacity = widgetService.getChangeOpacity();
    } else {
      log.trace("No other item to replace, will show the slot as empty");
      widgetService.setEmptyItem(widget);
      opacity = widgetService.getHideOpacity();
    }
    state.setSlot(widget, opacity);
  }

  /**
   * @param widget the widget to equip
   * @return The item that was equipped (left) and potentially the off-hand item that was equipped (right) if it will be unequipped
   */
  @VisibleForTesting
  @Nullable
  public Pair<Item, Item> getEquipmentToReplace(Widget widget) {
    final ItemStats itemStats = itemManager.getItemStats(widget.getItemId());
    if (itemStats == null || !itemStats.isEquipable()) {
      log.debug("Item has not status or is not equipable, will not equip it: {}", itemStats);
      return null;
    }
    Item toReplace = null;
    Item extra = null;

    final ItemEquipmentStats clickedEquipment = itemStats.getEquipment();

    ItemContainer equipmentContainer = client.getItemContainer(InventoryID.WORN);
    if (clickedEquipment != null && equipmentContainer != null) {
      if (lastEquipped.getOrDefault(clickedEquipment.getSlot(), 0) == client.getTickCount()) {
        log.debug("We have already equipped an item in the same slot this tick, will not replace it");
        return null;
      }
      final int slotOfClickedItem = clickedEquipment.getSlot();
      toReplace = equipmentContainer.getItem(slotOfClickedItem);

      if (isWeaponSlot(slotOfClickedItem)) {
        if (clickedEquipment.isTwoHanded()) {
          extra = equipmentContainer.getItem(EquipmentInventorySlot.SHIELD.getSlotIdx());
        }
      } else if (isShieldSlot(slotOfClickedItem)) {
        var weaponItem = equipmentContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
        if (weaponItem != null) {
          ItemStats weaponStat = itemManager.getItemStats(weaponItem.getId());
          if (weaponStat != null && weaponStat.isEquipable()) {
            ItemEquipmentStats weaponStatEquipment = weaponStat.getEquipment();
            if (weaponStatEquipment != null && weaponStatEquipment.isTwoHanded()) {
              //If we click a shield while have a two-handed weapon equipped, the weapon get unequipped
              extra = weaponItem;
            }
          }
        }
      }
      lastEquipped.put(clickedEquipment.getSlot(), client.getTickCount());
    }
    if (extra != null && toReplace == null) {
      return Pair.of(extra, null);
    }
    return Pair.of(toReplace, extra);
  }

  private static boolean isShieldSlot(int index) {
    return index == EquipmentInventorySlot.SHIELD.getSlotIdx();
  }

  private static boolean isWeaponSlot(int index) {
    return index == EquipmentInventorySlot.WEAPON.getSlotIdx();
  }

  @Override
  public @NonNull String getConfigKey() {
    return EQUIP_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.features;

import static net.runelite.api.gameval.VarbitID.QUICKPRAYER_ACTIVE;
import static net.runelite.api.gameval.VarbitID.QUICKPRAYER_SELECTED;
import static no.elg.ii.model.PrayerInfo.INTERFACE_TO_BIT;

import java.util.Map;
import java.util.function.IntBinaryOperator;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptEvent;
import net.runelite.api.Skill;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import no.elg.ii.feature.Feature;
import no.elg.ii.feature.state.PrayerState;
import no.elg.ii.model.PrayerInfo;
import no.elg.ii.service.VarService;
import no.elg.ii.service.WidgetService;
import no.elg.ii.util.WidgetUtils;

@Slf4j
@Singleton
@NoArgsConstructor
public class PrayerFeature implements Feature {

  public static final String PRAYER_CONFIG_KEY = "instantPrayer";

  /**
   * Index of the background/highlight widget for a prayer
   */
  private static final int BACKGROUND_PRAYER_INDEX = 0;

  /**
   * Script called when clicking a prayer in the prayer book
   */
  private static final int TOGGLE_SINGLE_PRAYER_SCRIPT_ID = 462;

  /**
   * Script called when toggling quick prayer orb
   */
  private static final int TOGGLE_QUICK_PRAYER_SCRIPT_ID = 455;

  @Nonnull
  private static final IntBinaryOperator TOGGLE_OP = (prayerState, bit) -> prayerState ^ bit;
  @Nonnull
  private static final IntBinaryOperator ENABLE_OP = (prayerState, bit) -> prayerState | bit;

  @Inject
  @Getter
  private PrayerState state;

  @Inject
  private Client client;

  @Inject
  private VarService varService;

  @Inject
  private ClientThread clientThread;

  @Inject
  private WidgetService widgetService;

  @Subscribe
  public void onBeforeRender(BeforeRender event) {
    assert client.isClientThread();
    render();
  }

  @Subscribe
  public void onGameTick(final GameTick event) {
    assert client.isClientThread();
    state.validateAll();
  }

  /* (non-javadoc)
   * We cannot use ScriptPostFired, because it does not contain the source widget.
   * And as the code suggest, we use the widget id to determine which prayer was toggled.
   */
  @Subscribe
  public void onScriptPreFired(final ScriptPreFired event) {
    assert client.isClientThread();
    if (event.getScriptId() == TOGGLE_SINGLE_PRAYER_SCRIPT_ID && hasPrayerPoints()) {
      ScriptEvent scriptEvent = event.getScriptEvent();
      if (scriptEvent != null) {
        Widget src = scriptEvent.getSource();
        if (src != null) {
          var prayerBit = INTERFACE_TO_BIT.getOrDefault(src.getId(), 0);
          if (prayerBit != 0) {
            updateBit(prayerBit, TOGGLE_OP);
          }
        }
      }
    }
  }

  /* (non-javadoc)
   * Use the ScriptPostFired event because the QUICKPRAYER_ACTIVE varbit is updated by the TOGGLE_QUICK_PRAYER_SCRIPT_ID
   * We cannot use VarbitChanged event because it does not toggle the prayers correctly off.
   * Also, it is called from multiple places, and we are only interested in when the player toggles quick prayer.
   */
  @Subscribe
  public void onScriptPostFired(final ScriptPostFired event) {
    assert client.isClientThread();
    if (event.getScriptId() == TOGGLE_QUICK_PRAYER_SCRIPT_ID && hasPrayerPoints()) {
      if (varService.isVarbitTrue(QUICKPRAYER_ACTIVE)) {
        int quickPrayerBits = varService.varbitValue(QUICKPRAYER_SELECTED);
        // turn on quick prayers, conflicting prayers will be automatically turned off by update
        if (log.isDebugEnabled()) {
          log.debug("[{}] Quick prayers ON bits={}", client.getTickCount(), Integer.toBinaryString(quickPrayerBits));
        }
        enableAllBits(quickPrayerBits);
      } else {
        if (log.isDebugEnabled()) {
          log.debug("[{}] Quick prayers OFF -> clearing all", client.getTickCount());
        }
        // Quick prayer will turn off all prayers when toggled off, not just the configured prayers
        state.setPrayerState(0);
      }
    }
  }

  /**
   * @return Whether the player has any prayer points left to use prayers
   */
  private boolean hasPrayerPoints() {
    return client.getBoostedSkillLevel(Skill.PRAYER) > 0;
  }

  /**
   * Enable all bits one at a time so that conflicts are resolved correctly
   */
  private void enableAllBits(int prayerBits) {
    int remaining = prayerBits;
    while (remaining != 0) {
      // find the next lowest bit that is on
      int bit = Integer.lowestOneBit(remaining);
      // clear the bit (we know it was on)
      remaining ^= bit;
      updateBit(bit, ENABLE_OP);
    }
  }

  /**
   * Update a single prayer bit using the provided operator.
   *
   * @param prayerBit The prayer bit to update. Must only have one bit set.
   * @param op        How to update {@code prayerBit}
   */
  private void updateBit(int prayerBit, @NonNull IntBinaryOperator op) {
    assert Integer.bitCount(prayerBit) == 1;
    int prayerState = state.getPrayerState();
    int tweakedPrayerState = op.applyAsInt(prayerState, prayerBit);
    int updateValue = update(tweakedPrayerState, prayerBit);
    state.setPrayerState(updateValue);
    if (log.isDebugEnabled()) {
      log.debug("[{}] Toggled prayer: old state {}, tweaked prayer state {}, updated value {}", client.getTickCount(), Integer.toBinaryString(prayerState), Integer.toBinaryString(tweakedPrayerState), Integer.toBinaryString(updateValue));
    }
  }

  /**
   * Update the prayer state, making sure no conflicting prayers are active at the same time.
   *
   * @param tweakedState The new prayer state. Must be only bit different from the current state.
   * @return The corrected prayer state
   */
  private int update(int tweakedState, int prayerBit) {
    int initState = state.getPrayerState();
    if (initState == tweakedState) {
      if (log.isDebugEnabled()) {
        log.debug("[{}] Skipping update, tweaked state did not differ from init state", client.getTickCount());
      }
      // We might get here when enabling quick prayers that were already manually enabled
      return initState;
    }
    //Only one bit should be different, and that bit should be the prayerBit
    assert Integer.bitCount(prayerBit) == 1
      : "prayerBit must have exactly one bit set, prayerBit = " + Integer.toBinaryString(prayerBit);
    assert (initState ^ tweakedState) == prayerBit
      : "Unexpected diff. expected=" + Integer.toBinaryString(prayerBit) + " actual=" + Integer.toBinaryString(initState ^ tweakedState);

    if (initState == 0) {
      if (log.isDebugEnabled()) {
        log.debug("[{}] init state has no prayer, returning tweaked state", client.getTickCount());
      }
      return tweakedState;
    }
    if ((tweakedState & prayerBit) == 0) {
      // A prayer was disabled, no need to check for conflicts
      // we know here (by assertions) that it was on in the initState
      if (log.isDebugEnabled()) {
        log.debug("[{}] Prayer disabled. No need for conflict checking returning early", client.getTickCount());
      }
      return tweakedState;
    }

    // A prayer was enabled, check for conflicts

    int nextState = tweakedState;
    for (int prayerConflictMask : PrayerInfo.CONFLICTING_PRAYERS) {
      int activeInGroup = nextState & prayerConflictMask;
      assert Integer.bitCount((initState & prayerConflictMask)) <= 1
        : "Unexpected conflict in initState with a conflict mask. initState & prayerConflictMask= " + Integer.toBinaryString((initState & prayerConflictMask)) + " initState=" + Integer.toBinaryString(initState) + " prayerConflictMask=" + Integer.toBinaryString(prayerConflictMask);
      if (Integer.bitCount(activeInGroup) > 1) {
        // Keep only the just-enabled prayerBit in this conflict group
        nextState = (nextState & ~prayerConflictMask) | prayerBit;
      }
    }
    if (log.isDebugEnabled()) {
      log.debug("[{}] init state {}, final state {} (diff {})", client.getTickCount(), Integer.toBinaryString(initState), Integer.toBinaryString(nextState), Integer.toBinaryString(initState ^ nextState));
    }
    return nextState;
  }

  /**
   * Modify whether the prayer book is active based on the internal prayer state.
   */
  private void render() {
    //Only update background widget when prayers was or is active
    // The lastPrayerState is needed to make sure we disable the prayers when they are turned off
    int prayerState = state.getPrayerState();
    if ((prayerState != 0 || state.getLastPrayerState() != 0)) {
      Widget prayerContainer = client.getWidget(InterfaceID.Prayerbook.CONTAINER);
      if (prayerContainer != null && !prayerContainer.isHidden()) {
        int serverState = state.getServerPrayerState();
        for (Map.Entry<Integer, Integer> entry : INTERFACE_TO_BIT.entrySet()) {
          int prayerBit = entry.getValue();
          int prayerWidgetId = entry.getKey();
          Widget prayerWidget = client.getWidget(prayerWidgetId);
          if (prayerWidget != null) {
            Widget backgroundWidget = prayerWidget.getChild(BACKGROUND_PRAYER_INDEX);
            if (backgroundWidget != null) {
              // prayer is hidden when the bit is not set in the prayer state
              boolean hidden = (prayerBit & prayerState) == 0;
              boolean serverHidden = (prayerBit & serverState) == 0;
              customizeWidget(backgroundWidget, hidden, serverHidden);
              if (prayerState == 0) {
                // this render will not run next tick so make sure we are resetting everything
                clientThread.invokeLater(() -> {
                  backgroundWidget.setHidden(hidden);
                  backgroundWidget.setOpacity(WidgetUtils.FULLY_OPAQUE);
                });
              }
            }
          }
        }
      }
    }
  }

  private void customizeWidget(@Nonnull Widget backgroundWidget, boolean hidden, boolean serverHidden) {
    if (hidden != serverHidden) {
      backgroundWidget.setHidden(false);
      if (hidden) {
        backgroundWidget.setOpacity(widgetService.getPrayerDisableOpacity());
      } else {
        backgroundWidget.setOpacity(widgetService.getPrayerEnableOpacity());
      }
    } else {
      backgroundWidget.setHidden(serverHidden);
      backgroundWidget.setOpacity(WidgetUtils.FULLY_OPAQUE);
    }
  }

  @Override
  public @NonNull String getConfigKey() {
    return PRAYER_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.features;

import static no.elg.ii.util.InventoryUtil.findFirst;
import static no.elg.ii.util.WidgetUtils.ZERO_QUANTITY_BANK_ITEM_OPACITY;
import static no.elg.ii.util.WidgetUtils.isEmpty;

import com.google.common.annotations.VisibleForTesting;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import no.elg.ii.feature.Feature;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.service.VarService;
import no.elg.ii.service.WidgetService;
import no.elg.ii.util.Util;
import no.elg.ii.util.WidgetUtils;

@Slf4j
@Singleton
@NoArgsConstructor
public class WithdrawFeature implements Feature {

  public static final String WITHDRAW_PREFIX_OPTION = "Withdraw-";
  public static final String WITHDRAW_CONFIG_KEY = "instantWithdraw";

  @Inject
  @VisibleForTesting
  Client client;

  @Inject
  @VisibleForTesting
  public ItemManager itemManager;

  @Inject
  @Getter
  private InventoryState state;
  @Inject
  private WidgetService widgetService;
  @Inject
  private VarService varService;

  @Subscribe
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget bankWidget = event.getWidget();
    if (bankWidget != null && !event.isConsumed()) {
      String menuOption = event.getMenuOption();
      if (menuOption != null && menuOption.startsWith(WITHDRAW_PREFIX_OPTION)) {
        int amount = Util.getNumberFromMenuOption(menuOption, bankWidget);
        if (amount == Util.NO_MENU_OPTION_NUMBER) {
          return;
        }
        log.debug("Withdrawing item {}", WidgetUtils.debugInfo(bankWidget));
        withdraw(bankWidget, amount);
      }
    }
  }

  private void withdraw(Widget bankWidget, int amount) {
    int originalItemId = bankWidget.getItemId();
    ItemComposition originalComposition = itemManager.getItemComposition(originalItemId);

    //If we're withdrawing as a note, we need to get the item id of the note as the banked item is never the noted item
    int bankWidgetItemId;
    ItemComposition bankWidgetComposition;
    if (isWithdrawingAsNote() && isItemNotable(originalComposition)) {
      bankWidgetItemId = originalComposition.getLinkedNoteId();
      bankWidgetComposition = itemManager.getItemComposition(bankWidgetItemId);
    } else {
      bankWidgetItemId = originalItemId;
      bankWidgetComposition = originalComposition;
    }

    //Only withdraw the amount that is available
    int quantityToWithdraw = Math.min(bankWidget.getItemQuantity(), amount);

    if (bankWidgetComposition.isStackable()) {
      Widget inventoryWidget = findFirst(client, ComponentID.BANK_INVENTORY_ITEM_CONTAINER, w -> w.getItemId() == bankWidgetItemId);
      if (inventoryWidget != null) {
        //There is a matching widget, so we can just update the quantity
        updateBankItem(bankWidget, quantityToWithdraw);
        widgetService.updateQuantity(inventoryWidget, quantityToWithdraw);
        getState().setSlot(inventoryWidget.getIndex(), bankWidgetItemId, inventoryWidget.getItemQuantity(), widgetService.getChangeOpacity());
      } else {
        fillFirstEmpty(bankWidget, bankWidgetItemId, quantityToWithdraw);
      }
    } else {
      //Item is not stackable, so we have to fill the inventory with the item until we run out of space or items
      for (int i = 0; i < quantityToWithdraw; i++) {
        boolean outOfSpace = fillFirstEmpty(bankWidget, bankWidgetItemId, 1);
        if (outOfSpace) {
          break;
        }
      }
    }
  }

  /**
   * @return Whether the item can be noted
   */
  private boolean isItemNotable(ItemComposition itemComposition) {
    return itemComposition.getLinkedNoteId() > 0;
  }

  /**
   * @return {@code false} if there is no more space in the inventory, {@code true} otherwise
   */
  private boolean fillFirstEmpty(Widget bankWidget, int actualItemId, int quantityToWithdraw) {
    var emptyWidget = findFirst(client, ComponentID.BANK_INVENTORY_ITEM_CONTAINER, widget -> {
      @Nullable
      InventorySlot slot = getState().getSlot(widget.getIndex());
      return isEmpty(widget) && slot != null && !slot.hasValidItemId();
    });
    if (emptyWidget != null) {
      widgetService.setFakeWidgetItem(emptyWidget, actualItemId, quantityToWithdraw);
      updateBankItem(bankWidget, quantityToWithdraw);
      getState().setSlot(emptyWidget.getIndex(), bankWidget.getItemId(), quantityToWithdraw, widgetService.getChangeOpacity());
      return false;
    }
    return true;
  }

  private void updateBankItem(@NonNull Widget bankWidget, int quantityToWithdraw) {
    widgetService.updateQuantity(bankWidget, -quantityToWithdraw);
    log.debug("Removing {} from bank widget {}", quantityToWithdraw, WidgetUtils.debugInfo(bankWidget));
    if (bankWidget.getItemQuantity() == 0) {
      if (isPlaceholdersDisabled()) {
        log.debug("Hiding bank widget, new quantity is 0 and placeholders are disabled");
        widgetService.setAsHideOpacity(bankWidget, false);
      } else {
        widgetService.setOpacity(bankWidget, ZERO_QUANTITY_BANK_ITEM_OPACITY, false);
      }
    } else {
      widgetService.setAsChangeOpacity(bankWidget, false);
    }
  }

  /**
   * @return Whether the bank is set to withdraw as a note
   */
  private boolean isWithdrawingAsNote() {
    return varService.isVarbitTrue(VarbitID.BANK_WITHDRAWNOTES);
  }

  private boolean isPlaceholdersDisabled() {
    return varService.isVarbitFalse(VarbitID.BANK_LEAVEPLACEHOLDERS);
  }

  @Override
  public @NonNull String getConfigKey() {
    return WITHDRAW_CONFIG_KEY;
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature;

import com.google.common.annotations.VisibleForTesting;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import no.elg.ii.feature.features.CleanHerbFeature;
import no.elg.ii.feature.features.DepositFeature;
import no.elg.ii.feature.features.DropFeature;
import no.elg.ii.feature.features.EquipFeature;
import no.elg.ii.feature.features.PrayerFeature;
import no.elg.ii.feature.features.WithdrawFeature;

@Singleton
@Data
@AllArgsConstructor
@NoArgsConstructor
public final class Features {

  @Inject
  @VisibleForTesting
  private DropFeature dropFeature;

  @Inject
  @VisibleForTesting
  private CleanHerbFeature cleanHerbFeature;

  @Inject
  @VisibleForTesting
  private DepositFeature depositFeature;

  @Inject
  @VisibleForTesting
  private EquipFeature equipFeature;

  @Inject
  @VisibleForTesting
  private WithdrawFeature withdrawFeature;

  @Inject
  @VisibleForTesting
  private PrayerFeature prayerFeature;
}

/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature;

import com.google.common.annotations.VisibleForTesting;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.InstantInventoryPlugin;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.service.WidgetService;

@Slf4j
@NoArgsConstructor
public abstract class HideFeature implements Feature {

  @Inject
  public InstantInventoryPlugin plugin;

  @Inject
  @VisibleForTesting
  protected InstantInventoryConfig config;

  @Inject
  public ClientThread clientThread;

  @Inject
  @Getter
  private InventoryState state;

  @Inject
  public Client client;

  @Inject
  public WidgetService widgetService;

  protected void hide(@Nonnull Widget widget) {
    state.setSlot(widget, widgetService.getHideOpacity());
  }
}

/*
 * Copyright (c) 2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.state;

/**
 *
 */
public interface FeatureState {

  /**
   * Reset the state to its initial state
   */
  void resetAll();

  /**
   * Validate the state of the feature
   * <p>
   * Must be called on the client thread
   */
  void validateAll();

}

/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.feature.state;

import static no.elg.ii.inventory.slot.InventorySlot.INVALID_ITEM_ID;
import static no.elg.ii.util.InventoryUtil.INVENTORY_SIZE;

import com.google.common.annotations.VisibleForTesting;
import java.util.Arrays;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.InstantInventoryPlugin;
import no.elg.ii.feature.Feature;
import no.elg.ii.inventory.slot.IndexedInventorySlot;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.model.IndexedWidget;
import no.elg.ii.service.InventoryService;
import no.elg.ii.service.WidgetService;

/**
 * Hold the state of the players inventory. The state is checked every server tick in
 * {@link InstantInventoryPlugin#onGameTick(GameTick)}
 * <p>
 * A {@link Feature} uses this class to handle how to render the changes on the client. Typically, a
 * feature will modify the rendering of a given item in the inventory of the player when the
 * {@link #getSlot(int)} is different to {@link InventorySlot#INVALID_ITEM_ID}.
 * <p>
 * The state should only be modified by the client thread
 */
@EqualsAndHashCode
@Slf4j
@AllArgsConstructor
@NoArgsConstructor
@Singleton
public class InventoryState implements FeatureState {

  /**
   * Maximum number of ticks an item should be displayed as something else
   */
  public static final int DEFAULT_MAX_UNMODIFIED_TICKS = 1;

  /**
   * The tick the item was modified
   */
  private final InventorySlot[] slots = new InventorySlot[INVENTORY_SIZE];

  @Inject
  @VisibleForTesting
  InstantInventoryConfig config;

  @Inject
  @VisibleForTesting
  Client client;

  @Inject
  private InventoryService inventoryService;

  @Inject
  private WidgetService widgetService;

  {
    Arrays.fill(slots, InventorySlot.UNMODIFIED_SLOT);
  }

  /**
   * Update the {@code itemId} at {@code index} will also update which tick the item was modified
   */
  public void setSlot(Widget widget, int opacity) {
    int index = widget.getIndex();
    setSlot(index, new InventorySlot(client.getTickCount(), widget.getItemId(), widget.getItemQuantity(), opacity));
  }

  /**
   * Update the {@code itemId} at {@code index} will also update which tick the item was modified
   *
   * @param index  The index of the item
   * @param itemId The new itemId, intended to be the current item in the players inventory
   */
  public void setSlot(int index, int itemId, int quantity, int opacity) {
    setSlot(index, new InventorySlot(client.getTickCount(), itemId, quantity, opacity));
  }

  private void setSlot(int index, @Nonnull InventorySlot slot) {
    assert this.client.isClientThread();
    if (isValidIndex(index)) {
      log.trace("Setting index {} to {}", index, slot);
      slots[index] = slot;
    } else {
      log.debug("Tried to set invalid index {} to {}", index, slot);
    }
  }

  @Nullable
  public InventorySlot getSlot(int index) {
    assert this.client.isClientThread();
    if (isInvalidIndex(index)) {
      log.debug("Tried to get invalid index {}", index);
      return null;
    }
    return slots[index];
  }

  public static boolean isValidIndex(int index) {
    return index >= 0 && index < INVENTORY_SIZE;
  }

  public static boolean isInvalidIndex(int index) {
    return index < 0 || index >= INVENTORY_SIZE;
  }

  /**
   * @return The slots and its index we're currently modifying
   */
  public Stream<IndexedInventorySlot> getActiveSlots() {
    assert this.client.isClientThread();
    //noinspection DataFlowIssue Safe as we are always within the size of the inventory
    return IntStream.range(0, slots.length).mapToObj(i -> new IndexedInventorySlot(i, getSlot(i))).filter((iis) -> iis.getSlot().hasValidItemId());
  }

  @Override
  public void resetAll() {
    for (int i = 0; i < INVENTORY_SIZE; i++) {
      resetState(i);
    }
  }

  /**
   * Reset a given index to the initial state
   *
   * @param index The index of the item
   */
  public void resetState(int index) {
    resetState(index, null, false);
  }

  /**
   * Reset a given index to the initial state
   *
   * @param index The index of the item
   */
  private void resetState(int index, @Nullable Item item, boolean hasItem) {
    assert this.client.isClientThread();
    if (isValidIndex(index)) {
      log.trace("Resetting index {}", index);
      slots[index] = InventorySlot.RESET_SLOT;
      resetWidgetInSlot(index, item, hasItem);
    } else {
      log.debug("Tried to reset invalid index {}", index);
    }
  }

  /**
   * Update all inventory widgets to reflect the actual state of the inventory
   */
  private void resetWidgetInSlot(int index, @Nullable Item maybeItem, boolean hasItem) {
    assert this.client.isClientThread();
    Item item;
    if (hasItem) {
      item = maybeItem;
    } else {
      ItemContainer inventoryContainer = inventoryService.getCurrentInventoryContainer();
      if (inventoryContainer == null) {
        return;
      }
      item = inventoryContainer.getItem(index);
    }

    Stream<IndexedWidget> indexedWidgetStream = inventoryService.getAllOpenInventoryWidgets().filter(it -> it.getIndex() == index);
    if (item == null || item.getId() < 0) {
      //There is no item at this index, so we hide the widget
      //Make sure items that are not in the inventory are hidden
      indexedWidgetStream.forEach(it -> widgetService.setAsFullyOpaque(it.getWidget()));
    } else {
      //Update the item to the actual item
      indexedWidgetStream.forEach(it -> {
        widgetService.setAsFullyOpaque(it.getWidget());
        widgetService.updateVisibleWidget(it.getWidget(), item);
      });
    }
  }

  public static long msSinceChange(InventorySlot slot) {
    return System.currentTimeMillis() - slot.getChangedMs();
  }

  /**
   * @return If this inventory slot has still "Invulnerability Frames" left
   */
  public boolean isTooEarlyToReset(InventorySlot slot) {
    return msSinceChange(slot) < config.minChangedMs();
  }

  @Override
  public void validateAll() {
    ItemContainer itemContainer = inventoryService.getCurrentInventoryContainer();
    if (itemContainer != null) {
      for (int index = 0; index < INVENTORY_SIZE; index++) {
        Item item = itemContainer.getItem(index);
        validateState(index, item);
      }
    }
  }

  /**
   * Validate and modify the state of an item for a given index.
   * <p>
   * The state will be reset when the {@code actualItemId} indicates a different item exists in at
   * the index's inventory slot. Additionally, if too much time have passed without an item change,
   * the state will also be reset to not operate on stale data
   *
   * @param index The index of the item
   * @param item  The actual item which is in the inventory
   */
  public void validateState(int index, @Nullable Item item) {
    assert this.client.isClientThread();
    InventorySlot slot = getSlot(index);
    if (slot == null || slot == InventorySlot.UNMODIFIED_SLOT || slot == InventorySlot.RESET_SLOT) {
      // This item is not modified (or at least not by us) so we do not need to do anything
      return;
    }

    if (isTooEarlyToReset(slot)) {
      log.debug("Not resetting slot {} as it is too early", index);
      return;
    }
    int actualItemId = item == null ? INVALID_ITEM_ID : item.getId();
    int actualQuantity = item == null ? INVALID_ITEM_ID : item.getQuantity();

    int itemId = slot.getItemId();
    int quantity = slot.getQuantity();
    int modifiedTick = slot.getChangedTick();
    // Item at index changed so we must reset the slot
    if (slot.hasValidItemId() && (itemId != actualItemId || quantity != actualQuantity)) {
      log.debug("Item at index {} changed from item id {} to {} or from quantity {} to {}, resetting the item", index, itemId, actualItemId, quantity, actualQuantity);
      resetState(index, item, true);
      return;
    }

    // The item at the given index have not changes in some time, we reset to
    int ticksSinceModified = client.getTickCount() - modifiedTick;
    if (slot.hasChangedTick() && ticksSinceModified >= config.maxUnmodifiedTicks()) {
      log.debug("Item at index {} has not changed in {} tick ({} ms), resetting the item", index, ticksSinceModified, msSinceChange(slot));
      resetState(index, item, true);
    }
  }
}

/*
 * Copyright (c) 2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.state;

import javax.inject.Singleton;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * A no-op implementation of {@link FeatureState} that does nothing.
 * This is used when no state management is required.
 */
@Slf4j
@Singleton
@NoArgsConstructor
public class NoOpState implements FeatureState {
  @Override
  public void resetAll() {
  }

  @Override
  public void validateAll() {
  }
}

/*
 * Copyright (c) 2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.state;

import javax.inject.Inject;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;
import no.elg.ii.InstantInventoryConfig;

@Slf4j
@NoArgsConstructor
public class PrayerState implements FeatureState {

  @Inject
  Client client;

  @Inject
  InstantInventoryConfig pluginConfig;

  /**
   * Last tick server prayer state. Might be modified by client
   */
  @Getter
  private int lastPrayerState;

  /**
   * Current server prayer state. Might be modified by client
   */
  @Getter
  private int prayerState;

  /**
   * Current server prayer state. Never modified by client
   */
  @Getter
  private int serverPrayerState;

  private long lastManuallyModified;

  public void setPrayerState(int state) {
    this.prayerState = state;
    lastManuallyModified = System.currentTimeMillis();
  }

  @Override
  public void resetAll() {
    assert client.isClientThread();
    serverPrayerState = client.getServerVarbitValue(VarbitID.PRAYER_ALLACTIVE);
    prayerState = serverPrayerState;
    // Keep to record of last state on reset
    lastPrayerState = serverPrayerState;
  }

  @Override
  public void validateAll() {
    assert client.isClientThread();
    serverPrayerState = client.getServerVarbitValue(VarbitID.PRAYER_ALLACTIVE);
    if (shouldRevalidate()) {
      lastPrayerState = prayerState;
      prayerState = serverPrayerState;
    } else {
      // Skip reading server value as it likely does not reflect the clicked state.
      // This will prevent flickering of prayer icons when clicking fast on multiple conflicting prayers
      log.debug("Skipping prayer state revalidation, a manual modification was done ~ {} ms ago. Must wait at least {} ms", System.currentTimeMillis() - lastManuallyModified, pluginConfig.minChangedMs());
    }
  }

  /**
   *
   * @return Whether we should revalidate the state from server. This is to avoid overwriting manual changes too early
   */
  private boolean shouldRevalidate() {
    return System.currentTimeMillis() - lastManuallyModified >= pluginConfig.minChangedMs();
  }

}

/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii;

import static no.elg.ii.InstantInventoryConfig.GROUP;
import static no.elg.ii.feature.features.CleanHerbFeature.CLEAN_CONFIG_KEY;
import static no.elg.ii.feature.features.DepositFeature.DEPOSIT_CONFIG_KEY;
import static no.elg.ii.feature.features.DropFeature.DROP_CONFIG_KEY;
import static no.elg.ii.feature.features.EquipFeature.EQUIP_CONFIG_KEY;
import static no.elg.ii.feature.features.PrayerFeature.PRAYER_CONFIG_KEY;
import static no.elg.ii.feature.features.WithdrawFeature.WITHDRAW_CONFIG_KEY;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.util.Util;

@ConfigGroup(GROUP)
public interface InstantInventoryConfig extends Config {

  String GROUP = "instant-inventory";

  @ConfigSection(
    name = "Features",
    description = "Toggle different features of the plugin",
    position = 10
  )
  String FEATURE_SECTION = "instant-inventory-features";

  @ConfigSection(
    name = "Appearance",
    description = "How predicted widget will look",
    position = 0
  )
  String APPEARANCE_SECTION = "instant-inventory-appearance";

  @ConfigSection(
    name = "Advanced",
    description = "Advanced settings for all features",
    position = 20,
    closedByDefault = true
  )
  String ADVANCED_SECTION = "instant-inventory-advanced";

  /// ////////////////////////////////////////////////////////////////////////////////////////////////////////////

  @ConfigItem(
    keyName = DROP_CONFIG_KEY,
    name = "Drop Items Instantly",
    section = FEATURE_SECTION,
    description = "Drop items from the inventory instantly",
    position = 0
  )
  default boolean instantDrop() {
    return true;
  }

  @ConfigItem(
    keyName = CLEAN_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Clean Herbs Instantly",
    description = "Show the cleaned herb instantly",
    position = 1
  )
  default boolean instantClean() {
    return true;
  }

  @ConfigItem(
    keyName = DEPOSIT_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Deposit Items Instantly",
    description = "Deposit items into your bank instantly."
      + "<p>"
      + "<p>Note that how many items that can be deposited at a time is limited by how osrs works. It appears"
      + "<p>that only four items can be deposited in a single game tick, so if you deposit more than four items at "
      + "<p>once, you have to wait for the next game tick before the rest of the items are deposited.",
    position = 2
  )
  default boolean instantDeposit() {
    return true;
  }

  @ConfigItem(
    keyName = EQUIP_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Equip Items Instantly",
    description = "Equip wearable/wieldable items instantly",
    position = 3
  )
  default boolean instantEquip() {
    return true;
  }

  @ConfigItem(
    keyName = WITHDRAW_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Withdraw Items Instantly",
    description = "Withdraw items from your bank instantly",
    position = 4
  )
  default boolean instantWithdraw() {
    return true;
  }

  @ConfigItem(
    keyName = PRAYER_CONFIG_KEY,
    section = FEATURE_SECTION,
    name = "Prayer Switch Instantly",
    description = "Switch prayers instantly",
    position = 5
  )
  default boolean instantPrayer() {
    return true;
  }


  /// ////////////////////////////////////////////////////////////////////////////////////////////////////////////


  @ConfigItem(
    section = APPEARANCE_SECTION,
    keyName = "hideOpacityPercent",
    name = "Hidden items opacity",
    description = "How transparent items are when removed from the inventory or bank" +
      "<p>A lower value will cause items to be more transparent",
    position = 10
  )
  @Range(max = 100)
  @Units(Units.PERCENT)
  default int hideOpacityPercent() {
    return 20; //% transparent
  }

  @ConfigItem(
    section = APPEARANCE_SECTION,
    keyName = "changeOpacityPercent",
    name = "Changed items opacity",
    description = "How transparent items are when replaced with another item." +
      "<p>A lower value will cause items to be more transparent",
    position = 20
  )
  @Range(max = 100)
  @Units(Units.PERCENT)
  default int changeOpacityPercent() {
    return 75; //% transparent
  }

  @ConfigItem(
    section = APPEARANCE_SECTION,
    keyName = "prayerDisableOpacityPercent",
    name = "Disabled prayer opacity",
    description =
      "Temporary background opacity shown <i>after you click to disable</i> a prayer but <i>before the server confirms it is off</i>."
        + "<p>"
        + "<p>Applies only during this short prediction window."
        + "<p>Set to 0 to make it indistinguishable from normal inactive prayers."
        + "<p>"
        + "<p>Lower value makes background more transparent.",
    position = 30
  )
  @Range(max = 100)
  @Units(Units.PERCENT)
  default int prayerDisableOpacityPercent() {
    return 15; //% transparent
  }

  @ConfigItem(
    section = APPEARANCE_SECTION,
    keyName = "prayerEnableOpacityPercent",
    name = "Enabled prayer opacity",
    description =
      "Temporary background opacity shown <i>after you click to enable</i> a prayer but <i>before the server confirms it is active</i>."
        + "<p>"
        + "<p>Applies only during this short prediction window."
        + "<p>Set to 100 to make it indistinguishable from normal active prayers."
        + "<p>"
        + "<p>Lower value makes background more transparent.",
    position = 40
  )
  @Range(max = 100)
  @Units(Units.PERCENT)
  default int prayerEnableOpacityPercent() {
    return 80; //% transparent
  }

  /// ////////////////////////////////////////////////////////////////////////////////////////////////////////////


  @ConfigItem(
    section = ADVANCED_SECTION,
    keyName = "maxUnmodifiedTicks",
    name = "Max Unmodified Ticks",
    description =
      "How many game ticks (0.6s) an item should be displayed as something else before being reverted back."
        + "<p>"
        + "<p>If this is zero the item will always flicker back into existence,"
        + "<p>when this is 1 items will occasionally flicker back into view when the servers are unstable,"
        + "<p>and when this is 2+ flickering rarely happens (i.e., only when the server lags)."
        + "<p>"
        + "<p>When in PvP or Bossing it is recommended to set this to 1."
        + "<p>"
        + "<p>This setting applies only items and not generally.",
    position = 10
  )
  @Units(Units.TICKS)
  default int maxUnmodifiedTicks() {
    return InventoryState.DEFAULT_MAX_UNMODIFIED_TICKS;
  }

  @ConfigItem(
    section = ADVANCED_SECTION,
    keyName = "minChangedMs",
    name = "Min Changed Millis",
    description =
      "How many milliseconds an action should minimum stay changed before it can be reverted back to what the server says it is."
        + "<p>The default value is half a game tick, i.e, 300ms."
        + "<p>This setting is affected by the ping and performance of the server. If you see widgets flicker back into existence, increase this value."
        + "<p>"
        + "<p>This overwrites the \"Max Unmodified Ticks\" setting for inventory actions.",
    position = 20
  )
  @Units(Units.MILLISECONDS)
  default int minChangedMs() {
    return Util.TICK_LENGTH_MS / 2;
  }

}

/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii;

import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;
import java.util.Set;
import javax.inject.Inject;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import no.elg.ii.feature.Feature;
import no.elg.ii.feature.FeatureManager;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.service.DisallowModifiedWidgetInteractionService;
import no.elg.ii.service.EnsureWidgetStateService;

@Slf4j
@AllArgsConstructor
@NoArgsConstructor
@PluginDescriptor(
  name = "Instant Inventory",
  description = "Perform inventory actions instantly",
  tags = {"qol", "client", "drop", "clean", "herb", "equip", "withdraw", "item", "prayer"}
)
public class InstantInventoryPlugin extends Plugin {

  @Inject
  @VisibleForTesting
  protected Client client;

  @Inject
  @VisibleForTesting
  protected EventBus eventBus;

  @Inject
  @VisibleForTesting
  protected InstantInventoryConfig config;

  @Inject
  @VisibleForTesting
  protected FeatureManager featureManager;

  @Inject
  protected InventoryState inventoryState;
  @Inject
  protected ClientThread clientThread;

  //TODO If more services are added which only reacts to events, this should be redesigned to be more generic
  @Inject
  EnsureWidgetStateService ensureWidgetStateService;

  @Inject
  DisallowModifiedWidgetInteractionService disallowModifiedWidgetInteractionService;

  @Override
  protected void startUp() {
    featureManager.updateAllFeatureStatus();
    eventBus.register(ensureWidgetStateService);
    eventBus.register(disallowModifiedWidgetInteractionService);
  }

  @Override
  protected void shutDown() {
    // Disable all features when the plugin shuts down
    featureManager.disableAllFeatures();
    eventBus.unregister(ensureWidgetStateService);
    eventBus.unregister(disallowModifiedWidgetInteractionService);
  }

  /* (non-javadoc)
   * When an item is different in the inventory, unmark it as being hidden.
   *
   * This should run after client ticking to prevent flickering of items
   */
  @Subscribe(priority = Integer.MAX_VALUE)
  public void onGameTick(GameTick event) {
    clientThread.invokeLater(inventoryState::validateAll);
  }

  /* (non-javadoc)
   * Reset features when the state change as we do not want to operate on stale data
   */
  @Subscribe
  public void onGameStateChanged(GameStateChanged event) {
    if (event.getGameState() == GameState.LOGGED_IN) {
      log.debug("Resetting features as the GameState changed to {}", event.getGameState());
      Set<Feature> activeFeatures = featureManager.getActiveFeatures();
      for (Feature feature : activeFeatures) {
        feature.reset();
      }
    }
  }

  @Subscribe
  public void onConfigChanged(ConfigChanged configChanged) {
    if (InstantInventoryConfig.GROUP.equals(configChanged.getGroup())) {
      featureManager.updateAllFeatureStatus();
    }
  }

  @Provides
  InstantInventoryConfig provideConfig(ConfigManager configManager) {
    return configManager.getConfig(InstantInventoryConfig.class);
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.inventory.slot;

import javax.annotation.Nonnull;
import lombok.Value;

@Value
public class IndexedInventorySlot {

  int index;
  @Nonnull
  InventorySlot slot;
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.inventory.slot;

import static no.elg.ii.util.WidgetUtils.FULLY_TRANSPARENT;

import lombok.Value;

@Value
public class InventorySlot {

  /**
   * Indicate that the item is not a real item, but rather a placeholder
   */
  public static final int INVALID_ITEM_ID = -1;
  public static final int RESET_ITEM_ID = -2;

  /**
   * Indicate the item has not been modified
   */
  public static final int NO_CHANGED_TICK = -1;

  public static final InventorySlot UNMODIFIED_SLOT = new InventorySlot(NO_CHANGED_TICK, INVALID_ITEM_ID, 0, FULLY_TRANSPARENT);
  public static final InventorySlot RESET_SLOT = new InventorySlot(NO_CHANGED_TICK, RESET_ITEM_ID, 0, FULLY_TRANSPARENT);

  /**
   * When this slot was modified, or {@link InventorySlot#NO_CHANGED_TICK} if it has not been (or cannot be) modified
   */
  int changedTick;
  /**
   * When this slot was modified in milliseconds. This is to remove flickering
   */
  long changedMs = System.currentTimeMillis();
  /**
   * The item id of this slot, or {@link InventorySlot#INVALID_ITEM_ID} if this slot is not a real item
   */
  int itemId;
  /**
   * How many of the item in this slot
   */
  int quantity;
  /**
   * The opacity this slot should be rendered with
   */
  int opacity;

  /**
   * @return Whether this slot is valid, i.e. has an item id
   */
  public boolean hasValidItemId() {
    return itemId >= 0;
  }

  /**
   * @return Whether this slot has been modified, if so when it was will be reflected in {@link #getChangedTick()}
   */
  public boolean hasChangedTick() {
    return changedTick >= 0;
  }
}

/*
 * Copyright (c) 2022-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
package no.elg.ii.model;

import java.util.HashMap;
import java.util.Map;
import lombok.Value;
import net.runelite.api.gameval.ItemID;

@Value
@SuppressWarnings("MagicNumber")
public class HerbInfo {

  /**
   * Map of {@link ItemID} from grimy herbs to cleaned herbs
   */
  public static Map<Integer, HerbInfo> HERBS = new HashMap<>();

  static {
    HERBS.put(ItemID.UNIDENTIFIED_ROGUES_PURSE, new HerbInfo(ItemID.ROGUES_PURSE, 3));
    HERBS.put(ItemID.UNIDENTIFIED_SNAKE_WEED, new HerbInfo(ItemID.SNAKE_WEED, 3));
    HERBS.put(ItemID.UNIDENTIFIED_ARDRIGAL, new HerbInfo(ItemID.ARDRIGAL, 3));
    HERBS.put(ItemID.UNIDENTIFIED_SITO_FOIL, new HerbInfo(ItemID.SITO_FOIL, 3));
    HERBS.put(ItemID.UNIDENTIFIED_VOLENCIA_MOSS, new HerbInfo(ItemID.VOLENCIA_MOSS, 3));
    HERBS.put(ItemID.UNIDENTIFIED_GUAM, new HerbInfo(ItemID.GUAM_LEAF, 3));
    HERBS.put(ItemID.UNIDENTIFIED_MARENTILL, new HerbInfo(ItemID.MARENTILL, 5));
    HERBS.put(ItemID.UNIDENTIFIED_TARROMIN, new HerbInfo(ItemID.TARROMIN, 11));
    HERBS.put(ItemID.UNIDENTIFIED_HARRALANDER, new HerbInfo(ItemID.HARRALANDER, 20));
    HERBS.put(ItemID.UNIDENTIFIED_RANARR, new HerbInfo(ItemID.RANARR_WEED, 25));
    HERBS.put(ItemID.UNIDENTIFIED_IRIT, new HerbInfo(ItemID.IRIT_LEAF, 40));
    HERBS.put(ItemID.UNIDENTIFIED_AVANTOE, new HerbInfo(ItemID.AVANTOE, 48));
    HERBS.put(ItemID.UNIDENTIFIED_KWUARM, new HerbInfo(ItemID.KWUARM, 54));
    HERBS.put(ItemID.UNIDENTIFIED_SNAPDRAGON, new HerbInfo(ItemID.SNAPDRAGON, 59));
    HERBS.put(ItemID.UNIDENTIFIED_CADANTINE, new HerbInfo(ItemID.CADANTINE, 65));
    HERBS.put(ItemID.UNIDENTIFIED_DWARF_WEED, new HerbInfo(ItemID.DWARF_WEED, 70));
    HERBS.put(ItemID.UNIDENTIFIED_TORSTOL, new HerbInfo(ItemID.TORSTOL, 75));
    HERBS.put(ItemID.UNIDENTIFIED_LANTADYME, new HerbInfo(ItemID.LANTADYME, 67));
    HERBS.put(ItemID.UNIDENTIFIED_TOADFLAX, new HerbInfo(ItemID.TOADFLAX, 30));

    // Chambers of Xeric herbs
    HERBS.put(ItemID.RAIDS_GRIMY_GOLPAR, new HerbInfo(ItemID.RAIDS_GOLPAR, 47));
    HERBS.put(ItemID.RAIDS_GRIMY_BUCHULEAF, new HerbInfo(ItemID.RAIDS_BUCHULEAF, 52));
    HERBS.put(ItemID.RAIDS_GRIMY_NOXIFER, new HerbInfo(ItemID.RAIDS_NOXIFER, 60));
  }

  int cleanItemId;
  int minLevel;

}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.model;

import com.google.common.collect.Streams.FunctionWithIndex;
import lombok.NonNull;
import lombok.Value;
import net.runelite.api.widgets.Widget;

@Value
public class IndexedWidget implements Comparable<IndexedWidget> {

  int index;
  @NonNull
  Widget widget;

  @Override
  public int compareTo(IndexedWidget o) {
    return Integer.compare(index, o.index);
  }

  @SuppressWarnings("UnstableApiUsage")
  public static final FunctionWithIndex<Widget, IndexedWidget> indexWidget =
    (from, index) -> new IndexedWidget((int) index, from);
}
/*
 * Copyright (c) 2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.model;

import static net.runelite.api.Prayer.AUGURY;
import static net.runelite.api.Prayer.BURST_OF_STRENGTH;
import static net.runelite.api.Prayer.CHIVALRY;
import static net.runelite.api.Prayer.CLARITY_OF_THOUGHT;
import static net.runelite.api.Prayer.DEADEYE;
import static net.runelite.api.Prayer.EAGLE_EYE;
import static net.runelite.api.Prayer.HAWK_EYE;
import static net.runelite.api.Prayer.IMPROVED_REFLEXES;
import static net.runelite.api.Prayer.INCREDIBLE_REFLEXES;
import static net.runelite.api.Prayer.MYSTIC_LORE;
import static net.runelite.api.Prayer.MYSTIC_MIGHT;
import static net.runelite.api.Prayer.MYSTIC_VIGOUR;
import static net.runelite.api.Prayer.MYSTIC_WILL;
import static net.runelite.api.Prayer.PIETY;
import static net.runelite.api.Prayer.PRESERVE;
import static net.runelite.api.Prayer.PROTECT_FROM_MAGIC;
import static net.runelite.api.Prayer.PROTECT_FROM_MELEE;
import static net.runelite.api.Prayer.PROTECT_FROM_MISSILES;
import static net.runelite.api.Prayer.PROTECT_ITEM;
import static net.runelite.api.Prayer.RAPID_HEAL;
import static net.runelite.api.Prayer.RAPID_RESTORE;
import static net.runelite.api.Prayer.REDEMPTION;
import static net.runelite.api.Prayer.RETRIBUTION;
import static net.runelite.api.Prayer.RIGOUR;
import static net.runelite.api.Prayer.ROCK_SKIN;
import static net.runelite.api.Prayer.SHARP_EYE;
import static net.runelite.api.Prayer.SMITE;
import static net.runelite.api.Prayer.STEEL_SKIN;
import static net.runelite.api.Prayer.SUPERHUMAN_STRENGTH;
import static net.runelite.api.Prayer.THICK_SKIN;
import static net.runelite.api.Prayer.ULTIMATE_STRENGTH;

import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import net.runelite.api.Prayer;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;

@NoArgsConstructor
public final class PrayerInfo {

  /**
   * Mapping to find the bit for a prayer
   */
  public final static EnumMap<Prayer, Integer> PRAYER_TO_BIT;


  /**
   * Key is the interface id in the prayer book. value is the bit for the prayer.
   *
   * @see #PRAYER_TO_BIT
   *
   */
  public static final Map<Integer, Integer> INTERFACE_TO_BIT;

  /**
   * Groups of conflicting prayers
   */
  public final static int[] CONFLICTING_PRAYERS;

  static {
    PRAYER_TO_BIT = setupPrayerToBit();
    INTERFACE_TO_BIT = setupInterfaceToBit();
    // Endgame prayers conflict with (almost) everything else
    int endgame = prayerToBits(CHIVALRY, PIETY, RIGOUR, AUGURY);
    // Ranged and magic prayers
    int rangedAndMagic = prayerToBits(SHARP_EYE, MYSTIC_WILL, HAWK_EYE, MYSTIC_LORE, EAGLE_EYE, MYSTIC_MIGHT);
    CONFLICTING_PRAYERS = new int[]{
      // Protection / overheads
      prayerToBits(PROTECT_FROM_MAGIC, PROTECT_FROM_MISSILES, PROTECT_FROM_MELEE, RETRIBUTION, REDEMPTION, SMITE),
      // Defence prayers (can be used with ranged/magic prayers!)
      prayerToBits(THICK_SKIN, ROCK_SKIN, STEEL_SKIN) | endgame,
      // Strength prayers
      prayerToBits(BURST_OF_STRENGTH, SUPERHUMAN_STRENGTH, ULTIMATE_STRENGTH) | rangedAndMagic | endgame,
      // Attack prayers
      prayerToBits(CLARITY_OF_THOUGHT, IMPROVED_REFLEXES, INCREDIBLE_REFLEXES) | rangedAndMagic | endgame,
      // Ranged and magic prayers
      rangedAndMagic | endgame, //
      endgame,//
    };
  }

  /**
   * Manual setup of prayer to a bit. These bits reflect what bit the server sets in {@link VarbitID#PRAYER_ALLACTIVE}.
   *
   * @see VarbitID#PRAYER_ALLACTIVE
   */
  @SuppressWarnings({"MagicNumber", "PointlessBitwiseExpression"})
  private static EnumMap<Prayer, Integer> setupPrayerToBit() {
    EnumMap<Prayer, Integer> prayerToBit = new EnumMap<>(Prayer.class);
    prayerToBit.put(THICK_SKIN, 1 << 0);
    prayerToBit.put(BURST_OF_STRENGTH, 1 << 1);
    prayerToBit.put(CLARITY_OF_THOUGHT, 1 << 2);
    prayerToBit.put(SHARP_EYE, 1 << 18);
    prayerToBit.put(MYSTIC_WILL, 1 << 19);

    prayerToBit.put(ROCK_SKIN, 1 << 3);
    prayerToBit.put(SUPERHUMAN_STRENGTH, 1 << 4);
    prayerToBit.put(IMPROVED_REFLEXES, 1 << 5);
    prayerToBit.put(RAPID_RESTORE, 1 << 6);
    prayerToBit.put(RAPID_HEAL, 1 << 7);

    prayerToBit.put(PROTECT_ITEM, 1 << 8);
    prayerToBit.put(HAWK_EYE, 1 << 20);
    prayerToBit.put(MYSTIC_LORE, 1 << 21);
    prayerToBit.put(STEEL_SKIN, 1 << 9);
    prayerToBit.put(ULTIMATE_STRENGTH, 1 << 10);

    prayerToBit.put(INCREDIBLE_REFLEXES, 1 << 11);
    prayerToBit.put(PROTECT_FROM_MAGIC, 1 << 12);
    prayerToBit.put(PROTECT_FROM_MISSILES, 1 << 13);
    prayerToBit.put(PROTECT_FROM_MELEE, 1 << 14);
    prayerToBit.put(EAGLE_EYE, 1 << 22);
    prayerToBit.put(DEADEYE, 1 << 22); // Intentional overlap with EAGLE_EYE

    prayerToBit.put(MYSTIC_MIGHT, 1 << 23);
    prayerToBit.put(MYSTIC_VIGOUR, 1 << 23); // Intentional overlap with MYSTIC_MIGHT

    prayerToBit.put(RETRIBUTION, 1 << 15);
    prayerToBit.put(REDEMPTION, 1 << 16);
    prayerToBit.put(SMITE, 1 << 17);
    prayerToBit.put(PRESERVE, 1 << 28);

    prayerToBit.put(CHIVALRY, 1 << 25);
    prayerToBit.put(PIETY, 1 << 26);
    prayerToBit.put(RIGOUR, 1 << 24);
    prayerToBit.put(AUGURY, 1 << 27);
    return prayerToBit;
  }

  private static Map<Integer, Integer> setupInterfaceToBit() {
    Map<Integer, Integer> interfaceTobit = new HashMap<>(PRAYER_TO_BIT.size());

    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER1, PRAYER_TO_BIT.get(THICK_SKIN));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER2, PRAYER_TO_BIT.get(BURST_OF_STRENGTH));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER3, PRAYER_TO_BIT.get(CLARITY_OF_THOUGHT));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER19, PRAYER_TO_BIT.get(SHARP_EYE));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER22, PRAYER_TO_BIT.get(MYSTIC_WILL));

    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER4, PRAYER_TO_BIT.get(ROCK_SKIN));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER5, PRAYER_TO_BIT.get(SUPERHUMAN_STRENGTH));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER6, PRAYER_TO_BIT.get(IMPROVED_REFLEXES));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER7, PRAYER_TO_BIT.get(RAPID_RESTORE));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER8, PRAYER_TO_BIT.get(RAPID_HEAL));

    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER9, PRAYER_TO_BIT.get(PROTECT_ITEM));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER20, PRAYER_TO_BIT.get(HAWK_EYE));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER23, PRAYER_TO_BIT.get(MYSTIC_LORE));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER10, PRAYER_TO_BIT.get(STEEL_SKIN));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER11, PRAYER_TO_BIT.get(ULTIMATE_STRENGTH));

    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER12, PRAYER_TO_BIT.get(INCREDIBLE_REFLEXES));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER13, PRAYER_TO_BIT.get(PROTECT_FROM_MAGIC));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER14, PRAYER_TO_BIT.get(PROTECT_FROM_MISSILES));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER15, PRAYER_TO_BIT.get(PROTECT_FROM_MELEE));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER21, PRAYER_TO_BIT.get(EAGLE_EYE)); // Uses same slot as DEADEYE

    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER24, PRAYER_TO_BIT.get(MYSTIC_MIGHT)); // uses same slot as MYSTIC_VIGOUR
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER16, PRAYER_TO_BIT.get(RETRIBUTION));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER17, PRAYER_TO_BIT.get(REDEMPTION));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER18, PRAYER_TO_BIT.get(SMITE));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER29, PRAYER_TO_BIT.get(PRESERVE));

    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER26, PRAYER_TO_BIT.get(CHIVALRY));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER27, PRAYER_TO_BIT.get(PIETY));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER25, PRAYER_TO_BIT.get(RIGOUR));
    interfaceTobit.put(InterfaceID.Prayerbook.PRAYER28, PRAYER_TO_BIT.get(AUGURY));
    return interfaceTobit;
  }

  /**
   *
   * Note: must not be called before {@link PrayerInfo#PRAYER_TO_BIT} is populated
   *
   * @return The bits of each prayer combined with bitwise OR
   */
  public static int prayerToBits(@NonNull Prayer... prayers) {
    return Stream.of(prayers).mapToInt(PRAYER_TO_BIT::get).reduce(0, (a, b) -> a | b);
  }
}

/*
 * Copyright (c) 2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.service;


import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
@NoArgsConstructor
public class DisallowModifiedWidgetInteractionService {

  @Inject
  private InventoryService inventoryService;

  @Inject
  private Client client;

  @Subscribe(priority = Integer.MAX_VALUE)
  public void onMenuOptionClicked(final MenuOptionClicked event) {
    Widget widget = event.getWidget();
    if (widget != null && !event.isConsumed() && (event.isItemOp() || isUseItemAction(event.getMenuEntry()))) {
      ItemContainer currentInventoryContainer = inventoryService.getCurrentInventoryContainer();
      if (currentInventoryContainer != null) {
        Item item = currentInventoryContainer.getItem(widget.getIndex());
        if (item != null && item.getId() != widget.getItemId()) {
          log.debug("Widget item in slot {} is not the same as the item in the inventory. Disallowing interaction", widget.getIndex());
          event.consume();
        }
      }
    }
  }

  private boolean isUseItemAction(@Nullable MenuEntry menuEntry) {
    if (menuEntry != null && "Use".equals(menuEntry.getOption())) {
      MenuAction type = menuEntry.getType();
      if (client.isWidgetSelected()) {
        return type == MenuAction.WIDGET_TARGET_ON_WIDGET;
      } else {
        return type == MenuAction.WIDGET_TARGET;
      }
    } else {
      return false;
    }
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.service;

import java.util.function.BiConsumer;
import java.util.function.BiPredicate;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NoArgsConstructor;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.util.WidgetUtils;

/**
 * Force widget to look a certain way. Sometimes the widgets get updated by client code, but this will override
 * any other (clientside) changes to inventory widgets.
 * <p>
 * If this is not actively corrected the item will be fully visible.
 * This only applies to the clicked item, but it is not known <b>when</b> the item was clicked.
 * So this is a brute-force method to ensure that the item is hidden.
 */
@Singleton
@NoArgsConstructor
public class EnsureWidgetStateService {
  @Inject
  InventoryService inventoryService;

  @Inject
  InventoryState state;
  @Inject
  WidgetService widgetService;

  @Subscribe
  public void onBeforeRender(BeforeRender event) {
    forceWidgetState(EnsureWidgetStateService::isDifferent, this::setWidgetFromSlot);
  }

  private void forceWidgetState(BiPredicate<Widget, InventorySlot> widgetFilter, BiConsumer<Widget, InventorySlot> force) {
    state.getActiveSlots()
      .forEach(iis -> inventoryService.getAllOpenInventoryWidgets()
        .filter(slotWidget -> slotWidget.getIndex() == iis.getIndex() && widgetFilter.test(slotWidget.getWidget(), iis.getSlot()))
        .forEach(slotWidget -> force.accept(slotWidget.getWidget(), iis.getSlot())));
  }

  private static boolean isDifferent(Widget widget, InventorySlot slot) {
    return slot.hasValidItemId() && !WidgetUtils.isEmpty(widget)
      && (widget.getItemId() != slot.getItemId()
      || widget.getItemQuantity() != slot.getQuantity()
      || widget.getOpacity() != slot.getOpacity());
  }

  private void setWidgetFromSlot(Widget widget, InventorySlot slot) {
    widgetService.updateVisibleWidget(widget, slot.getItemId(), slot.getQuantity());
    widgetService.setOpacity(widget, slot.getOpacity(), true);
  }

}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.service;

import static no.elg.ii.model.IndexedWidget.indexWidget;
import static no.elg.ii.util.InventoryUtil.INVENTORY_ITEMS_CONTAINERS;

import com.google.common.collect.Streams;
import java.util.Arrays;
import java.util.Collection;
import java.util.stream.Stream;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import no.elg.ii.model.IndexedWidget;

@Slf4j
@Singleton
@NoArgsConstructor
public class InventoryService {

  @Inject
  private Client client;

  @Nullable
  public ItemContainer getCurrentInventoryContainer() {
    Widget groupStorageWidget = client.getWidget(InterfaceID.SharedBankSide.ITEMS);
    boolean isGroupStorageOpen = groupStorageWidget != null && !groupStorageWidget.isHidden();
    int itemContainer;
    if (isGroupStorageOpen) {
      itemContainer = InventoryID.INV_PLAYER_TEMP;
    } else {
      itemContainer = InventoryID.INV;
    }
    return client.getItemContainer(itemContainer);
  }

  @Nonnull
  private Stream<Widget> getOpenWidget(Collection<Integer> componentIds) {
    return componentIds.stream()
      .map(componentId -> client.getWidget(componentId))
      .filter(widget -> widget != null && !widget.isHidden());
  }

  /**
   * @return A stream of indexed widgets in the current open inventory
   */
  @Nonnull
  @SuppressWarnings("UnstableApiUsage")
  public final Stream<IndexedWidget> getAllOpenInventoryWidgets() {
    return getOpenWidget(INVENTORY_ITEMS_CONTAINERS)
      .flatMap(container -> Streams.mapWithIndex(Arrays.stream(container.getDynamicChildren()), indexWidget));
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.service;

import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NoArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.annotations.VarCInt;
import net.runelite.api.annotations.VarCStr;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.annotations.Varp;

/**
 * @see net.runelite.api.gameval.VarbitID
 * @see net.runelite.api.gameval.VarPlayerID
 */
@Singleton
@NoArgsConstructor
public class VarService {

  @Inject
  private Client client;

  public static final int VAR_VALUE_TRUE = 1;
  public static final int VAR_VALUE_FALSE = 0;


  public int varbitValue(@Varbit int varbit) {
    return client.getVarbitValue(varbit);
  }

  public int varpValue(@Varp int varp) {
    return client.getVarpValue(varp);
  }

  public int varCIntValue(@VarCInt int varc) {
    return client.getVarcIntValue(varc);
  }

  public String varCStrValue(@VarCStr int varc) {
    return client.getVarcStrValue(varc);
  }

  /**
   * @param varbit the varbit to test
   * @return Whether the value of the varbit is true, i.e., 1
   */
  public boolean isVarbitTrue(@Varbit int varbit) {
    return varbitValue(varbit) == VAR_VALUE_TRUE;
  }

  /**
   * @param varbit the varbit to test
   * @return Whether the value of the varbit is false, i.e., 0
   */
  public boolean isVarbitFalse(@Varbit int varbit) {
    return varbitValue(varbit) == VAR_VALUE_FALSE;
  }

  /**
   * @param varp the varp to test
   * @return Whether the value of the varp is true, i.e., 1
   */
  public boolean isVarpTrue(@Varp int varp) {
    return varpValue(varp) == VAR_VALUE_TRUE;
  }

  /**
   * @param varp the varp to test
   * @return Whether the value of the varp is false, i.e., 0
   */
  public boolean isVarpFalse(@Varp int varp) {
    return varpValue(varp) == VAR_VALUE_FALSE;
  }


  /**
   * @param varc the varc to test
   * @return Whether the value of the varc is true, i.e., 1
   */
  public boolean isVarcTrue(@VarCInt int varc) {
    return varCIntValue(varc) == VAR_VALUE_TRUE;
  }

  /**
   * @param varc the varc to test
   * @return Whether the value of the varc is false, i.e., 0
   */
  public boolean isVarcFalse(@VarCInt int varc) {
    return varCIntValue(varc) == VAR_VALUE_FALSE;
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.service;

import static no.elg.ii.util.WidgetUtils.FULLY_OPAQUE;
import static no.elg.ii.util.WidgetUtils.FULLY_TRANSPARENT;
import static no.elg.ii.util.WidgetUtils.THE_EMPTY_ITEM_ID;

import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NoArgsConstructor;
import net.runelite.api.Item;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.util.Util;
import no.elg.ii.util.WidgetUtils;


@Singleton
@NoArgsConstructor
public class WidgetService {

  @Inject
  private InstantInventoryConfig config;

  private static final int FULLY_OPAQUE_INT_PERCENT = 100;
  private static final int FULLY_TRANSPARENT_INT_PERCENT = 0;

  /**
   * Convert a number between {@link #FULLY_TRANSPARENT_INT_PERCENT} and {@link #FULLY_OPAQUE_INT_PERCENT} to the
   * corresponding opacity value between {@link WidgetUtils#FULLY_OPAQUE} and {@link WidgetUtils#FULLY_TRANSPARENT}
   */
  private static int intPercentToOpacityValue(int opacityPercent) {
    int validOpacityIntPercent = Util.coerceIn(opacityPercent, FULLY_TRANSPARENT_INT_PERCENT, FULLY_OPAQUE_INT_PERCENT);
    double percent = validOpacityIntPercent / (double) FULLY_OPAQUE_INT_PERCENT;
    return (int) ((1d - percent) * FULLY_TRANSPARENT);
  }

  public int getChangeOpacity() {
    return intPercentToOpacityValue(config.changeOpacityPercent());
  }

  public int getHideOpacity() {
    return intPercentToOpacityValue(config.hideOpacityPercent());
  }

  public int getPrayerEnableOpacity() {
    return intPercentToOpacityValue(config.prayerEnableOpacityPercent());
  }

  public int getPrayerDisableOpacity() {
    return intPercentToOpacityValue(config.prayerDisableOpacityPercent());
  }

  /**
   * Set the opacity of the widget to the user specified change opacity
   *
   * @param hideFully If the widget item id can be changed if the opacity is fully transparent
   */
  public void setAsChangeOpacity(@Nonnull Widget widget, boolean hideFully) {
    setOpacity(widget, getChangeOpacity(), hideFully);
  }

  /**
   * Set the opacity of the widget to the user specified hide opacity
   *
   * @param hideFully If the widget item id can be changed if the opacity is fully transparent
   */
  public void setAsHideOpacity(@Nonnull Widget widget, boolean hideFully) {
    setOpacity(widget, getHideOpacity(), hideFully);
  }

  /**
   * Make the widget fully visible
   */
  public void setAsFullyOpaque(@Nonnull Widget widget) {
    setOpacity(widget, FULLY_OPAQUE, false);
  }

  /**
   * Change the opacity of the widget to {@code opacity}
   *
   * @param hideFully If the widget item id can be changed if the opacity is fully transparent
   */
  public void setOpacity(@Nonnull Widget widget, int opacity, boolean hideFully) {
    if (hideFully && opacity == FULLY_TRANSPARENT) {
      //When the opacity should be fully transparent we want to change the widget to not display overlay for the given item
      setEmptyItem(widget);
    }
    widget.setHidden(false);
    widget.setOpacity(opacity);
  }

  /**
   * Set the itemId and quantity of a widget without changing the opacity or any other attributes
   */
  public void updateVisibleWidget(@Nonnull Widget dstWidget, int itemId, int amount) {
    dstWidget.setItemId(itemId);
    dstWidget.setItemQuantity(amount);
  }

  public void updateVisibleWidget(@Nonnull Widget dstWidget, @Nonnull Item srcItem) {
    updateVisibleWidget(dstWidget, srcItem.getId(), srcItem.getQuantity());
  }

  public void setEmptyItem(@Nonnull Widget widget) {
    widget.setItemQuantityMode(ItemQuantityMode.NEVER);
    setFakeWidgetItem(widget, THE_EMPTY_ITEM_ID, 1);
  }

  public void setFakeWidgetItem(@Nonnull Widget dstWidget, int itemId, int amount) {
    updateVisibleWidget(dstWidget, itemId, amount);
    setAsChangeOpacity(dstWidget, false); //this can never be true as it will cause an infinite loop
  }

  public void setFakeWidgetItem(@Nonnull Widget dstWidget, @Nonnull Item srcItem) {
    setFakeWidgetItem(dstWidget, srcItem.getId(), srcItem.getQuantity());
  }

  /**
   * Add {@code delta} from the quantity of {@code widget}
   *
   * @param widget the widget to update
   * @param delta  the amount to add
   */
  public void updateQuantity(@Nonnull Widget widget, int delta) {
    setQuantity(widget, widget.getItemQuantity() + delta);
  }

  /**
   * Set the quantity of {@code widget} to {@code quantity}
   */
  public void setQuantity(@Nonnull Widget widget, int quantity) {
    widget.setItemQuantity(quantity);
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import java.util.Set;
import java.util.function.Predicate;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.annotations.Component;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;

@Slf4j
@NoArgsConstructor(access = lombok.AccessLevel.PRIVATE)
public final class InventoryUtil {
  /**
   * Number of items in an inventory
   */
  public static final int INVENTORY_SIZE = 28;

  @Nullable
  public static Widget findFirst(@Nonnull Client client, @Component int componentId, @Nonnull Predicate<Widget> filter) {
    Widget invWidget = client.getWidget(componentId);
    if (invWidget == null) {
      return null;
    }
    Widget[] inventoryWidgets = invWidget.getDynamicChildren();
    for (Widget widget : inventoryWidgets) {
      if (filter.test(widget)) {
        return widget;
      }
    }
    return null;
  }

  public static final Set<Integer> INVENTORY_ITEMS_CONTAINERS = Set.of(
    InterfaceID.Inventory.ITEMS, // Normal inventory
    InterfaceID.Bankside.ITEMS, // Normal inventory when the bank is open
    InterfaceID.Bankside.WORNOPS, // Inventory when equipping items in the bank
    InterfaceID.GeOffersSide.ITEMS, // Inventory when inside the Grand Exchange interface
    InterfaceID.BankDepositbox.INVENTORY, // When using the deposit box
    InterfaceID.GePricecheckerSide.ITEMS, // When price checking items ('View guide prices' in the 'Worn Equipment' tab)
    InterfaceID.EquipmentSide.ITEMS, //When showing 'View equipment stats' in the 'Worn Equipment' tab
    InterfaceID.SharedBankSide.ITEMS, // Inventory when in group storage
    InterfaceID.InvoverlayNoops.ITEMS, // When the inventory is open, but it's not interactable (e.g. in the deposit box)
    InterfaceID.InventoryNoops.ITEMS // TODO unknown, thought it was InvoverlayNoops.ITEMS

    //Might be used in the future or broken:
//    InterfaceID.SeedVaultDeposit.INV, // When using the seed vault in the Farming Guild (currently buggy, when trying to deposit non-seed items)
//    InterfaceID.Shopside.ITEMS // When in a shop interface
  );
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import javax.annotation.Nonnull;
import lombok.NoArgsConstructor;
import net.runelite.api.widgets.Widget;

@NoArgsConstructor(access = lombok.AccessLevel.PRIVATE)
public final class Util {
  public static final int NO_MENU_OPTION_NUMBER = -1;
  public static final int TICK_LENGTH_MS = 600;

  public static int getNumberFromMenuOption(String text, @Nonnull Widget widget) {
    try {
      String substring = text.substring(text.indexOf('-') + 1);
      int quantity;
      if ("All".equals(substring)) {
        quantity = Integer.MAX_VALUE;
      } else if ("All-but-1".equalsIgnoreCase(substring)) {
        quantity = widget.getItemQuantity() - 1;
      } else {
        quantity = Integer.parseInt(substring);
      }
      assert quantity > 0;
      return quantity;
    } catch (NumberFormatException | IndexOutOfBoundsException e) {
      return NO_MENU_OPTION_NUMBER;
    }
  }

  public static int coerceIn(int value, int min, int max) {
    return Math.max(min, Math.min(max, value));
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.util;

import javax.annotation.Nonnull;
import lombok.NoArgsConstructor;
import net.runelite.api.Item;
import net.runelite.api.NullItemID;
import net.runelite.api.widgets.Widget;
import no.elg.ii.model.IndexedWidget;

@NoArgsConstructor(access = lombok.AccessLevel.PRIVATE)
public final class WidgetUtils {

  /**
   * Item is fully transparent, i.e., not visible
   */
  public static final int FULLY_TRANSPARENT = 255;

  /**
   * The opacity of a bank item with a quantity of zero
   */
  public static final int ZERO_QUANTITY_BANK_ITEM_OPACITY = 120;

  /**
   * Item is fully opaque, i.e., visible
   */
  public static final int FULLY_OPAQUE = 0;

  /**
   * This is the item id used by {@code clientscript}s to set a slot as empty
   *
   * @see <a href="https://github.com/runelite/runelite/wiki/Working-with-client-scripts">Working with client scripts</a>
   * @see <a href="https://github.com/Joshua-F/osrs-dumps/tree/master/script">cs2-scripts</a>
   * @see <a href="https://github.com/Joshua-F/osrs-dumps/tree/master/script/%5Bproc,bankmain_drawitem%5D.cs2#L41">Example: [proc,bankmain_drawitem].cs2</a>
   */
  public static final int THE_EMPTY_ITEM_ID = NullItemID.NULL_6512;

  @Nonnull
  public static String debugInfo(@Nonnull Widget widget) {
    return widget.getName() + " id: " + widget.getItemId() + ", index: " + widget.getIndex() + ", quantity: " + widget.getItemQuantity() + " opacity: " + widget.getOpacity();
  }

  @Nonnull
  public static String debugInfo(@Nonnull Item item) {
    return "id: " + item.getId() + ", quantity: " + item.getQuantity();
  }

  /**
   * There is no method to call to check if a slot is not empty, so we just check if they appear to be empty
   */
  public static boolean isEmpty(@Nonnull IndexedWidget indexedWidget) {
    return isEmpty(indexedWidget.getWidget());
  }

  /**
   * There is no method to call to check if a slot is not empty, so we just check if they appear to be empty
   */
  public static boolean isEmpty(@Nonnull Widget widget) {
    return widget.isHidden()
      || widget.getName().isEmpty()
      || widget.getOpacity() == FULLY_TRANSPARENT
      || widget.getItemId() == THE_EMPTY_ITEM_ID;
  }

  public static boolean isNotEmpty(@Nonnull Widget widget) {
    return !isEmpty(widget);
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import no.elg.ii.test.IntegrationTestHelper;
import org.junit.Test;

public class FeatureManagerTest extends IntegrationTestHelper {


  @Test
  public void updateFeatureStatus() {
    featureManager.updateFeatureStatus(dropFeature, false);
    verify(dropFeature, never()).onEnable();
    featureManager.updateFeatureStatus(dropFeature, false);
    verify(dropFeature, never()).onEnable();
    featureManager.updateFeatureStatus(dropFeature, true);
    verify(dropFeature).onEnable();
    featureManager.updateFeatureStatus(dropFeature, true);
    verify(dropFeature).onEnable();

    verify(dropFeature, never()).onDisable();
    featureManager.updateFeatureStatus(dropFeature, false);
    verify(dropFeature).onDisable();
    featureManager.updateFeatureStatus(dropFeature, false);
    verify(dropFeature).onDisable();
  }

  @Test
  public void enableFeature() {
    featureManager.enableFeature(dropFeature);

    verify(eventBus).register(dropFeature);
    verify(dropFeature).onEnable();
    verify(dropFeature).reset();
    assertEquals(1, featureManager.getActiveFeatures().size());
    assertTrue(featureManager.getActiveFeatures().contains(dropFeature));
  }

  @Test
  public void disableFeature() {
    featureManager.enableFeature(dropFeature);
    featureManager.disableFeature(dropFeature);

    verify(eventBus).unregister(dropFeature);
    verify(dropFeature).onDisable();
    //Once to enable, once to disable
    verify(dropFeature, times(2)).reset();
    assertTrue(featureManager.getActiveFeatures().isEmpty());
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.features;

import static net.runelite.api.gameval.ItemID.TZHAAR_CAPE_FIRE;
import static net.runelite.api.gameval.ItemID.UNIDENTIFIED_GUAM;
import static no.elg.ii.feature.features.CleanHerbFeature.CLEAN_CONFIG_KEY;
import static no.elg.ii.feature.features.CleanHerbFeature.CLEAN_OPTION;
import static no.elg.ii.inventory.slot.InventorySlot.INVALID_ITEM_ID;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;

import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import no.elg.ii.test.FeatureTestMother;
import no.elg.ii.test.TestSetup;
import org.junit.Test;

public class CleanHerbFeatureTest extends FeatureTestMother<CleanHerbFeature> {

  @Override
  public CleanHerbFeature createNewInstance() {
    return TestSetup.createNewCleanHerbFeature();
  }

  @Test
  public void configKey_is_CLEAN_CONFIG_KEY() {
    CleanHerbFeature feature = createNewInstance();
    assertEquals(CLEAN_CONFIG_KEY, feature.getConfigKey());
  }

  @Test
  public void onMenuOptionClicked_happy_path() {
    onMenuOptionClicked_test(UNIDENTIFIED_GUAM, UNIDENTIFIED_GUAM, true, CLEAN_OPTION, 99);
  }

  @Test
  public void onMenuOptionClicked_no_widget() {
    onMenuOptionClicked_test(INVALID_ITEM_ID, UNIDENTIFIED_GUAM, false, CLEAN_OPTION, 99);
  }

  @Test
  public void onMenuOptionClicked_not_clean_option() {
    onMenuOptionClicked_test(INVALID_ITEM_ID, UNIDENTIFIED_GUAM, true, "not clean", 99);
  }

  @Test
  public void onMenuOptionClicked_not_a_herb() {
    onMenuOptionClicked_test(INVALID_ITEM_ID, TZHAAR_CAPE_FIRE, true, CLEAN_OPTION, 99);
  }

  @Test
  public void onMenuOptionClicked_too_low_level() {
    onMenuOptionClicked_test(INVALID_ITEM_ID, UNIDENTIFIED_GUAM, true, CLEAN_OPTION, 1);
  }

  private void onMenuOptionClicked_test(int stateItemId, int itemId, boolean hasWidget, String menuEntryOption, int level) {
    int index = 1;
    CleanHerbFeature feature = createNewInstance();

    Widget widget = mock(Widget.class);
    doReturn(index).when(widget).getIndex();

    MenuEntry menuEntry = mock(MenuEntry.class);
    doReturn(menuEntryOption).when(menuEntry).getOption();
    doReturn(itemId).when(menuEntry).getItemId();
    doReturn(hasWidget ? widget : null).when(menuEntry).getWidget();
    Client client = feature.client;
    doReturn(level).when(client).getBoostedSkillLevel(any());

    MenuOptionClicked event = new MenuOptionClicked(menuEntry);

    assertFalse(feature.getState().getSlot(index).hasValidItemId());
    feature.onMenuOptionClicked(event);
    assertEquals(stateItemId, feature.getState().getSlot(index).getItemId());
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.features;

import no.elg.ii.test.FeatureTestMother;
import no.elg.ii.test.TestSetup;
import org.junit.Test;

public class DepositFeatureTest extends FeatureTestMother<DepositFeature> {

  @Override
  public DepositFeature createNewInstance() {
    return TestSetup.createNewDepositFeature();
  }

  @Test
  public void afterEnablingItWillBeShownOnSomeWidget() {
    DepositFeature dropFeature = createNewInstance();
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.feature.features;

import static no.elg.ii.feature.features.DropFeature.DROP_CONFIG_KEY;
import static no.elg.ii.feature.state.InventoryState.DEFAULT_MAX_UNMODIFIED_TICKS;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.feature.HideFeature;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.service.InventoryService;
import no.elg.ii.service.WidgetService;
import no.elg.ii.test.FeatureTestMother;
import no.elg.ii.test.TestSetup;
import org.junit.Test;

public class DropFeatureTest extends FeatureTestMother<DropFeature> {

  @Override
  public DropFeature createNewInstance() {
    return TestSetup.createNewDropFeature();
  }

  @Test
  public void onMenuOptionClicked_doNothingWhenWidgetIsNull() {
    int index = 1;
    int itemId = 2;
    DropFeature dropFeature = createNewInstance();

    MenuEntry menuEntry = mock(MenuEntry.class);
    doReturn(DropFeature.DROP_OPTION).when(menuEntry).getOption();
    doReturn(itemId).when(menuEntry).getItemId();
    doReturn(null).when(menuEntry).getWidget();

    MenuOptionClicked event = new MenuOptionClicked(menuEntry);

    assertFalse(dropFeature.getState().getSlot(index).hasValidItemId());
    dropFeature.onMenuOptionClicked(event);
    assertFalse(dropFeature.getState().getSlot(index).hasValidItemId());
  }

  @Test
  public void onMenuOptionClicked_different_menuEntry_clicked_does_not_update_state() {
    int index = 1;
    int itemId = 2;
    DropFeature dropFeature = createNewInstance();

    Widget widget = mock(Widget.class);
    doReturn(index).when(widget).getIndex();

    MenuEntry menuEntry = mock(MenuEntry.class);
    doReturn("not drop").when(menuEntry).getOption();
    doReturn(itemId).when(menuEntry).getItemId();
    doReturn(widget).when(menuEntry).getWidget();

    MenuOptionClicked event = new MenuOptionClicked(menuEntry);

    assertFalse(dropFeature.getState().getSlot(index).hasValidItemId());
    dropFeature.onMenuOptionClicked(event);
    assertFalse(dropFeature.getState().getSlot(index).hasValidItemId());
  }

  @Test
  public void stateResetWhenItemNotDropped() {
    int index = 1;
    int itemId = 2;
    DropFeature feature = createNewInstance();

    Widget widget = mock(Widget.class);
    doReturn(index).when(widget).getIndex();
    doReturn(itemId).when(widget).getItemId();

    MenuEntry menuEntry = mock(MenuEntry.class);
    doReturn(DropFeature.DROP_OPTION).when(menuEntry).getOption();
    doReturn(itemId).when(menuEntry).getItemId();
    doReturn(widget).when(menuEntry).getWidget();

    InstantInventoryConfig config = spy(new InstantInventoryConfig() {
    });
    Client client = mock(Client.class);
    var inventoryService = mock(InventoryService.class);
    var widgetService = mock(WidgetService.class);
    InventoryState inventoryState = new InventoryState(config, client, inventoryService, widgetService);
    doReturn(inventoryState).when(feature).getState();

    MenuOptionClicked event = new MenuOptionClicked(menuEntry);

    assertFalse(feature.getState().getSlot(index).hasValidItemId());
    feature.onMenuOptionClicked(event);
    assertTrue(feature.getState().getSlot(index).hasValidItemId());
    assertEquals(itemId, feature.getState().getSlot(index).getItemId());

    feature.getState().validateState(index, null);
    assertTrue("State was reset when it should not have been", feature.getState().getSlot(index).hasValidItemId());

    doReturn(DEFAULT_MAX_UNMODIFIED_TICKS).when(client).getTickCount();
    feature.getState().validateState(index, null);
    assertFalse("State was NOT reset when it should have been", feature.getState().getSlot(index).hasValidItemId());
  }

  @Test
  public void configKey_is_CLEAN_CONFIG_KEY() {
    DropFeature feature = createNewInstance();
    assertEquals(DROP_CONFIG_KEY, feature.getConfigKey());
  }

  @Test
  public void afterEnablingItWillBeShownOnSomeWidget() {
    HideFeature dropFeature = createNewInstance();
//    assertFalse(dropFeature.getWidgets().isEmpty());
  }
}

/*
 * Copyright (c) 2023-2024 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii;

import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import net.runelite.api.events.GameStateChanged;
import net.runelite.client.events.ConfigChanged;
import no.elg.ii.test.IntegrationTestHelper;
import org.junit.Test;

public class InstantInventoryPluginTest extends IntegrationTestHelper {

  @Test
  public void startUp_calls_updateAllFeatures() {
    plugin.startUp();
    verify(featureManager).updateAllFeatureStatus();
  }

  @Test
  public void shutDown_disables_all_features() {
    plugin.shutDown();
    verify(featureManager).disableAllFeatures();
  }

  @Test
  public void onGameStateChanged_calls_nothing_on_incorrect_group() {
    plugin.startUp();
    plugin.onGameStateChanged(new GameStateChanged());

    verify(dropFeature, times(2)).reset();
    verify(cleanHerbFeature, times(2)).reset();
  }

  @Test
  public void onConfigChanged_calls_updateAllFeatureStatus_on_correct_group() {
    ConfigChanged configChanged = new ConfigChanged();
    configChanged.setGroup(InstantInventoryConfig.GROUP);
    plugin.onConfigChanged(configChanged);
    verify(featureManager).updateAllFeatureStatus();
  }

  @Test
  public void onConfigChanged_calls_nothing_on_incorrect_group() {
    ConfigChanged configChanged = new ConfigChanged();
    configChanged.setGroup("");
    plugin.onConfigChanged(configChanged);
    verify(featureManager, never()).updateAllFeatureStatus();
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.inventory;

import static no.elg.ii.feature.state.InventoryState.DEFAULT_MAX_UNMODIFIED_TICKS;
import static no.elg.ii.inventory.slot.InventorySlot.INVALID_ITEM_ID;
import static no.elg.ii.inventory.slot.InventorySlot.NO_CHANGED_TICK;
import static no.elg.ii.inventory.slot.InventorySlot.RESET_ITEM_ID;
import static no.elg.ii.inventory.slot.InventorySlot.RESET_SLOT;
import static no.elg.ii.util.InventoryUtil.INVENTORY_SIZE;
import static no.elg.ii.util.WidgetUtils.FULLY_OPAQUE;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

import net.runelite.api.Client;
import net.runelite.api.Item;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.inventory.slot.InventorySlot;
import no.elg.ii.service.InventoryService;
import no.elg.ii.service.WidgetService;
import org.junit.Before;
import org.junit.Test;

public class InventoryStateTest {

  private InventoryState inventoryState;
  private InstantInventoryConfig config;
  private Client client;

  private final int index = 3;
  private final int itemId = 1;
  private final int quantity = 2;
  private final Item item = new Item(itemId, quantity);

  @Before
  public void setUp() {
    config = spy(InstantInventoryConfig.class);
    client = mock(Client.class);
    var inventoryService = mock(InventoryService.class);
    var widgetService = mock(WidgetService.class);

    inventoryState = new InventoryState(config, client, inventoryService, widgetService);
  }

  private void setAll(int itemId) {
    for (int index = 0; index < INVENTORY_SIZE; index++) {
      inventoryState.setSlot(index, itemId, 0, FULLY_OPAQUE);
    }
  }

  @Test
  public void initially_invalid() {
    int index = 0;
    assertSame(inventoryState.getSlot(index), InventorySlot.UNMODIFIED_SLOT);
  }

  @Test
  public void resetAll_makesAllIndexesInvalid() {
    doReturn(123).when(client).getTickCount();
    setAll(1234);

    for (int i = 0; i < INVENTORY_SIZE; i++) {
      InventorySlot slot = inventoryState.getSlot(i);

      assertTrue(slot.hasValidItemId());
      assertTrue(slot.hasChangedTick());
    }

    inventoryState.resetAll();

    for (int i = 0; i < INVENTORY_SIZE; i++) {
      InventorySlot slot = inventoryState.getSlot(i);

      assertFalse(slot.hasValidItemId());
      assertFalse(slot.hasChangedTick());
      assertSame(slot, RESET_SLOT);
    }
  }

  @Test
  public void validateState_differentItemIdFromCurrent_resets() {
    doReturn(2).when(client).getTickCount();
    inventoryState.setSlot(index, itemId, 0, FULLY_OPAQUE);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(2, inventoryState.getSlot(index).getChangedTick());

    inventoryState.validateState(index, item);

    assertEquals(RESET_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_timeout_resets_default_is_2() {
    inventoryState.setSlot(index, itemId, quantity, FULLY_OPAQUE);

    assertEquals(1, inventoryState.getSlot(index).getItemId());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());

    doReturn(DEFAULT_MAX_UNMODIFIED_TICKS).when(client).getTickCount();

    inventoryState.validateState(index, item);

    assertEquals(RESET_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_timeout_resets_not_before_configurable_ticks() {

    doReturn(DEFAULT_MAX_UNMODIFIED_TICKS + 1).when(config).maxUnmodifiedTicks();
    inventoryState.setSlot(index, itemId, quantity, FULLY_OPAQUE);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());

    doReturn(DEFAULT_MAX_UNMODIFIED_TICKS).when(client).getTickCount();

    inventoryState.validateState(index, item);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_timeout_resets_customizable_time() {
    int maxUnmodifiedTicks = DEFAULT_MAX_UNMODIFIED_TICKS + 1;
    doReturn(maxUnmodifiedTicks).when(config).maxUnmodifiedTicks();
    inventoryState.setSlot(index, itemId, 0, FULLY_OPAQUE);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());

    doReturn(maxUnmodifiedTicks).when(client).getTickCount();

    inventoryState.validateState(index, item);

    assertEquals(RESET_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_new_item_when_invalid_does_not_change_state() {
    int index = 0;

    assertEquals(INVALID_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());

    inventoryState.validateState(index, item);

    assertEquals(INVALID_ITEM_ID, inventoryState.getSlot(index).getItemId());
    assertEquals(NO_CHANGED_TICK, inventoryState.getSlot(index).getChangedTick());
  }

  @Test
  public void validateState_not_timeout_and_same_item_does_not_reset() {
    inventoryState.setSlot(index, itemId, quantity, FULLY_OPAQUE);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(quantity, inventoryState.getSlot(index).getQuantity());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());

    inventoryState.validateState(0, item);

    assertEquals(itemId, inventoryState.getSlot(index).getItemId());
    assertEquals(quantity, inventoryState.getSlot(index).getQuantity());
    assertEquals(0, inventoryState.getSlot(index).getChangedTick());
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import java.util.Arrays;
import java.util.List;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import net.runelite.client.plugins.defaultworld.DefaultWorldPlugin;
import org.slf4j.LoggerFactory;

public class LivePluginTest {

  private final static List<String> SPAMMING_LOGGERS = List.of(
    "client-patch",
    "net.runelite.client.task.Scheduler",
    "net.runelite.api.geometry.RectangleUnion",
    "net.runelite.client.game.LootManager",
    "net.runelite.client.input.KeyManager",
    "net.runelite.client.config.ConfigInvocationHandler"
  );

  @SuppressWarnings("unchecked")
  public static void main(String[] args) throws Exception {
    ExternalPluginManager.loadBuiltin(InstantInventoryPlugin.class, DefaultWorldPlugin.class);
    var argsList = Arrays.asList(args);
    if (argsList.contains("--trace")) {

      final Logger logger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
      logger.setLevel(Level.TRACE);

      //Spams too much
      for (String loggerName : SPAMMING_LOGGERS) {
        final Logger taskScheduler = (Logger) LoggerFactory.getLogger(loggerName);
        taskScheduler.setLevel(Level.INFO);
      }

      String[] argsNoTrace = Arrays.stream(args).filter(s -> !s.equalsIgnoreCase("--trace")).toArray(String[]::new);
      RuneLite.main(argsNoTrace);
    } else {
      RuneLite.main(args);
    }
  }
}
/*
 * Copyright (c) 2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.model;

import static no.elg.ii.model.PrayerInfo.PRAYER_TO_BIT;
import static org.junit.Assert.assertEquals;

import net.runelite.api.Prayer;
import org.junit.Test;

public class PrayerInfoTest {

  @Test
  public void toConflictLongTest() {
    int conflictLong = PrayerInfo.prayerToBits(Prayer.THICK_SKIN, Prayer.ROCK_SKIN);
    assertEquals(PRAYER_TO_BIT.get(Prayer.THICK_SKIN) | PRAYER_TO_BIT.get(Prayer.ROCK_SKIN), conflictLong);
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

import java.lang.reflect.Method;
import net.runelite.client.config.ConfigItem;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.feature.Feature;
import no.elg.ii.feature.state.InventoryState;
import org.junit.Test;

public abstract class FeatureTestMother<T extends Feature> {

  /**
   * @return A {@link org.mockito.Spy} instance of this feature
   */
  public abstract T createNewInstance();

  @Test
  public void configTest() {
    Feature feature = createNewInstance();

    try {
      Method method = InstantInventoryConfig.class.getMethod(feature.getConfigKey());
      ConfigItem configItemAnnotation = method.getAnnotation(ConfigItem.class);
      assertNotNull(configItemAnnotation);
      assertEquals("key name in ConfigItem must match feature.getConfigKey()",
        feature.getConfigKey(), configItemAnnotation.keyName());
    } catch (NoSuchMethodException e) {
      fail("Failed to find a field in " + InstantInventoryConfig.class.getSimpleName()
        + " which matches the config key: " + feature.getConfigKey());
    }
  }

  @Test
  public void reset_calls_state_resetAll() {
    Feature feature = createNewInstance();
    InventoryState mockState = mock(InventoryState.class);
    doReturn(mockState).when(feature).getState();
    doNothing().when(mockState).resetAll();

    feature.reset();
    verify(mockState).resetAll();
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.test;

import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;

import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.InstantInventoryPlugin;
import no.elg.ii.feature.FeatureManager;
import no.elg.ii.feature.Features;
import no.elg.ii.feature.features.CleanHerbFeature;
import no.elg.ii.feature.features.DepositFeature;
import no.elg.ii.feature.features.DropFeature;
import no.elg.ii.feature.features.EquipFeature;
import no.elg.ii.feature.features.WithdrawFeature;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.service.DisallowModifiedWidgetInteractionService;
import no.elg.ii.service.EnsureWidgetStateService;
import no.elg.ii.service.InventoryService;
import no.elg.ii.service.WidgetService;
import org.junit.Before;
import org.mockito.Answers;
import org.mockito.Mock;

public class IntegrationTestHelper {

  protected InstantInventoryPlugin plugin;
  @Mock(answer = Answers.CALLS_REAL_METHODS)
  protected InstantInventoryConfig instantInventoryConfig;
  @Mock
  protected EventBus eventBus;
  @Mock
  protected Client client;
  @Mock
  protected InventoryService inventoryService;
  @Mock
  protected EnsureWidgetStateService ensureWidgetStateService;
  @Mock
  protected DisallowModifiedWidgetInteractionService disallowModifiedWidgetInteractionService;
  @Mock
  protected WidgetService widgetService;

  protected FeatureManager featureManager;
  protected Features features;

  protected DropFeature dropFeature;
  protected CleanHerbFeature cleanHerbFeature;
  protected DepositFeature depositFeature;
  protected EquipFeature equipFeature;
  protected WithdrawFeature withdrawFeature;
  protected InventoryState inventoryState;
  protected ClientThread clientThread;

  @Before
  public void setUp() {
    features = new Features(
      TestSetup.createNewDropFeature(),
      TestSetup.createNewCleanHerbFeature(),
      TestSetup.createNewDepositFeature(),
      TestSetup.createNewEquipFeature(),
      TestSetup.createNewWithdrawFeature(),
      TestSetup.createNewInstantPrayer()
    );
    dropFeature = features.getDropFeature();
    cleanHerbFeature = features.getCleanHerbFeature();
    depositFeature = features.getDepositFeature();
    equipFeature = features.getEquipFeature();
    withdrawFeature = features.getWithdrawFeature();

    featureManager = spy(new FeatureManager(eventBus, instantInventoryConfig, features, clientThread));

    inventoryState = new InventoryState(instantInventoryConfig, client, inventoryService, widgetService);
    doReturn(inventoryState).when(dropFeature).getState();
    doReturn(inventoryState).when(cleanHerbFeature).getState();
    doReturn(inventoryState).when(depositFeature).getState();

    plugin = spy(new InstantInventoryPlugin(client, eventBus, instantInventoryConfig, featureManager, inventoryState, clientThread, ensureWidgetStateService, disallowModifiedWidgetInteractionService));
  }
}

/*
 * Copyright (c) 2023-2025 Elg
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package no.elg.ii.test;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

import java.util.function.BooleanSupplier;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import no.elg.ii.InstantInventoryConfig;
import no.elg.ii.InstantInventoryPlugin;
import no.elg.ii.feature.Feature;
import no.elg.ii.feature.HideFeature;
import no.elg.ii.feature.features.CleanHerbFeature;
import no.elg.ii.feature.features.DepositFeature;
import no.elg.ii.feature.features.DropFeature;
import no.elg.ii.feature.features.EquipFeature;
import no.elg.ii.feature.features.PrayerFeature;
import no.elg.ii.feature.features.WithdrawFeature;
import no.elg.ii.feature.state.InventoryState;
import no.elg.ii.service.InventoryService;
import no.elg.ii.service.WidgetService;
import org.mockito.stubbing.Answer;

public class TestSetup {

  public static CleanHerbFeature createNewCleanHerbFeature() {
    CleanHerbFeature feature = spy(new CleanHerbFeature());
    feature.client = mock(Client.class);

    setupCommonFeature(feature, feature.client);
    return feature;
  }

  public static DropFeature createNewDropFeature() {
    DropFeature feature = spy(new DropFeature());
    setupHideFeature(feature);
    return feature;
  }

  public static DepositFeature createNewDepositFeature() {
    DepositFeature feature = spy(new DepositFeature());
    setupHideFeature(feature);
    return feature;
  }

  public static EquipFeature createNewEquipFeature() {
    EquipFeature feature = spy(new EquipFeature());
    return feature;
  }

  public static WithdrawFeature createNewWithdrawFeature() {
    WithdrawFeature feature = spy(new WithdrawFeature());
    return feature;
  }

  public static PrayerFeature createNewInstantPrayer() {
    PrayerFeature feature = spy(new PrayerFeature());
    return feature;
  }

  private static void setupCommonFeature(Feature feature, Client client) {
    var inventoryService = mock(InventoryService.class);
    var widgetService = mock(WidgetService.class);

    InventoryState inventoryState = new InventoryState(spy(new InstantInventoryConfig() {
    }), client, inventoryService, widgetService);
    doReturn(inventoryState).when(feature).getState();
  }

  private static void setupHideFeature(HideFeature feature) {
    setupCommonFeature(feature, mock(Client.class));
    feature.clientThread = TestSetup.mockedClientThread();
    InstantInventoryPlugin plugin = feature.plugin = mock(InstantInventoryPlugin.class);
//    doReturn(EMPTY_WIDGET).when(plugin).inventoryItems(any());
  }

  public static ClientThread mockedClientThread() {
    ClientThread clientThread = mock(ClientThread.class);

    Answer<Void> runnableAnswer = invocation -> {
      invocation.getArgument(0, Runnable.class).run();
      return null;
    };
    doAnswer(runnableAnswer).when(clientThread).invoke(any(Runnable.class));
    doAnswer(runnableAnswer).when(clientThread).invokeLater(any(Runnable.class));

    doAnswer(it -> it.getArgument(0, BooleanSupplier.class).getAsBoolean()).when(clientThread)
      .invoke(any(BooleanSupplier.class));
    doAnswer(it -> it.getArgument(0, BooleanSupplier.class).getAsBoolean()).when(clientThread)
      .invokeLater(any(BooleanSupplier.class));

    return clientThread;
  }

}

