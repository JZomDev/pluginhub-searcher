package com.bookofthedeadnotifier;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("bookofthedeadreminder")
public interface BookOfTheDeadNotifierConfig extends Config
{
    @ConfigItem(
        keyName = "reminderStyle",
        name = "Reminder Text",
        description = "The style of reminder text to display",
        position = 0
    )
    default BookOfTheDeadNotifierStyle reminderStyle()
    {
        return BookOfTheDeadNotifierStyle.LONG_TEXT;
    }

    @ConfigItem(
        keyName = "notification",
        name = "Notification on Reminder",
        description = "Sends a notification when warning appears",
        position = 1
    )
    default Notification notification()
    {
        return Notification.ON;
    }

    @ConfigItem(
        keyName = "hideReminderHotkey",
        name = "Hide Reminder Hotkey",
        description = "Hotkey to dismiss the warning",
        position = 2
    )
    default Keybind hideReminderHotkey()
    {
        return Keybind.NOT_SET;
    }

    @ConfigSection(
        name = "Notification Conditions",
        description = "Choose which conditions trigger a reminder",
        position = 3,
        closedByDefault = true
    )
    String notificationConditionsSection = "notificationConditions";

    @ConfigItem(
        keyName = "notifyOnMissingBook",
        name = "Notify on Missing Book",
        description = "Show reminder when Book of the Dead is missing",
        position = 0,
        section = notificationConditionsSection
    )
    default boolean notifyOnMissingBook()
    {
        return true;
    }

    @ConfigItem(
        keyName = "notifyOnMissingRunes",
        name = "Notify on Missing Runes",
        description = "Show reminder when thrall runes are missing",
        position = 1,
        section = notificationConditionsSection
    )
    default boolean notifyOnMissingRunes()
    {
        return true;
    }

    @ConfigItem(
        keyName = "notifyOnWrongSpellbook",
        name = "Notify on Wrong Spellbook",
        description = "Show reminder when not on Arceuus spellbook",
        position = 2,
        section = notificationConditionsSection
    )
    default boolean notifyOnWrongSpellbook()
    {
        return true;
    }

    @ConfigSection(
        name = "Rune Thresholds",
        description = "Minimum rune quantities required",
        position = 4,
        closedByDefault = true
    )
    String runeThresholdSection = "runeThresholds";

    @ConfigItem(
        keyName = "minFireRunes",
        name = "Minimum Fire Runes",
        description = "Minimum fire runes needed",
        position = 0,
        section = runeThresholdSection
    )
    default int minFireRunes()
    {
        return 10;
    }

    @ConfigItem(
        keyName = "minBloodRunes",
        name = "Minimum Blood Runes",
        description = "Minimum blood runes needed",
        position = 1,
        section = runeThresholdSection
    )
    default int minBloodRunes()
    {
        return 5;
    }

    @ConfigItem(
        keyName = "minCosmicRunes",
        name = "Minimum Cosmic Runes",
        description = "Minimum cosmic runes needed",
        position = 2,
        section = runeThresholdSection
    )
    default int minCosmicRunes()
    {
        return 1;
    }

    @ConfigSection(
        name = "Display Options",
        description = "Customize the appearance of warnings",
        position = 5
    )
    String displaySection = "displayOptions";

    @ConfigItem(
        keyName = "customText",
        name = "Custom Text",
        description = "Custom text to display when using CUSTOM_TEXT style",
        position = 0,
        section = displaySection
    )
    default String customText()
    {
        return "Cannot cast thralls!";
    }

    @ConfigItem(
        keyName = "flashReminderBox",
        name = "Flash the Reminder Box",
        description = "Makes the reminder box flash between two colors",
        position = 1,
        section = displaySection
    )
    default boolean flashReminderBox()
    {
        return false;
    }

    @Alpha
    @ConfigItem(
        keyName = "reminderColor",
        name = "Color",
        description = "Main color for the reminder box",
        position = 2,
        section = displaySection
    )
    default Color reminderColor()
    {
        return new Color(255, 0, 0, 150);
    }

    @Alpha
    @ConfigItem(
        keyName = "flashColor",
        name = "Flash Color",
        description = "Secondary color to flash between (if flashing enabled)",
        position = 3,
        section = displaySection
    )
    default Color flashColor()
    {
        return new Color(70, 70, 70, 150);
    }
}

package com.bookofthedeadnotifier;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;
import java.awt.*;

public class BookOfTheDeadNotifierOverlay extends OverlayPanel
{
    private final Client client;
    private final BookOfTheDeadNotifierPlugin plugin;
    private final BookOfTheDeadNotifierConfig config;

    @Inject
    private BookOfTheDeadNotifierOverlay(Client client, BookOfTheDeadNotifierPlugin plugin, BookOfTheDeadNotifierConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!shouldRenderWarning())
        {
            return null;
        }

        String displayText = getDisplayText();
        if (displayText == null)
        {
            return null;
        }

        setupPanelContent(displayText);
        configurePanelSize(graphics, displayText);
        configurePanelColor();

        return renderPanel(graphics);
    }

    private boolean shouldRenderWarning()
    {
        if (!plugin.shouldShowWarning())
        {
            return false;
        }

        MissingCondition condition = plugin.getCurrentMissingCondition();
        return condition != MissingCondition.NONE;
    }

    private void setupPanelContent(String displayText)
    {
        panelComponent.getChildren().clear();
        panelComponent.getChildren().add(LineComponent.builder()
            .left(displayText)
            .build());
    }

    private void configurePanelSize(Graphics2D graphics, String displayText)
    {
        FontMetrics fontMetrics = graphics.getFontMetrics();
        int textWidth = fontMetrics.stringWidth(displayText);
        int padding = getTextPadding();
        int totalWidth = textWidth + padding;

        panelComponent.setPreferredSize(new Dimension(totalWidth, 0));
    }

    private void configurePanelColor()
    {
        Color backgroundColor = getCurrentBackgroundColor();
        panelComponent.setBackgroundColor(backgroundColor);
    }

    private Color getCurrentBackgroundColor()
    {
        if (shouldFlash())
        {
            return config.flashColor();
        }
        return config.reminderColor();
    }

    private boolean shouldFlash()
    {
        if (!config.flashReminderBox())
        {
            return false;
        }

        int gameCycle = client.getGameCycle();
        return gameCycle % 40 >= 20;
    }

    private Dimension renderPanel(Graphics2D graphics)
    {
        boolean useCustomTextStyle = config.reminderStyle() == BookOfTheDeadNotifierStyle.CUSTOM_TEXT;
        if (useCustomTextStyle)
        {
            return super.render(graphics);
        }
        return panelComponent.render(graphics);
    }

    private String getDisplayText()
    {
        BookOfTheDeadNotifierStyle style = config.reminderStyle();
        
        if (style == BookOfTheDeadNotifierStyle.CUSTOM_TEXT)
        {
            return config.customText();
        }

        MissingCondition condition = plugin.getCurrentMissingCondition();
        
        if (style == BookOfTheDeadNotifierStyle.LONG_TEXT)
        {
            return condition.getLongText();
        }
        
        if (style == BookOfTheDeadNotifierStyle.SHORT_TEXT)
        {
            return condition.getShortText();
        }
        
        return null;
    }

    private int getTextPadding()
    {
        switch (config.reminderStyle())
        {
            case LONG_TEXT:
            case CUSTOM_TEXT:
                return -20;
            case SHORT_TEXT:
                return 10;
            default:
                return 0;
        }
    }
}

package com.bookofthedeadnotifier;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

import javax.inject.Inject;

@Slf4j
@PluginDescriptor(
    name = "Book of the Dead Reminder",
    description = "Reminds you when you seem to be missing a thrall requirement (Book of the Dead, Arceuus spellbook, Thrall runes)",
    tags = {"arceuus", "thrall", "thralls", "book of the dead", "spell", "reminder", "spellbook"}
)
public class BookOfTheDeadNotifierPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private BookOfTheDeadNotifierConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private BookOfTheDeadNotifierOverlay overlay;

    @Inject
    private Notifier notifier;

    @Inject
    private KeyManager keyManager;

    private boolean hasArceuusSpellbook = false;
    private boolean hasSufficientThrallRunes = false;
    private boolean hasBookOfTheDead = false;
    private boolean warningShown = false;
    private MissingCondition currentMissingCondition = MissingCondition.NONE;

    private final HotkeyListener hotkeyListener = new HotkeyListener(() -> config.hideReminderHotkey())
    {
        @Override
        public void hotkeyPressed()
        {
            hideWarning();
        }
    };

    @Override
    protected void startUp() throws Exception
    {
        overlayManager.add(overlay);
        keyManager.registerKeyListener(hotkeyListener);
        log.info("Book of the Dead Reminder started!");
    }

    @Override
    protected void shutDown() throws Exception
    {
        overlayManager.remove(overlay);
        keyManager.unregisterKeyListener(hotkeyListener);
        log.info("Book of the Dead Reminder stopped!");
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (event.getVarbitId() == Varbits.SPELLBOOK)
        {
            checkSpellbook();
            checkThrallRunes();
            evaluateWarningState();
        }
        else if (isRunePouchVarbit(event.getVarbitId()))
        {
            checkThrallRunes();
            evaluateWarningState();
        }
    }

    private boolean isRunePouchVarbit(int varbitId)
    {
        return varbitId == Varbits.RUNE_POUCH_RUNE1
            || varbitId == Varbits.RUNE_POUCH_RUNE2
            || varbitId == Varbits.RUNE_POUCH_RUNE3
            || varbitId == Varbits.RUNE_POUCH_RUNE4
            || varbitId == Varbits.RUNE_POUCH_RUNE5
            || varbitId == Varbits.RUNE_POUCH_RUNE6
            || varbitId == Varbits.RUNE_POUCH_AMOUNT1
            || varbitId == Varbits.RUNE_POUCH_AMOUNT2
            || varbitId == Varbits.RUNE_POUCH_AMOUNT3
            || varbitId == Varbits.RUNE_POUCH_AMOUNT4
            || varbitId == Varbits.RUNE_POUCH_AMOUNT5
            || varbitId == Varbits.RUNE_POUCH_AMOUNT6;
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        boolean isRelevantContainer = isInventoryOrEquipment(event.getContainerId());
        if (isRelevantContainer)
        {
            checkSpellbook();
            checkThrallRunes();
            checkBookOfTheDead();
            evaluateWarningState();
        }
    }

    private boolean isInventoryOrEquipment(int containerId)
    {
        return containerId == InventoryID.INVENTORY.getId() 
            || containerId == InventoryID.EQUIPMENT.getId();
    }

    private void evaluateWarningState()
    {
        int conditionsMet = countConditionsMet();
        boolean shouldWarn = conditionsMet == 2;

        if (shouldWarn)
        {
            handleWarningState();
        }
        else
        {
            hideWarning();
        }
    }

    private int countConditionsMet()
    {
        int count = 0;
        if (hasArceuusSpellbook) count++;
        if (hasSufficientThrallRunes) count++;
        if (hasBookOfTheDead) count++;
        return count;
    }

    private void handleWarningState()
    {
        MissingCondition missingCondition = determineMissingCondition();
        
        if (!isConditionNotificationEnabled(missingCondition))
        {
            hideWarning();
            return;
        }
        
        boolean conditionChanged = missingCondition != currentMissingCondition;

        if (conditionChanged)
        {
            currentMissingCondition = missingCondition;
            showWarning();
        }
    }

    private boolean isConditionNotificationEnabled(MissingCondition condition)
    {
        switch (condition)
        {
            case BOOK_OF_THE_DEAD:
                return config.notifyOnMissingBook();
            case THRALL_RUNES:
                return config.notifyOnMissingRunes();
            case ARCEUUS_SPELLBOOK:
                return config.notifyOnWrongSpellbook();
            default:
                return false;
        }
    }

    private MissingCondition determineMissingCondition()
    {
        if (!hasBookOfTheDead)
        {
            return MissingCondition.BOOK_OF_THE_DEAD;
        }
        
        if (!hasArceuusSpellbook)
        {
            return MissingCondition.ARCEUUS_SPELLBOOK;
        }
        
        if (!hasSufficientThrallRunes)
        {
            return MissingCondition.THRALL_RUNES;
        }
        
        return MissingCondition.NONE;
    }

    public MissingCondition getCurrentMissingCondition()
    {
        return currentMissingCondition;
    }

    private void checkSpellbook()
    {
        int spellbookVarbit = client.getVarbitValue(Varbits.SPELLBOOK);
        hasArceuusSpellbook = (spellbookVarbit == 3); // 3 = Arceuus spellbook
    }

    private void checkThrallRunes()
    {
        int fireRunes = countFireRunes();
        int bloodRunes = countBloodRunes();
        int cosmicRunes = countCosmicRunes();

        boolean hasEnoughFire = fireRunes >= config.minFireRunes();
        boolean hasEnoughBlood = bloodRunes >= config.minBloodRunes();
        boolean hasEnoughCosmic = cosmicRunes >= config.minCosmicRunes();

        hasSufficientThrallRunes = hasEnoughFire && hasEnoughBlood && hasEnoughCosmic;
    }

    private int countFireRunes()
    {
        if (hasEquippedFireStaff())
        {
            return Integer.MAX_VALUE;
        }

        int total = 0;
        total += countRunesInInventory(this::isFireRune);
        total += countRunesInRunePouch(this::isFireRune);
        return total;
    }

    private int countBloodRunes()
    {
        int total = 0;
        total += countRunesInInventory(this::isBloodRune);
        total += countRunesInRunePouch(this::isBloodRune);
        return total;
    }

    private int countCosmicRunes()
    {
        int total = 0;
        total += countRunesInInventory(this::isCosmicRune);
        total += countRunesInRunePouch(this::isCosmicRune);
        return total;
    }

    private int countRunesInInventory(RuneChecker checker)
    {
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory == null)
        {
            return 0;
        }

        int count = 0;
        for (Item item : inventory.getItems())
        {
            if (checker.matches(item.getId()))
            {
                count += item.getQuantity();
            }
        }
        return count;
    }

    private int countRunesInRunePouch(RuneChecker checker)
    {
        if (!hasRunePouch())
        {
            return 0;
        }

        int count = 0;
        for (int slot = 1; slot <= 6; slot++)
        {
            count += countRunesInPouchSlot(slot, checker);
        }
        return count;
    }

    private boolean hasRunePouch()
    {
        return hasItemInEquipmentOrInventory(ItemID.RUNE_POUCH)
            || hasItemInEquipmentOrInventory(ItemID.RUNE_POUCH_L)
            || hasItemInEquipmentOrInventory(ItemID.DIVINE_RUNE_POUCH)
            || hasItemInEquipmentOrInventory(ItemID.DIVINE_RUNE_POUCH_L);
    }

    private int countRunesInPouchSlot(int slot, RuneChecker checker)
    {
        int runeEnumId = getRunePouchRuneEnumId(slot);
        int amount = getRunePouchAmount(slot);

        if (runeEnumId == 0 || amount <= 0)
        {
            return 0;
        }

        int itemId = convertRuneEnumIdToItemId(runeEnumId);
        if (checker.matches(itemId))
        {
            return amount;
        }
        return 0;
    }

    private int convertRuneEnumIdToItemId(int runeEnumId)
    {
        EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
        return runepouchEnum.getIntValue(runeEnumId);
    }

    private int getRunePouchRuneEnumId(int slot)
    {
        switch (slot)
        {
            case 1: return client.getVarbitValue(Varbits.RUNE_POUCH_RUNE1);
            case 2: return client.getVarbitValue(Varbits.RUNE_POUCH_RUNE2);
            case 3: return client.getVarbitValue(Varbits.RUNE_POUCH_RUNE3);
            case 4: return client.getVarbitValue(Varbits.RUNE_POUCH_RUNE4);
            case 5: return client.getVarbitValue(Varbits.RUNE_POUCH_RUNE5);
            case 6: return client.getVarbitValue(Varbits.RUNE_POUCH_RUNE6);
            default: return 0;
        }
    }

    private int getRunePouchAmount(int slot)
    {
        switch (slot)
        {
            case 1: return client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT1);
            case 2: return client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT2);
            case 3: return client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT3);
            case 4: return client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT4);
            case 5: return client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT5);
            case 6: return client.getVarbitValue(Varbits.RUNE_POUCH_AMOUNT6);
            default: return 0;
        }
    }

    private boolean isFireRune(int itemId)
    {
        switch (itemId)
        {
            case ItemID.FIRE_RUNE:
            case ItemID.LAVA_RUNE:
            case ItemID.SMOKE_RUNE:
            case ItemID.STEAM_RUNE:
                return true;
            default:
                return false;
        }
    }

    private boolean isBloodRune(int itemId)
    {
        return itemId == ItemID.BLOOD_RUNE;
    }

    private boolean isCosmicRune(int itemId)
    {
        switch (itemId)
        {
            case ItemID.COSMIC_RUNE:
            case ItemID.AETHER_RUNE:
                return true;
            default:
                return false;
        }
    }

    @FunctionalInterface
    private interface RuneChecker
    {
        boolean matches(int itemId);
    }

    private boolean hasEquippedFireStaff()
    {
        Item weapon = getEquippedWeapon();
        if (weapon == null)
        {
            return false;
        }

        return isFireStaff(weapon.getId());
    }

    private Item getEquippedWeapon()
    {
        ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
        if (equipment == null)
        {
            return null;
        }

        return equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
    }

    private boolean isFireStaff(int itemId)
    {
        switch (itemId)
        {
            case ItemID.STAFF_OF_FIRE:
            case ItemID.FIRE_BATTLESTAFF:
            case ItemID.MYSTIC_FIRE_STAFF:
            case ItemID.LAVA_BATTLESTAFF:
            case ItemID.MYSTIC_LAVA_STAFF:
            case ItemID.STEAM_BATTLESTAFF:
            case ItemID.MYSTIC_STEAM_STAFF:
            case ItemID.SMOKE_BATTLESTAFF:
            case ItemID.MYSTIC_SMOKE_STAFF:
            case ItemID.TOME_OF_FIRE:
            case ItemID.TWINFLAME_STAFF:
                return true;
            default:
                return false;
        }
    }

    private void checkBookOfTheDead()
    {
        hasBookOfTheDead = hasItemInEquipmentOrInventory(ItemID.BOOK_OF_THE_DEAD);
    }

    private boolean hasItemInEquipmentOrInventory(int itemId)
    {
        if (hasItemInEquipment(itemId))
        {
            return true;
        }

        if (hasItemInInventory(itemId))
        {
            return true;
        }

        return false;
    }

    private boolean hasItemInEquipment(int itemId)
    {
        ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
        if (equipment == null)
        {
            return false;
        }

        return containsItem(equipment, itemId);
    }

    private boolean hasItemInInventory(int itemId)
    {
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory == null)
        {
            return false;
        }

        return containsItem(inventory, itemId);
    }

    private boolean containsItem(ItemContainer container, int itemId)
    {
        for (Item item : container.getItems())
        {
            if (item.getId() == itemId)
            {
                return true;
            }
        }
        return false;
    }

    private void showWarning()
    {
        boolean isFirstWarning = !warningShown;
        if (isFirstWarning)
        {
            warningShown = true;
            sendNotification();
        }
    }

    private void sendNotification()
    {
        if (!config.notification().isEnabled())
        {
            return;
        }

        String message = currentMissingCondition.getLongText();
        String notificationMessage = "Thrall Reminder: " + message;
        notifier.notify(config.notification(), notificationMessage);
    }

    private void hideWarning()
    {
        if (!warningShown)
        {
            return;
        }

        warningShown = false;
        currentMissingCondition = MissingCondition.NONE;
    }

    public boolean shouldShowWarning()
    {
        return warningShown;
    }

    @Provides
    BookOfTheDeadNotifierConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(BookOfTheDeadNotifierConfig.class);
    }
}

package com.bookofthedeadnotifier;

public enum BookOfTheDeadNotifierStyle {
    LONG_TEXT,
    SHORT_TEXT,
    CUSTOM_TEXT
}

package com.bookofthedeadnotifier;

public enum MissingCondition
{
    BOOK_OF_THE_DEAD("Missing Book of the Dead", "Book!"),
    ARCEUUS_SPELLBOOK("Not on Arceuus spellbook", "Spellbook!"),
    THRALL_RUNES("Missing thrall runes", "Runes!"),
    NONE("", "");

    private final String longText;
    private final String shortText;

    MissingCondition(String longText, String shortText)
    {
        this.longText = longText;
        this.shortText = shortText;
    }

    public String getLongText()
    {
        return longText;
    }

    public String getShortText()
    {
        return shortText;
    }
}

package com.bookofthedeadnotifier;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BookOfTheDeadNotifierPlugin.class);
		RuneLite.main(args);
	}
}

