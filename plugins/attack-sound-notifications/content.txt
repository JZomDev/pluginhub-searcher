package com.AttackSoundNotifications;

import static com.AttackSoundNotifications.AttackSoundNotificationsPlugin.CONFIG_GROUP;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;

@ConfigGroup(CONFIG_GROUP)
public interface AttackSoundNotificationsConfig extends Config
{

	@Range(min = 0, max = 200)
	@ConfigItem(position = 1, keyName = "Volume", name = "Volume", description = "Control how loud the audio should be")
	default int Volume()
	{
		return 25;
	}

	@ConfigItem(keyName = "help", name = "Help", description = "Panel Help", position = 2, warning = "Reset this field if you accidentally remove it.")
	default String help()
	{
		return "When you use the plugin panel " +
			"the default weapon is ALL weapons (-1). " +
			"If you don't select a weapon, it will " +
			"play the sound for any weapon you hit with. " +
			"Otherwise it will play only for the weapon you select";
	}

	// Instructions to add custom sounds
	@ConfigItem(keyName = "customHitSound", name = "Set Custom Sound", description = "Instructions to set custom sounds", position = 3, warning = "Reset this field if you accidentally remove it.")
	default String customHitSound()
	{
		return "Adding a custom sound:\n" +
			"Add your custom sound file anywhere you want\n" +
			"Copy the absolute filepath\n" +
			"Paste the filepath into the text box under the dropdown menus\n" +
			"Click \"Test the sound\" to make sure the plugin found it\n\n" +
			"You'll receive a chat message in-game if your file can't be found when you attack.";
	}
}

/* Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2022, Ferrariic <ferrariictweet@gmail.com>
 * Copyright (c) 2018, Raqes <j.raqes@gmail.com>
 * Copyright (c) 2019, Ron Young <https://github.com/raiyni>
 * Copyright (c) 2023, Jacob Browder <https://github.com/DominickCobb-rs>
 * Copyright (c) 2024, TJ Stein <https://github.com/AverageToaster>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.AttackSoundNotifications;

import com.AttackSoundNotifications.ui.AttackSoundNotificationsPanel;
import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import javax.inject.Inject;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Hitsplat;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.VarPlayer;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxItemSearch;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(name = "Attack Sound Notifications", description = "A plugin that plays sounds based on hitsplats and special attacks", tags = {
	"special", "sounds", "notifications"})
public class AttackSoundNotificationsPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "attacknotifications";
	public static final String PANEL_PREFIX = "attackNotificationsPanel_";
	@Inject
	public Client client;

	@Inject
	public AttackSoundNotificationsConfig config;

	@Inject
	public ClientThread clientThread;

	@Inject
	public ClientToolbar clientToolbar;

	@Inject
	public ChatboxItemSearch searchProvider;

	@Inject
	public ChatboxPanelManager chatboxPanelManager;

	@Inject
	public ItemManager itemManager;

	@Inject
	public ConfigManager configManager;

	@Inject
	public Gson gson;

	private AttackSoundNotificationsPanel pluginPanel;
	private Clip clip = null;
	private NavigationButton navButton;
	private int specialPercentage;
	private int specialWeapon;
	private boolean specced = false;

	@Provides
	AttackSoundNotificationsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(AttackSoundNotificationsConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		pluginPanel = new AttackSoundNotificationsPanel(this);
		BufferedImage icon = ImageUtil.loadImageResource(getClass(),"/icons/panelIcon.png");
		navButton = NavigationButton.builder()
			.tooltip("Attack Sounds")
			.icon(icon)
			.priority(5)
			.panel(pluginPanel)
			.build();
		clientToolbar.addNavigation(navButton);
		log.info("Attack Sounds Notifier started!");
	}

	@Override
	protected void shutDown() throws Exception
	{
		pluginPanel.save();
		clientToolbar.removeNavigation(navButton);
		log.info("Attack Sounds Notifier stopped!");
	}

	// Load new profile's attack sound notifications into the plugin panel.
	@Subscribe
	public void onProfileChanged(ProfileChanged profileChanged)
	{
		pluginPanel.profileChanged();
	}

	// From the SpecialAttackCounter plugin
	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarpId() != VarPlayer.SPECIAL_ATTACK_PERCENT)
		{
			return;
		}

		int specialPercentage = event.getValue();
		if (this.specialPercentage == -1 || specialPercentage >= this.specialPercentage)
		{
			this.specialPercentage = specialPercentage;
			return;
		}

		this.specialPercentage = specialPercentage;

		// We don't need most of this stuff, but we do need it for some reason >:(

		// This event runs prior to player and npc updating, making getInteracting() too
		// early to call..
		// defer this with invokeLater(), but note that this will run after incrementing
		// the server tick counter
		// so we capture the current server tick counter here for use in computing the
		// final hitsplat tick
		clientThread.invokeLater(() -> {
			if (specialWeapon == -1)
			{
				ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
				if (equipment != null)
				{
					Item weapon = equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
					if (weapon != null)
					{
						specialWeapon = weapon.getId();
					}
				}
			}
			specced = true;
		});
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
		Actor target = hitsplatApplied.getActor();
		Hitsplat hitsplat = hitsplatApplied.getHitsplat();
		if (hitsplat.isMine() && target != client.getLocalPlayer())
		{
			// Adapted from the SpecialAttackSounds plugin
			// Could already be assigned from the spec varbit change so we check
			// if it's already been assigned a value
			if (specialWeapon == -1)
			{
				ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
				if (equipment != null)
				{
					Item weapon = equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
					if (weapon != null)
					{
						specialWeapon = weapon.getId();
					}
				}
			}
			InputStream soundToPlay = pluginPanel.fetchSound(hitsplat.getHitsplatType(), specialWeapon, specced);
			if (soundToPlay != null)
			{
				playCustomSound(soundToPlay);
			}
			specialWeapon = -1;
			specced = false;
		}
	}

	// The following two functions have been adapted from the Hit-Sounds plugin
	public synchronized void playCustomSound(InputStream streamName)
	{
		if (clip != null)
		{
			clip.stop();
			clip.flush();
			clip.close();
			clip = null;
		}
		if (streamName != null)
		{
			try
			{
				clip = AudioSystem.getClip();
			}
			catch (LineUnavailableException e)
			{
				log.warn("Unable to play sound", e);
				return;
			}
			if (!tryLoadCustomSoundFile(streamName))
			{
				return;
			}
		}

		FloatControl volume = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);
		float gain = 20f * (float) Math.log10(config.Volume() / 100f);
		gain = Math.min(gain, volume.getMaximum());
		gain = Math.max(gain, volume.getMinimum());
		volume.setValue(gain);

		clip.start();
	}

	private boolean tryLoadCustomSoundFile(InputStream streamName)
	{
		try (AudioInputStream sound = AudioSystem.getAudioInputStream(streamName))
		{
			clip.open(sound);
			return true;
		}
		catch (UnsupportedAudioFileException | IOException | LineUnavailableException e)
		{
			log.warn("Unable to load sound", e);
		}
		return false;
	}
}

/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// Chatbox Item Search - From runelite/client/plugins/banktags/tabs/TabInterface
/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2018, Ron Young <https://github.com/raiyni>
 * Copyright (c) 2023, DominickCobb-rs <https://github.com/DominickCobb-rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.AttackSoundNotifications.ui;

import com.AttackSoundNotifications.AttackSoundNotificationsPlugin;
import com.AttackSoundNotifications.ui.AttackSoundNotificationsPanel.Condition;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.swing.BorderFactory;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.util.ImageUtil;

@Slf4j
public class EntryPanel extends JPanel
{
	private final JPanel mainPanel;
	private Integer weaponId = -1;
	private ImageIcon weaponIcon;
	private final AttackSoundNotificationsPanel pluginPanel;
	private final AttackSoundNotificationsPlugin plugin;
	private final JPanel textEntry;

	// Data fields //
	private final JLabel weaponLabel;
	private final JLabel removeEntry;
	private final JLabel audible;
	private final JTextField customSoundTextField;
	private final JLabel selectFile;
	private final JComboBox<Condition> replacing;
	private final JLabel playing;
	private final JLabel clearPlaying;
	/////////////////

	private final FlatTextField nameInput = new FlatTextField();
	private final JLabel rename = new JLabel("Rename");
	private final JLabel save = new JLabel("Save");
	private final JLabel cancel = new JLabel("Cancel");
	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
		BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR), BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	// Icons //
	public static final ImageIcon WEAPON_BACKGROUND;
	public static final BufferedImage DEFAULT_WEAPON_ICON;
	public static final ImageIcon DEFAULT_WEAPON_HOVER_ICON;
	public static final ImageIcon AUDIBLE_ICON;
	public static final ImageIcon AUDIBLE_HOVER_ICON;
	public static final ImageIcon INAUDIBLE_ICON;
	public static final ImageIcon INAUDIBLE_HOVER_ICON;
	public static final ImageIcon REMOVE_ICON;
	public static final ImageIcon REMOVE_HOVER_ICON;
	public static final ImageIcon OPEN_ICON;
	public static final ImageIcon OPEN_HOVER_ICON;

	static
	{
		final BufferedImage audibleImg = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/on.png");
		AUDIBLE_ICON = new ImageIcon(audibleImg);
		AUDIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(audibleImg, -100));

		final BufferedImage inaudibleImg = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/off.png");
		// Flipped because we want the hover to be brighter
		INAUDIBLE_HOVER_ICON = new ImageIcon(inaudibleImg);
		INAUDIBLE_ICON = new ImageIcon(ImageUtil.alphaOffset(inaudibleImg, -100));

		final BufferedImage removeImg = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/delete.png");
		REMOVE_ICON = new ImageIcon(removeImg);
		REMOVE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(removeImg, -100));

		final BufferedImage openImg = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/open_icon.png");
		OPEN_ICON = new ImageIcon(openImg);

		final BufferedImage openBrightImage = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/open_bright_icon.png");
		OPEN_HOVER_ICON = new ImageIcon(openBrightImage);

		final BufferedImage weaponBackground = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/weapon_back.png");
		WEAPON_BACKGROUND = new ImageIcon(weaponBackground);

		DEFAULT_WEAPON_ICON = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/panelIcon.png");

		final BufferedImage searchIcon = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/search.png");
		DEFAULT_WEAPON_HOVER_ICON = new ImageIcon(searchIcon);
	}


	public EntryPanel(AttackSoundNotificationsPanel passedPanel, AttackSoundNotificationsPlugin passedPlugin)
	{
		pluginPanel = passedPanel;
		plugin = passedPlugin;
		this.setName("Custom Sound " + (pluginPanel.entryPanel.getComponentCount() + 1));

		weaponLabel = new JLabel();
		weaponLabel.setHorizontalAlignment(SwingConstants.CENTER);
		weaponLabel.setBorder(new EmptyBorder(2, 2, 2, 2));

		setWeaponIcons(DEFAULT_WEAPON_ICON);

		customSoundTextField = new JTextField();
		customSoundTextField.setFocusable(true);

		replacing = new JComboBox<>(new DefaultComboBoxModel<>(Condition.values()));
		replacing.setFocusable(false);
		replacing.setToolTipText("When to play the sound");

		playing = new JLabel();
		playing.setFocusable(false);
		playing.setToolTipText("What sound to play");
		playing.setText("No sound selected");
		playing.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		playing.setForeground(Color.WHITE);
		playing.setHorizontalAlignment(JTextField.CENTER);
		playing.setBorder(new EmptyBorder(0,4,0,4));

		clearPlaying = new JLabel();
		clearPlaying.setIcon(REMOVE_ICON);
		clearPlaying.setToolTipText("Clear the custom sound path");
		clearPlaying.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JButton testSound = new JButton("Play the sound");
		testSound.setFocusable(false);
		testSound.setToolTipText("Play the selected sound, if it exists");

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setBorder(NAME_BOTTOM_BORDER);

		JPanel nameActions = new JPanel(new BorderLayout(3, 0));
		nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel resetOptions = new JPanel(new BorderLayout());
		resetOptions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel reset = new JLabel("Reset");
		reset.setFont(FontManager.getRunescapeSmallFont());
		reset.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		reset.setHorizontalAlignment(SwingConstants.CENTER);
		audible = new JLabel();
		reset.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				boolean shiftHeld = mouseEvent.isShiftDown();
				if (!shiftHeld)
				{
					if(JOptionPane.showConfirmDialog(EntryPanel.this, "Reset this sound swap?", "Confirm", JOptionPane.YES_NO_OPTION)!=0)
					{
						return;
					}
				}
				EntryPanel.this.setName("Custom Sound " + pluginPanel.entryPanel.getComponentCount());
				nameInput.setText("Custom Sound " + pluginPanel.entryPanel.getComponentCount());
				audible.setIcon(AUDIBLE_ICON);
				setWeaponIcons(DEFAULT_WEAPON_ICON);
				weaponId = -1;
				replacing.setSelectedIndex(0);
				playing.setToolTipText("No sound selected");
				playing.setText("No sound selected");
				pluginPanel.save();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				reset.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				reset.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			}
		});

		save.setVisible(false);
		save.setFont(FontManager.getRunescapeSmallFont());
		save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		save.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				save();
				mainPanel.requestFocusInWindow();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
			}
		});

		cancel.setVisible(false);
		cancel.setFont(FontManager.getRunescapeSmallFont());
		cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		cancel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				cancel();
				mainPanel.requestFocusInWindow();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}
		});

		rename.setFont(FontManager.getRunescapeSmallFont());
		rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		rename.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				nameInput.setEditable(true);
				updateNameActions(true);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			}
		});

		nameActions.add(save, BorderLayout.EAST);
		nameActions.add(cancel, BorderLayout.WEST);
		nameActions.add(rename, BorderLayout.CENTER);

		nameInput.setText(this.getName());
		nameInput.setBorder(null);
		nameInput.setEditable(false);
		nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameInput.getTextField().setForeground(Color.WHITE);
		nameInput.getTextField().setHorizontalAlignment(JTextField.CENTER);
		nameInput.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					save();
					mainPanel.requestFocusInWindow();
				}
				else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					cancel();
					mainPanel.requestFocusInWindow();
				}
			}
		});

		nameWrapper.add(nameInput, BorderLayout.CENTER);
		nameWrapper.setPreferredSize(new Dimension(200, 20));

		resetOptions.add(reset, BorderLayout.CENTER);

		removeEntry = new JLabel();
		removeEntry.setIcon(new ImageIcon(ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class,"/icons/delete.png")));
		removeEntry.setToolTipText("Remove this sound");

		removeEntry.setBorder(new EmptyBorder(2, 2, 2, 2));

		JPanel removePanel = new JPanel(new BorderLayout());
		removePanel.add(removeEntry, BorderLayout.EAST);
		removePanel.add(nameActions, BorderLayout.WEST);
		removePanel.add(resetOptions, BorderLayout.CENTER);

		JPanel weaponIconPanel = new JPanel(new BorderLayout())
		{
			@Override
			protected void paintComponent(Graphics g)
			{
				super.paintComponent(g);
				ImageIcon image = new ImageIcon(ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/weapon_back.png"));
				int x = (getWidth() - image.getIconWidth()) / 2;
				int y = (getHeight() - image.getIconHeight()) / 2;
				g.drawImage(image.getImage(), x, y, null);
			}
		};
		weaponIconPanel.add(weaponLabel, BorderLayout.CENTER);
		weaponIconPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		weaponIconPanel.setMinimumSize(new Dimension(32, 32));
		weaponIconPanel.setPreferredSize(new Dimension(32, 32));
		weaponIconPanel.setMaximumSize(new Dimension(32, 32));
		JPanel chooserPanel = new JPanel(new BorderLayout());
		chooserPanel.add(replacing, BorderLayout.EAST);
		chooserPanel.add(weaponIconPanel, BorderLayout.WEST);
		chooserPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.add(removePanel, BorderLayout.NORTH);
		topPanel.add(chooserPanel, BorderLayout.CENTER);
		topPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		topPanel.setBorder(new EmptyBorder(4, 4, 4, 4));

		audible.setHorizontalAlignment(SwingConstants.CENTER);
		audible.setToolTipText("Enable/Disable");
		JPanel iconPanel = new JPanel(new BorderLayout());
		iconPanel.add(audible, BorderLayout.WEST);
		iconPanel.add(playing, BorderLayout.CENTER);
		iconPanel.add(clearPlaying, BorderLayout.EAST);
		iconPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		iconPanel.setBorder(new EmptyBorder(4, 4, 4, 4));

		selectFile = new JLabel();
		selectFile.setIcon(OPEN_ICON);
		selectFile.setToolTipText("Find the file in on your computer");

		textEntry = new JPanel(new BorderLayout());
		textEntry.add(new JLabel("Enter your custom sound here:"), BorderLayout.NORTH);
		textEntry.add(customSoundTextField, BorderLayout.CENTER);
		textEntry.add(selectFile, BorderLayout.EAST);
		textEntry.setBorder(new EmptyBorder(5, 8, 5, 8));
		textEntry.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JPanel buttons = new JPanel(new BorderLayout());
		buttons.add(textEntry, BorderLayout.NORTH);
		buttons.add(testSound, BorderLayout.CENTER);
		buttons.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Not my stuff - From the ScreenMarkerPluginPanel //
		JPanel bottomContainer = new JPanel(new BorderLayout());
		bottomContainer.add(topPanel, BorderLayout.NORTH);
		bottomContainer.add(iconPanel, BorderLayout.CENTER);
		bottomContainer.add(buttons, BorderLayout.SOUTH);
		bottomContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
		bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		mainPanel = new JPanel();
		mainPanel.setLayout(new BorderLayout());
		mainPanel.setFocusable(true);
		mainPanel.add(nameWrapper, BorderLayout.NORTH);
		mainPanel.add(bottomContainer, BorderLayout.SOUTH);
		Border emptyBorder = new EmptyBorder(0, 0, 0, 0);
		MatteBorder topRightBorder = new MatteBorder(3, 0, 0, 3, ColorScheme.DARKER_GRAY_COLOR.brighter());
		MatteBorder bottomLeftBorder = new MatteBorder(0, 3, 3, 0, ColorScheme.DARKER_GRAY_COLOR.darker());
		CompoundBorder firstBorder = new CompoundBorder(topRightBorder, emptyBorder);
		CompoundBorder semiFinalBorder = new CompoundBorder(bottomLeftBorder, firstBorder);
		CompoundBorder finalBorder = new CompoundBorder(new EmptyBorder(1, 0, 1, 0), semiFinalBorder);

		mainPanel.setBorder(finalBorder);
		replacing.setMaximumSize(new Dimension(160, 32));
		replacing.setPreferredSize(new Dimension(155, 32));

		audible.setIcon(AUDIBLE_ICON);
		audible.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

		// Set default weapon icon //
		weaponLabel.setIcon(weaponIcon);
		weaponIconPanel.setToolTipText("Choose the weapon to play the sound for");

		// ACTIONS //
		weaponIconPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		weaponIconPanel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				// Ripped directly from weapon-animation-replacer
				if (plugin.client.getGameState() != GameState.LOGGED_IN)
				{
					JOptionPane.showMessageDialog(pluginPanel,
						"This plugin uses the in-game item search panel; you must be logged in to use this.",
						"Log in to choose items",
						JOptionPane.ERROR_MESSAGE);
					weaponLabel.setIcon(weaponIcon);
					return;
				}
				plugin.searchProvider.tooltipText("Choose this weapon").onItemSelected((itemId) -> {
					if (itemId == null)
					{
						log.warn("Failed to get itemId");
					}
					else
					{
						weaponId = itemId;
						setWeaponIcons(plugin.itemManager.getImage(weaponId, 0, false));
						pluginPanel.save();
					}
				}).build();
				plugin.chatboxPanelManager.openInput(plugin.searchProvider);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				weaponLabel.setIcon(DEFAULT_WEAPON_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				weaponLabel.setIcon(weaponIcon);
			}

		});

		audible.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (audible.getIcon() == AUDIBLE_HOVER_ICON)
				{
					audible.setIcon(INAUDIBLE_HOVER_ICON);
				}
				else
				{
					audible.setIcon(AUDIBLE_HOVER_ICON);
				}
				pluginPanel.save();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				if (audible.getIcon() == AUDIBLE_ICON)
				{
					audible.setIcon(AUDIBLE_HOVER_ICON);
				}
				else
				{
					audible.setIcon(INAUDIBLE_HOVER_ICON);
				}
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				if (audible.getIcon() == AUDIBLE_HOVER_ICON)
				{
					audible.setIcon(AUDIBLE_ICON);
				}
				else
				{
					audible.setIcon(INAUDIBLE_ICON);
				}
			}
		});

		removeEntry.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				boolean shiftHeld = mouseEvent.isShiftDown();
				if (!shiftHeld)
				{
					int confirm = JOptionPane.showConfirmDialog(EntryPanel.this, "Delete this sound swap?", "Confirm", JOptionPane.YES_NO_OPTION);
					if (confirm != 0)
					{
						return; // If user doesn't confirm, we do nothing more
					}
				}
				pluginPanel.removeEntryPanel(EntryPanel.this);
				pluginPanel.entryPanel.remove(mainPanel);
				pluginPanel.reloadPanels();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				removeEntry.setIcon(REMOVE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				removeEntry.setIcon(REMOVE_ICON);
			}
		});

		replacing.addActionListener(new ActionListener()
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				pluginPanel.save();
			}
		});

		clearPlaying.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				boolean shiftHeld = mouseEvent.isShiftDown();
				if (!shiftHeld)
				{
					int confirm = JOptionPane.showConfirmDialog(EntryPanel.this, "Clear the sound path?", "Confirm", JOptionPane.YES_NO_OPTION);
					if (confirm != 0)
					{
						return; // If user doesn't confirm, we do nothing more
					}
				}
				playing.setText("No sound selected");
				playing.setToolTipText("No sound selected");
				customSoundTextField.setText("");
				save();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				clearPlaying.setIcon(REMOVE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				clearPlaying.setIcon(REMOVE_ICON);
			}
		});

		customSoundTextField.addActionListener(new ActionListener()
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				if (customSoundTextField.getText().endsWith(".wav"))
				{
					String text = customSoundTextField.getText();
					pluginPanel.requestFocusInWindow();
					String newString;
					if (text.contains("\\"))
					{
						newString = text.substring(text.lastIndexOf('\\') + 1, text.lastIndexOf('.'));
					}
					else
					{
						newString = text.substring(text.lastIndexOf('/') + 1, text.lastIndexOf('.'));
					}
					playing.setText(newString);
					playing.setToolTipText(newString);

					pluginPanel.save();
				}
				else
				{
					JOptionPane.showMessageDialog(EntryPanel.this, "Acceptable file types: .wav", "Bad file", JOptionPane.ERROR_MESSAGE);
					customSoundTextField.setText("");
					playing.setText("No sound selected");
				}
			}
		});

		selectFile.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		selectFile.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				JFileChooser fileChooser = new JFileChooser();
				fileChooser.setCurrentDirectory(new File(System.getProperty("user.home"))); // start at application
				fileChooser.setFileFilter(new FileNameExtensionFilter(".wav sound files", "wav"));
				int returnValue = fileChooser.showOpenDialog(null);
				if (returnValue == JFileChooser.APPROVE_OPTION)
				{
					String filePath = fileChooser.getSelectedFile().getPath();
					if (filePath.endsWith(".wav"))
					{
						customSoundTextField.setText(filePath);
						pluginPanel.requestFocusInWindow();
						String newString;
						if (filePath.contains("\\"))
						{
							newString = filePath.substring(filePath.lastIndexOf('\\') + 1, filePath.lastIndexOf('.'));
						}
						else
						{
							newString = filePath.substring(filePath.lastIndexOf('/') + 1, filePath.lastIndexOf('.'));
						}
						playing.setText(newString);
						playing.setToolTipText(newString);
						pluginPanel.save();
					}
					else
					{
						JOptionPane.showMessageDialog(EntryPanel.this, "Acceptable file types: .wav", "Bad file", JOptionPane.ERROR_MESSAGE);
					}
				}
				pluginPanel.reloadPanels();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				selectFile.setIcon(OPEN_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				selectFile.setIcon(OPEN_ICON);
			}
		});

		testSound.addActionListener(new ActionListener()
		{
			@Override
			public void actionPerformed(ActionEvent e)
			{
				pluginPanel.findCustomSound(getCustomSoundPath());
			}
		});
	}

	// ALSO NOT MINE //
	// From the Screen Markers plugin //
	private void save()
	{
		// plugin.updateConfig();
		nameInput.setEditable(false);
		updateNameActions(false);
		setName(nameInput.getText());
		pluginPanel.save();
	}

	private void cancel()
	{
		nameInput.setEditable(false);
		nameInput.setText(this.getName());
		updateNameActions(false);
	}

	private void updateNameActions(boolean saveAndCancel)
	{
		save.setVisible(saveAndCancel);
		cancel.setVisible(saveAndCancel);
		rename.setVisible(!saveAndCancel);

		if (saveAndCancel)
		{
			nameInput.getTextField().requestFocusInWindow();
			nameInput.getTextField().selectAll();
		}
	}
	/////////////////////////

	// Get the panel to add to the pluginPanel //
	public JPanel getMainPanel()
	{
		return mainPanel;
	}

	// Get the panel data, for sound selection purposes //
	public int getWeaponId()
	{
		return weaponId;
	}

	public boolean getAudible()
	{
		return audible.getIcon() == AUDIBLE_ICON || audible.getIcon() == AUDIBLE_HOVER_ICON;
	}

	public Condition getReplacing()
	{
		return (Condition) replacing.getSelectedItem();
	}

	// Get the panel data in string form for simple storage
	public String getWeaponIdString()
	{
		return Integer.toString(weaponId);
	}

	public String getAudibleString()
	{
		if (audible.getIcon() == AUDIBLE_ICON || audible.getIcon() == AUDIBLE_HOVER_ICON)
		{
			return "true";
		}
		else
		{
			return "false";
		}
	}

	public String getCustomSoundPath()
	{
		return customSoundTextField.getText();
	}

	public String getReplacingString()
	{
		return replacing.getSelectedItem().toString();
	}

	private void setWeaponIcons(BufferedImage image)
	{
		weaponIcon = new ImageIcon(image);
		weaponLabel.setIcon(weaponIcon);
	}

	// Set the panel data from the stored config
	public void setPanelName(String name)
	{
		setName(name);
		nameInput.setText(name);
	}

	public void setWeaponId(String id)
	{
		weaponId = (Integer.parseInt(id));
		if (weaponId == -1)
		{
			setWeaponIcons(DEFAULT_WEAPON_ICON);
		}
		else
		{
			setWeaponIcons(plugin.itemManager.getImage(weaponId, 0, false));
		}
	}

	public void setAudible(String audibleStatus)
	{
		if (audibleStatus.equals("true"))
		{
			audible.setIcon(AUDIBLE_ICON);
		}
		else
		{
			audible.setIcon(INAUDIBLE_ICON);
		}
	}

	public void setReplacing(Condition replacingValue)
	{
		replacing.setSelectedItem(replacingValue);
	}

	public void setCustomSoundPath(String customSoundPath)
	{
		customSoundTextField.setText(customSoundPath);
		// for some reason the sound path will be empty and yet it will say it's non-null.
		// checking if it is >4 maybe ensures the '.wav' exists
		if (customSoundPath.length() > 4)
		{
			if (customSoundPath.contains("\\"))
			{
				playing.setText(customSoundPath.substring(customSoundPath.lastIndexOf('\\') + 1, customSoundPath.lastIndexOf('.')));
			}
			else
			{
				playing.setText(customSoundPath.substring(customSoundPath.lastIndexOf('/') + 1, customSoundPath.lastIndexOf('.')));
			}
		}
	}
}
package com.AttackSoundNotifications.ui;

public class EntryPanelState
{
	private String panelName;
	private String weaponId;
	private String audible_status;
	private String customSoundTextField_contents;
	private String replacing_value;

	public EntryPanelState(EntryPanel panel)
	{
		this.panelName = panel.getName();
		this.weaponId = panel.getWeaponIdString();
		this.audible_status = panel.getAudibleString();
		this.customSoundTextField_contents = panel.getCustomSoundPath();
		this.replacing_value = panel.getReplacingString();
	}

	public String getPanelName()
	{
		return panelName;
	}

	public String getWeaponId()
	{
		return weaponId;
	}

	public String getAudible()
	{
		return audible_status;
	}

	public String getCustomSoundPath()
	{
		return customSoundTextField_contents;
	}

	public String getReplacing()
	{
		return replacing_value;
	}
}
// License from ScreenMarkerPluginPanel
/*
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * Copyright (c) 2023, DominickCobb-rs <https://github.com/DominickCobb-rs>
 * Copyright (c) 2024, TJ Stein <https://github.com/AverageToaster>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.AttackSoundNotifications.ui;

import com.AttackSoundNotifications.AttackSoundNotificationsPlugin;
import static com.AttackSoundNotifications.AttackSoundNotificationsPlugin.CONFIG_GROUP;
import static com.AttackSoundNotifications.AttackSoundNotificationsPlugin.PANEL_PREFIX;
import com.google.gson.reflect.TypeToken;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.api.ChatMessageType;
import net.runelite.api.HitsplatID;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;

public class AttackSoundNotificationsPanel extends PluginPanel
{
	private final List<EntryPanel> entryPanelList = new ArrayList<>();

	// Panel Construction //
	private static final ImageIcon ADD_ICON;
	private static final ImageIcon ADD_HOVER_ICON;
	private final JLabel addSound = new JLabel(ADD_ICON);
	public final JPanel entryPanel = new JPanel(new GridBagLayout());

	static
	{
		final BufferedImage addIcon = ImageUtil.loadImageResource(AttackSoundNotificationsPlugin.class, "/icons/add_icon.png");
		ADD_ICON = new ImageIcon(addIcon);
		ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));
	}

	private final AttackSoundNotificationsPlugin plugin;
	private Boolean startup = false;

	public enum Condition
	{
		SPECIAL_HIT("Special Attack Hit"), SPECIAL_MISS("Special Attack Miss"), SPECIAL_MAX("Special Attack Max"), MAX("Non-Special Max"), MISS("Non-Special Miss");

		private final String displayValue;

		Condition(String displayValue)
		{
			this.displayValue = displayValue;
		}

		public static Condition fromString(String displayValue)
		{
			for (Condition option : Condition.values())
			{
				if (option.displayValue.equalsIgnoreCase(displayValue))
				{
					return option;
				}
			}
			return null;
		}

		@Override
		public String toString()
		{
			return this.displayValue;
		}
	}

	// Panels >:(
	@Inject
	public AttackSoundNotificationsPanel(AttackSoundNotificationsPlugin plugin)
	{
		this.plugin = plugin;
		setLayout(new BorderLayout());
		JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.setBorder(new EmptyBorder(11, 10, 10, 10));

		JLabel title = new JLabel();
		title.setText("Attack Sound Notifications");
		title.setForeground(Color.WHITE);

		northPanel.add(title, BorderLayout.WEST);
		northPanel.add(addSound, BorderLayout.EAST);

		add(northPanel, BorderLayout.NORTH);
		add(entryPanel, BorderLayout.SOUTH);

		addSound.setToolTipText("Add new sound");
		addSound.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		addSound.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				addNewEntry();
				save();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				addSound.setIcon(ADD_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				addSound.setIcon(ADD_ICON);
			}
		});
		loadEntryPanels(entryPanel);
	}

	public void reloadPanels()
	{
		plugin.clientThread.invokeLater(() -> {
			this.revalidate();
			this.repaint();
		});
	}

	private void addNewEntry()
	{
		GridBagConstraints entryConstraints = new GridBagConstraints();
		entryConstraints.gridx = 0;
		entryConstraints.weightx = 1;
		entryConstraints.fill = GridBagConstraints.HORIZONTAL;
		entryConstraints.anchor = GridBagConstraints.NORTH;

		EntryPanel newEntryPanel = new EntryPanel(this, plugin);

		entryPanelList.add(newEntryPanel);

		entryPanel.add(newEntryPanel.getMainPanel(), entryConstraints);

		reloadPanels();
	}

	private void loadEntryPanels(JPanel parentPanel)
	{
		startup = true;
		List<EntryPanelState> panelStates = plugin.gson.fromJson(
			plugin.configManager.getConfiguration(CONFIG_GROUP, PANEL_PREFIX
			), new TypeToken<List<EntryPanelState>>()
			{
			}.getType());
		if (panelStates != null)
		{
			for (EntryPanelState panelState : panelStates)
			{
				if (panelState.getPanelName() != null)
				{
					EntryPanel newPanel = new EntryPanel(this, plugin);
					newPanel.setPanelName(panelState.getPanelName());
					if (panelState.getWeaponId() != null)
					{
						newPanel.setWeaponId(panelState.getWeaponId());
					}
					if (panelState.getAudible() != null)
					{
						newPanel.setAudible(panelState.getAudible());
					}
					if (panelState.getReplacing() != null)
					{
						Condition replacing = Condition.fromString(panelState.getReplacing());
						newPanel.setReplacing(replacing);
					}
					if (panelState.getCustomSoundPath() != null)
					{
						newPanel.setCustomSoundPath(panelState.getCustomSoundPath());
					}
					entryPanelList.add(newPanel);
					GridBagConstraints entryConstraints = new GridBagConstraints();
					entryConstraints.gridx = 0;
					entryConstraints.weightx = 1;
					entryConstraints.fill = GridBagConstraints.HORIZONTAL;
					entryConstraints.anchor = GridBagConstraints.NORTHWEST;
					parentPanel.add(newPanel.getMainPanel(), entryConstraints);
				}

			}
		}
		startup = false;
	}

	public void save()
	{
		if (!startup)
		{
			List<EntryPanelState> panelStates = entryPanelList.stream().map(EntryPanelState::new).collect(Collectors.toList());
			plugin.configManager.setConfiguration(CONFIG_GROUP, PANEL_PREFIX, plugin.gson.toJson(panelStates));
		}

	}

	public void removeEntryPanel(EntryPanel panel)
	{
		entryPanelList.remove(panel);
		save();
	}

	public void profileChanged()
	{
		entryPanelList.clear();
		entryPanel.removeAll();
		loadEntryPanels(entryPanel);
		reloadPanels();
	}

	// Sounds! //
	public InputStream fetchSound(Integer hitType, Integer weaponId, Boolean usedSpecialAttack)
	{
		for (EntryPanel panel : entryPanelList)
		{
			if ((weaponId == panel.getWeaponId() || panel.getWeaponId() == -1) && panel.getAudible() && !panel.getCustomSoundPath().isEmpty())
			{
				InputStream returnSound;
				switch (panel.getReplacing())
				{
					case MISS:
					{
						if (!usedSpecialAttack)
						{
							if (hitType == HitsplatID.BLOCK_ME)
							{
								returnSound = loadCustomSound(panel.getCustomSoundPath());
								if (returnSound == null)
								{
									plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Couldn't find custom sound file:" + panel.getCustomSoundPath(), null);
								}
								return returnSound;
							}
						}
					}
					break;
					case MAX:
					{
						if (!usedSpecialAttack)
						{
							if (hitType == HitsplatID.DAMAGE_MAX_ME)
							{
								returnSound = loadCustomSound(panel.getCustomSoundPath());
								if (returnSound == null)
								{
									plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Couldn't find custom sound file:" + panel.getCustomSoundPath(), null);
								}
								return returnSound;
							}
						}
					}
					break;
					case SPECIAL_MISS:
					{
						if (usedSpecialAttack)
						{
							if (hitType == HitsplatID.BLOCK_ME)
							{
								returnSound = loadCustomSound(panel.getCustomSoundPath());
								if (returnSound == null)
								{
									plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Couldn't find custom sound file:" + panel.getCustomSoundPath(), null);
								}
								return returnSound;
							}
						}
					}
					break;
					case SPECIAL_HIT:
					{
						if (usedSpecialAttack)
						{
							if (hitType == HitsplatID.DAMAGE_ME)
							{
								returnSound = loadCustomSound(panel.getCustomSoundPath());
								if (returnSound == null)
								{
									plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Couldn't find custom sound file:" + panel.getCustomSoundPath(), null);
								}
								return returnSound;
							}
						}
					}
					break;
					case SPECIAL_MAX:
					{
						if (usedSpecialAttack)
						{
							if (hitType == HitsplatID.DAMAGE_MAX_ME)
							{
								returnSound = loadCustomSound(panel.getCustomSoundPath());
								if (returnSound == null)
								{
									plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Couldn't find custom sound file:" + panel.getCustomSoundPath(), null);
								}
								return returnSound;
							}
						}
					}
				}
			}
		}
		return null;
	}

	private BufferedInputStream loadCustomSound(String fileName)
	{
		try
		{
			return new BufferedInputStream(new FileInputStream(fileName));
		}
		catch (FileNotFoundException e)
		{
			return null;
		}
	}

	public void findCustomSound(String filePath)
	{
		InputStream soundStream = loadCustomSound(filePath);
		if (soundStream != null)
		{
			plugin.playCustomSound(soundStream);
		}
		else
		{
			// Plays the system default system oops noise
			java.awt.Toolkit.getDefaultToolkit().beep();
		}
	}

}

package com.AttackSoundNotifications;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AttackSoundNotificationsTest
{	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AttackSoundNotificationsPlugin.class);
		RuneLite.main(args);
	}
}
