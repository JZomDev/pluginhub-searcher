/*
 * Copyright (c) 2019, Benjamin <https://github.com/genetic-soybean>
 * Copyright (c) 2020, Bram91 <https://github.com/Bram91>
 * Copyright (c) 2020, ConorLeckey <https://github.com/ConorLeckey>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tileman;

import java.awt.*;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class TilemanModeWorldMapOverlay extends Overlay {
    private static final int REGION_SIZE = 1 << 6;
    // Bitmask to return first coordinate in region
    private static final int REGION_TRUNCATE = ~((1 << 6) - 1);

    private final Client client;
    private final TilemanModeConfig config;
    private final TilemanModePlugin plugin;

    @Inject
    private TilemanModeWorldMapOverlay(Client client, TilemanModeConfig config, TilemanModePlugin plugin) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_HIGH);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.drawTilesOnWorldMap()) {
            return null;
        }

        drawOnWorldMap(graphics);

        return null;
    }

    private void drawOnWorldMap(Graphics2D graphics) {
        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        Float pixelsPerTile = client.getWorldMap().getWorldMapZoom();
        if (map == null) {
            return;
        }
        Rectangle worldMapRect = map.getBounds();
        graphics.setClip(worldMapRect);


        int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
        int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

        Point worldMapPosition = client.getWorldMap().getWorldMapPosition();

        // Offset in tiles from anchor sides
        int yTileMin = worldMapPosition.getY() - heightInTiles / 2;
        int xRegionMin = (worldMapPosition.getX() - widthInTiles / 2) & REGION_TRUNCATE;
        int xRegionMax = ((worldMapPosition.getX() + widthInTiles / 2) & REGION_TRUNCATE) + REGION_SIZE;
        int yRegionMin = (yTileMin & REGION_TRUNCATE);
        int yRegionMax = ((worldMapPosition.getY() + heightInTiles / 2) & REGION_TRUNCATE) + REGION_SIZE;
        int regionPixelSize = (int) Math.ceil(REGION_SIZE * pixelsPerTile);

        for (int x = xRegionMin; x < xRegionMax; x += REGION_SIZE) {
            for (int y = yRegionMin; y < yRegionMax; y += REGION_SIZE) {
                int regionId = ((x >> 6) << 8) | (y >> 6);
                int plane = client.getPlane();

                // draw imported tile sets
                Set<TilemanModeTile> importedTiles = new HashSet<>();
                for (String key : plugin.getGroupTilemanDataManager().getImportedDataSetKeys()) {
                    importedTiles.addAll(plugin.readImportedTileSet(key, regionId, plane));
                }
                for (final TilemanModeTile tile : importedTiles) {
                    if (tile.getZ() != plane) {
                        continue;
                    }
                    int yTileOffset = -(yTileMin - y) + 2; // Added offset of 2 as tiles were misaligned
                    int xTileOffset = x + widthInTiles / 2 - worldMapPosition.getX();
                    int xPos = ((int) (xTileOffset * pixelsPerTile)) + (int) worldMapRect.getX();
                    int yPos = (worldMapRect.height - (int) (yTileOffset * pixelsPerTile)) + (int) worldMapRect.getY();
                    int size = (regionPixelSize / (64 - Math.round(48f * ((8f - pixelsPerTile) / 7f))));
                    int tileSize = regionPixelSize / 64;

                    graphics.setColor(Color.PINK);
                    graphics.fillRect(xPos + (tile.getRegionX() * tileSize), yPos - (tile.getRegionY() * tileSize) + tileSize, size - 1, size - 1);
                    graphics.drawRect(xPos + (tile.getRegionX() * tileSize), yPos - (tile.getRegionY() * tileSize) + tileSize, size - 1, size - 1);
                }

                // draw player claimed tiles
                for (final TilemanModeTile tile : plugin.readTiles(regionId, plane)) {
                    if(tile.getZ() != plane) {
                        continue;
                    }
                    int yTileOffset = -(yTileMin - y) + 2; // Added offset of 2 as tiles were misaligned
                    int xTileOffset = x + widthInTiles / 2 - worldMapPosition.getX();
                    int xPos = ((int) (xTileOffset * pixelsPerTile)) + (int) worldMapRect.getX();
                    int yPos = (worldMapRect.height - (int) (yTileOffset * pixelsPerTile)) + (int) worldMapRect.getY();
                    int size = (regionPixelSize / (64 - Math.round(48f * ((8f - pixelsPerTile) / 7f))));
                    int tileSize = regionPixelSize / 64;

                    graphics.setColor(new Color(config.markerColor().getRGB()));
                    graphics.fillRect(xPos + (tile.getRegionX() * tileSize), yPos - (tile.getRegionY() * tileSize) + tileSize, size - 1, size - 1);
                    graphics.drawRect(xPos + (tile.getRegionX() * tileSize), yPos - (tile.getRegionY() * tileSize) + tileSize, size - 1, size - 1);
                }
            }
        }
    }
}

package com.tileman;
import com.google.gson.JsonSyntaxException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.FlatTextField;

import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.io.IOException;
import java.util.*;
import java.awt.datatransfer.DataFlavor;
import java.util.List;

import com.google.common.base.Strings;
import com.google.gson.Gson;

class GroupTilemanData {
    String playerName;
    TreeMap<String, List<TilemanModeTile>> regionTiles;
}

@Slf4j
@Singleton
public class GroupTilemanDataManager extends PluginPanel {

    private JPanel panel;
    private GridBagConstraints constraints;
    final private TilemanModePlugin plugin;
    final private ConfigManager configManager;
    final private Gson gson;
    final private Set<String> importedDataSetKeys = new HashSet<>();
    final private Color NEUTRAL_COLOR = new Color(0, 0, 0);
    final private Color FAILURE_RED = new Color(100, 0, 0);
    final private Color SUCCESS_GREEN = new Color(0, 100, 0);

    public GroupTilemanDataManager(TilemanModePlugin plugin, ConfigManager configManager, Gson gson) {
        this.plugin = plugin;
        this.configManager = configManager;
        this.gson = gson;
        updatePanelContents();
    }

    public Set<String> getImportedDataSetKeys(){
        return importedDataSetKeys;
    }

    private void updatePanelContents() {
        // clean any previous panel contents ready for a fresh update
        removeAll();

        // stylize the panel
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // create the panel and grid to display elements in
        panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        // add contents
        addTitleToLayout("Group Tileman Data");
        addDividerToLayout(10);
        addButtonsToLayout();
        addDividerToLayout(10);
        addTitleToLayout("Imported Tile Sets:");
        addDividerToLayout(10);
        populateListOfImportedTiles();

        // add the root panel, so it displays on the plugin panel
        add(panel);
    }

    private void populateListOfImportedTiles(){

        // process the config file to determine imported tile sets
        String prefix = TilemanModePlugin.CONFIG_GROUP + "." + TilemanModePlugin.REGION_PREFIX_IMPORTED;
        List<String> configString = configManager.getConfigurationKeys(prefix);
        Set<String> cleanKeys = new HashSet<>();
        for (String key : configString){

            // scrub the prefix from the front of the string
            key = key.substring(prefix.length());

            // advance forward in the string until _ is encountered, using the characters traveled over as the label
            int underscoreIndex = key.indexOf('_');
            String cleanLabel = key.substring(0, underscoreIndex);
            cleanKeys.add(cleanLabel);
        }

        // display imported tile sets
        for (String key : cleanKeys){
            {
                importedDataSetKeys.add(key);
                addDataEntry(key);
            }
            addDividerToLayout(5);
        }

    }

    private void addDataEntry(String key) {
        // create the name related fields
        FlatTextField keyField = new FlatTextField();
        keyField.setText(key);
        keyField.setEditable(false);
        keyField.setHoverBackgroundColor(Color.ORANGE);
        panel.add(keyField, constraints);
        constraints.gridy++;

        // add a delete button with input handling
        JButton deleteButton = new JButton("Delete");
        deleteButton.addActionListener(l -> deleteTileSet(key, false));
        panel.add(deleteButton, constraints);
        constraints.gridy++;
    }

    private void deleteTileSet(String tileSetName, boolean silent) {

        // deleteTileSet is triggered silently when updating a tileset that has already been imported.
        // It first deletes it, then imports fresh from the import string.
        if (!silent) {
            String chatMessage = new ChatMessageBuilder()
                    .append(NEUTRAL_COLOR, "Deleting tile set " + tileSetName + "...")
                    .build();
            plugin.sendChatMessage(chatMessage);
        }

        // walk all imported keys matching that tile set name, then delete them.
        String configGroup = TilemanModePlugin.CONFIG_GROUP + ".";
        List<String> allKeys = configManager.getConfigurationKeys(configGroup + TilemanModePlugin.REGION_PREFIX_IMPORTED + tileSetName);
        for (String key : allKeys) {
            log.debug("Scrubbing config key: " + key);
            key = key.substring(configGroup.length());
            configManager.unsetConfiguration(TilemanModePlugin.CONFIG_GROUP, key);
        }

        // write to disk after deleting all the keys
        configManager.sendConfig();

        // rebuild the visual menu
        updatePanelContents();

        // update the tiles that the player can visually see on screen around them since tiles have been deleted
        plugin.updateTilesToRender();

        // provide feedback to the player
        if (!silent) {
            String chatMessage = new ChatMessageBuilder()
                    .append(SUCCESS_GREEN, "Tile set " + tileSetName + " was removed.")
                    .build();
            plugin.sendChatMessage(chatMessage);
        }
    }

    private void addTitleToLayout(String label) {
        JLabel title = new JLabel();
        title.setText(label);
        title.setForeground(Color.ORANGE);
        panel.add(title, constraints);
        constraints.gridy++;
    }

    private void addDividerToLayout(int height) {
        panel.add(Box.createRigidArea(new Dimension(0, height)), constraints);
        constraints.gridy++;
    }

    private void addButtonsToLayout() {

        // create the import button
        JButton importButton = new JButton("Import from clipboard (Paste)");
        panel.add(importButton, constraints);
        importButton.addActionListener(l -> importButtonClicked());
        importButton.setToolTipText("Import Tileman Data from the string currently copied to the system clipboard.");
        constraints.gridy++;

        // tiny divider
        addDividerToLayout(5);

        // create the export button
        JButton exportButton = new JButton("Export to clipboard (Copy)");
        panel.add(exportButton, constraints);
        exportButton.addActionListener(l -> exportButtonClicked());
        exportButton.setToolTipText("Export your claimed tiles as plaintext Tileman Data to the clipboard for sharing.");
        constraints.gridy++;

        // provide optional cleanup functionality for legacy group tileman data
        List<String> legacyKeys = configManager.getConfigurationKeys(TilemanModePlugin.LEGACY_GROUP_TILEMAN_CONFIG_GROUP);
        if (legacyKeys != null && !legacyKeys.isEmpty()){

            // tiny divider
            addDividerToLayout(5);

            JButton purgeButton = new JButton("Purge legacy Group tileman data");
            panel.add(purgeButton, constraints);
            purgeButton.addActionListener(l -> purgeButtonClicked());
            purgeButton.setToolTipText("Deletes data from the old 'Group tileman addon' plugin (deprecated). "
                    + "May improve performance if you had previously imported many group tiles.");
            constraints.gridy++;
        }
    }

    private void purgeButtonClicked() {

        // provide immediate feedback when the button is clicked
        String start = new ChatMessageBuilder()
                .append(NEUTRAL_COLOR, "Cleaning up 'Group tileman addon' config file data...")
                .build();
        plugin.sendChatMessage(start);

        // walk all legacy keys and delete them
        String groupName = TilemanModePlugin.LEGACY_GROUP_TILEMAN_CONFIG_GROUP;
        List<String> legacyKeys = configManager.getConfigurationKeys(groupName + ".");
        for (String key : legacyKeys) {
            String cleanKey = key.substring(groupName.length() + 1);
            configManager.unsetConfiguration(groupName, cleanKey);
        }

        // save to disk since we've removed a significant volume of config data
        configManager.sendConfig();

        // rebuild the visual menu since this purge button should now disappear
        updatePanelContents();

        // provide results feedback
        String end = new ChatMessageBuilder()
                .append(SUCCESS_GREEN, legacyKeys.size() + " legacy config entries were successfully removed.")
                .build();
        plugin.sendChatMessage(end);
    }

    private void importButtonClicked() {

        String start = new ChatMessageBuilder()
                .append(NEUTRAL_COLOR, "Beginning tile set import from system clipboard...")
                .build();
        plugin.sendChatMessage(start);

        // Exit early if we can't get the clipboard text contents
        final String clipboardText;
        try {
            clipboardText = Toolkit.getDefaultToolkit()
                    .getSystemClipboard()
                    .getData(DataFlavor.stringFlavor)
                    .toString();
        } catch (IOException | UnsupportedFlavorException ex) {
            // this is so we grab the exception details in debug
            log.debug(" | There was an error while reading from the clipboard", ex);
            String chatMessage = new ChatMessageBuilder()
                    .append(FAILURE_RED, "Import failed. Unable to read the data from the system clipboard.")
                    .build();
            plugin.sendChatMessage(chatMessage);
            return;
        }

        // Exit early if we can't validate the data is a string
        if (Strings.isNullOrEmpty(clipboardText)) {
            String chatMessage = new ChatMessageBuilder()
                    .append(FAILURE_RED, "Import failed. No text was found on the clipboard.")
                    .build();
            plugin.sendChatMessage(chatMessage);
            return;
        }

        processGroupTilemanImport(clipboardText);
    }

    private void processGroupTilemanImport(String clipboardText){

        // Config related string keys used in this function should not be updated.
        // They have been statically implemented to ensure backwards compatibility with data exported
        // from the legacy group tileman plugin https://github.com/Flexz9/Tileman-GroupMode

        // convert export string to groupTilemanData
        GroupTilemanData parsedData;
        try {
            parsedData = gson.fromJson(clipboardText, GroupTilemanData.class);
        } catch (JsonSyntaxException e) {
            log.debug("The text on the clipboard was unable to be parsed. Abandoning import.", e);
            String chatMessage = new ChatMessageBuilder()
                    .append(FAILURE_RED, "Import failed. Clipboard text was not a well formed group tileman tile set.")
                    .build();
            plugin.sendChatMessage(chatMessage);
            return;
        }

        // generate a sanitized pure alphanumeric label for the tile set
        String tileSetName;
        try {
            // guard against empty field contents
            if (parsedData.playerName == null){
                throw new IllegalArgumentException();
            }

            // clean the label by scrubbing all non-alphanumeric characters as these can interfere with parsing
            String cleaningRegex = "[^a-zA-Z0-9]";
            tileSetName = parsedData.playerName.replaceAll(cleaningRegex, "");

            // guard against the sanitized string being clean, but empty
            if (tileSetName.trim().isEmpty()){
                throw new IllegalArgumentException();
            }

        } catch (Exception e){
            log.debug("Unable to extract a sensible tile set name from the supplied string.", e);
            String badName = new ChatMessageBuilder()
                    .append(FAILURE_RED, "Import failed. Unable to generate a sensible tile set name from the clipboard contents.")
                    .build();
            plugin.sendChatMessage(badName);
            return;
        }

        // clean any existing data stored under the same key name
        deleteTileSet(tileSetName, true);

        // write the imported data to the config store
        int tilesImported = 0;
        for (String regionStr : parsedData.regionTiles.keySet()) {
            List<TilemanModeTile> regionTiles = parsedData.regionTiles.get(regionStr);
            int regionId = Integer.parseInt(regionStr.substring(TilemanModePlugin.REGION_PREFIX_V1.length()));
            for(int plane = 0; plane < 4; plane++){

                // split the region data to planes
                List<TilemanModeTile> filteredTiles = new ArrayList<>();
                for (TilemanModeTile tile : regionTiles) {
                    if (tile.getZ() == plane){
                        filteredTiles.add(tile);
                    }
                }

                String key = TilemanModePlugin.REGION_PREFIX_IMPORTED + tileSetName + "_" + regionId + "_" + plane;
                plugin.writeV2FormatData(filteredTiles, key);
                tilesImported += filteredTiles.size();
            }
        }

        // save to disk since we've imported new data
        configManager.sendConfig();

        // rebuild the visual menu
        updatePanelContents();

        // update the tiles that the player can visually see on screen around them based on the new import data
        plugin.updateTilesToRender();

        // provide some feedback to the player
        String chatMessage = new ChatMessageBuilder()
                .append(SUCCESS_GREEN, "Successfully imported " + tilesImported + " tiles into tile set " + tileSetName + "!")
                .build();
        plugin.sendChatMessage(chatMessage);
    }

    private void exportButtonClicked() {

        // Config related string keys used in this function should not be updated.
        // They have been statically implemented to generate an equivalent export string as
        // from the legacy group tileman plugin https://github.com/Flexz9/Tileman-GroupMode

        String start = new ChatMessageBuilder()
                .append(NEUTRAL_COLOR, "Beginning tile set export to system clipboard...")
                .build();
        plugin.sendChatMessage(start);

        // prepare the export structure for the data export
        GroupTilemanData exportData = new GroupTilemanData();
        exportData.playerName = plugin.getPlayerName();
        exportData.regionTiles = new TreeMap<>();

        // collect config keys that need processing into the export data structure
        Set<Integer> regionsToExport = plugin.getAllRegionIds(TilemanModePlugin.CONFIG_GROUP, TilemanModePlugin.REGION_PREFIX_V2);

        // iterate all regions and collect the tiles into an export string
        int tilesExported = 0;
        for (int regionId : regionsToExport) {
            List<TilemanModeTile> tiles = new ArrayList<>();
            for (int plane = 0; plane < 4; plane++) {
                tiles.addAll(plugin.readTiles(regionId, plane));
            }
            // V1 is used for legacy format compatibility with historic exports from group tileman addon plugin.
            exportData.regionTiles.put(TilemanModePlugin.REGION_PREFIX_V1 + regionId, tiles);
            tilesExported += tiles.size();
        }

        final String exportDump = gson.toJson(exportData);
        Toolkit.getDefaultToolkit()
                .getSystemClipboard()
                .setContents(new StringSelection(exportDump), null);

        // log the complete output to the console for developers.
        log.debug("Exported tile set: {}", exportDump);

        // provide player feedback
        String end = new ChatMessageBuilder()
                .append(SUCCESS_GREEN, "Successfully exported tile set containing " + tilesExported + " tiles to system clipboard!")
                .build();
        plugin.sendChatMessage(end);

    }

    void generateLegacyGroupTilemanPluginWarning() {

        // generates a warning for up to three independent gameplay sessions about legacy plugin behavior.

        // search for group tileman related config keys
        List<String> legacyKeys = configManager.getConfigurationKeys(TilemanModePlugin.LEGACY_GROUP_TILEMAN_CONFIG_GROUP + ".");
        String warningKey = "timesWarnedAboutGroupTilemanPlugin";
        String keyContents = configManager.getConfiguration(TilemanModePlugin.CONFIG_GROUP, warningKey);
        int warningCount = 0;
        if (keyContents != null){
            warningCount = Integer.parseInt(keyContents);
        }

        // manage maximum number of warnings to provide about this
        final int maxWarningsToGive = 3;
        final int remainingWarnings = maxWarningsToGive - (warningCount + 1);
        final Map<Integer, String> countMessage = new HashMap<>();
        countMessage.put(2, "This warning will display two more times.");
        countMessage.put(1, "This warning will display one more time.");
        countMessage.put(0, "This warning will not display again.");

        // actually show the warning the first three times
        if (!legacyKeys.isEmpty() && warningCount < maxWarningsToGive) {

            String warning = "Warning: Data from the 'Group tileman addon' plugin was detected. That plugin has been deprecated! "
                    + "Group tiles are now managed in the 'Group Tileman Data' menu (located on the far right navigation bar). "
                    + "Please have your group export and import tiles through this new interface. "
                    + countMessage.get(remainingWarnings);

            plugin.sendChatMessage(new ChatMessageBuilder().append(Color.RED, warning).build());
            configManager.setConfiguration(TilemanModePlugin.CONFIG_GROUP, warningKey, warningCount + 1);
        }
    }

}
/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, ConorLeckey <https://github.com/ConorLeckey>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tileman;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.game.chatbox.ChatboxPanelManager;

import javax.inject.Inject;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
        name = "Tileman Mode",
        description = "Automatically draws tiles where you walk",
        tags = {"overlay", "tiles"}
)
public class TilemanModePlugin extends Plugin {

    // Constants with values that should not be modified. Configs "in the wild" use these keys.
    public static final String CONFIG_GROUP = "tilemanMode";
    public static final String LEGACY_GROUP_TILEMAN_CONFIG_GROUP = "groupTilemanAddon";
    public static final String REGION_PREFIX_IMPORTED = "imported_";
    public static final String REGION_PREFIX_V2 = "regionv2_";
    public static final String REGION_PREFIX_V1 = "region_";

    // Constants for menu option strings that the plugin utilises
    private static final String MARK = "Unlock Tileman tile";
    private static final String UNMARK = "Clear Tileman tile";
    private static final String WALK_HERE = "Walk here";

    private GroupTilemanDataManager groupTilemanDataManager;

    @Getter(AccessLevel.PACKAGE)
    private final List<WorldPoint> tilesToRender = new ArrayList<>();

    @Getter(AccessLevel.PACKAGE)
    private final Set<WorldPoint> groupTilesToRender = new HashSet<>();

    @Inject
    private Client client;

    @Inject
    private Gson gson;

    @Inject
    private TilemanModeConfigEvaluator config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private TilemanModeOverlay overlay;

    @Inject
    private TilemanModeMinimapOverlay minimapOverlay;

    @Inject
    private TilemanModeWorldMapOverlay worldMapOverlay;

    @Inject
    private TileInfoOverlay infoOverlay;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private ChatboxPanelManager chatboxPanelManager;

    @Provides
    TilemanModeConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TilemanModeConfig.class);
    }

    private final MovementFlag[] fullBlock = new MovementFlag[]
            {MovementFlag.BLOCK_MOVEMENT_FLOOR,
                    MovementFlag.BLOCK_MOVEMENT_FLOOR_DECORATION,
                    MovementFlag.BLOCK_MOVEMENT_OBJECT,
                    MovementFlag.BLOCK_MOVEMENT_FULL};

    private final MovementFlag[] allDirections = new MovementFlag[]
            {
                    MovementFlag.BLOCK_MOVEMENT_NORTH_WEST,
                    MovementFlag.BLOCK_MOVEMENT_NORTH,
                    MovementFlag.BLOCK_MOVEMENT_NORTH_EAST,
                    MovementFlag.BLOCK_MOVEMENT_EAST,
                    MovementFlag.BLOCK_MOVEMENT_SOUTH_EAST,
                    MovementFlag.BLOCK_MOVEMENT_SOUTH,
                    MovementFlag.BLOCK_MOVEMENT_SOUTH_WEST,
                    MovementFlag.BLOCK_MOVEMENT_WEST
            };

    private final HashSet<Integer> tutorialIslandRegionIds = new HashSet<Integer>();

    private int totalTilesUsed, remainingTiles, xpUntilNextTile;
    private LocalPoint lastTile;
    public int lastPlane;
    private boolean lastAutoTilesConfig = false;
    private boolean inHouse = false;
    private long totalXp;
    private boolean dataMigrationInProgress = false;

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {

        if (event.getMenuAction().getId() != MenuAction.RUNELITE.getId() ||
                !(event.getMenuOption().equals(MARK) || event.getMenuOption().equals(UNMARK))) {
            return;
        }

        Tile target = client.getSelectedSceneTile();
        if (target == null) {
            return;
        }
        handleMenuOption(target.getLocalLocation(), event.getMenuOption().equals(MARK));
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        final boolean hotKeyPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
        if (hotKeyPressed && event.getOption().equals(WALK_HERE)) {
            final Tile selectedSceneTile = client.getSelectedSceneTile();

            if (selectedSceneTile == null) {
                return;
            }

            final WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, selectedSceneTile.getLocalLocation());

            if (worldPoint.getPlane() != client.getPlane()) {
                return;
            }

            client.createMenuEntry(-1)
                .setOption(tilesToRender.contains(worldPoint) ? UNMARK : MARK)
                .setTarget(event.getTarget())
                .setType(MenuAction.RUNELITE);
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        autoMark();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {

        // Guard against doing anything until the player is actually logged in
        if (gameStateChanged.getGameState() != GameState.LOGGED_IN) {
            lastTile = null;
            return;
        }

        updateTileCountFromConfigs();
        updateTilesToRender();
        inHouse = false;
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        // exit early if change made is during an automatic data migration
        if (dataMigrationInProgress){
            return;
        }

        // Check if automark tiles is on, and if so attempt to step on current tile
        final WorldPoint playerPos = client.getLocalPlayer().getWorldLocation();
        final LocalPoint playerPosLocal = LocalPoint.fromWorld(client, playerPos);
        if (playerPosLocal != null && config.automarkTiles() && !lastAutoTilesConfig) {
            handleWalkedToTile(playerPosLocal);
        }
        lastAutoTilesConfig = config.automarkTiles();
        updateTileCountFromConfigs();
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        GameObject gameObject = event.getGameObject();

        if (gameObject.getId() == 4525) {
            inHouse = true;
        }
    }

    @Override
    protected void startUp() {

        log.debug("TileManMode Startup - Start");

        performConfigVersionMigrations();

        tutorialIslandRegionIds.add(12079);
        tutorialIslandRegionIds.add(12080);
        tutorialIslandRegionIds.add(12335);
        tutorialIslandRegionIds.add(12336);
        tutorialIslandRegionIds.add(12592);
        overlayManager.add(overlay);
        overlayManager.add(minimapOverlay);
        overlayManager.add(worldMapOverlay);
        overlayManager.add(infoOverlay);

        // update so we render if the plugin has just been freshly enabled.
        updateTileCountFromConfigs();
        updateTilesToRender();

        groupTilemanDataManager = new GroupTilemanDataManager(this, configManager, gson);
        NavigationButton navButton = NavigationButton.builder()
                .tooltip("Group Tileman Data")
                .icon(ImageUtil.getResourceStreamFromClass(getClass(), "/icon.png"))
                .priority(70)
                .panel(groupTilemanDataManager)
                .build();

        clientToolbar.addNavigation(navButton);

        // check if legacy group tileman data is found
        groupTilemanDataManager.generateLegacyGroupTilemanPluginWarning();
    }

    @Override
    protected void shutDown() {
        tutorialIslandRegionIds.clear();
        overlayManager.remove(overlay);
        overlayManager.remove(minimapOverlay);
        overlayManager.remove(worldMapOverlay);
        overlayManager.remove(infoOverlay);
        tilesToRender.clear();
        groupTilesToRender.clear();
    }

    private void autoMark() {

        final WorldPoint playerPos = client.getLocalPlayer().getWorldLocation();
        if (playerPos == null) {
            return;
        }

        final LocalPoint playerPosLocal = LocalPoint.fromWorld(client, playerPos);
        if (playerPosLocal == null) {
            return;
        }

        // If we have no last tile, we probably just spawned in, so make sure we walk on our current tile
        if ((lastTile == null
                || (lastTile.distanceTo(playerPosLocal) != 0 && lastPlane == playerPos.getPlane())
                || lastPlane != playerPos.getPlane()) && !regionIsOnTutorialIsland(playerPos.getRegionID())) {
            // Player moved
            handleWalkedToTile(playerPosLocal);
            lastTile = playerPosLocal;
            log.debug("last tile={}  distance={}", lastTile, lastTile == null ? "null" : lastTile.distanceTo(playerPosLocal));
        }

        // Refresh metrics
        long currentTotalXp = client.getOverallExperience();
        if (totalXp != currentTotalXp) {
            totalXp = currentTotalXp;
        }
        updateXpUntilNextTile();
        updateRemainingTiles();
    }

    Set<Integer> getAllRegionIds(String configGroup, String regionPrefix) {

        List<String> allKeys = configManager.getConfigurationKeys(configGroup + "." + regionPrefix);
        Set<Integer> regionIds = new HashSet<>();

        for (String key : allKeys) {
            key = key.replace(configGroup + "." + regionPrefix, "");
            key = key.replace("_0", "");
            key = key.replace("_1", "");
            key = key.replace("_2", "");
            key = key.replace("_3", "");
            regionIds.add(Integer.parseInt(key));
        }

        return regionIds;
    }

    private void updateTileCountFromConfigs() {
        log.debug("Updating tile counter");

        int totalTiles = 0;
        Set<Integer> regions = getAllRegionIds(CONFIG_GROUP, REGION_PREFIX_V2);
        for (int regionId : regions) {
            for (int plane = 0; plane < 4; plane++) {
                Collection<TilemanModeTile> regionTiles = readTiles(regionId, plane);
                totalTiles += regionTiles.size();
            }
        }

        totalTilesUsed = totalTiles;
        updateRemainingTiles();
    }

    private void updateRemainingTiles() {
        // Start with tiles offset. We always get these
        int earnedTiles = config.tilesOffset();

        // If including xp, add those tiles in
        if (!config.excludeExp()) {
            earnedTiles += (int) client.getOverallExperience() / config.expPerTile();
        }

        // If including total level, add those tiles in
        if (config.includeTotalLevel()) {
            earnedTiles += client.getTotalLevel();
        }

        remainingTiles = earnedTiles - totalTilesUsed;
    }

    private void updateXpUntilNextTile() {
        xpUntilNextTile = config.expPerTile() - Integer.parseInt(Long.toString(client.getOverallExperience() % config.expPerTile()));
    }

    private void performConfigVersionMigrations() {
        Instant startTime = Instant.now();
        // Progressively move v1 -> v2, then v2 -> v3 etc so users configs are always on the latest version.
        // This ensures runtime code is always using the most efficient / current implementation.
        // Use string literals here rather than constants in case somebody removes or changes the constants in future

        dataMigrationInProgress = true;

        // v1 to v2 data
        String prefix = "tilemanMode.region_";
        List<String> v1keys = configManager.getConfigurationKeys(prefix);
        for (String key : v1keys){
            Integer regionId = Integer.parseInt(key.replace(prefix, ""));
            String json = configManager.getConfiguration("tilemanMode", "region_" + regionId);
            List<TilemanModeTile> tiles = gson.fromJson(json, new TypeToken<List<TilemanModeTile>>(){}.getType());
            log.debug("TileManMode performConfigVersionMigrations - " + tiles.size() + " tiles to migrate");
            for (int plane = 0; plane < 4; plane++) {
                List<TilemanModeTile> filteredTiles = new ArrayList<TilemanModeTile>();
                for (TilemanModeTile tile : tiles) {
                    if (tile.getZ() == plane){
                        filteredTiles.add(tile);
                    }
                }
                key = "regionv2_" + regionId + "_" + plane;
                writeV2FormatData(filteredTiles, key);
            }
        }
        configManager.sendConfig(); // v1 -> v2 saved to disk

        // cleanup v1 keys now the v2 keys have been safely saved to disk
        for (String key : v1keys) {
            Integer regionId = Integer.parseInt(key.replace(prefix, ""));
            configManager.unsetConfiguration("tilemanMode", "region_" + regionId); // remove old v1 format
        }
        configManager.sendConfig(); // v1 removed from configs and saved to disk

        // any future migrations should be added here migrating from v2 data to v3 and so on.

        dataMigrationInProgress = false;
        Duration d = Duration.between(startTime, Instant.now());
        log.debug("TileManMode performConfigVersionMigrations - Finish (" + d.toMillis() + "ms)");
    }

    private void writeTiles(int regionId, Collection<TilemanModeTile> tiles, int plane) {
        // Wrap data writes using this handler so if the format changes in future only one location needs updating
        Instant startTime = Instant.now();
        String key = REGION_PREFIX_V2 + regionId + "_" + plane;
        writeV2FormatData(tiles, key);
        Duration d = Duration.between(startTime, Instant.now());
        log.debug("TileManMode writeTiles (memory) - Finish (" + d.toMillis() + "ms)");
    }

    public Collection<TilemanModeTile> readTiles(int regionId, int plane) {
        // Wrap most data reads using this handler so if the format changes in future only one location needs updating
        // The logging here is spammy for general development but useful for on demand profiling, so we comment gate it.
        //Instant startTime = Instant.now();
        Collection<TilemanModeTile> tiles = readV2FormatData(REGION_PREFIX_V2, regionId, plane);
        //Duration d = Duration.between(startTime, Instant.now());
        //log.debug("TileManMode readTiles (memory) " + regionId + ":" + plane + " - Finish (" + d.toNanos()+ " nanoseconds)");
        return tiles;
    }

    public Collection<TilemanModeTile> readImportedTileSet(String tileSetName, int regionId, int plane) {
        Collection<TilemanModeTile> tiles = readV2FormatData(REGION_PREFIX_IMPORTED + tileSetName + "_", regionId, plane);
        return tiles;
    }

    private Collection<TilemanModeTile> readV1FormatData(String configGroup, String key) {
        // retained to allow reading of legacy V1 format data

        String json = configManager.getConfiguration(configGroup, key);

        if (Strings.isNullOrEmpty(json)) {
            return Collections.emptyList();
        }

        return gson.fromJson(json, new TypeToken<List<TilemanModeTile>>() {
        }.getType());
    }

    private Collection<TilemanModeTile> readV2FormatData(String prefix, int regionID, int plane) {

        // generate the list to build or return empty.
        List<TilemanModeTile> tilesStoredInV2Format = new ArrayList<>();

        // grab the raw encoded string in Base64 from the config file
        String key = prefix + regionID + "_" + plane;
        String encoded = configManager.getConfiguration(CONFIG_GROUP, key);

        if (encoded == null){
            return tilesStoredInV2Format;
        }

        // decode to a byte array, then interpret it as a Bitset
        byte[] bytes = Base64.getUrlDecoder().decode(encoded);

        // return if there's no data under that key
        if (bytes == null || bytes.length == 0){
            return tilesStoredInV2Format;
        }

        BitSet bitSet = BitSet.valueOf(bytes);

        // find bits set to 1, and create a tile when they're found
        for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) {
            int tileRegionY = i / 64;
            int tileRegionX = i - (64 * tileRegionY);
            tilesStoredInV2Format.add(new TilemanModeTile(regionID, tileRegionX, tileRegionY, plane));
        }

        return tilesStoredInV2Format;
    }

    public void updateTilesToRender() {
        Instant startTime = Instant.now();

        // clear any existing rendering arrays
        tilesToRender.clear();
        groupTilesToRender.clear();

        // we only want to update tiles to render if they are around the player
        int[] regions = client.getMapRegions();
        if (regions == null) {
            return;
        }

        for (int regionId : regions) {

            // update player centric tile claims
            Collection<WorldPoint> worldPoint = translateToWorldPoint(readTiles(regionId, client.getPlane()));
            tilesToRender.addAll(worldPoint);

            // update group tileman claims
            for (String tileSetName : groupTilemanDataManager.getImportedDataSetKeys()) {
                Collection<WorldPoint> groupTiles = translateToWorldPoint(readImportedTileSet(tileSetName, regionId, client.getPlane()));
                groupTilesToRender.addAll(groupTiles);
            }
        }

        Duration d = Duration.between(startTime, Instant.now());
        log.debug("TileManMode updateTilesToRender - Finish (" + d.toNanos()+ " nanoseconds)");
    }

    public void writeV2FormatData(Collection<TilemanModeTile> tiles, String key) {

        // don't write empty regions. remove them instead.
        if (tiles == null || tiles.isEmpty()) {
            configManager.unsetConfiguration(CONFIG_GROUP, key);
            return;
        }

        // 4096 = 64x64 because that's Runelite's region dimensions
        BitSet out = new BitSet(4096);
        for (TilemanModeTile tile : tiles) {
            out.set(tile.getRegionY() * 64 + tile.getRegionX());
        }

        // write out the plane data directly to base64 encoded string.
        configManager.setConfiguration(CONFIG_GROUP, key, out.toByteArray());
    }

    private Collection<WorldPoint> translateToWorldPoint(Collection<TilemanModeTile> points) {
        if (points.isEmpty()) {
            return Collections.emptyList();
        }

        return points.stream()
                .map(point -> WorldPoint.fromRegion(point.getRegionId(), point.getRegionX(), point.getRegionY(), point.getZ()))
                .flatMap(worldPoint ->
                {
                    final Collection<WorldPoint> localWorldPoints = WorldPoint.toLocalInstance(client, worldPoint);
                    return localWorldPoints.stream();
                })
                .collect(Collectors.toList());
    }

    int getTotalTiles() {
        return totalTilesUsed;
    }

    int getRemainingTiles() {
        return remainingTiles;
    }

    private void handleMenuOption(LocalPoint selectedPoint, boolean markedValue) {
        if (selectedPoint == null) {
            return;
        }
        updateTileMark(selectedPoint, markedValue, true);
    }

    private void handleWalkedToTile(LocalPoint currentPlayerPoint) {
        if (currentPlayerPoint == null ||
                inHouse ||
                !config.automarkTiles()) {
            return;
        }

        // Mark the tile they walked to
        updateTileMark(currentPlayerPoint, true, false);

        // If player moves 2 tiles in a straight line, fill in the middle tile
        // TODO Fill path between last point and current point. This will fix missing tiles that occur when you lag
        // TODO   and rendered frames are skipped. See if RL has an api that mimic's OSRS's pathing. If so, use that to
        // TODO   set all tiles between current tile and lastTile as marked
        if(lastTile != null){
            int xDiff = currentPlayerPoint.getX() - lastTile.getX();
            int yDiff = currentPlayerPoint.getY() - lastTile.getY();
            int yModifier = yDiff / 2;
            int xModifier = xDiff / 2;

            switch(lastTile.distanceTo(currentPlayerPoint)) {
                case 0: // Haven't moved
                case 128: // Moved 1 tile
                    return;
                case 181: // Moved 1 tile diagonally
                    handleCornerMovement(xDiff, yDiff);
                    break;
                case 256: // Moved 2 tiles straight
                case 362: // Moved 2 tiles diagonally
                    fillTile(new LocalPoint(lastTile.getX() + xModifier, lastTile.getY() + yModifier));
                    break;
                case 286: // Moved in an 'L' shape
                    handleLMovement(xDiff, yDiff);
                    break;
            }
        }
    }

    private void handleLMovement(int xDiff, int yDiff) {
        int xModifier = xDiff / 2;
        int yModifier = yDiff / 2;
        int tileBesideXDiff, tileBesideYDiff;

        // Whichever direction has moved only one, keep it 0. This is the translation to the potential 'problem' gameObject
        if (Math.abs(yDiff) == 128) {
            tileBesideXDiff = xDiff;
            tileBesideYDiff = 0;
        } else {
            tileBesideXDiff = 0;
            tileBesideYDiff = yDiff;
        }

        MovementFlag[] tileBesideFlagsArray = getTileMovementFlags(lastTile.getX() + tileBesideXDiff, lastTile.getY() + tileBesideYDiff);

        if (tileBesideFlagsArray.length == 0) {
            fillTile(new LocalPoint(lastTile.getX() + tileBesideXDiff / 2, lastTile.getY() + tileBesideYDiff / 2));
        } else if (containsAnyOf(fullBlock, tileBesideFlagsArray)) {
            if (Math.abs(yModifier) == 64) {
                yModifier *= 2;
            } else if (Math.abs(xModifier) == 64) {
                xModifier *= 2;
            }
            fillTile(new LocalPoint(lastTile.getX() + xModifier, lastTile.getY() + yModifier));
        } else if (containsAnyOf(allDirections, tileBesideFlagsArray)){
            MovementFlag direction1, direction2;
            if (yDiff == 256 || yDiff == -128) {
                // Moving 2 North or 1 South
                direction1 = MovementFlag.BLOCK_MOVEMENT_SOUTH;
            } else {
                // Moving 2 South or 1 North
                direction1 = MovementFlag.BLOCK_MOVEMENT_NORTH;
            }
            if (xDiff == 256 || xDiff == -128) {
                // Moving 2 East or 1 West
                direction2 = MovementFlag.BLOCK_MOVEMENT_WEST;
            } else {
                // Moving 2 West or 1 East
                direction2 = MovementFlag.BLOCK_MOVEMENT_EAST;
            }

            if (containsAnyOf(tileBesideFlagsArray, new MovementFlag[]{direction1, direction2})) {
                // Interrupted
                if (yModifier == 64) {
                    yModifier = 128;
                } else if (xModifier == 64) {
                    xModifier = 128;
                }
                fillTile(new LocalPoint(lastTile.getX() + xModifier, lastTile.getY() + yModifier));
            } else {
                // Normal Pathing
                fillTile(new LocalPoint(lastTile.getX() + tileBesideXDiff / 2, lastTile.getY() + tileBesideYDiff / 2));
            }
        }
    }

    private void handleCornerMovement(int xDiff, int yDiff) {
        LocalPoint northPoint;
        LocalPoint southPoint;
        if(yDiff > 0) {
            northPoint = new LocalPoint(lastTile.getX(), lastTile.getY() + yDiff);
            southPoint = new LocalPoint(lastTile.getX() + xDiff, lastTile.getY());
        } else {
            northPoint = new LocalPoint(lastTile.getX() + xDiff, lastTile.getY());
            southPoint = new LocalPoint(lastTile.getX(), lastTile.getY() + yDiff);
        }

        MovementFlag[] northTile = getTileMovementFlags(northPoint);
        MovementFlag[] southTile = getTileMovementFlags(southPoint);

        if (xDiff + yDiff == 0) {
            // Diagonal tilts north west
            if(containsAnyOf(fullBlock, northTile)
                    || containsAnyOf(northTile, new MovementFlag[]{MovementFlag.BLOCK_MOVEMENT_SOUTH, MovementFlag.BLOCK_MOVEMENT_WEST})){
                fillTile(southPoint);
            } else if (containsAnyOf(fullBlock, southTile)
                    || containsAnyOf(southTile, new MovementFlag[]{MovementFlag.BLOCK_MOVEMENT_NORTH, MovementFlag.BLOCK_MOVEMENT_EAST})){
                fillTile(northPoint);
            }
        } else {
            // Diagonal tilts north east
            if(containsAnyOf(fullBlock, northTile)
                    || containsAnyOf(northTile, new MovementFlag[]{MovementFlag.BLOCK_MOVEMENT_SOUTH, MovementFlag.BLOCK_MOVEMENT_EAST})){
                fillTile(southPoint);
            } else if (containsAnyOf(fullBlock, southTile)
                    || containsAnyOf(southTile, new MovementFlag[]{MovementFlag.BLOCK_MOVEMENT_NORTH, MovementFlag.BLOCK_MOVEMENT_WEST})){
                fillTile(northPoint);
            }
        }
    }

    private MovementFlag[] getTileMovementFlags(int x, int y) {
        LocalPoint pointBeside = new LocalPoint(x, y);

        CollisionData[] collisionData = client.getCollisionMaps();
        assert collisionData != null;
        int[][] collisionDataFlags = collisionData[client.getPlane()].getFlags();

        Set<MovementFlag> tilesBesideFlagsSet = MovementFlag.getSetFlags(collisionDataFlags[pointBeside.getSceneX()][pointBeside.getSceneY()]);
        MovementFlag[] tileBesideFlagsArray = new MovementFlag[tilesBesideFlagsSet.size()];
        tilesBesideFlagsSet.toArray(tileBesideFlagsArray);

        return tileBesideFlagsArray;
    }

    private MovementFlag[] getTileMovementFlags(LocalPoint localPoint) {
        return  getTileMovementFlags(localPoint.getX(), localPoint.getY());
    }

    private boolean containsAnyOf(MovementFlag[] comparisonFlags, MovementFlag[] flagsToCompare) {
        if (comparisonFlags.length == 0 || flagsToCompare.length == 0) {
            return false;
        }
        for (MovementFlag flag : flagsToCompare) {
            if (Arrays.asList(comparisonFlags).contains(flag)) {
                return true;
            }
        }
        return false;
    }

    private boolean regionIsOnTutorialIsland(int regionId) {
        return tutorialIslandRegionIds.contains(regionId);
    }

    private void fillTile(LocalPoint localPoint){
        if(lastPlane != client.getPlane()) {
            return;
        }
        updateTileMark(localPoint, true, false);
    }

    private void updateTileMark(LocalPoint localPoint, boolean claimTile, boolean ignoreImportedTiles) {
        Instant startTime = Instant.now();

        // never modify a blocked tile
        if(containsAnyOf(getTileMovementFlags(localPoint), fullBlock)) {
            return;
        }

        int plane = client.getPlane();
        WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
        int regionId = worldPoint.getRegionID();
        TilemanModeTile tile = new TilemanModeTile(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), plane);
        log.debug("Updating point: {} - {}", tile, worldPoint);

        Collection<TilemanModeTile> tiles = readTiles(regionId, plane);
        Boolean tileIsUnlocked = tiles.contains(tile);
        Boolean stateChanged = false;
        Boolean groupTilemanClaimed = !ignoreImportedTiles && groupTilesToRender.contains(WorldPoint.fromLocalInstance(client, localPoint));

        // attempt to unlock
        if (claimTile && !tileIsUnlocked && !groupTilemanClaimed) {
            if ((config.allowTileDeficit() || remainingTiles > 0)) {
                log.debug("TileManMode updateTileMark - claimed tile");
                tiles.add(tile);
                tilesToRender.add(worldPoint);
                totalTilesUsed += 1;
                stateChanged = true;
            }
        }

        // release lock
        if (!claimTile && tileIsUnlocked)
        {
            log.debug("TileManMode updateTileMark - released tile");
            tiles.remove(tile);
            tilesToRender.remove(worldPoint);
            totalTilesUsed -= 1;
            stateChanged = true;
        }

        // do updates only if state changes to prevent updates when unchanged
        if (stateChanged)
        {
            writeTiles(regionId, tiles, plane);
        }

        Duration d = Duration.between(startTime, Instant.now());
        log.debug("TileManMode updateTileMark - Finish (" + d.toNanos()+ " nanoseconds)");
    }

    public String getPlayerName() {
        return client.getLocalPlayer().getName();
    }

    int getXpUntilNextTile() {
        return xpUntilNextTile;
    }

    public void sendChatMessage(String message)
    {
        // display the stylised message
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.FRIENDSCHAT)
                .sender("Tileman Mode Plugin")
                .runeLiteFormattedMessage(message)
                .timestamp((int) (System.currentTimeMillis() / 1000))
                .build());
    }

    GroupTilemanDataManager getGroupTilemanDataManager() {
        return groupTilemanDataManager;
    }

    @AllArgsConstructor
    enum MovementFlag {
        BLOCK_MOVEMENT_NORTH_WEST(CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST),
        BLOCK_MOVEMENT_NORTH(CollisionDataFlag.BLOCK_MOVEMENT_NORTH),
        BLOCK_MOVEMENT_NORTH_EAST(CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST),
        BLOCK_MOVEMENT_EAST(CollisionDataFlag.BLOCK_MOVEMENT_EAST),
        BLOCK_MOVEMENT_SOUTH_EAST(CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST),
        BLOCK_MOVEMENT_SOUTH(CollisionDataFlag.BLOCK_MOVEMENT_SOUTH),
        BLOCK_MOVEMENT_SOUTH_WEST(CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST),
        BLOCK_MOVEMENT_WEST(CollisionDataFlag.BLOCK_MOVEMENT_WEST),

        BLOCK_MOVEMENT_OBJECT(CollisionDataFlag.BLOCK_MOVEMENT_OBJECT),
        BLOCK_MOVEMENT_FLOOR_DECORATION(CollisionDataFlag.BLOCK_MOVEMENT_FLOOR_DECORATION),
        BLOCK_MOVEMENT_FLOOR(CollisionDataFlag.BLOCK_MOVEMENT_FLOOR),
        BLOCK_MOVEMENT_FULL(CollisionDataFlag.BLOCK_MOVEMENT_FULL);

        @Getter
        private int flag;

        /**
         * @param collisionData The tile collision flags.
         * @return The set of {@link MovementFlag}s that have been set.
         */
        public static Set<MovementFlag> getSetFlags(int collisionData) {
            return Arrays.stream(values())
                    .filter(movementFlag -> (movementFlag.flag & collisionData) != 0)
                    .collect(Collectors.toSet());
        }
    }

}

/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, Sam Ramirez <https://github.com/sram1337>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.tileman;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.Map;

/***
 * This class handles evaluating the config basedon which game mode is selected, and whether or not the user
 * has selected to customize their game mode.
 */
@Slf4j
class TilemanModeConfigEvaluator implements TilemanModeConfig {

    /***
     * Instead of injecting TilemanModeConfig into TilemanModePlugin, we inject it here and use it to evaluate
     * what the final permissions should be. Then we should instead inject this class into TilemanModePlugin.
     * Because this class also implements TilemanModeConfig, we only need to override the methods we care about ie.
     * the ones controlled by the Game Mode dropdown.
     */
    @Inject
    private TilemanModeConfig config;

    // Tileman Game Mode
    private static final int TILEMAN_TILE_OFFSET = 9;
    private static final boolean TILEMAN_INCLUDE_TOTAL_LEVEL = false;

    // Strict Tileman Game Mode
    private static final int STRICT_TILEMAN_TILE_OFFSET = 0;
    private static final boolean STRICT_TILEMAN_INCLUDE_TOTAL_LEVEL = false;

    // Expeditious Tileman Game Mode
    private static final int EXPEDITIOUS_TILEMAN_TILE_OFFSET = 0;
    private static final boolean EXPEDITIOUS_TILEMAN_INCLUDE_TOTAL_LEVEL = true;

    private static Map<TilemanGameMode, Integer> gameModeToTilesOffsetDefault;
    private static Map<TilemanGameMode, Boolean> gameModeToIncludeTotalLevelDefault;

    static {
        // Load Game Mode defaults for Tiles Offset
        gameModeToTilesOffsetDefault = new HashMap<>();
        gameModeToTilesOffsetDefault.put(TilemanGameMode.COMMUNITY, TILEMAN_TILE_OFFSET);
        gameModeToTilesOffsetDefault.put(TilemanGameMode.STRICT, STRICT_TILEMAN_TILE_OFFSET);
        gameModeToTilesOffsetDefault.put(TilemanGameMode.ACCELERATED, EXPEDITIOUS_TILEMAN_TILE_OFFSET);

        // Load Game Mode defaults for Include Total Levels
        gameModeToIncludeTotalLevelDefault = new HashMap<>();
        gameModeToIncludeTotalLevelDefault.put(TilemanGameMode.COMMUNITY, TILEMAN_INCLUDE_TOTAL_LEVEL);
        gameModeToIncludeTotalLevelDefault.put(TilemanGameMode.STRICT, STRICT_TILEMAN_INCLUDE_TOTAL_LEVEL);
        gameModeToIncludeTotalLevelDefault.put(TilemanGameMode.ACCELERATED, EXPEDITIOUS_TILEMAN_INCLUDE_TOTAL_LEVEL);
    }

    @Override
    public int tilesOffset() {
        if (config.enableCustomGameMode()) {
            return config.tilesOffset();
        } else {
            return gameModeToTilesOffsetDefault.get(config.gameMode());
        }
    }

    @Override
    public boolean includeTotalLevel() {
        if (config.enableCustomGameMode()) {
            return config.includeTotalLevel();
        } else {
            return gameModeToIncludeTotalLevelDefault.get(config.gameMode());
        }
    }

    @Override
    public int expPerTile() {
        if (config.enableCustomGameMode()) {
            return config.expPerTile();
        } else {
            return 1000;
        }
    }

    @Override
    public boolean excludeExp() {
        if(config.enableCustomGameMode()) {
            return config.excludeExp();
        } else {
            return false;
        }
    }

    @Override
    public boolean automarkTiles() {
        return config.automarkTiles();
    }

    @Override
    public boolean allowTileDeficit() {
        return config.allowTileDeficit();
    }
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, ConorLeckey <https://github.com/ConorLeckey>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tileman;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;

import javax.inject.Inject;
import java.awt.*;
import java.util.Collection;

public class TilemanModeOverlay extends Overlay
{
	private static final int MAX_DRAW_DISTANCE = 32;

	private final Client client;
	private final TilemanModePlugin plugin;

	@Inject
	private TilemanModeConfig config;

	@Inject
	private TilemanModeOverlay(Client client, TilemanModeConfig config, TilemanModePlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// If players plane changes (or has never been set) refresh the tile list to render
		// We trigger it here in the render thread to avoid a ConcurrentModificationException of the tilesToRender collection.
		if (plugin.lastPlane != client.getPlane()){
			plugin.updateTilesToRender();
			plugin.lastPlane = client.getPlane();
		}

		// draw group tileman data first so that player centric rendering draws on top of them
		final Collection<WorldPoint> groupPoints = plugin.getGroupTilesToRender();
		for (final WorldPoint point : groupPoints)
		{
			if (point.getPlane() != client.getPlane())
			{
				continue;
			}
			temporaryDrawImportedTile(graphics, point);
		}

		// draw player tiles
		final Collection<WorldPoint> points = plugin.getTilesToRender();
		for (final WorldPoint point : points)
		{
			if (point.getPlane() != client.getPlane())
			{
				continue;
			}

			drawTile(graphics, point);
		}

		return null;
	}

	private void temporaryDrawImportedTile(Graphics2D graphics, WorldPoint point)
	{
		// This method is temporary to avoid touching the changed rendering logic in drawTile when
		// integrating with the wayfinding code.

		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
		if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
		{
			return;
		}
		LocalPoint lp = LocalPoint.fromWorld(client, point);
		if (lp == null)
		{
			return;
		}
		Polygon poly = Perspective.getCanvasTilePoly(client, lp);
		if (poly == null)
		{
			return;
		}
		OverlayUtil.renderPolygon(graphics, poly, Color.PINK);
	}

	private void drawTile(Graphics2D graphics, WorldPoint point)
	{
		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

		if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
		{
			return;
		}

		LocalPoint lp = LocalPoint.fromWorld(client, point);
		if (lp == null)
		{
			return;
		}

		Polygon poly = Perspective.getCanvasTilePoly(client, lp);
		if (poly == null)
		{
			return;
		}

		OverlayUtil.renderPolygon(graphics, poly, getTileColor());
	}

	private Color getTileColor() {
		if(config.enableTileWarnings()) {
			if (plugin.getRemainingTiles() <= 0) {
				return Color.RED;
			} else if (plugin.getRemainingTiles() <= config.warningLimit()) {
				return new Color(255, 153, 0);
			}
		}
		return config.markerColor();
	}
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tileman;

import lombok.Value;

/**
 * Used for serialization of ground marker points.
 */
@Value
class TilemanModeTile
{
	private int regionId;
	private int regionX;
	private int regionY;
	private int z;
}

/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, ConorLeckey <https://github.com/ConorLeckey>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tileman;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;
import java.awt.*;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

class TileInfoOverlay extends OverlayPanel {
    private final TilemanModeConfig config;
    private final TilemanModePlugin plugin;

    private final static String UNSPENT_TILES_STRING = "Available Tiles:";
    private final static String XP_UNTIL_NEXT_TILE = "XP Until Next Tile:";
    private final static String UNLOCKED_TILES = "Tiles Unlocked:";
    private final static String[] STRINGS = new String[] {
        UNSPENT_TILES_STRING,
        XP_UNTIL_NEXT_TILE,
        UNLOCKED_TILES,
    };

    @Inject
    private TileInfoOverlay(TilemanModeConfig config, TilemanModePlugin plugin) {
        super(plugin);
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_LEFT);
        setPriority(Overlay.PRIORITY_MED);
        getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Tileman Mode overlay"));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        String unspentTiles = addCommasToNumber(plugin.getRemainingTiles());
        String unlockedTiles = addCommasToNumber(plugin.getTotalTiles());
        String xpUntilNextTile = addCommasToNumber(plugin.getXpUntilNextTile());

        panelComponent.getChildren().add(LineComponent.builder()
                .left(UNSPENT_TILES_STRING)
                .leftColor(getTextColor())
                .right(unspentTiles)
                .rightColor(getTextColor())
                .build());

        if(!(config.enableCustomGameMode() && config.excludeExp())) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(XP_UNTIL_NEXT_TILE)
                    .right(xpUntilNextTile)
                    .build());
        }

        panelComponent.getChildren().add(LineComponent.builder()
                .left(UNLOCKED_TILES)
                .right(unlockedTiles)
                .build());

        panelComponent.setPreferredSize(new Dimension(
                getLongestStringWidth(STRINGS, graphics)
                        + getLongestStringWidth(new String[] {unlockedTiles, unspentTiles}, graphics),
                0));

        return super.render(graphics);
    }

    private Color getTextColor() {
        if(config.enableTileWarnings()) {
            if (plugin.getRemainingTiles() <= 0) {
                return Color.RED;
            } else if (plugin.getRemainingTiles() <= config.warningLimit()) {
                return Color.ORANGE;
            }
        }
        return Color.WHITE;
    }

    private int getLongestStringWidth(String[] strings, Graphics2D graphics) {
        int longest = graphics.getFontMetrics().stringWidth("000000");
        for(String i: strings) {
            int currentItemWidth = graphics.getFontMetrics().stringWidth(i);
            if(currentItemWidth > longest) {
                longest = currentItemWidth;
            }
        }
        return longest;
    }

    private String addCommasToNumber(int number) {
        String input = Integer.toString(number);
        StringBuilder output = new StringBuilder();
        for(int x = input.length() - 1; x >= 0; x--) {
            int lastPosition = input.length() - x - 1;
            if(lastPosition != 0 && lastPosition % 3 == 0) {
                output.append(",");
            }
            output.append(input.charAt(x));
        }
        return output.reverse().toString();
    }
}

/*
 * Copyright (c) 2019, Benjamin <https://github.com/genetic-soybean>
 * Copyright (c) 2020, ConorLeckey <https://github.com/ConorLeckey>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tileman;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;

import javax.inject.Inject;
import java.awt.*;
import java.util.Collection;

class TilemanModeMinimapOverlay extends Overlay
{
	private static final int MAX_DRAW_DISTANCE = 16;
	private static final int TILE_WIDTH = 4;
	private static final int TILE_HEIGHT = 4;

	private final Client client;
	private final TilemanModeConfig config;
	private final TilemanModePlugin plugin;

	@Inject
	private TilemanModeMinimapOverlay(Client client, TilemanModeConfig config, TilemanModePlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.drawTilesOnMinimap())
		{
			return null;
		}

		// draw group tileman data first so that player data overlaps it.
		final Collection<WorldPoint> groupPoints = plugin.getGroupTilesToRender();
		for (final WorldPoint point : groupPoints)
		{
			WorldPoint worldPoint = point;
			if (worldPoint.getPlane() != client.getPlane())
			{
				continue;
			}

			drawOnMinimap(graphics, worldPoint, Color.PINK);
		}

		final Collection<WorldPoint> points = plugin.getTilesToRender();
		for (final WorldPoint point : points)
		{
			WorldPoint worldPoint = point;
			if (worldPoint.getPlane() != client.getPlane())
			{
				continue;
			}

			drawOnMinimap(graphics, worldPoint, getTileColor());
		}

		return null;
	}

	private void drawOnMinimap(Graphics2D graphics, WorldPoint point, Color color)
	{
		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

		if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
		{
			return;
		}

		LocalPoint lp = LocalPoint.fromWorld(client, point);
		if (lp == null)
		{
			return;
		}

		Point posOnMinimap = Perspective.localToMinimap(client, lp);
		if (posOnMinimap == null)
		{
			return;
		}

		OverlayUtil.renderMinimapRect(client, graphics, posOnMinimap, TILE_WIDTH, TILE_HEIGHT, color);
	}

	private Color getTileColor() {
		if(config.enableTileWarnings()) {
			if (plugin.getRemainingTiles() <= 0) {
				return Color.RED;
			} else if (plugin.getRemainingTiles() <= config.warningLimit()) {
				return new Color(255, 153, 0);
			}
		}
		return config.markerColor();
	}
}

/*
 * Copyright (c) 2018, TheLonelyDev <https://github.com/TheLonelyDev>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, ConorLeckey <https://github.com/ConorLeckey>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.tileman;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("tilemanMode")
public interface TilemanModeConfig extends Config {
    @ConfigSection(
            name = "Game Mode",
            description = "Select your Tileman game mode'",
            position = 1
    )
    String gameModeSection = "gameMode";

    @ConfigSection(
            name = "Settings",
            description = "Settings'",
            position = 2
    )
    String settingsSection = "settings";

    @ConfigSection(
            name = "Custom Game Mode",
            description = "Create a custom Tileman game mode. Be sure to 'Enable Custom Game Mode'",
            position = 99,
            closedByDefault = true
    )
    String customGameModeSection = "customGameMode";

    public enum TilemanGameMode {
        COMMUNITY,
        STRICT,
        ACCELERATED
    }

    @Alpha
    @ConfigItem(
            keyName = "gameMode",
            name = "Game Mode",
            section = gameModeSection,
            description = "Select your Tileman game mode",
            position = 1
    )
    default TilemanGameMode gameMode() {
        return TilemanGameMode.COMMUNITY;
    }

    @ConfigItem(
            keyName = "automarkTiles",
            name = "Auto-mark tiles",
            section = settingsSection,
            description = "Automatically mark tiles as you walk.",
            position = 2
    )
    default boolean automarkTiles() {
        return false;
    }

    @Range(
            min = Integer.MIN_VALUE
    )
    @ConfigItem(
            keyName = "warningLimit",
            name = "Unspent tiles warning",
            section = settingsSection,
            description = "Highlights overlay when limit reached",
            position = 3
    )
    default int warningLimit() {
        return 20;
    }

    @ConfigItem(
            keyName = "enableTilesWarning",
            name = "Enable Tiles Warning",
            section = settingsSection,
            description = "Turns on tile warnings when you reach your set limit or 0.",
            position = 4
    )
    default boolean enableTileWarnings() {
        return false;
    }

    @ConfigItem(
            keyName = "allowTileDeficit",
            name = "Allow Tile Deficit",
            section = settingsSection,
            description = "Allows you to place tiles after you have none left.",
            position = 5
    )
    default boolean allowTileDeficit() {
        return false;
    }

    @ConfigItem(
            keyName = "drawOnMinimap",
            name = "Draw tiles on minimap",
            section = settingsSection,
            description = "Configures whether marked tiles should be drawn on minimap",
            position = 6
    )
    default boolean drawTilesOnMinimap() {
        return false;
    }

    @ConfigItem(
            keyName = "drawTilesOnWorldMap",
            name = "Draw tiles on world map",
            section = settingsSection,
            description = "Configures whether marked tiles should be drawn on world map",
            position = 5
    )
    default boolean drawTilesOnWorldMap() {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "markerColor",
            name = "Tile Color",
            section = settingsSection,
            description = "Configures the color of the tiles",
            position = 6
    )
    default Color markerColor() {
        return Color.YELLOW;
    }

    /***   Custom Game Mode section   ***/
    @ConfigItem(
            keyName = "enableCustomGameMode",
            name = "Enable Custom Game Mode",
            description = "Settings below will override Game Mode defaults",
            section = customGameModeSection,
            position = 1
    )
    default boolean enableCustomGameMode() {
        return false;
    }

    @Range(
            min = Integer.MIN_VALUE
    )
    @ConfigItem(
            keyName = "tilesOffset",
            name = "Bonus tiles",
            description = "Add more tiles to your limit, set to 0 for off",
            section = customGameModeSection,
            position = 2
    )
    default int tilesOffset() {
        return 9;
    }

    @ConfigItem(
            keyName = "includeTotalLevels",
            name = "Include total level",
            description = "Includes total level in usable tiles",
            section = customGameModeSection,
            position = 3
    )
    default boolean includeTotalLevel() {
        return false;
    }

    @ConfigItem(
            keyName = "excludeExp",
            name = "Exclude Experience",
            description = "Includes experience / 1000 in usable tiles",
            section = customGameModeSection,
            position = 4
    )
    default boolean excludeExp() {
        return false;
    }

    @Range(
            min = 500
    )
    @ConfigItem(
            keyName = "expPerTile",
            name = "Exp per Tile",
            description = "Determines how much exp you require per tile",
            section = customGameModeSection,
            position = 5
    )
    default int expPerTile() {
        return 1000;
    }
}

package com.tileman;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TilemanModePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TilemanModePlugin.class);
		RuneLite.main(args);
	}
}
