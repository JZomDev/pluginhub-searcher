package com.liteutilities;

import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.game.ItemManager;

import java.awt.*;
import java.awt.image.BufferedImage;

@Slf4j
public class ItemHighlightOverlay extends WidgetItemOverlay
{
	private final LiteUtilitiesPlugin plugin;
	private final ItemManager itemManager;

	@Inject
	private ItemHighlightOverlay(LiteUtilitiesPlugin plugin, ItemManager itemManager)
	{
		this.plugin = plugin;
		this.itemManager = itemManager;

		showOnEquipment();
		showOnInventory();
		showOnBank();
	}

	private long itemPrice(int itemId)
	{
		ItemComposition itemDef = itemManager.getItemComposition(itemId);
		long maxPrice = 0;
		int gePrice = itemManager.getItemPrice(itemId);
		int haPrice = itemDef.getHaPrice();

		if (plugin.getPriceType() == LiteUtilsPriceTypes.GRAND_EXCHANGE)
		{
			maxPrice = Math.max(maxPrice, gePrice);
		}
		else if (plugin.getPriceType() == LiteUtilsPriceTypes.HIGH_ALCHEMY)
		{
			maxPrice = Math.max(maxPrice, haPrice);
		}

		return maxPrice;
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem itemWidget)
	{
		long price = itemPrice(itemId);
		price *= itemWidget.getQuantity();

		final Color color = plugin.getRarityColor(price);

		if (color == null || color.getAlpha() == 0)
		{
			return;
		}

		Rectangle bounds = itemWidget.getCanvasBounds();
		final BufferedImage outline = itemManager.getItemOutline(itemId, itemWidget.getQuantity(), color);
		graphics.drawImage(outline, (int)bounds.getX(), (int)bounds.getY(), null);
	}
}

package com.liteutilities;

import java.awt.Color;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup(LiteUtilsConfig.GROUP)
public interface LiteUtilsConfig extends Config
{
	String GROUP = "inventorytotal";

	@ConfigSection(
		name = "Hotkeys",
		description = "Hotkey settings.",
		position = 1,
		closedByDefault = true
	)
	String HotKeySection = "HotKeySettings";

	@ConfigSection(
		name = "Advanced Settings",
		description = "Extra settings.",
		position = 2,
		closedByDefault = true
	)
	String AdvancedSection = "AdvancedSettings";

	@ConfigSection(
		name = "Container",
		description = "Container settings.",
		position = 3,
		closedByDefault = true
	)
	String ContainerSection = "ContainerSettings";

	@ConfigSection(
		position = 4,
		name = "Item Highlights",
		description = "Adjust the highlight color and value",
		closedByDefault = true
	)
	String highlightSection = "highlightSection";

	@ConfigItem(
			position = 0,
			keyName = "itemPricesSetting",
			name = "GP Source",
			description = "Configures the price unit between G.E and H.A."
	)
	default LiteUtilsPriceTypes priceType()
	{
		return LiteUtilsPriceTypes.GRAND_EXCHANGE;
	}

	@ConfigItem(
			position = 0,
			keyName = "enableProfitLossSetting",
			name = "Show Profit/Loss",
			description = "When enabled, displays profits on the counter."
	)
	default boolean enableProfitLoss()
	{
		return false;
	}

	@ConfigItem(
			position = 0,
			keyName = "showExactGpSetting",
			name = "Show True GP Value",
			description = "Configures whether or not the exact gp value is visible."
	)
	default boolean showExactGp()
	{
		return false;
	}

	@ConfigItem(
			keyName = "overlayEnabled",
			name = "Show Item Highlight",
			description = "Toggles whether the Item highlight is enabled or not. (Inventory & Bank)",
			position = 0
	)
	default boolean overlayEnabled() {
		return false;
	}

	@ConfigItem(
			position = 0,
			keyName = "profitLossToggleSetting",
			name = "Toggle Profit/Loss",
			description = "Switch between Total & Profit / Loss display.",
			section = HotKeySection
	)
	default Keybind profitLossToggleKey()
	{
		return new Keybind(KeyEvent.VK_V, InputEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			position = 1,
			keyName = "resetProfitsSetting",
			name = "Reset Profits",
			description = "Resets the current profits and losses.",
			section = HotKeySection
	)
	default Keybind newRunKey()
	{
		return new Keybind(KeyEvent.VK_R, InputEvent.CTRL_DOWN_MASK);
	}

	@Alpha
	@ConfigItem(
			position = 1,
			keyName = "normalBackgroundColorSetting",
			name = "Background (Total)",
			description = "Configures the background color.",
			section = ContainerSection
	)
	default Color totalColor()
	{
		return new Color(17,17,17,225);
	}

	@Alpha
	@ConfigItem(
			position = 2,
			keyName = "profitBackgroundColorSetting",
			name = "Background (Profit)",
			description = "Configures profit background color.",
			section = ContainerSection
	)
	default Color profitColor()
	{
		return new Color(17,17,17,225);
	}

	@Alpha
	@ConfigItem(
			position = 4,
			keyName = "lossBackgroundColorSetting",
			name = "Background (Loss)",
			description = "Configures loss background color.",
			section = ContainerSection
	)
	default Color lossColor()
	{
		return new Color(17,17,17,225);
	}

	@ConfigItem(
			position = 0,
			keyName = "showContainerSetting",
			name = "Show Container",
			description = "Enable/Disable container.",
			section = ContainerSection
	)
	default boolean showContainer()
	{
		return false;
	}

	@ConfigItem(
			position = 5,
			keyName = "resetUponBankingSetting",
			name = "Auto-Reset Profits (Banking)",
			description = "Resets the profits/losses after banking.",
			section = AdvancedSection
	)
	default boolean newRunAfterBanking()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "lowValueColor",
		name = "Low Value",
		description = "Configures the color for low value items.",
		section = highlightSection,
		position = 1
	)
	default Color lowValueColor()
	{
		return new Color(101, 255, 141, 110);
	}

	@ConfigItem(
		keyName = "lowValuePrice",
		name = "",
		description = "Configures the start price for low value items.",
		section = highlightSection,
		position = 2
	)
	default int lowValuePrice()
	{
		return 10000;
	}

	@Alpha
	@ConfigItem(
		keyName = "mediumValueColor",
		name = "Medium Value",
		description = "Configures the color for medium value items.",
		section = highlightSection,
		position = 3
	)
	default Color mediumValueColor()
	{
		return new Color(0, 255, 250, 114);
	}

	@ConfigItem(
		keyName = "mediumValuePrice",
		name = "",
		description = "Configures the start price for medium value items.",
		section = highlightSection,
		position = 4
	)
	default int mediumValuePrice()
	{
		return 100000;
	}

	@Alpha
	@ConfigItem(
		keyName = "highValueColor",
		name = "High Value",
		description = "Configures the color for high value items.",
		section = highlightSection,
		position = 5
	)
	default Color highValueColor()
	{
		return new Color(255, 150, 0, 162);
	}

	@ConfigItem(
		keyName = "highValuePrice",
		name = "",
		description = "Configures the start price for high value items.",
		section = highlightSection,
		position = 6
	)
	default int highValuePrice()
	{
		return 1000000;
	}

	@Alpha
	@ConfigItem(
		keyName = "insaneValueColor",
		name = "Insane Value",
		description = "Configures the color for insane value items.",
		section = highlightSection,
		position = 7
	)
	default Color insaneValueColor()
	{
		return new Color(255, 0, 0, 167);
	}

	@ConfigItem(
		keyName = "insaneValuePrice",
		name = "",
		description = "Configures the start price for insane value items.",
		section = highlightSection,
		position = 8
	)
	default int insaneValuePrice()
	{
		return 10000000;
	}

	@ConfigItem(
			position = 5,
			keyName = "excludedItemsSetting",
			name = "Excluded Items",
			description = "Do not add these items to value calculation."
	)
	default String ignoredItems()
	{
		return "Cannon barrels, Cannon base, Cannon furnace, Cannon stand";
	}

}

package com.liteutilities;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.time.Instant;
import java.util.Arrays;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.inject.Inject;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

class LiteUtilsOverlay extends Overlay
{
	private static final int TEXT_Y_OFFSET = 17;
	private static final int HORIZONTAL_PADDING = 10;
	private static final int BANK_CLOSE_DELAY = 0;
	private static final Color TOOLTIP_BACKGROUND_COLOR = new Color(17, 17, 17, 225);

	private final Client client;
	private final LiteUtilitiesPlugin plugin;
	private final LiteUtilsConfig config;

	private final ItemManager itemManager;

	private Widget inventoryWidget;
	@Getter
	private ItemContainer inventoryItemContainer;
	@Getter
	private ItemContainer equipmentItemContainer;

	private boolean onceBank = false;

	private boolean showInterstitial = false;

	private boolean postNewRun = false;
	private long newRunTime = 0;

	private int invX = -1;
	private int invY = -1;
	private int invW = -1;

	private int canvasX = 0;
	private int canvasY = 0;
	private int canvasWidth = 0;
	private int canvasHeight = 0;

	int xOffset = 0;
	int yOffset = 0;

	private static final Map<ViewportModus, int[]> VIEWPORT_OFFSETS = new EnumMap<>(ViewportModus.class);
	static {
		VIEWPORT_OFFSETS.put(ViewportModus.RESIZED_BOX, new int[] { 26, 36 });
		VIEWPORT_OFFSETS.put(ViewportModus.RESIZED_BOTTOM, new int[] { 11, 5 });
		VIEWPORT_OFFSETS.put(ViewportModus.FIXED, new int[] { -216, -134 });
		VIEWPORT_OFFSETS.put(ViewportModus.FIXED_BANK, new int[] { 26, 36 });
	}

	@Inject
	private LiteUtilsOverlay(Client client, LiteUtilitiesPlugin plugin, LiteUtilsConfig config, ItemManager itemManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);

		this.client = client;
		this.plugin = plugin;
		this.config = config;

		this.itemManager = itemManager;
	}

	private ViewportModus currentViewportModus = null;

	private void updateOffsets(Widget viewportWidget) {
		ViewportModus newViewportModus = null;
		for (ViewportModus mode : ViewportModus.values()) {
			if (viewportWidget.getId() == mode.getViewport()) {
				newViewportModus = mode;
				break;
			}
		}

		if (newViewportModus != currentViewportModus) {
			currentViewportModus = newViewportModus;
			int[] offsets = VIEWPORT_OFFSETS.get(currentViewportModus);
			if (offsets != null) {
				xOffset = offsets[0];
				yOffset = offsets[1];
			} else {
				xOffset = 0;
				yOffset = 0;
			}
		}
	}

	private Widget getViewportWidget() {
		for (ViewportModus mode : ViewportModus.values()) {
			Widget widget = client.getWidget(mode.getViewport());
			if (widget != null && !widget.isHidden()) {
				return widget;
			}
		}
		return null;
	}

	void updatePluginState()
	{
		inventoryWidget = client.getWidget(ComponentID.INVENTORY_CONTAINER);
		inventoryItemContainer = client.getItemContainer(InventoryID.INVENTORY);
		equipmentItemContainer = client.getItemContainer(InventoryID.EQUIPMENT);

		if (plugin.getPLToggleOverride() == null)
		{
			if (config.enableProfitLoss())
			{
				plugin.setMode(LiteUtilsModes.PROFIT_LOSS);
			}
			else
			{
				plugin.setMode(LiteUtilsModes.TOTAL);
			}
		}
		else if (plugin.getPLToggleOverride() == LiteUtilsModes.PROFIT_LOSS)
		{
			plugin.setMode(LiteUtilsModes.PROFIT_LOSS);
		}
		else if (plugin.getPLToggleOverride() == LiteUtilsModes.TOTAL)
		{
			plugin.setMode(LiteUtilsModes.TOTAL);
		}

		boolean isBank = false;

		if (inventoryWidget == null || inventoryWidget.getCanvasLocation().getX() < 0 || inventoryWidget.isHidden())
		{
			Widget[] altInventoryWidgets = new Widget[]
				{
				client.getWidget(ComponentID.BANK_INVENTORY_ITEM_CONTAINER),
				client.getWidget(ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER)
			};

			for (Widget altInventoryWidget : altInventoryWidgets)
			{
				inventoryWidget = altInventoryWidget;
				if (inventoryWidget != null && !inventoryWidget.isHidden())
				{
					isBank = true;
					if (!onceBank)
					{
						onceBank = true;
					}
					break;
				}
			}
		}

		if (isBank)
		{
			plugin.setState(LiteUtilsState.BANK);
		}
		else
		{
			plugin.setState(LiteUtilsState.RUN);
		}

		boolean newRun = (plugin.getPreviousState() == LiteUtilsState.BANK
			&& plugin.getState() == LiteUtilsState.RUN
			&& config.newRunAfterBanking()) || plugin.isManualNewRun();
		plugin.getRunData().itemQtys.clear();

		long[] inventoryTotals = plugin.getInventoryTotals(false);
		long[] equipmentTotals = plugin.getEquipmentTotals(false);

		if (inventoryTotals.length >= LiteUtilitiesPlugin.TOTAL_QTY_INDEX + 1)
		{
			long inventoryTotal = inventoryTotals[LiteUtilitiesPlugin.TOTAL_GP_GE_INDEX];
			long inventoryTotalHA = inventoryTotals[LiteUtilitiesPlugin.TOTAL_GP_HA_INDEX];
			long inventoryQty = inventoryTotals[LiteUtilitiesPlugin.TOTAL_QTY_INDEX];

			long totalGp = 0;
			if (config.priceType() == LiteUtilsPriceTypes.GRAND_EXCHANGE)
			{
				totalGp += inventoryTotal;
			}
			else
			{
				totalGp += inventoryTotalHA;
			}

			if (equipmentTotals.length >= 2)
			{
				long equipmentTotal = equipmentTotals[0];
				long equipmentTotalHA = equipmentTotals[1];

				if ((plugin.getState() == LiteUtilsState.RUN || !config.newRunAfterBanking())
					&& plugin.getMode() == LiteUtilsModes.PROFIT_LOSS)
				{
					if (config.priceType() == LiteUtilsPriceTypes.GRAND_EXCHANGE)
					{
						totalGp += equipmentTotal;
					}
					else
					{
						totalGp += equipmentTotalHA;
					}
				}
			}

			plugin.setTotalGp(totalGp);
			plugin.setTotalQty(inventoryQty);
		}
		else
		{
			plugin.setTotalGp(0);
			plugin.setTotalQty(0);
		}

		if (newRun)
		{
			plugin.onNewRun();
			postNewRun = true;
			newRunTime = Instant.now().toEpochMilli();
		}
		else if (plugin.getPreviousState() == LiteUtilsState.RUN && plugin.getState() == LiteUtilsState.BANK)
		{
			plugin.onBank();
		}

		if (postNewRun && (Instant.now().toEpochMilli() - newRunTime) > BANK_CLOSE_DELAY)
		{
			plugin.postNewRun();
			postNewRun = false;
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		updatePluginState();

		Widget depositBox = client.getWidget(ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER);
		Widget viewportWidget = getViewportWidget();

		if (viewportWidget == null || (depositBox != null && depositBox.isHidden()))
		{
			return null;
		}

		updateOffsets(viewportWidget);

		net.runelite.api.Point viewportCanvasLocation = viewportWidget.getCanvasLocation();
		if (viewportCanvasLocation == null)
		{
			return null;
		}

		canvasX = viewportCanvasLocation.getX();
		canvasY = viewportCanvasLocation.getY();
		canvasWidth = viewportWidget.getWidth() + 28;
		canvasHeight = viewportWidget.getHeight() + 41;

		int invH;
		if (inventoryWidget != null)
		{
			net.runelite.api.Point invCanvasLocation = inventoryWidget.getCanvasLocation();
			if (invCanvasLocation != null)
			{
				invX = invCanvasLocation.getX();
				invY = invCanvasLocation.getY();
				invW = inventoryWidget.getWidth();
				invH = inventoryWidget.getHeight();
			}
			else
			{
				return null;
			}
		}
		else
		{
			return null;
		}

		if (invX < 0 || invY < 0 || invW < 0 || invH < 0)
		{
			return null;
		}

		if (inventoryWidget.isHidden())
		{
			return null;
		}

		int height = 20;

		if (plugin == null)
		{
			return null;
		}

		long total = plugin.getProfitGp();
		String totalText = getTotalText(total);


		if (showInterstitial)
		{
			total = 0;
			if (plugin.getMode() == LiteUtilsModes.PROFIT_LOSS)
			{
				totalText = "0";
			}
			else
			{
				totalText = getTotalText(plugin.getProfitGp());
			}
		}

		renderTotal(config, graphics, plugin,
			plugin.getTotalQty(), total, totalText, height);

		return null;
	}

	private void renderTotal(LiteUtilsConfig config, Graphics2D graphics, LiteUtilitiesPlugin plugin,
							 long totalQty, long total, String totalText,
							 int height)
	{
		if (plugin.getMode() == LiteUtilsModes.PROFIT_LOSS)
		{
			long profitGp = plugin.getProfitGp();
			totalText = profitGp > 0 ? ('+' + totalText) : totalText;
		}

		int imageSize = 15;
		int numCoins;
		if (total > Integer.MAX_VALUE)
		{
			numCoins = Integer.MAX_VALUE;
		}
		else if (total < Integer.MIN_VALUE)
		{
			numCoins = Integer.MIN_VALUE;
		}
		else
		{
			numCoins = (int) total;
			if (numCoins == 0)
			{
				numCoins = 1000000;
			}
		}
		numCoins = Math.abs(numCoins);

		if (totalQty == 0)
		{
			return;
		}

		graphics.setFont(FontManager.getRunescapeSmallFont());
		final int totalWidth = graphics.getFontMetrics().stringWidth(totalText);

		int imageWidthWithPadding;

		imageWidthWithPadding = imageSize + 3;

		int width = totalWidth + imageWidthWithPadding + HORIZONTAL_PADDING * 2;

		int x = invX + invW - width;

		x += xOffset;
		int y = invY - height - yOffset;

		Color backgroundColor;
		Color borderColor;
		Color textColor;

		if (numCoins >= 1_000_000_000)
		{
			textColor = new Color(0x6698FF);
		}
		else if (numCoins >= 10_000_000)
		{
			textColor = new Color(0x00FF80);
		}
		else if (numCoins >= 100_000)
		{
			textColor = new Color(0xFFFFFF);
		}
		else if (numCoins > 0)
		{
			textColor = new Color(0xFFFF00);
		}
		else
		{
			textColor = new Color(0xFF0000);
		}

		if ((plugin.getState() == LiteUtilsState.BANK && config.newRunAfterBanking())
			|| plugin.getMode() == LiteUtilsModes.TOTAL)
		{
			backgroundColor = config.totalColor();
			borderColor = new Color(textColor.getRed(), textColor.getGreen(), textColor.getBlue(), 125);
		}
		else if (total > 0)
		{
			backgroundColor = config.profitColor();
			borderColor = new Color(0,255,0,125);
			textColor = new Color(0,255,0,255);
		}
		else
		{
			backgroundColor = config.lossColor();
			borderColor = new Color(255,0,0,125);
			textColor = new Color(255,0,0,255);
		}

		int cornerRadius = 0;

		int containerAlpha = backgroundColor.getAlpha();

		if (config.showContainer())
		{
			if (containerAlpha > 0)
			{
				graphics.setColor(borderColor);
				graphics.drawRoundRect(x + 1, y, width - 7, height - 2, cornerRadius, cornerRadius);

				graphics.setColor(backgroundColor);

				graphics.fillRoundRect(x + 2, y + 1, width - 8, height - 3, cornerRadius, cornerRadius);
			}
		}

		TextComponent textComponent = new TextComponent();

		textComponent.setColor(textColor);
		textComponent.setText(totalText);
		textComponent.setPosition(new Point(x + HORIZONTAL_PADDING, y + TEXT_Y_OFFSET - 1));
		textComponent.render(graphics);

		int imageOffset = 4;
		BufferedImage coinsImage = itemManager.getImage(ItemID.COINS_995, numCoins, false);

		BufferedImage resizedImage = new BufferedImage(imageSize, imageSize, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g2d = resizedImage.createGraphics();

		g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
		g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		g2d.drawImage(coinsImage, 0, 0, imageSize, imageSize, null);
		g2d.dispose();

		int coinImageX = (x + width) - HORIZONTAL_PADDING - imageSize + imageOffset;
		int coinImageY = y + 2;

		graphics.drawImage(resizedImage, coinImageX, coinImageY, null);

		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX();
		int mouseY = mouse.getY();

		Rectangle coinImageBounds = new Rectangle(coinImageX, coinImageY, imageSize, imageSize);

		if (coinImageBounds.contains(mouseX, mouseY) &&
			(plugin.getState() != LiteUtilsState.BANK || !config.newRunAfterBanking()) &&
			(Instant.now().toEpochMilli() - newRunTime) > (BANK_CLOSE_DELAY))
		{
			renderUnifiedLedger(graphics);
		}
	}

	private BufferedImage getScaledItemImage(long itemId)
	{
		BufferedImage itemImage;

		if (itemId == ItemID.COINS_995)
		{
			int xCoins = 0;

			if (inventoryItemContainer != null)
			{
				for (Item item : inventoryItemContainer.getItems())
				{
					if (item.getId() == ItemID.COINS_995)
					{
						xCoins += item.getQuantity();
					}
				}
			}
			itemImage = itemManager.getImage(ItemID.COINS_995, Math.abs(xCoins), false);
		}
		else
		{
			itemImage = itemManager.getImage((int) itemId);
		}

		if (itemImage == null)
		{
			return null;
		}

		int targetWidth = 12;

		BufferedImage resizedImage = new BufferedImage(targetWidth, 12, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g2d = resizedImage.createGraphics();

		g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
		g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
		g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		g2d.drawImage(itemImage, 0, 0, targetWidth, 12, null);
		g2d.dispose();

		return resizedImage;
	}

	private String formatPrice(long value)
	{
		if (config.showExactGp())
		{
			return NumberFormat.getInstance(Locale.ENGLISH).format(value);
		}
		else
		{
			return getFormattedGp(value);
		}
	}

	private void renderUnifiedLedger(Graphics2D graphics)
	{
		FontMetrics fontMetrics = graphics.getFontMetrics();

		List<LiteUtilsTooltipItem> inventoryLedger = plugin.getInventoryLedger().stream()
			.filter(item -> item.getQty() != 0)
			.collect(Collectors.toList());

		List<LiteUtilsTooltipItem> profitLossLedger = plugin.getProfitLossLedger().stream()
			.filter(item -> item.getQty() != 0)
			.collect(Collectors.toList());

		List<LiteUtilsTooltipItem> gainsLedger = profitLossLedger.stream()
			.filter(item -> item.getQty() > 0)
			.collect(Collectors.toList());

		List<LiteUtilsTooltipItem> lossesLedger = profitLossLedger.stream()
			.filter(item -> item.getQty() < 0)
			.collect(Collectors.toList());


		List<Long> inventoryItemIds = inventoryLedger.stream()
			.map(LiteUtilsTooltipItem::getItemId)
			.filter(id -> id != -1)
			.distinct()
			.collect(Collectors.toList());

		List<Long> profitLossItemIds = profitLossLedger.stream()
			.map(LiteUtilsTooltipItem::getItemId)
			.filter(id -> id != -1)
			.distinct()
			.collect(Collectors.toList());

		List<Long> allItemIds = Stream.concat(inventoryItemIds.stream(), profitLossItemIds.stream())
			.distinct()
			.collect(Collectors.toList()); // FOR FUTURE REFERENCING

		if (inventoryLedger.isEmpty() && profitLossLedger.isEmpty())
		{
			return;
		}

		inventoryLedger = inventoryLedger.stream()
			.sorted(Comparator.comparingLong(o -> -(o.getQty() * o.getAmount())))
			.collect(Collectors.toList());

		java.util.List<LiteUtilsTooltipItem> gain = profitLossLedger.stream()
			.filter(item -> item.getQty() > 0)
			.sorted(Comparator.comparingLong(o -> -(o.getQty() * o.getAmount())))
			.collect(Collectors.toList());

		java.util.List<LiteUtilsTooltipItem> loss = profitLossLedger.stream()
			.filter(item -> item.getQty() < 0)
			.sorted(Comparator.comparingLong(o -> (o.getQty() * o.getAmount())))
			.collect(Collectors.toList());

		long totalInventory = inventoryLedger.stream().mapToLong(item -> item.getQty() * item.getAmount()).sum();
		long totalGain = gain.stream().mapToLong(item -> item.getQty() * item.getAmount()).sum();
		long totalLoss = loss.stream().mapToLong(item -> item.getQty() * item.getAmount()).sum();
		long totalProfitLoss = totalGain + totalLoss;

		inventoryLedger.add(new LiteUtilsTooltipItem("Total Worth:", 1, totalInventory, 0));
		gainsLedger.add(new LiteUtilsTooltipItem("Gained:", 1, totalGain, 0));
		lossesLedger.add(new LiteUtilsTooltipItem("Lost:", 1, totalLoss, 0));

		String[] inventoryDescriptions = inventoryLedger.stream()
			.map(this::formatDescription)
			.toArray(String[]::new);

		Long[] inventoryPrices = inventoryLedger.stream()
			.map(item -> item.getQty() * item.getAmount())
			.toArray(Long[]::new);

		String[] profitLossDescriptions = Stream.concat(
			gainsLedger.stream().map(this::formatDescription),
			lossesLedger.stream().map(this::formatDescription)
		).toArray(String[]::new);

		String[] descriptions = Stream.concat(Arrays.stream(inventoryDescriptions), Arrays.stream(profitLossDescriptions))
			.toArray(String[]::new);

		Long[] prices = Stream.concat(Arrays.stream(inventoryPrices),
			Stream.concat(
				gainsLedger.stream().map(item -> item.getQty() * item.getAmount()),
				lossesLedger.stream().map(item -> item.getQty() * item.getAmount())
			)
		).toArray(Long[]::new);

		String[] formattedPrices = new String[prices.length];
		for (int i = 0; i < prices.length; i++)
		{
			long price = prices[i];
			if (i < inventoryLedger.size())
			{
				formattedPrices[i] = formatPrice(Math.abs(price));
			}
			else
			{
				if (price > 0)
				{
					formattedPrices[i] = "+" + formatPrice(price);
				}
				else if (price < 0)
				{
					formattedPrices[i] = formatPrice(price);
				}
				else
				{
					formattedPrices[i] = "0";
				}
			}
		}

		int maxRowWidth = 0;
		for (int i = 0; i < descriptions.length; i++)
		{
			int rowWidth = fontMetrics.stringWidth(descriptions[i]) + fontMetrics.stringWidth(formattedPrices[i]) + HORIZONTAL_PADDING * 2;
			maxRowWidth = Math.max(maxRowWidth, rowWidth);
		}

		net.runelite.api.Point mouse = client.getMouseCanvasPosition();
		int mouseX = mouse.getX();
		int mouseY = mouse.getY();

		int sectionPadding = 5;
		int rowH = fontMetrics.getHeight();

		int totalHeight = (descriptions.length * rowH) + TEXT_Y_OFFSET + sectionPadding + 50;

		int x = mouseX - maxRowWidth - 10;
		int y = mouseY - totalHeight / 2;

		x = Math.max(5, Math.min(x, canvasX + canvasWidth - maxRowWidth - 5));
		y = Math.max(5, Math.min(y, canvasY + canvasHeight - totalHeight - 10));

		Color colorWithAlpha;

		if (totalProfitLoss > 0)
		{
			colorWithAlpha = new Color(0, 255, 0, 75);
		}
		else if (totalProfitLoss < 0)
		{
			colorWithAlpha = new Color(255, 0, 0, 75);
		}
		else
		{
			colorWithAlpha = new Color(255, 255, 0, 75);
		}

		graphics.setColor(TOOLTIP_BACKGROUND_COLOR);
		graphics.fillRoundRect(x, y, maxRowWidth + 12, totalHeight, 0, 0);
		graphics.setColor(colorWithAlpha);
		graphics.setStroke(new BasicStroke(1));
		graphics.drawRoundRect(x, y, maxRowWidth + 12, totalHeight, 0, 0);

		int yOffset = 0;

		for (int i = 0; i < inventoryLedger.size(); i++)
		{
			String desc = inventoryDescriptions[i];
			long price = inventoryPrices[i];

			if (desc.equals("Total Worth:"))
			{
				int textX = x + HORIZONTAL_PADDING / 2 + 2;
				int textY = y + rowH * i + TEXT_Y_OFFSET + 5 + yOffset;

				TextComponent textComponent = new TextComponent();
				textComponent.setColor(new Color(255,215,70,255));
				textComponent.setText(desc);
				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);

				String formattedPrice = formattedPrices[i];
				int textW = fontMetrics.stringWidth(formattedPrice);
				textX = x + maxRowWidth + 12 - HORIZONTAL_PADDING / 2 - textW;

				textComponent.setText(formattedPrice);
				textComponent.setColor(getPriceColor(price));
				textComponent.setPosition(new Point(textX, textY));
				textComponent.render(graphics);

				continue;
			}

			long itemId = inventoryLedger.get(i).getItemId();

			BufferedImage itemImage = getScaledItemImage(itemId);

			assert itemImage != null;
			int imageWidth = itemImage.getWidth();
			int textX = x + HORIZONTAL_PADDING / 2 + imageWidth + 2;
			int textY = y + rowH * i + TEXT_Y_OFFSET + yOffset;

			int imageX = x + HORIZONTAL_PADDING / 2;
			int imageY = textY - fontMetrics.getAscent() + 1;

			graphics.drawImage(itemImage, imageX, imageY - 2, null);

			TextComponent textComponent = new TextComponent();
			textComponent.setColor(getHighlightColor(price));
			textComponent.setText(desc);
			textComponent.setPosition(new Point(textX, textY));
			textComponent.render(graphics);

			String formattedPrice = formattedPrices[i];
			int textW = fontMetrics.stringWidth(formattedPrice);
			textX = x + maxRowWidth + imageWidth - HORIZONTAL_PADDING / 2 - textW;

			textComponent.setText(formattedPrice);
			textComponent.setColor(getPriceColor(price));
			textComponent.setPosition(new Point(textX, textY));
			textComponent.render(graphics);
		}

		int dashedLineY = y + (inventoryLedger.size() * rowH) + TEXT_Y_OFFSET + yOffset;

		float[] dashPattern = {5f, 5f};
		BasicStroke dashedStroke = new BasicStroke(1f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10f, dashPattern, 0f);
		graphics.setStroke(dashedStroke);
		graphics.setColor(colorWithAlpha);

		graphics.drawLine(x + 10, dashedLineY, x + maxRowWidth + 2, dashedLineY);

		int currentY = dashedLineY + rowH + sectionPadding;
		for (LiteUtilsTooltipItem liteUtilsTooltipItem : gainsLedger)
		{
			String desc = formatDescription(liteUtilsTooltipItem);
			long price = liteUtilsTooltipItem.getQty() * liteUtilsTooltipItem.getAmount();

			if (desc.equals("Gained:"))
			{
				currentY += rowH + sectionPadding - 11;
			}

			Color gainColor = Color.GREEN;

			BufferedImage itemImage = null;
			if (!desc.equals("Gained:"))
			{
				long itemId = liteUtilsTooltipItem.getItemId();
				itemImage = getScaledItemImage(itemId);

				if (itemImage != null)
				{
					int imageX = x + HORIZONTAL_PADDING / 2;
					int imageY = currentY - fontMetrics.getAscent() + 1;
					graphics.drawImage(itemImage, imageX, imageY - 2, null);
				}
			}

			int textX = x + HORIZONTAL_PADDING / 2 + (itemImage != null ? itemImage.getWidth() + 2 : 0) + (desc.equals("Gained:") ? 2 : 0);
			int textY = currentY;

			TextComponent textComponent = new TextComponent();
			textComponent.setColor(gainColor);
			textComponent.setText(desc);
			textComponent.setPosition(new Point(textX, textY));
			textComponent.render(graphics);

			String formattedPrice = "+" + formatPrice(price);
			int priceTextX = x + maxRowWidth + 12 - HORIZONTAL_PADDING / 2 - fontMetrics.stringWidth(formattedPrice);
			textComponent.setText(formattedPrice);
			textComponent.setColor(gainColor);
			textComponent.setPosition(new Point(priceTextX, textY));
			textComponent.render(graphics);

			currentY += rowH;
		}

		currentY += sectionPadding - 13;
		graphics.setStroke(dashedStroke);
		graphics.setColor(colorWithAlpha);
		graphics.drawLine(x + 10, currentY, x + maxRowWidth + 2, currentY);

		currentY += rowH + sectionPadding;
		for (LiteUtilsTooltipItem liteUtilsTooltipItem : lossesLedger)
		{
			String desc = formatDescription(liteUtilsTooltipItem);
			long price = liteUtilsTooltipItem.getQty() * liteUtilsTooltipItem.getAmount();

			if (desc.equals("Lost:"))
			{
				currentY += rowH + sectionPadding - 11;
			}

			Color lossColor = Color.RED;

			BufferedImage itemImage = null;
			if (!desc.equals("Lost:"))
			{
				long itemId = liteUtilsTooltipItem.getItemId();
				itemImage = getScaledItemImage(itemId);

				if (itemImage != null)
				{
					int imageX = x + HORIZONTAL_PADDING / 2;
					int imageY = currentY - fontMetrics.getAscent() + 1;
					graphics.drawImage(itemImage, imageX, imageY - 2, null);
				}
			}

			int textX = x + HORIZONTAL_PADDING / 2 + (itemImage != null ? itemImage.getWidth() + 2 : 0) + (desc.equals("Lost:") ? 2 : 0);
			int textY = currentY;

			TextComponent textComponent = new TextComponent();
			textComponent.setColor(lossColor);
			textComponent.setText(desc);
			textComponent.setPosition(new Point(textX, textY));
			textComponent.render(graphics);

			String formattedPrice = formatPrice(price);
			int priceTextX = x + maxRowWidth + 12 - HORIZONTAL_PADDING / 2 - fontMetrics.stringWidth(formattedPrice);
			textComponent.setText(formattedPrice);
			textComponent.setColor(lossColor);
			textComponent.setPosition(new Point(priceTextX, textY));
			textComponent.render(graphics);

			currentY += rowH;
		}

		currentY += sectionPadding - 13;
		graphics.setStroke(dashedStroke);
		graphics.setColor(colorWithAlpha);
		graphics.drawLine(x + 10, currentY, x + maxRowWidth + 2, currentY);

		currentY += sectionPadding + 13;

		String profitDesc;
		if (totalProfitLoss > 0)
		{
			profitDesc = "Earning:";
		}
		else if (totalProfitLoss < 0)
		{
			profitDesc = "Losing:";
		}
		else
		{
			profitDesc = "Break-even:";
		}

		String formattedProfit = (totalProfitLoss > 0 ? "+" : "") + formatPrice(totalProfitLoss);
		Color profitColor;
		if (totalProfitLoss > 0)
		{
			profitColor = Color.GREEN;
		}
		else if (totalProfitLoss < 0)
		{
			profitColor = Color.RED;
		}
		else
		{
			profitColor = Color.YELLOW;
		}

		TextComponent textComponent = new TextComponent();
		textComponent.setColor(profitColor);
		textComponent.setText(profitDesc);
		textComponent.setPosition(new Point(x + HORIZONTAL_PADDING / 2 + 2, currentY));
		textComponent.render(graphics);

		int profitTextX = x + maxRowWidth + 12 - HORIZONTAL_PADDING / 2 - fontMetrics.stringWidth(formattedProfit);
		textComponent.setText(formattedProfit);
		textComponent.setColor(profitColor);
		textComponent.setPosition(new Point(profitTextX, currentY));
		textComponent.render(graphics);
	}

	private String formatDescription(LiteUtilsTooltipItem item)
	{
		String desc = item.getDescription();
		if (item.getQty() != 0 && Math.abs(item.getQty()) != 1
			&& !item.getDescription().contains("Total") && !item.getDescription().contains("Coins"))
		{
			desc = NumberFormat.getInstance(Locale.ENGLISH).format(Math.abs(item.getQty())) + " " + desc;
		}
		return desc;
	}

	private Color getTextColor(String description)
	{
		if (description.contains("Total"))
		{
			return description.contains("Profit/Loss") ? Color.YELLOW : Color.ORANGE;
		}
		return Color.decode("#FFF7E3");
	}

	private Color getPriceColor(long price)
	{
		long numCoins = Math.abs(price);
		if (numCoins >= 1_000_000_000)
		{
			return new Color(0x6698FF);
		}
		else if (numCoins >= 10_000_000)
		{
			return new Color(0x00FF80);
		}
		else if (numCoins >= 100_000)
		{
			return new Color(0xFFFFFF);
		}
		else if (numCoins > 0)
		{
			return new Color(0xFFFF00);
		}
		else
		{
			return Color.RED;
		}
	}

	private Color getHighlightColor(long price)
	{
		long numCoins = Math.abs(price);
		if (config.overlayEnabled())
		{
			if (numCoins >= config.insaneValuePrice())
			{
				return new Color(
					config.insaneValueColor().getRed(),
					config.insaneValueColor().getGreen(),
					config.insaneValueColor().getBlue(),
					255
				);
			}
			else if (numCoins >= config.highValuePrice())
			{
				return new Color(
					config.highValueColor().getRed(),
					config.highValueColor().getGreen(),
					config.highValueColor().getBlue(),
					255
				);
			}
			else if (numCoins >= config.mediumValuePrice())
			{
				return new Color(
					config.mediumValueColor().getRed(),
					config.mediumValueColor().getGreen(),
					config.mediumValueColor().getBlue(),
					255
				);
			}
			else if (numCoins >= config.lowValuePrice())
			{
				return new Color(
					config.lowValueColor().getRed(),
					config.lowValueColor().getGreen(),
					config.lowValueColor().getBlue(),
					255
				);
			}
			else
			{
				return new Color(255, 255, 0, 255);
			}
		}
		else
		{
			return new Color(255, 255, 0, 255);
		}
	}


	private String getTotalText(long total)
	{
		if (config.showExactGp())
		{
			return getExactFormattedGp(total);
		}
		else
		{
			String totalText = getFormattedGp(total);
			return totalText.replace(".0", "");
		}
	}

	private String getFormattedGp(long total)
	{
		if (total >= 1000000000 || total <= -1000000000)
		{
			double bTotal = total / 1000000000.0;
			return getTruncatedTotal(bTotal) + "B";
		}
		else
		{
			if (total >= 1000000 || total <= -1000000)
			{
				double mTotal = total / 1000000.0;
				return getTruncatedTotal(mTotal) + "M";
			}
			else
			{
				if (total >= 1000 || total <= -1000)
				{
					double kTotal = total / 1000.0;
					return getTruncatedTotal(kTotal) + "K";
				}
				else
				{
					return getExactFormattedGp(total);
				}
			}
		}
	}

	private String getTruncatedTotal(double total)
	{
		String totalString = Double.toString(total);

		long dotIndex = totalString.indexOf('.');
		if (dotIndex < totalString.length() - 1)
		{
			return totalString.substring(0, Math.toIntExact(dotIndex + 2));
		}

		return totalString;
	}

	private String getExactFormattedGp(long total)
	{
		return NumberFormat.getInstance(Locale.ENGLISH).format(total);
	}

	public void showInterstitial()
	{
		showInterstitial = true;
	}

	public void hideInterstitial()
	{
		showInterstitial = false;
	}
}

/*
 * Copyright (c) 2018, Jos <Malevolentdev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.liteutilities;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;

@Getter
@AllArgsConstructor
public enum ViewportModus
{
	RESIZED_BOX(ComponentID.RESIZABLE_VIEWPORT_RESIZABLE_VIEWPORT_OLD_SCHOOL_BOX, ComponentID.RESIZABLE_VIEWPORT_INTERFACE_CONTAINER),
	RESIZED_BOTTOM(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_RESIZABLE_VIEWPORT_BOTTOM_LINE, ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_INTERFACE_CONTAINER),
	FIXED(ComponentID.FIXED_VIEWPORT_FIXED_VIEWPORT, ComponentID.FIXED_VIEWPORT_INTERFACE_CONTAINER),
	FIXED_BANK(ComponentID.BANK_CONTAINER, ComponentID.BANK_INVENTORY_ITEM_CONTAINER);

	private int container;
	private final int viewport;
}

package com.liteutilities;

public enum LiteUtilsModes
{
    TOTAL,
    PROFIT_LOSS
}

package com.liteutilities;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

public class LiteUtilsTimerData
{
    long profitLossInitialGp = 0;
    long profitLossInitialGpHA = 0;

    Map<Long, Long> itemPrices = new HashMap<>();
    Map<Long, Long> itemPricesHA = new HashMap<>();
    Map<Long, Long> initialItemQtys = new HashMap<>();
    Map<Long, Long> itemQtys = new HashMap<>();

    LinkedList<String> ignoredItems = new LinkedList<>();
}

package com.liteutilities;

import lombok.Getter;

@Getter
public class LiteUtilsTooltipItem
{
    private final String description;
    private long qty;
    private final long amount;
	@Getter
	private long itemId;

    public LiteUtilsTooltipItem(String description, long qty, long amount, long itemId)
    {
        this.description = description;
        this.qty = qty;
        this.amount = amount;
		this.itemId = itemId;
    }

	public void addQuantityDifference(long qtyDifference)
    {
        qty += qtyDifference;
    }
}

package com.liteutilities;

public enum LiteUtilsState
{
    NONE,
    BANK,
    RUN
}

package com.liteutilities;

import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.Color;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.Varbits;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

@PluginDescriptor(
	name = "Lite Utilities",
	description = "Utilities that are compact yet informative, display profits and inventory value.",
	tags = {"combat", "profit", "gold", "items", "inventory", "tracking", "calculate", "skilling", "money", "pouch", "highlight"},
	conflicts = {"Inventory Total", "ItemRarity"}
)

public class LiteUtilitiesPlugin extends Plugin
{
	static final int COINS = ItemID.COINS_995;
	static final int TOTAL_GP_GE_INDEX = 0;
	static final int TOTAL_GP_HA_INDEX = 1;
	static final int TOTAL_QTY_INDEX = 2;
	static final int RUNEPOUCH_ITEM_ID = 12791;
	static final int DIVINE_RUNEPOUCH_ITEM_ID = 27281;

	@Inject
	private LiteUtilsOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ItemHighlightOverlay overlayItem;

	@Inject
	private Client client;

	@Inject
	private LiteUtilsConfig config;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Gson gson;

	@Inject
	private KeyManager keyManager;

	@Getter
	private LiteUtilsTimerData runData;

	@Getter
	private LiteUtilsModes mode = LiteUtilsModes.TOTAL;

	@Getter
	private LiteUtilsState state = LiteUtilsState.NONE;
	private LiteUtilsState prevState = LiteUtilsState.NONE;

	private long totalGp = 0;
	@Getter
	private long totalQty = 0;

	private long runStartTime = 0;

	private long lastWriteSaveTime = 0;

	private LiteUtilsModes plToggleOverride = null;
	private KeyListener plToggleKeyListener;
	private KeyListener newRunKeyListener;

	private boolean manualNewRun = false;

	private static final long[] RUNEPOUCH_AMOUNT_VARBITS = {
			Varbits.RUNE_POUCH_AMOUNT1, Varbits.RUNE_POUCH_AMOUNT2, Varbits.RUNE_POUCH_AMOUNT3, Varbits.RUNE_POUCH_AMOUNT4
	};
	private static final long[] RUNEPOUCH_RUNE_VARBITS = {
			Varbits.RUNE_POUCH_RUNE1, Varbits.RUNE_POUCH_RUNE2, Varbits.RUNE_POUCH_RUNE3, Varbits.RUNE_POUCH_RUNE4
	};

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);

		if (config.overlayEnabled()) {
			overlayManager.add(overlayItem);
		}

		runData = new LiteUtilsTimerData();
		manualNewRun = true;
		registerKeys();
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		overlayManager.remove(overlayItem);
		unregisterKeys();
	}

	@Subscribe
	public void onRuneScapeProfileChanged(RuneScapeProfileChanged e)
	{
		String profileKey = configManager.getRSProfileKey();
		if (profileKey != null)
		{
			runData = getSavedData();
		}
	}

	@Provides
	LiteUtilsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LiteUtilsConfig.class);
	}

	LiteUtilsPriceTypes getPriceType()
	{
		return config.priceType();
	}

	Color getRarityColor(final long itemPrice)
	{
		if (itemPrice >= config.insaneValuePrice())
		{
			return config.insaneValueColor();
		}
		else if (itemPrice >= config.highValuePrice())
		{
			return config.highValueColor();
		}
		else if (itemPrice >= config.mediumValuePrice())
		{
			return config.mediumValueColor();
		}
		else if (itemPrice >= config.lowValuePrice())
		{
			return config.lowValueColor();
		}

		return null;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged config)
	{
		if (config.getGroup().equals(LiteUtilsConfig.GROUP))
		{
			if (config.getKey().equals("overlayEnabled"))
			{
				boolean overlayEnabled = configManager.getConfig(LiteUtilsConfig.class).overlayEnabled();

				if (overlayEnabled)
				{
					overlayManager.add(overlayItem);
				}
				else
				{
					overlayManager.remove(overlayItem);
				}
			}
			else if (config.getKey().equals("enableProfitLoss"))
			{
				plToggleOverride = null;
			}
			else if (config.getKey().equals("profitLossToggleKey"))
			{
				unregisterKeys();
				registerKeys();
			}
			else if (config.getKey().equals("ignoredItems"))
			{
				if (runData != null)
				{
					runData.ignoredItems = getIgnoredItems();
				}
			}
		}
	}

	private void registerKeys()
	{
		plToggleKeyListener = new HotkeyListener(() -> config.profitLossToggleKey())
		{
			@Override
			public void hotkeyPressed()
			{
				if (mode == LiteUtilsModes.TOTAL)
				{
					plToggleOverride = LiteUtilsModes.PROFIT_LOSS;
				}
				else
				{
					plToggleOverride = LiteUtilsModes.TOTAL;
				}
			}
		};
		keyManager.registerKeyListener(plToggleKeyListener);

		newRunKeyListener = new HotkeyListener(() -> config.newRunKey())
		{
			@Override
			public void hotkeyPressed()
			{
				if (state != LiteUtilsState.BANK)
				{
					manualNewRun = true;
				}
			}
		};
		keyManager.registerKeyListener(newRunKeyListener);
	}

	private void unregisterKeys()
	{
		if (plToggleKeyListener != null)
		{
			keyManager.unregisterKeyListener(plToggleKeyListener);
		}
		if (newRunKeyListener != null)
		{
			keyManager.unregisterKeyListener(newRunKeyListener);
		}
	}

	void onNewRun()
	{
		overlay.showInterstitial();

		runStartTime = Instant.now().toEpochMilli();

		runData.ignoredItems = getIgnoredItems();
	}

	void postNewRun()
	{
		runData.initialItemQtys.clear();

		long [] inventoryTotals = getInventoryTotals(true);
		long [] equipmentTotals = getEquipmentTotals(true);

		long inventoryTotal = inventoryTotals[LiteUtilitiesPlugin.TOTAL_GP_GE_INDEX];
		long inventoryTotalHA = inventoryTotals[LiteUtilitiesPlugin.TOTAL_GP_HA_INDEX];

		long equipmentTotal = equipmentTotals[0];
		long equipmentTotalHA = equipmentTotals[1];

		runData.profitLossInitialGp = inventoryTotal + equipmentTotal;
		runData.profitLossInitialGpHA = inventoryTotalHA + equipmentTotalHA;

		writeSavedData();

		overlay.hideInterstitial();
	}

	void onBank()
	{
		if (!config.newRunAfterBanking())
		{
			return;
		}

		runData.profitLossInitialGp = 0;
		runData.profitLossInitialGpHA = 0;
		runData.itemPrices.clear();

		runStartTime = 0;

		writeSavedData();
	}

	long[] getInventoryTotals(boolean isNewRun)
	{
		final ItemContainer itemContainer = overlay.getInventoryItemContainer();

		if (itemContainer == null)
		{
			return new long [2];
		}

		final Item[] items = itemContainer.getItems();

		final LinkedList<Item> allItems = new LinkedList<>(Arrays.asList(items));
		if (allItems.stream().anyMatch(s -> s.getId() == RUNEPOUCH_ITEM_ID || s.getId() == DIVINE_RUNEPOUCH_ITEM_ID))
		{
			allItems.addAll(getRunepouchContents());
		}

		long totalQty = 0;
		long totalGp = 0;
		long totalGpHA = 0;

		for (Item item: allItems)
		{
			long itemId = item.getId();

			final ItemComposition itemComposition = itemManager.getItemComposition(Math.toIntExact(itemId));

			String itemName = itemComposition.getName();
			final boolean ignore = runData.ignoredItems.stream().anyMatch(s -> {
				String lcItemName = itemName.toLowerCase();
				String lcS = s.toLowerCase();
				return lcItemName.contains(lcS);
			});
			if (ignore)
			{
				continue;
			}

			final boolean isNoted = itemComposition.getNote() != -1;
			final long realItemId = isNoted ? itemComposition.getLinkedNoteId() : itemId;

			long totalPrice;
			long totalPriceHA;
			long gePrice;
			long haPrice;

			if (runData.itemPrices.containsKey(realItemId))
			{
				gePrice = runData.itemPrices.get(realItemId);
			}
			else
			{
				gePrice = itemManager.getItemPrice(Math.toIntExact(realItemId));
			}

			if (runData.itemPricesHA.containsKey(realItemId))
			{
				haPrice = runData.itemPricesHA.get(realItemId);
			}
			else
			{
				haPrice = itemComposition.getHaPrice();
			}

			long itemQty = item.getQuantity();

			if (realItemId == COINS)
			{
				totalPrice = itemQty;
			}
			else
			{
				totalPrice = itemQty * gePrice;
			}

			if (realItemId == COINS)
			{
				totalPriceHA = itemQty;
			}
			else
			{
				totalPriceHA = itemQty * haPrice;
			}

			totalGp += totalPrice;
			totalGpHA += totalPriceHA;
			totalQty += itemQty;

			if (realItemId != COINS && !runData.itemPrices.containsKey(realItemId))
			{
				runData.itemPrices.put(realItemId, gePrice);
			}

			if (realItemId != COINS && !runData.itemPricesHA.containsKey(realItemId))
			{
				runData.itemPricesHA.put(realItemId, haPrice);
			}

			if (isNewRun)
			{
				if (runData.initialItemQtys.containsKey(realItemId))
				{
					runData.initialItemQtys.put(realItemId, runData.initialItemQtys.get(realItemId) + itemQty);
				}
				else
				{
					runData.initialItemQtys.put(realItemId, itemQty);
				}
			}

			if (runData.itemQtys.containsKey(realItemId))
			{
				runData.itemQtys.put(realItemId, runData.itemQtys.get(realItemId) + itemQty);
			}
			else
			{
				runData.itemQtys.put(realItemId, itemQty);
			}
		}

		long[] totals = new long[3];

		totals[TOTAL_GP_GE_INDEX] = totalGp;
		totals[TOTAL_GP_HA_INDEX] = totalGpHA;
		totals[TOTAL_QTY_INDEX] = totalQty;

		return totals;
	}

	long[] getEquipmentTotals(boolean isNewRun)
	{
		final ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);

		if (itemContainer == null)
		{
			return new long [] {0, 0};
		}

		Item ammo = itemContainer.getItem(EquipmentInventorySlot.AMMO.getSlotIdx());

		List<Integer> eIds = getEquipmentIds();

		long eTotal = 0;
		long eTotalHA = 0;
		for (long itemId: eIds)
		{
			long qty = 1;
			if (ammo != null && itemId == ammo.getId())
			{
				qty = ammo.getQuantity();
			}

			long gePrice;
			long haPrice;

			if (runData.itemPrices.containsKey(itemId))
			{
				gePrice = runData.itemPrices.get(itemId);
			}
			else
			{
				gePrice = itemManager.getItemPrice(Math.toIntExact(itemId));
			}

			if (runData.itemPricesHA.containsKey(itemId))
			{
				haPrice = runData.itemPricesHA.get(itemId);
			}
			else
			{
				ItemComposition itemComposition = itemManager.getItemComposition(Math.toIntExact(itemId));
				haPrice = itemComposition.getHaPrice();
			}

			long totalPrice = qty * gePrice;
			long totalPriceHA = qty * haPrice;

			eTotal += totalPrice;
			eTotalHA += totalPriceHA;

			if (!runData.itemPrices.containsKey(itemId))
			{
				runData.itemPrices.put(itemId, gePrice);
			}

			if (!runData.itemPricesHA.containsKey(itemId))
			{
				runData.itemPricesHA.put(itemId, haPrice);
			}

			if (isNewRun)
			{
				if (runData.initialItemQtys.containsKey(itemId))
				{
					runData.initialItemQtys.put(itemId, runData.initialItemQtys.get(itemId) + qty);
				}
				else
				{
					runData.initialItemQtys.put(itemId, qty);
				}
			}

			if (runData.itemQtys.containsKey(itemId))
			{
				runData.itemQtys.put(itemId, runData.itemQtys.get(itemId) + qty);
			}
			else
			{
				runData.itemQtys.put(itemId, qty);
			}
		}

		return new long [] {eTotal, eTotalHA};
	}

	private List<Integer> getEquipmentIds()
	{
		List<Item> equipment = getEquipment();

		return equipment
				.stream()
				.map(Item::getId)
				.collect(Collectors.toList());
	}

	private List<Item> getEquipment()
	{
		final ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);

		if (equipment == null)
		{
			return new ArrayList<>();
		}

		Item head = equipment.getItem(EquipmentInventorySlot.HEAD.getSlotIdx());
		Item cape = equipment.getItem(EquipmentInventorySlot.CAPE.getSlotIdx());
		Item amulet = equipment.getItem(EquipmentInventorySlot.AMULET.getSlotIdx());
		Item ammo = equipment.getItem(EquipmentInventorySlot.AMMO.getSlotIdx());
		Item weapon = equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
		Item body = equipment.getItem(EquipmentInventorySlot.BODY.getSlotIdx());
		Item shield = equipment.getItem(EquipmentInventorySlot.SHIELD.getSlotIdx());
		Item legs = equipment.getItem(EquipmentInventorySlot.LEGS.getSlotIdx());
		Item gloves = equipment.getItem(EquipmentInventorySlot.GLOVES.getSlotIdx());
		Item boots = equipment.getItem(EquipmentInventorySlot.BOOTS.getSlotIdx());
		Item ring = equipment.getItem(EquipmentInventorySlot.RING.getSlotIdx());

		List<Item> items = new ArrayList<Item>();

		if (head != null)
		{
			items.add(head);
		}

		if (cape != null)
		{
			items.add(cape);
		}

		if (amulet != null)
		{
			items.add(amulet);
		}

		if (ammo != null)
		{
			items.add(ammo);
		}

		if (weapon != null)
		{
			items.add(weapon);
		}

		if (body != null)
		{
			items.add(body);
		}

		if (shield != null)
		{
			items.add(shield);
		}

		if (legs != null)
		{
			items.add(legs);
		}

		if (gloves != null)
		{
			items.add(gloves);
		}

		if (boots != null)
		{
			items.add(boots);
		}

		if (ring != null)
		{
			items.add(ring);
		}

		return items;
	}

	List<LiteUtilsTooltipItem> getInventoryLedger()
	{
		List<LiteUtilsTooltipItem> ledgerItems = new LinkedList<>();

		final ItemContainer itemContainer = overlay.getInventoryItemContainer();

		if (itemContainer == null)
		{
			return new LinkedList<>();
		}

		final Item[] items = itemContainer.getItems();

		final LinkedList<Item> allItems = new LinkedList<>(Arrays.asList(items));
		if (allItems.stream().anyMatch(s -> s.getId() == RUNEPOUCH_ITEM_ID || s.getId() == DIVINE_RUNEPOUCH_ITEM_ID))
		{
			allItems.addAll(getRunepouchContents());
		}

		Map<Long, Long> qtyMap = new HashMap<>();

		for (Item item: allItems)
		{
			long itemId = item.getId();

			final ItemComposition itemComposition = itemManager.getItemComposition(Math.toIntExact(itemId));

			String itemName = itemComposition.getName();
			final boolean ignore = runData.ignoredItems.stream().anyMatch(s -> {
				String lcItemName = itemName.toLowerCase();
				String lcS = s.toLowerCase();
				return lcItemName.contains(lcS);
			});
			if (ignore)
			{
				continue;
			}

			final boolean isNoted = itemComposition.getNote() != -1;
			final long realItemId = isNoted ? itemComposition.getLinkedNoteId() : itemId;

			long itemQty = item.getQuantity();

			if (qtyMap.containsKey(realItemId))
			{
				qtyMap.put(realItemId, qtyMap.get(realItemId) + itemQty);
			}
			else
			{
				qtyMap.put(realItemId, itemQty);
			}
		}

		for (Long itemId: qtyMap.keySet())
		{
			final ItemComposition itemComposition = itemManager.getItemComposition(Math.toIntExact(itemId));

			String itemName = itemComposition.getName();

			Long qty = qtyMap.get(itemId);

			Long total;
			if (config.priceType() == LiteUtilsPriceTypes.GRAND_EXCHANGE)
			{
				total = runData.itemPrices.get(itemId);
			}
			else
			{
				total = runData.itemPricesHA.get(itemId);
			}

			if (itemId == COINS || total == null)
			{
				total = 1L;
			}

			ledgerItems.add(new LiteUtilsTooltipItem(itemName, qty, total, itemId));
		}

		return ledgerItems;
	}

	List<LiteUtilsTooltipItem> getProfitLossLedger()
	{
		Map<Long, Long> prices;
		if (config.priceType() == LiteUtilsPriceTypes.GRAND_EXCHANGE)
		{
			prices = runData.itemPrices;
		}
		else
		{
			prices = runData.itemPricesHA;
		}

		Map<Long, Long> initialQtys = runData.initialItemQtys;
		Map<Long, Long> qtys = runData.itemQtys;

		Map<Long, Long> qtyDifferences = new HashMap<>();

		HashSet <Long> combinedQtyKeys = new HashSet<>();
		combinedQtyKeys.addAll(qtys.keySet());
		combinedQtyKeys.addAll(initialQtys.keySet());

		for (Long itemId: combinedQtyKeys)
		{
			Long initialQty = initialQtys.get(itemId);
			Long qty = qtys.get(itemId);

			if (initialQty == null)
			{
				initialQty = 0L;
			}

			if (qty == null)
			{
				qty = 0L;
			}

			qtyDifferences.put(itemId, qty - initialQty);
		}

		List<LiteUtilsTooltipItem> ledgerItems = new LinkedList<>();

		for (Long itemId: qtyDifferences.keySet())
		{
			final ItemComposition itemComposition = itemManager.getItemComposition(Math.toIntExact(itemId));
			Long price = prices.get(itemId);

			if (price == null)
			{
				price = 1L;
			}

			Long qtyDifference = qtyDifferences.get(itemId);

			List<LiteUtilsTooltipItem> filteredList = ledgerItems.stream().filter(
					item -> item.getDescription().equals(itemComposition.getName())).collect(Collectors.toList()
			);

			if (!filteredList.isEmpty())
			{
				filteredList.get(0).addQuantityDifference(qtyDifference);
			}
			else
			{
				if (price > 0)
				{
					ledgerItems.add(new LiteUtilsTooltipItem(itemComposition.getName(), qtyDifference, price, itemId));
				}
			}
		}

		return ledgerItems;
	}

	private List<Item> getRunepouchContents()
	{
		EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
		List<Item> items = new ArrayList<>(RUNEPOUCH_AMOUNT_VARBITS.length);
		for (int i = 0; i < RUNEPOUCH_AMOUNT_VARBITS.length; i++)
		{
			long amount = client.getVarbitValue(Math.toIntExact(RUNEPOUCH_AMOUNT_VARBITS[i]));
			if (amount <= 0)
			{
				continue;
			}

			long runeId = client.getVarbitValue(Math.toIntExact(RUNEPOUCH_RUNE_VARBITS[i]));
			if (runeId == 0)
			{
				continue;
			}

			final long itemId = runepouchEnum.getIntValue(Math.toIntExact(runeId));
			Item item = new Item(Math.toIntExact(itemId), Math.toIntExact(amount));
			items.add(item);
		}
		return items;
	}

	void writeSavedData()
	{
		if (state == LiteUtilsState.BANK || Instant.now().toEpochMilli() - lastWriteSaveTime < 600)
		{
			return;
		}

		String profile = configManager.getRSProfileKey();

		String json = gson.toJson(runData);
		configManager.setConfiguration(LiteUtilsConfig.GROUP, profile, "inventory_total_data", json);

		lastWriteSaveTime = Instant.now().toEpochMilli();
	}

	private LiteUtilsTimerData getSavedData()
	{
		String profile = configManager.getRSProfileKey();
		String json = configManager.getConfiguration(LiteUtilsConfig.GROUP, profile, "inventory_total_data");

		LiteUtilsTimerData savedData = gson.fromJson(json, LiteUtilsTimerData.class);

		if (savedData == null)
		{
			return new LiteUtilsTimerData();
		}
		return savedData;
	}

	private LinkedList<String> getIgnoredItems()
	{
		return new LinkedList<>(
			Arrays.asList(
				config.ignoredItems().split("\\s*,\\s*")
			)
		);
	}


	void setMode(LiteUtilsModes mode)

	{
		this.mode = mode;
	}

	void setState(LiteUtilsState state)
	{
		this.prevState = this.state;
		this.state = state;
	}

	public LiteUtilsState getPreviousState()
	{
		return prevState;
	}

	public long getProfitGp()
	{
		if (mode == LiteUtilsModes.TOTAL)
		{
			return totalGp;
		}
		else if (config.priceType() == LiteUtilsPriceTypes.GRAND_EXCHANGE)
		{
			return totalGp - runData.profitLossInitialGp;
		}
		else
		{
			return totalGp - runData.profitLossInitialGpHA;
		}
	}

	void setTotalGp(long totalGp)
	{
		this.totalGp = totalGp;
	}

	void setTotalQty(long totalQty)
	{
		this.totalQty = totalQty;
	}

	public LiteUtilsModes getPLToggleOverride()
	{
		return plToggleOverride;
	}

	public boolean isManualNewRun()
	{
		if (manualNewRun)
		{
			manualNewRun = false;
			return true;
		}
		return false;
	}
}

package com.liteutilities;

public enum LiteUtilsPriceTypes
{
    GRAND_EXCHANGE,
	HIGH_ALCHEMY
}

package com.liteutilities;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LiteUtilitiesPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LiteUtilitiesPlugin.class);
		RuneLite.main(args);
	}
}
