package com.monstermonitor;

import com.google.inject.Provides;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.stream.Collectors;

@PluginDescriptor(
        name = "Monster Monitor",
        description = "Tracks NPC kills and allows setting kill limits",
        tags = {"npc", "kill", "limit, mm"}
)
public class MonsterMonitorPlugin extends Plugin
{
    @Inject
    MonsterMonitorConfig config;

    @Inject
    private EventBus eventBus;

    @Inject
    MonsterMonitorLogger logger;

    @Inject
    MonsterMonitorOverlay overlay;

    @Inject
    MonsterMonitorPanel panel;

    @Inject
    OverlayManager overlayManager;

    @Inject
    ClientToolbar clientToolbar;

    @Inject
    Client client;

    @Inject
    ClientThread clientThread;

    @Inject
    DeathTracker deathTracker;

    @Inject
    MonsterMonitorMenuHandler menuHandler;

    @Inject
    private MonsterMonitorPopup popup;

    @Inject
    private SpecialNpcTracker specialNpcTracker;
    private NavigationButton navButton;
    private boolean initialized = false;

    @Provides
    MonsterMonitorConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(MonsterMonitorConfig.class);
    }

    @Inject
    private ConfigManager configManager;

    public void resetProgressBarColors() {
        configManager.setConfiguration("monster monitor", "progressBarStartColor", new Color(139, 0, 0));
        configManager.setConfiguration("monster monitor", "progressBarMidColor", new Color(204, 102, 0));
        configManager.setConfiguration("monster monitor", "progressBarEndColor", new Color(0, 128, 0));
        updateUI();
    }

    /**
     * Initializes the plugin, setting up UI components and registering events.
     */
    @Override
    protected void startUp() throws Exception
    {
        // Ensure the logger is initialized once the player is loaded.
        clientThread.invoke(() -> {
            if (client.getLocalPlayer() != null)
            {
                logger.initialize();
            }
        });

        // Load the plugin icon and create a navigation button.
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/net/runelite/client/plugins/MonsterMonitor/icon.png");
        navButton = NavigationButton.builder()
                .tooltip("Monster Monitor")
                .icon(icon)
                .panel(panel)
                .build();
        clientToolbar.addNavigation(navButton);
        updateOverlayVisibility();

        // Register DeathTracker and menu handler for event handling.
        eventBus.register(deathTracker);
        eventBus.register(menuHandler);
    }

    /**
     * Handles plugin shutdown, including saving logs and removing UI elements.
     */
    @Override
    protected void shutDown() throws Exception
    {
        overlayManager.remove(overlay);
        clientToolbar.removeNavigation(navButton);

        // Unregister DeathTracker and menu handler to stop event handling.
        eventBus.unregister(deathTracker);
        eventBus.unregister(menuHandler);

        // Unregister SpecialNpcTracker
        eventBus.unregister(specialNpcTracker);
        specialNpcTracker.shutdown();

        // Unregister MonsterMonitorPopup
        if (popup != null) {
            popup.shutdownPopup();
        }

        // Save the current log state if the logger was initialized.
        if (logger != null && initialized)
        {
            logger.saveLog();
        }
        initialized = false;
    }

    /**
     * Handles the game tick event to initialize components if needed.
     */
    @Subscribe
    public void onGameTick(GameTick event)
    {
        // Initialize logger and UI elements if not yet initialized.
        if (!initialized && client.getLocalPlayer() != null)
        {
            logger.initialize();
            logger.loadLog();
            SwingUtilities.invokeLater(() -> {
                updateOverlay();
                updateOverlayVisibility();
                panel.updatePanel();
            });
            initialized = true;
        }
    }

    /**
     * Logs a death for a specific NPC and updates the UI accordingly.
     *
     * @param npcName The name of the NPC to log the death for.
     */
    public void logDeath(String npcName)
    {
        if (initialized)
        {
            logger.logDeath(npcName);
            updateUI();
            checkKillLimit(npcName);
        }
    }

    /**
     * Updates the UI elements, including the overlay and panel.
     */
    public void updateUI()
    {
        if (initialized)
        {
            SwingUtilities.invokeLater(() -> {
                updateOverlay();
                panel.updatePanel();
            });
        }
    }

    /**
     * Checks if a kill limit has been reached for a specific NPC and sends notifications.
     *
     * @param npcName The name of the NPC to check the kill limit for.
     */
    private void checkKillLimit(String npcName)
    {
        if (!initialized)
        {
            return;
        }

        NpcData npcData = logger.getNpcLog().get(npcName);
        if (npcData == null)
        {
            return;
        }

        int killLimit = npcData.getKillLimit();
        int killCountForLimit = npcData.getKillCountForLimit();

        // If the kill limit is reached, notify the player.
        if (killLimit > 0 && killCountForLimit >= killLimit && npcData.isNotifyOnLimit())
        {
            if (config.notifyOnLimit())
            {
                // Play a sound if enabled.
                if (config.enableSoundAlerts())
                {
                    Toolkit.getDefaultToolkit().beep();
                }
                // Display a chat message if enabled.
                if (config.showChatNotifications())
                {
                    String message = "<col=ff0000>" + config.customNotificationMessage().replace("{npc}", npcName) + "</col>";
                    client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null);
                }

                if (config.showPopup()) {
                    popup.showPopup(npcName);
                }
            }
        }
    }

    /**
     * Retrieves the list of tracked NPCs.
     *
     * @return A list of tracked NPC data.
     */
    public List<NpcData> getTrackedNpcs()
    {
        return logger.getNpcLog().values().stream().collect(Collectors.toList());
    }

    /**
     * Updates the overlay with the current list of tracked NPCs.
     * Only displays NPCs that have a set kill limit.
     */
    public void updateOverlay() {
        List<NpcData> filteredNpcs = getTrackedNpcs().stream()
                .filter(npcData -> npcData.isLimitSet() && !npcData.isIgnored())
                .collect(Collectors.toList());

        overlay.updateOverlayData(filteredNpcs);
    }

    /**
     * Updates the visibility of the overlay based on user settings and tracked NPCs.
     */
    public void updateOverlayVisibility() {
        // Check if there are any tracked NPCs with a set kill limit.
        boolean hasKillLimitSet = logger.getNpcLog().values().stream()
                .anyMatch(npcData -> npcData.isLimitSet() && !npcData.isIgnored());

        // Only show the overlay if enabled in the config and at least one kill limit is set.
        if (hasKillLimitSet && config.showOverlay()) {
            overlayManager.add(overlay);
        } else {
            overlayManager.remove(overlay);
        }
    }

    /**
     * Sets the specified NPC to be monitored with a given kill limit.
     * If the limit is zero, it is considered as having no limit.
     *
     * @param npcName The name of the NPC to monitor.
     * @param killLimit The kill limit to set.
     */
    public void setNpcToMonitor(String npcName, int killLimit) {
        NpcData npcData = logger.getNpcLog().computeIfAbsent(npcName, NpcData::new);
        boolean limitChanged = npcData.getKillLimit() != killLimit; // Check if limit changed

        npcData.setKillLimit(killLimit);
        npcData.setLimitSet(true); // Ensure the limit is set
        npcData.setIgnored(false); // Ensure the NPC is not ignored
        npcData.resetKillCountForLimit(); // Reset progress towards the limit if changed

        if (limitChanged) {
            checkKillLimit(npcName);
        }

        // Update the logger with the new NPC data and refresh the UI.
        logger.updateNpcData(npcData);
        SwingUtilities.invokeLater(() -> panel.updatePanel()); // Update the panel to reflect the checkbox state
        updateOverlayVisibility();
    }

    /**
     * Sets the specified NPC to be ignored, preventing it from being tracked.
     *
     * @param npcName The name of the NPC to ignore.
     */
    public void setNpcToIgnore(String npcName) {
        NpcData npcData = logger.getNpcLog().computeIfAbsent(npcName, NpcData::new);

        npcData.setIgnored(true);
        npcData.setLimitSet(false);
        npcData.setKillLimit(0);
        npcData.resetKillCountForLimit();

        // Update the logger with the new NPC data and refresh the UI.
        logger.updateNpcData(npcData);
        updateUI();
        updateOverlayVisibility();
    }

    /**
     * Handles changes in the plugin's configuration settings.
     *
     * @param event The configuration change event.
     */
    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        // Ensure the config change is related to the "monster monitor" plugin.
        if (!event.getGroup().equals("monster monitor")) {
            return;
        }

        // Respond to specific configuration changes.
        switch (event.getKey()) {
            case "showOverlay":
            case "showTitle":
            case "showRightClickMenuEntries":
                updateOverlayVisibility();
                break;
            case "notifyOnLimit":
            case "showChatNotifications":
            case "customNotificationMessage":
            case "enableSoundAlerts":
            case "progressBarStartColor":
            case "progressBarMidColor":
            case "progressBarEndColor":
            case "showPopup":
                updateUI();
                break;
            case "resetProgressBarColors":
                resetProgressBarColors();
                break;
        }
    }
}

package com.monstermonitor;

import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javax.inject.Inject;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Hitsplat;
import net.runelite.api.NPC;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

/**
 * Tracks and manages NPC deaths and interactions for Monster Monitor.
 * This class handles tracking of kills, including special NPCs that do not fire the ActorDeath event.
 */
public class DeathTracker {
    private final Client client;
    private final MonsterMonitorPlugin plugin;
    private final MonsterMonitorLogger logger;
    private final MonsterMonitorPanel panel;
    private final ClientThread clientThread;
    private final SpecialNpcTracker specialNpcTracker;

    // Tracks NPCs with recent player interactions
    private final Map<Integer, String> lastKnownNpcName = new ConcurrentHashMap<>();
    private final Map<Integer, Integer> lastInteractionTicks = new ConcurrentHashMap<>();
    private final Map<Integer, Boolean> wasNpcEngaged = new ConcurrentHashMap<>();

    private static final int INTERACTION_TIMEOUT_TICKS = 7;

    private static final Map<String, Set<Integer>> FINAL_PHASE_IDS = Map.ofEntries(
            Map.entry("Kalphite Queen", Set.of(965)),
            Map.entry("The Nightmare", Set.of(378)),
            Map.entry("Phosani's Nightmare", Set.of(377)),
            Map.entry("Alchemical Hydra", Set.of(8622)),
            Map.entry("Hydra", Set.of(8609)),
            Map.entry("Phantom Muspah", Set.of(12082)),
            Map.entry("Dusk", Set.of(7889)),
            Map.entry("Abyssal Sire", Set.of(5891)),
            Map.entry("Kephri", Set.of(11722)),
            Map.entry("Verzik Vitur", Set.of(10832, 8371, 10849)),
            Map.entry("Great Olm", Set.of(7551))
    );

    private static final Map<String, Set<Integer>> EXCLUDED_NPC_IDS = Map.ofEntries(
            Map.entry("The Hueycoatl", Set.of(14010, 14011, 14013)),
            Map.entry("Hueycoatl Tail", Set.of(14014, 14015)),
            Map.entry("Hueycoatl Tail (Broken)", Set.of(14014, 14015)),
            Map.entry("Hueycoatl body", Set.of(14017, 14018)),
            Map.entry("Dawn", Set.of(7888)),
            Map.entry("Unstable ice", Set.of(13688)),
            Map.entry("Cracked Ice", Set.of(13026)),
            Map.entry("Rubble", Set.of(14018)),
            Map.entry("Great Olm Right Claw", Set.of(7550, 7553)),
            Map.entry("Great Olm Left Claw", Set.of(7552, 7555))
    );

    @Inject
    public DeathTracker(Client client, MonsterMonitorPlugin plugin, MonsterMonitorLogger logger,
                        MonsterMonitorPanel panel, ClientThread clientThread, SpecialNpcTracker specialNpcTracker) {
        this.client = client;
        this.plugin = plugin;
        this.logger = logger;
        this.panel = panel;
        this.clientThread = clientThread;
        this.specialNpcTracker = specialNpcTracker;
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged event) {
        Actor source = event.getSource();
        Actor target = event.getTarget();

        if (source == client.getLocalPlayer() && target instanceof NPC) {
            NPC npc = (NPC) target;
            int npcIndex = npc.getIndex();
            String npcName = Optional.ofNullable(npc.getName()).orElse("Unnamed NPC");

            lastKnownNpcName.put(npcIndex, npcName);
            lastInteractionTicks.put(npcIndex, client.getTickCount());
            wasNpcEngaged.put(npcIndex, false);

            // Start tracking if the NPC is a special NPC
            if (specialNpcTracker.isSpecialNpc(npc)) {
                specialNpcTracker.trackNpc(npc);
            }
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        Actor target = event.getActor();
        Hitsplat hitsplat = event.getHitsplat();

        if (target instanceof NPC && hitsplat.isMine()) {
            NPC npc = (NPC) target;
            int npcIndex = npc.getIndex();
            String npcName = Optional.ofNullable(npc.getName()).orElse(lastKnownNpcName.getOrDefault(npcIndex, "Unnamed NPC"));

            lastKnownNpcName.put(npcIndex, npcName);
            lastInteractionTicks.put(npcIndex, client.getTickCount());
            wasNpcEngaged.put(npcIndex, true);
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath event) {
        Actor actor = event.getActor();

        if (actor instanceof NPC) {
            NPC npc = (NPC) actor;
            int npcIndex = npc.getIndex();
            int npcId = npc.getId();
            String npcName = normalizeName(lastKnownNpcName.getOrDefault(npcIndex, npc.getName()));

            // Skip logging if the NPC is in the exclusion list
            if (isExcludedNpc(npcName, npcId)) {
                return;
            }

            // For special NPCs, let SpecialNpcTracker handle logging
            if (specialNpcTracker.isSpecialNpc(npc)) {
                cleanupAfterLogging(npcIndex);
                return;
            }

            // For multi-phase bosses, only log if the NPC is in its final phase
            if (FINAL_PHASE_IDS.containsKey(npcName)) {
                Set<Integer> finalIds = FINAL_PHASE_IDS.get(npcName);
                if (!finalIds.contains(npcId)) {
                    return; // Skip logging for intermediate phases
                }
            }

            // Log death for standard NPCs if the interaction was valid
            if (wasNpcEngaged.getOrDefault(npcIndex, false) && isInteractionValid(npcIndex)) {
                clientThread.invoke(() -> plugin.logDeath(npcName));
            }

            // Clean up tracking for this NPC
            cleanupAfterLogging(npcIndex);
        }
    }

    /**
     * Normalizes an NPC name by stripping out color tags or extra formatting.
     *
     * @param npcName The original name of the NPC.
     * @return The normalized NPC name.
     */
    private String normalizeName(String npcName) {
        if (npcName == null) {
            return "Unnamed NPC";
        }
        return npcName.replaceAll("<.*?>", "").trim(); // Remove color tags and extra whitespace
    }

    /**
     * Checks if an NPC should be excluded from logging based on its name and ID.
     *
     * @param npcName The name of the NPC.
     * @param npcId   The ID of the NPC.
     * @return True if the NPC is excluded, otherwise false.
     */
    private boolean isExcludedNpc(String npcName, int npcId) {
        // Check by name and associated IDs
        if (EXCLUDED_NPC_IDS.containsKey(npcName)) {
            return EXCLUDED_NPC_IDS.get(npcName).contains(npcId);
        }

        for (Set<Integer> excludedIds : EXCLUDED_NPC_IDS.values()) {
            if (excludedIds.contains(npcId)) {
                return true;
            }
        }

        return false;
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        int currentTick = client.getTickCount();

        // Update health-based tracking for special NPCs
        specialNpcTracker.updateTrackedNpcs();

        // Clean up entries where interaction has timed out
        lastInteractionTicks.keySet().removeIf(npcIndex ->
                (currentTick - lastInteractionTicks.get(npcIndex)) > INTERACTION_TIMEOUT_TICKS
        );
    }

    /**
     * Checks if the interaction with an NPC is valid based on the last interaction time.
     *
     * @param npcIndex The index of the NPC to check.
     * @return true if the interaction is within the allowed time window, false otherwise.
     */
    private boolean isInteractionValid(int npcIndex) {
        Integer lastTick = lastInteractionTicks.get(npcIndex);
        return lastTick != null && (client.getTickCount() - lastTick) <= INTERACTION_TIMEOUT_TICKS;
    }

    /**
     * Cleans up tracking information after an NPC's interaction has been logged or expired.
     *
     * @param npcIndex The index of the NPC to clean up.
     */
    private void cleanupAfterLogging(int npcIndex) {
        lastKnownNpcName.remove(npcIndex);
        lastInteractionTicks.remove(npcIndex);
        wasNpcEngaged.remove(npcIndex);
    }
}

package com.monstermonitor;

import javax.swing.*;
import java.awt.*;

/**
 * Represents a UI component (box) in Monster Monitor that displays information
 * about a specific NPC. The box shows the NPC's name, kill count, and provides options to
 * set kill limits, enable notifications, and other related settings.
 * This component also supports expanding and collapsing additional options via a dropdown.
 */
public class MonsterMonitorBox extends JPanel
{
    private final MonsterMonitorPlugin plugin;
    private final NpcData npcData;
    private boolean optionsVisible; // Tracks whether the dropdown is open
    private final JPanel optionsPanel;
    private JButton toggleButton;
    private JCheckBox setLimitCheckbox;
    private JSpinner limitSpinner;
    private JCheckBox notifyCheckbox;

    /**
     * Constructs the MonsterMonitorBox component and initializes its UI elements.
     *
     * @param plugin The MonsterMonitorPlugin instance that this box is part of.
     * @param npcData The NpcData associated with the NPC displayed in this box.
     * @param initialDropdownState The initial state of the dropdown (expanded or collapsed).
     */
    public MonsterMonitorBox(MonsterMonitorPlugin plugin, NpcData npcData, boolean initialDropdownState)
    {
        this.plugin = plugin;
        this.npcData = npcData;
        this.optionsVisible = initialDropdownState;

        setLayout(new BorderLayout());
        setBackground(new Color(60, 60, 60));
        setBorder(BorderFactory.createLineBorder(Color.GRAY));

        add(createNpcNameLabel(), BorderLayout.WEST);
        add(createToggleButton(), BorderLayout.EAST);

        // Create the options panel
        optionsPanel = createOptionsPanel();
        if (optionsVisible) {
            add(optionsPanel, BorderLayout.SOUTH);
        }

        // Set the initial state of the checkbox and other UI elements
        refreshUI();
        updateOptionStateBasedOnIgnored();
    }

    /**
     * Creates the NPC name label displaying the NPC's name and kill count.
     *
     * @return The JLabel for the NPC's name.
     */
    private JLabel createNpcNameLabel()
    {
        JLabel npcNameLabel = new JLabel(npcData.getNpcName() + " x " + npcData.getTotalKillCount());
        npcNameLabel.setForeground(new Color(200, 200, 200));
        npcNameLabel.setFont(new Font("Arial", Font.BOLD, 12));
        npcNameLabel.setHorizontalAlignment(SwingConstants.LEFT);
        npcNameLabel.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));
        return npcNameLabel;
    }

    /**
     * Creates the toggle button for expanding or collapsing the options panel.
     *
     * @return The JButton used to toggle the dropdown visibility.
     */
    private JButton createToggleButton()
    {
        toggleButton = new JButton(optionsVisible ? "▲" : "▼");
        toggleButton.setPreferredSize(new Dimension(16, 16));
        toggleButton.setBorder(BorderFactory.createEmptyBorder());
        toggleButton.setContentAreaFilled(false);
        toggleButton.setFocusPainted(false);
        toggleButton.setForeground(new Color(200, 150, 0));

        toggleButton.addActionListener(e -> toggleOptionsVisibility());
        return toggleButton;
    }

    /**
     * Toggles the visibility of the options panel (dropdown) in the NPC box.
     * Expands or collapses the options panel and updates the toggle button text.
     */
    private void toggleOptionsVisibility() {
        SwingUtilities.invokeLater(() -> {
            if (optionsVisible) {
                remove(optionsPanel);
                toggleButton.setText("▼");
            } else {
                add(optionsPanel, BorderLayout.SOUTH);
                toggleButton.setText("▲");
            }
            optionsVisible = !optionsVisible;
            revalidate();
            getParent().revalidate();
            getParent().repaint();
        });
    }

    /**
     * Creates the options panel that allows users to set a kill limit, enable notifications,
     * and interact with other related settings for the NPC.
     *
     * @return A JPanel containing the options controls.
     */
    private JPanel createOptionsPanel()
    {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(new Color(60, 60, 60));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(2, 2, 2, 2);

        setLimitCheckbox = createSetLimitCheckbox();
        limitSpinner = createLimitSpinner();
        notifyCheckbox = createNotifyCheckbox();

        gbc.gridx = 0;
        gbc.weightx = 0.1;
        panel.add(setLimitCheckbox, gbc);

        gbc.gridx = 1;
        gbc.weightx = 0.3;
        panel.add(limitSpinner, gbc);

        gbc.gridx = 2;
        gbc.weightx = 0.1;
        panel.add(notifyCheckbox, gbc);

        return panel;
    }

    /**
     * Creates the checkbox to set a kill limit.
     *
     * @return A JCheckBox to enable or disable kill limit.
     */
    private JCheckBox createSetLimitCheckbox()
    {
        JCheckBox checkBox = new JCheckBox("Set Limit");
        checkBox.setForeground(Color.LIGHT_GRAY);
        checkBox.setBackground(new Color(60, 60, 60));
        checkBox.setFont(new Font("SansSerif", Font.BOLD, 11));
        checkBox.setSelected(npcData.isLimitSet());
        checkBox.addActionListener(e -> handleSetLimitCheckbox());
        return checkBox;
    }

    /**
     * Creates the spinner to adjust the kill limit.
     *
     * @return A JSpinner for selecting the kill limit.
     */
    private JSpinner createLimitSpinner()
    {
        JSpinner spinner = new JSpinner(new SpinnerNumberModel(npcData.getKillLimit(), 0, 9999999, 1)) {
            @Override
            public Dimension getPreferredSize() {
                return new Dimension(70, 20);
            }

            @Override
            public Dimension getMaximumSize() {
                return new Dimension(90, 20);
            }
        };
        spinner.setEnabled(npcData.isLimitSet());
        spinner.setFont(new Font("SansSerif", Font.BOLD, 11));
        spinner.addChangeListener(e -> {
            int limit = (Integer) spinner.getValue();
            npcData.setKillLimit(limit);
            plugin.logger.updateNpcData(npcData);
            plugin.updateOverlay();
        });
        return spinner;
    }

    /**
     * Creates the checkbox to enable notifications for reaching the kill limit.
     *
     * @return A JCheckBox to enable or disable notifications.
     */
    private JCheckBox createNotifyCheckbox()
    {
        JCheckBox checkBox = new JCheckBox("Notify");
        checkBox.setForeground(Color.LIGHT_GRAY);
        checkBox.setBackground(new Color(60, 60, 60));
        checkBox.setFont(new Font("SansSerif", Font.BOLD, 11));
        checkBox.setSelected(npcData.isNotifyOnLimit());
        checkBox.setEnabled(npcData.isLimitSet());
        checkBox.addActionListener(e -> {
            npcData.setNotifyOnLimit(checkBox.isSelected());
            plugin.logger.updateNpcData(npcData);
        });
        return checkBox;
    }

    /**
     * Handles the action when the set limit checkbox is toggled.
     */
    private void handleSetLimitCheckbox()
    {
        boolean isChecked = setLimitCheckbox.isSelected();
        npcData.setLimitSet(isChecked);
        limitSpinner.setEnabled(isChecked);
        notifyCheckbox.setEnabled(isChecked);

        if (!isChecked) {
            npcData.setKillLimit(0); // Clear the limit when unchecked
            limitSpinner.setValue(0); // Reset the spinner to 0
            notifyCheckbox.setSelected(false); // Uncheck notify
            npcData.setNotifyOnLimit(false); // Update npcData to reflect unchecked state
            plugin.updateOverlay();
        } else {
            npcData.setKillLimit((Integer) limitSpinner.getValue());
        }

        plugin.logger.updateNpcData(npcData);
        updatePanelDirectly();
    }

    /**
     * Refreshes the UI elements based on the current state of the npcData.
     */
    private void refreshUI()
    {
        setLimitCheckbox.setSelected(npcData.isLimitSet());
        limitSpinner.setEnabled(npcData.isLimitSet());
        notifyCheckbox.setEnabled(npcData.isLimitSet());
        revalidate();
        repaint();
    }

    /**
     * Disables or enables option controls based on whether the NPC is ignored.
     */
    private void updateOptionStateBasedOnIgnored() {
        SwingUtilities.invokeLater(() -> {
            boolean isIgnored = npcData.isIgnored();
            setLimitCheckbox.setEnabled(!isIgnored);
            limitSpinner.setEnabled(!isIgnored && npcData.isLimitSet());
            notifyCheckbox.setEnabled(!isIgnored && npcData.isLimitSet());

            setBackground(isIgnored ? new Color(50, 50, 50) : new Color(60, 60, 60));
            toggleButton.setBackground(isIgnored ? new Color(50, 50, 50) : new Color(60, 60, 60));
            toggleButton.setForeground(isIgnored ? Color.GRAY : new Color(200, 150, 0));

            revalidate();
            repaint();
        });
    }

    /**
     * Updates the parent panel directly to reflect any changes made in this component.
     */
    private void updatePanelDirectly()
    {
        Container parent = getParent();
        if (parent instanceof MonsterMonitorPanel) {
            ((MonsterMonitorPanel) parent).updatePanel();
        }
    }

    /**
     * Returns the NpcData associated with this box.
     *
     * @return The NpcData object.
     */
    public NpcData getNpcData()
    {
        return npcData;
    }

    /**
     * Checks if the dropdown options panel is currently visible.
     *
     * @return True if the dropdown is visible, otherwise false.
     */
    public boolean isDropdownVisible()
    {
        return optionsVisible;
    }

    /**
     * Sets the visibility of the dropdown options panel to the specified state.
     *
     * @param visible True to make the dropdown visible, false to hide it.
     */
    public void setDropdownVisible(boolean visible)
    {
        if (visible != optionsVisible)
        {
            toggleOptionsVisibility();
        }
    }
}

package com.monstermonitor;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.api.Client;
import net.runelite.api.Player;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.io.*;
import java.lang.reflect.Type;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * The MonsterMonitorLogger class is responsible for logging and managing data related to NPC kills.
 * It handles reading from and writing to log files specific to each player,
 * maintains the current state of the tracked NPCs, and handles NPC ignore/monitor states.
 */
public class MonsterMonitorLogger {
	private static final Logger logger = LoggerFactory.getLogger(MonsterMonitorLogger.class);
	private static final String BASE_LOG_DIR = System.getProperty("user.home") + "/.runelite/monstermonitor";
	private final Map<String, NpcData> npcLog = Collections.synchronizedMap(new LinkedHashMap<>());
	private static final ExecutorService saveQueue = Executors.newSingleThreadExecutor();

	private String playerLogDir;
	private String logFilePath;
	private final MonsterMonitorPlugin plugin;

	@Inject
	private Client client;

	@Inject
	private Gson gson;

	@Inject
	public MonsterMonitorLogger(MonsterMonitorPlugin plugin) {
		this.plugin = plugin;
	}

	/**
	 * Initializes the logger, creating directories and loading logs.
	 */
	public void initialize() {
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null) {
			return; // Exit early if the player is not yet initialized
		}

		String playerName = localPlayer.getName();
		playerLogDir = BASE_LOG_DIR + "/" + playerName;
		logFilePath = playerLogDir + "/monster_monitor_log.json";

		File directory = new File(playerLogDir);
		if (!directory.exists()) {
			directory.mkdirs(); // Create the directory if it doesn't exist
		}

		createEmptyFileIfNotExists(logFilePath);
		loadLog(); // Load existing data
	}

	private void createEmptyFileIfNotExists(String filePath) {
		File file = new File(filePath);
		if (!file.exists()) {
			try {
				file.createNewFile();
			} catch (IOException e) {
				logger.error("Failed to create log file at {}", filePath, e);
			}
		}
	}

	/**
	 * Loads the NPC log from the file, creating the file if it doesn't exist.
	 * Initializes missing fields for compatibility.
	 */
	public void loadLog() {
		if (logFilePath == null) {
			return;
		}

		File logFile = new File(logFilePath);

		synchronized (npcLog) {
			// Create file if it doesn't exist
			if (!logFile.exists()) {
				createEmptyFileIfNotExists(logFilePath);
			}

			try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
				Type type = new TypeToken<Map<String, NpcData>>() {}.getType();
				Map<String, NpcData> loadedLog = gson.fromJson(reader, type);

				if (loadedLog != null) {
					loadedLog.forEach((npcName, npcData) -> npcLog.put(npcName, ensureNpcDataCompatibility(npcData)));
				}
			} catch (IOException e) {
				logger.error("Failed to load log data from {}", logFilePath, e);
			}
		}

		plugin.updateOverlayVisibility();
	}

	/**
	 * Ensures the compatibility of NpcData by initializing missing fields.
	 *
	 * @param npcData The NpcData to validate.
	 * @return A validated and compatible NpcData object.
	 */
	private NpcData ensureNpcDataCompatibility(NpcData npcData) {
		if (npcData.getKillLimit() == 0) npcData.setKillLimit(10);
		if (npcData.getKillCountForLimit() == 0) npcData.resetKillCountForLimit();
		if (!npcData.isLimitSet()) npcData.setLimitSet(false);
		if (!npcData.isIgnored()) npcData.setIgnored(false);
		if (!npcData.isNotifyOnLimit()) npcData.setNotifyOnLimit(false);
		return npcData;
	}

	/**
	 * Logs the death of an NPC, updating its kill count and queuing a save operation.
	 *
	 * @param npcName the name of the NPC
	 */
	public void logDeath(String npcName) {
		synchronized (npcLog) {
			NpcData npcData = npcLog.computeIfAbsent(npcName, NpcData::new);

			if (npcData.isIgnored()) {
				return; // Skip ignored NPCs
			}

			npcData.incrementKillCount();
			npcLog.remove(npcName);
			npcLog.put(npcName, npcData);
		}
		saveLogAsync();
		plugin.updateOverlay();
	}

	/**
	 * Saves the log asynchronously using a sequential processing queue.
	 */
	public void saveLogAsync() {
		saveQueue.submit(this::saveLog);
	}

	/**
	 * Saves the NPC log to disk in a thread-safe manner.
	 */
	public void saveLog() {
		synchronized (npcLog) {
			if (logFilePath == null) {
				return;
			}

			try (BufferedWriter writer = new BufferedWriter(new FileWriter(logFilePath))) {
				gson.toJson(npcLog, writer);
			} catch (IOException e) {
				logger.error("Failed to save log data to {}", logFilePath, e);
			}
		}
	}

	/**
	 * Retrieves the current NPC log.
	 *
	 * @return a map containing the NPC log data
	 */
	public synchronized Map<String, NpcData> getNpcLog() {
		return new LinkedHashMap<>(npcLog);
	}

	/**
	 * Removes an NPC from the log by name.
	 *
	 * @param npcName the name of the NPC to remove
	 */
	public void removeNpcFromLog(String npcName) {
		synchronized (npcLog) {
			npcLog.remove(npcName);
		}
	}

	/**
	 * Updates an NPC's data in the log and queues a save operation.
	 *
	 * @param npcData the updated NPC data
	 */
	public void updateNpcData(NpcData npcData) {
		synchronized (npcLog) {
			npcLog.put(npcData.getNpcName(), npcData);
		}
		saveLogAsync();
		plugin.updateOverlayVisibility();
	}
}

package com.monstermonitor;

import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuOpened;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;

/**
 * Handles adding custom menu entries for Monster Monitor.
 * Manages the creation of "Monitor" and "Ignore" options.
 */
public class MonsterMonitorMenuHandler {
    private static final String MONITOR_OPTION = "Monitor";
    private static final String IGNORE_OPTION = "Ignore";
    private final MonsterMonitorPlugin plugin;
    private final MonsterMonitorLogger logger;
    private final MonsterMonitorPanel panel;
    private final MonsterMonitorConfig config;
    private final Client client;

    @Inject
    public MonsterMonitorMenuHandler(MonsterMonitorPlugin plugin, MonsterMonitorLogger logger, Client client, MonsterMonitorPanel panel, MonsterMonitorConfig config) {
        this.plugin = plugin;
        this.logger = logger;
        this.panel = panel;
        this.config = config;
        this.client = client;
    }

    /**
     * Inserts custom options when the target is an NPC.
     *
     * @param event The event triggered when the menu is opened.
     */
    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        if (!config.showRightClickMenuEntries()) {
            return; // Exit early if the user has disabled the right-click menu entries
        }

        MenuEntry[] menuEntries = event.getMenuEntries();
        NPC targetNpc = findTargetNpc(menuEntries);

        if (targetNpc != null) {
            addCustomMenuOptions(targetNpc);
        }
    }

    /**
     * Finds the target NPC from the menu entries.
     *
     * @param menuEntries The array of menu entries.
     * @return The target NPC if found, otherwise null.
     */
    private NPC findTargetNpc(MenuEntry[] menuEntries) {
        for (MenuEntry menuEntry : menuEntries) {
            MenuAction menuType = menuEntry.getType();
            NPC target = menuEntry.getNpc();

            if (target != null && isValidMenuType(menuType, menuEntry.getOption(), target.getCombatLevel())) {
                return target;
            }
        }
        return null;
    }

    /**
     * Checks if a menu type and option are valid for adding custom entries.
     *
     * @param menuType The type of the menu.
     * @param optionText The option text from the menu.
     * @param combatLevel The combat level of the NPC.
     * @return True if the menu type and option are valid for adding entries, otherwise false.
     */
    private boolean isValidMenuType(MenuAction menuType, String optionText, int combatLevel) {
        return (menuType == MenuAction.EXAMINE_NPC || menuType == MenuAction.NPC_SECOND_OPTION || menuType == MenuAction.NPC_FIFTH_OPTION)
                && optionText.equals("Attack")
                && combatLevel > 0;
    }

    /**
     * Adds custom "Monitor" and "Ignore" menu options for the specified NPC.
     *
     * @param npc The NPC to add the options for.
     */
    private void addCustomMenuOptions(NPC npc) {
        String npcName = npc.getName();
        int combatLevel = npc.getCombatLevel();

        if (npcName == null) {
            return;
        }

        NpcData npcData = logger.getNpcLog().get(npcName);

        if (shouldAddMonitorOption(npcData)) {
            addMonitorMenuOption(npcName, combatLevel);
        }

        if (shouldAddIgnoreOption(npcData)) {
            addIgnoreMenuOption(npcName, combatLevel);
        }
    }

    /**
     * Determines if the "Monitor" option should be added for the NPC.
     *
     * @param npcData The data of the NPC.
     * @return True if the "Monitor" option should be added, otherwise false.
     */
    private boolean shouldAddMonitorOption(NpcData npcData) {
        return npcData == null || (!npcData.isLimitSet() && !npcData.isIgnored());
    }

    /**
     * Adds the "Monitor" option to the menu.
     *
     * @param npcName The name of the NPC.
     * @param combatLevel The combat level of the NPC.
     */
    private void addMonitorMenuOption(String npcName, int combatLevel) {
        client.getMenu()
                .createMenuEntry(1)
                .setOption(MONITOR_OPTION)
                .setTarget(npcName + " (level-" + combatLevel + ")")
                .setType(MenuAction.RUNELITE_HIGH_PRIORITY)
                .onClick(e -> handleMonitorAction(npcName));
    }

    /**
     * Determines if the "Ignore" option should be added for the NPC.
     *
     * @param npcData The data of the NPC.
     * @return True if the "Ignore" option should be added, otherwise false.
     */
    private boolean shouldAddIgnoreOption(NpcData npcData) {
        return npcData == null || (!npcData.isIgnored() && !npcData.isLimitSet());
    }

    /**
     * Adds the "Ignore" option to the menu.
     *
     * @param npcName The name of the NPC.
     * @param combatLevel The combat level of the NPC.
     */
    private void addIgnoreMenuOption(String npcName, int combatLevel) {
        client.getMenu()
                .createMenuEntry(1)
                .setOption(IGNORE_OPTION)
                .setTarget(npcName + " (level-" + combatLevel + ")")
                .setType(MenuAction.RUNELITE_HIGH_PRIORITY)
                .onClick(e -> handleIgnoreAction(npcName));
    }

    /**
     * Handles the "Monitor" action from the menu.
     *
     * @param npcName The name of the NPC to monitor.
     */
    private void handleMonitorAction(String npcName) {
        plugin.setNpcToMonitor(npcName, 10); // Default to a kill limit of 10 when monitoring
        NpcData npcData = logger.getNpcLog().get(npcName);
        if (npcData != null) {
            npcData.setLimitSet(true); // Make sure the checkbox is checked
            logger.updateNpcData(npcData);
            plugin.updateOverlay();
            panel.updatePanel();
        }
    }

    /**
     * Handles the "Ignore" action from the menu.
     *
     * @param npcName The name of the NPC to ignore.
     */
    private void handleIgnoreAction(String npcName) {
        plugin.setNpcToIgnore(npcName);
    }
}

package com.monstermonitor;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import java.awt.*;

/**
 * The MonsterMonitorConfig interface defines the configuration options for Monster Monitor.
 * It allows users to customize settings such as progress bar colors, overlay visibility,
 * and kill limit notifications.
 */
@ConfigGroup("monster monitor")
public interface MonsterMonitorConfig extends Config {

    /**
     * Configures whether the Monster Monitor overlay should be displayed.
     *
     * @return true if the overlay should be shown, false otherwise
     */
    @ConfigItem(
            keyName = "showOverlay",
            name = "Show Overlay",
            description = "Toggle to display or hide the Monster Monitor overlay"
    )
    default boolean showOverlay() {
        return true; // Default to showing the overlay
    }

    /**
     * Configures whether a notification should be sent when a kill limit is reached.
     *
     * @return true if notifications should be sent when the kill limit is reached, false otherwise
     */
    @ConfigItem(
            keyName = "notifyOnLimit",
            name = "Notify on Kill Limit",
            description = "Send a notification when the kill limit is reached"
    )
    default boolean notifyOnLimit() {
        return true;  // Default to notifying when the kill limit is reached
    }

    /**
     * Configures whether chat notifications should be shown when kill limits are reached.
     *
     * @return true if chat notifications should be shown, false otherwise
     */
    @ConfigItem(
            keyName = "showChatNotifications",
            name = "Show Chat Notifications",
            description = "Show notifications about reaching kill limits in the chat window."
    )
    default boolean showChatNotifications() {
        return true; // Default to showing chat notifications
    }

    /**
     * Configures the custom notification message displayed when a kill limit is reached.
     *
     * @return the custom notification message
     */
    @ConfigItem(
            keyName = "customNotificationMessage",
            name = "Custom Notification Message",
            description = "Lets you personalize the message displayed when a kill limit is reached. add {npc} for npc name"
    )
    default String customNotificationMessage() {
        return "Kill limit reached for {npc}"; // Default message
    }

    /**
     * Configures whether sound alerts should be enabled for notifications.
     *
     * @return true if sound alerts should be enabled, false otherwise
     */
    @ConfigItem(
            keyName = "enableSoundAlerts",
            name = "Enable Sound Alerts",
            description = "Enable sound alerts for notifications."
    )
    default boolean enableSoundAlerts() {
        return true; // Default to enabling sound alerts
    }

    /**
     * Configures whether right-click menu entries should be displayed.
     *
     * @return true if the right-click menu entries should be shown, false otherwise
     */
    @ConfigItem(
            keyName = "showRightClickMenuEntries",
            name = "Show Right-Click Menu Entries",
            description = "Toggle to show or hide the right-click menu entries for NPCs."
    )
    default boolean showRightClickMenuEntries() {
        return true; // Default to showing right-click menu entries
    }

    @ConfigItem(
            keyName = "showTitle",
            name = "Show Overlay Title",
            description = "Toggle the display of the overlay title"
    )
    default boolean showTitle() {
        return true;
    }
    /**
     * Configures the colors for the progress bar.
     *
     * @return the start color of the progress bar.
     */
    @ConfigItem(
            keyName = "progressBarStartColor",
            name = "Progress Bar Start Color",
            description = "Select the color for the start of the progress bar.",
            position = 4
    )
    default Color progressBarStartColor() {
        return new Color(139, 0, 0); // Dark red
    }

    /**
     * Configures the midpoint color for the progress bar.
     *
     * @return the midpoint color of the progress bar.
     */
    @ConfigItem(
            keyName = "progressBarMidColor",
            name = "Progress Bar Midpoint Color",
            description = "Select the color for the midpoint of the progress bar.",
            position = 5
    )
    default Color progressBarMidColor() {
        return new Color(204, 102, 0); // Dark orange
    }

    /**
     * Configures the end color for the progress bar.
     *
     * @return the end color of the progress bar.
     */
    @ConfigItem(
            keyName = "progressBarEndColor",
            name = "Progress Bar End Color",
            description = "Select the color for the end of the progress bar.",
            position = 6
    )
    default Color progressBarEndColor() {
        return new Color(0, 128, 0); // Dark green
    }
    /**
     * Adds a button to reset progress bar colors to their default values.
     */
    @ConfigItem(
            keyName = "resetProgressBarColors",
            name = "Reset Colors",
            description = "Click to reset all progress bar colors to their default values.",
            position = 10
    )
    default Button resetProgressBarColors() {
        return new Button("Reset Colors");
    }

    /**
     * Configures whether the popup notification should be displayed when a kill limit is reached.
     *
     * @return true if the popup should be shown, false otherwise
     */
    @ConfigItem(
            keyName = "showPopup",
            name = "Show Popup",
            description = "Display a popup when the kill limit is reached"
    )
    default boolean showPopup() {
        return true;
    }
}

package com.monstermonitor;

import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.WidgetNode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetModalMode;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * Handles displaying a modal popup when a player reaches the kill limit for an NPC.
 */
public class MonsterMonitorPopup {
    private static final int FIXED_CLASSIC_LAYOUT = (548 << 16) | 13;
    private static final int RESIZABLE_CLASSIC_LAYOUT = (161 << 16) | 13;
    private static final int RESIZABLE_MODERN_LAYOUT = (164 << 16) | 13;
    private static final int INTERFACE_GROUP_ID = 660;
    private static final int SCRIPT_ID = 3343;

    private WidgetNode popupWidgetNode;
    private final ConcurrentLinkedQueue<String> queuedPopups = new ConcurrentLinkedQueue<>();

    private final Client client;
    private final ClientThread clientThread;
    private final MonsterMonitorConfig config;
    private volatile boolean isDisplayingPopup = false;

    @Inject
    public MonsterMonitorPopup(Client client, ClientThread clientThread, MonsterMonitorConfig config) {
        this.client = client;
        this.clientThread = clientThread;
        this.config = config;
    }

    /**
     * Triggers a popup for the given NPC name when its kill limit is reached.
     * @param npcName The name of the NPC.
     */
    public void showPopup(String npcName) {
        if (!config.showPopup()) {
            return;
        }

        queuedPopups.add(npcName);
        if (!isDisplayingPopup) {
            clientThread.invokeLater(this::displayNextPopup);
        }
    }

    /**
     * Displays the next popup in the queue.
     */
    private void displayNextPopup() {
        if (queuedPopups.isEmpty()) {
            isDisplayingPopup = false;
            return;
        }

        isDisplayingPopup = true;
        String npcName = queuedPopups.poll();

        clientThread.invokeLater(() -> {
            try {
                int componentId = getParentComponentId();
                Widget parentWidget = client.getWidget(componentId);

                if (parentWidget == null) {
                    isDisplayingPopup = false;
                    return;
                }

                popupWidgetNode = client.openInterface(componentId, INTERFACE_GROUP_ID, WidgetModalMode.MODAL_CLICKTHROUGH);

                if (popupWidgetNode == null) {
                    isDisplayingPopup = false;
                    return;
                }

                client.runScript(SCRIPT_ID, "Monster Monitor", "You have reached the kill limit for " + npcName, -1);
                clientThread.invokeLater(this::tryClearMessage);
            } catch (IllegalStateException ex) {
                isDisplayingPopup = false;
                clientThread.invokeLater(this::tryClearMessage);
            }
        });
    }

    /**
     * Determines the correct parent component ID based on the UI layout.
     */
    private int getParentComponentId() {
        if (client.isResized()) {
            int sidePanel = client.getVarbitValue(Varbits.SIDE_PANELS);
            return (sidePanel == 1) ? RESIZABLE_MODERN_LAYOUT : RESIZABLE_CLASSIC_LAYOUT;
        }
        return FIXED_CLASSIC_LAYOUT;
    }

    /**
     * Handles the fade-out effect and removal of the popup.
     */
    private boolean tryClearMessage() {
        Widget w = client.getWidget(INTERFACE_GROUP_ID, 1);

        if (w != null && w.getWidth() > 0) {
            return false;
        }

        try {
            if (popupWidgetNode != null) {
                client.closeInterface(popupWidgetNode, true);
            }
        } catch (Exception ignored) {}

        popupWidgetNode = null;
        isDisplayingPopup = false;

        if (!queuedPopups.isEmpty()) {
            clientThread.invokeLater(this::displayNextPopup);
        }
        return true;
    }

    /**
     * Properly clears all popups and resets the queue on shutdown.
     */
    public void shutdownPopup() {
        queuedPopups.clear();
        isDisplayingPopup = false;

        clientThread.invokeLater(() -> {
            try {
                if (popupWidgetNode != null) {
                    client.closeInterface(popupWidgetNode, true);
                }
            } catch (Exception ignored) {}
            popupWidgetNode = null;
        });
    }
}

package com.monstermonitor;

import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.plaf.basic.BasicScrollBarUI;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;

/**
 * Represents the main panel of Monster Monitor.
 * This panel displays a list of NPCs that the player has been tracking, including their kill counts and
 * various options for managing the tracked data, including ignore/monitor status.
 * The panel also includes a title, total kill count display, and scrollable list of NPCs.
 */
public class MonsterMonitorPanel extends PluginPanel {
    private final MonsterMonitorPlugin plugin;
    private final MonsterMonitorSearchBar searchBar;
    private final JPanel npcListPanel;
    private final JPanel ignoredNpcListPanel;
    private final JPanel fillerBox; // The filler box at the bottom
    private JLabel totalKillCountLabel;
    private final Map<NpcData, Boolean> dropdownStates = new HashMap<>(); // Stores the state of dropdowns
    private String searchText = "";

    @Inject
    public MonsterMonitorPanel(MonsterMonitorPlugin plugin) {
        this.plugin = plugin;

        setLayout(new BorderLayout());
        Color backgroundColor = new Color(45, 45, 45);
        Color textColor = new Color(200, 200, 200);
        setBackground(backgroundColor);

        // Title Panel setup
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBackground(backgroundColor);

        JLabel titleLabel = new JLabel("Monster Monitor", SwingConstants.CENTER);
        titleLabel.setFont(new Font("Arial", Font.BOLD, 14));
        titleLabel.setForeground(new Color(200, 150, 0));
        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);

        ImageIcon icon = new ImageIcon(getClass().getResource("/net/runelite/client/plugins/MonsterMonitor/icon.png"));
        titleLabel.setIcon(icon);

        totalKillCountLabel = new JLabel("Total kills: 0");
        totalKillCountLabel.setFont(new Font("Arial", Font.BOLD, 12));
        totalKillCountLabel.setForeground(textColor);
        totalKillCountLabel.setHorizontalAlignment(SwingConstants.CENTER);

        titlePanel.add(titleLabel, BorderLayout.NORTH);
        titlePanel.add(totalKillCountLabel, BorderLayout.SOUTH);

        // Add the title panel at the top
        add(titlePanel, BorderLayout.NORTH);

        // Initialize the search bar and add it below the title panel
        searchBar = new MonsterMonitorSearchBar(searchText -> {
            this.searchText = searchText.toLowerCase();
            updatePanel();
        });
        add(searchBar, BorderLayout.CENTER);

        // NPC List Panels setup
        this.npcListPanel = new JPanel(new GridBagLayout());
        this.npcListPanel.setBackground(backgroundColor);
        this.npcListPanel.setBorder(BorderFactory.createEmptyBorder());
        this.ignoredNpcListPanel = new JPanel(new GridBagLayout());
        this.ignoredNpcListPanel.setBackground(backgroundColor);
        add(npcListPanel, BorderLayout.SOUTH);

        SwingUtilities.invokeLater(() -> {
            Component parent = this.getParent();
            while (parent != null && !(parent instanceof JScrollPane)) {
                parent = parent.getParent();
            }
            if (parent instanceof JScrollPane) {
                JScrollPane scrollPane = (JScrollPane) parent;
                scrollPane.getVerticalScrollBar().setUI(new CustomScrollBarUI(new Color(200, 150, 0)));
                scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));
                scrollPane.getVerticalScrollBar().setUnitIncrement(6);
            }
        });

        this.fillerBox = new JPanel();
        fillerBox.setBackground(backgroundColor); // Same background as the panel (invisible)
        fillerBox.setPreferredSize(new Dimension(0, 200)); // Initial height is large
    }

    /**
     * Captures the current dropdown state for all NPC panels before refreshing.
     */
    private void captureDropdownStates() {
        Component[] components = npcListPanel.getComponents();
        for (Component component : components) {
            if (component instanceof MonsterMonitorBox) {
                MonsterMonitorBox box = (MonsterMonitorBox) component;
                NpcData npcData = box.getNpcData();
                dropdownStates.put(npcData, box.isDropdownVisible());
            }
        }
    }

    /**
     * Restores the dropdown states after the panel is refreshed.
     */
    private void restoreDropdownStates() {
        Component[] components = npcListPanel.getComponents();
        for (Component component : components) {
            if (component instanceof MonsterMonitorBox) {
                MonsterMonitorBox box = (MonsterMonitorBox) component;
                NpcData npcData = box.getNpcData();
                box.setDropdownVisible(dropdownStates.getOrDefault(npcData, false));
            }
        }
    }

    /**
     * Updates the panel by refreshing the list of tracked and ignored NPCs.
     */
    public void updatePanel() {
        SwingUtilities.invokeLater(() -> {
            captureDropdownStates();

            npcListPanel.removeAll();
            ignoredNpcListPanel.removeAll();

            List<NpcData> trackedNpcs = new ArrayList<>(plugin.getTrackedNpcs());
            List<NpcData> ignoredNpcs = new ArrayList<>();

            for (NpcData npcData : trackedNpcs) {
                if (npcData.isIgnored()) {
                    ignoredNpcs.add(npcData);
                }
            }

            // Apply search filter to both tracked and ignored NPCs
            trackedNpcs.removeIf(npcData -> !npcData.getNpcName().toLowerCase().contains(searchText));
            ignoredNpcs.removeIf(npcData -> !npcData.getNpcName().toLowerCase().contains(searchText));

            Collections.reverse(trackedNpcs);
            Collections.reverse(ignoredNpcs);

            int totalKills = 0;
            GridBagConstraints gbc = new GridBagConstraints();
            gbc.gridx = 0;
            gbc.gridy = 0;
            gbc.weightx = 1.0;
            gbc.fill = GridBagConstraints.HORIZONTAL;
            gbc.insets = new Insets(5, 0, 5, 0);

            for (NpcData npcData : trackedNpcs) {
                if (!npcData.isIgnored()) {
                    MonsterMonitorBox npcPanel = new MonsterMonitorBox(plugin, npcData, dropdownStates.getOrDefault(npcData, false));
                    totalKills += npcData.getTotalKillCount();
                    npcListPanel.add(npcPanel, gbc);
                    addContextMenuToNpcPanel(npcPanel, npcData);
                    gbc.gridy++;
                }
            }

            if (!ignoredNpcs.isEmpty()) {
                JLabel ignoredLabel = new JLabel("Ignored NPCs", SwingConstants.CENTER);
                ignoredLabel.setForeground(new Color(180, 180, 180));
                ignoredLabel.setFont(new Font("Arial", Font.BOLD, 12));
                npcListPanel.add(ignoredLabel, gbc);
                gbc.gridy++;

                for (NpcData npcData : ignoredNpcs) {
                    MonsterMonitorBox npcPanel = new MonsterMonitorBox(plugin, npcData, dropdownStates.getOrDefault(npcData, false));
                    npcPanel.setBackground(new Color(50, 50, 50));
                    npcListPanel.add(npcPanel, gbc);
                    addContextMenuToNpcPanel(npcPanel, npcData);
                    gbc.gridy++;
                }
            }

            adjustFillerBox(trackedNpcs.size() + ignoredNpcs.size());
            npcListPanel.add(fillerBox, gbc);

            totalKillCountLabel.setText("Total kills: " + totalKills);
            npcListPanel.revalidate();
            npcListPanel.repaint();

            restoreDropdownStates();
        });
    }

    /**
     * Adds a context menu to the given NPC panel.
     */
    private void addContextMenuToNpcPanel(MonsterMonitorBox npcPanel, NpcData npcData) {
        JPopupMenu contextMenu = createContextMenu(npcData);
        npcPanel.setComponentPopupMenu(contextMenu);
        npcPanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    contextMenu.show(npcPanel, e.getX(), e.getY());
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    contextMenu.show(npcPanel, e.getX(), e.getY());
                }
            }
        });
    }

    private void adjustFillerBox(int npcCount) {
        int minHeight = 100;
        int maxHeight = 400;

        if (npcCount > 15) {
            fillerBox.setPreferredSize(new Dimension(0, 0));
        } else {
            int dynamicHeight = maxHeight - (npcCount * 15);
            dynamicHeight = Math.max(minHeight, dynamicHeight);
            fillerBox.setPreferredSize(new Dimension(0, dynamicHeight));
        }

        fillerBox.revalidate();
        fillerBox.repaint();
    }

    private JPopupMenu createContextMenu(NpcData npcData) {
        JPopupMenu contextMenu = new JPopupMenu();

        if (!npcData.isIgnored()) {
            JMenuItem ignoreMenuItem = new JMenuItem("Ignore NPC");
            ignoreMenuItem.addActionListener(ev -> {
                npcData.setIgnored(true);
                plugin.logger.updateNpcData(npcData);
                plugin.updateOverlay();
                updatePanel();
            });
            contextMenu.add(ignoreMenuItem);
        }

        JMenu monitorMenu = new JMenu("Monitor");
        String[] presets = {"1", "10", "100", "1000"};
        for (String preset : presets) {
            JMenuItem presetItem = new JMenuItem(preset);
            presetItem.addActionListener(ev -> {
                npcData.setKillLimit(Integer.parseInt(preset));
                npcData.setLimitSet(true); // Ensure the Set Limit checkbox is checked
                npcData.setIgnored(false);
                plugin.logger.updateNpcData(npcData);
                plugin.updateOverlay();
                updatePanel();
            });
            monitorMenu.add(presetItem);
        }

        // Add custom limit option
        JMenuItem customMonitorItem = new JMenuItem("Custom...");
        customMonitorItem.addActionListener(ev -> {
            String input = JOptionPane.showInputDialog("Enter custom kill limit:");
            try {
                int customLimit = Integer.parseInt(input);
                npcData.setKillLimit(customLimit);
                npcData.setLimitSet(true); // Ensure the Set Limit checkbox is checked
                npcData.setIgnored(false);
                plugin.logger.updateNpcData(npcData);
                plugin.updateOverlay();
                updatePanel();
            } catch (NumberFormatException ignored) {
                // Handle invalid input silently
            }
        });
        monitorMenu.add(customMonitorItem);
        contextMenu.add(monitorMenu);

        JMenuItem resetMenuItem = new JMenuItem("Clear NPC Data");
        resetMenuItem.addActionListener(ev -> {
            plugin.logger.removeNpcFromLog(npcData.getNpcName());
            plugin.logger.saveLog();
            plugin.updateOverlay();
            updatePanel();
        });

        JMenuItem resetKillLimitMenuItem = new JMenuItem("Reset Kill Limit");
        resetKillLimitMenuItem.addActionListener(ev -> {
            npcData.setKillLimit(0);
            npcData.setLimitSet(false);
            npcData.resetKillCountForLimit();
            plugin.logger.updateNpcData(npcData);
            plugin.updateOverlay();
            updatePanel();
        });

        contextMenu.add(resetMenuItem);
        contextMenu.add(resetKillLimitMenuItem);

        // "Edit NPC Data" option to edit NPC Data from log
        JMenuItem editNpcDataMenuItem = new JMenuItem("Edit NPC Data");
        editNpcDataMenuItem.addActionListener(ev -> showEditNpcDataDialog(npcData));
        contextMenu.add(editNpcDataMenuItem);

        // Add Expand All and Collapse All
        JMenuItem collapseAllItem = new JMenuItem("Collapse All");
        collapseAllItem.addActionListener(this::collapseAllDropdowns);

        JMenuItem expandAllItem = new JMenuItem("Expand All");
        expandAllItem.addActionListener(this::expandAllDropdowns);

        contextMenu.addSeparator();
        contextMenu.add(collapseAllItem);
        contextMenu.add(expandAllItem);

        return contextMenu;
    }

    private void showEditNpcDataDialog(NpcData npcData) {
        JPanel panel = new JPanel(new GridLayout(4, 2));

        // Create input fields with current values prefilled
        JLabel npcNameField = new JLabel(String.valueOf(npcData.getNpcName()));
        JTextField totalKillsField = new JTextField(String.valueOf(npcData.getTotalKillCount()));
        JTextField killLimitField = new JTextField(String.valueOf(npcData.getKillLimit()));
        JTextField killsForLimitField = new JTextField(String.valueOf(npcData.getKillCountForLimit()));

        // Add labels and fields to the panel
        panel.add(new JLabel(getName()));
        panel.add(npcNameField);
        panel.add(new JLabel("Total Kills:"));
        panel.add(totalKillsField);
        panel.add(new JLabel("Kill Limit:"));
        panel.add(killLimitField);
        panel.add(new JLabel("Kills For Limit:"));
        panel.add(killsForLimitField);

        int result = JOptionPane.showConfirmDialog(null, panel, "Edit NPC Data", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

        if (result == JOptionPane.OK_OPTION) {
            try {
                // Parse and set new values if valid
                int totalKills = Integer.parseInt(totalKillsField.getText());
                int killLimit = Integer.parseInt(killLimitField.getText());
                int killsForLimit = Integer.parseInt(killsForLimitField.getText());

                npcData.setTotalKillCount(totalKills);
                npcData.setKillLimit(killLimit);
                npcData.setKillCountForLimit(killsForLimit);

                plugin.logger.updateNpcData(npcData);
                plugin.updateOverlay();
                updatePanel();  // Refresh the panel to show updated values

            } catch (NumberFormatException e) {
                JOptionPane.showMessageDialog(null, "Please enter valid numbers.", "Invalid Input", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    private void collapseAllDropdowns(ActionEvent e) {
        for (Component component : npcListPanel.getComponents()) {
            if (component instanceof MonsterMonitorBox) {
                MonsterMonitorBox box = (MonsterMonitorBox) component;
                box.setDropdownVisible(false);
            }
        }
        npcListPanel.revalidate();
        npcListPanel.repaint();
    }

    private void expandAllDropdowns(ActionEvent e) {
        for (Component component : npcListPanel.getComponents()) {
            if (component instanceof MonsterMonitorBox) {
                MonsterMonitorBox box = (MonsterMonitorBox) component;
                box.setDropdownVisible(true);
            }
        }
        npcListPanel.revalidate();
        npcListPanel.repaint();
    }

    public static class CustomScrollBarUI extends BasicScrollBarUI {
        private final Color arrowColor;

        public CustomScrollBarUI(Color arrowColor) {
            this.arrowColor = arrowColor;
        }

        @Override
        protected void configureScrollBarColors() {
            this.thumbColor = new Color(200, 150, 0);
            this.trackColor = new Color(30, 30, 30);
        }

        @Override
        protected JButton createDecreaseButton(int orientation) {
            return createZeroButton();
        }

        @Override
        protected JButton createIncreaseButton(int orientation) {
            return createZeroButton();
        }

        private JButton createZeroButton() {
            JButton button = new JButton();
            button.setPreferredSize(new Dimension(0, 0));
            return button;
        }
    }
}

package com.monstermonitor;

import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

/**
 * Represents the overlay used in Monster Monitor.
 * This overlay displays information about tracked NPCs, such as their names and the number of kills
 * towards a specified kill limit, along with a dynamic progress bar.
 */
public class MonsterMonitorOverlay extends Overlay {

    private static final int NAME_CHARACTER_LIMIT = 16;  // Define a character limit for truncation
    private final AtomicReference<List<NpcData>> trackedNpcs = new AtomicReference<>(Collections.emptyList()); // Thread-safe list of tracked NPCs

    @Getter
    private final Client client;
    private final MonsterMonitorPlugin plugin;
    private final MonsterMonitorConfig config;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    private ClientThread clientThread;

    /**
     * Constructs the MonsterMonitorOverlay and initializes the overlay's properties.
     *
     * @param client The RuneLite client instance.
     * @param plugin The MonsterMonitorPlugin instance that this overlay is part of.
     * @param config The MonsterMonitorConfig instance for user settings.
     */
    @Inject
    public MonsterMonitorOverlay(Client client, MonsterMonitorPlugin plugin, MonsterMonitorConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_CENTER);
        setLayer(OverlayLayer.ABOVE_SCENE); // Layer the overlay above widgets
        setResizable(true); // Allow users to resize the overlay
        setMovable(true); // Allow users to move the overlay
        setPriority(55); // Increase priority slightly for better visibility

        // Configure the panelComponent for the overlay
        panelComponent.setBackgroundColor(new Color(45, 45, 45, 200)); // Dark gray with semi-transparency
        panelComponent.setPreferredSize(new Dimension(160, 0)); // Set preferred width for the overlay
        panelComponent.setBorder(new Rectangle(5, 5, 5, 5)); // Adds padding around the content
    }

    /**
     * Updates the list of tracked NPCs to be displayed on the overlay.
     * Filters out any NPCs that are currently ignored before updating.
     *
     * @param trackedNpcs The list of NPCs to be tracked and displayed.
     */
    public void updateOverlayData(List<NpcData> trackedNpcs) {
        clientThread.invokeLater(() -> {
            List<NpcData> filteredNpcs = trackedNpcs.stream()
                    .filter(npcData -> !npcData.isIgnored())
                    .collect(Collectors.toList());

            Collections.reverse(filteredNpcs); // Reverse the order to display the most recent NPCs first
            this.trackedNpcs.set(filteredNpcs); // Atomically update the tracked NPCs
        });
    }

    /**
     * Renders the overlay on the game screen, displaying tracked NPCs and their kill counts.
     *
     * @param graphics The Graphics2D object used for drawing the overlay.
     * @return The dimension of the rendered overlay.
     */
    @Override
    public Dimension render(Graphics2D graphics) {
        Dimension preferredSize = getPreferredSize();
        int overlayWidth = (preferredSize != null && preferredSize.width > 0) ? preferredSize.width : 160;
        panelComponent.getChildren().clear(); // Clear previous overlay components

        List<NpcData> currentNpcs = trackedNpcs.get();
        if (currentNpcs == null || currentNpcs.isEmpty()) {
            return null;
        }

        int yOffset = 0;
        int totalHeight = 0;

        // Calculate dynamic bar height based on the available space
        int totalBars = currentNpcs.size();
        int availableHeight = (preferredSize != null && preferredSize.height > 0) ? preferredSize.height : 0;
        int barHeight = Math.max(14, Math.min(availableHeight / (totalBars + 1), 30)); // Dynamically scale bar height

        // Render the title if enabled
        if (plugin.config.showTitle()) {
            graphics.setFont(new Font("Arial", Font.BOLD, 14));
            FontMetrics metrics = graphics.getFontMetrics();
            int titleX = (overlayWidth - metrics.stringWidth("Monster Monitor")) / 2;
            int titleY = yOffset + metrics.getAscent();

            // Draw the title
            graphics.setColor(Color.BLACK);
            graphics.drawString("Monster Monitor", titleX + 1, titleY + 1);
            graphics.setColor(new Color(200, 150, 0));
            graphics.drawString("Monster Monitor", titleX, titleY);

            yOffset += 20;
            totalHeight += 20;
        } else {
            panelComponent.getChildren().add(LineComponent.builder().left("").build());
            yOffset += 10;
            totalHeight += 10;
        }

        // Render progress bars for each tracked NPC
        for (NpcData npcData : currentNpcs) {
            if (npcData.getKillLimit() > 0) {
                drawProgressBar(graphics, npcData, overlayWidth, barHeight, yOffset);
                yOffset += barHeight + 4; // Increment yOffset for the next bar
                totalHeight += barHeight + 4; // Add bar height and spacing to total height
            }
        }

        panelComponent.setPreferredSize(new Dimension(overlayWidth, totalHeight));
        return new Dimension(overlayWidth, totalHeight);
    }

    /**
     * Draws a progress bar for a specific NPC's kill progress toward the limit.
     *
     * @param graphics     The Graphics2D object used for drawing.
     * @param npcData      The NPC data containing kill information.
     * @param overlayWidth The width of the overlay.
     * @param barHeight    The height of the progress bar.
     * @param yOffset      The vertical offset for drawing the bar.
     */
    private void drawProgressBar(Graphics2D graphics, NpcData npcData, int overlayWidth, int barHeight, int yOffset) {
        int limit = npcData.getKillLimit();
        int killsTowardLimit = npcData.getKillCountForLimit();

        // Calculate progress percentage and cap it at 100%
        double progressPercentage = Math.min(killsTowardLimit / (double) limit, 1.0);

        // Interpolate color based on custom configuration
        Color barColor = interpolateColor(progressPercentage);

        int barWidth = overlayWidth - 10;
        int startX = (overlayWidth - barWidth) / 2;

        // Draw the progress bar background (gray)
        graphics.setColor(new Color(60, 60, 60));
        graphics.fillRect(startX, yOffset, barWidth, barHeight);

        // Draw the filled progress bar
        int filledWidth = (int) (progressPercentage * barWidth);
        graphics.setColor(barColor);
        graphics.fillRect(startX, yOffset, filledWidth, barHeight);

        // Draw a border around the progress bar
        graphics.setColor(Color.BLACK);
        graphics.drawRect(startX, yOffset, barWidth, barHeight);

        // Draw NPC name and progress text
        drawText(graphics, npcData, killsTowardLimit, limit, overlayWidth, startX, yOffset, barHeight, barWidth);
    }

    /**
     * Interpolates between three colors (customizable) based on a ratio.
     * The color transitions from the start color (0%) to the midpoint color (50%) to the end color (100%).
     *
     * @param ratio The progress ratio (0.0 to 1.0) used to determine the interpolated color.
     * @return The interpolated color corresponding to the given ratio.
     */
    private Color interpolateColor(double ratio) {
        Color startColor = config.progressBarStartColor();
        Color midColor = config.progressBarMidColor();
        Color endColor = config.progressBarEndColor();

        Color interpolatedColor;
        if (ratio <= 0.5) {
            // Interpolate between Start Color and Midpoint Color
            interpolatedColor = interpolate(startColor, midColor, ratio * 2);
        } else {
            // Interpolate between Midpoint Color and End Color
            interpolatedColor = interpolate(midColor, endColor, (ratio - 0.5) * 2);
        }

        return interpolatedColor;
    }

    /**
     * Interpolates between two colors based on a given ratio.
     *
     * @param startColor The starting color.
     * @param endColor   The ending color.
     * @param ratio      The interpolation ratio (0.0 to 1.0).
     * @return The interpolated color.
     */
    private Color interpolate(Color startColor, Color endColor, double ratio) {
        int red = (int) (startColor.getRed() * (1 - ratio) + endColor.getRed() * ratio);
        int green = (int) (startColor.getGreen() * (1 - ratio) + endColor.getGreen() * ratio);
        int blue = (int) (startColor.getBlue() * (1 - ratio) + endColor.getBlue() * ratio);

        return new Color(red, green, blue);
    }

    /**
     * Draws the NPC name and kill progress text on top of the progress bar.
     * Dynamically adjusts font size, text alignment, and truncation based on available space.
     *
     * @param graphics         The Graphics2D object used for drawing.
     * @param npcData          The NPC data containing kill information.
     * @param killsTowardLimit The current kill count for the NPC.
     * @param limit            The kill limit for the NPC.
     * @param overlayWidth     The width of the overlay.
     * @param startX           The starting X position for the text.
     * @param yOffset          The vertical offset for drawing the text.
     * @param barHeight        The height of the progress bar.
     * @param barWidth         The width of the progress bar.
     */
    private void drawText(Graphics2D graphics, NpcData npcData, int killsTowardLimit, int limit, int overlayWidth, int startX, int yOffset, int barHeight, int barWidth) {
        // Dynamically calculate font size based on bar height
        int fontSize = Math.max(11, barHeight - 2);
        graphics.setFont(new Font("Arial", Font.BOLD, fontSize));
        FontMetrics metrics = graphics.getFontMetrics();
        int textY = yOffset + ((barHeight + metrics.getAscent() - metrics.getDescent()) / 2);

        // Calculate available width for the NPC name and progress text
        int availableTextWidth = barWidth - 10; // Leave some padding

        // NPC Name (Left-aligned)
        String npcName = truncateText(npcData.getNpcName(), availableTextWidth / 2, metrics); // Allocate half width
        graphics.setColor(Color.BLACK);
        graphics.drawString(npcName, startX + 4, textY + 1); // Shadow
        graphics.setColor(Color.LIGHT_GRAY);
        graphics.drawString(npcName, startX + 3, textY);

        // Kill Progress Text (Right-aligned)
        String progressText = formatNumberDynamic(killsTowardLimit, limit, availableTextWidth / 2, metrics);
        int textWidth = metrics.stringWidth(progressText);
        int textX = startX + barWidth - textWidth - 4; // Align to the right
        graphics.setColor(Color.BLACK);
        graphics.drawString(progressText, textX + 1, textY + 1); // Shadow
        graphics.setColor(Color.LIGHT_GRAY);
        graphics.drawString(progressText, textX, textY);
    }

    /**
     * Truncates a string to fit within a specified width, appending an ellipsis if necessary.
     *
     * @param text      The text to truncate.
     * @param maxWidth  The maximum width allowed for the text.
     * @param metrics   The FontMetrics used to measure the text width.
     */
    private String truncateText(String text, int maxWidth, FontMetrics metrics) {
        if (metrics.stringWidth(text) <= maxWidth) {
            return text;
        }

        // Truncate text and add ellipsis
        for (int i = text.length() - 1; i > 0; i--) {
            String truncated = text.substring(0, i) + "...";
            if (metrics.stringWidth(truncated) <= maxWidth) {
                return truncated;
            }
        }
        return "..."; // Fallback
    }

    /**
     * Formats the given number to a more readable string, such as 1k for 1000, without rounding up.
     *
     * @param number The number to format.
     * @return A formatted string representing the number.
     */
    private String formatNumber(int number) {
        if (number >= 1_000_000) {
            return String.format("%.1fm", number / 1_000_000.0);
        } else if (number >= 1_000) {
            return String.format("%.1fk", number / 1_000.0);
        } else {
            return Integer.toString(number);
        }
    }

    /**
     * Dynamically formats the kill progress text (e.g., "125/500" or "125K/500K").
     * Expands or truncates the text based on available width.
     *
     * @param current   The current kill count.
     * @param limit     The kill limit for the NPC.
     * @param maxWidth  The maximum width allowed for the text.
     * @param metrics   The FontMetrics used to measure the text width.
     * @return A formatted string representing the kill progress, truncated if necessary.
     */
    private String formatNumberDynamic(int current, int limit, int maxWidth, FontMetrics metrics) {
        // Check if the full text fits
        String fullText = String.format("%d/%d", current, limit);
        if (metrics.stringWidth(fullText) <= maxWidth) {
            return fullText; // Return full text if it fits
        }

        // Use shortened format (e.g., 125K/500K)
        String shortText = formatNumber(current) + "/" + formatNumber(limit);
        if (metrics.stringWidth(shortText) <= maxWidth) {
            return shortText;
        }

        return "..."; // Fallback
    }
}
package com.monstermonitor;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.Hitsplat;
import net.runelite.api.Actor;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Tracks special NPCs for Monster Monitor.
 * Special NPCs do not trigger the ActorDeath event and require monitoring their health
 * to determine when they die.
 */
public class SpecialNpcTracker {
    private final Map<Integer, NPC> trackedNpcs = new HashMap<>(); // Tracks NPCs by their unique index
    private final Set<Integer> specialNpcIds = new HashSet<>(); // Set of special NPC IDs to track
    private final Set<Integer> loggedNpcIndices = new HashSet<>(); // Prevents duplicate logging by storing NPC indices that have been logged
    private final Object lock = new Object(); // Single lock to manage synchronization for both trackedNpcs and loggedNpcIndices
    private final Client client;
    private final MonsterMonitorPlugin plugin;
    private final ClientThread clientThread;

    @Inject
    public SpecialNpcTracker(Client client, MonsterMonitorPlugin plugin, ClientThread clientThread) {
        this.client = client;
        this.plugin = plugin;
        this.clientThread = clientThread;

        // Register special NPC IDs
        registerSpecialNpc(14009); // The Hueycoatl
        registerSpecialNpc(14012); // The Final Hueycoatl
        registerSpecialNpc(13685); // Amoxliatl
        registerSpecialNpc(12166); // Duke Sucellus
        registerSpecialNpc(13013); // Blue Moon
        registerSpecialNpc(13012); // Eclipse Moon
        registerSpecialNpc(13011); // Blood Moon
    }

    /**
     * Registers a special NPC ID for tracking.
     *
     * @param npcId The ID of the special NPC.
     */
    public void registerSpecialNpc(int npcId) {
        specialNpcIds.add(npcId);
    }

    /**
     * Checks if the given NPC is a special NPC.
     *
     * @param npc The NPC to check.
     * @return True if the NPC is special, otherwise false.
     */
    public boolean isSpecialNpc(NPC npc) {
        return specialNpcIds.contains(npc.getId());
    }

    /**
     * Determines if the NPC should be logged.
     * For Huey, only log if it is in its final phase (ID 14012).
     *
     * @param npc The NPC to check.
     * @return True if the NPC should be logged, false otherwise.
     */
    private boolean shouldLogNpc(NPC npc) {
        if ("The Hueycoatl".equalsIgnoreCase(npc.getName())) {
            return npc.getId() == 14012;
        }
        return true;
    }

    /**
     * Starts tracking the health of a special NPC.
     *
     * @param npc The NPC to start tracking.
     */
    public void trackNpc(NPC npc) {
        if (isSpecialNpc(npc)) {
            synchronized (lock) {
                trackedNpcs.put(npc.getIndex(), npc);
            }
        }
    }

    /**
     * Updates the health of tracked NPCs and handles their death and respawn.
     * This method is called on every game tick.
     */
    public void updateTrackedNpcs() {
        clientThread.invokeLater(() -> {
            synchronized (lock) {
                // Create a snapshot to avoid concurrent modification issues.
                for (NPC npc : new HashSet<>(trackedNpcs.values())) {
                    if (npc == null) {
                        continue;
                    }
                    int healthRatio = npc.getHealthRatio();
                    int npcIndex = npc.getIndex();

                    // LOG DEATH: Only log if health is 0, it hasn't been logged yet, and it passes the check.
                    if (healthRatio <= 1 && !loggedNpcIndices.contains(npcIndex) && shouldLogNpc(npc)) {
                        loggedNpcIndices.add(npcIndex);
                        plugin.logDeath(npc.getName());
                    }

                    // RETRACK: If the NPC "respawns" (health > 0) and was previously logged,
                    // remove it from logged indices and add it back to tracking.
                    else if (healthRatio > 0 && loggedNpcIndices.contains(npcIndex)) {
                        loggedNpcIndices.remove(npcIndex);
                        trackNpc(npc);
                    }
                }
            }
        });
    }

    /**
     * Event listener for when a hitsplat is applied.
     * This ensures retracking of an NPC if it is hit again.
     *
     * @param event The HitsplatApplied event.
     */
    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        Actor target = event.getActor();
        Hitsplat hitsplat = event.getHitsplat();

        if (target instanceof NPC && hitsplat.isMine()) {
            NPC npc = (NPC) target;
            int npcIndex = npc.getIndex();

            synchronized (lock) {
                if (loggedNpcIndices.contains(npcIndex)) {
                    loggedNpcIndices.remove(npcIndex);
                    trackNpc(npc);
                }
            }
        }
    }

    /**
     * Clears all tracked and logged NPCs on shutdown.
     */
    public void shutdown() {
        synchronized (lock) {
            trackedNpcs.clear();
            loggedNpcIndices.clear();
        }
    }
}

package com.monstermonitor;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

/**
 * A search bar component for filtering NPCs in Monster Monitor.
 * Displays a text field with a search icon, triggering real-time filtering through the `SearchListener`.
 */
public class MonsterMonitorSearchBar extends JPanel {
    private final JTextField searchField;

    public interface SearchListener {
        void onSearch(String searchText);
    }

    public MonsterMonitorSearchBar(SearchListener listener) {
        setLayout(new BorderLayout());
        setBackground(new Color(45, 45, 45));
        setBorder(new EmptyBorder(5, 5, 5, 5));

        // Create a panel to hold the icon and search field together
        JPanel searchContainer = new JPanel(new BorderLayout());
        searchContainer.setBackground(new Color(30, 30, 30)); // Match search field background
        searchContainer.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5)); // Padding

        // Search icon
        JLabel searchIcon = new JLabel("🔍"); //Magnifying glass
        searchIcon.setForeground(new Color(200, 200, 200));
        searchIcon.setBorder(new EmptyBorder(0, 5, 0, 5));

        // Search field
        searchField = new JTextField();
        searchField.setBackground(new Color(30, 30, 30)); // Dark background for visibility
        searchField.setForeground(Color.LIGHT_GRAY);
        searchField.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5)); // Inner padding
        searchField.setCaretColor(Color.LIGHT_GRAY);

        // Listen for key releases to trigger the search
        searchField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyReleased(KeyEvent e) {
                SwingUtilities.invokeLater(() -> listener.onSearch(searchField.getText()));
            }
        });

        // Add icon and search field to the container panel
        searchContainer.add(searchIcon, BorderLayout.WEST);
        searchContainer.add(searchField, BorderLayout.CENTER);

        // Add the container panel to this search bar panel
        add(searchContainer, BorderLayout.CENTER);
    }
}

package com.monstermonitor;

import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

/**
 * Represents the data associated with an NPC being tracked by Monster Monitor.
 * This class holds information such as the NPC's name, kill counts, kill limits,
 * whether the NPC is ignored (not logged), and whether notifications should be sent when a kill limit is reached.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class NpcData
{
    private String npcName; // Name of the NPC
    private int totalKillCount; // Total kills of this NPC
    private int killCountForLimit; // Progress towards the kill limit
    private int killLimit; // The set kill limit for this NPC
    private boolean limitSet; // Flag to track if the limit is set
    private boolean notifyOnLimit; // Flag to determine if notifications should be sent when the kill limit is reached
    private boolean ignored; // Flag to indicate if the NPC is ignored (true = ignored, false = tracked)

    /**
     * Constructor to create an NpcData object with just the NPC name.
     * Initializes other fields to default values.
     *
     * @param npcName the name of the NPC
     */
    public NpcData(String npcName)
    {
        this.npcName = npcName;
        this.totalKillCount = 0;
        this.killCountForLimit = 0;
        this.killLimit = 0; // No limit by default
        this.limitSet = false; // Default to not set
        this.notifyOnLimit = false; // Default to not notify
        this.ignored = false; // Default to not ignored (tracked)
    }

    /**
     * Increment the total kill count and the kill count towards the limit.
     * This method is typically called when the player kills the tracked NPC.
     * Ignores incrementing counts if the NPC is marked as ignored.
     */
    public void incrementKillCount()
    {
        if (!ignored) {
            this.totalKillCount++;
            this.killCountForLimit++;
        }
    }

    /**
     * Reset the total kill count and progress towards the limit.
     * This method is used to reset the tracking data for the NPC, typically when the player
     * wants to restart the tracking from zero.
     */
    public void resetKillCount()
    {
        this.totalKillCount = 0;
        this.killCountForLimit = 0;
    }

    /**
     * Reset only the progress towards the limit.
     * This method resets the kill count related to the limit while retaining the total kills.
     * Useful when the player wants to set a new limit but retain overall kill history.
     */
    public void resetKillCountForLimit()
    {
        this.killCountForLimit = 0;
    }

    /**
     * Checks if the NPC should be tracked in the overlay based on its ignored state.
     * This is useful for ensuring ignored NPCs don't appear in the monitoring section.
     *
     * @return true if the NPC should be tracked, false if it is ignored.
     */
    public boolean isTrackable()
    {
        return !ignored;
    }
}

package com.example;

import com.monstermonitor.MonsterMonitorPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MonsterMonitorPlugin.class);
		RuneLite.main(args);
	}
}
