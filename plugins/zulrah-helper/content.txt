package com.zulrahhelper;

/**
 * Orientation of the phase images in Cardinal directions
 */
public enum ImageOrientation
{
	SOUTH,
	NORTH,
	EAST,
	WEST;

	public double getRotation()
	{
		switch (this)
		{
			case NORTH:
				return Math.PI;
			case EAST:
				return Math.PI / 2;
			case WEST:
				return Math.PI * 1.5f;
			case SOUTH:
			default:
				return 0.0;
		}
	}
}
/*
 * Copyright (c) 2020, Anthony Alves
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.ui;

import com.zulrahhelper.ZulrahHelperPlugin;
import com.zulrahhelper.tree.Node;
import com.zulrahhelper.tree.PatternTree;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.LineBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

@Slf4j
public class ZulrahHelperPhasePanel extends JPanel implements MouseListener
{
	private final ZulrahHelperPlugin plugin;
	private final Node node;

	private final JLabel picLabel;
	private final ImageIcon phaseIcon;
	private final ImageIcon phaseIconHover;

	private final PatternTree tree;

	ZulrahHelperPhasePanel(ZulrahHelperPlugin plugin, PatternTree tree, Node node, int columns)
	{
		this.plugin = plugin;
		this.node = node;
		this.tree = tree;

		BufferedImage img = processImg(Images.createImage(node.getValue(), plugin.getConfig()), columns);
		phaseIcon = new ImageIcon(img);
		phaseIconHover = new ImageIcon(ImageUtil.luminanceScale(img, .75f));

		picLabel = new JLabel(phaseIcon);
		picLabel.addMouseListener(this);
//
		if (node.equals(tree.getState()))
		{
			setBorder(new LineBorder(ColorScheme.PROGRESS_COMPLETE_COLOR));
		}

		if (columns >= 2)
		{
			setBorder(new LineBorder(ColorScheme.PROGRESS_INPROGRESS_COLOR));
		}

		add(picLabel);
	}

	private BufferedImage processImg(BufferedImage img, int columns)
	{
		int size = 95;
		// make the images smaller if we're showing more than 3 images on the same row
		if (columns >= 3)
		{
			size = 60;
		}
		img = ImageUtil.resizeImage(img, size, size);
		if (tree.depth(node) < tree.depth(tree.getState()))
		{
			img = ImageUtil.luminanceScale(img, 0.35f);
		}

		return img;
	}

	@Override
	public void mouseClicked(MouseEvent mouseEvent)
	{
	}

	@Override
	public void mousePressed(MouseEvent mouseEvent)
	{
		plugin.setState(node);
	}

	@Override
	public void mouseReleased(MouseEvent mouseEvent)
	{

	}

	@Override
	public void mouseEntered(MouseEvent mouseEvent)
	{
		picLabel.setIcon(phaseIconHover);
	}

	@Override
	public void mouseExited(MouseEvent mouseEvent)
	{
		picLabel.setIcon(phaseIcon);
	}
}

/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.ui;

import com.zulrahhelper.ZulrahHelperConfig;
import com.zulrahhelper.ZulrahHelperPlugin;
import com.zulrahhelper.tree.Step;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

public class Images
{
	private static final BufferedImage FLOOR_IMG = ImageUtil.loadImageResource(Step.class, "/floor.png");
	private static final BufferedImage SNAKELINGS = ImageUtil.loadImageResource(Step.class, "/options/snakeling2.png");
	private static final BufferedImage HITSPLAT = ImageUtil.loadImageResource(Step.class, "/options/hitsplat.png");
	private static final BufferedImage VENOM = ImageUtil.loadImageResource(Step.class, "/options/venom.png");
	private static final BufferedImage RESET = ImageUtil.loadImageResource(ZulrahHelperPlugin.class, "/ui/reset_icon.png");;


	private static final int WIDTH = 105;
	private static final int HEIGHT = 105;

	private static final int PADDING = 2;

	private static final Color DARK_BACKGROUND = new Color(24, 24, 24, 65);
	private static final Color LIGHT_BACKGROUND = new Color(255, 255, 255, 200);

	public static BufferedImage createImage(final Step step, final ZulrahHelperConfig config)
	{
		BufferedImage image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = (Graphics2D) image.getGraphics();

		g.setColor(config.darkMode() ? DARK_BACKGROUND : LIGHT_BACKGROUND);
		g.fillRect(0, 0, WIDTH, HEIGHT);

		int px = (WIDTH - FLOOR_IMG.getWidth()) / 2 + 1;
		int py = (HEIGHT - FLOOR_IMG.getHeight()) / 2;

		g.drawImage(FLOOR_IMG, null, px, py);

		for (var p : step.getPoints())
		{
			p.drawX(g, px, py);
		}

		var spawn = step.getSpawn();
		spawn.drawLocation(g, step.getForm().getColor(config), px, py);

		var theta = config.imageOrientation().getRotation();
		if (theta != 0)
		{
			image = ImageUtil.rotateImage(image, theta);
			g.dispose();
			g = (Graphics2D) image.getGraphics();
		}

		var prayers = step.getPrayers();
		if (config.displayPrayerIcons())
		{
			for (int idx = 0; idx < prayers.size(); idx++)
			{
				var p = prayers.get(idx);
				var img = p.getImage();

				int offset = idx == 1 ? WIDTH - img.getWidth() - PADDING : PADDING;
				g.drawImage(img, null, offset, PADDING);
			}
		}

		g.setFont(FontManager.getRunescapeBoldFont());
		if (config.displayAttackIcons() && step.getAttacks() > 0)
		{
			drawSplat(g, Color.WHITE, HITSPLAT, step.getAttacks() + "", 0);
		}

		if (config.displayVenom() && step.getVenom() > 0)
		{
			drawSplat(g, Color.WHITE, VENOM, step.getVenom() + "", WIDTH / 2 - VENOM.getWidth() / 2);
		}

		if (config.displaySnakelings() && step.getSnakelings() > 0)
		{
			var c = config.darkMode() ? Color.WHITE : Color.BLACK;
			var x = WIDTH - SNAKELINGS.getWidth() * 2 + PADDING * 2;
			drawSplat(g, c, SNAKELINGS, step.getSnakelings() + "", x, x + PADDING);
		}

		if (step.isReset())
		{
			var p = 23;
			g.drawImage(RESET, p, p, RESET.getWidth() * 3, RESET.getHeight() * 3, null);
		}

		g.dispose();
		return image;
	}

	private static void drawSplat(Graphics2D g, Color c, BufferedImage img, String text, int splatX, int textX)
	{
		var fm = g.getFontMetrics();
		g.drawImage(img, null, splatX + PADDING, HEIGHT - PADDING - HITSPLAT.getHeight());
		var tw = fm.stringWidth(text);
		var cx = HITSPLAT.getWidth() / 2 - tw / 2 + (tw % 2 == 1 ? -2 : 0);
		var cy = HITSPLAT.getHeight() / 2 - fm.getFont().getSize();

		var tx = textX + PADDING + cx;
		var ty = HEIGHT - PADDING + cy;

		g.setColor(Color.BLACK);
		g.drawString(text, tx + 1, ty + 1);

		g.setColor(c);
		g.drawString(text, tx, ty);
	}

	private static void drawSplat(Graphics2D g, Color c, BufferedImage img, String text, int x)
	{
		drawSplat(g, c, img, text, x, x);
	}
}

/*
 * Copyright (c) 2020, Anthony Alves
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.ui;

import com.google.common.base.Strings;
import com.zulrahhelper.ZulrahHelperPlugin;
import com.zulrahhelper.tree.PatternTree;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

@Slf4j
@Singleton
public class ZulrahHelperPanel extends PluginPanel
{
	private static final ImageIcon RESET_ICON;
	private static final ImageIcon RESET_HOVER_ICON;

	static
	{
		final BufferedImage addIcon = ImageUtil.loadImageResource(ZulrahHelperPlugin.class, "/ui/reset_icon.png");
		RESET_ICON = new ImageIcon(addIcon);
		RESET_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));
	}

	private final ZulrahHelperPlugin plugin;
	private final PatternTree tree;

	private final JPanel phasesView = new JPanel(new GridBagLayout());

	@Inject
	ZulrahHelperPanel(ZulrahHelperPlugin plugin, PatternTree tree)
	{
		this.plugin = plugin;
		this.tree = tree;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));

		JLabel title = new JLabel();
		title.setText("Zulrah Helper");
		title.setForeground(Color.WHITE);

		northPanel.add(title, BorderLayout.WEST);
		JButton reset = new JButton(RESET_ICON);
		northPanel.add(reset, BorderLayout.EAST);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		phasesView.setBackground(ColorScheme.DARK_GRAY_COLOR);

		reset.setToolTipText("Reset Zulrah rotation");
		reset.setRolloverIcon(RESET_HOVER_ICON);
		reset.addActionListener(l -> plugin.reset());
		reset.setFocusable(false);

		centerPanel.add(phasesView, BorderLayout.CENTER);

		add(northPanel, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);

		rebuildPanel();
	}

	public void rebuildPanel()
	{
		SwingUtil.fastRemoveAll(phasesView);

		GridBagConstraints constraints = new GridBagConstraints();
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		JPanel rowPanel = new JPanel(new GridBagLayout());
		GridBagConstraints rowConstraints = resetRowConstraints();

		var path = tree.buildPath();
		int phaseNumber = 1;
		String title = null;
		for (var node : path)
		{
			if (!Strings.isNullOrEmpty(node.getValue().getTitle()))
			{
				title = node.getValue().getTitle();
			}

			if (rowPanel.getComponentCount() >= 2)
			{
				phasesView.add(rowPanel, constraints);
				constraints.gridy++;
				rowPanel = new JPanel(new GridBagLayout());
				rowConstraints = resetRowConstraints();
			}

			if (node.equals(tree.getState()))
			{
				createLabel(String.format("Current Phase: %s #%d", title, phaseNumber), constraints);
			}

			rowPanel.add(new ZulrahHelperPhasePanel(plugin, tree, node, 1), rowConstraints);
			rowConstraints.gridx++;

			if (node.size() >= 2)
			{
				phasesView.add(rowPanel, constraints);
				constraints.gridy++;
				rowPanel = new JPanel(new GridBagLayout());
				rowConstraints = resetRowConstraints();

				createLabel("Select Phase...", constraints);

				for (var nc : node.getChildren())
				{
					rowPanel.add(new ZulrahHelperPhasePanel(plugin, tree, nc, node.size()), rowConstraints);
					rowConstraints.gridx++;
				}
			}

			phasesView.add(rowPanel, constraints);
			constraints.gridy++;
			phaseNumber++;
		}

		repaint();
		revalidate();
	}

	private GridBagConstraints resetRowConstraints()
	{
		var c = new GridBagConstraints();
		c.fill = GridBagConstraints.VERTICAL;
		c.weighty = 1;
		c.gridx = 0;
		c.gridy = 0;

		return c;
	}

	private void createLabel(String text, GridBagConstraints constraints)
	{
		phasesView.add(Box.createRigidArea(new Dimension(0, 12)), constraints);
		constraints.gridy++;
		phasesView.add(new JLabel(text), constraints);
		constraints.gridy++;
	}
}

package com.zulrahhelper;

import com.google.inject.Provides;
import com.zulrahhelper.tree.Node;
import com.zulrahhelper.tree.PatternTree;
import com.zulrahhelper.ui.ZulrahHelperPanel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "Zulrah Helper",
	description = "Panel to show Zulrah rotations",
	tags = {"zulrah", "pvm"}
)
public class ZulrahHelperPlugin extends Plugin
{
	static final String CONFIG_GROUP = "zulrahhelper";
	static final String SECTION_IMAGE_OPTIONS = "Image Options";
	static final String SECTION_HOTKEYS = "Hotkeys";
	static final String SECTION_MISC = "Miscellaneous";

	static final String DARK_MODE_KEY = "darkMode";
	static final String DISPLAY_PRAYER_KEY = "displayPrayer";
	static final String DISPLAY_ATTACK_KEY = "displayAttack";
	static final String DISPLAY_VENOM_KEY = "displayVenom";
	static final String DISPLAY_SNAKELINGS_KEY = "displaySnakelings";
	static final String IMAGE_ORIENTATION_KEY = "imageOrientation";
	static final String AUTO_HIDE_KEY = "autoHide";
	static final String RESET_ON_LEAVE_KEY = "resetOnLeave";
	static final String MAGE_COLOR_KEY = "mageColor";
	static final String RANGE_COLOR_KEY = "rangeColor";
	static final String MELEE_COLOR_KEY = "meleeColor";


	private static final int ZULANDRA_REGION_ID = 8751;
	private static final int ZULRAH_SPAWN_REGION_ID = 9007;
	private static final int ZULRAH_REGION_ID = 9008;

	private static final List<String> OPTION_KEYS = Arrays.asList(
		DARK_MODE_KEY,
		DISPLAY_PRAYER_KEY,
		DISPLAY_ATTACK_KEY,
		IMAGE_ORIENTATION_KEY,
		RESET_ON_LEAVE_KEY,
		DISPLAY_VENOM_KEY,
		DISPLAY_SNAKELINGS_KEY,
		MAGE_COLOR_KEY,
		MELEE_COLOR_KEY,
		RANGE_COLOR_KEY
	);

	@Inject
	private KeyManager keyManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Client client;

	@Inject
	private PatternTree tree;

	@Inject
	@Getter
	private ZulrahHelperConfig config;

	private ZulrahHelperPanel panel;
	private NavigationButton navButton;

	private final List<HotkeyListener> hotkeys = new ArrayList<>();
	private boolean hotkeysEnabled = false;
	private boolean panelEnabled = false;
	private boolean wasInInstance = false;

	@Override
	protected void startUp() throws Exception
	{
		panel = injector.getInstance(ZulrahHelperPanel.class);
		navButton = NavigationButton.builder()
			.tooltip("Zulrah Helper")
			.icon(ImageUtil.loadImageResource(getClass(), "/icon.png"))
			.priority(70)
			.panel(panel)
			.build();
		clientToolbar.addNavigation(navButton);

		initHotkeys();
		togglePanel(!config.autoHide(), false);
		reset();
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
		hotkeys.forEach(keyManager::unregisterKeyListener);
		hotkeys.clear();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(CONFIG_GROUP))
		{
			return;
		}

		if (OPTION_KEYS.contains(event.getKey()))
		{
			rebuildPanel();
		}

		if (event.getKey().equals(AUTO_HIDE_KEY) && !config.autoHide())
		{
			togglePanel(true, false);
		}
	}

	@Provides
	ZulrahHelperConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ZulrahHelperConfig.class);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		checkRegion();
	}

	private void checkRegion()
	{
		if (inZulrahRegion())
		{
			if (!hotkeysEnabled)
			{
				toggleHotkeys();
			}

			if (config.autoHide() && !panelEnabled)
			{
				togglePanel(true, true);
			}

			if (wasInInstance && !client.isInInstancedRegion())
			{
				reset();
			}

			wasInInstance = client.isInInstancedRegion();
		}
		else
		{
			if (hotkeysEnabled)
			{
				toggleHotkeys();
			}

			if (panelEnabled && config.autoHide())
			{
				togglePanel(false, false);
			}

			if (wasInInstance)
			{
				if (config.resetOnLeave())
				{
					reset();
				}

				wasInInstance = false;
			}
		}
	}

	private boolean inZulrahRegion()
	{
		final int regionId = getRegionId();

		return regionId == ZULANDRA_REGION_ID ||
			((regionId == ZULRAH_SPAWN_REGION_ID || regionId == ZULRAH_REGION_ID) && client.isInInstancedRegion());
	}

	private int getRegionId()
	{
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return -1;
		}

		return WorldPoint.fromLocalInstance(client, player.getLocalLocation()).getRegionID();
	}

	public void reset()
	{
		tree.reset();
		SwingUtilities.invokeLater(() -> panel.rebuildPanel());
	}

	public void setState(Node node)
	{
		var s = tree.find(node.getValue());
		if (s == null)
		{
			log.debug("state not found {}", node);
			return;
		}

		if (s.getValue().isReset())
		{
			reset();
			return;
		}

		tree.setState(s);
		rebuildPanel();
	}

	private void rebuildPanel()
	{
		SwingUtilities.invokeLater(() -> panel.rebuildPanel());
	}

	private void selectOption(int choice)
	{
		var node = tree.getState();
		var choices = node.getChildren();
		if (choice >= choices.size())
		{
			log.error("trying to select nonexistent phase: {} {}", choice, choices.size());
			return;
		}

		setState(choices.get(choice));
	}

	private void initHotkeys()
	{
		hotkeys.forEach(keyManager::unregisterKeyListener);
		hotkeys.clear();

		hotkeys.add(new HotkeyListener(() -> config.phaseSelection1Hotkey())
		{
			@Override
			public void hotkeyPressed()
			{
				selectOption(0);
			}
		});

		hotkeys.add(new HotkeyListener(() -> config.phaseSelection2Hotkey())
		{
			@Override
			public void hotkeyPressed()
			{
				selectOption(1);
			}
		});

		hotkeys.add(new HotkeyListener(() -> config.phaseSelection3Hotkey())
		{
			@Override
			public void hotkeyPressed()
			{
				selectOption(2);
			}
		});

		hotkeys.add(new HotkeyListener(() -> config.nextPhaseHotkey())
		{
			@Override
			public void hotkeyPressed()
			{
				selectOption(0);
			}
		});

		hotkeys.add(new HotkeyListener(() -> config.resetPhasesHotkey())
		{
			@Override
			public void hotkeyPressed()
			{
				reset();
			}
		});
	}

	private void toggleHotkeys()
	{
		hotkeys.forEach(hotkeysEnabled ? keyManager::unregisterKeyListener : keyManager::registerKeyListener);
		hotkeysEnabled = !hotkeysEnabled;
	}

	private void togglePanel(boolean enable, boolean show)
	{
		panelEnabled = enable;
		if (enable)
		{
			clientToolbar.addNavigation(navButton);
			if (show)
			{
				SwingUtilities.invokeLater(() -> {
					clientToolbar.openPanel(navButton);
				});
			}
		}
		else
		{
			clientToolbar.removeNavigation(navButton);
		}
	}
}

/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.options;

import java.awt.Color;
import java.awt.Graphics;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum StandLocation
{

	START(19, 52),
	START_MAGMA(11, 43),
	PILLAR_1_SOUTH(20, 23),
	PILLAR_1_WEST(18, 16),
	PILLAR_1_NORTH(26, 9),
	NORTH(41, 10),
	PILLAR_2_SOUTH(62, 23),
	PILLAR_2_EAST(63, 16),
	PILLAR_2_NORTH(55, 9);

	private static final int WIDTH = 6;
	private static final int HEIGHT = 6;

	private final int x;
	private final int y;

	public void drawX(Graphics g, int px, int py)
	{
		var x = px + this.x - WIDTH / 2;
		var y = py + this.y - HEIGHT / 2;

		g.setColor(Color.WHITE);

		g.drawLine(x, y, x + WIDTH, y + HEIGHT);
		g.drawLine(x, y + HEIGHT, x + WIDTH, y);

		g.drawLine(x - 1, y, x + WIDTH - 1, y + HEIGHT);
		g.drawLine(x - 1, y + HEIGHT, x + WIDTH - 1, y);
	}
}

/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.options;

import java.awt.Color;
import java.awt.Graphics2D;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum ZulrahLocation
{
	NORTH(39, -10),
	SOUTH(40, 30),
	EAST(82, 25),
	WEST(-5, 35);

	private static final int PHASE_RADIUS = 5;
	private static final Color BORDER_COLOR = new Color(140, 140, 140);

	private final int x;
	private final int y;

	public int getX()
	{
		return x - PHASE_RADIUS;
	}

	public int getY()
	{
		return y - PHASE_RADIUS;
	}

	public int getWidth()
	{
		return PHASE_RADIUS * 2 + 1;
	}

	public int getHeight()
	{
		return PHASE_RADIUS * 2 + 1;
	}

	public void drawLocation(Graphics2D g, Color c, int px, int py)
	{
		// draw a little bit bigger for a sharper circle
		g.setColor(c);
		g.fillOval(getX() + px - 1, getY() + py - 1, getWidth() + 2, getHeight() + 2);

		g.setColor(BORDER_COLOR);
		g.drawOval(getX() + px - 1, getY() + py - 1, getWidth() + 2, getHeight() + 2);

	}
}

/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.options;

import com.zulrahhelper.ZulrahHelperConfig;
import java.awt.Color;

public enum ZulrahForm
{
	RANGE,
	MAGE,
	MELEE;

	public Color getColor(ZulrahHelperConfig config)
	{
		switch (this)
		{
			case RANGE:
				return config.rangeColor();
			case MAGE:
				return config.mageColor();
			default:
				return config.meleeColor();
		}
	}
}

/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.options;

import java.awt.image.BufferedImage;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;

@Getter
public enum Prayer
{
	MAGIC("protect-from-magic.png"),
	RANGE("protect-from-missiles.png");

	private final BufferedImage image;

	Prayer(String file)
	{
		this.image = ImageUtil.loadImageResource(Prayer.class, "/options/" + file);
	}
}

package com.zulrahhelper;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup(ZulrahHelperPlugin.CONFIG_GROUP)
public interface ZulrahHelperConfig extends Config
{
	@ConfigSection(
		name = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		description = "All the options for image options",
		position = 0
	)
	String SECTION_IMAGE_OPTIONS = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS;

	@ConfigSection(
		name = ZulrahHelperPlugin.SECTION_HOTKEYS,
		description = "All the options for binding hotkeys",
		position = 1
	)
	String SECTION_HOTKEYS = "Hotkeys";

	@ConfigSection(
		name = ZulrahHelperPlugin.SECTION_MISC,
		description = "Miscellaneous options for the plugin",
		position = 2
	)
	String SECTION_MISC = ZulrahHelperPlugin.SECTION_MISC;

	@ConfigItem(
		keyName = ZulrahHelperPlugin.DISPLAY_PRAYER_KEY,
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Prayer Icons",
		description = "Set phase images to use prayer icons, " +
			"denoting what overhead prayer to use per phase. " +
			"No prayer icon means the phase is safe to turn overheads off.",
		position = 0
	)
	default boolean displayPrayerIcons()
	{
		return false;
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.DISPLAY_ATTACK_KEY,
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Attack Icons",
		description = "Display number of Zulrah attacks",
		position = 1
	)
	default boolean displayAttackIcons()
	{
		return false;
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.DISPLAY_VENOM_KEY,
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Venom Icons",
		description = "Display number of venom attacks",
		position = 1
	)
	default boolean displayVenom()
	{
		return false;
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.DISPLAY_SNAKELINGS_KEY,
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Snakeling Icons",
		description = "Display snakeling spawns",
		position = 1
	)
	default boolean displaySnakelings()
	{
		return false;
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.DARK_MODE_KEY,
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Dark Mode",
		description = "Set phase images to dark mode",
		position = 2
	)
	default boolean darkMode()
	{
		return true;
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.MAGE_COLOR_KEY,
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Mage Form Color",
		description = "Color of Zulrah mage form",
		position = 3
	)
	default Color mageColor()
	{
		return new Color(0, 51, 255);
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.RANGE_COLOR_KEY,
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Range Form Color",
		description = "Color of Zulrah range form",
		position = 3
	)
	default Color rangeColor()
	{
		return new Color(25, 194, 4);
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.MELEE_COLOR_KEY,
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Melee Form Color",
		description = "Color of Zulrah melee form",
		position = 3
	)
	default Color meleeColor()
	{
		return new Color(251, 0, 7);
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.AUTO_HIDE_KEY,
		section = ZulrahHelperPlugin.SECTION_MISC,
		name = "Hide when outside of Zul-Andra",
		description = "Don't show the button in the sidebar when you're not in Zul-Andra",
		position = 3
	)
	default boolean autoHide()
	{
		return true;
	}

	@ConfigItem(
		keyName = ZulrahHelperPlugin.RESET_ON_LEAVE_KEY,
		section = ZulrahHelperPlugin.SECTION_MISC,
		name = "Reset on Leave",
		description = "Automatically reset when leaving the Zulrah area",
		position = 2
	)
	default boolean resetOnLeave()
	{
		return true;
	}

	@ConfigItem(
		keyName = "resetPhasesHotkey",
		section = ZulrahHelperPlugin.SECTION_HOTKEYS,
		name = "Reset Phases",
		description = "Set phases back to start",
		position = 4
	)
	default Keybind resetPhasesHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "nextPhaseHotkey",
		section = ZulrahHelperPlugin.SECTION_HOTKEYS,
		name = "Next Phase",
		description = "Increment the phase number by 1",
		position = 5
	)
	default Keybind nextPhaseHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "phaseSelection1Hotkey",
		section = ZulrahHelperPlugin.SECTION_HOTKEYS,
		name = "Phase Selection 1",
		description = "Choose the first option in phase selection",
		position = 6
	)
	default Keybind phaseSelection1Hotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "phaseSelection2Hotkey",
		section = ZulrahHelperPlugin.SECTION_HOTKEYS,
		name = "Phase Selection 2",
		description = "Choose the second option in phase selection",
		position = 7
	)
	default Keybind phaseSelection2Hotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "phaseSelection3Hotkey",
		section = ZulrahHelperPlugin.SECTION_HOTKEYS,
		name = "Phase Selection 3",
		description = "Choose the third option in phase selection",
		position = 8
	)
	default Keybind phaseSelection3Hotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "imageOrientation",
		section = ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,
		name = "Orientation",
		description = "Rotate the phase images to the specified cardinal direction",
		position = 9
	)
	default ImageOrientation imageOrientation()
	{
		return ImageOrientation.SOUTH;
	}
}

/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.tree;

import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nonnull;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Singular;
import lombok.ToString;

@Getter
@Builder()
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString(onlyExplicitlyIncluded = true)
public class Node
{
	protected Node parent;

	@ToString.Include
	@EqualsAndHashCode.Include
	protected Step value;

	@Singular
	protected List<Node> children;

	public int size()
	{
		return this.getChildren().size();
	}

	public Node find(Step val)
	{
		if (this.value.equals(val))
		{
			return this;
		}

		for (var c : children)
		{
			var n = c.find(val);
			if (n != null)
			{
				return n;
			}
		}

		return null;
	}

	public boolean find(Node node)
	{
		if (node == null)
		{
			return false;
		}

		if (this == node || this.value.equals(node.value))
		{
			return true;
		}

		for (var c : children)
		{
			if (c.find(node))
			{
				return true;
			}
		}

		return false;
	}

	public static Node of(@Nonnull Node n)
	{
		return new Node(null, n.value, new ArrayList<>());
	}

	public static class NodeBuilder
	{
		NodeBuilder parentBuilder;

		public NodeBuilder node()
		{
			var c = Node.builder();
			c.parentBuilder = this;
			return c;
		}

		public Node buildUp()
		{
			NodeBuilder b = this;
			NodeBuilder p;
			Node n = null;
			while (b != null)
			{
				n = b.build();
				p = b.parentBuilder;
				if (p != null)
				{
					p.child(n);
				}
				b = p;
			}

			return n;
		}

		public Node build()
		{
			if (this.children == null)
			{
				this.children = new ArrayList<>();
			}

			Node n = new Node(null, this.value, this.children);

			for (var c : n.children)
			{
				c.parent = n;
			}

			return n;
		}
	}
}

/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.tree;

import com.zulrahhelper.options.Prayer;
import com.zulrahhelper.options.StandLocation;
import com.zulrahhelper.options.ZulrahForm;
import com.zulrahhelper.options.ZulrahLocation;
import java.security.SecureRandom;
import java.util.List;
import lombok.Builder;
import lombok.NonNull;
import lombok.Singular;
import lombok.Value;

@Value
@Builder(toBuilder = true)
public class Step
{
	private static final SecureRandom RANDOM = new SecureRandom();

	@Builder.Default
	int id = RANDOM.nextInt();

	String title;

	int attacks;
	int venom;
	int snakelings;

	ZulrahForm form;

	@Singular
	List<StandLocation> points;

	@Singular
	List<Prayer> prayers;

	@Builder.Default
	ZulrahLocation spawn = ZulrahLocation.SOUTH;

	boolean reset;
}

/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper.tree;

import com.google.common.collect.Iterables;
import com.zulrahhelper.options.Prayer;
import com.zulrahhelper.options.StandLocation;
import com.zulrahhelper.options.ZulrahForm;
import com.zulrahhelper.options.ZulrahLocation;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

@Singleton
@Slf4j
public class PatternTree
{
	protected Node root;

	@Getter
	@NonNull
	protected Node state;

	@Inject
	public PatternTree()
	{
		this.root = build();
		this.state = root;
	}

	public Node find(Step value)
	{
		return root.find(value);
	}

	public void setState(@Nonnull Node n)
	{
		if (contains(n))
		{
			state = n;
		}
	}

	public boolean contains(Node node)
	{
		return root.find(node);
	}

	public void reset()
	{
		state = root;
	}

	public int depth(Node node)
	{
		return depth(node.getValue());
	}

	public int depth(Step value)
	{
		Node node = find(value);
		if (node == null)
		{
			return -1;
		}

		int i = 0;
		while (node.parent != null)
		{
			i++;
			node = node.parent;
		}

		return i;
	}

	public List<Node> buildPath()
	{
		return buildPath(state);
	}

	public List<Node> buildPath(Node n)
	{
		List<Node> path = new ArrayList<>();
		if (n.getParent() != null)
		{
			var p = n.getParent();
			while (p != null)
			{
				path.add(0, Node.of(p));
				p = p.getParent();
			}
		}

		path.add(Node.of(n));
		var nc = n.getChildren();
		while (!nc.isEmpty())
		{
			if (nc.size() > 1)
			{
				Iterables.getLast(path)
					.children.addAll(nc.stream()
						.map(Node::of)
						.collect(Collectors.toList()));
				break;
			}
			else
			{
				path.add(Node.of(nc.get(0)));
			}

			nc = nc.get(0).getChildren();
		}

		return path;
	}

	private static Node build()
	{
		return Node.builder()
			.value(Step.builder()
				.title("START")
				.point(StandLocation.START)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.venom(4)
				.build())
			.child(buildMelee())
			.child(buildRange())
			.child(buildMage())
			.build();
	}

	private static Node buildMelee()
	{
		return Node.builder()
			.value(Step.builder()
				.title("MAGMA")
				.form(ZulrahForm.MELEE)
				.point(StandLocation.START)
				.point(StandLocation.START_MAGMA)
				.attacks(2)
				.build())
			.child(Node.builder()
				.value(Step.builder()
					.form(ZulrahForm.MAGE)
					.prayer(Prayer.MAGIC)
					.attacks(4)
					.point(StandLocation.START)
					.build())
				.child(buildMeleeA())
				.child(buildMeleeB())
				.build())
			.build();
	}

	private static Node buildMeleeA()
	{
		return Node.builder()
			.value(Step.builder()
				.title("MAGMA A")
				.form(ZulrahForm.RANGE)
				.spawn(ZulrahLocation.NORTH)
				.point(StandLocation.PILLAR_2_SOUTH)
				.prayer(Prayer.RANGE)
				.attacks(5)
				.venom(2)
				.snakelings(2)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MELEE)
				.attacks(2)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MAGE)
				.attacks(5)
				.prayer(Prayer.MAGIC)
				.spawn(ZulrahLocation.EAST)
				.point(StandLocation.NORTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.NORTH)
				.form(ZulrahForm.RANGE)
				.venom(3)
				.snakelings(2)
				.point(StandLocation.PILLAR_1_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.NORTH)
				.form(ZulrahForm.MAGE)
				.attacks(5)
				.venom(2)
				.snakelings(2)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_1_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.EAST)
				.form(ZulrahForm.RANGE)
				.attacks(10)
				.venom(4)
				.prayer(Prayer.RANGE)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MELEE)
				.attacks(2)
				.point(StandLocation.START)
				.point(StandLocation.START_MAGMA)
				.build())
			.node()
			.value(Step.builder()
				.title("RESET")
				.form(ZulrahForm.RANGE)
				.prayer(Prayer.RANGE)
				.point(StandLocation.START)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.venom(4)
				.reset(true)
				.build())
			.buildUp();
	}

	private static Node buildMeleeB()
	{
		return Node.builder()
			.value(Step.builder()
				.title("MAGMA B")
				.form(ZulrahForm.RANGE)
				.spawn(ZulrahLocation.EAST)
				.point(StandLocation.PILLAR_2_SOUTH)
				.venom(3)
				.snakelings(2)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.NORTH)
				.form(ZulrahForm.MAGE)
				.attacks(5)
				.venom(2)
				.snakelings(2)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MELEE)
				.attacks(2)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.WEST)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.prayer(Prayer.RANGE)
				.point(StandLocation.NORTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.NORTH)
				.form(ZulrahForm.MAGE)
				.attacks(5)
				.venom(2)
				.snakelings(2)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.EAST)
				.form(ZulrahForm.RANGE)
				.attacks(10)
				.venom(4)
				.prayer(Prayer.RANGE)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MELEE)
				.attacks(2)
				.point(StandLocation.START)
				.point(StandLocation.START_MAGMA)
				.build())
			.node()
			.value(Step.builder()
				.title("RESET")
				.form(ZulrahForm.RANGE)
				.prayer(Prayer.RANGE)
				.point(StandLocation.START)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.venom(4)
				.reset(true)
				.build())
			.buildUp();
	}

	private static Node buildRange()
	{
		return Node.builder()
			.value(Step.builder()
				.title("SERP")
				.form(ZulrahForm.RANGE)
				.spawn(ZulrahLocation.WEST)
				.point(StandLocation.START)
				.prayer(Prayer.RANGE)
				.attacks(5)
				.snakelings(2)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MELEE)
				.attacks(2)
				.venom(3)
				.snakelings(2)
				.point(StandLocation.PILLAR_1_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.EAST)
				.form(ZulrahForm.MAGE)
				.attacks(5)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.NORTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.NORTH)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.prayer(Prayer.RANGE)
				.point(StandLocation.NORTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.WEST)
				.form(ZulrahForm.MAGE)
				.attacks(5)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.NORTH)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.RANGE)
				.venom(3)
				.snakelings(2)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.EAST)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.prayer(Prayer.RANGE)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MAGE)
				.attacks(5)
				.venom(2)
				.snakelings(2)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_1_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.WEST)
				.form(ZulrahForm.RANGE)
				.attacks(10)
				.prayer(Prayer.MAGIC)
				.prayer(Prayer.RANGE)
				.point(StandLocation.PILLAR_1_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MAGE)
				.snakelings(2)
				.point(StandLocation.START)
				.build())
			.node()
			.value(Step.builder()
				.title("RESET")
				.form(ZulrahForm.RANGE)
				.prayer(Prayer.RANGE)
				.point(StandLocation.START)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.venom(4)
				.reset(true)
				.build())
			.buildUp();
	}

	private static Node buildMage()
	{
		return Node.builder()
			.value(Step.builder()
				.title("TANZ")
				.form(ZulrahForm.MAGE)
				.spawn(ZulrahLocation.WEST)
				.point(StandLocation.START)
				.prayer(Prayer.MAGIC)
				.attacks(6)
				.snakelings(2)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.NORTH)
				.form(ZulrahForm.RANGE)
				.attacks(4)
				.venom(2)
				.prayer(Prayer.RANGE)
				.point(StandLocation.PILLAR_2_SOUTH)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.EAST)
				.form(ZulrahForm.MAGE)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_2_SOUTH)
				.attacks(4)
				.snakelings(2)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MELEE)
				.point(StandLocation.PILLAR_1_SOUTH)
				.attacks(2)
				.venom(2)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.RANGE)
				.spawn(ZulrahLocation.WEST)
				.point(StandLocation.PILLAR_1_SOUTH)
				.prayer(Prayer.RANGE)
				.attacks(4)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.RANGE)
				.spawn(ZulrahLocation.NORTH)
				.point(StandLocation.PILLAR_1_SOUTH)
				.snakelings(2)
				.venom(3)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.EAST)
				.form(ZulrahForm.MAGE)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_2_EAST)
				.attacks(5)
				.venom(4)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.RANGE)
				.prayer(Prayer.RANGE)
				.point(StandLocation.PILLAR_1_SOUTH)
				.attacks(5)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MAGE)
				.prayer(Prayer.MAGIC)
				.point(StandLocation.PILLAR_1_SOUTH)
				.attacks(4)
				.venom(3)
				.build())
			.node()
			.value(Step.builder()
				.spawn(ZulrahLocation.WEST)
				.form(ZulrahForm.RANGE)
				.prayer(Prayer.MAGIC)
				.prayer(Prayer.RANGE)
				.point(StandLocation.PILLAR_1_SOUTH)
				.attacks(8)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MAGE)
				.point(StandLocation.START)
				.snakelings(2)
				.build())
			.node()
			.value(Step.builder()
				.title("RESET")
				.form(ZulrahForm.RANGE)
				.prayer(Prayer.RANGE)
				.point(StandLocation.START)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.venom(4)
				.reset(true)
				.build())
			.buildUp();
	}
}

package com.zulrahhelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ZulrahHelperPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ZulrahHelperPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2024, Ron Young <https://github.com/raiyni>
 * All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.zulrahhelper;

import com.zulrahhelper.options.Prayer;
import com.zulrahhelper.options.StandLocation;
import com.zulrahhelper.options.ZulrahForm;
import com.zulrahhelper.options.ZulrahLocation;
import com.zulrahhelper.tree.Node;
import com.zulrahhelper.tree.Step;
import com.zulrahhelper.ui.Images;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;
import lombok.extern.slf4j.Slf4j;
import static org.junit.Assert.assertEquals;
import org.junit.Test;
import static org.mockito.Mockito.spy;

@Slf4j
public class ImageBuilderTest
{
	private ZulrahHelperConfig getConfig()
	{
		return spy(ZulrahHelperConfig.class);
	}

	@Test
	public void streamlinedBuilder()
	{
		var root = Node.builder()
			.value(Step.builder()
				.point(StandLocation.START)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.venom(4)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MELEE)
				.point(StandLocation.START)
				.point(StandLocation.START_MAGMA)
				.attacks(2)
				.build())
			.node()
			.value(Step.builder()
				.form(ZulrahForm.MAGE)
				.point(StandLocation.START)
				.point(StandLocation.START_MAGMA)
				.attacks(4)
				.build())
			.buildUp();

		assertEquals(1, root.getChildren().size());
		assertEquals(root, root.getChildren().get(0).getParent());
		assertEquals(1, root.getChildren().get(0).getChildren().size());
		assertEquals(ZulrahForm.MAGE, root.getChildren().get(0).getChildren().get(0).getValue().getForm());
	}

	@Test
	public void childrenHasParent()
	{
		var root = Node.builder()
			.value(Step.builder()
				.point(StandLocation.START)
				.form(ZulrahForm.RANGE)
				.attacks(5)
				.venom(4)
				.build())
			.child(Node.builder()
				.value(Step.builder()
					.form(ZulrahForm.MELEE)
					.point(StandLocation.START)
					.point(StandLocation.START_MAGMA)
					.attacks(2)
					.build())
				.build())
			.build();

		assertEquals(1, root.getChildren().size());
		assertEquals(root, root.getChildren().get(0).getParent());
		assertEquals(0, root.getChildren().get(0).getChildren().size());
	}

	@Test
	public void simpleStep() throws IOException
	{
		Step step = Step.builder()
			.point(StandLocation.START)
			.point(StandLocation.START_MAGMA)
			.spawn(ZulrahLocation.NORTH)
			.prayer(Prayer.MAGIC)
			.prayer(Prayer.RANGE)
			.form(ZulrahForm.MELEE)
			.snakelings(2)
			.attacks(6)
			.venom(3)
			.build();

		assertEquals(StandLocation.START, step.getPoints().get(0));
		assertEquals(ZulrahLocation.NORTH, step.getSpawn());
		assertEquals(2, step.getPrayers().size());
		assertEquals(Prayer.MAGIC, step.getPrayers().get(0));

		BufferedImage img = Images.createImage(step, getConfig());

		File out = new File("out/simple.png");
		ImageIO.write(img, "png", out);
	}

	@Test
	public void spawns() throws IOException
	{
		for (var loc : ZulrahLocation.values())
		{
			Step step = Step.builder()
				.point(StandLocation.START)
				.spawn(loc)
				.build();

			BufferedImage img = Images.createImage(step, getConfig());

			File out = new File("out/spawns/" + loc + ".png");
			ImageIO.write(img, "png", out);
		}
	}

	@Test
	public void points() throws IOException
	{
		for (var loc : StandLocation.values())
		{
			Step step = Step.builder()
				.point(loc)
				.prayer(Prayer.MAGIC)
				.build();

			BufferedImage img = Images.createImage(step, getConfig());

			File out = new File("out/points/" + loc + ".png");
			ImageIO.write(img, "png", out);
		}
	}
}

