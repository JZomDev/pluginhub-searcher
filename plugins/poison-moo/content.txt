package net.remindful;

import javax.inject.Inject;

import com.google.inject.Provides;

import lombok.extern.slf4j.Slf4j;
import net.remindful.enums.config.CureTicksChoice;
import net.remindful.enums.PoisonStatus;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import java.util.Random;

@Slf4j
@PluginDescriptor(
		name = "Poison Moo"
)
public class PoisonMooPlugin extends Plugin {

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private Notifier notifier;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PoisonMooConfig config;

	static final int COW_ATMOSPHERIC = 3044;

	static final Random rand = new Random();

	private final PoisonState poisonState = new PoisonState(0);

	@Provides
	PoisonMooConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PoisonMooConfig.class);
	}

	@Override
	protected void startUp() {
	}

	@Override
	protected void shutDown() {
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged event) {
		if (event.getVarpId() == VarPlayerID.POISON) {
			this.poisonState.setNextValue(event.getValue());
			moo(this.poisonState);
		}
	}

	private void moo(PoisonState poisonState) {
		if (poisonState.nextStatus() == PoisonStatus.Antipoisoned && !config.mooOnAntipoisonTicks()) {
			return;
		}
		if (poisonState.nextStatus() == PoisonStatus.Cured) {
			if (config.mooOnCureTicks() == CureTicksChoice.Never) {
				return;
			}
			if (!poisonState.poisonCured() && config.mooOnCureTicks() == CureTicksChoice.Poison_Cure) {
				return;
			}
		}

		var moo = new StringBuilder("Moo");

		switch (config.mooVariety()) {
			case Never:
				break;
			case Random:
				moo.append("o".repeat(rand.nextInt(config.maxMooLength())));
				break;
			case Damage:
				moo.append("o".repeat(Math.round(config.maxMooLength()*poisonState.damageFraction())));
				break;
			case Remaining:
				moo.append("o".repeat(Math.round(config.maxMooLength()*poisonState.remainingFraction())));
				break;
		}

		switch (config.tilde()) {
			case Never:
				break;
			case Always:
				moo.append('~');
				break;
			case Random:
				if (rand.nextBoolean()) {
					moo.append('~');
				}
				break;
		}

		switch (config.exclaim()) {
			case Never:
				break;
			case Always:
				moo.append('!');
				break;
			case Random:
				if (rand.nextBoolean()) {
					moo.append('!');
				}
				break;
		}

		var player = client.getLocalPlayer();
		player.setOverheadText(moo.toString());
		player.setOverheadCycle(config.mooDuration() * 1000 / Constants.CLIENT_TICK_LENGTH);

		if (config.playSoundEffectOnMoo()) {
			client.playSoundEffect(COW_ATMOSPHERIC);
		}
	}
}

package net.remindful;

import net.remindful.enums.config.CureTicksChoice;
import net.remindful.enums.config.ExclaimChoice;
import net.remindful.enums.config.MooVarietyChoice;
import net.remindful.enums.config.TildeChoice;
import net.runelite.client.config.*;

@ConfigGroup(net.remindful.PoisonMooConfig.GROUP)
public interface PoisonMooConfig extends Config {
	String GROUP = "poisonmoo";

	@ConfigItem(
			keyName = "mooOnAntipoisonTicks",
			name = "Moo on antipoison ticks",
			description = "Antiposion ticks are poison ticks with a negative value. Disabling this is arguably non-canon (Mod Ash comment pending)",
			position = 100
	)
	default boolean mooOnAntipoisonTicks() {
		return true;
	}

	@ConfigItem(
			keyName = "mooOnCureTicks",
			name = "Moo on cure ticks",
			description = "Cure ticks occur when a poison tick happens with a value of zero. Either because a poison/antipoison status ran out naturally, or because it was removed",
			position = 200
	)
	default CureTicksChoice mooOnCureTicks() {
		return CureTicksChoice.Always;
	}

	@ConfigItem(
			keyName = "playSoundEffectOnMoo",
			name = "Play sound effect on moo",
			description = "Play the cow mooing sound (uses in game sound effects volume). For true authenticity",
			position = 300
	)
	default boolean playSoundEffectOnMoo() {
		return false;
	}

	@Range(
			max = 18
	)
	@ConfigItem(
			keyName = "mooDuration",
			name = "Moo duration",
			description = "How long the overhead remains",
			position = 400
	)
	@Units(Units.SECONDS)
	default int mooDuration() {
		return 2;
	}

	@ConfigItem(
			keyName = "mooVariety",
			name = "Moo variety",
			description = "Moo in ways not known to OSRS before now",
			position = 500
	)
	default MooVarietyChoice mooVariety() {
		return MooVarietyChoice.Never;
	}

	@Range(
			max = 20
	)
	@ConfigItem(
			keyName = "maxMooLength",
			name = "Max extra length",
			description = "The maximum additional extra 'o's that will be added, if moo variety is on",
			position = 600
	)
	default int maxMooLength() {
		return 5;
	}

	@ConfigItem(
			keyName = "tilde",
			name = "~",
			description = "If you sort of like it",
			position = 700
	)
	default TildeChoice tilde() {
		return TildeChoice.Never;
	}

	@ConfigItem(
			keyName = "exclaim",
			name = "!",
			description = "If you want the world to know",
			position = 800
	)
	default ExclaimChoice exclaim() {
		return ExclaimChoice.Never;
	}
}


package net.remindful.enums;

public enum PoisonStatus {
	Cured,
	Poisoned,
	Antipoisoned;

	public static PoisonStatus fromValue(int value) {
		if (value < 0) {
			return Antipoisoned;
		}
		if (value > 0) {
			return Poisoned;
		}

		return Cured;
	}
}

package net.remindful.enums.config;

public enum ExclaimChoice {
	Never,
	Always,
	Random
}

package net.remindful.enums.config;

public enum MooVarietyChoice {
	Never,
	Random,
	Damage,
	Remaining
}

package net.remindful.enums.config;

public enum TildeChoice {
	Never,
	Always,
	Random
}

package net.remindful.enums.config;

public enum CureTicksChoice {
	Never,
	Always,
	Poison_Cure
}

package net.remindful;

import net.remindful.enums.PoisonStatus;

import static net.remindful.enums.PoisonStatus.*;

public class PoisonState {
	private int currentValue = 0;
	private int nextValue;

	public PoisonState(int nextValue) {
		this.nextValue = nextValue;
	}

	public void setNextValue(int nextValue) {
		this.currentValue = this.nextValue;
		this.nextValue = nextValue;
	}

	public PoisonStatus nextStatus() {
		return PoisonStatus.fromValue(this.nextValue);
	}

	public PoisonStatus currentStatus() {
		return PoisonStatus.fromValue(this.currentValue);
	}

	public boolean poisonCured() {
		return this.currentStatus() == Poisoned && this.nextStatus() == Cured;
	}

	public int damage() {
		if (this.nextStatus() != Poisoned) {
			return 0;
		}
		return nextDamage(this.currentValue);
	}

	private static float clamp(float fraction, float min, float max) {
		if (fraction < min) {
			return min;
		}
		if (fraction > max) {
			return max;
		}

		return fraction;
	}

	public float damageFraction() {
		return clamp((float) this.damage() / (float) MAX_DAMAGE, 0.0f, 1.0f);
	}

	public static final int MAX_ANTIVENOM_DURATION = 21;
	public static final int MAX_ANTIPOISON_DURATION = MAX_ANTIVENOM_DURATION + 38;
	public static final int MAX_POISON_DURATION = 100; // This is an assumption based off of damage values
	public float remainingFraction() {
		var statusRemaining =  remaining(this.nextValue);
		var fraction = 0f;

		if (this.nextStatus() == Antipoisoned) {
			if (statusRemaining > MAX_ANTIPOISON_DURATION) {
				fraction = (float) (statusRemaining - MAX_ANTIPOISON_DURATION) / (float) MAX_ANTIVENOM_DURATION;
			} else {
				fraction = (float) statusRemaining / (float) MAX_ANTIPOISON_DURATION;
			}
		} else if (this.nextStatus() == Poisoned) {
			fraction = (float) statusRemaining / (float) MAX_POISON_DURATION;
		}


		return clamp(fraction, 0.0f, 1.0f);
	}

	private static int remaining(int poisonValue) {
		int remaining = poisonValue;

		if (poisonValue >= VENOM_THRESHOLD) {
			remaining = poisonValue - VENOM_THRESHOLD - 3;
		}

		return Math.abs(remaining);
	}

	// Pulled from the Poison plugin
	private static final int VENOM_THRESHOLD = 1_000_000;
	public static final int MAX_DAMAGE = 20;
	private static int nextDamage(int poisonValue) {
		int damage;

		if (poisonValue >= VENOM_THRESHOLD) {
			//Venom Damage starts at 6, and increments in twos;
			//The VarPlayer increments in values of 1, however.
			poisonValue -= VENOM_THRESHOLD - 3;
			damage = poisonValue * 2;
			//Venom Damage caps at 20, but the VarPlayer keeps increasing
			if (damage > MAX_DAMAGE) {
				damage = MAX_DAMAGE;
			}
		} else {
			damage = (int) Math.ceil(poisonValue / 5.0f);
		}

		return damage;
	}
}
