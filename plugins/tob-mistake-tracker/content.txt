package com.tobmistaketracker.detector;

import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.TobMistakeTrackerPlugin;
import com.tobmistaketracker.TobRaider;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;
import java.util.List;

/**
 * Interface for detecting mistakes during The Theatre of Blood
 */
public abstract class BaseTobMistakeDetector {

    @Inject
    protected TobMistakeTrackerPlugin plugin;

    @Inject
    protected Client client;

    @Inject
    protected ClientThread clientThread;

    @Inject
    protected EventBus eventBus;

    @Getter
    public boolean detectingMistakes;

    protected BaseTobMistakeDetector() {
        detectingMistakes = false;
    }

    /**
     * Used to tell a detector to start listening for events.
     */
    public void startup() {
        eventBus.register(this);
        clientThread.invokeLater(this::computeDetectingMistakes);
    }

    /**
     * Shutdown and cleanup state. This is always called when the plugin is shutdown, or when a detector is finished.
     */
    public void shutdown() {
        detectingMistakes = false;
        eventBus.unregister(this);
    }

    /**
     * Compute if the detector should start detecting mistakes. This is always called from the client thread on startup.
     * This allows for detectors to startup right away if the plugin is turned on mid-raid, for example, and they missed
     * their normal startup trigger.
     */
    protected abstract void computeDetectingMistakes();

    /**
     * Detects mistakes for the given raider.
     * This is called during handling the {@link net.runelite.api.events.GameTick} event, each tick.
     *
     * @param raider - The raider to detect mistakes for
     * @return The list of {@link TobMistake} detected on this tick
     */
    public abstract List<TobMistake> detectMistakes(@NonNull TobRaider raider);

    /**
     * This optional method allows detectors to handle some logic after all detectMistakes methods have been invoked
     * for this {@link net.runelite.api.events.GameTick}.
     */
    public void afterDetect() {
    }
}

package com.tobmistaketracker.detector;

import com.google.common.annotations.VisibleForTesting;
import com.tobmistaketracker.TobBossNames;
import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.TobRaider;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * When Bloat spawns hands/feet, they hit the ground after 3 GameTicks. However, they also create a new GraphicsObject
 * for a blood squirt animation on that tick, so we can just detect when that spawns instead. For any player standing
 * on the same tile as the blood object, they are stunned.
 * <p>
 * I've decided that flying and taking a stomp are *not* universal mistakes, as they have legitimate use cases in the
 * current meta. I'd argue that taking a bloat hand/foot and getting stunned is *always* incorrect, though.
 * <p>
 * Getting hit by a hand/foot after Bloat has already died will *not* count as a mistake, though if the player dies,
 * it will still count as a death mistake.
 */
@Slf4j
@Singleton
public class BloatMistakeDetector extends BaseTobMistakeDetector {

    // This is the blood squirt animation that spawns and plays when a hand hits the ground.
    private static final int BLOAT_HAND_BLOOD_GRAPHICS_OBJECT_ID = 1576;

    private final Set<WorldPoint> activeHandTiles;

    @Inject
    public BloatMistakeDetector() {
        this.activeHandTiles = new HashSet<>();
    }

    @Override
    public void shutdown() {
        super.shutdown();
        activeHandTiles.clear();
    }

    @Override
    protected void computeDetectingMistakes() {
        if (!detectingMistakes && isAlreadySpawned()) {
            detectingMistakes = true;
        }
    }

    @Override
    public List<TobMistake> detectMistakes(@NonNull TobRaider raider) {
        if (!raider.isDead() && activeHandTiles.contains(raider.getPreviousWorldLocation())) {
            return Collections.singletonList(TobMistake.BLOAT_HAND);
        }

        return Collections.emptyList();
    }

    @Override
    public void afterDetect() {
        activeHandTiles.clear();
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        if (event.getGraphicsObject().getId() == BLOAT_HAND_BLOOD_GRAPHICS_OBJECT_ID) {
            LocalPoint localPoint = event.getGraphicsObject().getLocation();
            activeHandTiles.add(WorldPoint.fromLocal(client, localPoint));
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (!detectingMistakes && TobBossNames.BLOAT.equals(event.getActor().getName())) {
            detectingMistakes = true;
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath event) {
        Actor actor = event.getActor();
        if (actor instanceof NPC) {
            if (TobBossNames.BLOAT.equals(event.getActor().getName())) {
                shutdown();
            }
        }
    }

    private boolean isAlreadySpawned() {
        return client.getNpcs().stream().anyMatch(npc -> TobBossNames.BLOAT.equals(npc.getName()));
    }

    @VisibleForTesting
    public Set<WorldPoint> getActiveHandTiles() {
        return Collections.unmodifiableSet(activeHandTiles);
    }
}

package com.tobmistaketracker.detector;

import com.tobmistaketracker.TobBossNames;
import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.TobRaider;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static com.tobmistaketracker.TobMistakeTrackerPlugin.TOB_ROOM_TRANSITION_SCRIPT_ID;
import static com.tobmistaketracker.TobMistakeTrackerPlugin.getTobRoomEnterText;

@Slf4j
@Singleton
public class DeathMistakeDetector extends BaseTobMistakeDetector {

    private static final String REJOINED_PARTY_TEXT = "You have rejoined your party";
    private static final String NYLOCAS_NPC_NAME_PREFIX = "Nylocas";

    private final Set<String> playerDeaths;

    private TobRoom currentRoom;

    @NonNull
    private String previousRoomText; // For optimization so we only compute currentRoom on a new roomText

    @Inject
    public DeathMistakeDetector() {
        this.playerDeaths = new HashSet<>();
        currentRoom = null;
        this.previousRoomText = "";
    }

    @Override
    protected void computeDetectingMistakes() {
        // Always detect deaths throughout the raid
        detectingMistakes = true;

        if (currentRoom == null) {
            computeCurrentRoom();
        }
    }

    @Override
    public void shutdown() {
        super.shutdown();
        playerDeaths.clear();
        currentRoom = null;
    }

    @Override
    public List<TobMistake> detectMistakes(@NonNull TobRaider raider) {
        List<TobMistake> mistakes = new ArrayList<>();
        if (playerDeaths.contains(raider.getName())) {
            mistakes.add(TobMistake.DEATH);

            if (currentRoom == null) {
                // Try one more time to compute currentRoom
                computeCurrentRoom();
            }

            // In the case that we still can't determine which room we're in, we just won't add the room death
            if (currentRoom != null) {
                mistakes.add(currentRoom.getDeathMistake());
            }
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        playerDeaths.clear();
    }

    @Subscribe
    public void onActorDeath(ActorDeath event) {
        Actor actor = event.getActor();
        if (actor instanceof Player) {
            Player player = (Player) actor;

            if (plugin.isLoadedRaider(player.getName())) {
                playerDeaths.add(player.getName());
            }
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (currentRoom == null) {
            computeCurrentRoomForBossNpc(event.getNpc());
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (event.getScriptId() != TOB_ROOM_TRANSITION_SCRIPT_ID) return;

        final String roomText = getTobRoomEnterText(client);

        if (currentRoom == null && REJOINED_PARTY_TEXT.equals(roomText)) {
            computeCurrentRoom();
        }

        if (previousRoomText.equals(roomText)) {
            // No need to try to find a new TobRoom value as it's the same text as we just got previously.
            return;
        }
        previousRoomText = roomText;

        TobRoom tobRoom = TobRoom.fromRoomName(roomText);
        if (tobRoom != null && tobRoom != currentRoom) {
            log.debug("New Tob Room: " + tobRoom);
            currentRoom = tobRoom;
        }
    }

    /**
     * This is for handling edge cases in detecting the currentRoom. Normally, as long as there are no disconnects or
     * turning off/on the plugin mid-raid, the currentRoom will be computed during normal room transitions. This is to
     * catch the scenarios in which that wasn't possible, like detecting if there's a boss in the room etc.
     */
    private void computeCurrentRoom() {
        if (currentRoom != null) return; // Nothing to do

        // Let's check bosses first
        for (NPC npc : client.getNpcs()) {
            computeCurrentRoomForBossNpc(npc);

            if (currentRoom != null) return; // Compute completed
        }

        // Nylo should be the only room in which the just going off the boss won't necessarily work. For this case,
        // we can check for if there's *any* nylo in the room, as I don't think it's possible for a nylo to be in
        // a tob room without a boss already existing, except for Nylo room itself.
        for (NPC npc : client.getNpcs()) {
            if (npc.getName() != null && npc.getName().startsWith(NYLOCAS_NPC_NAME_PREFIX)) {
                currentRoom = TobRoom.NYLOCAS;
                log.debug("Computed Nylo Tob Room");
                return;
            }
        }

        // TODO: Technically Sotetseg maze shadow realm is still unaccounted for, but currently any deaths in there
        // anyway already don't fully work for everyone else, so let's just ignore it for now. The only way to get in
        // that state is to turn off and on your plugin while inside sot maze shadow realm and then have someone die.
    }

    private void computeCurrentRoomForBossNpc(NPC npc) {
        if (npc.getName() == null) return;

        TobRoom tobRoom = TobRoom.fromRoomBossName(npc.getName());
        if (tobRoom != null) {
            log.debug("Computed Tob Room: " + tobRoom);
            currentRoom = tobRoom;
        }
    }

    @AllArgsConstructor
    private enum TobRoom {
        MAIDEN("The Maiden of Sugadinti", TobMistake.DEATH_MAIDEN, TobBossNames.MAIDEN),
        BLOAT("The Pestilent Bloat", TobMistake.DEATH_BLOAT, TobBossNames.BLOAT),
        NYLOCAS("The Nylocas", TobMistake.DEATH_NYLOCAS, TobBossNames.NYLO_BOSS),
        SOTETSEG("Sotetseg", TobMistake.DEATH_SOTETSEG, TobBossNames.SOTETSEG),
        XARPUS("Xarpus", TobMistake.DEATH_XARPUS, TobBossNames.XARPUS),
        VERZIK("The Final Challenge", TobMistake.DEATH_VERZIK, TobBossNames.VERZIK);

        @Getter
        private final String roomName;

        @Getter
        private final TobMistake deathMistake;

        @Getter
        private final String roomBossName;

        /**
         * Retrieves the corresponding TobRoom for the specified roomName
         *
         * @param roomName - The name of the tob room
         * @return The TobRoom for the specified roomName, or null if none could be found
         */
        public static TobRoom fromRoomName(final String roomName) {
            for (TobRoom tobRoom : TobRoom.values()) {
                if (tobRoom.getRoomName().equals(roomName)) {
                    return tobRoom;
                }
            }

            return null;
        }

        /**
         * Retrieves the corresponding TobRoom for the specified boss
         *
         * @param roomBossName - The name of the main boss for the tob room
         * @return The TobRoom for the specified boss, or null if none could be found
         */
        public static TobRoom fromRoomBossName(final String roomBossName) {
            for (TobRoom tobRoom : TobRoom.values()) {
                if (tobRoom.getRoomBossName().equals(roomBossName)) {
                    return tobRoom;
                }
            }

            return null;
        }
    }
}

package com.tobmistaketracker.detector;

import com.google.common.annotations.VisibleForTesting;
import com.tobmistaketracker.TobBossNames;
import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.TobRaider;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Constants;
import net.runelite.api.GameObject;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * When Maiden throws her blood at players, she always throws 1 to where each player is currently standing, and 2 extra
 * to the furthest player. The remainingCycles on the blood Projectile depends on how far the player is from her
 * actual hitbox (not what's shown in-game, NE is closer). 1 tile away takes 65 cycles, incrementing by 15 for every
 * extra tile away from her hitbox (80, 95, 110, etc.). The extra two bloods thrown at the furthest player are *always*
 * +25 cycles from that player's blood spot (65 -> 90, 80 -> 105, 95 -> 120, etc.), which guarantees that they will
 * activate one tick later than the main blood spot.
 * <p>
 * Since there are 30 cycles per GameTick (a cycle happens once every 20ms), we can do some basic math to figure out
 * when the projectile is supposed to land on the tile and start becoming an active blood spot.
 * The math is: gameTicksToActivate = floor(remainingCycles / CYCLES_PER_GAME_TICK).
 * <p>
 * Once the blood spot is active, it *always* last for exactly 11 GameTicks.
 * <p>
 * Additionally, I was going to add splashing on a nylo as a mistake, but there were too many edge cases that couldn't
 * be resolved guaranteed, so I ended up scrapping it for now. I might revisit it in the future. In case I do, this
 * is how it works:
 * <p>
 * A player will freeze on tick 1, which is also when the Projectile is created and the graphic
 * on the npc is changed. By tick 2, the npc is actually frozen (if it caught), but the rest of the projectile
 * could take several more ticks to finish (up to 5 total?) -- We should add a delay on when to show the mistake
 * so it can't be used for decision-making.
 */
@Slf4j
@Singleton
public class MaidenMistakeDetector extends BaseTobMistakeDetector {

    private static final int BLOOD_SPAWN_BLOOD_GAME_OBJECT_ID = 32984;
    private static final int MAIDEN_BLOOD_PROJECTILE_ID = 1578;

    private static final int CYCLES_PER_GAME_TICK = Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

    // Each blood tile from maiden lasts exactly 11 ticks
    private static final int MAIDEN_BLOOD_GAME_TICK_LENGTH = 11;

    // It's easier to track these separately and check if a player is in either of them, since they (maybe?) can overlap
    // and we don't need to worry about removing one accidentally when the other despawns.
    private final Set<WorldPoint> bloodSpawnBloodTiles;
    private final Set<WorldPoint> maidenBloodTiles;

    private final Map<Integer, List<WorldPoint>> maidenBloodTilesToActivate; // Key is activationTick
    private final Map<Integer, List<WorldPoint>> activeMaidenBloodTiles; // Key is deactivationTick

    // From what I can tell, we need to remove the blood spawn tiles *after* we detect for that tick, so aggregate here
    private final Set<WorldPoint> bloodSpawnBloodTilesToRemove;

    @Inject
    public MaidenMistakeDetector() {
        bloodSpawnBloodTiles = new HashSet<>();
        bloodSpawnBloodTilesToRemove = new HashSet<>();
        maidenBloodTiles = new HashSet<>();
        maidenBloodTilesToActivate = new HashMap<>();
        activeMaidenBloodTiles = new HashMap<>();
    }

    @Override
    public void shutdown() {
        super.shutdown();
        bloodSpawnBloodTiles.clear();
        bloodSpawnBloodTilesToRemove.clear();
        maidenBloodTiles.clear();
        maidenBloodTilesToActivate.clear();
        activeMaidenBloodTiles.clear();
    }

    @Override
    protected void computeDetectingMistakes() {
        if (!detectingMistakes && isAlreadySpawned()) {
            detectingMistakes = true;
        }
    }

    @Override
    public List<TobMistake> detectMistakes(@NonNull TobRaider raider) {
        WorldPoint previousLocation = raider.getPreviousWorldLocation();
        if (!raider.isDead() && isOnBloodTile(previousLocation)) {
            return isSpawnedBlood(previousLocation) ? Collections.singletonList(TobMistake.MAIDEN_BLOOD) : Collections.singletonList(TobMistake.MAIDEN_BLOOD_SPAWN);
        }

        return Collections.emptyList();
    }

    @Override
    public void afterDetect() {
        // Remove the blood spawn blood tiles *after* detecting this tick, so that it's still around for detection.
        bloodSpawnBloodTiles.removeAll(bloodSpawnBloodTilesToRemove);
        bloodSpawnBloodTilesToRemove.clear();
    }

    private boolean isSpawnedBlood(WorldPoint worldPoint) {
        return maidenBloodTiles.contains(worldPoint);
    }

    private boolean isOnBloodTile(WorldPoint worldPoint) {
        return bloodSpawnBloodTiles.contains(worldPoint) || maidenBloodTiles.contains(worldPoint);
    }

    @Subscribe
    public void onProjectileMoved(ProjectileMoved event) {
        if (event.getProjectile().getId() == MAIDEN_BLOOD_PROJECTILE_ID) {
            int gameTicksToActivate =
                    (int) Math.floor((double) event.getProjectile().getRemainingCycles() / CYCLES_PER_GAME_TICK);
            int activationTick = client.getTickCount() + gameTicksToActivate;
            WorldPoint worldPoint = WorldPoint.fromLocal(client, event.getPosition());

            maidenBloodTilesToActivate.computeIfAbsent(activationTick, k -> new ArrayList<>()).add(worldPoint);
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        GameObject go = event.getGameObject();
        if (go.getId() == BLOOD_SPAWN_BLOOD_GAME_OBJECT_ID) {
            // TODO: These are missing if the plugin is turned on during the wave, after some have spawned. We could
            // TODO: aggregate all of them on startup too, to catch whatever's already been spawned. Pretty minor though
            bloodSpawnBloodTiles.add(go.getWorldLocation());
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        GameObject go = event.getGameObject();
        if (go.getId() == BLOOD_SPAWN_BLOOD_GAME_OBJECT_ID) {
            // Remove these *after* detecting this tick, since they were still present in the previous player location.
            bloodSpawnBloodTilesToRemove.add(go.getWorldLocation());
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (!detectingMistakes && TobBossNames.MAIDEN.equals(event.getActor().getName())) {
            detectingMistakes = true;
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath event) {
        Actor actor = event.getActor();
        if (actor instanceof NPC) {
            if (TobBossNames.MAIDEN.equals(event.getActor().getName())) {
                shutdown();
            }
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        int currentGameTick = client.getTickCount();

        // Find all blood tiles to activate this Game Tick
        if (maidenBloodTilesToActivate.containsKey(currentGameTick)) {
            int deactivationTick = currentGameTick + MAIDEN_BLOOD_GAME_TICK_LENGTH;
            for (WorldPoint worldPoint : maidenBloodTilesToActivate.remove(currentGameTick)) {
                activeMaidenBloodTiles.computeIfAbsent(deactivationTick, k -> new ArrayList<>()).add(worldPoint);
                // Also add to maiden blood tiles Set for fast detection
                maidenBloodTiles.add(worldPoint);
            }
        }

        // Remove all blood tiles that should deactivate this Game Tick
        if (activeMaidenBloodTiles.containsKey(currentGameTick)) {
            for (WorldPoint worldPoint : activeMaidenBloodTiles.remove(currentGameTick)) {
                maidenBloodTiles.remove(worldPoint);
            }
        }
    }

    private boolean isAlreadySpawned() {
        return client.getNpcs().stream().anyMatch(npc -> TobBossNames.MAIDEN.equals(npc.getName()));
    }

    @VisibleForTesting
    public Set<WorldPoint> getBloodSpawnBloodTiles() {
        return Collections.unmodifiableSet(bloodSpawnBloodTiles);
    }

    @VisibleForTesting
    public Set<WorldPoint> getMaidenBloodTiles() {
        return Collections.unmodifiableSet(maidenBloodTiles);
    }
}

package com.tobmistaketracker.detector;

import com.google.common.annotations.VisibleForTesting;
import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.TobRaider;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Manager for all the {@link BaseTobMistakeDetector}. It keeps all the detectors in memory in order to manage events.
 * <p>
 * All detectors initialized in the manager are responsible for determining when to start detecting mistakes.
 * The manager may call the startup() or shutdown() method on a detector at any time.
 * <p>
 * When the manager is on (started = true), then all other detectors are subscribed to the EventBus and
 * listening for events on when to turn themselves on/off. This will only be true while the player is in Tob.
 */
@Slf4j
@Singleton
public class MistakeDetectorManager {

    private final List<BaseTobMistakeDetector> mistakeDetectors;

    @Getter
    @VisibleForTesting
    private boolean started;

    @Inject
    public MistakeDetectorManager(DeathMistakeDetector deathMistakeDetector,
                                  MaidenMistakeDetector maidenMistakeDetector,
                                  BloatMistakeDetector bloatMistakeDetector,
                                  VerzikP2MistakeDetector verzikP2MistakeDetector,
                                  VerzikP3MistakeDetector verzikP3MistakeDetector) {
        // Order matters -- death should be last
        this.mistakeDetectors = new ArrayList<>(Arrays.asList(
                maidenMistakeDetector,
                bloatMistakeDetector,
                verzikP2MistakeDetector,
                verzikP3MistakeDetector,
                deathMistakeDetector));
        this.started = false;
    }

    public void startup() {
        started = true;
        for (BaseTobMistakeDetector mistakeDetector : mistakeDetectors) {
            mistakeDetector.startup();
        }
    }

    public void shutdown() {
        started = false;
        for (BaseTobMistakeDetector mistakeDetector : mistakeDetectors) {
            mistakeDetector.shutdown();
        }
        // Don't clear mistakeDetectors or else we can't get them back.
    }

    public List<TobMistake> detectMistakes(@NonNull TobRaider raider) {
        List<TobMistake> mistakes = new ArrayList<>();

        if (!started) {
            return mistakes;
        }

        for (BaseTobMistakeDetector mistakeDetector : mistakeDetectors) {
            if (mistakeDetector.isDetectingMistakes()) {
                mistakes.addAll(mistakeDetector.detectMistakes(raider));
            }
        }

        return mistakes;
    }

    public void afterDetect() {
        if (!started) return;

        for (BaseTobMistakeDetector mistakeDetector : mistakeDetectors) {
            if (mistakeDetector.isDetectingMistakes()) {
                mistakeDetector.afterDetect();
            }
        }
    }

    public List<BaseTobMistakeDetector> getMistakeDetectors() {
        return Collections.unmodifiableList(mistakeDetectors);
    }
}

package com.tobmistaketracker.detector.MistakeDetectors;

import lombok.Getter;
import lombok.Setter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.gameval.AnimationID;

import java.util.Set;

@Slf4j
public class VerzikMeleeChancedTracker {

    @Value
    public static class MeleeChanceData {

        String playerName;
        boolean wasMelee;
    }

    @Getter
    @Setter
    private MeleeChanceData meleeChanceData;

    private String lastTickTarget;
    private WorldArea lastTickTargetArea;
    private WorldArea lastTickVerzikArea;

    private static final Set<Integer> VERZIK_ATTACK_ANIMATIONS = Set.of(
            AnimationID.VERZIK_PHASE3_ATTACK_MELEE,
            AnimationID.VERZIK_PHASE3_ATTACK_MAGIC,
            AnimationID.VERZIK_PHASE3_ATTACK_RANGED
    );

    public void setVerzikAttackInfo(NPC verzik) {
        if (verzik == null) {
            emptyTickData();
        } else {
            Actor target = verzik.getInteracting();
            if (target instanceof Player) {
                lastTickTarget = target.getName();
                lastTickTargetArea = target.getWorldArea();
                lastTickVerzikArea = verzik.getWorldArea();
            } else {
                emptyTickData();
            }
        }
    }

    public void checkPlayerWronglyTanked(AnimationChanged event) {
        int animationId = event.getActor().getAnimation();

        if (VERZIK_ATTACK_ANIMATIONS.contains(animationId)) {
            if (lastTickTarget != null && lastTickTargetArea != null && lastTickVerzikArea != null) {
                if (isWronglyTanked(lastTickVerzikArea, lastTickTargetArea)) {
                    boolean wasMelee = AnimationID.VERZIK_PHASE3_ATTACK_MELEE == animationId;
                    meleeChanceData = new MeleeChanceData(lastTickTarget, wasMelee);
                }
            }
        }
    }

    public void dispose(){
        emptyTickData();
    }

    private boolean isWronglyTanked(WorldArea verzikArea, WorldArea tankArea) {
        return !verzikArea.intersectsWith(tankArea) && verzikArea.distanceTo(tankArea) == 1;
    }

    private void emptyTickData() {
        lastTickTarget = null;
        lastTickTargetArea = null;
        lastTickVerzikArea = null;
    }
}

package com.tobmistaketracker.detector;

import com.google.common.annotations.VisibleForTesting;
import com.tobmistaketracker.TobBossNames;
import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.TobRaider;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Verzik P2 is pretty straightforward. Detect the specific game objects/graphics objects/animations and we're done.
 * Currently this tracks bounces, bombs, and acid tiles.
 */
@Slf4j
@Singleton
public class VerzikP2MistakeDetector extends BaseTobMistakeDetector {

    private static final int VERZIK_BOMB_GRAPHICS_OBJECT_ID = 1584;
    private static final int PLAYER_BOUNCE_ANIMATION_ID = 1157;
    private static final int VERZIK_ACID_GAME_OBJECT_ID = 41747;
    private static final Set<Integer> VERZIK_P2_IDS = Set.of(
            10833, // Entry
            8372, // Normal
            10850 // Hard
    );

    private final Set<WorldPoint> activeBombTiles;

    private final Set<WorldPoint> activeAcidTiles;
    private final Set<WorldPoint> acidTilesToRemove;

    // AFAIK you can only have one person bounced per tick, but just in case that ever changes...
    private final Set<String> playerNamesBounced;

    @Inject
    public VerzikP2MistakeDetector() {
        activeBombTiles = new HashSet<>();
        activeAcidTiles = new HashSet<>();
        acidTilesToRemove = new HashSet<>();
        playerNamesBounced = new HashSet<>();
    }

    @Override
    public void shutdown() {
        super.shutdown();
        activeBombTiles.clear();
        activeAcidTiles.clear();
        acidTilesToRemove.clear();
        playerNamesBounced.clear();
    }

    @Override
    protected void computeDetectingMistakes() {
        if (!detectingMistakes && isAlreadySpawned()) {
            detectingMistakes = true;
        }
    }

    @Override
    public List<TobMistake> detectMistakes(@NonNull TobRaider raider) {
        List<TobMistake> mistakes = new ArrayList<>();

        if (raider.isDead()) {
            return mistakes;
        }

        // Put acid mistake first, so if acid and bomb happen on the same tick, the chat overhead is for the latter.
        if (activeAcidTiles.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(TobMistake.VERZIK_P2_ACID);
        }

        if (activeBombTiles.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(TobMistake.VERZIK_P2_BOMB);
        }

        // Currently, there doesn't seem to be a way to be both bombed *and* bounced on the same tick, but let's
        // write it up this way anyway in case that ever changes, since it's not a problem to do so.
        if (playerNamesBounced.contains(raider.getName())) {
            mistakes.add(TobMistake.VERZIK_P2_BOUNCE);
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        activeBombTiles.clear();
        activeAcidTiles.removeAll(acidTilesToRemove);
        acidTilesToRemove.clear();
        playerNamesBounced.clear();
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        if (event.getGraphicsObject().getId() == VERZIK_BOMB_GRAPHICS_OBJECT_ID) {
            WorldPoint worldPoint = WorldPoint.fromLocal(client, event.getGraphicsObject().getLocation());
            activeBombTiles.add(worldPoint);
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        if (event.getGameObject().getId() == VERZIK_ACID_GAME_OBJECT_ID) {
            activeAcidTiles.add(event.getGameObject().getWorldLocation());
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        if (event.getGameObject().getId() == VERZIK_ACID_GAME_OBJECT_ID) {
            // Remove these *after* detecting this tick, since they were still present in the previous player location.
            acidTilesToRemove.add(event.getGameObject().getWorldLocation());
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        if (event.getActor() instanceof Player && event.getActor().getAnimation() == PLAYER_BOUNCE_ANIMATION_ID) {
            playerNamesBounced.add(event.getActor().getName());
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (!detectingMistakes && isVerzikP2(event.getNpc())) {
            detectingMistakes = true;
        }
    }

    @Subscribe
    public void onNpcChanged(NpcChanged event) {
        if (!detectingMistakes && isVerzikP2(event.getNpc())) {
            detectingMistakes = true;
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath event) {
        if (event.getActor() instanceof NPC && isVerzikP2((NPC) event.getActor())) {
            shutdown();
        }
    }

    private boolean isAlreadySpawned() {
        return client.getNpcs().stream().anyMatch(VerzikP2MistakeDetector::isVerzikP2);
    }

    private static boolean isVerzikP2(NPC npc) {
        return TobBossNames.VERZIK.equals(npc.getName()) && VERZIK_P2_IDS.contains(npc.getId());
    }

    @VisibleForTesting
    public Set<WorldPoint> getVerzikP2AcidTiles() {
        return Collections.unmodifiableSet(activeAcidTiles);
    }
}

package com.tobmistaketracker.detector;

import com.google.common.annotations.VisibleForTesting;
import com.tobmistaketracker.TobBossNames;
import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.TobRaider;
import com.tobmistaketracker.detector.MistakeDetectors.VerzikMeleeChancedTracker;
import com.tobmistaketracker.detector.MistakeDetectors.VerzikMeleeChancedTracker.MeleeChanceData;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Verzik P3 is also pretty straightforward -- detect for webs/purples and show them.
 * <p>
 * We are intentionally waiting until the web has *despawned* and checking if a player was standing on it in order
 * to combat any form of "cheating" where the mistake detection can be seen as a communication mechanic.
 * <p>
 * In the future, this will also add verzik melee for the player tanking, but we currently can't easily
 * detect when verzik is meleeing, unless the dev team unmask certain animations/graphics for P3.
 */
@Slf4j
@Singleton
public class VerzikP3MistakeDetector extends BaseTobMistakeDetector {
    private VerzikMeleeChancedTracker verzikMeleeChancedTracker = new VerzikMeleeChancedTracker();

    private static final Set<Integer> VERZIK_P3_IDS = Set.of(
            10835, // Entry
            8374, // Normal
            10852 // Hard
    );

    private static final int VERZIK_WEB_GAME_OBJECT_ID = 32734;
    private static final int PLAYER_PURPLE_GRAPHIC_ID = 1602;

    private final Set<WorldPoint> activeWebTiles;
    private final Set<WorldPoint> webTilesToRemove;

    private final Set<String> playerNamesPurpled;
    private NPC verzikP3NPC;

    @Inject
    public VerzikP3MistakeDetector() {
        activeWebTiles = new HashSet<>();
        webTilesToRemove = new HashSet<>();
        playerNamesPurpled = new HashSet<>();
    }

    @Override
    public void shutdown() {
        super.shutdown();
        activeWebTiles.clear();
        webTilesToRemove.clear();
        playerNamesPurpled.clear();
        verzikMeleeChancedTracker.dispose();

        verzikP3NPC = null;
    }

    @Override
    protected void computeDetectingMistakes() {
        if (!detectingMistakes && isAlreadySpawned()) {
            enableDetectingMistakes();
        }
    }

    @Override
    public List<TobMistake> detectMistakes(@NonNull TobRaider raider) {
        List<TobMistake> mistakes = new ArrayList<>();

        if (raider.isDead()) {
            return mistakes;
        }

        // If this web just despawned, we can track this mistake
        // Note: We are intentionally delaying detecting this, so as to avoid cheating
        if (webTilesToRemove.contains(raider.getPreviousWorldLocation())) {
            mistakes.add(TobMistake.VERZIK_P3_WEB);
        }

        if (playerNamesPurpled.contains(raider.getName())) {
            mistakes.add(TobMistake.VERZIK_P3_PURPLE);
        }

        MeleeChanceData chancedMeleePlayer = verzikMeleeChancedTracker.getMeleeChanceData();
        if (chancedMeleePlayer != null && chancedMeleePlayer.getPlayerName().equals(raider.getName())) {
            TobMistake mistake = chancedMeleePlayer.isWasMelee() ?
                    TobMistake.VERZIK_P3_MELEE_TANKED :
                    TobMistake.VERZIK_P3_MELEE_CHANCED;
            mistakes.add(mistake);
        }

        return mistakes;
    }

    @Override
    public void afterDetect() {
        activeWebTiles.removeAll(webTilesToRemove);
        webTilesToRemove.clear();
        playerNamesPurpled.clear();
        verzikMeleeChancedTracker.setMeleeChanceData(null);
    }

    @Subscribe
    public void onGraphicChanged(GraphicChanged event) {
        if (event.getActor() instanceof Player && event.getActor().getGraphic() == PLAYER_PURPLE_GRAPHIC_ID) {
            playerNamesPurpled.add(event.getActor().getName());
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (verzikP3NPC != null) {
            verzikMeleeChancedTracker.setVerzikAttackInfo(verzikP3NPC);
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        if (event.getActor() instanceof NPC) {
            verzikMeleeChancedTracker.checkPlayerWronglyTanked(event);
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event) {
        if (!detectingMistakes && isVerzikP3(event.getNpc())) {
            enableDetectingMistakes();
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event) {
        if (event.getGameObject().getId() == VERZIK_WEB_GAME_OBJECT_ID) {
            activeWebTiles.add(event.getGameObject().getWorldLocation());
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event) {
        if (event.getGameObject().getId() == VERZIK_WEB_GAME_OBJECT_ID) {
            // Remove these *after* detecting this tick, since they were still present in the previous player location.
            webTilesToRemove.add(event.getGameObject().getWorldLocation());
        }
    }

    @Subscribe
    public void onNpcChanged(NpcChanged event) {
        if (!detectingMistakes && isVerzikP3(event.getNpc())) {
            enableDetectingMistakes();
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath event) {
        if (event.getActor() instanceof NPC && isVerzikP3((NPC) event.getActor())) {
            shutdown();
        }
    }

    private boolean isAlreadySpawned() {
        return client.getNpcs().stream().anyMatch(VerzikP3MistakeDetector::isVerzikP3);
    }

    private static boolean isVerzikP3(NPC npc) {
        return TobBossNames.VERZIK.equals(npc.getName()) && VERZIK_P3_IDS.contains(npc.getId());
    }

    private void enableDetectingMistakes() {
        detectingMistakes = true;

        verzikP3NPC = client.getNpcs().stream()
                .filter(VerzikP3MistakeDetector::isVerzikP3)
                .findFirst()
                .orElse(null);
    }

    @VisibleForTesting
    public Set<WorldPoint> getVerzikP3WebTiles() {
        return Collections.unmodifiableSet(activeWebTiles);
    }
}

package com.tobmistaketracker.panel;

import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.state.MistakeStateManager;
import lombok.Getter;
import lombok.NonNull;
import lombok.Value;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

public class PlayerMistakesBox extends JPanel {

    private static final int ITEMS_PER_ROW = 5;

    private final MistakeStateManager mistakeStateManager;

    @NonNull
    @Getter
    private final String playerName;
    private int totalMistakes;

    private final JPanel mistakesContainer = new JPanel();
    private final JLabel raidCountLabel;
    private final JLabel mistakeCountLabel;

    protected PlayerMistakesBox(MistakeStateManager mistakeStateManager, @NonNull String playerName) {
        this.mistakeStateManager = mistakeStateManager;
        this.playerName = playerName;

        setLayout(new BorderLayout(0, 1));
        setBorder(new EmptyBorder(5, 0, 0, 0));

        final JPanel playerMistakesTitle = new JPanel(new BorderLayout(5, 0));
        playerMistakesTitle.setBorder(new EmptyBorder(7, 7, 7, 7));
        playerMistakesTitle.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

        final JLabel playerNameLabel = new JLabel(playerName); // e.g. Questing Pet
        playerNameLabel.setFont(FontManager.getRunescapeSmallFont());
        playerNameLabel.setForeground(Color.WHITE);
        playerMistakesTitle.add(playerNameLabel, BorderLayout.WEST);

        mistakeCountLabel = new JLabel(); // e.g. 78 Mistakes
        mistakeCountLabel.setFont(FontManager.getRunescapeSmallFont());
        mistakeCountLabel.setForeground(Color.LIGHT_GRAY);
        mistakeCountLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        playerMistakesTitle.add(mistakeCountLabel, BorderLayout.CENTER);

        raidCountLabel = new JLabel(); // e.g. (53 Raids)
        raidCountLabel.setFont(FontManager.getRunescapeSmallFont());
        raidCountLabel.setForeground(Color.GRAY);
        playerMistakesTitle.add(raidCountLabel, BorderLayout.EAST);

        add(playerMistakesTitle, BorderLayout.NORTH);
        add(mistakesContainer, BorderLayout.CENTER);

        // Create popup menu for resetting the player's mistakes
        final JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
        setComponentPopupMenu(popupMenu);
    }

    void rebuildAllMistakes(boolean isRaidDeaths) {
        buildMistakes(isRaidDeaths);

        final String mistakeString = totalMistakes == 1 ? "Mistake" : "Mistakes";
        mistakeCountLabel.setText(String.format("%s %s", totalMistakes, mistakeString));

        final int totalRaids = mistakeStateManager.getRaidCountForPlayer(playerName);
        if (totalRaids > 0) {
            final String raidString = totalRaids == 1 ? "Raid" : "Raids";
            raidCountLabel.setText(String.format("(%s %s)", totalRaids, raidString));
        }

        validate();
        repaint();
    }

    private void buildMistakes(boolean isRaidDeaths) {
        totalMistakes = 0;
        setVisible(true);

        List<TobMistakeCount> mistakeCountsForPlayer = new ArrayList<>();
        for (TobMistake mistake : TobMistake.values()) {
            if (isRaidDeaths && TobMistake.isRoomDeath(mistake)) {
                continue;
            } else if (!isRaidDeaths && mistake == TobMistake.DEATH) {
                continue;
            }

            int mistakeCount = mistakeStateManager.getMistakeCountForPlayer(playerName, mistake);
            if (mistakeCount > 0) {
                totalMistakes += mistakeCount;
                mistakeCountsForPlayer.add(new TobMistakeCount(mistake, mistakeCount));
            }
        }

        int numRows = calculateNumRows(mistakeCountsForPlayer.size());

        mistakesContainer.removeAll();
        mistakesContainer.setLayout(new GridLayout(numRows, ITEMS_PER_ROW, 1, 1));

        for (int i = 0; i < numRows * ITEMS_PER_ROW; i++) {
            // Create the panel for this mistake
            final JPanel mistakeContainer = new JPanel(new BorderLayout(0, 0));
            mistakeContainer.setMaximumSize(new Dimension(36, 32));
            mistakeContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            // If we still have mistakes to show for this row
            if (i < mistakeCountsForPlayer.size()) {
                TobMistakeCount mistakeCount = mistakeCountsForPlayer.get(i);

                // Create the image label
                final JLabel imageLabel = new JLabel();
                imageLabel.setLayout(new BorderLayout(0, 0));
                imageLabel.setToolTipText(mistakeCount.getTooltipText());
                imageLabel.setVerticalAlignment(SwingConstants.CENTER);
                imageLabel.setHorizontalAlignment(SwingConstants.CENTER);

                BufferedImage mistakeImage = mistakeCount.getMistake().getMistakeImage();
                imageLabel.setIcon(new ImageIcon(mistakeImage));

                // Create the quantity label
                final JLabel quantityLabel = new JLabel();
                quantityLabel.setText(String.valueOf(mistakeCount.getCount()));
                quantityLabel.setFont(FontManager.getRunescapeSmallFont());
                quantityLabel.setForeground(Color.YELLOW);
                quantityLabel.setVerticalAlignment(SwingConstants.BOTTOM);
                quantityLabel.setHorizontalAlignment(SwingConstants.LEFT);

                // Add them to the panel
                imageLabel.add(quantityLabel, BorderLayout.NORTH); // Add the quantity to the image so it's on top of it
                mistakeContainer.add(imageLabel);

            }
            mistakesContainer.add(mistakeContainer);
        }

        mistakesContainer.repaint();
    }

    private static int calculateNumRows(int numItems) {
        return (int) Math.ceil((double) numItems / ITEMS_PER_ROW);
    }

    @Value
    private static class TobMistakeCount {

        TobMistake mistake;
        int count;
        String tooltipText;

        TobMistakeCount(TobMistake mistake, int count) {
            this.mistake = mistake;
            this.count = count;
            this.tooltipText = String.format("%s x %s", mistake.getMistakeName(), count);
        }
    }
}

package com.tobmistaketracker.panel;

import com.tobmistaketracker.TobMistake;
import com.tobmistaketracker.TobMistakeTrackerPlugin;
import com.tobmistaketracker.state.MistakeStateManager;
import com.tobmistaketracker.state.MistakeStateReader;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.util.SwingUtil;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ButtonGroup;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JRadioButton;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class TobMistakeTrackerPanel extends PluginPanel {

    private static final String HTML_LABEL_TEMPLATE =
            "<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";

    private static final boolean DEFAULT_IS_RAID_DEATHS = false;

    private static final ImageIcon RAID_DEATHS_ICON;
    private static final ImageIcon RAID_DEATHS_ICON_FADED;
    private static final ImageIcon RAID_DEATHS_ICON_HOVER;

    private static final ImageIcon ROOM_DEATHS_ICON;
    private static final ImageIcon ROOM_DEATHS_ICON_FADED;
    private static final ImageIcon ROOM_DEATHS_ICON_HOVER;

    private final Client client;

    private final MistakeStateManager mistakeStateManager;

    private List<String> currentRaiderNames;

    private final JLabel currentViewTitle = new JLabel();
    private final JButton switchMistakesViewBtn = new JButton();

    private final JRadioButton raidDeathsBtn = new JRadioButton();
    private final JRadioButton roomDeathsBtn = new JRadioButton();

    // Panel for overall mistake data
    private final JPanel overallPanel = new JPanel();
    private final JLabel overallPlayersLabel = new JLabel();
    private final JLabel overallMistakesLabel = new JLabel();
    private final JLabel overallRaidsLabel = new JLabel();
    private final JLabel overallIcon = new JLabel();

    // Panel for all PlayerMistakesBoxes
    private final JPanel mistakesContainer = new JPanel();

    // Keep track of all boxes
    private final List<PlayerMistakesBox> playerMistakesBoxes = new ArrayList<>();

    // Keep track of the current death grouping
    private boolean isRaidDeaths;
    // Keep track of the current view we're showing
    private boolean isShowingAll = false;

    private final PluginErrorPanel errorPanel = new PluginErrorPanel();

    static {
        final BufferedImage raidDeathsImg = ImageUtil.loadImageResource(
                TobMistakeTrackerPlugin.class, "raid_deaths.png");
        final BufferedImage roomDeathsImg = ImageUtil.loadImageResource(
                TobMistakeTrackerPlugin.class, "room_deaths.png");

        RAID_DEATHS_ICON = new ImageIcon(raidDeathsImg);
        RAID_DEATHS_ICON_FADED = new ImageIcon(ImageUtil.alphaOffset(raidDeathsImg, -180));
        RAID_DEATHS_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(raidDeathsImg, -220));

        ROOM_DEATHS_ICON = new ImageIcon(roomDeathsImg);
        ROOM_DEATHS_ICON_FADED = new ImageIcon(ImageUtil.alphaOffset(roomDeathsImg, -180));
        ROOM_DEATHS_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(roomDeathsImg, -220));
    }

    @Inject
    public TobMistakeTrackerPanel(Client client, MistakeStateReader mistakeStateReader,
                                  @Named("developerMode") boolean developerMode) {
        this.client = client;
        this.mistakeStateManager = mistakeStateReader.read();
        this.currentRaiderNames = Collections.emptyList();

        setBorder(new EmptyBorder(6, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Add the outer panel for wrapping everything else inside
        final JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
        add(layoutPanel, BorderLayout.NORTH);

        // Create panel for the header (contains things like view, action buttons, etc.)
        JPanel headerContainer = new JPanel(new GridLayout(2, 1, 0, 0));
        headerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create the view container
        final JPanel viewContainer = new JPanel(new BorderLayout());
        viewContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewContainer.setPreferredSize(new Dimension(0, 30));
        viewContainer.setBorder(new EmptyBorder(5, 5, 5, 10));

        // Create the container for the view title
        final JPanel leftTitleContainer = new JPanel(new BorderLayout(5, 0));
        leftTitleContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create the current view title
        currentViewTitle.setForeground(Color.WHITE);
        currentViewTitle.setText(getCurrentViewTitleText());
        leftTitleContainer.add(currentViewTitle, BorderLayout.WEST);

        // Create the switch view button
        switchMistakesViewBtn.setText(getSwitchMistakesViewButtonText());
        switchMistakesViewBtn.setBackground(Color.DARK_GRAY);
        switchMistakesViewBtn.setBorder(new EmptyBorder(10, 10, 10, 10));
        switchMistakesViewBtn.setBorderPainted(true);
        switchMistakesViewBtn.setPreferredSize(new Dimension(100, 10));

        // Add the listeners to the button
        switchMistakesViewBtn.addActionListener(e -> switchMistakesView());
        switchMistakesViewBtn.addMouseListener(new MouseAdapter() {
            public void mouseEntered(MouseEvent e) {
                switchMistakesViewBtn.setBackground(Color.GRAY);
            }

            public void mouseExited(MouseEvent e) {
                switchMistakesViewBtn.setBackground(Color.DARK_GRAY);
            }
        });

        // Add the view container to header
        viewContainer.add(leftTitleContainer, BorderLayout.WEST);
        viewContainer.add(switchMistakesViewBtn, BorderLayout.EAST);
        headerContainer.add(viewContainer);

        // Create the panel for the action buttons
        final JPanel actionButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        actionButtons.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        actionButtons.setPreferredSize(new Dimension(0, 30));
        actionButtons.setBorder(new EmptyBorder(5, 5, 5, 10));

        // Create the raid deaths button
        SwingUtil.removeButtonDecorations(raidDeathsBtn);
        raidDeathsBtn.setIcon(RAID_DEATHS_ICON_FADED);
        raidDeathsBtn.setRolloverIcon(RAID_DEATHS_ICON_HOVER);
        raidDeathsBtn.setSelectedIcon(RAID_DEATHS_ICON);
        raidDeathsBtn.setToolTipText("Group all raid deaths into a singular mistake");
        raidDeathsBtn.addActionListener(e -> changeDeathGrouping(true));

        // Create the room deaths button
        SwingUtil.removeButtonDecorations(roomDeathsBtn);
        roomDeathsBtn.setIcon(ROOM_DEATHS_ICON_FADED);
        roomDeathsBtn.setRolloverIcon(ROOM_DEATHS_ICON_HOVER);
        roomDeathsBtn.setSelectedIcon(ROOM_DEATHS_ICON);
        roomDeathsBtn.setToolTipText("Show each room's deaths as their own mistakes");
        roomDeathsBtn.addActionListener(e -> changeDeathGrouping(false));

        ButtonGroup raidRoomGroup = new ButtonGroup();
        raidRoomGroup.add(raidDeathsBtn);
        raidRoomGroup.add(roomDeathsBtn);

        // Add all action buttons to the header
        actionButtons.add(raidDeathsBtn);
        actionButtons.add(roomDeathsBtn);
        headerContainer.add(actionButtons);

        changeDeathGrouping(DEFAULT_IS_RAID_DEATHS);
        headerContainer.setVisible(true);

        // Create panel that will contain overall data (at the top)
        overallPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(5, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR),
                BorderFactory.createEmptyBorder(8, 10, 8, 10)
        ));
        overallPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        overallPanel.setLayout(new BorderLayout());

        // Add icon and contents to overallPanel
        final JPanel overallInfo = new JPanel();
        overallInfo.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        overallInfo.setLayout(new GridLayout(3, 1));
        overallInfo.setBorder(new EmptyBorder(2, 10, 2, 0));
        overallPlayersLabel.setFont(FontManager.getRunescapeSmallFont());
        overallMistakesLabel.setFont(FontManager.getRunescapeSmallFont());
        overallRaidsLabel.setFont(FontManager.getRunescapeSmallFont());
        overallInfo.add(overallPlayersLabel);
        overallInfo.add(overallMistakesLabel);
        overallInfo.add(overallRaidsLabel);
        overallPanel.add(overallIcon, BorderLayout.WEST);
        overallPanel.add(overallInfo, BorderLayout.CENTER);

        // Create reset all menu
        final JMenuItem reset = new JMenuItem("Reset All");
        reset.addActionListener(e ->
        {
            final int result = JOptionPane.showOptionDialog(overallPanel,
                    "This will permanently delete ALL mistakes across ALL raids from the client.",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");

            if (result != JOptionPane.YES_OPTION) {
                return;
            }

            resetAll();
        });

        // Create popup menu
        final JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
        popupMenu.add(reset);
        overallPanel.setComponentPopupMenu(popupMenu);

        // Create the mistakes panel which shows all mistakes for all players
        mistakesContainer.setLayout(new BoxLayout(mistakesContainer, BoxLayout.Y_AXIS));

        // Add all our panels in the order we want them to appear
        layoutPanel.add(headerContainer);
        layoutPanel.add(overallPanel);
        layoutPanel.add(mistakesContainer);

        // Create testing button
        if (developerMode) {
            JButton testButton = new JButton("Test Mistakes");
            testButton.addActionListener(e ->
            {
                for (TobMistake mistake : TobMistake.values()) {
                    addMistakeForPlayer("Test Player", mistake);
                }
            });
            layoutPanel.add(testButton);
        }

        // Add the error for when there are no mistakes yet
        errorPanel.setContent("Tob Mistake Tracker", "You have not tracked any mistakes yet.");
        updateVisiblePanels(true);
    }

    /**
     * The plugin has been reloaded, reload the panel
     */
    public void reload() {
        rebuildAll();
    }

    public void loadHeaderIcon(BufferedImage img) {
        overallIcon.setIcon(new ImageIcon(img));
    }

    /**
     * Resets the current raid mistakes and panel, and notifies the manager that a new raid has been entered
     */
    public void newRaid(List<String> playerNames) {
        currentRaiderNames = playerNames;
        mistakeStateManager.newRaid(new HashSet<>(playerNames));
        if (isShowingAll) {
            updateOverallPanel();
            reorderRaiderBoxes();
        } else {
            // We're looking at the current raid view, reset it and start over
            resetUi();
        }
    }

    /**
     * Adds a mistake for the specified player, both in the manager and the panel.
     *
     * @param playerName - The player name that a mistake was added for
     */
    public void addMistakeForPlayer(String playerName, TobMistake mistake) {
        mistakeStateManager.addMistakeForPlayer(playerName, mistake);

        PlayerMistakesBox box = buildBox(playerName);
        box.rebuildAllMistakes(isRaidDeaths);
        updateOverallPanel();

        // Ensure ordering is correct
        reorderRaiderBoxes();
    }

    /**
     * Rebuilds all the boxes from scratch based on which view we're currently looking at
     */
    private void rebuildAll() {
        if (SwingUtilities.isEventDispatchThread()) {
            SwingUtil.fastRemoveAll(mistakesContainer);
        } else {
            mistakesContainer.removeAll();
        }
        playerMistakesBoxes.clear();

        for (String playerName : mistakeStateManager.getPlayersWithMistakes()) {
            buildBox(playerName);
        }

        playerMistakesBoxes.forEach(box -> box.rebuildAllMistakes(isRaidDeaths));
        updateOverallPanel();
        reorderRaiderBoxes();
        mistakesContainer.revalidate();
        mistakesContainer.repaint();

        updateVisiblePanels(playerMistakesBoxes.isEmpty());
    }

    private PlayerMistakesBox buildBox(String playerName) {
        for (PlayerMistakesBox box : playerMistakesBoxes) {
            if (box.getPlayerName().equals(playerName)) {
                return box;
            }
        }

        // Create a new box if one could not be found
        PlayerMistakesBox box = new PlayerMistakesBox(mistakeStateManager, playerName);

        // Use the existing popup menu or create a new one
        JPopupMenu popupMenu = box.getComponentPopupMenu();
        if (popupMenu == null) {
            popupMenu = new JPopupMenu();
            popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
            box.setComponentPopupMenu(popupMenu);
        }

        // Create reset menu
        final JMenuItem reset = new JMenuItem("Reset ALL Mistakes for " + playerName);
        reset.addActionListener(e -> {
            mistakeStateManager.removeAllMistakesForPlayer(playerName);
            playerMistakesBoxes.remove(box);

            updateOverallPanel();
            mistakesContainer.remove(box);
            mistakesContainer.repaint();

            if (playerMistakesBoxes.isEmpty()) {
                updateVisiblePanels(true);
            }
        });

        popupMenu.add(reset);

        // Show main view
        updateVisiblePanels(false);

        // Add box to panel
        mistakesContainer.add(box);
        playerMistakesBoxes.add(box);

        return box;
    }

    private void reorderRaiderBoxes() {
        // For lookups
        Map<String, PlayerMistakesBox> playerNameToBox = playerMistakesBoxes.stream()
                .collect(Collectors.toMap(PlayerMistakesBox::getPlayerName, e -> e));

        // Reverse iteration so that we can put each player's box at the top, meaning last raider will be at the bottom
        for (int i = currentRaiderNames.size() - 1; i >= 0; i--) {
            PlayerMistakesBox box = playerNameToBox.get(currentRaiderNames.get(i));
            if (box != null) {
                moveBoxToTop(box);
            }
        }

        // Always put local player at the top
        if (client.getLocalPlayer() != null && playerNameToBox.get(client.getLocalPlayer().getName()) != null) {
            PlayerMistakesBox box = playerNameToBox.get(client.getLocalPlayer().getName());
            moveBoxToTop(box);
        }
    }

    private void resetAll() {
        mistakeStateManager.resetAll();
        resetUi();
    }

    private void resetUi() {
        playerMistakesBoxes.clear();

        updateOverallPanel();
        mistakesContainer.removeAll();
        mistakesContainer.repaint();

        updateVisiblePanels(true);
    }

    private void updateOverallPanel() {
        overallPlayersLabel.setText(htmlLabel("Total players: ",
                mistakeStateManager.getPlayersWithMistakes().size()));
        overallMistakesLabel.setText(htmlLabel("Total mistakes: ",
                mistakeStateManager.getTotalMistakeCountForAllPlayers()));
        overallRaidsLabel.setText(htmlLabel("Tracked raids: ",
                mistakeStateManager.getTrackedRaids()));
    }

    private static String htmlLabel(String key, long value) {
        final String valueStr = QuantityFormatter.quantityToStackSize(value);
        return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), key, valueStr);
    }

    private boolean doesLocalPlayerHaveMistakesBox() {
        if (client.getLocalPlayer() != null) {
            String name = client.getLocalPlayer().getName();
            return playerMistakesBoxes.stream().anyMatch(b -> b.getPlayerName().equals(name));
        }

        return false;
    }

    private void moveBoxToTop(PlayerMistakesBox box) {
        mistakesContainer.setComponentZOrder(box, 0);
    }

    private void updateVisiblePanels(boolean isEmpty) {
        if (isEmpty) {
            add(errorPanel);
            overallPanel.setVisible(false);
            mistakesContainer.setVisible(false);
        } else {
            remove(errorPanel);
            overallPanel.setVisible(true);
            mistakesContainer.setVisible(true);
        }
    }

    private void changeDeathGrouping(boolean isRaid) {
        isRaidDeaths = isRaid;
        (isRaid ? raidDeathsBtn : roomDeathsBtn).setSelected(true);
        rebuildAll();
    }

    private void switchMistakesView() {
        // TODO: Minor UI bug: Switching panels re-orders mistakes on the first switch, and is consistent afterwards
        // until another mistake is added. This is because we re-order the boxes we add, but don't persist that ordering
        // in the underlying manager.
        isShowingAll = !isShowingAll;
        currentViewTitle.setText(getCurrentViewTitleText());
        switchMistakesViewBtn.setText(getSwitchMistakesViewButtonText());

        mistakeStateManager.switchMistakes();
        rebuildAll();
    }

    private String getCurrentViewTitleText() {
        return isShowingAll ? "All Raids" : "Current Raid";
    }

    private String getSwitchMistakesViewButtonText() {
        return isShowingAll ? "Show Current" : "Show All";
    }
}

package com.tobmistaketracker.state;

import com.tobmistaketracker.TobMistake;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Keeps track of mistakes for players
 */
class MistakeManager {

    private final Map<String, PlayerTrackingInfo> trackingInfo;
    private int trackedRaids;

    MistakeManager() {
        trackingInfo = new HashMap<>();
        trackedRaids = 0;
    }

    public void clearAllMistakes() {
        trackingInfo.clear();
        trackedRaids = 0;
    }

    public void addMistakeForPlayer(String playerName, TobMistake mistake) {
        PlayerTrackingInfo playerInfo = trackingInfo.computeIfAbsent(playerName,
                k -> new PlayerTrackingInfo(playerName));
        playerInfo.incrementMistake(mistake);
    }

    public void newRaid(Set<String> playerNames) {
        trackedRaids++;

        for (String playerName : playerNames) {
            PlayerTrackingInfo playerInfo = trackingInfo.get(playerName);
            if (playerInfo != null) {
                playerInfo.incrementRaidCount();
            } else {
                trackingInfo.put(playerName, new PlayerTrackingInfo(playerName));
            }
        }
    }

    public void removeAllMistakesForPlayer(String playerName) {
        trackingInfo.remove(playerName);
    }

    public Set<String> getPlayersWithMistakes() {
        return trackingInfo.values().stream()
                .filter(PlayerTrackingInfo::hasMistakes)
                .map(PlayerTrackingInfo::getPlayerName)
                .collect(Collectors.toSet());
    }

    public int getMistakeCountForPlayer(String playerName, TobMistake mistake) {
        PlayerTrackingInfo playerInfo = trackingInfo.get(playerName);
        if (playerInfo != null) {
            Integer count = playerInfo.getMistakes().get(mistake);
            if (count != null) {
                return count;
            }
        }

        return 0;
    }

    public int getTotalMistakeCountForAllPlayers() {
        int totalMistakes = 0;
        for (PlayerTrackingInfo playerInfo : trackingInfo.values()) {
            for (int mistakes : playerInfo.getMistakes().values()) {
                totalMistakes += mistakes;
            }
        }

        return totalMistakes;
    }

    public int getRaidCountForPlayer(String playerName) {
        PlayerTrackingInfo playerInfo = trackingInfo.get(playerName);
        if (playerInfo != null) {
            return playerInfo.getRaidCount();
        }

        return 0;
    }

    public int getTrackedRaids() {
        return trackedRaids;
    }
}

package com.tobmistaketracker.state;

import com.tobmistaketracker.TobMistake;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Singleton;
import java.util.Set;

/**
 * In charge of the different MistakeManagers, and knowing which one is the currently viewed one.
 * <p>
 * For now, these are very small and writes are relatively infrequent, so let's write to disk for every write API.
 */
@Slf4j
@Singleton
public class MistakeStateManager {

    private final MistakeManager currentRaidMistakeManager;
    private final MistakeManager allRaidsMistakeManager;

    private transient boolean isAll;
    @Setter
    private transient MistakeStateWriter mistakeStateWriter;

    public MistakeStateManager(MistakeStateWriter mistakeStateWriter) {
        this.currentRaidMistakeManager = new MistakeManager();
        this.allRaidsMistakeManager = new MistakeManager();
        this.mistakeStateWriter = mistakeStateWriter;

        this.isAll = false;
    }

    public void addMistakeForPlayer(String playerName, TobMistake mistake) {
        // Always add to both
        currentRaidMistakeManager.addMistakeForPlayer(playerName, mistake);
        allRaidsMistakeManager.addMistakeForPlayer(playerName, mistake);

        mistakeStateWriter.write(this);
    }

    public void removeAllMistakesForPlayer(String playerName) {
        // Always remove from both
        currentRaidMistakeManager.removeAllMistakesForPlayer(playerName);
        allRaidsMistakeManager.removeAllMistakesForPlayer(playerName);

        mistakeStateWriter.write(this);
    }

    public void resetAll() {
        // Always clear from both
        currentRaidMistakeManager.clearAllMistakes();
        allRaidsMistakeManager.clearAllMistakes();

        mistakeStateWriter.write(this);
    }

    public void newRaid(Set<String> playerNames) {
        // Clear just the current mistakes
        currentRaidMistakeManager.clearAllMistakes();

        // Denote to the manager that there's a new raid, incrementing the raid count for all players in this raid
        // Raid count for current raid isn't valid, so only do for all raids
        allRaidsMistakeManager.newRaid(playerNames);

        mistakeStateWriter.write(this);
    }

    public Set<String> getPlayersWithMistakes() {
        return isAll ?
                allRaidsMistakeManager.getPlayersWithMistakes() :
                currentRaidMistakeManager.getPlayersWithMistakes();
    }

    public int getMistakeCountForPlayer(String playerName, TobMistake mistake) {
        return isAll ?
                allRaidsMistakeManager.getMistakeCountForPlayer(playerName, mistake) :
                currentRaidMistakeManager.getMistakeCountForPlayer(playerName, mistake);
    }

    public int getTotalMistakeCountForAllPlayers() {
        return isAll ?
                allRaidsMistakeManager.getTotalMistakeCountForAllPlayers() :
                currentRaidMistakeManager.getTotalMistakeCountForAllPlayers();
    }

    public int getRaidCountForPlayer(String playerName) {
        return isAll ? allRaidsMistakeManager.getRaidCountForPlayer(playerName) :
                0; // Raid count for current raid isn't valid, so return 0
    }

    public int getTrackedRaids() {
        return isAll ? allRaidsMistakeManager.getTrackedRaids() :
                1; // Tracked raids for current raid is always just the 1 raid
    }

    public void switchMistakes() {
        isAll = !isAll;
    }
}
package com.tobmistaketracker.state;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.stream.JsonReader;
import lombok.extern.slf4j.Slf4j;
import net.runelite.http.api.RuneLiteAPI;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import static com.tobmistaketracker.state.MistakeStateUtil.getMistakeStateFilePath;

/**
 * Reads MistakeState from disk
 */
@Slf4j
@Singleton
public class MistakeStateReader {

    private static final Gson GSON = RuneLiteAPI.GSON;

    private final MistakeStateWriter mistakeStateWriter;
    private final Path mistakeStateFilePath;

    @Inject
    public MistakeStateReader(MistakeStateWriter mistakeStateWriter, @Named("developerMode") boolean developerMode) {
        this.mistakeStateWriter = mistakeStateWriter;
        this.mistakeStateFilePath = getMistakeStateFilePath(developerMode);
    }

    public MistakeStateManager read() {
        if (Files.exists(mistakeStateFilePath)) {
            try (BufferedReader reader = Files.newBufferedReader(mistakeStateFilePath);
                 JsonReader jsonReader = new JsonReader(reader)) {
                MistakeStateManager mistakeStateManager = GSON.fromJson(jsonReader, MistakeStateManager.class);
                if (mistakeStateManager == null) {
                    return new MistakeStateManager(mistakeStateWriter);
                }
                mistakeStateManager.setMistakeStateWriter(mistakeStateWriter);
                return mistakeStateManager;
            } catch (IOException | JsonSyntaxException e) {
                log.error("Unable to read mistake state from " + mistakeStateFilePath, e);
            }
        }

        return new MistakeStateManager(mistakeStateWriter);
    }
}
package com.tobmistaketracker.state;

import java.nio.file.Path;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

public class MistakeStateUtil {

    private static final Path MISTAKE_STATE_DIR = RUNELITE_DIR.toPath().resolve("tob-mistake-tracker");

    // Use the same mistake state file regardless of user
    private static final String MISTAKE_STATE_FILE_NAME = "mistake-state.txt";

    private static final String DEVELOPER_MODE_PREFIX = "dev-";

    static Path getMistakeStateDir() {
        return MISTAKE_STATE_DIR;
    }

    static Path getMistakeStateFilePath(boolean developerMode) {
        final String filename;
        if (developerMode) {
            filename = DEVELOPER_MODE_PREFIX + MISTAKE_STATE_FILE_NAME;
        } else {
            filename = MISTAKE_STATE_FILE_NAME;
        }

        return getMistakeStateDir().resolve(filename);
    }
}

package com.tobmistaketracker.state;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.http.api.RuneLiteAPI;

import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import static com.tobmistaketracker.state.MistakeStateUtil.getMistakeStateDir;
import static com.tobmistaketracker.state.MistakeStateUtil.getMistakeStateFilePath;

/**
 * Writes MistakeState to disk
 */
@Slf4j
@Singleton
public class MistakeStateWriter {

    private static final Gson GSON = RuneLiteAPI.GSON;

    private final Path mistakeStateDir;
    private final Path mistakeStateFilePath;

    @Inject
    public MistakeStateWriter(@Named("developerMode") boolean developerMode) {
        this.mistakeStateDir = getMistakeStateDir();
        this.mistakeStateFilePath = getMistakeStateFilePath(developerMode);
    }

    public void write(MistakeStateManager mistakeStateManager) {
        try {
            Files.createDirectories(mistakeStateDir);
        } catch (IOException e) {
            log.error("Unable to create directories " + mistakeStateDir, e);
            return;
        }

        final Path filepath = mistakeStateFilePath;
        try (BufferedWriter writer = Files.newBufferedWriter(filepath)) {
            writer.write(GSON.toJson(mistakeStateManager));
        } catch (IOException e) {
            log.error("Unable to write mistake state to " + filepath, e);
        }
    }
}
package com.tobmistaketracker.state;

import com.tobmistaketracker.TobMistake;
import lombok.Getter;
import lombok.NonNull;

import java.util.HashMap;
import java.util.Map;

/**
 * Encapsulating class for relevant tracking information for a player, including mistakes.
 */
public class PlayerTrackingInfo {

    @NonNull
    @Getter
    private final String playerName;
    @NonNull
    @Getter
    private final Map<TobMistake, Integer> mistakes;
    @Getter
    private int raidCount;

    public PlayerTrackingInfo(@NonNull final String playerName) {
        this.playerName = playerName;
        this.mistakes = new HashMap<>();
        this.raidCount = 1; // Default raid count is 1 since just by creating this object it's assumed there's a raid
    }

    public void incrementMistake(TobMistake mistake) {
        mistakes.compute(mistake, PlayerTrackingInfo::increment);
    }

    public void incrementRaidCount() {
        raidCount++;
    }

    public boolean hasMistakes() {
        return !mistakes.isEmpty();
    }

    private static <T> Integer increment(T key, Integer oldValue) {
        return oldValue == null ? 1 : oldValue + 1;
    }
}

package com.tobmistaketracker;

public class TobBossNames {

    public static final String MAIDEN = "The Maiden of Sugadinti";
    public static final String BLOAT = "Pestilent Bloat";
    public static final String NYLO_DEMI_BOSS = "Nylocas Prinkipas";
    public static final String NYLO_BOSS = "Nylocas Vasilias";
    public static final String SOTETSEG = "Sotetseg";
    public static final String XARPUS = "Xarpus";
    public static final String VERZIK = "Verzik Vitur";
}

package com.tobmistaketracker;

import lombok.Getter;
import lombok.NonNull;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public enum TobMistake {
    // All death chat messages will be handled by the corresponding specific DEATH enum
    DEATH("Death", "death.png", ""),
    DEATH_MAIDEN("Maiden Death", "death_maiden.png", "I'm planking!"),
    DEATH_BLOAT("Bloat Death", "death_bloat.png", "I'm planking!"),
    DEATH_NYLOCAS("Nylocas Death", "death_nylo.png", "I'm planking!"),
    DEATH_SOTETSEG("Sotetseg Death", "death_sot.png", "I'm planking!"),
    DEATH_XARPUS("Xarpus Death", "death_xarpus.png", "I'm planking!"),
    DEATH_VERZIK("Verzik Death", "death_verzik.png", "I'm planking!"),
    MAIDEN_BLOOD("Maiden Blood", "maiden_blood.png", "I'm drowning in Maiden's blood!"),
    MAIDEN_BLOOD_SPAWN("Maiden Blood (Tomato)", "maiden_blood_orb.png", "I'm gonna catch this tomato!"),
    BLOAT_HAND("Bloat Hand", "bloat_hand.png", "I'm stunned!"),
    VERZIK_P2_BOUNCE("Verzik P2 Bounce", "verzik_p2_bounce.png", "Bye!"),
    VERZIK_P2_BOMB("Verzik P2 Bomb", "verzik_p2_bomb.png", "I'm eating cabbages!"),
    VERZIK_P2_ACID("Verzik P2 Acid", "verzik_p2_acid.png", "I can't count to four!"),
    VERZIK_P3_MELEE_TANKED("Verzik P3 Melee", "verzik_p3_melee.png", "I'm PKing my team!"),
    VERZIK_P3_MELEE_CHANCED("Verzik P3 Melee", "verzik_p3_melee.png", "Was I lucky?"),
    VERZIK_P3_WEB("Verzik P3 Web", "verzik_p3_web.png", "I was stuck in a web!"),
    VERZIK_P3_PURPLE("Verzik P3 Purple Tornado", "verzik_p3_purple.png", "I'm healing Verzik!");


    private static final Set<TobMistake> ROOM_DEATH_ENUMS = EnumSet.of(
            DEATH_MAIDEN, DEATH_BLOAT, DEATH_NYLOCAS, DEATH_SOTETSEG, DEATH_XARPUS, DEATH_VERZIK);

    /**
     * Mistakes that should actually be tracked as another mistake, but only defined above for their own chat messages
     * For example, VERZIK_P3_MELEE_CHANCED is tracked as VERZIK_P3_MELEE_TANKED, but we want to show the chat message
     * for both of them depending on the contextual situation determined by the detector.
     * <p>
     * It's a bit hacky, but meh.
     */
    private static final Map<TobMistake, TobMistake> REFERENCE_MISTAKES = new HashMap<TobMistake, TobMistake>() {
        {
            put(VERZIK_P3_MELEE_CHANCED, VERZIK_P3_MELEE_TANKED);
        }
    };

    @Getter
    @NonNull
    private final String mistakeName;

    @Getter
    @NonNull
    // TODO: Maybe have a list of messages to say after reaching a certain amount of mistakes
    // TODO: Maybe have these be configurable for each mistake in the config?
    private final String chatMessage;

    @Getter
    @NonNull
    private final BufferedImage mistakeImage;

    TobMistake(@NonNull String mistakeName, @NonNull String mistakeImagePath, @NonNull String chatMessage) {
        this.mistakeName = mistakeName;
        this.chatMessage = chatMessage;

        this.mistakeImage = ImageUtil.loadImageResource(getClass(), mistakeImagePath);
    }

    public static boolean isRoomDeath(TobMistake mistake) {
        return ROOM_DEATH_ENUMS.contains(mistake);
    }

    public static TobMistake getMistakeForTracking(TobMistake mistake) {
        return REFERENCE_MISTAKES.getOrDefault(mistake, mistake);
    }
}

package com.tobmistaketracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(TobMistakeTrackerPlugin.CONFIG_GROUP)
public interface TobMistakeTrackerConfig extends Config {

    @ConfigItem(
            keyName = "showMistakesInChat",
            name = "Show Mistakes In Chat",
            description = "When a player makes a mistake in ToB, whether or not to put it in public chat for other " +
                    "raiders who have the plugin to see.",
            position = 1
    )
    default boolean showMistakesInChat() {
        return true;
    }

    @ConfigItem(
            keyName = "showMistakesOnOverheadText",
            name = "Show Mistakes On Overhead Text",
            description = "When a player makes a mistake in ToB, whether or not to show the overhead text for other " +
                    "raiders who have the plugin to see.",
            position = 2
    )
    default boolean showMistakesOnOverheadText() {
        return true;
    }
}

package com.tobmistaketracker;

import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;
import com.tobmistaketracker.detector.MistakeDetectorManager;
import com.tobmistaketracker.panel.TobMistakeTrackerPanel;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarClientStrChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static net.runelite.api.widgets.InterfaceID.TOB;

@Singleton
@Slf4j
@PluginDescriptor(
        name = "Tob Mistake Tracker"
)
public class TobMistakeTrackerPlugin extends Plugin {

    static final String CONFIG_GROUP = "tobMistakeTracker";
    public static final int TOB_ROOM_TRANSITION_SCRIPT_ID = 2315;

    private static final int TOB_BOSS_INTERFACE_ID = 1;
    private static final int TOB_BOSS_INTERFACE_TEXT_ID = 2;

    // These are some of the possible values for Varbits.THEATRE_OF_BLOOD
    private static final int TOB_STATE_NO_PARTY = 0;
    private static final int TOB_STATE_IN_PARTY = 1;
    private static final int TOB_STATE_IN_TOB = 2;

    private static final int THEATRE_RAIDERS_VARC = 330;

    private static final int MAX_RAIDERS = 5;

    private static final int OVERHEAD_TEXT_TICK_TIMEOUT = 5;
    private static final int CYCLES_PER_GAME_TICK = Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;
    private static final int CYCLES_FOR_OVERHEAD_TEXT = OVERHEAD_TEXT_TICK_TIMEOUT * CYCLES_PER_GAME_TICK;

    private static final Pattern STORY_MODE_FAILED_PATTERN = Pattern.compile("You have failed.");

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private TobMistakeTrackerConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private EventBus eventBus;

    @Inject
    private MistakeDetectorManager mistakeDetectorManager;

    private final BufferedImage icon = ImageUtil.loadImageResource(TobMistakeTrackerPlugin.class, "panel_icon.png");
    private TobMistakeTrackerPanel panel;
    private NavigationButton navButton;

    private int raidState;
    @Getter
    @VisibleForTesting
    private boolean inTob;
    @Getter
    @VisibleForTesting
    private boolean allRaidersLoaded;

    @Getter
    @VisibleForTesting
    // This is in charge of determining if we need to reset the current raid panel. We need this boolean here due to
    // disconnects/turning off and on the plugin mid-raid. This let's us know that we might need to reset the panel
    // the next time that we transition back into a raid and the boss is Maiden.
    // We set this to true any time we reset the raid state, and to false when we determine that we've entered a brand
    // new raid.
    private boolean panelMightNeedReset;

    private String[] raiderNames;
    private Map<String, TobRaider> raiders; // name -> raider

    @Override
    protected void startUp() throws Exception {
        // Can't @Inject because we null it out in shutdown()
        panel = injector.getInstance(TobMistakeTrackerPanel.class);

        // Add panel and icon
        panel.loadHeaderIcon(icon);
        navButton = NavigationButton.builder()
                .tooltip("Tob Mistake Tracker")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();
        clientToolbar.addNavigation(navButton);

        // Reset all state
        resetRaidState();

        // If the plugin was turned on mid-raid, try to load the right state
        clientThread.invokeLater(() -> {
            computeInTob();
            if (inTob) {
                tryLoadRaiders();
            }
        });

        panel.reload();
    }

    @Override
    protected void shutDown() throws Exception {
        resetRaidState();

        clientToolbar.removeNavigation(navButton);
        panel = null;
    }

    private void resetRaidState() {
        raidState = TOB_STATE_NO_PARTY;
        inTob = false;
        allRaidersLoaded = false;
        panelMightNeedReset = true;

        raiderNames = new String[MAX_RAIDERS];
        raiders = new HashMap<>(MAX_RAIDERS);

        mistakeDetectorManager.shutdown();
    }

    // This should run *after* all detectors have handled the GameTick.
    @Subscribe(priority = -1)
    public void onGameTick(GameTick event) {
        if (!inTob) return;

        if (!allRaidersLoaded) {
            tryLoadRaiders();
        }

        // Try detecting all possible mistakes for this GameTick
        detectAll();

        // Invoke post-processing method for detectors to get ready for the next GameTick
        afterDetectAll();
    }

    private void detectAll() {
        for (TobRaider raider : raiders.values()) {
            if (raider != null) {
                detect(raider);
            }
        }
    }

    private void detect(@NonNull TobRaider raider) {
        List<TobMistake> mistakes = mistakeDetectorManager.detectMistakes(raider);
        if (!mistakes.isEmpty()) {
            log.debug("" + client.getTickCount() + " Found mistakes for " + raider.getName() + " - " + mistakes);

            for (TobMistake mistake : mistakes) {
                // Handle special logic for deaths
                if (mistake == TobMistake.DEATH) {
                    raider.setDead(true);
                }

                TobMistake mistakeForTracking = TobMistake.getMistakeForTracking(mistake);
                addMistakeForPlayer(raider.getName(), mistakeForTracking);
                addChatMessageForPlayerMistake(raider.getPlayer(), mistake);
            }
        }

        afterDetect(raider);
    }

    private void addChatMessageForPlayerMistake(Player player, TobMistake mistake) {
        final String overheadText = mistake.getChatMessage();
        if (overheadText.isEmpty()) {
            // This is the case for the universal DEATH mistake, for example.
            return;
        }

        // Add to overhead text if config is enabled
        if (config.showMistakesOnOverheadText()) {
            player.setOverheadText(overheadText);
            player.setOverheadCycle(CYCLES_FOR_OVERHEAD_TEXT);
        }

        // Add to chat box if config is enabled
        if (config.showMistakesInChat()) {
            client.addChatMessage(ChatMessageType.PUBLICCHAT, player.getName(), mistake.getChatMessage(), null);
        }
    }

    private void afterDetect(TobRaider raider) {
        raider.setPreviousWorldLocationForOverlay(raider.getPreviousWorldLocation());
        raider.setPreviousWorldLocation(raider.getCurrentWorldLocation());
    }

    private void afterDetectAll() {
        mistakeDetectorManager.afterDetect();
    }

    private void tryLoadRaiders() {
        // Look through all players and see if they should be a raider
        Set<String> raiderNamesSet = new HashSet<>(getRaiderNames());
        if (raiderNamesSet.isEmpty()) {
            // Let's try loading raider names manually, since we might already be in a raid and thus
            // onVarClientStrChanged will never get invoked
            tryLoadRaiderNames();
            raiderNamesSet = new HashSet<>(getRaiderNames());
        }

        for (Player player : client.getPlayers()) {
            if (player != null && player.getName() != null &&
                    !raiders.containsKey(player.getName()) && raiderNamesSet.contains(player.getName())) {
                raiders.put(player.getName(), new TobRaider(player));
            }
        }

        int totalRaiders = raiderNamesSet.size();
        if (totalRaiders > 0 && raiders.size() == totalRaiders) {
            allRaidersLoaded = true;
        }
    }

    private void tryLoadRaiderNames() {
        for (int i = 0; i < MAX_RAIDERS; i++) {
            String playerName = client.getVarcStrValue(THEATRE_RAIDERS_VARC + i);

            if (playerName != null && !playerName.isEmpty()) {
                raiderNames[i] = (Text.sanitize(playerName));
            }
        }
    }

    private boolean shouldTrackMistakes() {
        return inTob;
    }

    private void addMistakeForPlayer(String playerName, TobMistake mistake) {
        if (shouldTrackMistakes()) {
            SwingUtilities.invokeLater(() -> panel.addMistakeForPlayer(playerName, mistake));
        }
    }

    @Subscribe
    public void onPlayerDespawned(PlayerDespawned event) {
        // We only care about players that despawn when in a raid.
        if (inTob && raiders.containsKey(event.getPlayer().getName())) {
            raiders.remove(event.getPlayer().getName());
            allRaidersLoaded = false;
        }
    }

    @Subscribe
    public void onVarClientStrChanged(VarClientStrChanged event) {
        if (event.getIndex() >= THEATRE_RAIDERS_VARC && event.getIndex() < THEATRE_RAIDERS_VARC + MAX_RAIDERS) {
            // A raider has joined or left -- reset allRaidersLoaded
            allRaidersLoaded = false;

            int raiderIndex = event.getIndex() - THEATRE_RAIDERS_VARC;
            String raiderName = client.getVarcStrValue(event.getIndex());
            if (raiderName != null && !raiderName.isEmpty()) {
                raiderNames[raiderIndex] = Text.sanitize(raiderName);
            } else {
                raiderNames[raiderIndex] = null;
            }
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        computeInTob();
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (inTob && panelMightNeedReset && event.getScriptId() == TOB_ROOM_TRANSITION_SCRIPT_ID) {
            final String roomText = getTobRoomEnterText(client);
            if (TobBossNames.MAIDEN.equals(roomText)) {
                panel.newRaid(getRaiderNames());
                // Set to false until next time we're no longer sure if we're in a raid.
                panelMightNeedReset = false;
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOADING) {
            // If there are still raiders, they can't be dead anymore after loading.
            for (TobRaider raider : raiders.values()) {
                raider.setDead(false);
            }
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (event.getMessageNode().getType() == ChatMessageType.GAMEMESSAGE) {
            if (STORY_MODE_FAILED_PATTERN.matcher(event.getMessage()).find()) {
                // Failed a story mode attempt, all raiders are no longer dead.
                // TODO: I'm not sure this works for spectators, but I mean, who spectates story mode I guess...
                // TODO: I'll need to test it more if I care to fix it for story mode spectators...
                for (TobRaider raider : raiders.values()) {
                    raider.setDead(false);
                }
            }
        }
    }

    private void computeInTob() {
        if (client.getGameState() != GameState.LOGGED_IN) return;

        int newRaidState = client.getVarbitValue(Varbits.THEATRE_OF_BLOOD);
        if (raidState != newRaidState) {
            if (newRaidState == TOB_STATE_NO_PARTY || newRaidState == TOB_STATE_IN_PARTY) {
                // We're not in a raid
                resetRaidState();
            } else if (newRaidState == TOB_STATE_IN_TOB) {
                inTob = true;
                mistakeDetectorManager.startup();
            }
            raidState = newRaidState;
        }
    }

    public boolean isLoadedRaider(String playerName) {
        return playerName != null && raiders.containsKey(playerName);
    }

    public Iterable<TobRaider> getRaiders() {
        return Collections.unmodifiableCollection(raiders.values());
    }

    /**
     * Gets a copy of all the raider names. Elements returned are guaranteed to be non-null.
     */
    public List<String> getRaiderNames() {
        return Arrays.stream(raiderNames).filter(Objects::nonNull).collect(Collectors.toList());
    }

    /**
     * Retrieves the room text when entering a tob room
     *
     * @param client The client
     * @return The text shown on the screen from the tob widget when entering a new room, or empty string if none
     */
    public static String getTobRoomEnterText(final Client client) {
        Widget widget = client.getWidget(TOB, TOB_BOSS_INTERFACE_ID);
        if (widget != null && widget.getChild(TOB_BOSS_INTERFACE_TEXT_ID) != null) {
            Widget childWidget = widget.getChild(TOB_BOSS_INTERFACE_TEXT_ID);
            return childWidget.getText();
        }

        return "";
    }

    @Provides
    TobMistakeTrackerConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TobMistakeTrackerConfig.class);
    }
}

package com.tobmistaketracker;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;

/**
 * Encapsulating class for a {@link Player} and other relevant metadata in a Tob raid.
 */
public class TobRaider {

    @Getter
    @NonNull
    private final Player player;

    @Getter
    @Setter(AccessLevel.PACKAGE)
    private WorldPoint previousWorldLocation;

    @Getter
    @Setter(AccessLevel.PACKAGE)
    private WorldPoint previousWorldLocationForOverlay;

    @Getter
    @Setter(AccessLevel.PACKAGE)
    private boolean isDead;

    TobRaider(@NonNull Player player) {
        this.player = player;
    }

    public String getName() {
        return player.getName();
    }

    public WorldPoint getCurrentWorldLocation() {
        return player.getWorldLocation();
    }
}

package com.tobmistaketracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TobMistakeTrackerPluginTest {

    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(TobMistakeTrackerPlugin.class);
        RuneLite.main(args);
    }
}
