package com.cyneris;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("onlyree")
public interface OnlyReeConfig extends Config {
    @ConfigItem(
            keyName = "xpMultiplier",
            name = "Xp multiplier",
            description = "The bonus xp multiplier (from season game mode for example) that should be factored when calculating the hit",
            position = 1
    )
    default double xpMultiplier() {
        return 1;
    }

    @ConfigItem(
            keyName = "ignoreNpcIds",
            name = "Excluded NPCs",
            description = "Comma separated list of npc ids to ignore",
            position = 2
    )
    default String ignoreNpcIds() {
        return "";
    }

    @ConfigItem(
            keyName = "triggerOnAoe",
            name = "Enable For AOE",
            description = "Whether the sound effect should play when using AOE spells and range weapons.",
            position = 3
    )
    default boolean triggerOnAoe() {
        return false;
    }
}

package com.cyneris;

import com.cyneris.predictedhit.SpellUtil;
import com.cyneris.predictedhit.XpDropDamageCalculator;
import com.cyneris.predictedhit.npcswithscalingbonus.ChambersLayoutSolver;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
        name = "Only Ree"
)
public class OnlyReePlugin extends Plugin {
    public static final int[] SKILL_PRIORITY = new int[]{1, 5, 2, 6, 3, 7, 4, 15, 17, 18, 0, 16, 11, 14, 13, 9, 8, 10, 19, 20, 12, 22, 21};
    private static final Set<Integer> VOIDWAKERS = new ImmutableSet.Builder<Integer>()
            .addAll(ItemVariationMapping.getVariations(ItemID.VOIDWAKER))
            .build();
    private static final Set<Integer> CROSSBOWS = new ImmutableSet.Builder<Integer>() // All crossbows that can shoot addy bolts or higher
            .add(ItemID.ADAMANT_CROSSBOW)
            .addAll(ItemVariationMapping.getVariations(ItemID.RUNE_CROSSBOW))
            .addAll(ItemVariationMapping.getVariations(ItemID.DRAGON_CROSSBOW))
            .addAll(ItemVariationMapping.getVariations(ItemID.DRAGON_HUNTER_CROSSBOW))
            .addAll(ItemVariationMapping.getVariations(ItemID.ARMADYL_CROSSBOW))
            .addAll(ItemVariationMapping.getVariations(ItemID.ZARYTE_CROSSBOW))
            .build();

    private static final Set<Integer> AOE_RANGE_WEAPONS = new ImmutableSet.Builder<Integer>() // All range weapons that can hit multiple targets
            .addAll(ItemVariationMapping.getVariations(ItemID.VENATOR_BOW))
            .add(ItemID.CHINCHOMPA)
            .add(ItemID.RED_CHINCHOMPA)
            .add(ItemID.BLACK_CHINCHOMPA)
            .build();

    private static final Set<Integer> AUTOCASTING_WEAPONS = new ImmutableSet.Builder<Integer>() // Weapons that can autocast ancients
            .addAll(ItemVariationMapping.getVariations(ItemID.ANCIENT_STAFF))
            .addAll(ItemVariationMapping.getVariations(ItemID.ANCIENT_SCEPTRE))
            .addAll(ItemVariationMapping.getVariations(ItemID.BLOOD_ANCIENT_SCEPTRE))
            .addAll(ItemVariationMapping.getVariations(ItemID.ICE_ANCIENT_SCEPTRE))
            .addAll(ItemVariationMapping.getVariations(ItemID.SHADOW_ANCIENT_SCEPTRE))
            .addAll(ItemVariationMapping.getVariations(ItemID.SMOKE_ANCIENT_SCEPTRE))
            .addAll(ItemVariationMapping.getVariations(ItemID.AHRIMS_STAFF))
            .addAll(ItemVariationMapping.getVariations(ItemID.MASTER_WAND))
            .addAll(ItemVariationMapping.getVariations(ItemID.KODAI_WAND))
            .addAll(ItemVariationMapping.getVariations(ItemID.NIGHTMARE_STAFF))
            .addAll(ItemVariationMapping.getVariations(ItemID.ELDRITCH_NIGHTMARE_STAFF))
            .addAll(ItemVariationMapping.getVariations(ItemID.VOLATILE_NIGHTMARE_STAFF))
            .addAll(ItemVariationMapping.getVariations(ItemID.THAMMARONS_SCEPTRE))
            .addAll(ItemVariationMapping.getVariations(ItemID.ACCURSED_SCEPTRE))
            .addAll(ItemVariationMapping.getVariations(ItemID.BLUE_MOON_SPEAR))
            .build();

    private static final Set<Integer> QUIVERS = new ImmutableSet.Builder<Integer>()
            .addAll(ItemVariationMapping.getVariations(ItemID.DIZANAS_MAX_CAPE))
            .addAll(ItemVariationMapping.getVariations(ItemID.DIZANAS_QUIVER))
            .addAll(ItemVariationMapping.getVariations(ItemID.BLESSED_DIZANAS_QUIVER))
            .build();
    private static final int LEVIATHAN_ID = 12214;
    private static final int VARDORVIS_ID = 12223;
    private static final int AUTO_CAST_VARBIT_ID = 276;

    @Getter
    private final ArrayDeque<Integer> hitBuffer = new ArrayDeque<>();
    @Inject
    private XpDropDamageCalculator xpDropDamageCalculator;
    @Inject
    private ClientThread clientThread;
    @Inject
    private ChambersLayoutSolver chambersLayoutSolver;
    private static final int[] previous_exp = new int[Skill.values().length - 1];
    private boolean resetXpTrackerLingerTimerFlag = false;
    private boolean isAoeManualCasting = false; // Flag for manually barraging/bursting
    private int autocastingSpellId = 0;

    // ---------------------------------------------------------------------------

    @Inject
    private Client client;
    @Inject
    private OnlyReeConfig config;

    private final Set<Integer> npcsToIgnore = new HashSet<>();


    @Override
    protected void startUp() throws Exception {
        if (client.getGameState() == GameState.LOGGED_IN) {
            // -------------- Testing ignore fields -----------------------
            addAllIgnoredNpcIds();
            // ------------------------------------------------------------
            clientThread.invokeLater(() ->
            {
                int[] xps = client.getSkillExperiences();
                System.arraycopy(xps, 0, previous_exp, 0, previous_exp.length);
            });
        } else {
            Arrays.fill(previous_exp, 0);
            npcsToIgnore.clear();
        }
    }

    @Override
    protected void shutDown() throws Exception {
        log.info("Example stopped!");
    }

    @Provides
    OnlyReeConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(OnlyReeConfig.class);
    }

    @Subscribe
    protected void onConfigChanged(ConfigChanged configChanged) {
        if (configChanged.getGroup().equals("onlyree")) {
            npcsToIgnore.clear();
            addAllIgnoredNpcIds();
        }
    }

    @Subscribe
    protected void onFakeXpDrop(FakeXpDrop event) {
        if (event.getSkill() != Skill.HITPOINTS || event.getXp() >= 20000000) {
            return;
        }

        int currentXp = event.getXp();

        Player player = client.getLocalPlayer();
        int lastOpponentId = -1;
        Actor lastOpponent = null;
        if (player != null) {
            var weaponId = player.getPlayerComposition().getEquipmentId(KitType.WEAPON);

            // Check if we should ignore this damage due to config settings
            if (skipSoundEffect(player, weaponId)) return;

            lastOpponent = player.getInteracting();
        }

        int hit = 0;
        if (lastOpponent instanceof Player) {
            hit = xpDropDamageCalculator.calculateHitOnPlayer(lastOpponent.getCombatLevel(), currentXp, config.xpMultiplier());
        } else if (lastOpponent instanceof NPC) {
            lastOpponentId = ((NPC) lastOpponent).getId();

            // User is actively ignoring this NPC
            if (npcsToIgnore.contains(lastOpponentId)) {
                return;
            }

            // Special case for Awakened DT2 Bosses
            if ((lastOpponentId == LEVIATHAN_ID || lastOpponentId == VARDORVIS_ID)
                    && lastOpponent.getCombatLevel() > 1000) {
                lastOpponentId *= -1;
            }
            hit = xpDropDamageCalculator.calculateHitOnNpc(lastOpponentId, currentXp, config.xpMultiplier());
        }

        hitBuffer.add(hit);
        isAoeManualCasting = false;
    }

    @Subscribe
    protected void onPostClientTick(PostClientTick event) {
        int totalHit = 0;
        while (!hitBuffer.isEmpty()) {
            var hit = hitBuffer.poll();
            log.info("Polling {} from hitbuffer", hit);
            totalHit += hit;
        }

        if (totalHit >= 100) {
            client.playSoundEffect(2911); // REEEEEE
        }
    }

    @Subscribe
    protected void onMenuOptionClicked(MenuOptionClicked event) {
        String menuOption = Text.removeTags(event.getMenuOption());
        String menuTarget = Text.removeTags(event.getMenuTarget());
        isAoeManualCasting = menuOption.contains("Cast")
                && (menuTarget.contains("Burst ->") || menuTarget.contains("Barrage ->"));
    }

    @Subscribe
    protected void onVarbitChanged(VarbitChanged event) {
        if (event.getVarbitId() == AUTO_CAST_VARBIT_ID) {
            autocastingSpellId = client.getVarbitValue(AUTO_CAST_VARBIT_ID);
        }
    }

    @Subscribe
    protected void onStatChanged(StatChanged event) {
        if (event.getSkill() != Skill.HITPOINTS) {
            return;
        }

        int currentXp = event.getXp();
        int previousXp = previous_exp[event.getSkill().ordinal()];

        previous_exp[event.getSkill().ordinal()] = event.getXp();
        if (previousXp > 0 && currentXp - previousXp > 0) {

            Player player = client.getLocalPlayer();
            int lastOpponentId = -1;
            Actor lastOpponent = null;
            if (player != null) {
                var weaponId = player.getPlayerComposition().getEquipmentId(KitType.WEAPON);

                // Check if we should ignore this damage due to config settings
                if (skipSoundEffect(player, weaponId)) return;

                lastOpponent = player.getInteracting();
            }

            int hit = 0;
            if (lastOpponent instanceof Player) {
                lastOpponentId = lastOpponent.getCombatLevel();
                hit = xpDropDamageCalculator.calculateHitOnPlayer(lastOpponentId, currentXp - previousXp, config.xpMultiplier());
            } else if (lastOpponent instanceof NPC) {
                lastOpponentId = ((NPC) lastOpponent).getId();

                // User is actively ignoring this NPC
                if (npcsToIgnore.contains(lastOpponentId)) {
                    return;
                }

                hit = xpDropDamageCalculator.calculateHitOnNpc(lastOpponentId, currentXp - previousXp, config.xpMultiplier());
            }

            hitBuffer.add(hit);
        }

        isAoeManualCasting = false;
    }

    @Subscribe
    protected void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN || gameStateChanged.getGameState() == GameState.HOPPING) {
            Arrays.fill(previous_exp, 0);
            resetXpTrackerLingerTimerFlag = true;
        }
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN && resetXpTrackerLingerTimerFlag) {
            resetXpTrackerLingerTimerFlag = false;
        }

        chambersLayoutSolver.onGameStateChanged(gameStateChanged);
    }


    // ------------------------------------------------------------------------------------------------
    private boolean isNumeric(String input) {
        log.info(input);
        return input.isEmpty() || input.isBlank() || !input.matches("$[0-9]*^");
    }

    private void addAllIgnoredNpcIds() {
        if (config.ignoreNpcIds().length() == 0) {
            return;
        }

        var idsAsStrings = config.ignoreNpcIds().split(",");
        var allIgnoredIds = Arrays.stream(idsAsStrings)
                .map(String::trim)
                .filter(this::isNumeric)
                .peek(str -> log.info("numeric found: " + str))
                .map(Integer::parseInt)
                .collect(Collectors.toSet());
        log.info("Adding All ignored npc ids: " + allIgnoredIds + "\n");
        npcsToIgnore.addAll(allIgnoredIds);
    }

    private boolean skipSoundEffect(Player player, int weaponId) {
        // Natural ruby proc
        if (CROSSBOWS.contains(weaponId)) {
            var dizanaAmmoId = client.getVarpValue(VarPlayer.DIZANAS_QUIVER_ITEM_ID); // Ammo in the dizana's quiver
            var ammoItem = client.getItemContainer(InventoryID.EQUIPMENT).getItem(EquipmentInventorySlot.AMMO.getSlotIdx());
            if (ammoItem.getId() == ItemID.RUBY_BOLTS_E || ammoItem.getId() == ItemID.RUBY_DRAGON_BOLTS_E) {
                return true;
            } else {
                return QUIVERS.contains(player.getPlayerComposition().getEquipmentId(KitType.CAPE))
                        && (dizanaAmmoId == ItemID.RUBY_BOLTS_E || dizanaAmmoId == ItemID.RUBY_DRAGON_BOLTS_E);
            }

        }

        // AOE is disabled
        if (!config.triggerOnAoe()) {
            // Range weapons
            if (AOE_RANGE_WEAPONS.contains(weaponId)) return true;

            // Manual AoE spell
            if (isAoeManualCasting) return true;

            // Autocast AoE spell
            if (AUTOCASTING_WEAPONS.contains(weaponId) && SpellUtil.isAoE(autocastingSpellId))
                return true;
        }
        return false;
    }
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cyneris.predictedhit;

import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.StructComposition;

public enum AttackStyle
{
    ACCURATE("Accurate", Skill.ATTACK),
    AGGRESSIVE("Aggressive", Skill.STRENGTH),
    DEFENSIVE("Defensive", Skill.DEFENCE),
    CONTROLLED("Controlled", Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
    RANGING("Ranging", Skill.RANGED),
    LONGRANGE("Longrange", Skill.RANGED, Skill.DEFENCE),
    CASTING("Casting", Skill.MAGIC),
    DEFENSIVE_CASTING("Defensive Casting", Skill.MAGIC, Skill.DEFENCE),
    OTHER("Other");

    @Getter
    private final String name;
    @Getter
    private final Skill[] skills;

    private static final int WEAPON_STYLES = 3908; // EnumID.WEAPON_STYLES
    private static final int ATTACK_STYLE_NAME = 1407; // ParamID.ATTACK_STYLE_NAME

    AttackStyle(String name, Skill... skills)
    {
        this.name = name;
        this.skills = skills;
    }

    // Duplicated from RuneLite's AttackStylesPlugin.java
    public static AttackStyle[] getAttackStylesForWeaponType(Client client, int weaponType)
    {
        // from script4525
        int weaponStyleEnum = client.getEnum(WEAPON_STYLES).getIntValue(weaponType);
        if (weaponStyleEnum == -1)
        {
            if (weaponType == 30)
            {
                // Partisan
                return new AttackStyle[]{
                        AttackStyle.ACCURATE, AttackStyle.AGGRESSIVE, AttackStyle.AGGRESSIVE, DEFENSIVE
                };
            }
            return new AttackStyle[0];
        }

        int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

        if (weaponStyleStructs == null)
        {
            return new AttackStyle[0];
        }

        AttackStyle[] styles = new AttackStyle[weaponStyleStructs.length];
        int i = 0;
        for (int style : weaponStyleStructs)
        {
            StructComposition attackStyleStruct = client.getStructComposition(style);
            String attackStyleName = attackStyleStruct.getStringValue(ATTACK_STYLE_NAME);

            AttackStyle attackStyle = AttackStyle.valueOf(attackStyleName.toUpperCase());
            if (attackStyle == AttackStyle.OTHER)
            {
                // "Other" is used for no style
                ++i;
                continue;
            }

            // "Defensive" is used for Defensive and also Defensive casting
            if (i == 5 && attackStyle == AttackStyle.DEFENSIVE)
            {
                attackStyle = AttackStyle.DEFENSIVE_CASTING;
            }

            styles[i++] = attackStyle;
        }
        return styles;
    }
}
/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.cyneris.predictedhit;

/**
 * An enumeration of skills that a player can level.
 */
public enum Skill
{
    ATTACK("Attack"),
    DEFENCE("Defence"),
    STRENGTH("Strength"),
    HITPOINTS("Hitpoints"),
    RANGED("Ranged"),
    PRAYER("Prayer"),
    MAGIC("Magic"),
    COOKING("Cooking"),
    WOODCUTTING("Woodcutting"),
    FLETCHING("Fletching"),
    FISHING("Fishing"),
    FIREMAKING("Firemaking"),
    CRAFTING("Crafting"),
    SMITHING("Smithing"),
    MINING("Mining"),
    HERBLORE("Herblore"),
    AGILITY("Agility"),
    THIEVING("Thieving"),
    SLAYER("Slayer"),
    FARMING("Farming"),
    RUNECRAFT("Runecraft"),
    HUNTER("Hunter"),
    CONSTRUCTION("Construction"),
    /**
     * The level of all skills added together.
     */
    OVERALL("Overall");

    private final String name;

    Skill(String name)
    {
        this.name = name;
    }

    /**
     * Gets the name of the skill.
     *
     * @return the skill name
     */
    public String getName()
    {
        return name;
    }

    public static Skill fromSkill(net.runelite.api.Skill skill) {
        return skill.ordinal() < Skill.values().length ? Skill.values()[skill.ordinal()] : null;
//		return Skill.valueOf(skill.getName().toUpperCase());
    }

    public net.runelite.api.Skill toSkill() {
        return ordinal() < net.runelite.api.Skill.values().length ? net.runelite.api.Skill.values()[ordinal()] : null;
//		return net.runelite.api.Skill.valueOf(getName().toUpperCase());
    }
}
package com.cyneris.predictedhit;

import com.google.common.collect.ImmutableSet;

import java.util.List;
import java.util.Set;

public class SpellUtil {
    /**
     * The currently selected autocast spell.
     * 0        = no spell selected.
     * <p>
     * 1 -> 4   = wind, water, earth, fire strike
     * 5 -> 8   = wind, water, earth, fire bolt
     * 9 -> 12  = wind, water, earth, fire blast
     * 13 -> 16 = wind, water, earth, fire wave
     * 48 -> 51 = wind, water, earth, fire surge
     * <p>
     * 31 -> 34 = Smoke, Shadow, Blood, Ice Rush
     * 35 -> 38 = Smoke, Shadow, Blood, Ice Burst
     * 39 -> 42 = Smoke, Shadow, Blood, Ice Blitz
     * 43 -> 46 = Smoke, Shadow, Blood, Ice Barrage
     * <p>
     * 53 -> 55 = Inferior, Superior, Dark Demonbane
     * 56 -> 58 = Ghostly, Skeletal, Undead Grasp
     * <p>
     * 47       = Iban's blast
     * 17       = Crumble Undead
     * 18       = Magic Dart
     * 19       = Claws of Guthix
     * 20       = Flames of Zamorak
     * 52       = Saradomin Strike
     */
    private static final Set<Integer> AOE_SPELL_IDS = new ImmutableSet.Builder<Integer>()
            .addAll(List.of(35, 36, 37, 38, 43, 44, 45, 46))
            .build();

    public static boolean isAoE(int spellId) {
        return AOE_SPELL_IDS.contains(spellId);
    }

}

package com.cyneris.predictedhit.npcswithscalingbonus.tob;

import net.runelite.api.NpcID;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

// We need a mapping (npc id, raid_type) -> xp bonus
// EM = Entry Mode
// HM = Hard Mode
public enum ToBNPCs
{
    // TOB EM
    // I'm not sure if EM does not scale at all
    BLOAT_EM(			new ToBNPC(1.075,	1.075, 	1.075	), NpcID.PESTILENT_BLOAT_10812),
    NYLOCAS_VASILIAS_EM(new ToBNPC(1.025,	1.025, 	1.025	), NpcID.NYLOCAS_VASILIAS_10787, NpcID.NYLOCAS_VASILIAS_10788, NpcID.NYLOCAS_VASILIAS_10789),
    SOTETSEG_EM(		new ToBNPC(1.045,	1.045, 	1.045	), NpcID.SOTETSEG_10865),
    VERZIK_P1_EM(		new ToBNPC(1.05,	1.05, 	1.05	), NpcID.VERZIK_VITUR_10831, NpcID.VERZIK_VITUR_10832),
    VERZIK_P2_EM(		new ToBNPC(1.025,	1.025, 	1.025	), NpcID.VERZIK_VITUR_10833, NpcID.VERZIK_VITUR_10834),
    VERZIK_P3_EM(		new ToBNPC(1.125,	1.125, 	1.125	), NpcID.VERZIK_VITUR_10835, NpcID.VERZIK_VITUR_10836),
    // TOB
    BLOAT(				new ToBNPC(1.7, 	1.775, 	1.85	), NpcID.PESTILENT_BLOAT),
    NYLOCAS_VASILIAS(	new ToBNPC(1.175,	1.2, 	1.2		), NpcID.NYLOCAS_VASILIAS_8355, NpcID.NYLOCAS_VASILIAS_8356, NpcID.NYLOCAS_VASILIAS_8357),
    SOTETSEG(			new ToBNPC(1.375,	1.375, 	1.375	), NpcID.SOTETSEG_8388),
    VERZIK_P1(			new ToBNPC(1.05,	1.05, 	1.05	), NpcID.VERZIK_VITUR_8370, NpcID.VERZIK_VITUR_8371),
    VERZIK_P2(			new ToBNPC(1.30,	1.30, 	1.30	), NpcID.VERZIK_VITUR_8372, NpcID.VERZIK_VITUR_8373),
    VERZIK_P3(			new ToBNPC(1.575,	1.575, 	1.575	), NpcID.VERZIK_VITUR_8374, NpcID.VERZIK_VITUR_8375),
    // TOB HM
    BLOAT_HM(			new ToBNPC(1.8, 	1.85, 	1.85	), NpcID.PESTILENT_BLOAT_10813),
    NYLOCAS_VASILIAS_HM(new ToBNPC(1.175,	1.2, 	1.2		), NpcID.NYLOCAS_VASILIAS_10808, NpcID.NYLOCAS_VASILIAS_10809, NpcID.NYLOCAS_VASILIAS_10810),
    SOTETSEG_HM(		new ToBNPC(1.4,	1.4, 	1.4		), NpcID.SOTETSEG_10868),
    VERZIK_P1_HM(		new ToBNPC(1.05,	1.05, 	1.05	), NpcID.VERZIK_VITUR_10848, NpcID.VERZIK_VITUR_10849),
    VERZIK_P2_HM(		new ToBNPC(1.30,	1.30, 	1.30	), NpcID.VERZIK_VITUR_10850, NpcID.VERZIK_VITUR_10851),
    VERZIK_P3_HM(		new ToBNPC(1.575,	1.575, 	1.575	), NpcID.VERZIK_VITUR_10852, NpcID.VERZIK_VITUR_10853),
    ;
    private final HashSet<Integer> ids;
    private final ToBNPC npcWithScalingBonus;
    ToBNPCs(ToBNPC npcWithScalingBonus, int ... ids)
    {
        this.npcWithScalingBonus = npcWithScalingBonus;
        this.ids = new HashSet<>();
        Arrays.stream(ids).forEach(this.ids::add);
    }

    private static final HashMap<Integer, ToBNPC> NPCS_WITH_SCALING_BONUS_MAPPING;

    static
    {
        NPCS_WITH_SCALING_BONUS_MAPPING = new HashMap<>();
        for (ToBNPCs value : ToBNPCs.values())
        {
            for (Integer id : value.ids)
            {
                NPCS_WITH_SCALING_BONUS_MAPPING.put(id, value.npcWithScalingBonus);
            }
        }
    }

    public static boolean isTOBNPC(int id)
    {
        return NPCS_WITH_SCALING_BONUS_MAPPING.containsKey(id);
    }

    public static double getModifier(int id, int partySize)
    {
        if (isTOBNPC(id))
        {
            return NPCS_WITH_SCALING_BONUS_MAPPING.get(id).calculateModifier(partySize);
        }
        return 1.0;
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.tob;

public class ToBNPC
{
    private final double[] modifiers;

    ToBNPC(double... modifiers)
    {
        this.modifiers = modifiers;
    }

    public double calculateModifier(int partySize)
    {
        return modifiers[Math.min(Math.max(partySize - 3, 0), modifiers.length - 1)];
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.cox;

// Head and hands
public class GreatOlm extends CoXNPC
{
    public GreatOlm(int hp, int att, int str, int mage, int range, int def, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(hp, att, str, mage, range, def, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    @Override
    protected double calculateHpScaling(int scaledPartySize, int playersInRaid)
    {
        return (scaledPartySize - 3 * Math.floor(scaledPartySize / 8.0) + 1) / 2.0;
    }

    @Override
    protected double cmHpMultiplier()
    {
        return 1.0;
    }

    @Override
    protected double calculateModifier(int raidType, int scaledPartySize, int playersInRaid)
    {
        // From testing, it seems Olm does not ever have xp bonus even though the sheet suggests otherwise.
        return 1.0;
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.cox;

import lombok.Getter;
import net.runelite.api.NpcID;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

public enum CoXNPCs
{
    TEKTON(CoXNPCStats.TEKTON.getCoxnpc(), NpcID.TEKTON_7541, NpcID.TEKTON_7542),
    TEKTON_ENRAGED(CoXNPCStats.TEKTON_ENRAGED.getCoxnpc(), NpcID.TEKTON_ENRAGED, NpcID.TEKTON_ENRAGED_7544),
    ICE_DEMON(CoXNPCStats.ICE_DEMON.getCoxnpc(), NpcID.ICE_DEMON, NpcID.ICE_DEMON_7585),
    LIZARDMAN(CoXNPCStats.LIZARDMAN.getCoxnpc(), NpcID.LIZARDMAN_SHAMAN_7573, NpcID.LIZARDMAN_SHAMAN_7574),
    MELEE_VANG(CoXNPCStats.MELEE_VANG.getCoxnpc(), NpcID.VANGUARD_7527),
    MAGE_VANG(CoXNPCStats.MAGE_VANG.getCoxnpc(), NpcID.VANGUARD_7529),
    RANGE_VANG(CoXNPCStats.RANGE_VANG.getCoxnpc(), NpcID.VANGUARD_7528),
    VESPULA(CoXNPCStats.VESPULA.getCoxnpc(), NpcID.VESPULA, NpcID.VESPULA_7531, NpcID.VESPULA_7532),
    ABYSSAL_PORTAL(CoXNPCStats.ABYSSAL_PORTAL.getCoxnpc(), NpcID.ABYSSAL_PORTAL),
    GUARDIAN(CoXNPCStats.GUARDIAN.getCoxnpc(), NpcID.GUARDIAN, NpcID.GUARDIAN_7570, NpcID.GUARDIAN_7571, NpcID.GUARDIAN_7572),
    VASA(CoXNPCStats.VASA.getCoxnpc(), NpcID.VASA_NISTIRIO, NpcID.VASA_NISTIRIO_7567),
    GLOWING_CRYSTAL(CoXNPCStats.GLOWING_CRYSTAL.getCoxnpc(), NpcID.GLOWING_CRYSTAL),
    MYSTIC(CoXNPCStats.MYSTIC.getCoxnpc(), NpcID.SKELETAL_MYSTIC, NpcID.SKELETAL_MYSTIC_7605, NpcID.SKELETAL_MYSTIC_7606),
    SMALL_CROC(CoXNPCStats.SMALL_CROC.getCoxnpc(), NpcID.MUTTADILE_7562),
    BIG_CROC(CoXNPCStats.BIG_CROC.getCoxnpc(), NpcID.MUTTADILE_7563),
    ROPE_RANGER(CoXNPCStats.ROPE_RANGER.getCoxnpc(), NpcID.DEATHLY_RANGER),
    ROPE_MAGER(CoXNPCStats.ROPE_MAGER.getCoxnpc(), NpcID.DEATHLY_MAGE),
    GREAT_OLM(CoXNPCStats.GREAT_OLM.getCoxnpc(), NpcID.GREAT_OLM, NpcID.GREAT_OLM_7554),
    GREAT_OLM_MAGE_HAND(CoXNPCStats.GREAT_OLM_MAGE_HAND.getCoxnpc(), NpcID.GREAT_OLM_LEFT_CLAW, NpcID.GREAT_OLM_LEFT_CLAW_7555),
    GREAT_OLM_MELEE_HAND(CoXNPCStats.GREAT_OLM_MELEE_HAND.getCoxnpc(), NpcID.GREAT_OLM_RIGHT_CLAW, NpcID.GREAT_OLM_RIGHT_CLAW_7553),
    SCAVENGER(CoXNPCStats.SCAVENGER.getCoxnpc(), NpcID.SCAVENGER_BEAST, NpcID.SCAVENGER_BEAST_7549),
    ;
    private final HashSet<Integer> ids;
    private final CoXNPC npcWithScalingBonus;

    CoXNPCs(CoXNPC coxnpc, int... ids)
    {
        this.npcWithScalingBonus = coxnpc;
        this.ids = new HashSet<>();
        Arrays.stream(ids).forEach(this.ids::add);
    }

    private static final HashMap<Integer, CoXNPC> COXNPC_MAPPING;

    static
    {
        COXNPC_MAPPING = new HashMap<>();
        for (CoXNPCs value : CoXNPCs.values())
        {
            for (Integer id : value.ids)
            {
                COXNPC_MAPPING.put(id, value.npcWithScalingBonus);
            }
        }
    }

    public static boolean isCOXNPC(int id)
    {
        return COXNPC_MAPPING.containsKey(id);
    }

    public static double getModifier(int id, int scaledPartySize, int playersInRaid, int raidType)
    {
        if (isCOXNPC(id))
        {
            return COXNPC_MAPPING.get(id).calculateModifier(raidType, scaledPartySize, playersInRaid);
        }
        return 1.0;
    }

    @Getter
    enum CoXNPCStats
    {
        TEKTON(new Tekton(300, 390, 390, 205, 1, 205, 64, 20, 155, 165, 105, 0, 0)),
        TEKTON_ENRAGED(new Tekton(300, 390, 390, 205, 1, 205, 64, 30, 280, 290, 180, 0, 0)),
        ICE_DEMON(new CoXNPC(140, 1, 1, 390, 390, 160, 0, 0, 70, 70, 110, 40, 140)),
        LIZARDMAN(new CoXNPC(190, 130, 130, 130, 130, 210, 58, 52, 102, 160, 150, 160, 0)),
        MAGE_VANG(new CoXNPC(180, 150, 150, 150, 150, 160, 0, 0, 315, 340, 400, 110, 50)),
        MELEE_VANG(new CoXNPC(180, 150, 150, 150, 150, 160, 20, 10, 150, 150, 150, 20, 400)),
        RANGE_VANG(new CoXNPC(180, 150, 150, 150, 150, 160, 0, 0, 55, 60, 100, 400, 300)),
        VESPULA(new CoXNPC(200, 150, 150, 88, 150, 88, 0, -8, 0, 0, 0, 70, 60)),
        ABYSSAL_PORTAL(new AbyssalPortal(250, 1, 1, 176, 1, 176, 0, 0, 0, 0, 0, 60, 140)),
        GUARDIAN(new Guardian(1, 140, 140, 1, 1, 100, 0, 20, 80, 180, -10, 0, 0)),
        VASA(new CoXNPC(300, 1, 1, 230, 230, 175, 0, 0, 170, 190, 50, 400, 40)),
        GLOWING_CRYSTAL(new GlowingCrystal(120, 1, 1, 100, 1, 100, 0, 0, -5, 180, 180, 0, 0)),
        MYSTIC(new CoXNPC(160, 140, 140, 140, 1, 187, 85, 50, 155, 155, 115, 140, 115)),
        SMALL_CROC(new CoXNPC(250, 150, 150, 1, 150, 138, 71, 48, -5, 72, 50, 60, 0)),
        BIG_CROC(new CoXNPC(250, 250, 250, 250, 250, 220, 88, 55, -5, 82, 60, 75, 0)),
        ROPE_RANGER(new CoXNPC(120, 1, 1, 155, 210, 155, 0, 0, 0, 0, 0, 0, 0)),
        ROPE_MAGER(new CoXNPC(120, 1, 1, 210, 1, 155, 0, 0, 0, 0, 0, 0, 0)),
        GREAT_OLM(new GreatOlm(800, 250, 250, 250, 250, 150, 0, 0, 200, 200, 200, 200, 50)),
        GREAT_OLM_MAGE_HAND(new GreatOlm(600, 250, 250, 175, 250, 175, 0, 0, 50, 50, 50, 50, 50)),
        GREAT_OLM_MELEE_HAND(new GreatOlm(600, 250, 250, 87, 250, 175, 0, 0, 200, 200, 200, 50, 200)),
        SCAVENGER(new Scavenger(30, 120, 120, 1, 1, 45, 0, 0, 0, 0, 0, 0, 0));
        private final CoXNPC coxnpc;
        CoXNPCStats(CoXNPC coxnpc)
        {
            this.coxnpc = coxnpc;
        }
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.cox;

// In reality scavenger beast has -97.5% xp bonus or 40x multiplier making it pointless to predict since most hits will not give hp xp
public class Scavenger extends CoXNPC
{
    public Scavenger(int hp, int att, int str, int mage, int range, int def, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(hp, att, str, mage, range, def, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    @Override
    protected double calculateHpScaling(int scaledPartySize, int playersInRaid)
    {
        return 1.0;
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.cox;


public class Guardian extends CoXNPC
{

    public Guardian(int hp, int att, int str, int mage, int range, int def, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(hp, att, str, mage, range, def, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    // Formula to calculate average mining level:
    // floor(total mining level / total party size),
    // where board scaling accounts have 0 mining.
    @Override
    protected double calculateHpScaling(int scaledPartySize, int playersInRaid)
    {
        int guardianHp = 250 - 99 + 99 * playersInRaid / scaledPartySize;
        return (1.0 + Math.floor(scaledPartySize / 2.0)) * guardianHp;
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.cox;

import com.cyneris.predictedhit.npcswithscalingbonus.NPCStats;

// Credits: De0, Bogi153, craigobaker, Ogkek, Machtigeman, and In Africa, for the CoX specific formulae used in this class and package.
public class CoXNPC extends NPCStats
{
    public CoXNPC(int hp, int att, int str, int mage, int range, int def, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(hp, att, str, def, mage, range, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    private boolean isCM(int raidType)
    {
        return raidType > 0;
    }

    protected double cmHpMultiplier()
    {
        return 1.5;
    }

    protected double cmOffensiveMultiplier()
    {
        return 1.5;
    }

    protected double cmDefenceMultiplier()
    {
        return 1.5;
    }

    protected double cmMagicMultiplier()
    {
        return 1.5;
    }

    protected double calculateHpScaling(int scaledPartySize, int playersInRaid)
    {
        return 1.0 + Math.floor(scaledPartySize / 2.0);
    }

    protected double calculateOffensiveScaling(int partySize)
    {
        return (Math.floor(Math.sqrt(partySize - 1.0)) * 7.0 + (partySize - 1.0) + 100.0) / 100.0;
    }

    protected double calculateDefensiveScaling(int partySize)
    {
        return (Math.floor(Math.sqrt(partySize - 1.0)) + Math.floor((partySize - 1) * 7.0 / 10.0) + 100.0) / 100.0;
    }

    // Assumes everyone in the raid is max combat and mining
    protected double calculateModifier(int raidType, int scaledPartySize, int playersInRaid)
    {
        double hpScaling = calculateHpScaling(scaledPartySize, playersInRaid);
        double offensiveScaling = calculateOffensiveScaling(scaledPartySize);
        double defensiveScaling = calculateDefensiveScaling(scaledPartySize);

        int hitpoints, attackLevel, strengthLevel, defenceLevel, magicLevel, rangingLevel;

        if (isCM(raidType))
        {
            hitpoints = (int) (hpScaling * getHp() * cmHpMultiplier());
            attackLevel = 1 == getAtt() ? 1 : (int) (offensiveScaling * getAtt() * cmOffensiveMultiplier());
            strengthLevel = 1 == getStr() ? 1 : (int) (offensiveScaling * getStr() * cmOffensiveMultiplier());
            defenceLevel = (int) (defensiveScaling * getDef() * cmDefenceMultiplier());
            magicLevel = 1 == getMage() ? 1 : (int) (offensiveScaling * getMage() * cmMagicMultiplier());
            rangingLevel = 1 == getRange() ? 1 : (int) (offensiveScaling * getRange() * cmOffensiveMultiplier());
        } else {
            hitpoints = (int) (hpScaling * getHp());
            attackLevel = 1 == getAtt() ? 1 : (int) (offensiveScaling * getAtt());
            strengthLevel = 1 == getStr() ? 1 : (int) (offensiveScaling * getStr());
            defenceLevel = (int) (defensiveScaling * getDef());
            magicLevel = 1 == getMage() ? 1 : (int) (offensiveScaling * getMage());
            rangingLevel = 1 == getRange() ? 1 : (int) (offensiveScaling * getRange());
        }

        NPCStats scaledStats = new NPCStats(
                hitpoints,
                attackLevel,
                strengthLevel,
                defenceLevel,
                magicLevel,
                rangingLevel,
                getOffensiveAtt(),
                getOffensiveStr(),
                getDefensiveStab(),
                getDefensiveSlash(),
                getDefensiveCrush(),
                getDefensiveMage(),
                getDefensiveRange()
        );
        return modifierFromStats(scaledStats);
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.cox;

public class GlowingCrystal extends CoXNPC
{
    public GlowingCrystal(int hp, int att, int str, int mage, int range, int def, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(hp, att, str, mage, range, def, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    @Override
    protected double cmHpMultiplier()
    {
        return 1.0;
    }

    @Override
    protected double cmDefenceMultiplier()
    {
        return 1.0;
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.cox;

public class AbyssalPortal extends CoXNPC
{
    public AbyssalPortal(int hp, int att, int str, int mage, int range, int def, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(hp, att, str, mage, range, def, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    @Override
    protected double calculateOffensiveScaling(int partySize)
    {
        return calculateDefensiveScaling(partySize);
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.cox;


public class Tekton extends CoXNPC
{
    public Tekton(int hp, int att, int str, int mage, int range, int def, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(hp, att, str, mage, range, def, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    @Override
    protected double cmMagicMultiplier()
    {
        return 1.2;
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.toa;

import lombok.Getter;
import net.runelite.api.NpcID;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

public enum ToANPCs
{
    AKKHA(ToANPCStats.AKKHA.getToANPC(), NpcID.AKKHA, NpcID.AKKHA_11790, NpcID.AKKHA_11791, NpcID.AKKHA_11792, NpcID.AKKHA_11793, NpcID.AKKHA_11794, NpcID.AKKHA_11795, NpcID.AKKHA_11796),
    BABA(ToANPCStats.BABA.getToANPC(), NpcID.BABA, NpcID.BABA_11779, NpcID.BABA_11780),
    BABOON_BRAWLER_56(ToANPCStats.BABOON_BRAWLER_56.getToANPC(), NpcID.BABOON_BRAWLER),
    BABOON_BRAWLER_68(ToANPCStats.BABOON_BRAWLER_68.getToANPC(), NpcID.BABOON_BRAWLER_11712),
    BABOON_MAGE_56(ToANPCStats.BABOON_MAGE_56.getToANPC(), NpcID.BABOON_MAGE),
    BABOON_MAGE_68(ToANPCStats.BABOON_MAGE_68.getToANPC(), NpcID.BABOON_MAGE_11714),
    BABOON_SHAMAN(ToANPCStats.BABOON_SHAMAN.getToANPC(), NpcID.BABOON_SHAMAN),
    CURSED_BABOON(ToANPCStats.CURSED_BABOON.getToANPC(), NpcID.CURSED_BABOON),
    VOLATILE_BABOON(ToANPCStats.VOLATILE_BABOON.getToANPC(), NpcID.VOLATILE_BABOON),
    KEPHRI(ToANPCStats.KEPHRI.getToANPC(), NpcID.KEPHRI, NpcID.KEPHRI_11720, NpcID.KEPHRI_11721, NpcID.KEPHRI_11722),
    ARCANE_SCARAB(ToANPCStats.ARCANE_SCARAB.getToANPC(), NpcID.ARCANE_SCARAB),
    SOLDIER_SCARAB(ToANPCStats.SOLDIER_SCARAB.getToANPC(), NpcID.SOLDIER_SCARAB),
    SPITTING_SCARAB(ToANPCStats.SPITTING_SCARAB.getToANPC(), NpcID.SPITTING_SCARAB),
    ZEBAK(ToANPCStats.ZEBAK.getToANPC(), NpcID.ZEBAK_11730, NpcID.ZEBAK_11732, NpcID.ZEBAK_11733),
    T_WARDEN_489(ToANPCStats.T_WARDEN_489.getToANPC(), NpcID.TUMEKENS_WARDEN_11756, NpcID.TUMEKENS_WARDEN_11757, NpcID.TUMEKENS_WARDEN_11758),
    T_WARDEN_544(ToANPCStats.T_WARDEN_544.getToANPC(), NpcID.TUMEKENS_WARDEN_11762, NpcID.TUMEKENS_WARDEN_11764),
    E_WARDEN_489(ToANPCStats.E_WARDEN_489.getToANPC(), NpcID.ELIDINIS_WARDEN_11753, NpcID.ELIDINIS_WARDEN_11754),
    E_WARDEN_544(ToANPCStats.E_WARDEN_544.getToANPC(), NpcID.ELIDINIS_WARDEN_11761, NpcID.ELIDINIS_WARDEN_11763),
    AKKHA_SHADOW(ToANPCStats.AKKHA_SHADOW.getToANPC(), NpcID.AKKHAS_SHADOW, NpcID.AKKHAS_SHADOW_11798, NpcID.AKKHAS_SHADOW_11799),
    OBELISK(ToANPCStats.OBELISK.getToANPC(), NpcID.OBELISK_11750, NpcID.OBELISK_11751, NpcID.OBELISK_11752);
    private final HashSet<Integer> ids;
    private final ToANPC npcWithScalingBonus;

    ToANPCs(ToANPC coxnpc, int... ids)
    {
        this.npcWithScalingBonus = coxnpc;
        this.ids = new HashSet<>();
        Arrays.stream(ids).forEach(this.ids::add);
    }

    private static final HashMap<Integer, ToANPC> TOANPCMAPPING;

    static
    {
        TOANPCMAPPING = new HashMap<>();
        for (ToANPCs value : ToANPCs.values())
        {
            for (Integer id : value.ids)
            {
                TOANPCMAPPING.put(id, value.npcWithScalingBonus);
            }
        }
    }

    public static boolean isToANPC(int id)
    {
        return TOANPCMAPPING.containsKey(id);
    }

    public static double getModifier(int id, int partySize, int raidLevel, int pathLevel)
    {
        if (isToANPC(id))
        {
            return TOANPCMAPPING.get(id).calculateModifier(raidLevel, partySize, pathLevel);
        }
        return 1.0;
    }

    enum ToANPCStats
    {
        AKKHA(new CoreBoss(40, 100, 140, 80, 100, 100, 115, 30, 60, 120, 120, 10, 60)),
        BABA(new CoreBoss(38, 150, 160, 80, 100, 0, 0, 26, 80, 160, 240, 280, 200)),
        BABOON_BRAWLER_56(new PuzzleRoomNpc(4, 40, 40, 12, 40, 40, 20, 0, 900, 900, 900, -60, 900)),
        BABOON_BRAWLER_68(new PuzzleRoomNpc(6.9, 60, 60, 20, 60, 40, 25, 0, 900, 900, 900, -60, 900)),
        BABOON_MAGE_56(new PuzzleRoomNpc(4, 40, 40, 12, 40, 40, 20, 0, 900, 900, 900, 900, -50)),
        BABOON_MAGE_68(new PuzzleRoomNpc(6, 40, 40, 12, 40, 40, 20, 0, 900, 900, 900, 900, -50)),
        BABOON_SHAMAN(new PuzzleRoomNpc(16, 60, 60, 20, 60, 60, 25, 0, 900, 900, 900, 900, -50)),
        CURSED_BABOON(new PuzzleRoomNpc(10, 60, 60, 20, 60, 60, 25, 0, 900, 900, 900, -60, -50)),
        VOLATILE_BABOON(new PuzzleRoomNpc(8, 60, 60, 20, 60, 60, 25, 0, 900, 900, 900, -60, -50)),
        KEPHRI(new CoreBoss(15, 0, 0, 80, 125, 0, 0, 0, 60, 300, 100, 200, 300)),
        ARCANE_SCARAB(new ScarabNPC(40, 75, 80, 80, 100, 95, 0, 55, 15, 250, 30, 75, 50)),
        SOLDIER_SCARAB(new ScarabNPC(40, 75, 80, 80, 100, 95, 100, 55, 15, 250, 30, 10, 250)),
        SPITTING_SCARAB(new ScarabNPC(40, 1, 80, 80, 100, 95, 0, 55, 15, 250, 30, 250, 125)),
        ZEBAK(new CoreBoss(58, 250, 140, 70, 100, 120, 160, 100, 160, 160, 260, 200, 110)),
        T_WARDEN_489(new RoomLevelInvariant.RoomLevelInvariant5x(28, 300, 150, 100, 190, 190, 0, 25, 70, 70, 70, -30, 70)),
        T_WARDEN_544(new RoomLevelInvariant.RoomLevelInvariant10x(88, 150, 150, 150, 150, 150, 0, 40, 40, 40, 20, 20, 20)),
        //T_WARDEN_544_ENRAGED(new RoomLevelInvariant.RoomLevelInvariant10x(88, 150, 150, 180, 150, 150, 0, 40, 40, 40, 20, 20, 20)),
        E_WARDEN_489(new RoomLevelInvariant.RoomLevelInvariant5x(28, 300, 150, 100, 190, 190, 0, 10, 70, 70, 70, -30, 70)),
        E_WARDEN_544(new RoomLevelInvariant.RoomLevelInvariant10x(88, 150, 150, 150, 150, 150, 0, 40, 40, 40, 20, 20, 20)),
        //E_WARDEN_544_ENRAGED(new RoomLevelInvariant.RoomLevelInvariant10x(88, 150, 150, 180, 150, 150, 0, 40, 40, 40, 20, 20, 20)), // Maps to the same ids but also leads to same xp bonus
        AKKHA_SHADOW(new RoomLevelInvariant.RoomLevelInvariant5x(14, 100, 140, 30, 100, 100, 115, 30, 60, 120, 120, 10, 60)),
        OBELISK(new RoomLevelInvariant.RoomLevelInvariant10x(26, 200, 150, 100, 100, 100, 0, 0, 70, 70, 70, 50, 60)),
        ;
        @Getter
        private final ToANPC toANPC;

        ToANPCStats(ToANPC toANPC)
        {
            this.toANPC = toANPC;
        }
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.toa;

public class PuzzleRoomNpc extends ToANPC
{
    public PuzzleRoomNpc(double baseHP, int att, int str, int def, int mage, int range, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(baseHP, att, str, def, mage, range, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    @Override
    protected int calculateHp(int raidLevel, int partySize, int pathLevel)
    {
        return (int)Math.floor(baseHP * raidLevelMod(raidLevel) * teamModifiers[partySize]);
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.toa;

public class ScarabNPC extends ToANPC
{
    public ScarabNPC(double baseHP, int att, int str, int def, int mage, int range, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(baseHP, att, str, def, mage, range, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    @Override
    protected int calculateHp(int raidLevel, int partySize, int pathLevel)
    {
        return (int)(Math.floor(baseHP * raidLevelMod(raidLevel) * roomModifiers[pathLevel] * teamModifiers[partySize]));
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.toa;

public abstract class RoomLevelInvariant extends ToANPC
{
    public static class RoomLevelInvariant5x extends RoomLevelInvariant
    {
        public RoomLevelInvariant5x(double baseHP, int att, int str, int def, int mage, int range, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
        {
            super(baseHP, att, str, def, mage, range, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
        }

        @Override
        protected int calculateHp(int raidLevel, int partySize, int pathLevel)
        {
            return calculateHp(raidLevel, partySize, pathLevel, 5.0);
        }
    }

    public static class RoomLevelInvariant10x extends RoomLevelInvariant
    {
        public RoomLevelInvariant10x(double baseHP, int att, int str, int def, int mage, int range, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
        {
            super(baseHP, att, str, def, mage, range, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
        }

        @Override
        protected int calculateHp(int raidLevel, int partySize, int pathLevel)
        {
            return calculateHp(raidLevel, partySize, pathLevel, 10.0);
        }
    }

    public RoomLevelInvariant(double baseHP, int att, int str, int def, int mage, int range, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(baseHP, att, str, def, mage, range, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    protected int calculateHp(int raidLevel, int partySize, int pathLevel, double multiplier)
    {
        return (int)(Math.round(baseHP * raidLevelMod(raidLevel) * teamModifiers[partySize]) * multiplier);
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus.toa;

// Akkha
// Baba
// Kephri
// Zebak
public class CoreBoss extends ToANPC
{
    public CoreBoss(double baseHP, int att, int str, int def, int mage, int range, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(baseHP, att, str, def, mage, range, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
    }

    @Override
    protected int calculateHp(int raidLevel, int partySize, int pathLevel)
    {
        return (int)(Math.round(baseHP * raidLevelMod(raidLevel) * roomModifiers[pathLevel] * teamModifiers[partySize]) * 10.0);
    }
}

package com.cyneris.predictedhit.npcswithscalingbonus.toa;

import com.cyneris.predictedhit.npcswithscalingbonus.NPCStats;

// Credit: Koekepan for the ToA related formulae used in this class and package.
public abstract class ToANPC extends NPCStats
{
    public static final double[] teamModifiers = {1.0, 1.9, 2.8, 3.4, 4.0, 4.6, 5.2, 5.8};
    public static final double[] roomModifiers = {1.0, 1.08, 1.13, 1.18, 1.23, 1.28, 1.33};

    protected double baseHP;
    public ToANPC(double baseHP, int att, int str, int def, int mage, int range, int offensiveAtt, int offensiveStr, int defensiveStab, int defensiveSlash, int defensiveCrush, int defensiveMage, int defensiveRange)
    {
        super(0, att, str, def, mage, range, offensiveAtt, offensiveStr, defensiveStab, defensiveSlash, defensiveCrush, defensiveMage, defensiveRange);
        this.baseHP = baseHP;
    }

    protected abstract int calculateHp(int raidLevel, int partySize, int pathLevel);
    protected double raidLevelMod(int raidLevel)
    {
        return 1 + raidLevel * 0.004;
    }

    protected double calculateModifier(int raidLevel, int partySize, int pathLevel)
    {
        partySize = Math.max(0, Math.min(teamModifiers.length - 1, partySize - 1));
        pathLevel = Math.max(0, Math.min(roomModifiers.length - 1, pathLevel));
        int hp = calculateHp(raidLevel, partySize, pathLevel);
        NPCStats npcStats = new NPCStats(hp, getAtt(), getStr(), getDef(), getMage(), getRange(), getOffensiveAtt(), getOffensiveStr(), getDefensiveStab(), getDefensiveSlash(), getDefensiveCrush(), getDefensiveMage(), getDefensiveRange());
        double modifierFromStats = modifierFromStats(npcStats);
        // not sure if required but following the formulae
        return Math.max(1.0, modifierFromStats);
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameState;
import net.runelite.api.InstanceTemplates;
import net.runelite.api.NullObjectID;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.plugins.raids.Raid;
import net.runelite.client.plugins.raids.RaidRoom;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.Perspective.SCENE_SIZE;

// Mostly copied from the core RaidsPlugin
@Slf4j
@Singleton
public class ChambersLayoutSolver
{
    static final int ROOM_MAX_SIZE = 32;
    private static final int LOBBY_PLANE = 3;
    private static final int SECOND_FLOOR_PLANE = 2;
    private static final int ROOMS_PER_PLANE = 8;
    private static final int AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE = 4;
    private static final WorldPoint TEMP_LOCATION = new WorldPoint(3360, 5152, 2);
    private static final String CM_RAID_CODE = "SPCFPC#CFP SPC#";

    private Client client;
    boolean checkInRaid;
    private boolean loggedIn;
    private boolean inRaidChambers;
    private int raidPartyID;
    @Getter
    private Raid raid;

    @Inject
    public ChambersLayoutSolver(Client client)
    {
        this.client = client;
    }

    public boolean isCM()
    {
        return raid != null && CM_RAID_CODE.equals(raid.toCode());
    }

    public void onVarbitChanged(VarbitChanged event)
    {
        if (event.getVarpId() == VarPlayer.IN_RAID_PARTY)
        {
            boolean tempInRaid = client.getVarbitValue(Varbits.IN_RAID) == 1;
            if (loggedIn && !tempInRaid)
            {
                raid = null;
            }

            raidPartyID = event.getValue();
        }

        if (event.getVarbitId() == Varbits.IN_RAID)
        {
            boolean tempInRaid = event.getValue() == 1;
            if (tempInRaid && loggedIn)
            {
                checkRaidPresence();
            }

            inRaidChambers = tempInRaid;
        }
    }

    public void onGameTick(GameTick event)
    {
        if (checkInRaid)
        {
            loggedIn = true;
            checkInRaid = false;

            if (inRaidChambers)
            {
                checkRaidPresence();
            }
            else
            {
                if (raidPartyID == -1)
                {
                    raid = null;
                }
            }
        }
    }

    public void onGameStateChanged(GameStateChanged event)
    {
        if (client.getGameState() == GameState.LOGGED_IN)
        {
            if (client.getLocalPlayer() == null
                    || client.getLocalPlayer().getWorldLocation().equals(TEMP_LOCATION))
            {
                return;
            }

            checkInRaid = true;
        }
        else if (client.getGameState() == GameState.LOGIN_SCREEN
                || client.getGameState() == GameState.CONNECTION_LOST)
        {
            loggedIn = false;
        }
        else if (client.getGameState() == GameState.HOPPING)
        {
            raid = null;
        }
    }

    private void checkRaidPresence()
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }

        inRaidChambers = client.getVarbitValue(Varbits.IN_RAID) == 1;

        if (!inRaidChambers)
        {
            return;
        }

        raid = buildRaid(raid);
    }

    private Raid buildRaid(Raid from)
    {
        Raid raid = from;

        if (raid == null)
        {
            Point gridBase = findLobbyBase();

            if (gridBase == null)
            {
                return null;
            }

            Integer lobbyIndex = findLobbyIndex(gridBase);

            if (lobbyIndex == null)
            {
                return null;
            }

            raid = new Raid(
                    new WorldPoint(client.getBaseX() + gridBase.getX(), client.getBaseY() + gridBase.getY(), LOBBY_PLANE),
                    lobbyIndex
            );
        }

        int baseX = raid.getLobbyIndex() % AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
        int baseY = raid.getLobbyIndex() % ROOMS_PER_PLANE > (AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE - 1) ? 1 : 0;

        for (int i = 0; i < raid.getRooms().length; i++)
        {
            int x = i % AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
            int y = i % ROOMS_PER_PLANE > (AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE - 1) ? 1 : 0;
            int plane = i > (ROOMS_PER_PLANE - 1) ? SECOND_FLOOR_PLANE : LOBBY_PLANE;

            x = x - baseX;
            y = y - baseY;

            x = raid.getGridBase().getX() + x * ROOM_MAX_SIZE;
            y = raid.getGridBase().getY() - y * ROOM_MAX_SIZE;

            x = x - client.getBaseX();
            y = y - client.getBaseY();

            if (x < (1 - ROOM_MAX_SIZE) || x >= SCENE_SIZE)
            {
                continue;
            }
            else if (x < 1)
            {
                x = 1;
            }

            if (y < 1)
            {
                y = 1;
            }

            Tile tile = client.getScene().getTiles()[plane][x][y];

            if (tile == null)
            {
                continue;
            }

            RaidRoom room = determineRoom(tile);
            raid.setRoom(room, i);
        }

        return raid;
    }

    private Point findLobbyBase()
    {
        Tile[][] tiles = client.getScene().getTiles()[LOBBY_PLANE];

        for (int x = 0; x < SCENE_SIZE; x++)
        {
            for (int y = 0; y < SCENE_SIZE; y++)
            {
                if (tiles[x][y] == null || tiles[x][y].getWallObject() == null)
                {
                    continue;
                }

                if (tiles[x][y].getWallObject().getId() == NullObjectID.NULL_12231)
                {
                    return tiles[x][y].getSceneLocation();
                }
            }
        }

        return null;
    }

    private RaidRoom determineRoom(Tile base)
    {
        int chunkData = client.getInstanceTemplateChunks()[base.getPlane()][(base.getSceneLocation().getX()) / 8][base.getSceneLocation().getY() / 8];
        InstanceTemplates template = InstanceTemplates.findMatch(chunkData);

        if (template == null)
        {
            return RaidRoom.EMPTY;
        }

        switch (template)
        {
            case RAIDS_LOBBY:
            case RAIDS_START:
                return RaidRoom.START;
            case RAIDS_END:
                return RaidRoom.END;
            case RAIDS_SCAVENGERS:
            case RAIDS_SCAVENGERS2:
                return RaidRoom.SCAVENGERS;
            case RAIDS_SHAMANS:
                return RaidRoom.SHAMANS;
            case RAIDS_VASA:
                return RaidRoom.VASA;
            case RAIDS_VANGUARDS:
                return RaidRoom.VANGUARDS;
            case RAIDS_ICE_DEMON:
                return RaidRoom.ICE_DEMON;
            case RAIDS_THIEVING:
                return RaidRoom.THIEVING;
            case RAIDS_FARMING:
            case RAIDS_FARMING2:
                return RaidRoom.FARMING;
            case RAIDS_MUTTADILES:
                return RaidRoom.MUTTADILES;
            case RAIDS_MYSTICS:
                return RaidRoom.MYSTICS;
            case RAIDS_TEKTON:
                return RaidRoom.TEKTON;
            case RAIDS_TIGHTROPE:
                return RaidRoom.TIGHTROPE;
            case RAIDS_GUARDIANS:
                return RaidRoom.GUARDIANS;
            case RAIDS_CRABS:
                return RaidRoom.CRABS;
            case RAIDS_VESPULA:
                return RaidRoom.VESPULA;
            default:
                return RaidRoom.EMPTY;
        }
    }

    private Integer findLobbyIndex(Point gridBase)
    {
        if (Constants.SCENE_SIZE <= gridBase.getX() + ROOM_MAX_SIZE
                || Constants.SCENE_SIZE <= gridBase.getY() + ROOM_MAX_SIZE)
        {
            return null;
        }
        int x;
        int y;
        Tile[][] tiles = client.getScene().getTiles()[LOBBY_PLANE];
        if (tiles[gridBase.getX()][gridBase.getY() + ROOM_MAX_SIZE] == null)
        {
            y = 0;
        }
        else
        {
            y = 1;
        }
        if (tiles[gridBase.getX() + ROOM_MAX_SIZE][gridBase.getY()] == null)
        {
            x = 3;
        }
        else
        {
            for (x = 0; x < 3; x++)
            {
                int sceneX = gridBase.getX() - 1 - ROOM_MAX_SIZE * x;
                if (sceneX < 0 || tiles[sceneX][gridBase.getY()] == null)
                {
                    break;
                }
            }
        }

        return x + y * AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
    }
}
package com.cyneris.predictedhit.npcswithscalingbonus;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class NPCStats
{
    private int hp;
    private int att;
    private int str;
    private int def;
    private int mage;
    private int range;

    private int offensiveAtt;
    private int offensiveStr;
//	private int offensiveMage;
//	private int offensiveMageStr;
//	private int offensiveRange;
//	private int offensiveRangeStr;

    private int defensiveStab;
    private int defensiveSlash;
    private int defensiveCrush;
    private int defensiveMage;
    private int defensiveRange;

    private static final int MAX_HP_FOR_MULTIPLIER = 2000;

    protected static double modifierFromStats(NPCStats npcStats)
    {
        int hp = Math.min(npcStats.hp, MAX_HP_FOR_MULTIPLIER);
        double averageLevel = Math.floor((hp + npcStats.getAtt() + npcStats.getStr() + npcStats.getDef()) / 4.0);
        double averageDefBonus = Math.floor((npcStats.getDefensiveStab() + npcStats.getDefensiveSlash() + npcStats.getDefensiveCrush()) / 3.0);
        return 1.0 + 0.025 * Math.floor((averageLevel * (averageDefBonus + npcStats.getOffensiveStr() + npcStats.getOffensiveAtt())) / 5120.0);
    }
}
package com.cyneris.predictedhit;

/**
 * Copyright (c) 2021, l2-
 * All rights reserved.
 * <p>
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * <p>
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * <p>
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * <p>
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import com.cyneris.predictedhit.npcswithscalingbonus.ChambersLayoutSolver;
import com.cyneris.predictedhit.npcswithscalingbonus.cox.CoXNPCs;
import com.cyneris.predictedhit.npcswithscalingbonus.toa.ToANPCs;
import com.cyneris.predictedhit.npcswithscalingbonus.tob.ToBNPCs;
import com.google.gson.Gson;
import com.google.gson.internal.LinkedTreeMap;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

@Slf4j
public class XpDropDamageCalculator {
    private static final String NPC_JSON_FILE = "npcs.min.json";
    private static final HashMap<Integer, Double> XP_BONUS_MAPPING = new HashMap<>();
    private static final Pattern RAID_LEVEL_MATCHER = Pattern.compile("(\\d+)");
    private static final int RAID_LEVEL_WIDGET_ID = (481 << 16) | 42;
    private static final int ROOM_LEVEL_WIDGET_ID = (481 << 16) | 45;
    private static final int COX_SCALED_PARTY_SIZE_VARBIT = 9540;
    private static final int RAID_PARTY_SIZE = 5424;

    private int lastToARaidLevel = 0;
    private int lastToARaidPartySize = 1;
    private int lastToARaidRoomLevel = 0;

    private final Gson GSON;
    private final Client client;
    private final ChambersLayoutSolver chambersLayoutSolver;
    private final boolean shouldEstimateXpModifier = false;

    @Inject
    protected XpDropDamageCalculator(Gson gson, Client client, ChambersLayoutSolver chambersLayoutSolver) {
        this.GSON = gson;
        this.client = client;
        this.chambersLayoutSolver = chambersLayoutSolver;
        populateMap();
    }

    public void populateMap() {
        XP_BONUS_MAPPING.clear();
        XP_BONUS_MAPPING.putAll(getNpcsWithXpBonus());
    }

    private int getCoxTotalPartySize() {
        return Math.max(1, client.getVarbitValue(COX_SCALED_PARTY_SIZE_VARBIT));
    }

    // Currently it checks a varbit for the amount of players in the raid.
    // Ideally this method returns how many non board scaling accounts started the raid.
    private int getCoxPlayersInRaid() {
        return Math.max(1, client.getVarbitValue(RAID_PARTY_SIZE));
    }

    private int getToBPartySize() {
        int count = 0;
        for (int i = 330; i < 335; i++) {
            String jagexName = client.getVarcStrValue(i);
            if (jagexName != null) {
                String name = Text.removeTags(jagexName).replace('\u00A0', ' ').trim();
                if (!"".equals(name)) {
                    count++;
                }
            }
        }
        return count;
    }

    private int getToAPartySize() {
        return 1 +
                (client.getVarbitValue(Varbits.TOA_MEMBER_1_HEALTH) != 0 ? 1 : 0) +
                (client.getVarbitValue(Varbits.TOA_MEMBER_2_HEALTH) != 0 ? 1 : 0) +
                (client.getVarbitValue(Varbits.TOA_MEMBER_3_HEALTH) != 0 ? 1 : 0) +
                (client.getVarbitValue(Varbits.TOA_MEMBER_4_HEALTH) != 0 ? 1 : 0) +
                (client.getVarbitValue(Varbits.TOA_MEMBER_5_HEALTH) != 0 ? 1 : 0) +
                (client.getVarbitValue(Varbits.TOA_MEMBER_6_HEALTH) != 0 ? 1 : 0) +
                (client.getVarbitValue(Varbits.TOA_MEMBER_7_HEALTH) != 0 ? 1 : 0);
    }

    private int getToARaidLevel() {
        return client.getVarbitValue(Varbits.TOA_RAID_LEVEL);
    }

    private int getToARoomLevel() {
        Widget levelWidget = client.getWidget(ROOM_LEVEL_WIDGET_ID);
        if (levelWidget != null && !levelWidget.isHidden()) {
            try {
                return Integer.parseInt(Text.sanitize(levelWidget.getText()));
            } catch (Exception ignored) {
            }
        }
        return -1;
    }

    private int calculateHit(int hpXpDiff, double modifier, double configModifier) {
        if (Math.abs(configModifier) < 1e-6) {
            configModifier = 1e-6;
        }

        if (modifier < 1e-6) {
            return 0;
        }

        var expectedHit = (int) Math.round((hpXpDiff * (3.0d / 4.0d)) / modifier / configModifier);
        return expectedHit;
    }

    public int calculateHitOnPlayer(int cmb, int hpXpDiff, double configModifier) {
        double modifier = Math.min(1.125d, 1 + Math.floor(cmb / 20.0d) / 40.0d);
        return calculateHit(hpXpDiff, modifier, configModifier);
    }

    public int calculateHitOnNpc(int id, int hpXpDiff, double configModifier) {
        double modifier = 1.0;
        if (CoXNPCs.isCOXNPC(id)) {
            int scaledPartySize = getCoxTotalPartySize();
            int playersInRaid = getCoxPlayersInRaid();
            // Wrong. only follows the setting of the player's board
//			int raidType = client.getVarbitValue(6385) > 0 ? 1 : 0;
            int raidType = chambersLayoutSolver.isCM() ? 1 : 0;

            modifier = CoXNPCs.getModifier(id, scaledPartySize, playersInRaid, raidType);
            log.debug("COX modifier {} {} party size {} players in raid {} raid type {}", id, modifier, scaledPartySize, playersInRaid, raidType);
        } else if (ToBNPCs.isTOBNPC(id)) {
            int partySize = getToBPartySize();
            modifier = ToBNPCs.getModifier(id, partySize);
            log.debug("TOB modifier {} {} part size {}", id, modifier, partySize);
        } else if (ToANPCs.isToANPC(id)) {
            int partySize = getToAPartySize();
            int roomLevel = getToARoomLevel();
            int raidLevel = getToARaidLevel();
            // If we cannot determine any of the above; use last known settings.
            if (partySize < 0) partySize = lastToARaidPartySize;
            else lastToARaidPartySize = partySize;
            if (roomLevel < 0) roomLevel = lastToARaidRoomLevel;
            else lastToARaidRoomLevel = roomLevel;
            if (raidLevel < 0) raidLevel = lastToARaidLevel;
            else lastToARaidLevel = raidLevel;
            modifier = ToANPCs.getModifier(id, partySize, raidLevel, roomLevel);
            log.debug("TOA modifier {} {} party size {} raid level {} room level {}", id, modifier, partySize, raidLevel, roomLevel);
        } else if (XP_BONUS_MAPPING.containsKey(id)) {
            modifier = XP_BONUS_MAPPING.get(id);
        }
        return calculateHit(hpXpDiff, modifier, configModifier);
    }

    // Don't do this in static block since we may want finer control of when it happens for a possibly long blocking
    // operation like this.
    private HashMap<Integer, Double> getNpcsWithXpBonus() {
        HashMap<Integer, Double> map1 = new HashMap<>();
        try {
            try (InputStream resource = XpDropDamageCalculator.class.getResourceAsStream(NPC_JSON_FILE);
                 BufferedReader reader = new BufferedReader(new InputStreamReader(resource,
                         StandardCharsets.UTF_8))) {
                Object jsonResult = GSON.fromJson(reader, Map.class);
                try {
                    Map<String, LinkedTreeMap<String, Double>> map = (Map<String, LinkedTreeMap<String, Double>>) jsonResult;
                    for (String id : map.keySet()) {
                        LinkedTreeMap<String, Double> result = map.get(id);
                        for (String key : result.keySet()) {
                            Double xpbonus = result.get(key);
                            xpbonus = (xpbonus + 100) / 100.0d;
                            map1.put(Integer.parseInt(id), xpbonus);
                        }
                    }
                } catch (ClassCastException castException) {
                    log.warn("Invalid json. Casting to expected hierarchy failed", castException);
                }
            }
        } catch (IOException e) {
            log.warn("Couldn't open NPC json file", e);
        }

        return map1;
    }
}
package com.cyneris.predictedhit;

import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.Actor;

@Data
@AllArgsConstructor
public class Hit
{
    private int hit;
    private Actor attachedActor;
    private AttackStyle style;
}
package com.cyneris;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class OnlyReePluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(OnlyReePlugin.class);
        RuneLite.main(args);
    }
}
