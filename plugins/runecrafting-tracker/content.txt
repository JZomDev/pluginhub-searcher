/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

@Getter
public enum Runes
{
	AIR(ItemID.AIRRUNE),
	MIND(ItemID.MINDRUNE),
	WATER(ItemID.WATERRUNE),
	EARTH(ItemID.EARTHRUNE),
	FIRE(ItemID.FIRERUNE),
	BODY(ItemID.BODYRUNE),
	COSMIC(ItemID.COSMICRUNE),
	CHAOS(ItemID.CHAOSRUNE),
	ASTRAL(ItemID.ASTRALRUNE),
	NATURE(ItemID.NATURERUNE),
	LAW(ItemID.LAWRUNE),
	DEATH(ItemID.DEATHRUNE),
	BLOOD(ItemID.BLOODRUNE),
	SOUL(ItemID.SOULRUNE),
	WRATH(ItemID.WRATHRUNE),
	MIST(ItemID.MISTRUNE),
	DUST(ItemID.DUSTRUNE),
	MUD(ItemID.MUDRUNE),
	SMOKE(ItemID.SMOKERUNE),
	STEAM(ItemID.STEAMRUNE),
	LAVA(ItemID.LAVARUNE),
	AETHER(ItemID.AETHERRUNE);

	private final int itemId;

	Runes(int itemId)
	{
		this.itemId = itemId;
	}
}

/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import javax.inject.Inject;
import javax.swing.SwingUtilities;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;

import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "Runecrafting Tracker",
	description = "Track your total profit and the amount of runes you have crafted",
	tags = {"rc", "rune", "craft", "runecraft", "runecrafting", "track", "tracker", "zmi", "ourania", "altar"}
)
public class RunecraftingTrackerPlugin extends Plugin
{
	// Rune pouch VarBits for tracking contents
	private static final int[] RUNE_POUCH_AMOUNT_VARBITS = {
		VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2, VarbitID.RUNE_POUCH_QUANTITY_3,
		VarbitID.RUNE_POUCH_QUANTITY_4, VarbitID.RUNE_POUCH_QUANTITY_5, VarbitID.RUNE_POUCH_QUANTITY_6
	};
	private static final int[] RUNE_POUCH_TYPE_VARBITS = {
		VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2, VarbitID.RUNE_POUCH_TYPE_3,
		VarbitID.RUNE_POUCH_TYPE_4, VarbitID.RUNE_POUCH_TYPE_5, VarbitID.RUNE_POUCH_TYPE_6
	};

	private RunecraftingTrackerPanel uiPanel;
	private NavigationButton uiNavigationButton;
	private final LinkedList<PanelItemData> runeTracker = new LinkedList<>();
	private final Map<Integer, PanelItemData> runeTrackerMap = new HashMap<>();
	private Multiset<Integer> inventorySnapshot;
	private Multiset<Integer> runePouchSnapshot;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Override
	protected void startUp() throws Exception
	{
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");
		uiPanel = new RunecraftingTrackerPanel(itemManager, runeTracker);

		uiNavigationButton = NavigationButton.builder()
			.tooltip("Runecrafting Tracker")
			.icon(icon)
			.priority(10)
			.panel(uiPanel)
			.build();

		clientToolbar.addNavigation(uiNavigationButton);

		// Prime an initial snapshot so the first craft can be detected
        // Don't take rune pouch snapshot on startup to avoid counting existing runes as crafted
        clientThread.invokeLater(this::takeInventorySnapshot);
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(uiNavigationButton);
	}

	private void init()
	{
		for (Runes rune : Runes.values())
		{
			PanelItemData data = new PanelItemData(
				rune.name(),
				rune.getItemId(),
				false,
				0,
				itemManager.getItemPrice(rune.getItemId()));
			runeTracker.add(data);
			runeTrackerMap.put(rune.getItemId(), data);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGING_IN)
		{
			if (runeTracker.isEmpty()) {
				clientThread.invokeLater(this::init);
			}
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		if (event.getSkill() != Skill.RUNECRAFT)
		{
			return;
		}

		if (isNotInRunecraftingRegion())
		{
			return;
		}

		// Process both inventory and rune pouch changes after XP gain
		final ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
		if (itemContainer != null)
		{
			processChange(itemContainer);
		}
		
		// Process rune pouch changes with a small delay to ensure VarBits are updated
		clientThread.invokeLater(this::processRunePouchChange);
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		// Remove automatic inventory processing - only process after XP gains
		// This prevents bank withdrawals from being counted as "crafted"
		return;
	}

	private void processChange(ItemContainer current)
	{
		// Take initial snapshot if needed
		if (inventorySnapshot == null)
		{
			inventorySnapshot = createInventorySnapshot(current);
			return; // Don't process changes on first snapshot
		}

		// Create inventory multiset {id -> quantity}
		Multiset<Integer> currentInventory = createInventorySnapshot(current);

		// Calculate difference manually to avoid @Beta API
		Multiset<Integer> diff = HashMultiset.create();
		for (Integer itemId : currentInventory.elementSet())
		{
			int currentCount = currentInventory.count(itemId);
			int snapshotCount = inventorySnapshot.count(itemId);
			int difference = currentCount - snapshotCount;
			if (difference > 0)
			{
				diff.add(itemId, difference);
			}
		}

		if (!diff.isEmpty()) {
			updateRuneTracker(diff);
		}
		inventorySnapshot = currentInventory;
	}

	private void processRunePouchChange()
	{
		// Take initial snapshot if needed
		if (runePouchSnapshot == null)
		{
			runePouchSnapshot = createRunePouchSnapshot();
			return; // Don't process changes on first snapshot
		}

		Multiset<Integer> currentRunePouch = createRunePouchSnapshot();

		// Calculate difference
		Multiset<Integer> diff = HashMultiset.create();
		for (Integer itemId : currentRunePouch.elementSet())
		{
			int currentCount = currentRunePouch.count(itemId);
			int snapshotCount = runePouchSnapshot.count(itemId);
			int difference = currentCount - snapshotCount;
			if (difference > 0)
			{
				diff.add(itemId, difference);
			}
		}

		if (!diff.isEmpty()) {
			updateRuneTracker(diff);
		}
		runePouchSnapshot = currentRunePouch;
	}

	private void updateRuneTracker(Multiset<Integer> diff)
	{
		for (Multiset.Entry<Integer> entry : diff.entrySet())
		{
			PanelItemData runeData = runeTrackerMap.get(entry.getElement());
			if (runeData != null)
			{
				if (!runeData.isVisible())
				{
					runeData.setVisible(true);
				}
				runeData.setCrafted(runeData.getCrafted() + entry.getCount());
			}
		}

		SwingUtilities.invokeLater(() -> {
			uiPanel.pack();
			uiPanel.refresh();
		});
	}

	private void takeInventorySnapshot()
	{
		final ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
		if (itemContainer != null)
		{
			inventorySnapshot = createInventorySnapshot(itemContainer);
		}
	}

	private void takeRunePouchSnapshot()
	{
		runePouchSnapshot = createRunePouchSnapshot();
	}

	private Multiset<Integer> createRunePouchSnapshot()
	{
		Multiset<Integer> snapshot = HashMultiset.create();
		final EnumComposition runepouchEnum = client.getEnum(982); // EnumID.RUNEPOUCH_RUNE
		
		if (runepouchEnum == null)
		{
			return snapshot;
		}

		for (int i = 0; i < RUNE_POUCH_AMOUNT_VARBITS.length; i++)
		{
			int amount = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]);
			int runeType = client.getVarbitValue(RUNE_POUCH_TYPE_VARBITS[i]);
			
			if (runeType != 0 && amount > 0)
			{
				// Convert rune pouch type ID to actual item ID
				int itemId = runepouchEnum.getIntValue(runeType);
				if (itemId != -1)
				{
					snapshot.add(itemId, amount);
				}
			}
		}
		
		return snapshot;
	}

	private Multiset<Integer> createInventorySnapshot(ItemContainer container)
	{
		Multiset<Integer> snapshot = HashMultiset.create();
		Arrays.stream(container.getItems())
			.forEach(item -> snapshot.add(item.getId(), item.getQuantity()));
		return snapshot;
	}

	private boolean isNotInRunecraftingRegion()
	{
		if (client.getLocalPlayer() == null)
		{
			return true;
		}

		int[] regions = client.getMapRegions();
		if (regions == null)
		{
			return true;
		}

		for (int region : regions)
		{
			if (RunecraftingRegions.REGIONS.contains(region))
			{
				return false;
			}
		}

		return true;
	}

	protected LinkedList<PanelItemData> getRuneTracker()
	{
		return runeTracker;
	}
}
/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import com.google.common.collect.ImmutableSet;
import java.util.Set;

public class RunecraftingRegions
{
	// Whitelist of region IDs where runecrafting occurs (from actual game data)
	public static final Set<Integer> REGIONS = ImmutableSet.of(
		// Air Altar
		11082, 11083, 11084, 11338, 11339, 11340, 11594, 11595, 11596,
		// Water Altar
		10570, 10571, 10572, 10826, 10827, 10828,
		// Earth Altar
		10314, 10315, 10316,
		// Fire Altar
		10059, 10060,
		// Body Altar
		9802, 9803, 9804, 10058,
		// Cosmic Altar
		8266, 8267, 8268, 8522, 8523, 8524, 8778, 8779, 8780,
		// Chaos Altar
		9034, 9035, 9036, 9290, 9291, 9292,
		// Astral Altar
		8251, 8252, 8253, 8507, 8508, 8509,
		// Nature Altar
		9546, 9547, 9548,
		// Law Altar (shares regions with Body/Nature)
		// Death Altar
		6715,
		// Blood Altar (Zeah)
		12618, 12619, 12620, 12874, 12875, 12876, 13130, 13131, 13132,
		// Ourania altar
		12119
	);

	private RunecraftingRegions()
	{
		// Utility class
	}
}

/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.util.LinkedList;

import javax.swing.*;
import javax.swing.border.EmptyBorder;

import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

public class RunecraftingTrackerPanel extends PluginPanel
{
	private static final int PANEL_BORDER_TOP = 10;
	private static final int PANEL_BORDER_SIDES = 5;
	private static final int ITEM_BORDER_VERTICAL = 4;
	private static final int ITEM_BORDER_HORIZONTAL = 10;
	private static final int TEXT_BORDER = 5;
	private static final int TOP_PANEL_BORDER = 5;
	private static final int GRID_SPACING = 2;

	private static final String HTML_LABEL_TEMPLATE =
			"<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";

	// When there is nothing tracked, display this
	private final PluginErrorPanel errorPanel = new PluginErrorPanel();
	private final JPanel layoutContainer;
	private final ItemManager itemManager;
	private final LinkedList<PanelItemData> runeTracker;

	private final ImageIcon COIN_ICON =
			new ImageIcon(ImageUtil.loadImageResource(RunecraftingTrackerPlugin.class,"COIN.png"));


	RunecraftingTrackerPanel(ItemManager itemManager, LinkedList<PanelItemData> runeTracker)
	{

		this.itemManager = itemManager;
		this.runeTracker = runeTracker;

		setBorder(new EmptyBorder(PANEL_BORDER_TOP, PANEL_BORDER_SIDES, PANEL_BORDER_SIDES, PANEL_BORDER_SIDES));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		layoutContainer = new JPanel();
		layoutContainer.setLayout(new GridLayout(0, 1, 0, GRID_SPACING));

		add(layoutContainer, BorderLayout.NORTH);

		// Error panel
		errorPanel.setContent("Runecrafting Tracker", "You have not crafted any runes yet.");

		pack();
	}

		protected void pack()
	{
		layoutContainer.removeAll();

		long totalProfit = runeTracker.stream()
			.mapToLong(runeData -> (long) runeData.getCrafted() * runeData.getCostPerRune())
			.sum();

		if (runeTracker.isEmpty())
		{
			layoutContainer.add(errorPanel);
		} else {
			layoutContainer.add(topPanelItem(COIN_ICON, totalProfit));

			runeTracker.forEach((runeData) -> {
				if (runeData.isVisible())
				{
					JPanel runePanelItem = runePanelItem(
							runeData.getId(),
							runeData.getCrafted(),
							(long) runeData.getCrafted() * runeData.getCostPerRune());
					layoutContainer.add(runePanelItem);
				}
			});
		}

	}

	protected void refresh()
	{
		revalidate();
	}

	protected LinkedList<PanelItemData> getRuneTracker()
	{
		return runeTracker;
	}

	private static String createLabel(long value)
	{
		return createLabel("Crafted: ", value, "");
	}

	private static String createLabel(String label, long value, String valueSuffix)
	{
		final String valueStr = QuantityFormatter.quantityToStackSize(value);
		return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), label, valueStr + valueSuffix);
	}

	private JPanel runePanelItem(int itemId, int craftedCount, long profitAmount)
	{
		JPanel container = new JPanel();
		container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		container.setLayout(new BorderLayout());
		container.setBorder(new EmptyBorder(ITEM_BORDER_VERTICAL, ITEM_BORDER_HORIZONTAL, ITEM_BORDER_VERTICAL, ITEM_BORDER_HORIZONTAL));

		JLabel iconLabel = new JLabel();
		itemManager.getImage(itemId, craftedCount, true).addTo(iconLabel);
		container.add(iconLabel, BorderLayout.WEST);

		JPanel textContainer = new JPanel();
		textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		textContainer.setLayout(new GridLayout(2, 1));
		textContainer.setBorder(new EmptyBorder(TEXT_BORDER, TEXT_BORDER, TEXT_BORDER, ITEM_BORDER_HORIZONTAL));

		JLabel topLine = new JLabel(createLabel(craftedCount));
		topLine.setForeground(Color.WHITE);
		topLine.setFont(FontManager.getRunescapeSmallFont());

		JLabel bottomLine = new JLabel(createLabel("Profit: ", profitAmount, " gp"));
		bottomLine.setForeground(Color.WHITE);
		bottomLine.setFont(FontManager.getRunescapeSmallFont());

		textContainer.add(topLine);
		textContainer.add(bottomLine);

		container.add(textContainer, BorderLayout.CENTER);

		return container;
	}

	private JPanel topPanelItem(ImageIcon icon, long totalProfit)
	{
		JPanel panelContainer = new JPanel();
		panelContainer.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
		panelContainer.setLayout(new BorderLayout());
		panelContainer.setBorder(new EmptyBorder(TOP_PANEL_BORDER, ITEM_BORDER_HORIZONTAL, TOP_PANEL_BORDER, ITEM_BORDER_HORIZONTAL));

		JLabel iconLabel = new JLabel(icon);
		panelContainer.add(iconLabel, BorderLayout.WEST);

		JLabel middleLine = new JLabel(createLabel("Total profit: ", totalProfit, " gp"));
		middleLine.setForeground(Color.WHITE);
		middleLine.setFont(FontManager.getRunescapeSmallFont());

		JPanel textContainer = new JPanel();
		textContainer.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
		textContainer.setLayout(new GridLayout(1, 1));
		textContainer.setBorder(new EmptyBorder(0, ITEM_BORDER_HORIZONTAL, 0, ITEM_BORDER_HORIZONTAL));
		textContainer.add(middleLine);

		panelContainer.add(textContainer, BorderLayout.CENTER);

		final JMenuItem resetAll = new JMenuItem("Reset All");

		resetAll.addActionListener(e ->
		{
			final int result = JOptionPane.showOptionDialog(panelContainer, "<html>This will permanently delete <b>all</b> crafted runes.</html>",
					"Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
					null, new String[]{"Yes", "No"}, "No");

			if (result != JOptionPane.YES_OPTION)
			{
				return;
			}


			for (PanelItemData runeData : runeTracker)
			{
				runeData.setCrafted(0);
				runeData.setVisible(false);
			}

			layoutContainer.removeAll();
			layoutContainer.add(errorPanel);

		});

		final JPopupMenu popupMenu = new JPopupMenu();
		// Set uniform border on all sides
		int borderSize = TOP_PANEL_BORDER;
		popupMenu.setBorder(new EmptyBorder(borderSize, borderSize, borderSize, borderSize));
		popupMenu.add(resetAll);
		panelContainer.setComponentPopupMenu(popupMenu);

		return panelContainer;
	}
}

/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PanelItemData
{
	private String name;
	private int id;
	private boolean visible;
	private int crafted;
	private int costPerRune;

	public PanelItemData(String name, int id, boolean visible, int crafted, int costPerRune)
	{
		this.name = name;
		this.id = id;
		this.visible = visible;
		this.crafted = crafted;
		this.costPerRune = costPerRune;
	}
}

package com.runecraftingtracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RunecraftingTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RunecraftingTrackerPlugin.class);
		RuneLite.main(args);
	}
}
