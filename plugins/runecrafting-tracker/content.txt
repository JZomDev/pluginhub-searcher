/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import lombok.Getter;
import net.runelite.api.gameval.ItemID;

@Getter
public enum Runes
{
	AIR(ItemID.AIRRUNE),
	MIND(ItemID.MINDRUNE),
	WATER(ItemID.WATERRUNE),
	EARTH(ItemID.EARTHRUNE),
	FIRE(ItemID.FIRERUNE),
	BODY(ItemID.BODYRUNE),
	COSMIC(ItemID.COSMICRUNE),
	CHAOS(ItemID.CHAOSRUNE),
	ASTRAL(ItemID.ASTRALRUNE),
	NATURE(ItemID.NATURERUNE),
	LAW(ItemID.LAWRUNE),
	DEATH(ItemID.DEATHRUNE),
	BLOOD(ItemID.BLOODRUNE),
	SOUL(ItemID.SOULRUNE),
	WRATH(ItemID.WRATHRUNE),
	MIST(ItemID.MISTRUNE),
	DUST(ItemID.DUSTRUNE),
	MUD(ItemID.MUDRUNE),
	SMOKE(ItemID.SMOKERUNE),
	STEAM(ItemID.STEAMRUNE),
	LAVA(ItemID.LAVARUNE),
	AETHER(ItemID.AETHERRUNE);

	private final int itemId;

	Runes(int itemId)
	{
		this.itemId = itemId;
	}
}

/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.SwingUtilities;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.api.Skill;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;

import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "Runecrafting Tracker",
	description = "Track your total profit and the amount of runes you have crafted",
	tags = {"rc", "rune", "craft", "runecraft", "runecrafting", "track", "tracker", "zmi", "ourania", "altar"}
)
public class RunecraftingTrackerPlugin extends Plugin
{
	private RunecraftingTrackerPanel uiPanel;
	private NavigationButton uiNavigationButton;
	private final LinkedList<PanelItemData> runeTracker = new LinkedList<>();
	private final Map<Integer, PanelItemData> runeTrackerMap = new HashMap<>();
	private Multiset<Integer> inventorySnapshot;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Override
	protected void startUp() throws Exception
	{
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");
		uiPanel = new RunecraftingTrackerPanel(itemManager, runeTracker);

		uiNavigationButton = NavigationButton.builder()
			.tooltip("Runecrafting Tracker")
			.icon(icon)
			.priority(10)
			.panel(uiPanel)
			.build();

		clientToolbar.addNavigation(uiNavigationButton);

		// Prime an initial snapshot so the first craft can be detected
		clientThread.invokeLater(this::takeInventorySnapshot);
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(uiNavigationButton);
	}

	private void init()
	{
		for (Runes rune : Runes.values())
		{
			PanelItemData data = new PanelItemData(
				rune.name(),
				rune.getItemId(),
				false,
				0,
				itemManager.getItemPrice(rune.getItemId()));
			runeTracker.add(data);
			runeTrackerMap.put(rune.getItemId(), data);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGING_IN)
		{
			if (runeTracker.isEmpty()) {
				clientThread.invokeLater(this::init);
			}
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		if (event.getSkill() != Skill.RUNECRAFT)
		{
			return;
		}

		if (!isInRunecraftingRegion())
		{
			return;
		}

		// Only take snapshot if one doesn't exist yet (before crafting)
		// Don't overwrite the baseline after crafting or we can't detect the difference
		if (inventorySnapshot == null)
		{
			takeInventorySnapshot();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (!isInRunecraftingRegion())
		{
			return;
		}

		if (event.getContainerId() != InventoryID.INV)
		{
			return;
		}

		processChange(event.getItemContainer());
	}

	private void processChange(ItemContainer current)
	{
		if (inventorySnapshot != null)
		{
			// Create inventory multiset {id -> quantity}
			Multiset<Integer> currentInventory = createInventorySnapshot(current);

			// Get inventory diff with snapshot
			final Multiset<Integer> diff = Multisets.difference(currentInventory, inventorySnapshot);

			// Process diff entries directly without ItemStack
			List<Multiset.Entry<Integer>> items = diff.entrySet().stream()
				.filter(e -> e.getCount() > 0)
				.collect(Collectors.toList());

			if (!items.isEmpty()) {
				for (Multiset.Entry<Integer> entry : items)
				{
					PanelItemData runeData = runeTrackerMap.get(entry.getElement());
					if (runeData != null)
					{
						if (!runeData.isVisible())
						{
							runeData.setVisible(true);
						}
						runeData.setCrafted(runeData.getCrafted() + entry.getCount());
					}
				}
				inventorySnapshot = currentInventory;

				SwingUtilities.invokeLater(() -> {
					uiPanel.pack();
					uiPanel.refresh();
				});
			}
		}
	}

	private void takeInventorySnapshot()
	{
		final ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
		if (itemContainer != null)
		{
			inventorySnapshot = createInventorySnapshot(itemContainer);
		}
	}

	private Multiset<Integer> createInventorySnapshot(ItemContainer container)
	{
		Multiset<Integer> snapshot = HashMultiset.create();
		Arrays.stream(container.getItems())
			.forEach(item -> snapshot.add(item.getId(), item.getQuantity()));
		return snapshot;
	}

	private boolean isInRunecraftingRegion()
	{
		if (client.getLocalPlayer() == null)
		{
			return false;
		}

		// TODO: replace deprecated method use
		int[] regions = client.getMapRegions();
		if (regions == null)
		{
			return false;
		}

		for (int region : regions)
		{
			if (RunecraftingRegions.REGIONS.contains(region))
			{
				return true;
			}
		}

		return false;
	}

	protected LinkedList<PanelItemData> getRuneTracker()
	{
		return runeTracker;
	}
}

/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import com.google.common.collect.ImmutableSet;
import java.util.Set;

public class RunecraftingRegions
{
	// Whitelist of region IDs where runecrafting occurs (from actual game data)
	public static final Set<Integer> REGIONS = ImmutableSet.of(
		// Air Altar
		11082, 11083, 11084, 11338, 11339, 11340, 11594, 11595, 11596,
		// Water Altar
		10570, 10571, 10572, 10826, 10827, 10828,
		// Earth Altar
		10314, 10315, 10316,
		// Fire Altar
		10059, 10060,
		// Body Altar
		9802, 9803, 9804, 10058,
		// Cosmic Altar
		8266, 8267, 8268, 8522, 8523, 8524, 8778, 8779, 8780,
		// Chaos Altar
		9034, 9035, 9036, 9290, 9291, 9292,
		// Astral Altar
		8251, 8252, 8253, 8507, 8508, 8509,
		// Nature Altar
		9546, 9547, 9548,
		// Law Altar (shares regions with Body/Nature)
		// Death Altar
		6715,
		// Blood Altar (Zeah)
		12618, 12619, 12620, 12874, 12875, 12876, 13130, 13131, 13132,
		// Ourania altar
		12119
	);

	private RunecraftingRegions()
	{
		// Utility class
	}
}

/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.util.LinkedList;

import javax.swing.*;
import javax.swing.border.EmptyBorder;

import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

public class RunecraftingTrackerPanel extends PluginPanel
{
	private static final int PANEL_BORDER_TOP = 10;
	private static final int PANEL_BORDER_SIDES = 5;
	private static final int ITEM_BORDER_VERTICAL = 4;
	private static final int ITEM_BORDER_HORIZONTAL = 10;
	private static final int TEXT_BORDER = 5;
	private static final int TOP_PANEL_BORDER = 5;
	private static final int GRID_SPACING = 2;

	private static final String HTML_LABEL_TEMPLATE =
			"<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";

	// When there is nothing tracked, display this
	private final PluginErrorPanel errorPanel = new PluginErrorPanel();
	private final JPanel layoutContainer;
	private ItemManager itemManager;
	private LinkedList<PanelItemData> runeTracker;

	private final ImageIcon COIN_ICON =
			new ImageIcon(ImageUtil.getResourceStreamFromClass(RunecraftingTrackerPlugin.class,"COIN.png"));


	RunecraftingTrackerPanel(ItemManager itemManager, LinkedList<PanelItemData> runeTracker)
	{

		this.itemManager = itemManager;
		this.runeTracker = runeTracker;

		setBorder(new EmptyBorder(PANEL_BORDER_TOP, PANEL_BORDER_SIDES, PANEL_BORDER_SIDES, PANEL_BORDER_SIDES));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		layoutContainer = new JPanel();
		layoutContainer.setLayout(new GridLayout(0, 1, 0, GRID_SPACING));

		add(layoutContainer, BorderLayout.NORTH);

		// Error panel
		errorPanel.setContent("Runecrafting Tracker", "You have not crafted any runes yet.");

		pack();
	}

		protected void pack()
	{
		layoutContainer.removeAll();

		long totalProfit = runeTracker.stream()
			.mapToLong(runeData -> (long) runeData.getCrafted() * runeData.getCostPerRune())
			.sum();

		if (runeTracker.size() == 0)
		{
			layoutContainer.add(errorPanel);
		} else {
			layoutContainer.add(topPanelItem(COIN_ICON, totalProfit));

			runeTracker.forEach((runeData) -> {
				if (runeData.isVisible())
				{
					JPanel runePanelItem = runePanelItem(
							runeData.getId(),
							runeData.getCrafted(),
							(long) runeData.getCrafted() * runeData.getCostPerRune());
					layoutContainer.add(runePanelItem);
				}
			});
		}

	}

	protected void refresh()
	{
		revalidate();
	}

	protected LinkedList<PanelItemData> getRuneTracker()
	{
		return runeTracker;
	}

	private static String createLabel(String label, long value)
	{
		return createLabel(label, value, "");
	}

	private static String createLabel(String label, long value, String valueSuffix)
	{
		final String valueStr = QuantityFormatter.quantityToStackSize(value);
		return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), label, valueStr + valueSuffix);
	}

	private JPanel runePanelItem(int itemId, int craftedCount, long profitAmount)
	{
		JPanel container = new JPanel();
		container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		container.setLayout(new BorderLayout());
		container.setBorder(new EmptyBorder(ITEM_BORDER_VERTICAL, ITEM_BORDER_HORIZONTAL, ITEM_BORDER_VERTICAL, ITEM_BORDER_HORIZONTAL));

		JLabel iconLabel = new JLabel();
		itemManager.getImage(itemId, craftedCount, true).addTo(iconLabel);
		container.add(iconLabel, BorderLayout.WEST);

		JPanel textContainer = new JPanel();
		textContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		textContainer.setLayout(new GridLayout(2, 1));
		textContainer.setBorder(new EmptyBorder(TEXT_BORDER, TEXT_BORDER, TEXT_BORDER, ITEM_BORDER_HORIZONTAL));

		JLabel topLine = new JLabel(createLabel("Crafted: ", craftedCount));
		topLine.setForeground(Color.WHITE);
		topLine.setFont(FontManager.getRunescapeSmallFont());

		JLabel bottomLine = new JLabel(createLabel("Profit: ", profitAmount, " gp"));
		bottomLine.setForeground(Color.WHITE);
		bottomLine.setFont(FontManager.getRunescapeSmallFont());

		textContainer.add(topLine);
		textContainer.add(bottomLine);

		container.add(textContainer, BorderLayout.CENTER);

		return container;
	}

	private JPanel topPanelItem(ImageIcon icon, long totalProfit)
	{
		JPanel panelContainer = new JPanel();
		panelContainer.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
		panelContainer.setLayout(new BorderLayout());
		panelContainer.setBorder(new EmptyBorder(TOP_PANEL_BORDER, ITEM_BORDER_HORIZONTAL, TOP_PANEL_BORDER, ITEM_BORDER_HORIZONTAL));

		JLabel iconLabel = new JLabel(icon);
		panelContainer.add(iconLabel, BorderLayout.WEST);

		JLabel middleLine = new JLabel(createLabel("Total profit: ", totalProfit, " gp"));
		middleLine.setForeground(Color.WHITE);
		middleLine.setFont(FontManager.getRunescapeSmallFont());

		JPanel textContainer = new JPanel();
		textContainer.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
		textContainer.setLayout(new GridLayout(1, 1));
		textContainer.setBorder(new EmptyBorder(0, ITEM_BORDER_HORIZONTAL, 0, ITEM_BORDER_HORIZONTAL));
		textContainer.add(middleLine);

		panelContainer.add(textContainer, BorderLayout.CENTER);

		final JMenuItem resetAll = new JMenuItem("Reset All");

		resetAll.addActionListener(e ->
		{
			final int result = JOptionPane.showOptionDialog(panelContainer, String.format("<html>This will permanently delete <b>all</b> crafted runes.</html>"),
					"Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
					null, new String[]{"Yes", "No"}, "No");

			if (result != JOptionPane.YES_OPTION)
			{
				return;
			}


			for (PanelItemData runeData : runeTracker)
			{
				runeData.setCrafted(0);
				runeData.setVisible(false);
			}

			layoutContainer.removeAll();
			layoutContainer.add(errorPanel);

		});

		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(TOP_PANEL_BORDER, TOP_PANEL_BORDER, TOP_PANEL_BORDER, TOP_PANEL_BORDER));
		popupMenu.add(resetAll);
		panelContainer.setComponentPopupMenu(popupMenu);

		return panelContainer;
	}
}

/*
 * Copyright (c) 2020, Harrison <https://github.com/hBurt>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runecraftingtracker;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class PanelItemData
{
	private String name;
	private int id;
	private boolean visible;
	private int crafted;
	private int costPerRune;

	public PanelItemData(String name, int id, boolean visible, int crafted, int costPerRune)
	{
		this.name = name;
		this.id = id;
		this.visible = visible;
		this.crafted = crafted;
		this.costPerRune = costPerRune;
	}
}

package com.runecraftingtracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RunecraftingTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RunecraftingTrackerPlugin.class);
		RuneLite.main(args);
	}
}
