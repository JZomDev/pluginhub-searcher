package com.RuneLingual;

import lombok.AccessLevel;
import lombok.Getter;

import javax.inject.Inject;

@Getter
public enum LangCodeSelectableList
{
    ENGLISH ("en", "EN","EN", 8, 6, false, false, false, false, true),
    //PORTUGUÊS_BRASILEIRO ("pt_br", "PT","PT-BR", 8, 6, false, false, false, false, true),
    //NORSK("no", "NB", "NB", 8, 6, false, false, false, false, true),
    日本語("ja", "JA", "JA", 15, 13, true, true, true, true, false);
    // todo: add languages here

    private final String langCode;
    private final String deeplLangCodeSource;
    private final String deeplLangCodeTarget;
    private final int charWidth;
    private final int chatBoxCharWidth;

    @Getter(AccessLevel.NONE)
    private final boolean needCharImages;
    @Getter(AccessLevel.NONE)
    private final boolean swapMenuOptionAndTarget;
    @Getter(AccessLevel.NONE)
    private final boolean needInputOverlay;
    @Getter(AccessLevel.NONE)
    private final boolean needInputCandidateOverlay;
    @Getter(AccessLevel.NONE)
    private final boolean needSpaceBetweenWords;

    @Inject
    LangCodeSelectableList(String langCode, String deeplCodeSrc, String deeplCodeTgt, int charWidth, int chatBoxCharWidth,
                           boolean needCharImages, boolean swapMenuOptionAndTarget,
                           boolean needInputOverlay, boolean needInputCandidateOverlay,
                           boolean needSpaceBetweenWords){
        this.langCode = langCode;
        this.deeplLangCodeSource = deeplCodeSrc;
        this.deeplLangCodeTarget = deeplCodeTgt;
        this.charWidth = charWidth;
        this.chatBoxCharWidth = chatBoxCharWidth;
        this.needCharImages = needCharImages;
        this.swapMenuOptionAndTarget = swapMenuOptionAndTarget;
        this.needInputOverlay = needInputOverlay;
        this.needInputCandidateOverlay = needInputCandidateOverlay;
        this.needSpaceBetweenWords = needSpaceBetweenWords;
    }

    public boolean needsCharImages() {
        return needCharImages;
    }
    public boolean needsSwapMenuOptionAndTarget() {
        return swapMenuOptionAndTarget;
    }

    public boolean needsInputOverlay() {
        return needInputOverlay;
    }

    public boolean needsInputCandidateOverlay() {
        return needInputCandidateOverlay;
    }

    public boolean needsSpaceBetweenWords() {
        return needSpaceBetweenWords;
    }

}

package com.RuneLingual.SQL;

import lombok.Getter;

@Getter
public enum SqlVariables {
    // SQL Variables
    columnEnglish("","english"),// name of column in the database
    columnTranslation("","translation"),
    columnCategory("","category"),
    columnSubCategory("","sub_category"),
    columnSource("","source"),

    dialogueInCategory("dialogue","category"), // string value for "dialogue" in category column
    examineInCategory("examine","category"),
    nameInCategory("name","category"),
    manualInCategory("manual","category"),//probably wont use
    actionsInCategory("actions","category"),
    lvlUpMessageInCategory("lvl_up_Message","category"),
    inventActionsInCategory("inventoryActions","category"), // this is for every menu entries in the main panel(Inventory, Worn Equipment, friends list, etc.


    itemInSubCategory("item","sub_category"),
    npcInSubCategory("npc","sub_category"),
    objInSubCategory("object","sub_category"),
    levelInSubCategory("level","sub_category"), // for "(level-%d)" of player or npcs with levels, category should be "name"
    menuInSubCategory("menu","sub_category"), // for widgets that are not buttons nor interface, such as one of the skills in skill list tab, name of tabs ("Combat Options", "Quest List")
    playerInSubCategory("player","sub_category"), // for player options, such as report, trade, follow, etc.
    questInSubCategory("quest","sub_category"),

    playerInSource("player","source"), // for player options, such as report, trade, follow, etc.
    //for tabs
    combatOptionsTabInSource("combatOptionsTab","source"), // for combat options, attack styles etc. query eg: Block	actions	menu	combatOption
    skillsTabInSource("skillsTab","source"), // for skills tab
    characterSummaryTabInSource("characterSummaryTab","source"), // for character summary tab
    questListTabInSource("questListTab","source"), // for quest list tab
    achievementDiaryTabInSource("achievementDiaryTab","source"), // for achievement Diary Tab
    inventTabInSource("inventTab","source"), // for inventory tab
    wornEquipmentTabInSource("wornEquipmentTab","source"), // for worn equipment tab
    prayerTabInSource("prayerTab","source"), // for prayer tab
    spellBookTabInSource("spellBookTab","source"), // for spell book tab
    groupTabInSource("groupTab","source"), // for group tab
    friendsTabInSource("friendsTab","source"), // for friends tab
    ignoreTabInSource("ignoreTab","source"), // for ignore tab
    accountManagementTabInSource("accountManagementTab","source"), // for account management tab
    settingsTabInSource("settingsTab","source"), // for settings tab
    logoutTabInSource("logoutTab","source"), // for logout tab
    worldSwitcherTabInSource("worldSwitcherTab","source"), // for world switcher
    emotesTabInSource("emotesTab","source"), // for emotes tab
    musicTabInSource("musicTab","source"), // for music tab

    ;


    private final String value;
    private final String columnName;

    SqlVariables(String val, String columnName) {
        this.value = val;
        this.columnName = columnName;
    }

}

package com.RuneLingual.SQL;

import java.sql.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.io.File;
import java.util.*;

import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.prepareResources.Downloader;
import com.RuneLingual.RuneLingualPlugin;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;

@Slf4j
public class SqlActions {

    public static final String tableName = "transcript";
    static final String databaseFileName = FileNameAndPath.getLocalSQLFileName();
    ;
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private Downloader downloader;
    @Inject
    private FileNameAndPath fileNameAndPath;

    @Inject
    public SqlActions(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    // private String databaseUrl = "jdbc:h2:" + downloader.getLocalLangFolder() + File.separator + databaseFileName;

    public void createTable() throws SQLException {
        Connection conn = DriverManager.getConnection(this.plugin.getDatabaseUrl());
        this.plugin.setConn(conn);

        // then create new table
        String sql = "CREATE TABLE " + tableName + " ()";

        try (Statement stmt = plugin.getConn().createStatement()) {
            stmt.execute(sql);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }


    public void tsvToSqlDatabase(String[] tsvFiles, String tsvFolderPath){
        // note: table must exist before calling this function

        for (String tsvFile : tsvFiles) {
            processTsvFile(tsvFolderPath + File.separator + tsvFile);
        }

        // index the english column
        String sql = "CREATE INDEX english_index ON " + tableName + " ("+ SqlVariables.columnEnglish.getColumnName()
                + ", " + SqlVariables.columnTranslation.getColumnName()
                + ", " + SqlVariables.columnCategory.getColumnName()
                + "," + SqlVariables.columnSubCategory.getColumnName()
                + "," + SqlVariables.columnSource.getColumnName() + ")";
        try (Statement stmt = this.plugin.getConn().createStatement()) {
            stmt.execute(sql);
        }catch (SQLException e) {
            log.error("Error creating index on " + tableName, e);
        }
    }

    private void processTsvFile(String tsvFilePath) {
        log.info("Processing TSV file: " + tsvFilePath);
        try {
            List<String> lines = Files.readAllLines(Paths.get(tsvFilePath));
            String[] columnNames = lines.get(0).split("\t");

            // Ensure all columns exist
            ensureColumnsExist(columnNames);

            // Insert data
            for (int i = 1; i < lines.size(); i++) {
                if(lines.get(i).split("\t").length > columnNames.length){
                    log.info("Warning processing TSV file " + tsvFilePath + " at line " + i + " : " + lines.get(i));
                    log.info("found more values than number of columns.");
                    log.info("Column names: " + Arrays.toString(columnNames));
                    log.info("Column values: " + Arrays.toString(lines.get(i).split("\t")));
                }
                String[] fields = lines.get(i).split("\t", columnNames.length);

                StringBuilder sql = new StringBuilder("INSERT INTO " + tableName + " (");

                for (String columnName : columnNames) {
                    sql.append(columnName).append(",");
                }

                sql.deleteCharAt(sql.length() - 1); // remove last comma
                sql.append(") VALUES (");

                for (int j = 0; j < fields.length; j++) {
                    sql.append("?,");
                }

                sql.deleteCharAt(sql.length() - 1); // remove last comma
                sql.append(")");

                try (PreparedStatement pstmt = this.plugin.getConn().prepareStatement(sql.toString())) {
                    for (int j = 0; j < fields.length; j++) {
                        pstmt.setString(j + 1, fields[j]);
                    }

                    pstmt.executeUpdate();
                } catch (SQLException e) {
                    log.error("Error processing TSV file {} at line {} : '{}'", tsvFilePath, i, lines.get(i));
                    log.error("sql: '{}'", sql, e);
                }
            }
        } catch (Exception e) {
            log.error("Error processing TSV file {}", tsvFilePath, e);
        }
    }

    private void ensureColumnsExist(String[] columnNames) {
        for (String columnName : columnNames) {
            String sql = "ALTER TABLE " + tableName + " ADD COLUMN IF NOT EXISTS " + columnName + " VARCHAR(2000)";
            try (Statement stmt = this.plugin.getConn().createStatement()) {
                stmt.execute(sql);
            } catch (SQLException e) {
                log.error("Error adding column {} to " + tableName, columnName, e);
            }
        }
    }

    public String[][] executeSearchQuery(String query) {
        /*
        * Execute a search query and return the results as a 2D array
        * eg. SELECT * FROM transcript WHERE english = 'hello'
        * returns [["hello", "hola"], ["hello", "こんにちは"]]
         */

        List<List<String>> results = new ArrayList<>();
        try (Statement stmt = this.plugin.getConn().createStatement();){
            ResultSet rs = stmt.executeQuery(query);

            ResultSetMetaData rsmd = rs.getMetaData();
            int columnsNumber = rsmd.getColumnCount();

            while (rs.next()) {
                List<String> row = new ArrayList<>();
                for (int i = 1; i <= columnsNumber; i++) {
                    row.add(rs.getString(i));
                }
                results.add(row);
            }
            String[][] array = new String[results.size()][];
            for (int i = 0; i < results.size(); i++) {
                List<String> row = results.get(i);
                array[i] = row.toArray(new String[0]);
            }
            return array;
        }
        catch (SQLException e) {
            log.error("Error executing search query: {}", query, e);
        }
        return new String[0][0];
    }

    public String[] executeQuery(String query) {
        /*
            * Execute a query and return the results as a 1D array
            * eg. SELECT translation FROM transcript WHERE english = 'hello'
            * returns ["hola", "こんにちは"]
         */
        List<String> results = new ArrayList<>();
        try (Statement stmt = this.plugin.getConn().createStatement();
             ResultSet rs = stmt.executeQuery(query)) {

            while (rs.next()) {
                String columnValue = rs.getString(1);
                results.add(columnValue);
            }
        } catch (SQLException e) {
            log.error("Error executing query: {}", query, e);
        }
        return results.toArray(new String[0]);
    }

}

package com.RuneLingual.SQL;

import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import lombok.Getter;
import lombok.Setter;

import com.RuneLingual.SQL.SqlActions;
import com.RuneLingual.SQL.SqlVariables;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Getter @Setter
public class SqlQuery {
    private String english; // the whole text, not a part of Colors.wordArray
    private String translation;
    private String category;
    private String subCategory;
    private String source;

    private Colors color;


    @Inject
    RuneLingualPlugin plugin;

    @Inject
    public SqlQuery(RuneLingualPlugin plugin){
        this.plugin = plugin;
        this.english = null;
        this.translation = null;
        this.category = null;
        this.subCategory = null;
        this.source = null;
        this.color = null;
    }

    public String[] getMatching(SqlVariables column, boolean searchAlike) {
        // create query -> execute -> return result
        String query = getSearchQuery();
        query = query.replace("*", column.getColumnName());
        String[][] result = plugin.getSqlActions().executeSearchQuery(query);
        if(result.length == 0 && searchAlike){
            return new String[]{getPlaceholderMatches()};
        }
        String[] translations = new String[result.length];
        for (int i = 0; i < result.length; i++){
            translations[i] = result[i][0];
        }
        return translations;
    }

    public String[] getMatching(SqlVariables[] columns) {
        // create query -> execute -> return result
        String query = getSearchQuery();
        String[] translations = new String[columns.length];
        for (int i = 0; i < columns.length; i++){
            query = query.replace("*", columns[i].getColumnName());
            String[][] result = plugin.getSqlActions().executeSearchQuery(query);
            translations[i] = result[0][0];
        }
        return translations;
    }

    private String getPlaceholderMatches(){
        /*
        returns translation which includes placeholders at first that matches the english text,
        with the placeholders replaced with the corresponding english word/number.
        placeholders =  %s0, %s1,... for strings atleast 1 alphabet and 0 or more numbers/spaces
                        %d0, %d1,... for numbers (and only numbers)
        1. gets all records that contains placeholder values in English, and matches the query except for english
        if no matches with placeholders are found, returns the original english text
        2. returns the translation of the first match
        3. if no match is found, returns the original english text
        not tested for %s, nor tested throughly for %d
         */
        String[] placeholders = {"%s", "%d"};
        String query = getPlaceholderSearchQuery(placeholders);
        String[][] result = plugin.getSqlActions().executeSearchQuery(query);
        // returns a placeholder if no matches are found
        if (result == null || result.length == 0){
            return english;
        }
        for (String[] row : result){
            String englishWithPlaceholders = row[0];
            String translationWithPlaceholders = row[1];
            String replacedMatch = englishWithPlaceholders;
            // Replace placeholders
            // Replace placeholders for strings
            for (int i = 0; i < 100; i++) {
                String beforeReplace = replacedMatch;
                replacedMatch = replacedMatch.replace("%s" + i, "[ \\w]+");
                if (beforeReplace.equals(replacedMatch)){
                    break;
                }
            }

            // Replace placeholders for numbers
            for (int i = 0; i < 100; i++) {
                String beforeReplace = replacedMatch;
                replacedMatch = replacedMatch.replace("%d" + i, "\\d+");
                if (beforeReplace.equals(replacedMatch)){
                    break;
                }
            }

            replacedMatch = stringToRegex(replacedMatch);

            Pattern pattern = Pattern.compile(replacedMatch);
            Matcher matcher = pattern.matcher(this.english);
            if (!matcher.matches()){
                continue;
            }
            List<String> matchedStrings = new ArrayList<>();
            List<String> matchedNumbers = new ArrayList<>();
            for (int i = 1; i <= matcher.groupCount(); i++) {
                String group = matcher.group(i);
                if (group.matches("\\d+")) {
                    matchedStrings.add(group);
                } else if (group.matches("[ \\w]+")) {
                    matchedNumbers.add(group);
                }
            }

            // Replace placeholders in the translated text
            String translation = translationWithPlaceholders;
            for (int i = 0; i < matchedStrings.size(); i++) {
                translation = translation.replace("%s" + i, matchedStrings.get(i));
            }
            for (int i = 0; i < matchedNumbers.size(); i++) {
                translation = translation.replace("%d" + i, matchedNumbers.get(i));
            }
            return translation;
        }

        return english;
    }

    private String stringToRegex(String str){
        return str.replaceAll("([\\[\\](){}*+?^$.|])", "\\\\$1");
    }

    public String getSearchQuery() {
        // creates query that matches all non-empty fields
        // returns null if no fields are filled
        String query = "SELECT * FROM " + SqlActions.tableName + " WHERE ";
        if (english != null && !english.isEmpty()){
            query += SqlVariables.columnEnglish.getColumnName() + " = '" + english.replace("'","''") + "' AND ";
        }
        if (category != null && !category.isEmpty()){
            query += SqlVariables.columnCategory.getColumnName() + " = '" + category + "' AND ";
        }
        if (subCategory != null && !subCategory.isEmpty()){
            query += SqlVariables.columnSubCategory.getColumnName() + " = '" + subCategory + "' AND ";
        }
        if (source != null && !source.isEmpty()){
            query += SqlVariables.columnSource.getColumnName() + " = '" + source + "' AND ";
        }
        if (translation != null && !translation.isEmpty()){
            query += SqlVariables.columnTranslation.getColumnName() + " = '" + translation.replace("'","''") + "' AND ";
        } //todo: add more here if columns to be filtered are added

        if (query.endsWith("AND ")){
            query = query.substring(0, query.length() - 5);
            return query;
        }
        return null;
    }

    public String getPlaceholderSearchQuery(String[] placeholders) {
        // creates query that matches all non-empty fields
        // returns null if no fields are filled
        // return only english
        String query = "SELECT english, translation FROM " + SqlActions.tableName + " WHERE (english LIKE '%\\%s%' OR english LIKE '%\\%d%') AND ";
        if (category != null && !category.isEmpty()){
            query += SqlVariables.columnCategory.getColumnName() + " = '" + category + "' AND ";
        }
        if (subCategory != null && !subCategory.isEmpty()){
            query += SqlVariables.columnSubCategory.getColumnName() + " = '" + subCategory + "' AND ";
        }
        if (source != null && !source.isEmpty()){
            query += SqlVariables.columnSource.getColumnName() + " = '" + source + "' AND ";
        }
        if (query.endsWith("AND ")){
            query = query.substring(0, query.length() - 5);
            return query;
        }
        //todo: add more here if columns to be filtered are added
        return query;
    }

    public void setEnCatSubcat(String english, String category, String subCategory, Colors defaultColor){
        this.english = english;
        this.category = category;
        this.subCategory = subCategory;
        this.color = defaultColor;
    }

    public void setItemName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.nameInCategory.getValue();
        this.subCategory = SqlVariables.itemInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setNpcName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.nameInCategory.getValue();
        this.subCategory = SqlVariables.npcInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setObjectName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.nameInCategory.getValue();
        this.subCategory = SqlVariables.objInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setMenuName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.nameInCategory.getValue();
        this.subCategory = SqlVariables.menuInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }




    public void setInventoryItemActions(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.inventActionsInCategory.getValue();
        this.subCategory = SqlVariables.itemInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setGroundItemActions(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.actionsInCategory.getValue();
        this.subCategory = SqlVariables.itemInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setNpcActions(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.actionsInCategory.getValue();
        this.subCategory = SqlVariables.npcInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setObjectActions(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.actionsInCategory.getValue();
        this.subCategory = SqlVariables.objInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setMenuAcitons(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.actionsInCategory.getValue();
        this.subCategory = SqlVariables.menuInSubCategory.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setPlayerActions(String en, Colors defualtColor){
        this.english = en;
        this.category = SqlVariables.actionsInCategory.getValue();
        this.subCategory = SqlVariables.playerInSubCategory.getValue();
        this.color = defualtColor;
        this.source = null;
        this.translation = null;
    }
    public void setPlayerLevel() {
        this.english = "level";
        this.category = SqlVariables.nameInCategory.getValue();
        this.subCategory = SqlVariables.levelInSubCategory.getValue();
        this.source = null;
        this.translation = null;
    }

    public void setDialogue(String en, String npcTalkingTo, boolean speakerIsPlayer, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.dialogueInCategory.getValue();
        this.subCategory = npcTalkingTo;
        this.color = defaultColor;
        if(speakerIsPlayer){
            this.source = "Player";
        } else {
            this.source = npcTalkingTo;
        }
        this.translation = null;
    }

}

package com.RuneLingual.MouseOverlays;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.MenuCapture;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableSet;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.*;
import javax.inject.Inject;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import static java.lang.Thread.sleep;

/*
 * Copyright (c) 2017, Aria <aria@ar1as.space>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
@Slf4j
public class MouseTooltipOverlay extends Overlay
{

    /**
     * Menu types which are on widgets.
     */
    private static final Set<MenuAction> WIDGET_MENU_ACTIONS = ImmutableSet.of(
            MenuAction.WIDGET_TYPE_1,
            MenuAction.WIDGET_TARGET,
            MenuAction.WIDGET_CLOSE,
            MenuAction.WIDGET_TYPE_4,
            MenuAction.WIDGET_TYPE_5,
            MenuAction.WIDGET_CONTINUE,
            MenuAction.ITEM_USE_ON_ITEM,
            MenuAction.WIDGET_USE_ON_ITEM,
            MenuAction.ITEM_FIRST_OPTION,
            MenuAction.ITEM_SECOND_OPTION,
            MenuAction.ITEM_THIRD_OPTION,
            MenuAction.ITEM_FOURTH_OPTION,
            MenuAction.ITEM_FIFTH_OPTION,
            MenuAction.ITEM_USE,
            MenuAction.WIDGET_FIRST_OPTION,
            MenuAction.WIDGET_SECOND_OPTION,
            MenuAction.WIDGET_THIRD_OPTION,
            MenuAction.WIDGET_FOURTH_OPTION,
            MenuAction.WIDGET_FIFTH_OPTION,
            MenuAction.EXAMINE_ITEM,
            MenuAction.WIDGET_TARGET_ON_WIDGET,
            MenuAction.CC_OP_LOW_PRIORITY,
            MenuAction.CC_OP
    );

    private final TooltipManager tooltipManager;
    private final Client client;
    private final RuneLingualConfig config;
    @Inject
    private RuneLingualPlugin plugin;
    @Setter
    private static List<String> attemptedTranslation = Collections.synchronizedList(new ArrayList<>());

    @Inject
    MouseTooltipOverlay(Client client, TooltipManager tooltipManager, RuneLingualConfig config, RuneLingualPlugin plugin)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        // additionally allow tooltips above the full screen world map and welcome screen
        drawAfterInterface(InterfaceID.FULLSCREEN_CONTAINER_TLI);
        this.client = client;
        this.tooltipManager = tooltipManager;
        this.config = config;
        this.plugin = plugin;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (client.isMenuOpen())
        {
            return null;
        }

        MenuEntry[] menuEntries = client.getMenuEntries();
        int last = menuEntries.length - 1;

        if (last < 0)
        {
            return null;
        }

        MenuEntry menuEntry = menuEntries[last];
        String target = menuEntry.getTarget();
        String option = menuEntry.getOption();
        MenuAction type = menuEntry.getType();

        if (!isNecessaryMenu(type, option, target))
        {
            return null;
        }

        // if is set to be translated with API,
        if(this.plugin.getConfig().ApiConfig()){
            // only translate if it has been translated before
            if(plugin.getDeepl().getDeeplPastTranslationManager().haveTranslatedMenuBefore(option, target, menuEntry)) {
                setMouseHover(menuEntry, true);
            } else { // dont translate if it hasnt been translated before
                setMouseHover(menuEntry, false);
                return null;
            }
        } else {
            // translate with local data if not set to use API
            setMouseHover(menuEntry, true);
            return null;
        }
        return null;
    }





    private void setMouseHover(MenuEntry menuEntry, boolean transform){
        String newTarget = "";
        String newOption = "";

        MenuCapture menuCapture = this.plugin.getMenuCapture();
        // if set not to transform, add the current target and option
        if (!transform){
            tooltipManager.addFront(new Tooltip(menuEntry.getOption() + (Strings.isNullOrEmpty(menuEntry.getTarget()) ? "" : " " + menuEntry.getTarget())));
            return;
        }

        //otherwise translate the target and option
        String[] newMenus = menuCapture.translateMenuAction(menuEntry);
        if (newMenus != null)
        {
            newTarget = newMenus[0];
            newOption = newMenus[1];
        }
        if (this.plugin.getTargetLanguage().needsSwapMenuOptionAndTarget())
        {
            tooltipManager.addFront(new Tooltip((Strings.isNullOrEmpty(newTarget) ? newOption : newTarget + " " + newOption)));
            return;
        }
        tooltipManager.addFront(new Tooltip(newOption + (Strings.isNullOrEmpty(newTarget) ? "" : " " + newTarget)));
    }


    private boolean isNecessaryMenu(MenuAction type, String option, String target)
    {
        if (type == MenuAction.RUNELITE_OVERLAY || type == MenuAction.CC_OP_LOW_PRIORITY)
        {
            // These are always right click only
            return false;
        }

        if (Strings.isNullOrEmpty(option))
        {
            return false;
        }

//        // Trivial options that don't need to be highlighted, add more as they appear.
        if (option.equals("Walk here") || option.equals("Cancel") || option.equals("Continue") || target.contains("Slide"))
            return false;
        if (!config.getMouseHoverConfig())
        {
            return false;
        }


        // If this varc is set, a tooltip will be displayed soon
        int tooltipTimeout = client.getVarcIntValue(VarClientInt.TOOLTIP_TIMEOUT);
        if (tooltipTimeout > client.getGameCycle())
        {
            return false;
        }

        // If this varc is set, a tooltip is already being displayed
        int tooltipDisplayed = client.getVarcIntValue(VarClientInt.TOOLTIP_VISIBLE);
        if (tooltipDisplayed == 1)
        {
            return false;
        }
        return true;
    }
}

package com.RuneLingual.ChatMessages;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.annotation.ParametersAreNonnullByDefault;
import javax.inject.Inject;
import java.awt.*;

@Slf4j
@ParametersAreNonnullByDefault
public class ChatInputCandidateOverlay extends Overlay
{
    @Inject
    private PlayerMessage playerMessage;
    private Client client;
    private RuneLingualPlugin plugin;
    private final PanelComponent panelComponent = new PanelComponent();
    private int[] ovlPos;
    private int inputWidth = 400;
    private int foreignCharSize; // px width of each japanese characters
    private int enCharSize = 8;
    private final int candListMax = 7;//max vert number of words


    @Inject
    public ChatInputCandidateOverlay(Client client, RuneLingualPlugin plugin) {
        setPosition(OverlayPosition.BOTTOM_LEFT);
        this.client = client;
        this.plugin = plugin;
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if(!plugin.getConfig().getSelectedLanguage().needsInputCandidateOverlay()){
            return null;
        }

        foreignCharSize = plugin.getConfig().getSelectedLanguage().getCharWidth() + 1;

        String[] nonLatinMsg = {};
        
        if(plugin.getConfig().getSelectedLanguage().equals(LangCodeSelectableList.日本語)){
            nonLatinMsg = plugin.getChatInputRLingual().getUpdateChatInputJa().getKanjKatCandidates().toArray(new String[0]);
        }

        int candSelectN = plugin.getChatInputRLingual().getUpdateChatInputJa().getInstCandidateSelection();
        int msgCount = plugin.getChatInputRLingual().getUpdateChatInputJa().getInputCount();

        if (msgCount == 0
                || playerMessage.getTranslationOption().equals(Transformer.TransformOption.AS_IS)
                || nonLatinMsg.length == 0) return null;// todo:also this if in npc dialogue
        if (nonLatinMsg.length == 1 && nonLatinMsg[0].matches("[^\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+")) return  null;

        
        
        panelComponent.getChildren().clear();
        int panelN = nonLatinMsg.length/candListMax + 1;

        Color bgColor = new Color(127, 82, 33);
        panelComponent.setBackgroundColor(bgColor);

        int[] panelWordLen = new int[panelN];
        int panelWidth = 0;
        for (int j = 0; j < panelN; j++) {
            for(int i = 0; i < candListMax && i + j * candListMax < nonLatinMsg.length; i++) {
                if (nonLatinMsg[i + j * candListMax].length() > panelWordLen[j]) {
                    String word = nonLatinMsg[i + j * candListMax].split("\\d")[0];
                    panelWordLen[j] = word.length();
                }
            }
            panelWidth += panelWordLen[j] * foreignCharSize;
        }
        panelWidth += foreignCharSize *panelN + enCharSize*3*panelN + enCharSize*2*(panelN-1);
        //if (panelN > 1)
        //   panelWidth += japCharSize*(panelN-1);
        for(int i = 0; i < candListMax; i++) {
            StringBuilder jp = new StringBuilder();
            String numbering;

            for (int j = 0; j < panelN; j++) {
                if (i + j * candListMax == candSelectN)
                    jp.append("<col=00ffff>");
                else
                    jp.append("<col=ffffff>");

                if (i + j * candListMax < nonLatinMsg.length) {
                    numbering = Integer.toString(i + j * candListMax) + "  ";
                    if (i+j*candListMax < 10)
                        numbering = " " + numbering;
//                    if (i + j * candListMax == candSelectN)
//                        numbering = "＞" + numbering;
//                    else
//                        numbering = "＿" + numbering;
                    if (j > 0) {
                        jp.append("　");

                    }
                    jp.append(numbering);

                    String word = nonLatinMsg[i + j * candListMax].split("\\d")[0];
                    jp.append(word);

                    int w = panelWordLen[j] - nonLatinMsg[i + j * candListMax].length();
                    jp.append("　".repeat(Math.max(0, w)));
                }
            }
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(jp.toString().trim())
                    .build());
        }
        // Set the size of the overlay
        panelComponent.setPreferredSize(new Dimension(panelWidth,0));
        return panelComponent.render(graphics);
    }

    private int getLen(String str) {
        return str.length()*14;
    }

    private String[] splitMsg(String string) {//splits message into 2, first with length of chat input width, second (and third if needed) with remaining
        String[] ret = {
                string.substring(0, string.length() / 2),  // First half
                string.substring(string.length() / 2)       // Second half
        };
        return ret;
    }

    public static String toFullWidth(String input) {
        StringBuilder fullWidthForm = new StringBuilder();
        for (char c : input.toCharArray()) {
            if (c >= '0' && c <= '9') { // 半角数字の範囲をチェック
                fullWidthForm.append((char) (c - '0' + '０')); // '０' は全角の '0'
            } else {
                fullWidthForm.append(c); // 数字以外はそのまま追加
            }
        }
        return fullWidthForm.toString();
    }
}


package com.RuneLingual.ChatMessages;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.annotation.ParametersAreNonnullByDefault;
import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@ParametersAreNonnullByDefault
public class ChatInputOverlay extends Overlay //remove abstract when actually making overlays with this
{
    @Inject
    private Client client;
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private PlayerMessage playerMessage;
    private final PanelComponent panelComponent = new PanelComponent();
    private int[] ovlPos;
    private int paddingWidth = 55;
    private int inputWidth = 400 - paddingWidth; // 400 for the whole width, 52 for the padding and the char count
    private int foreignCharSize; // px width of each japanese characters
    private int enCharSize = 8;

    @Inject
    public ChatInputOverlay(Client client, RuneLingualPlugin plugin) {
        setPosition(OverlayPosition.BOTTOM_LEFT);
        this.client = client;
        this.plugin = plugin;
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if(!plugin.getConfig().getSelectedLanguage().needsInputOverlay()){
            return null;
        }

        foreignCharSize = plugin.getConfig().getSelectedLanguage().getCharWidth() + 1;


        int msgLength = playerMessage.getChatInputString().length();
        String nonLatinMsg = "";

        if(plugin.getConfig().getSelectedLanguage().equals(LangCodeSelectableList.日本語)){
            nonLatinMsg = plugin.getChatInputRLingual().getUpdateChatInputJa().getChatJpMsg();
        } // TODO: add more languages that need this overlay


        if (msgLength == 0
                || playerMessage.getTranslationOption().equals(Transformer.TransformOption.AS_IS)
                || nonLatinMsg.trim().isEmpty()) return null; // todo:also this if in npc dialogue

        int latingCharCount = countLatinCharacters(nonLatinMsg);
        int foreignCharCount = nonLatinMsg.length() - latingCharCount;

        panelComponent.getChildren().clear();

        // Set the size of the overlay
        int currentInputSize = foreignCharSize*(foreignCharCount)+enCharSize*latingCharCount;
        panelComponent.setPreferredSize(new Dimension(Math.min( currentInputSize + paddingWidth, inputWidth + paddingWidth),0));

        Color bgColor = new Color(127, 82, 33);
        panelComponent.setBackgroundColor(bgColor);

        if(foreignCharSize*foreignCharCount + enCharSize*latingCharCount > inputWidth) {
            String[] newMsgs = splitMsg(nonLatinMsg);
            for (int i = 0;i < newMsgs.length; i++) {
                if (i == newMsgs.length - 1) {
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left(newMsgs[i])
                            .right("(" + msgLength + "/80)")
                            .build());
                } else {
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left(newMsgs[i])
                            .build());
                }
            }
        } else {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(nonLatinMsg)
                    .right(" (" + msgLength + "/80)")
                    .build());
        }
        return panelComponent.render(graphics);
    }

public int countLatinCharacters(String str) {
    int count = 0;
    for (char c : str.toCharArray()) {
        if ((Character.isLetter(c) && Character.UnicodeBlock.of(c) == Character.UnicodeBlock.BASIC_LATIN)
                || c == ',' || c == '.' || c == '!' || c == '?' || c == ' ' || c == '\'' || c == '\"'
                || c == '(' || c == ')' || c == ':' || c == ';' || c == '-') {
            count++;
        }
    }
    return count;
}

    private int getLen(String str) {
        return str.length()*foreignCharSize;
    }

    private String[] splitMsg(String str) {//splits message
        List<String> lines = new ArrayList<>();
        int lineLength = 0;
        StringBuilder line = new StringBuilder();
        StringBuilder enWord = new StringBuilder();

        for(int i = 0; i < str.length(); i++){
            if(!isJapaneseChar(str.charAt(i))) { // make sure it doesnt go to new line in the middle of an English word
                if (str.charAt(i) != ' ') {
                    enWord.append(str.charAt(i));
                } else { // if it's a space
                    if (lineLength + enWord.length()*enCharSize  >= inputWidth) { // if adding the word would go over the width
                        lines.add(line.toString()); // add the current line to the list
                        line = enWord.append(" "); // start a new line with the word
                        lineLength = enWord.length()*(enCharSize); // set the length to the length of the word
                        enWord = new StringBuilder(); // reset the word
                    } else {
                        line.append(enWord).append(" ");
                        lineLength += enCharSize*enWord.length();
                        enWord = new StringBuilder();

                    }
                }
            } else {
                enWord = new StringBuilder();
                if (lineLength + foreignCharSize>= inputWidth) {
                    lines.add(line.toString());
                    line = new StringBuilder();
                    line.append(str.charAt(i));
                    lineLength = foreignCharSize;
                } else {
                    line.append(str.charAt(i));
                    lineLength += foreignCharSize;
                }
            }
        }
        if(lineLength > inputWidth){
            lines.add(line.toString());
            line = new StringBuilder();
        } else if(lineLength + enWord.length()*enCharSize > inputWidth) {
            lines.add(line.toString());
            line = new StringBuilder();
        }
        line.append(enWord);
        lines.add(line.toString());
        return lines.toArray(new String[0]);
    }

    public boolean isLatinChar(char c) {
        if (Character.UnicodeBlock.of(c) == Character.UnicodeBlock.BASIC_LATIN
                || c == ',' || c == '.' || c == '!' || c == '?' || c == ' ' || c == '\'' || c == '\"'
                || c == '(' || c == ')' || c == ':' || c == ';' || c == '-'
                || c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6'
                || c == '7' || c == '8' || c == '9') {
            return true;
        } else
            return false;
    }

    public boolean isJapaneseChar(char c) {
        Character.UnicodeBlock block = Character.UnicodeBlock.of(c);

        return block == Character.UnicodeBlock.HIRAGANA
                || block == Character.UnicodeBlock.KATAKANA
                || block == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS
                || block == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION
                || block == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS
                || block == Character.UnicodeBlock.KATAKANA_PHONETIC_EXTENSIONS;
    }
}

package com.RuneLingual.ChatMessages;


import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.nonLatin.Japanese.UpdateChatInputJa;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;

@Slf4j
public class ChatInputRLingual {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject @Getter
    private UpdateChatInputJa updateChatInputJa;

    @Inject
    public ChatInputRLingual(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    public void updateChatInput() { // to update input and candidate overlay
        if (plugin.getConfig().getSelectedLanguage().needsCharImages()){
            if(plugin.getConfig().getSelectedLanguage().equals(LangCodeSelectableList.日本語)){
                updateChatInputJa.updateInput();
            }
        }
    }

    public String transformChatText(String text) { // example: "konnnitiha" -> "こんにちは"
        if (plugin.getConfig().getSelectedLanguage().needsCharImages()){
            if(plugin.getConfig().getSelectedLanguage().equals(LangCodeSelectableList.日本語)){
                return updateChatInputJa.romJpTransform(text, false);
            }
        }
        return text;
    }
}

package com.RuneLingual.ChatMessages;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.clan.ClanChannel;

import javax.inject.Inject;

@Slf4j
public class PlayerMessage {
    @Inject
    Client client;
    @Inject
    RuneLingualConfig config;
    @Inject
    RuneLingualPlugin plugin;
    @Inject
    ChatCapture chatCapture;

    @Inject
    public PlayerMessage(Client client, RuneLingualConfig config, RuneLingualPlugin plugin){
        this.plugin = plugin;
        this.client = plugin.getClient();
        this.config = plugin.getConfig();
        this.chatCapture = plugin.getChatCapture();
    }

    public enum talkingIn {
        PUBLIC,
        CHANNEL,
        CLAN,
        GUEST_CLAN,
        GIM,
        NONE
    }

    public Transformer.TransformOption getTranslationOption(){
        talkingIn talkingIn = getTalkingIn();
        if(talkingIn == PlayerMessage.talkingIn.PUBLIC){
            return getMyChatConfig(config.getMyPublicConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.CHANNEL){
            return getMyChatConfig(config.getMyFcConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.CLAN){
            return getMyChatConfig(config.getMyClanConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.GUEST_CLAN){
            return getMyChatConfig(config.getMyGuestClanConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.GIM){
            return getMyChatConfig(config.getMyGIMConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.NONE){
            return Transformer.TransformOption.AS_IS;
        }
        return Transformer.TransformOption.AS_IS;
    }

    public talkingIn getTalkingIn() {

        ChatCapture.openChatbox chatbox = chatCapture.getOpenChatbox();
        ChatCapture.chatModes chatMode = chatCapture.getChatMode();

        if(chatbox == ChatCapture.openChatbox.CLOSED) {
            return talkingIn.NONE;
        }

        // check the chat box for chat code, such as /// and /g etc
        if(typedPublicCode()){
            return talkingIn.PUBLIC;
        }

        if(typedFriendsChannelCode()){
            if(joinedFC())
                return talkingIn.CHANNEL;
            else
                return talkingIn.PUBLIC;
        }

        if(typedClanCode()){
            if(joinedClan()){
                if(joinedGIM())
                    return talkingIn.GIM;
                else
                    return talkingIn.CLAN;
            } else {
                return talkingIn.NONE;
            }
        }

        if(typedGuestClanCode()){
            if(joinedGuestClan())
                return talkingIn.GUEST_CLAN;
            else
                return talkingIn.NONE;
        }

        if(typedGimCode()){
            if(joinedGIM())
                return talkingIn.GIM;
            else {
                if(getChatInputString().startsWith("////")){
                    if(joinedGuestClan())
                        return talkingIn.GUEST_CLAN;
                    else
                        return talkingIn.NONE;
                }
                else if(getChatInputString().startsWith("/g"))
                    return talkingIn.PUBLIC;
                else if(getChatInputString().startsWith("@g")){
                    if(joinedClan())
                        return talkingIn.CLAN;
                    else
                        return talkingIn.NONE;
                }
            }
        }

        // if no chat code is found
        if(chatMode == ChatCapture.chatModes.PUBLIC) {
            if (chatbox == ChatCapture.openChatbox.ALL
                    || chatbox == ChatCapture.openChatbox.GAME
                    || chatbox == ChatCapture.openChatbox.PUBLIC
                    || chatbox == ChatCapture.openChatbox.PRIVATE) {
                return talkingIn.PUBLIC;
            }

            // if friends chat tab is opened
            if (chatbox == ChatCapture.openChatbox.CHANNEL) {
                if(joinedFC())
                    return talkingIn.CHANNEL;
                else
                    return talkingIn.PUBLIC;
            }

            // if clan chat tab is opened
            if (chatbox == ChatCapture.openChatbox.CLAN) {
                if(joinedClan())
                    return talkingIn.CLAN;
                else
                    return talkingIn.PUBLIC;
            }

            // if trade or gim tab is opened
            if (chatbox == ChatCapture.openChatbox.TRADE_GIM) {
                if(joinedGIM())
                    return talkingIn.GIM;
                else
                    return talkingIn.PUBLIC;
            }

        }
        else if(chatMode == ChatCapture.chatModes.CHANNEL){
            if(!joinedFC()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE) {
                    return talkingIn.NONE;
                }
                if(chatbox == ChatCapture.openChatbox.CHANNEL){
                    return talkingIn.PUBLIC;
                }

                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }

                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.NONE;
                }
            }
            if(joinedFC()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE
                        || chatbox == ChatCapture.openChatbox.CHANNEL) {
                    return talkingIn.CHANNEL;
                }

                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }

                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.CHANNEL;
                }
            }
        }
        else if(chatMode == ChatCapture.chatModes.CLAN){
            if(!joinedClan()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE
                        || chatbox == ChatCapture.openChatbox.CLAN) {
                    return talkingIn.NONE;
                }

                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.NONE;
                }

            }
            if(joinedClan()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE
                        || chatbox == ChatCapture.openChatbox.CLAN) {
                    return talkingIn.CLAN;
                }

                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.CLAN;
                }

            }
        }
        else if(chatMode == ChatCapture.chatModes.GUEST_CLAN){
            if(!joinedGuestClan()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE) {
                    return talkingIn.NONE;
                }

                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }
                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.NONE;
                }

            }
            if(joinedGuestClan()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE) {
                    return talkingIn.GUEST_CLAN;
                }
                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }
                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.GUEST_CLAN;
                }
            }
        }
        else if(chatMode == ChatCapture.chatModes.GROUP){
            if(!joinedGIM()) {
                // this shouldn't even happen, but to be safe
                return talkingIn.NONE;
            }
            if(joinedGIM()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE
                        || chatbox == ChatCapture.openChatbox.TRADE_GIM) {
                    return talkingIn.GIM;
                }
                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }
            }
        }
        //log.info("warning: no chat mode found");
        return  talkingIn.NONE;
    }

    private boolean joinedFC(){
        FriendsChatManager fc = client.getFriendsChatManager();
        return fc != null;
    }

    private boolean joinedClan() {
        ClanChannel clan = client.getClanChannel();
        return clan != null;
    }

    private boolean joinedGIM() {
        int account_type = client.getVarbitValue(Varbits.ACCOUNT_TYPE);
        return account_type == 4 || account_type == 5 || account_type == 6;
    }

    private boolean joinedGuestClan() {
        ClanChannel guestClan = client.getGuestClanChannel();
        return guestClan != null;
    }


    private boolean typedPublicCode() {
        if(getChatInputString().startsWith("/@p"))
            return true;
        return false;
    }

    private boolean typedFriendsChannelCode() {
        if((getChatInputString().startsWith("/") && !getChatInputString().startsWith("//")
                && !getChatInputString().startsWith("/c ") && !getChatInputString().startsWith("/@c")
                && !getChatInputString().startsWith("/gc ") && !getChatInputString().startsWith("/@gc")
                && !getChatInputString().startsWith("/g ") && !getChatInputString().startsWith("/@g")
                && !getChatInputString().startsWith("/@p"))
                || getChatInputString().startsWith("/@f"))
            return true;
        return false;
    }
    private boolean typedClanCode() {
        if((getChatInputString().startsWith("//") && !getChatInputString().startsWith("///"))
                || getChatInputString().startsWith("/c ")
                || getChatInputString().startsWith("/@c"))
            return true;
        return false;
    }
    private boolean typedGuestClanCode() {
        if((getChatInputString().startsWith("///") && !getChatInputString().startsWith("////"))
                || getChatInputString().startsWith("/gc ")
                || getChatInputString().startsWith("/@gc"))
            return true;
        return false;
    }
    private boolean typedGimCode() {
        if(getChatInputString().startsWith("////")
                || getChatInputString().startsWith("/g ")
                || (getChatInputString().startsWith("/@g") && !getChatInputString().startsWith("/@gc")) )
            return true;
        return false;
    }

    public String getChatInputString(){
        return client.getVarcStrValue(VarClientStr.CHATBOX_TYPED_TEXT);
    }

    public Transformer.TransformOption getMyChatConfig(RuneLingualConfig.chatSelfConfig config) {
        if(config == RuneLingualConfig.chatSelfConfig.LEAVE_AS_IS){
            return Transformer.TransformOption.AS_IS;
        }
        if(config == RuneLingualConfig.chatSelfConfig.TRANSFORM){
            return Transformer.TransformOption.TRANSFORM;
        }
        return  Transformer.TransformOption.AS_IS;
    }
}

package com.RuneLingual.ChatMessages;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.SQL.SqlQuery;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.commonFunctions.Transformer.TransformOption;
import com.RuneLingual.ChatMessages.ChatCapture;
import com.RuneLingual.RuneLingualConfig;

import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.client.game.ChatIconManager;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;


public class OverheadCapture {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private Client client;
    @Inject
    private PlayerMessage playerMessage;
    @Inject
    Transformer transformer;
    @Getter
    private Set<Pair<OverheadTextChanged, Long>> pendingOverheadTranslations = new HashSet<>();


    @Inject
    public OverheadCapture(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    public void translateOverhead(OverheadTextChanged event) throws Exception {
        String enMsg = event.getOverheadText();
        Actor actor = event.getActor();

        String name;
        if (actor.getName() != null) {
            name = Colors.removeAllTags(actor.getName());
        } else {
            name = null;
        }

        TransformOption option = getOverheadOption(actor);
        if(option == TransformOption.AS_IS)
            return;

        if (option == TransformOption.TRANSLATE_API) {
            String pastTranslation = plugin.getDeepl().getDeeplPastTranslationManager().getPastTranslation(enMsg);
            if(pastTranslation != null) { // have translated before
                String textToDisplay = strToYellowDisplayStr(pastTranslation);
                event.getActor().setOverheadText(textToDisplay);
            } else { // never translated before
                translateOverheadWithApi(event, enMsg);
            }
        }
        else if (option == TransformOption.TRANSFORM) {
            String japaneseMsg = plugin.getChatInputRLingual().transformChatText(enMsg);
            String textToDisplay = strToYellowDisplayStr(japaneseMsg);
            event.getActor().setOverheadText(textToDisplay);
        }
        else if (option == TransformOption.TRANSLATE_LOCAL) {// todo: would need to test this
            SqlQuery dialogueQuery = new SqlQuery(plugin);
            dialogueQuery.setDialogue(enMsg, name, false , Colors.yellow);
            String localTranslation = transformer.transform(enMsg, TransformOption.TRANSLATE_LOCAL, dialogueQuery,Colors.yellow, false);
            event.getActor().setOverheadText(localTranslation);
        }
    }

    private void translateOverheadWithApi(OverheadTextChanged event, String enMsg) {
        String apiTranslation = plugin.getDeepl().translate(Colors.removeAllTags(enMsg),
                                    LangCodeSelectableList.ENGLISH,
                                    plugin.getConfig().getSelectedLanguage());
        if(apiTranslation.equals(enMsg)) {// it is pending for api translation
            pendingOverheadTranslations.add(Pair.of(event, System.currentTimeMillis() + 10*1000)); // times out in 10 seconds
            return;
        }
        String textToDisplay = strToYellowDisplayStr(apiTranslation);

        event.getActor().setOverheadText(textToDisplay);
    }

    private String strToYellowDisplayStr(String str){
        Transformer transformer = new Transformer(plugin);
        return transformer.stringToDisplayedString(str, Colors.yellow);
    }

    private TransformOption getOverheadOption(Actor actor){
        if (actor instanceof NPC || actor instanceof GameObject){//is overhead of NPC
            switch (plugin.getConfig().getNpcDialogueConfig()) {
                case DONT_TRANSLATE:
                    return TransformOption.AS_IS;
                case USE_LOCAL_DATA:
                    return TransformOption.TRANSLATE_LOCAL;
                case USE_API:
                    return TransformOption.TRANSLATE_API;
            }
        }
        String name = actor.getName();
        if(name != null) {
            name = Colors.removeAllTags(name);
            //the player is the local player
            if (name.equals(client.getLocalPlayer().getName())) {
                //return playerMessage.getTranslationOption();
                return getMatchingOption(plugin.getConfig().getMyPublicConfig());
            }

            // check inside forceful config setting
            if (plugin.getChatCapture().isInConfigList(name, plugin.getConfig().getSpecificDontTranslate()))
                return TransformOption.AS_IS;
            if (plugin.getChatCapture().isInConfigList(name, plugin.getConfig().getSpecificTransform()))
                return TransformOption.TRANSFORM;
            if (plugin.getChatCapture().isInConfigList(name, plugin.getConfig().getSpecificApiTranslate()))
                return TransformOption.TRANSLATE_API;

            // if its from a friend
//            if (client.isFriended(name, true)) {
//                return getMatchingOption(plugin.getConfig().getAllFriendsConfig());
//            }

            // if its not from local player nor a friend
            return getMatchingOption(plugin.getConfig().getPublicChatConfig());
        }
        return TransformOption.AS_IS;
    }

    private TransformOption getMatchingOption(RuneLingualConfig.chatSelfConfig configSelf){
        switch (configSelf) {
            case LEAVE_AS_IS:
                return TransformOption.AS_IS;
            case TRANSFORM:
                return TransformOption.TRANSFORM;
            default:
                return TransformOption.AS_IS;
        }
    }

    private TransformOption getMatchingOption(RuneLingualConfig.chatConfig config){
        switch (config) {
            case LEAVE_AS_IS:
                return TransformOption.AS_IS;
            case TRANSFORM:
                return TransformOption.TRANSFORM;
            case USE_API:
                return TransformOption.TRANSLATE_API;
            default:
                return TransformOption.AS_IS;
        }
    }

    public void handlePendingOverheadTranslations(){
        Set<Pair<OverheadTextChanged, Long>> toRemove = new HashSet<>();
        for(Pair<OverheadTextChanged, Long> pair : pendingOverheadTranslations){
            if(pair.getLeft().getActor() == null) {
                toRemove.add(pair);
                continue;
            }
            String currentText = pair.getLeft().getActor().getOverheadText();
            if(System.currentTimeMillis() > pair.getRight() // time out
            || currentText == null || currentText.isBlank()){ // overhead text is removed
                toRemove.add(pair);
                continue;
            }

            OverheadTextChanged event = pair.getLeft();
            String enMsg = event.getOverheadText();
            String apiTranslation = plugin.getDeepl().translate(Colors.removeAllTags(enMsg),
                    LangCodeSelectableList.ENGLISH,
                    plugin.getConfig().getSelectedLanguage());
            if(apiTranslation.equals(enMsg)) {// it is still pending for api translation
                return;
            }
            String textToDisplay = strToYellowDisplayStr(apiTranslation);
            event.getActor().setOverheadText(textToDisplay);
            toRemove.add(pair);
        }
        pendingOverheadTranslations.removeAll(toRemove);
    }
}

package com.RuneLingual.ChatMessages;

import com.RuneLingual.*;
import com.RuneLingual.ApiTranslate.Deepl;
import com.RuneLingual.SidePanelComponents.ChatBoxSection;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;

import javax.inject.Inject;

import lombok.Setter;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer.TransformOption;
import org.apache.commons.lang3.tuple.Pair;

@Slf4j
public class ChatCapture
{
    /* Captures chat messages from any source
    ignores npc dialog, as they are handled in DialogCapture*/
    
    @Inject
    private Client client;
    @Inject
    private RuneLingualConfig config;
    @Inject @Getter
    private RuneLingualPlugin plugin;
    @Inject
    private PlayerMessage playerMessage;
    @Inject
    private ChatColorManager chatColorManager;
    @Getter
    private Set<Pair<ChatMessage, Long>> pendingChatMessages = new HashSet<>(); // the untranslated message (by api) and time to expire

    
    @Inject
    ChatCapture(RuneLingualConfig config, Client client, RuneLingualPlugin plugin)
    {
        this.config = config;
        this.client = client;
        this.plugin = plugin;
    }

    public enum openChatbox{
        ALL,
        GAME,
        PUBLIC,
        PRIVATE,
        CHANNEL,
        CLAN,
        TRADE_GIM,
        CLOSED
    }

    public enum chatModes {
        PUBLIC,
        CHANNEL,
        CLAN,
        GUEST_CLAN,
        GROUP
    }


    public void handleChatMessage(ChatMessage chatMessage) throws Exception {
        ChatMessageType type = chatMessage.getType();
        MessageNode messageNode = chatMessage.getMessageNode();
        String message = chatMessage.getMessage();// e.g.<col=6800bf>Some cracks around the cave begin to ooze water.
        //log.info("Chat message received: " + message + " | type: " + type.toString() + " | name: " + chatMessage.getName());
        String name = chatMessage.getName(); // getName always returns player name
        TransformOption translationOption;


//        // debug
//        log.info("Chat message received: " + message + " | type: " + type.toString() + " | name: " + name);
//        openChatbox chatbox = getOpenChatbox();
//        chatModes chatMode = getChatMode();
//        log.info("Chatbox: " + chatbox.toString() + " | Chat mode: " + chatMode.toString());
//        PlayerMessage.talkingIn talkingIn = playerMessage.getTalkingIn();
//        log.info("Talking in: " + talkingIn.toString());
//        TransformOption translationOption = playerMessage.getTranslationOption();
//        log.info("player translation option: " + translationOption.toString());

        switch (chatMessage.getType()) {
            case MESBOX: // dont support this, yet
            case DIALOG: // will be treated in dialogCapture
                return;
            default:
                translationOption = getTranslationOption(chatMessage);
        }

        //log.info("Translation option: " + translationOption.toString());
        chatColorManager.setMessageColor(chatMessage.getMessageNode().getType());
        switch (translationOption) {
            case AS_IS:
                return;
            case TRANSLATE_LOCAL:
                localTranslator(message, messageNode, chatMessage);
                break;
            case TRANSLATE_API:
                if(plugin.getConfig().ApiConfig())
                    onlineTranslator(message, messageNode, chatMessage);
                break;
            case TRANSFORM: // ex: konnnitiha -> こんにちは
                chatTransformer(message, messageNode, chatMessage);
                break;
        }

    }
    
    private void localTranslator(String message, MessageNode node, ChatMessage chatMessage)
    {
        // todo after adding transcripts for this type of message
        addMsgToSidePanel(chatMessage, message);
    }
    
    private void onlineTranslator(String message, MessageNode node, ChatMessage chatMessage)
    {
        if(plugin.getDeepl().getDeeplCount() + message.length() + 1000 > plugin.getDeepl().getDeeplLimit())
        {
            log.info("DeepL limit reached, cannot translate message.");
            return;
        }

        String translation = plugin.getDeepl().translate(message, LangCodeSelectableList.ENGLISH, config.getSelectedLanguage());

        // if the translation is the same as the original message, don't replace it
        if(translation.equals(message)){
            pendingChatMessages.add(Pair.of(chatMessage, System.currentTimeMillis()+30*1000));// it will timeout in 30 seconds
            return;
        }
        Transformer transformer = new Transformer(plugin);
        Colors textColor = chatColorManager.getMessageColor();
        String textToDisplay = transformer.stringToDisplayedString(translation, textColor);
        replaceChatMessage(textToDisplay, node);
        addMsgToSidePanel(chatMessage, translation);
    }

    private void chatTransformer(String message, MessageNode node, ChatMessage chatMessage) {
        String newMessage = plugin.getChatInputRLingual().transformChatText(message);
        Transformer transformer = new Transformer(plugin);
        Colors textColor = chatColorManager.getMessageColor();
        String textToDisplay = transformer.stringToDisplayedString(newMessage, textColor);
        replaceChatMessage(textToDisplay, node);
        addMsgToSidePanel(chatMessage, newMessage);
    }

    private void replaceChatMessage(String newMessage, MessageNode node) {
        if(plugin.getConfig().getSelectedLanguage().needsCharImages()) {
            newMessage = insertBr(newMessage, node);// inserts break line so messages are displayed in multiple lines if they are long
        }
        node.setRuneLiteFormatMessage(newMessage);
        this.client.refreshChat();
    }

    private void addMsgToSidePanel(ChatMessage chatMessage, String newMessage)
    {
        newMessage = Colors.removeAllTags(newMessage);

        String senderName = chatMessage.getName();
        senderName = Colors.removeAllTags(senderName);

        String messageToAdd = senderName.isEmpty() ? newMessage : senderName + ": " + newMessage;
        String chatType;
        ChatBoxSection chatBoxSection = plugin.getPanel().getChatBoxSection();
        switch (chatMessage.getType()) {
            case PUBLICCHAT:
                chatType = chatBoxSection.getTabNamePublic();
                break;
            case CLAN_CHAT:
            case CLAN_GUEST_CHAT:
                chatType = chatBoxSection.getTabNameClan();
                break;
            case FRIENDSCHAT:
                chatType = chatBoxSection.getTabNameChannel();
                break;
            case CLAN_GIM_CHAT:
                chatType = chatBoxSection.getTabNameGIM();
                break;
            default:
                chatType = chatBoxSection.getTabNameGame();
        }
        plugin.getPanel().getChatBoxSection().addSentenceToTab(chatType, messageToAdd);
    }

    private TransformOption getTranslationOption(ChatMessage chatMessage) {
        String playerName = Colors.removeAllTags(chatMessage.getName());
        if (isInConfigList(playerName, config.getSpecificDontTranslate()))
            return TransformOption.AS_IS;
        else if (isInConfigList(playerName, config.getSpecificApiTranslate()))
            return TransformOption.TRANSLATE_API;
        else if (isInConfigList(playerName, config.getSpecificTransform()))
            return TransformOption.TRANSFORM;

        boolean isLocalPlayer = Objects.equals(playerName, client.getLocalPlayer().getName());
        //if its by the player themselves
//        if (Objects.equals(playerName, client.getLocalPlayer().getName())) {
//            return playerMessage.getTranslationOption();
//        }

        // if its from a friend
//        boolean isFriend = client.isFriended(playerName,true);
//        if (isFriend && !isLocalPlayer) {
//            return getChatsChatConfig(config.getAllFriendsConfig());
//        }
        switch (chatMessage.getType()){
            case PUBLICCHAT:
                if(isLocalPlayer)
                    return getChatsChatConfig(config.getMyPublicConfig());
                else
                    return getChatsChatConfig(config.getPublicChatConfig());
            case CLAN_CHAT:
                if(isLocalPlayer)
                    return getChatsChatConfig(config.getMyClanConfig());
                else
                    return getChatsChatConfig(config.getClanChatConfig());
            case CLAN_GUEST_CHAT:
                if(isLocalPlayer)
                    return getChatsChatConfig(config.getMyGuestClanConfig());
                else
                    return getChatsChatConfig(config.getGuestClanChatConfig());
            case FRIENDSCHAT:
                if(isLocalPlayer)
                    return getChatsChatConfig(config.getMyFcConfig());
                else
                    return getChatsChatConfig(config.getFriendsChatConfig());
            case CLAN_GIM_CHAT:
                if (!Objects.equals(playerName, "null") && !playerName.isEmpty())
                    if(isLocalPlayer)
                        return getChatsChatConfig(config.getMyGIMConfig());
                    else
                        return getChatsChatConfig(config.getGIMChatConfig());

            default://if its examine, engine, etc
                switch (config.getGameMessagesConfig()) {
                    case DONT_TRANSLATE:
                        return TransformOption.AS_IS;
                    case USE_LOCAL_DATA:
                        return TransformOption.TRANSLATE_LOCAL;
                    case USE_API:
                        return TransformOption.TRANSLATE_API;
                }
        }
        return TransformOption.AS_IS;
    }


    public TransformOption getChatsChatConfig(RuneLingualConfig.chatConfig chatConfig) {
        switch (chatConfig) {
            case TRANSFORM:
                return TransformOption.TRANSFORM;
            case LEAVE_AS_IS:
                return TransformOption.AS_IS;
            case USE_API:
                return TransformOption.TRANSLATE_API;
            default:
                switch (config.getGameMessagesConfig()) {
                    case USE_API:
                        return TransformOption.TRANSLATE_API;
                    case USE_LOCAL_DATA:
                        return TransformOption.TRANSLATE_LOCAL;
                    default:
                        return TransformOption.AS_IS;
                }
        }
    }

    public TransformOption getChatsChatConfig(RuneLingualConfig.chatSelfConfig chatConfig) {
        switch (chatConfig) {
            case TRANSFORM:
                return TransformOption.TRANSFORM;
            case LEAVE_AS_IS:
                return TransformOption.AS_IS;
            default:
                return TransformOption.AS_IS;
        }
    }



    public boolean isInConfigList(String item, String arrayInString) {
        String[] array = arrayInString.split("[,、\n]");
        for (String s:array)
            if (item.equals(s.trim()))
                return true;
        return false;
    }

    public ChatCapture.openChatbox getOpenChatbox() {
        int chatboxVarbitValue = client.getVarcIntValue(41);
        switch (chatboxVarbitValue) {
            case 0:
                return ChatCapture.openChatbox.ALL;
            case 1:
                return ChatCapture.openChatbox.GAME;
            case 2:
                return ChatCapture.openChatbox.PUBLIC;
            case 3:
                return ChatCapture.openChatbox.PRIVATE;
            case 4:
                return ChatCapture.openChatbox.CHANNEL;
            case 5:
                return ChatCapture.openChatbox.CLAN;
            case 6:
                return ChatCapture.openChatbox.TRADE_GIM;
            case 1337:
                return ChatCapture.openChatbox.CLOSED;
            default:
                log.info("Chatbox not found, defaulting to all");
                return ChatCapture.openChatbox.ALL;
        }
    }

    public chatModes getChatMode() {
        int forceSendVarbitValue = client.getVarcIntValue(945);
        switch(forceSendVarbitValue) {
            case 0:
                return chatModes.PUBLIC;
            case 1:
                return chatModes.CHANNEL;
            case 2:
                return chatModes.CLAN;
            case 3:
                return chatModes.GUEST_CLAN;
            case 4:
                return chatModes.GROUP;
            default:
                log.info("Chat mode not found, defaulting to public");
                return chatModes.PUBLIC;
        }
    }
    private String insertBr(String str, MessageNode messageNode) {
        String name = messageNode.getName();
        String chatName = messageNode.getSender();
        int nameCharCount = replaceTagWithAA(name).length()+2; // swap out IM icons to make it easier to count. +2 because of ": " after name
        int chatNameCount = (chatName == null ? 0:chatName.length()+4); //+2 because of [] brackets
        int enCharCount = nameCharCount + chatNameCount + 8; //+8 because timestamp is probably on
        double enWidth = LangCodeSelectableList.ENGLISH.getChatBoxCharWidth(); //width of 1 en character
        double foreignWidth = plugin.getConfig().getSelectedLanguage().getChatBoxCharWidth(); //width of 1 <img=> character
        int chatWidth = 485;
        int width = chatWidth - (int) (enCharCount*enWidth+2); //-2 just to be safe

        String regex = "(<img=\\d+>)|.";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(str);

        StringBuilder stringBuilder = new StringBuilder();
        double wLeft = width;
        while(matcher.find()){
            String c = matcher.group();
            if (c.matches("<img=\\d+>"))
                wLeft -= foreignWidth;
            else
                wLeft -= enWidth;
            if (wLeft - foreignWidth < 0){
                wLeft = width;
                stringBuilder.append("<br>");
                stringBuilder.append(c);
            } else {
                stringBuilder.append(c);
            }
        }
        return stringBuilder.toString();
    }

    private String replaceTagWithAA (String string){ //"<img=41>sand in sand" into "11sand in sand" for easy counting
        return string.replaceAll("<img=(\\d+)>","AA");
    }

    // called every game tick, until the pendingChatMessages is empty
    // pending messages will be removed from set if they are not translated within 30 seconds
    public void handlePendingChatMessages() {
        if(pendingChatMessages.isEmpty())
            return;

        long currentTime = System.currentTimeMillis();
        Set<Pair<ChatMessage, Long>> toRemove = new HashSet<>();
        for(Pair<ChatMessage, Long> pair : pendingChatMessages){

            if (pair.getRight() < currentTime) { // time out
                toRemove.add(pair);
                continue;
            }

            ChatMessage chatMessage = pair.getLeft();
            MessageNode node = chatMessage.getMessageNode();
            String message = chatMessage.getMessage();

            String translation = plugin.getDeepl().translate(message, LangCodeSelectableList.ENGLISH, config.getSelectedLanguage());

            // if the translation is the same as the original message, don't replace
            if(translation.equals(message)){
                continue;
            }

            Transformer transformer = new Transformer(plugin);
            Colors textColor = chatColorManager.getMessageColor();
            String textToDisplay = transformer.stringToDisplayedString(translation, textColor);

            replaceChatMessage(textToDisplay, node);
            addMsgToSidePanel(chatMessage, translation);
            toRemove.add(pair);
        }
        for (Pair<ChatMessage, Long> pair : toRemove) {
            pendingChatMessages.remove(pair);
        }
    }
}

package com.RuneLingual.ChatMessages;


import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;

import javax.inject.Inject;

@Slf4j
public class ChatColorManager {
    @Inject
    private Client client;
    @Inject
    private RuneLingualPlugin plugin;
    @Getter
    private Colors messageColor = Colors.black;

    @Inject
    public ChatColorManager(RuneLingualPlugin plugin) {
        this.plugin = plugin;
        this.client = plugin.getClient();
    }



    public void setMessageColor(ChatMessageType chatMessageType){
        int opaqueInt = 0;
        if (client.getVarbitValue(Varbits.TRANSPARENT_CHATBOX) == opaqueInt) {
            messageColor = getOpaqueBoxMessageColor(chatMessageType);
        } else {
            messageColor = getTransparentBoxMessageColor(chatMessageType);
        }
    }

    public Colors getOpaqueBoxMessageColor(ChatMessageType type) {
        int color;
        switch (type) {
            case PUBLICCHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_PUBLIC);
                break;
            case PRIVATECHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_PRIVATE);
                break;
            case AUTOTYPER:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_AUTO);
                break;
            case BROADCAST:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_BROADCAST);
                break;
            case FRIENDSCHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_FRIEND);
                break;
            case CLAN_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_CLAN);
                break;
            case CLAN_GUEST_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_GUEST_CLAN);
                break;
            case CLAN_MESSAGE:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_CLAN_BROADCAST);
                break;
            case CLAN_GIM_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_IRON_GROUP_CHAT);
                break;
            case CLAN_GIM_MESSAGE:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_IRON_GROUP_BROADCAST);
                break;
            case TRADE:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_TRADE_REQUEST);
                break;
            case CHALREQ_CLANCHAT:
            case CHALREQ_FRIENDSCHAT:
            case CHALREQ_TRADE:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_CHALLENGE_REQUEST);
                break;
            default:
                color = 0;
        }
        if(color==0)
            return Colors.black;
        color--;
        return Colors.getColorFromHex(Integer.toHexString(color));
    }

    private Colors getTransparentBoxMessageColor(ChatMessageType type) {
        int color;
        switch (type) {
            case PUBLICCHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_PUBLIC);
                break;
            case PRIVATECHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_PRIVATE);
                break;
            case AUTOTYPER:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_AUTO);
                break;
            case BROADCAST:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_BROADCAST);
                break;
            case FRIENDSCHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_FRIEND);
                break;
            case CLAN_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_CLAN);
                break;
            case CLAN_GUEST_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_GUEST_CLAN);
                break;
            case CLAN_MESSAGE:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_CLAN_BROADCAST);
                break;
            case CLAN_GIM_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_IRON_GROUP_CHAT);
                break;
            case CLAN_GIM_MESSAGE:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_IRON_GROUP_BROADCAST);
                break;
            case TRADE:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_TRADE_REQUEST);
                break;
            case CHALREQ_CLANCHAT:
            case CHALREQ_FRIENDSCHAT:
            case CHALREQ_TRADE:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_CHALLENGE_REQUEST);
                break;
            default:
                color = 0;
        }
        color--;
        return Colors.getColorFromHex(Integer.toHexString(color));
    }
}

package com.RuneLingual;

import com.RuneLingual.ApiTranslate.*;
import com.RuneLingual.ChatMessages.*;
import com.RuneLingual.MouseOverlays.MouseTooltipOverlay;
import com.RuneLingual.SQL.SqlActions;
import com.RuneLingual.SQL.SqlQuery;
import com.RuneLingual.Wigets.DialogTranslator;
import com.RuneLingual.Wigets.WidgetCapture;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.nonLatin.*;
import com.RuneLingual.prepareResources.H2Manager;
import com.google.inject.Provides;

import javax.annotation.Nullable;
import javax.inject.Inject;

import lombok.AccessLevel;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.callback.ClientThread;


import lombok.Getter;

import com.RuneLingual.SidePanelComponents.SidePanel;
import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.prepareResources.Downloader;
import com.RuneLingual.commonFunctions.Ids;
import okhttp3.OkHttpClient;


import java.awt.image.BufferedImage;
import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@PluginDescriptor(
        // Plugin name shown at plugin hub
        name = "RuneLingual",
        description = "All-in-one translation plugin for OSRS."
)

public class RuneLingualPlugin extends Plugin {
    @Inject
    @Getter
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ClientToolbar clientToolBar;
    @Inject
    @Getter
    private ChatIconManager chatIconManager;
    @Getter
    private HashMap<String, Integer> charIds = new HashMap<>();    // colour-char(key) <-> CharIds(val)

    @Inject
    @Getter
    private RuneLingualConfig config;
    @Inject
    private CharImageInit charImageInit;

    @Getter @Setter
    private LangCodeSelectableList targetLanguage;
    @Getter
    private String selectedLanguageName;


    // main modules
    @Inject
    @Getter
    private ChatCapture chatCapture;
    @Inject
    @Getter
    private MenuCapture menuCapture;


    @Inject
    @Getter
    private Downloader downloader;
    @Inject
    private H2Manager h2Manager;
    @Inject
    @Getter
    private SidePanel panel;
    private NavigationButton navButton;
    @Inject
    @Getter
    private GeneralFunctions generalFunctions;
    @Inject
    @Getter
    private FileNameAndPath fileNameAndPath = new FileNameAndPath();
    @Inject
    @Getter
    private SqlActions sqlActions;
    @Inject
    private SqlQuery sqlQuery;
    @Getter
    @Setter
    private String[] tsvFileNames;
    @Getter @Setter
    private String databaseUrl;
    @Getter
    @Setter
    private Connection conn;
    @Inject
    @Getter
    private Ids ids;
    @Inject
    private MouseTooltipOverlay mouseTooltipOverlay;
    @Inject
    @Getter
    private Deepl deepl;
    @Inject
    private DeeplUsageOverlay deeplUsageOverlay;
    @Inject
    @Getter
    private ChatInputRLingual chatInputRLingual;
    @Inject
    @Getter
    private ChatInputOverlay chatInputOverlay;
    @Inject
    private ChatInputCandidateOverlay chatInputCandidateOverlay;
    @Inject
    private OverheadCapture overheadCapture;
    @Inject
    private WidgetCapture widgetCapture;

    @Getter
    private TileObject interactedObject;
    @Getter
    private NPC interactedNpc;
    @Getter
    boolean attacked;
    private int clickTick;
    @Getter
    private int gameCycle;
    @Inject
    private OkHttpClient httpClient;

    // stores selected languages during this session, to prevent re-initializing char images
    private final Set<LangCodeSelectableList> pastLanguages = new HashSet<>();

    @Override
    protected void startUp() throws Exception {
        log.info("Starting...");
        //get selected language
        targetLanguage = config.getSelectedLanguage();
        pastLanguages.add(targetLanguage);
        databaseUrl = h2Manager.getUrl(targetLanguage);
        // check if online files have changed, if so download and update local files
        initLangFiles();

        //connect to database
        conn = h2Manager.getConn(targetLanguage);

        // initiate overlays
        overlayManager.add(mouseTooltipOverlay);
        overlayManager.add(deeplUsageOverlay);
        overlayManager.add(chatInputOverlay);
        overlayManager.add(chatInputCandidateOverlay);

        // load image files
        charImageInit.loadCharImages();

        // side panel
        startPanel();

        log.info("RuneLingual started!");
    }

    @Subscribe
    public void onOverheadTextChanged(OverheadTextChanged event) throws Exception {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        overheadCapture.translateOverhead(event);
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        //log.info("Widget loaded:" + event.getGroupId());
//		clientThread.invokeLater(() -> {
//			widgetCapture.translateWidget();
//		});
    }

    @Subscribe
    private void onBeforeRender(BeforeRender event) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }

        chatInputRLingual.updateChatInput();


        //clientThread.invokeLater(() -> {
        widgetCapture.translateWidget();
        //});

    }

    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }

        menuCapture.handleOpenedMenu(event);
    }


    @Subscribe
    public void onChatMessage(ChatMessage event) throws Exception {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        if (client.getGameState() != GameState.LOGGED_IN && client.getGameState() != GameState.HOPPING) {
            return;
        }
        chatCapture.handleChatMessage(event);

    }


    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        if (gameStateChanged.getGameState() == GameState.LOADING) {
            deepl.setUsageAndLimit();
            interactedObject = null;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(RuneLingualConfig.GROUP))
        {
            return;
        }
        // if language is changed
        if (targetLanguage != config.getSelectedLanguage()) {
            targetLanguage = config.getSelectedLanguage();

            if (targetLanguage != LangCodeSelectableList.ENGLISH) {
                //close current connection
                h2Manager.closeConn();
            }

            if (targetLanguage == LangCodeSelectableList.ENGLISH) {
                clientToolBar.removeNavigation(navButton);
                return;
            }
            databaseUrl = h2Manager.getUrl(targetLanguage);
            initLangFiles();
            conn = h2Manager.getConn(targetLanguage);

            clientToolBar.removeNavigation(navButton);
            if (targetLanguage.needsCharImages() && !pastLanguages.contains(targetLanguage)) {
                charImageInit.loadCharImages();
            }

            overlayManager.remove(mouseTooltipOverlay);
            MouseTooltipOverlay.setAttemptedTranslation(new ArrayList<>());
            overlayManager.add(mouseTooltipOverlay);

            //reset deepl's past translations
            deepl = new Deepl(this, httpClient);

            restartPanel();
            pastLanguages.add(targetLanguage);
        }
        if(config.ApiConfig()){
            deepl.setUsageAndLimit();
            deepl.getTranslationAttempt().clear();
        }

    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned npcDespawned) {
        if (npcDespawned.getNpc() == interactedNpc) {
            interactedNpc = null;
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        if (client.getTickCount() > clickTick && client.getLocalDestinationLocation() == null) {
            // when the destination is reached, clear the interacting object
            interactedObject = null;
            interactedNpc = null;
        }

        if (client.isMenuOpen()) {
            menuCapture.handlePendingApiTranslation();
        }

        chatCapture.handlePendingChatMessages();
        overheadCapture.handlePendingOverheadTranslations();
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged interactingChanged) {
        if (interactingChanged.getSource() == client.getLocalPlayer()
                && client.getTickCount() > clickTick && interactingChanged.getTarget() != interactedNpc) {
            interactedNpc = null;
            attacked = interactingChanged.getTarget() != null && interactingChanged.getTarget().getCombatLevel() > 0;
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
        switch (menuOptionClicked.getMenuAction()) {
            case WIDGET_TARGET_ON_GAME_OBJECT:
            case GAME_OBJECT_FIRST_OPTION:
            case GAME_OBJECT_SECOND_OPTION:
            case GAME_OBJECT_THIRD_OPTION:
            case GAME_OBJECT_FOURTH_OPTION:
            case GAME_OBJECT_FIFTH_OPTION: {
                int x = menuOptionClicked.getParam0();
                int y = menuOptionClicked.getParam1();
                int id = menuOptionClicked.getId();
                interactedObject = findTileObject(x, y, id);
                interactedNpc = null;
                clickTick = client.getTickCount();
                gameCycle = client.getGameCycle();
                break;
            }
            case WIDGET_TARGET_ON_NPC:
            case NPC_FIRST_OPTION:
            case NPC_SECOND_OPTION:
            case NPC_THIRD_OPTION:
            case NPC_FOURTH_OPTION:
            case NPC_FIFTH_OPTION: {
                interactedObject = null;
                interactedNpc = menuOptionClicked.getMenuEntry().getNpc();
                attacked = menuOptionClicked.getMenuAction() == MenuAction.NPC_SECOND_OPTION ||
                        menuOptionClicked.getMenuAction() == MenuAction.WIDGET_TARGET_ON_NPC
                                && client.getSelectedWidget() != null
                                && WidgetUtil.componentToInterface(client.getSelectedWidget().getId()) == InterfaceID.SPELLBOOK;
                clickTick = client.getTickCount();
                gameCycle = client.getGameCycle();
                break;
            }
            // Any menu click which clears an interaction
            case WALK:
            case WIDGET_TARGET_ON_WIDGET:
            case WIDGET_TARGET_ON_GROUND_ITEM:
            case WIDGET_TARGET_ON_PLAYER:
            case GROUND_ITEM_FIRST_OPTION:
            case GROUND_ITEM_SECOND_OPTION:
            case GROUND_ITEM_THIRD_OPTION:
            case GROUND_ITEM_FOURTH_OPTION:
            case GROUND_ITEM_FIFTH_OPTION:
                interactedObject = null;
                interactedNpc = null;
                break;
            default:
                if (menuOptionClicked.isItemOp()) {
                    interactedObject = null;
                    interactedNpc = null;
                }
        }
    }

    @Override
    protected void shutDown() throws Exception {
        clientToolBar.removeNavigation(navButton);
        overlayManager.remove(mouseTooltipOverlay);
        overlayManager.remove(deeplUsageOverlay);
        overlayManager.remove(chatInputOverlay);
        overlayManager.remove(chatInputCandidateOverlay);
        h2Manager.closeConn();
        log.info("RuneLingual plugin stopped!");
    }


    @Provides
    RuneLingualConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(RuneLingualConfig.class);
    }

    private void initLangFiles() {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        //download necessary files
        downloader.setLangCode(targetLanguage.getLangCode());
        downloader.initDownloader();
    }

    public void restartPanel() {
        //update Language named folder (which is used to determine what language is selected)
        FileActions.deleteAllLangCodeNamedFile();
        FileActions.createLangCodeNamedFile(config.getSelectedLanguage());
        clientToolBar.removeNavigation(navButton);
        startPanel();
    }

    private void startPanel() {
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "globe.png");
        //panel.setTargetLanguage(config.getSelectedLanguage());
        panel = injector.getInstance(SidePanel.class);

        navButton = NavigationButton.builder()
                .tooltip("RuneLingual")
                .icon(icon)
                .priority(6)
                .panel(panel)
                .build();
        clientToolBar.addNavigation(navButton);
    }

    TileObject findTileObject(int x, int y, int id) {
        Scene scene = client.getScene();
        Tile[][][] tiles = scene.getTiles();
        Tile tile = tiles[client.getPlane()][x][y];
        if (tile != null) {
            for (GameObject gameObject : tile.getGameObjects()) {
                if (gameObject != null && gameObject.getId() == id) {
                    return gameObject;
                }
            }

            WallObject wallObject = tile.getWallObject();
            if (wallObject != null && wallObject.getId() == id) {
                return wallObject;
            }

            DecorativeObject decorativeObject = tile.getDecorativeObject();
            if (decorativeObject != null && decorativeObject.getId() == id) {
                return decorativeObject;
            }

            GroundObject groundObject = tile.getGroundObject();
            if (groundObject != null && groundObject.getId() == id) {
                return groundObject;
            }
        }
        return null;
    }

    @Nullable
    Actor getInteractedTarget() {
        return interactedNpc != null ? interactedNpc : client.getLocalPlayer().getInteracting();
    }

}


package com.RuneLingual.debug;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.SQL.SqlVariables;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class OutputToFile {
    public void menuTarget(String target, String subCategory, String source){
        if (Colors.countColorTagsAfterReformat(target) <= 1){
            target = Colors.removeColorTag(target);
        }
        target = Colors.enumerateColorsInColWord(target);
        writeToFile(target + "\t" + SqlVariables.nameInCategory.getValue() + "\t" + subCategory + "\t" + source, "menuTarget_debug.txt");
    }

    public void menuOption(String option, String subCategory, String source){
        if (Colors.countColorTagsAfterReformat(option) <= 1){
            option = Colors.removeColorTag(option);
        }
        option = Colors.enumerateColorsInColWord(option);
        writeToFile(option + "\t" + SqlVariables.actionsInCategory.getValue() + "\t" + subCategory + "\t" + source, "menuOption_debug.txt");
    }

    private void writeToFile(String str, String fileName){
        try {
            createDirectoryIfNotExists("output");
            Path filePath = Paths.get("output" + File.separator + fileName);
            createFileIfNotExists(filePath.toString());
            Files.write(filePath, (str + System.lineSeparator()).getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);
        } catch (IOException e) {
            log.error("Error writing to file.", e);
        }
    }

    public static void createFileIfNotExists(String fileName) {
        Path path = Paths.get(fileName);
        if (!Files.exists(path)) {
            try {
                Files.createFile(path);
            } catch (IOException e) {
            }
        }
    }

    public static void createDirectoryIfNotExists(String dirName) {
        Path path = Paths.get(dirName);
        if (!Files.exists(path)) {
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
            }
        }
    }
}

package com.RuneLingual.prepareResources;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.*;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;


@Slf4j
public class Downloader {//downloads translations and japanese char images to external file
    private static final File localBaseFolder = FileNameAndPath.getLocalBaseFolder();
    @Inject
    private RuneLingualPlugin plugin;
    @Getter
    private File localLangFolder;
    private String GITHUB_BASE_URL;
    @Setter
    @Getter
    private String langCode;
    @Inject
    private DataFormater dataFormater;


    @Inject
    public Downloader(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    // returns if char image changed
    public void initDownloader() {
        if (plugin.getConfig().getSelectedLanguage() == LangCodeSelectableList.ENGLISH) {
            return;
        }
        final List<String> extensions_to_download = Arrays.asList("tsv", "zip"); // will download all files with these extensions
        final List<String> file_name_to_download = List.of("char_" + langCode + ".zip",
                "latin2foreign_" + langCode + ".txt",
                "foreign2foreign_" + langCode + ".txt"); // will download all files with these names, no error if it doesnt exist
        localLangFolder = new File(localBaseFolder.getPath() + File.separator + langCode);
        plugin.getFileNameAndPath().setLocalLangFolder(localLangFolder.getPath());

        createDir(localLangFolder.getPath());
        String LOCAL_HASH_NAME = "hashListLocal_" + langCode + ".txt";
        String remote_sub_folder = "public"; //todo: this value is "draft" if reading from draft folder, "public" if reading from the public folder
        GITHUB_BASE_URL = "https://raw.githubusercontent.com/YS-jack/Runelingual-Transcripts/original-main/" +
                remote_sub_folder + "/" + langCode + "/"; //todo: replace the string after .com/ with the correct username

        String REMOTE_HASH_FILE = GITHUB_BASE_URL + "hashList_" + langCode + ".txt";

        try {
            Path dirPath = Paths.get(localBaseFolder.getPath());
            if (!Files.exists(dirPath)) {
                try {
                    // Attempt to create the directory
                    Files.createDirectories(dirPath);
                } catch (IOException e) {
                    log.error("Error creating directory", e);
                }
            }

            Map<String, String> localHashes = readHashFile(Paths.get(localLangFolder.getPath(), LOCAL_HASH_NAME));
            Map<String, String> remoteHashes = readHashFile(new URL(REMOTE_HASH_FILE));

            boolean dataChanged = false;
            boolean transcriptChanged = false;
            List<String> remoteTsvFileNames = new ArrayList<>(); // list of tsv files to include in the sql database


            for (Map.Entry<String, String> entry : remoteHashes.entrySet()) {
                String localHash = localHashes.get(entry.getKey());
                String remoteHash = entry.getValue();
                String remote_full_path = entry.getKey();
                //log.info("remote_full_path: " + remote_full_path);

                if ((localHash == null || !localHash.equals(remoteHash)) // if the file is not in the local hash file or the hash value is different
                        && (fileExtensionIncludedIn(remote_full_path, extensions_to_download) // and if the file extension is in the list of extensions to download
                        || same_file_included(remote_full_path, file_name_to_download))) { // or if the file name is in the list of file names to download

                    dataChanged = true;
                    downloadAndUpdateFile(remote_full_path);
                    if (fileExtensionIncludedIn(remote_full_path, List.of("zip"))) { // if its a zip file, unzip it
                        updateCharDir(Paths.get(localLangFolder.getPath(), "char_" + langCode + ".zip")); // currently only supports char images, which should suffice
                    } else {
                        transcriptChanged = true; // if the file is not a zip file, then one of the transcripts has changed
                    }
                }

                if (fileExtensionIncludedIn(remote_full_path, List.of("tsv"))) {
                    remoteTsvFileNames.add(remote_full_path);
                }
            }
            String[] tsvFileNames = remoteTsvFileNames.toArray(new String[0]);
            this.plugin.setTsvFileNames(tsvFileNames);

            if (dataChanged) {
                // Overwrite local hash file with the updated remote hash file
                Files.copy(new URL(REMOTE_HASH_FILE).openStream(), Paths.get(localLangFolder.getPath(), LOCAL_HASH_NAME), StandardCopyOption.REPLACE_EXISTING);
                if (transcriptChanged) {
                    dataFormater.updateSqlFromTsv(localLangFolder.getPath(), tsvFileNames);
                }
            } else {
                log.info("All files are up to date.");
            }
        } catch (IOException e) {
            log.error("An error occurred: {}", e.getMessage(), e);
        }
    }

    private void createDir(String path) {
        Path dirPath = Paths.get(path);
        if (!Files.exists(dirPath)) {
            try {
                // Attempt to create the directory
                Files.createDirectories(dirPath);
            } catch (IOException e) {
                log.error("Error creating directory", e);
            }
        }
    }

    private Boolean fileExtensionIncludedIn(String file_full_path, List<String> extensions) {
        String extension = get_file_extension(file_full_path);
        return extensions.contains(extension);
    }

    private String get_file_extension(String file_full_path) {
        String[] parts = file_full_path.split("\\.");
        return parts[parts.length - 1];
    }

    private Boolean same_file_included(String file_full_path, List<String> file_names) {
        Path fullPath = Paths.get(file_full_path);
        Path fileName = fullPath.getFileName();
        String fileNameString = fileName.toString();
        return file_names.contains(fileNameString);
    }

    private Map<String, String> readHashFile(Path filePath) throws IOException {
        Map<String, String> hashes = new HashMap<>();
        if (!Files.exists(filePath)) {
            Files.createFile(filePath);
        }
        try (BufferedReader reader = Files.newBufferedReader(filePath)) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("\\|");
                if (parts.length == 2) {
                    hashes.put(parts[0], parts[1]);
                }
            }
        }
        return hashes;
    }

    private Map<String, String> readHashFile(URL fileUrl) throws IOException {
        Map<String, String> hashes = new HashMap<>();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(fileUrl.openStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("\\|");
                if (parts.length == 2) {
                    hashes.put(parts[0], parts[1]);
                }
            }
        }
        return hashes;
    }

    private void downloadAndUpdateFile(String remoteFullPath) throws IOException {
        // filePath example: "draft\ja\actions_ja.xliff" this is the location of files relative to the GitHub repo root of RuneLite-Transcripts
        URL fileUrl = new URL(GITHUB_BASE_URL + remoteFullPath.replace("\\", "/"));
        Path localPath = Paths.get(localLangFolder.getPath(), remoteFullPath.replace("draft\\", ""));
        log.info("updating file " + localPath);


        // Check if the language directory exists, if not, create it
        if (Files.notExists(localPath.getParent())) {
            Files.createDirectories(localPath.getParent());
        }

        Files.copy(fileUrl.openStream(), localPath, StandardCopyOption.REPLACE_EXISTING);
    }

    public void updateCharDir(Path localPath) throws IOException {
        URL fileUrl3 = new URL(GITHUB_BASE_URL + "/char_" + langCode + ".zip");
        Files.copy(fileUrl3.openStream(), localPath, StandardCopyOption.REPLACE_EXISTING);
        unzip(String.valueOf(localPath), localLangFolder.getPath());
        Files.delete(localPath);
    }

    public void unzip(String zipFilePath, String destDir) {
        FileActions.deleteFolder(destDir + File.separator + "char_" + langCode);
        log.info("unzipping " + zipFilePath + " to " + destDir);
        File dir = new File(destDir);
        // create output directory if it doesn't exist
        if (!dir.exists()) dir.mkdirs();
        FileInputStream fis;
        //buffer for read and write data to file
        byte[] buffer = new byte[1024];
        try {
            fis = new FileInputStream(zipFilePath);
            ZipInputStream zis = new ZipInputStream(fis);
            ZipEntry ze = zis.getNextEntry();
            while (ze != null) {
                String fileName = ze.getName();
                File newFile = new File(destDir + File.separator + fileName);
                //create directories for sub directories in zip
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
                //close this ZipEntry
                zis.closeEntry();
                ze = zis.getNextEntry();
            }
            //close last ZipEntry
            zis.closeEntry();
            zis.close();
            fis.close();
        } catch (IOException e) {
            log.error("Error unzipping file", e);
        }
    }
}

package com.RuneLingual.prepareResources;

import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.SQL.SqlActions;
import com.RuneLingual.RuneLingualPlugin;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.HashMap;
import java.util.List;

@Slf4j
public class DataFormater {

    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    public DataFormater(RuneLingualPlugin plugin){
        this.plugin = plugin;
    }
    @Inject
    private SqlActions sqlActions;

    public void updateSqlFromTsv(String localLangFolder, String[] tsvFileNames){
        log.info("Updating SQL database from TSV files.");
        String SQLFilePath = localLangFolder + File.separator + FileNameAndPath.getLocalSQLFileName() + ".mv.db";
        String SQLFilePath2 = localLangFolder + File.separator + FileNameAndPath.getLocalSQLFileName() + ".trace.db";

        if (FileActions.fileExists(SQLFilePath)){
            FileActions.deleteFile(SQLFilePath);
        }
        if (FileActions.fileExists(SQLFilePath2)){
            FileActions.deleteFile(SQLFilePath2);
        }
        try {
            sqlActions.createTable();
            log.info("Table created.");
            sqlActions.tsvToSqlDatabase(tsvFileNames, localLangFolder);
        } catch (Exception e) {
            log.error("Error creating table.",e);
        }
    }

}

package com.RuneLingual.prepareResources;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;

@Slf4j
public class H2Manager {
    @Inject
    private RuneLingualPlugin plugin;

    public String getUrl(LangCodeSelectableList targetLanguage) {
        String databaseUrl = "jdbc:h2:" + FileNameAndPath.getLocalBaseFolder() + File.separator +
                targetLanguage.getLangCode() + File.separator + FileNameAndPath.getLocalSQLFileName();
        return databaseUrl;
    }

    public Connection getConn(LangCodeSelectableList targetLanguage) {
        Connection conn = null;
        String databaseUrl;

        databaseUrl = getUrl(targetLanguage);
        plugin.setDatabaseUrl(databaseUrl);
        try {
            conn = DriverManager.getConnection(databaseUrl);
        } catch (Exception e) {
            log.error("Error connecting to database: {}", databaseUrl, e);
            plugin.setTargetLanguage(LangCodeSelectableList.ENGLISH);
        }
        return conn;
    }

    public void closeConn() {
        try {
            if (plugin.getConn() != null) {
                plugin.getConn().close();
            }
        } catch (Exception e) {
            log.error("Error closing database connection.", e);
        }
    }
}

package com.RuneLingual.SidePanelComponents;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.net.URI;
import java.util.Map;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.SidePanelComponents.SearchSection;

@Slf4j

public class SidePanel extends PluginPanel{
    @Inject
    private RuneLingualPlugin plugin;

    String helpLink = RuneLingualConfig.helpLink;
    String titleText = "RuneLingual";
    String helpText = "Help with settings";
    String discordText = "Ask for help on Discord";
    @Getter
    ChatBoxSection chatBoxSection;

    @Inject
    private SidePanel(RuneLingualPlugin plugin){
        LangCodeSelectableList targetLanguage = FileActions.getLangCodeFromFile();
        translatePanelTexts(targetLanguage);

        this.setPreferredSize(new Dimension(200, 1500));
        this.add(createTitleLabel(titleText));
        this.add(createClickableLabel(helpText, helpLink));
        this.add(createClickableLabel(discordText, "https://discord.gg/ehwKcVdBGS"));
        this.add(new JSeparator());
        chatBoxSection = new ChatBoxSection(this, targetLanguage, plugin);
        SearchSection searchSection = new SearchSection(this, targetLanguage, plugin);
    }


    private void translatePanelTexts(LangCodeSelectableList targetLanguage) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            titleText = "RuneLingual";
            helpText = "Help with settings";
            discordText = "Ask for help on Discord";
        } /*else if (targetLanguage == LangCodeSelectableList.PORTUGUÊS_BRASILEIRO) {
            titleText = "RuneLíngual";
            helpText = "Ajuda nas configurações";
            discordText = "Peça ajuda no Discord";
        } else if (targetLanguage == LangCodeSelectableList.NORSK) {
            titleText = "RuneLingval";
            helpText = "Hjelp med innstillinger";
            discordText = "Be om hjelp på Discord";
        }*/else if (targetLanguage == LangCodeSelectableList.日本語) {
            titleText = "ルーンリンガル";
            helpText = "設定のヘルプ";
            discordText = "Discordでヘルプを求める";
        }
        // todo: add more languages as needed
    }

    private JLabel createTitleLabel(String title){
        JLabel label = new JLabel(title, SwingConstants.CENTER);
        label.setFont(new Font("MS Gothic", Font.BOLD, 18)); //todo: change the font if a language requires it
        label.setPreferredSize(new Dimension(200, 20));
        label.setForeground(Color.yellow);
        return label;
    }

    private JLabel createTextLabel(String text){
        JLabel label = new JLabel(text, SwingConstants.CENTER);
        label.setFont(new Font("MS Gothic", Font.PLAIN, 14));//todo: change the font if a language requires it
        label.setPreferredSize(new Dimension(200, 20));
        label.setForeground(Color.white);
        return label;
    }

    private JLabel createClickableLabel(String title, String url) {
        JLabel label = new JLabel(title, SwingConstants.CENTER);
        label.setFont(new Font("MS Gothic", Font.PLAIN, 14));//todo: change the font if a language requires it
        label.setPreferredSize(new Dimension(200, 20));
        label.setForeground(Color.white);

        label.addMouseListener(new MouseAdapter() {
               @Override
               public void mouseClicked(MouseEvent e) {
                   try {
                       Desktop.getDesktop().browse(new URI(url));
                   } catch (Exception ex) {
                       log.error("Error opening link", ex);
                   }
               }

            @Override
            public void mouseEntered(MouseEvent e) {
                label.setCursor(new Cursor(Cursor.HAND_CURSOR));
                Font font = label.getFont();
                Map attributes = font.getAttributes();
                attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
                label.setFont(font.deriveFont(attributes));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                Font font = label.getFont();
                Map attributes = font.getAttributes();
                attributes.put(TextAttribute.UNDERLINE, -1);
                label.setFont(font.deriveFont(attributes));
            }
        });

        return label;
    }
}

package com.RuneLingual.SidePanelComponents;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.util.Arrays;
import java.util.List;

@Slf4j
public class ChatBoxSection {
    private SidePanel sidePanel;
    @Getter
    private String tabNameGame = "Game";
    @Getter
    private String tabNamePublic = "Public";
    @Getter
    private String tabNameChannel = "Channel";
    @Getter
    private String tabNameClan = "Clan";
    @Getter
    private String tabNameGIM = "GIM";
    JTabbedPane tabbedPane = new JTabbedPane();

    public ChatBoxSection(SidePanel sideP, LangCodeSelectableList langList, RuneLingualPlugin plugin) {
        this.sidePanel = sideP;

        translateTabNames(langList);

        addTab(tabbedPane, tabNameGame);
        addTab(tabbedPane, tabNamePublic);
        addTab(tabbedPane, tabNameChannel);
        addTab(tabbedPane, tabNameClan);
        addTab(tabbedPane, tabNameGIM);

        sidePanel.add(tabbedPane);
        sidePanel.setSize(400, 500);
        sidePanel.setVisible(true);
    }

private static void addTab(JTabbedPane tabbedPane, String title) {
    JTextArea textArea = new JTextArea();
    textArea.setEditable(false); // This line makes the text uneditable
    textArea.setCursor(new Cursor(Cursor.TEXT_CURSOR)); // This line changes the cursor to the I-beam shape
    textArea.setSelectionColor(new Color(50,50,200)); // This line sets the background color of the selected text to black
    textArea.setSelectedTextColor(Color.WHITE); // This line sets the color of the selected text to white
    textArea.setLineWrap(true); // This line enables line wrapping

    JScrollPane scrollPane = new JScrollPane(textArea);
    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER); // This line disables horizontal scrolling

    tabbedPane.addTab(title, scrollPane);
    textArea.setBackground(new Color(30,30,30));
}

public void addSentenceToTab(String tabTitle, String sentence) {
    for (int i = 0; i < tabbedPane.getTabCount(); i++) {
        if (tabbedPane.getTitleAt(i).equals(tabTitle)) {
            JScrollPane scrollPane = (JScrollPane) tabbedPane.getComponentAt(i);
            JViewport viewport = scrollPane.getViewport();
            JTextArea textArea = (JTextArea) viewport.getView();
            if (textArea.getDocument().getLength() != 0) { // Check if the text area is not empty
                textArea.append("--------------------\n"); // Append a separator line
            }
            textArea.append(sentence + "\n");
            return;
        }
    }
    log.info("No tab found with title: " + tabTitle);
}


    private void translateTabNames(LangCodeSelectableList targetLanguage) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            tabNameGame = "Game";
            tabNamePublic = "Public";
            tabNameChannel = "Channel";
            tabNameClan = "Clan";
            tabNameGIM = "GIM";
        } /*else if (targetLanguage == LangCodeSelectableList.PORTUGUÊS_BRASILEIRO) {
            tabNameGame = "Jogo";
            tabNamePublic = "Público";
            tabNameChannel = "Canal";
            tabNameClan = "Clã";
            tabNameGIM = "GIM";
        } else if (targetLanguage == LangCodeSelectableList.NORSK) {
            tabNameGame = "Spill";
            tabNamePublic = "Offentlig";
            tabNameChannel = "Kanal";
            tabNameClan = "Klan";
            tabNameGIM = "GIM";
        } */else if (targetLanguage == LangCodeSelectableList.日本語) {
            tabNameGame = "ゲーム";
            tabNamePublic = "公共";
            tabNameChannel = "チャンネル";
            tabNameClan = "クラン";
            tabNameGIM = "GIM";
        }// todo: add more here as languages are added
    }
}

package com.RuneLingual.SidePanelComponents;


import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.SQL.*;
import com.RuneLingual.RuneLingualPlugin;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class SearchSection extends JPanel {
    private JTextField englishInput;
    private JTextField foreignInput;
    private JButton englishSearchButton;
    private JButton foreignSearchButton;
    private JList<String> englishResults;
    private JList<String> foreignResults;
    private SidePanel sidePanel;
    private DefaultTableModel tableModelEn;
    private JTable enTable;
    private DefaultTableModel tableModelForeign;
    private JTable foreignTable;
    private RuneLingualPlugin plugin;

    String textSearchEnglish = "Search English name";
    String textSearchForeign = "Search Foreign name";
    String textSearch = "Search";
    String textResult = "Result";
    String textType = "Type";

    public SearchSection(SidePanel sideP, LangCodeSelectableList langList, RuneLingualPlugin plugin){
        this.sidePanel = sideP;
        this.plugin = plugin;

        translatePanelTexts(langList);

        englishInput = new JTextField();
        englishInput.setSize(200, 25);
        foreignInput = new JTextField();
        foreignInput.setSize(200, 25);

        englishSearchButton = new JButton(textSearchEnglish);
        englishSearchButton.setBackground(Color.darkGray);
        englishSearchButton.setSize(200, 25);
        foreignSearchButton = new JButton(textSearchForeign);
        foreignSearchButton.setBackground(Color.darkGray);
        foreignSearchButton.setSize(200, 25);

        sidePanel.add(Box.createRigidArea(new Dimension(0, 10)));
        sidePanel.add(createTextLabel(textSearchEnglish));
        sidePanel.add(englishInput);
        sidePanel.add(englishSearchButton);
        sidePanel.add(Box.createRigidArea(new Dimension(0, 1)));
        enTable = addEnResultTable();
        tableModelEn = (DefaultTableModel) enTable.getModel();

        sidePanel.add(Box.createRigidArea(new Dimension(0, 10)));
        sidePanel.add(createTextLabel(textSearchForeign));
        sidePanel.add(foreignInput);
        sidePanel.add(foreignSearchButton);
        sidePanel.add(Box.createRigidArea(new Dimension(0, 10)));
        foreignTable = addForeignResultTable();
        tableModelForeign = (DefaultTableModel) foreignTable.getModel();


        englishSearchButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                removeAllRows(tableModelEn);
                String searchQuery = getExactMatchQuery(englishInput.getText(), SqlVariables.columnEnglish.getColumnName());
                String searchAlikeQuery = getAlikeQuery(englishInput.getText(), SqlVariables.columnEnglish.getColumnName());

                //log.info("Search Query: " + searchQuery);
                SqlActions sqlActions = new SqlActions(plugin);
                String[][] results = sqlActions.executeSearchQuery(searchQuery);
                String[][] resultsAlike = sqlActions.executeSearchQuery(searchAlikeQuery);
                //log.info("Results: " + results.length);
                for(String[] result : results){
                    tableModelEn.addRow(new String[]{result[0], result[1], result[2]});
                }
                for(String[] result : resultsAlike){
                    tableModelEn.addRow(new String[]{result[0], result[1], result[2]});
                }

                // adjust column width
                for (int i = 0; i < tableModelEn.getColumnCount(); i++) {
                    packColumn(enTable, i, 2);
                }
            }
        });

        foreignSearchButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                removeAllRows(tableModelForeign);
                String searchQuery = getExactMatchQuery(foreignInput.getText(), SqlVariables.columnTranslation.getColumnName());
                String searchAlikeQuery = getAlikeQuery(foreignInput.getText(), SqlVariables.columnTranslation.getColumnName());

                //log.info("Search Query: " + searchQuery);
                SqlActions sqlActions = new SqlActions(plugin);
                String[][] results = sqlActions.executeSearchQuery(searchQuery);
                String[][] resultsAlike = sqlActions.executeSearchQuery(searchAlikeQuery);
                //log.info("Results: " + results.length);
                for(String[] result : results){
                    tableModelForeign.addRow(new String[]{result[1], result[0], result[2]});
                }
                for(String[] result : resultsAlike){
                    tableModelForeign.addRow(new String[]{result[1], result[0], result[2]});
                }

                // adjust column width
                for (int i = 0; i < tableModelForeign.getColumnCount(); i++) {
                    packColumn(foreignTable, i, 2);
                }
            }
        });

        englishInput.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                englishSearchButton.doClick();
            }
        });

        foreignInput.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                foreignSearchButton.doClick();
            }
        });
    }

    private void translatePanelTexts(LangCodeSelectableList targetLanguage) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            textSearchEnglish = "Search with English name";
            textSearchForeign = "Search with Foreign name";
            textSearch = "Search";
            textResult = "Result";
            textType = "Type";
        } /*else if (targetLanguage == LangCodeSelectableList.PORTUGUÊS_BRASILEIRO) {
            textSearchEnglish = "Pesquisar com nome em inglês";
            textSearchForeign = "Pesquisar com nome estrangeiro";
            textSearch = "Pesquisa";
            textResult = "Resultado";
            textType = "Tipo";
        } else if (targetLanguage == LangCodeSelectableList.NORSK) {
            textSearchEnglish = "Søk med engelsk navn";
            textSearchForeign = "Søk med utenlandsk navn";
            textSearch = "Søk";
            textResult = "Resultat";
            textType = "Type";
        } */else if (targetLanguage == LangCodeSelectableList.日本語) {
            textSearchEnglish = "英語名で検索";
            textSearchForeign = "日本語名で検索";
            textSearch = "検索";
            textResult = "結果";
            textType = "タイプ";
        }// todo: add more languages as needed
    }

    private String getExactMatchQuery(String searchText, String searchColumnName) {
        return "SELECT " +
                SqlVariables.columnEnglish.getColumnName() + "," +
                SqlVariables.columnTranslation.getColumnName() + "," +
                SqlVariables.columnSubCategory.getColumnName() +
                " FROM " + SqlActions.tableName +
                " WHERE LOWER(" + searchColumnName + ")" +
                " = '" + searchText.toLowerCase().replace("'","''") + "'" +
                " AND " + SqlVariables.columnCategory.getColumnName() +
                " = '" + SqlVariables.nameInCategory.getValue() +"'";
    }

    private String getAlikeQuery(String searchText, String searchColumnName) {
        return "SELECT " +
                SqlVariables.columnEnglish.getColumnName() + "," +
                SqlVariables.columnTranslation.getColumnName() + "," +
                SqlVariables.columnSubCategory.getColumnName() +
                " FROM " + SqlActions.tableName +
                " WHERE LOWER(" + searchColumnName + ")" +
                " LIKE '%" + searchText.toLowerCase().replace("'","''") + "%'" +
                " AND " + SqlVariables.columnCategory.getColumnName() +
                " = '" + SqlVariables.nameInCategory.getValue() +"'";
    }

    private JTable addEnResultTable(){
        DefaultTableModel tableModelEn = new DefaultTableModel();
        JTable tableEn = new JTable(tableModelEn);
        tableEn.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        setTableColumn(tableModelEn);
        JScrollPane pane = new JScrollPane(tableEn, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); // Enable horizontal scrollbar
        pane.setPreferredSize(new Dimension(250, 250));
        this.sidePanel.add(pane);
        return tableEn;
    }

    private JTable addForeignResultTable(){
        DefaultTableModel tableModel = new DefaultTableModel();
        JTable table = new JTable(tableModel);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        setTableColumn(tableModel);
        JScrollPane pane = new JScrollPane(table, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); // Enable horizontal scrollbar
        pane.setPreferredSize(new Dimension(200, 250));
        this.sidePanel.add(pane);
        return table;
    }

    private void setTableColumn(DefaultTableModel table) {
        table.addColumn(textSearch);
        table.addColumn(textResult);
        table.addColumn(textType);
    }

    private void removeAllRows(DefaultTableModel tableModel) {
        while (tableModel.getRowCount() > 0) {
            tableModel.removeRow(0);
        }
    }

    public void packColumn(JTable table, int vColIndex, int margin) {
        DefaultTableColumnModel colModel = (DefaultTableColumnModel) table.getColumnModel();
        TableColumn col = colModel.getColumn(vColIndex);
        int width;

        // Get width of column header
        TableCellRenderer renderer = col.getHeaderRenderer();
        if (renderer == null) {
            renderer = table.getTableHeader().getDefaultRenderer();
        }
        Component comp = renderer.getTableCellRendererComponent(table, col.getHeaderValue(), false, false, 0, 0);
        width = comp.getPreferredSize().width;

        // Get maximum width of column data
        for (int r = 0; r < table.getRowCount(); r++) {
            renderer = table.getCellRenderer(r, vColIndex);
            comp = renderer.getTableCellRendererComponent(table, table.getValueAt(r, vColIndex), false, false, r, vColIndex);
            width = Math.max(width, comp.getPreferredSize().width);
        }

        // Add margin
        width += 2 * margin;

        // Set the width
        col.setPreferredWidth(width);
    }

    private JLabel createTextLabel(String text){
        JLabel label = new JLabel(text, SwingConstants.LEFT);
        label.setFont(new Font("MS Gothic", Font.PLAIN, 14));//todo: change the font if a language requires it
        label.setPreferredSize(new Dimension(200, 20));
        label.setForeground(Color.cyan);
        return label;
    }

}

package com.RuneLingual.nonLatin;

import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ChatIconManager;

import javax.inject.Inject;
import java.util.Arrays;
import java.util.HashMap;

@Slf4j
public class GeneralFunctions {
    @Inject
    private CharImageInit charImageInit;
    @Inject
    private RuneLingualPlugin runeLingualPlugin;


    public String StringToTags(String string, Colors colors) {
        /*
        This function takes a string + color and returns emojis that looks like letters
        But leave <img=??> tags as they are (they are already emojis)
        eg: こんにちは,<img=43>Lukyさん -> <img=43><img=1><img=2><img=3><img=4><img=5><img=6>

        order of conversion : String -> (for each char) -> char to codepoint -> get image name (eg: black--3021.png) ->
        -> get hash value of the char image from the hashmap
        -> get image Id in the chatIcon manager from the hash value
        -> create a tag with the image Id (eg: <img=1>)
        -> repeat to all characters in the string -> append all tags -> return
         */
        String pattern = "<img=[0-9]*>";
        String[] parts = string.split("(?=" + pattern + ")|(?<=" + pattern + ")");
        StringBuilder imgTagSb = new StringBuilder();
        for (String part : parts) {//check for img tags, such as the ironman icon
            if (part.matches(pattern)) {//if the part is an img tag, just append it
                imgTagSb.append(part);
                continue;
            }
            StringBuilder imgTagStrings = new StringBuilder();
            ChatIconManager chatIconManager = runeLingualPlugin.getChatIconManager();
            HashMap<String, Integer> map = runeLingualPlugin.getCharIds();
            for (int j = 0; j < part.length(); ) {//if the part is not an img tag, convert each letters to letter emojis

                int codePoint = part.codePointAt(j);
                if (Arrays.asList(32, 160, 8195, 8194, 8201, 8202, 8203, 12288).contains(codePoint)) {//if the char is a space, append a space
                    imgTagStrings.append(" ");
                    j += 1;
                    continue;
                }
                String imgName = colors.getName() + "--" + codePoint + ".png";
                int hash = map.getOrDefault(imgName, -99);
                if (hash == -99) {//if the char is not in the hashmap, append a question mark
                    imgTagStrings.append("?");
                    j += Character.isHighSurrogate(part.charAt(j)) ? 2 : 1;
                    log.error("Char not found in hashmap: {}", part.charAt(j));
                }
                imgTagStrings.append("<img=");
                imgTagStrings.append(chatIconManager.chatIconIndex(hash));
                imgTagStrings.append(">");
                j += Character.isHighSurrogate(part.charAt(j)) ? 2 : 1;

            }
            imgTagSb.append(imgTagStrings);
        }
        return imgTagSb.toString();
    }

}

package com.RuneLingual.nonLatin.Japanese;

import java.util.Comparator;
import com.RuneLingual.nonLatin.Japanese.Rom2hira.FourValues;

public class compareFV implements Comparator<FourValues> {
    public int compare(FourValues fv1, FourValues fv2) {
        return Integer.compare(fv1.getRank(), fv2.getRank());
    }
}

package com.RuneLingual.nonLatin.Japanese;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Pattern;

@Slf4j
public class Rom2hira {
    private HashMap<String,String> char2char = new HashMap<>();

    @Inject
    public Rom2hira() {
        String charDir = FileNameAndPath.getLocalBaseFolder() + "/" +
                LangCodeSelectableList.日本語.getLangCode() +
                "/latin2foreign_" + LangCodeSelectableList.日本語.getLangCode() + ".txt";
        putCharToHash(char2char, charDir);
    }

    private void putCharToHash(HashMap<String, String> hash, String dirName) {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader
                (new FileInputStream(dirName), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("\\|");
                if (parts.length == 2) {
                    hash.put(parts[0].trim().toLowerCase(), parts[1].trim());
                }
            }
        } catch (IOException e) {
            log.error("error creating hashmap for transform dict, for type : {}", dirName, e);
        }
    }


    @Setter @Getter
    public static class FourValues {
        private String written;
        private String read;
        private String type;
        private int rank;

        public FourValues(String value1, String value2, String value3, int value4) {
            this.written = value1;
            this.read = value2;
            this.type = value3;
            this.rank = value4;
        }
    }

    public String romToKat(String romMsg) {
        StringBuilder katBuilder = new StringBuilder();
        StringBuilder romBuilder = new StringBuilder();
        String pattern = "n[,.!?;:#$%&()'\\s\\d]$";
        String pattern2 = ".+n[,.!?;:#$%&()'\\s\\d]$";

        List<String> escapePattern = Arrays.asList("::",";;",";:",":;");// escape sequence for latin character input
        boolean escaping = false;

        for (int i = 0; i < romMsg.length(); i++) {
            String newChar = Character.toString(romMsg.charAt(i));
            if(!escaping) newChar = newChar.toLowerCase();
            romBuilder.append(newChar);
            String romBuffer = romBuilder.toString();
            int romBufferSize = romBuffer.length();
            String katCandidate;

            if (escaping) {
                katBuilder.append(romMsg.charAt(i));
                romBuilder.setLength(0);
                if(katBuilder.length() > 1 &&
                        escapePattern.contains(katBuilder.substring(katBuilder.length()-2))){
                    escaping = false;
                    katBuilder.delete(katBuilder.length()-2, katBuilder.length());
                    katBuilder.append(" ");
                    continue;
                } else {
                    continue;
                }
            }

            if (romBufferSize == 0)//something went wrong
                return "";
            if (romBufferSize == 1) {
                katCandidate = romBuffer;
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    katBuilder.append(ch);
                    romBuilder.setLength(0);
                    continue;
                }
                if (romBuffer.equals("n") && i == romMsg.length() - 1){
                    katBuilder.append("ん");
                    romBuilder.setLength(0);
                    continue;
                }
            } else if (romBufferSize == 2) {
                if(escapePattern.contains(romBuffer)){
                    romBuilder.setLength(0);
                    //katBuilder.deleteCharAt(katBuilder.length()-1);
                    katBuilder.append(" ");
                    escaping = true;
                    continue;
                }

                katCandidate = romBuffer;//eg: ka > カ
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    katBuilder.append(ch);
                    romBuilder.setLength(0);
                    continue;
                }
                katCandidate = romBuffer.substring(romBufferSize-1);
                if (char2char.containsKey(katCandidate)) {//eg:qe > qエ
                    String ch = char2char.get(katCandidate);
                    Character secToLast = romBuffer.charAt(0);
                    if (Pattern.matches(pattern, romBuffer)) //when n comes before a symbol or space, change it to ン
                        katBuilder.append("ん");
                    else
                        katBuilder.append(secToLast);//append q
                    katBuilder.append(ch); // append エ
                    romBuilder.setLength(0);
                    continue;
                }
                if (Pattern.matches(pattern, romBuffer)){//when n comes before a symbol or space, change it to ン
                    katBuilder.append("ん");
                    katBuilder.append(romBuffer.charAt(1));
                    romBuilder.setLength(0);
                    continue;
                }
            } else {//rombuffer size > 2
                if(escapePattern.contains(romBuffer.substring(romBufferSize-2))){
                    katBuilder.append(romBuffer,0,romBufferSize-2);
                    romBuilder.setLength(0);
                    escaping = true;
                    continue;
                }

                if (Pattern.matches(pattern2, romBuffer)){//when n comes before a symbol or space, change it to ン
                    katBuilder.append(romBuffer, 0, romBufferSize-2);
                    katBuilder.append("ん");
                    String lastChar = Character.toString(romBuffer.charAt(romBufferSize-1));
                    katBuilder.append(char2char.getOrDefault(lastChar, lastChar));
                    romBuilder.setLength(0);
                    continue;
                }
                katCandidate = romBuffer.substring(romBufferSize-3);
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    if (romBufferSize > 3) {
                        if (romBuffer.charAt(romBufferSize - 4)
                                == romBuffer.charAt(romBufferSize - 3)){ // eg: xwwhe > xッウェ
                            katBuilder.append(romBuffer,0,romBufferSize-4);//append x
                            katBuilder.append("っ");//append ッ
                            katBuilder.append(ch); // append ウェ
                            romBuilder.setLength(0);
                            continue;
                        }
                        if(romBuffer.charAt(romBufferSize - 4) == 'n'){// eg: xnwhe > xンウェ
                            katBuilder.append(romBuffer,0,romBufferSize-4);//append x
                            katBuilder.append("ん");//append ン
                            katBuilder.append(ch); // append ウェ
                            romBuilder.setLength(0);
                            continue;
                        }

                    }//eg:xxxwhe > xxxウェ
                    katBuilder.append(romBuffer, 0, romBufferSize-3);//append xxx
                    katBuilder.append(ch); // append ウェ
                    romBuilder.setLength(0);
                    continue;
                }
                katCandidate = romBuffer.substring(romBufferSize - 2);
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    if (romBuffer.charAt(romBufferSize - 3)
                            == romBuffer.charAt(romBufferSize - 2)){ // eg: xkka > xッカ
                        katBuilder.append(romBuffer,0,romBufferSize-3);//append x
                        katBuilder.append("っ");//append ッ
                        katBuilder.append(ch); // append ウェ
                        romBuilder.setLength(0);
                        continue;
                    }
                    if(romBuffer.charAt(romBufferSize - 3) == 'n'){// eg: xnka > xンカ
                        katBuilder.append(romBuffer,0,romBufferSize-3);//append x
                        katBuilder.append("ん");//append ン
                        katBuilder.append(ch); // append カ
                        romBuilder.setLength(0);
                        continue;
                    }
                    //eg: xxka > xxカ
                    katBuilder.append(romBuffer, 0, romBufferSize-2);//append xx
                    katBuilder.append(ch); //append カ
                    romBuilder.setLength(0);
                    continue;
                }
                katCandidate = romBuffer.substring(romBufferSize - 1);
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    katBuilder.append(romBuffer, 0, romBufferSize-1);//append
                    katBuilder.append(ch);
                    romBuilder.setLength(0);
                }
            }
        }
        katBuilder.append(romBuilder);
        return katBuilder.toString();
    }

}

package com.RuneLingual.nonLatin.Japanese;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.ChatMessages.PlayerMessage;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.nonLatin.Japanese.Rom2hira.FourValues;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class UpdateChatInputJa {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private PlayerMessage playerMessage;
    @Inject @Getter
    private Rom2hira rom2Hira;
    @Getter
    private int inputCount = 0; //for counting number of words in chat input
    @Getter
    private String chatJpMsg = "";//whats written for chat input overlay
    @Getter
    private List<String> kanjKatCandidates = new ArrayList<>();//candidates of kanji or katakana from input, also used for candidates overlay
    @Getter
    private int instCandidateSelection = -1;
    private List<FourValues> japCharDS = new ArrayList<>();//store all japanese words's written form, how its read, type, rank
    private List<String> prevHiraList = new ArrayList<>();//stores the last updated words that are displayed
    private List<String> prevJPList = new ArrayList<>();
    private HashMap<String,String> char2char = new HashMap<>();
    private String notAvailable = "nan";

    @Inject
    public UpdateChatInputJa(RuneLingualPlugin plugin) {
        this.plugin = plugin;
        String wordsDir = FileNameAndPath.getLocalBaseFolder() + "/" +
                LangCodeSelectableList.日本語.getLangCode() +
                "/foreign2foreign_" + LangCodeSelectableList.日本語.getLangCode() + ".txt";
        putWordToHash(wordsDir);
        log.info("created hashmap for transform dict, for type : " + wordsDir);
    }

    private void putWordToHash(String dirName) {
        /*
        * these files are in the format of "written,read,type,rank"
        * written is the kanji or katakana.
        * read is the hiragana.
        * type is the type of word, eg. noun, verb, adj, etc.
        * rank is the rank of the word, the smaller the number, the more common the word is.
        *
        * The file itself is downloaded by Downloader, so are not jar files
        * */
        try (BufferedReader reader = new BufferedReader(new InputStreamReader
                (new FileInputStream(dirName), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(",");
                if (parts.length == 4) {
                    FourValues fourValues = new FourValues(parts[0],parts[1],parts[2],Integer.parseInt(parts[3]));
                    japCharDS.add(fourValues);
                } else {
                    log.info("rom to jap.csv : not enough elements : "+parts.length);
                }
            }
        } catch (IOException e) {
            log.error("error creating hashmap for transform dict, for type : {}", dirName, e);
        }
    }

    public void updateInput() {
        if (playerMessage.getTranslationOption().equals(Transformer.TransformOption.AS_IS)) {
            return;
        }

        String inputmsg = playerMessage.getChatInputString();
        if (inputmsg.isBlank()){
            inputCount = 0;
            chatJpMsg = "";
            return;
        }

        inputCount = inputmsg.length();
        String newMsg = romJpTransform(inputmsg, true);
        if (newMsg != null && !newMsg.isEmpty())
            chatJpMsg = newMsg;
    }

    public String romJpTransform(String romMsg, boolean chatInput) {
        String hiraMsg = this.rom2Hira.romToKat(romMsg);
        return hira2Jp(hiraMsg, chatInput);
    }


    private String hira2Jp(String hiraMsg, boolean chatInput) {//hiragana list to kanji sentence
        String[] wordList = getWakatiGaki(hiraMsg);//get katakana text split with symbols, space attached at the end of each string if its katakana or numbers
        //eg of wordList : "強烈はぴはぴ閾値" "、," "凄く"  "!/" "だよ" "、" "kaka" "クェスト00" "やり" "33" "," "ましょう"
        List<String> wordListList = Arrays.asList(getWakatiGaki(hiraMsg));

        if (compareLists(wordListList, prevHiraList) && chatInput)
            return null;
        int startIndex = searchFirstDif(wordList);
        if (startIndex < 1)
            startIndex = 0;
        List<String> changedList = new ArrayList<>();
        boolean last;
        for (int i = startIndex; i < wordList.length; i++) {
            String word = wordList[i];
            if (word.matches("^\\d+$") || word.matches("^を+$")
                    || word.matches("[^\\p{IsHiragana}]+\\s*")){
                changedList.add(word);
                kanjKatCandidates.clear();
            }
            else {
                last = i == wordList.length - 1;
                Rom2hira.FourValues FVword = getMatch(word, last, chatInput);
                changedList.add(FVword.getWritten());
            }
        }
        List<String> sublistPrevJPList = prevJPList.subList(0, startIndex);
        String[] notChanged = sublistPrevJPList.toArray(new String[0]);
        ArrayList<String> combindedList = new ArrayList<>(Arrays.asList(notChanged));
        combindedList.addAll(changedList);

        prevHiraList = wordListList;
        prevJPList = combindedList;
        return String.join("",combindedList);
    }

    private Rom2hira.FourValues getMatch(String word, boolean last, boolean chatInput){//the last word in wordList
        Rom2hira.FourValues FVofWord = new Rom2hira.FourValues(word.trim().replaceAll("\\d",""),word.trim().replaceAll("\\d",""),notAvailable,-1);
        List<Rom2hira.FourValues> newCandidates = new ArrayList<>();
        newCandidates.add(FVofWord);
        if (word.matches("[\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+\\d+$") ||//if theres a number at the end of strings, set candidate to that
                word.matches("[\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+ +$")){// if theres 1 or more space, #space - 1 = candidateN
            //show no candidates
            int candidateSelectionN;
            String wordPart;
            if (word.matches("[\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+\\d+$")) {
                String intPart = word.split("\\D+")[1].trim();
                candidateSelectionN = Integer.parseInt(intPart);
                wordPart = word.split("\\d+\\s*$")[0];
            } else {
                String spacePart = word.split("[\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+")[1];
                candidateSelectionN = spacePart.length() - 1;
                wordPart = word.split(" +$")[0];
            }
            if (chatInput)
                kanjKatCandidates.clear();
            newCandidates.addAll(getCandidates(wordPart));

            if (newCandidates.size() -1< candidateSelectionN) //if the selection is too large, return the last cand
                candidateSelectionN = newCandidates.size() - 1;

            if (last) {
                if (chatInput)
                    instCandidateSelection = candidateSelectionN;
                for (Rom2hira.FourValues fv : newCandidates)
                    if (chatInput)
                        kanjKatCandidates.add(fv.getWritten());
            } else if (chatInput)
                instCandidateSelection = -1;
            return newCandidates.get(candidateSelectionN);

        } else { //no japanese + number nor space at the end, add it as hiragana if its not the last word, if last word then look for candidates
            if (last) {//if its the last word on wordList, update candidates shown by overlay
                if (chatInput)
                    instCandidateSelection = -1;
                newCandidates.addAll(getCandidates(word));
                if (chatInput)
                    kanjKatCandidates.clear();
                for (Rom2hira.FourValues fv : newCandidates)
                    if (chatInput)
                        kanjKatCandidates.add(fv.getWritten());
                if (chatInput)
                    instCandidateSelection = -1;
            }
            return FVofWord;
        }
    }
    private List<Rom2hira.FourValues> getCandidates(String word){
        List<Rom2hira.FourValues> matches;

        matches = getAllMatches(word, 50);//get all exact matches
        List<FourValues> newCandidates = new ArrayList<>(matches);

        if (newCandidates.size() < 30) {//if not many candidates, get matches that begin with the last wordPart
            // (the last wordPart might be in the middle of being typed
            matches = getAllBeginningWith(word,Math.min(30-10-newCandidates.size(),10));
            newCandidates.addAll(matches);
        }
        newCandidates.sort(new compareFV());
        if (newCandidates.size() < 40) {//if still not many candidates
            // (the last wordPart might be in the middle of being typed
            int nWordsToAdd = 40 - newCandidates.size();
            List<Rom2hira.FourValues> containedAndExtra;
            containedAndExtra = getAllContaining(word, nWordsToAdd); // get all words that is contained within "wordPart"
            newCandidates.addAll(containedAndExtra);
        }

        //add katakana candidate, as 3rd option if it has more than 1 kanji candidate, 2nd if no kanji candidate
        if (newCandidates.size() > 1) {
            String kata = hira2kata(word);
            Rom2hira.FourValues kataFV = new Rom2hira.FourValues(kata,kata,notAvailable,0);
            newCandidates.add(2,kataFV);
        } else {
            String kata = hira2kata(word);
            Rom2hira.FourValues kataFV = new Rom2hira.FourValues(kata,kata,notAvailable,0);
            newCandidates.add(0,kataFV);
        }
        return  newCandidates;
    }
    private int searchFirstDif(String[] wordList){
        int upTo = 0;
        if (wordList.length > prevHiraList.size())
            upTo = prevHiraList.size();
        else
            upTo = wordList.length;
        for (int i = 0; i < upTo; i++)
            if (!Objects.equals(wordList[i], prevHiraList.get(i)))
                return i;
        return (upTo == 0 ? 0 : upTo-1);
    }
    public static <T> boolean compareLists(List<T> list1, List<T> list2) {
        // If lists have different sizes, they are not equal
        if (list1.size() != list2.size()) {
            return false;
        }

        // Compare elements of the lists
        for (int i = 0; i < list1.size(); i++) {
            if (!list1.get(i).equals(list2.get(i))) {
                return false;
            }
        }

        // If all elements match, lists are equal
        return true;
    }
    private List<Rom2hira.FourValues> getAllMatches(String kata, int nToAdd) {
        List<Rom2hira.FourValues> matches = new ArrayList<>();
        int count = 0;
        for (Rom2hira.FourValues entry: japCharDS) {
            if (count > nToAdd)
                break;
            if (entry.getRead().equals(kata)){
                if (matches.isEmpty()) {
                    count++;
                    matches.add(entry);
                }
                else if (matches.get(matches.size() - 1).getRank() + 9 < entry.getRank()) {//dont add if the word is only different tense of the previous
                    count++;
                    matches.add(entry);
                }
            }
        }
        return matches;
    }
    private List<Rom2hira.FourValues> getAllBeginningWith(String kata, int nToAdd) {
        List<Rom2hira.FourValues> matches = new ArrayList<>();
        int count = 0;
        for (Rom2hira.FourValues entry: japCharDS) {
            if (count > nToAdd)
                break;
            if (entry.getRead().startsWith(kata) && !entry.getRead().equals(kata)) {
                count++;
                matches.add(entry);
            }
        }
        return matches;
    }
    private List<Rom2hira.FourValues> getAllContaining(String kata, int nToAdd) {//returns a substring 0:x that is in japCharDS, and add it to substring x:
        List<Rom2hira.FourValues> matches = new ArrayList<>();
        int count = 0;
        for (int i = kata.length() - 1; i >= 0 && count < nToAdd; i--) {
            String substring = kata.substring(0,i);
            for (int j = 0; j < japCharDS.size(); j++) {
                Rom2hira.FourValues entry = japCharDS.get(j);
                if (entry.getRead().equals(substring)) {
                    Rom2hira.FourValues addingFV = new Rom2hira.FourValues(entry.getWritten() + kata.substring(i),
                            entry.getWritten() + kata.substring(i), notAvailable, entry.getRank());
                    if (matches.isEmpty()) {
                        matches.add(addingFV);
                        count++;
                    } else if (matches.get(matches.size() - 1).getRank() + 3 < addingFV.getRank()) {//only add few of the word is only different tense of the previous
                        count++;
                        if (count > nToAdd)
                            break;
                        matches.add(addingFV);
                    }
                }
            }
        }
        return matches;
    }
    private String[] getWakatiGaki (String text) {
        // Regular expression pattern for splitting
        String regexPattern =
                "(を+)|" + "([^\\p{IsAlphabetic}]+[a-zA-Z]+)|" +
                        "([a-zA-Z]+[^\\p{IsAlphabetic}]+)|" +
                        "([\\p{IsHiragana}\\p{IsKatakana}ー]*\\d+)|" +
                        "([\\p{IsHiragana}\\p{IsKatakana}ー]+ +)|" +
                        "([\\p{IsHiragana}\\p{IsKatakana}ー]+)|"+
                        "(\\s*[\\d]+\\s*)|" +
                        "([^\\p{IsHiragana}\\p{IsKatakana}ー\\d ]+)";

        Pattern patternCompiled = Pattern.compile(regexPattern);
        Matcher matcher = patternCompiled.matcher(text);
        List<String> segmentsAndPunctuation = new ArrayList<>();

        // Find and collect all matches
        while (matcher.find()) {
            String segment = matcher.group(0);
            if (segment != null) {
                segmentsAndPunctuation.add(segment);
            }
        }


        // Convert the list to an array
        return segmentsAndPunctuation.toArray(new String[0]);
    }



    private String hira2kata(String hira) {
        StringBuilder kata = new StringBuilder();
        for (int i = 0; i < hira.length(); i++) {
            char c = hira.charAt(i);
            if (c >= 0x3041 && c <= 0x3096) {
                kata.append((char) (c + 0x60));
            } else {
                kata.append(c);
            }
        }
        return kata.toString();
    }

}

package com.RuneLingual.nonLatin;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FilenameFilter;
import java.util.HashMap;

import com.RuneLingual.prepareResources.Downloader;
import com.RuneLingual.RuneLingualPlugin;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ChatIconManager;

import javax.imageio.ImageIO;
import javax.inject.Inject;

@Slf4j
public class CharImageInit {
    @Inject
    RuneLingualPlugin runeLingualPlugin;

    /*
    * Load character images from the local folder, and register them to the chatIconManager
    * The images are downloaded from the RuneLingual transcript website, which is done in the Downloader class.
     */
    public void loadCharImages()
    {
        //if the target language doesn't need character images, return
        if(!runeLingualPlugin.getTargetLanguage().needsCharImages()){
            return;
        }

        ChatIconManager chatIconManager = runeLingualPlugin.getChatIconManager();
        HashMap<String, Integer> charIds = runeLingualPlugin.getCharIds();

        Downloader downloader = runeLingualPlugin.getDownloader();
        String langCode = downloader.getLangCode();
        final String pathToChar = downloader.getLocalLangFolder().toString() + File.separator + "char_" + langCode;

        String[] charNameArray = getCharList(pathToChar); //list of all characters e.g.　black--3021.png

        for (String imageName : charNameArray) {//register all character images to chatIconManager
            try {
                String fullPath = pathToChar + File.separator + imageName;
                File externalCharImg = new File(fullPath);
                final BufferedImage image = ImageIO.read(externalCharImg);

                final int charID = chatIconManager.registerChatIcon(image);
                charIds.put(imageName, charID);
            } catch (Exception e){log.error("error:",e);}
        }
        log.info("end of making character image hashmap");
    }


    public String[] getCharList(String pathToChar) {//get list of names of all characters of every colours)
        FilenameFilter pngFilter = new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.toLowerCase().endsWith(".png");
            }
        };
        File colorDir = new File(pathToChar + "/");
        File[] files = colorDir.listFiles(pngFilter); //list of files that end with ".png"

        if (files == null){return new String[]{};}

        String[] charImageNames = new String[files.length];
        for (int j = 0; j < files.length; j++) {
            charImageNames[j] = files[j].getName();
        }
        return charImageNames;
    }
}

package com.RuneLingual;

import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.commonFunctions.Transformer.TransformOption;
import com.RuneLingual.SQL.SqlVariables;
import com.RuneLingual.SQL.SqlQuery;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;

import javax.inject.Inject;

import lombok.Setter;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.tuple.Pair;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.regex.Pattern;

import com.RuneLingual.commonFunctions.Ids;
import com.RuneLingual.RuneLingualConfig.*;

@Slf4j
public class MenuCapture
{
	@Inject
	private Client client;
	@Inject
	private RuneLingualPlugin plugin;

	@Setter
	private boolean debugMessages = true;
	@Inject
	private Transformer transformer;
	@Getter // list of menu options currently being translated by api, periodically checked to see if they are done
	private Set<Pair<MenuEntry, PendingTranslationType>> pendingApiTranslation = new HashSet<>();

	private TransformOption menuOptionTransformOption = TransformOption.TRANSLATE_LOCAL;

	@Inject
	public MenuCapture(RuneLingualPlugin plugin) {
		this.plugin = plugin;
	}

	private final Colors optionColor = Colors.white;

	enum PendingTranslationType {
		OPTION,
		TARGET,
		BOTH
	}

	public void handleOpenedMenu(MenuOpened event){
		pendingApiTranslation.clear();
		MenuEntry[] menus = event.getMenuEntries();
		for (MenuEntry menu : menus) {
            handleMenuEvent(menu);
        }
	}

	public void handleMenuEvent(MenuEntry currentMenu) {
		// called whenever a right click menu is opened
		String[] newMenus = translateMenuAction(currentMenu);
		String newTarget = newMenus[0];
		String newOption = newMenus[1];

		// add to pending list if they haven't been translated yet

		boolean isPending = addPendingApiTranslation(currentMenu, newOption, newTarget);
		if (isPending) {
			return;
		}


		// reorder them if it is grammatically correct to do so in that language
		if(plugin.getTargetLanguage().needsSwapMenuOptionAndTarget()) {
			String temp = newOption;
			newOption = newTarget;
			newTarget = temp;
		}

		// swap out the translated menu action and target.
		if(newOption != null) {
			if (newTarget != null && !newTarget.isEmpty()) {
				currentMenu.setTarget(newTarget);
			} else {
				// if target is empty, remove the target part of the menu entry
				currentMenu.setTarget("");
			}
			currentMenu.setOption(newOption);
		}


	}

	public String[] translateMenuAction(MenuEntry currentMenu) {
		/*
		returns: String[] {newTarget, newOption}

		target and option examples
		option: Enable prayer reordering	target: <col=ff9040></col>
		option: Add-10<col=ff9040>		target: <col=ff9040>Pollnivneach teleport</col>
		 */
		MenuAction menuType = currentMenu.getType();

		String menuTarget = currentMenu.getTarget();  // eg. <col=ffff00>Sand Crab<col=ff00>  (level-15)     eg2. <col=ff9040>Dramen staff</col>
		String[] targetWordArray = Colors.getWordArray(menuTarget); // eg. ["Sand Crab", " (level-15)"]
		Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.white); // eg. [Colors.yellow, Colors.green]

		String menuOption = currentMenu.getOption(); // doesnt seem to have color tags, always white? eg. Attack
		String[] actionWordArray = Colors.getWordArray(menuOption); // eg. ["Attack"]
		Colors[] actionColorArray = Colors.getColorArray(menuOption, optionColor);



		menuOptionTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig());
		// for debug purposes
//		if(!isWalkOrCancel(menuType)){
//			//printMenuEntry(currentMenu);
//			if(!isNpcMenu(menuType) && !isObjectMenu(menuType)
//					&& !isItemOnGround(menuType) && !isItemInWidget(currentMenu) && !isPlayerMenu(menuType)){
//				//outputToFile.menuTarget(menuTarget,SqlVariables.menuInSubCategory.getValue(), "");
//				//outputToFile.menuOption(menuOption,SqlVariables.menuInSubCategory.getValue(), "");
//			}
//		}

		String[] result = new String[] {};
		// get translation for both target and option
		if(isWalkOrCancel(menuType)){
			result = translateWalkOrCancel(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray, targetColorArray);
		}
		else if (isPlayerMenu(menuType)){
			result = translatePlayer(menuOption, actionWordArray, actionColorArray, targetWordArray, targetColorArray);
		}
		else if(isNpcMenu(menuType)) { // need to split into npcs with and without level
			result = translateNpc(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray, targetColorArray);
		}
		else if(isObjectMenu(menuType)){
			result = translateObject(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray);
		}
		else if(isItemOnGround(menuType)){ // needs checking
			result = translateGroundItem(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray);
		}
		else if(isItemInWidget(currentMenu)){ // either in inventory or in equipment
			result = translateInventoryItem(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray);
		}
		else if(isWidgetOnSomething(menuType)){ // needs checking
			//printMenuEntry(currentMenu);
			Pair<String, String> results = convertWidgetOnSomething(currentMenu);
			String itemName = results.getLeft();
			String useOnX = results.getRight();
			String itemTranslation = translateInventoryItem(itemName, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(itemName))[0];
			String useOnXTranslation = "";
			if(menuType.equals(MenuAction.WIDGET_TARGET_ON_PLAYER)){
				useOnXTranslation = translatePlayerTargetPart(Colors.getWordArray(useOnX), Colors.getColorArray(useOnX, Colors.white));
			} else if(menuType.equals(MenuAction.WIDGET_TARGET_ON_NPC)){
				useOnXTranslation = translateNpc(useOnX, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(useOnX), Colors.getColorArray(useOnX, Colors.white))[0];
			} else if(menuType.equals(MenuAction.WIDGET_TARGET_ON_GAME_OBJECT)){
				useOnXTranslation = translateObject(useOnX, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(useOnX))[0];
			} else if(menuType.equals(MenuAction.WIDGET_TARGET_ON_WIDGET) || menuType.equals(MenuAction.WIDGET_TARGET_ON_GROUND_ITEM)){
				useOnXTranslation = translateGroundItem(useOnX, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(useOnX))[0];
			}
			String newTarget = itemTranslation + " -> " + useOnXTranslation;
			String newOption = translateInventoryItem(itemName, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(menuOption))[1];
			result = new String[]{newTarget, newOption};
		} else { // is a general menu
			//printMenuEntry(currentMenu);

			// for debug purposes
			//outputToFile.menuTarget(menuTarget,SqlVariables.menuInSubCategory.getValue(), source);
			//outputToFile.menuOption(menuOption,SqlVariables.menuInSubCategory.getValue(), source);
			result = translateGeneralMenu(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray, currentMenu);
		}

		// if the translation failed, return as is
		if (result.length < 2){
			return new String[]{menuTarget, menuOption};
		}

		String newTarget = result[0];
		String newOption = result[1];

		return new String[]{newTarget, newOption};
	}

	private String[] translateWalkOrCancel(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray, Colors[] targetColorArray){
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		String newOption, newTarget;
		actionSqlQuery.setEnglish(menuOption);
		actionSqlQuery.setCategory(SqlVariables.actionsInCategory.getValue());

		newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);

		if(Colors.removeColorTag(menuTarget).isEmpty()) {
			newTarget = "";
		} else {
			TransformOption menuTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig());
			if(hasLevel(menuTarget)){
				// if walk has a target with level, its a player
				newTarget = translatePlayerTargetPart(targetWordArray, targetColorArray);
			} else {
				// this shouldnt happen but just in case
				targetSqlQuery.setEnglish(targetWordArray[0]);
				targetSqlQuery.setCategory(SqlVariables.nameInCategory.getValue());
				targetSqlQuery.setSubCategory(SqlVariables.menuInSubCategory.getValue());
				// need to split into name and level if it has level
				newTarget = transformer.transform(targetWordArray, targetColorArray, menuTransformOption, targetSqlQuery, false);
			}
		}
		return new String[]{newTarget, newOption};
	}

	private String[] translatePlayer(String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray, Colors[] targetColorArray){
		//returns String[] {newTarget, newOption}
		//leave name as is (but replace to char image if needed)
		String newTarget = translatePlayerTargetPart(targetWordArray, targetColorArray);
		// set action as usual
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		actionSqlQuery.setPlayerActions(menuOption, Colors.white);
		String newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);
		return new String[] {newTarget, newOption};
	}

	private String[] translateNpc(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray, Colors[] targetColorArray) {
		String newTarget, newOption;
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		TransformOption npcTransformOption = getTransformOption(this.plugin.getConfig().getNPCNamesConfig());
		if(npcTransformOption.equals(TransformOption.AS_IS)){
			newTarget = menuTarget;
		} else if(hasLevel(menuTarget)){
			// if npc has a level, translate the name and level separately
			targetSqlQuery.setNpcName(targetWordArray[0], targetColorArray[0]);
			String targetName = transformer.transform(targetWordArray[0], targetColorArray[0], npcTransformOption, targetSqlQuery, false);
			String targetLevel = getLevelTranslation(targetWordArray[1], targetColorArray[1]);
			newTarget = targetName + targetLevel;
		} else {
			// if npc does not have a level, translate the name only
			targetSqlQuery.setNpcName(menuTarget, targetColorArray[0]);
			targetColorArray = Colors.getColorArray(menuTarget, targetColorArray[0]); //default color is not the same as initial definition
			newTarget = transformer.transform(targetWordArray, targetColorArray, npcTransformOption, targetSqlQuery, false);
		}

		actionSqlQuery.setNpcActions(menuOption, optionColor);
		newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);

		return new String[] {newTarget, newOption};
	}

	private String[] translateObject(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray) {
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		targetSqlQuery.setObjectName(menuTarget, Colors.lightblue);
		actionSqlQuery.setObjectActions(menuOption, optionColor);

		Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.lightblue); //default color is not the same as initial definition

		TransformOption	objectTransformOption = getTransformOption(this.plugin.getConfig().getObjectNamesConfig());

		String newTarget;
		if(objectTransformOption.equals(TransformOption.AS_IS)){
			newTarget = menuTarget;
		} else {
			newTarget = transformer.transform(targetWordArray, targetColorArray, objectTransformOption, targetSqlQuery, false);
		}
		String newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);

		return new String[] {newTarget, newOption};
	}

	private String[] translateGroundItem(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray){
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		targetSqlQuery.setItemName(menuTarget, Colors.orange);
		actionSqlQuery.setGroundItemActions(menuOption, optionColor);

		Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.orange); //default color is not the same as initial definition

		TransformOption itemTransformOption = getTransformOption(this.plugin.getConfig().getItemNamesConfig());
		String newTarget;
		if (itemTransformOption.equals(TransformOption.AS_IS)){
			newTarget = menuTarget;
		} else {
			newTarget = transformer.transform(targetWordArray, targetColorArray, itemTransformOption, targetSqlQuery, false);
		}
		String newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);
		return new String[] {newTarget, newOption};
	}

	private String[] translateInventoryItem(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray){
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);

		targetSqlQuery.setItemName(menuTarget, Colors.orange);
		actionSqlQuery.setInventoryItemActions(menuOption, optionColor);

		Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.orange); //default color is not the same as initial definition

		TransformOption itemTransformOption = getTransformOption(this.plugin.getConfig().getItemNamesConfig());
		String newTarget = transformer.transform(targetWordArray, targetColorArray, itemTransformOption, targetSqlQuery, false);
		String newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);
		return new String[] {newTarget, newOption};
	}

	private String[] translateGeneralMenu(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray, MenuEntry currentMenu){
		String newTarget, newOption;
		// check what widget it is in, then set the source column value accordingly
		String source;
		if(plugin.getConfig().getMenuOptionConfig().equals(ingameTranslationConfig.USE_API) && plugin.getConfig().ApiConfig()){
			source = "";
		} else {
			source = getSourceNameFromMenu(currentMenu);
		}

		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		actionSqlQuery.setMenuAcitons(menuOption, optionColor);
		actionSqlQuery.setSource(source);

		newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);

		if(Colors.removeColorTag(menuTarget).isEmpty()) { // if it doesnt have a target
			newTarget = "";
		} else {
			// if it is in the quest tab, the values are in a different category/sub_category
			if(source.equals(SqlVariables.questListTabInSource.getValue())) {
				menuTarget = translateQuestName(targetWordArray[0]);
				return new String[]{menuTarget, newOption};
			}
			SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
			targetSqlQuery.setEnglish(targetWordArray[0]);
			targetSqlQuery.setCategory(SqlVariables.nameInCategory.getValue());
			targetSqlQuery.setSubCategory(SqlVariables.menuInSubCategory.getValue());
			targetSqlQuery.setSource(source);

			TransformOption generalMenuTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig());
			Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.orange); //default color is not the same as initial definition
			newTarget = transformer.transform(targetWordArray, targetColorArray, generalMenuTransformOption, targetSqlQuery, false);
		}
		return new String[]{newTarget, newOption};
	}

	private String translateQuestName(String questName) {
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		targetSqlQuery.setEnglish(questName);
		targetSqlQuery.setCategory(SqlVariables.manualInCategory.getValue());
		targetSqlQuery.setSubCategory(SqlVariables.questInSubCategory.getValue());

		TransformOption generalMenuTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig());
		// color is not possible to obtain by simple means, so its just orange for now
		return transformer.transform(questName, Colors.orange, generalMenuTransformOption, targetSqlQuery, false);
	}

	private String translatePlayerTargetPart(String[] targetWordArray, Colors[] targetColorArray) {

		//leave name as is (but still give to transformer to replace to char image if needed)
		if(!targetWordArray[0].matches("^<img=.*>$")) { // doesn't have icons before their names
			String playerName = targetWordArray[0];
			String translatedName = transformer.transform(playerName, Colors.white, TransformOption.AS_IS, null, false);

			return translatedName + getLevelTranslation(targetWordArray[1], targetColorArray[1]);
		} else {
			// contains icons before their names, such as clan rank symbols
			StringBuilder newName = new StringBuilder();
			String levelString = "  (level-0)";
			for(int i = 0; i < targetWordArray.length; i++){
				if(i == targetWordArray.length - 1){ // the last element of targetWordArray is always the level part
					levelString = targetWordArray[i];
					break;
				}
				newName.append(targetWordArray[i]);
			}
			String translatedName = transformer.transform(newName.toString(), Colors.white, TransformOption.AS_IS, null, false);
			return translatedName + getLevelTranslation(levelString, targetColorArray[targetWordArray.length - 1]);
		}
	}

	private String getSourceNameFromMenu(MenuEntry menu){
		String source = "";
		Ids ids = this.plugin.getIds();
		if(isChildWidgetOf(ids.getCombatOptionParentWidgetId(), menu)){
			source = SqlVariables.combatOptionsTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getSkillsTabParentWidgetId(),menu)){
			source = SqlVariables.skillsTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getCharacterSummaryTabWidgetId(),menu)){
			source = SqlVariables.characterSummaryTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getQuestTabParentWidgetId(), menu)){
			source = SqlVariables.questListTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getAchievementDiaryTabParentWidgetId(),menu)){
			source = SqlVariables.achievementDiaryTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getInventoryTabParentWidgetId(),menu)){
			source = SqlVariables.inventTabInSource.getValue();
		}  else if(isChildWidgetOf(ids.getEquipmentTabParentWidgetId(),menu)){
			source = SqlVariables.wornEquipmentTabInSource.getValue();
		}else if(isChildWidgetOf(ids.getPrayerTabParentWidgetId(),menu)){
			source = SqlVariables.prayerTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getSpellBookTabParentWidgetId(), menu)){
			source = SqlVariables.spellBookTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getGroupsTabParentWidgetId(), menu)){
			source = SqlVariables.groupTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getFriendsTabParentWidgetId(), menu)){
			source = SqlVariables.friendsTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getIgnoreTabParentWidgetId(), menu)){
			source = SqlVariables.ignoreTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getAccountManagementTabParentWidgetId(), menu)){
			source = SqlVariables.accountManagementTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getSettingsTabParentWidgetId(), menu)){
			source = SqlVariables.settingsTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getLogoutTabParentWidgetId(), menu)){
			source = SqlVariables.logoutTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getWorldSwitcherTabParentWidgetId(), menu)) {
			source = SqlVariables.worldSwitcherTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getEmotesTabParentWidgetId(), menu)){
			source = SqlVariables.emotesTabInSource.getValue();
		} else if(isChildWidgetOf(ids.getMusicTabParentWidgetId(), menu)){
			source = SqlVariables.musicTabInSource.getValue();
		}
		//log.info("source: " + source);
		return source;
	}

	private String getLevelTranslation(String levelString, Colors color) {
		// translates combat level, such as "  (level-15)"
		SqlQuery levelQuery = new SqlQuery(this.plugin);
		String level = levelString.replaceAll("[^0-9]", "");
		levelQuery.setPlayerLevel();
		Transformer transformer = new Transformer(this.plugin);

		TransformOption option = getTransformOption(this.plugin.getConfig().getGameMessagesConfig());
	//TODO: colours may need adjusting for () and level's digits
		if(plugin.getConfig().getSelectedLanguage().needsCharImages()) // change color to simple color variants. eg: light green to green
			color = color.getSimpleColor();
		String levelTranslation = transformer.transform(levelQuery.getEnglish(), color, option, levelQuery, false);
		String openBracket = transformer.transform("(", color, TransformOption.AS_IS, null, false);
		String lvAndCloseBracket = transformer.transform(level+")", color, TransformOption.AS_IS, null, false);
		return "  " + color.getColorTag() + openBracket  + levelTranslation + color.getColorTag() + lvAndCloseBracket;
	}

	public static TransformOption getTransformOption(ingameTranslationConfig conf) {
		TransformOption transformOption;
		if(conf.equals(ingameTranslationConfig.USE_LOCAL_DATA)){
			transformOption = TransformOption.TRANSLATE_LOCAL;
		} else if(conf.equals(ingameTranslationConfig.DONT_TRANSLATE)){
			transformOption = TransformOption.AS_IS;
		} else if(conf.equals(ingameTranslationConfig.USE_API)){
			transformOption = TransformOption.TRANSLATE_API;
		} else {
			transformOption = TransformOption.TRANSLATE_LOCAL;
		}
		return transformOption;
	}

	private void printMenuEntry(MenuEntry menuEntry)
	{
		String target = menuEntry.getTarget();
		String option = menuEntry.getOption();
		MenuAction type = menuEntry.getType();
		log.info("option: " + option + ", target: " + target + ", type: " + type);
	}

	private Pair<String, String> convertWidgetOnSomething(MenuEntry entry)
	{
		String menuTarget = entry.getTarget();
		String[] parts = menuTarget.split(" -> ");
		String itemName = parts[0];
		String useOnName = parts[1];
		return Pair.of(itemName, useOnName);
	}

	private boolean hasLevel(String target)
	{
		// check if target contains <col=(numbers and alphabets)>(level-(*\d)). such as "<col=ffffff>Mama Layla<col=ffff00>(level-3000)"
		Pattern re = Pattern.compile(".+<col=[a-zA-Z0-9]+>\\s*\\(level-\\d+\\)");
		return re.matcher(target).find();
	}

	private boolean isWalkOrCancel(MenuAction action)
	{
		return ((action.equals(MenuAction.CANCEL))
				|| (action.equals(MenuAction.WALK)));
	}

	public boolean isGeneralMenu(MenuEntry menuEntry)
	{
		MenuAction action = menuEntry.getType();
		// checks if current action target is a menu that introduces general actions
		return  (!isItemInWidget(menuEntry) &&
					(action.equals(MenuAction.CC_OP)
						|| action.equals(MenuAction.CC_OP_LOW_PRIORITY)
						|| isWalkOrCancel(action)
						|| action.equals(MenuAction.RUNELITE_OVERLAY)
						|| action.equals(MenuAction.RUNELITE)
					)
		);
	}

	public boolean isObjectMenu(MenuAction action)
	{
		return ((action.equals(MenuAction.EXAMINE_OBJECT))
				|| (action.equals(MenuAction.GAME_OBJECT_FIRST_OPTION))
				|| (action.equals(MenuAction.GAME_OBJECT_SECOND_OPTION))
				|| (action.equals(MenuAction.GAME_OBJECT_THIRD_OPTION))
				|| (action.equals(MenuAction.GAME_OBJECT_FOURTH_OPTION))
				|| (action.equals(MenuAction.GAME_OBJECT_FIFTH_OPTION)));
	}
	public boolean isNpcMenu(MenuAction action)
	{
		return ((action.equals(MenuAction.EXAMINE_NPC))
				|| (action.equals(MenuAction.NPC_FIRST_OPTION))
				|| (action.equals(MenuAction.NPC_SECOND_OPTION))
				|| (action.equals(MenuAction.NPC_THIRD_OPTION))
				|| (action.equals(MenuAction.NPC_FOURTH_OPTION))
				|| (action.equals(MenuAction.NPC_FIFTH_OPTION)));
	}
	public boolean isItemOnGround(MenuAction action)
	{
		return ((action.equals(MenuAction.EXAMINE_ITEM_GROUND))
				|| (action.equals(MenuAction.GROUND_ITEM_FIRST_OPTION))
				|| (action.equals(MenuAction.GROUND_ITEM_SECOND_OPTION))
				|| (action.equals(MenuAction.GROUND_ITEM_THIRD_OPTION))
				|| (action.equals(MenuAction.GROUND_ITEM_FOURTH_OPTION))
				|| (action.equals(MenuAction.GROUND_ITEM_FIFTH_OPTION)));
	}
	public boolean isPlayerMenu(MenuAction action)
	{
		return ((action.equals(MenuAction.PLAYER_FIRST_OPTION))
				|| (action.equals(MenuAction.PLAYER_SECOND_OPTION))
				|| (action.equals(MenuAction.PLAYER_THIRD_OPTION))
				|| (action.equals(MenuAction.PLAYER_FOURTH_OPTION))
				|| (action.equals(MenuAction.PLAYER_FIFTH_OPTION))
				|| (action.equals(MenuAction.PLAYER_SIXTH_OPTION))
				|| (action.equals(MenuAction.PLAYER_SEVENTH_OPTION))
				|| (action.equals(MenuAction.PLAYER_EIGHTH_OPTION))
				|| (action.equals(MenuAction.RUNELITE_PLAYER)));
	}
	public boolean isWidgetOnSomething(MenuAction action)
	{
		return ((action.equals(MenuAction.WIDGET_TARGET_ON_WIDGET))
				|| (action.equals(MenuAction.WIDGET_TARGET_ON_GAME_OBJECT))
				|| (action.equals(MenuAction.WIDGET_TARGET_ON_NPC))
				|| (action.equals(MenuAction.WIDGET_TARGET_ON_GROUND_ITEM))
				|| (action.equals(MenuAction.WIDGET_TARGET_ON_PLAYER)));
	}

	public boolean isItemInWidget(MenuEntry menuEntry){
		MenuAction action = menuEntry.getType();
		String target = menuEntry.getTarget();
		target = Colors.removeColorTag(target);
		if(target.isEmpty()){
			return false;
		}

		SqlQuery sqlQuery = new SqlQuery(this.plugin);
		sqlQuery.setItemName(target, Colors.orange);


		return sqlQuery.getMatching(SqlVariables.columnEnglish, false).length > 0 &&
				(action.equals(MenuAction.CC_OP)
						|| action.equals(MenuAction.CC_OP_LOW_PRIORITY)
						|| action.equals(MenuAction.WIDGET_TARGET)
				);

	}

	private boolean isChildWidgetOf(int widgetIdToCheck, MenuEntry menuEntry){
		if(widgetIdToCheck == -1){
			return false;
		}
		Widget widget = client.getWidget(menuEntry.getParam1());

		while(widget != null){
			if(widget.getId() == widgetIdToCheck){
				return true;
			}
			widget = widget.getParent();
		}
		return false;
	}

	private boolean addPendingApiTranslation(MenuEntry currentMenu, String newOption, String newTarget) {
		if (!plugin.getConfig().ApiConfig()){
			return false;
		}
		PendingTranslationType pendingType = null;
		boolean isOptionPending = false;
		boolean isTargetPending = false;
		boolean updateTarget = true;
		boolean updateOption = true;
		if (plugin.getConfig().getMenuOptionConfig().equals(ingameTranslationConfig.USE_API)){
			if(!newOption.isEmpty() && !newOption.isBlank()) {
				String oldOption_colTag = currentMenu.getOption();
				String oldOption = Colors.removeColorTag(oldOption_colTag);
				newOption = Colors.removeColorTag(newOption);
				if ((oldOption.equals(newOption) && !oldOption.contains("<img="))// text didnt change after translation todo: need other way of telling if it has already been translated after other languages are added
				|| colWordHasMatchingWords(oldOption_colTag, newOption)){ // or when separating words by colors, if any of the words match
					isOptionPending = true;
					pendingType = PendingTranslationType.OPTION;
					updateOption = false;
				}
			}
		}
		String oldTarget_colTag = currentMenu.getTarget();
		String oldTarget = Colors.removeColorTag(oldTarget_colTag);
		newTarget = Colors.removeColorTag(newTarget);

		if(oldTarget.equals(newTarget) && !oldTarget.contains("<img=")// text didnt change after translation todo: same as above
				|| colWordHasMatchingWords(oldTarget_colTag, newTarget)){// or when separating words by colors, if any of the words match
			if(!newTarget.isEmpty() && !newTarget.isBlank()){
				isTargetPending = true;
				pendingType = PendingTranslationType.TARGET;
				updateTarget = false;
			}
		}
		if (updateOption){
			currentMenu.setOption(newOption);
		}
		if (updateTarget){
			currentMenu.setTarget(newTarget);
		}
		if (isOptionPending && isTargetPending){
			pendingType = PendingTranslationType.BOTH;
		}
		if (pendingType != null){
			pendingApiTranslation.add(Pair.of(currentMenu, pendingType));
		}

		return pendingType != null;
	}

	// check if any api translation is done
	// if it is, replace the menu entry with the translation
	public void handlePendingApiTranslation(){
		if (!plugin.getConfig().ApiConfig() ||
				pendingApiTranslation.isEmpty()){
			return;
		}
		Set<Pair<MenuEntry, PendingTranslationType>> toRemove = new HashSet<>();
        for (Pair<MenuEntry, PendingTranslationType> pair : pendingApiTranslation) {
			MenuEntry menu = pair.getLeft();
            PendingTranslationType type = pair.getRight();
			boolean remove = handlePendingMenu(menu, type);
			if (remove) {
				toRemove.add(pair);
			}
        }
		pendingApiTranslation.removeAll(toRemove);
	}

	// if the menu text contains multiple colors, it won't be updated with this function (need to reopen the menu)
	private boolean handlePendingMenu(MenuEntry menu, PendingTranslationType type){
		String[] newMenus = translateMenuAction(menu);
		String newTarget = newMenus[0];
		String newOption = newMenus[1];
		boolean remove = false;
		if (type.equals(PendingTranslationType.BOTH) && !newOption.equals(menu.getOption()) && !newTarget.equals(menu.getTarget())
		&& !colWordHasMatchingWords(menu.getOption(), newOption) && !colWordHasMatchingWords(menu.getTarget(), newTarget)){
			remove = true;
			menu.setOption(newOption);
			menu.setTarget(newTarget);
			swapOptionTarget(menu);
		} else if (type.equals(PendingTranslationType.OPTION) && !newOption.equals(menu.getOption())
				&& !colWordHasMatchingWords(menu.getOption(), newOption)){
			remove = true;
			menu.setOption(newOption);
			swapOptionTarget(menu);
		} else if (type.equals(PendingTranslationType.TARGET) && !newTarget.equals(menu.getTarget())
				&& !colWordHasMatchingWords(menu.getTarget(), newTarget)){
			remove = true;
			menu.setTarget(newTarget);
			swapOptionTarget(menu);
		}
		return remove;
	}

	private void swapOptionTarget(MenuEntry menu){
		String option = menu.getOption();
		String target = menu.getTarget();
		menu.setOption(target);
		menu.setTarget(option);
	}

	// check if any words in old text matches words in new text
	// eg: old text = <col=0>view<col=ff0000>Magic<col=0>Wiki
	// new text = <col=0>表示<col=ff0000>Magic<col=0>ウィキ
	// returns true because "Magic" is the same in both texts
	private boolean colWordHasMatchingWords(String oldText, String newText){
		String[] oldWords = Colors.getWordArray(oldText);
		for (String oldWord : oldWords) {
			if (newText.contains(oldWord)){
				return true;
			}
		}
		return false;
	}

}
package com.RuneLingual;

import lombok.Getter;

public enum TranslatingServiceSelectableList
{
    DeepL ("deepl"),
    DeepL_PRO ("deepl_pro"),;
//    GOOGLE_TRANSLATE ("google"),
//    OPENAI_GPT ("openai");

    @Getter
    private final String serviceName;

    TranslatingServiceSelectableList(String code){this.serviceName = code;}

    public String getService(){return this.serviceName;}
}

package com.RuneLingual;


import net.runelite.client.RuneLite;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.io.File;

@ConfigGroup(RuneLingualConfig.GROUP)
public interface RuneLingualConfig extends Config {
    final int offset_section1 = 0;
    public String helpLink = "https://github.com/YS-jack/RuneLingual-Plugin/blob/master/Readmes/Settings_select_lang.md";
    @ConfigSection(
            name = "Language selection",
            description = "Select language",
            position = offset_section1,
            closedByDefault = false
    )
    String SECTION_BASIC_SETTINGS = "basicSettings";
    final int offset = 5;
    String GROUP = "lingualConfig";
    @ConfigSection(
            name = "Dynamic translating",
            description = "Online translation options",
            position = 1 + offset,
            closedByDefault = false
    )
    String SECTION_CHAT_SETTINGS = "chatSettings";
    int offset_section2 = 20;
    @ConfigSection(
            name = "Game system text",
            description = "Options for game system texts",
            position = offset_section2,
            closedByDefault = false
    )
    String SECTION_GAME_SYSTEM_TEXT = "gameSystemText";
    final int offset_section3 = 40;
    @ConfigSection(
            name = "Others' Chat messages",
            description = "Options for chat messages",
            position = offset_section3,
            closedByDefault = false
    )
    String SECTION_CHAT_MESSAGES = "chatMessages";
    int offset_section4 = 60;
    @ConfigSection(
            name = "My Chat messages",
            description = "Options for chat messages",
            position = offset_section4,
            closedByDefault = false
    )
    String SECTION_MY_CHAT_MESSAGES = "myChatMessages";
    final int offset_section5 = 80;
    @ConfigSection(
            name = "Forceful Player Settings",
            description = "Options for specific players. This will take priority over other settings in this order",
            position = offset_section5,
            closedByDefault = false
    )
    String SECTION_SPECIFIC_PLAYER_SETTINGS = "specificPlayerSettings";

    @ConfigItem(
            name = "\uD83D\uDDE3\uD83D\uDCAC\uD83C\uDF10",
            description = "Select the language to be translated to",
            keyName = "targetLang",
            position = offset_section1,
            section = SECTION_BASIC_SETTINGS
    )
    default LangCodeSelectableList getSelectedLanguage() {
        return LangCodeSelectableList.ENGLISH;
    }

    @ConfigItem(
            name = "Help Link (right click to reset)",
            description = "right click to reset",
            position = 1 + offset_section1,
            keyName = "enableRuneLingual",
            section = SECTION_BASIC_SETTINGS
    )
    default String getHelpLink() {
        return helpLink;
    } // getHelpLink shouldnt be used anywhere, instead use helpLink

    @ConfigItem(
            name = "Enable Online Translation",
            description = "whether to translate using online services",
            section = SECTION_CHAT_SETTINGS,
            keyName = "enableAPI",
            position = 2 + offset
    )
    default boolean ApiConfig() {
        return false;
    }

    @ConfigItem(
            name = "Translating service",
            description = "Select your preferred translation service",
            section = SECTION_CHAT_SETTINGS,
            keyName = "translatingService",
            position = 3 + offset
    )
    default TranslatingServiceSelectableList getApiServiceConfig() {
        return TranslatingServiceSelectableList.DeepL;
    }

    @ConfigItem(
            name = "Service API Key",
            description = "Your API key for the chosen translating service",
            section = SECTION_CHAT_SETTINGS,
            keyName = "APIKey",
            position = 4 + offset,
            secret = true
            //hidden = true
    )
    default String getAPIKey() {
        return "";
    }

    @ConfigItem(
            name = "Enable Word Count Overlay",
            description = "whether to show how many characters you have used",
            section = SECTION_CHAT_SETTINGS,
            keyName = "enableUsageOverlay",
            position = 2 + offset
    )
    default boolean showUsageOverlayConfig() {
        return true;
    }

    @ConfigItem(
            name = "NPC Dialogue",
            description = "Option for NPC Dialogues",
            position = 1 + offset_section2,
            keyName = "npcDialogue",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getNpcDialogueConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Game Messages",
            description = "Option for game messages",
            position = 2 + offset_section2,
            keyName = "gameMessages",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getGameMessagesConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Item Names",
            description = "Option for item names",
            position = 4 + offset_section2,
            keyName = "itemNames",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getItemNamesConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "NPC Names",
            description = "Option for NPC names",
            position = 5 + offset_section2,
            keyName = "NPCNames",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getNPCNamesConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Object Names",
            description = "Option for object names",
            position = 6 + offset_section2,
            keyName = "objectNames",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getObjectNamesConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Interfaces",
            description = "Option for interface texts",
            position = 7 + offset_section2,
            keyName = "interfaceText",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getInterfaceTextConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    //not using this, makes configuration annoying
//	@ConfigItem(
//			name = "All Friends",
//			description = "Option that applies to all friends",
//			position = 2 + offset_section3,
//			keyName = "allFriends",
//			section = SECTION_CHAT_MESSAGES
//	)
//	default chatConfig getAllFriendsConfig() {return chatConfig.LEAVE_AS_IS;}

    @ConfigItem(
            name = "Mouse Menu Options",
            description = "Option for items, NPCs, objects, such as 'Use', 'Talk-to', etc.",
            position = 8 + offset_section2,
            keyName = "menuOption",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getMenuOptionConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Enable Mouse Hover Text",
            description = "Option to toggle mouse hover texts",
            position = 9 + offset_section2,
            keyName = "overheadText",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default boolean getMouseHoverConfig() {
        return true;
    }

    @ConfigItem(
            name = "Public",
            description = "Option for public chat messages",
            position = 3 + offset_section3,
            keyName = "publicChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getPublicChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "Clan",
            description = "Option for clan chat messages",
            position = 4 + offset_section3,
            keyName = "clanChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getClanChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "Guest Clan",
            description = "Option for guest clan chat messages",
            position = 5 + offset_section3,
            keyName = "guestClanChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getGuestClanChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "Friends Chat",
            description = "Option for friends chat messages",
            position = 6 + offset_section3,
            keyName = "friendsChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getFriendsChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "GIM Group",
            description = "Option for GIM group chat messages",
            position = 7 + offset_section3,
            keyName = "GIMChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getGIMChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "Me in Public",
            description = "Option for your own messages in Public chat",
            position = 1 + offset_section4,
            keyName = "myChatConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyPublicConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    @ConfigItem(
            name = "Me in Friends Chat",
            description = "Option for your own messages in Friends chat",
            position = 2 + offset_section4,
            keyName = "myFcConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyFcConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    @ConfigItem(
            name = "Me in Clan",
            description = "Option for your own messages in Clan chat",
            position = 3 + offset_section4,
            keyName = "myClanConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyClanConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    @ConfigItem(
            name = "Me in Guest Clan",
            description = "Option for your own messages in Guest Clan chat",
            position = 4 + offset_section4,
            keyName = "myGuestClanConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyGuestClanConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    @ConfigItem(
            name = "Me in GIM",
            description = "Option for your own messages in GIM chat",
            position = 5 + offset_section4,
            keyName = "myGimConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyGIMConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    String defaultText4ForcefulPlayerSettings = "enter player names here, separated by commas or new line";

    @ConfigItem(
            name = "Leave as is",
            description = "Specific players to not translate",
            position = 1 + offset_section5,
            keyName = "specificDontTranslate",
            section = SECTION_SPECIFIC_PLAYER_SETTINGS
    )
    default String getSpecificDontTranslate() {return defaultText4ForcefulPlayerSettings;}

    @ConfigItem(
            name = "Translate with APIs",
            description = "Specific players to translate using online translators",
            position = 2 + offset_section5,
            keyName = "specificApiTranslate",
            section = SECTION_SPECIFIC_PLAYER_SETTINGS
    )
    default String getSpecificApiTranslate() {
        return defaultText4ForcefulPlayerSettings;
    }

    @ConfigItem(
            name = "Transform",
            description = "Specific players to transform",
            position = 3 + offset_section5,
            keyName = "specificTransform",
            section = SECTION_SPECIFIC_PLAYER_SETTINGS
    )
    default String getSpecificTransform() {
        return defaultText4ForcefulPlayerSettings;
    }

    @ConfigItem(
            name = "Local file location",
            description = "Location of the files to be translated",
            keyName = "fileLocation",
            position = 200 + offset,
            secret = true
    )
    default String getFileLocation() {
        return RuneLite.RUNELITE_DIR.getPath() + File.separator + "RuneLingual_resources";
    }

    enum ingameTranslationConfig {
        USE_LOCAL_DATA,
        USE_API,
        //TRANSLITERATE, // not for now, need to prepare transliteration data for all languages
        DONT_TRANSLATE,
    }

    enum chatConfig {
        TRANSFORM, //eg: watasi ha inu ga suki -> 私は犬が好き
        USE_API, // eg: I like dogs -> 私は犬が好き
        LEAVE_AS_IS, // eg: I like dogs -> I like dogs
    }


    enum chatSelfConfig {
        TRANSFORM,
        LEAVE_AS_IS,
    }

}

package com.RuneLingual.ApiTranslate;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;
import java.awt.*;


public class DeeplUsageOverlay  extends Overlay {
    private Client client;
    private RuneLingualConfig config;
    private RuneLingualPlugin plugin;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    public DeeplUsageOverlay(Client client, RuneLingualPlugin plugin, RuneLingualConfig config) {
        setPosition(OverlayPosition.BOTTOM_RIGHT);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }
    /**
    * overlay for the number count by the DeepL API.
     * will show the number of characters translated by the DeepL API and the limit of the API.
     * if the API key is invalid, it will show a warning message.
     */
    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.showUsageOverlayConfig())
            return null;

        int enCharSize = LangCodeSelectableList.ENGLISH.getCharWidth();
        int foreignCharSize = config.getSelectedLanguage().getCharWidth();
        boolean deeplKeyValid = plugin.getDeepl().isKeyValid();
        String deeplCount = Long.toString(plugin.getDeepl().getDeeplCount());
        String deeplLimit = Long.toString(plugin.getDeepl().getDeeplLimit());

        Color bgColorCount = new Color(80, 148, 144);
        Color bgColorInvalid = new Color(194, 93, 93);
        panelComponent.getChildren().clear();
        int len;
        if (deeplKeyValid) {
            panelComponent.setBackgroundColor(bgColorCount);
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("DeepL:")
                    .right(deeplCount + " / " + deeplLimit)
                    .build());
            len = (deeplLimit.length()*2+10)*enCharSize;
        } else {
            panelComponent.setBackgroundColor(bgColorInvalid);
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("APIキーが無効です。APIキーが有効であることと\n上限に到達していないことを確認してください。")
                    .build());
            len = ("APIキーが無効です。APIキーが有効であることと".length()+2)*foreignCharSize;
        }//TODO: make it display in the configured language
        panelComponent.setPreferredSize(new Dimension(len,0));
        return panelComponent.render(graphics);
    }


}

package com.RuneLingual.ApiTranslate;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuEntry;

import javax.inject.Inject;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class PastTranslationManager {
    private final String pastTranslationFile;
    @Inject
    private Deepl deepl;
    private RuneLingualPlugin plugin;
    private Map<String, String> pastTranslations = new ConcurrentHashMap<>();


    @Inject
    public PastTranslationManager(Deepl deepl, RuneLingualPlugin plugin) {
        this.plugin = plugin;
        this.deepl = deepl;
        pastTranslationFile = FileNameAndPath.getLocalBaseFolder().getPath() + File.separator +
                plugin.getConfig().getSelectedLanguage().getLangCode() + File.separator + "pastTranslations.txt";
        setPastTranslationsFromFile();
    }

    public void setPastTranslationsFromFile() {
        // if pastTranslationFile exists, read from it
        if (FileActions.fileExists(pastTranslationFile)) {
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(
                    new FileInputStream(pastTranslationFile), StandardCharsets.UTF_8))) {
                // Skip BOM if present
                reader.mark(1);
                if (reader.read() != 0xFEFF) {
                    reader.reset();
                }

                String line;
                while ((line = reader.readLine()) != null) {
                    String[] parts = line.split("\\|");
                    if (parts.length == 2) {
                        String key = parts[0].trim();
                        String value = parts[1].trim();
                        pastTranslations.put(key, value);
                    }
                }

            } catch (IOException e) {
                log.error("Error reading file: " + e.getMessage(), e);
            }
        } else {
            // if pastTranslationFile doesn't exist, create an empty one
            try {
                Files.createFile(Paths.get(pastTranslationFile));
                log.info("Created empty file: " + pastTranslationFile);
            } catch (IOException e) {
                log.error("Error creating file: " + e.getMessage(), e);
            }
        }
    }

    /**
     * Get past translation from hashmap
     *
     * @param text the text to get past translation for
     * @return the past translation if it exists, null otherwise
     */
    public String getPastTranslation(String text) {
        return pastTranslations.getOrDefault(text, null);
    }

    public void addToPastTranslations(String text, String translation) {
        // add to the map
        pastTranslations.put(text, translation);

        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream(pastTranslationFile, true), StandardCharsets.UTF_8))) {
            String content = text + "|" + translation + "\n";
            writer.write(content);
            writer.flush(); // Ensure the content is written immediately
        } catch (IOException e) {
            log.error("Error writing to file: " + e.getMessage(), e);
        }
    }

    public boolean haveTranslatedMenuBefore(String option, String target, MenuEntry menuEntry) {
        String[] optionWordArray = Colors.getWordArray(option);
        String[] targetWordArray = Colors.getWordArray(target);

        // if option is set to be translated with API, check if all elements have been translated before
        if (plugin.getConfig().getMenuOptionConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)) {
            if (!checkAllElementExistInPastTranslation(optionWordArray)) {
                return false;
            }
        }

        // if target is item name and that is set to be translated with API,
        // check if all elements have been translated before
        if (plugin.getConfig().getItemNamesConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)
                && (plugin.getMenuCapture().isItemInWidget(menuEntry) || plugin.getMenuCapture().isItemOnGround(menuEntry.getType()))) {
            if (!checkAllElementExistInPastTranslation(targetWordArray)) {
                return false;
            }
        }

        // if target is object name, check if all elements have been translated before
        if (plugin.getConfig().getObjectNamesConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)
                && plugin.getMenuCapture().isObjectMenu(menuEntry.getType())) {
            if (!checkAllElementExistInPastTranslation(targetWordArray)) {
                return false;
            }
        }

        // if target is npc name, check if all elements have been translated before
        if (plugin.getConfig().getNPCNamesConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)
                && plugin.getMenuCapture().isNpcMenu(menuEntry.getType())) {
            if (!checkAllElementExistInPastTranslation(targetWordArray)) {
                return false;
            }
        }


        // if other target (general menu, walk here, player, etc) is set to be translated with API,
        // check if all elements have been translated before
        if (!target.isEmpty() &&
                plugin.getConfig().getMenuOptionConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)
                && !plugin.getMenuCapture().isItemInWidget(menuEntry)
                && !plugin.getMenuCapture().isItemOnGround(menuEntry.getType())
                && !plugin.getMenuCapture().isObjectMenu(menuEntry.getType())
                && !plugin.getMenuCapture().isNpcMenu(menuEntry.getType())) {
            if (!checkAllElementExistInPastTranslation(targetWordArray)) {
                return false;
            }
        }

        return true;
    }

    private boolean checkAllElementExistInPastTranslation(String[] wordArray) {
        for (String word : wordArray) {
            if (plugin.getDeepl().getDeeplPastTranslationManager().getPastTranslation(word) == null) {
                return false;
            }
        }
        return true;
    }
}

package com.RuneLingual.ApiTranslate;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.TranslatingServiceSelectableList;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.nonLatin.GeneralFunctions;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.*;
import org.json.JSONArray;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;

@Slf4j
public class Deepl {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private RuneLingualConfig config;
    @Inject
    private OkHttpClient httpClient;
    private String deeplKey;
    @Getter @Setter
    private int deeplLimit = 500000;
    @Getter @Setter
    private int deeplCount = deeplLimit;
    @Getter @Setter
    private boolean keyValid = true;

    @Getter @Setter
    private PastTranslationManager deeplPastTranslationManager;
    private static final MediaType mediaType = MediaType.parse("Content-Type: application/json");

    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    private final Object apiStateLock = new Object();
    private volatile int apiStateVersion = 0; // Tracks the current state version of the API

    // add texts that has already been attempted to be translated.
    // this avoids translating same texts multiple times when ran in a thread, which will waste limited or paid word count
    @Getter
    private List<String> translationAttempt = new ArrayList<>();

    @Inject
    public Deepl(RuneLingualPlugin plugin, OkHttpClient httpClient) {
        this.plugin = plugin;
        this.config = plugin.getConfig();
        this.httpClient = httpClient;
        //setUsageAndLimit();
        deeplKey = plugin.getConfig().getAPIKey();
        deeplPastTranslationManager = new PastTranslationManager(this, plugin);
    }

    /**
     * Translates the given text from the source language to the target language.
     * Sets deeplCount the number of characters translated using the API
     *
     * @param text the text to be translated
     * @param sourceLang the source language
     * @param targetLang the target language
     * @return the translated text if translated in the past, the original text if the translation fails or trying to translate
     */
    public String translate(String text, LangCodeSelectableList sourceLang, LangCodeSelectableList targetLang) {
        if(!plugin.getConfig().ApiConfig()){
            return text;
        }
        // if the text is already translated, return the past translation
        String pastTranslation = deeplPastTranslationManager.getPastTranslation(text);
        if (pastTranslation != null) {
            return pastTranslation;
        }

        // don't translate if text is empty, or has been attempted to translate
        if (text.isEmpty() || translationAttempt.contains(text)) {
            return text;
        }
        deeplKey = plugin.getConfig().getAPIKey();

        setUsageAndLimit();
        //if the character count is close to the limit, return the original text
        if(deeplCount > deeplLimit - text.length() - 1000){
            return text;
        }

        // from here, attempt to translate the text
        translationAttempt.add(text);


        String url = getTranslatorUrl();
        if(url.isEmpty()){// if selected service is not deepl, return as is
            return text;
        }

        JsonObject urlParameters = getUrlParameters(sourceLang, targetLang, text);

        getResponse(url, FormBody.create(mediaType, urlParameters.toString()), new ResponseCallback() {
            @Override
            public void onSuccess(String response) {
                setUsageAndLimit();
                String translation = getTranslationInResponse(response);
                if (!translation.isEmpty()) {
                    // add the new translation to the past translations and its file
                    deeplPastTranslationManager.addToPastTranslations(text, translation);
                    setKeyValid(true);
                    translationAttempt.remove(text);
                }

            }

            @Override
            public void onFailure(Exception error) {
                setKeyValid(false);
                handleError(error);
            }

            @Override
            public void onApiOff() {
                translationAttempt.remove(text);
            }
        });

        return text; // return original text while the translation is being processed in the thread
    }

    private JsonObject getUrlParameters(LangCodeSelectableList sourceLang, LangCodeSelectableList targetLang, String text) {
        String targetLangCode = targetLang.getDeeplLangCodeTarget();
        JsonArray jsonArray = new JsonArray();
        jsonArray.add(text);

        JsonObject jsonObject = new JsonObject();
        jsonObject.add("text", jsonArray);
        jsonObject.addProperty("target_lang", targetLangCode);
        jsonObject.addProperty("context", "runescape; dungeons and dragons; medieval fantasy;");
        jsonObject.addProperty("split_sentences", "nonewlines");
        jsonObject.addProperty("preserve_formatting", true);
        jsonObject.addProperty("formality", "prefer_less");
        jsonObject.addProperty("source_lang", "EN");

        return jsonObject;
    }

    private String getTranslatorUrl() {
        String baseUrl = getBaseUrl();
        if(baseUrl.isEmpty()){
            return "";
        }
        return baseUrl + "translate";
    }

    private String getUsageUrl() {
        String baseUrl = getBaseUrl();
        if(baseUrl.isEmpty()){
            return "";
        }
        return baseUrl + "usage";
    }

    private String getBaseUrl() {
        if (Objects.equals(config.getApiServiceConfig().getServiceName(), TranslatingServiceSelectableList.DeepL.getServiceName())) {
            return "https://api-free.deepl.com/v2/";
        } else if (Objects.equals(config.getApiServiceConfig().getServiceName(), TranslatingServiceSelectableList.DeepL_PRO.getServiceName())) {
            return "https://api.deepl.com/v2/";
        } else {
            return "";
        }
    }

    private void getResponse(String url, RequestBody requestBody, ResponseCallback callback) {
        getResponseWithRetry(url, requestBody, callback, 0);
    }

    private void getResponseWithRetry(String url, RequestBody requestBody, ResponseCallback callback, int retryCount) {
        final int currentVersion;
        synchronized (apiStateLock) {
            currentVersion = apiStateVersion; // Capture the current version
        }

        if (!plugin.getConfig().ApiConfig()) {
            callback.onApiOff();
            return;
        }

        if (deeplKey == null || deeplKey.isEmpty()) {
            callback.onFailure(new IOException("API key is missing"));
            return;
        }

        try {
            Request.Builder request = new Request.Builder()
                    .addHeader("User-Agent", RuneLite.USER_AGENT + " (runelingual)")
                    .addHeader("Authorization", "DeepL-Auth-Key " + deeplKey)
                    .addHeader("Accept", "application/json")
                    .addHeader("Content-Type", "application/json")
                    .addHeader("Content-Length", String.valueOf(requestBody.contentLength()))
                    .url(url)
                    .post(requestBody);

            httpClient.newCall(request.build()).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException error) {
                    synchronized (apiStateLock) {
                        if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                            //log.info("Discarding outdated failure callback due to API state change.");
                            return;
                        }
                    }
                    if (retryCount < 5) {
                        int delay = new Random().nextInt(8) + 3;
                        synchronized (apiStateLock) {
                            if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                                //log.info("Discarding outdated retry scheduling due to API state change.");
                                return;
                            }
                        }
                        //log.info("on failure: Retrying API request in {} seconds (attempt {})", delay, retryCount + 1);
                        scheduler.schedule(() -> {
                            synchronized (apiStateLock) {
                                if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                                    //log.info("Discarding outdated retry execution due to API state change.");
                                    return;
                                }
                            }
                            getResponseWithRetry(url, requestBody, callback, retryCount + 1);
                        }, delay, TimeUnit.SECONDS);
                    } else {
                        callback.onFailure(error);
                    }
                }

                @Override
                public void onResponse(Call call, Response response) {
                    synchronized (apiStateLock) {
                        if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                            //log.info("Discarding outdated response callback due to API state change.");
                            return;
                        }
                    }
                    try (ResponseBody responseBody = response.body()) {
                        if (responseBody != null) {
                            String responseBodyString = responseBody.string();
                            if (response.code() == 429) { // Too Many Requests
                                if (retryCount < 5) {
                                    int delay = new Random().nextInt(8) + 3;
                                    synchronized (apiStateLock) {
                                        if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                                            //log.info("Discarding outdated retry scheduling due to API state change.");
                                            return;
                                        }
                                    }
                                    //log.info("on response: Retrying API request in {} seconds (attempt {})", delay, retryCount + 1);
                                    scheduler.schedule(() -> {
                                        synchronized (apiStateLock) {
                                            if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                                                //log.info("Discarding outdated retry execution due to API state change.");
                                                return;
                                            }
                                        }
                                        getResponseWithRetry(url, requestBody, callback, retryCount + 1);
                                    }, delay, TimeUnit.SECONDS);
                                } else {
                                    callback.onFailure(new IOException("Too many requests"));
                                }
                            } else {
                                callback.onSuccess(responseBodyString);
                            }
                        } else {
                            callback.onFailure(new IOException("Response body is null"));
                        }
                    } catch (Exception error) {
                        callback.onFailure(error);
                    }
                }
            });
        } catch (Exception error) {
            log.error("Failed to create the API request", error);
            callback.onFailure(error);
        }
    }

    private void handleError(Exception error) {
        log.error("Failed to get response from DeepL API.", error);
    }


    public interface ResponseCallback {
        void onSuccess(String response);
        void onFailure(Exception error);
        void onApiOff();
    }

    private String getTranslationInResponse(String response) {
        JSONObject jsonObject = new JSONObject(response);
        if (jsonObject.has("translations")) {
            JSONArray translationsArray = jsonObject.getJSONArray("translations");
            if (!translationsArray.isEmpty()) {
                JSONObject translationObject = translationsArray.getJSONObject(0);
                return translationObject.getString("text");
            }
        }
        return "";
    }

    // function to set usage of the API
    public void setUsageAndLimit() {
        getResponse(getUsageUrl(), FormBody.create(mediaType, ""), new ResponseCallback() {
            @Override
            public void onSuccess(String usage) {
                if (usage.isEmpty()) {
                    return;
                }
                JSONObject jsonObject = new JSONObject(usage);
                deeplCount = jsonObject.getInt("character_count");
                deeplLimit = jsonObject.getInt("character_limit");
                //log.info("updated deepl count:" + deeplCount + "\nupdated deepl limit" + deeplLimit);
            }

            @Override
            public void onFailure(Exception error) {
                handleError(error);
            }

            @Override
            public void onApiOff() {
                //log.info("API is disabled");
            }
        });
    }
}

package com.RuneLingual.commonFunctions;

import java.io.File;
import java.io.IOException;
import java.util.List;

import com.RuneLingual.LangCodeSelectableList;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class FileActions {
    /*
    mainly for managing the file whose name includes the current selected language

    getLangCodeFromFile() - get the language code from the file name
    createLangCodeNamedFile() - create a file with the language code in the name
    deleteAllLangCodeNamedFile() - delete all files with the language code in the name

    these 3 functions should be used to manage the language named files.
     */
    static String fileNameStart = "setLang_";
    static String langNameFolder = FileNameAndPath.getLocalBaseFolder().toString();

    public static LangCodeSelectableList getLangCodeFromFile() {
        String existingFileName = getFileNameInFolderStartsWith(langNameFolder, fileNameStart);
        if (existingFileName != null){
            String langCode = existingFileName.substring(existingFileName.indexOf("_") + 1, existingFileName.indexOf("."));
            for (LangCodeSelectableList lang : LangCodeSelectableList.values()) {
                if (lang.getLangCode().equals(langCode)) {
                    return lang;
                }
            }
        }
        return LangCodeSelectableList.ENGLISH;
    }

    public static void createLangCodeNamedFile(LangCodeSelectableList lang) {
        String fileName = langNameFolder + File.separator + fileNameStart + lang.getLangCode() + ".txt";
        createFile(fileName);
    }

    public static void deleteAllLangCodeNamedFile() {
        for (LangCodeSelectableList lang : LangCodeSelectableList.values()) {
            String fileName = langNameFolder + File.separator + fileNameStart + lang.getLangCode() + ".txt";
            deleteFile(fileName);
        }
    }

    public static void createFile(String fileName) {
        try {
            File myObj = new File(fileName);
            if (myObj.createNewFile()) {
                log.info("File created: " + myObj.getName());
            } else {
                log.info("File already exists.");
            }
        } catch (IOException e) {
            log.error("error creating file", e);
        }
    }

    public static Boolean checkFileExists(String fileName) {
        File myObj = new File(fileName);
        return myObj.exists();
    }

    public static String getFileNameInFolderStartsWith(String path, String fileName) {
        File folder = new File(path);
        File[] listOfFiles = folder.listFiles();
        for (File file : listOfFiles) {
            if (file.isFile()) {
                if (file.getName().startsWith(fileName)) {
                    return file.getName();
                }
            }
        }
        return null;
    }

    public static List<String> getFileNamesWithExtension(String path, String extension){
        File folder = new File(path);
        File[] listOfFiles = folder.listFiles();
        List<String> matchedFileNames = null;
        for (File file : listOfFiles) {
            if (file.isFile()) {
                if (file.getName().endsWith(extension)) {
                    matchedFileNames.add(file.getName());
                }
            }
        }
        return matchedFileNames;
    }

    public static void deleteFile(String fileName) {
        File myObj = new File(fileName);
        if (myObj.delete()) {
            log.info("Deleted the file: " + myObj.getName());
        } else {
            log.info("Failed to delete the file.");
        }
    }

    public static boolean fileExists(String filename) {
        File myObj = new File(filename);
        return myObj.exists();
    }

    public static void deleteFolder(String folderPath) {
        File folder = new File(folderPath);
        File[] listOfFiles = folder.listFiles();
        if (listOfFiles != null) {
            for (File file : listOfFiles) {
                if (file.isFile()) {
                    file.delete();
                }
            }
        }
        folder.delete();
    }
}

package com.RuneLingual.commonFunctions;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.nonLatin.GeneralFunctions;
import com.RuneLingual.SQL.SqlVariables;
import com.RuneLingual.SQL.SqlQuery;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.util.List;

@Slf4j
public class Transformer {
    @Inject
    private RuneLingualPlugin plugin;

    private final Colors colorObj = Colors.blue;

    public enum TransformOption {
        AS_IS,
        TRANSLATE_LOCAL,
        TRANSLATE_API,
        TRANSLITERATE,
        TRANSFORM, // such as from alphabet to kanji, like neko -> 猫
    }

    @Inject
    public Transformer(RuneLingualPlugin plugin){
        this.plugin = plugin;
    }


    public String transformEngWithColor(TransformOption option, SqlQuery sqlQuery, boolean searchAlike){
        boolean needCharImage = plugin.getConfig().getSelectedLanguage().needsCharImages();
        GeneralFunctions generalFunctions = plugin.getGeneralFunctions();
        String text = sqlQuery.getEnglish();
        if(text == null || text.isEmpty()){
            return text;
        }

        String translatedText = "";

        if(option == TransformOption.AS_IS){
            translatedText = text;
        } else if(option == TransformOption.TRANSLATE_LOCAL){
        /*
        if there are 2 or more color tags in the sqlQuery.english, english and translation in the database will have color tag placeholders.
        must replace the color tags in sqlQuery.english with the color tag placeholders,
        and do the reverse for the obtained translation

        e.g.
        sqlQuery.english: <col=ff>text1<col=0>text2
        english in database: <colNum1>text1<colNum2>text2
        translation in database: <colNum2>translatedText2<colNum1>translatedText1
        final translation: <col=0>translatedText2<col=ff>translatedText1
         */
            List<String> colorTagsAsIs = Colors.getColorTagsAsIs(sqlQuery.getEnglish());
            int trueColorTagCount = Colors.countColorTagsAfterReformat(sqlQuery.getEnglish());
            for(int i = 0; i < colorTagsAsIs.size(); i++){
                sqlQuery.setEnglish(sqlQuery.getEnglish().replace(colorTagsAsIs.get(i), "<colNum" + i + ">")); // replace color tags with placeholders
            }

            String[] result = sqlQuery.getMatching(SqlVariables.columnTranslation, searchAlike);
            if(result.length == 0){
                //log.info("No translation found for " + text);
                //log.info("query = " + sqlQuery.getSearchQuery());
                return text;
                //translatedText = text;
            } else {
                if(result[0].isEmpty()) { // text exists in database but hasn't been translated yet
                    //translatedText = text;
                    //log.info("{} has not been translated yet", text);
                    return text;
                } else { // text has been translated
                    translatedText = convertFullWidthToHalfWidth(result[0]); // convert full width characters to half width
                    for(int i = 0; i < colorTagsAsIs.size(); i++){
                        translatedText = translatedText.replace("<colNum" + i + ">", colorTagsAsIs.get(i)); // replace placeholders with original color tags
                    }
                }
            }
            //translatedText = this.plugin.getTranscriptActions().getTranslation(text);
        } else if(option == TransformOption.TRANSLATE_API){ // wont have any colors
            translatedText = this.plugin.getDeepl().translate(Colors.removeAllTags(text),
                    LangCodeSelectableList.ENGLISH ,this.plugin.getConfig().getSelectedLanguage());
            if(translatedText.equals(text)){
                // if using api but the translation is the same as the original text, it's pending for translation
                return text;
            }
        } else if(option == TransformOption.TRANSLITERATE){
            //return
        }

        int colorTagCount = Colors.countColorTagsAfterReformat(translatedText);
        if(needCharImage) {
            // needs char image and has multiple colors
            String[] words = Colors.getWordArray(translatedText);
            Colors[] colorsArray = Colors.getColorArray(translatedText, sqlQuery.getColor());
            StringBuilder charImage = new StringBuilder();
            //log.info("words length = " + words.length + ", colorsArray length =" + colorsArray.length);
            for(int i = 0; i < words.length; i++){
                //log.info("words[" + i + "] = " + words[i] + ", colorsArray[" + i + "] = " + colorsArray[i]);
                charImage.append(generalFunctions.StringToTags(words[i], colorsArray[i]));
            }
            return charImage.toString();
        } else {// doesnt need char image and already has color tags
            return translatedText;
        }
    }

    public String transform(String text, Colors colors, TransformOption option, SqlQuery sqlQuery, boolean searchAlike){
        if(text == null || text.isEmpty()){
            return text;
        }

        String translatedText = "";

        if(option == TransformOption.AS_IS){
            return text;
        } else if(option == TransformOption.TRANSLATE_LOCAL){
            sqlQuery.setEnglish(text);

            String[] result = sqlQuery.getMatching(SqlVariables.columnTranslation, searchAlike);
            if(result.length == 0){
                //log.info("the following text doesn't exist in the English column :{}", text);
                //log.info("   query = {}", sqlQuery.getSearchQuery());
                // translatedText = text;
                return text;
            } else {
                if(result[0].isEmpty()) { // text exists in database but hasn't been translated yet
                    //translatedText = text;
                    //log.info("{} has not been translated yet", text);
                    return text;

                } else { // text has been translated
                    translatedText = convertFullWidthToHalfWidth(result[0]); // convert full width characters to half width
                }
            }
            //translatedText = this.plugin.getTranscriptActions().getTranslation(text);
        } else if(option == TransformOption.TRANSLATE_API){
            translatedText = this.plugin.getDeepl().translate(text,
                    LangCodeSelectableList.ENGLISH ,this.plugin.getConfig().getSelectedLanguage());
            if(translatedText.equals(text)){
                // if using api but the translation is the same as the original text, it's pending for translation
                return Colors.surroundWithColorTag(text,colors);
            }
        }
        return stringToDisplayedString(translatedText, colors);
    }

    /*
     * general idea:
     * 1. split into string array [name, level] and color array [color of name, color of level]
     * 2. translate name and level
     *    - if target language needs char image, after translating the string, use color and string to get char image
     *    - else translate the string, then combine each string with its color
     * 3. recombine into string
     */
    public String transform(String[] texts, Colors[] colors, TransformOption option, SqlQuery sqlQuery, boolean searchAlike){
        if(Colors.countColorTagsAfterReformat(sqlQuery.getEnglish()) > 1 && option != TransformOption.TRANSLATE_API){
            return transformEngWithColor(option, sqlQuery, searchAlike);
        }
        StringBuilder transformedTexts = new StringBuilder();
        for(int i = 0; i < texts.length; i++){
            transformedTexts.append(transform(texts[i], colors[i], option, sqlQuery, searchAlike));
        }
        return transformedTexts.toString();
    }

    public String transform(String[] texts, Colors[] colors, TransformOption option, SqlQuery[] sqlQueries, boolean searchAlike){
        StringBuilder transformedTexts = new StringBuilder();
        for(int i = 0; i < texts.length; i++){
            if(Colors.countColorTagsAfterReformat(sqlQueries[i].getEnglish()) > 1 && option != TransformOption.TRANSLATE_API){
                transformedTexts.append(transformEngWithColor(option, sqlQueries[i], searchAlike));
            } else {
                transformedTexts.append(transform(texts[i], colors[i], option, sqlQueries[i], searchAlike));
            }
        }
        return transformedTexts.toString();
    }

    public String transform(String[] texts, Colors[] colors, TransformOption[] options, SqlQuery[] sqlQueries, boolean searchAlike){
        StringBuilder transformedTexts = new StringBuilder();
        for(int i = 0; i < texts.length; i++){
            if(Colors.countColorTagsAfterReformat(sqlQueries[i].getEnglish()) > 1 && options[i] != TransformOption.TRANSLATE_API){
                transformedTexts.append(transformEngWithColor(options[i], sqlQueries[i], searchAlike));
            } else {
                transformedTexts.append(transform(texts[i], colors[i], options[i], sqlQueries[i], searchAlike));
            }
        }
        return transformedTexts.toString();
    }

    public String transform(String stringWithColors, TransformOption option, SqlQuery sqlQuery, Colors defaultColor, boolean searchAlike){
        String[] targetWordArray = Colors.getWordArray(stringWithColors); // eg. ["Sand Crab", " (level-15)"]
        Colors[] targetColorArray = Colors.getColorArray(stringWithColors, defaultColor); // eg. [Colors.white, Colors.red]

        return transform(targetWordArray, targetColorArray, option, sqlQuery, searchAlike);
    }

    public String transform(String stringWithColors, TransformOption option, SqlQuery[] sqlQueries, Colors defaultColor, boolean searchAlike){
        String[] targetWordArray = Colors.getWordArray(stringWithColors); // eg. ["Sand Crab", " (level-15)"]
        Colors[] targetColorArray = Colors.getColorArray(stringWithColors, defaultColor); // eg. [Colors.white, Colors.red]

        return transform(targetWordArray, targetColorArray, option, sqlQueries, searchAlike);
    }

    public String convertFullWidthToHalfWidth(String fullWidthStr) {
        String[][] fullWidthToHalfWidth = {
                {"０", "0"}, {"１", "1"}, {"２", "2"}, {"３", "3"}, {"４", "4"}, {"５", "5"}, {"６", "6"}, {"７", "7"}, {"８", "8"}, {"９", "9"},
                {"Ａ", "A"}, {"Ｂ", "B"}, {"Ｃ", "C"}, {"Ｄ", "D"}, {"Ｅ", "E"}, {"Ｆ", "F"}, {"Ｇ", "G"}, {"Ｈ", "H"}, {"Ｉ", "I"}, {"Ｊ", "J"},
                {"Ｋ", "K"}, {"Ｌ", "L"}, {"Ｍ", "M"}, {"Ｎ", "N"}, {"Ｏ", "O"}, {"Ｐ", "P"}, {"Ｑ", "Q"}, {"Ｒ", "R"}, {"Ｓ", "S"}, {"Ｔ", "T"},
                {"Ｕ", "U"}, {"Ｖ", "V"}, {"Ｗ", "W"}, {"Ｘ", "X"}, {"Ｙ", "Y"}, {"Ｚ", "Z"},
                {"ａ", "a"}, {"ｂ", "b"}, {"ｃ", "c"}, {"ｄ", "d"}, {"ｅ", "e"}, {"ｆ", "f"}, {"ｇ", "g"}, {"ｈ", "h"}, {"ｉ", "i"}, {"ｊ", "j"},
                {"ｋ", "k"}, {"ｌ", "l"}, {"ｍ", "m"}, {"ｎ", "n"}, {"ｏ", "o"}, {"ｐ", "p"}, {"ｑ", "q"}, {"ｒ", "r"}, {"ｓ", "s"}, {"ｔ", "t"},
                {"ｕ", "u"}, {"ｖ", "v"}, {"ｗ", "w"}, {"ｘ", "x"}, {"ｙ", "y"}, {"ｚ", "z"},
                {"！", "!"}, {"”", "\""}, {"＃", "#"}, {"＄", "$"}, {"％", "%"}, {"＆", "&"}, {"＇", "'"}, {"（", "("}, {"）", ")"}, {"＊", "*"},
                {"＋", "+"}, {"，", ","}, {"－", "-"}, {"．", "."}, {"／", "/"}, {"：", ":"}, {"；", ";"}, {"＜", "<"}, {"＝", "="}, {"＞", ">"},
                {"？", "?"}, {"＠", "@"}, {"［", "["}, {"＼", "\\"}, {"］", "]"}, {"＾", "^"}, {"＿", "_"}, {"｀", "`"}, {"｛", "{"}, {"｜", "|"},
                {"｝", "}"}, {"　", " "}//, {"～", "~"}
        };
        for (String[] pair : fullWidthToHalfWidth) {
            fullWidthStr = fullWidthStr.replace(pair[0], pair[1]);
        }
        return fullWidthStr;
    }

    public String stringToDisplayedString(String translatedText, Colors colors){
        boolean needCharImage = plugin.getConfig().getSelectedLanguage().needsCharImages();
        GeneralFunctions generalFunctions = plugin.getGeneralFunctions();

        if(needCharImage) {// needs char image but just 1 color
            return generalFunctions.StringToTags(Colors.removeColorTag(translatedText), colors);
        } else { // doesnt need char image and just 1 color
            return "<col=" + colors.getHex() + ">" + translatedText + "</col>";
        }
    }

}

package com.RuneLingual.commonFunctions;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Getter
@Slf4j
public enum Colors {
    black("000000","black"),
    black2("0","black"),
    blue("0000ff","blue"),
    blue2("ff","blue"),
    green("00ff00","green"),
    green2("ff00","green"),
    green3("c0ff00", "green"),
    green4("dc10d", "green"),
    lightblue("00ffff","lightblue"),
    lightblue2("ffff", "lightblue"),
    orange("ff7000","orange"),
    orange2("ff9040","orange"),
    orange3("ff981f","orange"),
    red("ff0000","red"),
    red2("800000","red"),
    red3("6800bf","red"),
    white("ffffff","white"),
    white2("9f9f9f","white"),
    yellow("ffff00", "yellow"),

    ;

    private String name;
    private String hex;

    private Colors(String hex, String name) {
        this.hex = hex;
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getHex() {
        return hex;
    }

    public String getColorTag() {
        return "<col=" + this.getHex() + ">";
    }

//    public static Colors fromName(String name) {
//        for (Colors Colors : values()) {
//            if (Colors.getName().equalsIgnoreCase(name)) {
//                return Colors;
//            }
//        }
//        return black; // or throw an exception
//    }

    public static Colors fromName(String colorName){
        if (colorName.equals(red.getName())){
            return getColorFromHex(red.getHex());
        }
        if (colorName.equals(black.getName())){
            return getColorFromHex(black.getHex());
        }
        if (colorName.equals(blue.getName())){
            return getColorFromHex(blue.getHex());
        }
        if (colorName.equals(lightblue.getName())){
            return getColorFromHex(lightblue.getHex());
        }
        if (colorName.equals(yellow.getName())){
            return getColorFromHex(yellow.getHex());
        }
        if (colorName.equals(orange.getName())){
            return getColorFromHex(orange.getHex());
        }
        if (colorName.equals(white.getName())){
            return getColorFromHex(white.getHex());
        }
        if (colorName.equals(green.getName())){
            return getColorFromHex(green.getHex());
        }
        log.error("couldn't find color with the name : {}", colorName);
        return getColorFromHex(white.getHex());
    }

    public static Colors getColorFromHex(String hex) {
        int[] colorInts = new int[Colors.values().length];//number of colors

        for (int i = 0; i < Colors.values().length;i++) {
            String colName = Colors.values()[i].hex;
            if (hex.equals(colName))
                return Colors.values()[i];
            colorInts[i] = hexToInt(Colors.values()[i].getHex());
        }
        int j = findClosest(hexToInt(hex),colorInts);
        //log.info("color = " + Colors.values()[j]);
        return Colors.values()[j]; // or throw an exception
    }

    public static Colors fromInt(int intColor) {
        String hexString = IntToHex(intColor);
        return getColorFromHex(hexString);
    }

    private static int findClosest(int target, int[] numbers) {
        if (target == hexToInt("f9f9f9")) {//int for hex 9f9f9f, grey text in settings
            int i;
            for (i = 1; i < numbers.length; i++)
                if (Colors.values()[i] == Colors.white)
                    return i;
            return i;
        } else {
            int smallestDifference = Math.abs(numbers[0] - target);
            int closestI = 0;
            for (int i = 1; i < numbers.length; i++) {
                int currentDifference = Math.abs(numbers[i] - target);
                if (currentDifference < smallestDifference) {
                    smallestDifference = currentDifference;
                    closestI = i;
                }
            }
            return closestI;
        }
    }
    public static String IntToHex(int intColor) {
        String hexString = String.format("%06x",intColor);

        for (Colors Colors : values()) {
            if (Colors.getHex().equalsIgnoreCase(hexString)) {
                return Colors.getHex();
            }
        }
        return hexString; // or throw an exception
    }

    public static int hexToInt(String hex) {
        if(hex.length() > 6){
            hex = hex.substring(0,6);
        }
        return Integer.parseInt(hex, 16);
    }

    public Colors getSimpleColor(){
        if (this.getName().equals(Colors.green.getName())){ //if the color is green
            return Colors.green;
        }
        if (this.getName().equals(Colors.red.getName())){ //if the color is red
            return Colors.red;
        }
        if (this.getName().equals(Colors.blue.getName())){ //if the color is blue
            return Colors.blue;
        }
        if (this.getName().equals(Colors.orange.getName())){ //if the color is orange
            return Colors.orange;
        }
        if (this.getName().equals(Colors.yellow.getName())){ //if the color is yellow
            return Colors.yellow;
        }
        if (this.getName().equals(Colors.white.getName())){ //if the color is white
            return Colors.white;
        }
        if (this.getName().equals(Colors.black.getName())){ //if the color is black
            return Colors.black;
        }
        if (this.getName().equals(Colors.lightblue.getName())){ //if the color is lightblue
            return Colors.lightblue;
        }
        return this;
    }









    public static int countColorTagsAfterReformat(String wordAndColor) {//count number of color tags in a string
        wordAndColor = reformatColorWord(wordAndColor, Colors.white);
        Pattern re = Pattern.compile("(?<=\\d)>|(?<=\\p{IsAlphabetic})>");
        String[] splitResult = re.split(wordAndColor);
        if (splitResult.length == 0) {
            return 0;
        }
        if (splitResult.length == 1 && splitResult[0].isEmpty()) {
            return 0;
        }
        return re.split(wordAndColor).length - 1;
    }

    public static Colors[] getColorArray(String strWithColor, Colors defaultColor) {
        /*
        This function takes a string with color tags and returns a list of color names
        eg: <col=ff0000>Nex<col=ffffff> (level-1) -> ["red", "white"]
         */

        // if there are no color tags, return defaultColor
        if(countColorTagsAfterReformat(strWithColor) == 0){
            return new Colors[]{defaultColor};
        }

        strWithColor = reformatColorWord(strWithColor, defaultColor);

        // if there are color tags, return the color names
        String[] parts = strWithColor.split("<col=");
        Colors[] colorArray = new Colors[parts.length - 1];
        Pattern re = Pattern.compile("(?<=\\d)>|(?<=\\p{IsAlphabetic})>");
        for (int i = 0; i < parts.length - 1; i++) {
            Colors c = Colors.getColorFromHex(re.split(parts[i + 1])[0]);
            colorArray[i] = c;
            if (colorArray[i] == null || Objects.equals(colorArray[i], "")) {
                colorArray[i] = defaultColor;
            }
        }
        return colorArray;
    }

    public static String[] getWordArray(String strWithColor) {
        /*
        This function takes a string with color tags and returns a list of words
        eg: <img=3><colHIGHLIGHT>Nex<col=ffffff> (level-1) -> ["<img=3>", "Nex", " (level-1)"]
         */
        strWithColor = reformatColorWord(strWithColor, Colors.white);
        Pattern re = Pattern.compile("<col=[a-zA-Z0-9]*?>");
        String[] strArray = re.split(strWithColor);
        if (strArray.length == 0) {
            return new String[0];
        }
        if (strArray[0].isEmpty()) {
            if (strArray.length == 1) {
                return new String[0];
            } else {
                return Arrays.copyOfRange(strArray, 1, strArray.length);
            }
        }
        return re.split(strWithColor);
    }

    private static String reformatColorWord(String colWord, Colors defaultColor) {
        // replace <colNORMAL> with <col=0>, <colHIGHLIGHT> with <col=ff0000>, etc.
        colWord = colWord.replace("<colNORMAL>", "<col=0>");
        colWord = colWord.replace("<colHIGHLIGHT>", "<col=ff0000>");
        //todo: if there are any color tags that are not in the enum, add and replace them with <col=??> here like above

        // give words after </col> the default color
        // <col=ff0000>Nex</col> (level-1) -> <col=ff0000>Nex<col=ffffff> (level-1)
        colWord = colWord.replace("</col>",defaultColor.getColorTag());

        // give the beginning words without a color tag the default color
        // Nex <col=ffffff> (level-1) -> <col=ff0000>Nex <col=ffffff>(level-1)
        if (!colWord.startsWith("<col")) {
            colWord = defaultColor.getColorTag() + colWord;
        }

        // remove the color tag at the end of the word
        // <col=ff0000>Nex<col=ffffff> (level-1) <col=f0f0f0> -> <col=ff0000>Nex<col=ffffff> (level-1)
        colWord = colWord.replaceAll("<col=[a-zA-Z0-9]*?>$","");

        return colWord;
    }

    public static String removeColorTag(String str) {
        return str.replaceAll("<(?!img|>).*?>", "");
    }

    public static String removeAllTags(String str) {
        return str.replaceAll("<.*?>", "");
    }

    public static String enumerateColorsInColWord(String colWord) {
        Pattern re = Pattern.compile("<col[=a-zA-Z0-9]*?>");
        String[] parts = re.split(colWord);
        StringBuilder colorString = new StringBuilder();
        for (int i = 0; i < parts.length; i++) {
            colorString.append(parts[i]);
            if (i < parts.length - 1) {
                colorString.append("<colNum").append(i).append(">");
            }
        }
        return colorString.toString();
    }

    public static List<String> getColorTagsAsIs(String strWithColor) {
        // supports abnormal color tags such as <colHIGHLIGHT>, as long as its only numbers and alphabets, no symbols
        List<String> matches = new ArrayList<>();
        Pattern pattern = Pattern.compile("<col[=a-zA-Z0-9]*?>");
        Matcher matcher = pattern.matcher(strWithColor);

        while (matcher.find()) {
            matches.add(matcher.group());
        }
        return matches;
    }

    public static String surroundWithColorTag(String str, Colors color) {
        return color.getColorTag() + str + "</col>";
    }
}
package com.RuneLingual.commonFunctions;

import lombok.Getter;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;

import com.RuneLingual.RuneLingualPlugin;

import javax.inject.Inject;

@Getter @Slf4j
public class Ids {
    @Inject
    public Ids(RuneLingualPlugin plugin) {
        this.plugin = plugin;
        this.client = plugin.getClient();
    }
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    Client client;

    //widget IDs of tabs
    //private final int combatOptionParentWidgetId = client.getWidget(ComponentID.COMBAT_LEVEL).getParentId();
    private final int skillsTabParentWidgetId = ComponentID.SKILLS_CONTAINER;
    //private final int characterSummaryTabWidgetId = ComponentID.CHARACTER_SUMMARY_CONTAINER;
    private final int questTabParentWidgetId = ComponentID.QUEST_LIST_BOX;
    private final int achievementDiaryTabParentWidgetId = ComponentID.ACHIEVEMENT_DIARY_CONTAINER;
    private final int inventoryTabParentWidgetId = ComponentID.INVENTORY_CONTAINER;
    private final int equipmentTabParentWidgetId = ComponentID.EQUIPMENT_INVENTORY_ITEM_CONTAINER;
    private final int prayerTabParentWidgetId = 35454976;
    private final int spellBookTabParentWidgetId = ComponentID.SPELLBOOK_PARENT;
    private final int groupsTabParentWidgetId = 47644672;
    //private final int friendsTabParentWidgetId = client.getWidget(ComponentID.FRIEND_LIST_TITLE).getParentId();
    //private final int ignoreTabParentWidgetId = client.getWidget(ComponentID.IGNORE_LIST_TITLE).getParentId();
    private final int accountManagementTabParentWidgetId = 7143424;
    private final int settingsTabParentWidgetId = 7602176;
    private final int logoutTabParentWidgetId = 11927552;
    //private final int logOutTabParentWidgetId = 4521984;
    private final int worldSwitcherTabParentWidgetId = 4521984;
    private final int emotesTabParentWidgetId = ComponentID.EMOTES_WINDOW;
    private final int musicTabParentWidgetId = ComponentID.MUSIC_CONTAINER;


    // dont translate at all, except menu option
    private final int GimGroupNameWidgetId = 47579137;
    private final int GimMemberListWidgetId = 47579140;
    private final int ignoreNameListWidgetId = ComponentID.IGNORE_LIST_FULL_CONTAINER;

    //dont translate names, but translate World ### and "Offline"
    private final int friendsNameListWidgetId = ComponentID.FRIEND_LIST_FULL_CONTAINER;



    public int getCombatOptionParentWidgetId() {
        Widget w = client.getWidget(ComponentID.COMBAT_LEVEL);
        if(w != null) {
            return w.getParentId();
        }
        //log.info("parent of ComponentID.COMBAT_LEVEL is null");
        return -1;
    }

    public int getAchievementDiaryTabParentWidgetId() {
        Widget w = client.getWidget(ComponentID.ACHIEVEMENT_DIARY_CONTAINER);
        if(w != null) {
            return w.getParent().getParent().getParentId();
        }
        //log.info("parent^3 of ComponentID.ACHIEVEMENT_DIARY_CONTAINER is null");
        return -1;
    }

    public int getFriendsTabParentWidgetId() {
        Widget w = client.getWidget(ComponentID.FRIEND_LIST_TITLE);
        if(w != null) {
            return w.getParentId();
        }
        //log.info("parent of ComponentID.FRIEND_LIST_TITLE is null");
        return -1;
    }

    public int getIgnoreTabParentWidgetId() {
        Widget w = client.getWidget(ComponentID.IGNORE_LIST_TITLE);
        if(w != null) {
            return w.getParentId();
        }
        //log.info("parent of ComponentID.IGNORE_LIST_TITLE is null");
        return -1;
    }

    public int getCharacterSummaryTabWidgetId(){
        Widget w = client.getWidget(ComponentID.CHARACTER_SUMMARY_CONTAINER);
        if(w != null) {
            return w.getParentId();
        }
        //log.info("parent of ComponentID.CHARACTER_SUMMARY_CONTAINER is null");
        return -1;
    }
}

package com.RuneLingual.commonFunctions;

import lombok.Getter;
import lombok.Setter;
import net.runelite.client.RuneLite;

import java.io.File;

public class FileNameAndPath {
    @Getter
    private static final File localBaseFolder = new File(RuneLite.RUNELITE_DIR.getPath() + File.separator + "RuneLingual_resources");
    @Getter
    private static final String localSQLFileName = "transcript";
    @Getter @Setter
    private String localLangFolder;
}

package com.RuneLingual.Wigets;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.Getter;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;

public class WidgetCapture {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private WidgetsUtilRLingual widgetsUtilRLingual;
    @Inject
    private DialogTranslator dialogTranslator;

    @Inject
    public WidgetCapture(RuneLingualPlugin plugin){
        this.plugin = plugin;
    }

    public void translateWidget(){
        Widget[] validWidgets = widgetsUtilRLingual.getAllChildren();
        for(Widget validWidget : validWidgets){
            int widgetGroup = WidgetUtil.componentToInterface(validWidget.getId());
            if(widgetGroup == InterfaceID.CHATBOX){// skip all chatbox widgets for now TODO: chatbox buttons should be translated
                continue;
            }
            if(widgetGroup == InterfaceID.DIALOG_NPC
                || widgetGroup == InterfaceID.DIALOG_PLAYER
                || widgetGroup == InterfaceID.DIALOG_OPTION){
                dialogTranslator.handleDialogs(validWidget);
            } else if(!validWidget.getText().isEmpty()
                    && !validWidget.getText().contains("<img=") // check if already translated to japanese. TODO: need something else after adding other languages
                    && plugin.getConfig().getInterfaceTextConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)) {
                // if its only numbers and symbols dont do anything
                String re = "^[^\\p{Alpha}]+$";
                if (validWidget.getText().matches(re))
                    continue;
                Colors widgetColor = Colors.fromInt(validWidget.getTextColor());
                Colors[] textColor = Colors.getColorArray(validWidget.getText(),widgetColor);
                // for now only translate interfaces and buttons with API
                widgetsUtilRLingual.setWidgetText_ApiTranslation(validWidget, validWidget.getText(), textColor[0]);

            }
        }
    }
}

package com.RuneLingual.Wigets;

import com.RuneLingual.*;
import com.RuneLingual.SQL.SqlQuery;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.commonFunctions.Transformer.TransformOption;
import com.RuneLingual.nonLatin.GeneralFunctions;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;

import net.runelite.api.widgets.WidgetUtil;

import static com.RuneLingual.Wigets.WidgetsUtilRLingual.removeBrAndTags;
import com.RuneLingual.Wigets.WidgetsUtilRLingual.*;


@Slf4j
public class DialogTranslator {
    // Dialog happens in a separate widget than the ChatBox itself
    // not limited to npc conversations themselves, but also chat actions
    @Inject
    private Client client;
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private RuneLingualConfig config;

    // player widget ids
    @Getter
    private final int playerNameWidgetId = 14221316;
    @Getter
    private final int playerContinueWidgetId = 14221317;
    @Getter
    private final int playerContentWidgetId = 14221318;

    // npc widget ids
    @Getter
    private final int npcNameWidgetId = 15138820;
    @Getter
    private final int npcContinueWidgetId = 15138821;
    @Getter
    private final int npcContentWidgetId = 15138822;

    // dialog option widget ids
    @Getter
    private final int dialogOptionWidgetId = 14352385; // each and every line of the option dialogue has this id, even the red "select an option" text


    private final Colors defaultTextColor = Colors.black;
    private final Colors continueTextColor = Colors.blue;
    private final String continueText = "Click here to continue";
    private final Colors nameAndSelectOptionTextColor = Colors.red;
    private final String selectOptionText = "Select an option";
    private final Colors pleaseWaitTextColor = Colors.blue;
    private final String pleaseWaitText = "Please wait...";

    private TransformOption dialogOption;
    private TransformOption npcNameOption;
    @Inject
    Transformer transformer;

    @Inject
    private GeneralFunctions generalFunctions;
    @Inject
    private WidgetsUtilRLingual widgetsUtilRLingual;

    @Inject
    public DialogTranslator(RuneLingualConfig config, Client client, RuneLingualPlugin plugin) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        this.transformer = new Transformer(plugin);
    }

    public void handleDialogs(Widget widget) {
        if(widget.getText().contains("<img=")) {
            return;
        }
        dialogOption = MenuCapture.getTransformOption(plugin.getConfig().getNpcDialogueConfig());
        npcNameOption = MenuCapture.getTransformOption(plugin.getConfig().getNPCNamesConfig());
        if ((widget.getId() != npcNameWidgetId && dialogOption.equals(TransformOption.AS_IS))
                || (widget.getId() == npcNameWidgetId && npcNameOption.equals(TransformOption.AS_IS))) {
            return;
        }

        int interfaceID = WidgetUtil.componentToInterface(widget.getId());

        // if the widget is the npc name widget, and the config is set to use api translation
        if (npcNameOption.equals(TransformOption.TRANSLATE_API) && widget.getId() == npcNameWidgetId) {
            String npcName = widget.getText();
            widgetsUtilRLingual.setWidgetText_ApiTranslation(widget, npcName, nameAndSelectOptionTextColor);
            return;
        }
        // if the widget is not npc name nor player name, and the config is set to use api translation
        else if (dialogOption.equals(TransformOption.TRANSLATE_API) && widget.getId() != playerNameWidgetId && widget.getId() != npcNameWidgetId) {
            String dialogText = widget.getText();

            Colors[] textColor = {defaultTextColor};
            if(widget.getId() == npcContinueWidgetId || widget.getId() == playerContinueWidgetId)
                textColor[0] = continueTextColor;
            else if(widget.getId() == dialogOptionWidgetId && widget.getText().equals(selectOptionText))
                textColor[0] = nameAndSelectOptionTextColor;

            widgetsUtilRLingual.setWidgetText_ApiTranslation(widget, dialogText, textColor[0]);
            return;
        }

        // is not api translation
        switch (interfaceID) {
            case InterfaceID.DIALOG_NPC:
                handleNpcDialog(widget);
                return;
            case InterfaceID.DIALOG_PLAYER:
                handlePlayerDialog(widget);
                return;
            case InterfaceID.DIALOG_OPTION:
                handleOptionDialog(widget);
                return;
            default:
                break;
        }
        log.info("Unknown dialog widget: " + widget.getId());
    }

    // is not api translation
    private void handleNpcDialog(Widget widget) {
        if (widget.getId() == npcNameWidgetId) {
            String npcName = widget.getText();
            npcName = removeBrAndTags(npcName);

            SqlQuery query = new SqlQuery(this.plugin);
            query.setNpcName(npcName, nameAndSelectOptionTextColor);
            String translatedText = transformer.transform(npcName, nameAndSelectOptionTextColor,
                    npcNameOption, query, false);
            widget.setText(translatedText);
        } else if (widget.getId() == npcContinueWidgetId) {
            translateContinueWidget(widget);
        } else if (widget.getId() == npcContentWidgetId) {
            String npcContent = widget.getText(); // this can contain tags like <br> and probably color tags
            npcContent = removeBrAndTags(npcContent);
            String npcName = getInteractingNpcName();
            SqlQuery query = new SqlQuery(this.plugin);
            query.setDialogue(npcContent, npcName, false, defaultTextColor);
            String translatedText = transformer.transform(npcContent, defaultTextColor, dialogOption, query, false);
            widgetsUtilRLingual.setWidgetText_NiceBr(widget, translatedText);
        }
    }

    // is not api translation
    private void handlePlayerDialog(Widget widget) {
        if (widget.getId() == playerContinueWidgetId) {
            //log.info(widget.getText());
            translateContinueWidget(widget);
            return;
        }
        if (widget.getId() == playerContentWidgetId) {
            String playerContent = widget.getText(); // this can contain tags like <br> and probably color tags
            playerContent = removeBrAndTags(playerContent);


            String npcName = getInteractingNpcName();
            //log.info("playerContent: " + playerContent + " with npc: " + npcName);

            SqlQuery query = new SqlQuery(this.plugin);
            query.setDialogue(playerContent, npcName, true, defaultTextColor);
            String translatedText = transformer.transform(playerContent, defaultTextColor, dialogOption, query, false);
            widgetsUtilRLingual.setWidgetText_NiceBr(widget, translatedText);
        }
        // player name does not need to be translated
    }

    private void handleOptionDialog(Widget widget) {
        // the red "Select an option" text is not tagged with red color
        String dialogOption = widget.getText();
        if (dialogOption.equals(selectOptionText)) {
            widget.setText(getSelectOptionTranslation());
            return;
        }
        if (dialogOption.equals(pleaseWaitText)) {
            widget.setText(getPleaseWaitTranslation());
            return;
        }
        dialogOption = removeBrAndTags(dialogOption);
        SqlQuery query = new SqlQuery(this.plugin);
        query.setDialogue(dialogOption, getInteractingNpcName(), false, defaultTextColor);
        String translatedText = transformer.transform(dialogOption, defaultTextColor, this.dialogOption, query, false);
        widgetsUtilRLingual.setWidgetText_NiceBr(widget, translatedText);
    }

    private String getInteractingNpcName() {
        NPC npc = plugin.getInteractedNpc();
        if (npc == null) {
            return "";
        }
        return npc.getName();
    }

    private String getContinueTranslation() {
        SqlQuery query = new SqlQuery(this.plugin);
        query.setDialogue(continueText, "", true, continueTextColor);
        return transformer.transform(continueText, continueTextColor, dialogOption, query, false);
    }

    private String getSelectOptionTranslation() {
        SqlQuery query = new SqlQuery(this.plugin);
        query.setDialogue(selectOptionText, "", true, nameAndSelectOptionTextColor);
        return transformer.transform(selectOptionText, nameAndSelectOptionTextColor, dialogOption, query, false);
    }

    private String getPleaseWaitTranslation() {
        SqlQuery query = new SqlQuery(this.plugin);
        query.setDialogue(pleaseWaitText, "", true, pleaseWaitTextColor);
        return transformer.transform(pleaseWaitText, pleaseWaitTextColor, dialogOption, query, false);
    }

    private void translateContinueWidget(Widget widget) {
        if (widget.getText().equals(continueText)) {
            widget.setText(getContinueTranslation());
        } else if (widget.getText().equals(pleaseWaitText)) {
            widget.setText(getPleaseWaitTranslation());
        }
    }
}
package com.RuneLingual.Wigets;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.nonLatin.GeneralFunctions;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.util.List;
import java.util.ArrayList;

public class WidgetsUtilRLingual
{
	@Inject
	private Client client;
	@Inject
	private RuneLingualPlugin plugin;
	@Inject
	private GeneralFunctions generalFunctions;
	private List<String> stringTranslatingInThread = new ArrayList<>();

	@Inject
	public WidgetsUtilRLingual(Client client, RuneLingualPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;
	}

	public void setWidgetText_NiceBr(Widget widget, String newText) {
		if (newText.equals(widget.getText())) // the texts will be the same if the widget has already been translated, or doesn't have a translation available
			return;

		if (plugin.getConfig().getSelectedLanguage().needsCharImages())
			setWidgetText_NiceBr_CharImages(widget, newText);
		else
			setWidgetText_NiceBr_NoCharImages(widget, newText);
	}

	public void setWidgetText_NiceBr_apiTranslated(Widget widget, String newText) {

		if (newText.equals(widget.getText())) // the texts will be the same if the widget has already been translated, or doesn't have a translation available
			return;

		if (plugin.getConfig().getSelectedLanguage().needsCharImages())
			setWidgetText_NiceBr_CharImages(widget, newText);
		else
			setWidgetText_NiceBr_NoCharImages(widget, newText);
	}

	public void setWidgetText_ApiTranslation(Widget widget, String newText, Colors color){
		final String newText_withoutBrAndTags = removeBrAndTags(newText);
//		if(stringTranslatingInThread.contains(newText)) // skip if already translating with api
//			return;
//		stringTranslatingInThread.add(newText);

		String translatedText = plugin.getDeepl().translate(newText_withoutBrAndTags, LangCodeSelectableList.ENGLISH, plugin.getConfig().getSelectedLanguage());
		if(translatedText.equals(newText_withoutBrAndTags)) { // if the translation is the same as the original text, don't set the text
			return;
		}

		if (plugin.getTargetLanguage().needsCharImages()) {
			translatedText = generalFunctions.StringToTags(translatedText, color);
		}
		setWidgetText_NiceBr(widget, translatedText);
		stringTranslatingInThread.remove(newText);

	}

	public void setWidgetText_NiceBr_CharImages(Widget widget, String newText) { // todo: set to show overlay if the mouse is hovering and the widget is too small for the text to display
		// Set the text of the widget, but insert br considering the width of the widget
		int widgetWidth = widget.getWidth();
		int foreignWidth = plugin.getConfig().getSelectedLanguage().getCharWidth();
		int maxChars = widgetWidth / foreignWidth;

		// if language uses charImages and needs space between words
		if(plugin.getConfig().getSelectedLanguage().needsSpaceBetweenWords()) { // todo: test this when such language is added
			String[] words = newText.split(" ");
			StringBuilder newTextBuilder = new StringBuilder();
			int currentLineLength = 0;
			for(String word : words) {
				if(currentLineLength + word.length() > maxChars) {
					newTextBuilder.append("<br>");
					currentLineLength = 0;
				}
				newTextBuilder.append(word);
				currentLineLength += word.length();
			}
			newText = newTextBuilder.toString();
		} else { // if language uses charImages and doesn't need space between words
			String[] letters = newText.split("(?<=>)");
			StringBuilder newTextBuilder = new StringBuilder();
			int currentLineLength = 0;
			for(String letter : letters) {
				if(currentLineLength + 1 > maxChars) {
					newTextBuilder.append("<br>");
					currentLineLength = 0;
				}
				newTextBuilder.append(letter);
				currentLineLength++;
			}
			newText = newTextBuilder.toString();
		}
		widget.setText(newText);
	}

	public void setWidgetText_NiceBr_NoCharImages(Widget widget, String newText) {
		// Set the text of the widget, but insert br considering the width of the widget
		int widgetWidth = widget.getWidth();
		int foreignWidth = plugin.getConfig().getSelectedLanguage().getCharWidth();
		int maxChars = widgetWidth / foreignWidth;

		if(plugin.getConfig().getSelectedLanguage().needsSpaceBetweenWords()) {
			String[] words = newText.split(" ");
			StringBuilder newTextBuilder = new StringBuilder();
			int currentLineLength = 0;
			for(String word : words) {
				if(currentLineLength + word.length() > maxChars) {
					newTextBuilder.append("<br>");
					currentLineLength = 0;
				}
				newTextBuilder.append(word);
				currentLineLength += word.length();
			}
			newText = newTextBuilder.toString();
		} else {
			StringBuilder newTextBuilder = new StringBuilder();
			int currentLineLength = 0;
			for(int i = 0; i < newText.length(); i++) {
				if(currentLineLength + 1 > maxChars) {
					newTextBuilder.append("<br>");
					currentLineLength = 0;
				}
				newTextBuilder.append(newText.charAt(i));
				currentLineLength++;
			}
			newText = newTextBuilder.toString();
		}
		widget.setText(newText);
	}

	public static String removeBrAndTags(String str) {
		// replaces br with space
		String tmp = str.replaceAll("(?<=\\S)<br>(?=\\S)", " ");
		return Colors.removeColorTag(tmp);
	}

	public Widget[] getAllChildren()
	{
		// Create a list to store widgets
		List<Widget> widgetList = new ArrayList<>();

		Widget[] roots = client.getWidgetRoots();
		for (Widget root : roots) {
			iterateWidgetsRecursive(root, widgetList);
		}

		// Convert the list to an array and return
		return widgetList.toArray(new Widget[0]);
	}


	public static List<Widget> getAllChildren(Widget widget)
	{
		// Create a list to store widgets
		List<Widget> widgetList = new ArrayList<>();
		
		// Call the recursive method to populate the list
		iterateWidgetsRecursive(widget, widgetList);
		
		// Convert the list to an array and return
		return widgetList;
	}
	
	private static void iterateWidgetsRecursive(Widget widget, List<Widget> widgetList)
	{
		// Check if the widget is not null and not hidden
		if(widget != null && !widget.isHidden())
		{
			// Add the widget to the list
			if(!widget.getText().isBlank() || !widget.getName().isBlank())
			{
				widgetList.add(widget);
			}
			
			Widget[] staticChildren = widget.getStaticChildren();
			if (staticChildren != null)
			{
				for (Widget child : staticChildren)
				{
					iterateWidgetsRecursive(child, widgetList);
				}
			}
			Widget[] dynamicChildren = widget.getDynamicChildren();
			if (dynamicChildren != null)
			{
				for (Widget child : dynamicChildren)
				{
					iterateWidgetsRecursive(child, widgetList);
				}
			}
			Widget[] nestedChildren = widget.getNestedChildren();
			if (nestedChildren != null)
			{
				for (Widget child : nestedChildren)
				{
					iterateWidgetsRecursive(child, widgetList);
				}
			}
		}
	}
}

package com.RuneLingual;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RuneLingualPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RuneLingualPlugin.class);
		RuneLite.main(args);
	}
}
