package com.RuneLingual;

import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;

@Getter
public enum LangCodeSelectableList
{
    ENGLISH ("en", "EN","EN", 8, 14, 6, 6, false, false, false, false, true, false, false),
    PORTUGUÊS_BRASILEIRO ("pt_br", "PT","PT-BR", 8, 11, 6, 6, false, false, false, false, true, false, false),
    NORSK("no", "NB", "NB", 8, 14, 6, 6, false, false, false, false, true, false, true),
    日本語("ja", "JA", "JA", 12, 12, 12, 15, true, true, true, true, false, true, true),
    Русский("ru", "RU", "RU", 8, 12, 6, 6, true, false, true, false, true, false, true),
    český("cs", "CS", "CS", 7, 14, 6, 6, false, false, false, false, true, false, false),
    dansk("da", "DA", "DA", 7, 14, 6, 6, false, false, false, false, true, false, false),
    DEUTSCH("de", "DE", "DE", 7, 14, 6, 6, false, false, false, false, true, false, false),
    ESPAÑOL("es", "ES", "ES", 7, 14, 6, 6, false, false, false, false, true, false, false),
    eesti("et", "ET", "ET", 7, 14, 6, 6, false, false, false, false, true, false, false),
    suomi("fi", "FI", "FI", 7, 14, 6, 6, false, false, false, false, true, false, false),
    FRANÇAIS("fr", "FR", "FR", 7, 14, 6, 6, false, false, false, false, true, true, false),
    //hrvatski("hr", "HE", "HE", 8, 14, 6, 6, false, true, false, false, true, false, false), // only available in pro v2 api, todo: change code to check for this, then add this language
    magyar("hu", "HU", "HU", 7, 14, 6, 6, false, false, false, false, true, false, false),
    Indonesian("id", "ID", "ID", 7, 14, 6, 6, false, false, false, false, true, false, false),
    italiano("it", "IT", "IT", 7, 14, 6, 6, false, false, false, false, true, false, false),
    Nederlands("nl", "NL", "NL", 7, 14, 6, 6, false, false, false, false, true, false, false),
    PORTUGUÊS("pt", "PT-PT", "PT-PT", 7, 14, 6, 6, false, false, false, false, true, false, false),
    svenska("sv", "SV", "SV", 7, 14, 6, 6, false, false, false, false, true, false, false),
    Türkçe("tr", "TR", "TR", 7, 14, 6, 6, false, false, false, false, true, false, true);


    // todo: add languages here
    // needs char images: arabic, bulgarian, czech, greek, hebrew(pro only), lithuanian, latvian, polish, romanian, slovak, slovenian, Thai (pro version only), Ukrainian, Vietnamese (pro version only), Chinese (simplified & traditional)

    private final String langCode;
    private final String deeplLangCodeSource;
    private final String deeplLangCodeTarget;
    private final int charWidth;
    private final int charHeight;
    private final int chatBoxCharWidth;
    private final int overlayCharWidth;

    @Getter(AccessLevel.NONE)
    private final boolean needCharImages;
    @Getter(AccessLevel.NONE)
    private final boolean swapMenuOptionAndTarget;
    @Getter(AccessLevel.NONE)
    private final boolean needInputOverlay;
    @Getter(AccessLevel.NONE)
    private final boolean needInputCandidateOverlay;
    @Getter(AccessLevel.NONE)
    private final boolean needSpaceBetweenWords;
    private final boolean chatButtonHorizontal;
    @Getter(AccessLevel.NONE)
    private final boolean localTranscript;


    @Inject
    LangCodeSelectableList(String langCode, String deeplCodeSrc, String deeplCodeTgt,
                           int charWidth, int charHeight, int chatBoxCharWidth, int overlayCharWidth,
                           boolean needCharImages, boolean swapMenuOptionAndTarget,
                           boolean needInputOverlay, boolean needInputCandidateOverlay,
                           boolean needSpaceBetweenWords, boolean chatButtonHorizontal, boolean localTranscript) {
        this.langCode = langCode;
        this.deeplLangCodeSource = deeplCodeSrc;
        this.deeplLangCodeTarget = deeplCodeTgt;
        this.charWidth = charWidth;
        this.charHeight = charHeight;
        this.chatBoxCharWidth = chatBoxCharWidth;
        this.overlayCharWidth = overlayCharWidth;
        this.needCharImages = needCharImages;
        this.swapMenuOptionAndTarget = swapMenuOptionAndTarget;
        this.needInputOverlay = needInputOverlay;
        this.needInputCandidateOverlay = needInputCandidateOverlay;
        this.needSpaceBetweenWords = needSpaceBetweenWords;
        this.chatButtonHorizontal = chatButtonHorizontal;
        this.localTranscript = localTranscript;
    }

    public boolean needsCharImages() {
        return needCharImages;
    }

    public boolean needsSwapMenuOptionAndTarget() {
        return swapMenuOptionAndTarget;
    }

    public boolean needsInputOverlay() {
        return needInputOverlay;
    }

    public boolean needsInputCandidateOverlay() {
        return needInputCandidateOverlay;
    }

    public boolean needsSpaceBetweenWords() {
        return needSpaceBetweenWords;
    }

    public boolean hasLocalTranscript() {return localTranscript;}

    public static int getLatinCharWidth(Widget widget, LangCodeSelectableList langCode) {
        /*
        494: 5 px
        495: 6 px
        496: 7 px
        */
        int fontId = widget.getFontId();
        if (fontId == 494) {
            return 5;
        } else if (fontId == 495) {
            return 6;
        } else if (fontId == 496) {
            return 7;
        }
        return langCode.getCharWidth();
    }

    public static String getAPIErrorMessage(LangCodeSelectableList langCode) {
        if (langCode == LangCodeSelectableList.日本語) {
            return "APIキーが無効、翻訳の上限が近い、\nもしくはリクエストが集中しています。";
        } else {
            return "The API key is invalid, the translation \nlimit is close, or requests are congested.";
        }
    }
}
/*
* deepl lang codes: https://developers.deepl.com/docs/resources/supported-languages#target-languages
* */
package com.RuneLingual.SQL;

import lombok.Getter;

@Getter
public enum SqlVariables {
    // SQL Variables
    columnEnglish("","english"),// name of column in the database
    columnTranslation("","translation"),
    columnCategory("","category"),
    columnSubCategory("","sub_category"),
    columnSource("","source"),

    // possible category values
    categoryValue4Dialogue("dialogue","category"), // string value for "dialogue" in category column
    categoryValue4Examine("examine","category"),
    categoryValue4Name("name","category"),
    categoryValue4Manual("manual","category"),//probably wont use
    categoryValue4Actions("actions","category"),
    categoryValue4LvlUpMessage("lvl_up_Message","category"),
    categoryValue4InventActions("inventoryActions","category"), // this is for every menu entries in the main panel(Inventory, Worn Equipment, friends list, etc.
    categoryValue4Interface("interface","category"), // for interfaces like buttons and widgets

    // possible sub_category values
    subcategoryValue4Item("item","sub_category"),
    subcategoryValue4Npc("npc","sub_category"),
    subcategoryValue4Obj("object","sub_category"),
    subcategoryValue4Level("level","sub_category"), // for "(level-%d)" of player or npcs with levels, category should be "name"
    subcategoryValue4Menu("menu","sub_category"), // for widgets that are not buttons nor interface, such as one of the skills in skill list tab, name of tabs ("Combat Options", "Quest List")
    subcategoryValue4Player("player","sub_category"), // for player options, such as report, trade, follow, etc.
    subcategoryValue4Quest("quest","sub_category"),
    subcategoryValue4Tab("genActions","sub_category"), // for general actions such as deposit all, sell-5, etc.
    subcategoryValue4GeneralUI("generalUI","sub_category"), // most if not all interfaces will have this subcategory value
    subcategoryValue4MainTabs("mainTabs","sub_category"), // for main tabs, such as combat options, skills, character summary, etc.
    subCategoryValue4ChatButtons("chatButtons","sub_category"), // for chat buttons, such as report, trade, On, Off, Hide, etc.
    subCategoryValue4LoginScreen("loginScreen","sub_category"),
    subCategoryValue4CA("combAchvmt","sub_category"), // for combat achievements and achievement diary


    // possible source values
    sourceValue4Player("player","source"), // for player options, such as report, trade, follow, etc.
    //  for tabs
    sourceValue4CombatOptionsTab("combatOptionsTab","source"), // for combat options, attack styles etc. query eg: Block	actions	menu	combatOption
    sourceValue4SkillsTab("skillsTab","source"), // for skills tab
    sourceValue4CharacterSummaryTab("characterSummaryTab","source"), // for character summary tab
    sourceValue4QuestListTab("questListTab","source"), // for quest list tab
    sourceValue4AchievementDiaryTab("achievementDiaryTab","source"), // for achievement Diary Tab
    sourceValue4InventTab("inventTab","source"), // for inventory tab
    sourceValue4WornEquipmentTab("wornEquipmentTab","source"), // for worn equipment tab
    sourceValue4PrayerTab("prayerTab","source"), // for prayer tab
    sourceValue4SpellBookTab("spellBookTab","source"), // for spell book tab
    sourceValue4GroupTab("groupTab","source"), // for group tab
    sourceValue4FriendsTab("friendsTab","source"), // for friends tab
    sourceValue4IgnoreTab("ignoreTab","source"), // for ignore tab
    sourceValue4AccountManagementTab("accountManagementTab","source"), // for account management tab
    sourceValue4SettingsTab("settingsTab","source"), // for settings tab
    sourceValue4LogoutTab("logoutTab","source"), // for logout tab
    sourceValue4WorldSwitcherTab("worldSwitcherTab","source"), // for world switcher
    sourceValue4EmotesTab("emotesTab","source"), // for emotes tab
    sourceValue4MusicTab("musicTab","source"), // for music tab

    // for interfaces
    sourceValue4SkillGuideInterface("skillGuide","source"), // for skill guide interface
    // add more here, with comments for what they are for
    // name should be "sourceValue4" + the name of the source
    // the second value "source" should not be changed, as it is the name of the column in the database
    ;

    private final String value;
    private final String columnName;

    SqlVariables(String val, String columnName) {
        this.value = val;
        this.columnName = columnName;
    }

}

package com.RuneLingual.SQL;

import java.sql.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.io.File;
import java.util.*;

import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.prepareResources.Downloader;
import com.RuneLingual.RuneLingualPlugin;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;

@Slf4j
public class SqlActions {

    public static final String tableName = "transcript";
    static final String databaseFileName = FileNameAndPath.getLocalSQLFileName();
    ;
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private Downloader downloader;
    @Inject
    private FileNameAndPath fileNameAndPath;

    @Inject
    public SqlActions(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    // private String databaseUrl = "jdbc:h2:" + downloader.getLocalLangFolder() + File.separator + databaseFileName;

    public void createTable() throws SQLException {
        try {
            Class.forName("org.h2.Driver");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
        Connection conn = DriverManager.getConnection(this.plugin.getDatabaseUrl());
        this.plugin.setConn(conn);

        // Check if the table already exists
        DatabaseMetaData metaData = conn.getMetaData();
        try (ResultSet tables = metaData.getTables(null, null, tableName.toUpperCase(), new String[]{"TABLE"})) {
            if (tables.next()) {
                //log.info("Table '{}' already exists. Skipping creation.", tableName);
                return;
            }
        }

        // Create the table if it does not exist
        String sql = "CREATE TABLE " + tableName + " ()";

        try (Statement stmt = conn.createStatement()) {
            stmt.execute(sql);
        } catch (SQLException e) {
            log.error("Error creating table '{}'.", tableName, e);
            throw new RuntimeException(e);
        }
    }


    public void tsvToSqlDatabase(String[] tsvFiles, String tsvFolderPath){
        try {
            Class.forName("org.h2.Driver");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
        // note: table must exist before calling this function

        for (String tsvFile : tsvFiles) {
            processTsvFile(tsvFolderPath + File.separator + tsvFile);
        }

        // Check if the index already exists
        DatabaseMetaData metaData = null;
        try {
            metaData = this.plugin.getConn().getMetaData();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        try (ResultSet indexes = metaData.getIndexInfo(null, null, tableName.toUpperCase(), false, false)) {
            while (indexes.next()) {
                String indexName = indexes.getString("INDEX_NAME");
                if ("ENGLISH_INDEX".equalsIgnoreCase(indexName)) {
                    //"Index 'english_index' already exists. Skipping creation.
                    return;
                }
            }
        } catch (SQLException e) {
            log.error("Error checking for existing index on " + tableName, e);
        }

        // Index the English column
        String sql = "CREATE INDEX english_index ON " + tableName + " (" + SqlVariables.columnEnglish.getColumnName()
                + ", " + SqlVariables.columnTranslation.getColumnName()
                + ", " + SqlVariables.columnCategory.getColumnName()
                + ", " + SqlVariables.columnSubCategory.getColumnName()
                + ", " + SqlVariables.columnSource.getColumnName() + ")";
        try (Statement stmt = this.plugin.getConn().createStatement()) {
            stmt.execute(sql);
        } catch (SQLException e) {
            log.error("Error creating index on " + tableName, e);
        }
    }

    private void processTsvFile(String tsvFilePath) {
        try {
            Class.forName("org.h2.Driver");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
        log.info("Processing TSV file: " + tsvFilePath);
        try {
            List<String> lines = Files.readAllLines(Paths.get(tsvFilePath));
            String[] columnNames = lines.get(0).split("\t");

            // Ensure all columns exist
            ensureColumnsExist(columnNames);

            // Insert data
            for (int i = 1; i < lines.size(); i++) {
                if(lines.get(i).split("\t").length > columnNames.length){
                    log.info("Warning processing TSV file " + tsvFilePath + " at line " + i + " : " + lines.get(i));
                    log.info("found more values than number of columns.");
                    log.info("Column names: " + Arrays.toString(columnNames));
                    log.info("Column values: " + Arrays.toString(lines.get(i).split("\t")));
                }
                String[] fields = lines.get(i).split("\t", columnNames.length);

                StringBuilder sql = new StringBuilder("INSERT INTO " + tableName + " (");

                for (String columnName : columnNames) {
                    sql.append(columnName).append(",");
                }

                sql.deleteCharAt(sql.length() - 1); // remove last comma
                sql.append(") VALUES (");

                for (int j = 0; j < fields.length; j++) {
                    sql.append("?,");
                }

                sql.deleteCharAt(sql.length() - 1); // remove last comma
                sql.append(")");

                try (PreparedStatement pstmt = this.plugin.getConn().prepareStatement(sql.toString())) {
                    for (int j = 0; j < fields.length; j++) {
                        pstmt.setString(j + 1, fields[j]);
                    }

                    pstmt.executeUpdate();
                } catch (SQLException e) {
                    log.error("Error processing TSV file {} at line {} : '{}'", tsvFilePath, i, lines.get(i));
                    log.error("sql: '{}'", sql, e);
                }
            }
        } catch (Exception e) {
            log.error("Error processing TSV file {}", tsvFilePath, e);
        }
    }

    private void ensureColumnsExist(String[] columnNames) {
        for (String columnName : columnNames) {
            String sql = "ALTER TABLE " + tableName + " ADD COLUMN IF NOT EXISTS " + columnName + " VARCHAR(2000)";
            try (Statement stmt = this.plugin.getConn().createStatement()) {
                stmt.execute(sql);
            } catch (SQLException e) {
                log.error("Error adding column {} to " + tableName, columnName, e);
            }
        }
    }

    public String[][] executeSearchQuery(String query) {
        /*
        * Execute a search query and return the results as a 2D array
        * eg. SELECT * FROM transcript WHERE english = 'hello'
        * returns [["hello", "hola"], ["hello", "こんにちは"]]
         */

        List<List<String>> results = new ArrayList<>();
        try (Statement stmt = this.plugin.getConn().createStatement();){
            ResultSet rs = stmt.executeQuery(query);

            ResultSetMetaData rsmd = rs.getMetaData();
            int columnsNumber = rsmd.getColumnCount();

            while (rs.next()) {
                List<String> row = new ArrayList<>();
                for (int i = 1; i <= columnsNumber; i++) {
                    row.add(rs.getString(i));
                }
                results.add(row);
            }
            String[][] array = new String[results.size()][];
            for (int i = 0; i < results.size(); i++) {
                List<String> row = results.get(i);
                array[i] = row.toArray(new String[0]);
            }
            return array;
        }
        catch (SQLException e) {
            log.error("Error executing search query: {}.\nDeleting hash file, restart plugin", query, e);
            // delete the hash file. When the plugin restarts, it will download the latest files, replacing possible corrupted files.
            String hashFilePath = FileActions.getHashFile(this.plugin.getConfig().getSelectedLanguage());
            FileActions.deleteFile(hashFilePath);
        }
        return new String[0][0];
    }

    public String[] executeQuery(String query) {
        /*
            * Execute a query and return the results as a 1D array
            * eg. SELECT translation FROM transcript WHERE english = 'hello'
            * returns ["hola", "こんにちは"]
         */
        List<String> results = new ArrayList<>();
        try (Statement stmt = this.plugin.getConn().createStatement();
             ResultSet rs = stmt.executeQuery(query)) {

            while (rs.next()) {
                String columnValue = rs.getString(1);
                results.add(columnValue);
            }
        } catch (SQLException e) {
            log.error("Error executing query: {}", query, e);
        }
        return results.toArray(new String[0]);
    }

    public static String[][] executePreparedStatement(PreparedStatement preparedStatement) throws SQLException {
        try (ResultSet resultSet = preparedStatement.executeQuery()) {
            ArrayList<String[]> results = new ArrayList<>();
            int columnCount = resultSet.getMetaData().getColumnCount();

            while (resultSet.next()) {
                String[] row = new String[columnCount];
                for (int i = 0; i < columnCount; i++) {
                    row[i] = resultSet.getString(i + 1);
                }
                results.add(row);
            }

            return results.toArray(new String[0][0]);
        }
    }

    public static boolean tableExists(Connection conn, String tableName) throws SQLException {
        try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ?")) {
            stmt.setString(1, tableName.toUpperCase());
            try (ResultSet rs = stmt.executeQuery()) {
                return rs.next();
            }
        }
    }

    public static boolean tableIsEmpty(Connection conn, String tableName) throws SQLException {
        try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT COUNT(*) FROM " + tableName)) {
            try (ResultSet rs = stmt.executeQuery()) {
                return rs.next() && rs.getInt(1) == 0;
            }
        }
    }

    public static boolean noTableExistsOrIsEmpty(Connection conn){
        String tableName = SqlActions.tableName;
        try {
            if (!tableExists(conn, tableName) || tableIsEmpty(conn, tableName)) {
                if(conn!=null) {
                    conn.close();
                }
                return true;
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return false;
    }




}

package com.RuneLingual.SQL;

import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import lombok.Getter;
import lombok.Setter;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Getter @Setter
public class SqlQuery implements Cloneable{
    private String english; // the whole text, not a part of Colors.wordArray
    private String translation;
    private String category;
    private String subCategory;
    private String source;

    private Colors color;


    @Inject
    RuneLingualPlugin plugin;

    @Inject
    public SqlQuery(RuneLingualPlugin plugin){
        this.plugin = plugin;
        this.english = null;
        this.translation = null;
        this.category = null;
        this.subCategory = null;
        this.source = null;
        this.color = null;
    }
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SqlQuery sqlQuery = (SqlQuery) o;
        return Objects.equals(english, sqlQuery.english) &&
                Objects.equals(category, sqlQuery.category) &&
                Objects.equals(subCategory, sqlQuery.subCategory) &&
                Objects.equals(source, sqlQuery.source) &&
                Objects.equals(translation, sqlQuery.translation);
    }
    @Override
    public int hashCode() {
        return Objects.hash(english, category, subCategory, source, translation);
    }
    public SqlQuery copy() {
        try {
            return (SqlQuery) this.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Clone not supported", e);
        }
    }

    public String[] getMatching(SqlVariables column, boolean searchAlike) {
        // create query -> execute -> return result
        String query = getSearchQuery();
        query = query.replace("*", column.getColumnName());
        String[][] result = plugin.getSqlActions().executeSearchQuery(query);
        if(result.length == 0 && searchAlike){
            return new String[]{getPlaceholderMatches()};
        }
        if(result.length == 0){
            // search again ignoring cases
            query = getSearchQuery_IgnoreCase();
            query = query.replace("*", column.getColumnName());
            result = plugin.getSqlActions().executeSearchQuery(query);
        }
        String[] translations = new String[result.length];
        for (int i = 0; i < result.length; i++){
            translations[i] = result[i][0];
        }
        return translations;
    }

    public String[] getMatching(SqlVariables[] columns) {
        // create query -> execute -> return result
        String query = getSearchQuery();
        String[] translations = new String[columns.length];
        for (int i = 0; i < columns.length; i++){
            query = query.replace("*", columns[i].getColumnName());
            String[][] result = plugin.getSqlActions().executeSearchQuery(query);
            translations[i] = result[0][0];
        }
        return translations;
    }

    private String getPlaceholderMatches(){
        /*
        returns translation which includes placeholders at first that matches the english text,
        with the placeholders replaced with the corresponding english word/number.
        placeholders =  %s0, %s1,... for strings atleast 1 alphabet and 0 or more numbers/spaces
                        %d0, %d1,... for numbers (and only numbers)
        1. gets all records that contains placeholder values in English, and matches the query except for english
        if no matches with placeholders are found, returns the original english text
        2. returns the translation of the first match
        3. if no match is found, returns the original english text
        not tested for %s, nor tested throughly for %d
         */
        String[] placeholders = {"%s", "%d"};
        String query = getPlaceholderSearchQuery(placeholders);
        String[][] result = plugin.getSqlActions().executeSearchQuery(query);
        // returns a placeholder if no matches are found
        if (result == null || result.length == 0){
            return english;
        }
        for (String[] row : result){
            String englishWithPlaceholders = row[0];
            String translationWithPlaceholders = row[1];
            String replacedMatch = englishWithPlaceholders;
            // Replace placeholders
            // Replace placeholders for strings
            for (int i = 0; i < 100; i++) {
                String beforeReplace = replacedMatch;
                replacedMatch = replacedMatch.replace("%s" + i, "[ \\w]+");
                if (beforeReplace.equals(replacedMatch)){
                    break;
                }
            }

            // Replace placeholders for numbers
            for (int i = 0; i < 100; i++) {
                String beforeReplace = replacedMatch;
                replacedMatch = replacedMatch.replace("%d" + i, "\\d+");
                if (beforeReplace.equals(replacedMatch)){
                    break;
                }
            }

            replacedMatch = stringToRegex(replacedMatch);

            Pattern pattern = Pattern.compile(replacedMatch);
            Matcher matcher = pattern.matcher(this.english);
            if (!matcher.matches()){
                continue;
            }
            List<String> matchedStrings = new ArrayList<>();
            List<String> matchedNumbers = new ArrayList<>();
            for (int i = 1; i <= matcher.groupCount(); i++) {
                String group = matcher.group(i);
                if (group.matches("\\d+")) {
                    matchedStrings.add(group);
                } else if (group.matches("[ \\w]+")) {
                    matchedNumbers.add(group);
                }
            }

            // Replace placeholders in the translated text
            String translation = translationWithPlaceholders;
            for (int i = 0; i < matchedStrings.size(); i++) {
                translation = translation.replace("%s" + i, matchedStrings.get(i));
            }
            for (int i = 0; i < matchedNumbers.size(); i++) {
                translation = translation.replace("%d" + i, matchedNumbers.get(i));
            }
            return translation;
        }

        return english;
    }

    private String stringToRegex(String str){
        return str.replaceAll("([\\[\\](){}*+?^$.|])", "\\\\$1");
    }

    public String getSearchQuery() {
        english = replaceSpecialSpaces(english);

        // creates query that matches all non-empty fields
        // returns null if no fields are filled
        String query = "SELECT * FROM " + SqlActions.tableName + " WHERE ";
        if (english != null && !english.isEmpty()){
            query += SqlVariables.columnEnglish.getColumnName() + " = '" + english.replace("'","''") + "' AND ";
        }
        if (category != null && !category.isEmpty()){
            query += SqlVariables.columnCategory.getColumnName() + " = '" + category + "' AND ";
        }
        if (subCategory != null && !subCategory.isEmpty()){
            query += SqlVariables.columnSubCategory.getColumnName() + " = '" + subCategory + "' AND ";
        }
        if (source != null && !source.isEmpty()){
            query += SqlVariables.columnSource.getColumnName() + " = '" + source + "' AND ";
        }
        if (translation != null && !translation.isEmpty()){
            query += SqlVariables.columnTranslation.getColumnName() + " = '" + translation.replace("'","''") + "' AND ";
        } //todo: add more here if columns to be filtered are added

        if (query.endsWith("AND ")){
            query = query.substring(0, query.length() - 5);
            return query;
        }
        return null;
    }

    public String getSearchQuery_IgnoreCase() {
        english = replaceSpecialSpaces(english);

        // creates query that matches all non-empty fields
        // returns null if no fields are filled
        String query = "SELECT * FROM " + SqlActions.tableName + " WHERE UPPER(";
        if (english != null && !english.isEmpty()){
            query += SqlVariables.columnEnglish.getColumnName() + ") = UPPER('" + english.replace("'","''") + "') AND ";
        }
        if (category != null && !category.isEmpty()){
            query += SqlVariables.columnCategory.getColumnName() + " = '" + category + "' AND ";
        }
        if (subCategory != null && !subCategory.isEmpty()){
            query += SqlVariables.columnSubCategory.getColumnName() + " = '" + subCategory + "' AND ";
        }
        if (source != null && !source.isEmpty()){
            query += SqlVariables.columnSource.getColumnName() + " = '" + source + "' AND ";
        }
        if (translation != null && !translation.isEmpty()){
            query += SqlVariables.columnTranslation.getColumnName() + " = '" + translation.replace("'","''") + "' AND ";
        } //todo: add more here if columns to be filtered are added

        if (query.endsWith("AND ")){
            query = query.substring(0, query.length() - 5);
            return query;
        }
        return null;
    }

    public String getPlaceholderSearchQuery(String[] placeholders) {
        // creates query that matches all non-empty fields
        // returns null if no fields are filled
        // return only english
        String query = "SELECT english, translation FROM " + SqlActions.tableName + " WHERE (english LIKE '%\\%s%' OR english LIKE '%\\%d%') AND ";
        if (category != null && !category.isEmpty()){
            query += SqlVariables.columnCategory.getColumnName() + " = '" + category + "' AND ";
        }
        if (subCategory != null && !subCategory.isEmpty()){
            query += SqlVariables.columnSubCategory.getColumnName() + " = '" + subCategory + "' AND ";
        }
        if (source != null && !source.isEmpty()){
            query += SqlVariables.columnSource.getColumnName() + " = '" + source + "' AND ";
        }
        if (query.endsWith("AND ")){
            query = query.substring(0, query.length() - 5);
            return query;
        }
        //todo: add more here if columns to be filtered are added
        return query;
    }

    public void setEnCatSubcat(String english, String category, String subCategory, Colors defaultColor){
        this.english = english;
        this.category = category;
        this.subCategory = subCategory;
        this.color = defaultColor;
    }

    public void setItemName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Name.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Item.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public boolean isItemNameQuery(){
        return english != null
                && Objects.equals(category, SqlVariables.categoryValue4Name.getValue())
                && Objects.equals(subCategory, SqlVariables.subcategoryValue4Item.getValue())
                && color != null;
    }

    public void setNpcName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Name.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Npc.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setObjectName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Name.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Obj.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setMenuName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Name.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Menu.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }



    public void setInventoryItemActions(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4InventActions.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Item.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setGroundItemActions(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Actions.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Item.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setNpcActions(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Actions.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Npc.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setObjectActions(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Actions.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Obj.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setGenMenuAcitons(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Actions.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Menu.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setPlayerActions(String en, Colors defualtColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Actions.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Player.getValue();
        this.color = defualtColor;
        this.source = null;
        this.translation = null;
    }
    public void setPlayerLevel() {
        this.english = "level";
        this.category = SqlVariables.categoryValue4Name.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Level.getValue();
        this.source = null;
        this.translation = null;
    }

    public void setDialogue(String en, String npcTalkingTo, boolean speakerIsPlayer, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Dialogue.getValue();
        this.subCategory = npcTalkingTo;
        this.color = defaultColor;
        if(speakerIsPlayer){
            this.source = "Player";
        } else {
            this.source = npcTalkingTo;
        }
        this.translation = null;
    }

    public void setQuestName(String en, Colors defaultColor){
        this.english = en;
        this.category = SqlVariables.categoryValue4Manual.getValue();
        this.subCategory = SqlVariables.subcategoryValue4Quest.getValue();
        this.color = defaultColor;
        this.source = null;
        this.translation = null;
    }

    public void setGeneralUI(String source){
        this.english = null;
        this.category = SqlVariables.categoryValue4Interface.getValue();
        this.subCategory = SqlVariables.subcategoryValue4GeneralUI.getValue();
        this.source = source;
        this.translation = null;
    }

    public static String replaceSpecialSpaces(String input) {
        if(input == null){
            return null;
        }

        int[] specialSpaces = {9, 32, 160, 8195, 8194, 8201, 8202, 8203, 12288};
        StringBuilder result = new StringBuilder();

        for (int i = 0; i < input.length(); i++) {
            int codePoint = input.codePointAt(i);
            boolean isSpecialSpace = false;

            for (int specialSpace : specialSpaces) {
                if (codePoint == specialSpace) {
                    isSpecialSpace = true;
                    break;
                }
            }

            if (isSpecialSpace) {
                result.append(' ');
            } else {
                result.appendCodePoint(codePoint);
            }
        }

        return result.toString();
    }

    /*
        * Replaces numbers in the input string with placeholders.
        * Numbers are replaced with <Num0>, <Num1>, <Num2>, etc.
        * For example, "Hello Asda123, how many 1s are there in 101?" becomes
        *              "Hello Asda<Num0>, how many <Num1>s are there in <Num2>?"
        * but if the number is between < and >, it is not replaced.
     */
    public static String replaceNumbersWithPlaceholders(String input) {
        if(input == null){
            return null;
        }

        StringBuilder result = new StringBuilder();
        int numberCount = 0;
        boolean lastCharWasNumber = false;
        Set<Character> punctuationMarks = Set.of('.', ',', '?', '!');
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (c == '<'){// if its a start of a tag, find the end of the tag
                for (int j = i + 1; j < input.length(); j++){
                    if (input.charAt(j) == '>'){// if the end of the tag is found, append the tag and continue from the end of the tag
                        result.append(input, i, j + 1);
                        i = j;
                        break;
                    }
                    // if the end of the string is reached, or letters between <> is longer than 15, or there is at least 1 punctuation,
                    // consider '<' as a normal character
                    if (j == input.length() - 1 || j-i > 15 || punctuationMarks.contains(input.charAt(j))){
                        result.append(c);
                        break;
                    }
                }
            } else if (Character.isDigit(c)) {
                if (!lastCharWasNumber) {
                    result.append("<Num").append(numberCount).append(">");
                    numberCount++;
                }
                lastCharWasNumber = true;
            } else // if the number is a decimal number or a large number, continue appending the number
                if ((c == '.' || c == ',') && lastCharWasNumber && i < input.length() - 1 && Character.isDigit(input.charAt(i + 1))) {
                continue;
            } else {
                result.append(c);
                lastCharWasNumber = false;
            }
        }

        return result.toString();
    }

    /*
        * Replaces placeholders in the original text with numbers from the translated text.
        * Placeholders are <Num0>, <Num1>, <Num2>, etc.
        * For example, if the original text is "Hello Asda123, how many 1s are there in 101?"
        * and the translated text is "こんにちは、アスダ<Num0>さん、<Num2>の中に<Num1>はいくつありますか？",
        * the result will be "こんにちは、アスダ123さん、101の中に1はいくつありますか？"
        * but if the number is between < and >, it is not replaced.
     */
    public static String replacePlaceholdersWithNumbers(String originalText, String translatedText) {
        if (originalText == null || translatedText == null) {
            return null;
        }
        String[] numbers = getNumbers(originalText);
        for (int i = 0; i < numbers.length; i++) {
            translatedText = translatedText.replace("<Num" + i + ">", numbers[i]);
        }
        return translatedText;
    }

    /*
     * Extracts numbers from the input string.
     * Numbers are sequences of digits.
     * For example, "Hello Asda123, how many 1s are there in 101?" returns ["123", "1", "101"]
     */
    private static String[] getNumbers(String input) {
        if(input == null){
            return null;
        }

        List<String> numbers = new ArrayList<>();
        StringBuilder currentNumber = new StringBuilder();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (c == '<') {
                for (int j = i + 1; j < input.length(); j++) {
                    if (input.charAt(j) == '>') {
                        i = j;
                        break;
                    }
                    // if the end of the string is reached, or letters between <> is longer than 15, consider '<' as a normal character
                    if (j == input.length() - 1 || j-i > 15){
                        break;
                    }
                }
            } else
            if (Character.isDigit(c)) {
                currentNumber.append(c);
            } else if ((c == '.' || c == ',') && currentNumber.length() > 0 && i < input.length() - 1 && Character.isDigit(input.charAt(i + 1))) {
                // Append the decimal point if the number is a decimal number or a large number
                currentNumber.append(c);
            } else {
                if (currentNumber.length() > 0) {
                    numbers.add(currentNumber.toString());
                    currentNumber = new StringBuilder();
                }
            }
        }

        if (currentNumber.length() > 0) {
            numbers.add(currentNumber.toString());
        }

        return numbers.toArray(new String[0]);
    }

}

package com.RuneLingual.MouseOverlays;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.MenuCapture;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableSet;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.*;
import javax.inject.Inject;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import static java.lang.Thread.sleep;

/*
 * Copyright (c) 2017, Aria <aria@ar1as.space>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
@Slf4j
public class MouseTooltipOverlay extends Overlay
{

    /**
     * Menu types which are on widgets.
     */
    private static final Set<MenuAction> WIDGET_MENU_ACTIONS = ImmutableSet.of(
            MenuAction.WIDGET_TYPE_1,
            MenuAction.WIDGET_TARGET,
            MenuAction.WIDGET_CLOSE,
            MenuAction.WIDGET_TYPE_4,
            MenuAction.WIDGET_TYPE_5,
            MenuAction.WIDGET_CONTINUE,
            MenuAction.ITEM_USE_ON_ITEM,
            MenuAction.WIDGET_USE_ON_ITEM,
            MenuAction.ITEM_FIRST_OPTION,
            MenuAction.ITEM_SECOND_OPTION,
            MenuAction.ITEM_THIRD_OPTION,
            MenuAction.ITEM_FOURTH_OPTION,
            MenuAction.ITEM_FIFTH_OPTION,
            MenuAction.ITEM_USE,
            MenuAction.WIDGET_FIRST_OPTION,
            MenuAction.WIDGET_SECOND_OPTION,
            MenuAction.WIDGET_THIRD_OPTION,
            MenuAction.WIDGET_FOURTH_OPTION,
            MenuAction.WIDGET_FIFTH_OPTION,
            MenuAction.EXAMINE_ITEM,
            MenuAction.WIDGET_TARGET_ON_WIDGET,
            MenuAction.CC_OP_LOW_PRIORITY,
            MenuAction.CC_OP
    );

    private final TooltipManager tooltipManager;
    private final Client client;
    private final RuneLingualConfig config;
    @Inject
    private RuneLingualPlugin plugin;
    @Setter
    private static List<String> attemptedTranslation = Collections.synchronizedList(new ArrayList<>());

    @Inject
    MouseTooltipOverlay(Client client, TooltipManager tooltipManager, RuneLingualConfig config, RuneLingualPlugin plugin)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        // additionally allow tooltips above the full screen world map and welcome screen
        drawAfterInterface(InterfaceID.FULLSCREEN_CONTAINER_TLI);
        this.client = client;
        this.tooltipManager = tooltipManager;
        this.config = config;
        this.plugin = plugin;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (client.isMenuOpen() || plugin.getTargetLanguage() == LangCodeSelectableList.ENGLISH)
        {
            return null;
        }

        MenuEntry[] menuEntries = client.getMenuEntries();
        int last = menuEntries.length - 1;

        if (last < 0)
        {
            return null;
        }

        MenuEntry menuEntry = menuEntries[last];
        String target = menuEntry.getTarget();
        String option = menuEntry.getOption();
        MenuAction type = menuEntry.getType();

        if (!isNecessaryMenu(type, option, target))
        {
            return null;
        }

        // if is set to be translated with API,
        if(this.plugin.getConfig().ApiConfig()){
            // only translate if it has been translated before
            if(plugin.getDeepl().getDeeplPastTranslationManager().haveTranslatedMenuBefore(option, target, menuEntry)) {
                setMouseHover(menuEntry, true);
            } else { // dont translate if it hasnt been translated before
                setMouseHover(menuEntry, false);
                return null;
            }
        } else {
            // translate with local data if not set to use API
            setMouseHover(menuEntry, true);
            return null;
        }
        return null;
    }





    private void setMouseHover(MenuEntry menuEntry, boolean transform){
        String newTarget = "";
        String newOption = "";

        MenuCapture menuCapture = this.plugin.getMenuCapture();
        // if set not to transform, add the current target and option
        if (!transform){
            tooltipManager.addFront(new Tooltip(menuEntry.getOption() + (Strings.isNullOrEmpty(menuEntry.getTarget()) ? "" : " " + menuEntry.getTarget())));
            return;
        }

        //otherwise translate the target and option
        String[] newMenus = menuCapture.translateMenuAction(menuEntry);
        if (newMenus != null)
        {
            newTarget = newMenus[0];
            newOption = newMenus[1];
        }
        if (this.plugin.getTargetLanguage().needsSwapMenuOptionAndTarget())
        {
            tooltipManager.addFront(new Tooltip((Strings.isNullOrEmpty(newTarget) ? newOption : newTarget + " " + newOption)));
            return;
        }
        tooltipManager.addFront(new Tooltip(newOption + (Strings.isNullOrEmpty(newTarget) ? "" : " " + newTarget)));
    }


    private boolean isNecessaryMenu(MenuAction type, String option, String target)
    {
        if (type == MenuAction.RUNELITE_OVERLAY || type == MenuAction.CC_OP_LOW_PRIORITY)
        {
            // These are always right click only
            return false;
        }

        if (Strings.isNullOrEmpty(option))
        {
            return false;
        }

//        // Trivial options that don't need to be highlighted, add more as they appear.
        if (option.equals("Walk here") || option.equals("Cancel") || option.equals("Continue") || target.contains("Slide"))
            return false;
        if (!config.getMouseHoverConfig())
        {
            return false;
        }


        // If this varc is set, a tooltip will be displayed soon
        int tooltipTimeout = client.getVarcIntValue(VarClientInt.TOOLTIP_TIMEOUT);
        if (tooltipTimeout > client.getGameCycle())
        {
            return false;
        }

        // If this varc is set, a tooltip is already being displayed
        int tooltipDisplayed = client.getVarcIntValue(VarClientInt.TOOLTIP_VISIBLE);
        if (tooltipDisplayed == 1)
        {
            return false;
        }
        return true;
    }
}

package com.RuneLingual.MouseOverlays;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.MenuCapture;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableSet;

import java.awt.*;
import java.awt.Point;
import java.util.*;
import java.util.List;
import javax.inject.Inject;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.BackgroundComponent;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import static java.lang.Thread.sleep;

@Slf4j
public class MenuEntryHighlightOverlay extends Overlay {
    private final Client client;
    private final RuneLingualConfig config;
    private final PanelComponent panelComponent = new PanelComponent();
    @Inject
    private RuneLingualPlugin plugin;
    @Setter
    private static List<String> attemptedTranslation = Collections.synchronizedList(new ArrayList<>());

    @Inject
    public MenuEntryHighlightOverlay(Client client, RuneLingualConfig config) {
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
    }

    // draw transparent square around the menu entry that is currently hovered over
    // only draw if the menu is open and the selected language needs character images
    @Override
    public Dimension render(Graphics2D graphics) {
//        if (!client.isMenuOpen() || !plugin.getTargetLanguage().needsCharImages() || plugin.getTargetLanguage() == LangCodeSelectableList.ENGLISH) {
//            return null;
//        }
//
//        // get the x, y, width of the menu
//        int x = client.getMenu().getMenuX();
//        int y = client.getMenu().getMenuY();
//        int width = client.getMenu().getMenuWidth();
//        log.info("Menu X: {}, Y: {}, Width: {}", x, y, width);
//        panelComponent.getChildren().clear();
//        panelComponent.setPreferredLocation(new Point(x, y));
//        panelComponent.setPreferredSize(new Dimension(width,100));
//        Color bgColor = new Color(127, 82, 33);
//        Rectangle rectangle = new Rectangle(
//                x,
//                y,
//                width,
//                100
//        );
//        BackgroundComponent backgroundComponent = new BackgroundComponent(
//                bgColor,
//                rectangle,
//                true
//        );
//        backgroundComponent.render(graphics);
        return null;
    }
}
package com.RuneLingual.ChatMessages;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.annotation.ParametersAreNonnullByDefault;
import javax.inject.Inject;
import java.awt.*;

@Slf4j
@ParametersAreNonnullByDefault
public class ChatInputCandidateOverlay extends Overlay
{
    @Inject
    private PlayerMessage playerMessage;
    private Client client;
    private RuneLingualPlugin plugin;
    private final PanelComponent panelComponent = new PanelComponent();
    private int[] ovlPos;
    private int inputWidth = 400;
    private int foreignCharSize; // px width of each japanese characters
    private int enCharSize = 8;
    private final int candListMax = 7;//max vert number of words


    @Inject
    public ChatInputCandidateOverlay(Client client, RuneLingualPlugin plugin) {
        setPosition(OverlayPosition.BOTTOM_LEFT);
        this.client = client;
        this.plugin = plugin;
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if(!plugin.getConfig().getSelectedLanguage().needsInputCandidateOverlay()){
            return null;
        }

        foreignCharSize = plugin.getConfig().getSelectedLanguage().getOverlayCharWidth() + 1;

        String[] nonLatinMsg = {};
        
        if(plugin.getConfig().getSelectedLanguage().equals(LangCodeSelectableList.日本語)){
            nonLatinMsg = plugin.getChatInputRLingual().getUpdateChatInputJa().getKanjKatCandidates().toArray(new String[0]);
        }

        int candSelectN = plugin.getChatInputRLingual().getUpdateChatInputJa().getInstCandidateSelection();
        int msgCount = plugin.getChatInputRLingual().getUpdateChatInputJa().getInputCount();

        if (msgCount == 0
                || playerMessage.getTranslationOption().equals(Transformer.TransformOption.AS_IS)
                || nonLatinMsg.length == 0) return null;// todo:also this if in npc dialogue
        if (nonLatinMsg.length == 1 && nonLatinMsg[0].matches("[^\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+")) return  null;

        
        
        panelComponent.getChildren().clear();
        int panelN = nonLatinMsg.length/candListMax + 1;

        Color bgColor = new Color(127, 82, 33);
        panelComponent.setBackgroundColor(bgColor);

        int[] panelWordLen = new int[panelN];
        int panelWidth = 0;
        for (int j = 0; j < panelN; j++) {
            for(int i = 0; i < candListMax && i + j * candListMax < nonLatinMsg.length; i++) {
                if (nonLatinMsg[i + j * candListMax].length() > panelWordLen[j]) {
                    String word = nonLatinMsg[i + j * candListMax].split("\\d")[0];
                    panelWordLen[j] = word.length();
                }
            }
            panelWidth += panelWordLen[j] * foreignCharSize;
        }
        panelWidth += foreignCharSize *panelN + enCharSize*3*panelN + enCharSize*2*(panelN-1);
        //if (panelN > 1)
        //   panelWidth += japCharSize*(panelN-1);
        for(int i = 0; i < candListMax; i++) {
            StringBuilder jp = new StringBuilder();
            String numbering;

            for (int j = 0; j < panelN; j++) {
                if (i + j * candListMax == candSelectN)
                    jp.append("<col=00ffff>");
                else
                    jp.append("<col=ffffff>");

                if (i + j * candListMax < nonLatinMsg.length) {
                    numbering = Integer.toString(i + j * candListMax) + "  ";
                    if (i+j*candListMax < 10)
                        numbering = " " + numbering;
//                    if (i + j * candListMax == candSelectN)
//                        numbering = "＞" + numbering;
//                    else
//                        numbering = "＿" + numbering;
                    if (j > 0) {
                        jp.append("　");

                    }
                    jp.append(numbering);

                    String word = nonLatinMsg[i + j * candListMax].split("\\d")[0];
                    jp.append(word);

                    int w = panelWordLen[j] - nonLatinMsg[i + j * candListMax].length();
                    jp.append("　".repeat(Math.max(0, w)));
                }
            }
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(jp.toString().trim())
                    .build());
        }
        // Set the size of the overlay
        panelComponent.setPreferredSize(new Dimension(panelWidth,0));
        return panelComponent.render(graphics);
    }

    private int getLen(String str) {
        return str.length()*14;
    }

    private String[] splitMsg(String string) {//splits message into 2, first with length of chat input width, second (and third if needed) with remaining
        String[] ret = {
                string.substring(0, string.length() / 2),  // First half
                string.substring(string.length() / 2)       // Second half
        };
        return ret;
    }

    public static String toFullWidth(String input) {
        StringBuilder fullWidthForm = new StringBuilder();
        for (char c : input.toCharArray()) {
            if (c >= '0' && c <= '9') { // 半角数字の範囲をチェック
                fullWidthForm.append((char) (c - '0' + '０')); // '０' は全角の '0'
            } else {
                fullWidthForm.append(c); // 数字以外はそのまま追加
            }
        }
        return fullWidthForm.toString();
    }
}


package com.RuneLingual.ChatMessages;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.annotation.ParametersAreNonnullByDefault;
import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@ParametersAreNonnullByDefault
public class ChatInputOverlay extends Overlay //remove abstract when actually making overlays with this
{
    @Inject
    private Client client;
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private PlayerMessage playerMessage;
    private final PanelComponent panelComponent = new PanelComponent();
    private int[] ovlPos;
    private int paddingWidth = 55;
    private int inputWidth = 400 - paddingWidth; // 400 for the whole width, 52 for the padding and the char count
    private int foreignCharSize; // px width of each japanese characters
    private int enCharSize = 8;

    @Inject
    public ChatInputOverlay(Client client, RuneLingualPlugin plugin) {
        setPosition(OverlayPosition.BOTTOM_LEFT);
        this.client = client;
        this.plugin = plugin;
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if(!plugin.getConfig().getSelectedLanguage().needsInputOverlay()){
            return null;
        }

        foreignCharSize = plugin.getConfig().getSelectedLanguage().getOverlayCharWidth() + 1;


        int msgLength = playerMessage.getChatInputString().length();
        String nonLatinMsg = "";

        if(plugin.getConfig().getSelectedLanguage().equals(LangCodeSelectableList.日本語)){
            nonLatinMsg = plugin.getChatInputRLingual().getUpdateChatInputJa().getChatJpMsg();
        } // TODO: add more languages that need this overlay


        if (msgLength == 0
                || playerMessage.getTranslationOption().equals(Transformer.TransformOption.AS_IS)
                || nonLatinMsg.trim().isEmpty()) return null; // todo:also this if in npc dialogue

        int latingCharCount = countLatinCharacters(nonLatinMsg);
        int foreignCharCount = nonLatinMsg.length() - latingCharCount;

        panelComponent.getChildren().clear();

        // Set the size of the overlay
        int currentInputSize = foreignCharSize*(foreignCharCount)+enCharSize*latingCharCount;
        panelComponent.setPreferredSize(new Dimension(Math.min( currentInputSize + paddingWidth, inputWidth + paddingWidth),0));

        Color bgColor = new Color(127, 82, 33);
        panelComponent.setBackgroundColor(bgColor);

        if(foreignCharSize*foreignCharCount + enCharSize*latingCharCount > inputWidth) {
            String[] newMsgs = splitMsg(nonLatinMsg);
            for (int i = 0;i < newMsgs.length; i++) {
                if (i == newMsgs.length - 1) {
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left(newMsgs[i])
                            .right("(" + msgLength + "/80)")
                            .build());
                } else {
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left(newMsgs[i])
                            .build());
                }
            }
        } else {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(nonLatinMsg)
                    .right(" (" + msgLength + "/80)")
                    .build());
        }
        return panelComponent.render(graphics);
    }

public int countLatinCharacters(String str) {
    int count = 0;
    for (char c : str.toCharArray()) {
        if ((Character.isLetter(c) && Character.UnicodeBlock.of(c) == Character.UnicodeBlock.BASIC_LATIN)
                || c == ',' || c == '.' || c == '!' || c == '?' || c == ' ' || c == '\'' || c == '\"'
                || c == '(' || c == ')' || c == ':' || c == ';' || c == '-') {
            count++;
        }
    }
    return count;
}

    private int getLen(String str) {
        return str.length()*foreignCharSize;
    }

    private String[] splitMsg(String str) {//splits message
        List<String> lines = new ArrayList<>();
        int lineLength = 0;
        StringBuilder line = new StringBuilder();
        StringBuilder enWord = new StringBuilder();

        for(int i = 0; i < str.length(); i++){
            if(!isJapaneseChar(str.charAt(i))) { // make sure it doesnt go to new line in the middle of an English word
                if (str.charAt(i) != ' ') {
                    enWord.append(str.charAt(i));
                } else { // if it's a space
                    if (lineLength + enWord.length()*enCharSize  >= inputWidth) { // if adding the word would go over the width
                        lines.add(line.toString()); // add the current line to the list
                        line = enWord.append(" "); // start a new line with the word
                        lineLength = enWord.length()*(enCharSize); // set the length to the length of the word
                        enWord = new StringBuilder(); // reset the word
                    } else {
                        line.append(enWord).append(" ");
                        lineLength += enCharSize*enWord.length();
                        enWord = new StringBuilder();

                    }
                }
            } else {
                enWord = new StringBuilder();
                if (lineLength + foreignCharSize>= inputWidth) {
                    lines.add(line.toString());
                    line = new StringBuilder();
                    line.append(str.charAt(i));
                    lineLength = foreignCharSize;
                } else {
                    line.append(str.charAt(i));
                    lineLength += foreignCharSize;
                }
            }
        }
        if(lineLength > inputWidth){
            lines.add(line.toString());
            line = new StringBuilder();
        } else if(lineLength + enWord.length()*enCharSize > inputWidth) {
            lines.add(line.toString());
            line = new StringBuilder();
        }
        line.append(enWord);
        lines.add(line.toString());
        return lines.toArray(new String[0]);
    }

    public boolean isLatinChar(char c) {
        if (Character.UnicodeBlock.of(c) == Character.UnicodeBlock.BASIC_LATIN
                || c == ',' || c == '.' || c == '!' || c == '?' || c == ' ' || c == '\'' || c == '\"'
                || c == '(' || c == ')' || c == ':' || c == ';' || c == '-'
                || c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6'
                || c == '7' || c == '8' || c == '9') {
            return true;
        } else
            return false;
    }

    public boolean isJapaneseChar(char c) {
        Character.UnicodeBlock block = Character.UnicodeBlock.of(c);

        return block == Character.UnicodeBlock.HIRAGANA
                || block == Character.UnicodeBlock.KATAKANA
                || block == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS
                || block == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION
                || block == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS
                || block == Character.UnicodeBlock.KATAKANA_PHONETIC_EXTENSIONS;
    }
}

package com.RuneLingual.ChatMessages;


import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.nonLatin.Japanese.UpdateChatInputJa;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;

@Slf4j
public class ChatInputRLingual {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject @Getter
    private UpdateChatInputJa updateChatInputJa;

    @Inject
    public ChatInputRLingual(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    public void updateChatInput() { // to update input and candidate overlay
        if (plugin.getConfig().getSelectedLanguage().needsCharImages()){
            if(plugin.getConfig().getSelectedLanguage().equals(LangCodeSelectableList.日本語)){
                updateChatInputJa.updateInput();
            }
        }
    }

    public String transformChatText(String text) { // example: "konnnitiha" -> "こんにちは"
        if (plugin.getConfig().getSelectedLanguage().needsCharImages()){
            if(plugin.getConfig().getSelectedLanguage().equals(LangCodeSelectableList.日本語)){
                return updateChatInputJa.romJpTransform(text, false);
            }
        }
        return text;
    }
}

package com.RuneLingual.ChatMessages;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.clan.ClanChannel;

import javax.inject.Inject;

@Slf4j
public class PlayerMessage {
    @Inject
    Client client;
    @Inject
    RuneLingualConfig config;
    @Inject
    RuneLingualPlugin plugin;
    @Inject
    ChatCapture chatCapture;

    @Inject
    public PlayerMessage(Client client, RuneLingualConfig config, RuneLingualPlugin plugin){
        this.plugin = plugin;
        this.client = plugin.getClient();
        this.config = plugin.getConfig();
        this.chatCapture = plugin.getChatCapture();
    }

    public enum talkingIn {
        PUBLIC,
        CHANNEL,
        CLAN,
        GUEST_CLAN,
        GIM,
        NONE
    }

    public Transformer.TransformOption getTranslationOption(){
        talkingIn talkingIn = getTalkingIn();
        if(talkingIn == PlayerMessage.talkingIn.PUBLIC){
            return getMyChatConfig(config.getMyPublicConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.CHANNEL){
            return getMyChatConfig(config.getMyFcConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.CLAN){
            return getMyChatConfig(config.getMyClanConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.GUEST_CLAN){
            return getMyChatConfig(config.getMyGuestClanConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.GIM){
            return getMyChatConfig(config.getMyGIMConfig());
        }
        if(talkingIn == PlayerMessage.talkingIn.NONE){
            return Transformer.TransformOption.AS_IS;
        }
        return Transformer.TransformOption.AS_IS;
    }

    public talkingIn getTalkingIn() {

        ChatCapture.openChatbox chatbox = chatCapture.getOpenChatbox();
        ChatCapture.chatModes chatMode = chatCapture.getChatMode();

        if(chatbox == ChatCapture.openChatbox.CLOSED) {
            return talkingIn.NONE;
        }

        // check the chat box for chat code, such as /// and /g etc
        if(typedPublicCode()){
            return talkingIn.PUBLIC;
        }

        if(typedFriendsChannelCode()){
            if(joinedFC())
                return talkingIn.CHANNEL;
            else
                return talkingIn.PUBLIC;
        }

        if(typedClanCode()){
            if(joinedClan()){
                if(joinedGIM())
                    return talkingIn.GIM;
                else
                    return talkingIn.CLAN;
            } else {
                return talkingIn.NONE;
            }
        }

        if(typedGuestClanCode()){
            if(joinedGuestClan())
                return talkingIn.GUEST_CLAN;
            else
                return talkingIn.NONE;
        }

        if(typedGimCode()){
            if(joinedGIM())
                return talkingIn.GIM;
            else {
                if(getChatInputString().startsWith("////")){
                    if(joinedGuestClan())
                        return talkingIn.GUEST_CLAN;
                    else
                        return talkingIn.NONE;
                }
                else if(getChatInputString().startsWith("/g"))
                    return talkingIn.PUBLIC;
                else if(getChatInputString().startsWith("@g")){
                    if(joinedClan())
                        return talkingIn.CLAN;
                    else
                        return talkingIn.NONE;
                }
            }
        }

        // if no chat code is found
        if(chatMode == ChatCapture.chatModes.PUBLIC) {
            if (chatbox == ChatCapture.openChatbox.ALL
                    || chatbox == ChatCapture.openChatbox.GAME
                    || chatbox == ChatCapture.openChatbox.PUBLIC
                    || chatbox == ChatCapture.openChatbox.PRIVATE) {
                return talkingIn.PUBLIC;
            }

            // if friends chat tab is opened
            if (chatbox == ChatCapture.openChatbox.CHANNEL) {
                if(joinedFC())
                    return talkingIn.CHANNEL;
                else
                    return talkingIn.PUBLIC;
            }

            // if clan chat tab is opened
            if (chatbox == ChatCapture.openChatbox.CLAN) {
                if(joinedClan())
                    return talkingIn.CLAN;
                else
                    return talkingIn.PUBLIC;
            }

            // if trade or gim tab is opened
            if (chatbox == ChatCapture.openChatbox.TRADE_GIM) {
                if(joinedGIM())
                    return talkingIn.GIM;
                else
                    return talkingIn.PUBLIC;
            }

        }
        else if(chatMode == ChatCapture.chatModes.CHANNEL){
            if(!joinedFC()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE) {
                    return talkingIn.NONE;
                }
                if(chatbox == ChatCapture.openChatbox.CHANNEL){
                    return talkingIn.PUBLIC;
                }

                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }

                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.NONE;
                }
            }
            if(joinedFC()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE
                        || chatbox == ChatCapture.openChatbox.CHANNEL) {
                    return talkingIn.CHANNEL;
                }

                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }

                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.CHANNEL;
                }
            }
        }
        else if(chatMode == ChatCapture.chatModes.CLAN){
            if(!joinedClan()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE
                        || chatbox == ChatCapture.openChatbox.CLAN) {
                    return talkingIn.NONE;
                }

                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.NONE;
                }

            }
            if(joinedClan()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE
                        || chatbox == ChatCapture.openChatbox.CLAN) {
                    return talkingIn.CLAN;
                }

                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.CLAN;
                }

            }
        }
        else if(chatMode == ChatCapture.chatModes.GUEST_CLAN){
            if(!joinedGuestClan()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE) {
                    return talkingIn.NONE;
                }

                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }
                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.NONE;
                }

            }
            if(joinedGuestClan()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE) {
                    return talkingIn.GUEST_CLAN;
                }
                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }
                if(chatbox == ChatCapture.openChatbox.TRADE_GIM && joinedGIM()){
                    return talkingIn.GIM;
                } else if(chatbox == ChatCapture.openChatbox.TRADE_GIM && !joinedGIM()){
                    return talkingIn.GUEST_CLAN;
                }
            }
        }
        else if(chatMode == ChatCapture.chatModes.GROUP){
            if(!joinedGIM()) {
                // this shouldn't even happen, but to be safe
                return talkingIn.NONE;
            }
            if(joinedGIM()){
                if(chatbox == ChatCapture.openChatbox.ALL
                        || chatbox == ChatCapture.openChatbox.GAME
                        || chatbox == ChatCapture.openChatbox.PUBLIC
                        || chatbox == ChatCapture.openChatbox.PRIVATE
                        || chatbox == ChatCapture.openChatbox.TRADE_GIM) {
                    return talkingIn.GIM;
                }
                if(chatbox == ChatCapture.openChatbox.CHANNEL && joinedFC()){
                    return talkingIn.CHANNEL;
                } else if(chatbox == ChatCapture.openChatbox.CHANNEL && !joinedFC()){
                    return talkingIn.PUBLIC;
                }
                if(chatbox == ChatCapture.openChatbox.CLAN && joinedClan()){
                    return talkingIn.CLAN;
                } else if(chatbox == ChatCapture.openChatbox.CLAN && !joinedClan()){
                    return talkingIn.NONE;
                }
            }
        }
        //log.info("warning: no chat mode found");
        return  talkingIn.NONE;
    }

    private boolean joinedFC(){
        FriendsChatManager fc = client.getFriendsChatManager();
        return fc != null;
    }

    private boolean joinedClan() {
        ClanChannel clan = client.getClanChannel();
        return clan != null;
    }

    private boolean joinedGIM() {
        int account_type = client.getVarbitValue(Varbits.ACCOUNT_TYPE);
        return account_type == 4 || account_type == 5 || account_type == 6;
    }

    private boolean joinedGuestClan() {
        ClanChannel guestClan = client.getGuestClanChannel();
        return guestClan != null;
    }


    private boolean typedPublicCode() {
        if(getChatInputString().startsWith("/@p"))
            return true;
        return false;
    }

    private boolean typedFriendsChannelCode() {
        if((getChatInputString().startsWith("/") && !getChatInputString().startsWith("//")
                && !getChatInputString().startsWith("/c ") && !getChatInputString().startsWith("/@c")
                && !getChatInputString().startsWith("/gc ") && !getChatInputString().startsWith("/@gc")
                && !getChatInputString().startsWith("/g ") && !getChatInputString().startsWith("/@g")
                && !getChatInputString().startsWith("/@p"))
                || getChatInputString().startsWith("/@f"))
            return true;
        return false;
    }
    private boolean typedClanCode() {
        if((getChatInputString().startsWith("//") && !getChatInputString().startsWith("///"))
                || getChatInputString().startsWith("/c ")
                || getChatInputString().startsWith("/@c"))
            return true;
        return false;
    }
    private boolean typedGuestClanCode() {
        if((getChatInputString().startsWith("///") && !getChatInputString().startsWith("////"))
                || getChatInputString().startsWith("/gc ")
                || getChatInputString().startsWith("/@gc"))
            return true;
        return false;
    }
    private boolean typedGimCode() {
        if(getChatInputString().startsWith("////")
                || getChatInputString().startsWith("/g ")
                || (getChatInputString().startsWith("/@g") && !getChatInputString().startsWith("/@gc")) )
            return true;
        return false;
    }

    public String getChatInputString(){
        return client.getVarcStrValue(VarClientStr.CHATBOX_TYPED_TEXT);
    }

    public Transformer.TransformOption getMyChatConfig(RuneLingualConfig.chatSelfConfig config) {
        if(config == RuneLingualConfig.chatSelfConfig.LEAVE_AS_IS){
            return Transformer.TransformOption.AS_IS;
        }
        if(config == RuneLingualConfig.chatSelfConfig.TRANSFORM){
            return Transformer.TransformOption.TRANSFORM;
        }
        return  Transformer.TransformOption.AS_IS;
    }
}

package com.RuneLingual.ChatMessages;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.SQL.SqlQuery;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.commonFunctions.Transformer.TransformOption;
import com.RuneLingual.ChatMessages.ChatCapture;
import com.RuneLingual.RuneLingualConfig;

import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.client.game.ChatIconManager;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;


public class OverheadCapture {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private Client client;
    @Inject
    private PlayerMessage playerMessage;
    @Inject
    Transformer transformer;
    @Getter
    private Set<Pair<OverheadTextChanged, Long>> pendingOverheadTranslations = new HashSet<>();


    @Inject
    public OverheadCapture(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    public void translateOverhead(OverheadTextChanged event) throws Exception {
        String enMsg = event.getOverheadText();
        Actor actor = event.getActor();

        String name;
        if (actor.getName() != null) {
            name = Colors.removeAllTags(actor.getName());
        } else {
            name = null;
        }

        TransformOption option = getOverheadOption(actor);
        if(option == TransformOption.AS_IS)
            return;

        if (option == TransformOption.TRANSLATE_API) {
            String pastTranslation = plugin.getDeepl().getDeeplPastTranslationManager().getPastTranslation(enMsg);
            if(pastTranslation != null) { // have translated before
                String textToDisplay = strToYellowDisplayStr(pastTranslation);
                event.getActor().setOverheadText(textToDisplay);
            } else { // never translated before
                translateOverheadWithApi(event, enMsg);
            }
        }
        else if (option == TransformOption.TRANSFORM) {
            String japaneseMsg = plugin.getChatInputRLingual().transformChatText(enMsg);
            String textToDisplay = strToYellowDisplayStr(japaneseMsg);
            event.getActor().setOverheadText(textToDisplay);
        }
        else if (option == TransformOption.TRANSLATE_LOCAL) {// todo: would need to test this
            SqlQuery dialogueQuery = new SqlQuery(plugin);
            dialogueQuery.setDialogue(enMsg, name, false , Colors.yellow);
            String localTranslation = transformer.transform(enMsg, TransformOption.TRANSLATE_LOCAL, dialogueQuery,Colors.yellow, false);
            event.getActor().setOverheadText(localTranslation);
        }
    }

    private void translateOverheadWithApi(OverheadTextChanged event, String enMsg) {
        String apiTranslation = plugin.getDeepl().translate(Colors.removeAllTags(enMsg),
                                    LangCodeSelectableList.ENGLISH,
                                    plugin.getConfig().getSelectedLanguage());
        if(apiTranslation.equals(enMsg)) {// it is pending for api translation
            pendingOverheadTranslations.add(Pair.of(event, System.currentTimeMillis() + 10*1000)); // times out in 10 seconds
            return;
        }
        String textToDisplay = strToYellowDisplayStr(apiTranslation);

        event.getActor().setOverheadText(textToDisplay);
    }

    private String strToYellowDisplayStr(String str){
        Transformer transformer = new Transformer(plugin);
        return transformer.stringToDisplayedString(str, Colors.yellow);
    }

    private TransformOption getOverheadOption(Actor actor){
        if (actor instanceof NPC || actor instanceof GameObject){//is overhead of NPC
            switch (plugin.getConfig().getNpcDialogueConfig()) {
                case DONT_TRANSLATE:
                    return TransformOption.AS_IS;
                case USE_LOCAL_DATA:
                    return TransformOption.TRANSLATE_LOCAL;
                case USE_API:
                    return TransformOption.TRANSLATE_API;
            }
        }
        String name = actor.getName();
        if(name != null) {
            name = Colors.removeAllTags(name);
            //the player is the local player
            if (name.equals(client.getLocalPlayer().getName())) {
                //return playerMessage.getTranslationOption();
                return getMatchingOption(plugin.getConfig().getMyPublicConfig());
            }

            // check inside forceful config setting
            if (plugin.getChatCapture().isInConfigList(name, plugin.getConfig().getSpecificDontTranslate()))
                return TransformOption.AS_IS;
            if (plugin.getChatCapture().isInConfigList(name, plugin.getConfig().getSpecificTransform()))
                return TransformOption.TRANSFORM;
            if (plugin.getChatCapture().isInConfigList(name, plugin.getConfig().getSpecificApiTranslate()))
                return TransformOption.TRANSLATE_API;

            // if its from a friend
//            if (client.isFriended(name, true)) {
//                return getMatchingOption(plugin.getConfig().getAllFriendsConfig());
//            }

            // if its not from local player nor a friend
            return getMatchingOption(plugin.getConfig().getPublicChatConfig());
        }
        return TransformOption.AS_IS;
    }

    private TransformOption getMatchingOption(RuneLingualConfig.chatSelfConfig configSelf){
        switch (configSelf) {
            case LEAVE_AS_IS:
                return TransformOption.AS_IS;
            case TRANSFORM:
                return TransformOption.TRANSFORM;
            default:
                return TransformOption.AS_IS;
        }
    }

    private TransformOption getMatchingOption(RuneLingualConfig.chatConfig config){
        switch (config) {
            case LEAVE_AS_IS:
                return TransformOption.AS_IS;
            case TRANSFORM:
                return TransformOption.TRANSFORM;
            case USE_API:
                return TransformOption.TRANSLATE_API;
            default:
                return TransformOption.AS_IS;
        }
    }

    public void handlePendingOverheadTranslations(){
        Set<Pair<OverheadTextChanged, Long>> toRemove = new HashSet<>();
        for(Pair<OverheadTextChanged, Long> pair : pendingOverheadTranslations){
            if(pair.getLeft().getActor() == null) {
                toRemove.add(pair);
                continue;
            }
            String currentText = pair.getLeft().getActor().getOverheadText();
            if(System.currentTimeMillis() > pair.getRight() // time out
            || currentText == null || currentText.isBlank()){ // overhead text is removed
                toRemove.add(pair);
                continue;
            }

            OverheadTextChanged event = pair.getLeft();
            String enMsg = event.getOverheadText();
            String apiTranslation = plugin.getDeepl().translate(Colors.removeAllTags(enMsg),
                    LangCodeSelectableList.ENGLISH,
                    plugin.getConfig().getSelectedLanguage());
            if(apiTranslation.equals(enMsg)) {// it is still pending for api translation
                return;
            }
            String textToDisplay = strToYellowDisplayStr(apiTranslation);
            event.getActor().setOverheadText(textToDisplay);
            toRemove.add(pair);
        }
        pendingOverheadTranslations.removeAll(toRemove);
    }
}

package com.RuneLingual.ChatMessages;

import com.RuneLingual.*;
import com.RuneLingual.ApiTranslate.Deepl;
import com.RuneLingual.SidePanelComponents.ChatBoxSection;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;

import javax.inject.Inject;

import lombok.Setter;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer.TransformOption;
import org.apache.commons.lang3.tuple.Pair;

@Slf4j
public class ChatCapture
{
    /* Captures chat messages from any source
    ignores npc dialog, as they are handled in DialogCapture*/
    
    @Inject
    private Client client;
    @Inject
    private RuneLingualConfig config;
    @Inject @Getter
    private RuneLingualPlugin plugin;
    @Inject
    private PlayerMessage playerMessage;
    @Inject
    private ChatColorManager chatColorManager;
    @Getter
    private Set<Pair<ChatMessage, Long>> pendingChatMessages = new HashSet<>(); // the untranslated message (by api) and time to expire

    
    @Inject
    ChatCapture(RuneLingualConfig config, Client client, RuneLingualPlugin plugin)
    {
        this.config = config;
        this.client = client;
        this.plugin = plugin;
    }

    public enum openChatbox{
        ALL,
        GAME,
        PUBLIC,
        PRIVATE,
        CHANNEL,
        CLAN,
        TRADE_GIM,
        CLOSED
    }

    public enum chatModes {
        PUBLIC,
        CHANNEL,
        CLAN,
        GUEST_CLAN,
        GROUP
    }


    public void handleChatMessage(ChatMessage chatMessage) throws Exception {
        ChatMessageType type = chatMessage.getType();
        MessageNode messageNode = chatMessage.getMessageNode();
        String message = chatMessage.getMessage();// e.g.<col=6800bf>Some cracks around the cave begin to ooze water.
        //log.info("Chat message received: " + message + " | type: " + type.toString() + " | name: " + chatMessage.getName());
        String name = chatMessage.getName(); // getName always returns player name
        TransformOption translationOption;

        switch (chatMessage.getType()) {
            case MESBOX: // dont support this, yet
            case DIALOG: // will be treated in dialogCapture
                return;
            default:
                translationOption = getTranslationOption(chatMessage);
        }

        //log.info("Translation option: " + translationOption.toString());
        chatColorManager.setMessageColor(chatMessage.getMessageNode().getType());
        switch (translationOption) {
            case AS_IS:
                return;
            case TRANSLATE_LOCAL:
                localTranslator(message, messageNode, chatMessage);
                break;
            case TRANSLATE_API:
                if(plugin.getConfig().ApiConfig())
                    onlineTranslator(message, messageNode, chatMessage);
                break;
            case TRANSFORM: // ex: konnnitiha -> こんにちは
                chatTransformer(message, messageNode, chatMessage);
                break;
        }

    }
    
    private void localTranslator(String message, MessageNode node, ChatMessage chatMessage)
    {
        // todo after adding transcripts for this type of message
        addMsgToSidePanel(chatMessage, message);
    }
    
    private void onlineTranslator(String message, MessageNode node, ChatMessage chatMessage)
    {
        if(plugin.getDeepl().getDeeplCount() + message.length() + 1000 > plugin.getDeepl().getDeeplLimit())
        {
            log.info("DeepL limit reached, cannot translate message.");
            return;
        }

        String translation = plugin.getDeepl().translate(message, LangCodeSelectableList.ENGLISH, config.getSelectedLanguage());

        // if the translation is the same as the original message, don't replace it
        if(translation.equals(message)){
            pendingChatMessages.add(Pair.of(chatMessage, System.currentTimeMillis()+30*1000));// it will timeout in 30 seconds
            return;
        }
        Transformer transformer = new Transformer(plugin);
        Colors textColor = chatColorManager.getMessageColor();
        String textToDisplay = transformer.stringToDisplayedString(translation, textColor);
        replaceChatMessage(textToDisplay, node);
        addMsgToSidePanel(chatMessage, translation);
    }

    private void chatTransformer(String message, MessageNode node, ChatMessage chatMessage) {
        String newMessage = plugin.getChatInputRLingual().transformChatText(message);
        Transformer transformer = new Transformer(plugin);
        Colors textColor = chatColorManager.getMessageColor();
        String textToDisplay = transformer.stringToDisplayedString(newMessage, textColor);
        replaceChatMessage(textToDisplay, node);
        addMsgToSidePanel(chatMessage, newMessage);
    }

    private void replaceChatMessage(String newMessage, MessageNode node) {
        if(plugin.getConfig().getSelectedLanguage().needsCharImages()) {
            newMessage = insertBr(newMessage, node);// inserts break line so messages are displayed in multiple lines if they are long
        }
        node.setRuneLiteFormatMessage(newMessage);
        this.client.refreshChat();
    }

    private void addMsgToSidePanel(ChatMessage chatMessage, String newMessage)
    {
        newMessage = Colors.removeAllTags(newMessage);

        String senderName = chatMessage.getName();
        senderName = Colors.removeAllTags(senderName);

        String messageToAdd = senderName.isEmpty() ? newMessage : senderName + ": " + newMessage;
        String chatType;
        ChatBoxSection chatBoxSection = plugin.getPanel().getChatBoxSection();
        switch (chatMessage.getType()) {
            case PUBLICCHAT:
                chatType = chatBoxSection.getTabNamePublic();
                break;
            case CLAN_CHAT:
            case CLAN_GUEST_CHAT:
                chatType = chatBoxSection.getTabNameClan();
                break;
            case FRIENDSCHAT:
                chatType = chatBoxSection.getTabNameChannel();
                break;
            case CLAN_GIM_CHAT:
                chatType = chatBoxSection.getTabNameGIM();
                break;
            default:
                chatType = chatBoxSection.getTabNameGame();
        }
        plugin.getPanel().getChatBoxSection().addSentenceToTab(chatType, messageToAdd);
    }

    private TransformOption getTranslationOption(ChatMessage chatMessage) {
        String playerName = Colors.removeAllTags(chatMessage.getName());
        if (isInConfigList(playerName, config.getSpecificDontTranslate()))
            return TransformOption.AS_IS;
        else if (isInConfigList(playerName, config.getSpecificApiTranslate()))
            return TransformOption.TRANSLATE_API;
        else if (isInConfigList(playerName, config.getSpecificTransform()))
            return TransformOption.TRANSFORM;

        boolean isLocalPlayer = Objects.equals(playerName, client.getLocalPlayer().getName());
        //if its by the player themselves
//        if (Objects.equals(playerName, client.getLocalPlayer().getName())) {
//            return playerMessage.getTranslationOption();
//        }

        // if its from a friend
//        boolean isFriend = client.isFriended(playerName,true);
//        if (isFriend && !isLocalPlayer) {
//            return getChatsChatConfig(config.getAllFriendsConfig());
//        }
        switch (chatMessage.getType()){
            case PUBLICCHAT:
                if(isLocalPlayer)
                    return getChatsChatConfig(config.getMyPublicConfig());
                else
                    return getChatsChatConfig(config.getPublicChatConfig());
            case CLAN_CHAT:
                if(isLocalPlayer)
                    return getChatsChatConfig(config.getMyClanConfig());
                else
                    return getChatsChatConfig(config.getClanChatConfig());
            case CLAN_GUEST_CHAT:
                if(isLocalPlayer)
                    return getChatsChatConfig(config.getMyGuestClanConfig());
                else
                    return getChatsChatConfig(config.getGuestClanChatConfig());
            case FRIENDSCHAT:
                if(isLocalPlayer)
                    return getChatsChatConfig(config.getMyFcConfig());
                else
                    return getChatsChatConfig(config.getFriendsChatConfig());
            case CLAN_GIM_CHAT:
                if (!Objects.equals(playerName, "null") && !playerName.isEmpty())
                    if(isLocalPlayer)
                        return getChatsChatConfig(config.getMyGIMConfig());
                    else
                        return getChatsChatConfig(config.getGIMChatConfig());

            default://if its examine, engine, etc
                switch (config.getGameMessagesConfig()) {
                    case DONT_TRANSLATE:
                        return TransformOption.AS_IS;
                    case USE_LOCAL_DATA:
                        return TransformOption.TRANSLATE_LOCAL;
                    case USE_API:
                        return TransformOption.TRANSLATE_API;
                }
        }
        return TransformOption.AS_IS;
    }


    public TransformOption getChatsChatConfig(RuneLingualConfig.chatConfig chatConfig) {
        switch (chatConfig) {
            case TRANSFORM:
                return TransformOption.TRANSFORM;
            case LEAVE_AS_IS:
                return TransformOption.AS_IS;
            case USE_API:
                return TransformOption.TRANSLATE_API;
            default:
                switch (config.getGameMessagesConfig()) {
                    case USE_API:
                        return TransformOption.TRANSLATE_API;
                    case USE_LOCAL_DATA:
                        return TransformOption.TRANSLATE_LOCAL;
                    default:
                        return TransformOption.AS_IS;
                }
        }
    }

    public TransformOption getChatsChatConfig(RuneLingualConfig.chatSelfConfig chatConfig) {
        switch (chatConfig) {
            case TRANSFORM:
                return TransformOption.TRANSFORM;
            case LEAVE_AS_IS:
                return TransformOption.AS_IS;
            default:
                return TransformOption.AS_IS;
        }
    }



    public boolean isInConfigList(String item, String arrayInString) {
        String[] array = arrayInString.split("[,、\n]");
        for (String s:array)
            if (item.equals(s.trim()))
                return true;
        return false;
    }

    public ChatCapture.openChatbox getOpenChatbox() {
        int chatboxVarbitValue = client.getVarcIntValue(41);
        switch (chatboxVarbitValue) {
            case 0:
                return ChatCapture.openChatbox.ALL;
            case 1:
                return ChatCapture.openChatbox.GAME;
            case 2:
                return ChatCapture.openChatbox.PUBLIC;
            case 3:
                return ChatCapture.openChatbox.PRIVATE;
            case 4:
                return ChatCapture.openChatbox.CHANNEL;
            case 5:
                return ChatCapture.openChatbox.CLAN;
            case 6:
                return ChatCapture.openChatbox.TRADE_GIM;
            case 1337:
                return ChatCapture.openChatbox.CLOSED;
            default:
                log.info("Chatbox not found, defaulting to all");
                return ChatCapture.openChatbox.ALL;
        }
    }

    public chatModes getChatMode() {
        int forceSendVarbitValue = client.getVarcIntValue(945);
        switch(forceSendVarbitValue) {
            case 0:
                return chatModes.PUBLIC;
            case 1:
                return chatModes.CHANNEL;
            case 2:
                return chatModes.CLAN;
            case 3:
                return chatModes.GUEST_CLAN;
            case 4:
                return chatModes.GROUP;
            default:
                log.info("Chat mode not found, defaulting to public");
                return chatModes.PUBLIC;
        }
    }
    private String insertBr(String str, MessageNode messageNode) {
        String name = messageNode.getName();
        String chatName = messageNode.getSender();
        int nameCharCount = replaceTagWithAA(name).length()+2; // swap out IM icons to make it easier to count. +2 because of ": " after name
        int chatNameCount = (chatName == null ? 0:chatName.length()+4); //+2 because of [] brackets
        int enCharCount = nameCharCount + chatNameCount + 8; //+8 because timestamp is probably on
        double enWidth = LangCodeSelectableList.ENGLISH.getChatBoxCharWidth(); //width of 1 en character
        double foreignWidth = plugin.getConfig().getSelectedLanguage().getChatBoxCharWidth(); //width of 1 <img=> character
        int chatWidth = 485;
        int width = chatWidth - (int) (enCharCount*enWidth+2); //-2 just to be safe

        String regex = "(<img=\\d+>)|.";
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(str);

        StringBuilder stringBuilder = new StringBuilder();
        double wLeft = width;
        while(matcher.find()){
            String c = matcher.group();
            if (c.matches("<img=\\d+>"))
                wLeft -= foreignWidth;
            else
                wLeft -= enWidth;
            if (wLeft - foreignWidth < 0){
                wLeft = width;
                stringBuilder.append("<br>");
                stringBuilder.append(c);
            } else {
                stringBuilder.append(c);
            }
        }
        return stringBuilder.toString();
    }

    private String replaceTagWithAA (String string){ //"<img=41>sand in sand" into "11sand in sand" for easy counting
        return string.replaceAll("<img=(\\d+)>","AA");
    }

    // called every game tick, until the pendingChatMessages is empty
    // pending messages will be removed from set if they are not translated within 30 seconds
    public void handlePendingChatMessages() {
        if(pendingChatMessages.isEmpty())
            return;

        long currentTime = System.currentTimeMillis();
        Set<Pair<ChatMessage, Long>> toRemove = new HashSet<>();
        for(Pair<ChatMessage, Long> pair : pendingChatMessages){

            if (pair.getRight() < currentTime) { // time out
                toRemove.add(pair);
                continue;
            }

            ChatMessage chatMessage = pair.getLeft();
            MessageNode node = chatMessage.getMessageNode();
            String message = chatMessage.getMessage();

            String translation = plugin.getDeepl().translate(message, LangCodeSelectableList.ENGLISH, config.getSelectedLanguage());

            // if the translation is the same as the original message, don't replace
            if(translation.equals(message)){
                continue;
            }

            Transformer transformer = new Transformer(plugin);
            Colors textColor = chatColorManager.getMessageColor();
            String textToDisplay = transformer.stringToDisplayedString(translation, textColor);

            replaceChatMessage(textToDisplay, node);
            addMsgToSidePanel(chatMessage, translation);
            toRemove.add(pair);
        }
        for (Pair<ChatMessage, Long> pair : toRemove) {
            pendingChatMessages.remove(pair);
        }
    }
}

package com.RuneLingual.ChatMessages;


import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;

import javax.inject.Inject;

@Slf4j
public class ChatColorManager {
    @Inject
    private Client client;
    @Inject
    private RuneLingualPlugin plugin;
    @Getter
    private Colors messageColor = Colors.black;

    @Inject
    public ChatColorManager(RuneLingualPlugin plugin) {
        this.plugin = plugin;
        this.client = plugin.getClient();
    }



    public void setMessageColor(ChatMessageType chatMessageType){
        int opaqueInt = 0;
        if (client.getVarbitValue(Varbits.TRANSPARENT_CHATBOX) == opaqueInt) {
            messageColor = getOpaqueBoxMessageColor(chatMessageType);
        } else {
            messageColor = getTransparentBoxMessageColor(chatMessageType);
        }
    }

    public Colors getOpaqueBoxMessageColor(ChatMessageType type) {
        int color;
        switch (type) {
            case PUBLICCHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_PUBLIC);
                break;
            case PRIVATECHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_PRIVATE);
                break;
            case AUTOTYPER:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_AUTO);
                break;
            case BROADCAST:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_BROADCAST);
                break;
            case FRIENDSCHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_FRIEND);
                break;
            case CLAN_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_CLAN);
                break;
            case CLAN_GUEST_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_GUEST_CLAN);
                break;
            case CLAN_MESSAGE:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_CLAN_BROADCAST);
                break;
            case CLAN_GIM_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_IRON_GROUP_CHAT);
                break;
            case CLAN_GIM_MESSAGE:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_IRON_GROUP_BROADCAST);
                break;
            case TRADE:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_TRADE_REQUEST);
                break;
            case CHALREQ_CLANCHAT:
            case CHALREQ_FRIENDSCHAT:
            case CHALREQ_TRADE:
                color = client.getVarpValue(VarPlayer.SETTINGS_OPAQUE_CHAT_CHALLENGE_REQUEST);
                break;
            default:
                color = 0;
        }
        if(color==0)
            return Colors.black;
        color--;
        return Colors.getColorFromHex(Integer.toHexString(color));
    }

    private Colors getTransparentBoxMessageColor(ChatMessageType type) {
        int color;
        switch (type) {
            case PUBLICCHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_PUBLIC);
                break;
            case PRIVATECHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_PRIVATE);
                break;
            case AUTOTYPER:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_AUTO);
                break;
            case BROADCAST:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_BROADCAST);
                break;
            case FRIENDSCHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_FRIEND);
                break;
            case CLAN_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_CLAN);
                break;
            case CLAN_GUEST_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_GUEST_CLAN);
                break;
            case CLAN_MESSAGE:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_CLAN_BROADCAST);
                break;
            case CLAN_GIM_CHAT:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_IRON_GROUP_CHAT);
                break;
            case CLAN_GIM_MESSAGE:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_IRON_GROUP_BROADCAST);
                break;
            case TRADE:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_TRADE_REQUEST);
                break;
            case CHALREQ_CLANCHAT:
            case CHALREQ_FRIENDSCHAT:
            case CHALREQ_TRADE:
                color = client.getVarpValue(VarPlayer.SETTINGS_TRANSPARENT_CHAT_CHALLENGE_REQUEST);
                break;
            default:
                color = 0;
        }
        color--;
        return Colors.getColorFromHex(Integer.toHexString(color));
    }
}

package com.RuneLingual;

import com.RuneLingual.ApiTranslate.*;
import com.RuneLingual.ChatMessages.*;
import com.RuneLingual.MouseOverlays.MenuEntryHighlightOverlay;
import com.RuneLingual.MouseOverlays.MouseTooltipOverlay;
import com.RuneLingual.SQL.SqlActions;
import com.RuneLingual.SQL.SqlQuery;
import com.RuneLingual.Widgets.PartialTranslationManager;
import com.RuneLingual.Widgets.Widget2ModDict;
import com.RuneLingual.Widgets.WidgetCapture;
import com.RuneLingual.Widgets.WidgetsUtilRLingual;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.nonLatin.*;
import com.RuneLingual.prepareResources.H2Manager;
import com.RuneLingual.prepareResources.SpriteReplacer;
import com.google.inject.Provides;

import javax.annotation.Nullable;
import javax.inject.Inject;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.callback.ClientThread;


import lombok.Getter;

import com.RuneLingual.SidePanelComponents.SidePanel;
import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.prepareResources.Downloader;
import com.RuneLingual.commonFunctions.Ids;
import okhttp3.OkHttpClient;


import java.awt.image.BufferedImage;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@PluginDescriptor(
        // Plugin name shown at plugin hub
        name = "RuneLingual",
        description = "All-in-one translation plugin for OSRS."
)

public class RuneLingualPlugin extends Plugin {
    @Inject
    @Getter
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ClientToolbar clientToolBar;
    @Inject
    @Getter
    private ChatIconManager chatIconManager;
    @Getter
    private HashMap<String, Integer> charIds = new HashMap<>();    // colour-char(key) <-> CharIds(val)

    @Inject
    @Getter
    private RuneLingualConfig config;
    @Inject
    private CharImageInit charImageInit;

    @Getter @Setter
    private LangCodeSelectableList targetLanguage;
    @Getter
    private String selectedLanguageName;


    // main modules
    @Inject
    @Getter
    private ChatCapture chatCapture;
    @Inject
    @Getter
    private MenuCapture menuCapture;


    @Inject
    @Getter
    private Downloader downloader;
    @Inject
    @Getter
    private H2Manager h2Manager;
    @Inject
    @Getter
    private SidePanel panel;
    private NavigationButton navButton;
    @Inject
    @Getter
    private GeneralFunctions generalFunctions;
    @Inject
    @Getter
    private FileNameAndPath fileNameAndPath = new FileNameAndPath();
    @Inject
    @Getter
    private SqlActions sqlActions;
    @Inject
    private SqlQuery sqlQuery;
    @Getter
    @Setter
    private String[] tsvFileNames;
    @Getter @Setter
    private String databaseUrl;
    @Getter
    @Setter
    private Connection conn;
    @Inject
    @Getter
    private Ids ids;
    @Inject
    @Getter
    private Widget2ModDict widget2ModDict;
    @Inject @Getter
    private PartialTranslationManager partialTranslationManager;
    @Inject
    @Getter
    private WidgetsUtilRLingual widgetsUtilRLingual;
    @Inject
    private MouseTooltipOverlay mouseTooltipOverlay;
    @Inject
    @Getter
    private Deepl deepl;
    @Inject
    private DeeplUsageOverlay deeplUsageOverlay;
    @Inject
    @Getter
    private ChatInputRLingual chatInputRLingual;
    @Inject
    @Getter
    private ChatInputOverlay chatInputOverlay;
    @Inject
    private MenuEntryHighlightOverlay menuEntryHighlightOverlay;
    @Inject
    private ChatInputCandidateOverlay chatInputCandidateOverlay;
    @Inject
    private OverheadCapture overheadCapture;
    @Inject @Getter
    private WidgetCapture widgetCapture;

    @Getter
    private TileObject interactedObject;
    @Getter
    private NPC interactedNpc;
    @Getter
    boolean attacked;
    private int clickTick;
    @Getter
    private int gameCycle;
    @Inject
    private OkHttpClient httpClient;
    @Inject
    SpriteReplacer spriteReplacer;

    @Getter
    Set<SqlQuery> failedTranslations = new HashSet<>();

    // stores selected languages during this session, to prevent re-initializing char images
    private final Set<LangCodeSelectableList> pastLanguages = new HashSet<>();

    @Override
    protected void startUp() throws Exception {
        //get selected language
        targetLanguage = config.getSelectedLanguage();
        pastLanguages.add(targetLanguage);
        databaseUrl = h2Manager.getUrl(targetLanguage);
        // check if online files have changed, if so download and update local files
        initLangFiles();

        //connect to database
        conn = h2Manager.getConn(targetLanguage);

        // initiate overlays
        overlayManager.add(mouseTooltipOverlay);
        overlayManager.add(deeplUsageOverlay);
        overlayManager.add(chatInputOverlay);
        overlayManager.add(chatInputCandidateOverlay);
        overlayManager.add(menuEntryHighlightOverlay);

        // load image files
        charImageInit.loadCharImages();
        queueUpdateAllOverrides();

        // side panel
        startPanel();
        log.info("RuneLingual started!");
    }

    @Subscribe
    public void onOverheadTextChanged(OverheadTextChanged event) throws Exception {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        overheadCapture.translateOverhead(event);
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        //log.info("Widget loaded:" + event.getGroupId());
//		clientThread.invokeLater(() -> {
//			widgetCapture.translateWidget();
//		});
    }

    @Subscribe
    private void onBeforeRender(BeforeRender event) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }

        chatInputRLingual.updateChatInput();
        widgetCapture.translateWidget();
    }

    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }

        menuCapture.handleOpenedMenu(event);
    }




    @Subscribe
    public void onChatMessage(ChatMessage event) throws Exception {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        if (client.getGameState() != GameState.LOGGED_IN && client.getGameState() != GameState.HOPPING) {
            return;
        }
        chatCapture.handleChatMessage(event);
    }


    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        if (gameStateChanged.getGameState() == GameState.LOADING) {
            deepl.setUsageAndLimit();
            interactedObject = null;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(RuneLingualConfig.GROUP)) {
            return;
        }
        // if language is changed
        if (targetLanguage != config.getSelectedLanguage()) {
            targetLanguage = config.getSelectedLanguage();
            spriteReplacer.resetWidgetSprite();
            if (targetLanguage.hasLocalTranscript()) {
                //close current connection
                h2Manager.closeConn();
            }
            if (targetLanguage == LangCodeSelectableList.ENGLISH || !targetLanguage.hasLocalTranscript()) {
                clientToolBar.removeNavigation(navButton);
                if(targetLanguage != LangCodeSelectableList.ENGLISH){
                    deepl = new Deepl(this, httpClient);
                }
                return;
            }

            databaseUrl = h2Manager.getUrl(targetLanguage);
            initLangFiles();
            conn = h2Manager.getConn(targetLanguage);

            clientToolBar.removeNavigation(navButton);
            queueUpdateAllOverrides();
            if (targetLanguage.needsCharImages() && !pastLanguages.contains(targetLanguage)) {
                charImageInit.loadCharImages();
            }

            overlayManager.remove(mouseTooltipOverlay);
            MouseTooltipOverlay.setAttemptedTranslation(new ArrayList<>());
            overlayManager.add(mouseTooltipOverlay);

            //reset deepl's past translations
            deepl = new Deepl(this, httpClient);

            restartPanel();
            pastLanguages.add(targetLanguage);
        }
        if(config.ApiConfig()){
            deepl.setUsageAndLimit();
            deepl.getTranslationAttempt().clear();
        }

    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned npcDespawned) {
        if (npcDespawned.getNpc() == interactedNpc) {
            interactedNpc = null;
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        if (client.getTickCount() > clickTick && client.getLocalDestinationLocation() == null) {
            // when the destination is reached, clear the interacting object
            interactedObject = null;
            interactedNpc = null;
        }

        if (client.isMenuOpen()) {
            menuCapture.handlePendingApiTranslation();
        }

        chatCapture.handlePendingChatMessages();
        overheadCapture.handlePendingOverheadTranslations();
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged interactingChanged) {
        if (interactingChanged.getSource() == client.getLocalPlayer()
                && client.getTickCount() > clickTick && interactingChanged.getTarget() != interactedNpc) {
            interactedNpc = null;
            attacked = interactingChanged.getTarget() != null && interactingChanged.getTarget().getCombatLevel() > 0;
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
        switch (menuOptionClicked.getMenuAction()) {
            case WIDGET_TARGET_ON_GAME_OBJECT:
            case GAME_OBJECT_FIRST_OPTION:
            case GAME_OBJECT_SECOND_OPTION:
            case GAME_OBJECT_THIRD_OPTION:
            case GAME_OBJECT_FOURTH_OPTION:
            case GAME_OBJECT_FIFTH_OPTION: {
                int x = menuOptionClicked.getParam0();
                int y = menuOptionClicked.getParam1();
                int id = menuOptionClicked.getId();
                interactedObject = findTileObject(x, y, id);
                interactedNpc = null;
                clickTick = client.getTickCount();
                gameCycle = client.getGameCycle();
                break;
            }
            case WIDGET_TARGET_ON_NPC:
            case NPC_FIRST_OPTION:
            case NPC_SECOND_OPTION:
            case NPC_THIRD_OPTION:
            case NPC_FOURTH_OPTION:
            case NPC_FIFTH_OPTION: {
                interactedObject = null;
                interactedNpc = menuOptionClicked.getMenuEntry().getNpc();
                attacked = menuOptionClicked.getMenuAction() == MenuAction.NPC_SECOND_OPTION ||
                        menuOptionClicked.getMenuAction() == MenuAction.WIDGET_TARGET_ON_NPC
                                && client.getSelectedWidget() != null
                                && WidgetUtil.componentToInterface(client.getSelectedWidget().getId()) == InterfaceID.SPELLBOOK;
                clickTick = client.getTickCount();
                gameCycle = client.getGameCycle();
                break;
            }
            // Any menu click which clears an interaction
            case WALK:
            case WIDGET_TARGET_ON_WIDGET:
            case WIDGET_TARGET_ON_GROUND_ITEM:
            case WIDGET_TARGET_ON_PLAYER:
            case GROUND_ITEM_FIRST_OPTION:
            case GROUND_ITEM_SECOND_OPTION:
            case GROUND_ITEM_THIRD_OPTION:
            case GROUND_ITEM_FOURTH_OPTION:
            case GROUND_ITEM_FIFTH_OPTION:
                interactedObject = null;
                interactedNpc = null;
                break;
            default:
                if (menuOptionClicked.isItemOp()) {
                    interactedObject = null;
                    interactedNpc = null;
                }
        }
    }

    private void queueUpdateAllOverrides()
    {
        clientThread.invoke(() -> {
            // Cross sprites and widget sprite cache are not setup until login screen
            if (client.getGameState().getState() < GameState.LOGIN_SCREEN.getState()) {
                return false;
            }
            updateAllOverrides();
            return true;
        });
    }

    private void updateAllOverrides() {
        spriteReplacer.initMap();
        spriteReplacer.replaceWidgetSprite();
    }

    @Override
    protected void shutDown() throws Exception {
        clientToolBar.removeNavigation(navButton);
        overlayManager.remove(mouseTooltipOverlay);
        overlayManager.remove(deeplUsageOverlay);
        overlayManager.remove(chatInputOverlay);
        overlayManager.remove(chatInputCandidateOverlay);
        overlayManager.remove(menuEntryHighlightOverlay);
        h2Manager.closeConn();
        spriteReplacer.resetWidgetSprite();
    }


    @Provides
    RuneLingualConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(RuneLingualConfig.class);
    }

    private void initLangFiles() {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            return;
        }
        //download necessary files
        downloader.setLangCode(targetLanguage.getLangCode());
        downloader.initDownloader();
    }

    public void restartPanel() {
        //update Language named folder (which is used to determine what language is selected)
        FileActions.deleteAllLangCodeNamedFile();
        FileActions.createLangCodeNamedFile(config.getSelectedLanguage());
        clientToolBar.removeNavigation(navButton);
        startPanel();
    }

    private void startPanel() {
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "globe.png");
        //panel.setTargetLanguage(config.getSelectedLanguage());
        panel = injector.getInstance(SidePanel.class);

        navButton = NavigationButton.builder()
                .tooltip("RuneLingual")
                .icon(icon)
                .priority(6)
                .panel(panel)
                .build();
        clientToolBar.addNavigation(navButton);
    }

    TileObject findTileObject(int x, int y, int id) {
        Scene scene = client.getScene();
        Tile[][][] tiles = scene.getTiles();
        Tile tile = tiles[client.getPlane()][x][y];
        if (tile != null) {
            for (GameObject gameObject : tile.getGameObjects()) {
                if (gameObject != null && gameObject.getId() == id) {
                    return gameObject;
                }
            }

            WallObject wallObject = tile.getWallObject();
            if (wallObject != null && wallObject.getId() == id) {
                return wallObject;
            }

            DecorativeObject decorativeObject = tile.getDecorativeObject();
            if (decorativeObject != null && decorativeObject.getId() == id) {
                return decorativeObject;
            }

            GroundObject groundObject = tile.getGroundObject();
            if (groundObject != null && groundObject.getId() == id) {
                return groundObject;
            }
        }
        return null;
    }

    @Nullable
    Actor getInteractedTarget() {
        return interactedNpc != null ? interactedNpc : client.getLocalPlayer().getInteracting();
    }

}


package com.RuneLingual.debug;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.List;

import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.SQL.SqlVariables;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class OutputToFile {
    public void menuTarget(String target, String subCategory, String source){
        if (Colors.countColorTagsAfterReformat(target) <= 1){
            target = Colors.removeNonImgTags(target);
        }
        target = Colors.getColorPlaceholdedColWord(target);
        appendToFile(target + "\t" + SqlVariables.categoryValue4Name.getValue() + "\t" + subCategory + "\t" + source, "menuTarget_debug.txt");
    }

    public void menuOption(String option, String subCategory, String source){
        if (Colors.countColorTagsAfterReformat(option) <= 1){
            option = Colors.removeNonImgTags(option);
        }
        option = Colors.getColorPlaceholdedColWord(option);
        appendToFile(option + "\t" + SqlVariables.categoryValue4Actions.getValue() + "\t" + subCategory + "\t" + source, "menuOption_debug.txt");
    }

    public void dumpGeneral(String english, String category, String subCategory, String source){
        if (english == null || english.isEmpty()){
            return;
        }
        if (category == null){
            category = "";
        }
        if (subCategory == null){
            subCategory = "";
        }
        if (source == null){
            source = "";
        }
        appendToFile(english + "\t" + category + "\t" + subCategory + "\t" + source, "dumpGeneral_debug.txt");
    }

    public static void appendToFile(String str, String fileName){
        try {
            createDirectoryIfNotExists("output");
            Path filePath = Paths.get("output" + File.separator + fileName);
            createFileIfNotExists(filePath.toString());
            Files.write(filePath, (str + System.lineSeparator()).getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);
        } catch (IOException e) {
            log.error("Error writing to file.", e);
        }
    }

    public static void appendIfNotExistToFile(String str, String fileName) {
        try {
            createDirectoryIfNotExists("output");
            Path filePath = Paths.get("output" + File.separator + fileName);
            createFileIfNotExists(filePath.toString());

            // Read all lines from the file
            List<String> lines = Files.readAllLines(filePath, StandardCharsets.UTF_8);

            // Check if the string is already in the file
            if (!lines.contains(str)) {
                Files.write(filePath, (str + System.lineSeparator()).getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void createFileIfNotExists(String fileName) {
        Path path = Paths.get(fileName);
        if (!Files.exists(path)) {
            try {
                Files.createFile(path);
            } catch (IOException e) {
            }
        }
    }

    public static void createDirectoryIfNotExists(String dirName) {
        Path path = Paths.get(dirName);
        if (!Files.exists(path)) {
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
            }
        }
    }
}

package com.RuneLingual.prepareResources;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.SQL.SqlActions;
import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.*;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;


@Slf4j
public class Downloader {//downloads translations and japanese char images to external file
    private static final File localBaseFolder = FileNameAndPath.getLocalBaseFolder();
    @Inject
    private RuneLingualPlugin plugin;
    @Getter
    private File localLangFolder;
    private String GITHUB_BASE_URL;
    @Setter
    @Getter
    private String langCode;
    @Inject
    private DataFormater dataFormater;


    @Inject
    public Downloader(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    // returns if char image changed
    public void initDownloader() {
        LangCodeSelectableList langCodeSelectableList = plugin.getConfig().getSelectedLanguage();
        if (langCodeSelectableList == LangCodeSelectableList.ENGLISH) {
            return;
        }
        final List<String> extensions_to_download = new ArrayList<>(); // will download all files with these extensions
        if (langCodeSelectableList.needsCharImages()){
            extensions_to_download.add("zip");
        }
        if (langCodeSelectableList.hasLocalTranscript()){
            extensions_to_download.add("png");//for swapping sprites
            extensions_to_download.add("tsv");
        }
        if (extensions_to_download.isEmpty()) {
            return;
        }
        final List<String> file_name_to_download = List.of("char_" + langCode + ".zip",
                "latin2foreign_" + langCode + ".txt",
                "foreign2foreign_" + langCode + ".txt"); // will download all files with these names, no error if it doesnt exist
        localLangFolder = new File(FileNameAndPath.getLocalLangFolder(langCodeSelectableList));

        createDir(localLangFolder.getPath());
        String LOCAL_HASH_NAME = "hashListLocal_" + langCode + ".txt";
        String remote_sub_folder = "public"; //todo: this value is "draft" if reading from draft folder, "public" if reading from the public folder
        GITHUB_BASE_URL = "https://raw.githubusercontent.com/YS-jack/Runelingual-Transcripts/original-main/" +
                remote_sub_folder + "/" + langCode + "/";

        // if the plugin is configured to use custom data, use that instead of the default GitHub URL
        // example of customDataUrl: https://raw.githubusercontent.com/YS-jack/Runelingual-Transcripts/original-main/draft/
        String customDataUrl = plugin.getConfig().getCustomDataUrl();
        if (!customDataUrl.endsWith("/")) {
            customDataUrl = customDataUrl + "/";
        }
        customDataUrl = customDataUrl + langCode + "/";
        if(plugin.getConfig().useCustomData() && isURLReachable(customDataUrl + "hashList_" + langCode + ".txt")) {
            GITHUB_BASE_URL = customDataUrl;
            log.info("Using custom data URL: " + GITHUB_BASE_URL);
        } else {
            log.error("Custom data URL is not reachable or not configured, using default GitHub URL: " + GITHUB_BASE_URL);
        }

        String REMOTE_HASH_FILE = GITHUB_BASE_URL + "hashList_" + langCode + ".txt";

        try {
            Path dirPath = Paths.get(localBaseFolder.getPath());
            if (!Files.exists(dirPath)) {
                try {
                    // Attempt to create the directory
                    Files.createDirectories(dirPath);
                } catch (IOException e) {
                    log.error("Error creating directory", e);
                }
            }

            Map<String, String> localHashes = readHashFile(Paths.get(localLangFolder.getPath(), LOCAL_HASH_NAME));
            Map<String, String> remoteHashes = readHashFile(new URL(REMOTE_HASH_FILE));

            boolean dataChanged = false;
            boolean transcriptChanged = false;
            List<String> remoteTsvFileNames = new ArrayList<>(); // list of tsv files to include in the sql database


            for (Map.Entry<String, String> entry : remoteHashes.entrySet()) {
                String localHash = localHashes.get(entry.getKey());
                String remoteHash = entry.getValue();
                String remote_full_path = entry.getKey();
                Connection conn = plugin.getH2Manager().getConn(plugin.getTargetLanguage());

                if ((localHash == null || !localHash.equals(remoteHash) || SqlActions.noTableExistsOrIsEmpty(conn)) // if the file is not in the local hash file OR the hash value is different OR the table TRANSCRIPT exists but empty
                        && (fileExtensionIncludedIn(remote_full_path, extensions_to_download) // and if the file extension is in the list of extensions to download
                        || same_file_included(remote_full_path, file_name_to_download))) { // or if the file name is in the list of file names to download

                    dataChanged = true;
                    downloadAndUpdateFile(remote_full_path);
                    if (fileExtensionIncludedIn(remote_full_path, List.of("zip"))) { // if its a zip file, unzip it
                        updateCharDir(Paths.get(localLangFolder.getPath(), "char_" + langCode + ".zip")); // currently only supports char images, which should suffice
                    } else {
                        transcriptChanged = true; // if the file is not a zip file, then one of the transcripts has changed
                    }
                }

                if (fileExtensionIncludedIn(remote_full_path, List.of("tsv"))) {
                    remoteTsvFileNames.add(remote_full_path);
                }
            }
            String[] tsvFileNames = remoteTsvFileNames.toArray(new String[0]);
            this.plugin.setTsvFileNames(tsvFileNames);

            if (dataChanged) {
                // Overwrite local hash file with the updated remote hash file
                Files.copy(new URL(REMOTE_HASH_FILE).openStream(), Paths.get(localLangFolder.getPath(), LOCAL_HASH_NAME), StandardCopyOption.REPLACE_EXISTING);
                if (transcriptChanged) {
                    dataFormater.updateSqlFromTsv(localLangFolder.getPath(), tsvFileNames);
                }
            } else {
                log.info("All files are up to date.");
            }
        } catch (IOException e) {
            log.error("An error occurred: {}", e.getMessage(), e);
        }
    }

    private void createDir(String path) {
        Path dirPath = Paths.get(path);
        if (!Files.exists(dirPath)) {
            try {
                // Attempt to create the directory
                Files.createDirectories(dirPath);
            } catch (IOException e) {
                log.error("Error creating directory", e);
            }
        }
    }

    private Boolean fileExtensionIncludedIn(String file_full_path, List<String> extensions) {
        String extension = get_file_extension(file_full_path);
        return extensions.contains(extension);
    }

    private String get_file_extension(String file_full_path) {
        String[] parts = file_full_path.split("\\.");
        return parts[parts.length - 1];
    }

    private Boolean same_file_included(String file_full_path, List<String> file_names) {
        Path fullPath = Paths.get(file_full_path);
        Path fileName = fullPath.getFileName();
        String fileNameString = fileName.toString();
        return file_names.contains(fileNameString);
    }

    private Map<String, String> readHashFile(Path filePath) throws IOException {
        Map<String, String> hashes = new HashMap<>();
        if (!Files.exists(filePath)) {
            Files.createDirectories(filePath.getParent());
            Files.createFile(filePath);
        }
        try (BufferedReader reader = Files.newBufferedReader(filePath)) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("\\|");
                if (parts.length == 2) {
                    hashes.put(parts[0], parts[1]);
                }
            }
        }
        return hashes;
    }

    private Map<String, String> readHashFile(URL fileUrl) throws IOException {
        Map<String, String> hashes = new HashMap<>();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(fileUrl.openStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("\\|");
                if (parts.length == 2) {
                    hashes.put(parts[0], parts[1]);
                }
            }
        }
        return hashes;
    }

    private void downloadAndUpdateFile(String remoteFullPath) throws IOException {
        // filePath example: "draft\ja\actions_ja.xliff" this is the location of files relative to the GitHub repo root of RuneLite-Transcripts
        URL fileUrl = new URL(GITHUB_BASE_URL + remoteFullPath.replace("\\", "/"));
        Path localPath = Paths.get(localLangFolder.getPath(), remoteFullPath.replace("draft\\", ""));
        log.info("updating file " + localPath);


        // Check if the language directory exists, if not, create it
        if (Files.notExists(localPath.getParent())) {
            Files.createDirectories(localPath.getParent());
        }

        Files.copy(fileUrl.openStream(), localPath, StandardCopyOption.REPLACE_EXISTING);
    }

    public void updateCharDir(Path localPath) throws IOException {
        URL fileUrl3 = new URL(GITHUB_BASE_URL + "/char_" + langCode + ".zip");
        Files.copy(fileUrl3.openStream(), localPath, StandardCopyOption.REPLACE_EXISTING);
        unzip(String.valueOf(localPath), localLangFolder.getPath());
        Files.delete(localPath);
    }

    public void unzip(String zipFilePath, String destDir) {
        FileActions.deleteFolder(destDir + File.separator + "char_" + langCode);
        log.info("unzipping " + zipFilePath + " to " + destDir);
        File dir = new File(destDir);
        // create output directory if it doesn't exist
        if (!dir.exists()) dir.mkdirs();
        FileInputStream fis;
        //buffer for read and write data to file
        byte[] buffer = new byte[1024];
        try {
            fis = new FileInputStream(zipFilePath);
            ZipInputStream zis = new ZipInputStream(fis);
            ZipEntry ze = zis.getNextEntry();
            while (ze != null) {
                String fileName = ze.getName();
                File newFile = new File(destDir + File.separator + fileName);
                //create directories for sub directories in zip
                new File(newFile.getParent()).mkdirs();
                FileOutputStream fos = new FileOutputStream(newFile);
                int len;
                while ((len = zis.read(buffer)) > 0) {
                    fos.write(buffer, 0, len);
                }
                fos.close();
                //close this ZipEntry
                zis.closeEntry();
                ze = zis.getNextEntry();
            }
            //close last ZipEntry
            zis.closeEntry();
            zis.close();
            fis.close();
        } catch (IOException e) {
            log.error("Error unzipping file", e);
        }
    }

    public static boolean isURLReachable(String urlString) {
        try {
            URL url = new URL(urlString);
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("HEAD");
            connection.setConnectTimeout(5000); // 5 seconds timeout
            connection.setReadTimeout(5000);
            int responseCode = connection.getResponseCode();
            return (200 <= responseCode && responseCode < 400);
        } catch (Exception e) {
            return false;
        }
    }
}

package com.RuneLingual.prepareResources;

import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.SQL.SqlActions;
import com.RuneLingual.RuneLingualPlugin;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.HashMap;
import java.util.List;

@Slf4j
public class DataFormater {

    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    public DataFormater(RuneLingualPlugin plugin){
        this.plugin = plugin;
    }
    @Inject
    private SqlActions sqlActions;

    public void updateSqlFromTsv(String localLangFolder, String[] tsvFileNames){
        log.info("Updating SQL database from TSV files.");
        String SQLFilePath = localLangFolder + File.separator + FileNameAndPath.getLocalSQLFileName() + ".mv.db";
        String SQLFilePath2 = localLangFolder + File.separator + FileNameAndPath.getLocalSQLFileName() + ".trace.db";

        if (FileActions.fileExists(SQLFilePath)){
            FileActions.deleteFile(SQLFilePath);
        }
        if (FileActions.fileExists(SQLFilePath2)){
            FileActions.deleteFile(SQLFilePath2);
        }
        try {
            sqlActions.createTable();
            log.info("Table created.");
            sqlActions.tsvToSqlDatabase(tsvFileNames, localLangFolder);
        } catch (Exception e) {
            log.error("Error creating table.",e);
        }
    }

}

package com.RuneLingual.prepareResources;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.commonFunctions.Ids;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SpritePixels;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.ImageUtil;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Map;

@Slf4j
public class SpriteReplacer {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;


    private final Map<String, Integer> fileNameToWidgetId = new java.util.HashMap<>();

    public void initMap() {
        Ids ids = plugin.getIds();
        LangCodeSelectableList lang = plugin.getConfig().getSelectedLanguage();
        String fileLoginBanner = FileNameAndPath.getLocalLangFolder(lang) + File.separator + "loginScreenSprite_" + lang.getLangCode() +".png";
        int loginBannerId = ids.getLoginBannerId();
        fileNameToWidgetId.put(fileLoginBanner, loginBannerId);
    }

    public void replaceWidgetSprite() {
        for(Map.Entry<String, Integer> entry : fileNameToWidgetId.entrySet()) {
            String file = entry.getKey();
            int widgetId = entry.getValue();
            SpritePixels sprite = getFileSpritePixels(file);
            if(sprite == null) {
                log.debug("Sprite is null for file: {}", file);
                continue;
            }
            client.getWidgetSpriteOverrides().put(widgetId, sprite);
        }
    }

    public void resetWidgetSprite() {
        clientThread.invokeLater(() ->
        {
            for(Map.Entry<String, Integer> entry : fileNameToWidgetId.entrySet()) {
                int widgetId = entry.getValue();
                client.getWidgetSpriteOverrides().remove(widgetId);
            }
        });
    }

    private SpritePixels getFileSpritePixels(String file)
    {
        try
        {
            log.debug("Loading: {}", file);
            File externalImage = new File(file);
            BufferedImage image = ImageIO.read(externalImage);
            return ImageUtil.getImageSpritePixels(image, client);
        }
        catch (RuntimeException ex)
        {
            log.debug("Unable to load image: ", ex);
        } catch (IOException e) {
            log.debug("Unable to load image: ", e);
        }
        return null;
    }
}

package com.RuneLingual.prepareResources;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;

@Slf4j
public class H2Manager {
    @Inject
    private RuneLingualPlugin plugin;

    public String getUrl(LangCodeSelectableList targetLanguage) {
        String databaseUrl = "jdbc:h2:" + FileNameAndPath.getLocalBaseFolder() + File.separator +
                targetLanguage.getLangCode() + File.separator + FileNameAndPath.getLocalSQLFileName() + ";AUTO_SERVER=TRUE";
        return databaseUrl;
    }

    public Connection getConn(LangCodeSelectableList targetLanguage) {
        Connection conn = null;
        String databaseUrl;

        databaseUrl = getUrl(targetLanguage);
        try {
            // Explicitly load the H2 driver class
            Class.forName("org.h2.Driver");
            conn = DriverManager.getConnection(databaseUrl);
        } catch (ClassNotFoundException e) {
            log.error("H2 Driver class not found.", e);
        } catch (Exception e) {
            log.error("Error connecting to database: {}", databaseUrl, e);
            plugin.setTargetLanguage(LangCodeSelectableList.ENGLISH);
        }
        return conn;
    }

    public void closeConn() {
        try {
            if (plugin.getConn() != null) {
                plugin.getConn().close();
            }
        } catch (Exception e) {
            log.error("Error closing database connection.", e);
        }
    }
}

package com.RuneLingual.SidePanelComponents;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.net.URI;
import java.util.Map;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.commonFunctions.FileActions;
import net.runelite.client.util.LinkBrowser;

@Slf4j

public class SidePanel extends PluginPanel{
    @Inject
    private RuneLingualPlugin plugin;

    String helpLink = RuneLingualConfig.helpLink;
    String titleText = "RuneLingual";
    String helpText = "Help with settings";
    String discordText = "Ask for help on Discord";
    @Getter
    ChatBoxSection chatBoxSection;

    @Inject
    private SidePanel(RuneLingualPlugin plugin){
        LangCodeSelectableList targetLanguage = FileActions.getLangCodeFromFile();
        translatePanelTexts(targetLanguage);

        this.setPreferredSize(new Dimension(200, 1500));
        this.add(createTitleLabel(titleText));
        this.add(createClickableLabel(helpText, helpLink));
        this.add(createClickableLabel(discordText, "https://discord.gg/ehwKcVdBGS"));
        this.add(new JSeparator());
        chatBoxSection = new ChatBoxSection(this, targetLanguage, plugin);
        SearchSection searchSection = new SearchSection(this, targetLanguage, plugin);
    }


    private void translatePanelTexts(LangCodeSelectableList targetLanguage) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            titleText = "RuneLingual";
            helpText = "Help with settings";
            discordText = "Ask for help on Discord";
        } /*else if (targetLanguage == LangCodeSelectableList.PORTUGUÊS_BRASILEIRO) {
            titleText = "RuneLíngual";
            helpText = "Ajuda nas configurações";
            discordText = "Peça ajuda no Discord";
        } else if (targetLanguage == LangCodeSelectableList.NORSK) {
            titleText = "RuneLingval";
            helpText = "Hjelp med innstillinger";
            discordText = "Be om hjelp på Discord";
        }*/else if (targetLanguage == LangCodeSelectableList.日本語) {
            titleText = "ルーンリンガル";
            helpText = "設定のヘルプ";
            discordText = "Discordでヘルプを求める";
        }
        // todo: add more languages as needed
    }

    private JLabel createTitleLabel(String title){
        JLabel label = new JLabel(title, SwingConstants.CENTER);
        label.setFont(new Font("MS Gothic", Font.BOLD, 18)); //todo: change the font if a language requires it
        label.setPreferredSize(new Dimension(200, 20));
        label.setForeground(Color.yellow);
        return label;
    }

    private JLabel createTextLabel(String text){
        JLabel label = new JLabel(text, SwingConstants.CENTER);
        label.setFont(new Font("MS Gothic", Font.PLAIN, 14));//todo: change the font if a language requires it
        label.setPreferredSize(new Dimension(200, 20));
        label.setForeground(Color.white);
        return label;
    }

    private JLabel createClickableLabel(String title, String url) {
        JLabel label = new JLabel(title, SwingConstants.CENTER);
        label.setFont(new Font("MS Gothic", Font.PLAIN, 14));//todo: change the font if a language requires it
        label.setPreferredSize(new Dimension(200, 20));
        label.setForeground(Color.white);

        label.addMouseListener(new MouseAdapter() {
               @Override
               public void mouseClicked(MouseEvent e) {
                   if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
                       try {
                           LinkBrowser.browse(url);
                       } catch (Exception ex) {
                           log.error("Error opening link", ex);
                       }
                   } else {
                       log.error("Desktop browsing is not supported on this platform.");
                   }
               }

            @Override
            public void mouseEntered(MouseEvent e) {
                label.setCursor(new Cursor(Cursor.HAND_CURSOR));
                Font font = label.getFont();
                Map attributes = font.getAttributes();
                attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
                label.setFont(font.deriveFont(attributes));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                Font font = label.getFont();
                Map attributes = font.getAttributes();
                attributes.put(TextAttribute.UNDERLINE, -1);
                label.setFont(font.deriveFont(attributes));
            }
        });

        return label;
    }
}

package com.RuneLingual.SidePanelComponents;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.util.Arrays;
import java.util.List;

@Slf4j
public class ChatBoxSection {
    private SidePanel sidePanel;
    @Getter
    private String tabNameGame = "Game";
    @Getter
    private String tabNamePublic = "Public";
    @Getter
    private String tabNameChannel = "Channel";
    @Getter
    private String tabNameClan = "Clan";
    @Getter
    private String tabNameGIM = "GIM";
    JTabbedPane tabbedPane = new JTabbedPane();

    public ChatBoxSection(SidePanel sideP, LangCodeSelectableList langList, RuneLingualPlugin plugin) {
        this.sidePanel = sideP;

        translateTabNames(langList);

        addTab(tabbedPane, tabNameGame);
        addTab(tabbedPane, tabNamePublic);
        addTab(tabbedPane, tabNameChannel);
        addTab(tabbedPane, tabNameClan);
        addTab(tabbedPane, tabNameGIM);

        // Wrap the tabbedPane in a panel with a fixed height
        JPanel fixedHeightPanel = new JPanel(new BorderLayout());
        fixedHeightPanel.setPreferredSize(new Dimension(400, 500)); // Set fixed width and height
        fixedHeightPanel.add(tabbedPane, BorderLayout.CENTER);

        sidePanel.add(fixedHeightPanel);
        sidePanel.setSize(400, 500);
        sidePanel.setVisible(true);
    }

private static void addTab(JTabbedPane tabbedPane, String title) {
    JTextArea textArea = new JTextArea();
    textArea.setEditable(false); // This line makes the text uneditable
    textArea.setCursor(new Cursor(Cursor.TEXT_CURSOR)); // This line changes the cursor to the I-beam shape
    textArea.setSelectionColor(new Color(50,50,200)); // This line sets the background color of the selected text to black
    textArea.setSelectedTextColor(Color.WHITE); // This line sets the color of the selected text to white
    textArea.setLineWrap(true); // This line enables line wrapping

    JScrollPane scrollPane = new JScrollPane(textArea);
    scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER); // This line disables horizontal scrolling

    tabbedPane.addTab(title, scrollPane);
    textArea.setBackground(new Color(30,30,30));
}

public void addSentenceToTab(String tabTitle, String sentence) {
    for (int i = 0; i < tabbedPane.getTabCount(); i++) {
        if (tabbedPane.getTitleAt(i).equals(tabTitle)) {
            JScrollPane scrollPane = (JScrollPane) tabbedPane.getComponentAt(i);
            JViewport viewport = scrollPane.getViewport();
            JTextArea textArea = (JTextArea) viewport.getView();
            if (textArea.getDocument().getLength() != 0) { // Check if the text area is not empty
                textArea.append("--------------------\n"); // Append a separator line
            }
            textArea.append(sentence + "\n");
            return;
        }
    }
}


    private void translateTabNames(LangCodeSelectableList targetLanguage) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            tabNameGame = "Game";
            tabNamePublic = "Public";
            tabNameChannel = "Channel";
            tabNameClan = "Clan";
            tabNameGIM = "GIM";
        } /*else if (targetLanguage == LangCodeSelectableList.PORTUGUÊS_BRASILEIRO) {
            tabNameGame = "Jogo";
            tabNamePublic = "Público";
            tabNameChannel = "Canal";
            tabNameClan = "Clã";
            tabNameGIM = "GIM";
        } else if (targetLanguage == LangCodeSelectableList.NORSK) {
            tabNameGame = "Spill";
            tabNamePublic = "Offentlig";
            tabNameChannel = "Kanal";
            tabNameClan = "Klan";
            tabNameGIM = "GIM";
        } */else if (targetLanguage == LangCodeSelectableList.日本語) {
            tabNameGame = "ゲーム";
            tabNamePublic = "公共";
            tabNameChannel = "チャンネル";
            tabNameClan = "クラン";
            tabNameGIM = "GIM";
        }// todo: add more here as languages are added
    }
}

package com.RuneLingual.SidePanelComponents;


import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.DefaultTableColumnModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.SQL.*;
import com.RuneLingual.RuneLingualPlugin;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class SearchSection extends JPanel {
    private JTextField englishInput;
    private JTextField foreignInput;
    private JButton englishSearchButton;
    private JButton foreignSearchButton;
    private JList<String> englishResults;
    private JList<String> foreignResults;
    private SidePanel sidePanel;
    private DefaultTableModel tableModelEn;
    private JTable enTable;
    private DefaultTableModel tableModelForeign;
    private JTable foreignTable;
    private RuneLingualPlugin plugin;

    String textSearchEnglish = "Search English name";
    String textSearchForeign = "Search Foreign name";
    String textSearch = "Search";
    String textResult = "Result";
    String textType = "Type";

    public SearchSection(SidePanel sideP, LangCodeSelectableList langList, RuneLingualPlugin plugin){
        this.sidePanel = sideP;
        this.plugin = plugin;

        translatePanelTexts(langList);

        englishInput = new JTextField();
        englishInput.setSize(200, 25);
        foreignInput = new JTextField();
        foreignInput.setSize(200, 25);

        englishSearchButton = new JButton(textSearchEnglish);
        englishSearchButton.setBackground(Color.darkGray);
        englishSearchButton.setSize(200, 25);
        foreignSearchButton = new JButton(textSearchForeign);
        foreignSearchButton.setBackground(Color.darkGray);
        foreignSearchButton.setSize(200, 25);

        sidePanel.add(Box.createRigidArea(new Dimension(0, 10)));
        sidePanel.add(createTextLabel(textSearchEnglish));
        sidePanel.add(englishInput);
        sidePanel.add(englishSearchButton);
        sidePanel.add(Box.createRigidArea(new Dimension(0, 1)));
        enTable = addEnResultTable();
        tableModelEn = (DefaultTableModel) enTable.getModel();

        sidePanel.add(Box.createRigidArea(new Dimension(0, 10)));
        sidePanel.add(createTextLabel(textSearchForeign));
        sidePanel.add(foreignInput);
        sidePanel.add(foreignSearchButton);
        sidePanel.add(Box.createRigidArea(new Dimension(0, 10)));
        foreignTable = addForeignResultTable();
        tableModelForeign = (DefaultTableModel) foreignTable.getModel();


        englishSearchButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                removeAllRows(tableModelEn);
                Connection connection = plugin.getConn(); // Reuse the connection without closing it
                String[][] results = executeExactMatchQuery(connection, englishInput.getText(), SqlVariables.columnEnglish.getColumnName());
                String[][] resultsAlike = executeAlikeQuery(connection, englishInput.getText(), SqlVariables.columnEnglish.getColumnName());

                for (String[] result : results) {
                    tableModelEn.addRow(new String[]{result[0], result[1], result[2]});
                }
                for (String[] result : resultsAlike) {
                    tableModelEn.addRow(new String[]{result[0], result[1], result[2]});
                }

                // adjust column width
                for (int i = 0; i < tableModelEn.getColumnCount(); i++) {
                    packColumn(enTable, i, 2);
                }
            }
        });

        foreignSearchButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                removeAllRows(tableModelForeign);
                Connection connection = plugin.getConn(); // Reuse the connection without closing it
                String[][] results = executeExactMatchQuery(connection, foreignInput.getText(), SqlVariables.columnTranslation.getColumnName());
                String[][] resultsAlike = executeAlikeQuery(connection, foreignInput.getText(), SqlVariables.columnTranslation.getColumnName());

                for (String[] result : results) {
                    tableModelForeign.addRow(new String[]{result[1], result[0], result[2]});
                }
                for (String[] result : resultsAlike) {
                    tableModelForeign.addRow(new String[]{result[1], result[0], result[2]});
                }

                // adjust column width
                for (int i = 0; i < tableModelForeign.getColumnCount(); i++) {
                    packColumn(foreignTable, i, 2);
                }
            }
        });

        englishInput.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                englishSearchButton.doClick();
            }
        });

        foreignInput.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                foreignSearchButton.doClick();
            }
        });
    }

    private void translatePanelTexts(LangCodeSelectableList targetLanguage) {
        if (targetLanguage == LangCodeSelectableList.ENGLISH) {
            textSearchEnglish = "Search with English name";
            textSearchForeign = "Search with Foreign name";
            textSearch = "Search";
            textResult = "Result";
            textType = "Type";
        } /*else if (targetLanguage == LangCodeSelectableList.PORTUGUÊS_BRASILEIRO) {
            textSearchEnglish = "Pesquisar com nome em inglês";
            textSearchForeign = "Pesquisar com nome estrangeiro";
            textSearch = "Pesquisa";
            textResult = "Resultado";
            textType = "Tipo";
        } else if (targetLanguage == LangCodeSelectableList.NORSK) {
            textSearchEnglish = "Søk med engelsk navn";
            textSearchForeign = "Søk med utenlandsk navn";
            textSearch = "Søk";
            textResult = "Resultat";
            textType = "Type";
        } */else if (targetLanguage == LangCodeSelectableList.日本語) {
            textSearchEnglish = "英語名で検索";
            textSearchForeign = "日本語名で検索";
            textSearch = "検索";
            textResult = "結果";
            textType = "タイプ";
        }// todo: add more languages as needed
    }

    private JTable addEnResultTable(){
        DefaultTableModel tableModelEn = new DefaultTableModel();
        JTable tableEn = new JTable(tableModelEn);
        tableEn.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        setTableColumn(tableModelEn);
        JScrollPane pane = new JScrollPane(tableEn, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); // Enable horizontal scrollbar
        pane.setPreferredSize(new Dimension(250, 250));
        this.sidePanel.add(pane);
        return tableEn;
    }

    private JTable addForeignResultTable(){
        DefaultTableModel tableModel = new DefaultTableModel();
        JTable table = new JTable(tableModel);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        setTableColumn(tableModel);
        JScrollPane pane = new JScrollPane(table, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); // Enable horizontal scrollbar
        pane.setPreferredSize(new Dimension(200, 250));
        this.sidePanel.add(pane);
        return table;
    }

    private void setTableColumn(DefaultTableModel table) {
        table.addColumn(textSearch);
        table.addColumn(textResult);
        table.addColumn(textType);
    }

    private void removeAllRows(DefaultTableModel tableModel) {
        while (tableModel.getRowCount() > 0) {
            tableModel.removeRow(0);
        }
    }

    public void packColumn(JTable table, int vColIndex, int margin) {
        DefaultTableColumnModel colModel = (DefaultTableColumnModel) table.getColumnModel();
        TableColumn col = colModel.getColumn(vColIndex);
        int width;

        // Get width of column header
        TableCellRenderer renderer = col.getHeaderRenderer();
        if (renderer == null) {
            renderer = table.getTableHeader().getDefaultRenderer();
        }
        Component comp = renderer.getTableCellRendererComponent(table, col.getHeaderValue(), false, false, 0, 0);
        width = comp.getPreferredSize().width;

        // Get maximum width of column data
        for (int r = 0; r < table.getRowCount(); r++) {
            renderer = table.getCellRenderer(r, vColIndex);
            comp = renderer.getTableCellRendererComponent(table, table.getValueAt(r, vColIndex), false, false, r, vColIndex);
            width = Math.max(width, comp.getPreferredSize().width);
        }

        // Add margin
        width += 2 * margin;

        // Set the width
        col.setPreferredWidth(width);
    }

    private JLabel createTextLabel(String text){
        JLabel label = new JLabel(text, SwingConstants.LEFT);
        label.setFont(new Font("MS Gothic", Font.PLAIN, 14));//todo: change the font if a language requires it
        label.setPreferredSize(new Dimension(200, 20));
        label.setForeground(Color.cyan);
        return label;
    }

    private String[][] executeExactMatchQuery(Connection connection, String searchText, String searchColumnName) {
        try (PreparedStatement preparedStatement = prepareExactMatchStatement(connection, searchText, searchColumnName)) {
            return SqlActions.executePreparedStatement(preparedStatement);
        } catch (SQLException e) {
            log.error("Error executing exact match query", e);
            return new String[0][0];
        }
    }

    private String[][] executeAlikeQuery(Connection connection, String searchText, String searchColumnName) {
        try (PreparedStatement preparedStatement = prepareAlikeStatement(connection, searchText, searchColumnName)) {
            return SqlActions.executePreparedStatement(preparedStatement);
        } catch (SQLException e) {
            log.error("Error executing alike query", e);
            return new String[0][0];
        }
    }

    private PreparedStatement prepareExactMatchStatement(Connection connection, String searchText, String searchColumnName) throws SQLException {
        String query = "SELECT " +
                SqlVariables.columnEnglish.getColumnName() + "," +
                SqlVariables.columnTranslation.getColumnName() + "," +
                SqlVariables.columnSubCategory.getColumnName() +
                " FROM " + SqlActions.tableName +
                " WHERE LOWER(" + searchColumnName + ") = ? AND " +
                SqlVariables.columnCategory.getColumnName() +
                " = ?";
        PreparedStatement preparedStatement = connection.prepareStatement(query);
        preparedStatement.setString(1, searchText.toLowerCase());
        preparedStatement.setString(2, SqlVariables.categoryValue4Name.getValue());
        return preparedStatement;
    }

    private PreparedStatement prepareAlikeStatement(Connection connection, String searchText, String searchColumnName) throws SQLException {
        String query = "SELECT " +
                SqlVariables.columnEnglish.getColumnName() + "," +
                SqlVariables.columnTranslation.getColumnName() + "," +
                SqlVariables.columnSubCategory.getColumnName() +
                " FROM " + SqlActions.tableName +
                " WHERE LOWER(" + searchColumnName + ") LIKE ? AND " +
                SqlVariables.columnCategory.getColumnName() +
                " = ?";
        PreparedStatement preparedStatement = connection.prepareStatement(query);
        preparedStatement.setString(1, "%" + searchText.toLowerCase() + "%");
        preparedStatement.setString(2, SqlVariables.categoryValue4Name.getValue());
        return preparedStatement;
    }
}

package com.RuneLingual.Widgets;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.SQL.SqlQuery;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.nonLatin.GeneralFunctions;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import java.util.*;
import java.util.stream.Collectors;


@Getter
@Setter
public class PartialTranslationManager {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private Transformer transformer;

    private List<PartialTranslation> partialTranslations = new ArrayList<>();

    @Inject
    public PartialTranslationManager(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    public enum PlaceholderType {
        PLAYER_NAME,
        ITEM_NAME,
        NPC_NAME,
        OBJECT_NAME,
        ANY_TRANSLATED // will first look for any matches in the local translation, but if it doesnt exist and the api config for interface is on, will try to translate with api
    } // after adding, add to getQuery4PlaceholderType

    @Getter
    public static class PartialTranslation {
        @Inject
        private RuneLingualPlugin plugin;
        @Inject
        private Transformer transformer;
        @Setter
        private int id;
        private final List<String> fixedTextParts; // fixed text parts of the text
        private final List<String> placeholders = new ArrayList<>(); // name and option for each placeholder

        public PartialTranslation(RuneLingualPlugin plugin, Transformer transformer, List<String> fixedTextParts,
                                  List<PlaceholderType> placeholders){
            /*
             fixedTextParts = ["slay ", " in "]
             placeholders = [(NPC_NAME, LOCAL_TRANSLATION), (LOCATION, AS_IS)]

             this.placeholders = [(NPC_NAME0, LOCAL_TRANSLATION), (LOCATION0, AS_IS)] (placeholder type with individual indexes)
            */
            this.plugin = plugin;
            this.transformer = transformer;
            this.fixedTextParts = fixedTextParts;

            int[] typeCounter = new int[PlaceholderType.values().length]; // count the number of each placeholder type, to be placed in the placeholder name (eg: <!PLAYER_NAME0>)
            Arrays.fill(typeCounter, 0);

            for (PlaceholderType placeholder : placeholders) {
                String type = placeholder.name();
                int counter = typeCounter[placeholder.ordinal()];
                String placeholderName = type + counter;

                this.placeholders.add(placeholderName);

                typeCounter[placeholder.ordinal()]++;
            }

        }

        public String getEnColVal(){
            /*
            fixedTextParts = ["slay ", " in "]
            placeholders = [(NPC_NAME, AS_IS), (LOCATION_NAME, TRANSLATE_LOCAL)]

            returns: "slay <!NPC_NAME0> in <!LOCATION_NAME1>"
             */
            StringBuilder enColVal = new StringBuilder();

            for (int i = 0; i < fixedTextParts.size(); i++) {
                enColVal.append(fixedTextParts.get(i));
                if (i < placeholders.size()) {
                    enColVal.append("<!");
                    enColVal.append(placeholders.get(i));
                    enColVal.append(">");
                }
            }
            return enColVal.toString();
        }

        private Transformer.TransformOption getTransformOption(int i){
            PlaceholderType placeholderType = PlaceholderType.valueOf(getPlaceholderName(i).replaceAll("[0-9]", ""));
            RuneLingualConfig.ingameTranslationConfig config;
            switch (placeholderType) {
                case PLAYER_NAME:
                    return Transformer.TransformOption.AS_IS;
                case ITEM_NAME:
                    config = plugin.getConfig().getItemNamesConfig();
                    if (config.equals(RuneLingualConfig.ingameTranslationConfig.USE_LOCAL_DATA)) {
                        return Transformer.TransformOption.TRANSLATE_LOCAL;
                    } else if (config.equals(RuneLingualConfig.ingameTranslationConfig.USE_API)) {
                        return Transformer.TransformOption.TRANSLATE_API;
                    } else {
                        return Transformer.TransformOption.AS_IS;
                    }
                case NPC_NAME:
                    config = plugin.getConfig().getNPCNamesConfig();
                    if (config.equals(RuneLingualConfig.ingameTranslationConfig.USE_LOCAL_DATA)) {
                        return Transformer.TransformOption.TRANSLATE_LOCAL;
                    } else if (config.equals(RuneLingualConfig.ingameTranslationConfig.USE_API)) {
                        return Transformer.TransformOption.TRANSLATE_API;
                    } else {
                        return Transformer.TransformOption.AS_IS;
                    }
                case OBJECT_NAME:
                    config = plugin.getConfig().getObjectNamesConfig();
                    if (config.equals(RuneLingualConfig.ingameTranslationConfig.USE_LOCAL_DATA)) {
                        return Transformer.TransformOption.TRANSLATE_LOCAL;
                    } else if (config.equals(RuneLingualConfig.ingameTranslationConfig.USE_API)) {
                        return Transformer.TransformOption.TRANSLATE_API;
                    } else {
                        return Transformer.TransformOption.AS_IS;
                    }
                case ANY_TRANSLATED:
                    // after trying to translate but failed, if api config for interface is on, try to translate with api
                    return Transformer.TransformOption.TRANSLATE_LOCAL;
                default:
                    return Transformer.TransformOption.AS_IS;
            }
        }

        private String getPlaceholderName(int i){
            return placeholders.get(i);
        }

        public List<String> translateAllPlaceholders(List<String> originalTexts, Colors defaultColor, Colors[] placeholdedColors){
            List<String> translatedPlaceholders = new ArrayList<>();
            for (int i = 0; i < placeholders.size(); i++) {
                String originalText = originalTexts.get(i);
                Transformer.TransformOption option = getTransformOption(i);
                SqlQuery query = new SqlQuery(plugin);
                PlaceholderType placeholderType = PlaceholderType.valueOf(getPlaceholderName(i).replaceAll("[0-9]", ""));
                Colors placeholderColor = getPlaceholderColor(fixedTextParts.get(i), defaultColor, placeholdedColors);
                getQuery4PlaceholderType(originalText, placeholderType, defaultColor, query);
                String translatedText = transformer.transform(originalText, placeholderColor, option, query, false);
                if (translatedText.equals(Colors.surroundWithColorTag(originalText, placeholderColor))) { // if the translation failed
                    if(!option.equals(Transformer.TransformOption.AS_IS)) {
                        return null;
                    }
                    if(placeholderType.equals(PlaceholderType.ANY_TRANSLATED) // if the placeholder type is ANY_TRANSLATED and api config for interface is on, try to translate with api
                            && plugin.getConfig().getInterfaceTextConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)){
                        translatedText = transformer.transform(originalText, placeholderColor, Transformer.TransformOption.TRANSLATE_API, query, false);
                    }
                }
                translatedPlaceholders.add(translatedText);
            }
            return translatedPlaceholders;
        }
    }

    public static Colors getPlaceholderColor(String text, Colors defaultColor, Colors[] colors){
        /*
         * placeholder color will always be the last color in the array
         * eg. text = "slay <colNum0>", colors = ["ff0000", "ffffff"] -> colNum0 is always the last color so return Color for ffffff
         */

        if (text.matches(".*<col.*?>$")) { // if the text ends with a color tag
            return colors[colors.length-1]; // return the last color in the array
        }

        return defaultColor;
    }

    public void addPartialTranslation(List<String> fixedTextParts,
                                        List<PlaceholderType> placeholders){
            partialTranslations.add(new PartialTranslation(plugin, transformer, fixedTextParts, placeholders));
    }

    public void addPartialTranslation(int id, List<String> fixedTextParts,
                                      List<PlaceholderType> placeholders){
        PartialTranslation partialTranslation = new PartialTranslation(plugin, transformer, fixedTextParts, placeholders);
        partialTranslation.setId(id);
        partialTranslations.add(partialTranslation);
    }

    public static String protectPlaceholderTags(String text){
        // surround <!.*> tags with <asis> and </asis> to prevent them from being turned into char images
        return text.replaceAll("<!(.+?)>", "<asis><!$1></asis>");
    }

    public boolean hasId(int id){
        return partialTranslations.stream().anyMatch(partialTranslation -> partialTranslation.getId() == id);
    }
    public String getEnColVal(int id, String text) {
        // Get a list of partial translations that match the given id
        List<PartialTranslation> matchingTranslationsIds = partialTranslations.stream()
                .filter(partialTranslation -> partialTranslation.getId() == id)
                .collect(Collectors.toList());

        // Iterate through the matching translations and find one that matches the text
        for (PartialTranslation partialTranslation : matchingTranslationsIds) {
            if (doesStringMatchEnColVal(text, partialTranslation.getEnColVal())) {
                return partialTranslation.getEnColVal();
            }
        }

        // Return null if no match is found
        return null;
    }

    // Helper function to check if the text matches the enColVal pattern
    // enColVal = "slay <!NPC_NAME0> in <!LOCATION_NAME1>"
    // text = "slay blue dragons in Taverley"
    private boolean doesStringMatchEnColVal(String text, String enColVal) {
        if (text == null || enColVal == null) {
            return false;
        }
        if(text.equals(enColVal)){
            return true;
        }
        // Escape special regex characters in the template except for the placeholder
        String regex = enColVal.replaceAll("([\\\\.*+\\[\\](){}|^$])", "\\\\$1")
                .replaceAll("<!.+?>", ".*")
                .replaceAll("<colNum\\d+>", "<col=.*?>")
                .replaceAll("<Num\\d+>", "\\\\d+");
        return text.matches(regex);
    }
    public String translateWidget(Widget widget, String translationWithPlaceHolder, String originalText, Colors defaultColor) {
        String enColVal = getEnColVal(widget.getId(), widget.getText());
        return translate(enColVal, translationWithPlaceHolder, originalText, defaultColor);
    }
    public String translateString(String textToTranslate, String translationWithPlaceHolder, String originalText, Colors defaultColor) {
        String enColVal = getMatchingEnColVal(textToTranslate);
        return translate(enColVal, translationWithPlaceHolder, originalText, defaultColor);
    }
    public String translate(String enColVal, String translationWithPlaceHolder, String originalText, Colors defaultColor) {
        // for widgets like "slay <!NPC_NAME0> in <!LOCATION_NAME1>", where only the part of the text should be translated
        // originalText = "slay blue dragons in Taverley",
        // translationWithPlaceHolder = "<col=0><!LOCATION_NAME0></col>にいる<col=0><!NPC_NAME0></col>を討伐せよ" (the translated character can be char images like <img=23432>)

        // process:
        // 1. translate text in the tags, "blue dragons" and "Taverley" in this case
        // 2. replace the tags in the translation with the translated text ("ターベリーにいる青い竜を討伐せよ" (Taverley = ターベリー, blue dragons = 青い竜))
        // 3. return the translation with the replaced text

         // enColVal = "slay <!NPC_NAME0> in <!LOCATION_NAME0>"
        if (enColVal == null || translationWithPlaceHolder == null) {
            return Colors.surroundWithColorTag(originalText, defaultColor);
        }

        // from the originalText and enColVal, get the content of each placeholders
        // eg. <!NPC_NAME0> = blue dragons, <!LOCATION_NAME0> = Taverley
        String originalWithoutColNum = originalText.replaceAll("<[^!]+?>", ""); // remove all tags that doesn't start with <! (eg. <col=ffffff>), which means they are not placeholders for partial translation
        String enColValWithoutColNum = enColVal.replaceAll("(<col.*?>)|(</col>)", "");
        Map<String, String> placeholder2Content = GeneralFunctions.getPlaceholder2Content(originalWithoutColNum, enColValWithoutColNum); // {"NPC_NAME0": "blue dragons", "LOCATION_NAME0": "Taverley"}

        // translationWithPlaceholder's color tag is specific (eg. <col=ffffff>), but the text given at initialization is not (eg. <colNum0>)
        // so, replace the color tag with color placeholder tag, then turn it back later
        List<String> colorList = Colors.getColorTagsAsIs(translationWithPlaceHolder); // get the color tags in the translation, eg. ["ffffff"]
        Colors[] colorArray = Colors.getColorArray(translationWithPlaceHolder, defaultColor);
        translationWithPlaceHolder = Colors.getColorPlaceholdedColWord(translationWithPlaceHolder); // eg. "<colNum0><!LOCATION_NAME0></colNum0>にいる<colNum1><!NPC_NAME0></colNum1>を討伐せよ"


        PartialTranslation partialTranslation = partialTranslations.stream() //partialTranslation = "slay <!NPC_NAME0> in <!LOCATION_NAME0>"
                .filter(partialTranslation1 -> partialTranslation1.getEnColVal().equals(enColVal))
                .findFirst()
                .orElse(null);

        // translate the content of each placeholders
        assert partialTranslation != null;
        List<String> phContent = new ArrayList<>(placeholder2Content.values()); // phContent = ["blue dragons", "Taverley"]
        if(phContent.isEmpty()){
            return Colors.surroundWithColorTag(originalText, defaultColor);
        }
        List<String> translatedPlaceholders = partialTranslation.translateAllPlaceholders(phContent, defaultColor, colorArray); // translatedPlaceholders = ["青い竜", "ターベリー"]

        if (translatedPlaceholders == null) {
            // return the original text if the translation failed
            return Colors.surroundWithColorTag(originalText, defaultColor);
        }
        for (int i = 0; i < translatedPlaceholders.size(); i++) {
            String translatedPlaceholder = translatedPlaceholders.get(i); // translatedPlaceholder = "青い竜"
            String placeholderName = partialTranslation.getPlaceholderName(i); // placeholderName = "NPC_NAME0"
            translationWithPlaceHolder = translationWithPlaceHolder.replaceAll("<!" + placeholderName + ">", translatedPlaceholder);
        }
        translationWithPlaceHolder = Colors.getOriginalColorWord(translationWithPlaceHolder, colorList); // turn the color placeholder tags back to color tags
        return translationWithPlaceHolder;

    }

    protected static void getQuery4PlaceholderType(String text, PlaceholderType type, Colors defaultColor, SqlQuery query){
        if (type == PlaceholderType.PLAYER_NAME) {
            query.setGenMenuAcitons(text, defaultColor);
        } else if (type == PlaceholderType.ITEM_NAME) {
            query.setItemName(text, defaultColor);
        } else if (type == PlaceholderType.NPC_NAME) {
            query.setNpcName(text, defaultColor);
        } else if (type == PlaceholderType.OBJECT_NAME) {
            query.setObjectName(text, defaultColor);
        } else if (type == PlaceholderType.ANY_TRANSLATED) {
            query.setEnglish(text);
            query.setColor(defaultColor);
        }
    }

    /*
    * Check if the widget text matches the enColVal of the partial translation.
    * Searches by id given at initialization.
    * eg. "slay blue dragons in Taverley" matches "slay <!NPC_NAME0> in <!LOCATION_NAME0>"
     */
    public boolean stringMatchesEnColVal(String text, int id) {
        if(!hasId(id)){
            return false;
        }
        String template = getEnColVal(id, text);
        // Escape special regex characters in the template except for the placeholder
        String regex = template.replaceAll("([\\\\.*+\\[\\](){}|^$])", "\\\\$1")
                .replaceAll("<!.+?>", ".*");
        return text.matches(regex);
    }

    /*
     * Check if the text matches the enColVal of the partial translation (doesnt need widget id)
     * Checks only text pattern
     * eg. "slay blue dragons in Taverley" matches "slay <!NPC_NAME0> in <!LOCATION_NAME0>"
     */
    public boolean doesStringMatchEnColVal(String text) {
        for(PartialTranslation partialTranslation : partialTranslations){
            // Escape special regex characters in the template except for the placeholder
            String regex = getRegex(partialTranslation);
            if(text.matches(regex)){
                return true;
            }
        }
        return false;
    }

    public String getMatchingEnColVal(String text) {
        List<String> matchingEnColVals = getMatchingEnColValList(text);
        if(matchingEnColVals != null && !matchingEnColVals.isEmpty()){
            return matchingEnColVals.get(0);
        }
        // If no match is found, return null
        return null;
    }

    public List<String> getMatchingEnColValList(String text) {
        text = Colors.getEnumeratedColorWord(text);
        List<String> matchingEnColVals = new ArrayList<>();
        for(PartialTranslation partialTranslation : partialTranslations){
            // Escape special regex characters in the template except for the placeholder
            String regex = getRegex(partialTranslation);
            if(text.matches(regex)){
                matchingEnColVals.add(partialTranslation.getEnColVal());
            }
        }
        if(!matchingEnColVals.isEmpty()){
            return matchingEnColVals;
        }
        return null;
    }

    private String getRegex(PartialTranslation partialTranslation) {
        String regex = partialTranslation.getEnColVal().replaceAll("([\\\\.*+\\[\\](){}|^$])", "\\\\$1")
                .replaceAll("<!.+?>", ".*")
                .replaceAll("<asis>|</asis>", "")
                .replaceAll("<autoBr>|</autoBr>","");
        regex = regex + "|" + regex.replaceAll("<Num\\d>", "\\\\d+")
                                .replaceAll("<colNum\\d+>", "<col.+>");
        return regex;
    }
}

package com.RuneLingual.Widgets;

public class ChatButtonTranslator {

}
package com.RuneLingual.Widgets;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.SQL.SqlQuery;
import com.RuneLingual.SQL.SqlVariables;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Ids;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.*;

import javax.inject.Inject;
import java.awt.*;
import java.util.*;

import static com.RuneLingual.Widgets.WidgetsUtilRLingual.removeBrAndTags;
import static com.RuneLingual.debug.OutputToFile.appendIfNotExistToFile;

@Slf4j
public class WidgetCapture {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    Client client;
    @Inject
    private Transformer transformer;


    @Inject
    private WidgetsUtilRLingual widgetsUtilRLingual;
    @Inject
    private DialogTranslator dialogTranslator;
    @Inject
    private Ids ids;
    @Getter
    Set<String> pastTranslationResults = new HashSet<>();


    @Inject
    public WidgetCapture(RuneLingualPlugin plugin) {
        this.plugin = plugin;
        ids = this.plugin.getIds();
    }

    public void translateWidget() {
        if (plugin.getConfig().getInterfaceTextConfig() == RuneLingualConfig.ingameTranslationConfig.DONT_TRANSLATE) {
            return;
        }
        Widget[] roots = client.getWidgetRoots();
        SqlQuery sqlQuery = new SqlQuery(this.plugin);
        for (Widget root : roots) {
            translateWidgetRecursive(root, sqlQuery);
        }
    }

    private void translateWidgetRecursive(Widget widget,SqlQuery sqlQuery) {
        int widgetId = widget.getId();

        // stop the recursion if the widget is hidden, outside the window or should be ignored
        // without the isOutsideWindow check, client will lag heavily when opening deep widget hierarchy, like combat achievement task list
        if (widget.isHidden() || (!isInLobby() && isOutsideWindow(widget)) || ids.getWidgetIdNot2Translate().contains(widgetId)) {
            return;
        }
        if (ids.getWidgetIdNot2ApiTranslate().contains(widgetId)
                && plugin.getConfig().getInterfaceTextConfig() == RuneLingualConfig.ingameTranslationConfig.USE_API) {
            return;
        }

        // skip all chatbox widgets for now TODO: chatbox buttons should be translated
        int widgetGroup = WidgetUtil.componentToInterface(widgetId);
        modifySqlQuery4Widget(widget, sqlQuery);

        // recursive call
        for (Widget dynamicChild : widget.getDynamicChildren()) {
            translateWidgetRecursive(dynamicChild, sqlQuery);
        }
        for (Widget nestedChild : widget.getNestedChildren()) {
            translateWidgetRecursive(nestedChild, sqlQuery);
        }
        for (Widget staticChild : widget.getStaticChildren()) {
            translateWidgetRecursive(staticChild, sqlQuery);
        }

        // translate the widget text////////////////
        // dialogues are handled separately
        if (widgetGroup == InterfaceID.DIALOG_NPC
                || widgetGroup == InterfaceID.DIALOG_PLAYER
                || widgetGroup == InterfaceID.DIALOG_OPTION) {
            dialogTranslator.handleDialogs(widget);
            alignIfChatButton(widget);
            return;
        }

        if(shouldTranslateWidget(widget)) {
            if (plugin.getConfig().getInterfaceTextConfig() == RuneLingualConfig.ingameTranslationConfig.USE_API
                 && plugin.getConfig().ApiConfig()) {
                translateWidgetApi(widget);
                return;
            }

            SqlQuery queryToPass = sqlQuery.copy();
            // replace sqlQuery if they are defined as item, npc, object, quest names
            Colors textColor = Colors.getColorFromHex(Colors.IntToHex(widget.getTextColor()));
            if (isChildWidgetOf(widget, ComponentID.CHATBOX_BUTTONS)) { // chat buttons
                queryToPass.setCategory(SqlVariables.categoryValue4Interface.getValue());
                queryToPass.setSubCategory(SqlVariables.subCategoryValue4ChatButtons.getValue());
            } else if (isChildWidgetOf(widget, ids.getLoginScreenId())) { // login screen
                queryToPass.setCategory(SqlVariables.categoryValue4Interface.getValue());
                queryToPass.setSubCategory(SqlVariables.subCategoryValue4LoginScreen.getValue());
            } else if (isChildWidgetOf(widget, ids.getWidgetIdCA())) {
                queryToPass.setCategory(SqlVariables.categoryValue4Interface.getValue());
                queryToPass.setSubCategory(SqlVariables.subCategoryValue4CA.getValue());
            }
            else {
                if (queryToPass.getCategory() == null) {
                    queryToPass.setCategory(SqlVariables.categoryValue4Interface.getValue());
                }
                if (queryToPass.getSubCategory() == null) {
                    queryToPass.setSubCategory(SqlVariables.subcategoryValue4GeneralUI.getValue());
                }
            }

            if (ids.getWidgetIdItemName().contains(widgetId)
                && !(widgetId == ComponentID.COMBAT_WEAPON_NAME && Objects.equals(widget.getText(), "Unarmed")) // "Unarmed" in combat tab is not an item
                ) {
                    String itemName = Colors.removeNonImgTags(widget.getText());
                    queryToPass.setItemName(itemName, textColor);
            } else if (ids.getWidgetIdNpcName().contains(widgetId)) {
                String npcName = Colors.removeNonImgTags(widget.getText());
                queryToPass.setNpcName(npcName, textColor);
            } else if (ids.getWidgetIdObjectName().contains(widgetId)) {
                String objectName = Colors.removeNonImgTags(widget.getText());
                queryToPass.setObjectName(objectName, textColor);
            } else if (ids.getWidgetIdQuestName().contains(widgetId)) {
                String questName = Colors.removeNonImgTags(widget.getText());
                queryToPass.setQuestName(questName, textColor);
            } else {
                queryToPass.setColor(textColor);
            }
            // debug: if the widget is the target for dumping
            ifIsDumpTarget_thenDump(widget, queryToPass);
            // translate the widget text
            translateWidgetText(widget, queryToPass);

            alignIfChatButton(widget);
        }
    }

    private void translateWidgetApi(Widget widget) {
        String text = widget.getText();
        Colors color = Colors.getColorArray(widget.getText(), Colors.getColorFromHex(Colors.IntToHex(widget.getTextColor())))[0];
        widgetsUtilRLingual.setWidgetText_ApiTranslation(widget, text, color);
        widgetsUtilRLingual.changeWidgetSize_ifNeeded(widget);
    }

    private void modifySqlQuery4Widget(Widget widget, SqlQuery sqlQuery) {
        sqlQuery.setColor(Colors.getColorFromHex(Colors.IntToHex(widget.getTextColor())));
        int widgetId = widget.getId();
        if (widgetId == ids.getWidgetIdSkillGuide()) { //Id for parent of skill guide, or parent of element in list
            sqlQuery.setGeneralUI(SqlVariables.sourceValue4SkillGuideInterface.getValue());
        }
        /* example of using Sets:
        if (ids.getWidgetIdPlayerName().contains(widgetId)) {
            sqlQuery.setPlayerName(widget.getText(), sqlQuery.getColor());
        }
         */
        // add more general UIs here

        // if one of the main tabs, set the category and subcategory. main tabs = combat options, skills tab, etc.
        if (widgetId == ids.getWidgetIdMainTabs()) {
            sqlQuery.setCategory(SqlVariables.categoryValue4Interface.getValue());
            sqlQuery.setSubCategory(SqlVariables.subcategoryValue4MainTabs.getValue());
        }
        // if one of the main tabs, set the source as the tab name
        if (sqlQuery.getCategory() != null && sqlQuery.getCategory().equals(SqlVariables.categoryValue4Interface.getValue())
                && sqlQuery.getSubCategory() != null && sqlQuery.getSubCategory().equals(SqlVariables.subcategoryValue4MainTabs.getValue())) {
            // set the source as the tab name
            if (widgetId == ids.getWidgetIdAttackStyleTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4CombatOptionsTab.getValue());
            } else if (widgetId == ids.getWidgetIdSkillsTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4SkillsTab.getValue());
            } else if (widgetId == ids.getWidgetIdCharacterSummaryTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4CharacterSummaryTab.getValue());
            } else if (widgetId == ids.getWidgetIdQuestTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4QuestListTab.getValue());
            } else if (widgetId == ids.getWidgetIdAchievementDiaryTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4AchievementDiaryTab.getValue());
            } else if (widgetId == ids.getWidgetIdPrayerTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4PrayerTab.getValue());
            } else if (widgetId == ids.getWidgetIdSpellBookTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4SpellBookTab.getValue());
            } else if (widgetId == ids.getWidgetIdGroupsTab() || widgetId == ids.getWidgetIdGroupTabNonGIM() || widgetId == ids.getWidgetIdPvPArena()) {
                sqlQuery.setSource(SqlVariables.sourceValue4GroupTab.getValue());
            } else if (widgetId == ids.getWidgetIdFriendsTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4FriendsTab.getValue());
            } else if (widgetId == ids.getWidgetIdIgnoreTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4IgnoreTab.getValue());
            } else if (widgetId == ids.getWidgetIdAccountManagementTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4AccountManagementTab.getValue());
            } else if (widgetId == ids.getWidgetIdSettingsTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4SettingsTab.getValue());
            } else if (widgetId == ids.getWidgetIdEmotesTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4EmotesTab.getValue());
            } else if (widgetId == ids.getWidgetIdMusicTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4MusicTab.getValue());
            } else if (widgetId == ids.getWidgetIdLogoutTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4LogoutTab.getValue());
            } else if (widgetId == ids.getWidgetIdWorldSwitcherTab()) {
                sqlQuery.setSource(SqlVariables.sourceValue4WorldSwitcherTab.getValue());
            }
        }
    }

    private void translateWidgetText(Widget widget, SqlQuery sqlQuery) {
        int widgetId = widget.getId();
        String originalText = widget.getText();
        String textToTranslate = getEnglishColValFromWidget(widget);
        String translatedText;
        if (ids.getWidgetIdAnyTranslated().contains(widgetId)) {
            sqlQuery.setCategory(null);
            sqlQuery.setSubCategory(null);
            sqlQuery.setSource(null);
            translatedText = getTranslationFromQuery(sqlQuery, originalText, textToTranslate);
        } else if (widgetsUtilRLingual.shouldPartiallyTranslateWidget(widget)) {
            // for widgets like "Name: <playerName>" (found in accounts management tab), where only the part of the text should be translated
            // order:
            // textToTranslate = "Name: <playerName>" -> translatedText = "名前: <playerName>" -> translatedText = "名前: Durial321"
            String translationWithPlaceHolder = getTranslationFromQuery(sqlQuery, originalText, textToTranslate);
            translatedText = ids.getPartialTranslationManager().translateWidget(widget, translationWithPlaceHolder, originalText, sqlQuery.getColor());
        } else if (!ids.getWidgetId2SplitTextAtBr().contains(widgetId)// for most cases
            && !ids.getWidgetId2KeepBr().contains(widgetId)) {
            translatedText = getTranslationFromQuery(sqlQuery, originalText, textToTranslate);
        } else if (ids.getWidgetId2SplitTextAtBr().contains(widgetId)){// for widgets that have <br> in the text and should be kept where they are, translate each line separately
            String[] textList = textToTranslate.split("<br>");
            String[] originalTextList = originalText.split("<br>");
            StringBuilder translatedTextBuilder = new StringBuilder();

            for (int i = 0; i < textList.length; i++) {
                String text = textList[i];
                String originalTextLine = originalTextList[i];
                String translatedTextPart = getTranslationFromQuery(sqlQuery, originalTextLine, text);
                if (translatedTextPart == null) { // if translation failed
                    return;
                }
                translatedTextBuilder.append(translatedTextPart);
                if (i != textList.length - 1) { // if it's not the last line, add <br>
                    translatedTextBuilder.append("<br>");
                }
            }

            translatedText = translatedTextBuilder.toString();
        } else { // if(ids.getWidgetId2KeepBr().contains(widgetId))
            // for widgets that have <br> in the text and should be kept where they are, translate the whole text
            translatedText = getTranslationFromQuery(sqlQuery, originalText, textToTranslate);
        }

        // translation was not available

        if(translatedText == null){ // if the translation is the same as the original with <br>
            return;
        }
        String originalWithoutBr = removeBrAndTags(originalText);
        String translationWithoutBr = removeBrAndTags(translatedText);
        if(Objects.equals(translatedText, originalText) // if the translation is the same as the original
                || originalWithoutBr.equals(translationWithoutBr)){ // if the translation is the same as the original without <br>
            return;
        }

        pastTranslationResults.add(translatedText);

        if (ids.getWidgetId2SplitTextAtBr().contains(widgetId)
                || ids.getWidgetId2KeepBr().contains(widgetId)
                || ids.getWidgetId2FixedSize().containsKey(widgetId)) {
            widgetsUtilRLingual.setWidgetText_BrAsIs(widget, translatedText);
        } else {
            widgetsUtilRLingual.setWidgetText_NiceBr(widget, translatedText);
        }
        widgetsUtilRLingual.changeLineHeight(widget);
        widgetsUtilRLingual.changeWidgetSize_ifNeeded(widget);
    }

    private String getTranslationFromQuery(SqlQuery sqlQuery, String originalText, String textToTranslate) {
        sqlQuery.setEnglish(textToTranslate);
        Transformer.TransformOption option = Transformer.TransformOption.TRANSLATE_LOCAL;
        return transformer.transformWithPlaceholders(originalText, textToTranslate, option, sqlQuery);
    }


    private boolean shouldTranslateWidget(Widget widget) {
        int widgetId = widget.getId();

        return shouldTranslateText(widget.getText())
                && widget.getType() == WidgetType.TEXT
                && widget.getFontId() != -1 // if font id is -1 it's probably not shown
                && !ids.getWidgetIdNot2Translate().contains(widgetId)
                && !isWidgetIdNot2Translate(widget);
    }

    public boolean isWidgetIdNot2Translate(Widget widget) {
        int widgetId = widget.getId();
        boolean isFriendsListNames = ComponentID.FRIEND_LIST_NAMES_CONTAINER == widgetId
                    && widget.getXTextAlignment() == WidgetTextAlignment.LEFT;
        boolean isGimMemberNames = ids.getGimMemberNameId() == widgetId
                    && widget.getXTextAlignment() == WidgetTextAlignment.LEFT
                    && widget.getTextColor() == 0xffffff; // if not white text its "Vacancy". use color because "Vacancy" could be player name
        boolean isFriendsChatList = ComponentID.FRIENDS_CHAT_LIST == widgetId
                    && widget.getType() == WidgetType.TEXT && widget.getTextColor() == 0xffffff; // check colors so its not world #
        boolean isFcTitleOrOwner = (ComponentID.FRIENDS_CHAT_TITLE == widgetId || ComponentID.FRIENDS_CHAT_OWNER == widgetId)
                && client.getFriendsChatManager() != null;
        // if its orange text, its clan name, world, member count etc,
        // but if its grey its "Your Clan" and "No current clan" which is displayed when not in a clan
        boolean isClanName = ComponentID.CLAN_HEADER == widgetId
                    && widget.getTextColor() == 0xe6981f;
        boolean isClanMemberName = ComponentID.CLAN_MEMBERS == widgetId
                    && widget.getTextColor() == 0xffffff;
        boolean isGuesClanName = ComponentID.CLAN_GUEST_HEADER == widgetId
                    && widget.getTextColor() == 0xe6981f;
        boolean isGuestClanMemberName = ComponentID.CLAN_GUEST_MEMBERS == widgetId
                    && widget.getTextColor() == 0xffffff;
        boolean isPvPMemberName = ids.getGroupTabPvPGroupMemberId() == widgetId
                    && (widget.getTextColor() == 0xffffff || widget.getTextColor() == 0x9f9f9f);
        boolean isGroupingGroupMemberName = ids.getGroupingGroupMemberNameId() == widgetId
                && widget.getTextColor() == 0xffffff;

        return isFriendsListNames || isGimMemberNames || isFcTitleOrOwner || isFriendsChatList || isClanMemberName || isClanName
                || isGuesClanName || isGuestClanMemberName || isPvPMemberName || isGroupingGroupMemberName;
    }

    /* check if the text should be translated
     * returns true if the text contains letters excluding tags, has at least 1 alphabet, and has not been translated
     */
    private boolean shouldTranslateText(String text) {
        String modifiedText = text.trim();
        modifiedText = Colors.removeAllTags(modifiedText);
        return !modifiedText.isEmpty()
                && !pastTranslationResults.contains(text)
                && modifiedText.matches(".*[a-zA-Z].*")
                && !plugin.getConfig().getInterfaceTextConfig().equals(RuneLingualConfig.ingameTranslationConfig.DONT_TRANSLATE);
    }

    /*
      * get the English text from the widget that should be identical to the corresponding sql column value
      * used when creating the dump file for manual translation
      * and when searching for English added manually originating from the dump file
     */
    public String getEnglishColValFromWidget(Widget widget) {
        String text = widget.getText();
        if (text == null) {
            return "";
        }

        text = SqlQuery.replaceSpecialSpaces(text);
        text = Colors.getEnumeratedColorWord(text);
        text = SqlQuery.replaceNumbersWithPlaceholders(text);
        if (!ids.getWidgetId2SplitTextAtBr().contains(widget.getId())
                && !ids.getWidgetId2KeepBr().contains(widget.getId())) {
            text = text.replace(" <br>", " ");
            text = text.replace("<br> ", " ");
            text = text.replace("<br>", " ");
        }

        // special case: if the text should only be partially translated
        if (widgetsUtilRLingual.shouldPartiallyTranslateWidget(widget)) {
            String enColVal = ids.getPartialTranslationManager().getMatchingEnColVal(widget.getText());
            return widgetsUtilRLingual.getEnColVal4PartialTranslation(widget, enColVal);
        }

        return text;
    }



    // used for creating the English transcript used for manual translation
    private void ifIsDumpTarget_thenDump(Widget widget, SqlQuery sqlQuery) {
//        if (sqlQuery.getSource() != null &&
//                (sqlQuery.getSource().equals(SqlVariables.sourceValue4FriendsTab.getValue())
//        || sqlQuery.getSource().equals(SqlVariables.sourceValue4IgnoreTab.getValue())
//        || sqlQuery.getSource().equals(SqlVariables.sourceValue4AccountManagementTab.getValue()))) {
        //if (sqlQuery.getSource() != null && sqlQuery.getSource().equals(SqlVariables.sourceValue4MusicTab.getValue())){
        if (isChildWidgetOf(widget, ids.getWidgetIdCA())){// change for new dump category
            if (widget.getText() == null || !shouldTranslateWidget(widget)) {
                return;
            }
            String fileName = "combAchvmt.txt"; // change for new dump category
            String textToDump = getEnglishColValFromWidget(widget);

            // for partial translation
            if (widgetsUtilRLingual.shouldPartiallyTranslateWidget(widget)) {
                textToDump = widgetsUtilRLingual.getEnColVal4PartialTranslation(widget, ids.getPartialTranslationManager().getMatchingEnColVal(widget.getText()));
            }
            String category = sqlQuery.getCategory();
            String subCategory = sqlQuery.getSubCategory();
            String source = sqlQuery.getSource();
            if (category == null) {
                category = "";
            }
            if (subCategory == null) {
                subCategory = "";
            }
            if (source == null) {
                source = "";
            }
            if (ids.getWidgetIdAnyTranslated().contains(widget.getId())) {
                return;
                //appendIfNotExistToFile(textToDump + "\t\t\t", fileName);
            } else if (ids.getWidgetId2SplitTextAtBr().contains(widget.getId())) {
                String[] textList = textToDump.split("<br>");
                for (String text : textList) {
                    appendIfNotExistToFile(text + "\t" + category +
                            "\t" + subCategory +
                            "\t" + source, fileName);
                }
            } else {
                appendIfNotExistToFile(textToDump + "\t" + category +
                        "\t" + subCategory +
                        "\t" + source, fileName);
            }
        }

    }

    private boolean isChildWidgetOf(Widget widget, int parentWidgetId) {
        Widget parent = widget.getParent();
        while (parent != null) {
            if (parent.getId() == parentWidgetId) {
                return true;
            }
            parent = parent.getParent();
        }
        return false;
    }

    private boolean isChildWidgetOf(Widget widget, Set<Integer> parentWidgetIds) {
        Widget parent = widget.getParent();
        while (parent != null) {
            if (parentWidgetIds.contains(parent.getId())) {
                return true;
            }
            parent = parent.getParent();
        }
        return false;
    }

    private void alignIfChatButton(Widget widget) {
        int widgetId = widget.getId();
        if(ids.getWidgetIdChatButton2SetXTextAliLeft().contains(widgetId) && plugin.getConfig().getSelectedLanguage().isChatButtonHorizontal()) {
            widget.setXTextAlignment(WidgetTextAlignment.LEFT);
        } else if (ids.getWidgetIdChatButton2SetXTextAliRight().contains(widgetId) && plugin.getConfig().getSelectedLanguage().isChatButtonHorizontal()) {
            widget.setXTextAlignment(WidgetTextAlignment.RIGHT);
        }
    }

    private boolean isOutsideWindow(Widget widget) {
        Widget canvasWidget = client.getWidget(ids.getRootWidgetId());
        if (canvasWidget == null) {
            return true;
        }
        Rectangle canvasRec = canvasWidget.getBounds();
        Rectangle widgetRec = widget.getBounds();
        return widgetRec.x + widgetRec.width < canvasRec.x
                || widgetRec.x > canvasRec.x + canvasRec.width
                || widgetRec.y + widgetRec.height < canvasRec.y
                || widgetRec.y > canvasRec.y + canvasRec.height;
    }

    private boolean isInLobby() {
        Widget loginWidget = client.getWidget(ids.getLoginScreenId());
        return loginWidget != null && !loginWidget.isHidden();
    }
}


package com.RuneLingual.Widgets;

import com.RuneLingual.*;
import com.RuneLingual.SQL.SqlQuery;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.commonFunctions.Transformer.TransformOption;
import com.RuneLingual.nonLatin.GeneralFunctions;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;

import net.runelite.api.widgets.WidgetUtil;

import static com.RuneLingual.Widgets.WidgetsUtilRLingual.removeBrAndTags;


@Slf4j
public class DialogTranslator {
    // Dialog happens in a separate widget than the ChatBox itself
    // not limited to npc conversations themselves, but also chat actions
    @Inject
    private Client client;
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private RuneLingualConfig config;

    // player widget ids
    @Getter
    private final int playerNameWidgetId = 14221316;
    @Getter
    private final int playerContinueWidgetId = 14221317;
    @Getter
    private final int playerContentWidgetId = 14221318;

    // npc widget ids
    @Getter
    private final int npcNameWidgetId = 15138820;
    @Getter
    private final int npcContinueWidgetId = 15138821;
    @Getter
    private final int npcContentWidgetId = 15138822;

    // dialog option widget ids
    @Getter
    private final int dialogOptionWidgetId = 14352385; // each and every line of the option dialogue has this id, even the red "select an option" text


    private final Colors defaultTextColor = Colors.black;
    private final Colors continueTextColor = Colors.blue;
    private final String continueText = "Click here to continue";
    private final Colors nameAndSelectOptionTextColor = Colors.red;
    private final String selectOptionText = "Select an option";
    private final Colors pleaseWaitTextColor = Colors.blue;
    private final String pleaseWaitText = "Please wait...";

    private TransformOption dialogOption;
    private TransformOption npcNameOption;
    @Inject
    Transformer transformer;

    @Inject
    private GeneralFunctions generalFunctions;
    @Inject
    private WidgetsUtilRLingual widgetsUtilRLingual;

    @Inject
    public DialogTranslator(RuneLingualConfig config, Client client, RuneLingualPlugin plugin) {
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        this.transformer = new Transformer(plugin);
    }

    public void handleDialogs(Widget widget) {
        if(widget.getText().contains("<img=")) {
            return;
        }
        dialogOption = MenuCapture.getTransformOption(plugin.getConfig().getNpcDialogueConfig(), plugin.getConfig().getSelectedLanguage());
        npcNameOption = MenuCapture.getTransformOption(plugin.getConfig().getNPCNamesConfig(), plugin.getConfig().getSelectedLanguage());
        if ((widget.getId() != npcNameWidgetId && dialogOption.equals(TransformOption.AS_IS))
                || (widget.getId() == npcNameWidgetId && npcNameOption.equals(TransformOption.AS_IS))) {
            return;
        }

        int interfaceID = WidgetUtil.componentToInterface(widget.getId());

        // if the widget is the npc name widget, and the config is set to use api translation
        if (npcNameOption.equals(TransformOption.TRANSLATE_API) && widget.getId() == npcNameWidgetId) {
            String npcName = widget.getText();
            widgetsUtilRLingual.setWidgetText_ApiTranslation(widget, npcName, nameAndSelectOptionTextColor);
            return;
        }
        // if the widget is not npc name nor player name, and the config is set to use api translation
        else if (dialogOption.equals(TransformOption.TRANSLATE_API) && widget.getId() != playerNameWidgetId && widget.getId() != npcNameWidgetId) {
            String dialogText = widget.getText();
            if(dialogText.isEmpty()) {
                return;
            }
            Colors[] textColor = {defaultTextColor};
            if(widget.getId() == npcContinueWidgetId || widget.getId() == playerContinueWidgetId)
                textColor[0] = continueTextColor;
            else if(widget.getId() == dialogOptionWidgetId && widget.getText().equals(selectOptionText))
                textColor[0] = nameAndSelectOptionTextColor;

            widgetsUtilRLingual.setWidgetText_ApiTranslation(widget, dialogText, textColor[0]);
            return;
        }

        // is not api translation
        switch (interfaceID) {
            case InterfaceID.DIALOG_NPC:
                handleNpcDialog(widget);
                return;
            case InterfaceID.DIALOG_PLAYER:
                handlePlayerDialog(widget);
                return;
            case InterfaceID.DIALOG_OPTION:
                handleOptionDialog(widget);
                return;
            default:
                break;
        }
        log.info("Unknown dialog widget: " + widget.getId());
    }

    // is not api translation
    private void handleNpcDialog(Widget widget) {
        if (widget.getId() == npcNameWidgetId) {
            String npcName = widget.getText();
            npcName = removeBrAndTags(npcName);

            SqlQuery query = new SqlQuery(this.plugin);
            query.setNpcName(npcName, nameAndSelectOptionTextColor);
            String translatedText = transformer.transform(npcName, nameAndSelectOptionTextColor,
                    npcNameOption, query, false);
            widget.setText(translatedText);
        } else if (widget.getId() == npcContinueWidgetId) {
            translateContinueWidget(widget);
        } else if (widget.getId() == npcContentWidgetId) {
            String npcContent = widget.getText(); // this can contain tags like <br> and probably color tags
            npcContent = removeBrAndTags(npcContent);
            String npcName = getInteractingNpcName();
            SqlQuery query = new SqlQuery(this.plugin);
            query.setDialogue(npcContent, npcName, false, defaultTextColor);
            String translatedText = transformer.transform(npcContent, defaultTextColor, dialogOption, query, false);
            widgetsUtilRLingual.setWidgetText_NiceBr(widget, translatedText);
            widgetsUtilRLingual.changeLineHeight(widget);
        }
    }

    // is not api translation
    private void handlePlayerDialog(Widget widget) {
        if (widget.getId() == playerContinueWidgetId) {
            //log.info(widget.getText());
            translateContinueWidget(widget);
            return;
        }
        if (widget.getId() == playerContentWidgetId) {
            String playerContent = widget.getText(); // this can contain tags like <br> and probably color tags
            playerContent = removeBrAndTags(playerContent);


            String npcName = getInteractingNpcName();
            //log.info("playerContent: " + playerContent + " with npc: " + npcName);

            SqlQuery query = new SqlQuery(this.plugin);
            query.setDialogue(playerContent, npcName, true, defaultTextColor);
            String translatedText = transformer.transform(playerContent, defaultTextColor, dialogOption, query, false);
            widgetsUtilRLingual.setWidgetText_NiceBr(widget, translatedText);
            widgetsUtilRLingual.changeLineHeight(widget);
        }
        // player name does not need to be translated
    }

    private void handleOptionDialog(Widget widget) {
        // the red "Select an option" text is not tagged with red color
        String dialogOption = widget.getText();
        if (dialogOption.equals(selectOptionText)) {
            widget.setText(getSelectOptionTranslation());
            return;
        }
        if (dialogOption.equals(pleaseWaitText)) {
            widget.setText(getPleaseWaitTranslation());
            return;
        }
        dialogOption = removeBrAndTags(dialogOption);
        SqlQuery query = new SqlQuery(this.plugin);
        query.setDialogue(dialogOption, getInteractingNpcName(), false, defaultTextColor);
        String translatedText = transformer.transform(dialogOption, defaultTextColor, this.dialogOption, query, false);
        widgetsUtilRLingual.setWidgetText_NiceBr(widget, translatedText);
        widgetsUtilRLingual.changeLineHeight(widget);
    }

    private String getInteractingNpcName() {
        NPC npc = plugin.getInteractedNpc();
        if (npc == null) {
            return "";
        }
        return npc.getName();
    }

    private String getContinueTranslation() {
        SqlQuery query = new SqlQuery(this.plugin);
        query.setDialogue(continueText, "", true, continueTextColor);
        return transformer.transform(continueText, continueTextColor, dialogOption, query, false);
    }

    private String getSelectOptionTranslation() {
        SqlQuery query = new SqlQuery(this.plugin);
        query.setDialogue(selectOptionText, "", true, nameAndSelectOptionTextColor);
        return transformer.transform(selectOptionText, nameAndSelectOptionTextColor, dialogOption, query, false);
    }

    private String getPleaseWaitTranslation() {
        SqlQuery query = new SqlQuery(this.plugin);
        query.setDialogue(pleaseWaitText, "", true, pleaseWaitTextColor);
        return transformer.transform(pleaseWaitText, pleaseWaitTextColor, dialogOption, query, false);
    }

    private void translateContinueWidget(Widget widget) {
        if (widget.getText().equals(continueText)) {
            widget.setText(getContinueTranslation());
        } else if (widget.getText().equals(pleaseWaitText)) {
            widget.setText(getPleaseWaitTranslation());
        }
    }
}
package com.RuneLingual.Widgets;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Ids;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.nonLatin.GeneralFunctions;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetSizeMode;

import javax.inject.Inject;

public class WidgetsUtilRLingual
{
	@Inject
	private Client client;
	@Inject
	private RuneLingualPlugin plugin;
	@Inject
	private GeneralFunctions generalFunctions;
	@Inject
	private Ids ids;

	@Inject
	public WidgetsUtilRLingual(Client client, RuneLingualPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;
		this.ids = plugin.getIds();
	}

	public void setWidgetText_BrAsIs(Widget widget, String newText)
	{
		if (newText.equals(widget.getText())) // the texts will be the same if the widget has already been translated, or doesn't have a translation available
			return;
		// Set the text of the widget, but keep br as is
		widget.setText(newText);
	}

	public void setWidgetText_NiceBr(Widget widget, String newText) {
		if (newText.contains("<br>") && !newText.contains("<autoBr>")) { // if the text already has <br> and not specified to insert br automatically, don't insert br
			widget.setText(newText);
			return;
		}

		if (plugin.getConfig().getSelectedLanguage().needsCharImages())
			setWidgetText_NiceBr_CharImages(widget, newText);
		else
			setWidgetText_NiceBr_NoCharImages(widget, newText);
	}

	public void setWidgetText_NiceBr_apiTranslated(Widget widget, String newText) {
		if (newText.equals(widget.getText())) // the texts will be the same if the widget has already been translated, or doesn't have a translation available
			return;

		if (plugin.getConfig().getSelectedLanguage().needsCharImages())
			setWidgetText_NiceBr_CharImages(widget, newText);
		else
			setWidgetText_NiceBr_NoCharImages(widget, newText);
	}

	public void setWidgetText_ApiTranslation(Widget widget, String originalText, Colors color){
		final String text_withoutBrAndTags = Colors.removeNonImgTags(originalText);
		String translatedText = plugin.getDeepl().translate(text_withoutBrAndTags, LangCodeSelectableList.ENGLISH, plugin.getConfig().getSelectedLanguage());
		int originalLineHeight = widget.getLineHeight();
		if(translatedText.equals(text_withoutBrAndTags)) { // if the translation is the same as the original text, don't set the text
			return;
		}

		if (plugin.getTargetLanguage().needsCharImages()) {
			translatedText = generalFunctions.StringToTags(translatedText, color);
		}
		setWidgetText_NiceBr(widget, translatedText);
		widget.setLineHeight(originalLineHeight);
	}

	private void setWidgetText_NiceBr_CharImages(Widget widget, String newText) {
		// if newText doesnt have <br> tag at all, insert br automatically
		if (!newText.contains("<br>")) {
			newText = newText.replaceAll("<autoBr>|</autoBr>", ""); // remove <autoBr> tags
			newText = getWidgetText_NiceBr_CharImages(widget, newText);
			widget.setText(newText);
			return;
		}
		// if newText has <br> tag,
		// insert br automatically if it's inside <autoBr> tags, or doesnt have <br> tag at all
		String[] splitText = newText.split("(?=<autoBr>)|(?<=</autoBr>)");
		StringBuilder newTextBuilder = new StringBuilder();
		for (String part : splitText) {
			if (part.contains("<autoBr>")) {
				part = part.replaceAll("<autoBr>|</autoBr>", ""); // remove <autoBr> tags
				part = getWidgetText_NiceBr_CharImages(widget, part);
			}
			newTextBuilder.append(part);
		}
		newText = newTextBuilder.toString();
		// remove the first <br> if it's at the beginning of the text
		if (newText.matches("^<br>.*")) {
			newText = newText.substring(4);
		}
		// remove the last <br> if it's at the end of the text
		if (newText.matches(".*<br>$")) {
			newText = newText.substring(0, newText.length() - 4);
		}
		newText = newText.replaceAll("<br><br>", "<br>"); // remove double <br>
		widget.setText(newText);
	}

	private String getWidgetText_NiceBr_CharImages(Widget widget, String text){
		// Set the text of the widget, but insert br considering the width of the widget
		int widgetWidth = widget.getWidth();
		int foreignWidth = plugin.getConfig().getSelectedLanguage().getCharWidth();
		int maxChars = widgetWidth / foreignWidth;
		// if language uses charImages and needs space between words
		if(plugin.getConfig().getSelectedLanguage().needsSpaceBetweenWords()) { // todo: test this when such language is added
			String[] words = text.split("(?=\\s)");
			StringBuilder newTextBuilder = new StringBuilder();
			int currentLineLength = 0;
			for(String word : words) {
				int charCount = 0;
				if(plugin.getConfig().getSelectedLanguage().needsCharImages()){
					charCount = word.replaceAll("<img=[0-9]+>", "a").length(); // replace <img=??> tags with "a" and count the length
				} else {
					charCount = word.length();
				}
				if(currentLineLength + charCount > maxChars) {
					newTextBuilder.append("<br>");
					currentLineLength = 0;
				}
				newTextBuilder.append(word);
				currentLineLength += charCount;
			}
			text = newTextBuilder.toString();
		} else { // if language uses charImages and doesn't need space between words
			String[] letters = text.split("(?<=>)");
			StringBuilder newTextBuilder = new StringBuilder();
			int currentLineLength = 0;
			for(String letter : letters) {
				if(currentLineLength + 1 > maxChars) {
					newTextBuilder.append("<br>");
					currentLineLength = 0;
				}
				newTextBuilder.append(letter);
				currentLineLength++;
			}
			text = newTextBuilder.toString();
		}
		return text;
	}

	private void setWidgetText_NiceBr_NoCharImages(Widget widget, String newText) {
		// if newText doesnt have <br> tag at all, insert br automatically
		if (!newText.contains("<br>")) {
			newText = newText.replaceAll("<autoBr>|</autoBr>", ""); // remove <autoBr> tags
			newText = getWidgetText_NiceBr_CharImages(widget, newText);
			widget.setText(newText);
			return;
		}
		// if newText has <br> tag,
		// insert br automatically if it's inside <autoBr> tags, or doesnt have <br> tag at all
		String[] splitText = newText.split("(?=<autoBr>)|(?<=</autoBr>)");
		StringBuilder newTextBuilder = new StringBuilder();
		for (String part : splitText) {
			if (part.contains("<autoBr>")) {
				part = part.replaceAll("<autoBr>|</autoBr>", ""); // remove <autoBr> tags
				part = getWidgetText_NiceBr_NoCharImages(widget, part);
			}
			newTextBuilder.append(part);
		}
		newText = newTextBuilder.toString();
		// remove the first <br> if it's at the beginning of the text
		if (newText.matches("^<br>.*")) {
			newText = newText.substring(4);
		}
		// remove the last <br> if it's at the end of the text
		if (newText.matches(".*<br>$")) {
			newText = newText.substring(0, newText.length() - 4);
		}
		newText = newText.replaceAll("<br><br>", "<br>"); // remove double <br>
		widget.setText(newText);
	}

	private String getWidgetText_NiceBr_NoCharImages(Widget widget, String newText) {
		if (!newText.contains(" ")) { // if there are no spaces, don't insert br
			return newText;
		}
		// Set the text of the widget, but insert br considering the width of the widget
		int widgetWidth = widget.getWidth();
		int foreignWidth = LangCodeSelectableList.getLatinCharWidth(widget, plugin.getConfig().getSelectedLanguage());
		int maxChars = widgetWidth / foreignWidth;

		if(plugin.getConfig().getSelectedLanguage().needsSpaceBetweenWords()) {
			String[] words = newText.split("(?=\\s)");
			StringBuilder newTextBuilder = new StringBuilder();
			int currentLineLength = 0;
			for(String word : words) {
				if(currentLineLength + word.length() > maxChars) {
					newTextBuilder.append("<br>");
					currentLineLength = 0;
				}
				if (currentLineLength == 0 && word.charAt(0) == ' ') {
					// remove space from the beginning of the word
					word = word.replaceFirst(" ", "");
				}
				newTextBuilder.append(word);
				currentLineLength += word.length();
			}
			newText = newTextBuilder.toString();
		} else {
			StringBuilder newTextBuilder = new StringBuilder();
			int currentLineLength = 0;
			for(int i = 0; i < newText.length(); i++) {
				if(currentLineLength + 1 > maxChars) {
					newTextBuilder.append("<br>");
					currentLineLength = 0;
				}
				newTextBuilder.append(newText.charAt(i));
				currentLineLength++;
			}
			newText = newTextBuilder.toString();
		}
		// remove the first <br> if it's at the beginning of the text
		if (newText.matches("^<br>.*")) {
			newText = newText.substring(4);
		}
		// remove the last <br> if it's at the end of the text
		if (newText.matches(".*<br>$")) {
			newText = newText.substring(0, newText.length() - 4);
		}
		newText = newText.replaceAll("<br><br>", "<br>"); // remove double <br>

		return newText;
	}

	public static String removeBrAndTags(String str) {
		// replaces br with space
		String tmp = str.replaceAll("(?<=\\S)<br>(?=\\S)", " ");
		return Colors.removeNonImgTags(tmp);
	}

	public void changeWidgetSize_ifNeeded(Widget widget) {
		int widgetId = widget.getId();
		String translatedText = widget.getText();

		//	resize widget if needed, dynamically depending on text length
		ids.getWidget2ModDict().resizeWidgetIfNeeded(widget, translatedText);

		// resize widget to fixed size, as defined in ids.getWidgetId2ChangeSize()
		if (ids.getWidgetId2FixedSize().containsKey(widgetId)) {// if is set to change to fixed size
			if (ids.getWidgetId2FixedSize().get(widgetId).getLeft() != null) {
				widget.setWidthMode(WidgetSizeMode.ABSOLUTE)
						.setOriginalWidth(ids.getWidgetId2FixedSize().get(widgetId).getLeft());
			}
			if (ids.getWidgetId2FixedSize().get(widgetId).getRight() != null) {
				widget.setHeightMode(WidgetSizeMode.ABSOLUTE)
						.setOriginalHeight(ids.getWidgetId2FixedSize().get(widgetId).getRight());
			}
			widget.revalidate();
		}
	}

	public boolean shouldPartiallyTranslateWidget(Widget widget) {
		String enColVal = Transformer.getEnglishColValFromText(widget.getText());
		boolean hasId = ids.getPartialTranslationManager().hasId(widget.getId());
		if (!hasId) {
			return false;
		}
		boolean stringMatch = ids.getPartialTranslationManager().doesStringMatchEnColVal(widget.getText());
		return stringMatch;
	}

	public boolean shouldPartiallyTranslateText(String string) {
		return ids.getPartialTranslationManager().doesStringMatchEnColVal(string);
	}

	public String getEnColVal4PartialTranslation(Widget widget, String text) {
		int widgetId = widget.getId();
		return ids.getPartialTranslationManager().getEnColVal(widgetId, text);
	}

	public String getMatchingEnColVal4PartialTranslation(String string) {
		return ids.getPartialTranslationManager().getMatchingEnColVal(string);
	}

	// set height of line for specified widgets, because they can be too small
	public void changeLineHeight(Widget widget) {
		int lineHeight = plugin.getConfig().getSelectedLanguage().getCharHeight();
		widget.setLineHeight(lineHeight);
	}

}

package com.RuneLingual.Widgets;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;

@Getter @Setter
public class Widget2ModDict {
    private List<Widget2Mod> widgets2Mod = new ArrayList<>();
    @Inject
    private RuneLingualPlugin plugin;

    @Inject
    public Widget2ModDict(RuneLingualPlugin plugin) {
        this.plugin = plugin;
    }

    @Getter @Setter
    public static class Widget2Mod {
        private Widget widget;
        private final int errorPixels;
        private final int widgetId;
        private final boolean hasAdjacentSiblingWidget;
        private final boolean fixedTop;
        private final boolean fixedBottom;
        private final boolean fixedLeft;
        private final boolean fixedRight;
        private final int topPadding;
        private final int bottomPadding;
        private final int leftPadding;
        private final int rightPadding;

        public Widget2Mod(int widgetId, int errorPixels, boolean hasAdjacentSiblingWidget, boolean fixedTop, boolean fixedBottom, boolean fixedLeft, boolean fixedRight, int topPadding, int bottomPadding, int leftPadding, int rightPadding){
            this.widgetId = widgetId;
            this.errorPixels = errorPixels;
            this.hasAdjacentSiblingWidget = hasAdjacentSiblingWidget;
            this.fixedTop = fixedTop;
            this.fixedBottom = fixedBottom;
            this.fixedLeft = fixedLeft;
            this.fixedRight = fixedRight;
            this.topPadding = topPadding;
            this.bottomPadding = bottomPadding;
            this.leftPadding = leftPadding;
            this.rightPadding = rightPadding;
        }

    }

    private enum Direction {
        RIGHT,
        LEFT,
        ABOVE,
        BELOW,
        INSIDE,
        OUTSIDE,
        DIAGONAL, // won't need to shift, nor is it inside or outside
        ALMOST_SAME // for widgets that are almost the same size and position, +/- the error pixels

    }

    private enum notFixedDir {
        HORIZONTAL,
        VERTICAL,
    }

    public void add(int widgetId, int errorPixels, boolean hasSiblingWidget , boolean fixedTop, boolean fixedBottom, boolean fixedLeft, boolean fixedRight, int topPadding, int bottomPadding, int leftPadding, int rightPadding) {
        Widget2Mod widget2Mod = new Widget2Mod(widgetId, errorPixels, hasSiblingWidget, fixedTop, fixedBottom, fixedLeft, fixedRight, topPadding, bottomPadding, leftPadding, rightPadding);
        widgets2Mod.add(widget2Mod);
    }
    private boolean contains(int widgetId) {
        for (Widget2Mod widget2Mod : widgets2Mod) {
            if (widget2Mod.getWidgetId() == widgetId) {
                return true;
            }
        }
        return false;
    }

    public Widget2Mod getWidgets2Mod(int widgetId) {
        for (Widget2Mod widget2Mod : widgets2Mod) {
            if (widget2Mod.getWidgetId() == widgetId) {
                return widget2Mod;
            }
        }
        return null;
    }

    public void resizeWidgetIfNeeded(Widget widget, String newText) {
        int widgetId = widget.getId();
        if (!contains(widgetId)) {
            return;
        }
        resizeWidget(widget, newText);
    }


    public void resizeWidget(Widget widget, String newText) {
        int widgetId = widget.getId();
        Widget2Mod widget2Mod = getWidgets2Mod(widgetId);
        if (widget2Mod == null) {
            return;
        }
        widget2Mod.setWidget(widget);

        if (!widget2Mod.fixedLeft || !widget2Mod.fixedRight) {
            fitWidgetInDirection(widget2Mod, newText, notFixedDir.HORIZONTAL);
        }
        if (!widget2Mod.fixedTop || !widget2Mod.fixedBottom) {
            fitWidgetInDirection(widget2Mod, newText, notFixedDir.VERTICAL);
        }
    }

    // change width/height of widget
    // if the widget doesn't have adjacent sibling widgets, make parent + sibling widgets larger/smaller by the same amount
    // else (if the widget has adjacent sibling widgets):
    // reposition depending on what side is fixed
    // shift sibling widgets in that direction
    // change parent width/height if needed
    // revalidate widgets
    private void fitWidgetInDirection(Widget2Mod widget2Mod, String newText, notFixedDir dirNotFixed) {
        Widget widget = widget2Mod.getWidget();
        int originalSize = (dirNotFixed == notFixedDir.HORIZONTAL) ? widget.getWidth() : widget.getHeight();
        int newSize = (dirNotFixed == notFixedDir.HORIZONTAL) ? getWidthToFit(widget2Mod, widget2Mod.widget, newText) :getHeightToFit(widget2Mod, newText);
        int originalPos = (dirNotFixed == notFixedDir.HORIZONTAL) ? widget.getRelativeX() : widget.getRelativeY();
        int sizeDiff = newSize - originalSize;
//        if (originalSize == newSize) {
//            return;
//        }
        Widget parentWidget = widget.getParent();

        // if the widget doesn't have adjacent sibling widgets, make parent + sibling widgets larger/smaller by the same amount
        if (!widget2Mod.hasAdjacentSiblingWidget && widget.getParent() != null) {
            int originalParentPosition = (dirNotFixed == notFixedDir.HORIZONTAL) ? parentWidget.getRelativeX() : parentWidget.getRelativeY();
            int originalParentSize = (dirNotFixed == notFixedDir.HORIZONTAL) ? parentWidget.getWidth() : parentWidget.getHeight();
            int newParentSize = originalParentSize + sizeDiff;
            // set new size and position for parent and widget
            if (dirNotFixed == notFixedDir.HORIZONTAL) {
                setWidgetWidthAbsolute(widget, newSize);
                setWidgetWidthAbsolute(parentWidget, newParentSize);
            } else {
                setWidgetHeightAbsolute(widget, newSize);
                setWidgetHeightAbsolute(parentWidget, newParentSize);
            }

            // reposition parent and the target widget
            if (dirNotFixed == notFixedDir.HORIZONTAL) {
                if (widget2Mod.fixedLeft && widget2Mod.fixedRight) {
                    int newParentPos = originalParentPosition - sizeDiff / 2;
                    if (newParentPos < 0) {
                        newParentPos = 0;
                    }
                    setWidgetRelativeXPos(parentWidget, newParentPos, 0);
                    setWidgetRelativeXPos(widget, originalPos, widget2Mod.leftPadding);
                } else if (widget2Mod.fixedLeft) {
                    setWidgetRelativeXPos(parentWidget, originalParentPosition, 0);
                    setWidgetRelativeXPos(widget, originalPos, widget2Mod.leftPadding);
                } else { // if (widget2Mod.fixedRight)
                    int newParentPos = originalParentPosition - sizeDiff;
                    if (newParentPos < 0) {
                        newParentPos = 0;
                    }
                    setWidgetRelativeXPos(parentWidget, newParentPos, 0);
                    setWidgetRelativeXPos(widget, originalPos, widget2Mod.leftPadding);
                }
            } else {
                if (widget2Mod.fixedTop && widget2Mod.fixedBottom) {
                    setWidgetRelativeYPos(parentWidget, originalParentPosition - sizeDiff / 2, 0);
                    setWidgetRelativeYPos(widget, originalPos, widget2Mod.topPadding);
                } else if (widget2Mod.fixedTop) {
                    setWidgetRelativeYPos(parentWidget, originalParentPosition, 0);
                    setWidgetRelativeYPos(widget, originalPos, widget2Mod.topPadding);
                } else { // if (widget2Mod.fixedBottom)
                    setWidgetRelativeYPos(parentWidget, originalParentPosition - sizeDiff, 0);
                    setWidgetRelativeYPos(widget, originalPos, widget2Mod.topPadding);
                }
            }

            // set new size for sibling widgets
            List<Widget> childWidgets = getAllChildWidget(parentWidget);
            for (Widget sibling : childWidgets) {
                if (sibling != widget && sibling.getType() == 3) { // 3 seems to be the type for background widgets
                    int originalSiblingPosition = (dirNotFixed == notFixedDir.HORIZONTAL) ? sibling.getRelativeX() : sibling.getRelativeY();
                    if (dirNotFixed == notFixedDir.HORIZONTAL) {
                        // set new width for sibling
                        int originalSiblingWidth = sibling.getWidth();
                        int newSiblingWidth = originalSiblingWidth + sizeDiff;
                        setWidgetWidthAbsolute(sibling, newSiblingWidth);

                        // set new position for sibling
                        if (widget2Mod.fixedLeft && widget2Mod.fixedRight) {
                            setWidgetRelativeXPos(sibling, originalSiblingPosition, 0);
                        } else if (widget2Mod.fixedLeft) {
                            setWidgetRelativeXPos(sibling, originalSiblingPosition, 0);
                        } else { // if (widget2Mod.fixedRight)
                            setWidgetRelativeXPos(sibling, originalSiblingPosition,0);
                        }
                    } else {
                        // set new height for sibling
                        int originalSiblingHeight = sibling.getHeight();
                        int newSiblingHeight = originalSiblingHeight + sizeDiff;
                        setWidgetHeightAbsolute(sibling, newSiblingHeight);

                        // set new position for sibling
                        if (widget2Mod.fixedTop && widget2Mod.fixedBottom) {
                            setWidgetRelativeYPos(sibling, originalSiblingPosition, 0);
                        } else if (widget2Mod.fixedTop) {
                            setWidgetRelativeYPos(sibling, originalSiblingPosition, 0);
                        } else { // if (widget2Mod.fixedBottom)
                            setWidgetRelativeYPos(sibling, originalSiblingPosition, 0);
                        }
                    }
                }
            }

        } else {
            List<Widget> childWidgets = getAllChildWidget(widget.getParent());
            // update size in cases like the xp hover text in skills tab, where the widget is in the same row as the sibling
            // in this case even though the sibling widget is ALMOST_SAME, the sibling widget text's width + widget's text width should be the new size,
            // instead of expanding the sibling widget to fit the widget's size
            if (dirNotFixed == notFixedDir.HORIZONTAL) {
                newSize += getAdjacentTextSiblingSize(childWidgets, widget, dirNotFixed, widget2Mod);
                sizeDiff = newSize - originalSize;
            }
            // reposition depending on what side is fixed, and resize
            Direction dirToShift = getDirToShift(widget2Mod, dirNotFixed);
            // shift sibling widgets in that direction
            for (Widget sibling : childWidgets) {
                if (sibling.equals(widget)) {
                    continue;
                }
                Direction dir = getDirTowards(widget, sibling, widget2Mod);
                if (dir == dirToShift) {
                    shiftWidget(sibling, sizeDiff, dirToShift);
                } else if (dir == Direction.OUTSIDE || dir == Direction.INSIDE || dir == Direction.ALMOST_SAME) {
                    moveAndExpandWidget(sibling, dirToShift, sizeDiff);
                }
            }

//             resize and reposition the target widget
            if (dirNotFixed == notFixedDir.HORIZONTAL) {
                originalPos = widget.getRelativeX(); // delete later
                setWidgetWidthAbsolute(widget, newSize);
                if (dirToShift == Direction.LEFT) { // if shifting left, shift the widget itself by the difference
                    originalPos = getNewShiftedPos(originalPos, dirToShift, sizeDiff); // relative position
                }
                setWidgetRelativeXPos(widget, originalPos, 0);
            } else {
                setWidgetHeightAbsolute(widget, newSize);
                if (dirToShift == Direction.ABOVE) { // if shifting upwards, shift the widget itself by the difference
                    originalPos = getNewShiftedPos(originalPos, dirToShift, sizeDiff); // relative position
                }
                setWidgetRelativeYPos(widget, originalPos, 0);
            }


            // change parent width/height to fit all the widget and sibling widgets
            int originalParentPosition = (dirNotFixed == notFixedDir.HORIZONTAL) ? parentWidget.getRelativeX() : parentWidget.getRelativeY();
            int siblingCoverage = getSiblingsCoverage(childWidgets, dirNotFixed);
            int parentCoverage = (dirNotFixed == notFixedDir.HORIZONTAL) ? parentWidget.getWidth() : parentWidget.getHeight();
            if (parentCoverage < siblingCoverage) {
                if (dirNotFixed == notFixedDir.HORIZONTAL) {
                    if (dirToShift == Direction.LEFT) {
                        int newParentX = originalParentPosition - sizeDiff;
                        setWidgetRelativeXPos(parentWidget, newParentX, 0);
                    }
                    setWidgetWidthAbsolute(parentWidget, siblingCoverage);

                } else {
                    if (dirToShift == Direction.ABOVE) {
                        int newParentY = originalParentPosition - sizeDiff;
                        setWidgetRelativeYPos(parentWidget, newParentY, 0);
                    }
                    setWidgetHeightAbsolute(parentWidget, siblingCoverage);
                }
            }

            // if any of the parent's corners are outside of the parent's parent, resize and reposition parent and child widgets

            // also, if the parent width/height (children coverage) is larger than parent's parent,
            // resize and reposition parent and child widgets
            if (dirNotFixed == notFixedDir.HORIZONTAL) {
                int parentWidth = parentWidget.getWidth();
                int grandPWidth = parentWidget.getParent().getWidth();
                boolean isLeftOutside = parentWidget.getRelativeX() < 0;
                boolean isRightOutside = parentWidget.getRelativeX() + parentWidth > grandPWidth;

                if (isLeftOutside && isRightOutside) {
                    // parent size is bigger than parent's parent. need to make parent and sibling widgets smaller to fit. not checked
                    setWidgetRelativeXPos(parentWidget, 0, 0);
                    setWidgetWidthAbsolute(parentWidget, grandPWidth);
                    setAllChildFitPar(parentWidget, notFixedDir.HORIZONTAL, widget2Mod);
                }
                if (isLeftOutside) {
                    setWidgetRelativeXPos(parentWidget, 0, 0);
                    if (parentWidth > grandPWidth) {
                        // if the parent widget is larger than the parent, make it the same size as the parent
                        setWidgetWidthAbsolute(parentWidget, grandPWidth);
                    }
                    setAllChildFitPar(parentWidget, notFixedDir.HORIZONTAL, widget2Mod);
                }
                if (isRightOutside) {
                    if (parentWidth <= grandPWidth) {
                        setWidgetRelativeXPos(parentWidget, grandPWidth - parentWidth, 0);
                        setWidgetWidthAbsolute(parentWidget, grandPWidth);
                    } else {
                        setWidgetWidthAbsolute(parentWidget, grandPWidth);
                        setWidgetRelativeXPos(parentWidget, 0, 0);
                    }
                    setAllChildFitPar(parentWidget, notFixedDir.HORIZONTAL, widget2Mod);
                }
            } else {
                int parentHeight = parentWidget.getHeight();
                int grandPHeight = parentWidget.getParent().getHeight();
                boolean isTopOutside = parentWidget.getRelativeY() < 0;
                boolean isBottomOutside = parentWidget.getRelativeY() + parentHeight > grandPHeight;
                if (isTopOutside && isBottomOutside) { // need to make parent and sibling widgets smaller to fit, not checked
                    setWidgetRelativeYPos(parentWidget, 0, 0);
                    setWidgetHeightAbsolute(parentWidget, grandPHeight);
                    setAllChildFitPar(parentWidget, notFixedDir.VERTICAL, widget2Mod);
                }
                if (isTopOutside) {
                    setWidgetRelativeYPos(parentWidget, 0, 0);
                    if (parentHeight > grandPHeight) {
                        // if the parent widget is larger than the parent, make it the same size as the parent
                        setWidgetHeightAbsolute(parentWidget, grandPHeight);
                    }
                    setAllChildFitPar(parentWidget, notFixedDir.VERTICAL, widget2Mod);
                }
                if (isBottomOutside) {
                    setWidgetRelativeYPos(parentWidget, grandPHeight - parentHeight, 0);
                    if (parentHeight > grandPHeight) {
                        // if the parent widget is larger than the parent, make it the same size as the parent
                        setWidgetHeightAbsolute(parentWidget, grandPHeight);
                    }
                    setAllChildFitPar(parentWidget, notFixedDir.VERTICAL, widget2Mod);
                }
            }
        }
    }

    private int getAdjacentTextSiblingSize(List<Widget> childWidgets, Widget widget, notFixedDir dirNotFixed, Widget2Mod widget2Mod) {
        int maxSize = 0;
        for (Widget sibling : childWidgets) {
            if (sibling.equals(widget)) {
                continue;
            }
            String siblingText = sibling.getText();
            if (siblingText == null || siblingText.isEmpty()) {
                continue;
            }
            int newSize = 0;
            Direction dir = getDirTowards(widget, sibling, widget2Mod);
            if (dir == Direction.ALMOST_SAME// if the widgets share similar boundary
                    && sibling.getType() == 4 && sibling.getText() != null && !sibling.getText().isEmpty() // and the sibling is a text widget
                    && Math.pow(sibling.getXTextAlignment() - widget.getXTextAlignment(), 2) == 4) { // and the sibling is aligned to the left or right of the widget
                // they are likely to be in the same row, like the xp hover text in skills tab
                if (dirNotFixed == notFixedDir.HORIZONTAL) {
                    newSize = getWidthToFit(widget2Mod, widget2Mod.widget, siblingText);
                } else {
                    newSize = getHeightToFit(widget2Mod, siblingText);
                }
            }
            if (newSize > maxSize) {
                maxSize = newSize;
            }
        }
        return maxSize;
    }

    private int getHeightToFit(Widget2Mod widget2Mod, String newText) {
        int lineHeight = plugin.getConfig().getSelectedLanguage().getCharHeight();
        int numLines = newText.split("<br>").length;
        return lineHeight * numLines + widget2Mod.topPadding + widget2Mod.bottomPadding;
    }

    // give widget as argument to get width for
    // give widget2Mod as argument to get padding
    private int getWidthToFit(Widget2Mod widget2Mod, Widget widget, String newText) {
        // get the longest line, multiply by the width of selected language's character
        int longestLine = 0;

        String[] lines = newText.split("<br>");
        // count the number of characters, but if its char images, count the number of <img> tags, else
        if (!plugin.getConfig().getSelectedLanguage().needsCharImages()) {
            for (String line : lines) {
                if (line.length() > longestLine) {
                    longestLine = line.length();
                }
            }
            int latinCharWidth = LangCodeSelectableList.getLatinCharWidth(widget, plugin.getConfig().getSelectedLanguage());
            longestLine *= latinCharWidth;
        } else {
            for (String line : lines) {
                int imgCount = line.split("<img=").length - 1;
                int nonImgCount = line.replaceAll("<.+?>", "").length();
                int lineLength = imgCount * plugin.getConfig().getSelectedLanguage().getCharWidth() +
                        nonImgCount * LangCodeSelectableList.getLatinCharWidth(widget, LangCodeSelectableList.ENGLISH);
                if (lineLength > longestLine) {
                    longestLine = lineLength;
                }
            }
        }
        return longestLine + widget2Mod.leftPadding + widget2Mod.rightPadding;
    }

    private void setWidgetWidthAbsolute(Widget widget, int width) {
        widget.setWidthMode(WidgetSizeMode.ABSOLUTE)
                .setOriginalWidth(width)
                .revalidate();
    }

    private void setWidgetHeightAbsolute(Widget widget, int height) {
        widget.setHeightMode(WidgetSizeMode.ABSOLUTE)
                .setOriginalHeight(height)
                .revalidate();
    }

    private void setWidgetRelativeXPos(Widget widget, int x, int leftPadding) {
        widget.setOriginalX(x + leftPadding)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT)
                .revalidate();
    }
    private void setWidgetRelativeYPos(Widget widget, int y, int topPadding) {
        widget.setOriginalY(y + topPadding)
                .setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP)
                .revalidate();
    }


    private Direction getDirToShift(Widget2Mod widget2Mod, notFixedDir dirNotFixed) {
        // can be difficult to determine which direction to shift, so hard coding

        // for spellbook tab hover text
        if (widget2Mod.getWidgetId() == plugin.getIds().getSpellbookTabHoverTextId()){
            // if the bottom edge of widget is at the bottom of parent, shift above
            Widget widget = widget2Mod.getWidget();
            int parentHeight = widget.getParent().getHeight();
            int widgetBottomY = widget.getRelativeY() + widget.getHeight();
            if (widgetBottomY > parentHeight /2) {
                return Direction.ABOVE;
            } else {
                return Direction.BELOW;// not tested
            }
        }

         if (widget2Mod.getWidgetId() == plugin.getIds().getSkillsTabXpHoverTextId()) {
            if (dirNotFixed == notFixedDir.VERTICAL) {
                int Y = widget2Mod.getWidget().getRelativeY();
                if (Y < 170) {
                    return Direction.BELOW;
                } else {
                    return Direction.ABOVE;
                }
            } else {
                int parentWidth = widget2Mod.getWidget().getParent().getWidth();
                int X = widget2Mod.getWidget().getRelativeX();
                if (X < parentWidth / 4) {
                    return Direction.RIGHT;
                } else {
                    return Direction.LEFT;
                }
            }
        }

        if (dirNotFixed == notFixedDir.VERTICAL) {
            if (!widget2Mod.fixedBottom) {
                return Direction.BELOW;
            } else if (!widget2Mod.fixedTop) {
                return Direction.ABOVE;
            }
        } else {
            if (!widget2Mod.fixedLeft) {
                return Direction.LEFT;
            } else if (!widget2Mod.fixedRight) {
                return Direction.RIGHT;
            }
        }
        return Direction.OUTSIDE;
    }

    // returns relative position
    private int getNewShiftedPos(int originalPos, Direction dirToShift, int heightDiff) {
        int newY = getNewPos(originalPos, dirToShift, heightDiff);
        if (newY == -1) {
            return originalPos - heightDiff / 2;
        }
        return newY;
    }


    private int getNewPos(int originalPos, Direction dirToShift, int diff) {
        int newPos;
        switch (dirToShift) {
            case ABOVE:
                newPos = originalPos - diff;
                break;
            case BELOW:
                newPos = originalPos + diff;
                break;
            case RIGHT:
                newPos = originalPos + diff;
                break;
            case LEFT:
                newPos = originalPos - diff;
                break;
            default:
                newPos = -1;
        }
        return newPos;
    }

    private List<Widget> getAllChildWidget(Widget widget) {
        List<Widget> childWidgets = new ArrayList<>(List.of(widget.getDynamicChildren()));
        childWidgets.addAll(List.of(widget.getStaticChildren()));
        childWidgets.addAll(List.of(widget.getNestedChildren()));
        return childWidgets;
    }

    private Direction getDirTowards(Widget baseWidget, Widget targetWidget, Widget2Mod widget2Mod) {
        int baseTop = baseWidget.getRelativeY();
        int baseBottom = baseWidget.getRelativeY() + baseWidget.getHeight();
        int baseLeft = baseWidget.getRelativeX();
        int baseRight = baseWidget.getRelativeX() + baseWidget.getWidth();
        int targetTop = targetWidget.getRelativeY();
        int targetBottom = targetWidget.getRelativeY() + targetWidget.getHeight();
        int targetLeft = targetWidget.getRelativeX();
        int targetRight = targetWidget.getRelativeX() + targetWidget.getWidth();
        boolean widgetsOverlapHor = widgetsOverlapHor(baseWidget, targetWidget);
        boolean widgetsOverlapVer = widgetsOverlapVer(baseWidget, targetWidget);

        int overlapErrorPixels = widget2Mod.getErrorPixels(); // widgets inside can be bigger by this amount even for bottom and right edges, even if they appear to be inside

        if (targetBottom - overlapErrorPixels < baseTop && widgetsOverlapHor) {
            return Direction.ABOVE;
        } else if (targetTop > baseBottom - overlapErrorPixels && widgetsOverlapHor) {
            return Direction.BELOW;
        } else if (targetRight - overlapErrorPixels < baseLeft && widgetsOverlapVer) {
            return Direction.LEFT;
        } else if (targetLeft > baseRight - overlapErrorPixels && widgetsOverlapVer) {
            return Direction.RIGHT;
        } else if (widgetsOverlapHor && widgetsOverlapVer) {
            if (Math.abs(baseTop - targetTop) < overlapErrorPixels
                    && Math.abs(baseBottom - targetBottom) < overlapErrorPixels
                    && Math.abs(baseLeft - targetLeft) < overlapErrorPixels
                    && Math.abs(baseRight - targetRight) < overlapErrorPixels) {
                return Direction.ALMOST_SAME;
            } else
            if (isAnyEdgeInside(baseWidget, targetWidget, overlapErrorPixels)) {
                return Direction.INSIDE;
            } else if (targetTop <= baseTop && targetBottom >= baseBottom && targetLeft <= baseLeft && targetRight >= baseRight) {
                return Direction.OUTSIDE;
            }
        }
        return Direction.DIAGONAL;

    }

    private boolean widgetsOverlapHor(Widget w1, Widget w2) {
        // if the widgets share the same horizontal space, return true
        int w1Left = w1.getRelativeX();
        int w1Right = w1.getRelativeX() + w1.getWidth();
        int w2Left = w2.getRelativeX();
        int w2Right = w2.getRelativeX() + w2.getWidth();
        return (w1Left >= w2Left && w1Left < w2Right) || (w1Right >= w2Left && w1Right < w2Right) || (w1Left < w2Left && w1Right >= w2Right)
            || (w2Left >= w1Left && w2Left < w1Right) || (w2Right >= w1Left && w2Right < w1Right) || (w2Left < w1Left && w2Right >= w1Right);
    }

    private boolean widgetsOverlapVer(Widget w1, Widget w2) {
        // if the widgets share the same vertical space, return true
        int w1Top = w1.getRelativeY();
        int w1Bottom = w1.getRelativeY() + w1.getHeight();
        int w2Top = w2.getRelativeY();
        int w2Bottom = w2.getRelativeY() + w2.getHeight();
        return (w1Top >= w2Top && w1Top < w2Bottom) || (w1Bottom >= w2Top && w1Bottom < w2Bottom) || (w1Top < w2Top && w1Bottom >= w2Bottom)
            || (w2Top >= w1Top && w2Top < w1Bottom) || (w2Bottom >= w1Top && w2Bottom < w1Bottom) || (w2Top < w1Top && w2Bottom >= w1Bottom);
    }

    private int getSiblingsCoverage(List<Widget> siblings, notFixedDir dirNotFixed) {
        int min = 999999;
        int max = 0;
        for (Widget sibling : siblings) {
            if (dirNotFixed == notFixedDir.HORIZONTAL) {
                int siblingLeft = sibling.getRelativeX();
                int siblingRight = sibling.getRelativeX() + sibling.getWidth();
                if (siblingLeft < min) {
                    min = siblingLeft;
                }
                if (siblingRight > max) {
                    max = siblingRight;
                }
            } else {
                int siblingTop = sibling.getRelativeY();
                int siblingBottom = sibling.getRelativeY() + sibling.getHeight();
                if (siblingTop < min) {
                    min = siblingTop;
                }
                if (siblingBottom > max) {
                    max = siblingBottom;
                }
            }
            int siblingTop = sibling.getRelativeY();
            int siblingBottom = sibling.getRelativeY() + sibling.getHeight();
            if (siblingTop < min) {
                min = siblingTop;
            }
            if (siblingBottom > max) {
                max = siblingBottom;
            }
        }
        return max - min;
    }


    private void moveAndExpandWidget(Widget widget, Direction dir, int diff) {
        int originalY = widget.getRelativeY();
        int originalX = widget.getRelativeX();
        int originalHeight = widget.getHeight();
        int originalWidth = widget.getWidth();
        int newY = originalY;
        int newX = originalX;
        int newHeight = originalHeight;
        int newWidth = originalWidth;
        switch (dir) {
            case ABOVE:
                newY = originalY - diff;
                newHeight = originalHeight + diff;
                break;
            case BELOW:
                newHeight = originalHeight + diff;
                break;
            case RIGHT:
                newWidth = originalWidth + diff;
                break;
            case LEFT:
                newX = originalX - diff;
                newWidth = originalWidth + diff;
                break;
        }

        setWidgetHeightAbsolute(widget, newHeight);
        setWidgetWidthAbsolute(widget, newWidth);
        setWidgetRelativeXPos(widget, newX, 0);
        setWidgetRelativeYPos(widget, newY, 0);

    }

    private boolean isAnyEdgeInside(Widget baseWgt, Widget targetWgt, int overlapErrorPixels) {
        return getNumCornerInside(baseWgt, targetWgt, overlapErrorPixels) > 0;
    }

    private int getNumCornerInside(Widget baseWgt, Widget targetWgt, int overlapErrorPixels) {
        //** for target bottom and right edges, consider overlapErrorPixels
        int baseTop = baseWgt.getRelativeY();
        int baseBottom = baseWgt.getRelativeY() + baseWgt.getHeight();
        int baseLeft = baseWgt.getRelativeX();
        int baseRight = baseWgt.getRelativeX() + baseWgt.getWidth();
        int targetTop = targetWgt.getRelativeY();
        int targetBottom = targetWgt.getRelativeY() + targetWgt.getHeight() - overlapErrorPixels;
        int targetLeft = targetWgt.getRelativeX();
        int targetRight = targetWgt.getRelativeX() + targetWgt.getWidth() - overlapErrorPixels;
        int count = 0;

        //** top and left edges can be on top of base widget's (so use <= or >= instead of < or >)
        // target's top left corner is inside base
        if (targetTop >= baseTop && targetTop < baseBottom && targetLeft >= baseLeft && targetLeft < baseRight) {
            count++;
        }
        // target's top right corner is inside base
        if (targetTop >= baseTop && targetTop < baseBottom && targetRight > baseLeft && targetRight < baseRight) {
            count++;
        }
        // target's bottom left corner is inside base
        if (targetBottom > baseTop && targetBottom < baseBottom && targetLeft >= baseLeft && targetLeft < baseRight) {
            count++;
        }
        // target's bottom right corner is inside base
        if (targetBottom > baseTop && targetBottom < baseBottom && targetRight > baseLeft && targetRight < baseRight) {
            count++;
        }
        return count;
    }

    private void shiftWidget(Widget widget, int diff, Direction dirToShift) {
        if (dirToShift == Direction.ABOVE || dirToShift == Direction.BELOW) {
            int originalY = widget.getRelativeY();
            int newY = getNewShiftedPos(widget.getRelativeY(), dirToShift, diff); // relative position
            if (newY != originalY) {
                setWidgetRelativeYPos(widget, newY, 0);
            }
        } else {
            int originalX = widget.getRelativeX();
            int newX = getNewShiftedPos(widget.getRelativeX(), dirToShift, diff); // relative position
            if (newX != originalX) {
                setWidgetRelativeXPos(widget, newX, 0);
            }
        }
    }

    private void setAllChildFitPar(Widget parentWidget, notFixedDir notFixedDir, Widget2Mod widget2Mod) {
        List<Widget> childWidgets = getAllChildWidget(parentWidget);
        for (Widget sibling : childWidgets) {
            // if the sibling widget is larger than the parent widget, make it the same size as the parent widget
            if (notFixedDir == Widget2ModDict.notFixedDir.HORIZONTAL
                    && sibling.getWidth() > parentWidget.getWidth()) {
                int newSiblingWidth = parentWidget.getWidth();
                if (sibling.getType() == 4 && sibling.getXTextAlignment() == WidgetTextAlignment.RIGHT) {
                    // (subtract right padding for right aligned texts)
                    newSiblingWidth -= widget2Mod.rightPadding;
                }
                setWidgetWidthAbsolute(sibling, newSiblingWidth);
            }
            // if the sibling widget is larger than the parent widget, make it the same size as the parent widget
            if (notFixedDir == Widget2ModDict.notFixedDir.VERTICAL
                    && sibling.getHeight() > parentWidget.getHeight()) {
                int newSiblingHeight = parentWidget.getHeight();
                if (sibling.getType() == 4 && sibling.getYTextAlignment() == WidgetTextAlignment.BOTTOM) {
                    // (subtract bottom padding for bottom aligned texts)
                    newSiblingHeight -= widget2Mod.bottomPadding;
                }
                setWidgetHeightAbsolute(sibling, newSiblingHeight);

            }
        }
    }

}
package com.RuneLingual.nonLatin;

import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ChatIconManager;

import javax.inject.Inject;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class GeneralFunctions {
    @Inject
    private CharImageInit charImageInit;
    @Inject
    private RuneLingualPlugin runeLingualPlugin;


    public String StringToTags(String string, Colors colors) {
        /*
        This function takes a string + color and returns emojis that looks like letters
        But leave <img=??> tags as they are (they are already emojis).
        Also leave <asis> tags as they are. This tag can be specified by the translator.
        eg: こんにちは,<img=43>Lukyさん -> <img=43><img=1><img=2><img=3><img=4><img=5><img=6>

        order of conversion : String -> (for each char) -> char to codepoint -> get image name (eg: black--3021.png) ->
        -> get hash value of the char image from the hashmap
        -> get image Id in the chatIcon manager from the hash value
        -> create a tag with the image Id (eg: <img=1>)
        -> repeat to all characters in the string -> append all tags -> return
         */
        String lookBehindPattern = "<img=[0-9]*>|</asis>";
        String lookForwardPattern = "<img=[0-9]*>";
        String asIsPattern = "<asis>.*?</asis>";
        String[] parts = string.split("(?=" + lookForwardPattern + "|"+ asIsPattern +")|(?<=" + lookBehindPattern + ")");
        StringBuilder imgTagSb = new StringBuilder();
        for (String part : parts) {//check for img tags, such as the ironman icon
            if (part.matches(lookForwardPattern)) {//if the part is an img tag, just append it
                imgTagSb.append(part);
                continue;
            }
            if (part.matches(asIsPattern)) {//if the part is an asis tag, append the inside with color tag
                String asIsContent = part.substring(6, part.length() - 7);
                imgTagSb.append("<col=");
                imgTagSb.append(colors.getHex());
                imgTagSb.append(">");
                imgTagSb.append(asIsContent);
                imgTagSb.append("</col>");
                continue;
            }
            StringBuilder imgTagStrings = new StringBuilder();
            ChatIconManager chatIconManager = runeLingualPlugin.getChatIconManager();
            HashMap<String, Integer> map = runeLingualPlugin.getCharIds();
            for (int j = 0; j < part.length(); ) {//if the part is not an img tag, convert each letters to letter emojis

                int codePoint = part.codePointAt(j);
                if (Arrays.asList(32, 160, 8195, 8194, 8201, 8202, 8203, 12288).contains(codePoint)) {//if the char is a space, append a space
                    imgTagStrings.append(" ");
                    j += 1;
                    continue;
                }
                String imgName = colors.getName() + "--" + codePoint + ".png";
                int hash = map.getOrDefault(imgName, -99);
                if (hash == -99) {//if the char is not in the hashmap, append a question mark
                    imgTagStrings.append("?");
                    j += Character.isHighSurrogate(part.charAt(j)) ? 2 : 1;
                    log.error("Char not found in hashmap: {}", part.charAt(j));
                }
                imgTagStrings.append("<img=");
                imgTagStrings.append(chatIconManager.chatIconIndex(hash));
                imgTagStrings.append(">");
                j += Character.isHighSurrogate(part.charAt(j)) ? 2 : 1;

            }
            imgTagSb.append(imgTagStrings);
        }
        return imgTagSb.toString();
    }

    public static Map<String, String> getPlaceholder2Content(String originalText, String placeholderText) {
        /*
        String originalText = "slay blue dragons in Taverley";
        String placeholderText = "slay <!monster> in <!location>";
        returns: {"monster": "blue dragons", "location": "Taverley"}
         */
        Map<String, String> result = new HashMap<>();
        String[] fixedTexts = placeholderText.split("(?=<![^>]+>)|(?=<Num\\d+>)|(?<=\\w>)"); // fixedTexts = ["slay ", "<!monster>", " in ", "<!location>"]

        StringBuilder regex = new StringBuilder("^");
        List<String> placeholders = new ArrayList<>();

        for (String segment : fixedTexts) {
            if (segment.startsWith("<!") && segment.endsWith(">")) {
                placeholders.add(segment.substring(2, segment.length() - 1));
                regex.append("(.*)");
            } else if(segment.matches("<Num\\d+>")) {
                regex.append("(\\d+)"); // for <Num1>, <Num2>, etc.
            } else {
                regex.append(Pattern.quote(segment));
            }
        }
        regex.append("$"); // regex = "^\Qslay \E(.*)\Q in \E(.*)$", placeholders = ["monster", "location"]

        Pattern pattern = Pattern.compile(regex.toString());
        Matcher matcher = pattern.matcher(originalText);

        if (matcher.find()) {
            for (int i = 0; i < placeholders.size(); i++) {
                result.put(placeholders.get(i), matcher.group(i + 1));
            }
        }
        return result; //{location=Taverley, monster=blue dragons}
    }
}

package com.RuneLingual.nonLatin.Japanese;

import java.util.Comparator;
import com.RuneLingual.nonLatin.Japanese.Rom2hira.FourValues;

public class compareFV implements Comparator<FourValues> {
    public int compare(FourValues fv1, FourValues fv2) {
        return Integer.compare(fv1.getRank(), fv2.getRank());
    }
}

package com.RuneLingual.nonLatin.Japanese;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Pattern;

@Slf4j
public class Rom2hira {
    private HashMap<String,String> char2char = new HashMap<>();

    @Inject
    public Rom2hira() {
        String charFilePath = FileNameAndPath.getLocalBaseFolder() + "/" +
                LangCodeSelectableList.日本語.getLangCode() +
                "/latin2foreign_" + LangCodeSelectableList.日本語.getLangCode() + ".txt";
        putCharToHash(char2char, charFilePath);
    }

    private void putCharToHash(HashMap<String, String> hash, String filePath) {
        FileNameAndPath.createDirectoryIfNotExists(FileNameAndPath.getLocalBaseFolder() + "/" +
                LangCodeSelectableList.日本語.getLangCode());
        FileNameAndPath.createFileIfNotExists(filePath);
        try (BufferedReader reader = new BufferedReader(new InputStreamReader
                (new FileInputStream(filePath), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split("\\|");
                if (parts.length == 2) {
                    hash.put(parts[0].trim().toLowerCase(), parts[1].trim());
                }
            }
        } catch (IOException e) {
            log.error("error creating hashmap for transform dict, for type : {}", filePath, e);
        }
    }


    @Setter @Getter
    public static class FourValues {
        private String written;
        private String read;
        private String type;
        private int rank;

        public FourValues(String value1, String value2, String value3, int value4) {
            this.written = value1;
            this.read = value2;
            this.type = value3;
            this.rank = value4;
        }
    }

    public String romToKat(String romMsg) {
        StringBuilder katBuilder = new StringBuilder();
        StringBuilder romBuilder = new StringBuilder();
        String pattern = "n[,.!?;:#$%&()'\\s\\d]$";
        String pattern2 = ".+n[,.!?;:#$%&()'\\s\\d]$";

        List<String> escapePattern = Arrays.asList("::",";;",";:",":;");// escape sequence for latin character input
        boolean escaping = false;

        for (int i = 0; i < romMsg.length(); i++) {
            String newChar = Character.toString(romMsg.charAt(i));
            if(!escaping) newChar = newChar.toLowerCase();
            romBuilder.append(newChar);
            String romBuffer = romBuilder.toString();
            int romBufferSize = romBuffer.length();
            String katCandidate;

            if (escaping) {
                katBuilder.append(romMsg.charAt(i));
                romBuilder.setLength(0);
                if(katBuilder.length() > 1 &&
                        escapePattern.contains(katBuilder.substring(katBuilder.length()-2))){
                    escaping = false;
                    katBuilder.delete(katBuilder.length()-2, katBuilder.length());
                    katBuilder.append(" ");
                    continue;
                } else {
                    continue;
                }
            }

            if (romBufferSize == 0)//something went wrong
                return "";
            if (romBufferSize == 1) {
                katCandidate = romBuffer;
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    katBuilder.append(ch);
                    romBuilder.setLength(0);
                    continue;
                }
                if (romBuffer.equals("n") && i == romMsg.length() - 1){
                    katBuilder.append("ん");
                    romBuilder.setLength(0);
                    continue;
                }
            } else if (romBufferSize == 2) {
                if(escapePattern.contains(romBuffer)){
                    romBuilder.setLength(0);
                    //katBuilder.deleteCharAt(katBuilder.length()-1);
                    katBuilder.append(" ");
                    escaping = true;
                    continue;
                }

                katCandidate = romBuffer;//eg: ka > カ
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    katBuilder.append(ch);
                    romBuilder.setLength(0);
                    continue;
                }
                katCandidate = romBuffer.substring(romBufferSize-1);
                if (char2char.containsKey(katCandidate)) {//eg:qe > qエ
                    String ch = char2char.get(katCandidate);
                    Character secToLast = romBuffer.charAt(0);
                    if (Pattern.matches(pattern, romBuffer)) //when n comes before a symbol or space, change it to ン
                        katBuilder.append("ん");
                    else
                        katBuilder.append(secToLast);//append q
                    katBuilder.append(ch); // append エ
                    romBuilder.setLength(0);
                    continue;
                }
                if (Pattern.matches(pattern, romBuffer)){//when n comes before a symbol or space, change it to ン
                    katBuilder.append("ん");
                    katBuilder.append(romBuffer.charAt(1));
                    romBuilder.setLength(0);
                    continue;
                }
            } else {//rombuffer size > 2
                if(escapePattern.contains(romBuffer.substring(romBufferSize-2))){
                    katBuilder.append(romBuffer,0,romBufferSize-2);
                    romBuilder.setLength(0);
                    escaping = true;
                    continue;
                }

                if (Pattern.matches(pattern2, romBuffer)){//when n comes before a symbol or space, change it to ン
                    katBuilder.append(romBuffer, 0, romBufferSize-2);
                    katBuilder.append("ん");
                    String lastChar = Character.toString(romBuffer.charAt(romBufferSize-1));
                    katBuilder.append(char2char.getOrDefault(lastChar, lastChar));
                    romBuilder.setLength(0);
                    continue;
                }
                katCandidate = romBuffer.substring(romBufferSize-3);
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    if (romBufferSize > 3) {
                        if (romBuffer.charAt(romBufferSize - 4)
                                == romBuffer.charAt(romBufferSize - 3)){ // eg: xwwhe > xッウェ
                            katBuilder.append(romBuffer,0,romBufferSize-4);//append x
                            katBuilder.append("っ");//append ッ
                            katBuilder.append(ch); // append ウェ
                            romBuilder.setLength(0);
                            continue;
                        }
                        if(romBuffer.charAt(romBufferSize - 4) == 'n'){// eg: xnwhe > xンウェ
                            katBuilder.append(romBuffer,0,romBufferSize-4);//append x
                            katBuilder.append("ん");//append ン
                            katBuilder.append(ch); // append ウェ
                            romBuilder.setLength(0);
                            continue;
                        }

                    }//eg:xxxwhe > xxxウェ
                    katBuilder.append(romBuffer, 0, romBufferSize-3);//append xxx
                    katBuilder.append(ch); // append ウェ
                    romBuilder.setLength(0);
                    continue;
                }
                katCandidate = romBuffer.substring(romBufferSize - 2);
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    if (romBuffer.charAt(romBufferSize - 3)
                            == romBuffer.charAt(romBufferSize - 2)){ // eg: xkka > xッカ
                        katBuilder.append(romBuffer,0,romBufferSize-3);//append x
                        katBuilder.append("っ");//append ッ
                        katBuilder.append(ch); // append ウェ
                        romBuilder.setLength(0);
                        continue;
                    }
                    if(romBuffer.charAt(romBufferSize - 3) == 'n'){// eg: xnka > xンカ
                        katBuilder.append(romBuffer,0,romBufferSize-3);//append x
                        katBuilder.append("ん");//append ン
                        katBuilder.append(ch); // append カ
                        romBuilder.setLength(0);
                        continue;
                    }
                    //eg: xxka > xxカ
                    katBuilder.append(romBuffer, 0, romBufferSize-2);//append xx
                    katBuilder.append(ch); //append カ
                    romBuilder.setLength(0);
                    continue;
                }
                katCandidate = romBuffer.substring(romBufferSize - 1);
                if (char2char.containsKey(katCandidate)) {
                    String ch = char2char.get(katCandidate);
                    katBuilder.append(romBuffer, 0, romBufferSize-1);//append
                    katBuilder.append(ch);
                    romBuilder.setLength(0);
                }
            }
        }
        katBuilder.append(romBuilder);
        return katBuilder.toString();
    }

}

package com.RuneLingual.nonLatin.Japanese;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.ChatMessages.PlayerMessage;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.nonLatin.Japanese.Rom2hira.FourValues;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class UpdateChatInputJa {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private PlayerMessage playerMessage;
    @Inject @Getter
    private Rom2hira rom2Hira;
    @Getter
    private int inputCount = 0; //for counting number of words in chat input
    @Getter
    private String chatJpMsg = "";//whats written for chat input overlay
    @Getter
    private List<String> kanjKatCandidates = new ArrayList<>();//candidates of kanji or katakana from input, also used for candidates overlay
    @Getter
    private int instCandidateSelection = -1;
    private List<FourValues> japCharDS = new ArrayList<>();//store all japanese words's written form, how its read, type, rank
    private List<String> prevHiraList = new ArrayList<>();//stores the last updated words that are displayed
    private List<String> prevJPList = new ArrayList<>();
    private HashMap<String,String> char2char = new HashMap<>();
    private String notAvailable = "nan";

    @Inject
    public UpdateChatInputJa(RuneLingualPlugin plugin) {
        this.plugin = plugin;
        String wordFilePath = FileNameAndPath.getLocalBaseFolder() + "/" +
                LangCodeSelectableList.日本語.getLangCode() +
                "/foreign2foreign_" + LangCodeSelectableList.日本語.getLangCode() + ".txt";
        putWordToHash(wordFilePath);
        log.info("created hashmap for transform dict, for type : " + wordFilePath);
    }

    private void putWordToHash(String filePath) {
        /*
        * these files are in the format of "written,read,type,rank"
        * written is the kanji or katakana.
        * read is the hiragana.
        * type is the type of word, eg. noun, verb, adj, etc.
        * rank is the rank of the word, the smaller the number, the more common the word is.
        *
        * The file itself is downloaded by Downloader, so are not jar files
        * */
        // check if folder and file exists, if not, create it
        FileNameAndPath.createDirectoryIfNotExists(FileNameAndPath.getLocalBaseFolder() + "/" +
                LangCodeSelectableList.日本語.getLangCode());
        FileNameAndPath.createFileIfNotExists(filePath);
        try (BufferedReader reader = new BufferedReader(new InputStreamReader
                (new FileInputStream(filePath), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(",");
                if (parts.length == 4) {
                    FourValues fourValues = new FourValues(parts[0],parts[1],parts[2],Integer.parseInt(parts[3]));
                    japCharDS.add(fourValues);
                } else {
                    log.info("rom to jap.csv : not enough elements : "+parts.length);
                }
            }
        } catch (IOException e) {
            log.error("error creating hashmap for transform dict, for type : {}", filePath, e);
        }
    }

    public void updateInput() {
        if (playerMessage.getTranslationOption().equals(Transformer.TransformOption.AS_IS)) {
            return;
        }

        String inputmsg = playerMessage.getChatInputString();
        if (inputmsg.isBlank()){
            inputCount = 0;
            chatJpMsg = "";
            return;
        }

        inputCount = inputmsg.length();
        String newMsg = romJpTransform(inputmsg, true);
        if (newMsg != null && !newMsg.isEmpty())
            chatJpMsg = newMsg;
    }

    public String romJpTransform(String romMsg, boolean chatInput) {
        String hiraMsg = this.rom2Hira.romToKat(romMsg);
        return hira2Jp(hiraMsg, chatInput);
    }


    private String hira2Jp(String hiraMsg, boolean chatInput) {//hiragana list to kanji sentence
        String[] wordList = getWakatiGaki(hiraMsg);//get katakana text split with symbols, space attached at the end of each string if its katakana or numbers
        //eg of wordList : "強烈はぴはぴ閾値" "、," "凄く"  "!/" "だよ" "、" "kaka" "クェスト00" "やり" "33" "," "ましょう"
        List<String> wordListList = Arrays.asList(getWakatiGaki(hiraMsg));

        if (compareLists(wordListList, prevHiraList) && chatInput)
            return null;
        int startIndex = searchFirstDif(wordList);
        if (startIndex < 1)
            startIndex = 0;
        List<String> changedList = new ArrayList<>();
        boolean last;
        for (int i = startIndex; i < wordList.length; i++) {
            String word = wordList[i];
            if (word.matches("^\\d+$") || word.matches("^を+$")
                    || word.matches("[^\\p{IsHiragana}]+\\s*")){
                changedList.add(word);
                kanjKatCandidates.clear();
            }
            else {
                last = i == wordList.length - 1;
                Rom2hira.FourValues FVword = getMatch(word, last, chatInput);
                changedList.add(FVword.getWritten());
            }
        }
        List<String> sublistPrevJPList = prevJPList.subList(0, startIndex);
        String[] notChanged = sublistPrevJPList.toArray(new String[0]);
        ArrayList<String> combindedList = new ArrayList<>(Arrays.asList(notChanged));
        combindedList.addAll(changedList);

        prevHiraList = wordListList;
        prevJPList = combindedList;
        return String.join("",combindedList);
    }

    private Rom2hira.FourValues getMatch(String word, boolean last, boolean chatInput){//the last word in wordList
        Rom2hira.FourValues FVofWord = new Rom2hira.FourValues(word.trim().replaceAll("\\d",""),word.trim().replaceAll("\\d",""),notAvailable,-1);
        List<Rom2hira.FourValues> newCandidates = new ArrayList<>();
        newCandidates.add(FVofWord);
        if (word.matches("[\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+\\d+$") ||//if theres a number at the end of strings, set candidate to that
                word.matches("[\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+ +$")){// if theres 1 or more space, #space - 1 = candidateN
            //show no candidates
            int candidateSelectionN;
            String wordPart;
            if (word.matches("[\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+\\d+$")) {
                String intPart = word.split("\\D+")[1].trim();
                candidateSelectionN = Integer.parseInt(intPart);
                wordPart = word.split("\\d+\\s*$")[0];
            } else {
                String spacePart = word.split("[\\p{IsAlphabetic}\\p{IsHiragana}\\p{IsKatakana}]+")[1];
                candidateSelectionN = spacePart.length() - 1;
                wordPart = word.split(" +$")[0];
            }
            if (chatInput)
                kanjKatCandidates.clear();
            newCandidates.addAll(getCandidates(wordPart));

            if (newCandidates.size() -1< candidateSelectionN) //if the selection is too large, return the last cand
                candidateSelectionN = newCandidates.size() - 1;

            if (last) {
                if (chatInput)
                    instCandidateSelection = candidateSelectionN;
                for (Rom2hira.FourValues fv : newCandidates)
                    if (chatInput)
                        kanjKatCandidates.add(fv.getWritten());
            } else if (chatInput)
                instCandidateSelection = -1;
            return newCandidates.get(candidateSelectionN);

        } else { //no japanese + number nor space at the end, add it as hiragana if its not the last word, if last word then look for candidates
            if (last) {//if its the last word on wordList, update candidates shown by overlay
                if (chatInput)
                    instCandidateSelection = -1;
                newCandidates.addAll(getCandidates(word));
                if (chatInput)
                    kanjKatCandidates.clear();
                for (Rom2hira.FourValues fv : newCandidates)
                    if (chatInput)
                        kanjKatCandidates.add(fv.getWritten());
                if (chatInput)
                    instCandidateSelection = -1;
            }
            return FVofWord;
        }
    }
    private List<Rom2hira.FourValues> getCandidates(String word){
        List<Rom2hira.FourValues> matches;

        matches = getAllMatches(word, 50);//get all exact matches
        List<FourValues> newCandidates = new ArrayList<>(matches);

        if (newCandidates.size() < 30) {//if not many candidates, get matches that begin with the last wordPart
            // (the last wordPart might be in the middle of being typed
            matches = getAllBeginningWith(word,Math.min(30-10-newCandidates.size(),10));
            newCandidates.addAll(matches);
        }
        newCandidates.sort(new compareFV());
        if (newCandidates.size() < 40) {//if still not many candidates
            // (the last wordPart might be in the middle of being typed
            int nWordsToAdd = 40 - newCandidates.size();
            List<Rom2hira.FourValues> containedAndExtra;
            containedAndExtra = getAllContaining(word, nWordsToAdd); // get all words that is contained within "wordPart"
            newCandidates.addAll(containedAndExtra);
        }

        //add katakana candidate, as 3rd option if it has more than 1 kanji candidate, 2nd if no kanji candidate
        if (newCandidates.size() > 1) {
            String kata = hira2kata(word);
            Rom2hira.FourValues kataFV = new Rom2hira.FourValues(kata,kata,notAvailable,0);
            newCandidates.add(2,kataFV);
        } else {
            String kata = hira2kata(word);
            Rom2hira.FourValues kataFV = new Rom2hira.FourValues(kata,kata,notAvailable,0);
            newCandidates.add(0,kataFV);
        }
        return  newCandidates;
    }
    private int searchFirstDif(String[] wordList){
        int upTo = 0;
        if (wordList.length > prevHiraList.size())
            upTo = prevHiraList.size();
        else
            upTo = wordList.length;
        for (int i = 0; i < upTo; i++)
            if (!Objects.equals(wordList[i], prevHiraList.get(i)))
                return i;
        return (upTo == 0 ? 0 : upTo-1);
    }
    public static <T> boolean compareLists(List<T> list1, List<T> list2) {
        // If lists have different sizes, they are not equal
        if (list1.size() != list2.size()) {
            return false;
        }

        // Compare elements of the lists
        for (int i = 0; i < list1.size(); i++) {
            if (!list1.get(i).equals(list2.get(i))) {
                return false;
            }
        }

        // If all elements match, lists are equal
        return true;
    }
    private List<Rom2hira.FourValues> getAllMatches(String kata, int nToAdd) {
        List<Rom2hira.FourValues> matches = new ArrayList<>();
        int count = 0;
        for (Rom2hira.FourValues entry: japCharDS) {
            if (count > nToAdd)
                break;
            if (entry.getRead().equals(kata)){
                if (matches.isEmpty()) {
                    count++;
                    matches.add(entry);
                }
                else if (matches.get(matches.size() - 1).getRank() + 9 < entry.getRank()) {//dont add if the word is only different tense of the previous
                    count++;
                    matches.add(entry);
                }
            }
        }
        return matches;
    }
    private List<Rom2hira.FourValues> getAllBeginningWith(String kata, int nToAdd) {
        List<Rom2hira.FourValues> matches = new ArrayList<>();
        int count = 0;
        for (Rom2hira.FourValues entry: japCharDS) {
            if (count > nToAdd)
                break;
            if (entry.getRead().startsWith(kata) && !entry.getRead().equals(kata)) {
                count++;
                matches.add(entry);
            }
        }
        return matches;
    }
    private List<Rom2hira.FourValues> getAllContaining(String kata, int nToAdd) {//returns a substring 0:x that is in japCharDS, and add it to substring x:
        List<Rom2hira.FourValues> matches = new ArrayList<>();
        int count = 0;
        for (int i = kata.length() - 1; i >= 0 && count < nToAdd; i--) {
            String substring = kata.substring(0,i);
            for (int j = 0; j < japCharDS.size(); j++) {
                Rom2hira.FourValues entry = japCharDS.get(j);
                if (entry.getRead().equals(substring)) {
                    Rom2hira.FourValues addingFV = new Rom2hira.FourValues(entry.getWritten() + kata.substring(i),
                            entry.getWritten() + kata.substring(i), notAvailable, entry.getRank());
                    if (matches.isEmpty()) {
                        matches.add(addingFV);
                        count++;
                    } else if (matches.get(matches.size() - 1).getRank() + 3 < addingFV.getRank()) {//only add few of the word is only different tense of the previous
                        count++;
                        if (count > nToAdd)
                            break;
                        matches.add(addingFV);
                    }
                }
            }
        }
        return matches;
    }
    private String[] getWakatiGaki (String text) {
        // Regular expression pattern for splitting
        String regexPattern =
                "(を+)|" + "([^\\p{IsAlphabetic}]+[a-zA-Z]+)|" +
                        "([a-zA-Z]+[^\\p{IsAlphabetic}]+)|" +
                        "([\\p{IsHiragana}\\p{IsKatakana}ー]*\\d+)|" +
                        "([\\p{IsHiragana}\\p{IsKatakana}ー]+ +)|" +
                        "([\\p{IsHiragana}\\p{IsKatakana}ー]+)|"+
                        "(\\s*[\\d]+\\s*)|" +
                        "([^\\p{IsHiragana}\\p{IsKatakana}ー\\d ]+)";

        Pattern patternCompiled = Pattern.compile(regexPattern);
        Matcher matcher = patternCompiled.matcher(text);
        List<String> segmentsAndPunctuation = new ArrayList<>();

        // Find and collect all matches
        while (matcher.find()) {
            String segment = matcher.group(0);
            if (segment != null) {
                segmentsAndPunctuation.add(segment);
            }
        }


        // Convert the list to an array
        return segmentsAndPunctuation.toArray(new String[0]);
    }



    private String hira2kata(String hira) {
        StringBuilder kata = new StringBuilder();
        for (int i = 0; i < hira.length(); i++) {
            char c = hira.charAt(i);
            if (c >= 0x3041 && c <= 0x3096) {
                kata.append((char) (c + 0x60));
            } else {
                kata.append(c);
            }
        }
        return kata.toString();
    }

}

package com.RuneLingual.nonLatin;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FilenameFilter;
import java.util.HashMap;

import com.RuneLingual.prepareResources.Downloader;
import com.RuneLingual.RuneLingualPlugin;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ChatIconManager;

import javax.imageio.ImageIO;
import javax.inject.Inject;

@Slf4j
public class CharImageInit {
    @Inject
    RuneLingualPlugin runeLingualPlugin;

    /*
    * Load character images from the local folder, and register them to the chatIconManager
    * The images are downloaded from the RuneLingual transcript website, which is done in the Downloader class.
     */
    public void loadCharImages()
    {
        //if the target language doesn't need character images, return
        if(!runeLingualPlugin.getTargetLanguage().needsCharImages()){
            return;
        }

        ChatIconManager chatIconManager = runeLingualPlugin.getChatIconManager();
        HashMap<String, Integer> charIds = runeLingualPlugin.getCharIds();

        Downloader downloader = runeLingualPlugin.getDownloader();
        String langCode = downloader.getLangCode();
        final String pathToChar = downloader.getLocalLangFolder().toString() + File.separator + "char_" + langCode;

        String[] charNameArray = getCharList(pathToChar); //list of all characters e.g.　black--3021.png

        for (String imageName : charNameArray) {//register all character images to chatIconManager
            try {
                String fullPath = pathToChar + File.separator + imageName;
                File externalCharImg = new File(fullPath);
                final BufferedImage image = ImageIO.read(externalCharImg);

                final int charID = chatIconManager.registerChatIcon(image);
                charIds.put(imageName, charID);
            } catch (Exception e){log.error("error:",e);}
        }
        log.info("end of making character image hashmap");
    }


    public String[] getCharList(String pathToChar) {//get list of names of all characters of every colours)
        FilenameFilter pngFilter = new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.toLowerCase().endsWith(".png");
            }
        };
        File colorDir = new File(pathToChar + "/");
        File[] files = colorDir.listFiles(pngFilter); //list of files that end with ".png"

        if (files == null){return new String[]{};}

        String[] charImageNames = new String[files.length];
        for (int j = 0; j < files.length; j++) {
            charImageNames[j] = files[j].getName();
        }
        return charImageNames;
    }
}

package com.RuneLingual;

import com.RuneLingual.Widgets.WidgetsUtilRLingual;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.Transformer;
import com.RuneLingual.commonFunctions.Transformer.TransformOption;
import com.RuneLingual.SQL.SqlVariables;
import com.RuneLingual.SQL.SqlQuery;

import com.RuneLingual.nonLatin.GeneralFunctions;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;

import javax.inject.Inject;

import lombok.Setter;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.tuple.Pair;

import java.util.HashSet;
import java.util.Set;
import java.util.Arrays;
import java.util.regex.Pattern;
import com.RuneLingual.debug.OutputToFile;
import com.RuneLingual.commonFunctions.Ids;
import com.RuneLingual.RuneLingualConfig.*;

@Slf4j
public class MenuCapture
{
	@Inject
	private Client client;
	@Inject
	private RuneLingualPlugin plugin;

	@Setter
	private boolean debugMessages = true;
	@Inject
	private Transformer transformer;
	@Getter // list of menu options currently being translated by api, periodically checked to see if they are done
	private Set<Pair<MenuEntry, PendingTranslationType>> pendingApiTranslation = new HashSet<>();

	private TransformOption menuOptionTransformOption = TransformOption.TRANSLATE_LOCAL;
	@Inject
	private OutputToFile outputToFile;

	@Inject
	public MenuCapture(RuneLingualPlugin plugin) {
		this.plugin = plugin;
	}
	@Inject
	private WidgetsUtilRLingual widgetsUtilRLingual;

	private final Colors optionColor = Colors.white;

	enum PendingTranslationType {
		OPTION,
		TARGET,
		BOTH
	}

	public void handleOpenedMenu(MenuOpened event){
		pendingApiTranslation.clear();
		MenuEntry[] menus = event.getMenuEntries();
		for (MenuEntry menu : menus) {
            handleMenuEvent(menu);
			Menu subMenu = menu.getSubMenu();
			if (subMenu != null)
				for(MenuEntry subMenuEntry : subMenu.getMenuEntries()) {
					handleMenuEvent(subMenuEntry);
				}
        }
	}

	public void handleMenuEvent(MenuEntry currentMenu) {
		// called whenever a right click menu is opened
		String[] newMenus = translateMenuAction(currentMenu);
		String newTarget = newMenus[0];
		String newOption = newMenus[1];

		// add to pending list if they haven't been translated yet
		boolean isPending = addPendingMenuApiTranslation(currentMenu, newOption, newTarget);
		if (isPending) {
			return;
		}


		// reorder them if it is grammatically correct to do so in that language
		if(plugin.getTargetLanguage().needsSwapMenuOptionAndTarget()) {
			String temp = newOption;
			newOption = newTarget;
			newTarget = temp;
		}

		// swap out the translated menu action and target.
		if(newOption != null) {
			if (newTarget != null && !newTarget.isEmpty()) {
				currentMenu.setTarget(newTarget);
			} else {
				// if target is empty, remove the target part of the menu entry
				currentMenu.setTarget("");
			}
			currentMenu.setOption(newOption);
		}
	}

	public String[] translateMenuAction(MenuEntry currentMenu) {
		/*
		returns: String[] {newTarget, newOption}

		target and option examples
		option: Enable prayer reordering	target: <col=ff9040></col>
		option: Add-10<col=ff9040>		target: <col=ff9040>Pollnivneach teleport</col>
		 */
		MenuAction menuType = currentMenu.getType();

		String menuTarget = currentMenu.getTarget();  // eg. <col=ffff00>Sand Crab<col=ff00>  (level-15)     eg2. <col=ff9040>Dramen staff</col>
		String[] targetWordArray = Colors.getWordArray(menuTarget); // eg. ["Sand Crab", " (level-15)"]
		Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.white); // eg. [Colors.yellow, Colors.green]

		String menuOption = currentMenu.getOption(); // doesnt seem to have color tags, always white? eg. Attack
		String[] actionWordArray = Colors.getWordArray(menuOption); // eg. ["Attack"]
		Colors[] actionColorArray = Colors.getColorArray(menuOption, optionColor);



		menuOptionTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig(), plugin.getConfig().getSelectedLanguage());


		String[] result;
		// get translation for both target and option
		if(menuOptionTransformOption == TransformOption.TRANSLATE_API) {
			result = translateGeneralMenu(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray, currentMenu);
		} else if(isWalkOrCancel(menuType)){
			result = translateWalkOrCancel(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray, targetColorArray);
		}
		else if (isPlayerMenu(menuType)){
			result = translatePlayer(menuOption, actionWordArray, actionColorArray, targetWordArray, targetColorArray);
		}
		else if(isNpcMenu(menuType)) { // need to split into npcs with and without level
			result = translateNpc(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray, targetColorArray);
		}
		else if(isObjectMenu(menuType)){
			result = translateObject(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray);
		}
		else if(isItemOnGround(menuType)){ // needs checking
			result = translateGroundItem(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray);
		}
		else if(isItemInWidget(currentMenu)){ // either in inventory or in equipment
			result = translateInventoryItem(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray);
		}
		else if(isWidgetOnSomething(menuType)){ // needs checking
			//printMenuEntry(currentMenu);
			Pair<String, String> results = convertWidgetOnSomething(currentMenu);
			String itemLeft = results.getLeft();
			String entityOnRight = results.getRight();
			String itemTranslation = translateInventoryItem(itemLeft, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(itemLeft))[0];
			String entityTranslation = "";
			if(menuType.equals(MenuAction.WIDGET_TARGET_ON_PLAYER)){
				entityTranslation = translatePlayerTargetPart(Colors.getWordArray(entityOnRight), Colors.getColorArray(entityOnRight, Colors.white));
			} else if(menuType.equals(MenuAction.WIDGET_TARGET_ON_NPC)){
				entityTranslation = translateNpc(entityOnRight, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(entityOnRight), Colors.getColorArray(entityOnRight, Colors.white))[0];
			} else if(menuType.equals(MenuAction.WIDGET_TARGET_ON_GAME_OBJECT)){
				entityTranslation = translateObject(entityOnRight, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(entityOnRight))[0];
			} else if(menuType.equals(MenuAction.WIDGET_TARGET_ON_WIDGET) || menuType.equals(MenuAction.WIDGET_TARGET_ON_GROUND_ITEM)){
				entityTranslation = translateGroundItem(entityOnRight, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(entityOnRight))[0];
			}
			String newTarget = itemTranslation + " -> " + entityTranslation;
			String newOption = translateInventoryItem(itemLeft, menuOption, actionWordArray, actionColorArray, Colors.getWordArray(menuOption))[1];
			result = new String[]{newTarget, newOption};
		} else { // is a general menu
//			log.info("General menu");
//			printMenuEntry(currentMenu);

			// for debug purposes
			//outputToFile.menuTarget(menuTarget,SqlVariables.menuInSubCategory.getValue(), source);
			//outputToFile.menuOption(menuOption,SqlVariables.menuInSubCategory.getValue(), source);
			result = translateGeneralMenu(menuTarget, menuOption, actionWordArray, actionColorArray, targetWordArray, currentMenu);
		}

		// if the translation failed, return as is
		if (result.length < 2){
			return new String[]{menuTarget, menuOption};
		}

		String newTarget = result[0];
		String newOption = result[1];

		return new String[]{newTarget, newOption};
	}

	private String[] translateWalkOrCancel(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray, Colors[] targetColorArray){
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		String newOption, newTarget;
		actionSqlQuery.setEnglish(menuOption);
		actionSqlQuery.setCategory(SqlVariables.categoryValue4Actions.getValue());

		newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);

		if(Colors.removeNonImgTags(menuTarget).isEmpty()) {
			newTarget = "";
		} else {
			TransformOption menuTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig(), plugin.getConfig().getSelectedLanguage());
			if(hasLevel(menuTarget)){
				// if walk has a target with level, its a player
				newTarget = translatePlayerTargetPart(targetWordArray, targetColorArray);
			} else {
				// this shouldnt happen but just in case
				targetSqlQuery.setEnglish(targetWordArray[0]);
				targetSqlQuery.setCategory(SqlVariables.categoryValue4Name.getValue());
				targetSqlQuery.setSubCategory(SqlVariables.subcategoryValue4Menu.getValue());
				// need to split into name and level if it has level
				newTarget = transformer.transform(targetWordArray, targetColorArray, menuTransformOption, targetSqlQuery, false);
			}
		}
		return new String[]{newTarget, newOption};
	}

	private String[] translatePlayer(String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray, Colors[] targetColorArray){
		//returns String[] {newTarget, newOption}
		//leave name as is (but replace to char image if needed)
		String newTarget = translatePlayerTargetPart(targetWordArray, targetColorArray);
		// set action as usual
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		actionSqlQuery.setPlayerActions(menuOption, Colors.white);
		String newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);
		return new String[] {newTarget, newOption};
	}

	private String[] translateNpc(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray, Colors[] targetColorArray) {
		String newTarget, newOption;
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		TransformOption npcTransformOption = getTransformOption(this.plugin.getConfig().getNPCNamesConfig(), plugin.getConfig().getSelectedLanguage());
		if(npcTransformOption.equals(TransformOption.AS_IS)){
			newTarget = menuTarget;
		} else if(hasLevel(menuTarget)){
			// if npc has a level, translate the name and level separately
			targetSqlQuery.setNpcName(targetWordArray[0], targetColorArray[0]);
			String targetName = transformer.transform(targetWordArray[0], targetColorArray[0], npcTransformOption, targetSqlQuery, false);
			String targetLevel = getLevelTranslation(targetWordArray[1], targetColorArray[1]);
			newTarget = targetName + targetLevel;
		} else {
			// if npc does not have a level, translate the name only
			targetSqlQuery.setNpcName(menuTarget, targetColorArray[0]);
			targetColorArray = Colors.getColorArray(menuTarget, targetColorArray[0]); //default color is not the same as initial definition
			newTarget = transformer.transform(targetWordArray, targetColorArray, npcTransformOption, targetSqlQuery, false);
		}

		actionSqlQuery.setNpcActions(menuOption, optionColor);
		newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);

		return new String[] {newTarget, newOption};
	}

	private String[] translateObject(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray) {
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		targetSqlQuery.setObjectName(menuTarget, Colors.lightblue);
		actionSqlQuery.setObjectActions(menuOption, optionColor);

		Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.lightblue); //default color is not the same as initial definition

		TransformOption	objectTransformOption = getTransformOption(this.plugin.getConfig().getObjectNamesConfig(), plugin.getConfig().getSelectedLanguage());

		String newTarget;
		if(objectTransformOption.equals(TransformOption.AS_IS)){
			newTarget = menuTarget;
		} else {
			newTarget = transformer.transform(targetWordArray, targetColorArray, objectTransformOption, targetSqlQuery, false);
		}
		String newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);

		return new String[] {newTarget, newOption};
	}

	private String[] translateGroundItem(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray){
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		targetSqlQuery.setItemName(menuTarget, Colors.orange);
		actionSqlQuery.setGroundItemActions(menuOption, optionColor);

		Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.orange); //default color is not the same as initial definition

		TransformOption itemTransformOption = getTransformOption(this.plugin.getConfig().getItemNamesConfig(), plugin.getConfig().getSelectedLanguage());
		String newTarget;
		if (itemTransformOption.equals(TransformOption.AS_IS)){
			newTarget = menuTarget;
		} else {
			newTarget = transformer.transform(targetWordArray, targetColorArray, itemTransformOption, targetSqlQuery, false);
		}
		if (menuOption.equals("Use")){// if it is "Use" option, it only looks at first value
			return new String[] {newTarget, ""};
		}
		String newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);
		return new String[] {newTarget, newOption};
	}

	private String[] translateInventoryItem(String menuTarget, String menuOption, String[] actionWordArray, Colors[] actionColorArray, String[] targetWordArray){
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);

		targetSqlQuery.setItemName(menuTarget, Colors.orange);
		actionSqlQuery.setInventoryItemActions(menuOption, optionColor);

		Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.orange); //default color is not the same as initial definition

		TransformOption itemTransformOption = getTransformOption(this.plugin.getConfig().getItemNamesConfig(), plugin.getConfig().getSelectedLanguage());
		String newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);
		if (Arrays.equals(targetWordArray, new String[]{"Use"}) && Arrays.equals(actionWordArray, new String[]{"Use"})){
			// it comes from the use item on something menu, and only needs to translate the option
			return new String[] {"", newOption};
		}
		String newTarget = transformer.transform(targetWordArray, targetColorArray, itemTransformOption, targetSqlQuery, false);

		return new String[] {newTarget, newOption};
	}

	// for menus that are none of item, object, npc, player, walk, cancel
	// e.g. "Enable prayer reordering" or "Add-10"
	private String[] translateGeneralMenu(String menuTarget, String menuOption, String[] actionWordArray,
										  Colors[] actionColorArray, String[] targetWordArray, MenuEntry currentMenu){
		String newTarget, newOption;
		// check what widget it is in, then set the source column value accordingly
		String source;
		if(plugin.getConfig().getMenuOptionConfig().equals(ingameTranslationConfig.USE_API) && plugin.getConfig().ApiConfig()){
			source = "";
		} else {
			source = getSourceNameFromMenu(currentMenu);
		}
		SqlQuery actionSqlQuery = new SqlQuery(this.plugin);
		actionSqlQuery.setGenMenuAcitons(menuOption, optionColor);
		actionSqlQuery.setSource(source);

		String optionToTranslate = Transformer.getEnglishColValFromText(menuOption);
		actionSqlQuery.setEnglish(optionToTranslate);

		if (!widgetsUtilRLingual.shouldPartiallyTranslateText(optionToTranslate)) {
			newOption = transformer.transformWithPlaceholders(menuOption, optionToTranslate, menuOptionTransformOption, actionSqlQuery);
		} else {
			optionToTranslate = widgetsUtilRLingual.getMatchingEnColVal4PartialTranslation(optionToTranslate);
			if (optionToTranslate == null) {
				newOption = menuOption;
			} else {
				actionSqlQuery.setEnglish(optionToTranslate);
				newOption = transformer.transformWithPlaceholders(menuOption, optionToTranslate, menuOptionTransformOption, actionSqlQuery);
				if (newOption != null) {
					newOption = plugin.getIds().getPartialTranslationManager().translateString(optionToTranslate, newOption, menuOption, optionColor);
				}
			}
		}
		if (newOption == null){ // if no translation was found, then return as is
			newOption = menuOption;
		}

		// if it didnt find a new option (newOption = menuOption), search for any match
		if(Colors.removeNonImgTags(newOption).equals(menuOption) && menuOptionTransformOption.equals(TransformOption.TRANSLATE_LOCAL)) {
			actionSqlQuery = new SqlQuery(this.plugin);
			actionSqlQuery.setEnglish(menuOption);
			newOption = transformer.transform(actionWordArray, actionColorArray, menuOptionTransformOption, actionSqlQuery, false);
		}

		if(Colors.removeNonImgTags(menuTarget).isEmpty()) { // if it doesnt have a target
			newTarget = "";
		} else if (Colors.removeNonImgTags(menuTarget).matches("(\\d+)")){ // if target is a number, leave as is
			newTarget = menuTarget;
		} else {
			// if it is in the quest tab, the values are in a different category/sub_category
			if(source.equals(SqlVariables.sourceValue4QuestListTab.getValue())) {
				menuTarget = translateQuestName(targetWordArray[0]);
				return new String[]{menuTarget, newOption};
			}
			if(source.equals(SqlVariables.sourceValue4EmotesTab.getValue())) { // emote names are stored in category=interface, subcategory=mainTabs, source=emotesTab
				menuTarget = translateEmoteName(targetWordArray[0]);
				return new String[]{menuTarget, newOption};
			}
			if(source.equals(SqlVariables.sourceValue4MusicTab.getValue())) { // music names are stored in category=interface, subcategory=mainTabs, source=musicTab
				menuTarget = translateMusicName(targetWordArray[0]);
				return new String[]{menuTarget, newOption};
			}
			// if the menu target is a widget not to translate (eg. player name) return as is
			Widget widget = currentMenu.getWidget();
			if (widget != null && this.plugin.getWidgetCapture().isWidgetIdNot2Translate(widget)) {
				return new String[]{menuTarget, newOption};
			}
			SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
			targetSqlQuery.setEnglish(targetWordArray[0]);
			targetSqlQuery.setCategory(SqlVariables.categoryValue4Name.getValue());
			targetSqlQuery.setSubCategory(SqlVariables.subcategoryValue4Menu.getValue());
			targetSqlQuery.setSource(source);
			targetSqlQuery.setColor(Colors.orange);

			TransformOption generalMenuTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig(), plugin.getConfig().getSelectedLanguage());
			Colors[] targetColorArray = Colors.getColorArray(menuTarget, Colors.orange); //default color is not the same as initial definition
			if(targetColorArray.length <= 1){
				newTarget = transformer.transform(targetWordArray, targetColorArray, generalMenuTransformOption, targetSqlQuery, false);
			} else {
				String targetToTranslate = Transformer.getEnglishColValFromText(menuTarget);
				newTarget = transformer.transformWithPlaceholders(menuTarget, targetToTranslate, generalMenuTransformOption, targetSqlQuery);
				if (newTarget == null) { // if no translation was found, then return as is
					newTarget = menuTarget;
				}
			}
		}
		return new String[]{newTarget, newOption};
	}

	private String translateQuestName(String questName) {
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		targetSqlQuery.setEnglish(questName);
		targetSqlQuery.setCategory(SqlVariables.categoryValue4Manual.getValue());
		targetSqlQuery.setSubCategory(SqlVariables.subcategoryValue4Quest.getValue());

		TransformOption generalMenuTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig(), plugin.getConfig().getSelectedLanguage());
		// color is not possible to obtain by simple means, so its just orange for now
		return transformer.transform(questName, Colors.orange, generalMenuTransformOption, targetSqlQuery, false);
	}
	private String translateEmoteName(String emoteName) {
		// emote names are stored in category=interface, subcategory=mainTabs, source=emotesTab
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		targetSqlQuery.setEnglish(emoteName);
		targetSqlQuery.setCategory(SqlVariables.categoryValue4Interface.getValue());
		targetSqlQuery.setSubCategory(SqlVariables.subcategoryValue4MainTabs.getValue());
		targetSqlQuery.setSource(SqlVariables.sourceValue4EmotesTab.getValue());

		TransformOption generalMenuTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig(), plugin.getConfig().getSelectedLanguage());
		return transformer.transform(emoteName, Colors.orange, generalMenuTransformOption, targetSqlQuery, false);
	}
	private String translateMusicName(String musicName) {
		// music names are stored in category=interface, subcategory=mainTabs, source=musicTab
		SqlQuery targetSqlQuery = new SqlQuery(this.plugin);
		targetSqlQuery.setEnglish(musicName);
		targetSqlQuery.setCategory(SqlVariables.categoryValue4Interface.getValue());
		targetSqlQuery.setSubCategory(SqlVariables.subcategoryValue4MainTabs.getValue());
		targetSqlQuery.setSource(SqlVariables.sourceValue4MusicTab.getValue());
		targetSqlQuery.setColor(Colors.orange);

		TransformOption generalMenuTransformOption = getTransformOption(this.plugin.getConfig().getMenuOptionConfig(), plugin.getConfig().getSelectedLanguage());
		if(generalMenuTransformOption.equals(TransformOption.TRANSLATE_LOCAL)) {
			// music name can have placeholder values for numbers such as arabian <Num0> for "arabian 2", "arabian 3"
			String textToTranslate = Transformer.getEnglishColValFromText(musicName);
			targetSqlQuery.setEnglish(textToTranslate);
			String newMusic = transformer.transformWithPlaceholders(musicName, textToTranslate, generalMenuTransformOption, targetSqlQuery);
			if (newMusic == null){
				newMusic = musicName;
			}
			return newMusic;
		}
		return transformer.transform(musicName, Colors.orange, generalMenuTransformOption, targetSqlQuery, false);

	}

	private String translatePlayerTargetPart(String[] targetWordArray, Colors[] targetColorArray) {

		//leave name as is (but still give to transformer to replace to char image if needed)
		if(!targetWordArray[0].matches("^<img=.*>$")) { // doesn't have icons before their names
			String playerName = targetWordArray[0];
			String translatedName = transformer.transform(playerName, Colors.white, TransformOption.AS_IS, null, false);
			if (targetWordArray.length == 1) {
				return translatedName;
			} else {
				return translatedName + getLevelTranslation(targetWordArray[1], targetColorArray[1]);
			}
		} else {
			// contains icons before their names, such as clan rank symbols
			StringBuilder newName = new StringBuilder();
			String levelString = "  (level-0)";
			for(int i = 0; i < targetWordArray.length; i++){
				if(i == targetWordArray.length - 1){ // the last element of targetWordArray is always the level part
					levelString = targetWordArray[i];
					break;
				}
				newName.append(targetWordArray[i]);
			}
			String translatedName = transformer.transform(newName.toString(), Colors.white, TransformOption.AS_IS, null, false);
			return translatedName + getLevelTranslation(levelString, targetColorArray[targetWordArray.length - 1]);
		}
	}

	private String getSourceNameFromMenu(MenuEntry menu){
		String source = "";
		Ids ids = this.plugin.getIds();
		if(isChildWidgetOf(ids.getCombatOptionParentWidgetId(), menu)){
			source = SqlVariables.sourceValue4CombatOptionsTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdSkillsTab(),menu)){
			source = SqlVariables.sourceValue4SkillsTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdCharacterSummaryTab(),menu)){
			source = SqlVariables.sourceValue4CharacterSummaryTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdQuestTab(), menu)){
			source = SqlVariables.sourceValue4QuestListTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdAchievementDiaryTab(),menu)){
			source = SqlVariables.sourceValue4AchievementDiaryTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdInventoryTab(),menu)){
			source = SqlVariables.sourceValue4InventTab.getValue();
		}  else if(isChildWidgetOf(ids.getWidgetIdEquipmentTab(),menu)){
			source = SqlVariables.sourceValue4WornEquipmentTab.getValue();
		}else if(isChildWidgetOf(ids.getWidgetIdPrayerTab(),menu)){
			source = SqlVariables.sourceValue4PrayerTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdSpellBookTab(), menu)){
			source = SqlVariables.sourceValue4SpellBookTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdGroupsTab(), menu)){
			source = SqlVariables.sourceValue4GroupTab.getValue();
		} else if(isChildWidgetOf(ids.getFriendsTabParentWidgetId(), menu)){
			source = SqlVariables.sourceValue4FriendsTab.getValue();
		} else if(isChildWidgetOf(ids.getIgnoreTabParentWidgetId(), menu)){
			source = SqlVariables.sourceValue4IgnoreTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdAccountManagementTab(), menu)){
			source = SqlVariables.sourceValue4AccountManagementTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdSettingsTab(), menu)){
			source = SqlVariables.sourceValue4SettingsTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdLogoutTab(), menu)){
			source = SqlVariables.sourceValue4LogoutTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdWorldSwitcherTab(), menu)) {
			source = SqlVariables.sourceValue4WorldSwitcherTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdEmotesTab(), menu)){
			source = SqlVariables.sourceValue4EmotesTab.getValue();
		} else if(isChildWidgetOf(ids.getWidgetIdMusicTab(), menu)){
			source = SqlVariables.sourceValue4MusicTab.getValue();
		}
		//log.info("source: " + source);
		return source;
	}

	private String getLevelTranslation(String levelString, Colors color) {
		// translates combat level, such as "  (level-15)"
		SqlQuery levelQuery = new SqlQuery(this.plugin);
		String level = levelString.replaceAll("[^0-9]", "");
		levelQuery.setPlayerLevel();
		Transformer transformer = new Transformer(this.plugin);

		TransformOption option = getTransformOption(this.plugin.getConfig().getGameMessagesConfig(), plugin.getConfig().getSelectedLanguage());
	//TODO: colours may need adjusting for () and level's digits
		if(plugin.getConfig().getSelectedLanguage().needsCharImages()) // change color to simple color variants. eg: light green to green
			color = color.getSimpleColor();
		String levelTranslation = transformer.transform(levelQuery.getEnglish(), color, option, levelQuery, false);
		String openBracket = transformer.transform("(", color, TransformOption.AS_IS, null, false);
		String lvAndCloseBracket = transformer.transform(level+")", color, TransformOption.AS_IS, null, false);
		return "  " + color.getColorTag() + openBracket  + levelTranslation + color.getColorTag() + lvAndCloseBracket;
	}

	public static TransformOption getTransformOption(ingameTranslationConfig conf, LangCodeSelectableList lang) {
		TransformOption transformOption;
		if(conf.equals(ingameTranslationConfig.USE_LOCAL_DATA)){
			if(lang.hasLocalTranscript()) {
				transformOption = TransformOption.TRANSLATE_LOCAL;
			} else {
				transformOption = TransformOption.AS_IS;
			}
		} else if(conf.equals(ingameTranslationConfig.DONT_TRANSLATE)){
			transformOption = TransformOption.AS_IS;
		} else if(conf.equals(ingameTranslationConfig.USE_API)){
			transformOption = TransformOption.TRANSLATE_API;
		} else {
			transformOption = TransformOption.TRANSLATE_LOCAL;
		}
		return transformOption;
	}

	private void printMenuEntry(MenuEntry menuEntry)
	{
		String target = menuEntry.getTarget();
		String option = menuEntry.getOption();
		MenuAction type = menuEntry.getType();
		log.info("option: " + option + ", target: " + target + ", type: " + type);
	}

	private Pair<String, String> convertWidgetOnSomething(MenuEntry entry)
	{
		String menuTarget = entry.getTarget();
		String[] parts = menuTarget.split(" -> ");
		String itemName = parts[0];
		String useOnName = parts[1];
		return Pair.of(itemName, useOnName);
	}

	private boolean hasLevel(String target)
	{
		// check if target contains <col=(numbers and alphabets)>(level-(*\d)). such as "<col=ffffff>Mama Layla<col=ffff00>(level-3000)"
		Pattern re = Pattern.compile(".+<col=[a-zA-Z0-9]+>\\s*\\(level-\\d+\\)");
		return re.matcher(target).find();
	}

	private boolean isWalkOrCancel(MenuAction action)
	{
		return ((action.equals(MenuAction.CANCEL))
				|| (action.equals(MenuAction.WALK)));
	}

	public boolean isGeneralMenu(MenuEntry menuEntry)
	{
		MenuAction action = menuEntry.getType();
		// checks if current action target is a menu that introduces general actions
		return  (!isItemInWidget(menuEntry) &&
					(action.equals(MenuAction.CC_OP)
						|| action.equals(MenuAction.CC_OP_LOW_PRIORITY)
						|| isWalkOrCancel(action)
						|| action.equals(MenuAction.RUNELITE_OVERLAY)
						|| action.equals(MenuAction.RUNELITE)
					)
		);
	}

	public boolean isObjectMenu(MenuAction action)
	{
		return ((action.equals(MenuAction.EXAMINE_OBJECT))
				|| (action.equals(MenuAction.GAME_OBJECT_FIRST_OPTION))
				|| (action.equals(MenuAction.GAME_OBJECT_SECOND_OPTION))
				|| (action.equals(MenuAction.GAME_OBJECT_THIRD_OPTION))
				|| (action.equals(MenuAction.GAME_OBJECT_FOURTH_OPTION))
				|| (action.equals(MenuAction.GAME_OBJECT_FIFTH_OPTION)));
	}
	public boolean isNpcMenu(MenuAction action)
	{
		return ((action.equals(MenuAction.EXAMINE_NPC))
				|| (action.equals(MenuAction.NPC_FIRST_OPTION))
				|| (action.equals(MenuAction.NPC_SECOND_OPTION))
				|| (action.equals(MenuAction.NPC_THIRD_OPTION))
				|| (action.equals(MenuAction.NPC_FOURTH_OPTION))
				|| (action.equals(MenuAction.NPC_FIFTH_OPTION)));
	}
	public boolean isItemOnGround(MenuAction action)
	{
		return ((action.equals(MenuAction.EXAMINE_ITEM_GROUND))
				|| (action.equals(MenuAction.GROUND_ITEM_FIRST_OPTION))
				|| (action.equals(MenuAction.GROUND_ITEM_SECOND_OPTION))
				|| (action.equals(MenuAction.GROUND_ITEM_THIRD_OPTION))
				|| (action.equals(MenuAction.GROUND_ITEM_FOURTH_OPTION))
				|| (action.equals(MenuAction.GROUND_ITEM_FIFTH_OPTION)));
	}
	public boolean isPlayerMenu(MenuAction action)
	{
		return ((action.equals(MenuAction.PLAYER_FIRST_OPTION))
				|| (action.equals(MenuAction.PLAYER_SECOND_OPTION))
				|| (action.equals(MenuAction.PLAYER_THIRD_OPTION))
				|| (action.equals(MenuAction.PLAYER_FOURTH_OPTION))
				|| (action.equals(MenuAction.PLAYER_FIFTH_OPTION))
				|| (action.equals(MenuAction.PLAYER_SIXTH_OPTION))
				|| (action.equals(MenuAction.PLAYER_SEVENTH_OPTION))
				|| (action.equals(MenuAction.PLAYER_EIGHTH_OPTION))
				|| (action.equals(MenuAction.RUNELITE_PLAYER)));
	}
	public boolean isWidgetOnSomething(MenuAction action)
	{
		return ((action.equals(MenuAction.WIDGET_TARGET_ON_WIDGET))
				|| (action.equals(MenuAction.WIDGET_TARGET_ON_GAME_OBJECT))
				|| (action.equals(MenuAction.WIDGET_TARGET_ON_NPC))
				|| (action.equals(MenuAction.WIDGET_TARGET_ON_GROUND_ITEM))
				|| (action.equals(MenuAction.WIDGET_TARGET_ON_PLAYER)));
	}

	public boolean isItemInWidget(MenuEntry menuEntry){
		MenuAction action = menuEntry.getType();
		String target = menuEntry.getTarget();
		target = Colors.removeNonImgTags(target);
		if(target.isEmpty() || !plugin.getConfig().getSelectedLanguage().hasLocalTranscript()){
			return false;
		}
		if (target.endsWith(" (Members)")) {
			target = target.substring(0, target.length() - 10);
		}


		SqlQuery sqlQuery = new SqlQuery(this.plugin);
		sqlQuery.setItemName(target, Colors.orange);


		return sqlQuery.getMatching(SqlVariables.columnEnglish, false).length > 0 &&
				(action.equals(MenuAction.CC_OP)
						|| action.equals(MenuAction.CC_OP_LOW_PRIORITY)
						|| action.equals(MenuAction.WIDGET_TARGET)
				);

	}

	private boolean isChildWidgetOf(int widgetIdToCheck, MenuEntry menuEntry){
		if(widgetIdToCheck == -1){
			return false;
		}
		Widget widget = client.getWidget(menuEntry.getParam1());

		while(widget != null){
			if(widget.getId() == widgetIdToCheck){
				return true;
			}
			widget = widget.getParent();
		}
		return false;
	}

	private boolean addPendingMenuApiTranslation(MenuEntry currentMenu, String newOption, String newTarget) {
		if (!plugin.getConfig().ApiConfig()){
			return false;
		}
		PendingTranslationType pendingType = null;
		boolean isOptionPending = false;
		boolean isTargetPending = false;
		if (plugin.getConfig().getMenuOptionConfig().equals(ingameTranslationConfig.USE_API)){
			if(!newOption.isEmpty() && !newOption.isBlank()) {
				String oldOption_colTag = currentMenu.getOption();
				boolean haveTranslatedBefore = plugin.getDeepl().getDeeplPastTranslationManager().haveTranslatedBefore(oldOption_colTag);
				if (!haveTranslatedBefore){ // when separating words by colors, if any of the words are not result of translation
					isOptionPending = true;
					pendingType = PendingTranslationType.OPTION;
				}
			}
		}
		if(getMenuTargetOption(currentMenu).equals(TransformOption.TRANSLATE_API)) {
			String oldTarget_colTag = currentMenu.getTarget();
			newTarget = Colors.removeNonImgTags(newTarget);
			boolean haveTranslatedBefore = plugin.getDeepl().getDeeplPastTranslationManager().haveTranslatedBefore(oldTarget_colTag);
			if (!haveTranslatedBefore) {// or when separating words by colors, if any of the words match
				if (!newTarget.isEmpty() && !newTarget.isBlank()) {
					isTargetPending = true;
					pendingType = PendingTranslationType.TARGET;
				}
			}
		}
		if (!isOptionPending){
			currentMenu.setOption(newOption);
		}
		if (!isTargetPending){
			currentMenu.setTarget(newTarget);
		}
		if (isOptionPending && isTargetPending){
			pendingType = PendingTranslationType.BOTH;
		}
		if (pendingType != null){
			pendingApiTranslation.add(Pair.of(currentMenu, pendingType));
		}

		return pendingType != null;
	}

	// check if any api translation is done
	// if it is, replace the menu entry with the translation
	public void handlePendingApiTranslation(){
		if (!plugin.getConfig().ApiConfig() ||
				pendingApiTranslation.isEmpty()){
			return;
		}
		Set<Pair<MenuEntry, PendingTranslationType>> toRemove = new HashSet<>();
        for (Pair<MenuEntry, PendingTranslationType> pair : pendingApiTranslation) {
			MenuEntry menu = pair.getLeft();
            PendingTranslationType type = pair.getRight();
			boolean remove = handlePendingMenu(menu, type);
			if (remove) {
				toRemove.add(pair);
			}
        }
		pendingApiTranslation.removeAll(toRemove);
	}

	// if the menu text contains multiple colors, it won't be updated with this function (need to reopen the menu)
	private boolean handlePendingMenu(MenuEntry menu, PendingTranslationType type){
		String oldOption = menu.getOption();
		String oldTarget = menu.getTarget();
		boolean remove = false;
		String newOption = this.plugin.getDeepl().getDeeplPastTranslationManager().getPastTranslation(oldOption);
		String newTarget = this.plugin.getDeepl().getDeeplPastTranslationManager().getPastTranslation(oldTarget);
		if(plugin.getTargetLanguage().needsCharImages()) {
			Colors targetColor, local_optionColor;
			local_optionColor = Colors.white;
			targetColor = Colors.getColorArray(oldTarget, Colors.orange)[0];
			if(plugin.getTargetLanguage().needsSwapMenuOptionAndTarget()){
				// swap the option and target colors
				local_optionColor = targetColor;
				targetColor = Colors.white;
			}
			if (newTarget != null) {
				newTarget = transformer.stringToDisplayedString(newTarget, local_optionColor);
			}
			if (newOption != null) {
				newOption = transformer.stringToDisplayedString(newOption, targetColor);
			}
		}
		if (type.equals(PendingTranslationType.BOTH) && newOption != null && newTarget != null){
			remove = true;
			menu.setOption(newOption);
			menu.setTarget(newTarget);
			swapOptionTarget(menu);
		} else if (type.equals(PendingTranslationType.OPTION) && newOption != null){
			remove = true;
			menu.setOption(newOption);
			swapOptionTarget(menu);
		} else if (type.equals(PendingTranslationType.TARGET) && newTarget != null){
			remove = true;
			menu.setTarget(newTarget);
			swapOptionTarget(menu);
		}


		return remove;
	}

	private void swapOptionTarget(MenuEntry menu){
		if (!this.plugin.getTargetLanguage().needsSwapMenuOptionAndTarget()){
			return;
		}
		String option = menu.getOption();
		String target = menu.getTarget();
		menu.setOption(target);
		menu.setTarget(option);
	}

	private TransformOption getMenuTargetOption(MenuEntry menuEntry){
		if(isNpcMenu(menuEntry.getType())){
			return getTransformOption(this.plugin.getConfig().getNPCNamesConfig(), plugin.getConfig().getSelectedLanguage());
		}
		if(isObjectMenu(menuEntry.getType())){
			return getTransformOption(this.plugin.getConfig().getObjectNamesConfig(), plugin.getConfig().getSelectedLanguage());
		}
		if(isItemOnGround(menuEntry.getType())){
			return getTransformOption(this.plugin.getConfig().getItemNamesConfig(), plugin.getConfig().getSelectedLanguage());
		}
		if(isItemInWidget(menuEntry)){
			return getTransformOption(this.plugin.getConfig().getItemNamesConfig(), plugin.getConfig().getSelectedLanguage());
		}

		return getTransformOption(this.plugin.getConfig().getMenuOptionConfig(), plugin.getConfig().getSelectedLanguage());
	}

//	private void outputToDump(MenuEntry menu, SqlQuery query){
//		String menuTarget = menu.getTarget();
//		String menuOption = menu.getOption();
//		outputToFile.dumpGeneral(menuTarget, query.getCategory(), query.getSubCategory(), query.getSource());
//		outputToFile.dumpGeneral(menuOption, query.getCategory(), query.getSubCategory(), query.getSource());
//	}

}
package com.RuneLingual;

import lombok.Getter;

public enum TranslatingServiceSelectableList
{
    DeepL ("deepl"),
    DeepL_PRO ("deepl_pro"),;
//    GOOGLE_TRANSLATE ("google"),
//    OPENAI_GPT ("openai");

    @Getter
    private final String serviceName;

    TranslatingServiceSelectableList(String code){this.serviceName = code;}

    public String getService(){return this.serviceName;}
}

package com.RuneLingual;


import net.runelite.client.RuneLite;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.io.File;

@ConfigGroup(RuneLingualConfig.GROUP)
public interface RuneLingualConfig extends Config {
    final int offset_section1 = 0;
    public String helpLink = "https://github.com/YS-jack/RuneLingual-Plugin/blob/master/Readmes/Settings_select_lang.md";
    @ConfigSection(
            name = "Language selection",
            description = "Select language",
            position = offset_section1,
            closedByDefault = false
    )
    String SECTION_BASIC_SETTINGS = "basicSettings";
    final int offset = 5;
    String GROUP = "lingualConfig";
    @ConfigSection(
            name = "Dynamic translating",
            description = "Online translation options",
            position = 1 + offset,
            closedByDefault = false
    )
    String SECTION_CHAT_SETTINGS = "chatSettings";
    int offset_section2 = 20;
    @ConfigSection(
            name = "Game system text",
            description = "Options for game system texts",
            position = offset_section2,
            closedByDefault = false
    )
    String SECTION_GAME_SYSTEM_TEXT = "gameSystemText";
    final int offset_section3 = 40;
    @ConfigSection(
            name = "Others' Chat messages",
            description = "Options for chat messages",
            position = offset_section3,
            closedByDefault = false
    )
    String SECTION_CHAT_MESSAGES = "chatMessages";
    int offset_section4 = 60;
    @ConfigSection(
            name = "My Chat messages",
            description = "Options for chat messages",
            position = offset_section4,
            closedByDefault = false
    )
    String SECTION_MY_CHAT_MESSAGES = "myChatMessages";
    final int offset_section5 = 80;
    @ConfigSection(
            name = "Forceful Player Settings",
            description = "Options for specific players. This will take priority over other settings in this order",
            position = offset_section5,
            closedByDefault = false
    )
    String SECTION_SPECIFIC_PLAYER_SETTINGS = "specificPlayerSettings";

    final int offset_section6 = 100;
    @ConfigSection(
            name = "Debugging",
            description = "Settings for Debugging",
            position = offset_section6,
            closedByDefault = true
    )
    String SECTION_DEBUGGING = "debugging";

    @ConfigItem(
            name = "\uD83D\uDDE3\uD83D\uDCAC\uD83C\uDF10",
            description = "Select the language to be translated to",
            keyName = "targetLang",
            position = offset_section1,
            section = SECTION_BASIC_SETTINGS
    )
    default LangCodeSelectableList getSelectedLanguage() {
        return LangCodeSelectableList.ENGLISH;
    }

    @ConfigItem(
            name = "Help Link (right click to reset)",
            description = "right click to reset",
            position = 1 + offset_section1,
            keyName = "enableRuneLingual",
            section = SECTION_BASIC_SETTINGS
    )
    default String getHelpLink() {
        return helpLink;
    } // getHelpLink shouldnt be used anywhere, instead use helpLink

    @ConfigItem(
            name = "Enable Online Translation",
            description = "whether to translate using online services",
            section = SECTION_CHAT_SETTINGS,
            keyName = "enableAPI",
            position = 2 + offset
    )
    default boolean ApiConfig() {
        return false;
    }

    @ConfigItem(
            name = "Translating service",
            description = "Select your preferred translation service",
            section = SECTION_CHAT_SETTINGS,
            keyName = "translatingService",
            position = 3 + offset
    )
    default TranslatingServiceSelectableList getApiServiceConfig() {
        return TranslatingServiceSelectableList.DeepL;
    }

    @ConfigItem(
            name = "Service API Key",
            description = "Your API key for the chosen translating service",
            section = SECTION_CHAT_SETTINGS,
            keyName = "APIKey",
            position = 4 + offset,
            secret = true
            //hidden = true
    )
    default String getAPIKey() {
        return "";
    }

    @ConfigItem(
            name = "Enable Word Count Overlay",
            description = "whether to show how many characters you have used",
            section = SECTION_CHAT_SETTINGS,
            keyName = "enableUsageOverlay",
            position = 2 + offset
    )
    default boolean showUsageOverlayConfig() {
        return true;
    }

    @ConfigItem(
            name = "NPC Dialogue",
            description = "Option for NPC Dialogues",
            position = 1 + offset_section2,
            keyName = "npcDialogue",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getNpcDialogueConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Game Messages",
            description = "Option for game messages",
            position = 2 + offset_section2,
            keyName = "gameMessages",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getGameMessagesConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Item Names",
            description = "Option for item names",
            position = 4 + offset_section2,
            keyName = "itemNames",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getItemNamesConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "NPC Names",
            description = "Option for NPC names",
            position = 5 + offset_section2,
            keyName = "NPCNames",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getNPCNamesConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Object Names",
            description = "Option for object names",
            position = 6 + offset_section2,
            keyName = "objectNames",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getObjectNamesConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Interfaces",
            description = "Option for interface texts",
            position = 7 + offset_section2,
            keyName = "interfaceText",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getInterfaceTextConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    //not using this, makes configuration annoying
//	@ConfigItem(
//			name = "All Friends",
//			description = "Option that applies to all friends",
//			position = 2 + offset_section3,
//			keyName = "allFriends",
//			section = SECTION_CHAT_MESSAGES
//	)
//	default chatConfig getAllFriendsConfig() {return chatConfig.LEAVE_AS_IS;}

    @ConfigItem(
            name = "Mouse Menu Options",
            description = "Option for items, NPCs, objects, such as 'Use', 'Talk-to', etc.",
            position = 8 + offset_section2,
            keyName = "menuOption",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default ingameTranslationConfig getMenuOptionConfig() {
        return ingameTranslationConfig.USE_LOCAL_DATA;
    }

    @ConfigItem(
            name = "Enable Mouse Hover Text",
            description = "Option to toggle mouse hover texts",
            position = 9 + offset_section2,
            keyName = "overheadText",
            section = SECTION_GAME_SYSTEM_TEXT
    )
    default boolean getMouseHoverConfig() {
        return true;
    }

    @ConfigItem(
            name = "Public",
            description = "Option for public chat messages",
            position = 3 + offset_section3,
            keyName = "publicChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getPublicChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "Clan",
            description = "Option for clan chat messages",
            position = 4 + offset_section3,
            keyName = "clanChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getClanChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "Guest Clan",
            description = "Option for guest clan chat messages",
            position = 5 + offset_section3,
            keyName = "guestClanChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getGuestClanChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "Friends Chat",
            description = "Option for friends chat messages",
            position = 6 + offset_section3,
            keyName = "friendsChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getFriendsChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "GIM Group",
            description = "Option for GIM group chat messages",
            position = 7 + offset_section3,
            keyName = "GIMChat",
            section = SECTION_CHAT_MESSAGES
    )
    default chatConfig getGIMChatConfig() {
        return chatConfig.LEAVE_AS_IS;
    }

    @ConfigItem(
            name = "Me in Public",
            description = "Option for your own messages in Public chat",
            position = 1 + offset_section4,
            keyName = "myChatConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyPublicConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    @ConfigItem(
            name = "Me in Friends Chat",
            description = "Option for your own messages in Friends chat",
            position = 2 + offset_section4,
            keyName = "myFcConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyFcConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    @ConfigItem(
            name = "Me in Clan",
            description = "Option for your own messages in Clan chat",
            position = 3 + offset_section4,
            keyName = "myClanConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyClanConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    @ConfigItem(
            name = "Me in Guest Clan",
            description = "Option for your own messages in Guest Clan chat",
            position = 4 + offset_section4,
            keyName = "myGuestClanConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyGuestClanConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    @ConfigItem(
            name = "Me in GIM",
            description = "Option for your own messages in GIM chat",
            position = 5 + offset_section4,
            keyName = "myGimConfig",
            section = SECTION_MY_CHAT_MESSAGES
    )
    default chatSelfConfig getMyGIMConfig() {
        return chatSelfConfig.TRANSFORM;
    }

    String defaultText4ForcefulPlayerSettings = "enter player names here, separated by commas or new line";

    @ConfigItem(
            name = "Leave as is",
            description = "Specific players to not translate",
            position = 1 + offset_section5,
            keyName = "specificDontTranslate",
            section = SECTION_SPECIFIC_PLAYER_SETTINGS
    )
    default String getSpecificDontTranslate() {return defaultText4ForcefulPlayerSettings;}

    @ConfigItem(
            name = "Translate with APIs",
            description = "Specific players to translate using online translators",
            position = 2 + offset_section5,
            keyName = "specificApiTranslate",
            section = SECTION_SPECIFIC_PLAYER_SETTINGS
    )
    default String getSpecificApiTranslate() {
        return defaultText4ForcefulPlayerSettings;
    }

    @ConfigItem(
            name = "Transform",
            description = "Specific players to transform",
            position = 3 + offset_section5,
            keyName = "specificTransform",
            section = SECTION_SPECIFIC_PLAYER_SETTINGS
    )
    default String getSpecificTransform() {
        return defaultText4ForcefulPlayerSettings;
    }

    @ConfigItem(
            name = "Local file location",
            description = "Location of the files to be translated",
            keyName = "fileLocation",
            position = 1 + offset_section6,
            secret = true,
            section = SECTION_DEBUGGING
    )
    default String getFileLocation() {
        return RuneLite.RUNELITE_DIR.getPath() + File.separator + "RuneLingual_resources";
    }

    @ConfigItem(
            name = "Use Custom Data",
            description = "Use custom data for translations on github repository",
            keyName = "useCustomData",
            position = 2 + offset_section6,
            section = SECTION_DEBUGGING
    )
    default boolean useCustomData() {
        return false;
    }

    @ConfigItem(
            name = "Use Custom Data URL",
            description = "Change the user name part and public to draft if necessary. Do not include the language code. Right click 'reset' to get default url",
            keyName = "customDataUrl",
            position = 3 + offset_section6,
            section = SECTION_DEBUGGING
    )
    default String getCustomDataUrl() {
        return "https://raw.githubusercontent.com/YS-jack/Runelingual-Transcripts/original-main/public/";
    }
    enum ingameTranslationConfig {
        USE_LOCAL_DATA,
        USE_API,
        //TRANSLITERATE, // not for now, need to prepare transliteration data for all languages
        DONT_TRANSLATE,
    }

    enum chatConfig {
        TRANSFORM, //eg: watasi ha inu ga suki -> 私は犬が好き
        USE_API, // eg: I like dogs -> 私は犬が好き
        LEAVE_AS_IS, // eg: I like dogs -> I like dogs
    }


    enum chatSelfConfig {
        TRANSFORM,
        LEAVE_AS_IS,
    }

}

package com.RuneLingual.ApiTranslate;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;
import java.awt.*;


public class DeeplUsageOverlay  extends Overlay {
    private Client client;
    private RuneLingualConfig config;
    private RuneLingualPlugin plugin;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    public DeeplUsageOverlay(Client client, RuneLingualPlugin plugin, RuneLingualConfig config) {
        setPosition(OverlayPosition.BOTTOM_RIGHT);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }
    /**
    * overlay for the number count by the DeepL API.
     * will show the number of characters translated by the DeepL API and the limit of the API.
     * if the API key is invalid, it will show a warning message.
     */
    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.showUsageOverlayConfig())
            return null;

        int enCharSize = LangCodeSelectableList.ENGLISH.getCharWidth();
        int foreignCharSize = config.getSelectedLanguage().getCharWidth();
        boolean deeplKeyValid = plugin.getDeepl().isKeyValid();
        String deeplCount = Long.toString(plugin.getDeepl().getDeeplCount());
        String deeplLimit = Long.toString(plugin.getDeepl().getDeeplLimit());

        Color bgColorCount = new Color(80, 148, 144);
        Color bgColorInvalid = new Color(194, 93, 93);
        panelComponent.getChildren().clear();
        int len;
        if (deeplKeyValid) {
            panelComponent.setBackgroundColor(bgColorCount);
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("DeepL:")
                    .right(deeplCount + " / " + deeplLimit)
                    .build());
            len = (deeplLimit.length()*2+10)*enCharSize;
        } else {
            String errorMessage = LangCodeSelectableList.getAPIErrorMessage(config.getSelectedLanguage());
            panelComponent.setBackgroundColor(bgColorInvalid);
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(errorMessage)
                    .build());
            len = (getMaxLetters(errorMessage.split("\n"))+2)*foreignCharSize;
        }
        panelComponent.setPreferredSize(new Dimension(len,0));
        return panelComponent.render(graphics);
    }

    public static int getMaxLetters(String[] strings) {
        int maxLength = 0;
        for (String str : strings) {
            if (str != null) {
                maxLength = Math.max(maxLength, str.length());
            }
        }
        return maxLength;
    }
}

package com.RuneLingual.ApiTranslate;

import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.commonFunctions.FileActions;
import com.RuneLingual.commonFunctions.FileNameAndPath;
import com.RuneLingual.commonFunctions.Transformer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuEntry;

import javax.inject.Inject;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class PastTranslationManager {
    private final String pastTranslationFile;
    @Inject
    private Deepl deepl;
    private RuneLingualPlugin plugin;
    private Map<String, String> pastTranslations = new ConcurrentHashMap<>();
    @Getter
    private Set<String> translationResults = new HashSet<>();


    @Inject
    public PastTranslationManager(Deepl deepl, RuneLingualPlugin plugin) {
        this.plugin = plugin;
        this.deepl = deepl;
        pastTranslationFile = FileNameAndPath.getLocalBaseFolder().getPath() + File.separator +
                plugin.getConfig().getSelectedLanguage().getLangCode() + File.separator + "pastTranslations.txt";
        setPastTranslationsFromFile();
    }

    public void setPastTranslationsFromFile() {
        // if pastTranslationFile exists, read from it
        if (FileActions.fileExists(pastTranslationFile)) {
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(
                    new FileInputStream(pastTranslationFile), StandardCharsets.UTF_8))) {
                // Skip BOM if present
                reader.mark(1);
                if (reader.read() != 0xFEFF) {
                    reader.reset();
                }

                String line;
                while ((line = reader.readLine()) != null) {
                    String[] parts = line.split("\\|");
                    if (parts.length == 2) {
                        String key = parts[0].trim();
                        String value = parts[1].trim();
                        pastTranslations.put(key, value);
                        translationResults.add(value);
                    }
                }

            } catch (IOException e) {
                log.error("Error reading file: " + e.getMessage(), e);
            }
        } else {
            // Ensure the directory exists
            try {
                Files.createDirectories(Paths.get(pastTranslationFile).getParent());
            } catch (IOException e) {
                log.error("Error creating directories: " + e.getMessage(), e);
                return; // Exit the method if we can't create the directory
            }
            try {
                Path filePath = Paths.get(pastTranslationFile);
                Files.createDirectories(filePath.getParent());
                Files.createFile(Paths.get(pastTranslationFile));
            } catch (FileAlreadyExistsException e) {
                log.info("File already exists: " + pastTranslationFile);
            } catch (NoSuchFileException e) {
                log.error("Unable to create file, directory doesn't exist: " + e.getMessage(), e);
            } catch (AccessDeniedException e) {
                log.error("Permission denied when creating file: " + e.getMessage(), e);
            } catch (IOException e) {
                log.error("Error creating file: " + e.getMessage(), e);
            }

        }
    }

    /**
     * Get past translation from hashmap
     *
     * @param text the text to get past translation for
     * @return the past translation if it exists, null otherwise
     */
    public String getPastTranslation(String text) {
        // first check that the text is not a result of translation
        if (translationResults.contains(text) || text.isEmpty() || text.isBlank()) {
            return text;
        }
        // if its not a result of translation, check the past translation map
        String translation = pastTranslations.getOrDefault(text, null);
        if (translation != null) {
            translation = Transformer.unifySimilarChars(translation);
            return translation;
        }

        /////////////////////////////////////////////////
        // text may have been transformed into generic text (enColVal, where color tags are tunred to <colNum#> and numbers are turned to <valNum#>)
        String genericText = Transformer.getEnglishColValFromText(text);
        // check that the text is not a result of translation
        if (translationResults.contains(genericText)) {
            return text;
        }
        // if its not a result of translation, check the past translation map
        translation = pastTranslations.getOrDefault(text, null);
        if (translation != null) {
            translation = Transformer.unifySimilarChars(translation);
            return translation;
        }

        ////////////////////////////////////////////////
        // texts with just 1 color tag may have had their color tags removed
        String textWithColorTagRemoved = Colors.removeNonImgTags(text);
        Colors colTag = Colors.getColorArray(text, Colors.white)[0];
        if (colTag == null) {
            return null;
        }
        // check that the text is not a result of translation
        if (translationResults.contains(textWithColorTagRemoved)) {
            return text;
        }
        // if its not a result of translation, check the past translation map
        translation = pastTranslations.getOrDefault(textWithColorTagRemoved, null);
        if (translation != null) {
            translation = Transformer.unifySimilarChars(translation);
            return colTag.getColorTag() + translation;
        }
        return null;
    }

    public void addToPastTranslations(String text, String translation) {
        // add to the map
        pastTranslations.put(text, translation);
        // add to the set of translation results
        translationResults.add(translation);

        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(
                new FileOutputStream(pastTranslationFile, true), StandardCharsets.UTF_8))) {
            String content = text + "|" + translation + "\n";
            writer.write(content);
            writer.flush(); // Ensure the content is written immediately
        } catch (IOException e) {
            log.error("Error writing to file: " + e.getMessage(), e);
        }
    }

    public boolean haveTranslatedMenuBefore(String option, String target, MenuEntry menuEntry) {
        String[] optionWordArray = Colors.getWordArray(option);
        String[] targetWordArray = Colors.getWordArray(target);

        // if option is set to be translated with API, check if all elements have been translated before
        if (plugin.getConfig().getMenuOptionConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)) {
            if (check4PendingElementInPastTranslation(optionWordArray)) {
                return false;
            }
        }

        // if target is item name and that is set to be translated with API,
        // check if all elements have been translated before
        if (plugin.getConfig().getItemNamesConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)
                && (plugin.getMenuCapture().isItemInWidget(menuEntry) || plugin.getMenuCapture().isItemOnGround(menuEntry.getType()))) {
            if (check4PendingElementInPastTranslation(targetWordArray)) {
                return false;
            }
        }

        // if target is object name, check if all elements have been translated before
        if (plugin.getConfig().getObjectNamesConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)
                && plugin.getMenuCapture().isObjectMenu(menuEntry.getType())) {
            if (check4PendingElementInPastTranslation(targetWordArray)) {
                return false;
            }
        }

        // if target is npc name, check if all elements have been translated before
        if (plugin.getConfig().getNPCNamesConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)
                && plugin.getMenuCapture().isNpcMenu(menuEntry.getType())) {
            if (check4PendingElementInPastTranslation(targetWordArray)) {
                return false;
            }
        }


        // if other target (general menu, walk here, player, etc) is set to be translated with API,
        // check if all elements have been translated before
        if (!target.isEmpty() &&
                plugin.getConfig().getMenuOptionConfig().equals(RuneLingualConfig.ingameTranslationConfig.USE_API)
                && !plugin.getMenuCapture().isItemInWidget(menuEntry)
                && !plugin.getMenuCapture().isItemOnGround(menuEntry.getType())
                && !plugin.getMenuCapture().isObjectMenu(menuEntry.getType())
                && !plugin.getMenuCapture().isNpcMenu(menuEntry.getType())) {
            if (check4PendingElementInPastTranslation(targetWordArray)) {
                return false;
            }
        }

        return true;
    }

    private boolean check4PendingElementInPastTranslation(String[] wordArray) {
        for (String word : wordArray) {
            if (plugin.getDeepl().getDeeplPastTranslationManager().getPastTranslation(word) == null) {
                return true;
            }
        }
        return false;
    }

    public boolean haveTranslatedBefore(String text) {
        return pastTranslations.containsKey(text) || translationResults.contains(text)
                || pastTranslations.containsKey(Transformer.getEnglishColValFromText(text))
                || translationResults.contains(Transformer.getEnglishColValFromText(text))
                || pastTranslations.containsKey(Colors.removeNonImgTags(text))
                || translationResults.contains(Colors.removeNonImgTags(text));
    }
}

package com.RuneLingual.ApiTranslate;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualConfig;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.TranslatingServiceSelectableList;
import com.RuneLingual.commonFunctions.Colors;
import com.RuneLingual.nonLatin.GeneralFunctions;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.*;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;

@Slf4j
public class Deepl {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    private RuneLingualConfig config;
    @Inject
    private OkHttpClient httpClient;
    private String deeplKey;
    @Getter @Setter
    private int deeplLimit = 500000;
    @Getter @Setter
    private int deeplCount = deeplLimit;
    @Getter @Setter
    private boolean keyValid = true;

    @Getter @Setter
    private PastTranslationManager deeplPastTranslationManager;
    private static final MediaType mediaType = MediaType.parse("Content-Type: application/json");

    private ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    private final Object apiStateLock = new Object();
    private volatile int apiStateVersion = 0; // Tracks the current state version of the API

    // add texts that has already been attempted to be translated.
    // this avoids translating same texts multiple times when ran in a thread, which will waste limited or paid word count
    @Getter
    private List<String> translationAttempt = new ArrayList<>();

    @Inject
    public Deepl(RuneLingualPlugin plugin, OkHttpClient httpClient) {
        this.plugin = plugin;
        this.config = plugin.getConfig();
        this.httpClient = httpClient;
        //setUsageAndLimit();
        deeplKey = plugin.getConfig().getAPIKey();
        deeplPastTranslationManager = new PastTranslationManager(this, plugin);
    }

    /**
     * Translates the given text from the source language to the target language.
     * Sets deeplCount the number of characters translated using the API
     *
     * @param text the text to be translated
     * @param sourceLang the source language
     * @param targetLang the target language
     * @return the translated text if translated in the past, the original text if the translation fails or trying to translate
     */
    public String translate(String text, LangCodeSelectableList sourceLang, LangCodeSelectableList targetLang) {
        if(!plugin.getConfig().ApiConfig()){
            return text;
        }
        // if the text is already translated, return the past translation
        String pastTranslation = deeplPastTranslationManager.getPastTranslation(text);
        if (pastTranslation != null) {
            return pastTranslation;
        }

        // don't translate if text is empty, or has been attempted to translate, or is a result of translation
        if (text.isEmpty() || translationAttempt.contains(text) || deeplPastTranslationManager.getTranslationResults().contains(text)) {
            return text;
        }
        deeplKey = plugin.getConfig().getAPIKey();

        setUsageAndLimit();
        //if the character count is close to the limit, return the original text
        if(deeplCount > deeplLimit - text.length() - 1000){
            return text;
        }

        // from here, attempt to translate the text
        translationAttempt.add(text);


        String url = getTranslatorUrl();
        if(url.isEmpty()){// if selected service is not deepl, return as is
            return text;
        }

        JsonObject urlParameters = getUrlParameters(sourceLang, targetLang, text);

        getResponse(url, FormBody.create(mediaType, urlParameters.toString()), new ResponseCallback() {
            @Override
            public void onSuccess(String response) {
                setUsageAndLimit();
                String translation = getTranslationInResponse(response);
                if (!translation.isEmpty()) {
                    // add the new translation to the past translations and its file
                    deeplPastTranslationManager.addToPastTranslations(text, translation);
                    setKeyValid(true);
                    translationAttempt.remove(text);
                }

            }

            @Override
            public void onFailure(Exception error) {
                setKeyValid(false);
                handleError(error);
            }

            @Override
            public void onApiOff() {
                translationAttempt.remove(text);
            }
        });

        return text; // return original text while the translation is being processed in the thread
    }

    private JsonObject getUrlParameters(LangCodeSelectableList sourceLang, LangCodeSelectableList targetLang, String text) {
        String targetLangCode = targetLang.getDeeplLangCodeTarget();
        JsonArray jsonArray = new JsonArray();
        jsonArray.add(text);

        JsonObject jsonObject = new JsonObject();
        jsonObject.add("text", jsonArray);
        jsonObject.addProperty("target_lang", targetLangCode);
        jsonObject.addProperty("context", "runescape; dungeons and dragons; medieval fantasy;");
        jsonObject.addProperty("split_sentences", "nonewlines");
        jsonObject.addProperty("preserve_formatting", true);
        jsonObject.addProperty("formality", "prefer_less");
        jsonObject.addProperty("source_lang", "EN");

        return jsonObject;
    }

    private String getTranslatorUrl() {
        String baseUrl = getBaseUrl();
        if(baseUrl.isEmpty()){
            return "";
        }
        return baseUrl + "translate";
    }

    private String getUsageUrl() {
        String baseUrl = getBaseUrl();
        if(baseUrl.isEmpty()){
            return "";
        }
        return baseUrl + "usage";
    }

    private String getBaseUrl() {
        if (Objects.equals(config.getApiServiceConfig().getServiceName(), TranslatingServiceSelectableList.DeepL.getServiceName())) {
            return "https://api-free.deepl.com/v2/";
        } else if (Objects.equals(config.getApiServiceConfig().getServiceName(), TranslatingServiceSelectableList.DeepL_PRO.getServiceName())) {
            return "https://api.deepl.com/v2/";
        } else {
            return "";
        }
    }

    private void getResponse(String url, RequestBody requestBody, ResponseCallback callback) {
        getResponseWithRetry(url, requestBody, callback, 0);
    }

    private void getResponseWithRetry(String url, RequestBody requestBody, ResponseCallback callback, int retryCount) {
        final int currentVersion;
        synchronized (apiStateLock) {
            currentVersion = apiStateVersion; // Capture the current version
        }

        if (!plugin.getConfig().ApiConfig()) {
            callback.onApiOff();
            return;
        }

        if (deeplKey == null || deeplKey.isEmpty()) {
            callback.onFailure(new IOException("API key is missing"));
            return;
        }

        try {
            Request.Builder request = new Request.Builder()
                    .addHeader("User-Agent", RuneLite.USER_AGENT + " (runelingual)")
                    .addHeader("Authorization", "DeepL-Auth-Key " + deeplKey)
                    .addHeader("Accept", "application/json")
                    .addHeader("Content-Type", "application/json")
                    .addHeader("Content-Length", String.valueOf(requestBody.contentLength()))
                    .url(url)
                    .post(requestBody);

            httpClient.newCall(request.build()).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException error) {
                    synchronized (apiStateLock) {
                        if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                            //log.info("Discarding outdated failure callback due to API state change.");
                            return;
                        }
                    }
                    if (retryCount < 5) {
                        int delay = new Random().nextInt(8) + 3;
                        synchronized (apiStateLock) {
                            if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                                //log.info("Discarding outdated retry scheduling due to API state change.");
                                return;
                            }
                        }
                        //log.info("on failure: Retrying API request in {} seconds (attempt {})", delay, retryCount + 1);
                        scheduler.schedule(() -> {
                            synchronized (apiStateLock) {
                                if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                                    //log.info("Discarding outdated retry execution due to API state change.");
                                    return;
                                }
                            }
                            getResponseWithRetry(url, requestBody, callback, retryCount + 1);
                        }, delay, TimeUnit.SECONDS);
                    } else {
                        callback.onFailure(error);
                    }
                }

                @Override
                public void onResponse(Call call, Response response) {
                    synchronized (apiStateLock) {
                        if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                            //log.info("Discarding outdated response callback due to API state change.");
                            return;
                        }
                    }
                    try (ResponseBody responseBody = response.body()) {
                        if (responseBody != null) {
                            String responseBodyString = responseBody.string();
                            if (response.code() == 429) { // Too Many Requests
                                if (retryCount < 5) {
                                    int delay = new Random().nextInt(8) + 3;
                                    synchronized (apiStateLock) {
                                        if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                                            //log.info("Discarding outdated retry scheduling due to API state change.");
                                            return;
                                        }
                                    }
                                    //log.info("on response: Retrying API request in {} seconds (attempt {})", delay, retryCount + 1);
                                    scheduler.schedule(() -> {
                                        synchronized (apiStateLock) {
                                            if (currentVersion != apiStateVersion || !plugin.getConfig().ApiConfig()) {
                                                //log.info("Discarding outdated retry execution due to API state change.");
                                                return;
                                            }
                                        }
                                        getResponseWithRetry(url, requestBody, callback, retryCount + 1);
                                    }, delay, TimeUnit.SECONDS);
                                } else {
                                    callback.onFailure(new IOException("Too many requests"));
                                }
                            } else {
                                callback.onSuccess(responseBodyString);
                            }
                        } else {
                            callback.onFailure(new IOException("Response body is null"));
                        }
                    } catch (Exception error) {
                        callback.onFailure(error);
                    }
                }
            });
        } catch (Exception error) {
            log.error("Failed to create the API request", error);
            callback.onFailure(error);
        }
    }

    private void handleError(Exception error) {
        log.error("Failed to get response from DeepL API.", error);
    }


    public interface ResponseCallback {
        void onSuccess(String response);
        void onFailure(Exception error);
        void onApiOff();
    }

    private String getTranslationInResponse(String response) {
        JSONObject jsonObject = new JSONObject(response);
        if (jsonObject.has("translations")) {
            JSONArray translationsArray = jsonObject.getJSONArray("translations");
            if (translationsArray != null && translationsArray.length() > 0) { // .length() > 0 is used instead of ! .isEmpty() because .isEmpty on JsonObject doesnt work on the runelite client for some reason
                JSONObject translationObject = translationsArray.getJSONObject(0);
                return translationObject.getString("text");
            }
        }
        return "";
    }

    // function to set usage of the API
    public void setUsageAndLimit() {
        getResponse(getUsageUrl(), FormBody.create(mediaType, ""), new ResponseCallback() {
            @Override
            public void onSuccess(String usage) {
                if (usage.isEmpty()) {
                    log.error("API response is empty.");
                    return;
                }
                try {
                    JSONObject jsonObject = new JSONObject(usage);
                    if (jsonObject.has("character_count") && jsonObject.has("character_limit")) {
                        keyValid = true;
                        deeplCount = jsonObject.getInt("character_count");
                        deeplLimit = jsonObject.getInt("character_limit");
                        //log.info("Updated deepl count: " + deeplCount + "\nUpdated deepl limit: " + deeplLimit);
                    } else {
                        keyValid = false;
                        log.error("Required keys not found in API response: " + usage);
                    }
                } catch (JSONException e) {
                    keyValid = false;
                    log.error("Failed to parse API response: " + usage, e);
                }
            }

            @Override
            public void onFailure(Exception error) {
                handleError(error);
            }

            @Override
            public void onApiOff() {
                //log.info("API is disabled");
            }
        });
    }
}

package com.RuneLingual.commonFunctions;

import java.io.File;
import java.io.IOException;
import java.util.List;

import com.RuneLingual.LangCodeSelectableList;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class FileActions {
    /*
    mainly for managing the file whose name includes the current selected language

    getLangCodeFromFile() - get the language code from the file name
    createLangCodeNamedFile() - create a file with the language code in the name
    deleteAllLangCodeNamedFile() - delete all files with the language code in the name

    these 3 functions should be used to manage the language named files.
     */
    static String fileNameStart = "setLang_";
    static String langNameFolder = FileNameAndPath.getLocalBaseFolder().toString();

    public static LangCodeSelectableList getLangCodeFromFile() {
        String existingFileName = getFileNameInFolderStartsWith(langNameFolder, fileNameStart);
        if (existingFileName != null){
            String langCode = existingFileName.substring(existingFileName.indexOf("_") + 1, existingFileName.indexOf("."));
            for (LangCodeSelectableList lang : LangCodeSelectableList.values()) {
                if (lang.getLangCode().equals(langCode)) {
                    return lang;
                }
            }
        }
        return LangCodeSelectableList.ENGLISH;
    }

    public static void createLangCodeNamedFile(LangCodeSelectableList lang) {
        String fileName = langNameFolder + File.separator + fileNameStart + lang.getLangCode() + ".txt";
        createFile(fileName);
    }

    public static void deleteAllLangCodeNamedFile() {
        for (LangCodeSelectableList lang : LangCodeSelectableList.values()) {
            String fileName = langNameFolder + File.separator + fileNameStart + lang.getLangCode() + ".txt";
            deleteFile(fileName);
        }
    }



    public static void createFile(String fileName) {
        try {
            File myObj = new File(fileName);
            if (myObj.createNewFile()) {
                log.info("File created: " + myObj.getName());
            } else {
                log.info("File already exists.");
            }
        } catch (IOException e) {
            log.error("error creating file", e);
        }
    }

    public static String getFileNameInFolderStartsWith(String path, String fileName) {
        File folder = new File(path);
        File[] listOfFiles = folder.listFiles();
        if (listOfFiles == null) {
            return null;
        }
        for (File file : listOfFiles) {
            if (file.isFile()) {
                if (file.getName().startsWith(fileName)) {
                    return file.getName();
                }
            }
        }
        return null;
    }

    public static String getHashFile(LangCodeSelectableList lang) {
        return FileNameAndPath.getLocalBaseFolder() + File.separator +
                lang.getLangCode() + File.separator + "hashListLocal_" + lang.getLangCode() + ".txt";
    }

    public static List<String> getFileNamesWithExtension(String path, String extension){
        File folder = new File(path);
        File[] listOfFiles = folder.listFiles();
        List<String> matchedFileNames = null;
        for (File file : listOfFiles) {
            if (file.isFile()) {
                if (file.getName().endsWith(extension)) {
                    matchedFileNames.add(file.getName());
                }
            }
        }
        return matchedFileNames;
    }

    public static void deleteFile(String fileName) {
        File myObj = new File(fileName);
        if (myObj.delete()) {
            log.info("Deleted the file: " + myObj.getName());
        } else {
            log.info("Failed to delete the file.");
        }
    }

    public static boolean fileExists(String filename) {
        File myObj = new File(filename);
        return myObj.exists();
    }

    public static void deleteFolder(String folderPath) {
        File folder = new File(folderPath);
        File[] listOfFiles = folder.listFiles();
        if (listOfFiles != null) {
            for (File file : listOfFiles) {
                if (file.isFile()) {
                    file.delete();
                }
            }
        }
        folder.delete();
    }
}

package com.RuneLingual.commonFunctions;

import com.RuneLingual.LangCodeSelectableList;
import com.RuneLingual.RuneLingualPlugin;
import com.RuneLingual.debug.OutputToFile;
import com.RuneLingual.nonLatin.GeneralFunctions;
import com.RuneLingual.SQL.SqlVariables;
import com.RuneLingual.SQL.SqlQuery;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.util.List;

import static com.RuneLingual.Widgets.PartialTranslationManager.protectPlaceholderTags;

@Slf4j
public class Transformer {
    @Inject
    private RuneLingualPlugin plugin;
    private boolean outputUnknownToFile = true;
    @Inject
    private OutputToFile outputToFile;


    public enum TransformOption {
        AS_IS,
        TRANSLATE_LOCAL,
        TRANSLATE_API,
        TRANSLITERATE,
        TRANSFORM, // such as from alphabet to kanji, like neko -> 猫
    }

    @Inject
    public Transformer(RuneLingualPlugin plugin){
        this.plugin = plugin;
    }


    public String transformEngWithColor(TransformOption option, SqlQuery sqlQuery, boolean searchAlike){
        boolean needCharImage = plugin.getConfig().getSelectedLanguage().needsCharImages();
        GeneralFunctions generalFunctions = plugin.getGeneralFunctions();
        String text = sqlQuery.getEnglish();
        if(text == null || text.isEmpty()){
            plugin.getFailedTranslations().add(sqlQuery);
            return textAddColor(text, sqlQuery.getColor());
        }
        if (option == TransformOption.TRANSLATE_LOCAL && !plugin.getConfig().getSelectedLanguage().hasLocalTranscript()){
            return textAddColor(text, sqlQuery.getColor());
        }

        String translatedText = "";

        if(option == TransformOption.AS_IS){
            translatedText = text;
        } else if(option == TransformOption.TRANSLATE_LOCAL){
        /*
        if there are 2 or more color tags in the sqlQuery.english, english and translation in the database will have color tag placeholders.
        must replace the color tags in sqlQuery.english with the color tag placeholders,
        and do the reverse for the obtained translation

        e.g.
        sqlQuery.english: <col=ff>text1<col=0>text2
        english in database: <colNum1>text1<colNum2>text2
        translation in database: <colNum2>translatedText2<colNum1>translatedText1
        final translation: <col=0>translatedText2<col=ff>translatedText1
         */
            List<String> colorTagsAsIs = Colors.getColorTagsAsIs(sqlQuery.getEnglish());
//            int trueColorTagCount = Colors.countColorTagsAfterReformat(sqlQuery.getEnglish());
//            for(int i = 0; i < colorTagsAsIs.size(); i++){
//                sqlQuery.setEnglish(sqlQuery.getEnglish().replace(colorTagsAsIs.get(i), "<colNum" + i + ">")); // replace color tags with placeholders
//            }
            sqlQuery.setEnglish(Colors.getEnumeratedColorWord(sqlQuery.getEnglish())); // replace color tags with placeholders
            // if translating failed for this query before, return the original text with color
            if (plugin.getFailedTranslations().contains(sqlQuery)) {
                return sqlQuery.getEnglish();
            }

            String[] result = sqlQuery.getMatching(SqlVariables.columnTranslation, searchAlike);
            if(result.length == 0){
                log.info("(engWithColor) No translation found for " + text + " ");
                log.info("query = " + sqlQuery.getSearchQuery());
                plugin.getFailedTranslations().add(sqlQuery);
                outputUnknown(sqlQuery);
                return textAddColor(text, sqlQuery.getColor());
                //translatedText = text;
            } else {
                if(result[0].isEmpty()) { // text exists in database but hasn't been translated yet
                    //translatedText = text;
                    log.info("{} has not been translated yet (engWithColor)", text);
                    plugin.getFailedTranslations().add(sqlQuery);
                    outputUnknown(sqlQuery);
                    return textAddColor(text, sqlQuery.getColor());
                } else { // text has been translated
                    translatedText = unifySimilarChars(result[0]); // convert full width characters to half width
                    translatedText = Colors.getOriginalColorWord(translatedText, colorTagsAsIs); // replace placeholders with original color tags
//                    for(int i = 0; i < colorTagsAsIs.size(); i++){
//                        translatedText = translatedText.replace("<colNum" + i + ">", colorTagsAsIs.get(i)); // replace placeholders with original color tags
//                    }
                }
            }
            //translatedText = this.plugin.getTranscriptActions().getTranslation(text);
        } else if(option == TransformOption.TRANSLATE_API){ // wont have any colors
            translatedText = this.plugin.getDeepl().translate(Colors.removeAllTags(text),
                    LangCodeSelectableList.ENGLISH ,this.plugin.getConfig().getSelectedLanguage());
            if(translatedText.equals(text)){
                // if using api but the translation is the same as the original text, it's pending for translation
                return text;
            }
        } else if(option == TransformOption.TRANSLITERATE){
            //return
        }

        if(needCharImage) {
            // needs char image and has multiple colors
            String[] words = Colors.getWordArray(translatedText);
            Colors[] colorsArray = Colors.getColorArray(translatedText, sqlQuery.getColor());
            StringBuilder charImage = new StringBuilder();
            //log.info("words length = " + words.length + ", colorsArray length =" + colorsArray.length);
            for(int i = 0; i < words.length; i++){
                //log.info("words[" + i + "] = " + words[i] + ", colorsArray[" + i + "] = " + colorsArray[i]);
                charImage.append(generalFunctions.StringToTags(words[i], colorsArray[i]));
            }
            return charImage.toString();
        } else {// doesnt need char image and already has color tags
            return translatedText;
        }
    }

    /*
        * transform text with placeholders to translated text
        * example: transformWithPlaceholders("Sand <col=ff>Crab</col> (level-15)", "Sand <colNum0>Crab</col> (level-<Num0>)", TransformOption.TRANSLATE_LOCAL, sqlQuery)
        * matching translation will be "サンド <colNum0>クラブ</col> (レベル<Num0>)"
        * return value will be "サンド <col=ff>クラブ</col> (レベル15)"
     */
    public String transformWithPlaceholders(String originalText, String textWithPlaceholders,TransformOption option , SqlQuery sqlQuery){
        if(textWithPlaceholders == null || textWithPlaceholders.isEmpty()){
            plugin.getFailedTranslations().add(sqlQuery);
            return textWithPlaceholders;
        }
        if (option == TransformOption.TRANSLATE_LOCAL && !plugin.getConfig().getSelectedLanguage().hasLocalTranscript()){
            return textAddColor(originalText, sqlQuery.getColor());
        }

        String translatedText = "";

        if(option == TransformOption.AS_IS){
            return textWithPlaceholders;
        } else if(option == TransformOption.TRANSLATE_LOCAL){
            sqlQuery.setEnglish(textWithPlaceholders);
            // if translating failed for this query before, return the original text with color
            if (plugin.getFailedTranslations().contains(sqlQuery)) {
                return originalText;
            }

            String[] result = sqlQuery.getMatching(SqlVariables.columnTranslation, false);
            if(result.length == 0){
                log.info("(withPlaceholders func) the following placeholder text doesn't exist in the English column :{}", textWithPlaceholders);
                log.info("   query = {}", sqlQuery.getSearchQuery());
                outputUnknown(sqlQuery);
                // translatedText = text;
                plugin.getFailedTranslations().add(sqlQuery);
                return null;
            } else {
                if(result[0].isEmpty()) { // text exists in database but hasn't been translated yet
                    //translatedText = text;
                    log.info("{} has not been translated yet (withPlaceholders func)", textWithPlaceholders);
                    outputUnknown(sqlQuery);
                    plugin.getFailedTranslations().add(sqlQuery);
                    return null;

                } else { // text has been translated
                    translatedText = unifySimilarChars(result[0]); // convert full width characters to half width
                    translatedText = protectPlaceholderTags(translatedText); // protect placeholder tags like <!monster> from being turned into char images
                }
            }
            //translatedText = this.plugin.getTranscriptActions().getTranslation(text);
        } else if(option == TransformOption.TRANSLATE_API){
            translatedText = this.plugin.getDeepl().translate(textWithPlaceholders,
                    LangCodeSelectableList.ENGLISH ,this.plugin.getConfig().getSelectedLanguage());
        } else if(option == TransformOption.TRANSLITERATE){
            //return
        }
        List<String> colorTags = Colors.getColorTagsAsIs(originalText);
        translatedText = Colors.getOriginalColorWord(translatedText, colorTags); // replace placeholders of color tags with original color tags
        translatedText = SqlQuery.replacePlaceholdersWithNumbers(originalText, translatedText); // replace placeholders of numbers with original numbers
        translatedText = translatedText.replace("<br>", "<asis><br></asis>"); // keep <br> tags
        translatedText = translatedText.replace("<autoBr>", "<asis><autoBr></asis>"); // keep <autoBr> tags
        translatedText = translatedText.replace("</autoBr>", "<asis></autoBr></asis>");
        // convert to displayed string
        boolean needCharImage = plugin.getConfig().getSelectedLanguage().needsCharImages();
        GeneralFunctions generalFunctions = plugin.getGeneralFunctions();
        if(needCharImage) {
            // needs char image and could have multiple colors
            String[] words = Colors.getWordArray(translatedText);
            Colors[] colorsArray = Colors.getColorArray(translatedText, sqlQuery.getColor());
            if(colorsArray.length==0){
                colorsArray = new Colors[words.length];
                for(int i = 0; i < words.length; i++){
                    colorsArray[i] = sqlQuery.getColor();
                }
            }
            StringBuilder charImage = new StringBuilder();
            //log.info("words length = " + words.length + ", colorsArray length =" + colorsArray.length);
            for(int i = 0; i < words.length; i++){
                //log.info("words[" + i + "] = " + words[i] + ", colorsArray[" + i + "] = " + colorsArray[i]);
                charImage.append(generalFunctions.StringToTags(words[i], colorsArray[i]));
            }
            return charImage.toString();
        } else {// doesnt need char image and already has color tags
            return translatedText;
        }
    }

    public String transform(String text, Colors colors, TransformOption option, SqlQuery sqlQuery, boolean searchAlike){
        if(text == null || text.isEmpty()){
            plugin.getFailedTranslations().add(sqlQuery);
            return textAddColor(text, colors);
        }
        if (option == TransformOption.TRANSLATE_LOCAL && !plugin.getConfig().getSelectedLanguage().hasLocalTranscript()){
            return textAddColor(text, colors);
        }
        String translatedText = "";

        if(option == TransformOption.AS_IS){
            return textAddColor(text, colors);
        } else if(option == TransformOption.TRANSLATE_LOCAL){
            sqlQuery.setEnglish(text);
            // if translating failed for this query before, return the original text with color
            if (plugin.getFailedTranslations().contains(sqlQuery)) {
                return textAddColor(text, colors);
            }

            String[] result = sqlQuery.getMatching(SqlVariables.columnTranslation, searchAlike);
            if(result.length == 0){
                log.info("(transform func) the following text doesn't exist in the English column :{}", text);
                log.info("   query = {}", sqlQuery.getSearchQuery());
                // translatedText = text;
                plugin.getFailedTranslations().add(sqlQuery);
                outputUnknown(sqlQuery);
                return textAddColor(text, colors);
            } else {
                for (String s : result) {
                    if(!s.isEmpty()) {
                        translatedText = unifySimilarChars(s); // convert full width characters to half width
                        break;
                    }
                }
                if(translatedText.isEmpty()) { // text exists in database but hasn't been translated yet
                    //translatedText = text;
                    log.info("{} has not been translated yet (transform func)", text);
                    log.info("   query = {}", sqlQuery.getSearchQuery());
                    plugin.getFailedTranslations().add(sqlQuery);
                    outputUnknown(sqlQuery);
                    return textAddColor(text, colors);
                }
            }
            //translatedText = this.plugin.getTranscriptActions().getTranslation(text);
        } else if(option == TransformOption.TRANSLATE_API){
            translatedText = this.plugin.getDeepl().translate(text,
                    LangCodeSelectableList.ENGLISH ,this.plugin.getConfig().getSelectedLanguage());
            if(!this.plugin.getDeepl().getDeeplPastTranslationManager().getTranslationResults().contains(translatedText)){
                // if using api and the returned text is not a translated text, it's pending for translation
                return Colors.surroundWithColorTag(text,colors);
            }
        }
        return stringToDisplayedString(translatedText, colors);
    }

    /*
     * general idea:
     * 1. split into string array [name, level] and color array [color of name, color of level]
     * 2. translate name and level
     *    - if target language needs char image, after translating the string, use color and string to get char image
     *    - else translate the string, then combine each string with its color
     * 3. recombine into string
     */
    public String transform(String[] texts, Colors[] colors, TransformOption option, SqlQuery sqlQuery, boolean searchAlike){
        if(Colors.countColorTagsAfterReformat(sqlQuery.getEnglish()) > 1 && option != TransformOption.TRANSLATE_API){
            return transformEngWithColor(option, sqlQuery, searchAlike);
        }
        StringBuilder transformedTexts = new StringBuilder();
        for(int i = 0; i < texts.length; i++){
            if (isMembersItemInF2P(texts[i], sqlQuery) && option == TransformOption.TRANSLATE_LOCAL) {
                transformedTexts.append(translateMembersItemInF2P(texts[i], colors[i], sqlQuery));
            } else {
                transformedTexts.append(transform(texts[i], colors[i], option, sqlQuery, searchAlike));
            }
        }
        return transformedTexts.toString();
    }

    public String transform(String stringWithColors, TransformOption option, SqlQuery sqlQuery, Colors defaultColor, boolean searchAlike){
        String[] targetWordArray = Colors.getWordArray(stringWithColors); // eg. ["Sand Crab", " (level-15)"]
        Colors[] targetColorArray = Colors.getColorArray(stringWithColors, defaultColor); // eg. [Colors.white, Colors.red]

        if (isMembersItemInF2P(stringWithColors, sqlQuery) && option == TransformOption.TRANSLATE_LOCAL) {
            return translateMembersItemInF2P(stringWithColors ,defaultColor, sqlQuery);
        }
        return transform(targetWordArray, targetColorArray, option, sqlQuery, searchAlike);
    }

    private boolean isMembersItemInF2P(String stringWithColors, SqlQuery sqlQuery){
        String stringWithoutTags = Colors.removeAllTags(stringWithColors);
        return sqlQuery.isItemNameQuery() && stringWithoutTags.endsWith(" (Members)");
    }

    private String translateMembersItemInF2P(String stringWithColors ,Colors defaultColor, SqlQuery sqlQuery){
        TransformOption option = TransformOption.TRANSLATE_LOCAL;
        String stringWithoutTags = Colors.removeAllTags(stringWithColors);
        String itemPart = stringWithoutTags.substring(0, stringWithoutTags.length() - 10);
        sqlQuery.setItemName(itemPart, defaultColor);
        String itemTranslation = transform(itemPart, defaultColor, option, sqlQuery, false);

        // translate the "(Members)" part
        String members = "(Members)";
        sqlQuery.setGroundItemActions(members, defaultColor); // was added to database with same column values
        String membersPart = transform(members, defaultColor, option, sqlQuery, false);

        if (plugin.getConfig().getSelectedLanguage().needsCharImages()) {
            return itemTranslation + membersPart;
        } else {
            return itemTranslation + " " + membersPart;
        }
    }

    public static String unifySimilarChars(String fullWidthStr) {
        String[][] fullWidthToHalfWidth = {
                {"０", "0"}, {"１", "1"}, {"２", "2"}, {"３", "3"}, {"４", "4"}, {"５", "5"}, {"６", "6"}, {"７", "7"}, {"８", "8"}, {"９", "9"},
                {"Ａ", "A"}, {"Ｂ", "B"}, {"Ｃ", "C"}, {"Ｄ", "D"}, {"Ｅ", "E"}, {"Ｆ", "F"}, {"Ｇ", "G"}, {"Ｈ", "H"}, {"Ｉ", "I"}, {"Ｊ", "J"},
                {"Ｋ", "K"}, {"Ｌ", "L"}, {"Ｍ", "M"}, {"Ｎ", "N"}, {"Ｏ", "O"}, {"Ｐ", "P"}, {"Ｑ", "Q"}, {"Ｒ", "R"}, {"Ｓ", "S"}, {"Ｔ", "T"},
                {"Ｕ", "U"}, {"Ｖ", "V"}, {"Ｗ", "W"}, {"Ｘ", "X"}, {"Ｙ", "Y"}, {"Ｚ", "Z"},
                {"ａ", "a"}, {"ｂ", "b"}, {"ｃ", "c"}, {"ｄ", "d"}, {"ｅ", "e"}, {"ｆ", "f"}, {"ｇ", "g"}, {"ｈ", "h"}, {"ｉ", "i"}, {"ｊ", "j"},
                {"ｋ", "k"}, {"ｌ", "l"}, {"ｍ", "m"}, {"ｎ", "n"}, {"ｏ", "o"}, {"ｐ", "p"}, {"ｑ", "q"}, {"ｒ", "r"}, {"ｓ", "s"}, {"ｔ", "t"},
                {"ｕ", "u"}, {"ｖ", "v"}, {"ｗ", "w"}, {"ｘ", "x"}, {"ｙ", "y"}, {"ｚ", "z"},
                {"！", "!"}, {"”", "\""}, {"＃", "#"}, {"＄", "$"}, {"％", "%"}, {"＆", "&"}, {"＇", "'"}, {"（", "("}, {"）", ")"}, {"＊", "*"},
                {"＋", "+"}, {"，", ","}, {"－", "-"}, {"．", "."}, {"／", "/"}, {"：", ":"}, {"；", ";"}, {"＜", "<"}, {"＝", "="}, {"＞", ">"},
                {"？", "?"}, {"＠", "@"}, {"［", "["}, {"＼", "\\"}, {"］", "]"}, {"＾", "^"}, {"＿", "_"}, {"｀", "`"}, {"｛", "{"}, {"｜", "|"},
                {"｝", "}"}, {"　", " "},  {"！", "!"},//, {"～", "~"}
                // turkish letters
                {"İ", "I"}, {"ı", "i"}, {"Ş", "S"}, {"ş", "s"}, {"Ğ", "G"}, {"ğ", "g"}, {"Ü", "U"}, {"ü", "u"}, {"Ö", "O"}, {"ö", "o"},
        };
        for (String[] pair : fullWidthToHalfWidth) {
            fullWidthStr = fullWidthStr.replace(pair[0], pair[1]);
        }
        return fullWidthStr;
    }

    public String stringToDisplayedString(String translatedText, Colors colors){
        boolean needCharImage = plugin.getConfig().getSelectedLanguage().needsCharImages();
        GeneralFunctions generalFunctions = plugin.getGeneralFunctions();

        if(needCharImage) {// needs char image but just 1 color
            return generalFunctions.StringToTags(Colors.removeNonImgTags(translatedText), colors);
        } else { // doesnt need char image and just 1 color
            return "<col=" + colors.getHex() + ">" + translatedText + "</col>";
        }
    }

    private String textAddColor(String text, Colors color){
        if (Colors.getColorTagsAsIs(text).isEmpty()) {
            return Colors.surroundWithColorTag(text, color);
        }
        return text;
    }

    public static String getEnglishColValFromText(String str) {
        if (str == null) {
            return "";
        }

        str = SqlQuery.replaceSpecialSpaces(str);
        str = Colors.getEnumeratedColorWord(str);
        str = SqlQuery.replaceNumbersWithPlaceholders(str);
        str = str.replace(" <br>", " ");
        str = str.replace("<br> ", " ");
        str = str.replace("<br>", " ");
        return str;
    }

    private void outputUnknown(SqlQuery query){
        if(outputUnknownToFile){
            outputToFile.dumpGeneral(query.getEnglish(), query.getCategory(), query.getSubCategory(), query.getSource());
        }
    }

}

package com.RuneLingual.commonFunctions;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Getter
@Slf4j
public enum Colors {
    black("000000","black"),
    black2("0","black"),
    black3("46320a","black"),//dark brown
    blue("0000ff","blue"),
    blue2("ff","blue"),
    green("00ff00","green"),
    green2("ff00","green"),
    green3("c0ff00", "green"),
    green4("dc10d", "green"),
    green5("40ff00", "green"),
    green6("80ff00", "green"),
    lightblue("00ffff","lightblue"),
    lightblue2("ffff", "lightblue"),
    orange("ff7000","orange"),
    orange2("ff9040","orange"),
    orange3("ff981f","orange"),
    red("ff0000","red"),
    red2("800000","red"),
    red3("6800bf","red"),
    white("ffffff","white"),
    white2("9f9f9f","white"),
    white3("af6a1a","white"),
    yellow("ffff00", "yellow"),
    yellow2("ffb83f", "yellow"),

    ;

    private String name;
    private String hex;

    private Colors(String hex, String name) {
        this.hex = hex;
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getHex() {
        return hex;
    }

    public String getColorTag() {
        return "<col=" + this.getHex() + ">";
    }

//    public static Colors fromName(String name) {
//        for (Colors Colors : values()) {
//            if (Colors.getName().equalsIgnoreCase(name)) {
//                return Colors;
//            }
//        }
//        return black; // or throw an exception
//    }

    public static Colors fromName(String colorName){
        if (colorName.equals(red.getName())){
            return getColorFromHex(red.getHex());
        }
        if (colorName.equals(black.getName())){
            return getColorFromHex(black.getHex());
        }
        if (colorName.equals(blue.getName())){
            return getColorFromHex(blue.getHex());
        }
        if (colorName.equals(lightblue.getName())){
            return getColorFromHex(lightblue.getHex());
        }
        if (colorName.equals(yellow.getName())){
            return getColorFromHex(yellow.getHex());
        }
        if (colorName.equals(orange.getName())){
            return getColorFromHex(orange.getHex());
        }
        if (colorName.equals(white.getName())){
            return getColorFromHex(white.getHex());
        }
        if (colorName.equals(green.getName())){
            return getColorFromHex(green.getHex());
        }
        log.error("couldn't find color with the name : {}", colorName);
        return getColorFromHex(white.getHex());
    }

    public static Colors getColorFromHex(String hex) {
        int[] colorInts = new int[Colors.values().length]; // array of color's value in int instead of string hex

        for (int i = 0; i < Colors.values().length;i++) {
            String colName = Colors.values()[i].hex;
            if (hex.equals(colName))
                return Colors.values()[i];
            colorInts[i] = hexToInt(Colors.values()[i].getHex());
        }
        int j = findClosest(hexToInt(hex),colorInts);
        //log.info("color = " + Colors.values()[j]);
        return Colors.values()[j]; // or throw an exception
    }

    public static Colors fromInt(int intColor) {
        String hexString = IntToHex(intColor);
        return getColorFromHex(hexString);
    }

    private static int findClosest(int target, int[] colInInt) {
        if (target == hexToInt("f9f9f9")) {//int for hex 9f9f9f, grey text in settings
            int i;
            for (i = 1; i < colInInt.length; i++)
                if (Colors.values()[i] == Colors.white)
                    return i;
            return i;
        } else {
            int closestI = 0;
            int smallestDifference = 256*3;
            int rValue = (target / 65536) % 256;
            int gValue = (target / 256) % 256;
            int bValue = target % 256;
            for (int i = 1; i < colInInt.length; i++) {
                int rDif = Math.abs((colInInt[i] / 65536) % 256 - rValue);
                int gDif = Math.abs((colInInt[i] / 256) % 256 - gValue);
                int bDif = Math.abs(colInInt[i] % 256 - bValue);
                int currentDifference = rDif + gDif + bDif;

                if (currentDifference < smallestDifference) {
                    smallestDifference = currentDifference;
                    closestI = i;
                }
            }
            return closestI;
        }
    }
    public static String IntToHex(int intColor) {
        String hexString = String.format("%06x",intColor);

        for (Colors Colors : values()) {
            if (Colors.getHex().equalsIgnoreCase(hexString)) {
                return Colors.getHex();
            }
        }
        return hexString; // or throw an exception
    }

    public static int hexToInt(String hex) {
        if(hex.length() > 6){
            hex = hex.substring(0,6);
        }
        return Integer.parseInt(hex, 16);
    }

    public Colors getSimpleColor(){
        if (this.getName().equals(Colors.green.getName())){ //if the color is green
            return Colors.green;
        }
        if (this.getName().equals(Colors.red.getName())){ //if the color is red
            return Colors.red;
        }
        if (this.getName().equals(Colors.blue.getName())){ //if the color is blue
            return Colors.blue;
        }
        if (this.getName().equals(Colors.orange.getName())){ //if the color is orange
            return Colors.orange;
        }
        if (this.getName().equals(Colors.yellow.getName())){ //if the color is yellow
            return Colors.yellow;
        }
        if (this.getName().equals(Colors.white.getName())){ //if the color is white
            return Colors.white;
        }
        if (this.getName().equals(Colors.black.getName())){ //if the color is black
            return Colors.black;
        }
        if (this.getName().equals(Colors.lightblue.getName())){ //if the color is lightblue
            return Colors.lightblue;
        }
        return this;
    }









    public static int countColorTagsAfterReformat(String wordAndColor) {//count number of color tags in a string
        wordAndColor = reformatColorWord(wordAndColor, Colors.white);
        // remove <img=**> tags
        wordAndColor = wordAndColor.replaceAll("<img=[0-9]*>", "");
        Pattern re = Pattern.compile("(?<=\\d)>|(?<=\\p{IsAlphabetic})>");
        String[] splitResult = re.split(wordAndColor);
        if (splitResult.length <= 1) {
            return 0;
        }
        return re.split(wordAndColor).length - 1;
    }

    public static Colors[] getColorArray(String strWithColor, Colors defaultColor) {
        /*
        This function takes a string with color tags and returns a list of color names
        eg: <col=ff0000>Nex<col=ffffff> (level-1) -> ["red", "white"]
         */
        strWithColor = strWithColor.replaceAll("<img=.+?>", ""); // remove <img=**> tags
        // if there are no color tags,
        // or if it contains placeholder for color, return defaultColor
        if(countColorTagsAfterReformat(strWithColor) == 0 ||
                strWithColor.contains("<colNum") || strWithColor.isEmpty()) {
            return new Colors[]{defaultColor};
        }

        strWithColor = reformatColorWord(strWithColor, defaultColor);

        // if there are color tags, return the color names
        String[] parts = strWithColor.split("<col=");
        Colors[] colorArray = new Colors[parts.length - 1];
        Pattern re = Pattern.compile("(?<=\\d)>|(?<=\\p{IsAlphabetic})>");
        for (int i = 0; i < parts.length - 1; i++) {
            Colors c = Colors.getColorFromHex(re.split(parts[i + 1])[0]);
            colorArray[i] = c;
            if (colorArray[i] == null || Objects.equals(colorArray[i], "")) {
                colorArray[i] = defaultColor;
            }
        }
        return colorArray;
    }

    public static String[] getWordArray(String strWithColor) {
        /*
        This function takes a string with color tags and returns a list of words
        eg: <img=3><colHIGHLIGHT>Nex<col=ffffff> (level-1) -> ["<img=3>", "Nex", " (level-1)"]
         */
        strWithColor = reformatColorWord(strWithColor, Colors.white);
        Pattern re = Pattern.compile("<col=[a-zA-Z0-9]*?>");
        String[] strArray = re.split(strWithColor);
        if (strArray.length == 0) {
            return new String[0];
        }
        if (strArray[0].isEmpty()) {
            if (strArray.length == 1) {
                return new String[0];
            } else {
                return Arrays.copyOfRange(strArray, 1, strArray.length);
            }
        }
        return re.split(strWithColor);
    }

    private static String reformatColorWord(String colWord, Colors defaultColor) {
        // replace <colNORMAL> with <col=0>, <colHIGHLIGHT> with <col=ff0000>, etc.
        colWord = colWord.replace("<colNORMAL>", "<col=0>");
        colWord = colWord.replace("<colHIGHLIGHT>", "<col=ff0000>");
        //todo: if there are any color tags that are not in the enum, add and replace them with <col=??> here like above

        // give words after </col> the default color
        // <col=ff0000>Nex</col> (level-1) -> <col=ff0000>Nex<col=ffffff> (level-1)
        colWord = colWord.replace("</col>",defaultColor.getColorTag());

        // give the beginning words without a color tag the default color
        // Nex <col=ffffff> (level-1) -> <col=ff0000>Nex <col=ffffff>(level-1)
        if (!colWord.startsWith("<col")) {
            colWord = defaultColor.getColorTag() + colWord;
        }

        // remove the color tag at the end of the word
        // <col=ff0000>Nex<col=ffffff> (level-1) <col=f0f0f0> -> <col=ff0000>Nex<col=ffffff> (level-1)
        colWord = colWord.replaceAll("<col=[a-zA-Z0-9]*?>$","");

        return colWord;
    }

    public static String removeNonImgTags(String str) {
        return str.replaceAll("<(?!img|>).*?>", "");
    }

    public static String removeAllTags(String str) {
        return str.replaceAll("<.*?>", "");
    }


    /*
     * returns: text with color tags that are enumerated instead of actual colors
     * eg: <col=ff0000>Nex<col=ffffff> (level-1) -> <colNum0>Nex<colNum1> (level-1)
     */
    public static String getColorPlaceholdedColWord(String colWord) {
        Pattern re = Pattern.compile("<col[=a-zA-Z0-9]*?>");
        String[] parts = re.split(colWord);
        StringBuilder colorString = new StringBuilder();
        for (int i = 0; i < parts.length; i++) {
            colorString.append(parts[i]);
            if (i < parts.length - 1) {
                colorString.append("<colNum").append(i).append(">");
            }
        }
        return colorString.toString();
    }

    /*
     * returns: list of strings found in the color tags
     * eg: <col=ff0000>Nex<col=ffffff> (level-1) -> ["ff0000", "ffffff"]
     */
    public static List<String> getColorTagsAsIs(String strWithColor) {
        // supports abnormal color tags such as <colHIGHLIGHT>, as long as its only numbers and alphabets, no symbols
        List<String> matches = new ArrayList<>();
        Pattern pattern = Pattern.compile("<col[=a-zA-Z0-9]*?>");
        Matcher matcher = pattern.matcher(strWithColor);

        while (matcher.find()) {
            matches.add(matcher.group());
        }
        return matches;
    }

    /*
     * returns: text with color tags that are enumerated instead of actual colors
     * eg: <col=ff0000>Nex<col=ffffff> (level-1) -> <colNum0>Nex<colNum1> (level-1)
     */
    public static String getEnumeratedColorWord(String colWord) {
        Pattern re = Pattern.compile("<col[=a-zA-Z0-9]*?>");
        String[] parts = re.split(colWord);
        StringBuilder colorString = new StringBuilder();
        for (int i = 0; i < parts.length; i++) {
            colorString.append(parts[i]);
            if (i < parts.length - 1) {
                colorString.append("<colNum").append(i).append(">");
            }
        }
        return colorString.toString();
    }

    /*
     * returns: text with color tags that were originally in place of the enumerated color tags
     * eg: <colNum0>Nex<colNum1> (level-1) -> <col=ff0000>Nex<col=ffffff> (level-1)
     */
    public static String getOriginalColorWord(String colWord, List<String> originalColorTags) {
        for (int i = 0; i < originalColorTags.size(); i++) {
            colWord = colWord.replace("<colNum" + i + ">", originalColorTags.get(i));
        }
        return colWord;

    }

    public static String surroundWithColorTag(String str, Colors color) {
        if(str == null){
            return "";
        }
        if(color == null){
            return str;
        }
        return color.getColorTag() + str + "</col>";
    }
}
package com.RuneLingual.commonFunctions;

import com.RuneLingual.Widgets.PartialTranslationManager;
import com.RuneLingual.Widgets.Widget2ModDict;
import lombok.Getter;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InterfaceID.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;

import com.RuneLingual.RuneLingualPlugin;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.RuneLingual.Widgets.PartialTranslationManager.PlaceholderType.*;

@Getter @Slf4j
public class Ids {
    @Inject
    private RuneLingualPlugin plugin;
    @Inject
    Client client;
    @Getter
    private Widget2ModDict widget2ModDict;
    @Getter
    private PartialTranslationManager partialTranslationManager;

    @Inject
    public Ids(RuneLingualPlugin plugin, Widget2ModDict widget2ModDict, PartialTranslationManager partialTranslationManager) {
        this.plugin = plugin;
        this.client = plugin.getClient();
        this.widget2ModDict = widget2ModDict;
        this.partialTranslationManager = partialTranslationManager;
        initWidget2ModDict();
        initPartialTranslations();
    }

    // Ids of widgets
    // main tabs
    private final int widgetIdMainTabs = ToplevelPreEoc.SIDE_PANELS;
    private final int widgetIdAttackStyleTab = CombatInterface.UNIVERSE;
    private final int widgetIdSkillsTab = Stats.UNIVERSE;
    private final int widgetIdCharacterSummaryTab = AccountSummarySidepanel.SUMMARY_CONTENTS;
    private final int widgetIdQuestTab = Questlist.UNIVERSE;
    private final int widgetIdAchievementDiaryTab = AreaTask.TASKBOX;
    private final int widgetIdInventoryTab = Inventory.ITEMS;
    private final int widgetIdEquipmentTab = Wornitems.UNIVERSE;
    private final int widgetIdPrayerTab = Prayerbook.UNIVERSE;
    private final int widgetIdSpellBookTab = MagicSpellbook.UNIVERSE;
    private final int widgetIdGroupsTab = SideChannelsLarge.UNIVERSE;
    private final int widgetIdGroupTabNonGIM = 46333952;
    private final int widgetIdPvPArena = PvpArenaSidepanel.UNIVERSE;
    private final int widgetIdFriendsTab = Friends.UNIVERSE;
    private final int widgetIdIgnoreTab = Ignore.UNIVERSE;
    private final int widgetIdAccountManagementTab = Account.CONTENT;
    private final int widgetIdSettingsTab = SettingsSide.UNIVERSE;
    private final int widgetIdEmotesTab = Emote.UNIVERSE;
    private final int widgetIdMusicTab = Music.UNIVERSE;
    private final int widgetIdLogoutTab = Logout.UNIVERSE;
    private final int widgetIdWorldSwitcherTab = Worldswitcher.UNIVERSE;

    // dont translate at all, except menu option
    private final int widgetIdCharacterSummaryName = AccountSummarySidepanel.SUMMARY_PLAYER_NAME;
    private final int widgetIdGimGroupName = GimSidepanel.TITLE;
    private final int widgetIdClockGIM = SideChannelsLarge.CLOCK;
    private final int widgetIdClockNonGIM = SideChannels.CLOCK;
    private final int widgetIdMusicCurrent = Music.NOW_PLAYING_TEXT;
    private final int settingsSearchBarId = Settings.SEARCH_TEXT;
    private final int widgetIdCombatAchSearchBar = CaBosses.SEARCH_TEXT;
    private final int widgetIdBehindLoginScreen = ToplevelDisplay.LAYERS;

    //general interface
    private final int widgetIdSkillGuide = SkillGuide.UNIVERSE;
    private final int rootWidgetId = ToplevelPreEoc.GAMEFRAME;

    /* example for adding set of widget ids
    private final Set<Integer> idSet4Raids_Colosseum = Set.of(
            1234, // widget id of parent containing text of display board for raids 1
            5678, // ...
            1234 // ...
    );
     */

    // dont translate at all
    private final Set<Integer> widgetIdNot2Translate = Set.of(
            Chatbox.CHATDISPLAY,
            10617391,//some sort of background for chatbox
            widgetIdCharacterSummaryName,
            Ignore.LIST_CONTAINER,
            widgetIdGimGroupName, //gim group name in group tab
            widgetIdClockGIM, widgetIdClockNonGIM,
            //ComponentID.MUSIC_SCROLL_CONTAINER, // if music is not ignored here, having the music tab opened will drop fps
            //widgetIdMusicCurrent // may need to be ignored if clue solver reads this widget's value
            settingsSearchBarId,
            widgetIdCombatAchSearchBar,
            widgetIdBehindLoginScreen
    );

    // dont translate with api
    private final Set<Integer> widgetIdNot2ApiTranslate = Set.of(
            Music.FRAME, // if music is not ignored here, having the music tab opened will drop fps
            CaTasks.TASKS // combat achievement tasks
    );


    private final Set<Integer> widgetIdItemName = Set.of(
            CombatInterface.TITLE // combat weapon name in combat options
    );

    private final Set<Integer> widgetIdNpcName = Set.of(
            CaBosses.BOSSES_NAME, // the boss names in the "Combat Achievement - Bosses"
            CaBoss.BOSS_NAME // the boss names in the "Combat Achievement - Specific Bosses"
    );

    private final Set<Integer> widgetIdObjectName = Set.of(

    );

    private final Set<Integer> widgetIdQuestName = Set.of(
            Questlist.LIST // quest name in quest list
    );

    private final Set<Integer> widgetIdAnyTranslated = Set.of(// dont specify any categoriries

    );

    private final Set<Integer> widgetIdCA = Set.of(
            CaOverview.INFINITY, // combat achievement overview
            CaTasks.INFINITY, // combat achievement tasks
            CaBosses.INFINITY, // combat achievement Bosses
            CaRewards.INFINITY, // combat achievement Rewards
            CaBoss.INFINITY, // combat achievement specific bosses
            CaTasks.DROPDOWN_BOX  // combat achievement task filter drop down list
    );

    // other specific ids
    private final int attackStyleHoverTextId = CombatInterface.TOOLTIP;
    private final int prayerTabHoverTextId = Prayerbook.TOOLTIP;
    private final int spellbookTabHoverTextId = MagicSpellbook.TOOLTIP;
    private final int addFriendButtonId = Friends.UNIVERSE_TEXT4;
    private final int removeFriendButtonId = Friends.UNIVERSE_TEXT6;
    private final int skillsTabXpHoverTextId = Stats.TOOLTIP;
    private final int xpBarTopRightHoverTextId = XpDrops.TOOLTIP;
    private final int gimMemberNameId = GimSidepanel.MEMBERS; // show only if type = 4 and left aligned
    private final int groupTabPvPGroupMemberId = PvpArenaSidepanel.PLAYERLIST;
    private final int groupingGroupMemberNameId = Grouping.PLAYERLIST;
    private final int settingsHoverTextId = SettingsSide.TOOLTIP;
    private final int emotesHoverTextId = Emote.TOOLTIP;
    private final int worldSwitcherHoverTextId = Worldswitcher.TOOLTIP;
    private final int worldSwitcherWorldActivityId = Worldswitcher.INFO;
    private final int houseOptionsHoverTextId = PohOptions.TOOLTIP; // house options, from the settings tab, click house icon
    private final int houseOptionsTextOnID = PohOptions.ROOT_TEXT2; // in house options, the "On" text (can get <br> tag in some languages)
    private final int houseOptionsTextOffID = PohOptions.ROOT_TEXT3; // in house options, the "Off" text (can get <br> tag in some languages)
    private final int loginScreenId = WelcomeScreen.CONTENT;
    private final int loginBannerId = WelcomeScreen.BANNER_ARTCANVAS;

    // for English transcript to be split at <br> tags and added to the transcript
    // will reduce the number of translations needed
    // (below, "Next level at:" and "Remaining XP:" are only translated once instead of for every skill)
    // e.g
    // (original text) "Agility Xp:<br>Next level at:<br>Remaining XP:"
    // ->(split into) "Agility Xp:", "Next level at:", "Remaining XP:"
    // -> (translated to) "運動神経XP", "次レベル開始：", "残りXP："
    // -> (combine and set widget text as) "運動神経XP:<br>次レベル開始：<br>残りXP："
    private final Set<Integer> widgetId2SplitTextAtBr = Set.of(
            skillsTabXpHoverTextId, // skill tab's xp hover display
            xpBarTopRightHoverTextId // hover display of xp bar top right
    );

    // for English transcript to be kept as is
    // useful for widgets that have multiple variables in one widget
    // e.g (first line is level, second line is prayer name, third line is description, all in one widget)
    // (original text) "Level 22<br>Rapid Heal<br>2x restore rate for<br>Hitpoints stat."
    // -> (translated to) "レベル22<br>急激な回復<br>体力の回復速度を<br>２倍にする"
    // -> (set widget text as above)
    private final Set<Integer> widgetId2KeepBr = Set.of(
            prayerTabHoverTextId,
            spellbookTabHoverTextId,
            addFriendButtonId, removeFriendButtonId,
            settingsHoverTextId,
            emotesHoverTextId,
            worldSwitcherHoverTextId, worldSwitcherWorldActivityId,
            houseOptionsHoverTextId, houseOptionsTextOnID, houseOptionsTextOffID
    );

    private final Set<Integer> widgetIdChatButton2SetXTextAliLeft = Set.of(
            Chatbox.CHAT_GAME_TEXT1, // CHATBOX_TAB_GAME 's "Game" widget
            Chatbox.CHAT_PUBLIC_TEXT1, // CHATBOX_TAB_PUBLIC 's "Public" widget
            Chatbox.CHAT_PRIVATE_TEXT1, // CHATBOX_TAB_PRIVATE 's "Private" widget
            Chatbox.CHAT_FRIENDSCHAT_TEXT1, // CHATBOX_TAB_CHANNEL 's "Channel" widget
            Chatbox.CHAT_CLAN_TEXT1, // CHATBOX_TAB_CLAN 's "Clan" widget
            Chatbox.CHAT_TRADE_TEXT // CHATBOX_TAB_TRADE 's "Trade" widget
    );
    private final Set<Integer> widgetIdChatButton2SetXTextAliRight = Set.of(
            Chatbox.CHAT_GAME_FILTER, // CHATBOX_TAB_GAME 's setting widget
            Chatbox.CHAT_PUBLIC_FILTER, // CHATBOX_TAB_PUBLIC 's setting widget
            Chatbox.CHAT_PRIVATE_FILTER, // CHATBOX_TAB_PRIVATE 's setting widget
            Chatbox.CHAT_FRIENDSCHAT_FILTER, // CHATBOX_TAB_CHANNEL 's setting widget
            Chatbox.CHAT_CLAN_FILTER, // CHATBOX_TAB_CLAN 's setting widget
            Chatbox.CHAT_TRADE_FILTER // CHATBOX_TAB_TRADE 's setting widget
    );

    // widget ids to change the width of, because some widget have room and also needs more
    // each value's meaning: Map<widgetId, Pair<newWidth, newHeight>>
    private final Map<Integer, Pair<Integer, Integer>> widgetId2FixedSize = Map.ofEntries(
        //Map.entry(widget_id, Pair.of(newWidth, newHeight))
        Map.entry(AreaTask.TASKBOX, Pair.of(110, null)) // the achievement diary tab's location names
    );

    // ids of widgets to resize to match the text inside it, mostly for hover displays like prayer's hover descriptions
    // sibling widgets = other widgets under the same parent, which contains text
    private void initWidget2ModDict() {
        widget2ModDict.add(attackStyleHoverTextId, 4, false, true, false, false, false, 2, 3, 2, 2);
        widget2ModDict.add(skillsTabXpHoverTextId, 4, true, false, false, false, false, 3, 3, 3, 3); // skill tab's xp hover display
        widget2ModDict.add(prayerTabHoverTextId, 4,false, true, false, false, false, 3, 3, 2, 0);
        widget2ModDict.add(spellbookTabHoverTextId, 4,true, false, false, true, true, 2, 2, 2, 2);
        widget2ModDict.add(settingsHoverTextId, 4, false, true, false, false, false, 2, 2, 2, 2);
        widget2ModDict.add(emotesHoverTextId, 4, false, true, false, false, false, 2, 2, 2, 2);
        widget2ModDict.add(worldSwitcherHoverTextId, 4, false, false, false, false, false, 0, 2, 0, 2);
        widget2ModDict.add(houseOptionsHoverTextId, 4, false, true, false, false, false, 2, 2, 2, 0);
    }

    // partial translations
    private final int playerNameInAccManTab = Account.NAME_TEXT;
    private final int widgetIdPvPArenaNan = PvpArenaSidepanel.PLAYERLIST;//group tab, click PvP Arena button in top right while in an unrelated guest clan
    private final int widgetIdInOtherActivityChannel = Grouping.PLAYERLIST;// group tab, select an activity in drop down menu, click join, then select another activity
    private final int playerNameInCombAch = CaOverview.CA_PERSONAL_HEADER;// the player name in "Overview" of combat achievements tab
    private final int topBossInCombAch = CaOverview.CA_PERSONAL_CONTENT;// CA overview > the texts on right side, under text with player name
    private final int monsterTargetNameInCombAch = CaTasks.TASKS_MONSTER;// "Monster: ..." in combat achievements tab (tasks)
    private final int bossSpecificCA = CaBoss.FRAME;// combat achievements - specific bosses' title at the top

    private void initPartialTranslations() {
        /* use for when part of a text should not be translated / translated as item name, object name etc, and other parts should be translated by translator/api
         * for placeholder types, use PLAYER_NAME, ITEM_NAME, NPC_NAME, OBJECT_NAME, QUEST_NAME
         * use PLAYER_NAME for any text that shouldn't be translated, ITEM_NAME for item names, etc.
         *
        partialTranslationManager.addPartialTranslation(
                widgetId, (give any number if its not for widget)
                List.of("fixed text part 1", "fixed text part 2", "fixed text part 3"),
                List.of(placeholder_type1, placeholder_type2)
                * );
         (text = fixed text part 1 placeholder_type1 fixed text part 2 placeholder_type2 fixed text part 3)
         */
        partialTranslationManager.addPartialTranslation(
                playerNameInAccManTab,
                List.of("Name: "),
                List.of(PLAYER_NAME)
        );
        partialTranslationManager.addPartialTranslation(
                widgetIdPvPArenaNan,
                List.of("You have currently loaded <colNum0>", "</col>, which is not a PvP Arena group."),
                List.of(PLAYER_NAME)// clan name goes here
        );
        partialTranslationManager.addPartialTranslation(
                widgetIdInOtherActivityChannel,
                List.of("You are currently talking in the <colNum0>","</col> channel."),
                List.of(ANY_TRANSLATED)// activity name goes here
        );
        partialTranslationManager.addPartialTranslation( // menu option for join button in group tab's activity tab
                0,
                List.of("Join <colNum0>","</col> channel"),
                List.of(ANY_TRANSLATED)// activity name goes here
        );
        partialTranslationManager.addPartialTranslation( // menu option for leave button in group tab's activity tab, displayed after joining
                0,
                List.of("Leave <colNum0>","</col> channel"),
                List.of(ANY_TRANSLATED)// activity name goes here
        );
        partialTranslationManager.addPartialTranslation( // menu option for teleport button in group tab's activity tab
                0,
                List.of("Teleport to <colNum0>","</col>"),
                List.of(ANY_TRANSLATED)// activity name goes here
        );
        partialTranslationManager.addPartialTranslation(
                topBossInCombAch,
                List.of("", " (<Num0>)"),
                List.of(ANY_TRANSLATED)// boss names. ANY_TRANSLATED and not NPC_NAME because it's not always npc name, eg Wintertodt)
        );
        partialTranslationManager.addPartialTranslation(
                playerNameInCombAch,
                List.of("Combat Profile - "),
                List.of(PLAYER_NAME)
        );
        partialTranslationManager.addPartialTranslation(
                monsterTargetNameInCombAch,
                List.of("Monster: <colNum0>","</col>"),
                List.of(NPC_NAME)// monster name, but includes non npc names like "Royal Titans", "Wintertodt"
        );
        partialTranslationManager.addPartialTranslation(
                bossSpecificCA,
                List.of("Combat Achievements - "),
                List.of(NPC_NAME)// npc names include non-npcs like "chambers of zeric", "theatre of blood"
        );
        partialTranslationManager.addPartialTranslation(
                0,
                List.of("Add friend "),
                List.of(PLAYER_NAME)// for menu action in group tab, activity tab after joining an fc and right clicking player there
        );
        partialTranslationManager.addPartialTranslation(
                0,
                List.of("Add ignore "),
                List.of(PLAYER_NAME)// for menu action in group tab, activity tab after joining an fc and right clicking player there
        );
        partialTranslationManager.addPartialTranslation(
                0,
                List.of("Remove friend "),
                List.of(PLAYER_NAME)// for menu action in group tab, activity tab after joining an fc and right clicking player there
        );
        partialTranslationManager.addPartialTranslation(
                0,
                List.of("Remove ignore "),
                List.of(PLAYER_NAME)// for menu action in group tab, activity tab after joining an fc and right clicking player there
        );

        // to add placeholder at the beginning of the text, add an empty string to the fixedTextParts
        // eg.  partialTranslationManager.addPartialTranslation(
        //                playerNameInAccManTab,
        //                List.of("", "is his name."),
        //                List.of(PLAYER_NAME)
        //        );

        // add more partial translations here
    }

    public int getCombatOptionParentWidgetId() {
        Widget w = client.getWidget(ComponentID.COMBAT_LEVEL);
        if(w != null) {
            return w.getParentId();
        }
        //log.info("parent of ComponentID.COMBAT_LEVEL is null");
        return -1;
    }

    public int getWidgetIdAchievementDiaryTab() {
        Widget w = client.getWidget(ComponentID.ACHIEVEMENT_DIARY_CONTAINER);
        if(w != null) {
            return w.getParent().getParent().getParentId();
        }
        //log.info("parent^3 of ComponentID.ACHIEVEMENT_DIARY_CONTAINER is null");
        return -1;
    }

    public int getFriendsTabParentWidgetId() {
        Widget w = client.getWidget(ComponentID.FRIEND_LIST_TITLE);
        if(w != null) {
            return w.getParentId();
        }
        //log.info("parent of ComponentID.FRIEND_LIST_TITLE is null");
        return -1;
    }

    public int getIgnoreTabParentWidgetId() {
        Widget w = client.getWidget(ComponentID.IGNORE_LIST_TITLE);
        if(w != null) {
            return w.getParentId();
        }
        //log.info("parent of ComponentID.IGNORE_LIST_TITLE is null");
        return -1;
    }

    public int getWidgetIdCharacterSummaryTab(){
        Widget w = client.getWidget(ComponentID.CHARACTER_SUMMARY_CONTAINER);
        if(w != null) {
            return w.getParentId();
        }
        //log.info("parent of ComponentID.CHARACTER_SUMMARY_CONTAINER is null");
        return -1;
    }

}

package com.RuneLingual.commonFunctions;

import com.RuneLingual.LangCodeSelectableList;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import java.io.File;

@Slf4j
public class FileNameAndPath {
    @Getter
    private static final File localBaseFolder = new File(RuneLite.RUNELITE_DIR.getPath() + File.separator + "RuneLingual_resources");
    @Getter
    private static final String localSQLFileName = "transcript";


    public static String getLocalLangFolder(LangCodeSelectableList lang) {
        String langCode = lang.getLangCode();
        File localLangFolder = new File(localBaseFolder.getPath() + File.separator + langCode);
        return localLangFolder.getPath();
    }
    @Getter @Setter
    private String localLangFolder;

    public static void createDirectoryIfNotExists(String folderPath) {
        //create the directory if it doesn't exist
        File directory = new File(folderPath);
        directory.mkdir();
    }

    public static void createFileIfNotExists(String filePath) {
        //create the file if it doesn't exist
        File file = new File(filePath);
        try {
            if (!file.createNewFile()) {
                log.error("File already exists: {}", filePath);
            }
        } catch (Exception e) {
            log.error("Error creating file: {}", e.getMessage());
        }
    }
}

package com.RuneLingual;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RuneLingualPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RuneLingualPlugin.class);
		RuneLite.main(args);
	}
}
