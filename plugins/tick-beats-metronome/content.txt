package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import javax.inject.Singleton;
import java.io.File;
import java.util.*;

/**
 * Handles finding and managing user-supplied sound files from the
 * RuneLite plugin configuration directory.
 * This class creates a map of audio files which can be accessed via getUserSoundMap()
 *   ~/.runelite/tick-beats/sounds/*
 * Is the expected location of sound files, it should create this folder on startup:
 * All user-supplied files must be `.wav` format.
 */
@Slf4j
@Singleton
public class UserSoundManager
{
    // Path to the directory where users can drop .wav files
    private static final File SOUND_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "tick-beats/sounds");

    // Stores user sound files keyed by their ID ("1", "2", etc.)
    private final Map<String, File> userSoundMap = new HashMap<>();

    // list of sound files
    private List<File> userFiles = new ArrayList<>();



    /**
     * Loads all .wav files from the user's sound directory.
     * This should be called once during plugin startup.
     */
    public void loadUserSounds()
    {
        // Clear any previously loaded sounds (safe for reloads)
        userFiles.clear();
        userSoundMap.clear();

        // Ensure directory exists
        if (!SOUND_DIRECTORY.exists())
        {
            boolean created = SOUND_DIRECTORY.mkdirs();
            if (!created)
            {
                log.debug("Could not create user sound directory: {}", SOUND_DIRECTORY.getAbsolutePath());
                return;
            }
        }

        // List all .wav files in the sound directory
        File[] files = SOUND_DIRECTORY.listFiles();
        if (files == null)
        {
            log.debug("Could not read sound directory contents.");
            return;
        }

        for (File file : files)
        {
            // Only accept regular files that end in .wav (case-insensitive)
            if (file.isFile() && file.getName().toLowerCase().endsWith(".wav"))
            {
                userFiles.add(file);
                log.debug("Discovered user sound file: {}", file.getName());
            }
        }

        //sort the files by filename
        userFiles.sort(Comparator.comparing(File::getName));

        log.debug("Total user sound files loaded: {}", userFiles.size());

        //create the userSoundMap attaching an id to each sound file for access
        int i = 0;
        for (File file : userFiles)
        {
            i++;
            String fileId = String.valueOf(i);
            userSoundMap.put(fileId, file);
            log.debug("Registered user sound [{}]: {}", fileId, file.getName());
        }
    }



    /**
     * Returns a collection of all user sound files.
     */

    public Map<String, File> getUserSoundMap()
    {
        return userSoundMap;
    }

}
package com.TickBeatsMetronome;

import com.google.inject.Provides;
import javax.inject.Inject;


import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;


@Slf4j
@PluginDescriptor(
        name = "Tick Beats",
        description = "Music player and metronome with advanced audio and visual configurations",
        tags = {"tick", "beat", "beats", "visual", "helper", "metronome", "music", "sound", "audio", "skilling", "skill", "cycle"}
)
//suppressing unused warning in IDE at class level as there are a lot of them with RL Plugins
@SuppressWarnings("unused") //comment or remove this line out if you want to see unused warnings
//extends Plugin makes this a singleton so @Singleton isn't used here
public class TickBeatsMetronomePlugin extends Plugin {

    //Needed for Guice Dependency Injection
    @Inject
    private Client client;

    @Inject
    private TickBeatsMetronomeConfig config;

    @Inject
    private OverlayOverheadNumber overlayOverheadNumber;

    @Inject
    private OverlayColor overlayColor;

    @Inject
    private OverlayInfoBox overlayInfoBox;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private OverlayMessage overlayMessage;

    @Inject
    private KeyManager keyManager;

    @Inject
    private InputManager inputManager;

    @Inject
    private SoundManager soundManager;

    @Inject
    private UserSoundManager userSoundManager;

    @Inject
    private UserMusicManager userMusicManager;

    @Inject
    private EventBus eventBus;

    @Inject
    private MusicManager musicManager;

    @Inject
    private DownloadManager downloadManager;

    //need to pass in local tick callback so don't inject this one
    private LocalTickManager localTickManager;


    //Holds the tick count//
    public int tickCount = 0;

    //Holds the Beat Number of which beat to play/
    public int beatNumber = 1;

    //Holds the max number of ticks for the current beat
    public int maxTicks = 1;


    protected void startUp()
    {
        log.debug("Tick Beats Plugin started");

        tickCount = config.startTick();

        // Attach the overlays
        overlayManager.add(overlayOverheadNumber);
        overlayManager.add(overlayColor);
        overlayManager.add(overlayInfoBox);
        overlayManager.add(overlayMessage);

        // Register the key input listener
        keyManager.registerKeyListener(inputManager);

        // Create the LocalTickManager and pass in your tick callback
        localTickManager = new LocalTickManager(this::onLocalTick);

        // Register LocalTickManager so it gets onGameTick events
        eventBus.register(localTickManager);

        //load the user sound files
        userSoundManager.loadUserSounds();

        //load list of user music files
        userMusicManager.loadUserMusic();

        //check to see if all files that need to be downloaded are downloaded
        downloadManager.initializeDownloads();


        //get a music track ready to go on tick 1
        musicManager.prepMusicTrack();


    }

    @Override
    protected void shutDown()
    {
        log.debug("Tick Beats Plugin stopped");
        overlayManager.remove(overlayOverheadNumber);
        overlayManager.remove(overlayColor);
        overlayManager.remove(overlayInfoBox);
        overlayManager.remove(overlayMessage);

        keyManager.unregisterKeyListener(inputManager);

        // Shutdown local tick loop and unregister events
        if (localTickManager != null)
        {
            localTickManager.shutdown();
            eventBus.unregister(localTickManager);
            localTickManager = null;
        }

        if (downloadManager != null)
        {
            downloadManager.shutdown();
        }

    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        GameState state = event.getGameState();

        if (state == GameState.LOGIN_SCREEN || state == GameState.HOPPING)
        {
            log.debug("Player logged out or world hopping â€” resetting local tick manager.");
            if (localTickManager != null)
            {
                localTickManager.reset();
            }
        }
    }


    /**
     * Fires on every game tick ~(.6s). Updates the metronome tick count.
     */
    @Subscribe
    public void onGameTick(GameTick tick)
    {
        //nudge our local tick towards the game tick to be a near perfect average
        localTickManager.updateLocalTick();

        if(!config.enableTickSmoothing()){
            onTick();
        }

    }

    /*
     * Fires on every local tick which is setup in LocalTickManager
     */
    private void onLocalTick()
    {
        if(config.enableTickSmoothing()){
            onTick();
        }

    }

    
    private void onTick(){
        //if the reset key is being held, don't do anything on the game tick
        if(inputManager.resetActive)
        {
            return;
        }

        // Update maxTicks count based on current beat
        switch (beatNumber) {
            case 1: maxTicks = config.beat1TickCount(); break;
            case 2: maxTicks = config.beat2TickCount(); break;
            case 3: maxTicks = config.beat3TickCount(); break;
            default: maxTicks = config.beat1TickCount(); break;
        }


        // Increment the tick counter and wrap back to 1 if over max
        tickCount = (tickCount % maxTicks) + 1;

        // If Audio Metronome is enabled play the audio for the current tick
        if(config.enableAudioMetronome()){
            soundManager.playSound(beatNumber, tickCount);
        }


        // If Enable Music is checked
        if(config.enableMusic()) {

            //if music isn't playing, and we're at tick 1 start playing music
            if (!musicManager.isPlaying() && tickCount == 1) {
                musicManager.start();
            }


            //Play the music clips
            musicManager.onTick(maxTicks, tickCount, config.musicVolume());
        }else{
            //if Enable Music isn't checked, stop the music clips from playing
            musicManager.stop();
        }


    }


    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {

        //make sure the event is coming from this plugin's config group
        if (!event.getGroup().equals("tickBeats"))
        {
            return;
        }

        //if event is coming from the music track dropdown
        if (event.getKey().equals("musicTrack"))
        {
            log.debug("Music track changed.");
            musicManager.prepMusicTrack();
        }

        //if event is high quality music button run initialize downloads to see if we need to download music tracks
        if (event.getKey().equals("useHighQualityMusic"))
        {
            downloadManager.initializeDownloads();
        }
    }



    // I believe this is Required by RuneLite to provide config interface.
    @Provides
    TickBeatsMetronomeConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(TickBeatsMetronomeConfig.class);
    }

}

package com.TickBeatsMetronome;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.*;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Collectors;

/**
 * Handles downloading built-in music files for Tick Beats plugin.
 * User music is ignored â€” only tracks with non-numeric file names are downloaded.
 * Downloads are staggered based on a delay to avoid hitting GitHub rate limits.
 * Files are stored in .runelite/tick-beats/downloads/lo or hi folders.
 */
@Slf4j
@Singleton
public class DownloadManager
{
    @Inject
    private TickBeatsMetronomeConfig config;

    // Base path inside .runelite directory
    private static final Path BASE_LOCAL_PATH = new File(RuneLite.RUNELITE_DIR, "tick-beats/downloads").toPath();
    private static final Path LO_LOCAL_PATH = BASE_LOCAL_PATH.resolve("lo");
    private static final Path HI_LOCAL_PATH = BASE_LOCAL_PATH.resolve("hi");

    private static final String BASE_DOWNLOAD_URL = "https://raw.githubusercontent.com/HarperDevLab/Tick-Beats-Metronome/master/music/";

    //the default music track to download first so the user can hear it as soon as possible
    private static final String DEFAULT_TRACK = "sea_shanty_2.wav";

    // delay for low quality music files, 6x for high quality files
    private static final int DELAY_MULTIPLIER = 30000;

    //A list of only built-in tracks (doesn't check user tracks which have numeric file name "1", "2", etc)
    private List<MusicTrackOption> builtinTracks;

    private final OkHttpClient httpClient;

    private ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();

    // Shared booleans between threads
    @Getter
    private volatile boolean allLoDownloaded = false;
    @Getter
    private volatile boolean allHiDownloaded = false;

    @Getter
    private volatile int downloadedCountLo = 0;
    @Getter
    private volatile int downloadedCountHi = 0;

    @Inject
    public DownloadManager(OkHttpClient httpClient)
    {
        this.httpClient = httpClient;
    }



    /** Total number of built-in tracks (non-numeric filenames). (returns 0 if built in tracks is null)*/
    public int getTotalBuiltinCount()
    {
        if (builtinTracks == null){
            return 0;
        }

        return builtinTracks.size();
    }







    /**
     * Loads the filtered track list, checks file state, and kicks off download scheduling.
     */
    public void initializeDownloads()
    {
        //needed to prevent an error when restarting the plugin in runelite
        if (scheduler == null || scheduler.isShutdown() || scheduler.isTerminated())
        {
            log.debug("Reinitializing DownloadManager scheduler...");
            scheduler = Executors.newSingleThreadScheduledExecutor();
        }


        //pull in all the non-user tracks from the music track option enum
        builtinTracks = Arrays.stream(MusicTrackOption.values())
                .filter(track -> !track.getFileName().matches("\\d+"))
                .collect(Collectors.toList());



        checkDownloadState();

        if (!allLoDownloaded || (config.useHighQualityMusic() && !allHiDownloaded))
        {
            log.debug("a download is missing, start download scheduler");

            //if the default track doesn't exist yet
            if (!Files.exists(LO_LOCAL_PATH.resolve(DEFAULT_TRACK)))
            {
                downloadDefaultTrack();
            }

            scheduler.execute(() -> scheduleDownloads(config.useHighQualityMusic()));
        }else{
            log.debug("all files downloaded");
        }
    }

    /**
     * Whatever is set to the default track we'll want downloaded immediately so that when the user turns on music,
     * Ideally it's already downloaded so they'll hear music instead of an info/error message
     */
    private void downloadDefaultTrack(){
        scheduler.execute(() ->
        {
            String url = BASE_DOWNLOAD_URL + "lo/" + DEFAULT_TRACK;

            try {
                downloadFile(url, LO_LOCAL_PATH.resolve(DEFAULT_TRACK));
            } catch (IOException e) {
                log.debug("Failed to download Default Track: {}", e.getMessage());
            }
        });
    }





    /**
     * update our download state variables.
     */
    private void checkDownloadState()
    {
        downloadedCountLo = countExistingTracks(builtinTracks, LO_LOCAL_PATH);
        downloadedCountHi = countExistingTracks(builtinTracks, HI_LOCAL_PATH);

        allLoDownloaded = allTracksExist(builtinTracks, LO_LOCAL_PATH);

        //if the user has selected to use High Quality music check if all the tracks exist
        //if they haven't selected to use High Quality music, then it doesn't matter how many tracks are downloaded,
        // they have all they need so set to true
        if (config.useHighQualityMusic())
        {
            allHiDownloaded = allTracksExist(builtinTracks, HI_LOCAL_PATH);
        } else{
            allHiDownloaded = true;
        }

    }

    /**
     * Verifies that all expected files exist in the given directory.
     */
    private boolean allTracksExist(List<MusicTrackOption> tracks, Path dir)
    {
        for (MusicTrackOption track : tracks)
        {
            if (!Files.exists(dir.resolve(track.getFileName())))
            {
                return false;
            }
        }
        return true;
    }

    /**
     * Gets a count for how many of the music tracks exist in the given directory
     * */
    private int countExistingTracks(List<MusicTrackOption> tracks, Path dir)
    {
        int count = 0;
        for (MusicTrackOption track : tracks)
        {
            if (Files.exists(dir.resolve(track.getFileName())))
            {
                count++;
            }
        }
        return count;
    }

    /**
     * Finds and schedules the next missing download (lo priority first).
     */
    private void scheduleDownloads(boolean includeHi)
    {

        //run this to try to keep allLoDownloaded and allHiDownloaded accurate
        checkDownloadState();

        //first download all the low quality tracks
        for (MusicTrackOption track : builtinTracks)
        {
            Path loPath = LO_LOCAL_PATH.resolve(track.getFileName());
            if (!Files.exists(loPath))
            {
                queueDownload(track, false);
                return;
            }
        }

        //then if we have all the low quality tracks download high quality tracks
        if (includeHi)
        {
            for (MusicTrackOption track : builtinTracks)
            {
                Path hiPath = HI_LOCAL_PATH.resolve(track.getFileName());
                if (!Files.exists(hiPath))
                {
                    queueDownload(track, true);
                    return;
                }
            }
        }
    }

    /**
     * Schedules a single file download with delay based on quality.
     */
    private void queueDownload(MusicTrackOption track, boolean hi)
    {
        Path targetPath;
        String quality;
        int delayMs;

        if (hi)
        {
            quality = "hi";
            targetPath = HI_LOCAL_PATH.resolve(track.getFileName());
            delayMs = 6 * DELAY_MULTIPLIER;
        }
        else
        {
            quality = "lo";
            targetPath = LO_LOCAL_PATH.resolve(track.getFileName());
            delayMs = DELAY_MULTIPLIER;
        }

        String url = BASE_DOWNLOAD_URL + quality + "/" + track.getFileName();

        scheduler.schedule(() ->
        {
            try
            {
                downloadFile(url, targetPath);
                log.debug("Downloading: {}", track);
            }
            catch (IOException e)
            {
                log.debug("Failed to download {} ({}): {}", track, quality, e.getMessage());
            }

            scheduleDownloads(config.useHighQualityMusic());

        }, delayMs, TimeUnit.MILLISECONDS);
    }

    /**
     * Downloads a single file from GitHub and writes to disk.
     */
    private void downloadFile(String url, Path outputPath) throws IOException
    {
        log.debug("Downloading a file, URL: {} OutputPath: {}",  url, outputPath);

        Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "TickBeats-Plugin")
                .build();

        try (Response response = httpClient.newCall(request).execute())
        {
            if (!response.isSuccessful())
            {
                log.debug("HTTP Request failed: {}",  response.code());
                return;
            }

            if (response.body() == null)
            {
                log.debug("Response body was null for URL: {}", url);
                return;
            }

            Files.createDirectories(outputPath.getParent());

            try (InputStream in = response.body().byteStream())
            {
                Files.copy(in, outputPath, StandardCopyOption.REPLACE_EXISTING);
            }
        }
    }




    /**
     * Ensures background thread shuts down on plugin unload.
     */
    public void shutdown()
    {
        log.debug("Shutting down DownloadManager");

        scheduler.shutdownNow();

    }
}
package com.TickBeatsMetronome;

import javax.sound.sampled.AudioFormat;
import java.util.List;

/**
 * Represents a full music track composed of multiple 600ms beat segments.
 * Tracks are internally structured as a flat list of beats,
 * where every 4 beats form a bar (assuming a 4/4 time signature).
 */
public class MusicTrack
{
    // Name of the track
    private final String fileName;

    // Flat list of MusicBeat objects that make up the full track
    private final List<MusicBeat> beats;

    // Audio format (e.g., 44.1 kHz, 16-bit PCM, stereo) shared across all beats
    private final AudioFormat format;

    // Constant: number of beats in a single bar (e.g., 4 for 4/4 time)
    public static final int BEATS_PER_BAR = 4;

    /**
     * Constructs a new MusicTrack object from the parsed beat list and audio format.
     *
     * @param fileName  The fileName for the track
     * @param beats  A list of MusicBeat segments extracted from the audio
     * @param format The shared audio format for all beats in the track
     */
    public MusicTrack(String fileName, List<MusicBeat> beats, AudioFormat format)
    {
        this.fileName = fileName;
        this.beats = beats;
        this.format = format;
    }

    /** @return The file location of the track */
    public String getFileName() { return fileName; }

    /** @return The list of all beats in the track */
    public List<MusicBeat> getBeats() { return beats; }

    /** @return The audio format of the track */
    public AudioFormat getFormat() { return format; }

    /**
     * @return The total number of full bars in the track.
     */
    public int getNumberBarsInTrack()
    {
        return (int) Math.floor((double) beats.size() / BEATS_PER_BAR);
    }

    /**
     * Retrieves a specific beat based on bar and beat number (both 1-based).
     *
     * @param bar  The 1-based bar number
     * @param beat The 1-based beat number within the bar (must be between 1 and BEATS_PER_BAR)
     * @return The MusicBeat object, or null if the bar/beat index is invalid or out of range
     */
    public MusicBeat getBeat(int bar, int beat)
    {
        // Reject invalid beat numbers (e.g., 0 or > 4)
        if (beat < 1 || beat > BEATS_PER_BAR)
            return null;

        // Convert 1-based bar/beat to a 0-based flat index
        int index = (bar - 1) * BEATS_PER_BAR + (beat - 1);

        // Validate index is within bounds
        if (index >= 0 && index < beats.size())
            return beats.get(index);

        return null;
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.Keybind;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;


/*
 * Listens for hotkey input for adjusting the metronome
 */
@Slf4j
@Singleton
public class InputManager implements net.runelite.client.input.KeyListener
{
    @Inject
    TickBeatsMetronomePlugin plugin;

    @Inject
    TickBeatsMetronomeConfig config;

    //stores if reset key is currently being held down
    public boolean resetActive = false;



    /// KeyPressed KeyEvent returns all the modifier keys (CTRL, ALT, SHIFT etc.) pressed merged together.
    /// if multiple modifier keys are held down including the one you're looking for bitmasks need to be used
    /// to find the key we're looking for from the combined value.
    @Override
    public void keyPressed(KeyEvent e)
    {
        //check if the reset hotkey is being held down
        updateResetKey(e);
    }


    /// keyReleased() seems to only return 1 key as opposed to keyPressed() which returns all keys held merged together,
    /// however .matches(e) doesn't seem to work with modifier and key combos so we use our own custom version
    @Override
    public void keyReleased(KeyEvent e)
    {

        //canceling reset hotkey on any key release feels a little lazy, but logic was causing missed releases
        //especially when using key combinations, in practice this behaves better, but will cancel reset hold if any other
        //keys are released
        resetActive = false;

        //handle hotkey for next beat
        if (strictMatch(config.nextBeatHotkey(), e))
        {
            adjustBeat(1);
            return;
        }

        //handle hotkey for previous beat
        if (strictMatch(config.previousBeatHotkey(), e))
        {
            adjustBeat(-1);
            return;
        }


        //handle add tick hotkey
        if(strictMatch(config.nextTickHotkey(), e))
        {

            adjustTick(1); // Decrease the metronome tick
            return;
        }

        //handle subtract tick hotkey
        if (strictMatch(config.previousTickHotkey(), e))
        {
            adjustTick(-1); // Decrease the metronome tick
        }


    }

    @Override
    public void keyTyped(KeyEvent e)
    {
        // Not used
    }



    private boolean strictMatch(Keybind keybind, KeyEvent e)
    {
        // Case 1: Modifier-only keybind (e.g., Ctrl, Alt)

        // Runelite Keybinds and KeyEvents are made up of 2 numbers, a Key Code Number and a Modifier Number
        // There's a gotcha where when just a modifier key is held by itself (not a modifier key with another key like CTRL+A)
        // the KeyEvent returns a key code number, and not the right modifier number that the RL Keybind is looking for.
        // The RL keybind is looking for just a modifier number but not the one that was returned by the KeyEvent
        // to accurately get the modifier number RL is looking for, we use the key events key code number
        // to figure out what the modifier number should be as far as Runelite is concerned

        // first check if Runelite is looking for a modifier key with no key code, then we know
        // that it's the scenario of a modifier key by itself being used as the Runelite hotkey
        if (keybind.getKeyCode() == 0 && keybind.getModifiers() != 0)
        {
            // Get the modifier number we're looking for from our Runelite keybind
            int requiredModifierNumber = keybind.getModifiers();

            // If the keyboard event key code belongs to a modifier key continue, else it's not a match
            if (isModifierKeyCode(e.getKeyCode()))
            {
                //Use our event keycode to figure out what its modifier key number should be (as far as Runelite is concerned)
                int eventModifierNumber = getModifierNumberFromKeyCode(e.getKeyCode());

                // if our new events modifier number is a match to the modifier our runelite keybind is looking for, return true
                return eventModifierNumber == requiredModifierNumber;
            }

            return false;
        }

        // Case 2: Regular key + optional modifier
        boolean keyMatch = e.getKeyCode() == keybind.getKeyCode();
        // use a bitmask to check if our modifier key is in the modifier keys in the key event
        boolean modifiersMatch = (e.getModifiersEx() & keybind.getModifiers()) == keybind.getModifiers();

        //if both the keycode and the modifiers match return true
        return keyMatch && modifiersMatch;

    }


    ///Check if a keycode is the keycode for a modifier key
    private boolean isModifierKeyCode(int keyCode)
    {
        return keyCode == KeyEvent.VK_SHIFT ||
                keyCode == KeyEvent.VK_CONTROL ||
                keyCode == KeyEvent.VK_ALT ||
                keyCode == KeyEvent.VK_META ||
                keyCode == KeyEvent.VK_ALT_GRAPH;
    }

    //use a keycode number to determine what its modifier number should be (the modifier number Runelite is looking for)
    private int getModifierNumberFromKeyCode(int keyCode)
    {
        switch (keyCode)
        {
            case KeyEvent.VK_SHIFT: return InputEvent.SHIFT_DOWN_MASK;
            case KeyEvent.VK_CONTROL: return InputEvent.CTRL_DOWN_MASK;
            case KeyEvent.VK_ALT: return InputEvent.ALT_DOWN_MASK;
            case KeyEvent.VK_META: return InputEvent.META_DOWN_MASK;
            case KeyEvent.VK_ALT_GRAPH: return InputEvent.ALT_GRAPH_DOWN_MASK;
            default: return 0;
        }
    }

    //check if the reset hotkey is being held down
    public void updateResetKey(KeyEvent e){

        //This check uses bitmasks to work with modifier keys
        if (strictMatch(config.resetHotkey(), e))
        {
            resetActive = true;
            plugin.tickCount = config.startTick();
        } else{
            resetActive = false;
        }

    }

    /**
     * Manually adjust the current tick (via key listener). Wraps correctly based on config.
     * @param delta The amount to add/subtract (e.g., -1 to go back, +1 to go forward)
     */
    private void adjustTick(int delta)
    {

        // Get max ticks based on current beat
        int maxTicks;
        switch (plugin.beatNumber) {
            case 1: maxTicks = config.beat1TickCount(); break;
            case 2: maxTicks = config.beat2TickCount(); break;
            case 3: maxTicks = config.beat3TickCount(); break;
            default: maxTicks = config.beat1TickCount(); break;
        }
        //calculate the plugin tick count using modulo while staying 1 based (not 0 based)
        plugin.tickCount = ((plugin.tickCount - 1 + delta + maxTicks) % maxTicks) + 1;
    }


    /**
     * Manually adjust the current beat number (via key listener). Wraps between 1 and the configured max beat count.
     * @param delta The amount to add/subtract (e.g., -1 to go back, +1 to go forward)
     */
    private void adjustBeat(int delta)
    {
        // Clamp to the user defined beats
        int maxBeats = config.enabledBeats();

        // Update beatNumber using modulo logic to wrap between 1 and maxBeats
        plugin.beatNumber = ((plugin.beatNumber - 1 + delta + maxBeats) % maxBeats) + 1;
    }

}

package com.TickBeatsMetronome;

import javax.inject.Inject;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Singleton;
import java.util.concurrent.*;

/**
 * LocalTickManager tracks tick timing independently though with the help of RuneLite's game tick events,
 * it works by nudging a few milliseconds towards the game tick, every game tick, imperceptibly drifting towards
 * an almost perfect average to determine exactly when server ticks should happen without jitter caused by lag
 * for when a metronome that sounds good and consistent is more important than perfect game ticks that include server lag
 */
@Slf4j
@Singleton
public class LocalTickManager
{
    // Base values
    private static final long BASE_TICK_INTERVAL_MS = 600; // Standard tick duration
    private static final long MAX_ADJUSTMENT_MS = 5;      // Maximum per-tick interval correction in milliseconds

    // Tick counters
    @Getter
    private int gameTickCount = 0;   // Increments each time onGameTick fires
    @Getter
    private int localTickCount = 0;  // Increments each time local tick fires

    // Time tracking
    @Getter
    private long lastLocalTickTime = 0;         // Timestamp of the last local tick
    @Getter
    private long lastGameTickTime = 0;         // Timestamp of the last game tick
    private long nextTickInterval = BASE_TICK_INTERVAL_MS;

    // Executor for scheduling ticks
    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
    private ScheduledFuture<?> tickLoop = null;

    // Logic to run on each local tick
    private final Runnable onTickCallback;

    @Inject
    public LocalTickManager(Runnable onTickCallback)
    {
        this.onTickCallback = onTickCallback;
    }

    /**
     * We use this to make sure our local metronome is relatively in sync with game ticks.
     */
    public void updateLocalTick()
    {

        lastGameTickTime = System.currentTimeMillis();
        gameTickCount++;

        //if local metronome hasn't incremented yet, start it up
        if(localTickCount == 0){
            localTickCount++;
            start();
        }

        //so the tick counts don't count up infinitely, not really needed though
        int gameTickMax = 2000000000;
        if(gameTickCount >= gameTickMax){
            gameTickCount = gameTickCount - gameTickMax;
            localTickCount = localTickCount - gameTickMax;
        }


        //it appears logging in or world hopping can cause an offset of a few hundred ms
        //This is used to allow for a more aggressive tick correction at the start to speed up syncing to game ticks
        long maxAdjustment;
        if(gameTickCount < 10){
            //used to make tick correction less aggressive with each tick
            long multiplier = 10 - gameTickCount;
            maxAdjustment = 10 * multiplier;
        }else{
            maxAdjustment = MAX_ADJUSTMENT_MS;
        }

        // if for some reason ticks get way out of sync make them equal to each other
        int tickDifference = gameTickCount - localTickCount;
        if (tickDifference > 1 || tickDifference < 0){
            localTickCount = gameTickCount;
            log.debug("Correcting out of sync ticks");
        }

        long timeDifference;

        //if gametick is ahead of local tick then the next local tick needs to happen sooner than 600ms else later
        if(gameTickCount > localTickCount)
        {
            //if game tick is before local tick
            //calculate when the next local tick is set to fire using the same logic as the local tick scheduler
            long nextLocalTickTime = lastLocalTickTime + nextTickInterval;

            //get the time difference of how far off the local tick is from this game tick
            //returning a negative, so negative time difference means game tick is earlier positive means local tick is earlier
            timeDifference = lastGameTickTime - nextLocalTickTime;

            //if the time difference between local and game ticks is less than our max adjustment
            //adjust by that much to make things slightly more accurate
            //else subtract our max adjustment from 600ms to get the next tick interval
            if(Math.abs(timeDifference) < maxAdjustment)
            {
                nextTickInterval = BASE_TICK_INTERVAL_MS - Math.abs(timeDifference);
            }else{
                nextTickInterval = BASE_TICK_INTERVAL_MS - maxAdjustment;
            }


        }else{
            //if game tick is after local tick
            //use the tick counts to see how far apart they are
            timeDifference = lastGameTickTime - lastLocalTickTime;

            //if the time difference is less than our max adjustment, adjust by that much to make things slightly more accurate
            if(timeDifference < maxAdjustment)
            {
                nextTickInterval = BASE_TICK_INTERVAL_MS + timeDifference;
            }else{
                nextTickInterval = BASE_TICK_INTERVAL_MS + maxAdjustment;
            }

        }

        /*
        log.debug("GameTick: {}, LocalTick: {}, Tick Difference: {}, Adjusted Interval: {}, Time Difference: {}",
                gameTickCount, localTickCount, tickDifference, nextTickInterval, timeDifference);

         */
    }

    /*
     * Starts the local tick loop.
     * This schedules the first tick after receiving the first GameTick.
     */
    public void start()
    {
        // Don't start twice
        if (tickLoop != null)
        {
            return;
        }

        log.debug("Starting local tick loop.");
        lastLocalTickTime = System.currentTimeMillis();
        scheduleNextTick();
    }

    /*
     * Schedules the next local tick.
     * Each tick reschedules itself with a slightly adjusted interval.
     */
    private void scheduleNextTick()
    {
        tickLoop = executor.schedule(() -> {
            onTickCallback.run();                 // Run local metronome
            lastLocalTickTime = System.currentTimeMillis(); //save the current time
            localTickCount++;                     // Count this local tick

            scheduleNextTick();                   // Schedule the next one

        }, nextTickInterval, TimeUnit.MILLISECONDS); //schedule the next local tick according to our tick interval
    }

    /*
     * Stops the local tick loop and resets all counters/timers.
     * Call on logout or shutdown.
     */
    public void reset()
    {
        log.debug("Resetting local tick manager.");

        stopTickLoop();

        // Reset counters and timing
        gameTickCount = 0;
        localTickCount = 0;
        lastLocalTickTime = 0;
        nextTickInterval = BASE_TICK_INTERVAL_MS;
    }

    /*
     * Cleanly stops any active tick loop.
     */
    private void stopTickLoop()
    {
        if (tickLoop != null)
        {
            tickLoop.cancel(true);
            tickLoop = null;
        }
    }

    /*
     * Completely shuts down the local tick manager and background thread.
     * Call this in plugin's shutDown().
     */
    public void shutdown()
    {
        log.debug("Shutting down local tick manager.");
        reset();
        executor.shutdownNow();
    }
}
package com.TickBeatsMetronome;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;

public class OverlayColor extends Overlay {
    private final Client client;
    private final TickBeatsMetronomePlugin plugin;
    private final TickBeatsMetronomeConfig config;

    @Inject
    private OverlayColor(Client client, TickBeatsMetronomePlugin plugin, TickBeatsMetronomeConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);

    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.enableColorOverlay()) {
            return null;
        }

        // Get the appropriate color and opacity based on the current beat and tick count
        Color tickColor;
        float opacity;
        
        if (plugin.beatNumber == 1) {
            switch (plugin.tickCount) {
                case 1: tickColor = config.beat1Tick1Color(); opacity = config.beat1Tick1Opacity() / 100f; break;
                case 2: tickColor = config.beat1Tick2Color(); opacity = config.beat1Tick2Opacity() / 100f; break;
                case 3: tickColor = config.beat1Tick3Color(); opacity = config.beat1Tick3Opacity() / 100f; break;
                case 4: tickColor = config.beat1Tick4Color(); opacity = config.beat1Tick4Opacity() / 100f; break;
                case 5: tickColor = config.beat1Tick5Color(); opacity = config.beat1Tick5Opacity() / 100f; break;
                case 6: tickColor = config.beat1Tick6Color(); opacity = config.beat1Tick6Opacity() / 100f; break;
                case 7: tickColor = config.beat1Tick7Color(); opacity = config.beat1Tick7Opacity() / 100f; break;
                case 8: tickColor = config.beat1Tick8Color(); opacity = config.beat1Tick8Opacity() / 100f; break;
                case 9: tickColor = config.beat1Tick9Color(); opacity = config.beat1Tick9Opacity() / 100f; break;
                default: tickColor = Color.WHITE; opacity = 0f; break;
            }
        } else if (plugin.beatNumber == 2) {
            switch (plugin.tickCount) {
                case 1: tickColor = config.beat2Tick1Color(); opacity = config.beat2Tick1Opacity() / 100f; break;
                case 2: tickColor = config.beat2Tick2Color(); opacity = config.beat2Tick2Opacity() / 100f; break;
                case 3: tickColor = config.beat2Tick3Color(); opacity = config.beat2Tick3Opacity() / 100f; break;
                case 4: tickColor = config.beat2Tick4Color(); opacity = config.beat2Tick4Opacity() / 100f; break;
                case 5: tickColor = config.beat2Tick5Color(); opacity = config.beat2Tick5Opacity() / 100f; break;
                case 6: tickColor = config.beat2Tick6Color(); opacity = config.beat2Tick6Opacity() / 100f; break;
                case 7: tickColor = config.beat2Tick7Color(); opacity = config.beat2Tick7Opacity() / 100f; break;
                case 8: tickColor = config.beat2Tick8Color(); opacity = config.beat2Tick8Opacity() / 100f; break;
                case 9: tickColor = config.beat2Tick9Color(); opacity = config.beat2Tick9Opacity() / 100f; break;
                default: tickColor = Color.WHITE; opacity = 0f; break;
            }
        } else {
            switch (plugin.tickCount) {
                case 1: tickColor = config.beat3Tick1Color(); opacity = config.beat3Tick1Opacity() / 100f; break;
                case 2: tickColor = config.beat3Tick2Color(); opacity = config.beat3Tick2Opacity() / 100f; break;
                case 3: tickColor = config.beat3Tick3Color(); opacity = config.beat3Tick3Opacity() / 100f; break;
                case 4: tickColor = config.beat3Tick4Color(); opacity = config.beat3Tick4Opacity() / 100f; break;
                case 5: tickColor = config.beat3Tick5Color(); opacity = config.beat3Tick5Opacity() / 100f; break;
                case 6: tickColor = config.beat3Tick6Color(); opacity = config.beat3Tick6Opacity() / 100f; break;
                case 7: tickColor = config.beat3Tick7Color(); opacity = config.beat3Tick7Opacity() / 100f; break;
                case 8: tickColor = config.beat3Tick8Color(); opacity = config.beat3Tick8Opacity() / 100f; break;
                case 9: tickColor = config.beat3Tick9Color(); opacity = config.beat3Tick9Opacity() / 100f; break;
                default: tickColor = Color.WHITE; opacity = 0f; break;
            }
        }

        // Create a new color with the configured opacity
        Color overlayColor = new Color(
            tickColor.getRed(),
            tickColor.getGreen(),
            tickColor.getBlue(),
            Math.round(opacity * 255)
        );

        // Fill the entire canvas with the color
        graphics.setColor(overlayColor);
        graphics.fillRect(0, 0, client.getCanvasWidth(), client.getCanvasHeight());

        return null;
    }
} 
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;

@Slf4j
@Singleton
public class MusicManager
{

    @Inject
    private TickBeatsMetronomeConfig config;

    @Inject
    private MusicTrackLoader musicTrackLoader;
    private MusicTrack currentTrack = null;

    private int volume = 100;
    private int currentBar = 1;
    //bar beat should always be 1 - 4 referencing a beat in the bar
    private int barBeat = 1;
    //current beat that matches the game tick number
    private int tickBeat = 1;
    private boolean isPlaying = false;

    //this is used to play the last beat/notes of the 4 beat per bar songs when doing 3 beats per bar for 3 tick
    private boolean playFinalFourthBeatNext = false;

    private int lastTickCount = 0;

    public boolean isPlaying() { return isPlaying; }


    /**
     * preps the currently selected track to start being played on tick 1 when start is called()
     */
    public void prepMusicTrack()
    {
        // Stop current playback to wait for start() to be called on tick 1 so start of song starts on tick 1
        stop();

        String currentTrackFileName = "";
        if(currentTrack != null){
            currentTrackFileName = currentTrack.getFileName();
        }

        String selectedTrackFileName = "";
        if(config.musicTrack() != null){
            selectedTrackFileName = config.musicTrack().getFileName();
        }

        // Load track if a track has been selected, and it's not the track that's already playing
        if (!selectedTrackFileName.isEmpty() && !selectedTrackFileName.equals(currentTrackFileName))
        {
            loadTrack(selectedTrackFileName);
        }

    }

    /**
     * resets the track and sets isPlaying to true
     * note: the current setup causes this to run every time a track ends
     */
    public void start()
    {
        //run prep the track every time we run start this will make it so if an error track was being played before
        // it'll check again for the proper track every restart
        prepMusicTrack();
        //if current track is null for some reason abort the start (start should try to run again on tick 1)
        if(currentTrack == null){
            return;
        }
        //set isPlaying to true at the start, if loadTrack can't find the track it'll set it to false
        isPlaying = true;

        //reset our bar, beat and tick numbers to 1
        reset();

    }


    /**
     * Get a track based on the track name and get it ready to play
     * @param trackName the tracks filename for local files or number if it's a user track
     */
    private void loadTrack(String trackName)
    {
        // Clear reference to old track, might help gc clean up the old track
        currentTrack = null;

        //when we load up a new track make reset, probobly not necessary to reset again but doesn't hurt
        reset();

        //get the music track based on its track name
        currentTrack = musicTrackLoader.loadFromResource(trackName);

        //if no track is found set isPlaying to false
        if(currentTrack == null){
            stop();
        }


    }



    /**
     * resets the track and sets isPlaying to false
     */
    public void stop()
    {
        reset();
        isPlaying = false;
    }

    /**
     * sets current bar, bar beat, and tick beat to 1 effectively resetting the track
     */
    public void reset()
    {
        currentBar = 1;
        barBeat = 1;
        tickBeat = 1;
    }


    /**
     * Called on every tick (local or game tick depends on plugin settings). Handles advancing music playback.
     * @param tickCount How many ticks per beat the user has configured
     * @param pluginTick Which tick this is within the current beat (1-based)
     * @param musicVolume How loud to play music clips, 100 is full, goes up to 150 for boosted audio
     */
    public void onTick(int tickCount, int pluginTick, int musicVolume) {

        //if for any reason the current track is null, don't do anything
        if(currentTrack == null){
            stop();
            return;
        }
        //set the volume field on every tick
        volume = musicVolume;

        //if the tick from our plugin doesn't match the music manager tick we're using to determine bar beat
        //update the Music Manager tick beat, this happens when the user adjust which tick they're on
        correctMusicManagerTick(tickCount, pluginTick);

        //if play final 4th beat is true (play the last beat/audio clip of the song)
        //songs can feel unfinished without the last note
        if (playFinalFourthBeatNext)
        {
            playBeat(currentTrack.getNumberBarsInTrack(), 4);
            playFinalFourthBeatNext = false;
        }

        // If track has ended or playback is stopped, this should be after play fourth beat check so we don't return before that
        if (!isPlaying || currentTrack.getBeat(currentBar, barBeat) == null)
        {
            stop();
            return;
        }




        // Dispatch logic by tick mode
        switch (tickCount) {
            case 1: handle1Tick(); break;
            case 2: handle2Tick(); break;
            case 3: handle3Tick(); break;
            case 5: handle5Tick(); break;
            case 6: handle6Tick(); break;
            case 7: handle7Tick(); break;
            case 8: handle8Tick(); break;
            case 9: handle9Tick(); break;
            case 4:
            default: handle4Tick(); break;
        }
    }


    /**
     * If the tick from our plugin doesn't match the MusicManager tickBeat Update the Music Manager Tick Beat
     * this happens when the user adjust which beat they're on or makes other plugin adjustments while music is playing
     * @param tickCount How many ticks per beat the user has configured
     * @param pluginTick the current tick as far as the plugin is concerned
     */
    private void correctMusicManagerTick(int tickCount, int pluginTick){
        //tick counts 1 and 2 need special treatment because the plugin tick will only go up to 1 or 2,
        //but we want to play notes 3 and 4 of the bar so tickBeat needs to be able to go up to 3 and 4 without "correcting"

        //if the user has Tick Count set to 1, the Plugin Tick will always be 1, so we don't correct for that just play the music
        if (tickCount == 1){
            return;
        }

        //if Tick Count is set to 2 tick,
        //we want to make sure if plugin tick is 1, our Music Manager tickBeat is 1 or 3
        //and if our plugin tick is 2 our Music Manager tickBeat is set to 2 or 4 to play those parts of the bar
        if (tickCount == 2){

            //if the plugin tick is 1 but the tick beat is 2 or 4, we're out of sync
            if (pluginTick == 1){
                if (tickBeat == 2 || tickBeat == 4) {
                    //set the music manager tick to match the plugin's tick
                    tickBeat = pluginTick;
                }
            }

            //if the plugin tick is 2 but the Music Manager tick beat is 1 or 3, we're out of sync
            if (pluginTick == 2){
                if (tickBeat == 1 || tickBeat == 3) {
                    //set the music manager tick to match the plugin's tick
                    tickBeat = pluginTick;
                }
            }

            return;
        }

        //In all other scenarios the music manager Tick Beat and the Plugin Tick should match
        if(pluginTick != tickBeat){
            tickBeat = pluginTick;
        }

    }

    // -- Tick Handlers --

    //1 tick plays 4 beat per bar music as is
    private void handle1Tick()
    {
        barBeat = tickBeat;

        playBeat(currentBar, barBeat);

        tickBeat++;

        if (tickBeat >= 5) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //2 tick plays 4 beat per bar music as is
    private void handle2Tick()
    {
        barBeat = tickBeat;

        playBeat(currentBar, barBeat);
        tickBeat++;
        if (tickBeat >= 5) {
            tickBeat = 1;
            currentBar++;
        }
    }

    /// 3 tick will play the music with a 3/4 time signature / 3 beats per bar by removing the last beat from each bar
    private void handle3Tick()
    {
        barBeat = tickBeat;

        // If we're on the final bar, queue up beat 4 for next tick to play the last notes / beat in the song
        // Songs often feel unsatisfying or incomplete without the last note.
        if (currentTrack.getNumberBarsInTrack() == currentBar && barBeat >= 3)
        {
            playFinalFourthBeatNext = true;
        }

        playBeat(currentBar, barBeat);
        tickBeat++;

        // 3-tick loop
        if (tickBeat >= 4)
        {
            tickBeat = 1;
            currentBar++;
        }
    }

    //Songs are currently required to have a 4/4 time signature so they work very well with 4 tick
    private void handle4Tick()
    {
        barBeat = tickBeat;

        playBeat(currentBar, barBeat);
        tickBeat++;
        if (tickBeat >= 5) {
            tickBeat = 1;
            currentBar++;
        }
    }


    //5 tick replays the last note of the bar (not ideal but sounds ok most of the time)
    private void handle5Tick()
    {
        barBeat = tickBeat;


        //replay the last note of the bar on beat 5
        if (tickBeat == 5){
            barBeat = 4;
        }

        playBeat(currentBar, barBeat);

        tickBeat++;

        if (tickBeat >= 6) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //6 tick will play 2 3 beat bars, removing the last note from each bar
    private void handle6Tick()
    {
        barBeat = tickBeat;

        //if tickBeat >=4 we advanced to the next bar of music
        //subtract 3 from tickBeat to get the proper beat from this bar
        if(tickBeat >= 4){
            barBeat = tickBeat - 3;
        }

        // If we're on the final bar, queue up beat 4 for next tick to play the last notes / beat in the song
        // Songs often feel unsatisfying or incomplete without the last note.
        if (currentTrack.getNumberBarsInTrack() == currentBar && barBeat >= 3)
        {
            playFinalFourthBeatNext = true;
        }

        playBeat(currentBar, barBeat);
        tickBeat++;

        //because we're using 3/4 for 6 tick, when we hit beat 4 move to the next bar in the music
        if(tickBeat == 4){
            currentBar++;
        }

        //once tick beat hits 7, reset tickBeat and move on to the next bar
        if (tickBeat >= 7) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //7 tick will remove the last beat on every other bar so will play alternating 4 beat bars and 3 beat bars
    private void handle7Tick()
    {
        barBeat = tickBeat;

        //if we're >=5 we advanced to the next bar of music
        //subtract 4 to get the proper beat from this bar
        if(tickBeat >= 5){
            barBeat = tickBeat - 4;
        }

        // If we're on the final bar, and only if tick beat is set to 7 queue up the 4th note
        // we only want to queue up the 4th note if we're on the 3/4 second bar
        if (currentTrack.getNumberBarsInTrack() == currentBar && tickBeat == 7)
        {
            playFinalFourthBeatNext = true;
        }

        playBeat(currentBar, barBeat);
        tickBeat++;

        //when we hit beat 5 move to the next bar in the music
        if(tickBeat == 5){
            currentBar++;
        }

        if (tickBeat >= 8) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //8 tick will play 2 regular 4 beat bars
    private void handle8Tick()
    {
        barBeat = tickBeat;

        //if we're >=5 we advanced to the next bar of music
        //subtract 4 to get the proper beat from this bar
        if(tickBeat >= 5){
            barBeat = tickBeat - 4;
        }

        playBeat(currentBar, barBeat);
        tickBeat++;

        //when we hit beat 5 move to the next bar in the music
        //important Make sure this is after playBeat so we don't try to play a bar that doesn't exist
        if(tickBeat == 5){
            currentBar++;
        }

        if (tickBeat >= 9) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //9 tick will play 3 3 beat bars, removing the last beat from every bar of music
    private void handle9Tick()
    {
        barBeat = tickBeat;

        //if the tick beat is 4 or greater it means we're on the next 3/4 bar so remove 3 to get the beat in the bar
        if(tickBeat >= 4){
            barBeat = barBeat - 3;
        }

        //if the tick beat is 7 or greater it means we're 2 3/4 bars in, so remove another 3 to get the beat in the bar
        if(tickBeat >= 7){
            barBeat = barBeat - 3;
        }

        // If we're on the final note of the final bar queue up the final note of the song to play on the next bar
        if (currentTrack.getNumberBarsInTrack() == currentBar && barBeat == 3)
        {
            playFinalFourthBeatNext = true;
        }

        playBeat(currentBar, barBeat);

        tickBeat++;

        //if after playing and incrementing the beat we're on beat 4 or 7 , move on to the next bar
        if(tickBeat == 4 || tickBeat == 7){
            currentBar++;
        }

        //once tick beat hits 10, reset tickBeat to 1 and move on to the next bar
        if (tickBeat >= 10) {
            tickBeat = 1;
            currentBar++;
        }
    }


    /**
     * Plays a 600ms audio clip for a specific bar and beat.
     * Uses Java's AudioSystem to load a new Clip and play it.
     * Ensures that Clips are always cleaned up to prevent memory leaks,
     * even in the case of playback failure.
     *
     * @param bar  the bar number in the track (1-based)
     * @param beat the beat number in the bar (1-based, typically 1â€“4)
     */
    public void playBeat(int bar, int beat)
    {
        // Defensive check: make sure a track is loaded
        if (currentTrack == null)
        {
            log.debug("No track loaded.");
            return;
        }

        // Retrieve the audio data for the requested bar and beat
        MusicBeat musicBeat = currentTrack.getBeat(bar, beat);
        if (musicBeat == null)
        {
            log.debug("Invalid beat requested: bar={} beat={}", bar, beat);
            return;
        }

        try
        {
            // Fetch audio format and raw beat data (PCM bytes)
            AudioFormat format = currentTrack.getFormat();
            byte[] data = musicBeat.getAudioData();

            // Create a new Clip from the AudioSystem
            Clip clip = AudioSystem.getClip();

            // Load the audio data into the clip
            clip.open(format, data, 0, data.length);

            // Apply current volume settings
            setClipVolume(clip);

            // Register a listener to automatically close the clip after playback finishes
            clip.addLineListener(event -> {
                if (event.getType() == LineEvent.Type.STOP)
                {
                    clip.close(); // Clean up clip
                }
            });

            // Start playback (non-blocking)
            clip.start();
        }
        catch (Exception e)
        {
            log.debug("Failed to play beat at bar {} beat {}: {}", bar, beat, e.getMessage(), e);
        }
    }

    /**
     * Converts the plugin's volume percentage to decibels and sets it on the given audio clip
     * The volume percentage is stored in the `volume` field (0â€“150),
     * where 100 is standard volume and 150 is boosted.
     *
     * @param clip the Clip to apply volume adjustments to
     */
    private void setClipVolume(Clip clip)
    {
        // Check if the clip supports master gain control (volume)
        // if not return
        if (!clip.isControlSupported(FloatControl.Type.MASTER_GAIN))
        {
            return;
        }

        FloatControl volumeControl = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);

        double dB;

        // Avoid log10(0) (log10 shouldn't be 0 or negative) and handle 0 volume
        if (volume <= 0)
        {
            dB = volumeControl.getMinimum();
        }
        else
        {
            // Convert percentage to a volume ratio (0.0â€“1.0)
            float volumePercent = volume / 100f;

            // Convert to decibels using a log scale
            dB = Math.log10(volumePercent) * 20.0;
        }

        // Clamp volume to the supported dB range
        float minDb = volumeControl.getMinimum();
        float maxDb = volumeControl.getMaximum();

        if (dB < minDb)
        {
            dB = minDb;
        }
        else if (dB > maxDb)
        {
            dB = maxDb;
        }

        // Apply the decibel volume to the clip
        volumeControl.setValue((float) dB);
    }

}
package com.TickBeatsMetronome;

public enum TickSoundOption
{
    OFF("Off", ""),
    TICK("Tick", "tick.wav"),
    TICK_HIHAT("Tick Hi-Hat", "tick-hihat.wav"),
    TICK_HIHAT_2("Tick Hi-Hat 2", "tick-hihat-2.wav"),

    METRO_TICK("Metro Tick", "metro-tick.wav"),
    METRO_TICK_2("Metro Tick Strong", "metro-tick-strong.wav"),
    METRO_TOCK("Metro Tock", "metro-tock.wav"),

    BASS("Bass", "bass.wav"),
    BASS_2("Bass 2", "bass-2.wav"),
    BASS_3("Bass 3", "bass-3.wav"),
    BASS_ELECTRONIC("Bass Electronic", "bass-electronic.wav"),
    BASS_ELECTRONIC_2("Bass Electronic 2", "bass-electronic-2.wav"),
    BASS_ELECTRONIC_3("Bass Electronic 3", "bass-electronic-3.wav"),
    BASS_ELECTRONIC_4("Bass Electronic 4", "bass-electronic-4.wav"),
    BASS_ELECTRONIC_5("Bass Electronic 5", "bass-electronic-5.wav"),
    BASS_ELECTRONIC_6("Bass Electronic 6", "bass-electronic-6.wav"),

    CLAP("Clap", "clap.wav"),
    CLAP_2("Clap 2", "clap-2.wav"),
    CLAP_3("Clap 3", "clap-3.wav"),
    CLAP_SLAP("Clap Slap", "clap-slap.wav"),

    SNARE("Snare", "snare.wav"),
    SNARE_2("Snare 2", "snare-2.wav"),
    SNARE_3("Snare 3", "snare-3.wav"),

    CRACK_HIGH("Crack High", "crack-high.wav"),
    CRACK_LOW("Crack Low", "crack-low.wav"),

    X2_TICK("X2 Tick", "x2-tick.wav"),
    X2_BASS("X2 Bass", "x2-bass.wav"),
    X2_CLAP("X2 Clap", "x2-clap.wav"),

    // User Sounds
    USER_SOUND_1("User Sound 1", "1"),
    USER_SOUND_2("User Sound 2", "2"),
    USER_SOUND_3("User Sound 3", "3"),
    USER_SOUND_4("User Sound 4", "4"),
    USER_SOUND_5("User Sound 5", "5"),
    USER_SOUND_6("User Sound 6", "6"),
    USER_SOUND_7("User Sound 7", "7"),
    USER_SOUND_8("User Sound 8", "8"),
    USER_SOUND_9("User Sound 9", "9"),
    USER_SOUND_10("User Sound 10", "10"),
    USER_SOUND_11("User Sound 11", "11"),
    USER_SOUND_12("User Sound 12", "12"),
    USER_SOUND_13("User Sound 13", "13"),
    USER_SOUND_14("User Sound 14", "14"),
    USER_SOUND_15("User Sound 15", "15"),
    USER_SOUND_16("User Sound 16", "16"),
    USER_SOUND_17("User Sound 17", "17"),
    USER_SOUND_18("User Sound 18", "18"),
    USER_SOUND_19("User Sound 19", "19"),
    USER_SOUND_20("User Sound 20", "20");

    private final String displayName;
    private final String resourceName;

    TickSoundOption(String displayName, String resourceName)
    {
        this.displayName = displayName;
        this.resourceName = resourceName;
    }

    public String getFileName()
    {
        return resourceName;
    }

    @Override
    public String toString()
    {
        return displayName;
    }
}


package com.TickBeatsMetronome;

public enum MusicTrackOption {

    ALLS_FAIRY_IN_LOVE_AND_WAR("Alls Fairy In Love And War", "alls_fairy_in_love_and_war.wav"),
    AMASCUTS_PROMISE("Amascut's Promise", "amascuts_promise.wav"),
    ANGELS_FURY("Angels Fury", "angels_fury.wav"),
    AUTUMN_VOYAGE("Autumn Voyage", "autumn_voyage.wav"),
    BOOK_OF_SPELLS("Book Of Spells", "book_of_spells.wav"),
    FIRE_IN_THE_DEEP("Fire In The Deep", "fire_in_the_deep.wav"),
    FIRE_IN_THE_HOLE("Fire In The Hole !", "fire_in_the_hole.wav"),
    FLUTE_SALAD("Flute Salad", "flute_salad.wav"),
    GAUNTLET("Gauntlet", "gauntlet.wav"),
    HOME_SWEET_HOME("Home Sweet Home", "home_sweet_home.wav"),
    HORIZON("Horizon", "horizon.wav"),
    INFERNO("Inferno", "inferno.wav"),
    INTO_THE_TOMBS("Into The Tombs", "into_the_tombs.wav"),
    ISLE_OF_SERENITY("Isle Of Serenity", "isle_of_serenity.wav"),
    MOR_UL_REK("Mor Ul Rek", "mor_ul_rek.wav"),
    POWER_OF_THE_SHADOW_REALM("Power Of The Shadow Realm", "power_of_the_shadow_realm.wav"),
    PREDATOR_XARPUS("Predator Xarpus", "predator_xarpus.wav"),
    PROSPERING_FORTUNE("Prospering Fortune", "prospering_fortune.wav"),
    SCAPE_SOFT("Scape Soft", "scape_soft.wav"),
    SEA_SHANTY_2("Sea Shanty 2", "sea_shanty_2.wav"),
    SPIRIT("Spirit", "spirit.wav"),
    TRADE_PARADE("Trade Parade", "trade_parade.wav"),
    WALK_IN_THE_WOODS("Walk In The Woods", "walk_in_the_woods.wav"),
    WATCH_YOUR_STEP("Watch Your Step", "watch_your_step.wav"),
    WELCOME_TO_THE_THEATRE("Welcome To The Theatre", "welcome_to_the_theatre.wav"),


    // User Music
    // The Music files are given IDs based on their alphabetical order.
    USER_MUSIC_1("User Track 1", "1"),
    USER_MUSIC_2("User Track 2", "2"),
    USER_MUSIC_3("User Track 3", "3"),
    USER_MUSIC_4("User Track 4", "4"),
    USER_MUSIC_5("User Track 5", "5"),
    USER_MUSIC_6("User Track 6", "6"),
    USER_MUSIC_7("User Track 7", "7"),
    USER_MUSIC_8("User Track 8", "8"),
    USER_MUSIC_9("User Track 9", "9"),
    USER_MUSIC_10("User Track 10", "10"),
    USER_MUSIC_11("User Track 11", "11"),
    USER_MUSIC_12("User Track 12", "12"),
    USER_MUSIC_13("User Track 13", "13"),
    USER_MUSIC_14("User Track 14", "14"),
    USER_MUSIC_15("User Track 15", "15"),
    USER_MUSIC_16("User Track 16", "16"),
    USER_MUSIC_17("User Track 17", "17"),
    USER_MUSIC_18("User Track 18", "18"),
    USER_MUSIC_19("User Track 19", "19"),
    USER_MUSIC_20("User Track 20", "20"),
    USER_MUSIC_21("User Track 21", "21"),
    USER_MUSIC_22("User Track 22", "22"),
    USER_MUSIC_23("User Track 23", "23"),
    USER_MUSIC_24("User Track 24", "24"),
    USER_MUSIC_25("User Track 25", "25"),
    USER_MUSIC_26("User Track 26", "26"),
    USER_MUSIC_27("User Track 27", "27"),
    USER_MUSIC_28("User Track 28", "28"),
    USER_MUSIC_29("User Track 29", "29"),
    USER_MUSIC_30("User Track 30", "30"),
    USER_MUSIC_31("User Track 31", "31"),
    USER_MUSIC_32("User Track 32", "32"),
    USER_MUSIC_33("User Track 33", "33"),
    USER_MUSIC_34("User Track 34", "34"),
    USER_MUSIC_35("User Track 35", "35"),
    USER_MUSIC_36("User Track 36", "36"),
    USER_MUSIC_37("User Track 37", "37"),
    USER_MUSIC_38("User Track 38", "38"),
    USER_MUSIC_39("User Track 39", "39"),
    USER_MUSIC_40("User Track 40", "40"),
    USER_MUSIC_41("User Track 41", "41"),
    USER_MUSIC_42("User Track 42", "42"),
    USER_MUSIC_43("User Track 43", "43"),
    USER_MUSIC_44("User Track 44", "44"),
    USER_MUSIC_45("User Track 45", "45"),
    USER_MUSIC_46("User Track 46", "46"),
    USER_MUSIC_47("User Track 47", "47"),
    USER_MUSIC_48("User Track 48", "48"),
    USER_MUSIC_49("User Track 49", "49"),
    USER_MUSIC_50("User Track 50", "50");

    private final String displayName;
    private final String fileName;

    MusicTrackOption(String displayName, String fileName) {
        this.displayName = displayName;
        this.fileName = fileName;
    }

    public String getFileName() {
        return fileName;
    }


    @Override
    public String toString() {
        return displayName;
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Slf4j
@Singleton
public class OverlayInfoBox extends Overlay
{
    @Inject
    TickBeatsMetronomePlugin plugin;

    @Inject
    TickBeatsMetronomeConfig config;

    @Inject
    DownloadManager downloadManager;

    private final PanelComponent panel = new PanelComponent();

    @Inject
    public OverlayInfoBox()
    {

        // Users can drag overlays with these positions.
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // only show this info box if the setting is enabled by the user
        if (!config.showInfoBox()) return null;


        panel.getChildren().clear();

        panel.getChildren().add(TitleComponent.builder()
                .text("Tick Beats")
                .color(Color.green)
                .build());

        panel.getChildren().add(LineComponent.builder()
                .left("Beat:")
                .right(plugin.beatNumber + " / " + config.enabledBeats())
                .build());

        panel.getChildren().add(LineComponent.builder()
                .left("Tick:")
                .right(plugin.tickCount + " / " + plugin.maxTicks)
                .build());

        panel.setPreferredSize(new Dimension(125, 0));


        // --- Download progress ---
        final int totalBuiltinTracksCount = downloadManager.getTotalBuiltinCount();

        //only display download status for low quality tracks if all low downloads aren't done yet
        if(!downloadManager.isAllLoDownloaded() && totalBuiltinTracksCount > 0){

            panel.setPreferredSize(new Dimension(200, 0));

            panel.getChildren().add(LineComponent.builder()
                    .left("Downloading Music...")
                    .right( downloadManager.getDownloadedCountLo() + " / " + totalBuiltinTracksCount)
                    .build());
        }

        //if the user wants to use hi quality music and all the high quality music tracks aren't downloaded yet
        if(config.useHighQualityMusic() && !downloadManager.isAllHiDownloaded() && totalBuiltinTracksCount > 0){
            panel.setPreferredSize(new Dimension(250, 0));
            panel.getChildren().add(LineComponent.builder()
                    .left("Downloading High Quality Music...")
                    .right(downloadManager.getDownloadedCountHi() + " / " + totalBuiltinTracksCount)
                    .build());
        }



        return panel.render(graphics);
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@Singleton
public class MusicTrackLoader
{

    @Inject
    private TickBeatsMetronomeConfig config;

    @Inject
    UserMusicManager userMusicManager;

    @Inject
    OverlayMessage overlayMessage;




    private static final float BEAT_DURATION_SECONDS = 0.6f;

    private String musicFileName = "";

    /**
     * Loads a music track either from embedded plugin resources or from user-supplied files.
     * The track is split into 600ms segments.
     *
     * @param trackName The name or ID of the track to load.
     *                  - For built-in tracks, this is the WAV filename (e.g., "sea_shanty_2.wav").
     *                  - For user music, this is a stringified number key (e.g., "1", "2", "3", etc.).
     * @return A MusicTrack object containing the parsed beats and audio format, or null if the track is missing.
     */
    public MusicTrack loadFromResource(String trackName)
    {
        // Try to get an AudioInputStream for either a user track or downloaded track
        try (AudioInputStream stream = getAudioStream(trackName))
        {
            // If the track couldn't be loaded (not found, unreadable, etc.), skip loading.
            if (stream == null)
            {
                log.debug("Track '{}' could not be loaded (stream was null). Skipping load.", trackName);
                return null;
            }

            // Get audio format info (e.g., sample rate, bit depth, channels)
            AudioFormat format = stream.getFormat();


            //make sure .wav file is 16-bit
            int sampleSize = format.getSampleSizeInBits();
            if(sampleSize != 16){

                //if the track name is a number it's a user track
                if (trackName.matches("\\d+"))
                {
                    //if it's a user track show the user where the file that is the wrong sample size is located
                    String trackLocation = userMusicManager.getUserMusicMap().get(trackName).getAbsolutePath();
                    overlayMessage.show( "User Music Track " + trackName + " is a " + sampleSize + "-bit .wav file but must be 16-bit",
                            trackLocation);

                }else{
                    //if the user modifies a downloaded .wav file, this could fire on what's supposed to be a built-in track
                    overlayMessage.show(  trackName + " isn't 16-bit, Files in the tick-beats/downloads folder aren't meant to be modified",
                             "Delete: " + trackName + " from the hi and lo folder to redownload");
                }
                return null;
            }



            // Calculate audio segment (beat) size in bytes based on duration and format
            int frameSize = format.getFrameSize();                  // e.g., 4 bytes for 16-bit stereo
            float frameRate = format.getFrameRate();                // e.g., 44100 Hz
            int framesPerBeat = (int)(frameRate * BEAT_DURATION_SECONDS);  // e.g., 44100 * 0.6 = 26460 frames per beat
            int bytesPerBeat = framesPerBeat * frameSize;           // e.g., 26460 * 4 = 105840 bytes per beat

            // Read the entire audio file into memory
            byte[] fullAudio = stream.readAllBytes();
            int totalBeats = fullAudio.length / bytesPerBeat;       // Determine how many full 600ms beats exist

            // List to store beat objects for this track
            List<MusicBeat> beatList = new ArrayList<>();

            // Iterate through each full beat segment and extract audio data for it
            for (int i = 0; i < totalBeats; i++)
            {
                int start = i * bytesPerBeat;
                int end = Math.min(start + bytesPerBeat, fullAudio.length); // Handle potential edge cases at end of track
                byte[] beatData = new byte[end - start];

                // Copy just the data for this beat
                System.arraycopy(fullAudio, start, beatData, 0, beatData.length);

                // Calculate the musical bar and beat position (1-based indexing)
                int barNumber = (i / MusicTrack.BEATS_PER_BAR) + 1;
                int beatNumber = (i % MusicTrack.BEATS_PER_BAR) + 1;

                // Add the beat to our list
                beatList.add(new MusicBeat(barNumber, beatNumber, beatData));
            }

            // Remove any leftover partial bar at the end (e.g., trailing silence)
            beatList = trimIncompleteBar(beatList);


            // Package everything into a MusicTrack object
            return new MusicTrack(musicFileName, beatList, format);
        }
        catch (Exception e)
        {
            // Wrap any loading/parsing exceptions with more context
            throw new RuntimeException("Failed to load track: " + trackName, e);
        }
    }


    /**
     * Gets an AudioInputStream from user music directory or downloaded resource.
     * determines if the track is a downloaded track or a user file, then gets its audioInputStream
     * @param trackName used to determine which track to create the audio stream for,
     *                  - For downloaded tracks, this is the WAV filename (e.g., "sea_shanty_2.wav").
     *                  - For user music, this is a stringified number key (e.g., "1", "2", "3", etc.).
     * @return returns the AudioInputStream for the track
     */
    public AudioInputStream getAudioStream(String trackName)
    {
        try
        {
            // Check if this is a user track (digit string like "1", "2", etc.)
            if (trackName.matches("\\d+"))
            {
                //Not really needed, but make the variable name more accurate
                String trackNumber = trackName;

                //get the user file based on its track id number
                File userFile = userMusicManager.getUserMusicMap().get(trackNumber);
                if (userFile != null && userFile.exists())
                {
                    //Store music file name to be used when we create the music track object
                    musicFileName = trackNumber;
                    return AudioSystem.getAudioInputStream(userFile);
                }
                String titleMessage ="User Music Track " + trackNumber + " Not Found. Save 16-bit .wav files to:";
                String tickBeatsMusicFolder = Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath(), "tick-beats", "music").toString();
                overlayMessage.show(titleMessage, tickBeatsMusicFolder);


            }
            else
            {
                // If it's not a user track, first check high-quality folder if the user has use high quality music checked
                Path hiPath = Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath(), "tick-beats", "downloads", "hi", trackName);
                if (Files.exists(hiPath) && config.useHighQualityMusic())
                {
                    //Store music file name to be used when we create the music track object
                    musicFileName = trackName;
                    return AudioSystem.getAudioInputStream(hiPath.toFile());
                }

                // now check low-quality folder
                Path loPath = Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath(), "tick-beats", "downloads", "lo", trackName);
                if (Files.exists(loPath))
                {
                    //Store music file name to be used when we create the music track object
                    musicFileName = trackName;
                    return AudioSystem.getAudioInputStream(loPath.toFile());
                }

                //if the file isn't found in either folder, display the track hasn't been downloaded yet message
                overlayMessage.show("This Track Hasn't Been Downloaded Yet", "Try a track higher up in the list");

            }

            return null;
        }
        catch (Exception e)
        {
            log.debug("Failed to load audio stream for '{}': {}", trackName, e.getMessage());
            return null;
        }
    }

    /**
     * Removes trailing incomplete bar from the beat list if it exists.
     */
    private List<MusicBeat> trimIncompleteBar(List<MusicBeat> beats)
    {
        int totalBeats = beats.size();
        int remainder = totalBeats % MusicTrack.BEATS_PER_BAR;

        if (remainder == 0)
        {
            return beats;
        }

        for (int i = 0; i < remainder; i++)
        {
            beats.remove(beats.size() - 1);
        }

        return beats;
    }

}
package com.TickBeatsMetronome;

public class MusicBeat
{
    private final int barIndex;
    private final int beatIndex;
    private final byte[] audioData;

    public MusicBeat(int barIndex, int beatIndex, byte[] audioData)
    {
        this.barIndex = barIndex;
        this.beatIndex = beatIndex;
        this.audioData = audioData;
    }

    public int getBarIndex() { return barIndex; }
    public int getBeatIndex() { return beatIndex; }
    public byte[] getAudioData() { return audioData; }

    // Optional: for debugging/logging
    @Override
    public String toString()
    {
        return "MusicBeat{bar=" + barIndex + ", beat=" + beatIndex + "}";
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.File;
import java.nio.file.Paths;
import java.util.Map;

import net.runelite.client.RuneLite;
import net.runelite.client.audio.AudioPlayer;


/*
 * This Class is used to determine which sounds are played
 */
@Slf4j
@Singleton
public class SoundManager {

    @Inject
    TickBeatsMetronomeConfig config;

    @Inject
    private AudioPlayer audioPlayer;

    @Inject
    UserSoundManager userSoundManager;

    @Inject
    OverlayMessage overlayMessage;




    /**
     * Determines which tick to play on which beat
     */
    public void playSound(int beatNumber, int tickCount)
    {
        switch (beatNumber)
        {
            case 1: playBeat1(tickCount); break;
            case 2: playBeat2(tickCount); break;
            case 3: playBeat3(tickCount); break;
            default: playBeat1(tickCount); break;
        }
    }

    /**
     * Plays the configured sound for the given tick using the DEFAULT set
     */
    private void playBeat1(int tickCount)
    {
        TickSoundOption soundOption;

        switch (tickCount)
        {
            case 1: soundOption = config.beat1Tick1Sound(); break;
            case 2: soundOption = config.beat1Tick2Sound(); break;
            case 3: soundOption = config.beat1Tick3Sound(); break;
            case 4: soundOption = config.beat1Tick4Sound(); break;
            case 5: soundOption = config.beat1Tick5Sound(); break;
            case 6: soundOption = config.beat1Tick6Sound(); break;
            case 7: soundOption = config.beat1Tick7Sound(); break;
            case 8: soundOption = config.beat1Tick8Sound(); break;
            case 9: soundOption = config.beat1Tick9Sound(); break;
            default: soundOption = TickSoundOption.OFF; break;
        }

        if (soundOption != TickSoundOption.OFF)
        {
            play(soundOption.getFileName());
        }
    }

    /**
     * Plays the configured sound for the given tick (1â€“10) using the ALTERNATE set
     */
    private void playBeat2(int tickCount)
    {
        TickSoundOption soundOption;

        switch (tickCount)
        {
            case 1: soundOption = config.beat2Tick1Sound(); break;
            case 2: soundOption = config.beat2Tick2Sound(); break;
            case 3: soundOption = config.beat2Tick3Sound(); break;
            case 4: soundOption = config.beat2Tick4Sound(); break;
            case 5: soundOption = config.beat2Tick5Sound(); break;
            case 6: soundOption = config.beat2Tick6Sound(); break;
            case 7: soundOption = config.beat2Tick7Sound(); break;
            case 8: soundOption = config.beat2Tick8Sound(); break;
            case 9: soundOption = config.beat2Tick9Sound(); break;
            default: soundOption = TickSoundOption.OFF; break;
        }

        if (soundOption != TickSoundOption.OFF)
        {
            play(soundOption.getFileName());
        }
    }

    /**
     * Plays the configured sound for the given tick (1â€“10) using the third set
     */
    private void playBeat3(int tickCount)
    {
        TickSoundOption soundOption;

        switch (tickCount)
        {
            case 1: soundOption = config.beat3Tick1Sound(); break;
            case 2: soundOption = config.beat3Tick2Sound(); break;
            case 3: soundOption = config.beat3Tick3Sound(); break;
            case 4: soundOption = config.beat3Tick4Sound(); break;
            case 5: soundOption = config.beat3Tick5Sound(); break;
            case 6: soundOption = config.beat3Tick6Sound(); break;
            case 7: soundOption = config.beat3Tick7Sound(); break;
            case 8: soundOption = config.beat3Tick8Sound(); break;
            case 9: soundOption = config.beat3Tick9Sound(); break;
            default: soundOption = TickSoundOption.OFF; break;
        }

        if (soundOption != TickSoundOption.OFF)
        {
            play(soundOption.getFileName());
        }
    }




    /**
     * Plays a sound using its key (from TickSoundOption or user file ID).
     *
     * @param fileIdentifier TickSoundOption name or user file ID (e.g., "tick-hihat.wav" or "1") found in TickSoundOptions
     */
    public void play(String fileIdentifier)
    {


        //get the key and normalize it to lowercase for better matching
        //I've changed things a bit since implementing, I'm not certain this is still necessary
        String normalizedKey = fileIdentifier.toLowerCase();


        // Check if file identifier is a stringified int, if it is, we're looking for a user supplied sound
        if (fileIdentifier.matches("\\d+")){

            //get the user sound map
            Map<String, File> userSoundMap = userSoundManager.getUserSoundMap();

            //if our file identifier is greater than the size of our sound map, then no wav file exists for that sound
            //display a message and return
            if(Integer.parseInt(fileIdentifier) > userSoundMap.size()){

                String titleMessage ="No User Sound " + fileIdentifier + ". Save sounds as 16-bit .wav files to:";

                String tickBeatsSoundsFolder = Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath(), "tick-beats", "sounds").toString();
                overlayMessage.show(titleMessage, tickBeatsSoundsFolder);

                return;

            }

            File userFile = userSoundMap.get(normalizedKey);

            if (userFile.exists()) {
                try {
                    audioPlayer.play(userFile, 1.0f);
                } catch (Exception e) {
                    String titleMessage = "Couldn't play: " + userFile.getAbsolutePath();
                    overlayMessage.show(titleMessage, "Make sure it's a 16-bit PCM .wav file");

                    log.debug("Failed to play user sound '{}': {}", normalizedKey, e.getMessage());
                }
                return;
            }

        }




        // Otherwise, try to play a built-in resource
        String resourcePath = "/com/TickBeatsMetronome/Sounds/" + normalizedKey;
        try
        {
            audioPlayer.play(getClass(), resourcePath, 1.0f);
        }
        catch (Exception e)
        {
            log.debug("Failed to play sound '{}': {}", normalizedKey, e.getMessage());
        }
    }

}

package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Slf4j
@Singleton
public class OverlayMessage extends Overlay
{
    @Inject private Client client;

    private String text = null;
    private String subText = null;
    private Color baseColor = Color.YELLOW;
    private int distanceFromTop = 100;
    private long startMs = 0L;
    private int holdMs = 2000;   // visible at full alpha
    private int fadeMs = 3000;    // fade-out duration
    private int subtextYOffset = 30; //how far below should the sub message be

    @Inject
    public OverlayMessage()
    {
        // Weâ€™ll draw at exact canvas coords, so use DYNAMIC + ABOVE_SCENE.
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    /**
     * Show a message with default settings
     */
    public void show(String message, String subMessage)
    {
        show(message, subMessage, baseColor, holdMs, fadeMs);
    }

    /**
     * Show a message with custom color/durations.
     */
    public void show(String message, String subMessage, Color color, int holdDurationMs, int fadeDurationMs)
    {
        this.text = message;
        this.subText = subMessage;
        this.baseColor = color;
        this.holdMs = Math.max(0, holdDurationMs);
        this.fadeMs = Math.max(1, fadeDurationMs);
        this.startMs = System.currentTimeMillis();
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        final String message = text;
        final String subMessage = subText;
        if (message == null) return null;

        long elapsed = System.currentTimeMillis() - startMs;
        if (elapsed > holdMs + fadeMs)
        {
            // Done â€“ clear message
            text = null;
            return null;
        }

        // Compute alpha: 1.0 during hold, then linear fade to 0
        float alpha = 1f;
        if (elapsed > holdMs) {
            float fadeProgress = (elapsed - holdMs) / (float) fadeMs; // 0..1
            alpha = 1f - fadeProgress;
        }

        // Prepare a clean graphics context to make sure we don't interfere with other overlay graphics settings
        Graphics2D graphics2 = (Graphics2D) graphics.create();
        try
        {
            // Big, readable font (RuneLite bold), centered near top
            Font font = FontManager.getRunescapeBoldFont().deriveFont(Font.BOLD, 24f);
            graphics2.setFont(font);

            // Center horizontally
            int canvasWidth = client.getCanvasWidth();
            int y = distanceFromTop; // how far down from the top to display the message

            FontMetrics fm = graphics2.getFontMetrics(font);

            int textWidth = fm.stringWidth(message);
            int x = (canvasWidth - textWidth) / 2;

            int text2Width = fm.stringWidth(subMessage);
            int x2 = (canvasWidth - text2Width) / 2;

            //if client is fixed size, make some adjustments so things fit better
            if(!client.isResized()){
                font = FontManager.getRunescapeBoldFont().deriveFont(Font.BOLD, 14f);
                graphics2.setFont(font);

                fm = graphics2.getFontMetrics(font);

                textWidth = fm.stringWidth(message);
                x = (canvasWidth - textWidth) / 2;

                text2Width = fm.stringWidth(subMessage);
                x2 = (canvasWidth - text2Width) / 2;

                //In testing these values seemed to provide decent results for better centering the messages in fixed mode
                y = y -50;
                x = x -120;
                x2 = x2 -120;
            }


            // Apply alpha
            graphics2.setComposite(AlphaComposite.SrcOver.derive(alpha));

            // Simple shadow for contrast
            graphics2.setColor(Color.BLACK);
            graphics2.drawString(message, x + 2, y + 2);
            graphics2.drawString(subMessage, x2 + 2, y + subtextYOffset + 2 );

            // Main text
            graphics2.setColor(baseColor);

            graphics2.drawString(message, x, y);
            graphics2.drawString(subMessage, x2, y + subtextYOffset);
        }
        finally
        {
            graphics2.dispose();
        }

        return null;
    }
}
package com.TickBeatsMetronome;

import net.runelite.client.config.*;

import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

//ConfigGroup internally makes this @Singleton, so it's not required
@ConfigGroup("tickBeats")
public interface TickBeatsMetronomeConfig extends Config
{
	////////////////////////////////////////////////
	/////////////////  Settings  ///////////////////
	////////////////////////////////////////////////

	@ConfigItem(
			keyName = "enableAudioMetronome",
			name = "Enable Beats",
			description = "Toggles tick sounds",
			position = 1
	)
	default boolean enableAudioMetronome() { return true; }

	@ConfigItem(
			keyName = "enableMusic",
			name = "Enable Music",
			description = "Toggles Music On or Off",
			position = 2
	)
	default boolean enableMusic() { return false; }

	@ConfigItem(
			keyName = "enableTextMetronome",
			name = "Enable Overhead Count",
			description = "Toggles the tick number above the player",
			position = 3
	)
	default boolean enableTextMetronome() { return true; }

	@ConfigItem(
			keyName = "enableColorOverlay",
			name = "Enable Color Overlay",
			description = "Toggles the full screen color overlay that changes with ticks",
			position = 4
	)
	default boolean enableColorOverlay() { return false; }

	@ConfigItem(
			keyName = "enableTickSmoothing",
			name = "Enable Tick Smoothing",
			description = "More consistent but less accurate ticks",
			position = 5
	)
	default boolean enableTickSmoothing() { return true; }

	@ConfigItem(
			keyName = "showInfoBox",
			name = "Show Info Box",
			description = "Display the Tick Info Overlay Box",
			position = 6
	)
	default boolean showInfoBox() { return true; }

	@Range(min = 1, max = 3)
	@ConfigItem(
			keyName = "enabledBeats",
			name = "Enabled Beats",
			description = "Which beat settings are enabled for rotating through with hotkey",
			position = 7
	)
	default int enabledBeats() { return 3; }

	@Range(max = 9)
	@ConfigItem(
			keyName = "startTick",
			name = "Start Tick",
			description = "The tick the metronome starts on (0 to 9)",
			position = 8
	)
	default int startTick() { return 0; }

	////////////////////////////////////////////////
	/////////////////  Music Settings  /////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Music Settings",
			description = "Music Settings",
			position = 8
	)
	String musicSettings = "musicSettings";


	@ConfigItem(
			keyName = "useHighQualityMusic",
			name = "Use High Quality Music",
			description = "If checked, this plugin will download much larger CD quality tracks to use",
			section = musicSettings,
			position = 1
	)
	default boolean useHighQualityMusic() {return false;}


	@ConfigItem(
			keyName = "musicTrack",
			name = "Music Track",
			description = "Select which music track to play",
			section = musicSettings,
			position = 2
	)
	default MusicTrackOption musicTrack() { return MusicTrackOption.SEA_SHANTY_2; }

	@ConfigItem(
			keyName = "musicVolume",
			name = "Music Volume",
			description = "Controls the volume of music playback (Normal:100%, Boosted:150%)",
			position = 3,
			section = musicSettings
	)
	@Range(min = 0, max = 150)
	default int musicVolume() { return 100; }

	////////////////////////////////////////////////
	//////////////  Hotkey Settings  ///////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Hotkey Settings",
			description = "Hotkey Settings",
			position = 9
	)
	String hotkeys = "hotkeys";


	@ConfigItem(
			name = "Reset to Start Tick",
			keyName = "resetHotkey",
			description = "The keybind to manually reset the metronome tick (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 2
	)
	default Keybind resetHotkey() { return new Keybind(KeyEvent.VK_TAB, 0); }

	@ConfigItem(
			name = "Next Beat",
			keyName = "nextBeatHotkey",
			description = "Keybind to go to the next beat (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 3
	)
	default Keybind nextBeatHotkey() { return new Keybind(KeyEvent.VK_UP, InputEvent.CTRL_DOWN_MASK); }

	@ConfigItem(
			name = "Previous Beat",
			keyName = "previousBeatHotkey",
			description = "Keybind to go to the previous beat (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 4
	)
	default Keybind previousBeatHotkey() { return new Keybind(KeyEvent.VK_DOWN, InputEvent.CTRL_DOWN_MASK); }

	@ConfigItem(
			name = "Next Tick",
			keyName = "nextTickHotkey",
			description = "Keybind to manually advance the metronome a tick (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 5
	)
	default Keybind nextTickHotkey() { return new Keybind(KeyEvent.VK_RIGHT, InputEvent.CTRL_DOWN_MASK); }

	@ConfigItem(
			name = "Previous Tick",
			keyName = "previousTickHotkey",
			description = "Keybind to manually go back a tick (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 6
	)
	default Keybind previousTickHotkey() { return new Keybind(KeyEvent.VK_LEFT, InputEvent.CTRL_DOWN_MASK); }

	////////////////////////////////////////////////
	///////////////  Text Settings  ////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Text Settings",
			description = "Configure text appearance and colors",
			position = 9
	)
	String textSettings = "textSettings";

	@ConfigItem(
			keyName = "fontSize",
			name = "Font Size",
			description = "Size of the tick number displayed",
			section = textSettings,
			position = 1
	)
	default int fontSize() { return 40; }

	@ConfigItem(
			keyName = "textVerticalOffset",
			name = "Text Vertical Offset",
			description = "Vertical offset of the text from player",
			section = textSettings,
			position = 2
	)
	default int textVerticalOffset() { return 200; }

	////////////////////////////////////////////////
	//////////////////  Beat 1  ////////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 1",
			description = "The Default Beat",
			position = 10
	)
	String Beat1 = "Beat1";

	@Range(min = 1, max = 9)
	@ConfigItem(
			keyName = "beat1TickCount",
			name = "Beat 1 Tick Count",
			description = "Number of ticks in Beat 1's loop (1 to 9)",
			section = Beat1,
			position = 1
	)
	default int beat1TickCount() { return 4; }

	////////////////////////////////////////////////
	//////////////  Beat 1 Sounds  /////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 1 Sound Options",
			description = "Configure sounds for Beat 1",
			position = 11,
			closedByDefault = true
	)
	String beat1Sounds = "beat1Sounds";

	@ConfigItem(
			keyName = "beat1Tick1Sound",
			name = "Tick 1 Sound",
			description = "Sound to play on Beat 1 Tick 1",
			section = beat1Sounds,
			position = 1
	)
	default TickSoundOption beat1Tick1Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat1Tick2Sound",
			name = "Tick 2 Sound",
			description = "Sound to play on Beat 1 Tick 2",
			section = beat1Sounds,
			position = 2
	)
	default TickSoundOption beat1Tick2Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick3Sound",
			name = "Tick 3 Sound",
			description = "Sound to play on Beat 1 Tick 3",
			section = beat1Sounds,
			position = 3
	)
	default TickSoundOption beat1Tick3Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat1Tick4Sound",
			name = "Tick 4 Sound",
			description = "Sound to play on Beat 1 Tick 4",
			section = beat1Sounds,
			position = 4
	)
	default TickSoundOption beat1Tick4Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick5Sound",
			name = "Tick 5 Sound",
			description = "Sound to play on Beat 1 Tick 5",
			section = beat1Sounds,
			position = 5
	)
	default TickSoundOption beat1Tick5Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat1Tick6Sound",
			name = "Tick 6 Sound",
			description = "Sound to play on Beat 1 Tick 6",
			section = beat1Sounds,
			position = 6
	)
	default TickSoundOption beat1Tick6Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick7Sound",
			name = "Tick 7 Sound",
			description = "Sound to play on Beat 1 Tick 7",
			section = beat1Sounds,
			position = 7
	)
	default TickSoundOption beat1Tick7Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat1Tick8Sound",
			name = "Tick 8 Sound",
			description = "Sound to play on Beat 1 Tick 8",
			section = beat1Sounds,
			position = 8
	)
	default TickSoundOption beat1Tick8Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick9Sound",
			name = "Tick 9 Sound",
			description = "Sound to play on Beat 1 Tick 9",
			section = beat1Sounds,
			position = 9
	)
	default TickSoundOption beat1Tick9Sound() { return TickSoundOption.TICK; }


	////////////////////////////////////////////////
	////////////  Beat 1 Visual Options  ///////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 1 Visual Options",
			description = "Configure colors and opacity for Beat 1",
			position = 12,
			closedByDefault = true
	)
	String beat1Visuals = "beat1Visuals";

	@ConfigItem(
			keyName = "beat1Tick1Color",
			name = "Tick 1 Color",
			description = "Color for Beat 1 Tick 1 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 1
	)
	default Color beat1Tick1Color() { return Color.RED; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick1Opacity",
			name = "Tick 1 Opacity",
			description = "How transparent tick 1's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 2
	)
	default int beat1Tick1Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick2Color",
			name = "Tick 2 Color",
			description = "Color for Beat 1 Tick 2 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 3
	)
	default Color beat1Tick2Color() { return Color.BLUE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick2Opacity",
			name = "Tick 2 Opacity",
			description = "How transparent tick 2's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 4
	)
	default int beat1Tick2Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick3Color",
			name = "Tick 3 Color",
			description = "Color for Beat 1 Tick 3 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 5
	)
	default Color beat1Tick3Color() { return Color.GREEN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick3Opacity",
			name = "Tick 3 Opacity",
			description = "How transparent tick 3's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 6
	)
	default int beat1Tick3Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick4Color",
			name = "Tick 4 Color",
			description = "Color for Beat 1 Tick 4 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 7
	)
	default Color beat1Tick4Color() { return Color.YELLOW; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick4Opacity",
			name = "Tick 4 Opacity",
			description = "How transparent tick 4's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 8
	)
	default int beat1Tick4Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick5Color",
			name = "Tick 5 Color",
			description = "Color for Beat 1 Tick 5 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 9
	)
	default Color beat1Tick5Color() { return Color.ORANGE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick5Opacity",
			name = "Tick 5 Opacity",
			description = "How transparent tick 5's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 10
	)
	default int beat1Tick5Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick6Color",
			name = "Tick 6 Color",
			description = "Color for Beat 1 Tick 6 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 11
	)
	default Color beat1Tick6Color() { return Color.PINK; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick6Opacity",
			name = "Tick 6 Opacity",
			description = "How transparent tick 6's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 12
	)
	default int beat1Tick6Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick7Color",
			name = "Tick 7 Color",
			description = "Color for Beat 1 Tick 7 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 13
	)
	default Color beat1Tick7Color() { return Color.MAGENTA; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick7Opacity",
			name = "Tick 7 Opacity",
			description = "How transparent tick 7's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 14
	)
	default int beat1Tick7Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick8Color",
			name = "Tick 8 Color",
			description = "Color for Beat 1 Tick 8 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 15
	)
	default Color beat1Tick8Color() { return Color.CYAN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick8Opacity",
			name = "Tick 8 Opacity",
			description = "How transparent tick 8's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 16
	)
	default int beat1Tick8Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick9Color",
			name = "Tick 9 Color",
			description = "Color for Beat 1 Tick 9 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 17
	)
	default Color beat1Tick9Color() { return Color.LIGHT_GRAY; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick9Opacity",
			name = "Tick 9 Opacity",
			description = "How transparent tick 9's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 18
	)
	default int beat1Tick9Opacity() { return 10; }


	////////////////////////////////////////////////
	//////////////////  Beat 2  ////////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 2 (Activate With Next Beat Hotkey)",
			description = "Another beat to use, activate with next beat hotkey",
			position = 13
	)
	String Beat2 = "Beat2";

	@Range(min = 1, max = 9)
	@ConfigItem(
			keyName = "beat2TickCount",
			name = "Beat 2 Tick Count",
			description = "Number of ticks in Beat 2's loop (1 to 9)",
			section = Beat2,
			position = 30
	)
	default int beat2TickCount() { return 3; }

	////////////////////////////////////////////////
	//////////////  Beat 2 Sounds  /////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 2 Sound Options",
			description = "Configure sounds for Beat 2",
			position = 14,
			closedByDefault = true
	)
	String beat2Sounds = "beat2Sounds";

	@ConfigItem(
			keyName = "beat2Tick1Sound",
			name = "Tick 1 Sound",
			description = "Sound to play on Beat 2 Tick 1",
			section = beat2Sounds,
			position = 1
	)
	default TickSoundOption beat2Tick1Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat2Tick2Sound",
			name = "Tick 2 Sound",
			description = "Sound to play on Beat 2 Tick 2",
			section = beat2Sounds,
			position = 2
	)
	default TickSoundOption beat2Tick2Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat2Tick3Sound",
			name = "Tick 3 Sound",
			description = "Sound to play on Beat 2 Tick 3",
			section = beat2Sounds,
			position = 3
	)
	default TickSoundOption beat2Tick3Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat2Tick4Sound",
			name = "Tick 4 Sound",
			description = "Sound to play on Beat 2 Tick 4",
			section = beat2Sounds,
			position = 4
	)
	default TickSoundOption beat2Tick4Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat2Tick5Sound",
			name = "Tick 5 Sound",
			description = "Sound to play on Beat 2 Tick 5",
			section = beat2Sounds,
			position = 5
	)
	default TickSoundOption beat2Tick5Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat2Tick6Sound",
			name = "Tick 6 Sound",
			description = "Sound to play on Beat 2 Tick 6",
			section = beat2Sounds,
			position = 6
	)
	default TickSoundOption beat2Tick6Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat2Tick7Sound",
			name = "Tick 7 Sound",
			description = "Sound to play on Beat 2 Tick 7",
			section = beat2Sounds,
			position = 7
	)
	default TickSoundOption beat2Tick7Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat2Tick8Sound",
			name = "Tick 8 Sound",
			description = "Sound to play on Beat 2 Tick 8",
			section = beat2Sounds,
			position = 8
	)
	default TickSoundOption beat2Tick8Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat2Tick9Sound",
			name = "Tick 9 Sound",
			description = "Sound to play on Beat 2 Tick 9",
			section = beat2Sounds,
			position = 9
	)
	default TickSoundOption beat2Tick9Sound() { return TickSoundOption.CLAP; }



	////////////////////////////////////////////////
	////////////  Beat 2 Visual Options  ///////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 2 Visual Options",
			description = "Configure colors and opacity for Beat 2",
			position = 15,
			closedByDefault = true
	)
	String beat2Visuals = "beat2Visuals";

	@ConfigItem(
			keyName = "beat2Tick1Color",
			name = "Tick 1 Color",
			description = "Color for Beat 2 Tick 1 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 1
	)
	default Color beat2Tick1Color() { return Color.RED; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick1Opacity",
			name = "Tick 1 Opacity",
			description = "How transparent tick 1's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 2
	)
	default int beat2Tick1Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick2Color",
			name = "Tick 2 Color",
			description = "Color for Beat 2 Tick 2 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 3
	)
	default Color beat2Tick2Color() { return Color.BLUE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick2Opacity",
			name = "Tick 2 Opacity",
			description = "How transparent tick 2's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 4
	)
	default int beat2Tick2Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick3Color",
			name = "Tick 3 Color",
			description = "Color for Beat 2 Tick 3 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 5
	)
	default Color beat2Tick3Color() { return Color.GREEN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick3Opacity",
			name = "Tick 3 Opacity",
			description = "How transparent tick 3's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 6
	)
	default int beat2Tick3Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick4Color",
			name = "Tick 4 Color",
			description = "Color for Beat 2 Tick 4 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 7
	)
	default Color beat2Tick4Color() { return Color.YELLOW; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick4Opacity",
			name = "Tick 4 Opacity",
			description = "How transparent tick 4's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 8
	)
	default int beat2Tick4Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick5Color",
			name = "Tick 5 Color",
			description = "Color for Beat 2 Tick 5 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 9
	)
	default Color beat2Tick5Color() { return Color.ORANGE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick5Opacity",
			name = "Tick 5 Opacity",
			description = "How transparent tick 5's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 10
	)
	default int beat2Tick5Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick6Color",
			name = "Tick 6 Color",
			description = "Color for Beat 2 Tick 6 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 11
	)
	default Color beat2Tick6Color() { return Color.PINK; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick6Opacity",
			name = "Tick 6 Opacity",
			description = "How transparent tick 6's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 12
	)
	default int beat2Tick6Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick7Color",
			name = "Tick 7 Color",
			description = "Color for Beat 2 Tick 7 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 13
	)
	default Color beat2Tick7Color() { return Color.MAGENTA; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick7Opacity",
			name = "Tick 7 Opacity",
			description = "How transparent tick 7's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 14
	)
	default int beat2Tick7Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick8Color",
			name = "Tick 8 Color",
			description = "Color for Beat 2 Tick 8 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 15
	)
	default Color beat2Tick8Color() { return Color.CYAN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick8Opacity",
			name = "Tick 8 Opacity",
			description = "How transparent tick 8's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 16
	)
	default int beat2Tick8Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick9Color",
			name = "Tick 9 Color",
			description = "Color for Beat 2 Tick 9 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 17
	)
	default Color beat2Tick9Color() { return Color.LIGHT_GRAY; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick9Opacity",
			name = "Tick 9 Opacity",
			description = "How transparent tick 9's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 18
	)
	default int beat2Tick9Opacity() { return 10; }


	////////////////////////////////////////////////
	//////////////////  Beat 3  ////////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 3 (Activate With Next Beat Hotkey)",
			description = "Another beat to use, activate with next beat hotkey",
			position = 16
	)
	String Beat3 = "Beat3";

	@Range(min = 1, max = 9)
	@ConfigItem(
			keyName = "beat3TickCount",
			name = "Beat 3 Tick Count",
			description = "Number of ticks in Beat 3's loop (1 to 9)",
			section = Beat3,
			position = 1
	)
	default int beat3TickCount() { return 4; }

	////////////////////////////////////////////////
	//////////////  Beat 3 Sounds  /////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 3 Sound Options",
			description = "Configure sounds for Beat 3",
			position = 17,
			closedByDefault = true
	)
	String beat3Sounds = "beat3Sounds";

	@ConfigItem(
			keyName = "beat3Tick1Sound",
			name = "Tick 1 Sound",
			description = "Sound to play on Beat 3 Tick 1",
			section = beat3Sounds,
			position = 1
	)
	default TickSoundOption beat3Tick1Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick2Sound",
			name = "Tick 2 Sound",
			description = "Sound to play on Beat 3 Tick 2",
			section = beat3Sounds,
			position = 2
	)
	default TickSoundOption beat3Tick2Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick3Sound",
			name = "Tick 3 Sound",
			description = "Sound to play on Beat 3 Tick 3",
			section = beat3Sounds,
			position = 3
	)
	default TickSoundOption beat3Tick3Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick4Sound",
			name = "Tick 4 Sound",
			description = "Sound to play on Beat 3 Tick 4",
			section = beat3Sounds,
			position = 4
	)
	default TickSoundOption beat3Tick4Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick5Sound",
			name = "Tick 5 Sound",
			description = "Sound to play on Beat 3 Tick 5",
			section = beat3Sounds,
			position = 5
	)
	default TickSoundOption beat3Tick5Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick6Sound",
			name = "Tick 6 Sound",
			description = "Sound to play on Beat 3 Tick 6",
			section = beat3Sounds,
			position = 6
	)
	default TickSoundOption beat3Tick6Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick7Sound",
			name = "Tick 7 Sound",
			description = "Sound to play on Beat 3 Tick 7",
			section = beat3Sounds,
			position = 7
	)
	default TickSoundOption beat3Tick7Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick8Sound",
			name = "Tick 8 Sound",
			description = "Sound to play on Beat 3 Tick 8",
			section = beat3Sounds,
			position = 8
	)
	default TickSoundOption beat3Tick8Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick9Sound",
			name = "Tick 9 Sound",
			description = "Sound to play on Beat 3 Tick 9",
			section = beat3Sounds,
			position = 9
	)
	default TickSoundOption beat3Tick9Sound() { return TickSoundOption.TICK; }



	////////////////////////////////////////////////
	////////////  Beat 3 Visual Options  ///////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 3 Visual Options",
			description = "Configure colors and opacity for Beat 3",
			position = 18,
			closedByDefault = true
	)
	String beat3Visuals = "beat3Visuals";

	@ConfigItem(
			keyName = "beat3Tick1Color",
			name = "Tick 1 Color",
			description = "Color for Beat 3 Tick 1 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 1
	)
	default Color beat3Tick1Color() { return Color.RED; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick1Opacity",
			name = "Tick 1 Opacity",
			description = "How transparent tick 1's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 2
	)
	default int beat3Tick1Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick2Color",
			name = "Tick 2 Color",
			description = "Color for Beat 3 Tick 2 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 3
	)
	default Color beat3Tick2Color() { return Color.BLUE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick2Opacity",
			name = "Tick 2 Opacity",
			description = "How transparent tick 2's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 4
	)
	default int beat3Tick2Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick3Color",
			name = "Tick 3 Color",
			description = "Color for Beat 3 Tick 3 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 5
	)
	default Color beat3Tick3Color() { return Color.GREEN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick3Opacity",
			name = "Tick 3 Opacity",
			description = "How transparent tick 3's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 6
	)
	default int beat3Tick3Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick4Color",
			name = "Tick 4 Color",
			description = "Color for Beat 3 Tick 4 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 7
	)
	default Color beat3Tick4Color() { return Color.YELLOW; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick4Opacity",
			name = "Tick 4 Opacity",
			description = "How transparent tick 4's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 8
	)
	default int beat3Tick4Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick5Color",
			name = "Tick 5 Color",
			description = "Color for Beat 3 Tick 5 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 9
	)
	default Color beat3Tick5Color() { return Color.ORANGE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick5Opacity",
			name = "Tick 5 Opacity",
			description = "How transparent tick 5's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 10
	)
	default int beat3Tick5Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick6Color",
			name = "Tick 6 Color",
			description = "Color for Beat 3 Tick 6 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 11
	)
	default Color beat3Tick6Color() { return Color.PINK; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick6Opacity",
			name = "Tick 6 Opacity",
			description = "How transparent tick 6's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 12
	)
	default int beat3Tick6Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick7Color",
			name = "Tick 7 Color",
			description = "Color for Beat 3 Tick 7 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 13
	)
	default Color beat3Tick7Color() { return Color.MAGENTA; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick7Opacity",
			name = "Tick 7 Opacity",
			description = "How transparent tick 7's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 14
	)
	default int beat3Tick7Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick8Color",
			name = "Tick 8 Color",
			description = "Color for Beat 3 Tick 8 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 15
	)
	default Color beat3Tick8Color() { return Color.CYAN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick8Opacity",
			name = "Tick 8 Opacity",
			description = "How transparent tick 8's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 16
	)
	default int beat3Tick8Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick9Color",
			name = "Tick 9 Color",
			description = "Color for Beat 3 Tick 9 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 17
	)
	default Color beat3Tick9Color() { return Color.LIGHT_GRAY; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick9Opacity",
			name = "Tick 9 Opacity",
			description = "How transparent tick 9's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 18
	)
	default int beat3Tick9Opacity() { return 10; }

}

package com.TickBeatsMetronome;


import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Slf4j
@Singleton
public class OverlayOverheadNumber extends Overlay
{
    @Inject
    Client client;

    @Inject
    TickBeatsMetronomePlugin plugin;

    @Inject
    TickBeatsMetronomeConfig config;

    @Inject
    public OverlayOverheadNumber()
    {
        // Set the overlay to move with the game world (e.g., above the player)
        setPosition(OverlayPosition.DYNAMIC);
        // Draw this above the main game scene (so it shows over your player)
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    //note render runs every time the screen is redrawn
    public Dimension render(Graphics2D graphics)
    {

        //if the visual metronome is turned off, don't draw it to the screen
        if (!config.enableTextMetronome()){
            return null;
        }

        Player player = client.getLocalPlayer(); // Get your own character
        if (player == null)
        {
            log.debug("Player");
            return null; // Game might still be loading
        }

        // Get the current tick number
        String tickText = String.valueOf(plugin.tickCount);

        // Determine where to draw the text
        int zOffset = config.textVerticalOffset(); // Get absolute value for the initial calculation
        Point textLocation = player.getCanvasTextLocation(graphics, tickText, zOffset);
        if (textLocation == null)
        {
            log.debug("couldn't calculate text location");
            return null; // Couldn't calculate a position
        }

        // Set font from config
        graphics.setFont(new Font("Arial", Font.BOLD, config.fontSize()));

        //get the width of text so that it can be centered
        FontMetrics metrics = graphics.getFontMetrics();
        int textWidth = metrics.stringWidth(tickText);

        //place the text on the screen
        int x = textLocation.getX() - (textWidth / 2);
        int y = textLocation.getY();
        


        // Draw black outline around text (offset by 1 pixel in each direction)
        graphics.setColor(Color.BLACK);
        graphics.drawString(tickText, x + 1, y);
        graphics.drawString(tickText, x - 1, y);
        graphics.drawString(tickText, x, y + 1);
        graphics.drawString(tickText, x, y - 1);

        // Get the appropriate color based on current beat and tick
        Color textColor;
        if (plugin.beatNumber == 1) {
            switch (plugin.tickCount) {
                case 1: textColor = config.beat1Tick1Color(); break;
                case 2: textColor = config.beat1Tick2Color(); break;
                case 3: textColor = config.beat1Tick3Color(); break;
                case 4: textColor = config.beat1Tick4Color(); break;
                case 5: textColor = config.beat1Tick5Color(); break;
                case 6: textColor = config.beat1Tick6Color(); break;
                case 7: textColor = config.beat1Tick7Color(); break;
                case 8: textColor = config.beat1Tick8Color(); break;
                case 9: textColor = config.beat1Tick9Color(); break;
                default: textColor = Color.WHITE; break;
            }
        } else if (plugin.beatNumber == 2) {
            switch (plugin.tickCount) {
                case 1: textColor = config.beat2Tick1Color(); break;
                case 2: textColor = config.beat2Tick2Color(); break;
                case 3: textColor = config.beat2Tick3Color(); break;
                case 4: textColor = config.beat2Tick4Color(); break;
                case 5: textColor = config.beat2Tick5Color(); break;
                case 6: textColor = config.beat2Tick6Color(); break;
                case 7: textColor = config.beat2Tick7Color(); break;
                case 8: textColor = config.beat2Tick8Color(); break;
                case 9: textColor = config.beat2Tick9Color(); break;
                default: textColor = Color.WHITE; break;
            }
        } else {
            switch (plugin.tickCount) {
                case 1: textColor = config.beat3Tick1Color(); break;
                case 2: textColor = config.beat3Tick2Color(); break;
                case 3: textColor = config.beat3Tick3Color(); break;
                case 4: textColor = config.beat3Tick4Color(); break;
                case 5: textColor = config.beat3Tick5Color(); break;
                case 6: textColor = config.beat3Tick6Color(); break;
                case 7: textColor = config.beat3Tick7Color(); break;
                case 8: textColor = config.beat3Tick8Color(); break;
                case 9: textColor = config.beat3Tick9Color(); break;
                default: textColor = Color.WHITE; break;
            }
        }

        // Draw text in tick-specific color
        graphics.setColor(textColor);
        graphics.drawString(tickText, x, y);


        return null;
    }
}

package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import javax.inject.Singleton;
import java.io.File;
import java.util.*;

@Slf4j
@Singleton
public class UserMusicManager
{
    // Path to the directory where users can drop .wav files
    private static final File MUSIC_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "tick-beats/music");

    // Stores user sound files keyed by their ID ("1", "2", etc.)
    private final Map<String, File> userMusicMap = new HashMap<>();

    // list of music files
    private List<File> userFiles = new ArrayList<>();



    /**
     * Loads all .wav Files from the user's sound directory. for access with "getUserMusicMap()"
     * Note: it doesn't add all the music data itself to memory, just File objects which contains things like the file names
     * This should be called once during plugin startup.
     */
    public void loadUserMusic()
    {
        // Clear any previously loaded music files
        userFiles.clear();
        userMusicMap.clear();

        // Ensure directory exists
        if (!MUSIC_DIRECTORY.exists())
        {
            //if the directory doesn't exist, create it
            boolean created = MUSIC_DIRECTORY.mkdirs();
            if (!created)
            {
                log.debug("Could not create user music directory: {}", MUSIC_DIRECTORY.getAbsolutePath());
                return;
            }
        }

        // List all .wav files in the sound directory
        File[] files = MUSIC_DIRECTORY.listFiles();
        if (files == null)
        {
            log.debug("Could not read music directory contents, or no user music files exist.");
            return;
        }

        for (File file : files)
        {
            // Only accept regular files that end in .wav
            if (file.isFile() && file.getName().toLowerCase().endsWith(".wav"))
            {
                userFiles.add(file);
                log.debug("Discovered user music file: {}", file.getName());
            }
        }

        //sort the files by filename
        userFiles.sort(Comparator.comparing(File::getName));

        log.debug("Total user music files loaded: {}", userFiles.size());

        //create the userMusicMap attaching an id to each sound file
        //this will be used to access user sound files based on a number alone so we don't need to work with file names
        int i = 0;
        for (File file : userFiles)
        {
            //increment first to make the ids 1 based instead of 0 based
            i++;
            String fileId = String.valueOf(i);
            userMusicMap.put(fileId, file);
            log.debug("Registered user music [{}]: {}", fileId, file.getName());
        }
    }



    /**
     * Returns a collection of user sound files.
     * the files will be accessed with string integers matching the user track number
     * so a key of "1" will return the file for User Track 1, a key of "2" will give the File for User Track 2 and so on
     */
    public Map<String, File> getUserMusicMap()
    {
        return userMusicMap;
    }

}
package com.TickBeatsMetronome;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TickBeatsMetronomePlugin.class);
		RuneLite.main(args);
	}
}
