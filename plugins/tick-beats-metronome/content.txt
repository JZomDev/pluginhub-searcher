package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import javax.inject.Singleton;
import java.io.File;
import java.util.*;

/**
 * Handles finding and managing user-supplied sound files from the
 * RuneLite plugin configuration directory.
 * This class creates a map of audio files which can be accessed via getUserSoundMap()
 *   ~/.runelite/tick-beats/sounds/*
 * Is the expected location of sound files, it should create this folder on startup:
 * All user-supplied files must be `.wav` format.
 */
@Slf4j
@Singleton
public class UserSoundManager
{
    // Path to the directory where users can drop .wav files
    private static final File SOUND_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "tick-beats/sounds");

    // Stores user sound files keyed by their ID ("1", "2", etc.)
    private final Map<String, File> userSoundMap = new HashMap<>();

    // list of sound files
    private List<File> userFiles = new ArrayList<>();



    /**
     * Loads all .wav file from the user's sound directory.
     * This should be called once during plugin startup.
     */
    public void loadUserSounds()
    {
        // Clear any previously loaded sounds (safe for reloads)
        userFiles.clear();
        userSoundMap.clear();

        // Ensure directory exists
        if (!SOUND_DIRECTORY.exists())
        {
            boolean created = SOUND_DIRECTORY.mkdirs();
            if (!created)
            {
                log.debug("Could not create user sound directory: {}", SOUND_DIRECTORY.getAbsolutePath());
                return;
            }
        }

        // List all .wav files in the sound directory
        File[] files = SOUND_DIRECTORY.listFiles();
        if (files == null)
        {
            log.debug("Could not read sound directory contents.");
            return;
        }

        for (File file : files)
        {
            // Only accept regular files that end in .wav (case-insensitive)
            if (file.isFile() && file.getName().toLowerCase().endsWith(".wav"))
            {
                userFiles.add(file);
                log.debug("Discovered user sound file: {}", file.getName());
            }
        }

        //sort the files by filename
        userFiles.sort(Comparator.comparing(File::getName));

        log.debug("Total user sound files loaded: {}", userFiles.size());

        //create the userSoundMap attaching an id to each sound file for access
        int i = 0;
        for (File file : userFiles)
        {
            i++;
            String fileId = String.valueOf(i);
            userSoundMap.put(fileId, file);
            log.debug("Registered user sound [{}]: {}", fileId, file.getName());
        }
    }



    /**
     * Returns a collection of all user sound files.
     */

    public Map<String, File> getUserSoundMap()
    {
        return userSoundMap;
    }

}
package com.TickBeatsMetronome;

import com.google.inject.Provides;
import javax.inject.Inject;


import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;


@Slf4j
@PluginDescriptor(
        name = "Tick Beats",
        description = "Music player metronome with advanced audio and visual configurations",
        tags = {"tick", "beat", "beats", "visual", "helper", "metronome", "music", "sound", "audio", "skilling", "skill", "cycle"}
)
//suppressing unused warning in IDE at class level as there are a lot of them with RL Plugins
@SuppressWarnings("unused") //comment or remove this line out if you want to see unused warnings
//extends Plugin makes this a singleton so @Singleton isn't used here
public class TickBeatsMetronomePlugin extends Plugin {

    // Needed for Guice Dependency Injection
    @Inject
    private Client client;

    @Inject
    private TickBeatsMetronomeConfig config;

    @Inject
    private EventBus eventBus;

    @Inject
    private OverlayOverheadNumber overlayOverheadNumber;

    @Inject
    private OverlayColor overlayColor;

    @Inject
    private OverlayInfoBox overlayInfoBox;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private OverlayMessage overlayMessage;

    @Inject
    private KeyManager keyManager;

    @Inject
    private InputManager inputManager;

    @Inject
    private TickSoundCache tickSoundCache;

    @Inject
    private TickSoundManager tickSoundManager;

    @Inject
    private UserSoundManager userSoundManager;

    @Inject
    private UserMusicManager userMusicManager;

    @Inject
    private MusicManager musicManager;

    @Inject
    private MusicPlaylistManager musicPlaylistManager;

    @Inject
    private DownloadManager downloadManager;

    // Need to pass in local tick callback so don't inject this one
    private LocalTickManager localTickManager;

    // Holds the tick count
    public int tickCount = 0;

    // Holds the Beat Number of which beat to play
    public int beatNumber = 1;

    // Holds the max number of ticks for the current beat
    public int maxTicks = 1;

    protected void startUp()
    {
        log.debug("Tick Beats Plugin started");

        tickCount = config.startTick();

        // Attach the overlays
        overlayManager.add(overlayOverheadNumber);
        overlayManager.add(overlayColor);
        overlayManager.add(overlayInfoBox);
        overlayManager.add(overlayMessage);

        // Register the key input listener
        keyManager.registerKeyListener(inputManager);

        // Create the LocalTickManager and pass in the tick callback
        localTickManager = new LocalTickManager(this::onLocalTick);

        // Register LocalTickManager so it gets onGameTick events
        eventBus.register(localTickManager);

        // Load the user sound files
        userSoundManager.loadUserSounds();

        // Load All Tick Sounds Into Memory for quick playback
        tickSoundCache.cacheTickSounds();

        // Load list of user music files
        userMusicManager.loadUserMusic();

        // Check to see if all files that need to be downloaded are downloaded
        downloadManager.initializeDownloads();

        // Make sure Playlists and shuffle order are ready
        musicPlaylistManager.resetPlaylists();

        // Get a music track ready to go on tick 1 (this should be called near or at the end)
        musicManager.prepMusicTrack();
    }

    @Override
    protected void shutDown()
    {
        log.debug("Tick Beats Plugin stopped");

        // Remove overlays
        overlayManager.remove(overlayOverheadNumber);
        overlayManager.remove(overlayColor);
        overlayManager.remove(overlayInfoBox);
        overlayManager.remove(overlayMessage);

        keyManager.unregisterKeyListener(inputManager);

        // Shutdown local tick loop and unregister events
        if (localTickManager != null)
        {
            localTickManager.shutdown();
            eventBus.unregister(localTickManager);
            localTickManager = null;
        }

        if (downloadManager != null)
        {
            downloadManager.shutdown();
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        GameState state = event.getGameState();

        // If the GameState event is login screen or world hopping reset the local tick manager
        if (state == GameState.LOGIN_SCREEN || state == GameState.HOPPING)
        {
            log.debug("Player logged out or world hopping â€” resetting local tick manager.");
            if (localTickManager != null)
            {
                localTickManager.reset();
            }
        }
    }

    /**
     * Fires on every game tick ~(.6s). Updates the metronome tick count.
     */
    @Subscribe
    public void onGameTick(GameTick tick)
    {
        //nudge our local tick towards the game tick to be a near perfect average
        localTickManager.updateLocalTick();

        if(!config.enableTickSmoothing()){
            onTick();
        }
    }

    /**
     * Fires on every local tick which is set up in LocalTickManager
     */
    private void onLocalTick()
    {
        if(config.enableTickSmoothing()){
            onTick();
        }
    }
    
    private void onTick(){
        // If the reset key is being held, don't do anything on the game tick
        if(inputManager.resetActive)
        {
            return;
        }

        // Update maxTicks count based on current beat
        switch (beatNumber) {
            case 1: maxTicks = config.beat1TickCount(); break;
            case 2: maxTicks = config.beat2TickCount(); break;
            case 3: maxTicks = config.beat3TickCount(); break;
            default: maxTicks = config.beat1TickCount(); break;
        }

        // Increment the tick counter and wrap back to 1 if over max
        tickCount = (tickCount % maxTicks) + 1;

        // If Audio Metronome is enabled play the audio for the current tick
        if(config.enableAudioMetronome()){
            tickSoundManager.playSound(beatNumber, tickCount);
        }

        // If Enable Music is checked
        if(config.enableMusic()) {

            // If music isn't playing, and we're at tick 1 start playing music
            if (!musicManager.isPlaying() && tickCount == 1) {
                musicManager.start();
            }

            // Play the music clips
            musicManager.onTick(maxTicks, tickCount, config.musicVolume());
        }else{
            // If Enable Music isn't checked, stop the music clips from playing
            musicManager.stop();
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        // Make sure the event is coming from this plugin's config group
        if (!event.getGroup().equals("tickBeats"))
        {
            return;
        }

        // If event is coming from the music track dropdown
        if (event.getKey().equals("musicTrack"))
        {
            musicManager.prepMusicTrack();
        }

        // If event is coming from a playlist change
        if (event.getKey().startsWith("playlist") || event.getKey().equals("shuffle"))
        {
            // Seems to work without the refresh but including anyway just in case
            musicPlaylistManager.refreshPlaylists();
            musicManager.prepMusicTrack();
        }

        // If event is coming from the playback Mode dropdown
        if (event.getKey().equals("playbackMode"))
        {
            // Refresh the playlists and go to song 1
            musicPlaylistManager.resetPlaylists();
            musicManager.prepMusicTrack();
        }

        // If event is high quality music button run initialize downloads to see if we need to download music tracks
        if (event.getKey().equals("useHighQualityMusic"))
        {
            downloadManager.initializeDownloads();
        }

        // Detect TickSound changes (e.g., beat1Tick1Sound, beat2Tick3Sound, etc.)
        if (event.getKey().startsWith("beat") && event.getKey().endsWith("Sound"))
        {
            // Refresh the user sound cache in case the user has made changes to their user sounds folder
            tickSoundCache.cacheAllUserSounds();
        }
    }

    // I believe this is Required by RuneLite to provide config interface.
    @Provides
    TickBeatsMetronomeConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(TickBeatsMetronomeConfig.class);
    }
}

package com.TickBeatsMetronome;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.*;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Collectors;

/**
 * Handles downloading the built-in music files for the Tick Beats plugin.
 *
 * Built-in tracks are defined in MusicTrackOption and filtered to exclude user-supplied tracks
 * (which are identified by purely numeric file names like "1", "2", etc.).
 * Downloads are performed in the background and staggered with a delay to reduce the chance of
 * hitting GitHub rate limits. Files are stored inside the RuneLite settings directory
 * under .runelite/tick-beats/downloads/lo or  .../hi for low- and high-quality versions.
 */
@Slf4j
@Singleton
public class DownloadManager
{
    @Inject
    private TickBeatsMetronomeConfig config;

    // Base path inside .runelite directory
    private static final Path BASE_LOCAL_PATH = new File(RuneLite.RUNELITE_DIR, "tick-beats/downloads").toPath();
    private static final Path LO_LOCAL_PATH = BASE_LOCAL_PATH.resolve("lo");
    private static final Path HI_LOCAL_PATH = BASE_LOCAL_PATH.resolve("hi");

    private static final String BASE_DOWNLOAD_URL = "https://raw.githubusercontent.com/HarperDevLab/Tick-Beats-Metronome/master/music/";

    // The default music track to download first so the user can hear it as soon as possible
    private static final String DEFAULT_TRACK = "sea_shanty_2.wav";

    // Delay for low-quality music file downloads, multiplied by 6 for high-quality files
    private static final int DELAY_MULTIPLIER = 30000;

    // A list of only built-in tracks (doesn't include user tracks which have numeric file names)
    private List<MusicTrackOption> builtinTracks;

    private final OkHttpClient httpClient;

    // Single-thread scheduler to manage sequential download tasks
    private ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();

    // Download status fields, shared between threads
    @Getter
    private volatile boolean allLoDownloaded = false;
    @Getter
    private volatile boolean allHiDownloaded = false;
    @Getter
    private volatile int downloadedCountLo = 0;
    @Getter
    private volatile int downloadedCountHi = 0;

    @Inject
    public DownloadManager(OkHttpClient httpClient)
    {
        this.httpClient = httpClient;
    }

    /**
     * Gets the total number of built-in tracks (non-numeric filenames) for this plugin.
     *
     * Returns 0 if builtinTracks has not yet been initialized.
     *
     * @return the total number of built-in track entries, or 0 if uninitialized.
     */
    public int getTotalBuiltinCount()
    {
        if (builtinTracks == null)
        {
            return 0;
        }
        return builtinTracks.size();
    }

    /**
     * Initializes the download manager .
     *
     * This method:
     * <ol>
     *   <li>Ensures the scheduler is running (restarts it if needed).</li>
     *   <li>Loads the list of built-in tracks from MusicTrackOption, filtering out numeric (user) tracks.</li>
     *   <li>Updates internal download state counts and booleans via checkDownloadState().</li>
     *   <li>If any required files are missing, schedules downloads starting with the DEFAULT_TRACK
     *       so the user has an immediate playable track, then queues remaining downloads.</li>
     * </ol>
     */
    public void initializeDownloads()
    {
        // Ensure scheduler is ready (e.g., after plugin restart)
        if (scheduler == null || scheduler.isShutdown() || scheduler.isTerminated())
        {
            log.debug("Reinitializing DownloadManager scheduler...");
            scheduler = Executors.newSingleThreadScheduledExecutor();
        }

        // Load all non-user tracks from the enum
        builtinTracks = Arrays.stream(MusicTrackOption.values())
                .filter(track -> !track.getResourceName().matches("\\d+"))
                .collect(Collectors.toList());

        // Update current download state
        checkDownloadState();

        // If missing files, start scheduler
        if (!allLoDownloaded || (config.useHighQualityMusic() && !allHiDownloaded))
        {
            log.debug("A download is missing, starting download scheduler");

            // Download the default track immediately if not present
            if (!Files.exists(LO_LOCAL_PATH.resolve(DEFAULT_TRACK)))
            {
                downloadDefaultTrack();
            }

            // Schedule the rest
            scheduler.execute(() -> scheduleDownloads(config.useHighQualityMusic()));
        }
        else
        {
            log.debug("All files downloaded");
        }
    }

    /**
     * Queues the default track for immediate download in low-quality format.
     *
     * This is done so that when the user first enables music, the plugin
     * can hopefully start playing music right away
     */
    private void downloadDefaultTrack()
    {
        scheduler.execute(() ->
        {
            String url = BASE_DOWNLOAD_URL + "lo/" + DEFAULT_TRACK;

            try
            {
                downloadFile(url, LO_LOCAL_PATH.resolve(DEFAULT_TRACK));
            }
            catch (IOException e)
            {
                log.debug("Failed to download Default Track: {}", e.getMessage());
            }
        });
    }

    /**
     * Updates the download state fields downloadedCountLo, downloadedCountHi,
     * allLoDownloaded, and #allHiDownloaded based on the current files present in each quality folder.
     *
     * If high-quality music is disabled in config, allHiDownloaded is set to true
     * so that the rest of the logic treats the set as "complete".
     */
    private void checkDownloadState()
    {
        downloadedCountLo = countExistingTracks(builtinTracks, LO_LOCAL_PATH);
        downloadedCountHi = countExistingTracks(builtinTracks, HI_LOCAL_PATH);

        allLoDownloaded = allTracksExist(builtinTracks, LO_LOCAL_PATH);

        if (config.useHighQualityMusic())
        {
            allHiDownloaded = allTracksExist(builtinTracks, HI_LOCAL_PATH);
        }
        else
        {
            allHiDownloaded = true;
        }
    }

    /**
     * Checks whether every expected music track file exists in a specified directory.
     *
     * It is used to confirm that all required built-in music tracks for a given
     * quality level (low or high) have been successfully downloaded and stored locally.
     *
     * @param tracks the list of MusicTrackOption entries to check.
     *               Each entry provides a file name to look for.
     * @param dir    the directory Path in which the track files are expected to be found.
     *               This should point to either the "lo" or "hi" music download folder.
     * @return true if every track in tracks exists in dir;
     *         false as soon as a missing file is found.
     */
    private boolean allTracksExist(List<MusicTrackOption> tracks, Path dir)
    {
        for (MusicTrackOption track : tracks)
        {
            if (!Files.exists(dir.resolve(track.getResourceName())))
            {
                return false;
            }
        }
        return true;
    }

    /**
     * Counts how many of the expected track files currently exist in a given directory.
     *<p>
     * @param tracks the list of MusicTrackOption entries to check for.
     * @param dir    the directory Path in which the track files are expected to be found.
     * @return the number of tracks in tracks that exist in dir.
     */
    private int countExistingTracks(List<MusicTrackOption> tracks, Path dir)
    {
        int count = 0;
        for (MusicTrackOption track : tracks)
        {
            if (Files.exists(dir.resolve(track.getResourceName())))
            {
                count++;
            }
        }
        return count;
    }

    /**
     * Schedules the next missing download, prioritizing low-quality tracks first.
     *
     * If all low-quality tracks are present, and includeHi is true,
     * this method will then schedule high-quality tracks. Only one track is queued per call,
     * the method is called again after each download finishes.
     *
     * @param includeHi whether to also download high-quality tracks once low-quality is complete.
     */
    private void scheduleDownloads(boolean includeHi)
    {
        // Keep counts and booleans up-to-date
        checkDownloadState();

        // Low-quality first
        for (MusicTrackOption track : builtinTracks)
        {
            Path loPath = LO_LOCAL_PATH.resolve(track.getResourceName());
            if (!Files.exists(loPath))
            {
                queueDownload(track, false);
                return;
            }
        }

        // Then high-quality
        if (includeHi)
        {
            for (MusicTrackOption track : builtinTracks)
            {
                Path hiPath = HI_LOCAL_PATH.resolve(track.getResourceName());
                if (!Files.exists(hiPath))
                {
                    queueDownload(track, true);
                    return;
                }
            }
        }
    }

    /**
     * Schedules a single file download for a specific track in either low- or high-quality format.
     *
     * The scheduled task will:
     * Wait the configured delay before starting (longer for high-quality).
     * Attempt to download the file from BASE_DOWNLOAD_URL.
     * On completion, call scheduleDownloads to queue the next missing track.
     *
     * @param track the MusicTrackOption to download.
     * @param hi    true to download the high-quality version; false for low-quality.
     */
    private void queueDownload(MusicTrackOption track, boolean hi)
    {
        Path targetPath;
        String quality;
        int delayMs;

        if (hi)
        {
            quality = "hi";
            targetPath = HI_LOCAL_PATH.resolve(track.getResourceName());
            delayMs = 6 * DELAY_MULTIPLIER;
        }
        else
        {
            quality = "lo";
            targetPath = LO_LOCAL_PATH.resolve(track.getResourceName());
            delayMs = DELAY_MULTIPLIER;
        }

        String url = BASE_DOWNLOAD_URL + quality + "/" + track.getResourceName();

        scheduler.schedule(() ->
        {
            try
            {
                downloadFile(url, targetPath);
                log.debug("Downloading: {}", track);
            }
            catch (IOException e)
            {
                log.debug("Failed to download {} ({}): {}", track, quality, e.getMessage());
            }

            // Continue with next file
            scheduleDownloads(config.useHighQualityMusic());

        }, delayMs, TimeUnit.MILLISECONDS);
    }

    /**
     * Downloads a single file from the given URL and writes it to disk.
     *
     * This method:
     * <ul>
     *   <li>Creates the parent directories if they don't exist.</li>
     *   <li>Makes an HTTP GET request.</li>
     *   <li>Writes the response body to the specified output path, replacing any existing file.</li>
     * </ul>
     * If the HTTP request fails or the response body is null, no file is written.
     *
     * @param url        the full HTTP URL to the file.
     * @param outputPath the target file path to write to.
     * @throws IOException if an I/O error occurs during download or file write.
     */
    private void downloadFile(String url, Path outputPath) throws IOException
    {
        log.debug("Downloading a file, URL: {} OutputPath: {}", url, outputPath);

        Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "TickBeats-Plugin")
                .build();

        try (Response response = httpClient.newCall(request).execute())
        {
            if (!response.isSuccessful())
            {
                log.debug("HTTP Request failed: {}", response.code());
                return;
            }

            if (response.body() == null)
            {
                log.debug("Response body was null for URL: {}", url);
                return;
            }

            Files.createDirectories(outputPath.getParent());

            try (InputStream in = response.body().byteStream())
            {
                Files.copy(in, outputPath, StandardCopyOption.REPLACE_EXISTING);
            }
        }
    }

    /**
     * Shuts down the download manager and stops any pending or running download tasks.
     *
     * Called when the plugin is unloaded to ensure no background threads remain active.
     */
    public void shutdown()
    {
        log.debug("Shutting down DownloadManager");
        scheduler.shutdownNow();
    }
}
package com.TickBeatsMetronome;

import lombok.Getter;

import javax.inject.Inject;
import javax.sound.sampled.AudioFormat;
import java.util.List;

/**
 * Represents a full music track composed of multiple 600ms beat segments.
 * Tracks are internally structured as a flat list of beats,
 * where every 4 beats form a bar (assuming a 4/4 time signature).
 */
public class MusicTrack
{
    /** The MusicTrackOption for this music track */
    @Getter
    private final MusicTrackOption musicTrackOption;

    /** A nice looking display name to use for displaying the track name */
    @Getter
    private final String displayName;

    /** Flat list of MusicBeat objects that make up the full track */
    @Getter
    private final List<MusicBeat> beats;

    /** Audio format (e.g., 44.1 kHz, 16-bit PCM, stereo) */
    @Getter
    private final AudioFormat format;

    /** Constant: number of beats in a single bar (e.g., 4 for 4/4 time) */
    public static final int BEATS_PER_BAR = 4;

    /**
     * Constructs a new MusicTrack object from the parsed beat list and audio format.
     *
     * @param musicTrackOption  The MusicTrackOption enum for this track
     * @param displayName A user-friendly name to use when displaying this tracks name to the user
     * @param beats  A list of MusicBeat segments extracted from the audio
     * @param format The shared audio format for all beats in the track
     */
    public MusicTrack(MusicTrackOption musicTrackOption, String displayName, List<MusicBeat> beats, AudioFormat format)
    {
        this.musicTrackOption = musicTrackOption;
        this.displayName = displayName;
        this.beats = beats;
        this.format = format;
    }

    /** @return The total number of full bars in the track. */
    public int getNumberBarsInTrack()
    {
        return (int) Math.floor((double) beats.size() / BEATS_PER_BAR);
    }

    /**
     * Retrieves a specific beat based on bar and beat number (both 1-based).
     *
     * @param bar  The 1-based bar number
     * @param beat The 1-based beat number within the bar (must be between 1 and BEATS_PER_BAR)
     * @return The MusicBeat object, or null if the bar/beat index is invalid or out of range
     */
    public MusicBeat getBeat(int bar, int beat)
    {
        // Reject invalid beat numbers (e.g., 0 or > 4)
        if (beat < 1 || beat > BEATS_PER_BAR)
            return null;

        // Convert 1-based bar/beat to a 0-based flat index
        int index = (bar - 1) * BEATS_PER_BAR + (beat - 1);

        // Validate index is within bounds
        if (index >= 0 && index < beats.size())
            return beats.get(index);

        return null;
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.Keybind;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

/*
 * Listens for hotkey input for adjusting the metronome
 */
@Slf4j
@Singleton
public class InputManager implements net.runelite.client.input.KeyListener
{
    @Inject
    TickBeatsMetronomePlugin plugin;

    @Inject
    TickBeatsMetronomeConfig config;

    @Inject
    MusicPlaylistManager musicPlaylistManager;

    // Stores if reset key is currently being held down
    public boolean resetActive = false;

    // KeyPressed KeyEvent returns all the modifier keys (CTRL, ALT, SHIFT etc.) pressed merged together.
    // if multiple modifier keys are held down including the one you're looking for bitmasks need to be used
    // to find the key we're looking for from the combined value.
    @Override
    public void keyPressed(KeyEvent e)
    {
        // Check if the reset hotkey is being held down
        updateResetKey(e);
    }

    // keyReleased() seems to only return 1 key as opposed to keyPressed() which returns all keys held merged together,
    // however .matches(e) doesn't seem to work with modifier and key combos so we use our own custom version
    @Override
    public void keyReleased(KeyEvent e)
    {
        // Canceling reset hotkey on any key release feels a little lazy, but logic was causing missed releases
        // especially when using key combinations, in practice this behaves better, but will cancel reset hold if any other
        // keys are released
        resetActive = false;

        // Handle hotkey for next song
        if (strictMatch(config.nextSongHotkey(), e))
        {
            musicPlaylistManager.playNextSong();
            return;
        }

        // Handle hotkey for previous song
        if (strictMatch(config.previousSongHotkey(), e))
        {
            musicPlaylistManager.playPreviousSong();
            return;
        }

        // Handle hotkey for next beat
        if (strictMatch(config.nextBeatHotkey(), e))
        {
            adjustBeat(1);
            return;
        }

        // Handle hotkey for previous beat
        if (strictMatch(config.previousBeatHotkey(), e))
        {
            adjustBeat(-1);
            return;
        }

        // Handle add tick hotkey
        if(strictMatch(config.nextTickHotkey(), e))
        {
            adjustTick(1); // Increase the metronome tick
            return;
        }

        // Handle subtract tick hotkey
        if (strictMatch(config.previousTickHotkey(), e))
        {
            adjustTick(-1); // Decrease the metronome tick
        }
    }

    @Override
    public void keyTyped(KeyEvent e)
    {
        // Not used
    }

    private boolean strictMatch(Keybind keybind, KeyEvent e)
    {
        // Case 1: Modifier-only keybind (e.g., Ctrl, Alt)

        // Runelite Keybinds and KeyEvents are made up of 2 numbers, a Key Code Number and a Modifier Number
        // There's a gotcha where when just a modifier key is held by itself (not a modifier key with another key like CTRL+A)
        // the KeyEvent returns a key code number, and not the right modifier number that the RL Keybind is looking for.
        // The RL keybind is looking for just a modifier number but not the one that was returned by the KeyEvent
        // to accurately get the modifier number RL is looking for, we use the key events key code number
        // to figure out what the modifier number should be as far as Runelite is concerned

        // first check if Runelite is looking for a modifier key with no key code, then we know
        // that it's the scenario of a modifier key by itself being used as the Runelite hotkey
        if (keybind.getKeyCode() == 0 && keybind.getModifiers() != 0)
        {
            // Get the modifier number we're looking for from our Runelite keybind
            int requiredModifierNumber = keybind.getModifiers();

            // If the keyboard event key code belongs to a modifier key continue, else it's not a match
            if (isModifierKeyCode(e.getKeyCode()))
            {
                // Use our event keycode to figure out what its modifier key number should be (as far as Runelite is concerned)
                int eventModifierNumber = getModifierNumberFromKeyCode(e.getKeyCode());

                // If our new events modifier number is a match to the modifier our runelite keybind is looking for, return true
                return eventModifierNumber == requiredModifierNumber;
            }

            return false;
        }

        // Case 2: Regular key + optional modifier
        boolean keyMatch = e.getKeyCode() == keybind.getKeyCode();

        // Use a bitmask to check if our modifier key is in the modifier keys in the key event
        boolean modifiersMatch = (e.getModifiersEx() & keybind.getModifiers()) == keybind.getModifiers();

        // If both the keycode and the modifiers match return true
        return keyMatch && modifiersMatch;
    }

    // Check if a keycode is the keycode for a modifier key
    private boolean isModifierKeyCode(int keyCode)
    {
        return keyCode == KeyEvent.VK_SHIFT ||
                keyCode == KeyEvent.VK_CONTROL ||
                keyCode == KeyEvent.VK_ALT ||
                keyCode == KeyEvent.VK_META ||
                keyCode == KeyEvent.VK_ALT_GRAPH;
    }

    // Use a keycode number to determine what its modifier number should be (the modifier number Runelite is looking for)
    private int getModifierNumberFromKeyCode(int keyCode)
    {
        switch (keyCode)
        {
            case KeyEvent.VK_SHIFT: return InputEvent.SHIFT_DOWN_MASK;
            case KeyEvent.VK_CONTROL: return InputEvent.CTRL_DOWN_MASK;
            case KeyEvent.VK_ALT: return InputEvent.ALT_DOWN_MASK;
            case KeyEvent.VK_META: return InputEvent.META_DOWN_MASK;
            case KeyEvent.VK_ALT_GRAPH: return InputEvent.ALT_GRAPH_DOWN_MASK;
            default: return 0;
        }
    }

    // Check if the reset hotkey is being held down
    public void updateResetKey(KeyEvent e){

        // This check uses bitmasks to work with modifier keys
        if (strictMatch(config.resetHotkey(), e))
        {
            resetActive = true;
            plugin.tickCount = config.startTick();
        } else{
            resetActive = false;
        }
    }

    /**
     * Manually adjust the current tick (via key listener). Wraps correctly based on config.
     * @param delta The amount to add/subtract (e.g., -1 to go back, +1 to go forward)
     */
    private void adjustTick(int delta)
    {

        // Get max ticks based on current beat
        int maxTicks;
        switch (plugin.beatNumber) {
            case 1: maxTicks = config.beat1TickCount(); break;
            case 2: maxTicks = config.beat2TickCount(); break;
            case 3: maxTicks = config.beat3TickCount(); break;
            default: maxTicks = config.beat1TickCount(); break;
        }
        // Calculate the plugin tick count using modulo while staying 1 based (not 0 based)
        plugin.tickCount = ((plugin.tickCount - 1 + delta + maxTicks) % maxTicks) + 1;
    }

    /**
     * Manually adjust the current beat number (via key listener). Wraps between 1 and the configured max beat count.
     * @param delta The amount to add/subtract (e.g., -1 to go back, +1 to go forward)
     */
    private void adjustBeat(int delta)
    {
        // Clamp to the user defined beats
        int maxBeats = config.enabledBeats();

        // Update beatNumber using modulo logic to wrap between 1 and maxBeats
        plugin.beatNumber = ((plugin.beatNumber - 1 + delta + maxBeats) % maxBeats) + 1;
    }
}

package com.TickBeatsMetronome;

import javax.inject.Inject;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Singleton;
import java.util.concurrent.*;

/**
 * LocalTickManager tracks tick timing independently though with the help of RuneLite's game tick events,
 * it works by nudging a few milliseconds towards the game tick, every game tick, imperceptibly drifting towards
 * an almost perfect average to determine exactly when server ticks should happen without jitter caused by lag
 * for when a metronome that sounds good and consistent is more important than perfect game ticks that include server lag
 */
@Slf4j
@Singleton
public class LocalTickManager
{
    // Base values
    private static final long BASE_TICK_INTERVAL_MS = 600; // Standard tick duration
    private static final long MAX_ADJUSTMENT_MS = 5;      // Maximum per-tick interval correction in milliseconds

    // Tick counters
    @Getter
    private int gameTickCount = 0;   // Increments each time onGameTick fires
    @Getter
    private int localTickCount = 0;  // Increments each time local tick fires

    // Time tracking
    @Getter
    private long lastLocalTickTime = 0;         // Timestamp of the last local tick
    @Getter
    private long lastGameTickTime = 0;         // Timestamp of the last game tick

    private long nextTickInterval = BASE_TICK_INTERVAL_MS;

    // Executor for scheduling ticks
    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
    private ScheduledFuture<?> tickLoop = null;

    // Logic to run on each local tick
    private final Runnable onTickCallback;

    @Inject
    public LocalTickManager(Runnable onTickCallback)
    {
        this.onTickCallback = onTickCallback;
    }

    /**
     * We use this to make sure our local metronome is relatively in sync with game ticks.
     */
    public void updateLocalTick()
    {
        lastGameTickTime = System.currentTimeMillis();
        gameTickCount++;

        // If local metronome hasn't incremented yet, start it up
        if(localTickCount == 0){
            localTickCount++;
            start();
        }

        // So the tick counts don't count up infinitely, not really needed though
        int gameTickMax = 2000000000;
        if(gameTickCount >= gameTickMax){
            gameTickCount = gameTickCount - gameTickMax;
            localTickCount = localTickCount - gameTickMax;
        }

        // It appears logging in or world hopping can cause an offset of a few hundred ms
        // This is used to allow for a more aggressive tick correction at the start to speed up syncing to game ticks
        long maxAdjustment;
        if(gameTickCount < 10){
            // Used to make tick correction less aggressive with each tick
            long multiplier = 10 - gameTickCount;
            maxAdjustment = 10 * multiplier;
        }else{
            maxAdjustment = MAX_ADJUSTMENT_MS;
        }

        // If for some reason ticks get way out of sync make them equal to each other
        int tickDifference = gameTickCount - localTickCount;
        if (tickDifference > 1 || tickDifference < 0){
            localTickCount = gameTickCount;
            log.debug("Correcting out of sync ticks");
        }

        long timeDifference;

        // If gametick is ahead of local tick then the next local tick needs to happen sooner than 600ms else later
        if(gameTickCount > localTickCount)
        {
            // If game tick is before local tick
            // Calculate when the next local tick is set to fire using the same logic as the local tick scheduler
            long nextLocalTickTime = lastLocalTickTime + nextTickInterval;

            // Get the time difference of how far off the local tick is from this game tick
            // Negative time difference means game tick is earlier positive means local tick is earlier
            timeDifference = lastGameTickTime - nextLocalTickTime;

            // If the time difference between local and game ticks is less than our max adjustment
            // adjust by that much to make things slightly more accurate
            // else subtract our max adjustment from 600ms to get the next tick interval
            if(Math.abs(timeDifference) < maxAdjustment)
            {
                nextTickInterval = BASE_TICK_INTERVAL_MS - Math.abs(timeDifference);
            }else{
                nextTickInterval = BASE_TICK_INTERVAL_MS - maxAdjustment;
            }
        }else{
            // If game tick is after local tick use the tick counts to see how far apart they are
            timeDifference = lastGameTickTime - lastLocalTickTime;

            // If the time difference is less than our max adjustment,
            // adjust by that much to make things slightly more accurate
            if(timeDifference < maxAdjustment)
            {
                nextTickInterval = BASE_TICK_INTERVAL_MS + timeDifference;
            }else{
                nextTickInterval = BASE_TICK_INTERVAL_MS + maxAdjustment;
            }
        }
    }

    /*
     * Starts the local tick loop
     * This schedules the first tick after receiving the first GameTick
     */
    public void start()
    {
        // Don't start twice
        if (tickLoop != null)
        {
            return;
        }

        log.debug("Starting local tick loop.");
        lastLocalTickTime = System.currentTimeMillis();
        scheduleNextTick();
    }

    /*
     * Schedules the next local tick
     * Each tick reschedules itself with a slightly adjusted interval
     */
    private void scheduleNextTick()
    {
        tickLoop = executor.schedule(() -> {
            // Run local metronome
            onTickCallback.run();

            //save the current time
            lastLocalTickTime = System.currentTimeMillis();

            // Count this local tick
            localTickCount++;

            // Schedule the next tick
            scheduleNextTick();

        }, nextTickInterval, TimeUnit.MILLISECONDS); //schedule the next local tick according to our tick interval
    }

    /*
     * Stops the local tick loop and resets all counters/timers
     * Call on logout or shutdown
     */
    public void reset()
    {
        log.debug("Resetting local tick manager.");

        // Stop any active tick loops
        stopTickLoop();

        // Reset counters and timing
        gameTickCount = 0;
        localTickCount = 0;
        lastLocalTickTime = 0;
        nextTickInterval = BASE_TICK_INTERVAL_MS;
    }

    /*
     * Stops any active tick loop.
     */
    private void stopTickLoop()
    {
        if (tickLoop != null)
        {
            tickLoop.cancel(true);
            tickLoop = null;
        }
    }

    /*
     * Completely shuts down the local tick manager and background thread.
     * Call this in plugin's shutDown().
     */
    public void shutdown()
    {
        log.debug("Shutting down local tick manager.");
        reset();
        executor.shutdownNow();
    }
}
package com.TickBeatsMetronome;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;

public class OverlayColor extends Overlay {

    @Inject
    Client client;

    @Inject
    TickBeatsMetronomePlugin plugin;

    @Inject
    TickBeatsMetronomeConfig config;

    @Inject
    private OverlayColor() {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.enableColorOverlay()) {
            return null;
        }

        // Get the appropriate color and opacity based on the current beat and tick count
        Color tickColor;
        float opacity;
        
        if (plugin.beatNumber == 1) {
            switch (plugin.tickCount) {
                case 1: tickColor = config.beat1Tick1Color(); opacity = config.beat1Tick1Opacity() / 100f; break;
                case 2: tickColor = config.beat1Tick2Color(); opacity = config.beat1Tick2Opacity() / 100f; break;
                case 3: tickColor = config.beat1Tick3Color(); opacity = config.beat1Tick3Opacity() / 100f; break;
                case 4: tickColor = config.beat1Tick4Color(); opacity = config.beat1Tick4Opacity() / 100f; break;
                case 5: tickColor = config.beat1Tick5Color(); opacity = config.beat1Tick5Opacity() / 100f; break;
                case 6: tickColor = config.beat1Tick6Color(); opacity = config.beat1Tick6Opacity() / 100f; break;
                case 7: tickColor = config.beat1Tick7Color(); opacity = config.beat1Tick7Opacity() / 100f; break;
                case 8: tickColor = config.beat1Tick8Color(); opacity = config.beat1Tick8Opacity() / 100f; break;
                case 9: tickColor = config.beat1Tick9Color(); opacity = config.beat1Tick9Opacity() / 100f; break;
                default: tickColor = Color.WHITE; opacity = 0f; break;
            }
        } else if (plugin.beatNumber == 2) {
            switch (plugin.tickCount) {
                case 1: tickColor = config.beat2Tick1Color(); opacity = config.beat2Tick1Opacity() / 100f; break;
                case 2: tickColor = config.beat2Tick2Color(); opacity = config.beat2Tick2Opacity() / 100f; break;
                case 3: tickColor = config.beat2Tick3Color(); opacity = config.beat2Tick3Opacity() / 100f; break;
                case 4: tickColor = config.beat2Tick4Color(); opacity = config.beat2Tick4Opacity() / 100f; break;
                case 5: tickColor = config.beat2Tick5Color(); opacity = config.beat2Tick5Opacity() / 100f; break;
                case 6: tickColor = config.beat2Tick6Color(); opacity = config.beat2Tick6Opacity() / 100f; break;
                case 7: tickColor = config.beat2Tick7Color(); opacity = config.beat2Tick7Opacity() / 100f; break;
                case 8: tickColor = config.beat2Tick8Color(); opacity = config.beat2Tick8Opacity() / 100f; break;
                case 9: tickColor = config.beat2Tick9Color(); opacity = config.beat2Tick9Opacity() / 100f; break;
                default: tickColor = Color.WHITE; opacity = 0f; break;
            }
        } else {
            switch (plugin.tickCount) {
                case 1: tickColor = config.beat3Tick1Color(); opacity = config.beat3Tick1Opacity() / 100f; break;
                case 2: tickColor = config.beat3Tick2Color(); opacity = config.beat3Tick2Opacity() / 100f; break;
                case 3: tickColor = config.beat3Tick3Color(); opacity = config.beat3Tick3Opacity() / 100f; break;
                case 4: tickColor = config.beat3Tick4Color(); opacity = config.beat3Tick4Opacity() / 100f; break;
                case 5: tickColor = config.beat3Tick5Color(); opacity = config.beat3Tick5Opacity() / 100f; break;
                case 6: tickColor = config.beat3Tick6Color(); opacity = config.beat3Tick6Opacity() / 100f; break;
                case 7: tickColor = config.beat3Tick7Color(); opacity = config.beat3Tick7Opacity() / 100f; break;
                case 8: tickColor = config.beat3Tick8Color(); opacity = config.beat3Tick8Opacity() / 100f; break;
                case 9: tickColor = config.beat3Tick9Color(); opacity = config.beat3Tick9Opacity() / 100f; break;
                default: tickColor = Color.WHITE; opacity = 0f; break;
            }
        }

        // Create a new color with the configured opacity
        Color overlayColor = new Color(
            tickColor.getRed(),
            tickColor.getGreen(),
            tickColor.getBlue(),
            Math.round(opacity * 255)
        );

        // Fill the entire canvas with the color
        graphics.setColor(overlayColor);
        graphics.fillRect(0, 0, client.getCanvasWidth(), client.getCanvasHeight());

        return null;
    }
} 
package com.TickBeatsMetronome;

import javax.sound.sampled.AudioFormat;

/**
 * TickSound
 *
 * Represents a single cached tick sound in memory.
 * Stores both:
 * - The AudioFormat (sample rate, channels, encoding, etc.)
 * - The raw PCM audio data (decoded bytes)
 */
public class TickSound
{
    private final AudioFormat format;
    private final byte[] data;

    public TickSound(AudioFormat format, byte[] data)
    {
        this.format = format;
        this.data = data;
    }

    /**
     * Get the audio format describing the PCM data.
     */
    public AudioFormat getFormat()
    {
        return format;
    }

    /**
     * Get the raw PCM audio data for this sound.
     */
    public byte[] getData()
    {
        return data;
    }
}
package com.TickBeatsMetronome;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;

@Slf4j
@Singleton
public class MusicManager
{

    @Inject
    private TickBeatsMetronomeConfig config;

    @Inject
    private OverlayMessage overlayMessage;

    @Inject
    private MusicTrackLoader musicTrackLoader;

    @Inject
    private  MusicPlaylistManager musicPlaylistManager;

    @Getter
    private MusicTrack currentTrack = null;

    private int volume = 100;
    private int currentBar = 1;
    //bar beat should always be 1 - 4 referencing a beat in the bar
    private int barBeat = 1;
    //current beat that matches the game tick number
    private int tickBeat = 1;

    @Getter
    private boolean isPlaying = false;

    //this is used to play the last beat/notes of the 4 beat per bar songs when doing 3 beats per bar for 3 tick
    private boolean playFinalFourthBeatNext = false;

    /**
     * Preps a track to start being played on tick 1 when start is called()
     * This will only reset the track if it's a new track, if the track to load is the track that's already playing it won't do anything
     */
    public void prepMusicTrack()
    {
        MusicTrackOption newMusicTrackOption = null;

        // Manual mode: get track from config
        if (config.playbackMode() == TickBeatsMetronomeConfig.PlaybackMode.MANUAL) {
            newMusicTrackOption = config.musicTrack();
        }
        // Playlist mode: get track from playlist manager
        else {
            newMusicTrackOption = musicPlaylistManager.getCurrentTrack();
        }

        // If no valid track is selected, stop playback
        if (newMusicTrackOption == null || newMusicTrackOption == MusicTrackOption.NONE) {
            currentTrack = null;
            return;
        }

        // If we already have this track loaded, donâ€™t reload
        if (currentTrack != null && currentTrack.getMusicTrackOption() == newMusicTrackOption) {
            return;
        }

        // Stop the current song so it can start cleanly on tick 1
        stop();

        // Load the new track
        loadTrack(newMusicTrackOption);
    }

    /**
     * Resets the track and sets isPlaying to true
     * Note: the current setup causes this to run every time a track ends and a new one starts up
     */
    public void start()
    {

        // Run prep the track every time we run start it'll check again for the proper track every restart
        prepMusicTrack();

        // If current track is null abort the start (start should try to run again on tick 1)
        if(currentTrack == null){
            return;
        }
        // Set isPlaying to true at the start, if loadTrack can't find the track it'll set it to false
        isPlaying = true;

        // Reset our bar, beat and tick numbers to 1
        reset();
    }

    /**
     * Loads a track based on its MusicTrackOption.
     */
    private void loadTrack(MusicTrackOption option)
    {
        // Reset state and clear old track
        currentTrack = null;
        reset();

        currentTrack = musicTrackLoader.loadFromResource(option);

        if (currentTrack == null) {
            stop();
        }
    }

    /**
     * resets the track and sets isPlaying to false
     */
    public void stop()
    {
        reset();
        isPlaying = false;
    }

    /**
     * sets current bar, bar beat, and tick beat to 1 effectively resetting the track
     */
    public void reset()
    {
        currentBar = 1;
        barBeat = 1;
        tickBeat = 1;
    }

    /**
     * Called on every tick (local or game tick depends on plugin settings). Handles advancing music playback.
     * @param tickCount How many ticks per beat the user has configured
     * @param pluginTick Which tick this is within the current beat (1-based)
     * @param musicVolume How loud to play music clips, 100 is full, goes up to 150 for boosted audio
     */
    public void onTick(int tickCount, int pluginTick, int musicVolume) {

        //if for any reason the current track is null or is playing is set to false, stop the track and don't do anything
        if(currentTrack == null || !isPlaying){
            stop();
            return;
        }
        //set the volume field on every tick
        volume = musicVolume;

        //if the tick from our plugin doesn't match the music manager tick we're using to determine bar beat
        //update the Music Manager tick beat, this happens when the user adjust which tick they're on
        correctMusicManagerTick(tickCount, pluginTick);

        //if play final 4th beat is true (play the last beat/audio clip of the song)
        //songs can feel unfinished without the last note
        if (playFinalFourthBeatNext)
        {
            playBeat(currentTrack.getNumberBarsInTrack(), 4);
            currentBar++; // Increment the bar so that end of song triggers properly
            playFinalFourthBeatNext = false;
        }

        // If current bar is greater than the number of bars in the song, the song has played to completion
        if(currentBar > currentTrack.getNumberBarsInTrack()){

            // Tell playlist manager that the song has ended so increment to the next track
            musicPlaylistManager.incrementTrack();

            // Stop and reset the song
            stop();
            return;
        }

        // If for some reason the beat that will be played is null, stop the song and don't do anything else
        if (currentTrack.getBeat(currentBar, barBeat) == null)
        {
            stop();
            return;
        }

        // Dispatch logic by tick mode
        switch (tickCount) {
            case 1: handle1Tick(); break;
            case 2: handle2Tick(); break;
            case 3: handle3Tick(); break;
            case 5: handle5Tick(); break;
            case 6: handle6Tick(); break;
            case 7: handle7Tick(); break;
            case 8: handle8Tick(); break;
            case 9: handle9Tick(); break;
            case 4:
            default: handle4Tick(); break;
        }
    }

    /**
     * If the tick from our main plugin file doesn't match the MusicManager tickBeat, update the Music Manager Tick Beat
     * this happens when the user adjust which beat they're on or makes other plugin adjustments while music is playing
     * @param tickCount How many ticks per beat the user has configured
     * @param pluginTick the current tick as far as the main plugin file is concerned
     */
    private void correctMusicManagerTick(int tickCount, int pluginTick){
        // Tick counts 1 and 2 need special treatment because the plugin tick will only go up to 1 or 2,
        // but we want to play beats 3 and 4 of the music bar so tickBeat needs to be able to go up to 3 and 4 without "correcting"

        // If the user has Tick Count set to 1, the Plugin Tick will always be 1, so we don't correct for that, just play the music
        if (tickCount == 1){
            return;
        }

        // If Tick Count is set to 2 tick,
        // We want to make sure if plugin tick is 1, our Music Manager tickBeat is 1 or 3
        // and if our plugin tick is 2 our Music Manager tickBeat is set to 2 or 4 to play those parts of the bar
        if (tickCount == 2){

            //if the plugin tick is 1 but the tick beat is 2 or 4, we're out of sync
            if (pluginTick == 1){
                if (tickBeat == 2 || tickBeat == 4) {
                    //set the music manager tick to match the plugin's tick
                    tickBeat = pluginTick;
                }
            }

            //if the plugin tick is 2 but the Music Manager tick beat is 1 or 3, we're out of sync
            if (pluginTick == 2){
                if (tickBeat == 1 || tickBeat == 3) {
                    //set the music manager tick to match the plugin's tick
                    tickBeat = pluginTick;
                }
            }

            return;
        }

        //In all other scenarios the music manager Tick Beat and the Plugin Tick should match
        if(pluginTick != tickBeat){
            tickBeat = pluginTick;
        }
    }

    // -- Tick Handlers --
    //1 tick plays 4 beat per bar music as is
    private void handle1Tick()
    {
        barBeat = tickBeat;

        playBeat(currentBar, barBeat);

        tickBeat++;

        if (tickBeat >= 5) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //2 tick plays 4 beat per bar music as is
    private void handle2Tick()
    {
        barBeat = tickBeat;

        playBeat(currentBar, barBeat);
        tickBeat++;
        if (tickBeat >= 5) {
            tickBeat = 1;
            currentBar++;
        }
    }

    /// 3 tick will play the music with a 3/4 time signature / 3 beats per bar by removing the last beat from each bar
    private void handle3Tick()
    {
        barBeat = tickBeat;

        // If we're on the final bar, queue up beat 4 for next tick to play the last notes / beat in the song
        // Songs often feel unsatisfying or incomplete without the last note.
        if (currentTrack.getNumberBarsInTrack() == currentBar && barBeat >= 3)
        {
            playFinalFourthBeatNext = true;
        }

        playBeat(currentBar, barBeat);
        tickBeat++;

        // 3-tick loop
        if (tickBeat >= 4)
        {
            tickBeat = 1;
            currentBar++;
        }
    }

    //Songs are currently required to have a 4/4 time signature so they work very well with 4 tick
    private void handle4Tick()
    {
        barBeat = tickBeat;

        playBeat(currentBar, barBeat);
        tickBeat++;
        if (tickBeat >= 5) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //5 tick replays the last note of the bar (not ideal but sounds ok most of the time)
    private void handle5Tick()
    {
        barBeat = tickBeat;

        //replay the last note of the bar on beat 5
        if (tickBeat == 5){
            barBeat = 4;
        }

        playBeat(currentBar, barBeat);

        tickBeat++;

        if (tickBeat >= 6) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //6 tick will play 2 3 beat bars, removing the last note from each bar
    private void handle6Tick()
    {
        barBeat = tickBeat;

        //if tickBeat >=4 we advanced to the next bar of music
        //subtract 3 from tickBeat to get the proper beat from this bar
        if(tickBeat >= 4){
            barBeat = tickBeat - 3;
        }

        // If we're on the final bar, queue up beat 4 for next tick to play the last notes / beat in the song
        // Songs often feel unsatisfying or incomplete without the last note.
        if (currentTrack.getNumberBarsInTrack() == currentBar && barBeat >= 3)
        {
            playFinalFourthBeatNext = true;
        }

        playBeat(currentBar, barBeat);
        tickBeat++;

        //because we're using 3/4 for 6 tick, when we hit beat 4 move to the next bar in the music
        if(tickBeat == 4){
            currentBar++;
        }

        //once tick beat hits 7, reset tickBeat and move on to the next bar
        if (tickBeat >= 7) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //7 tick will remove the last beat on every other bar so will play alternating 4 beat bars and 3 beat bars
    private void handle7Tick()
    {
        barBeat = tickBeat;

        //if we're >=5 we advanced to the next bar of music
        //subtract 4 to get the proper beat from this bar
        if(tickBeat >= 5){
            barBeat = tickBeat - 4;
        }

        // If we're on the final bar, and only if tick beat is set to 7 queue up the 4th note
        // we only want to queue up the 4th note if we're on the 3/4 second bar
        if (currentTrack.getNumberBarsInTrack() == currentBar && tickBeat == 7)
        {
            playFinalFourthBeatNext = true;
        }

        playBeat(currentBar, barBeat);
        tickBeat++;

        //when we hit beat 5 move to the next bar in the music
        if(tickBeat == 5){
            currentBar++;
        }

        if (tickBeat >= 8) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //8 tick will play 2 regular 4 beat bars
    private void handle8Tick()
    {
        barBeat = tickBeat;

        //if we're >=5 we advanced to the next bar of music
        //subtract 4 to get the proper beat from this bar
        if(tickBeat >= 5){
            barBeat = tickBeat - 4;
        }

        playBeat(currentBar, barBeat);
        tickBeat++;

        //when we hit beat 5 move to the next bar in the music
        //important Make sure this is after playBeat so we don't try to play a bar that doesn't exist
        if(tickBeat == 5){
            currentBar++;
        }

        if (tickBeat >= 9) {
            tickBeat = 1;
            currentBar++;
        }
    }

    //9 tick will play 3 3 beat bars, removing the last beat from every bar of music
    private void handle9Tick()
    {
        barBeat = tickBeat;

        //if the tick beat is 4 or greater it means we're on the next 3/4 bar so remove 3 to get the beat in the bar
        if(tickBeat >= 4){
            barBeat = barBeat - 3;
        }

        //if the tick beat is 7 or greater it means we're 2 3/4 bars in, so remove another 3 to get the beat in the bar
        if(tickBeat >= 7){
            barBeat = barBeat - 3;
        }

        // If we're on the final note of the final bar queue up the final note of the song to play on the next bar
        if (currentTrack.getNumberBarsInTrack() == currentBar && barBeat == 3)
        {
            playFinalFourthBeatNext = true;
        }

        playBeat(currentBar, barBeat);

        tickBeat++;

        //if after playing and incrementing the beat we're on beat 4 or 7 , move on to the next bar
        if(tickBeat == 4 || tickBeat == 7){
            currentBar++;
        }

        //once tick beat hits 10, reset tickBeat to 1 and move on to the next bar
        if (tickBeat >= 10) {
            tickBeat = 1;
            currentBar++;
        }
    }

    /**
     * Plays a 600ms audio clip for a specific bar and beat.
     * Uses Java's AudioSystem to load a new Clip and play it.
     * Ensures that Clips are always cleaned up to prevent memory leaks,
     * even in the case of playback failure.
     *
     * @param bar  the bar number in the track (1-based)
     * @param beat the beat number in the bar (1-based, typically 1â€“4)
     */
    public void playBeat(int bar, int beat)
    {
        // Make sure a track is loaded
        if (currentTrack == null)
        {
            log.debug("No track loaded.");
            return;
        }

        // Retrieve the audio data for the requested bar and beat
        MusicBeat musicBeat = currentTrack.getBeat(bar, beat);
        if (musicBeat == null)
        {
            log.debug("Invalid beat requested: bar={} beat={}", bar, beat);
            return;
        }

        try
        {
            // Fetch audio format and raw beat data (PCM bytes)
            AudioFormat format = currentTrack.getFormat();
            byte[] data = musicBeat.getAudioData();

            // Create a new Clip from the AudioSystem
            Clip clip = AudioSystem.getClip();

            // Load the audio data into the clip
            clip.open(format, data, 0, data.length);

            // Apply current volume settings
            setClipVolume(clip);

            // Register a listener to automatically close the clip after playback finishes
            clip.addLineListener(event -> {
                if (event.getType() == LineEvent.Type.STOP)
                {
                    clip.close(); // Clean up clip
                }
            });

            // Start playback (non-blocking)
            clip.start();
        }
        catch (Exception e)
        {
            log.debug("Failed to play beat at bar {} beat {}: {}", bar, beat, e.getMessage(), e);
        }
    }

    /**
     * Converts the plugin's volume percentage to decibels and sets it on the given audio clip
     * The volume percentage is stored in the `volume` field (0â€“150),
     * where 100 is standard volume and 150 is boosted.
     *
     * @param clip the Clip to apply volume adjustments to
     */
    private void setClipVolume(Clip clip)
    {
        // Check if the clip supports master gain control (volume)
        // if not return
        if (!clip.isControlSupported(FloatControl.Type.MASTER_GAIN))
        {
            return;
        }

        FloatControl volumeControl = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);

        double dB;

        // Avoid log10(0) (log10 shouldn't be 0 or negative) and handle 0 volume
        if (volume <= 0)
        {
            dB = volumeControl.getMinimum();
        }
        else
        {
            // Convert percentage to a volume ratio (0.0â€“1.0)
            float volumePercent = volume / 100f;

            // Convert to decibels using a log scale
            dB = Math.log10(volumePercent) * 20.0;
        }

        // Clamp volume to the supported dB range
        float minDb = volumeControl.getMinimum();
        float maxDb = volumeControl.getMaximum();

        if (dB < minDb)
        {
            dB = minDb;
        }
        else if (dB > maxDb)
        {
            dB = maxDb;
        }

        // Apply the decibel volume to the clip
        volumeControl.setValue((float) dB);
    }

}
package com.TickBeatsMetronome;

public enum TickSoundOption
{
    OFF("Off", ""),
    TICK("Tick", "tick.wav"),
    TICK_HIHAT("Tick Hi-Hat", "tick-hihat.wav"),
    TICK_HIHAT_2("Tick Hi-Hat 2", "tick-hihat-2.wav"),

    METRO_TICK("Metro Tick", "metro-tick.wav"),
    METRO_TICK_2("Metro Tick Strong", "metro-tick-strong.wav"),
    METRO_TOCK("Metro Tock", "metro-tock.wav"),

    BASS("Bass", "bass.wav"),
    BASS_2("Bass 2", "bass-2.wav"),
    BASS_3("Bass 3", "bass-3.wav"),
    BASS_ELECTRONIC("Bass Electronic", "bass-electronic.wav"),
    BASS_ELECTRONIC_2("Bass Electronic 2", "bass-electronic-2.wav"),
    BASS_ELECTRONIC_3("Bass Electronic 3", "bass-electronic-3.wav"),
    BASS_ELECTRONIC_4("Bass Electronic 4", "bass-electronic-4.wav"),
    BASS_ELECTRONIC_5("Bass Electronic 5", "bass-electronic-5.wav"),
    BASS_ELECTRONIC_6("Bass Electronic 6", "bass-electronic-6.wav"),

    CLAP("Clap", "clap.wav"),
    CLAP_2("Clap 2", "clap-2.wav"),
    CLAP_3("Clap 3", "clap-3.wav"),
    CLAP_SLAP("Clap Slap", "clap-slap.wav"),

    SNARE("Snare", "snare.wav"),
    SNARE_2("Snare 2", "snare-2.wav"),
    SNARE_3("Snare 3", "snare-3.wav"),

    CRACK_HIGH("Crack High", "crack-high.wav"),
    CRACK_LOW("Crack Low", "crack-low.wav"),

    X2_TICK("X2 Tick", "x2-tick.wav"),
    X2_BASS("X2 Bass", "x2-bass.wav"),
    X2_CLAP("X2 Clap", "x2-clap.wav"),

    // User Sounds
    USER_SOUND_1("User Sound 1", "1"),
    USER_SOUND_2("User Sound 2", "2"),
    USER_SOUND_3("User Sound 3", "3"),
    USER_SOUND_4("User Sound 4", "4"),
    USER_SOUND_5("User Sound 5", "5"),
    USER_SOUND_6("User Sound 6", "6"),
    USER_SOUND_7("User Sound 7", "7"),
    USER_SOUND_8("User Sound 8", "8"),
    USER_SOUND_9("User Sound 9", "9"),
    USER_SOUND_10("User Sound 10", "10"),
    USER_SOUND_11("User Sound 11", "11"),
    USER_SOUND_12("User Sound 12", "12"),
    USER_SOUND_13("User Sound 13", "13"),
    USER_SOUND_14("User Sound 14", "14"),
    USER_SOUND_15("User Sound 15", "15"),
    USER_SOUND_16("User Sound 16", "16"),
    USER_SOUND_17("User Sound 17", "17"),
    USER_SOUND_18("User Sound 18", "18"),
    USER_SOUND_19("User Sound 19", "19"),
    USER_SOUND_20("User Sound 20", "20");

    private final String displayName;
    private final String resourceName;

    TickSoundOption(String displayName, String resourceName)
    {
        this.displayName = displayName;
        this.resourceName = resourceName;
    }

    public String getResourceName()
    {
        return resourceName;
    }

    public boolean isUserSound()
    {
        return resourceName.matches("\\d+");
    }

    @Override
    public String toString()
    {
        return displayName;
    }
}


package com.TickBeatsMetronome;

public enum MusicTrackOption {
    NONE("None", ""),

    ALLS_FAIRY_IN_LOVE_AND_WAR("Alls Fairy In Love And War", "alls_fairy_in_love_and_war.wav"),
    AMASCUTS_PROMISE("Amascut's Promise", "amascuts_promise.wav"),
    ANGELS_FURY("Angels Fury", "angels_fury.wav"),
    AUTUMN_VOYAGE("Autumn Voyage", "autumn_voyage.wav"),
    BOOK_OF_SPELLS("Book Of Spells", "book_of_spells.wav"),
    FIRE_IN_THE_DEEP("Fire In The Deep", "fire_in_the_deep.wav"),
    FIRE_IN_THE_HOLE("Fire In The Hole !", "fire_in_the_hole.wav"),
    FLUTE_SALAD("Flute Salad", "flute_salad.wav"),
    GAUNTLET("Gauntlet", "gauntlet.wav"),
    HOME_SWEET_HOME("Home Sweet Home", "home_sweet_home.wav"),
    HORIZON("Horizon", "horizon.wav"),
    INFERNO("Inferno", "inferno.wav"),
    INTO_THE_TOMBS("Into The Tombs", "into_the_tombs.wav"),
    ISLE_OF_SERENITY("Isle Of Serenity", "isle_of_serenity.wav"),
    MOR_UL_REK("Mor Ul Rek", "mor_ul_rek.wav"),
    POWER_OF_THE_SHADOW_REALM("Power Of The Shadow Realm", "power_of_the_shadow_realm.wav"),
    PREDATOR_XARPUS("Predator Xarpus", "predator_xarpus.wav"),
    PROSPERING_FORTUNE("Prospering Fortune", "prospering_fortune.wav"),
    SCAPE_SOFT("Scape Soft", "scape_soft.wav"),
    SEA_SHANTY_2("Sea Shanty 2", "sea_shanty_2.wav"),
    SPIRIT("Spirit", "spirit.wav"),
    TRADE_PARADE("Trade Parade", "trade_parade.wav"),
    WALK_IN_THE_WOODS("Walk In The Woods", "walk_in_the_woods.wav"),
    WATCH_YOUR_STEP("Watch Your Step", "watch_your_step.wav"),
    WELCOME_TO_THE_THEATRE("Welcome To The Theatre", "welcome_to_the_theatre.wav"),

    // User Music
    // The Music files are given IDs based on their alphabetical order.
    USER_MUSIC_1("User Track 1", "1"),
    USER_MUSIC_2("User Track 2", "2"),
    USER_MUSIC_3("User Track 3", "3"),
    USER_MUSIC_4("User Track 4", "4"),
    USER_MUSIC_5("User Track 5", "5"),
    USER_MUSIC_6("User Track 6", "6"),
    USER_MUSIC_7("User Track 7", "7"),
    USER_MUSIC_8("User Track 8", "8"),
    USER_MUSIC_9("User Track 9", "9"),
    USER_MUSIC_10("User Track 10", "10"),
    USER_MUSIC_11("User Track 11", "11"),
    USER_MUSIC_12("User Track 12", "12"),
    USER_MUSIC_13("User Track 13", "13"),
    USER_MUSIC_14("User Track 14", "14"),
    USER_MUSIC_15("User Track 15", "15"),
    USER_MUSIC_16("User Track 16", "16"),
    USER_MUSIC_17("User Track 17", "17"),
    USER_MUSIC_18("User Track 18", "18"),
    USER_MUSIC_19("User Track 19", "19"),
    USER_MUSIC_20("User Track 20", "20"),
    USER_MUSIC_21("User Track 21", "21"),
    USER_MUSIC_22("User Track 22", "22"),
    USER_MUSIC_23("User Track 23", "23"),
    USER_MUSIC_24("User Track 24", "24"),
    USER_MUSIC_25("User Track 25", "25"),
    USER_MUSIC_26("User Track 26", "26"),
    USER_MUSIC_27("User Track 27", "27"),
    USER_MUSIC_28("User Track 28", "28"),
    USER_MUSIC_29("User Track 29", "29"),
    USER_MUSIC_30("User Track 30", "30"),
    USER_MUSIC_31("User Track 31", "31"),
    USER_MUSIC_32("User Track 32", "32"),
    USER_MUSIC_33("User Track 33", "33"),
    USER_MUSIC_34("User Track 34", "34"),
    USER_MUSIC_35("User Track 35", "35"),
    USER_MUSIC_36("User Track 36", "36"),
    USER_MUSIC_37("User Track 37", "37"),
    USER_MUSIC_38("User Track 38", "38"),
    USER_MUSIC_39("User Track 39", "39"),
    USER_MUSIC_40("User Track 40", "40"),
    USER_MUSIC_41("User Track 41", "41"),
    USER_MUSIC_42("User Track 42", "42"),
    USER_MUSIC_43("User Track 43", "43"),
    USER_MUSIC_44("User Track 44", "44"),
    USER_MUSIC_45("User Track 45", "45"),
    USER_MUSIC_46("User Track 46", "46"),
    USER_MUSIC_47("User Track 47", "47"),
    USER_MUSIC_48("User Track 48", "48"),
    USER_MUSIC_49("User Track 49", "49"),
    USER_MUSIC_50("User Track 50", "50");

    private final String displayName;
    private final String resourceName;

    MusicTrackOption(String displayName, String resourceName) {
        this.displayName = displayName;
        this.resourceName = resourceName;
    }

    public String getResourceName() {
        return resourceName;
    }

    public String getDisplayName() {
        return displayName;
    }

    public boolean isUserMusic()
    {
        return resourceName.matches("\\d+");
    }

    //Make it so that in UI menus we get the nice display name
    @Override
    public String toString() {
        return displayName;
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Slf4j
@Singleton
public class OverlayInfoBox extends Overlay
{
    @Inject
    TickBeatsMetronomePlugin plugin;

    @Inject
    TickBeatsMetronomeConfig config;

    @Inject
    DownloadManager downloadManager;

    @Inject
    MusicManager musicManager;

    private final PanelComponent panel = new PanelComponent();

    @Inject
    public OverlayInfoBox()
    {
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Only show this info box if the setting is enabled by the user
        if (!config.showInfoBox()) return null;

        // Clear out old values
        panel.getChildren().clear();

        // Set the default size
        panel.setPreferredSize(new Dimension(160, 0));

        // Add the title
        panel.getChildren().add(TitleComponent.builder()
                .text("Tick Beats")
                .color(Color.green)
                .build());

        // Add playback mode info
        // Make Playback Mode string lowercase with space instead of underscore
        String modeDisplayString = config.playbackMode().toString().toLowerCase().replace('_', ' ');
        // Then capitalize the first letter
        modeDisplayString = modeDisplayString.substring(0,1).toUpperCase() + modeDisplayString.substring(1);
        panel.getChildren().add(TitleComponent.builder()
                .text(modeDisplayString)
                .color(Color.cyan)
                .build());

        // Add Song Name if it exists
        if(musicManager.getCurrentTrack() != null){
            // Get the song name to display
            String songName = musicManager.getCurrentTrack().getDisplayName();

            panel.getChildren().add(TitleComponent.builder()
                    .text(songName)
                    .color(Color.cyan)
                    .build());
        }

        // Add beat number info
        panel.getChildren().add(LineComponent.builder()
                .left("Beat:")
                .right(plugin.beatNumber + " / " + config.enabledBeats())
                .build());

        // Add tick number info
        panel.getChildren().add(LineComponent.builder()
                .left("Tick:")
                .right(plugin.tickCount + " / " + plugin.maxTicks)
                .build());

        // --- Download progress ---
        final int totalBuiltinTracksCount = downloadManager.getTotalBuiltinCount();

        // Only display download status for low quality tracks if all low downloads aren't done yet
        if(!downloadManager.isAllLoDownloaded() && totalBuiltinTracksCount > 0){

            // Resize the info box to fit the longer text
            panel.setPreferredSize(new Dimension(200, 0));

            // Add the download status for low quality tracks info to the box
            panel.getChildren().add(LineComponent.builder()
                    .left("Downloading Music...")
                    .right( downloadManager.getDownloadedCountLo() + " / " + totalBuiltinTracksCount)
                    .build());
        }

        // If the user wants to use hi quality music and all the high quality music tracks aren't downloaded yet
        if(config.useHighQualityMusic() && !downloadManager.isAllHiDownloaded() && totalBuiltinTracksCount > 0){

            // Resize the info box to fit the longer text
            panel.setPreferredSize(new Dimension(250, 0));

            // Add the download status for high quality tracks info to the box
            panel.getChildren().add(LineComponent.builder()
                    .left("Downloading High Quality Music...")
                    .right(downloadManager.getDownloadedCountHi() + " / " + totalBuiltinTracksCount)
                    .build());
        }

        return panel.render(graphics);
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;
import java.io.File;
import java.nio.file.Paths;


/**
 * This Class is used to determine which sounds are played and play them
 */
@Slf4j
@Singleton
public class TickSoundManager {

    @Inject
    TickBeatsMetronomeConfig config;

    @Inject
    UserSoundManager userSoundManager;

    @Inject
    OverlayMessage overlayMessage;

    @Inject
    private TickSoundCache tickSoundCache;


    /**
     * Determines which tick to play on which beat
     */
    public void playSound(int beatNumber, int tickCount)
    {
        switch (beatNumber)
        {
            case 1: playBeat1(tickCount); break;
            case 2: playBeat2(tickCount); break;
            case 3: playBeat3(tickCount); break;
            default: playBeat1(tickCount); break;
        }
    }

    /**
     * Plays the configured sound for the given tick (1â€“9) using the DEFAULT set (Beat 1).
     */
    private void playBeat1(int tickCount)
    {
        TickSoundOption soundOption;
        int volume;

        switch (tickCount)
        {
            case 1:  soundOption = config.beat1Tick1Sound(); volume = config.beat1Tick1Volume(); break;
            case 2:  soundOption = config.beat1Tick2Sound(); volume = config.beat1Tick2Volume(); break;
            case 3:  soundOption = config.beat1Tick3Sound(); volume = config.beat1Tick3Volume(); break;
            case 4:  soundOption = config.beat1Tick4Sound(); volume = config.beat1Tick4Volume(); break;
            case 5:  soundOption = config.beat1Tick5Sound(); volume = config.beat1Tick5Volume(); break;
            case 6:  soundOption = config.beat1Tick6Sound(); volume = config.beat1Tick6Volume(); break;
            case 7:  soundOption = config.beat1Tick7Sound(); volume = config.beat1Tick7Volume(); break;
            case 8:  soundOption = config.beat1Tick8Sound(); volume = config.beat1Tick8Volume(); break;
            case 9:  soundOption = config.beat1Tick9Sound(); volume = config.beat1Tick9Volume(); break;
            default: soundOption = TickSoundOption.OFF; volume = 100; break;
        }

        if (soundOption != TickSoundOption.OFF)
        {
            play(soundOption.getResourceName(), volume);
        }
    }

    /**
     * Plays the configured sound for the given tick (1â€“9) using the ALTERNATE set (Beat 2).
     */
    private void playBeat2(int tickCount)
    {
        TickSoundOption soundOption;
        int volume;

        switch (tickCount)
        {
            case 1:  soundOption = config.beat2Tick1Sound(); volume = config.beat2Tick1Volume(); break;
            case 2:  soundOption = config.beat2Tick2Sound(); volume = config.beat2Tick2Volume(); break;
            case 3:  soundOption = config.beat2Tick3Sound(); volume = config.beat2Tick3Volume(); break;
            case 4:  soundOption = config.beat2Tick4Sound(); volume = config.beat2Tick4Volume(); break;
            case 5:  soundOption = config.beat2Tick5Sound(); volume = config.beat2Tick5Volume(); break;
            case 6:  soundOption = config.beat2Tick6Sound(); volume = config.beat2Tick6Volume(); break;
            case 7:  soundOption = config.beat2Tick7Sound(); volume = config.beat2Tick7Volume(); break;
            case 8:  soundOption = config.beat2Tick8Sound(); volume = config.beat2Tick8Volume(); break;
            case 9:  soundOption = config.beat2Tick9Sound(); volume = config.beat2Tick9Volume(); break;
            default: soundOption = TickSoundOption.OFF; volume = 100; break;
        }

        if (soundOption != TickSoundOption.OFF)
        {
            play(soundOption.getResourceName(), volume);
        }
    }

    /**
     * Plays the configured sound for the given tick (1â€“9) using the THIRD set (Beat 3).
     */
    private void playBeat3(int tickCount)
    {
        TickSoundOption soundOption;
        int volume;

        switch (tickCount)
        {
            case 1:  soundOption = config.beat3Tick1Sound(); volume = config.beat3Tick1Volume(); break;
            case 2:  soundOption = config.beat3Tick2Sound(); volume = config.beat3Tick2Volume(); break;
            case 3:  soundOption = config.beat3Tick3Sound(); volume = config.beat3Tick3Volume(); break;
            case 4:  soundOption = config.beat3Tick4Sound(); volume = config.beat3Tick4Volume(); break;
            case 5:  soundOption = config.beat3Tick5Sound(); volume = config.beat3Tick5Volume(); break;
            case 6:  soundOption = config.beat3Tick6Sound(); volume = config.beat3Tick6Volume(); break;
            case 7:  soundOption = config.beat3Tick7Sound(); volume = config.beat3Tick7Volume(); break;
            case 8:  soundOption = config.beat3Tick8Sound(); volume = config.beat3Tick8Volume(); break;
            case 9:  soundOption = config.beat3Tick9Sound(); volume = config.beat3Tick9Volume(); break;
            default: soundOption = TickSoundOption.OFF; volume = 100; break;
        }

        if (soundOption != TickSoundOption.OFF)
        {
            play(soundOption.getResourceName(), volume);
        }
    }

    /**
     * Plays a sound by its resource name at the specified volume.
     *
     * Retrieves the TickSound from cache, validates the audio data,
     * and plays it using Java's Clip system. Also displays helpful
     * error messages for common issues with user-provided sound files.
     *
     * @param resourceName The resource name or key (e.g., "snare.wav" or "1" for user sounds)
     * @param volume Volume to play at (0â€“150) Over 100 for boosted volume if you want to emphasize a sound
     */
    public void play(String resourceName, int volume) {
        // Attempt to retrieve the sound from the cache
        TickSound sound = tickSoundCache.getSound(resourceName);

        //////////////////////////////////////////////
        //////////// Sound Error Handling ////////////
        //////////////////////////////////////////////

        // If the sound wasn't found in the cache
        if (sound == null) {

            // If the name looks like a user sound (digits only, like "1", "2", etc.)
            if (resourceName.matches("\\d+")) {
                // Suggest to the user where to place valid user sound files
                String soundsFolder = Paths.get(
                        RuneLite.RUNELITE_DIR.getAbsolutePath(),
                        "tick-beats", "sounds"
                ).toString();

                overlayMessage.show(
                        "User Sound " + resourceName + " Not Found. Add 16-bit .wav files to:",
                        soundsFolder
                );
            } else {
                // Otherwise it's likely a built-in sound and should have been cached

                // Uncomment the overlayMessage below for a visual error for failed built-in sounds,
                // I ended up commenting it out as I thought it may be annoying to a user, as it doesn't provide very useful info
                // overlayMessage.show("Something went wrong playing sound: " + resourceName, "Try restarting Tick Beats");
            }

            // Log the failure for debugging purposes
            log.debug("Sound {} not found in cache", resourceName);
            return;
        }

        // Try to get the full path for the user sound (for displaying in error messages)
        String soundFilePath = "";
        File userSoundFile = userSoundManager.getUserSoundMap().get(resourceName);
        if (userSoundFile != null) {
            soundFilePath = userSoundFile.getAbsolutePath();
        }

        // Check for file size exceeding 1MB (limit for user sounds)
        if (sound.getData().length >= 1024 * 1024) {
            overlayMessage.show(
                    "User Sound " + resourceName + " is too large (must be under 1MB)",
                    soundFilePath
            );
            return;
        }

        // Check that the audio is 16-bit (other formats may cause playback issues)
        int sampleSize = sound.getFormat().getSampleSizeInBits();
        if (sampleSize != 16) {
            overlayMessage.show(
                    "User Sound " + resourceName + " is " + sampleSize + "-bit. Must be 16-bit.",
                    soundFilePath
            );
            return;
        }

        //////////////////////////////////////////////
        //////////// Try to Play the Sound ///////////
        //////////////////////////////////////////////

        try {
            // Create a Clip instance from the system
            Clip clip = AudioSystem.getClip();

            // Load raw audio data into the clip
            clip.open(sound.getFormat(), sound.getData(), 0, sound.getData().length);

            // Apply the user-configured volume setting
            setClipVolume(clip, volume);

            // Ensure the clip is closed automatically after playing
            clip.addLineListener(event -> {
                if (event.getType() == LineEvent.Type.STOP) {
                    clip.close();
                }
            });

            // Begin playback (non-blocking)
            clip.start();
        }
        catch (Exception e) {
            // Show error overlay if something went wrong during playback
            overlayMessage.show("Unable to play sound file", soundFilePath);

            // Log the full exception message for debugging
            log.debug("Failed to play sound {}: {}", resourceName, e.getMessage());
        }
    }

    /**
     * Set the clips volume
     * @param clip the audio clip to adjust the volume for
     * @param volume the volume percentage to set the clip at, ex. 100. supports over 100 for boosted audio
     */
    private void setClipVolume(Clip clip, float volume)
    {
        // Check if the clip supports master gain control (volume)
        // if not return
        if (!clip.isControlSupported(FloatControl.Type.MASTER_GAIN))
        {
            return;
        }

        FloatControl volumeControl = (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);

        double dB;

        // Avoid log10(0) (log10 shouldn't be 0 or negative) and handle 0 volume
        if (volume <= 0)
        {
            dB = volumeControl.getMinimum();
        }
        else
        {
            // Convert percentage to a volume ratio (0.0â€“1.0)
            float volumePercent = volume / 100f;

            // Convert to decibels using a log scale
            dB = Math.log10(volumePercent) * 20.0;
        }

        // Clamp volume to the supported dB range
        float minDb = volumeControl.getMinimum();
        float maxDb = volumeControl.getMaximum();

        if (dB < minDb)
        {
            dB = minDb;
        }
        else if (dB > maxDb)
        {
            dB = maxDb;
        }

        // Apply the decibel volume to the clip
        volumeControl.setValue((float) dB);
    }
}

package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.*;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@Singleton
public class MusicTrackLoader
{
    @Inject
    private TickBeatsMetronomeConfig config;

    @Inject
    UserMusicManager userMusicManager;

    @Inject
    OverlayMessage overlayMessage;

    private static final float BEAT_DURATION_SECONDS = 0.6f;

    /**
     * Loads a music track either from embedded plugin resources or from user-supplied files.
     * The track is split into 600ms segments.
     *
     * @param musicTrackOption The music track option of the track to load.
     *                  - For built-in tracks, this includes the WAV resourceName (e.g., "sea_shanty_2.wav").
     *                  - For user music, this includes a stringified number key resourceName (e.g., "1", "2", "3", etc.).
     * @return A MusicTrack object containing the parsed beats and audio format, or null if the track is missing.
     */
    public MusicTrack loadFromResource(MusicTrackOption musicTrackOption)
    {
        String resourceName = musicTrackOption.getResourceName();

        // Try to get an AudioInputStream for either a user track or downloaded track
        try (AudioInputStream stream = getAudioStream(musicTrackOption))
        {
            // If the track couldn't be loaded (not found, unreadable, etc.), skip loading.
            if (stream == null)
            {
                log.debug("Track '{}' could not be loaded (stream was null). Skipping load.", resourceName);
                return null;
            }

            // Get audio format info (e.g., sample rate, bit depth, channels)
            AudioFormat format = stream.getFormat();

            // Make sure .wav file is 16-bit
            int sampleSize = format.getSampleSizeInBits();
            if(sampleSize != 16){

                // If the music track is a user track
                if (musicTrackOption.isUserMusic())
                {
                    File userFile = userMusicManager.getUserMusicMap().get(resourceName);
                    // the userFile shouldn't be null, but just in case wouldn't want to somehow get a null pointer exception on displaying an error message
                    if (userFile == null)
                    {
                        return null;
                    }

                    // If it's a user track show the user where the file that is the wrong sample size is located
                    String trackLocation = userFile.getAbsolutePath();
                    overlayMessage.show( "User Music Track " + resourceName + " is a " + sampleSize + "-bit .wav file but must be 16-bit",
                            trackLocation);

                }else{
                    //if the user modifies a downloaded .wav file, this could fire on what's supposed to be a built-in track
                    overlayMessage.show(  resourceName + " isn't 16-bit, Files in the tick-beats/downloads folder aren't meant to be modified",
                             "Delete: " + resourceName + " from the hi and lo folder to redownload");
                }
                return null;
            }

            // Calculate audio segment (beat) size in bytes based on duration and format
            int frameSize = format.getFrameSize();                  // e.g., 4 bytes for 16-bit stereo
            float frameRate = format.getFrameRate();                // e.g., 44100 Hz
            int framesPerBeat = (int)(frameRate * BEAT_DURATION_SECONDS);  // e.g., 44100 * 0.6 = 26460 frames per beat
            int bytesPerBeat = framesPerBeat * frameSize;           // e.g., 26460 * 4 = 105840 bytes per beat

            // Read the entire audio file into memory
            byte[] fullAudio = stream.readAllBytes();
            int totalBeats = fullAudio.length / bytesPerBeat;       // Determine how many full 600ms beats exist

            // List to store beat objects for this track
            List<MusicBeat> beatList = new ArrayList<>();

            // Iterate through each full beat segment and extract audio data for it
            for (int i = 0; i < totalBeats; i++)
            {
                int start = i * bytesPerBeat;
                int end = Math.min(start + bytesPerBeat, fullAudio.length); // Handle potential edge cases at end of track
                byte[] beatData = new byte[end - start];

                // Copy just the data for this beat
                System.arraycopy(fullAudio, start, beatData, 0, beatData.length);

                // Calculate the musical bar and beat position (1-based indexing)
                int barNumber = (i / MusicTrack.BEATS_PER_BAR) + 1;
                int beatNumber = (i % MusicTrack.BEATS_PER_BAR) + 1;

                // Add the beat to our list
                beatList.add(new MusicBeat(barNumber, beatNumber, beatData));
            }

            // Remove any leftover partial bar at the end (e.g., trailing silence)
            beatList = trimIncompleteBar(beatList);

            // Get a nice looking track name to include with our MusicTrack object
            String displayName = getDisplayName(musicTrackOption);

            // Package everything into a MusicTrack object
            return new MusicTrack(musicTrackOption, displayName, beatList, format);
        }
        catch (Exception e)
        {
            log.debug("Failed to load track '{}': {}", resourceName, e.getMessage(), e);
            overlayMessage.show("Error loading track:", resourceName);
            return null;
        }
    }

    /**
     * Gets an AudioInputStream from user music directory or downloaded resource.
     * determines if the track is a downloaded track or a user file, then gets its audioInputStream
     * @param musicTrackOption which track to create the audio stream for,
     *                  - For downloaded tracks, this includes a WAV resourceName (e.g., "sea_shanty_2.wav").
     *                  - For user music, this includes a stringified number key resourceName (e.g., "1", "2", "3", etc.).
     * @return returns the AudioInputStream for the track
     */
    public AudioInputStream getAudioStream(MusicTrackOption musicTrackOption)
    {
        String resourceName = musicTrackOption.getResourceName();

        try
        {
            // Check if this is a user added track
            if (musicTrackOption.isUserMusic())
            {
                // Not really needed, but make the variable name more accurate
                String trackNumber = resourceName;

                // Get the user file based on its track id number
                File userFile = userMusicManager.getUserMusicMap().get(trackNumber);
                if (userFile != null && userFile.exists())
                {
                    return AudioSystem.getAudioInputStream(userFile);
                }
                String titleMessage ="User Music Track " + trackNumber + " Not Found. Save 16-bit .wav files to and restart plugin:";
                String tickBeatsMusicFolder = Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath(), "tick-beats", "music").toString();
                overlayMessage.show(titleMessage, tickBeatsMusicFolder);

            } else {

                // Not really needed, but make the variable name more accurate
                String fileName = resourceName;

                // If it's not a user track, first check high-quality folder if the user has use high quality music checked
                Path hiPath = Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath(), "tick-beats", "downloads", "hi", fileName);
                if (Files.exists(hiPath) && config.useHighQualityMusic())
                {
                    return AudioSystem.getAudioInputStream(hiPath.toFile());
                }

                // Now check low-quality folder
                Path loPath = Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath(), "tick-beats", "downloads", "lo", fileName);
                if (Files.exists(loPath))
                {
                    return AudioSystem.getAudioInputStream(loPath.toFile());
                }

                // If the file isn't found in either folder, display the track hasn't been downloaded yet message
                overlayMessage.show("This Track Hasn't Been Downloaded Yet", "Try a track higher up in the list");

            }

            return null;
        }
        catch (Exception e)
        {
            log.debug("Failed to load audio stream for '{}': {}", resourceName, e.getMessage());
            return null;
        }
    }

    /**
     * Removes any trailing beats that do not form a complete musical bar.
     *
     * @param beats
     *     The full list of MusicBeat objects representing the trackâ€™s beats.
     *     The list may contain extra beats at the end that do not form a full bar.
     *
     * @return
     *     A possibly shortened list with the incomplete final bar removed.
     */
    private List<MusicBeat> trimIncompleteBar(List<MusicBeat> beats)
    {
        int totalBeats = beats.size();
        int remainder = totalBeats % MusicTrack.BEATS_PER_BAR;

        // If total beats is an exact multiple of beats-per-bar, return unchanged
        if (remainder == 0)
        {
            return beats;
        }

        // Remove the leftover beats so that only full bars remain
        for (int i = 0; i < remainder; i++)
        {
            beats.remove(beats.size() - 1);
        }

        return beats;
    }

    /**
     * Generates a human-friendly display name for a music track option.
     *
     * For user tracks, this method:
     * <ul>
     *   <li>Retrieves the raw filename from the user music directory.</li>
     *   <li>Removes the .wav extension if present.</li>
     *   <li>Replaces underscores and dashes with spaces.</li>
     *   <li>Capitalizes the first letter of each word while lowercasing the rest.</li>
     * </ul>
     * For built-in tracks, the method simply returns the display name provided by the MusicTrackOption.
     *
     * @param musicTrackOption the track option to generate a display name for.
     *
     * @return A beautified, human-readable display name for the given track option.
     */
    public String getDisplayName(MusicTrackOption musicTrackOption) {

        String displayName;

        // If it's a user track, get the tracks file name and make it better looking
        if(musicTrackOption.isUserMusic()){

            // Get the file object from the userMusicMap for the user music track
            File userFile = userMusicManager.getUserMusicMap().get(musicTrackOption.getResourceName());

            // the userFile shouldn't be null, but just in case
            if (userFile == null)
            {
                log.debug("User track {} not found in userMusicMap", musicTrackOption.getResourceName());
                return musicTrackOption.getDisplayName();
            }

            // Get the files name by pulling it from the userMusicMap
            String fileName = userFile.getName();

            // Remove the .wav extension
            if (fileName.toLowerCase().endsWith(".wav")) {
                fileName = fileName.substring(0, fileName.length() - 4);
            }

            // Replace underscores and dashes with spaces
            fileName = fileName.replace('_', ' ')
                    .replace('-', ' ');

            // Split into words and capitalize first letter of each
            StringBuilder result = new StringBuilder();
            for (String word : fileName.split(" ")) {
                if (!word.isEmpty()) {
                    result.append(Character.toUpperCase(word.charAt(0)));
                    if (word.length() > 1) {
                        result.append(word.substring(1).toLowerCase());
                    }
                    result.append(" ");
                }
            }

            // Get our string and remove any leading or trailing whitespace
            displayName = result.toString().trim();

        }else{
            // The displayName for built-in tracks already looks nice, so just use that
            displayName = musicTrackOption.getDisplayName();
        }

        return displayName;
    }
}
package com.TickBeatsMetronome;

public class MusicBeat
{
    private final int barIndex;
    private final int beatIndex;
    private final byte[] audioData;

    public MusicBeat(int barIndex, int beatIndex, byte[] audioData)
    {
        this.barIndex = barIndex;
        this.beatIndex = beatIndex;
        this.audioData = audioData;
    }

    public int getBarIndex() { return barIndex; }
    public int getBeatIndex() { return beatIndex; }
    public byte[] getAudioData() { return audioData; }

    @Override
    public String toString()
    {
        return "MusicBeat{bar=" + barIndex + ", beat=" + beatIndex + "}";
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Slf4j
@Singleton
public class OverlayMessage extends Overlay
{
    @Inject private Client client;

    private String text = null;
    private String subText = null;
    private Color baseColor = Color.YELLOW;
    private int distanceFromTop = 100;
    private long startMs = 0L;
    private int holdMs = 2000;   // Visible at full alpha
    private int fadeMs = 3000;    // Fade-out duration
    private int subtextYOffset = 30; // How far below the message should the sub message be

    @Inject
    public OverlayMessage()
    {
        // Weâ€™ll draw at exact canvas coords, so using DYNAMIC + ABOVE_SCENE.
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    /**
     * Displays an overlay message using the default overlay color and timing settings.
     * This method is a convenience overload for when you want to show a message
     * and an optional sub-message without worrying about customizing the text color
     * or the display/fade durations.
     *
     * Internally, this calls the main show(String, String, Color, int, int)
     * method using yellow text, 2 seconds fully visible, and 3 second fade out.
     *
     * @param message    The main line of text to display. This will appear in larger/bolder font.
     * @param subMessage The secondary line of text to display beneath the main message.
     *                   Can be an empty string if no secondary text is needed.
     */
    public void show(String message, String subMessage)
    {
        show(message, subMessage, Color.yellow, 2000, 3000);
    }

    /**
     * Displays an overlay message with full customization of color and timing.
     *
     * Calling this method immediately replaces any existing message currently being shown
     * with the new message and starts the display timer from zero.
     *
     * The message will first be shown at full opacity for holdDurationMs milliseconds.
     * After that, it will fade out over fadeDurationMs milliseconds until it is
     * completely invisible, at which point the message will be cleared.
     *
     * @param message         The main line of text to display. This is usually the most important
     *                        part of the overlay and will appear centered on the screen.
     * @param subMessage      The secondary line of text to display beneath the main message.
     *                        Can be an empty string if no secondary text is needed.
     * @param color           The Color to use for drawing the text (both main and subtext).
     * @param holdDurationMs  How long, in milliseconds, the text should remain at full opacity
     *                        before starting to fade out. If less than 0, it will be treated as 0.
     * @param fadeDurationMs  How long, in milliseconds, the text should take to fade from full
     *                        opacity to completely invisible. If less than 1, it will be treated as 1.
     */
    public void show(String message, String subMessage, Color color, int holdDurationMs, int fadeDurationMs)
    {
        this.text = message;
        this.subText = subMessage;
        this.baseColor = color;
        this.holdMs = Math.max(0, holdDurationMs);
        this.fadeMs = Math.max(1, fadeDurationMs);
        this.startMs = System.currentTimeMillis();
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        final String message = text;
        final String subMessage = subText;

        // If there's no message or subMessage, don't do anything, subMessage should at least be an empty string ""
        if (message == null || subMessage == null) return null;

        long elapsed = System.currentTimeMillis() - startMs;

        // If hold + fade time has passed, clear the message
        if (elapsed > holdMs + fadeMs)
        {
            text = null;
            subText = null;
            return null;
        }

        // Compute alpha: 1.0 during hold, then linear fade to 0
        float alpha = 1f;
        if (elapsed > holdMs) {
            float fadeProgress = (elapsed - holdMs) / (float) fadeMs; // 0..1
            alpha = 1f - fadeProgress;
        }

        // Prepare a clean graphics context to make sure we don't interfere with other overlay graphics settings
        Graphics2D graphics2 = (Graphics2D) graphics.create();
        try
        {
            // Big, readable font (RuneLite bold), centered near top
            Font font = FontManager.getRunescapeBoldFont().deriveFont(Font.BOLD, 24f);
            graphics2.setFont(font);

            // Center horizontally
            int canvasWidth = client.getCanvasWidth();

            // How far down from the top to display the message
            int y = distanceFromTop;

            // Get Font information
            FontMetrics fm = graphics2.getFontMetrics(font);

            // Get the text widths to help center the text
            int textWidth = fm.stringWidth(message);
            int x = (canvasWidth - textWidth) / 2;

            int text2Width = fm.stringWidth(subMessage);
            int x2 = (canvasWidth - text2Width) / 2;

            // If client is fixed size, make some adjustments so things fit better
            if(!client.isResized()){
                // Make the font smaller
                font = FontManager.getRunescapeBoldFont().deriveFont(Font.BOLD, 14f);
                graphics2.setFont(font);

                // Get the New Font Metrics for the smaller font
                fm = graphics2.getFontMetrics(font);

                // Get the new width of our text now that it's smaller
                textWidth = fm.stringWidth(message);
                x = (canvasWidth - textWidth) / 2;

                text2Width = fm.stringWidth(subMessage);
                x2 = (canvasWidth - text2Width) / 2;


                // In testing these values seemed to provide decent results for better centering the messages in fixed mode
                // Move  the font up a bit higher
                y = y -50;
                // Move to the left to account for minimap and inventory when trying to center text
                x = x -120;
                x2 = x2 -120;
            }

            // Apply alpha
            graphics2.setComposite(AlphaComposite.SrcOver.derive(alpha));

            // Simple shadow to make text more visible
            graphics2.setColor(Color.BLACK);
            graphics2.drawString(message, x + 2, y + 2);
            graphics2.drawString(subMessage, x2 + 2, y + subtextYOffset + 2);

            // Set the message color
            graphics2.setColor(baseColor);

            // Draw the message and the subMessage
            graphics2.drawString(message, x, y);
            graphics2.drawString(subMessage, x2, y + subtextYOffset);

        }
        finally
        {
            graphics2.dispose();
        }

        return null;
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Handles building, refreshing, and controlling playlists of music tracks.
 * Supports 3 playlists, shuffle modes, and next/previous track navigation.
 */
@Slf4j
@Singleton
public class MusicPlaylistManager
{
    @Inject
    private TickBeatsMetronomeConfig config;

    @Inject
    private OverlayMessage overlayMessage;

    @Inject
    private MusicManager musicManager;

    private List<MusicTrackOption> activePlaylist;

    private final List<MusicTrackOption> playlist1 = new ArrayList<>();
    private final List<MusicTrackOption> playlist2 = new ArrayList<>();
    private final List<MusicTrackOption> playlist3 = new ArrayList<>();

    private int currentTrackNumber = 1;

    // Stores a randomized order of numbers ex. if the playlist were 5 tracks total numbers 1-5 in a random order [1, 5, 3, 2, 4]
    // To use it, currentTrackNumber will point to an index in the list and instead get the random track number from that index
    private final List<Integer> shuffleOrder = new ArrayList<>();

    /**
     * Resets all playlists sets the track counter back to 1 and reshuffles the shuffle order
     */
    public void resetPlaylists(){
        refreshPlaylists();
        generateShuffleOrder();
        currentTrackNumber = 1;
    }

    /**
     * Rebuilds all 3 playlists from the plugin config
     * Called before playback or when playlist options change
     */
    public void refreshPlaylists(){
        refreshPlaylist1();
        refreshPlaylist2();
        refreshPlaylist3();
    }

    /**
     * Rebuilds Playlist 1 based on user config
     * Slot 0 is always NONE so that playlist indexing matches track numbers (1-based)
     */
    public void refreshPlaylist1()
    {
        playlist1.clear();

        // Array lists are 0 based, make our list numbers match our track numbers by making track 0 = NONE
        playlist1.add(MusicTrackOption.NONE);

        playlist1.add(config.playlist1Track1());
        playlist1.add(config.playlist1Track2());
        playlist1.add(config.playlist1Track3());
        playlist1.add(config.playlist1Track4());
        playlist1.add(config.playlist1Track5());
        playlist1.add(config.playlist1Track6());
        playlist1.add(config.playlist1Track7());
        playlist1.add(config.playlist1Track8());
        playlist1.add(config.playlist1Track9());
        playlist1.add(config.playlist1Track10());
        playlist1.add(config.playlist1Track11());
        playlist1.add(config.playlist1Track12());
        playlist1.add(config.playlist1Track13());
        playlist1.add(config.playlist1Track14());
        playlist1.add(config.playlist1Track15());
        playlist1.add(config.playlist1Track16());
        playlist1.add(config.playlist1Track17());
        playlist1.add(config.playlist1Track18());
        playlist1.add(config.playlist1Track19());
        playlist1.add(config.playlist1Track20());
        playlist1.add(config.playlist1Track21());
        playlist1.add(config.playlist1Track22());
        playlist1.add(config.playlist1Track23());
        playlist1.add(config.playlist1Track24());
        playlist1.add(config.playlist1Track25());
    }

    /**
     * Rebuilds Playlist 2 based on users plugin settings
     */
    public void refreshPlaylist2()
    {
        playlist2.clear();

        playlist2.add(MusicTrackOption.NONE);

        playlist2.add(config.playlist2Track1());
        playlist2.add(config.playlist2Track2());
        playlist2.add(config.playlist2Track3());
        playlist2.add(config.playlist2Track4());
        playlist2.add(config.playlist2Track5());
        playlist2.add(config.playlist2Track6());
        playlist2.add(config.playlist2Track7());
        playlist2.add(config.playlist2Track8());
        playlist2.add(config.playlist2Track9());
        playlist2.add(config.playlist2Track10());
        playlist2.add(config.playlist2Track11());
        playlist2.add(config.playlist2Track12());
        playlist2.add(config.playlist2Track13());
        playlist2.add(config.playlist2Track14());
        playlist2.add(config.playlist2Track15());
        playlist2.add(config.playlist2Track16());
        playlist2.add(config.playlist2Track17());
        playlist2.add(config.playlist2Track18());
        playlist2.add(config.playlist2Track19());
        playlist2.add(config.playlist2Track20());
        playlist2.add(config.playlist2Track21());
        playlist2.add(config.playlist2Track22());
        playlist2.add(config.playlist2Track23());
        playlist2.add(config.playlist2Track24());
        playlist2.add(config.playlist2Track25());
    }

    /**
     * Rebuilds Playlist 3 based on users plugin settings
     */
    public void refreshPlaylist3()
    {
        playlist3.clear();

        playlist3.add(MusicTrackOption.NONE);

        playlist3.add(config.playlist3Track1());
        playlist3.add(config.playlist3Track2());
        playlist3.add(config.playlist3Track3());
        playlist3.add(config.playlist3Track4());
        playlist3.add(config.playlist3Track5());
        playlist3.add(config.playlist3Track6());
        playlist3.add(config.playlist3Track7());
        playlist3.add(config.playlist3Track8());
        playlist3.add(config.playlist3Track9());
        playlist3.add(config.playlist3Track10());
        playlist3.add(config.playlist3Track11());
        playlist3.add(config.playlist3Track12());
        playlist3.add(config.playlist3Track13());
        playlist3.add(config.playlist3Track14());
        playlist3.add(config.playlist3Track15());
        playlist3.add(config.playlist3Track16());
        playlist3.add(config.playlist3Track17());
        playlist3.add(config.playlist3Track18());
        playlist3.add(config.playlist3Track19());
        playlist3.add(config.playlist3Track20());
        playlist3.add(config.playlist3Track21());
        playlist3.add(config.playlist3Track22());
        playlist3.add(config.playlist3Track23());
        playlist3.add(config.playlist3Track24());
        playlist3.add(config.playlist3Track25());
    }

    /**
     * Advances to the next track (increment counter) if not in manual mode, this doesnâ€™t load or play the track
     * it just adjusts the pointer so next time getCurrentTrack() is called it grabs the next available track
     */
    public void incrementTrack()
    {
        if(config.playbackMode() != TickBeatsMetronomeConfig.PlaybackMode.MANUAL){
            currentTrackNumber++;
        }
    }

    /**
     * Sets which playlist should be active based on config playback mode.
     */
    public void setActivePlaylist(){
        // Set default playlist to playlist 1
        activePlaylist = playlist1;

        // If playlist 2 is set by the user, make that the active playlist
        if (config.playbackMode() == TickBeatsMetronomeConfig.PlaybackMode.PLAYLIST_2){
            activePlaylist = playlist2;
        }

        // If playlist 3 is set by the user, make that the active playlist
        if (config.playbackMode() == TickBeatsMetronomeConfig.PlaybackMode.PLAYLIST_3){
            activePlaylist = playlist3;
        }
    }

    /**
     * Gets the current track to play, applying shuffle logic if enabled.
     *
     * @return the active track to play, or MusicTrackOption NONE if no valid track is found
     */
    public MusicTrackOption getCurrentTrack(){

        // Rebuilds Playlist based on config plugin settings
        refreshPlaylists();

        // Sets activePlaylist to whatever setting is in the config plugin settings
        setActivePlaylist();

        // If there are no tracks in the playlist, set the music track to none
        // This will also return true if RL doesn't load our plugins config at startup which was causing the plugin to break on startup
        if (playlistIsEmpty())
        {
            return MusicTrackOption.NONE;
        }

        int loops = 0;

        //loop through the track list to find the next one that isn't set to None
        //return none if we've somehow looped through every track twice and not found a track
        while (loops < 3)
        {
            // Make sure we're not looking for a track that exceeds our track list size or is less than 1
            // Loop around if we're past the last track, and make sure we don't somehow put a number less than 1 in
            if (currentTrackNumber >= activePlaylist.size() || currentTrackNumber < 1)
            {
                // If we've gotten to the end of a playlist regenerate its shuffle order
                generateShuffleOrder();
                currentTrackNumber = 1;
                loops++;
            }

            MusicTrackOption track;
            // If Shuffle Playlist is enabled in the options
            if(config.shufflePlaylist()){
                // Pull a track number from ShuffleOrder (a shuffled list of ints) based on the Current Track Number
                track = activePlaylist.get(shuffleOrder.get(currentTrackNumber));
            }else{
                // If Shuffle Playlist isn't enabled just play the current track
                track = activePlaylist.get(currentTrackNumber);
            }

            // If we've found a valid track, return it
            if (track != null && track != MusicTrackOption.NONE)
            {
                return track;
            }

            // If the current track isn't valid move on to check the next track
            currentTrackNumber++;
        }

        //if somehow after 2 checks the playlist is empty, return an empty track
        return MusicTrackOption.NONE;
    }

    /**
     * Gets the previous valid track in the active playlist,
     * moving backwards until a track is found or NONE is returned.
     *
     * @return the previous track, or MusicTrackOption NONE if none available
     */
    public MusicTrackOption getPreviousTrack(){
        // Start by going back 1 track with the current track number
        currentTrackNumber--;

        // Make sure the tracks in the playlists are up to date as far as the users settings
        refreshPlaylists();

        // Make sure the selected playlist is up to date as far as the users settings
        setActivePlaylist();

        // If there are no tracks in the playlist, set the music track to none
        if (playlistIsEmpty())
        {
            return MusicTrackOption.NONE;
        }

        // A check to make sure we haven't somehow exceeded the size of our playlist
        if (currentTrackNumber >= activePlaylist.size())
        {
            currentTrackNumber = activePlaylist.size();
        }

        // Keep looking for a track until we hit track 1
        while (currentTrackNumber >= 1) {

            MusicTrackOption track;
            // If Shuffle Playlist is enabled in the options
            if(config.shufflePlaylist()){
                // Pull a track number from ShuffleOrder (a shuffled list of ints) based on the Current Track Number
                track = activePlaylist.get(shuffleOrder.get(currentTrackNumber));
            }else{
                // If Shuffle Playlist isn't enabled just play the current track
                track = activePlaylist.get(currentTrackNumber);
            }

            // If we've found a valid track, return it
            if (track != null && track != MusicTrackOption.NONE) {
                return track;
            }

            // If the current track isn't valid move on to check the next track
            currentTrackNumber--;
        }

        // This will hopefully provide a bit of protection if the user manages to spam the back button into the negatives
        currentTrackNumber = 1;

        // If we're on track 1 run the normal getCurrentTrack to get the first available track
        // The idea is to have it where hitting the back at the start plays the first available track
        return getCurrentTrack();
    }


    /**
     * Checks if the active playlist has at least one valid track.
     *
     * @return true if the playlist has no tracks set, false otherwise
     */
    public boolean playlistIsEmpty(){

        // Make sure active playlist is accurate to user's settings
        setActivePlaylist();

        // Safety check in case playlists werenâ€™t populated as expected (edge cases like plugin config settings not loading yet)
        if (activePlaylist == null || activePlaylist.isEmpty())
        {
            return true;
        }

        for (int i = 0; i < activePlaylist.size(); i++)
        {
            MusicTrackOption track = activePlaylist.get(i);
            if (track != null && track != MusicTrackOption.NONE)
            {
                // A track was found playlist isn't empty
                return false;
            }
        }

        // No tracks were found when looping through the playlist, the playlist is empty, output a message
        // Make playlist string lowercase with space instead of underscore
        String playlistDisplayString = config.playbackMode().toString().toLowerCase().replace('_', ' ');
        // Then capitalize the first letter
        playlistDisplayString = playlistDisplayString.substring(0,1).toUpperCase() + playlistDisplayString.substring(1);
        overlayMessage.show("Add Songs To " + playlistDisplayString, "Or Change Playback Mode To Hear Music");

        return true;
    }


    /**
     * Skips to the next song in the active playlist and stops current playback to be started up on tick 1
     */
    public void playNextSong(){
        if(config.playbackMode() != TickBeatsMetronomeConfig.PlaybackMode.MANUAL){
            currentTrackNumber++;
            getCurrentTrack();
            musicManager.stop();
        }
    }

    /**
     * Moves to the previous song in the active playlist and stops current playback to be started up on tick 1
     */
    public void playPreviousSong(){
        if(config.playbackMode() != TickBeatsMetronomeConfig.PlaybackMode.MANUAL){
            getPreviousTrack();
            musicManager.stop();
        }
    }

    /**
     * Creates a new randomized shuffle order for the active playlist.
     * Every number will be represented once in the list, and in a random order
     * The first element is a dummy (0) so the list is 1-based.
     */
    public void generateShuffleOrder()
    {
        shuffleOrder.clear();

        // Add dummy 0 to make list 1-based
        shuffleOrder.add(0);

        setActivePlaylist();

        // Make a list of numbers in order one through the size of the playlist
        List<Integer> allIndices = new ArrayList<>();
        for (int i = 1; i < activePlaylist.size(); i++)
        {
            allIndices.add(i);
        }

        // Mix up the list of numbers
        Collections.shuffle(allIndices);

        // Add them to our dummy 0 to get a 1-based list
        shuffleOrder.addAll(allIndices);
    }

}
package com.TickBeatsMetronome;

import net.runelite.client.config.*;

import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;

//ConfigGroup internally makes this @Singleton, so it's not required
@ConfigGroup("tickBeats")
public interface TickBeatsMetronomeConfig extends Config
{
	////////////////////////////////////////////////
	/////////////////  Settings  ///////////////////
	////////////////////////////////////////////////

	@ConfigItem(
			keyName = "enableAudioMetronome",
			name = "Enable Beats",
			description = "Toggles tick sounds",
			position = 1
	)
	default boolean enableAudioMetronome() { return false; }

	@ConfigItem(
			keyName = "enableMusic",
			name = "Enable Music",
			description = "Toggles Music On or Off",
			position = 2
	)
	default boolean enableMusic() { return false; }

	@ConfigItem(
			keyName = "enableTextMetronome",
			name = "Enable Overhead Count",
			description = "Toggles the tick number above the player",
			position = 3
	)
	default boolean enableTextMetronome() { return true; }

	@ConfigItem(
			keyName = "enableColorOverlay",
			name = "Enable Color Overlay",
			description = "Toggles the full screen color overlay that changes with ticks",
			position = 4
	)
	default boolean enableColorOverlay() { return false; }

	@ConfigItem(
			keyName = "enableTickSmoothing",
			name = "Enable Tick Smoothing",
			description = "More consistent but less accurate ticks",
			position = 5
	)
	default boolean enableTickSmoothing() { return true; }

	@ConfigItem(
			keyName = "showInfoBox",
			name = "Show Info Box",
			description = "Display the Tick Info Overlay Box",
			position = 6
	)
	default boolean showInfoBox() { return true; }

	@Range(min = 1, max = 3)
	@ConfigItem(
			keyName = "enabledBeats",
			name = "Enabled Beats",
			description = "Which beat settings are enabled for rotating through with hotkey",
			position = 7
	)
	default int enabledBeats() { return 3; }

	@Range(max = 9)
	@ConfigItem(
			keyName = "startTick",
			name = "Start Tick",
			description = "The tick the metronome starts on (0 to 9)",
			position = 8
	)
	default int startTick() { return 0; }

	////////////////////////////////////////////////
	/////////////////  Music Settings  /////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Music Settings",
			description = "Music Settings",
			position = 10
	)
	String musicSettings = "musicSettings";


	@ConfigItem(
			keyName = "useHighQualityMusic",
			name = "Use High Quality Music",
			description = "If checked, this plugin will download much larger CD quality tracks to use",
			section = musicSettings,
			position = 1
	)
	default boolean useHighQualityMusic() {return false;}


	@ConfigItem(
			keyName = "musicTrack",
			name = "Music Track",
			description = "Select which music track to play",
			section = musicSettings,
			position = 2
	)
	default MusicTrackOption musicTrack() { return MusicTrackOption.SEA_SHANTY_2; }

	@ConfigItem(
			keyName = "musicVolume",
			name = "Music Volume",
			description = "Controls the volume of music playback (Normal:100%, Boosted:150%)",
			position = 3,
			section = musicSettings
	)
	@Range(min = 0, max = 150)
	default int musicVolume() { return 100; }

	public enum PlaybackMode
	{
		MANUAL,
		PLAYLIST_1,
		PLAYLIST_2,
		PLAYLIST_3
	}

	@ConfigItem(
			keyName = "playbackMode",
			name = "Playback Mode",
			description = "Play a single track (Manual) or use a Playlist",
			section = musicSettings,
			position = 4
	)
	default PlaybackMode playbackMode() { return PlaybackMode.MANUAL; }

	////////////////////////////////////////////////
	//////////////  Hotkey Settings  ///////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Hotkey Settings",
			description = "Hotkey Settings",
			position = 11
	)
	String hotkeys = "hotkeys";

	@ConfigItem(
			name = "Next Song",
			keyName = "nextSongHotkey",
			description = "Keybind to go to the next song (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 2
	)
	default Keybind nextSongHotkey() { return new Keybind(KeyEvent.VK_RIGHT, InputEvent.SHIFT_DOWN_MASK); }

	@ConfigItem(
			name = "Previous Song",
			keyName = "previousSongHotkey",
			description = "Keybind to go to the previous song (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 3
	)
	default Keybind previousSongHotkey() { return new Keybind(KeyEvent.VK_LEFT, InputEvent.SHIFT_DOWN_MASK); }


	@ConfigItem(
			name = "Reset to Start Tick",
			keyName = "resetHotkey",
			description = "The keybind to manually reset the metronome tick (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 4
	)
	default Keybind resetHotkey() { return new Keybind(KeyEvent.VK_TAB, 0); }

	@ConfigItem(
			name = "Next Tick",
			keyName = "nextTickHotkey",
			description = "Keybind to manually advance the metronome a tick (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 5
	)
	default Keybind nextTickHotkey() { return new Keybind(KeyEvent.VK_RIGHT, InputEvent.CTRL_DOWN_MASK); }

	@ConfigItem(
			name = "Previous Tick",
			keyName = "previousTickHotkey",
			description = "Keybind to manually go back a tick (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 6
	)
	default Keybind previousTickHotkey() { return new Keybind(KeyEvent.VK_LEFT, InputEvent.CTRL_DOWN_MASK); }

	@ConfigItem(
			name = "Next Beat",
			keyName = "nextBeatHotkey",
			description = "Keybind to go to the next beat (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 7
	)
	default Keybind nextBeatHotkey() { return new Keybind(KeyEvent.VK_UP, InputEvent.CTRL_DOWN_MASK); }

	@ConfigItem(
			name = "Previous Beat",
			keyName = "previousBeatHotkey",
			description = "Keybind to go to the previous beat (Works with modifiers ex. CTRL+A)",
			section = hotkeys,
			position = 8
	)
	default Keybind previousBeatHotkey() { return new Keybind(KeyEvent.VK_DOWN, InputEvent.CTRL_DOWN_MASK); }

	////////////////////////////////////////////////
	///////////////  Text Settings  ////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Text Settings",
			description = "Configure text appearance and colors",
			position = 12
	)
	String textSettings = "textSettings";

	@ConfigItem(
			keyName = "fontSize",
			name = "Font Size",
			description = "Size of the tick number displayed",
			section = textSettings,
			position = 1
	)
	default int fontSize() { return 40; }

	@ConfigItem(
			keyName = "textVerticalOffset",
			name = "Text Vertical Offset",
			description = "Vertical offset of the text from player",
			section = textSettings,
			position = 2
	)
	default int textVerticalOffset() { return 200; }

	////////////////////////////////////////////////
	//////////////////  Beat 1  ////////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 1",
			description = "The Default Beat",
			position = 13
	)
	String Beat1 = "Beat1";

	@Range(min = 1, max = 9)
	@ConfigItem(
			keyName = "beat1TickCount",
			name = "Beat 1 Tick Count",
			description = "Number of ticks in Beat 1's loop (1 to 9)",
			section = Beat1,
			position = 1
	)
	default int beat1TickCount() { return 4; }

	////////////////////////////////////////////////
	//////////////  Beat 1 Sounds  /////////////////
	////////////////////////////////////////////////
	@ConfigSection(
			name = "Beat 1 Sound Options",
			description = "Configure sounds for Beat 1",
			position = 14,
			closedByDefault = true
	)
	String beat1Sounds = "beat1Sounds";

	@ConfigItem(
			keyName = "beat1Tick1Sound",
			name = "Tick 1 Sound",
			description = "Sound to play on Beat 1 Tick 1",
			section = beat1Sounds,
			position = 1
	)
	default TickSoundOption beat1Tick1Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat1Tick1Volume",
			name = "Tick 1 Volume",
			description = "How loud to play Beat 1 Tick 1",
			section = beat1Sounds,
			position = 2
	)
	@Range(min = 0, max = 150)
	default int beat1Tick1Volume() { return 100; }

	@ConfigItem(
			keyName = "beat1Tick2Sound",
			name = "Tick 2 Sound",
			description = "Sound to play on Beat 1 Tick 2",
			section = beat1Sounds,
			position = 3
	)
	default TickSoundOption beat1Tick2Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick2Volume",
			name = "Tick 2 Volume",
			description = "How loud to play Beat 1 Tick 2",
			section = beat1Sounds,
			position = 4
	)
	@Range(min = 0, max = 150)
	default int beat1Tick2Volume() { return 100; }

	@ConfigItem(
			keyName = "beat1Tick3Sound",
			name = "Tick 3 Sound",
			description = "Sound to play on Beat 1 Tick 3",
			section = beat1Sounds,
			position = 5
	)
	default TickSoundOption beat1Tick3Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat1Tick3Volume",
			name = "Tick 3 Volume",
			description = "How loud to play Beat 1 Tick 3",
			section = beat1Sounds,
			position = 6
	)
	@Range(min = 0, max = 150)
	default int beat1Tick3Volume() { return 100; }

	@ConfigItem(
			keyName = "beat1Tick4Sound",
			name = "Tick 4 Sound",
			description = "Sound to play on Beat 1 Tick 4",
			section = beat1Sounds,
			position = 7
	)
	default TickSoundOption beat1Tick4Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick4Volume",
			name = "Tick 4 Volume",
			description = "How loud to play Beat 1 Tick 4",
			section = beat1Sounds,
			position = 8
	)
	@Range(min = 0, max = 150)
	default int beat1Tick4Volume() { return 100; }

	@ConfigItem(
			keyName = "beat1Tick5Sound",
			name = "Tick 5 Sound",
			description = "Sound to play on Beat 1 Tick 5",
			section = beat1Sounds,
			position = 9
	)
	default TickSoundOption beat1Tick5Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat1Tick5Volume",
			name = "Tick 5 Volume",
			description = "How loud to play Beat 1 Tick 5",
			section = beat1Sounds,
			position = 10
	)
	@Range(min = 0, max = 150)
	default int beat1Tick5Volume() { return 100; }

	@ConfigItem(
			keyName = "beat1Tick6Sound",
			name = "Tick 6 Sound",
			description = "Sound to play on Beat 1 Tick 6",
			section = beat1Sounds,
			position = 11
	)
	default TickSoundOption beat1Tick6Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick6Volume",
			name = "Tick 6 Volume",
			description = "How loud to play Beat 1 Tick 6",
			section = beat1Sounds,
			position = 12
	)
	@Range(min = 0, max = 150)
	default int beat1Tick6Volume() { return 100; }

	@ConfigItem(
			keyName = "beat1Tick7Sound",
			name = "Tick 7 Sound",
			description = "Sound to play on Beat 1 Tick 7",
			section = beat1Sounds,
			position = 13
	)
	default TickSoundOption beat1Tick7Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat1Tick7Volume",
			name = "Tick 7 Volume",
			description = "How loud to play Beat 1 Tick 7",
			section = beat1Sounds,
			position = 14
	)
	@Range(min = 0, max = 150)
	default int beat1Tick7Volume() { return 100; }

	@ConfigItem(
			keyName = "beat1Tick8Sound",
			name = "Tick 8 Sound",
			description = "Sound to play on Beat 1 Tick 8",
			section = beat1Sounds,
			position = 15
	)
	default TickSoundOption beat1Tick8Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick8Volume",
			name = "Tick 8 Volume",
			description = "How loud to play Beat 1 Tick 8",
			section = beat1Sounds,
			position = 16
	)
	@Range(min = 0, max = 150)
	default int beat1Tick8Volume() { return 100; }

	@ConfigItem(
			keyName = "beat1Tick9Sound",
			name = "Tick 9 Sound",
			description = "Sound to play on Beat 1 Tick 9",
			section = beat1Sounds,
			position = 17
	)
	default TickSoundOption beat1Tick9Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat1Tick9Volume",
			name = "Tick 9 Volume",
			description = "How loud to play Beat 1 Tick 9",
			section = beat1Sounds,
			position = 18
	)
	@Range(min = 0, max = 150)
	default int beat1Tick9Volume() { return 100; }


	////////////////////////////////////////////////
	////////////  Beat 1 Visual Options  ///////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 1 Visual Options",
			description = "Configure colors and opacity for Beat 1",
			position = 15,
			closedByDefault = true
	)
	String beat1Visuals = "beat1Visuals";

	@ConfigItem(
			keyName = "beat1Tick1Color",
			name = "Tick 1 Color",
			description = "Color for Beat 1 Tick 1 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 1
	)
	default Color beat1Tick1Color() { return Color.RED; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick1Opacity",
			name = "Tick 1 Opacity",
			description = "How transparent tick 1's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 2
	)
	default int beat1Tick1Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick2Color",
			name = "Tick 2 Color",
			description = "Color for Beat 1 Tick 2 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 3
	)
	default Color beat1Tick2Color() { return Color.BLUE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick2Opacity",
			name = "Tick 2 Opacity",
			description = "How transparent tick 2's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 4
	)
	default int beat1Tick2Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick3Color",
			name = "Tick 3 Color",
			description = "Color for Beat 1 Tick 3 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 5
	)
	default Color beat1Tick3Color() { return Color.GREEN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick3Opacity",
			name = "Tick 3 Opacity",
			description = "How transparent tick 3's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 6
	)
	default int beat1Tick3Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick4Color",
			name = "Tick 4 Color",
			description = "Color for Beat 1 Tick 4 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 7
	)
	default Color beat1Tick4Color() { return Color.YELLOW; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick4Opacity",
			name = "Tick 4 Opacity",
			description = "How transparent tick 4's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 8
	)
	default int beat1Tick4Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick5Color",
			name = "Tick 5 Color",
			description = "Color for Beat 1 Tick 5 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 9
	)
	default Color beat1Tick5Color() { return Color.ORANGE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick5Opacity",
			name = "Tick 5 Opacity",
			description = "How transparent tick 5's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 10
	)
	default int beat1Tick5Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick6Color",
			name = "Tick 6 Color",
			description = "Color for Beat 1 Tick 6 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 11
	)
	default Color beat1Tick6Color() { return Color.PINK; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick6Opacity",
			name = "Tick 6 Opacity",
			description = "How transparent tick 6's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 12
	)
	default int beat1Tick6Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick7Color",
			name = "Tick 7 Color",
			description = "Color for Beat 1 Tick 7 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 13
	)
	default Color beat1Tick7Color() { return Color.MAGENTA; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick7Opacity",
			name = "Tick 7 Opacity",
			description = "How transparent tick 7's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 14
	)
	default int beat1Tick7Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick8Color",
			name = "Tick 8 Color",
			description = "Color for Beat 1 Tick 8 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 15
	)
	default Color beat1Tick8Color() { return Color.CYAN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick8Opacity",
			name = "Tick 8 Opacity",
			description = "How transparent tick 8's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 16
	)
	default int beat1Tick8Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat1Tick9Color",
			name = "Tick 9 Color",
			description = "Color for Beat 1 Tick 9 (applies to both text and overlay)",
			section = beat1Visuals,
			position = 17
	)
	default Color beat1Tick9Color() { return Color.LIGHT_GRAY; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat1Tick9Opacity",
			name = "Tick 9 Opacity",
			description = "How transparent tick 9's overlay is (0 = invisible, 100 = solid)",
			section = beat1Visuals,
			position = 18
	)
	default int beat1Tick9Opacity() { return 10; }


	////////////////////////////////////////////////
	//////////////////  Beat 2  ////////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 2 (Activate With Next Beat Hotkey)",
			description = "Another beat to use, activate with next beat hotkey",
			position = 16
	)
	String Beat2 = "Beat2";

	@Range(min = 1, max = 9)
	@ConfigItem(
			keyName = "beat2TickCount",
			name = "Beat 2 Tick Count",
			description = "Number of ticks in Beat 2's loop (1 to 9)",
			section = Beat2,
			position = 30
	)
	default int beat2TickCount() { return 3; }

	////////////////////////////////////////////////
	//////////////  Beat 2 Sounds  /////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 2 Sound Options",
			description = "Configure sounds for Beat 2",
			position = 17,
			closedByDefault = true
	)
	String beat2Sounds = "beat2Sounds";

	@ConfigItem(
			keyName = "beat2Tick1Sound",
			name = "Tick 1 Sound",
			description = "Sound to play on Beat 2 Tick 1",
			section = beat2Sounds,
			position = 1
	)
	default TickSoundOption beat2Tick1Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat2Tick1Volume",
			name = "Tick 1 Volume",
			description = "How loud to play Beat 2 Tick 1",
			section = beat2Sounds,
			position = 2
	)
	@Range(min = 0, max = 150)
	default int beat2Tick1Volume() { return 100; }

	@ConfigItem(
			keyName = "beat2Tick2Sound",
			name = "Tick 2 Sound",
			description = "Sound to play on Beat 2 Tick 2",
			section = beat2Sounds,
			position = 3
	)
	default TickSoundOption beat2Tick2Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat2Tick2Volume",
			name = "Tick 2 Volume",
			description = "How loud to play Beat 2 Tick 2",
			section = beat2Sounds,
			position = 4
	)
	@Range(min = 0, max = 150)
	default int beat2Tick2Volume() { return 100; }

	@ConfigItem(
			keyName = "beat2Tick3Sound",
			name = "Tick 3 Sound",
			description = "Sound to play on Beat 2 Tick 3",
			section = beat2Sounds,
			position = 5
	)
	default TickSoundOption beat2Tick3Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat2Tick3Volume",
			name = "Tick 3 Volume",
			description = "How loud to play Beat 2 Tick 3",
			section = beat2Sounds,
			position = 6
	)
	@Range(min = 0, max = 150)
	default int beat2Tick3Volume() { return 100; }

	@ConfigItem(
			keyName = "beat2Tick4Sound",
			name = "Tick 4 Sound",
			description = "Sound to play on Beat 2 Tick 4",
			section = beat2Sounds,
			position = 7
	)
	default TickSoundOption beat2Tick4Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat2Tick4Volume",
			name = "Tick 4 Volume",
			description = "How loud to play Beat 2 Tick 4",
			section = beat2Sounds,
			position = 8
	)
	@Range(min = 0, max = 150)
	default int beat2Tick4Volume() { return 100; }

	@ConfigItem(
			keyName = "beat2Tick5Sound",
			name = "Tick 5 Sound",
			description = "Sound to play on Beat 2 Tick 5",
			section = beat2Sounds,
			position = 9
	)
	default TickSoundOption beat2Tick5Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat2Tick5Volume",
			name = "Tick 5 Volume",
			description = "How loud to play Beat 2 Tick 5",
			section = beat2Sounds,
			position = 10
	)
	@Range(min = 0, max = 150)
	default int beat2Tick5Volume() { return 100; }

	@ConfigItem(
			keyName = "beat2Tick6Sound",
			name = "Tick 6 Sound",
			description = "Sound to play on Beat 2 Tick 6",
			section = beat2Sounds,
			position = 11
	)
	default TickSoundOption beat2Tick6Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat2Tick6Volume",
			name = "Tick 6 Volume",
			description = "How loud to play Beat 2 Tick 6",
			section = beat2Sounds,
			position = 12
	)
	@Range(min = 0, max = 150)
	default int beat2Tick6Volume() { return 100; }

	@ConfigItem(
			keyName = "beat2Tick7Sound",
			name = "Tick 7 Sound",
			description = "Sound to play on Beat 2 Tick 7",
			section = beat2Sounds,
			position = 13
	)
	default TickSoundOption beat2Tick7Sound() { return TickSoundOption.BASS; }

	@ConfigItem(
			keyName = "beat2Tick7Volume",
			name = "Tick 7 Volume",
			description = "How loud to play Beat 2 Tick 7",
			section = beat2Sounds,
			position = 14
	)
	@Range(min = 0, max = 150)
	default int beat2Tick7Volume() { return 100; }

	@ConfigItem(
			keyName = "beat2Tick8Sound",
			name = "Tick 8 Sound",
			description = "Sound to play on Beat 2 Tick 8",
			section = beat2Sounds,
			position = 15
	)
	default TickSoundOption beat2Tick8Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat2Tick8Volume",
			name = "Tick 8 Volume",
			description = "How loud to play Beat 2 Tick 8",
			section = beat2Sounds,
			position = 16
	)
	@Range(min = 0, max = 150)
	default int beat2Tick8Volume() { return 100; }

	@ConfigItem(
			keyName = "beat2Tick9Sound",
			name = "Tick 9 Sound",
			description = "Sound to play on Beat 2 Tick 9",
			section = beat2Sounds,
			position = 17
	)
	default TickSoundOption beat2Tick9Sound() { return TickSoundOption.CLAP; }

	@ConfigItem(
			keyName = "beat2Tick9Volume",
			name = "Tick 9 Volume",
			description = "How loud to play Beat 2 Tick 9",
			section = beat2Sounds,
			position = 18
	)
	@Range(min = 0, max = 150)
	default int beat2Tick9Volume() { return 100; }



	////////////////////////////////////////////////
	////////////  Beat 2 Visual Options  ///////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 2 Visual Options",
			description = "Configure colors and opacity for Beat 2",
			position = 18,
			closedByDefault = true
	)
	String beat2Visuals = "beat2Visuals";

	@ConfigItem(
			keyName = "beat2Tick1Color",
			name = "Tick 1 Color",
			description = "Color for Beat 2 Tick 1 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 1
	)
	default Color beat2Tick1Color() { return Color.RED; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick1Opacity",
			name = "Tick 1 Opacity",
			description = "How transparent tick 1's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 2
	)
	default int beat2Tick1Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick2Color",
			name = "Tick 2 Color",
			description = "Color for Beat 2 Tick 2 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 3
	)
	default Color beat2Tick2Color() { return Color.BLUE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick2Opacity",
			name = "Tick 2 Opacity",
			description = "How transparent tick 2's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 4
	)
	default int beat2Tick2Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick3Color",
			name = "Tick 3 Color",
			description = "Color for Beat 2 Tick 3 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 5
	)
	default Color beat2Tick3Color() { return Color.GREEN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick3Opacity",
			name = "Tick 3 Opacity",
			description = "How transparent tick 3's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 6
	)
	default int beat2Tick3Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick4Color",
			name = "Tick 4 Color",
			description = "Color for Beat 2 Tick 4 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 7
	)
	default Color beat2Tick4Color() { return Color.YELLOW; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick4Opacity",
			name = "Tick 4 Opacity",
			description = "How transparent tick 4's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 8
	)
	default int beat2Tick4Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick5Color",
			name = "Tick 5 Color",
			description = "Color for Beat 2 Tick 5 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 9
	)
	default Color beat2Tick5Color() { return Color.ORANGE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick5Opacity",
			name = "Tick 5 Opacity",
			description = "How transparent tick 5's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 10
	)
	default int beat2Tick5Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick6Color",
			name = "Tick 6 Color",
			description = "Color for Beat 2 Tick 6 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 11
	)
	default Color beat2Tick6Color() { return Color.PINK; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick6Opacity",
			name = "Tick 6 Opacity",
			description = "How transparent tick 6's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 12
	)
	default int beat2Tick6Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick7Color",
			name = "Tick 7 Color",
			description = "Color for Beat 2 Tick 7 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 13
	)
	default Color beat2Tick7Color() { return Color.MAGENTA; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick7Opacity",
			name = "Tick 7 Opacity",
			description = "How transparent tick 7's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 14
	)
	default int beat2Tick7Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick8Color",
			name = "Tick 8 Color",
			description = "Color for Beat 2 Tick 8 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 15
	)
	default Color beat2Tick8Color() { return Color.CYAN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick8Opacity",
			name = "Tick 8 Opacity",
			description = "How transparent tick 8's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 16
	)
	default int beat2Tick8Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat2Tick9Color",
			name = "Tick 9 Color",
			description = "Color for Beat 2 Tick 9 (applies to both text and overlay)",
			section = beat2Visuals,
			position = 17
	)
	default Color beat2Tick9Color() { return Color.LIGHT_GRAY; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat2Tick9Opacity",
			name = "Tick 9 Opacity",
			description = "How transparent tick 9's overlay is (0 = invisible, 100 = solid)",
			section = beat2Visuals,
			position = 18
	)
	default int beat2Tick9Opacity() { return 10; }


	////////////////////////////////////////////////
	//////////////////  Beat 3  ////////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 3 (Activate With Next Beat Hotkey)",
			description = "Another beat to use, activate with next beat hotkey",
			position = 19
	)
	String Beat3 = "Beat3";

	@Range(min = 1, max = 9)
	@ConfigItem(
			keyName = "beat3TickCount",
			name = "Beat 3 Tick Count",
			description = "Number of ticks in Beat 3's loop (1 to 9)",
			section = Beat3,
			position = 1
	)
	default int beat3TickCount() { return 4; }

	////////////////////////////////////////////////
	//////////////  Beat 3 Sounds  /////////////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 3 Sound Options",
			description = "Configure sounds for Beat 3",
			position = 20,
			closedByDefault = true
	)
	String beat3Sounds = "beat3Sounds";

	@ConfigItem(
			keyName = "beat3Tick1Sound",
			name = "Tick 1 Sound",
			description = "Sound to play on Beat 3 Tick 1",
			section = beat3Sounds,
			position = 1
	)
	default TickSoundOption beat3Tick1Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick1Volume",
			name = "Tick 1 Volume",
			description = "How loud to play Beat 3 Tick 1",
			section = beat3Sounds,
			position = 2
	)
	@Range(min = 0, max = 150)
	default int beat3Tick1Volume() { return 100; }

	@ConfigItem(
			keyName = "beat3Tick2Sound",
			name = "Tick 2 Sound",
			description = "Sound to play on Beat 3 Tick 2",
			section = beat3Sounds,
			position = 3
	)
	default TickSoundOption beat3Tick2Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick2Volume",
			name = "Tick 2 Volume",
			description = "How loud to play Beat 3 Tick 2",
			section = beat3Sounds,
			position = 4
	)
	@Range(min = 0, max = 150)
	default int beat3Tick2Volume() { return 100; }

	@ConfigItem(
			keyName = "beat3Tick3Sound",
			name = "Tick 3 Sound",
			description = "Sound to play on Beat 3 Tick 3",
			section = beat3Sounds,
			position = 5
	)
	default TickSoundOption beat3Tick3Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick3Volume",
			name = "Tick 3 Volume",
			description = "How loud to play Beat 3 Tick 3",
			section = beat3Sounds,
			position = 6
	)
	@Range(min = 0, max = 150)
	default int beat3Tick3Volume() { return 100; }

	@ConfigItem(
			keyName = "beat3Tick4Sound",
			name = "Tick 4 Sound",
			description = "Sound to play on Beat 3 Tick 4",
			section = beat3Sounds,
			position = 7
	)
	default TickSoundOption beat3Tick4Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick4Volume",
			name = "Tick 4 Volume",
			description = "How loud to play Beat 3 Tick 4",
			section = beat3Sounds,
			position = 8
	)
	@Range(min = 0, max = 150)
	default int beat3Tick4Volume() { return 100; }

	@ConfigItem(
			keyName = "beat3Tick5Sound",
			name = "Tick 5 Sound",
			description = "Sound to play on Beat 3 Tick 5",
			section = beat3Sounds,
			position = 9
	)
	default TickSoundOption beat3Tick5Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick5Volume",
			name = "Tick 5 Volume",
			description = "How loud to play Beat 3 Tick 5",
			section = beat3Sounds,
			position = 10
	)
	@Range(min = 0, max = 150)
	default int beat3Tick5Volume() { return 100; }

	@ConfigItem(
			keyName = "beat3Tick6Sound",
			name = "Tick 6 Sound",
			description = "Sound to play on Beat 3 Tick 6",
			section = beat3Sounds,
			position = 11
	)
	default TickSoundOption beat3Tick6Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick6Volume",
			name = "Tick 6 Volume",
			description = "How loud to play Beat 3 Tick 6",
			section = beat3Sounds,
			position = 12
	)
	@Range(min = 0, max = 150)
	default int beat3Tick6Volume() { return 100; }

	@ConfigItem(
			keyName = "beat3Tick7Sound",
			name = "Tick 7 Sound",
			description = "Sound to play on Beat 3 Tick 7",
			section = beat3Sounds,
			position = 13
	)
	default TickSoundOption beat3Tick7Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick7Volume",
			name = "Tick 7 Volume",
			description = "How loud to play Beat 3 Tick 7",
			section = beat3Sounds,
			position = 14
	)
	@Range(min = 0, max = 150)
	default int beat3Tick7Volume() { return 100; }

	@ConfigItem(
			keyName = "beat3Tick8Sound",
			name = "Tick 8 Sound",
			description = "Sound to play on Beat 3 Tick 8",
			section = beat3Sounds,
			position = 15
	)
	default TickSoundOption beat3Tick8Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick8Volume",
			name = "Tick 8 Volume",
			description = "How loud to play Beat 3 Tick 8",
			section = beat3Sounds,
			position = 16
	)
	@Range(min = 0, max = 150)
	default int beat3Tick8Volume() { return 100; }

	@ConfigItem(
			keyName = "beat3Tick9Sound",
			name = "Tick 9 Sound",
			description = "Sound to play on Beat 3 Tick 9",
			section = beat3Sounds,
			position = 17
	)
	default TickSoundOption beat3Tick9Sound() { return TickSoundOption.TICK; }

	@ConfigItem(
			keyName = "beat3Tick9Volume",
			name = "Tick 9 Volume",
			description = "How loud to play Beat 3 Tick 9",
			section = beat3Sounds,
			position = 18
	)
	@Range(min = 0, max = 150)
	default int beat3Tick9Volume() { return 100; }



	////////////////////////////////////////////////
	////////////  Beat 3 Visual Options  ///////////
	////////////////////////////////////////////////

	@ConfigSection(
			name = "Beat 3 Visual Options",
			description = "Configure colors and opacity for Beat 3",
			position = 21,
			closedByDefault = true
	)
	String beat3Visuals = "beat3Visuals";

	@ConfigItem(
			keyName = "beat3Tick1Color",
			name = "Tick 1 Color",
			description = "Color for Beat 3 Tick 1 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 1
	)
	default Color beat3Tick1Color() { return Color.RED; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick1Opacity",
			name = "Tick 1 Opacity",
			description = "How transparent tick 1's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 2
	)
	default int beat3Tick1Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick2Color",
			name = "Tick 2 Color",
			description = "Color for Beat 3 Tick 2 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 3
	)
	default Color beat3Tick2Color() { return Color.BLUE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick2Opacity",
			name = "Tick 2 Opacity",
			description = "How transparent tick 2's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 4
	)
	default int beat3Tick2Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick3Color",
			name = "Tick 3 Color",
			description = "Color for Beat 3 Tick 3 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 5
	)
	default Color beat3Tick3Color() { return Color.GREEN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick3Opacity",
			name = "Tick 3 Opacity",
			description = "How transparent tick 3's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 6
	)
	default int beat3Tick3Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick4Color",
			name = "Tick 4 Color",
			description = "Color for Beat 3 Tick 4 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 7
	)
	default Color beat3Tick4Color() { return Color.YELLOW; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick4Opacity",
			name = "Tick 4 Opacity",
			description = "How transparent tick 4's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 8
	)
	default int beat3Tick4Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick5Color",
			name = "Tick 5 Color",
			description = "Color for Beat 3 Tick 5 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 9
	)
	default Color beat3Tick5Color() { return Color.ORANGE; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick5Opacity",
			name = "Tick 5 Opacity",
			description = "How transparent tick 5's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 10
	)
	default int beat3Tick5Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick6Color",
			name = "Tick 6 Color",
			description = "Color for Beat 3 Tick 6 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 11
	)
	default Color beat3Tick6Color() { return Color.PINK; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick6Opacity",
			name = "Tick 6 Opacity",
			description = "How transparent tick 6's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 12
	)
	default int beat3Tick6Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick7Color",
			name = "Tick 7 Color",
			description = "Color for Beat 3 Tick 7 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 13
	)
	default Color beat3Tick7Color() { return Color.MAGENTA; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick7Opacity",
			name = "Tick 7 Opacity",
			description = "How transparent tick 7's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 14
	)
	default int beat3Tick7Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick8Color",
			name = "Tick 8 Color",
			description = "Color for Beat 3 Tick 8 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 15
	)
	default Color beat3Tick8Color() { return Color.CYAN; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick8Opacity",
			name = "Tick 8 Opacity",
			description = "How transparent tick 8's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 16
	)
	default int beat3Tick8Opacity() { return 10; }

	@ConfigItem(
			keyName = "beat3Tick9Color",
			name = "Tick 9 Color",
			description = "Color for Beat 3 Tick 9 (applies to both text and overlay)",
			section = beat3Visuals,
			position = 17
	)
	default Color beat3Tick9Color() { return Color.LIGHT_GRAY; }

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "beat3Tick9Opacity",
			name = "Tick 9 Opacity",
			description = "How transparent tick 9's overlay is (0 = invisible, 100 = solid)",
			section = beat3Visuals,
			position = 18
	)
	default int beat3Tick9Opacity() { return 10; }

	/////////////////////////////////////////////
	////////////  Playlist Options  /////////////
	/////////////////////////////////////////////

	@ConfigSection(
			name = "Playlist Settings",
			description = "Settings that apply to all playlists",
			position = 24
	)
	String playlistSettings = "playlistSettings";

	@ConfigItem(
			keyName = "shuffle",
			name = "Shuffle Playlist",
			description = "Play songs in random order",
			section = playlistSettings,
			position = 5
	)
	default boolean shufflePlaylist() { return false; }

	///////////////////////////////////////////////
	////////////  Playlist 1 Options  /////////////
	///////////////////////////////////////////////

	@ConfigSection(
			name = "Playlist 1",
			description = "Customize the songs included in playlist 1, songs set to none are ignored",
			position = 25,
			closedByDefault = true
	)
	String playlist1Section = "playlist1Section";

	@ConfigItem(
			keyName = "playlist1Track1",
			name = "1",
			description = "Music track 1",
			position = 1,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track1() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track2",
			name = "2",
			description = "Music track 2",
			position = 2,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track2() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track3",
			name = "3",
			description = "Music track 3",
			position = 3,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track3() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track4",
			name = "4",
			description = "Music track 4",
			position = 4,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track4() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track5",
			name = "5",
			description = "Music track 5",
			position = 5,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track5() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track6",
			name = "6",
			description = "Music track 6",
			position = 6,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track6() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track7",
			name = "7",
			description = "Music track 7",
			position = 7,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track7() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track8",
			name = "8",
			description = "Music track 8",
			position = 8,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track8() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track9",
			name = "9",
			description = "Music track 9",
			position = 9,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track9() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track10",
			name = "10",
			description = "Music track 10",
			position = 10,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track10() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track11",
			name = "11",
			description = "Music track 11",
			position = 11,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track11() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track12",
			name = "12",
			description = "Music track 12",
			position = 12,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track12() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track13",
			name = "13",
			description = "Music track 13",
			position = 13,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track13() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track14",
			name = "14",
			description = "Music track 14",
			position = 14,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track14() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track15",
			name = "15",
			description = "Music track 15",
			position = 15,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track15() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track16",
			name = "16",
			description = "Music track 16",
			position = 16,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track16() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track17",
			name = "17",
			description = "Music track 17",
			position = 17,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track17() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track18",
			name = "18",
			description = "Music track 18",
			position = 18,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track18() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track19",
			name = "19",
			description = "Music track 19",
			position = 19,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track19() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track20",
			name = "20",
			description = "Music track 20",
			position = 20,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track20() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track21",
			name = "21",
			description = "Music track 21",
			position = 21,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track21() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track22",
			name = "22",
			description = "Music track 22",
			position = 22,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track22() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track23",
			name = "23",
			description = "Music track 23",
			position = 23,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track23() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track24",
			name = "24",
			description = "Music track 24",
			position = 24,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track24() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist1Track25",
			name = "25",
			description = "Music track 25",
			position = 25,
			section = "playlist1Section"
	)
	default MusicTrackOption playlist1Track25() { return MusicTrackOption.NONE; }



	///////////////////////////////////////////////
	////////////  Playlist 2 Options  /////////////
	///////////////////////////////////////////////

	@ConfigSection(
			name = "Playlist 2",
			description = "Customize the songs in playlist 2, songs set to none are ignored",
			position = 26,
			closedByDefault = true
	)
	String playlist2Section = "playlist2Section";

	@ConfigItem(
			keyName = "playlist2Track1",
			name = "1",
			description = "Music track 1",
			position = 1,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track1() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track2",
			name = "2",
			description = "Music track 2",
			position = 2,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track2() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track3",
			name = "3",
			description = "Music track 3",
			position = 3,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track3() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track4",
			name = "4",
			description = "Music track 4",
			position = 4,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track4() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track5",
			name = "5",
			description = "Music track 5",
			position = 5,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track5() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track6",
			name = "6",
			description = "Music track 6",
			position = 6,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track6() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track7",
			name = "7",
			description = "Music track 7",
			position = 7,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track7() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track8",
			name = "8",
			description = "Music track 8",
			position = 8,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track8() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track9",
			name = "9",
			description = "Music track 9",
			position = 9,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track9() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track10",
			name = "10",
			description = "Music track 10",
			position = 10,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track10() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track11",
			name = "11",
			description = "Music track 11",
			position = 11,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track11() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track12",
			name = "12",
			description = "Music track 12",
			position = 12,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track12() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track13",
			name = "13",
			description = "Music track 13",
			position = 13,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track13() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track14",
			name = "14",
			description = "Music track 14",
			position = 14,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track14() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track15",
			name = "15",
			description = "Music track 15",
			position = 15,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track15() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track16",
			name = "16",
			description = "Music track 16",
			position = 16,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track16() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track17",
			name = "17",
			description = "Music track 17",
			position = 17,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track17() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track18",
			name = "18",
			description = "Music track 18",
			position = 18,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track18() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track19",
			name = "19",
			description = "Music track 19",
			position = 19,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track19() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track20",
			name = "20",
			description = "Music track 20",
			position = 20,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track20() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track21",
			name = "21",
			description = "Music track 21",
			position = 21,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track21() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track22",
			name = "22",
			description = "Music track 22",
			position = 22,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track22() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track23",
			name = "23",
			description = "Music track 23",
			position = 23,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track23() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track24",
			name = "24",
			description = "Music track 24",
			position = 24,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track24() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist2Track25",
			name = "25",
			description = "Music track 25",
			position = 25,
			section = "playlist2Section"
	)
	default MusicTrackOption playlist2Track25() { return MusicTrackOption.NONE; }

	///////////////////////////////////////////////
	////////////  Playlist 3 Options  /////////////
	///////////////////////////////////////////////

	@ConfigSection(
			name = "Playlist 3",
			description = "Customize the songs in playlist 3, songs set to none are ignored",
			position = 27,
			closedByDefault = true
	)
	String playlist3Section = "playlist3Section";

	@ConfigItem(
			keyName = "playlist3Track1",
			name = "1",
			description = "Music track 1",
			position = 1,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track1() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track2",
			name = "2",
			description = "Music track 2",
			position = 2,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track2() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track3",
			name = "3",
			description = "Music track 3",
			position = 3,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track3() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track4",
			name = "4",
			description = "Music track 4",
			position = 4,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track4() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track5",
			name = "5",
			description = "Music track 5",
			position = 5,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track5() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track6",
			name = "6",
			description = "Music track 6",
			position = 6,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track6() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track7",
			name = "7",
			description = "Music track 7",
			position = 7,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track7() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track8",
			name = "8",
			description = "Music track 8",
			position = 8,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track8() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track9",
			name = "9",
			description = "Music track 9",
			position = 9,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track9() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track10",
			name = "10",
			description = "Music track 10",
			position = 10,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track10() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track11",
			name = "11",
			description = "Music track 11",
			position = 11,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track11() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track12",
			name = "12",
			description = "Music track 12",
			position = 12,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track12() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track13",
			name = "13",
			description = "Music track 13",
			position = 13,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track13() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track14",
			name = "14",
			description = "Music track 14",
			position = 14,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track14() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track15",
			name = "15",
			description = "Music track 15",
			position = 15,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track15() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track16",
			name = "16",
			description = "Music track 16",
			position = 16,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track16() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track17",
			name = "17",
			description = "Music track 17",
			position = 17,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track17() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track18",
			name = "18",
			description = "Music track 18",
			position = 18,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track18() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track19",
			name = "19",
			description = "Music track 19",
			position = 19,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track19() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track20",
			name = "20",
			description = "Music track 20",
			position = 20,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track20() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track21",
			name = "21",
			description = "Music track 21",
			position = 21,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track21() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track22",
			name = "22",
			description = "Music track 22",
			position = 22,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track22() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track23",
			name = "23",
			description = "Music track 23",
			position = 23,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track23() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track24",
			name = "24",
			description = "Music track 24",
			position = 24,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track24() { return MusicTrackOption.NONE; }

	@ConfigItem(
			keyName = "playlist3Track25",
			name = "25",
			description = "Music track 25",
			position = 25,
			section = "playlist3Section"
	)
	default MusicTrackOption playlist3Track25() { return MusicTrackOption.NONE; }

}



package com.TickBeatsMetronome;


import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Slf4j
@Singleton
public class OverlayOverheadNumber extends Overlay
{
    @Inject
    Client client;

    @Inject
    TickBeatsMetronomePlugin plugin;

    @Inject
    TickBeatsMetronomeConfig config;

    @Inject
    public OverlayOverheadNumber()
    {
        // Set the overlay to move with the game world (e.g., above the player)
        setPosition(OverlayPosition.DYNAMIC);
        // Draw this above the main game scene (so it shows over your player)
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    //note render runs every time the screen is redrawn
    public Dimension render(Graphics2D graphics)
    {

        //if the visual metronome is turned off, don't draw it to the screen
        if (!config.enableTextMetronome()){
            return null;
        }

        Player player = client.getLocalPlayer(); // Get your own character
        if (player == null)
        {
            log.debug("Player");
            return null; // Game might still be loading
        }

        // Get the current tick number
        String tickText = String.valueOf(plugin.tickCount);

        // Determine where to draw the text
        int zOffset = config.textVerticalOffset(); // Get absolute value for the initial calculation
        Point textLocation = player.getCanvasTextLocation(graphics, tickText, zOffset);
        if (textLocation == null)
        {
            log.debug("couldn't calculate text location");
            return null; // Couldn't calculate a position
        }

        // Set font from config
        graphics.setFont(new Font("Arial", Font.BOLD, config.fontSize()));

        //get the width of text so that it can be centered
        FontMetrics metrics = graphics.getFontMetrics();
        int textWidth = metrics.stringWidth(tickText);

        //place the text on the screen
        int x = textLocation.getX() - (textWidth / 2);
        int y = textLocation.getY();
        


        // Draw black outline around text (offset by 1 pixel in each direction)
        graphics.setColor(Color.BLACK);
        graphics.drawString(tickText, x + 1, y);
        graphics.drawString(tickText, x - 1, y);
        graphics.drawString(tickText, x, y + 1);
        graphics.drawString(tickText, x, y - 1);

        // Get the appropriate color based on current beat and tick
        Color textColor;
        if (plugin.beatNumber == 1) {
            switch (plugin.tickCount) {
                case 1: textColor = config.beat1Tick1Color(); break;
                case 2: textColor = config.beat1Tick2Color(); break;
                case 3: textColor = config.beat1Tick3Color(); break;
                case 4: textColor = config.beat1Tick4Color(); break;
                case 5: textColor = config.beat1Tick5Color(); break;
                case 6: textColor = config.beat1Tick6Color(); break;
                case 7: textColor = config.beat1Tick7Color(); break;
                case 8: textColor = config.beat1Tick8Color(); break;
                case 9: textColor = config.beat1Tick9Color(); break;
                default: textColor = Color.WHITE; break;
            }
        } else if (plugin.beatNumber == 2) {
            switch (plugin.tickCount) {
                case 1: textColor = config.beat2Tick1Color(); break;
                case 2: textColor = config.beat2Tick2Color(); break;
                case 3: textColor = config.beat2Tick3Color(); break;
                case 4: textColor = config.beat2Tick4Color(); break;
                case 5: textColor = config.beat2Tick5Color(); break;
                case 6: textColor = config.beat2Tick6Color(); break;
                case 7: textColor = config.beat2Tick7Color(); break;
                case 8: textColor = config.beat2Tick8Color(); break;
                case 9: textColor = config.beat2Tick9Color(); break;
                default: textColor = Color.WHITE; break;
            }
        } else {
            switch (plugin.tickCount) {
                case 1: textColor = config.beat3Tick1Color(); break;
                case 2: textColor = config.beat3Tick2Color(); break;
                case 3: textColor = config.beat3Tick3Color(); break;
                case 4: textColor = config.beat3Tick4Color(); break;
                case 5: textColor = config.beat3Tick5Color(); break;
                case 6: textColor = config.beat3Tick6Color(); break;
                case 7: textColor = config.beat3Tick7Color(); break;
                case 8: textColor = config.beat3Tick8Color(); break;
                case 9: textColor = config.beat3Tick9Color(); break;
                default: textColor = Color.WHITE; break;
            }
        }

        // Draw text in tick-specific color
        graphics.setColor(textColor);
        graphics.drawString(tickText, x, y);


        return null;
    }
}

package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import javax.inject.Singleton;
import java.io.File;
import java.util.*;

@Slf4j
@Singleton
public class UserMusicManager
{
    // Path to the directory where users can drop .wav files
    private static final File MUSIC_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "tick-beats/music");

    // Stores user sound files keyed by their ID ("1", "2", etc.)
    private final Map<String, File> userMusicMap = new HashMap<>();

    // List of music files
    private List<File> userFiles = new ArrayList<>();

    /**
     * Loads all .wav Files from the user's sound directory. for access with "getUserMusicMap()"
     * Note: it doesn't add all the music data itself to memory, just File objects which contains things like the file names
     * This should be called once during plugin startup.
     */
    public void loadUserMusic()
    {
        // Clear any previously loaded music files
        userFiles.clear();
        userMusicMap.clear();

        // Ensure directory exists
        if (!MUSIC_DIRECTORY.exists())
        {
            // If the directory doesn't exist, create it
            boolean created = MUSIC_DIRECTORY.mkdirs();
            if (!created)
            {
                log.debug("Could not create user music directory: {}", MUSIC_DIRECTORY.getAbsolutePath());
                return;
            }
        }

        // List all .wav files in the sound directory
        File[] files = MUSIC_DIRECTORY.listFiles();
        if (files == null)
        {
            log.debug("Could not read music directory contents, or no files exist.");
            return;
        }

        for (File file : files)
        {
            // Only accept regular files that end in .wav
            if (file.isFile() && file.getName().toLowerCase().endsWith(".wav"))
            {
                userFiles.add(file);
                log.debug("Discovered user music file: {}", file.getName());
            }
        }

        // Sort the files by filename
        userFiles.sort(Comparator.comparing(File::getName));

        log.debug("Total user music files loaded: {}", userFiles.size());

        // Create the userMusicMap attaching an id to each sound file
        // this will be used to access user sound files based on a number alone so we don't need to work with file names
        int i = 0;
        for (File file : userFiles)
        {
            // Increment first to make the ids 1 based instead of 0 based
            i++;
            String fileId = String.valueOf(i);
            userMusicMap.put(fileId, file);
            log.debug("Registered user music [{}]: {}", fileId, file.getName());
        }
    }

    /**
     * Returns a collection of user sound files.
     * the files will be accessed with string integers matching the user track number
     * so a key of "1" will return the file for User Track 1, a key of "2" will give the File for User Track 2 and so on
     */
    public Map<String, File> getUserMusicMap()
    {
        return userMusicMap;
    }
}
package com.TickBeatsMetronome;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import java.io.*;
import java.util.HashMap;
import java.util.Map;

/**
 * TickSoundCache stores all tick sound files in memory to avoid repeatedly reading them from disk.
 *
 * Since tick sounds are small and played frequently, it is much more efficient to load them once
 * into a map (keyed by resource name) during startup or configuration changes. This allows for
 * fast retrieval and playback with minimal I/O overhead.
 */

@Slf4j
@Singleton
public class TickSoundCache
{
    // Limit user sound size to 1 MB to avoid putting too much data in memory
    private static final int MAX_FILE_SIZE_BYTES = 1024 * 1024; // 1 MB

    // Map of cached tick sounds: TickSound (format + data).
    private final Map<String, TickSound> cachedSounds = new HashMap<>();

    @Inject
    private UserSoundManager userSoundManager;

    /**
     * Preload and cache all sounds.
     * This should be called once on plugin startup.
     */
    public void cacheTickSounds(){
        cacheAllBuiltInSounds();
        cacheAllUserSounds();
    }

    /**
     * Preload and cache all built-in sounds (from resources).
     */
    public void cacheAllBuiltInSounds()
    {
        for (TickSoundOption option : TickSoundOption.values())
        {
            if (option == TickSoundOption.OFF || option.isUserSound())
            {
                continue;
            }
            cacheBuiltInSound(option.getResourceName());
        }
    }

    /**
     * Preload and cache all user sounds (from tick-beats/sounds directory).
     * This can be called once on startup, or refreshed if user updates files.
     */
    public void cacheAllUserSounds()
    {
        // Clear old user sounds (Any key that's a stringified int which indicates a user sound)
        // in case the user removed one or the order has changed
        cachedSounds.keySet().removeIf(key -> key.matches("\\d+"));

        //make sure user sound files are up to date with any changes the user may have made
        userSoundManager.loadUserSounds();

        // Now add all the user sounds to the cache
        Map<String, File> userSounds = userSoundManager.getUserSoundMap();
        for (Map.Entry<String, File> userSound : userSounds.entrySet())
        {
            cacheUserSound(userSound.getKey(), userSound.getValue());
        }
    }

    /**
     * Cache a single built-in resource sound.
     *
     * @param resourceName WAV filename in /com/TickBeatsMetronome/Sounds/
     */
    private void cacheBuiltInSound(String resourceName)
    {
        String resourcePath = "/com/TickBeatsMetronome/Sounds/" + resourceName;

        try (InputStream inputStream = TickSoundCache.class.getResourceAsStream(resourcePath))
        {
            if (inputStream == null)
            {
                log.debug("Built-in sound not found: {}", resourcePath);
                return;
            }

            //I've read it's better to use buffered input stream when using an internal sound file
            try (BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);
                 AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(bufferedInputStream))
            {
                cacheFromAudioInputStream(resourceName, audioInputStream);
            }
        }
        catch (Exception e)
        {
            log.debug("Failed to cache built-in sound {}: {}", resourceName, e.getMessage());
        }
    }

    /**
     * Cache a single user-provided sound.
     *
     * @param key  Identifier (e.g. "1", "2", etc.)
     * @param file User's sound file
     */
    private void cacheUserSound(String key, File file)
    {
        try (AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(file))
        {
            cacheFromAudioInputStream(key, audioInputStream);
        }
        catch (Exception e)
        {
            log.debug("Failed to cache user sound {}: {}", key, e.getMessage());
        }
    }

    /**
     * Decode and store a sound from an AudioInputStream.
     * Truncates files larger than 1 MB and shows an overlay warning.
     *
     * @param soundKey         Key used for lookup (e.g., "tick-hihat.wav" or "1")
     * @param audioInputStream The decoded audio stream from a WAV file or resource
     */
    private void cacheFromAudioInputStream(String soundKey, AudioInputStream audioInputStream) throws IOException
    {
        AudioFormat audioFormat = audioInputStream.getFormat();

        // Read up to MAX_FILE_SIZE_BYTES of audio data (will truncate if larger)
        byte[] rawAudioData = audioInputStream.readNBytes(MAX_FILE_SIZE_BYTES);

        // Store the decoded PCM data and format in the cache
        TickSound tickSound = new TickSound(audioFormat, rawAudioData);

        //add the key and tickSound data to the cache map
        cachedSounds.put(soundKey, tickSound);

        log.debug("Cached sound {} ({} bytes, {} Hz)", soundKey, rawAudioData.length, audioFormat.getSampleRate());
    }

    /**
     * Retrieve a CachedSound (format + PCM data) by key.
     *
     * @param key File name or user sound number
     * @return CachedSound or null if not cached
     */
    public TickSound getSound(String key)
    {
        return cachedSounds.get(key);
    }

    /**
     * Clear ALL cached sounds (both built-in + user).
     */
    public void clearAll()
    {
        cachedSounds.clear();
        log.debug("Cleared all cached tick sounds");
    }

}
package com.TickBeatsMetronome;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TickBeatsMetronomePlugin.class);
		RuneLite.main(args);
	}
}
