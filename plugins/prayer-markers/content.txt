package com.coopermor.prayermarkers;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;

@ConfigGroup("prayermarkers")
public interface PrayerMarkersConfig extends Config
{

}

package com.coopermor.prayermarkers;

import net.runelite.api.gameval.InterfaceID;

public final class WidgetID
{
	public static final int PRAYER_ID = InterfaceID.PRAYERBOOK;

	static class Prayer
	{
		static final int THICK_SKIN = 9;
		static final int BURST_OF_STRENGTH = 10;
		static final int CLARITY_OF_THOUGHT = 11;
		static final int ROCK_SKIN = 12;
		static final int SUPERHUMAN_STRENGTH = 13;
		static final int IMPROVED_REFLEXES = 14;
		static final int RAPID_RESTORE = 15;
		static final int RAPID_HEAL = 16;
		static final int PROTECT_ITEM = 17;
		static final int STEEL_SKIN = 18;
		static final int ULTIMATE_STRENGTH = 19;
		static final int INCREDIBLE_REFLEXES = 20;
		static final int PROTECT_FROM_MAGIC = 21;
		static final int PROTECT_FROM_MISSILES = 22;
		static final int PROTECT_FROM_MELEE = 23;
		static final int RETRIBUTION = 24;
		static final int REDEMPTION = 25;
		static final int SMITE = 26;
		static final int SHARP_EYE = 27;
		static final int HAWK_EYE = 28;
		static final int EAGLE_EYE = 29;
		static final int MYSTIC_WILL = 30;
		static final int MYSTIC_LORE = 31;
		static final int MYSTIC_MIGHT = 32;
		static final int RIGOUR = 33;
		static final int CHIVALRY = 34;
		static final int PIETY = 35;
		static final int AUGURY = 36;
		static final int PRESERVE = 37;
	}
}

package com.coopermor.prayermarkers;

import net.runelite.api.gameval.VarbitID;

public enum PrayerInfo
{
	THICK_SKIN(VarbitID.PRAYER_THICKSKIN, "Thick Skin", WidgetInfo.PRAYER_THICK_SKIN),
	BURST_OF_STRENGTH(VarbitID.PRAYER_BURSTOFSTRENGTH, "Burst of Strength", WidgetInfo.PRAYER_BURST_OF_STRENGTH),
	CLARITY_OF_THOUGHT(VarbitID.PRAYER_CLARITYOFTHOUGHT, "Clarity of Thought", WidgetInfo.PRAYER_CLARITY_OF_THOUGHT),
	SHARP_EYE(VarbitID.PRAYER_SHARPEYE, "Sharp Eye", WidgetInfo.PRAYER_SHARP_EYE),
	MYSTIC_WILL(VarbitID.PRAYER_MYSTICWILL, "Mystic Will", WidgetInfo.PRAYER_MYSTIC_WILL),
	ROCK_SKIN(VarbitID.PRAYER_ROCKSKIN, "Rock Skin", WidgetInfo.PRAYER_ROCK_SKIN),
	SUPERHUMAN_STRENGTH(VarbitID.PRAYER_SUPERHUMANSTRENGTH, "Superhuman Strength", WidgetInfo.PRAYER_SUPERHUMAN_STRENGTH),
	IMPROVED_REFLEXES(VarbitID.PRAYER_IMPROVEDREFLEXES, "Improved Reflexes", WidgetInfo.PRAYER_IMPROVED_REFLEXES),
	RAPID_RESTORE(VarbitID.PRAYER_RAPIDRESTORE, "Rapid Restore", WidgetInfo.PRAYER_RAPID_RESTORE),
	RAPID_HEAL(VarbitID.PRAYER_RAPIDHEAL, "Rapid Heal", WidgetInfo.PRAYER_RAPID_HEAL),
	PROTECT_ITEM(VarbitID.PRAYER_PROTECTITEM, "Protect Item", WidgetInfo.PRAYER_PROTECT_ITEM),
	HAWK_EYE(VarbitID.PRAYER_HAWKEYE, "Hawk Eye", WidgetInfo.PRAYER_HAWK_EYE),
	MYSTIC_LORE(VarbitID.PRAYER_MYSTICLORE, "Mystic Lore", WidgetInfo.PRAYER_MYSTIC_LORE),
	STEEL_SKIN(VarbitID.PRAYER_STEELSKIN, "Steel Skin", WidgetInfo.PRAYER_STEEL_SKIN),
	ULTIMATE_STRENGTH(VarbitID.PRAYER_ULTIMATESTRENGTH, "Ultimate Strength", WidgetInfo.PRAYER_ULTIMATE_STRENGTH),
	INCREDIBLE_REFLEXES(VarbitID.PRAYER_INCREDIBLEREFLEXES, "Incredible Reflexes", WidgetInfo.PRAYER_INCREDIBLE_REFLEXES),
	PROTECT_FROM_MAGIC(VarbitID.PRAYER_PROTECTFROMMAGIC, "Protect from Magic", WidgetInfo.PRAYER_PROTECT_FROM_MAGIC),
	PROTECT_FROM_MISSILES(VarbitID.PRAYER_PROTECTFROMMISSILES, "Protect from Missiles", WidgetInfo.PRAYER_PROTECT_FROM_MISSILES),
	PROTECT_FROM_MELEE(VarbitID.PRAYER_PROTECTFROMMELEE, "Protect from Melee", WidgetInfo.PRAYER_PROTECT_FROM_MELEE),
	EAGLE_EYE(VarbitID.PRAYER_EAGLEEYE, "Eagle Eye/Deadeye", WidgetInfo.PRAYER_EAGLE_EYE),
	MYSTIC_MIGHT(VarbitID.PRAYER_MYSTICMIGHT, "Mystic Might/Mystic Vigour", WidgetInfo.PRAYER_MYSTIC_MIGHT),
	RETRIBUTION(VarbitID.PRAYER_RETRIBUTION, "Retribution", WidgetInfo.PRAYER_RETRIBUTION),
	REDEMPTION(VarbitID.PRAYER_REDEMPTION, "Redemption", WidgetInfo.PRAYER_REDEMPTION),
	SMITE(VarbitID.PRAYER_SMITE, "Smite", WidgetInfo.PRAYER_SMITE),
	CHIVALRY(VarbitID.PRAYER_CHIVALRY, "Chivalry", WidgetInfo.PRAYER_CHIVALRY),
	PIETY(VarbitID.PRAYER_PIETY, "Piety", WidgetInfo.PRAYER_PIETY),
	PRESERVE(VarbitID.PRAYER_PRESERVE, "Preserve", WidgetInfo.PRAYER_PRESERVE),
	RIGOUR(VarbitID.PRAYER_RIGOUR, "Rigour", WidgetInfo.PRAYER_RIGOUR),
	AUGURY(VarbitID.PRAYER_AUGURY, "Augury", WidgetInfo.PRAYER_AUGURY);

	private final int varbit;
	private final String displayName;
	private final WidgetInfo widgetInfo;

	PrayerInfo(int varbit, String displayName, WidgetInfo widgetInfo)
	{
		this.varbit = varbit;
		this.displayName = displayName;
		this.widgetInfo = widgetInfo;
	}

	public int getVarbit()
	{
		return varbit;
	}

	public String getDisplayName()
	{
		return displayName;
	}

	public WidgetInfo getWidgetInfo()
	{
		return widgetInfo;
	}

	public static int getPrayerWidgetId(PrayerInfo prayer)
	{
		return PrayerInfo.valueOf(prayer.name()).getWidgetInfo().getId();
	}
}

package com.coopermor.prayermarkers;

import net.runelite.api.Client;
import net.runelite.api.VarClientInt;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;

public class Overlay
{
	public static Rectangle renderPrayerOverlay(Graphics2D graphics, Client client, PrayerInfo prayer, Color color, float borderWidth)
	{
		Widget prayerIconWidget = client.getWidget(PrayerInfo.getPrayerWidgetId(prayer));
		if (prayerIconWidget == null || !prayerWidgetVisibilityChecks(client, prayerIconWidget))
		{
			return null;
		}
		Rectangle prayerIconBounds = prayerIconWidget.getBounds();
		Stroke stroke = new BasicStroke(borderWidth);
		Color clear = new Color(0, 0, 0, 0);
		OverlayUtil.renderPolygon(graphics, rectangleToPolygon(prayerIconBounds), color, clear, stroke);
		return prayerIconBounds;
	}

	private static Polygon rectangleToPolygon(Rectangle rectangle)
	{
		int[] x_points = {rectangle.x, rectangle.x + rectangle.width, rectangle.x + rectangle.width, rectangle.x};
		int[] y_points = {rectangle.y, rectangle.y, rectangle.y + rectangle.height, rectangle.y + rectangle.height};

		return new Polygon(x_points, y_points, 4);
	}

	private static boolean prayerWidgetVisibilityChecks(Client client, Widget prayerWidget)
	{
		// Check if the inventory tab is on Prayer
		if (client.getVarcIntValue(VarClientInt.INVENTORY_TAB) != 5)
		{
			return false;
		}

		// Interfaces like the bank and shops still has VarClientInt.INVENTORY_TAB set to 5
		// but are forced away from the prayer screen. So we check the prayer widget is visible
		Widget prayerBook = client.getWidget(35454976);
		if (prayerBook == null || prayerBook.isHidden())
		{
			return false;
		}

		// Check if the prayer filtering interface widget is showing
		Widget prayerFilters = client.getWidget(35454982);
		if (prayerFilters != null)
		{
			// 1141 is white and 1150 is red, red means toggled
			Widget filterSprite = prayerFilters.getChild(0);
			if (filterSprite != null && filterSprite.getSpriteId() == 1150)
			{
				return false;
			}
		}

		// Check if the prayer icons are hidden through prayer filtering
		if (prayerWidget != null)
		{
			return !prayerWidget.isHidden();
		}
		return true;
	}
}
package com.coopermor.prayermarkers.ui.listeners;

import com.coopermor.prayermarkers.PrayerMarker;
import com.coopermor.prayermarkers.ui.PrayerMarkersPanel;
import com.coopermor.prayermarkers.PrayerMarkersPlugin;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ExpandMarkerActionListener implements ActionListener
{
	private final PrayerMarkersPlugin plugin;
	private final PrayerMarker marker;
	private final PrayerMarkersPanel panel;

	public ExpandMarkerActionListener(PrayerMarkersPlugin plugin, PrayerMarker marker, PrayerMarkersPanel panel)
	{
		this.plugin = plugin;
		this.marker = marker;
		this.panel = panel;
	}

	@Override
	public void actionPerformed(ActionEvent actionEvent)
	{
		boolean open = panel.markerContainer.isVisible();
		marker.setCollapsed(open);
		panel.updateCollapsed();
		plugin.saveMarkers();
	}
}

package com.coopermor.prayermarkers.ui.listeners;

import com.coopermor.prayermarkers.PrayerMarker;
import com.coopermor.prayermarkers.PrayerInfo;

import javax.swing.JComboBox;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Map;

public class PrayerSelectionActionListener implements ActionListener
{
	private final JComboBox<String> prayerSelection;
	private final Map<String, PrayerInfo> prayerMap;
	private final PrayerMarker marker;

	public PrayerSelectionActionListener(JComboBox<String> prayerSelection, Map<String, PrayerInfo> prayerMap, PrayerMarker marker)
	{
		this.prayerSelection = prayerSelection;
		this.prayerMap = prayerMap;
		this.marker = marker;
	}

	@Override
	public void actionPerformed(ActionEvent e)
	{
		String selectedName = (String) prayerSelection.getSelectedItem();
		if (selectedName != null)
		{
			PrayerInfo selectedPrayer = prayerMap.get(selectedName);
			if (selectedPrayer != null)
			{
				marker.setPrayerInfo(selectedPrayer);
			}
		}
	}
}

package com.coopermor.prayermarkers.ui;

import com.coopermor.prayermarkers.PrayerInfo;
import com.coopermor.prayermarkers.PrayerMarker;
import com.coopermor.prayermarkers.PrayerMarkersPlugin;
import com.coopermor.prayermarkers.ui.adapters.BorderWidthKeyAdapter;
import com.coopermor.prayermarkers.ui.adapters.CancelMouseAdapter;
import com.coopermor.prayermarkers.ui.adapters.DeleteMarkerMouseAdapter;
import com.coopermor.prayermarkers.ui.adapters.NameInputDoubleClickMouseAdapter;
import com.coopermor.prayermarkers.ui.adapters.NameInputKeyAdapter;
import com.coopermor.prayermarkers.ui.adapters.PrayerMarkerColorMouseAdapter;
import com.coopermor.prayermarkers.ui.adapters.RenameMouseAdapter;
import com.coopermor.prayermarkers.ui.adapters.SaveMouseAdapter;
import com.coopermor.prayermarkers.ui.adapters.HideMarkerMouseAdapter;
import com.coopermor.prayermarkers.ui.listeners.ExpandMarkerActionListener;

import com.coopermor.prayermarkers.ui.listeners.PrayerSelectionActionListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

public class PrayerMarkersPanel extends JPanel
{
	public final PrayerMarkersPlugin plugin;

	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
		BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
		BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	private static final ImageIcon
		BORDER_COLOR_ICON,
		VISIBLE_ICON,
		INVISIBLE_ICON,
		DELETE_ICON,
		COLLAPSE_ICON,
		COLLAPSE_HOVER_ICON,
		EXPAND_ICON,
		EXPAND_HOVER_ICON;

	public final JLabel
		prayerMarkerColor = new JLabel(),
		hideMarker        = new JLabel(),
		deleteMarker      = new JLabel();

	private final JLabel
		save   = new JLabel("Save"),
		cancel = new JLabel("Cancel"),
		rename = new JLabel("Rename");

	private final JSpinner borderWidth = new JSpinner(new SpinnerNumberModel(1.0, 0.1, 10.0, 0.1));
	public final JPanel markerContainer = new JPanel(new BorderLayout());
	private final FlatTextField nameInput = new FlatTextField();
	private final PrayerMarker marker;
	private final JButton expandMarker;

	static
	{
		final BufferedImage borderImg = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "border_color_icon.png");
		BORDER_COLOR_ICON = new ImageIcon(borderImg);

		final BufferedImage visibleImg = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "visible_icon.png");
		VISIBLE_ICON = new ImageIcon(visibleImg);

		final BufferedImage invisibleImg = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "invisible_icon.png");
		INVISIBLE_ICON = new ImageIcon(invisibleImg);

		final BufferedImage deleteImg = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "delete_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);

		BufferedImage retractIcon = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "arrow_right.png");
		retractIcon = ImageUtil.luminanceOffset(retractIcon, -121);
		EXPAND_ICON = new ImageIcon(retractIcon);
		EXPAND_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(retractIcon, -100));

		final BufferedImage expandIcon = ImageUtil.rotateImage(retractIcon, Math.PI / 2);
		COLLAPSE_ICON = new ImageIcon(expandIcon);
		COLLAPSE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(expandIcon, -100));
	}

	public PrayerMarkersPanel(PrayerMarkersPlugin plugin, PrayerMarker marker)
	{
		this.plugin = plugin;
		this.marker = marker;

		Map<String, PrayerInfo> prayerMap = new HashMap<>();
		JComboBox<String> prayerSelection = new JComboBox<>();

		for (PrayerInfo prayer : PrayerInfo.values())
		{
			String name = prayer.getDisplayName();
			prayerSelection.addItem(name);
			prayerMap.put(name, prayer);
		}

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setBorder(NAME_BOTTOM_BORDER);

		JPanel nameActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 3));
		nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		save.setVisible(false);
		save.setFont(FontManager.getRunescapeSmallFont());
		save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		save.setBorder(new EmptyBorder(3, 0, 0, 3));
		save.addMouseListener(new SaveMouseAdapter(save, this::save));

		cancel.setVisible(false);
		cancel.setFont(FontManager.getRunescapeSmallFont());
		cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		cancel.setBorder(new EmptyBorder(3, 0, 0, 3));
		cancel.addMouseListener(new CancelMouseAdapter(cancel, this::cancel));

		rename.setFont(FontManager.getRunescapeSmallFont());
		rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		rename.addMouseListener(new RenameMouseAdapter(rename, nameInput, this));

		nameInput.setText(marker.getDisplayName());
		nameInput.setBorder(null);
		nameInput.setEditable(false);
		nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameInput.setPreferredSize(new Dimension(0, 24));
		nameInput.getTextField().setForeground(Color.WHITE);
		nameInput.getTextField().setBorder(new EmptyBorder(0, 5, 0, 0));
		nameInput.addKeyListener(new NameInputKeyAdapter(this));
		nameInput.getTextField().addMouseListener(new NameInputDoubleClickMouseAdapter(this));

		markerContainer.setBorder(new EmptyBorder(5, 0, 5, 0));
		markerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel leftActionsPrayer = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		leftActionsPrayer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel rightActionsPrayer = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		rightActionsPrayer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel bottomActionsPrayer = new JPanel(new BorderLayout());
		bottomActionsPrayer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		prayerMarkerColor.setToolTipText("edit prayer marker color");
		prayerMarkerColor.setForeground(marker.getOverlayColor() == null ? Color.red : marker.getOverlayColor());
		prayerMarkerColor.addMouseListener(new PrayerMarkerColorMouseAdapter(prayerMarkerColor, this));
		leftActionsPrayer.add(prayerMarkerColor);

		prayerSelection.setSelectedItem(marker.getPrayerInfo().getDisplayName());
		prayerSelection.addActionListener(new PrayerSelectionActionListener(prayerSelection, prayerMap, marker));
		bottomActionsPrayer.add(prayerSelection);

		borderWidth.setValue((double) marker.getBorderWidth());
		borderWidth.addChangeListener(ce -> updateBorderWidth());
		borderWidth.setEditor(new JSpinner.NumberEditor(borderWidth, "0.0"));
		JFormattedTextField borderWidthField = ((JSpinner.NumberEditor) borderWidth.getEditor()).getTextField();
		borderWidthField.addKeyListener(new BorderWidthKeyAdapter(borderWidthField));
		rightActionsPrayer.add(borderWidth);

		expandMarker = new JButton(marker.isCollapsed() ? COLLAPSE_ICON : EXPAND_ICON);
		expandMarker.setRolloverIcon(marker.isCollapsed() ? COLLAPSE_HOVER_ICON : EXPAND_HOVER_ICON);
		expandMarker.setPreferredSize(new Dimension(15, 0));
		expandMarker.setBorder(new EmptyBorder(0, 6, 1, 0));
		expandMarker.setToolTipText((marker.isCollapsed() ? "Expand" : "Collapse") + " marker");
		expandMarker.addActionListener(new ExpandMarkerActionListener(plugin, marker, this));
		SwingUtil.removeButtonDecorations(expandMarker);

		hideMarker.setToolTipText((marker.isVisible() ? "Hide" : "Show") + " marker");
		hideMarker.addMouseListener(new HideMarkerMouseAdapter(hideMarker, marker, this, plugin));

		deleteMarker.setIcon(DELETE_ICON);
		deleteMarker.setToolTipText("Delete marker");
		deleteMarker.addMouseListener(new DeleteMarkerMouseAdapter(deleteMarker, marker, plugin, this));

		nameActions.add(rename);
		nameActions.add(cancel);
		nameActions.add(save);
		nameActions.add(hideMarker);
		nameActions.add(deleteMarker);

		nameWrapper.add(expandMarker, BorderLayout.WEST);
		nameWrapper.add(nameInput, BorderLayout.CENTER);
		nameWrapper.add(nameActions, BorderLayout.EAST);

		JPanel markerWrapper = new JPanel();
		markerWrapper.setLayout(new BoxLayout(markerWrapper, BoxLayout.Y_AXIS));
		markerWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		markerWrapper.add(nameWrapper);
		markerWrapper.add(markerContainer);

		JPanel horizontalRow = new JPanel(new BorderLayout());
		horizontalRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		horizontalRow.add(leftActionsPrayer, BorderLayout.WEST);
		horizontalRow.add(bottomActionsPrayer, BorderLayout.CENTER);
		horizontalRow.add(rightActionsPrayer, BorderLayout.EAST);

		markerContainer.setLayout(new BorderLayout());
		markerContainer.setLayout(new BorderLayout());
		markerContainer.add(horizontalRow, BorderLayout.SOUTH);

		add(markerWrapper);

		updateCollapsed();
		updateVisibility();
		updateColorIndicators();
	}

	public void openColorPickerPrayer()
	{
		Color color = marker.getOverlayColor() == null ? Color.red : marker.getOverlayColor();
		RuneliteColorPicker colourPicker = getColorPicker(color);
		colourPicker.setOnColorChange(c ->
		{
			marker.setOverlayColor(c);
			prayerMarkerColor.setBorder(new MatteBorder(0, 0, 3, 0, marker.getOverlayColor()));
			prayerMarkerColor.setIcon(BORDER_COLOR_ICON);
			updateColorIndicators();
		});
		colourPicker.setVisible(true);
	}

	private RuneliteColorPicker getColorPicker(Color color)
	{
		RuneliteColorPicker colorPicker = plugin.getColourPickerManager().create(
				SwingUtilities.windowForComponent(this),
				color,
				marker.getDisplayName() + " - prayer marker colour",
				false);
		colorPicker.setLocationRelativeTo(this);
		colorPicker.setOnClose(c -> plugin.saveMarkers());
		return colorPicker;
	}

	public void save()
	{
		marker.setDisplayName(nameInput.getText());
		plugin.saveMarkers();

		nameInput.setEditable(false);
		updateNameActions(false);
		requestFocusInWindow();
	}

	public void cancel()
	{
		nameInput.setEditable(false);
		nameInput.setText(marker.getDisplayName());
		updateNameActions(false);
		requestFocusInWindow();
	}
	private void updateBorderWidth()
	{
		float value = ((Number) borderWidth.getValue()).floatValue();
		marker.setBorderWidth(value);
		plugin.saveMarkers();
	}

private void updateColorIndicators()
	{
		prayerMarkerColor.setBorder(new MatteBorder(0, 0, 3, 0, marker.getOverlayColor()));
		prayerMarkerColor.setIcon(BORDER_COLOR_ICON);
	}

	public void updateVisibility()
	{
		hideMarker.setIcon(marker.isVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
	}

	public void updateCollapsed()
	{
		final boolean open = !marker.isCollapsed();
		rename.setVisible(open);
		markerContainer.setVisible(open);
		expandMarker.setIcon(open ? COLLAPSE_ICON : EXPAND_ICON);
		expandMarker.setRolloverIcon(open ? COLLAPSE_HOVER_ICON : EXPAND_HOVER_ICON);
		expandMarker.setToolTipText((open ? "Collapse" : "Expand") + " marker");
	}

	public void updateNameActions(boolean saveAndCancel)
	{
		save.setVisible(saveAndCancel);
		cancel.setVisible(saveAndCancel);
		rename.setVisible(!saveAndCancel);
		expandMarker.setVisible(!saveAndCancel);
		hideMarker.setVisible(!saveAndCancel);
		deleteMarker.setVisible(!saveAndCancel);

		if (saveAndCancel)
		{
			nameInput.getTextField().requestFocusInWindow();
			nameInput.getTextField().selectAll();

			String newName = nameInput.getText();
			if (newName != null && !newName.trim().isEmpty())
			{
				marker.setDisplayName(newName.trim());
			}
		}
	}
}

package com.coopermor.prayermarkers.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;

import com.coopermor.prayermarkers.PrayerMarker;
import com.coopermor.prayermarkers.PrayerMarkersPlugin;
import com.coopermor.prayermarkers.ui.adapters.AddMarkerMouseAdapter;
import com.coopermor.prayermarkers.ui.PrayerMarkersPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;


import java.awt.image.BufferedImage;
import java.util.Collection;

public class PrayerMarkersPluginPanel extends PluginPanel
{
	private static final ImageIcon ADD_ICON;
	private final PluginErrorPanel errorPanel = new PluginErrorPanel();
	public final PrayerMarkersPlugin plugin;
	private final JPanel markerView = new JPanel();

	static
	{
		final BufferedImage addIcon = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "add_icon.png");
		ADD_ICON = new ImageIcon(addIcon);
	}

	public PrayerMarkersPluginPanel(PrayerMarkersPlugin plugin)
	{
		this.plugin = plugin;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));
		setupErrorPanel(true);

		// title panel
		JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));

		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBorder(new EmptyBorder(1, 3, 10, 7));

		JLabel title = new JLabel("Prayer Markers");
		title.setForeground(Color.WHITE);

		JLabel markerAdd = new JLabel(ADD_ICON);
		markerAdd.setToolTipText("Add new prayer marker");
		markerAdd.addMouseListener(new AddMarkerMouseAdapter(markerAdd, plugin, this::addMarker));

		JPanel markerButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT, 7, 3));
		markerButtons.add(markerAdd);

		titlePanel.add(title, BorderLayout.WEST);
		titlePanel.add(markerButtons, BorderLayout.EAST);
		northPanel.add(titlePanel, BorderLayout.NORTH);

		// marker view panels, these are dynamically added in rebuild()
		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		markerView.setLayout(new BoxLayout(markerView, BoxLayout.Y_AXIS));
		markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);
		markerView.add(errorPanel);

		centerPanel.add(markerView, BorderLayout.NORTH);

		// setup panels border layout
		add(northPanel, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);
	}

	public void rebuild()
	{
		markerView.removeAll();
		Collection<PrayerMarker> markers = plugin.getMarkers();
		assert markers != null : "call to plugin.getMarkers() = null";
		for (PrayerMarker marker : markers)
		{
			markerView.add(new PrayerMarkersPanel(plugin, marker));
			markerView.add(Box.createRigidArea(new Dimension(0, 10)));
		}
		if (markers.isEmpty())
		{
			setupErrorPanel(true);
		}
		repaint();
		revalidate();
	}

	private void addMarker()
	{
		setupErrorPanel(false);
	}

	private void setupErrorPanel(boolean enabled)
	{
		PluginErrorPanel errorPanel = this.errorPanel;
		assert errorPanel != null : "prayerMarkerErrorPanel = null";
		errorPanel.setVisible(enabled);
		if (enabled)
		{
			errorPanel.setContent("Prayer Markers", "Click the '+' button to add a prayer marker to the prayer tab.");
			markerView.removeAll();
			markerView.setLayout(new BoxLayout(markerView, BoxLayout.Y_AXIS));
			markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);
			markerView.add(errorPanel);
		}
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import javax.swing.JFormattedTextField;

public class BorderWidthKeyAdapter extends KeyAdapter
{
	private final JFormattedTextField field;

	public BorderWidthKeyAdapter(JFormattedTextField field)
	{
		this.field = field;
	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		switch (e.getKeyCode())
		{
			case KeyEvent.VK_ENTER:
			case KeyEvent.VK_ESCAPE:
				field.transferFocus();
				break;
		}
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import com.coopermor.prayermarkers.PrayerInfo;
import com.coopermor.prayermarkers.PrayerMarkersPlugin;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class AddMarkerMouseAdapter extends MouseAdapter
{
	private static final BufferedImage addIcon = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "add_icon.png");
	private static final ImageIcon ADD_ICON = new ImageIcon(addIcon);
	private static final ImageIcon ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));
	private final PrayerMarkersPlugin plugin;
	private final JLabel markerAdd;
	private final Runnable onClick;

	public AddMarkerMouseAdapter(JLabel markerAdd, PrayerMarkersPlugin plugin, Runnable onClick)
	{
		this.markerAdd = markerAdd;
		this.plugin = plugin;
		this.onClick = onClick;
	}

	@Override
	public void mousePressed(MouseEvent e)
	{
		// Default Prayer Marker Data
		PrayerInfo selectedPrayer = PrayerInfo.STEEL_SKIN;
		String name = "Marker";
		Color color = Color.WHITE;
		boolean enabled = true;
		float borderWidth = 1.0F;
		plugin.addMarker(selectedPrayer, enabled, name, color, borderWidth);
		onClick.run();
	}

	@Override
	public void mouseEntered(MouseEvent e)
	{
		markerAdd.setIcon(ADD_HOVER_ICON);
	}

	@Override
	public void mouseExited(MouseEvent e)
	{
		markerAdd.setIcon(ADD_ICON);
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import com.coopermor.prayermarkers.PrayerMarker;
import com.coopermor.prayermarkers.PrayerMarkersPlugin;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import java.awt.Component;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import net.runelite.client.util.ImageUtil;

public class DeleteMarkerMouseAdapter extends MouseAdapter
{
	private final JLabel deleteMarker;
	private final PrayerMarker marker;
	private final PrayerMarkersPlugin plugin;
	private final Component parentComponent;
	private static final ImageIcon DELETE_ICON, DELETE_HOVER_ICON;

	static
	{
		final BufferedImage deleteImg = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "delete_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));
	}

	public DeleteMarkerMouseAdapter(JLabel deleteMarker, PrayerMarker marker, PrayerMarkersPlugin plugin, Component parentComponent)
	{
		this.deleteMarker = deleteMarker;
		this.marker = marker;
		this.plugin = plugin;
		this.parentComponent = parentComponent;
	}

	@Override
	public void mousePressed(MouseEvent mouseEvent)
	{
		int confirm = JOptionPane.showConfirmDialog(
				parentComponent,
				"Are you sure you want to permanently delete this prayer marker?",
				"Warning",
				JOptionPane.OK_CANCEL_OPTION
		);

		if (confirm == JOptionPane.OK_OPTION)
		{
			plugin.removeMarker(marker);
		}
	}

	@Override
	public void mouseEntered(MouseEvent mouseEvent)
	{
		deleteMarker.setIcon(DELETE_HOVER_ICON);
	}

	@Override
	public void mouseExited(MouseEvent mouseEvent)
	{
		deleteMarker.setIcon(DELETE_ICON);
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import net.runelite.client.ui.ColorScheme;

import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class CancelMouseAdapter extends MouseAdapter
{
	private final JLabel cancelLabel;
	private final Runnable onCancel;

	public CancelMouseAdapter(JLabel cancelLabel, Runnable onCancel)
	{
		this.cancelLabel = cancelLabel;
		this.onCancel = onCancel;
	}

	@Override
	public void mousePressed(MouseEvent mouseEvent)
	{
		onCancel.run();
	}

	@Override
	public void mouseEntered(MouseEvent mouseEvent)
	{
		cancelLabel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
	}

	@Override
	public void mouseExited(MouseEvent mouseEvent)
	{
		cancelLabel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import com.coopermor.prayermarkers.ui.PrayerMarkersPanel;

public class NameInputDoubleClickMouseAdapter extends MouseAdapter
{
	private final PrayerMarkersPanel panel;

	public NameInputDoubleClickMouseAdapter(PrayerMarkersPanel panel)
	{
		this.panel = panel;
	}

	@Override
	public void mouseClicked(MouseEvent e)
	{
		if (e.getClickCount() == 2 && e.getButton() == MouseEvent.BUTTON1)
		{
			panel.updateCollapsed();
			panel.plugin.saveMarkers();
		}
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import com.coopermor.prayermarkers.PrayerMarker;
import com.coopermor.prayermarkers.ui.PrayerMarkersPanel;
import com.coopermor.prayermarkers.PrayerMarkersPlugin;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import net.runelite.client.util.ImageUtil;

public class HideMarkerMouseAdapter extends MouseAdapter
{
	private final JLabel hideMarker;
	private final PrayerMarker marker;
	private final PrayerMarkersPanel panel;
	private final PrayerMarkersPlugin plugin;
	private static final ImageIcon VISIBLE_HOVER_ICON;
	private static final ImageIcon INVISIBLE_HOVER_ICON;

	static
	{
		final BufferedImage visibleImg = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "visible_icon.png");
		VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

		final BufferedImage invisibleImg = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "invisible_icon.png");
		INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));
	}

	public HideMarkerMouseAdapter(JLabel hideMarker, PrayerMarker marker, PrayerMarkersPanel panel, PrayerMarkersPlugin plugin)
	{
		this.hideMarker = hideMarker;
		this.marker = marker;
		this.panel = panel;
		this.plugin = plugin;
	}

	@Override
	public void mousePressed(MouseEvent mouseEvent)
	{
		marker.setVisible(!marker.isVisible());
		panel.updateVisibility();
		plugin.saveMarkers();
	}

	@Override
	public void mouseEntered(MouseEvent mouseEvent)
	{
		hideMarker.setIcon(marker.isVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
	}

	@Override
	public void mouseExited(MouseEvent mouseEvent)
	{
		panel.updateVisibility();
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

import com.coopermor.prayermarkers.ui.PrayerMarkersPanel;

public class NameInputKeyAdapter extends KeyAdapter
{
	private final PrayerMarkersPanel panel;

	public NameInputKeyAdapter(PrayerMarkersPanel panel)
	{
		this.panel = panel;
	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		if (e.getKeyCode() == KeyEvent.VK_ENTER)
		{
			panel.save();
		}
		else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
		{
			panel.cancel();
		}
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import net.runelite.client.ui.ColorScheme;

import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class SaveMouseAdapter extends MouseAdapter
{
	private final JLabel saveLabel;
	private final Runnable onSave;

	public SaveMouseAdapter(JLabel saveLabel, Runnable onSave)
	{
		this.saveLabel = saveLabel;
		this.onSave = onSave;
	}

	@Override
	public void mousePressed(MouseEvent mouseEvent)
	{
		onSave.run();
	}

	@Override
	public void mouseEntered(MouseEvent mouseEvent)
	{
		saveLabel.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
	}

	@Override
	public void mouseExited(MouseEvent mouseEvent)
	{
		saveLabel.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
	}
}

package com.coopermor.prayermarkers.ui.adapters;

import com.coopermor.prayermarkers.ui.PrayerMarkersPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;

import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class RenameMouseAdapter extends MouseAdapter
{
private final JLabel renameLabel;
private final FlatTextField nameInput;
private final PrayerMarkersPanel panel;

	public RenameMouseAdapter(JLabel renameLabel, FlatTextField nameInput, PrayerMarkersPanel panel)
	{
		this.renameLabel = renameLabel;
		this.nameInput = nameInput;
		this.panel = panel;
	}

	@Override
	public void mousePressed(MouseEvent mouseEvent)
	{
		nameInput.setEditable(true);
		panel.updateNameActions(true);
	}

	@Override
	public void mouseEntered(MouseEvent mouseEvent)
	{
		renameLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
	}

	@Override
	public void mouseExited(MouseEvent mouseEvent)
	{
		renameLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
	}
}



package com.coopermor.prayermarkers.ui.adapters;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import com.coopermor.prayermarkers.ui.PrayerMarkersPanel;
import com.coopermor.prayermarkers.PrayerMarkersPlugin;
import net.runelite.client.util.ImageUtil;

public class PrayerMarkerColorMouseAdapter extends MouseAdapter
{
	private final JLabel prayerMarkerColorLabel;
	private final PrayerMarkersPanel panel;
	private static final ImageIcon BORDER_COLOR_ICON;
	private static final ImageIcon BORDER_COLOR_HOVER_ICON;

	static
	{
		BufferedImage borderImg = ImageUtil.loadImageResource(PrayerMarkersPlugin.class, "border_color_icon.png");
		BufferedImage borderImgHover = ImageUtil.luminanceOffset(borderImg, -150);

		BORDER_COLOR_ICON = new ImageIcon(borderImg);
		BORDER_COLOR_HOVER_ICON = new ImageIcon(borderImgHover);
	}
	public PrayerMarkerColorMouseAdapter(JLabel prayerMarkerColorLabel, PrayerMarkersPanel panel)
	{
		this.prayerMarkerColorLabel = prayerMarkerColorLabel;
		this.panel = panel;
	}

	@Override
	public void mousePressed(MouseEvent mouseEvent)
	{
		panel.openColorPickerPrayer();
	}

	@Override
	public void mouseEntered(MouseEvent mouseEvent)
	{
		prayerMarkerColorLabel.setIcon(BORDER_COLOR_HOVER_ICON);
	}

	@Override
	public void mouseExited(MouseEvent mouseEvent)
	{
		prayerMarkerColorLabel.setIcon(BORDER_COLOR_ICON);
	}
}

package com.coopermor.prayermarkers;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;

import static com.coopermor.prayermarkers.Overlay.renderPrayerOverlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

class PrayerMarkersOverlay extends Overlay
{
	private final Client client;
	private final PrayerMarkersPlugin plugin;

	@Inject
	private PrayerMarkersOverlay(Client client, PrayerMarkersPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(Overlay.PRIORITY_HIGHEST);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		for (PrayerMarker marker : plugin.getMarkers())
		{
			if (!marker.isEnabled() || !marker.isVisible())
			{
				continue;
			}
			PrayerInfo info = marker.getPrayerInfo();
			PrayerInfo prayerInfo = PrayerInfo.valueOf(info.name());
			Color color = marker.getOverlayColor();
			float strokeThickness = marker.getBorderWidth();

			renderPrayerOverlay(graphics, client, prayerInfo, color, strokeThickness);
		}
		return null;
	}
}

package com.coopermor.prayermarkers;

public class PrayerMarkersDelegate
{
	public static boolean clientDeveloperMode;
}
package com.coopermor.prayermarkers;

import com.coopermor.prayermarkers.ui.PrayerMarkersPluginPanel;
import com.google.common.base.Strings;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.inject.Provides;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import javax.inject.Inject;
import javax.swing.JOptionPane;

import lombok.AccessLevel;
import lombok.extern.slf4j.Slf4j;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(
	name = "Prayer Markers"
)
public class PrayerMarkersPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "prayermarkers";
	private static final String CONFIG_KEY = "markers";
	private static final String PLUGIN_NAME = "Prayer Markers";
	private static final String ICON_FILE = "panel_icon.png";

	@Getter(AccessLevel.PUBLIC)
	Collection<PrayerMarker> markers = new ArrayList<>();

	@Inject
	private Client client;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ConfigManager configManager;

	@Inject
	private PrayerMarkersOverlay prayerMarkersOverlay;

	@Inject
	private Gson gson;

	@Getter
	@Inject
	private ColorPickerManager colourPickerManager;

	private PrayerMarkersPluginPanel pluginPanel;
	private NavigationButton navigationButton;

	@Override
	protected void startUp() throws Exception
	{
		pluginPanel = new PrayerMarkersPluginPanel(this);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);

		navigationButton = NavigationButton.builder()
			.tooltip(PLUGIN_NAME)
			.icon(icon)
			.priority(5)
			.panel(pluginPanel)
			.build();

		clientToolbar.addNavigation(navigationButton);

		overlayManager.add(prayerMarkersOverlay);

		if (PrayerMarkersDelegate.clientDeveloperMode)
		{
			setupDebugMarkers();
		}
		else
		{
			loadMarkers();
		}
		pluginPanel.rebuild();
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navigationButton);
		pluginPanel = null;
		navigationButton = null;
		overlayManager.remove(prayerMarkersOverlay);
	}

	public PrayerMarker addMarker(PrayerInfo prayerInfo, boolean enabled, String name, Color color, float borderWidth)
	{
		final PrayerMarker newMarker = new PrayerMarker(prayerInfo, name, color, borderWidth);
		assert markers != null : "ArrayList<PrayerMarker> markers = null";
		if (!markers.contains(newMarker))
		{
			markers.add(newMarker);
			saveMarkers();
			pluginPanel.rebuild();
		}
		return newMarker;
	}
	public void removeMarker(PrayerMarker prayerMarker)
	{
		int before = markers.size();
		markers.remove(prayerMarker);
		saveMarkers();
		loadMarkers();
		int after = markers.size();
		assert before - 1 == after : "Expected marker count to decrease by 1. Before: " + before + ", After: " + after;
		saveMarkers();
		pluginPanel.rebuild();
	}
	private void loadMarkers()
	{
		markers.clear();
		Collection<PrayerMarker> savedMarkers = getPrayerMarkers();
		assert savedMarkers != null : "getPrayerMarkers() = null";
		markers.addAll(savedMarkers);
	}

	private Collection<PrayerMarker> getPrayerMarkers()
	{
		String json = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY);

		if (Strings.isNullOrEmpty(json))
		{
			return Collections.emptyList();
		}

		try
		{
			//CHECKSTYLE:OFF
			List<PrayerMarker> fromConfig = gson.fromJson(json, new TypeToken<List<PrayerMarker>>(){}.getType());
			//CHECKSTYLE:ON
			fromConfig.removeIf(PrayerMarker::isInvalid);
			return fromConfig;
		}
		catch (IllegalStateException | JsonSyntaxException ignore)
		{
			JOptionPane.showConfirmDialog(pluginPanel,
				"The prayer markers configuration is invalid.",
				"Warning", JOptionPane.OK_CANCEL_OPTION);
			return null;
		}
	}

	public void saveMarkers()
	{
		if (markers == null || markers.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY);
			return;
		}
		String json = gson.toJson(markers);
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY, json);
	}

	@Provides
	PrayerMarkersConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PrayerMarkersConfig.class);
	}

	private void setupDebugMarkers()
	{
		PrayerMarker testMarker = new PrayerMarker(
				PrayerInfo.SMITE,
				"Marker 1",
				Color.RED,
				3.0F
		);

		markers.add(testMarker);
	}
}

package com.coopermor.prayermarkers;

public enum WidgetInfo
{
	PRAYER_THICK_SKIN(WidgetID.PRAYER_ID, WidgetID.Prayer.THICK_SKIN),
	PRAYER_BURST_OF_STRENGTH(WidgetID.PRAYER_ID, WidgetID.Prayer.BURST_OF_STRENGTH),
	PRAYER_CLARITY_OF_THOUGHT(WidgetID.PRAYER_ID, WidgetID.Prayer.CLARITY_OF_THOUGHT),
	PRAYER_SHARP_EYE(WidgetID.PRAYER_ID, WidgetID.Prayer.SHARP_EYE),
	PRAYER_MYSTIC_WILL(WidgetID.PRAYER_ID, WidgetID.Prayer.MYSTIC_WILL),
	PRAYER_ROCK_SKIN(WidgetID.PRAYER_ID, WidgetID.Prayer.ROCK_SKIN),
	PRAYER_SUPERHUMAN_STRENGTH(WidgetID.PRAYER_ID, WidgetID.Prayer.SUPERHUMAN_STRENGTH),
	PRAYER_IMPROVED_REFLEXES(WidgetID.PRAYER_ID, WidgetID.Prayer.IMPROVED_REFLEXES),
	PRAYER_RAPID_RESTORE(WidgetID.PRAYER_ID, WidgetID.Prayer.RAPID_RESTORE),
	PRAYER_RAPID_HEAL(WidgetID.PRAYER_ID, WidgetID.Prayer.RAPID_HEAL),
	PRAYER_PROTECT_ITEM(WidgetID.PRAYER_ID, WidgetID.Prayer.PROTECT_ITEM),
	PRAYER_HAWK_EYE(WidgetID.PRAYER_ID, WidgetID.Prayer.HAWK_EYE),
	PRAYER_MYSTIC_LORE(WidgetID.PRAYER_ID, WidgetID.Prayer.MYSTIC_LORE),
	PRAYER_STEEL_SKIN(WidgetID.PRAYER_ID, WidgetID.Prayer.STEEL_SKIN),
	PRAYER_ULTIMATE_STRENGTH(WidgetID.PRAYER_ID, WidgetID.Prayer.ULTIMATE_STRENGTH),
	PRAYER_INCREDIBLE_REFLEXES(WidgetID.PRAYER_ID, WidgetID.Prayer.INCREDIBLE_REFLEXES),
	PRAYER_PROTECT_FROM_MAGIC(WidgetID.PRAYER_ID, WidgetID.Prayer.PROTECT_FROM_MAGIC),
	PRAYER_PROTECT_FROM_MISSILES(WidgetID.PRAYER_ID, WidgetID.Prayer.PROTECT_FROM_MISSILES),
	PRAYER_PROTECT_FROM_MELEE(WidgetID.PRAYER_ID, WidgetID.Prayer.PROTECT_FROM_MELEE),
	PRAYER_EAGLE_EYE(WidgetID.PRAYER_ID, WidgetID.Prayer.EAGLE_EYE),
	PRAYER_MYSTIC_MIGHT(WidgetID.PRAYER_ID, WidgetID.Prayer.MYSTIC_MIGHT),
	PRAYER_RETRIBUTION(WidgetID.PRAYER_ID, WidgetID.Prayer.RETRIBUTION),
	PRAYER_REDEMPTION(WidgetID.PRAYER_ID, WidgetID.Prayer.REDEMPTION),
	PRAYER_SMITE(WidgetID.PRAYER_ID, WidgetID.Prayer.SMITE),
	PRAYER_PRESERVE(WidgetID.PRAYER_ID, WidgetID.Prayer.PRESERVE),
	PRAYER_CHIVALRY(WidgetID.PRAYER_ID, WidgetID.Prayer.CHIVALRY),
	PRAYER_PIETY(WidgetID.PRAYER_ID, WidgetID.Prayer.PIETY),
	PRAYER_RIGOUR(WidgetID.PRAYER_ID, WidgetID.Prayer.RIGOUR),
	PRAYER_AUGURY(WidgetID.PRAYER_ID, WidgetID.Prayer.AUGURY);

	private final int groupId;
	private final int childId;

	WidgetInfo(int groupId, int childId)
	{
		this.groupId = groupId;
		this.childId = childId;
	}

	public int getId()
	{
		return groupId << 16 | childId;
	}
}

package com.coopermor.prayermarkers;

import java.awt.Color;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public
class PrayerMarker
{
	PrayerInfo prayerInfo;
	String displayName;
	Color overlayColor;
	boolean enabled;
	boolean visible;
	boolean collapsed;
	float borderWidth;

	public PrayerMarker(PrayerInfo prayerInfo, String displayName, Color overlayColor, float borderWidth)
	{
		this.prayerInfo = prayerInfo;
		this.displayName = displayName;
		this.overlayColor = overlayColor;
		this.enabled = true;
		this.visible = true;
		this.collapsed = false;
		this.borderWidth = borderWidth;
	}

	public static boolean isInvalid(PrayerMarker marker)
	{
		return marker == null
		|| marker.prayerInfo == null
		|| marker.displayName == null
		|| marker.overlayColor == null
		|| marker.borderWidth <= 0.0005;
	}
}

package com.coopermor.prayermarkers;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;


public class PrayerMarkersPluginTest {
	public static void main(String[] args) throws Exception {

		OptionParser parser = new OptionParser();
		parser.accepts("developer-mode");
		OptionSet options = parser.parse(args);
		if (options.has("developer-mode")) {
			PrayerMarkersDelegate.clientDeveloperMode = true;
		}

		ExternalPluginManager.loadBuiltin(PrayerMarkersPlugin.class);
		RuneLite.main(args);
	}
}
