package com.escapecrystalnotify;

import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;

public class EscapeCrystalNotifyOverlayActive extends Overlay {
    private static final EscapeCrystalImage previouslyGeneratedImage = new EscapeCrystalImage();
    private static BufferedImage escapeCrystalImage;
    private final EscapeCrystalNotifyPlugin plugin;
    private final EscapeCrystalNotifyConfig config;

    @Inject
    EscapeCrystalNotifyOverlayActive(EscapeCrystalNotifyPlugin plugin, EscapeCrystalNotifyConfig config) throws PluginInstantiationException {
        super(plugin);
        setPriority(OverlayPriority.MED);
        setPosition(OverlayPosition.BOTTOM_LEFT);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);

        this.plugin = plugin;
        this.config = config;

        escapeCrystalImage = loadEscapeCrystalImage();

        initializePreviouslyGeneratedImage();
    }

    private static BufferedImage loadEscapeCrystalImage() {
        return ImageUtil.loadImageResource(EscapeCrystalNotifyPlugin.class, "/escape-crystal-active.png");
    }

    private void initializePreviouslyGeneratedImage() {
        previouslyGeneratedImage.scale = -1;
        previouslyGeneratedImage.generatedImage = escapeCrystalImage;
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        boolean enabled = config.enableOnScreenWidget();
        boolean active = plugin.isEscapeCrystalInactivityTeleportActive();
        boolean notHardcore = config.requireHardcoreAccountType() && !plugin.isHardcoreAccountType();
        boolean inactiveOnly = config.onlyDisplayInactiveOnScreenWidget();

        boolean atNotifyRegion;

        if (this.plugin.isAtNotifyRegionId()) {
            atNotifyRegion = true;
        } else {
            atNotifyRegion = this.config.alwaysDisplayOnScreenWidget();
        }

        if (!enabled || notHardcore || !atNotifyRegion || !active || inactiveOnly) {
            return null;
        }

        BufferedImage generatedEscapeCrystalImage = generateEscapeCrystalImage();
        ImageComponent imagePanelComponent = new ImageComponent(generatedEscapeCrystalImage);
        return imagePanelComponent.render(graphics);
    }

    private BufferedImage generateEscapeCrystalImage() {
        double targetScale = Math.max(config.activeCrystalWidgetScale(), 1);

        boolean escapeCrystalImageScaleChanged = previouslyGeneratedImage.scale != targetScale;
        boolean escapeCrystalLeftClickTeleportEnabledChanged = previouslyGeneratedImage.escapeCrystalLeftClickTeleportEnabled != plugin.isEscapeCrystalLeftClickTeleportEnabled();
        boolean escapeCrystalInactivityTicksChanged = previouslyGeneratedImage.escapeCrystalInactivityTicks != plugin.getEscapeCrystalInactivityTicks();
        boolean expectedServerInactivityTicksChanged = previouslyGeneratedImage.expectedServerInactivityTicks != plugin.getExpectedServerInactivityTicks();

        if (!escapeCrystalInactivityTicksChanged && !expectedServerInactivityTicksChanged && !escapeCrystalImageScaleChanged && !escapeCrystalLeftClickTeleportEnabledChanged) {
            return previouslyGeneratedImage.generatedImage;
        }

        BufferedImage scaledEscapeCrystalImage;
        if (!escapeCrystalImageScaleChanged) {
            scaledEscapeCrystalImage = previouslyGeneratedImage.scaledBaseImage;
        } else {
            scaledEscapeCrystalImage = scaleImage(escapeCrystalImage, targetScale / 5);
        }

        String overlayText = determineActiveEscapeCrystalOverlayText();
        boolean displayLeftClickWarning = !plugin.isEscapeCrystalLeftClickTeleportEnabled() && config.displayDisabledLeftClickTeleportText();
        BufferedImage generatedEscapeCrystalImage = drawInfoTextOnImage(scaledEscapeCrystalImage, targetScale, overlayText, displayLeftClickWarning);

        previouslyGeneratedImage.scaledBaseImage = scaledEscapeCrystalImage;
        previouslyGeneratedImage.generatedImage = generatedEscapeCrystalImage;
        previouslyGeneratedImage.scale = targetScale;
        previouslyGeneratedImage.escapeCrystalLeftClickTeleportEnabled = plugin.isEscapeCrystalLeftClickTeleportEnabled();
        previouslyGeneratedImage.escapeCrystalInactivityTicks = plugin.getEscapeCrystalInactivityTicks();
        previouslyGeneratedImage.expectedServerInactivityTicks = plugin.getExpectedServerInactivityTicks();

        return generatedEscapeCrystalImage;
    }

    private BufferedImage scaleImage(BufferedImage image, double scale) {
        BufferedImage scaledImage = new BufferedImage(
                (int) (scale * image.getWidth()),
                (int) (scale * image.getHeight()),
                BufferedImage.TYPE_INT_ARGB
        );

        AffineTransform at = new AffineTransform();
        at.scale(scale, scale);
        AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
        scaledImage = scaleOp.filter(image, scaledImage);

        return scaledImage;
    }

    private String determineActiveEscapeCrystalOverlayText() {
        return plugin.getItemModelDisplayText(config.onScreenWidgetDisplayFormat(), config.onScreenWidgetInactivityTimeFormat(), config.onScreenWidgetTimeExpiredText());
    }

    private BufferedImage drawInfoTextOnImage(BufferedImage image, double scale, String overlayText, boolean addLeftClickWarning) {
        BufferedImage imageWithInfoText = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());

        Graphics g = imageWithInfoText.getGraphics();
        g.drawImage(image, 0, 0, null);

        int fontSize;
        if (overlayText.length() >= 4) {
            fontSize = 5;
        } else {
            fontSize = 6;
        }

        Font font = new Font("Arial", Font.BOLD, fontSize * (int) Math.ceil(scale));

        g.setFont(font);
        g.setColor(Color.BLACK);
        drawTextLowerFourth(g, font, overlayText, imageWithInfoText.getWidth() + 1, imageWithInfoText.getHeight() + 1);

        g.setColor(plugin.getItemModelDisplayTextColor(config.onScreenWidgetDisplayFormat()));

        drawTextLowerFourth(g, font, overlayText, imageWithInfoText.getWidth() - 1, imageWithInfoText.getHeight() - 1);

        if (addLeftClickWarning){
            Font warningMessageFont = new Font("Arial", Font.BOLD, (int) (2.5 * Math.ceil(scale)));
            g.setFont(warningMessageFont);
            g.setColor(Color.RED);
            FontMetrics metrics = g.getFontMetrics(warningMessageFont);
            drawTextBottomMiddle(g, warningMessageFont, "NO LEFT", imageWithInfoText.getWidth(), imageWithInfoText.getHeight() - metrics.getHeight());
            drawTextBottomMiddle(g, warningMessageFont, "CLICK", imageWithInfoText.getWidth(), imageWithInfoText.getHeight());
        }

        g.dispose();

        return imageWithInfoText;
    }

    private void drawTextLowerFourth(Graphics g, Font font, String text, int x, int y) {
        FontMetrics metrics = g.getFontMetrics(font);

        int textWidth = metrics.stringWidth(text);
        int textAscent = metrics.getAscent();
        int textDescent = metrics.getDescent();

        int xDrawLocation = (x - textWidth) / 2;
        int yDrawLocation = y - (textAscent + (y - (textAscent + textDescent)) / 4);

        g.drawString(text, xDrawLocation, yDrawLocation);
    }

    private void drawTextBottomMiddle(Graphics g, Font font, String text, int x, int y) {
        FontMetrics metrics = g.getFontMetrics(font);
        int textWidth = metrics.stringWidth(text);
        int xDrawLocation = (x - textWidth) / 2;
        g.drawString(text, xDrawLocation, y);
    }

    private static class EscapeCrystalImage {
        private double scale;
        private BufferedImage scaledBaseImage;
        private BufferedImage generatedImage;
        private boolean escapeCrystalLeftClickTeleportEnabled;
        private int escapeCrystalInactivityTicks;
        private int expectedServerInactivityTicks;


    }
}

package com.escapecrystalnotify;

import lombok.Getter;

import java.util.List;

@Getter
public class EscapeCrystalNotifyRegionEntrance {
    public EscapeCrystalNotifyRegionEntranceOverlayType overlayType;
    public List<Integer> chunkIds;
    public EscapeCrystalNotifyRegionEntranceDirection entranceDirection;
    public int[] entranceIds;
    public EscapeCrystalNotifyRegionEntrancePlaneLevel planeLevel;
    public boolean escapeCrystalDisabled;
    public EscapeCrystalNotifyRegionEntranceObjectType objectType;

    EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType overlayType, List<Integer> chunkIds, EscapeCrystalNotifyRegionEntranceObjectType objectType, int...entranceIds) {
        this.overlayType = overlayType;
        this.chunkIds = chunkIds;
        this.entranceDirection = null;
        this.entranceIds = entranceIds;
        this.planeLevel = EscapeCrystalNotifyRegionEntrancePlaneLevel.ANY;
        this.escapeCrystalDisabled = false;
        this.objectType = objectType;
    }

    EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType overlayType, EscapeCrystalNotifyRegionEntranceDirection entranceDirection, List<Integer> chunkIds, EscapeCrystalNotifyRegionEntranceObjectType objectType, int...entranceIds) {
        this.overlayType = overlayType;
        this.chunkIds = chunkIds;
        this.entranceDirection = entranceDirection;
        this.entranceIds = entranceIds;
        this.planeLevel = EscapeCrystalNotifyRegionEntrancePlaneLevel.ANY;
        this.escapeCrystalDisabled = false;
        this.objectType = objectType;
    }

    EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType overlayType, List<Integer> chunkIds, EscapeCrystalNotifyRegionEntrancePlaneLevel planeLevel, EscapeCrystalNotifyRegionEntranceObjectType objectType, int...entranceIds) {
        this.overlayType = overlayType;
        this.chunkIds = chunkIds;
        this.entranceDirection = null;
        this.entranceIds = entranceIds;
        this.planeLevel = planeLevel;
        this.escapeCrystalDisabled = false;
        this.objectType = objectType;
    }

    EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType overlayType, EscapeCrystalNotifyRegionEntranceDirection entranceDirection, List<Integer> chunkIds, EscapeCrystalNotifyRegionEntrancePlaneLevel planeLevel, EscapeCrystalNotifyRegionEntranceObjectType objectType, int...entranceIds) {
        this.overlayType = overlayType;
        this.chunkIds = chunkIds;
        this.entranceDirection = entranceDirection;
        this.entranceIds = entranceIds;
        this.planeLevel = planeLevel;
        this.escapeCrystalDisabled = false;
        this.objectType = objectType;
    }

    EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType overlayType, List<Integer> chunkIds, boolean escapeCrystalDisabled, EscapeCrystalNotifyRegionEntranceObjectType objectType, int...entranceIds) {
        this.overlayType = overlayType;
        this.chunkIds = chunkIds;
        this.entranceDirection = null;
        this.entranceIds = entranceIds;
        this.planeLevel = EscapeCrystalNotifyRegionEntrancePlaneLevel.ANY;
        this.escapeCrystalDisabled = escapeCrystalDisabled;
        this.objectType = objectType;
    }

    EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType overlayType, EscapeCrystalNotifyRegionEntranceDirection entranceDirection, List<Integer> chunkIds, boolean escapeCrystalDisabled, EscapeCrystalNotifyRegionEntranceObjectType objectType, int...entranceIds) {
        this.overlayType = overlayType;
        this.chunkIds = chunkIds;
        this.entranceDirection = entranceDirection;
        this.entranceIds = entranceIds;
        this.planeLevel = EscapeCrystalNotifyRegionEntrancePlaneLevel.ANY;
        this.escapeCrystalDisabled = escapeCrystalDisabled;
        this.objectType = objectType;
    }

    EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType overlayType, List<Integer> chunkIds, EscapeCrystalNotifyRegionEntrancePlaneLevel planeLevel, boolean escapeCrystalDisabled, EscapeCrystalNotifyRegionEntranceObjectType objectType, int...entranceIds) {
        this.overlayType = overlayType;
        this.chunkIds = chunkIds;
        this.entranceDirection = null;
        this.entranceIds = entranceIds;
        this.planeLevel = planeLevel;
        this.escapeCrystalDisabled = escapeCrystalDisabled;
        this.objectType = objectType;
    }

    EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType overlayType, EscapeCrystalNotifyRegionEntranceDirection entranceDirection, List<Integer> chunkIds, EscapeCrystalNotifyRegionEntrancePlaneLevel planeLevel, boolean escapeCrystalDisabled, EscapeCrystalNotifyRegionEntranceObjectType objectType, int...entranceIds) {
        this.overlayType = overlayType;
        this.chunkIds = chunkIds;
        this.entranceDirection = entranceDirection;
        this.entranceIds = entranceIds;
        this.planeLevel = planeLevel;
        this.escapeCrystalDisabled = escapeCrystalDisabled;
        this.objectType = objectType;
    }
}

package com.escapecrystalnotify;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class EscapeCrystalNotifyLocatedEntrance {
    public EscapeCrystalNotifyRegionEntranceObject target;
    public EscapeCrystalNotifyRegionEntrance definition;
    public WorldPoint initialWorldPoint;
    public int initialTargetId;


    EscapeCrystalNotifyLocatedEntrance(EscapeCrystalNotifyRegionEntranceObject target, EscapeCrystalNotifyRegionEntrance definition, WorldPoint initialWorldPoint, int initialTargetId) {
        this.target = target;
        this.definition = definition;
        this.initialWorldPoint = initialWorldPoint;
        this.initialTargetId = initialTargetId;
    }

    public boolean hasMoved() {
        return computeChunkIdFromWorldPoint(this.target.getWorldLocation()) != computeChunkIdFromWorldPoint(initialWorldPoint);
    }

    public boolean hasChangedTargetId() {
        return this.target.getId() != this.initialTargetId;
    }

    public boolean isChunkless() {
        return this.definition.getChunkIds() == null;
    }

    public boolean isEntranceInValidChunk() {
        if (this.isChunkless()) return true;
        return this.definition.getChunkIds().contains(computeChunkIdFromWorldPoint(this.target.getWorldLocation()));
    }

    public boolean canHighlight() {
        return this.definition.getOverlayType().canHighlight();
    }

    public boolean canDeprioritize() {
        return this.definition.getOverlayType().canDeprioritize() && !this.definition.isEscapeCrystalDisabled();
    }

    public boolean isPrioritized() {
        return this.definition.getOverlayType() == EscapeCrystalNotifyRegionEntranceOverlayType.PRIORITIZED_WITH_HIGHLIGHT;
    }

    public boolean matchesPlayerPlane(int playerPlane) {
        return this.definition.getPlaneLevel().matchesPlane(playerPlane);
    }

    public boolean isPlayerPastEntrance(WorldPoint playerWorldPoint) {
        if (this.definition.getEntranceDirection() == null) return false;

        int entranceTileX = this.target.getWorldLocation().getX();
        int entranceTileY = this.target.getWorldLocation().getY();
        int playerTileX = playerWorldPoint.getX();
        int playerTileY = playerWorldPoint.getY();

        switch (this.definition.getEntranceDirection()) {
            case NORTHWARD:
                return playerTileY > entranceTileY;
            case NORTHWARD_INCLUSIVE:
                return playerTileY >= entranceTileY;
            case SOUTHWARD:
                return playerTileY < entranceTileY;
            case SOUTHWARD_INCLUSIVE:
                return playerTileY <= entranceTileY;
            case EASTWARD:
                return playerTileX > entranceTileX;
            case EASTWARD_INCLUSIVE:
                return playerTileX >= entranceTileX;
            case WESTWARD:
                return playerTileX < entranceTileX;
            case WESTWARD_INCLUSIVE:
                return playerTileX <= entranceTileX;
            default:
                return false;
        }
    }

    public static int computeChunkIdFromWorldPoint(WorldPoint worldPoint) {
        int currentTileX = worldPoint.getX();
        int currentTileY = worldPoint.getY();
        final int currentChunkX = currentTileX >> 3;
        final int currentChunkY = currentTileY >> 3;

        return (currentChunkX << 11) | currentChunkY;
    }
}

package com.escapecrystalnotify;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("escapecrystalnotify")
public interface EscapeCrystalNotifyConfig extends Config
{
	enum InactivityTimeFormat {
		SECONDS ("Seconds"),
		SECONDS_MMSS ("Seconds (MM:SS)"),
		GAME_TICKS ("Ticks");

		private final String formatName;

		InactivityTimeFormat(String formatName) {
			this.formatName = formatName;
		}

		public String toString() {
			return this.formatName;
		}
	}

	enum OverlayDisplayType {
		REMAINING_TIME ("Remaining Time"),
		CURRENT_SETTING ("Current Setting"),
		DISABLED ("Disabled");

		private final String formatName;

		OverlayDisplayType(String formatName) {
			this.formatName = formatName;
		}

		public String toString() {
			return this.formatName;
		}
	}

	enum ModelOverlayType {
		ITEM_FILL ("Item Fill"),
		BACKGROUND_FILL ("Background Fill"),
		DISABLED ("Disabled");

		private final String formatName;

		ModelOverlayType(String formatName) {
			this.formatName = formatName;
		}

		public String toString() {
			return this.formatName;
		}
	}

	@ConfigItem(
		keyName = "requireHardcoreAccountType",
		name = "Only display for HCIM/HCGIM",
		description = "Only display when logged in as a HCIM or HCGIM",
		position = 1
	)
	default boolean requireHardcoreAccountType() { return true; }

	@ConfigSection(
			name = "Location Filter",
			description = "Filter locations where the reminder is shown",
			closedByDefault = true,
			position = 2
	)
	String displayRegionFilter = "displayRegionFilter";

	@ConfigItem(
			keyName = "displayBosses",
			name = "Enable for Unsafe Bosses",
			description = "Enable the overlays for unsafe bosses",
			section = "displayRegionFilter",
			position = 1
	)
	default boolean displayBosses() { return true; }

	@ConfigItem(
			keyName = "displayRaids",
			name = "Enable in Unsafe Raids",
			description = "Enable the overlays in unsafe raids",
			section = "displayRegionFilter",
			position = 2
	)
	default boolean displayRaids() { return true; }

	@ConfigItem(
			keyName = "displayDungeons",
			name = "Enable in Unsafe Dungeons",
			description = "Enable the overlays when inside unsafe dungeons",
			section = "displayRegionFilter",
			position = 3
	)
	default boolean displayDungeons() { return true; }

	@ConfigItem(
			keyName = "displayMinigames",
			name = "Enable in Unsafe Minigames",
			description = "Enable the overlays when in unsafe minigames",
			section = "displayRegionFilter",
			position = 4
	)
	default boolean displayMinigames() { return true; }

	@ConfigItem(
			keyName = "displayTeleportDisabled",
			name = "Enable in Teleport Disabled Areas",
			description = "Enable the reminder overlay when in areas where your escape crystal cannot teleport you out",
			section = "displayRegionFilter",
			position = 5
	)
	default boolean displayTeleportDisabled() { return true; }

	@ConfigItem(
			keyName = "displayEverywhere",
			name = "Enable Everywhere",
			description = "Enable the overlays at all times",
			section = "displayRegionFilter",
			position = 6
	)
	default boolean displayEverywhere() { return false; }

	@ConfigItem(
			keyName = "excludeZulrahWithEliteDiary",
			name = "Exclude Zulrah With Elite Diary",
			description = "Don't display at Zulrah when you have completed the Western Elite Diary. Note: This exclusion is removed if you die and proc the revival.",
			section = "displayRegionFilter",
			position = 7
	)
	default boolean excludeZulrahWithEliteDiary() { return true; }

	@ConfigItem(
			keyName = "excludeRegionIds",
			name = "Exclude Region IDs",
			description = "A comma separated list of Region IDs to exclude",
			section = "displayRegionFilter",
			position = 8
	)
	default String excludeRegionIds() { return ""; }

	@ConfigItem(
			keyName = "includeRegionIds",
			name = "Include Region IDs",
			description = "A comma separated list of Region IDs to include",
			section = "displayRegionFilter",
			position = 9
	)
	default String includeRegionIds() { return ""; }

	@ConfigSection(
			name = "Entrance Overlay",
			description = "Add a reminder overlay to boss/dungeon entrances and optional deprioritization of the enter menu option",
			closedByDefault = true,
			position = 3
	)
	String entranceOverlaySettings = "entranceOverlaySettings";

	@ConfigItem(
			keyName = "deprioritizeEntranceEnterOption",
			name = "Deprioritize Entrance Enter Option",
			description = "Deprioritize the enter menu option when you do not have an active Escape Crystal",
			section = "entranceOverlaySettings",
			position = 1
	)
	default boolean deprioritizeEntranceEnterOption() { return true; }

	@ConfigItem(
			keyName = "displayEntranceOverlay",
			name = "Display Entrance Overlay",
			description = "Display the reminder overlay for entrances to dangerous regions when you do not have an active Escape Crystal",
			section = "entranceOverlaySettings",
			position = 2
	)
	default boolean displayEntranceOverlay() { return true; }

	@Alpha
	@ConfigItem(
			keyName = "entranceOverlayFillColor",
			name = "Entrance Overlay Fill Color",
			description = "Fill color of the entrance reminder overlay for deprioritized entrances",
			section = "entranceOverlaySettings",
			position = 3
	)
	default Color entranceOverlayFillColor() { return new Color(205,50,50,75); }

	@Alpha
	@ConfigItem(
			keyName = "prioritizedEntranceOverlayFillColor",
			name = "Prioritized Entrance Overlay Fill Color",
			description = "Fill color of the entrance reminder overlay for prioritized entrances",
			section = "entranceOverlaySettings",
			position = 4
	)
	default Color prioritizedEntranceOverlayFillColor() { return new Color(255,140,0,75); }

	@ConfigItem(
			keyName = "entranceOverlayImageScale",
			name = "Image Scale",
			description = "The scale of the inactive Escape Crystal image",
			section = "entranceOverlaySettings",
			position = 5
	)
	default double entranceOverlayImageScale()
	{
		return 1.0;
	}

	@ConfigItem(
			keyName = "deprioritizedMenuText",
			name = "Deprioritized Menu Text",
			description = "Text to display in the deprioritized menu option for entrances",
			section = "entranceOverlaySettings",
			position = 6
	)
	default String deprioritizedMenuText() { return "Where's Your Crystal?"; }

	@Alpha
	@ConfigItem(
			keyName = "deprioritizedMenuTextColor",
			name = "Deprioritized Menu Text Color",
			description = "Color of the deprioritized menu option text",
			section = "entranceOverlaySettings",
			position = 7
	)
	default Color deprioritizedMenuTextColor() { return new Color(255,106,213,255); }

	@Alpha
	@ConfigItem(
			keyName = "escapeCrystalDisabledTextColor",
			name = "Escape Crystal Disabled Text Color",
			description = "Color of the Escape Crystal disabled text overlay (Some regions of the game do not allow Escape Crystals)",
			section = "entranceOverlaySettings",
			position = 8
	)
	default Color escapeCrystalDisabledTextColor() { return new Color(255,0,0,255); }

	@ConfigSection(
		name = "On-Screen Widget",
		description = "Settings for the movable and resizable on-screen widget",
		closedByDefault = true,
		position = 4
	)
	String onScreenWidgetSettings = "onScreenWidgetSettings";

	@ConfigItem(
		keyName = "enableOnScreenWidget",
		name = "Enable On-Screen Widget",
		description = "Display the movable and resizable on-screen widget",
		section = "onScreenWidgetSettings",
		position = 1
	)
	default boolean enableOnScreenWidget() { return true; }

	@ConfigItem(
		keyName = "alwaysDisplayOnScreenWidget",
		name = "Display Everywhere",
		description = "Always enable the on-screen display regardless of location",
		section = "onScreenWidgetSettings",
		position = 2
	)
	default boolean alwaysDisplayOnScreenWidget() { return false; }

	@ConfigItem(
		keyName = "onlyDisplayInactiveOnScreenWidget",
		name = "Only Show When Inactive",
		description = "Only enable the on-screen display when your crystal is inactive",
		section = "onScreenWidgetSettings",
		position = 3
	)
	default boolean onlyDisplayInactiveOnScreenWidget() { return false; }

	@ConfigItem(
		keyName = "displayDisabledLeftClickTeleportText",
		name = "Display Left Click Disabled",
		description = "Display text indicating the the crystal is not set to be left click teleport",
		section = "onScreenWidgetSettings",
		position = 4
	)
	default boolean displayDisabledLeftClickTeleportText() { return true; }

	@ConfigItem(
		keyName = "onScreenWidgetDisplayFormat",
		name = "Display Format",
		description = "Type of information shown on the on-screen widget",
		section = "onScreenWidgetSettings",
		position = 5
	)
	default OverlayDisplayType onScreenWidgetDisplayFormat()
	{
		return OverlayDisplayType.REMAINING_TIME;
	}

	@ConfigItem(
		keyName = "onScreenWidgetInactivityTimeFormat",
		name = "Time Format",
		description = "Format for displaying the time information shown on the on-screen widget",
		section = "onScreenWidgetSettings",
		position = 6
	)
	default InactivityTimeFormat onScreenWidgetInactivityTimeFormat()
	{
		return InactivityTimeFormat.SECONDS;
	}

	@ConfigItem(
		keyName = "activeCrystalWidgetScale",
		name = "Active Widget Size",
		description = "The size of the active crystal widget",
		section = "onScreenWidgetSettings",
		position = 7
	)
	default int activeCrystalWidgetScale()
	{
		return 4;
	}

	@ConfigItem(
		keyName = "inactiveCrystalWidgetScale",
		name = "Inactive Widget Size",
		description = "The size of the inactive crystal widget",
		section = "onScreenWidgetSettings",
		position = 8
	)
	default int inactiveCrystalWidgetScale()
	{
		return 4;
	}

	@ConfigItem(
		keyName = "onScreenWidgetTimeExpiredText",
		name = "Time Expired Text",
		description = "Text to draw onto the crystal's inventory model when the inactivity time has been reached",
		section = "onScreenWidgetSettings",
		position = 9
	)
	default String onScreenWidgetTimeExpiredText() { return "Tele"; }

	@ConfigSection(
		name = "Info Box",
		description = "Settings for Info Box",
		closedByDefault = true,
		position = 5
)
	String infoBoxDisplaySettings = "infoBoxDisplaySettings";

	@ConfigItem(
		keyName = "enableInfoBox",
		name = "Enable Info Box",
		description = "Enable the info box display",
		section = "infoBoxDisplaySettings",
		position = 1
	)
	default boolean enableInfoBox() { return true; }

	@ConfigItem(
		keyName = "alwaysDisplayInfoBox",
		name = "Display Everywhere",
		description = "Always enable the info box display regardless of location",
		section = "infoBoxDisplaySettings",
		position = 2
	)
	default boolean alwaysDisplayInfoBox() { return true; }

	@ConfigItem(
		keyName = "infoBoxDisplayFormat",
		name = "Display Format",
		description = "Type of information shown on the info box",
		section = "infoBoxDisplaySettings",
		position = 3
	)
	default OverlayDisplayType infoBoxDisplayFormat()
	{
		return OverlayDisplayType.REMAINING_TIME;
	}

	@ConfigItem(
		keyName = "infoBoxInactivityTimeFormat",
		name = "Time Format",
		description = "Format for displaying the time left before triggering the inactivity teleport on the info box",
		section = "infoBoxDisplaySettings",
		position = 4
	)
	default InactivityTimeFormat infoBoxInactivityTimeFormat()
	{
		return InactivityTimeFormat.SECONDS;
	}

	@ConfigItem(
		keyName = "infoBoxTimeExpiredText",
		name = "Time Expired Text",
		description = "Text to draw onto the crystal's inventory model when the inactivity time has been reached",
		section = "infoBoxDisplaySettings",
		position = 5
	)
	default String infoBoxTimeExpiredText() { return "Tele"; }

	@ConfigItem(
		keyName = "infoBoxMissingCrystalText",
		name = "Missing Crystal Text",
		description = "Text to draw onto the crystal's inventory model when you are missing an Escape Crystal",
		section = "infoBoxDisplaySettings",
		position = 6
	)
	default String infoBoxMissingCrystalText() { return "Missing"; }

	@ConfigSection(
		name = "Inventory Highlight",
		description = "Settings for inventory & equipment screen",
		closedByDefault = true,
		position = 6
	)
	String inventoryDisplaySettings = "inventoryDisplaySettings";

	@ConfigItem(
		keyName = "enableInventoryDisplay",
		name = "Enable Inventory Display",
		description = "Enable the Inventory display",
		section = "inventoryDisplaySettings",
		position = 1
	)
	default boolean enableInventoryDisplay() { return true; }

	@ConfigItem(
		keyName = "alwaysDisplayInventory",
		name = "Display Everywhere",
		description = "Always enable the inventory display regardless of location",
		section = "inventoryDisplaySettings",
		position = 2
	)
	default boolean alwaysDisplayInventory() { return true; }

	@ConfigItem(
		keyName = "inventoryDisplayFormat",
		name = "Display Format",
		description = "Type of information shown on the inventory model",
		section = "inventoryDisplaySettings",
		position = 3
	)
	default OverlayDisplayType inventoryDisplayFormat()
	{
		return OverlayDisplayType.REMAINING_TIME;
	}

	@ConfigItem(
		keyName = "inventoryTimeFormat",
		name = "Time Format",
		description = "Format for displaying the time left before triggering the inactivity teleport in the inventory & equipment menus",
		section = "inventoryDisplaySettings",
		position = 4
	)
	default InactivityTimeFormat inventoryInactivityTimeFormat()
	{
		return InactivityTimeFormat.SECONDS;
	}

	@ConfigItem(
		keyName = "inventoryOverlayType",
		name = "Overlay Type",
		description = "Method of highlighting the crystal's inventory & equipment model",
		section = "inventoryDisplaySettings",
		position = 5
	)
	default ModelOverlayType inventoryOverlayType()
	{
		return ModelOverlayType.ITEM_FILL;
	}

	@Alpha
	@ConfigItem(
		keyName = "inventoryActiveFillColor",
		name = "Active Fill Color",
		description = "Color of the background fill to draw onto the crystal's inventory model while active",
		section = "inventoryDisplaySettings",
		position = 6
	)
	default Color inventoryActiveFillColor() { return new Color(50,205,50,75); }

	@Alpha
	@ConfigItem(
		keyName = "inventoryInactiveFillColor",
		name = "Inactive Fill Color",
		description = "Color of the background fill to draw onto the crystal's inventory model while inactive",
		section = "inventoryDisplaySettings",
		position = 7
	)
	default Color inventoryInactiveFillColor() { return new Color(205,50,50,75); }

	@ConfigItem(
		keyName = "inventoryActiveText",
		name = "Active Crystal Text",
		description = "Text to draw onto the crystal's inventory model while active",
		section = "inventoryDisplaySettings",
		position = 8
	)
	default String inventoryActiveText() { return "Active"; }

	@Alpha
	@ConfigItem(
		keyName = "inventoryActiveTextColor",
		name = "Active Text Color",
		description = "Color of the text to draw onto the crystal's inventory model while active",
		section = "inventoryDisplaySettings",
		position = 9
	)
	default Color inventoryActiveTextColor() { return Color.GREEN; }

	@ConfigItem(
		keyName = "inventoryInactiveText",
		name = "Inactive Crystal Text",
		description = "Text to draw onto the crystal's inventory model while inactive",
		section = "inventoryDisplaySettings",
		position = 10
	)
	default String inventoryInactiveText() { return "Inactive"; }

	@Alpha
	@ConfigItem(
		keyName = "inventoryInactiveTextColor",
		name = "Inactive Text Color",
		description = "Color of the text to draw onto the crystal's inventory model while inactive",
		section = "inventoryDisplaySettings",
		position = 11
	)
	default Color inventoryInactiveTextColor() { return Color.RED; }

	@ConfigItem(
		keyName = "inventoryTimeExpiredText",
		name = "Time Expired Text",
		description = "Text to draw onto the crystal's inventory model when the inactivity time has been reached",
		section = "inventoryDisplaySettings",
		position = 12
	)
	default String inventoryTimeExpiredText() { return "Tele"; }

	@ConfigSection(
		name = "Notification Settings",
		description = "Configure preferences for Runelite notifications",
		closedByDefault = true,
		position = 7
	)
	String notificationSettings = "notificationSettings";

	@ConfigItem(
		keyName = "requireCombatForNotifications",
		name = "Only Send in Combat",
		description = "Only show notifications when in combat or recently in combat",
		section = "notificationSettings",
		position = 1
	)
	default boolean requireCombatForNotifications() { return true; }

	@ConfigItem(
		keyName = "combatGracePeriodSeconds",
		name = "Combat Grace Period",
		description = "How many seconds after combat to enable notifications (0 = only during combat)",
		section = "notificationSettings",
		position = 2
	)
	default int combatGracePeriodSeconds() { return 10; }

	@ConfigItem(
		keyName = "notificationInactivityTimeFormat",
		name = "Time Format",
		description = "Format for displaying the time information shown in your RuneLite notifications",
		section = "notificationSettings",
		position = 3
	)
	default InactivityTimeFormat notificationInactivityTimeFormat()
	{
		return InactivityTimeFormat.SECONDS;
	}

	@ConfigItem(
		keyName = "notifyInactive",
		name = "Inactive Crystal",
		description = "Sends a notification when your escape crystal is not enabled",
		section = "notificationSettings",
		position = 4
	)
	default boolean notifyInactive() { return true; }

	@ConfigItem(
		keyName = "notifyMissing",
		name = "Missing Crystal",
		description = "Sends a notification when you are not carrying your escape crystal",
		section = "notificationSettings",
		position = 5
	)
	default boolean notifyMissing() { return true; }

	@ConfigItem(
		keyName = "notifyTimeUntilTeleportThreshold",
		name = "Time Remaining Threshold",
		description = "Sends a notification when your escape crystal is about to trigger. Note that this respects the time format you specified above (Ticks vs Seconds). A value of 0 will disable the notification.",
		section = "notificationSettings",
		position = 6
	)
	default int notifyTimeUntilTeleportThreshold() { return 0; }

	@ConfigItem(
		keyName = "notifyNonLeftClickTeleport",
		name = "Non Left Click Teleport",
		description = "Sends a notification when the left click option on your escape crystal is not set to teleport",
		section = "notificationSettings",
		position = 7
	)
	default boolean notifyNonLeftClickTeleport() { return true; }

	@ConfigSection(
		name = "Leviathan Safeguards",
		description = "Configure safeguards to prevent deaths due to Leviathan logout bugs",
		closedByDefault = true,
		position = 8
	)
	String leviathanSafeguardSettings = "leviathanSafeguardSettings";

	@ConfigItem(
		keyName = "disableLeviathanSafeguardPanelPopup",
		name = "Disable Panel Popup",
		description = "Disables the panel that appears when near Leviathan's entry boat",
		section = "leviathanSafeguardSettings",
		position = 1
	)
	default boolean disableLeviathanSafeguardPanelPopup() { return false; }

	@ConfigItem(
		keyName = "hideLeviathanBugInfoText",
		name = "Hide Bug Info Text",
		description = "Hides the information about Leviathan's logout bug",
		section = "leviathanSafeguardSettings",
		position = 2
	)
	default boolean hideLeviathanBugInfoText() { return false; }

	@ConfigItem(
		keyName = "deprioritizeLeviathanLogout",
		name = "Deprioritize Logout in Leviathan Arena",
		description = "Deprioritizes the logout menu entry while inside Leviathan's arena to disallow accidental logouts",
		section = "leviathanSafeguardSettings",
		position = 3
	)
	default boolean deprioritizeLeviathanLogout() { return false; }

	@ConfigItem(
		keyName = "hideLeviathanLogoutSettingText",
		name = "Hide Current Logout Setting Text",
		description = "Hides the information about the current configured logout setting",
		section = "leviathanSafeguardSettings",
		position = 4
	)
	default boolean hideLeviathanLogoutSettingText() { return false; }

	@ConfigItem(
		keyName = "warnSixHourLogout",
		name = "Warn When Close to a 6-Hour Logout",
		description = "Warns you when you are close to getting 6-hour logged",
		section = "leviathanSafeguardSettings",
		position = 5
	)
	default boolean warnLeviathanLogoutTimer() { return true; }

	@ConfigItem(
		keyName = "hideLeviathanSettingsInstructionText",
		name = "Hide Bottom Instruction Info",
		description = "Hides the text at the bottom of the panel that explains how to enable/disable the Leviathan safeguard features",
		section = "leviathanSafeguardSettings",
		position = 6
	)
	default boolean hideLeviathanSettingsInstructionText() { return false; }

	@ConfigSection(
		name = "Doom Safeguards",
		description = "Configure safeguards to prevent deaths due to Doom logout bugs",
		closedByDefault = true,
		position = 9
	)
	String doomSafeguardSettings = "doomSafeguardSettings";

	@ConfigItem(
		keyName = "disableDoomSafeguardPanelPopup",
		name = "Disable Panel Popup",
		description = "Disables the panel that appears when near Doom's arena",
		section = "doomSafeguardSettings",
		position = 1
	)
	default boolean disableDoomSafeguardPanelPopup() { return false; }

	@ConfigItem(
		keyName = "hideDoomBugInfoText",
		name = "Hide Bug Info Text",
		description = "Hides the information about Doom's logout bug",
		section = "doomSafeguardSettings",
		position = 2
	)
	default boolean hideDoomBugInfoText() { return false; }

	@ConfigItem(
		keyName = "deprioritizeDoomLogout",
		name = "Deprioritize Logout in Doom's Arena",
		description = "Deprioritizes the logout menu entry while inside Doom's arena to disallow accidental logouts. The logout is ENABLED between floors.",
		section = "doomSafeguardSettings",
		position = 3
	)
	default boolean deprioritizeDoomLogout() { return false; }

	@ConfigItem(
		keyName = "hideDoomLogoutSettingText",
		name = "Hide Current Logout Setting Text",
		description = "Hides the information about the current configured logout setting",
		section = "doomSafeguardSettings",
		position = 4
	)
	default boolean hideDoomLogoutSettingText() { return false; }

	@ConfigItem(
		keyName = "warnDoomSixHourLogout",
		name = "Warn When Close to a 6-Hour Logout",
		description = "Warns you when you are close to getting 6-hour logged",
		section = "doomSafeguardSettings",
		position = 5
	)
	default boolean warnDoomLogoutTimer() { return true; }

	@ConfigItem(
		keyName = "hideDoomSettingsInstructionText",
		name = "Hide Bottom Instruction Info",
		description = "Hides the text at the bottom of the panel that explains how to enable/disable the Doom safeguard features",
		section = "doomSafeguardSettings",
		position = 6
	)
	default boolean hideDoomSettingsInstructionText() { return false; }

	@ConfigSection(
		name = "Non-HC Inventory Highlight",
		description = "Settings for minimal inventory highlighting for non-hardcore accounts",
		closedByDefault = true,
		position = 10
	)
	String nonHardcoreInventorySettings = "nonHardcoreInventorySettings";

	@ConfigItem(
		keyName = "enableNonHardcoreInventoryHighlight",
		name = "Enable Non-HC Inventory Highlight",
		description = "Enable minimal inventory highlighting for non-hardcore accounts (no overlay text, just highlight)",
		section = "nonHardcoreInventorySettings",
		position = 1
	)
	default boolean enableNonHardcoreInventoryHighlight() { return true; }

	@ConfigItem(
		keyName = "nonHardcoreInventoryOverlayType",
		name = "Overlay Type",
		description = "Method of highlighting the crystal's inventory & equipment model for non-hardcore accounts",
		section = "nonHardcoreInventorySettings",
		position = 2
	)
	default ModelOverlayType nonHardcoreInventoryOverlayType()
	{
		return ModelOverlayType.ITEM_FILL;
	}

	@Alpha
	@ConfigItem(
		keyName = "nonHardcoreInventoryActiveFillColor",
		name = "Active Fill Color",
		description = "Color of the background fill to draw onto the crystal's inventory model while active for non-hardcore accounts",
		section = "nonHardcoreInventorySettings",
		position = 3
	)
	default Color nonHardcoreInventoryActiveFillColor() { return new Color(50,205,50,75); }

	@Alpha
	@ConfigItem(
		keyName = "nonHardcoreInventoryInactiveFillColor",
		name = "Inactive Fill Color",
		description = "Color of the background fill to draw onto the crystal's inventory model while inactive for non-hardcore accounts",
		section = "nonHardcoreInventorySettings",
		position = 4
	)
	default Color nonHardcoreInventoryInactiveFillColor() { return new Color(205,50,50,75); }

	@ConfigSection(
		name = "Debug",
		description = "Settings for testing and debugging the plugin",
		closedByDefault = true,
		position = 11
	)
	String debugSettings = "debugSettings";

	@ConfigItem(
		keyName = "enableDebugMode",
		name = "Enable Testing Mode",
		description = "Shows a comprehensive overlay with all plugin state information for debugging",
		section = "debugSettings",
		position = 1
	)
	default boolean enableDebugMode() { return false; }

	@ConfigItem(
		keyName = "showPlayerLocationSection",
		name = "Show Player Location Section",
		description = "Display player location information in the testing overlay",
		section = "debugSettings",
		position = 2
	)
	default boolean showPlayerLocationSection() { return true; }

	@ConfigItem(
		keyName = "showEscapeCrystalSection",
		name = "Show Escape Crystal Section",
		description = "Display escape crystal status information in the testing overlay",
		section = "debugSettings",
		position = 3
	)
	default boolean showEscapeCrystalSection() { return true; }

	@ConfigItem(
		keyName = "showAccountInfoSection",
		name = "Show Account Info Section",
		description = "Display account information in the testing overlay",
		section = "debugSettings",
		position = 4
	)
	default boolean showAccountInfoSection() { return true; }

	@ConfigItem(
		keyName = "showPossibleEntrancesSection",
		name = "Show Possible Entrances Section",
		description = "Display possible entrances information in the testing overlay",
		section = "debugSettings",
		position = 5
	)
	default boolean showPossibleEntrancesSection() { return true; }

	@ConfigItem(
		keyName = "showValidEntrancesSection",
		name = "Show Valid Entrances Section",
		description = "Display valid entrances information in the testing overlay",
		section = "debugSettings",
		position = 6
	)
	default boolean showValidEntrancesSection() { return true; }

	@ConfigItem(
		keyName = "showSpecialRegionSection",
		name = "Show Special Region Section",
		description = "Display special region status information in the testing overlay",
		section = "debugSettings",
		position = 7
	)
	default boolean showSpecialRegionSection() { return true; }

	@ConfigItem(
		keyName = "showNotificationSection",
		name = "Show Notification Section",
		description = "Display notification status information in the testing overlay",
		section = "debugSettings",
		position = 8
	)
	default boolean showNotificationSection() { return true; }

	@ConfigItem(
		keyName = "testingAccountTypeOverride",
		name = "Testing Account Type Override",
		description = "Override the detected account type for testing purposes. Set to 'Default' to use the actual account type.",
		section = "debugSettings",
		position = 9
	)
	default TestingAccountType testingAccountTypeOverride() { return TestingAccountType.DEFAULT; }

	enum TestingAccountType {
		DEFAULT ("Default (Actual Account Type)"),
		NON_HARDCORE ("Non-Hardcore"),
		STANDARD_HARDCORE ("Standard Hardcore"),
		GROUP_HARDCORE ("Group Hardcore");

		private final String displayName;

		TestingAccountType(String displayName) {
			this.displayName = displayName;
		}

		public String toString() {
			return this.displayName;
		}
	}
}


package com.escapecrystalnotify;

import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import java.awt.*;

@Getter
public class EscapeCrystalNotifyRegionEntranceObject {
    public GameObject gameObject;
    public NPC npc;
    public DecorativeObject decorativeObject;
    public WallObject wallObject;


    EscapeCrystalNotifyRegionEntranceObject(GameObject gameObject) {
        this.gameObject = gameObject;
        this.npc = null;
        this.decorativeObject = null;
        this.wallObject = null;
    }

    EscapeCrystalNotifyRegionEntranceObject(NPC npc) {
        this.gameObject = null;
        this.npc = npc;
        this.decorativeObject = null;
        this.wallObject = null;
    }

    EscapeCrystalNotifyRegionEntranceObject(DecorativeObject decorativeObject) {
        this.gameObject = null;
        this.npc = null;
        this.decorativeObject = decorativeObject;
        this.wallObject = null;
    }

    EscapeCrystalNotifyRegionEntranceObject(WallObject wallObject) {
        this.gameObject = null;
        this.npc = null;
        this.decorativeObject = null;
        this.wallObject = wallObject;
    }

    public WorldPoint getWorldLocation() {
        WorldPoint worldPoint = null;
        WorldView worldView = null;
        
        if (this.gameObject != null) {
            worldPoint = this.gameObject.getWorldLocation();
            worldView = this.gameObject.getWorldView();
        }

        if (this.npc != null) {
            worldPoint = this.npc.getWorldLocation();
            worldView = this.npc.getWorldView();
        }

        if (this.decorativeObject != null) {
            worldPoint = this.decorativeObject.getWorldLocation();
            worldView = this.decorativeObject.getWorldView();
        }

        if (this.wallObject != null) {
            worldPoint = this.wallObject.getWorldLocation();
            worldView = this.wallObject.getWorldView();
        }

        if (worldPoint == null) {
            return null;
        }

        if (worldView != null && worldView.isInstance()) {
            worldPoint = WorldPoint.fromLocalInstance(worldView.getScene(), this.getLocalLocation(), worldView.getPlane());
        }

        return worldPoint;
    }

    public LocalPoint getLocalLocation() {
        if (this.gameObject != null) {
            return this.gameObject.getLocalLocation();
        }

        if (this.npc != null) {
            return this.npc.getLocalLocation();
        }

        if (this.decorativeObject != null) {
            return this.decorativeObject.getLocalLocation();
        }

        if (this.wallObject != null) {
            return this.wallObject.getLocalLocation();
        }

        return null;
    }

    public int getId() {
        if (this.gameObject != null) {
            return this.gameObject.getId();
        }

        if (this.npc != null) {
            return this.npc.getId();
        }

        if (this.decorativeObject != null) {
            return this.decorativeObject.getId();
        }

        if (this.wallObject != null) {
            return this.wallObject.getId();
        }

        return -1;
    }

    public Shape getConvexHull() {
        try {
            if (gameObject != null) {
                return gameObject.getConvexHull();
            }
            if (npc != null) {
                return npc.getConvexHull();
            }
            if (decorativeObject != null) {
                return decorativeObject.getConvexHull();
            }
            if (wallObject != null) {
                return wallObject.getConvexHull();
            }
        } catch (Exception e) {
            return null;
        }

        return null;
    }

    public net.runelite.api.Point getCanvasTextLocation(Graphics2D graphics, String s, int i) {
        if (this.gameObject != null) {
            return this.gameObject.getCanvasTextLocation(graphics, s, i);
        }

        if (this.npc != null) {
            return this.npc.getCanvasTextLocation(graphics, s, i);
        }

        if (this.decorativeObject != null) {
            return this.decorativeObject.getCanvasTextLocation(graphics, s, i);
        }

        if (this.wallObject != null) {
            return this.wallObject.getCanvasTextLocation(graphics, s, i);
        }

        return null;
    }
}

package com.escapecrystalnotify;

import net.runelite.api.GameObject;
import net.runelite.api.Point;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.util.List;

public class EscapeCrystalNotifyRegionEntranceOverlay extends Overlay {
    private static final EntranceOverlayImage previouslyGeneratedImage = new EntranceOverlayImage();
    private static BufferedImage entranceOverlayImage;
    private final EscapeCrystalNotifyPlugin plugin;
    private final EscapeCrystalNotifyConfig config;
    private static final String ESCAPE_CRYSTAL_DISABLED_TEXT = "ESCAPE CRYSTAL\nDOES NOT WORK HERE";
    private static final String[] disabledTextLines = ESCAPE_CRYSTAL_DISABLED_TEXT.split("\n");

    @Inject
    EscapeCrystalNotifyRegionEntranceOverlay(EscapeCrystalNotifyPlugin plugin, EscapeCrystalNotifyConfig config) throws PluginInstantiationException {
        super(plugin);

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);

        this.plugin = plugin;
        this.config = config;

        initializePreviouslyGeneratedImage();
    }

    private void initializePreviouslyGeneratedImage() {
        previouslyGeneratedImage.scale = 1;
        previouslyGeneratedImage.generatedImage = entranceOverlayImage;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        boolean enabled = config.displayEntranceOverlay();
        boolean active = plugin.isEscapeCrystalInactivityTeleportActive();
        boolean notHardcore = config.requireHardcoreAccountType() && !plugin.isHardcoreAccountType();
        boolean atNotifyRegion = plugin.isAtNotifyRegionId();

        if (!enabled || notHardcore || !atNotifyRegion) {
            return null;
        }

        List<EscapeCrystalNotifyLocatedEntrance> validEntrances = plugin.getValidEntrances();
        if (validEntrances.isEmpty()) return null;

        if (entranceOverlayImage == null) {
            entranceOverlayImage = plugin.getEntranceOverlayImage();
            initializePreviouslyGeneratedImage();
        }

        for (EscapeCrystalNotifyLocatedEntrance entrance : validEntrances) {
            if (!entrance.canHighlight() || entrance.isPlayerPastEntrance(plugin.getCurrentWorldPoint())) {
                continue;
            }

            if (active && !entrance.getDefinition().isEscapeCrystalDisabled()) {
                continue;
            }

            Shape entranceClickbox = entrance.getTarget().getConvexHull();

            if (entranceClickbox == null) {
                continue;
            }

            Color fillColor = entrance.isPrioritized()
                ? config.prioritizedEntranceOverlayFillColor() 
                : config.entranceOverlayFillColor();

            graphics.setColor(fillColor);
            graphics.fill(entranceClickbox);

            graphics.setColor(fillColor.darker());
            graphics.draw(entranceClickbox);

            Point baseImageLocation = entrance.getTarget().getCanvasTextLocation(graphics, "", 125);

            if (baseImageLocation == null) {
                continue;
            }

            BufferedImage generatedEntranceOverlayImage = generateEntranceOverlayImage();
            int xOffset = generatedEntranceOverlayImage.getWidth() / 2;
            int yOffset = generatedEntranceOverlayImage.getHeight() / 2;
            Point imageLocation = new Point(baseImageLocation.getX() - xOffset, baseImageLocation.getY() - yOffset);
            OverlayUtil.renderImageLocation(graphics, imageLocation, generatedEntranceOverlayImage);

            if (entrance.getDefinition().isEscapeCrystalDisabled()) {
                FontMetrics fontMetrics = graphics.getFontMetrics();

                for (int i = 0; i < disabledTextLines.length; i++) {
                    int textWidth = fontMetrics.stringWidth(disabledTextLines[i]);
                    int centeredX = baseImageLocation.getX() - (textWidth / 2);
                    int textY = baseImageLocation.getY() + 30 + (i * 15);
                    
                    Point textLocation = new Point(centeredX, textY);
                    OverlayUtil.renderTextLocation(graphics, textLocation, disabledTextLines[i], config.escapeCrystalDisabledTextColor());
                }
            }
        }

        return null;
    }

    private BufferedImage generateEntranceOverlayImage() {
        double targetScale = Math.max(config.entranceOverlayImageScale(), 0.1);
        boolean entranceOverlayImageScaleChanged = previouslyGeneratedImage.scale != targetScale;

        if (!entranceOverlayImageScaleChanged) {
            return previouslyGeneratedImage.generatedImage;
        }

        BufferedImage generatedEntranceOverlayImage = scaleImage(entranceOverlayImage, targetScale);

        previouslyGeneratedImage.generatedImage = generatedEntranceOverlayImage;
        previouslyGeneratedImage.scale = targetScale;

        return generatedEntranceOverlayImage;
    }

    private BufferedImage scaleImage(BufferedImage image, double scale) {
        BufferedImage scaledImage = new BufferedImage(
                (int) (scale * image.getWidth()),
                (int) (scale * image.getHeight()),
                BufferedImage.TYPE_INT_ARGB
        );

        AffineTransform at = new AffineTransform();
        at.scale(scale, scale);
        AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
        scaledImage = scaleOp.filter(image, scaledImage);

        return scaledImage;
    }

    private static class EntranceOverlayImage {
        private double scale;
        private BufferedImage generatedImage;

    }
}

package com.escapecrystalnotify;

import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import org.apache.commons.lang3.StringUtils;

import javax.inject.Inject;
import java.awt.*;

public class EscapeCrystalNotifyTeleportDisabledPanel extends OverlayPanel {
    private static final Font OVERLAY_PANEL_FONT = FontManager.getRunescapeFont();
    private static final int OVERLAY_PANEL_WIDTH = 185;
    private static final int OVERLAY_PANEL_HEIGHT = 40;
    private static final String TELEPORT_DISABLED_WARNING_TEXT = "WARNING: THE ESCAPE CRYSTAL DOES NOT WORK HERE";

    private final EscapeCrystalNotifyPlugin plugin;
    private final EscapeCrystalNotifyConfig config;

    @Inject
    EscapeCrystalNotifyTeleportDisabledPanel(EscapeCrystalNotifyPlugin plugin, EscapeCrystalNotifyConfig config) throws PluginInstantiationException {
        super(plugin);

        setPosition(OverlayPosition.TOP_RIGHT);
        setPriority(OverlayPriority.HIGH);

        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isTeleportDisabledPanelEnabled()) return null;

        final FontMetrics metrics = graphics.getFontMetrics(OVERLAY_PANEL_FONT);

        panelComponent.setPreferredSize(new Dimension(OVERLAY_PANEL_WIDTH, OVERLAY_PANEL_HEIGHT));
        panelComponent.getChildren().clear();

        panelComponent.getChildren().add(LineComponent.builder()
                .left(getCenteredText(TELEPORT_DISABLED_WARNING_TEXT, metrics))
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(JagexColors.CHAT_FC_TEXT_TRANSPARENT_BACKGROUND)
                .build());

        return panelComponent.render(graphics);
    }

    private static String getCenteredText(String text, FontMetrics metrics) {
        int spaceWidth = metrics.stringWidth(" ");
        int remainingWidth = OVERLAY_PANEL_WIDTH - metrics.stringWidth(text);
        int requiredSpaces = remainingWidth / spaceWidth;
        int characterCount = text.length() + requiredSpaces;
        return StringUtils.center(text, characterCount);
    }
}

package com.escapecrystalnotify;

import lombok.Getter;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.Quest;

import java.util.*;
import java.util.stream.Collectors;

public enum EscapeCrystalNotifyRegion {

    /*
    Credit to the 'discord' Runelite plugin for many of the region IDs:

    https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/discord/DiscordGameEventType.java
     */

    BOSS_ABYSSAL_SIRE("Abyssal Sire", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.PRIORITIZED_WITH_HIGHLIGHT, List.of(774740, 774742, 780884, 780886), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.NEXUS_EYE_YELLOW_MIDDLE, ObjectID.NEXUS_EYE_YELLOW_LEFT, ObjectID.NEXUS_EYE_YELLOW_RIGHT, ObjectID.NEXUS_EYE_GREEN_MIDDLE, ObjectID.NEXUS_EYE_GREEN_LEFT, ObjectID.NEXUS_EYE_GREEN_RIGHT), 11851, 11850, 12106, 12363, 12362),
    BOSS_AMOXLIATL("Amoxliatl", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(410803, 410804), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.VMQ3_RUINS_DOOR_MULTI), 5446, 6294, 6550),
    BOSS_ARAXXOR("Araxxor", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(935114, 935115, 937162, 937163), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.ARAXXOR_BOSS_TUNNEL_MULTI), 14489, 14745),
    BOSS_ARTIO("Artio", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.PRIORITIZED_WITH_HIGHLIGHT, List.of(797131), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.WILD_CALLISTO_SINGLES_ENTRANCE01), 7092, 12345),
    BOSS_BARROWS("Barrows", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14131, 14231),
    BOSS_BRYOPHYTA("Bryophyta", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(812245), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.GB_MOSS_DOOR_IN), 12955),
    BOSS_CALVARION("Calvar'ion", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.PRIORITIZED_WITH_HIGHLIGHT, List.of(813516), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.WILD_VETION_SINGLES_ENTRANCE01), 7604, 12601),
    BOSS_CERBERUS("Cerberus", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(329884, 333982, 340124), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.HELLHOUND_WINCH), 4883, 5139, 5140, 5395),
    BOSS_COMMANDER_ZILYANA("Commander Zilyana", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.WESTWARD_INCLUSIVE, List.of(744082), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.GODWARS_DUNGEON_DOOR_SARADOMIN), 11601, 11602, 11858),
    BOSS_CORP("Corporeal Beast", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.EASTWARD, List.of(760339, 760340), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.CORP_BEAST_ENTRANCE), 11842, 11844),
    BOSS_CRAZY_ARCHAEOLOGIST("Crazy Archaeologist", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11833),
    BOSS_DERANGED_ARCHAEOLOGIST("Deranged Archaeologist", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.SOUTHWARD, List.of(942544), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.FOSSIL_FLORA_SWAMP_FALLEN_TRUNK), 14650, 14649),
    BOSS_DKS("Dagannoth Kings", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(487969), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.DAGEXP_BOSSROOMLADDER_DOWN), 7492, 11588, 11589),
    BOSS_DOOM_OF_MOKHAIOTL("Doom of Mokhaiotl", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(335018, 337066), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.DOM_ENTRANCE), 5268, 5269, 13668, 14180),
    BOSS_DUKE_SUCELLUS("Duke Sucellus", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.NORTHWARD, List.of(776996), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.DT2_GHORROCK_GATE_BOSS), 12132),
    BOSS_GAUNTLET_LOBBY("The Gauntlet Lobby", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(776958), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.GAUNTLET_ENTRANCE_HM_ENABLED, ObjectID.GAUNTLET_ENTRANCE), 12127),
    BOSS_GAUNTLET("The Gauntlet", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7512),
    BOSS_CORRUPTED_GAUNTLET("Corrupted Gauntlet", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7768),
    BOSS_FORTIS_COLOSSEUM("Fortis Colosseum", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(464036), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.COLOSSEUM_ENTRANCE), 7216, 7316),
    BOSS_GENERAL_GRAARDOR("General Graardor", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.EASTWARD_INCLUSIVE, List.of(731805), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.GODWARS_DUNGEON_DOOR_BANDOS), 11347),
    BOSS_GIANT_MOLE("Giant Mole", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 6993, 6992),
    BOSS_GROTESQUE_GUARDIANS("Grotesque Guardians", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(876986, 876987), EscapeCrystalNotifyRegionEntrancePlaneLevel.SECOND_FLOOR, EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.SLAYER_ROOF_ENTRANCE_UNLOCKED, ObjectID.SLAYER_ROOF_ENTRANCE), 6727, 13623),
    BOSS_HESPORI("Hespori", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(318700, 318701, 320748, 320749), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.HESPORI_PLANT_FULLYGROWN, ObjectID.HESPORI_PATCH), 5021),
    BOSS_HUEYCOATL("The Hueycoatl", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.SOUTHWARD, List.of(389530, 391578), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.HUEY_FIGHT_ENTRANCE_OUTAREA, ObjectID.HUEY_FIGHT_ENTRANCE), 5939),
    BOSS_HYDRA("Alchemical Hydra", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.EASTWARD, null, EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.KARUULM_HYDRA_ROOM_DOOR, ObjectID.KARUULM_HYDRA_ROOM_DOOR_M), 5536),
    BOSS_INFERNO("The Inferno", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, 9043),
    BOSS_INFERNO_ENTRANCE("The Inferno Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(637567, 637568, 637569, 639615, 639616, 639617), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.INFERNO_ENTRANCE_OP, ObjectID.INFERNO_ENTRANCE), 9807, 9808, 10063, 10064),
    BOSS_KING_BLACK_DRAGON("King Black Dragon", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9033, 12448),
    BOSS_KING_BLACK_DRAGON_ENTRANCE("King Black Dragon Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.PRIORITIZED_WITH_HIGHLIGHT, List.of(785665), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.DRAGONKINGINLEVER), List.of(785665, 785666), 12192),
    BOSS_KQ("Kalphite Queen", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(898211), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.KALPHITE_CHAMBER_ENTRANCE_UPDATE, ObjectID.KALPHITE_CHAMBER_ENTRANCE_WITHROPE_NORMAL), 13972),
    BOSS_KRAKEN("Kraken", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.NORTHWARD, List.of(584932), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.SLAYER_CAVE_KRAKEN_BOSS_ENTRANCE), 9116),
    BOSS_KREEARRA("Kree'arra", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.NORTHWARD_INCLUSIVE, List.of(725653), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.GODWARS_DUNGEON_DOOR_ARMADYL), 11346),
    BOSS_KRIL_TSUTSAROTH("K'ril Tsutsaroth", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.SOUTHWARD_INCLUSIVE, List.of(748186), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.GODWARS_DUNGEON_DOOR_ZAMORAK), 11603),
    BOSS_MIMIC("The Mimic", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10819),
    BOSS_MIMIC_ENTRANCE("The Mimic Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(420286), EscapeCrystalNotifyRegionEntrancePlaneLevel.FIRST_FLOOR, EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.TRAIL_MIMIC_ENABLER), List.of(420286), 6455),
    BOSS_MYSTERIOUS_FIGURE("Mysterious Figure", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, null, true, EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.DT2_HIDEOUT_ALTAR_OP), 12432),
    BOSS_NEX("Nex", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.EASTWARD, List.of(744074), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.NEX_FIGHT_BARRIER, ObjectID.NEX_FIGHT_BARRIER_BUSY), 11344, 11345, 11600, 11601),
    BOSS_NIGHTMARE("Nightmare of Ashihama", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 15515),
    BOSS_NIGHTMARE_ENTRANCE("Nightmare of Ashihama Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(974019, 974020, 974022, 976067, 976068, 976070), EscapeCrystalNotifyRegionEntranceObjectType.ANY, NpcID.NIGHTMARE_ENTRY_READY, NpcID.NIGHTMARE_ENTRY_OPEN, NpcID.NIGHTMARE_ENTRY_CLOSED_01, NpcID.NIGHTMARE_ENTRY_CLOSED_02, NpcID.NIGHTMARE_ENTRY_CLOSED_03, ObjectID.NIGHTMARE_CHALLENGE_PORTAL), 15256),
    BOSS_OBOR("Obor", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(791757), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.HILLGIANT_BOSS_ENTRANCE_R, ObjectID.HILLGIANT_BOSS_ENTRANCE_L), 12441),
    BOSS_PERILOUS_MOONS("Perilous Moons", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(361652, 369847, 375988), EscapeCrystalNotifyRegionEntrancePlaneLevel.GROUND, EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.PMOON_ENTRY_STATUE_BLOOD, ObjectID.PMOON_ENTRY_STATUE_BLUE, ObjectID.PMOON_ENTRY_STATUE_ECLIPSE), 5525, 5526, 5527, 5528, 5782, 5783, 6037, 6038, 6039),
    BOSS_PHANTOM_MUSPAH("Phantom Muspah", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(744713), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.GHORROCK_DUNGEON_CAVE_ENTRY), 11330, 11681),
    BOSS_PRIFDDINAS_RABBIT("Prifddinas Rabbit", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 13252),
    BOSS_PRIFDDINAS_RABBIT_ENTRANCE("Prifddinas Rabbit Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(580011), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.PRIF_RABBIT_CAVE_ENTRANCE), List.of(577962, 577963, 580011), 9013),
    BOSS_ROYAL_TITANS("Royal Titans", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(754860), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.ROYAL_TITANS_ENTRANCE), 11669, 11925),
    BOSS_SARACHNIS("Sarachnis", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.SOUTHWARD, List.of(472279), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.HOSDUN_SARACHNIS_ENTRANCE), 7322),
    BOSS_SCURRIUS("Scurrius", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.EASTWARD, List.of(840913), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.RAT_BOSS_ENTRANCE), 13210),
    BOSS_SKOTIZO("Skotizo", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9048),
    BOSS_SPINDEL("Spindel", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.PRIORITIZED_WITH_HIGHLIGHT, List.of(815572), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.WILD_VENENATIS_SINGLES_ENTRANCE01), 6580, 12602),
    BOSS_SMOKE_DEVIL("Thermonuclear smoke devil", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.PRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.WESTWARD, List.of(609437), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.SLAYER_CAVE_SMOKEDEVIL_BOSS_ENTRANCE), 9363, 9619),
    BOSS_THE_LEVIATHAN("The Leviathan", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 8291),
    BOSS_THE_LEVIATHAN_ENTRANCE("The Leviathan Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(529188), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.DT2_SCAR_BOAT_CAMP), 8292),
    BOSS_THE_WHISPERER("The Whisperer", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, null, EscapeCrystalNotifyRegionEntranceObjectType.NPC, NpcID.WHISPERER_SPAWN), 10595),
    BOSS_TZHAAR_FIGHT_CAVES("Tzhaar Fight Caves", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, 9551),
    BOSS_TZHAAR_FIGHT_CAVES_ENTRANCE("Tzhaar Fight Caves Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(623237), true, EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.TZHAAR_FIGHTCAVE_WALL_ENTRANCE), 9808),
    BOSS_VARDORVIS("Vardorvis", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(285100), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.DT2_STRANGLEWOOD_BOSS_ENTRY_OP, ObjectID.DT2_STRANGLEWOOD_BOSS_ENTRY), 4405, 4661),
    BOSS_VORKATH("Vorkath", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.NORTHWARD, List.of(582138), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.UNGAEL_CRATER_ENTRANCE), 9023),
    BOSS_WINTERTODT("Wintertodt", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 6462),
    BOSS_WINTERTODT_ENTRANCE("Wintertodt Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.PRIORITIZED_WITH_HIGHLIGHT, List.of(416239, 418287), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.WINT_DOOR), List.of(416238, 416239, 418287, 418287), 6461),
    BOSS_YAMA("Yama", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(367851, 367852, 369899, 369900, 384237), EscapeCrystalNotifyRegionEntranceObjectType.NPC, NpcID.YAMA_THRONE_OCCUPIED, NpcID.VOICE_OF_YAMA_3OP), 5789, 6045),
    BOSS_ZALCANO("Zalcano", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, EscapeCrystalNotifyRegionEntranceDirection.SOUTHWARD, List.of(776949), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.ZALCANO_BARRIER), 12126),
    BOSS_ZULRAH("Zulrah", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9007, 9008),
    BOSS_ZULRAH_ENTRANCE("Zulrah Entrance", EscapeCrystalNotifyRegionType.BOSSES, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(565630, 567678), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.SNAKEBOSS_BOAT, ObjectID.SNAKEBOSS_BOAT_2OPS), List.of(561533, 561534, 563581, 563582, 565630, 567678),8751),
    DUNGEON_ANCIENT_CAVERN("Ancient Cavern", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 6483, 6995),
    DUNGEON_ANCIENT_GUTHIXIAN_TEMPLE("Ancient Guthixian Temple", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 15943, 16199, 16455, 16196, 16197, 16452, 16453),
    DUNGEON_APE_ATOLL("Ape Atoll Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11150, 10894),
    DUNGEON_ASGARNIAN_ICE_CAVES("Asgarnian Ice Caves", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11925, 12181),
    DUNGEON_BRIMHAVEN("Brimhaven Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10901, 10900, 10899, 10645, 10644, 10643),
    DUNGEON_BRINE_RAT_CAVERN("Brine Rat Cavern", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10910),
    DUNGEON_CATACOMBS_OF_KOUREND("Catacombs of Kourend", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 6557, 6556, 6813, 6812),
    DUNGEON_CHAMPIONS_CHALLENGE("Champions' Challenge", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12696),
    DUNGEON_CHASM_OF_FIRE("Chasm of Fire", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 5789),
    DUNGEON_CORSAIR_COVE("Corsair Cove Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 8076, 8332),
    DUNGEON_CRANDOR("Crandor Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11414),
    DUNGEON_CRASH_SITE_CAVERN("Crash Site Cavern", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 8280, 8536),
    DUNGEON_DARKMEYER("Darkmeyer", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14388),
    DUNGEON_DORGESHKAAN("Dorgesh-Kaan South Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10833),
    DUNGEON_DORGESHUUN_MINES("Dorgeshuun Mines", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12950, 13206),
    DUNGEON_EDGEVILLE("Edgeville Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12441, 12442, 12443, 12698),
    DUNGEON_ELEMENTAL_WORKSHOP("Elemental Workshop", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10906, 7760),
    DUNGEON_ELVEN_RABBIT_CAVE("Elven rabbit cave", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 13252),
    DUNGEON_EVIL_CHICKENS_LAIR("Evil Chicken's Lair", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9796),
    DUNGEON_EXPERIMENT_CAVE("Experiment Cave", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14235, 13979),
    DUNGEON_FORTHOS("Forthos Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7323),
    DUNGEON_FREMENNIK_SLAYER("Fremennik Slayer Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10907, 10908, 11164),
    DUNGEON_FREMENNIK_ISLES("Fremennik Isles", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9276, 9532),
    DUNGEON_GIANTS_DEN("Giant's Den", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 5785),
    DUNGEON_GLARIALS_TOMB("Glarial's Tomb", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10137),
    DUNGEON_GOD_WARS("God Wars Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11578),
    DUNGEON_HEROES_GUILD("Heroes' Guild Mine", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11674),
    DUNGEON_IORWERTH("Iorwerth Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12737, 12738, 12993, 12994),
    DUNGEON_ISLE_OF_SOULS("Isle of Souls Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 8593),
    DUNGEON_JATIZSO_MINES("Jatizso Mines", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9631),
    DUNGEON_JIGGIG_BURIAL_TOMB("Jiggig Burial Tomb", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9875, 9874),
    DUNGEON_JOGRE("Jogre Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11412),
    DUNGEON_KARAMJA("Karamja Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11413),
    DUNGEON_KARUULM("Karuulm Slayer Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 5280, 5279, 5278, 5023, 5535, 5022, 4766, 4510, 4511, 4767, 4768, 4512),
    DUNGEON_KRUK("Kruk's Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9358, 9359, 9360, 9615, 9616, 9871, 10125, 10126, 10127, 10128, 10381, 10382, 10383, 10384, 10637, 10638, 10639, 10640),
    DUNGEON_LEGENDS_GUILD("Legends' Guild Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10904),
    DUNGEON_LIGHTHOUSE("Lighthouse", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10140),
    DUNGEON_LITHKREN("Lithkren", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 6223),
    DUNGEON_LIZARDMAN_CAVES("Lizardman Caves", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 5275),
    DUNGEON_LIZARDMAN_TEMPLE("Lizardman Temple", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 5277),
    DUNGEON_LUMBRIDGE_SWAMP_CAVES("Lumbridge Swamp Caves", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12693, 12949),
    DUNGEON_LUNAR_ISLE_MINE("Lunar Isle Mine", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9377),
    DUNGEON_MOS_LE_HARMLESS_CAVES("Mos Le'Harmless Caves", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14994, 14995, 15251),
    DUNGEON_MOURNER_TUNNELS("Mourner Tunnels", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7752, 8008),
    DUNGEON_MYREDITCH_LABORATORIES("Myreditch Laboratories", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14232, 14233, 14487, 14488),
    DUNGEON_MYTHS_GUILD("Myths' Guild Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7564, 7820, 7821),
    DUNGEON_OBSERVATORY("Observatory Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9362),
    DUNGEON_OGRE_ENCLAVE("Ogre Enclave", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10387),
    DUNGEON_OURANIA("Ourania Cave", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12119),
    DUNGEON_RASHILIYIAS_TOMB("Rashiliyta's Tomb", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11668),
    DUNGEON_SHADE_CATACOMBS("Shade Catacombs", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 13975),
    DUNGEON_SHADOW("Shadow Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10575, 10831),
    DUNGEON_SHAYZIEN_CRYPTS("Shayzien Crypts", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 6043),
    DUNGEON_SISTERHOOD_SANCTUARY("Sisterhood Sanctuary", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14999, 15000, 15001, 15255, 15256, 15257, 15511, 15512, 15513),
    DUNGEON_SLAYER_TOWER("Slayer Tower", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 13623, 13723),
    DUNGEON_SMOKE("Smoke Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12690, 12946, 13202),
    DUNGEON_SOPHANEM("Sophanem Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 13200),
    DUNGEON_SOURHOG_CAVE("Sourhog Cave", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12695),
    DUNGEON_STRONGHOLD_SECURITY("Stronghold of Security", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7505, 8017, 8530, 9297),
    DUNGEON_STRONGHOLD_SLAYER("Stronghold Slayer Cave", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9624, 9625, 9880, 9881),
    DUNGEON_TARNS_LAIR("Tarn's Lair", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12616, 12615),
    DUNGEON_TAVERLEY("Taverley Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11416, 11417, 11671, 11672, 11673, 11928, 11929),
    DUNGEON_TEMPLE_OF_IKOV("Temple of Ikov", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10649, 10905, 10650),
    DUNGEON_TEMPLE_OF_LIGHT("Temple of Light", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7496),
    DUNGEON_TEMPLE_OF_MARIMBO("Temple of Marimbo", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11151),
    DUNGEON_TOLNA("Dungeon of Tolna", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 13209),
    DUNGEON_UNDERGROUND_PASS("Underground Pass", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9369, 9370),
    DUNGEON_VIYELDI_CAVES("Viyeldi Caves", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9545, 11153),
    DUNGEON_WARRIORS_GUILD("Warriors' Guild Basement", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11675),
    DUNGEON_WATERBIRTH("Waterbirth Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 9886, 10142, 7492, 7748),
    DUNGEON_WATERFALL("Waterfall Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10394),
    DUNGEON_WHITE_WOLF_MOUNTAIN_CAVES("White Wolf Mountain Caves", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 11418, 11419),
    DUNGEON_WITCHAVEN_SHRINE("Witchhaven Shrine Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10903),
    DUNGEON_WOODCUTTING_GUILD("Woodcutting Guild Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 6298),
    DUNGEON_WYVERN_CAVE("Wyvern Cave", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14495, 14496),
    DUNGEON_YANILLE_AGILITY("Yanille Agility Dungeon", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 10388),
    DUNGEON_ZEMOUREGALS_BASE("Zemouregal's Base", EscapeCrystalNotifyRegionType.DUNGEONS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14151, 14407),
    RAIDS_CHAMBERS_OF_XERIC("Chambers of Xeric", EscapeCrystalNotifyRegionType.RAIDS, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, 12889, 13136, 13137, 13138, 13139, 13140, 13141, 13145, 13393, 13394, 13395, 13396, 13397, 13401),
    RAIDS_CHAMBERS_OF_XERIC_ENTRANCE("Chambers of Xeric Entrance", EscapeCrystalNotifyRegionType.RAIDS, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(315838), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.RAIDS_ENTRANCE_STEPS), List.of(313788, 313789, 313790, 315836, 315837, 315838, 317883, 317884, 317885), 4919),
    RAIDS_THEATRE_OF_BLOOD("Theatre of Blood", EscapeCrystalNotifyRegionType.RAIDS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 12611, 12612, 12613, 12867, 12869, 13122, 13123, 13125, 13379),
    RAIDS_THEATRE_OF_BLOOD_ENTRANCE("Theatre of Blood Entrance", EscapeCrystalNotifyRegionType.RAIDS, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(940434), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.TOB_SURFACE_RAID_ENTRANCE), List.of(938385, 938386, 938387, 940433, 940434, 940435), 14642),
    RAIDS_TOMBS_OF_AMASCUT("Tombs of Amascut", EscapeCrystalNotifyRegionType.RAIDS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14160, 14162, 14164, 14674, 14676, 15184, 15186, 15188, 15696, 15698, 15700),
    RAIDS_TOMBS_OF_AMASCUT_ENTRANCE("Tombs of Amascut Entrance", EscapeCrystalNotifyRegionType.RAIDS, EscapeCrystalNotifyRegionDeathType.UNSAFE, new EscapeCrystalNotifyRegionEntrance(EscapeCrystalNotifyRegionEntranceOverlayType.DEPRIORITIZED_WITH_HIGHLIGHT, List.of(859251, 861299), EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, ObjectID.TOA_LOBBY_RAID_ENTRY), 13454),
    RAIDS_OSMUMTENS_BURIAL_CHAMBER("Osmumten's Burial Chamber", EscapeCrystalNotifyRegionType.RAIDS, EscapeCrystalNotifyRegionDeathType.UNSAFE, 14672),
    MG_BARBARIAN_ASSAULT("Barbarian Assault", EscapeCrystalNotifyRegionType.MINIGAMES, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, 7508, 7509, 10322),
    MG_NIGHTMARE_ZONE("Nightmare Zone", EscapeCrystalNotifyRegionType.MINIGAMES, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, 9033),
    MG_PEST_CONTROL("Pest Control", EscapeCrystalNotifyRegionType.MINIGAMES, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM, 10536),
    MG_PYRAMID_PLUNDER("Pyramid Plunder", EscapeCrystalNotifyRegionType.MINIGAMES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7749),
    MG_TEMPLE_TREKKING("Temple Trekking", EscapeCrystalNotifyRegionType.MINIGAMES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 8014, 8270, 8256, 8782, 9038, 9294, 9550, 9806),
    MG_VOLCANIC_MINE("Volcanic Mine", EscapeCrystalNotifyRegionType.MINIGAMES, EscapeCrystalNotifyRegionDeathType.UNSAFE, 15263, 15262),
    TD_DONTKNOWWHAT_FIGHT("Making Friends WIth My Arm Don't Know What Fight", EscapeCrystalNotifyRegionType.TELEPORT_DISABLED, EscapeCrystalNotifyRegionDeathType.UNSAFE, Quest.MAKING_FRIENDS_WITH_MY_ARM, 11425),
    TD_EMISSARY_ENFORCER("Emissary Enforcer", EscapeCrystalNotifyRegionType.TELEPORT_DISABLED, EscapeCrystalNotifyRegionDeathType.UNSAFE, Quest.THE_FINAL_DAWN, 6807),
    TD_LUNAR_DREAMS("Lunar Dreams", EscapeCrystalNotifyRegionType.TELEPORT_DISABLED, EscapeCrystalNotifyRegionDeathType.UNSAFE, 7247, 7248),
    TD_MOVARIOS_BASE("Movario's Base", EscapeCrystalNotifyRegionType.TELEPORT_DISABLED, EscapeCrystalNotifyRegionDeathType.UNSAFE, 16461, 16717);

    @Getter
    private final String regionName;
    @Getter
    private final EscapeCrystalNotifyRegionType regionType;
    @Getter
    private final int[] regionIds;
    @Getter
    private final List<Integer> chunkIds;
    @Getter
    private final EscapeCrystalNotifyRegionDeathType regionDeathType;
    @Getter
    private final EscapeCrystalNotifyRegionEntrance regionEntrance;
    @Getter
    private final Quest questNotCompleted;

    EscapeCrystalNotifyRegion(String regionName, EscapeCrystalNotifyRegionType regionType, EscapeCrystalNotifyRegionDeathType regionDeathType, int... regionIds) {
        this.regionName = regionName;
        this.regionType = regionType;
        this.regionDeathType = regionDeathType;
        this.regionEntrance = null;
        this.questNotCompleted = null;
        this.regionIds = regionIds;
        this.chunkIds = null;
    }

    EscapeCrystalNotifyRegion(String regionName, EscapeCrystalNotifyRegionType regionType, EscapeCrystalNotifyRegionDeathType regionDeathType, List<Integer> chunkIds, int... regionIds) {
        this.regionName = regionName;
        this.regionType = regionType;
        this.regionDeathType = regionDeathType;
        this.regionEntrance = null;
        this.questNotCompleted = null;
        this.regionIds = regionIds;
        this.chunkIds = chunkIds;
    }

    EscapeCrystalNotifyRegion(String regionName, EscapeCrystalNotifyRegionType regionType, EscapeCrystalNotifyRegionDeathType regionDeathType, EscapeCrystalNotifyRegionEntrance regionEntrance, int... regionIds) {
        this.regionName = regionName;
        this.regionType = regionType;
        this.regionDeathType = regionDeathType;
        this.regionEntrance = regionEntrance;
        this.questNotCompleted = null;
        this.regionIds = regionIds;
        this.chunkIds = null;
    }

    EscapeCrystalNotifyRegion(String regionName, EscapeCrystalNotifyRegionType regionType, EscapeCrystalNotifyRegionDeathType regionDeathType, EscapeCrystalNotifyRegionEntrance regionEntrance, List<Integer> chunkIds, int... regionIds) {
        this.regionName = regionName;
        this.regionType = regionType;
        this.regionDeathType = regionDeathType;
        this.regionEntrance = regionEntrance;
        this.questNotCompleted = null;
        this.regionIds = regionIds;
        this.chunkIds = chunkIds;
    }

    EscapeCrystalNotifyRegion(String regionName, EscapeCrystalNotifyRegionType regionType, EscapeCrystalNotifyRegionDeathType regionDeathType, Quest questNotCompleted, int... regionIds) {
        this.regionName = regionName;
        this.regionType = regionType;
        this.regionDeathType = regionDeathType;
        this.regionEntrance = null;
        this.questNotCompleted = questNotCompleted;
        this.regionIds = regionIds;
        this.chunkIds = null;
    }

    public static List<Integer> getAllRegionIds() {
        return Arrays.stream(EscapeCrystalNotifyRegion.values())
                .flatMap(regionType -> Arrays.stream(regionType.getRegionIds()).boxed())
                .collect(Collectors.toList());
    }

    public static List<Integer> getAllEntranceIds() {
        return Arrays.stream(EscapeCrystalNotifyRegion.values())
                .map(EscapeCrystalNotifyRegion::getRegionEntrance)
                .filter(Objects::nonNull)
                .flatMap(entrance -> Arrays.stream(entrance.getEntranceIds()).boxed())
                .collect(Collectors.toList());
    }

    public static List<Integer> getEntranceIdsFromTypes(List<EscapeCrystalNotifyRegionEntranceObjectType> selectedEntranceTypes, List<EscapeCrystalNotifyRegionDeathType> selectedRegionDeathTypes) {
        return Arrays.stream(EscapeCrystalNotifyRegion.values())
                .filter(region -> selectedRegionDeathTypes.contains(region.getRegionDeathType()))
                .map(EscapeCrystalNotifyRegion::getRegionEntrance)
                .filter(Objects::nonNull)
                .filter(entrance -> selectedEntranceTypes.contains(entrance.getObjectType()))
                .flatMap(entrance -> Arrays.stream(entrance.getEntranceIds()).boxed())
                .collect(Collectors.toList());
    }

    public static List<Integer> getRegionIdsFromTypes(List<EscapeCrystalNotifyRegionType> selectedRegionTypes, List<EscapeCrystalNotifyRegionDeathType> selectedRegionDeathTypes) {
        return Arrays.stream(EscapeCrystalNotifyRegion.values())
                .filter(region -> selectedRegionTypes.contains(region.getRegionType()))
                .filter(region -> selectedRegionDeathTypes.contains(region.getRegionDeathType()))
                .flatMap(region -> Arrays.stream(region.getRegionIds()).boxed())
                .collect(Collectors.toList());
    }

    public static List<Integer> getRegionIdsFromRegions(List<EscapeCrystalNotifyRegion> selectedRegions) {
        return selectedRegions.stream()
                .flatMap(subRegionType -> Arrays.stream(subRegionType.getRegionIds()).boxed())
                .collect(Collectors.toList());
    }

    public static Map<Integer, EscapeCrystalNotifyRegionEntrance> getRegionEntranceMap() {
        Map<Integer, EscapeCrystalNotifyRegionEntrance> regionEntranceMap = new HashMap<>();
        for (EscapeCrystalNotifyRegion e : values()) {
            for (int regionId : e.regionIds) {
                if (e.regionEntrance != null) {
                    regionEntranceMap.put(regionId, e.regionEntrance);
                }
            }
        }
        return regionEntranceMap;
    }

    public static Map<Integer, List<Integer>> getRegionChunkRequirementsMap() {
        Map<Integer, List<Integer>> regionChunkRequirementsMap = new HashMap<>();
        for (EscapeCrystalNotifyRegion e : values()) {
            for (int regionId : e.regionIds) {
                if (e.chunkIds != null) {
                    regionChunkRequirementsMap.put(regionId, e.chunkIds);
                }
            }
        }
        return regionChunkRequirementsMap;
    }

    public static Map<Integer, EscapeCrystalNotifyRegionEntrance> getChunkEntranceMap() {
        Map<Integer, EscapeCrystalNotifyRegionEntrance> chunkEntranceMap = new HashMap<>();
        for (EscapeCrystalNotifyRegion e : values()) {
            if (e.regionEntrance != null && e.regionEntrance.chunkIds != null) {
                for (int chunkId : e.regionEntrance.getChunkIds()) {
                    chunkEntranceMap.put(chunkId, e.regionEntrance);
                }
            }
        }
        return chunkEntranceMap;
    }

    public static Set<Integer> getTeleportDisabledRegionIds() {
        return Arrays.stream(EscapeCrystalNotifyRegion.values())
                .filter(region -> region.getRegionType() == EscapeCrystalNotifyRegionType.TELEPORT_DISABLED)
                .flatMap(region -> Arrays.stream(region.getRegionIds()).boxed())
                .collect(Collectors.toSet());
    }
}
package com.escapecrystalnotify;

public enum EscapeCrystalNotifyAccountType {
    STANDARD_HARDCORE,
    GROUP_HARDCORE,
    NON_HARDCORE,
}
package com.escapecrystalnotify;

import lombok.Getter;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

public enum EscapeCrystalNotifyRegionChunkExclusions {

    LUMBRIDGE_BASEMENT(12950, 822449, 822450, 822451, 824497, 824498),
    EVIL_DAVE_BASEMENT(12442, 787666, 787667, 787668, 787669, 789714, 789715, 789716, 789717);

    @Getter
    private int regionId;
    @Getter
    private int[] chunkIds;

    EscapeCrystalNotifyRegionChunkExclusions(int regionId, int... chunkIds) {
        this.regionId = regionId;
        this.chunkIds = chunkIds;
    }

    public static HashSet<Integer> getAllExcludedRegionIds() {
        return Arrays.stream(EscapeCrystalNotifyRegionChunkExclusions.values())
                .map(EscapeCrystalNotifyRegionChunkExclusions::getRegionId)
                .collect(Collectors.toCollection(HashSet::new));
    }

    public static HashSet<Integer> getAllExcludedChunkIds() {
        return Arrays.stream(EscapeCrystalNotifyRegionChunkExclusions.values())
                .flatMap(region -> Arrays.stream(region.getChunkIds()).boxed())
                .collect(Collectors.toCollection(HashSet::new));
    }

}

package com.escapecrystalnotify;

import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import org.apache.commons.lang3.StringUtils;

import javax.inject.Inject;
import java.awt.*;


public class EscapeCrystalNotifyTextOverlayPanel extends OverlayPanel {
    private static final Font OVERLAY_PANEL_FONT = FontManager.getRunescapeSmallFont();
    private static final int OVERLAY_PANEL_WIDTH = 235;
    private static final int OVERLAY_PANEL_HEIGHT = 100;
    private static final String SIX_HOUR_WARNING_TEXT = "WARNING: You are approaching the 6-hour forced logout timer! You should re-log to avoid a potential forced death";
    private static final String LEVIATHAN_BUG_INFO_HEADER_TEXT = "WARNING: LEVIATHAN BUG";
    private static final String LEVIATHAN_BUG_INFO_TEXT = "Attempting to logout during the encounter can/will DISABLE ALL PLAYER ACTIONS (teleports, prayers, food, etc...) and cause an UNAVOIDABLE DEATH";
    private static final String LEVIATHAN_LOGOUT_STATUS_DEPRIORITIZED_TEXT_SHORT = "Right-Click Required";
    private static final String LEVIATHAN_LOGOUT_STATUS_HEADER_TEXT = "Current Logout Setting:";
    private static final String LEVIATHAN_LOGOUT_STATUS_PRIORITIZED_TEXT_SHORT = "Left-Click";
    private static final String LEVIATHAN_LOGOUT_STATUS_PRIORITIZED_TEXT_SHORT_ADDITIONAL_INFO = "NOT PROTECTED";
    private static final String LEVIATHAN_INSTRUCTION_TEXT = "Navigate to the 'Leviathan Safeguards' section in the 'Escape Crystal Notify' settings to enable left-click logout prevention and/or hide this panel";
    private static final String DOOM_BUG_INFO_HEADER_TEXT = "WARNING: DOOM BUG";
    private static final String DOOM_BUG_INFO_TEXT = "Attempting to logout during the encounter can/will DISABLE ALL PLAYER ACTIONS (teleports, prayers, food, etc...) and cause an UNAVOIDABLE DEATH";
    private static final String DOOM_LOGOUT_STATUS_DEPRIORITIZED_TEXT_SHORT = "Right-Click Required";
    private static final String DOOM_LOGOUT_STATUS_DEPRIORITIZED_TEXT_ADDITIONAL_INFO = "Left-Click enabled between floors";
    private static final String DOOM_LOGOUT_STATUS_HEADER_TEXT = "Current Logout Setting:";
    private static final String DOOM_LOGOUT_STATUS_PRIORITIZED_TEXT_SHORT = "Left-Click";
    private static final String DOOM_LOGOUT_STATUS_PRIORITIZED_TEXT_SHORT_ADDITIONAL_INFO = "NOT PROTECTED";
    private static final String DOOM_INSTRUCTION_TEXT = "Navigate to the 'Doom Safeguards' section in the 'Escape Crystal Notify' settings to enable left-click logout prevention and/or hide this panel";

    private final EscapeCrystalNotifyPlugin plugin;
    private final EscapeCrystalNotifyConfig config;

    @Inject
    EscapeCrystalNotifyTextOverlayPanel(EscapeCrystalNotifyPlugin plugin, EscapeCrystalNotifyConfig config) throws PluginInstantiationException {
        super(plugin);

        setPosition(OverlayPosition.TOP_RIGHT);
        setPriority(OverlayPriority.HIGH);

        this.plugin = plugin;
        this.config = config;
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isLeviathanSafeguardPanelEnabled() && !plugin.isDoomSafeguardPanelEnabled()) return null;

        String bugInfoHeaderText = null;
        String bugInfoText = null;
        String logoutStatusHeaderText = null;
        String logoutStatusText = null;
        String logoutStatusAdditionalText = null;
        Color logoutStatusTextColor = null;
        String sixHourWarningText = null;
        String instructionText = null;

        if (plugin.isLeviathanSafeguardPanelEnabled()) {
            if (!config.hideLeviathanBugInfoText()) {
                bugInfoHeaderText = LEVIATHAN_BUG_INFO_HEADER_TEXT;
                bugInfoText = LEVIATHAN_BUG_INFO_TEXT;
            }

            if (!config.hideLeviathanLogoutSettingText()) {
                logoutStatusHeaderText = LEVIATHAN_LOGOUT_STATUS_HEADER_TEXT;

                if (config.deprioritizeLeviathanLogout()) {
                    logoutStatusText = LEVIATHAN_LOGOUT_STATUS_DEPRIORITIZED_TEXT_SHORT;
                    logoutStatusTextColor = Color.GREEN;
                } else {
                    logoutStatusText = LEVIATHAN_LOGOUT_STATUS_PRIORITIZED_TEXT_SHORT;
                    logoutStatusAdditionalText = LEVIATHAN_LOGOUT_STATUS_PRIORITIZED_TEXT_SHORT_ADDITIONAL_INFO;
                    logoutStatusTextColor = JagexColors.CHAT_FC_TEXT_TRANSPARENT_BACKGROUND;
                }
            };

            if (config.warnLeviathanLogoutTimer()) sixHourWarningText = SIX_HOUR_WARNING_TEXT;
            if (!config.hideLeviathanSettingsInstructionText()) instructionText = LEVIATHAN_INSTRUCTION_TEXT;
        } else if (plugin.isDoomSafeguardPanelEnabled()) {
            if (!config.hideDoomBugInfoText()) {
                bugInfoHeaderText = DOOM_BUG_INFO_HEADER_TEXT;
                bugInfoText = DOOM_BUG_INFO_TEXT;
            }

            if (!config.hideDoomLogoutSettingText()) {
                logoutStatusHeaderText = DOOM_LOGOUT_STATUS_HEADER_TEXT;

                if (config.deprioritizeDoomLogout()) {
                    logoutStatusText = DOOM_LOGOUT_STATUS_DEPRIORITIZED_TEXT_SHORT;
                    logoutStatusAdditionalText = DOOM_LOGOUT_STATUS_DEPRIORITIZED_TEXT_ADDITIONAL_INFO;
                    logoutStatusTextColor = Color.GREEN;
                } else {
                    logoutStatusText = DOOM_LOGOUT_STATUS_PRIORITIZED_TEXT_SHORT;
                    logoutStatusAdditionalText = DOOM_LOGOUT_STATUS_PRIORITIZED_TEXT_SHORT_ADDITIONAL_INFO;
                    logoutStatusTextColor = JagexColors.CHAT_FC_TEXT_TRANSPARENT_BACKGROUND;
                }
            }

            if (config.warnDoomLogoutTimer()) sixHourWarningText = SIX_HOUR_WARNING_TEXT;
            if (!config.hideDoomSettingsInstructionText()) instructionText = DOOM_INSTRUCTION_TEXT;
        } else {
            return null;
        }

        final FontMetrics metrics = graphics.getFontMetrics(OVERLAY_PANEL_FONT);

        LineComponent newLineComponent = LineComponent.builder().left("\n").build();

        panelComponent.setPreferredSize(new Dimension(OVERLAY_PANEL_WIDTH, OVERLAY_PANEL_HEIGHT));
        panelComponent.getChildren().clear();

        if (bugInfoText != null) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(getCenteredText(bugInfoHeaderText, metrics))
                    .leftFont(OVERLAY_PANEL_FONT)
                    .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                    .build());

            panelComponent.getChildren().add(LineComponent.builder()
                    .left(bugInfoText)
                    .leftFont(OVERLAY_PANEL_FONT)
                    .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                    .build());
        }

        if (logoutStatusHeaderText != null) {
            if (!panelComponent.getChildren().isEmpty()) {
                panelComponent.getChildren().add(newLineComponent);
            }

            LineComponent.LineComponentBuilder logoutStatusComponent = LineComponent.builder()
                    .left(logoutStatusHeaderText)
                    .leftColor(JagexColors.DARK_ORANGE_INTERFACE_TEXT)
                    .leftFont(OVERLAY_PANEL_FONT);

            logoutStatusComponent
                    .right(logoutStatusText)
                    .rightColor(logoutStatusTextColor)
                    .rightFont(OVERLAY_PANEL_FONT);

            panelComponent.getChildren().add(logoutStatusComponent.build());

            if (logoutStatusAdditionalText != null) {
                panelComponent.getChildren().add(LineComponent.builder()
                        .right(logoutStatusAdditionalText)
                        .rightFont(OVERLAY_PANEL_FONT)
                        .rightColor(logoutStatusTextColor)
                        .build());
            }
        }

        if (sixHourWarningText != null && plugin.isCloseToSixHourLogout()) {
            if (!panelComponent.getChildren().isEmpty()) {
                panelComponent.getChildren().add(newLineComponent);
            }

            panelComponent.getChildren().add(LineComponent.builder()
                    .left(SIX_HOUR_WARNING_TEXT)
                    .leftFont(OVERLAY_PANEL_FONT)
                    .leftColor(JagexColors.CHAT_FC_TEXT_TRANSPARENT_BACKGROUND)
                    .build());
        }

        if (instructionText != null) {
            if (!panelComponent.getChildren().isEmpty()) {
                panelComponent.getChildren().add(newLineComponent);
            }

            panelComponent.getChildren().add(LineComponent.builder()
                    .left(instructionText)
                    .leftFont(OVERLAY_PANEL_FONT)
                    .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                    .build());
        }

        return panelComponent.render(graphics);
    }

    private static String getCenteredText(String text, FontMetrics metrics) {
        int spaceWidth = metrics.stringWidth(" ");
        int remainingWidth = OVERLAY_PANEL_WIDTH - metrics.stringWidth(text);
        int requiredSpaces = remainingWidth / spaceWidth;
        int characterCount = text.length() + requiredSpaces;
        return StringUtils.center(text, characterCount);
    }
}

package com.escapecrystalnotify;

public enum EscapeCrystalNotifyRegionType {
    BOSSES,
    RAIDS,
    DUNGEONS,
    MINIGAMES,
    GLOBAL,
    TELEPORT_DISABLED,
}

package com.escapecrystalnotify;

import lombok.Getter;

@Getter
public enum EscapeCrystalNotifyRegionEntrancePlaneLevel {
    ANY(null),
    GROUND(0),
    FIRST_FLOOR(1),
    SECOND_FLOOR(2),
    THIRD_FLOOR(3);

    private final Integer planeLevel;

    EscapeCrystalNotifyRegionEntrancePlaneLevel(Integer planeLevel) {
        this.planeLevel = planeLevel;
    }

    public boolean matchesPlane(int playerPlane) {
        return this.planeLevel == null || this.planeLevel == playerPlane;
    }
}

package com.escapecrystalnotify;

import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;

public class EscapeCrystalNotifyInfoBox extends InfoBox {
    private final EscapeCrystalNotifyPlugin plugin;
    private final EscapeCrystalNotifyConfig config;
    public int imageId;

    EscapeCrystalNotifyInfoBox(int imageId, BufferedImage image, EscapeCrystalNotifyPlugin plugin, EscapeCrystalNotifyConfig config) {
        super(image, plugin);
        this.plugin = plugin;
        this.config = config;
        this.imageId = imageId;
    }

    @Override
    public String getText() {
        return this.plugin.getItemModelDisplayText(this.config.infoBoxDisplayFormat(), this.config.infoBoxInactivityTimeFormat(), this.config.infoBoxTimeExpiredText());
    }

    @Override
    public Color getTextColor() {
        return this.plugin.getItemModelDisplayTextColor(this.config.infoBoxDisplayFormat());
    }

    @Override
    public boolean render() {
        boolean atNotifyRegion;

        if (this.plugin.isAtNotifyRegionId()) {
            atNotifyRegion = true;
        } else {
            atNotifyRegion = this.config.alwaysDisplayInfoBox();
        }

        return this.config.enableInfoBox() && atNotifyRegion;
    }

}

package com.escapecrystalnotify;

import lombok.Getter;

import java.util.HashMap;
import java.util.Map;

public enum EscapeCrystalNotifyRegionPlaneRequirements {

    PERILOUS_MOONS_DUNGEON(0, 5525, 5526, 5527, 5528, 5783, 6037, 6038, 6039);

    private int plane;
    @Getter
    private int[] regionIds;

    EscapeCrystalNotifyRegionPlaneRequirements(int plane, int... regionIds) {
        this.plane = plane;
        this.regionIds = regionIds;
    }

    public static Map<Integer, Integer> getRegionPlaneMap() {
        Map<Integer, Integer> regionPlaneMap = new HashMap<>();
        for (EscapeCrystalNotifyRegionPlaneRequirements e : values()) {
            for (int regionId : e.regionIds) {
                regionPlaneMap.put(regionId, e.plane);
            }
        }
        return regionPlaneMap;
    }

}

package com.escapecrystalnotify;

import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.time.format.DateTimeFormatter;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;
import java.util.Map;


@Slf4j
public class EscapeCrystalNotifyTestingOverlay extends OverlayPanel {
    private static final Font OVERLAY_PANEL_FONT = FontManager.getRunescapeSmallFont();
    private static final Font OVERLAY_PANEL_HEADER_FONT = FontManager.getRunescapeFont();
    private static final int OVERLAY_PANEL_WIDTH = 400;
    private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss");

    private final EscapeCrystalNotifyPlugin plugin;
    private final EscapeCrystalNotifyConfig config;

    @Inject
    public EscapeCrystalNotifyTestingOverlay(EscapeCrystalNotifyPlugin plugin, EscapeCrystalNotifyConfig config) throws PluginInstantiationException {
        super(plugin);
        this.plugin = plugin;
        this.config = config;
        
        setPosition(OverlayPosition.TOP_LEFT);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.enableDebugMode()) {
            return null;
        }

        panelComponent.getChildren().clear();
        panelComponent.setPreferredSize(new Dimension(OVERLAY_PANEL_WIDTH, 50));

        int totalHeight = 0;

        if (config.showPlayerLocationSection()) {
            totalHeight += renderPlayerLocationSection();
        }

        if (config.showEscapeCrystalSection()) {
            totalHeight += renderEscapeCrystalSection();
        }

        if (config.showAccountInfoSection()) {
            totalHeight += renderAccountInfoSection();
        }

        if (config.showPossibleEntrancesSection()) {
            totalHeight += renderPossibleEntrancesSection();
        }

        if (config.showValidEntrancesSection()) {
            totalHeight += renderValidEntrancesSection();
        }

        if (config.showSpecialRegionSection()) {
            totalHeight += renderSpecialRegionSection();
        }

        if (config.showNotificationSection()) {
            totalHeight += renderNotificationSection();
        }

        panelComponent.setPreferredSize(new Dimension(OVERLAY_PANEL_WIDTH, totalHeight + 20));

        return panelComponent.render(graphics);
    }

    private int renderPlayerLocationSection() {
        int height = 0;
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("PLAYER LOCATION")
                .leftFont(OVERLAY_PANEL_HEADER_FONT)
                .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                .build());
        height += 20;

        WorldPoint worldPoint = plugin.getCurrentWorldPoint();
        String worldPointText = worldPoint != null ? 
            String.format("(%d, %d, %d)", worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane()) : "null";
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("World Point:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(worldPointText)
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Region ID:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getCurrentRegionId()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Plane:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getCurrentPlaneId()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Chunk ID:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getCurrentChunkId()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("At Notify Region:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isAtNotifyRegionId()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isAtNotifyRegionId() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("At Notify Entrance:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isAtNotifyRegionEntrance()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isAtNotifyRegionEntrance() ? Color.GREEN : Color.RED)
                .build());
        height += 20; 

        return height;
    }

    private int renderEscapeCrystalSection() {
        int height = 0;
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("ESCAPE CRYSTAL STATUS")
                .leftFont(OVERLAY_PANEL_HEADER_FONT)
                .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                .build());
        height += 20;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("With Player:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isEscapeCrystalWithPlayer()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isEscapeCrystalWithPlayer() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Active:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isEscapeCrystalActive()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isEscapeCrystalActive() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Ring of Life:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isEscapeCrystalRingOfLifeActive()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isEscapeCrystalRingOfLifeActive() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Left Click Teleport:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isEscapeCrystalLeftClickTeleportEnabled()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isEscapeCrystalLeftClickTeleportEnabled() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Inactivity Ticks:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getEscapeCrystalInactivityTicks()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Expected Ticks Until Teleport:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getExpectedTicksUntilTeleport()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.getExpectedTicksUntilTeleport() <= 0 ? Color.RED : Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Client Inactivity Ticks:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getClientInactivityTicks()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Expected Server Inactivity:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getExpectedServerInactivityTicks()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 20; 

        return height;
    }

    private int renderAccountInfoSection() {
        int height = 0;
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("ACCOUNT INFORMATION")
                .leftFont(OVERLAY_PANEL_HEADER_FONT)
                .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                .build());
        height += 20;

        String accountTypeText = plugin.getAccountType().toString();
        boolean isOverridden = config.testingAccountTypeOverride() != EscapeCrystalNotifyConfig.TestingAccountType.DEFAULT;
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Account Type:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(accountTypeText + (isOverridden ? " (OVERRIDDEN)" : ""))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(isOverridden ? Color.ORANGE : Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Hardcore:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isHardcoreAccountType()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isHardcoreAccountType() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Ticks Since Login:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getTicksSinceLogin()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 15;

        String loginTimeText = plugin.getLoginTime() != null ? 
            LocalDateTime.ofInstant(plugin.getLoginTime(), ZoneId.systemDefault()).format(TIME_FORMATTER) : "null";
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Login Time:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(loginTimeText)
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 20; 

        return height;
    }

    private int renderPossibleEntrancesSection() {
        int height = 0;
        
        Map<Integer, List<EscapeCrystalNotifyLocatedEntrance>> possibleEntrances = plugin.getPossibleEntrances();
        int totalCount = possibleEntrances.values().stream().mapToInt(List::size).sum();
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("POSSIBLE ENTRANCES (" + totalCount + ")")
                .leftFont(OVERLAY_PANEL_HEADER_FONT)
                .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                .build());
        height += 20;

        if (possibleEntrances.isEmpty()) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("None")
                    .leftFont(OVERLAY_PANEL_FONT)
                    .leftColor(Color.WHITE)
                    .build());
            height += 15;
        } else {
            for (Map.Entry<Integer, List<EscapeCrystalNotifyLocatedEntrance>> entry : possibleEntrances.entrySet()) {
                int regionId = entry.getKey();
                List<EscapeCrystalNotifyLocatedEntrance> entrances = entry.getValue();
                
                panelComponent.getChildren().add(LineComponent.builder()
                        .left("Region " + regionId + " (" + entrances.size() + " entrances):")
                        .leftFont(OVERLAY_PANEL_FONT)
                        .leftColor(JagexColors.DARK_ORANGE_INTERFACE_TEXT)
                        .build());
                height += 15;
                
                for (EscapeCrystalNotifyLocatedEntrance entrance : entrances) {
                    try {
                        String entranceInfo = entrance.getTarget().getId() + 
                                            " at " + formatWorldPoint(entrance.getTarget().getWorldLocation()) +
                                            " (Valid: " + entrance.isEntranceInValidChunk() +
                                            ", Moved: " + entrance.hasMoved() +
                                            ", Past: " + entrance.isPlayerPastEntrance(plugin.getCurrentWorldPoint()) +
                                            ", Plane Match: " + entrance.matchesPlayerPlane(plugin.getCurrentPlaneId()) + ")";
                        
                        panelComponent.getChildren().add(LineComponent.builder()
                            .left("  - " + entranceInfo)
                            .leftFont(OVERLAY_PANEL_FONT)
                            .leftColor(Color.WHITE)
                            .build());
                        height += 15;
                    } catch (Exception ignored) {
                        log.debug("Target={}, Definition={}, Initial World Point={}, Initial Target Id={}", entrance.getTarget(), entrance.getDefinition(), entrance.getInitialWorldPoint(), entrance.getInitialTargetId());
                    }
                }
            }
        }
        height += 20;

        return height;
    }

    private int renderValidEntrancesSection() {
        int height = 0;
        
        List<EscapeCrystalNotifyLocatedEntrance> validEntrances = plugin.getValidEntrances();
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("VALID ENTRANCES (" + validEntrances.size() + ")")
                .leftFont(OVERLAY_PANEL_HEADER_FONT)
                .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                .build());
        height += 20;

        if (validEntrances.isEmpty()) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("None")
                    .leftFont(OVERLAY_PANEL_FONT)
                    .leftColor(Color.WHITE)
                    .build());
            height += 15;
        } else {
            for (EscapeCrystalNotifyLocatedEntrance entrance : validEntrances) {
                try {
                    String validInfo = entrance.getTarget().getId() + 
                                    " at " + formatWorldPoint(entrance.getTarget().getWorldLocation()) +
                                    " (Can Highlight: " + entrance.canHighlight() +
                                    ", Can Deprioritize: " + entrance.canDeprioritize() +
                                    ", Prioritized: " + entrance.isPrioritized() + ")";
                    
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left("- " + validInfo)
                            .leftFont(OVERLAY_PANEL_FONT)
                            .leftColor(Color.WHITE)
                            .build());
                    height += 15;
                } catch (Exception ignored) {
                    log.debug("Target={}, Definition={}, Initial World Point={}, Initial Target Id={}", entrance.getTarget(), entrance.getDefinition(), entrance.getInitialWorldPoint(), entrance.getInitialTargetId());
                }
            }
        }
        height += 20; 

        return height;
    }

    private int renderSpecialRegionSection() {
        int height = 0;
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("SPECIAL REGION STATUS")
                .leftFont(OVERLAY_PANEL_HEADER_FONT)
                .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                .build());
        height += 20;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("At Leviathan Region:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isAtLeviathanRegionId()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isAtLeviathanRegionId() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("At Leviathan Lobby:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isAtLeviathanLobby()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isAtLeviathanLobby() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("At Doom Region:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isAtDoomRegionId()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isAtDoomRegionId() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("At Doom Lobby:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isAtDoomLobby()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isAtDoomLobby() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Doom Floor Cleared:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isDoomFloorCleared()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isDoomFloorCleared() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Western Elite Diary Done:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isCompletedWesternEliteDiary()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isCompletedWesternEliteDiary() ? Color.GREEN : Color.RED)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Zulrah Revive Active:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(!plugin.hasDiedAtZulrah()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.hasDiedAtZulrah() ? Color.RED : Color.GREEN)
                .build());
        height += 20;

        return height;
    }

    private int renderNotificationSection() {
        int height = 0;
        
        panelComponent.getChildren().add(LineComponent.builder()
                .left("NOTIFICATION STATUS")
                .leftFont(OVERLAY_PANEL_HEADER_FONT)
                .leftColor(JagexColors.YELLOW_INTERFACE_TEXT)
                .build());
        height += 20;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("In Time Remaining Threshold:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.isInTimeRemainingThreshold()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(plugin.isInTimeRemainingThreshold() ? Color.RED : Color.WHITE)
                .build());
        height += 15;

        panelComponent.getChildren().add(LineComponent.builder()
                .left("Time Remaining Threshold Ticks:")
                .leftFont(OVERLAY_PANEL_FONT)
                .leftColor(Color.WHITE)
                .right(String.valueOf(plugin.getTimeRemainingThresholdTicks()))
                .rightFont(OVERLAY_PANEL_FONT)
                .rightColor(Color.WHITE)
                .build());
        height += 20; 

        return height;
    }

    private String formatWorldPoint(WorldPoint worldPoint) {
        if (worldPoint == null) return "null";
        return String.format("(region=%d, x=%d, y=%d, plane=%d)", worldPoint.getRegionID(), worldPoint.getX(), worldPoint.getY(), worldPoint.getPlane());
    }
}

package com.escapecrystalnotify;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "Escape Crystal Notify"
)
public class EscapeCrystalNotifyPlugin extends Plugin
{
	private static final int ESCAPE_CRYSTAL_ACTIVE_VARBIT = VarbitID.TELEPORT_CRYSTAL_AFK_MODE;
	private static final int ESCAPE_CRYSTAL_INACTIVITY_TICKS_VARBIT = VarbitID.TELEPORT_CRYSTAL_AFK_DELAY;
	private static final int ESCAPE_CRYSTAL_RING_OF_LIFE_ACTIVE_VARBIT = VarbitID.TELEPORT_CRYSTAL_ROL;
	private static final int ITEMS_STORED_VARBIT = VarbitID.HOLDING_INVENTORY_LOCATION;
	private static final int STANDARD_HARDCORE_ACCOUNT_TYPE_VARBIT_VALUE = 3;
	private static final int GROUP_HARDCORE_ACCOUNT_TYPE_VARBIT_VALUE = 5;
	private static final int ZULRAH_REVIVE_VARBIT = VarbitID.ZULRAH_REVIVE;
	private static final int ZULRAH_ENTRANCE_REGION_ID = 8751;
	private static final int YAMA_REGION_ID = 6045;
	private static final HashSet<Integer> LEVIATHAN_LOBBY_CHUNK_IDS = new HashSet<>(List.of(525092, 525093, 527139, 527140, 527141, 529188));
	private static final HashSet<Integer> DOOM_LOBBY_CHUNK_IDS = new HashSet<>(List.of(335016, 335017, 335018, 337064, 337065, 337066));
	private static final HashSet<Integer> DOOM_BURROW_HOLE_IDS = new HashSet<>(List.of(ObjectID.DOM_DESCEND_HOLE, ObjectID.DOM_DESCEND_HOLE_UNIQUE));
	private static final HashSet<Integer> DOOM_NPC_IDS = new HashSet<>(List.of(NpcID.DOM_BOSS, NpcID.DOM_BOSS_SHIELDED, NpcID.DOM_BOSS_BURROWED));
	private static final HashSet<Integer> HYDRA_ENTRANCE_IDS = new HashSet<>(List.of(34553, 34554));
	private static final HashSet<Integer> ENTRANCE_CLEAR_REQUIRED_IDS = new HashSet<>(List.of(ObjectID.INFERNO_ENTRANCE, ObjectID.TZHAAR_FIGHTCAVE_WALL_ENTRANCE));
	private static final HashSet<Integer> NPC_ENTRANCE_FORCE_CLEAR_IDS = new HashSet<>(List.of(NpcID.NIGHTMARE_ENTRY_READY, NpcID.NIGHTMARE_ENTRY_OPEN, NpcID.NIGHTMARE_ENTRY_CLOSED_01, NpcID.NIGHTMARE_ENTRY_CLOSED_02, NpcID.NIGHTMARE_ENTRY_CLOSED_03, NpcID.VOICE_OF_YAMA_3OP));
	private static final HashSet<Integer> NPC_ENTRANCE_AUTO_RECHECK_ON_LOAD_REGION_IDS = new HashSet<>(List.of(6045, 15256));
	private static final HashSet<Integer> NPC_ENTRANCE_AUTO_RECHECK_ON_LOAD_NPC_IDS = new HashSet<>(List.of(NpcID.NIGHTMARE_ENTRY_READY, NpcID.NIGHTMARE_ENTRY_OPEN, NpcID.NIGHTMARE_ENTRY_CLOSED_01, NpcID.NIGHTMARE_ENTRY_CLOSED_02, NpcID.NIGHTMARE_ENTRY_CLOSED_03, NpcID.YAMA_THRONE_OCCUPIED));
	private static final int SIX_HOUR_LOG_WARNING_THRESHOLD_TICKS = 34000;

	@Inject
	private Notifier notifier;
	@Inject
	private Client client;
	@Inject
	private ConfigManager configManager;

	@Inject
	private EscapeCrystalNotifyConfig config;

	@Inject
	private EscapeCrystalNotifyOverlayActive escapeCrystalNotifyOverlayActive;

	@Inject
	private EscapeCrystalNotifyOverlayInactive escapeCrystalNotifyOverlayInactive;

	@Inject
	private EscapeCrystalNotifyInventoryOverlay escapeCrystalNotifyInventoryOverlay;

	@Inject
	private EscapeCrystalNotifyTextOverlayPanel escapeCrystalNotifyTextOverlayPanel;

	@Inject
	private EscapeCrystalNotifyTeleportDisabledPanel escapeCrystalNotifyTeleportDisabledPanel;

	@Inject
	private EscapeCrystalNotifyRegionEntranceOverlay escapeCrystalNotifyRegionEntranceOverlay;

	@Inject
	private EscapeCrystalNotifyTestingOverlay escapeCrystalNotifyTestingOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Getter
	private Instant loginTime;

	@Getter
	private int ticksSinceLogin;

	@Getter
	private Instant lastCombatTime;

	private boolean ready;
	private boolean recheckLocalNpcs = false;
	private boolean notifyMissing = false;
	private boolean notifyInactive = false;
	private boolean notifyTimeRemainingThreshold = false;
	private boolean notifyNonLeftClickTeleport = false;
	private String notifyTimeRemainingThresholdMessage;
	@Getter
	private EscapeCrystalNotifyAccountType accountType = EscapeCrystalNotifyAccountType.NON_HARDCORE;
	@Getter
	private boolean hardcoreAccountType = false;
	@Getter
	private boolean completedWesternEliteDiary = false;
	@Getter
	private boolean escapeCrystalWithPlayer = true;
	@Getter
	private boolean escapeCrystalActive = true;
	@Getter
	private boolean escapeCrystalRingOfLifeActive = true;
	@Getter
	private boolean escapeCrystalLeftClickTeleportEnabled = true;
	@Getter
	private int escapeCrystalInactivityTicks;
	@Getter
	private int clientInactivityTicks;
	@Getter
	private int expectedServerInactivityTicks = 0;
	@Getter
	private int expectedTicksUntilTeleport;
	@Getter
	private WorldPoint currentWorldPoint;
	@Getter
	private int currentRegionId;
	@Getter
	private boolean atLeviathanRegionId = false;
	@Getter
	private boolean atLeviathanLobby = false;
	@Getter
	private boolean atDoomRegionId = false;
	@Getter
	private boolean atDoomLobby = false;
	@Getter
	private boolean doomFloorCleared = false;
	@Getter
	private boolean inTzhaarEntranceRegion = false;
	@Getter
	private boolean atTeleportDisabledRegion = false;
	@Getter
	private int timeRemainingThresholdTicks;
	@Getter
	private boolean inTimeRemainingThreshold = false;
	@Getter
	private boolean previouslyInTimeRemainingThreshold = false;
	@Getter
	private boolean enteredTimeRemainingThreshold = false;
	@Getter
	private int currentPlaneId;
	@Getter
	private int currentChunkId;
	@Getter
	private Map<Integer, List<EscapeCrystalNotifyLocatedEntrance>> possibleEntrances = new HashMap<>();
	@Getter
	private boolean testingModeEnabled = false;
	private int previousRegionId;
	private boolean enteredNotifyRegionId = false;
	@Getter
	private boolean atNotifyRegionId = false;
	private boolean previouslyAtNotifyRegionId = false;
	@Getter
	private boolean atNotifyRegionEntrance = false;
	@Getter
	private List<EscapeCrystalNotifyLocatedEntrance> validEntrances = new ArrayList<>();
	private Set<Integer> targetRegionIds;
	private Set<Integer> npcEntranceIds;
	private Set<Integer> gameObjectEntranceIds;
	private final HashSet<Integer> excludedRegionIds = EscapeCrystalNotifyRegionChunkExclusions.getAllExcludedRegionIds();
	private final HashSet<Integer> excludedChunkIds = EscapeCrystalNotifyRegionChunkExclusions.getAllExcludedChunkIds();
	private final Map<Integer, Integer> planeRequirements = EscapeCrystalNotifyRegionPlaneRequirements.getRegionPlaneMap();
	private final Map<Integer, List<Integer>> chunkRequirements = EscapeCrystalNotifyRegion.getRegionChunkRequirementsMap();
	private final Map<Integer, EscapeCrystalNotifyRegionEntrance> chunkEntranceMap = EscapeCrystalNotifyRegion.getChunkEntranceMap();
	private final Set<Integer> leviathanRegionIds = new HashSet<>(Arrays.stream(EscapeCrystalNotifyRegion.BOSS_THE_LEVIATHAN.getRegionIds()).boxed().collect(Collectors.toList()));
	private final Set<Integer> doomRegionIds = new HashSet<>(Arrays.stream(EscapeCrystalNotifyRegion.BOSS_DOOM_OF_MOKHAIOTL.getRegionIds()).boxed().collect(Collectors.toList()));
	private final Set<Integer> infernoEntranceRegionIds = new HashSet<>(Arrays.stream(EscapeCrystalNotifyRegion.BOSS_INFERNO_ENTRANCE.getRegionIds()).boxed().collect(Collectors.toList()));
	private final Set<Integer> fightCavesEntranceRegionIds = new HashSet<>(Arrays.stream(EscapeCrystalNotifyRegion.BOSS_TZHAAR_FIGHT_CAVES_ENTRANCE.getRegionIds()).boxed().collect(Collectors.toList()));
	private final Set<Integer> whispererEntranceRegionIds = new HashSet<>(Arrays.stream(EscapeCrystalNotifyRegion.BOSS_THE_WHISPERER.getRegionIds()).boxed().collect(Collectors.toList()));
	private final Set<Integer> hydraEntranceRegionIds = new HashSet<>(Arrays.stream(EscapeCrystalNotifyRegion.BOSS_HYDRA.getRegionIds()).boxed().collect(Collectors.toList()));
	private final Set<Integer> zulrahRegionIds = new HashSet<>(Arrays.stream(EscapeCrystalNotifyRegion.BOSS_ZULRAH.getRegionIds()).boxed().collect(Collectors.toList()));
	private final Set<Integer> zulrahEntranceRegionIds = new HashSet<>(Arrays.stream(EscapeCrystalNotifyRegion.BOSS_ZULRAH_ENTRANCE.getRegionIds()).boxed().collect(Collectors.toList()));
	private final Set<Integer> teleportDisabledRegionIds = EscapeCrystalNotifyRegion.getTeleportDisabledRegionIds();
	private Set<Integer> tzhaarEntranceRegionIds = new HashSet<>();
	private Set<Integer> logoutBugRegionIds = new HashSet<>();
	private BufferedImage inactiveEscapeCrystalImage;
	private BufferedImage activeEscapeCrystalImage;
	private BufferedImage bankFillerImage;
	private BufferedImage entranceOverlayImage;
	private EscapeCrystalNotifyInfoBox activeInfoBox;

	@Override
	protected void startUp() throws Exception
	{
		this.targetRegionIds = getTargetRegionIdsFromConfig(this.accountType);
		this.npcEntranceIds = new HashSet<>(EscapeCrystalNotifyRegion.getEntranceIdsFromTypes(List.of(EscapeCrystalNotifyRegionEntranceObjectType.NPC, EscapeCrystalNotifyRegionEntranceObjectType.ANY), getTargetDeathTypes(this.accountType)));
		this.gameObjectEntranceIds = new HashSet<>(EscapeCrystalNotifyRegion.getEntranceIdsFromTypes(List.of(EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, EscapeCrystalNotifyRegionEntranceObjectType.ANY), getTargetDeathTypes(this.accountType)));

		this.notifyTimeRemainingThresholdMessage = generateTimeRemainingThresholdMessage();
		this.timeRemainingThresholdTicks = normalizeTimeRemainingThresholdValue();

		this.logoutBugRegionIds.addAll(leviathanRegionIds);
		this.logoutBugRegionIds.addAll(doomRegionIds);

		this.tzhaarEntranceRegionIds.addAll(fightCavesEntranceRegionIds);
		this.tzhaarEntranceRegionIds.addAll(infernoEntranceRegionIds);

		this.possibleEntrances.clear();

		overlayManager.add(escapeCrystalNotifyOverlayActive);
		overlayManager.add(escapeCrystalNotifyOverlayInactive);
		overlayManager.add(escapeCrystalNotifyInventoryOverlay);
		overlayManager.add(escapeCrystalNotifyTextOverlayPanel);
		overlayManager.add(escapeCrystalNotifyTeleportDisabledPanel);
		overlayManager.add(escapeCrystalNotifyRegionEntranceOverlay);
		overlayManager.add(escapeCrystalNotifyTestingOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		this.possibleEntrances.clear();
		overlayManager.remove(escapeCrystalNotifyOverlayActive);
		overlayManager.remove(escapeCrystalNotifyOverlayInactive);
		overlayManager.remove(escapeCrystalNotifyInventoryOverlay);
		overlayManager.remove(escapeCrystalNotifyTextOverlayPanel);
		overlayManager.remove(escapeCrystalNotifyTeleportDisabledPanel);
		overlayManager.remove(escapeCrystalNotifyRegionEntranceOverlay);
		overlayManager.remove(escapeCrystalNotifyTestingOverlay);
		removeInfoBoxes();
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		ticksSinceLogin++;
		computeAccountTypeMetrics();
		computeLocationMetrics();
		computeEscapeCrystalMetrics();
		computeNotificationMetrics();

		if (this.config.enableInfoBox() && isAccountTypeEnabled()) {
			createInfoBox();
		} else {
			removeInfoBoxes();
		}

		sendRequestedNotifications();
	}

	@Subscribe
	public void onPostMenuSort(PostMenuSort e) {
		boolean inLeviathanEncounter = config.deprioritizeLeviathanLogout() && this.atLeviathanRegionId && !this.atLeviathanLobby;
		boolean inDoomEncounter = config.deprioritizeDoomLogout() && this.atDoomRegionId && !this.atDoomLobby && !this.doomFloorCleared;

		if (inLeviathanEncounter || inDoomEncounter) {
			deprioritizeLogoutButton();
		}

		if (this.shouldDeprioritizeEntranceEnterOption()) {
			deprioritizeEnterOption();
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		GameObject spawnedObject = event.getGameObject();
		int spawnedObjectId = spawnedObject.getId();

		if (this.gameObjectEntranceIds.contains(spawnedObjectId)) {
			WorldPoint locatedWorldPoint = resolvePossiblyInstancedWorldPoint(spawnedObject.getWorldLocation(), spawnedObject.getLocalLocation());
			int locatedChunkId = computeChunkIdFromWorldPoint(locatedWorldPoint);

			if (ENTRANCE_CLEAR_REQUIRED_IDS.contains(spawnedObjectId)) {
				clearPossibleEntranceId(spawnedObjectId);
			}

			possibleEntrances.computeIfAbsent(locatedWorldPoint.getRegionID(), k -> new ArrayList<>()).add(
					new EscapeCrystalNotifyLocatedEntrance(
							new EscapeCrystalNotifyRegionEntranceObject(spawnedObject),
							this.chunkEntranceMap.get(locatedChunkId),
							locatedWorldPoint,
							spawnedObjectId
					)
			);
		}

		if (!this.doomRegionIds.contains(this.currentRegionId)) return;

        if (DOOM_BURROW_HOLE_IDS.contains(spawnedObjectId)) this.doomFloorCleared = true;
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
		GameObject despawnedObject = event.getGameObject();

		if (this.gameObjectEntranceIds.contains(despawnedObject.getId())) {
			WorldPoint locatedWorldPoint = resolvePossiblyInstancedWorldPoint(despawnedObject.getWorldLocation(), despawnedObject.getLocalLocation());
			int regionId = locatedWorldPoint.getRegionID();
			List<EscapeCrystalNotifyLocatedEntrance> entrances = possibleEntrances.get(regionId);

			if (ENTRANCE_CLEAR_REQUIRED_IDS.contains(despawnedObject.getId())) {
				clearPossibleEntranceId(despawnedObject.getId());
			}

			if (entrances != null) {
				entrances.removeIf(entrance ->
					entrance.getTarget().getId() == despawnedObject.getId());

				if (entrances.isEmpty()) {
					possibleEntrances.remove(regionId);
				}
			}
		}

		// Special handling for Leviathan boat despawning as a different ID
		else if (despawnedObject.getId() == net.runelite.api.gameval.ObjectID.DT2_SCAR_BOAT_ISLAND) {
			possibleEntrances.remove(8292);
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npc)
	{
		NPC spawnedNpc = npc.getNpc();
		int spawnedNpcId = spawnedNpc.getId();

		if (this.npcEntranceIds.contains(spawnedNpcId)) {
			WorldPoint locatedWorldPoint = resolvePossiblyInstancedWorldPoint(spawnedNpc.getWorldLocation(), spawnedNpc.getLocalLocation());
			int locatedChunkId = computeChunkIdFromWorldPoint(locatedWorldPoint);

			if (this.infernoEntranceRegionIds.contains(locatedWorldPoint.getRegionID())) {
				for (int regionId : this.infernoEntranceRegionIds) {
					possibleEntrances.computeIfAbsent(regionId, k -> new ArrayList<>()).add(
							new EscapeCrystalNotifyLocatedEntrance(
									new EscapeCrystalNotifyRegionEntranceObject(spawnedNpc),
									this.chunkEntranceMap.get(locatedChunkId),
									locatedWorldPoint,
									spawnedNpcId
							)
					);
				}
			} else if (spawnedNpcId == NpcID.WHISPERER_SPAWN) {
				for (int regionId : this.whispererEntranceRegionIds) {
					possibleEntrances.computeIfAbsent(regionId, k -> new ArrayList<>()).add(
							new EscapeCrystalNotifyLocatedEntrance(
									new EscapeCrystalNotifyRegionEntranceObject(spawnedNpc),
									EscapeCrystalNotifyRegion.BOSS_THE_WHISPERER.getRegionEntrance(),
									locatedWorldPoint,
									spawnedNpcId
							)
					);
				}
			} else if (spawnedNpcId == NpcID.DT2_PURSUER_HIDEOUT_COMBAT) {
				this.clearPossibleEntranceId(ObjectID.DT2_HIDEOUT_ALTAR_OP);
			} else {
				possibleEntrances.computeIfAbsent(locatedWorldPoint.getRegionID(), k -> new ArrayList<>()).add(
						new EscapeCrystalNotifyLocatedEntrance(
								new EscapeCrystalNotifyRegionEntranceObject(spawnedNpc),
								this.chunkEntranceMap.get(locatedChunkId),
								locatedWorldPoint,
								spawnedNpcId
						)
				);
			}
		}

		if (!this.doomRegionIds.contains(this.currentRegionId)) {
			this.doomFloorCleared = true;
			return;
		}
		if (DOOM_NPC_IDS.contains(spawnedNpcId)) this.doomFloorCleared = false;
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npc)
	{
		NPC despawnedNpc = npc.getNpc();

		if (NPC_ENTRANCE_FORCE_CLEAR_IDS.contains(despawnedNpc.getId())) {
			clearPossibleEntranceId(despawnedNpc.getId());
			return;
		}

		if (this.npcEntranceIds.contains(despawnedNpc.getId())) {
			WorldPoint locatedWorldPoint = resolvePossiblyInstancedWorldPoint(despawnedNpc.getWorldLocation(), despawnedNpc.getLocalLocation());
			int regionId = locatedWorldPoint.getRegionID();
			List<EscapeCrystalNotifyLocatedEntrance> entrances = possibleEntrances.get(regionId);
			
			if (entrances != null) {
				entrances.removeIf(entrance -> 
					entrance.getTarget().getId() == despawnedNpc.getId());
				
				if (entrances.isEmpty()) {
					possibleEntrances.remove(regionId);
				}
			}
		}
	}

	@Subscribe
	public void onNpcChanged(NpcChanged npc)
	{
		NPC changedNpc = npc.getNpc();

		if (changedNpc.getId() == NpcID.WHISPERER || changedNpc.getId() == NpcID.WHISPERER_QUEST) {
			this.clearPossibleChangedEntranceId(NpcID.WHISPERER_SPAWN);
		}
	}

	@Subscribe
	public void onDecorativeObjectSpawned(DecorativeObjectSpawned event)
	{
		DecorativeObject spawnedObject = event.getDecorativeObject();

		if (this.gameObjectEntranceIds.contains(spawnedObject.getId())) {
			WorldPoint locatedWorldPoint = resolvePossiblyInstancedWorldPoint(spawnedObject.getWorldLocation(), spawnedObject.getLocalLocation());
			int locatedChunkId = computeChunkIdFromWorldPoint(locatedWorldPoint);

			possibleEntrances.computeIfAbsent(locatedWorldPoint.getRegionID(), k -> new ArrayList<>()).add(
					new EscapeCrystalNotifyLocatedEntrance(
							new EscapeCrystalNotifyRegionEntranceObject(spawnedObject),
							this.chunkEntranceMap.get(locatedChunkId),
							locatedWorldPoint,
							spawnedObject.getId()
					)
			);
		}
	}

	@Subscribe
	public void onDecorativeObjectDespawned(DecorativeObjectDespawned event)
	{
		DecorativeObject despawnedObject = event.getDecorativeObject();

		if (this.gameObjectEntranceIds.contains(despawnedObject.getId())) {
			WorldPoint locatedWorldPoint = resolvePossiblyInstancedWorldPoint(despawnedObject.getWorldLocation(), despawnedObject.getLocalLocation());
			int regionId = locatedWorldPoint.getRegionID();
			List<EscapeCrystalNotifyLocatedEntrance> entrances = possibleEntrances.get(regionId);
			
			if (entrances != null) {
				entrances.removeIf(entrance -> 
					entrance.getTarget().getId() == despawnedObject.getId());
				
				if (entrances.isEmpty()) {
					possibleEntrances.remove(regionId);
				}
			}
		}
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned event)
	{
		WallObject spawnedObject = event.getWallObject();

		if (this.gameObjectEntranceIds.contains(spawnedObject.getId())) {
			WorldPoint locatedWorldPoint = resolvePossiblyInstancedWorldPoint(spawnedObject.getWorldLocation(), spawnedObject.getLocalLocation());
			int locatedChunkId = computeChunkIdFromWorldPoint(locatedWorldPoint);

			if (HYDRA_ENTRANCE_IDS.contains(spawnedObject.getId())) {
				for (int regionId : this.hydraEntranceRegionIds) {
					possibleEntrances.computeIfAbsent(regionId, k -> new ArrayList<>()).add(
							new EscapeCrystalNotifyLocatedEntrance(
									new EscapeCrystalNotifyRegionEntranceObject(spawnedObject),
									EscapeCrystalNotifyRegion.BOSS_HYDRA.getRegionEntrance(),
									locatedWorldPoint,
									spawnedObject.getId()
							)
					);
				}
			} else {
				possibleEntrances.computeIfAbsent(locatedWorldPoint.getRegionID(), k -> new ArrayList<>()).add(
						new EscapeCrystalNotifyLocatedEntrance(
								new EscapeCrystalNotifyRegionEntranceObject(spawnedObject),
								this.chunkEntranceMap.get(locatedChunkId),
								locatedWorldPoint,
								spawnedObject.getId()
						)
				);
			}
		}
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned event)
	{
		WallObject despawnedObject = event.getWallObject();

		if (this.gameObjectEntranceIds.contains(despawnedObject.getId())) {
			WorldPoint locatedWorldPoint = resolvePossiblyInstancedWorldPoint(despawnedObject.getWorldLocation(), despawnedObject.getLocalLocation());
			int regionId = locatedWorldPoint.getRegionID();
			List<EscapeCrystalNotifyLocatedEntrance> entrances = possibleEntrances.get(regionId);
			
			if (entrances != null) {
				entrances.removeIf(entrance -> 
					entrance.getTarget().getId() == despawnedObject.getId());
				
				if (entrances.isEmpty()) {
					possibleEntrances.remove(regionId);
				}
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		GameState state = event.getGameState();

		switch (state)
		{
			case LOGGING_IN:
			case HOPPING:
				ready = true;
				lastCombatTime = null;
				break;
			case LOGGED_IN:
				if (ready)
				{
					loginTime = Instant.now();
					ticksSinceLogin = 0;
					lastCombatTime = null;
					ready = false;
				}
				break;
			case LOGIN_SCREEN:
            case LOADING:
                this.possibleEntrances.clear();

				if (NPC_ENTRANCE_AUTO_RECHECK_ON_LOAD_REGION_IDS.contains(this.currentRegionId)) {
					this.recheckLocalNpcs = true;
				}

				break;
        }
	}

	private EscapeCrystalNotifyAccountType determineAccountType() {
		if (config.testingAccountTypeOverride() != EscapeCrystalNotifyConfig.TestingAccountType.DEFAULT) {
			switch (config.testingAccountTypeOverride()) {
				case NON_HARDCORE: return EscapeCrystalNotifyAccountType.NON_HARDCORE;
				case STANDARD_HARDCORE: return EscapeCrystalNotifyAccountType.STANDARD_HARDCORE;
				case GROUP_HARDCORE: return EscapeCrystalNotifyAccountType.GROUP_HARDCORE;
				default: break;
			}
		}

		switch (client.getVarbitValue(Varbits.ACCOUNT_TYPE)) {
			case STANDARD_HARDCORE_ACCOUNT_TYPE_VARBIT_VALUE: return EscapeCrystalNotifyAccountType.STANDARD_HARDCORE;
			case GROUP_HARDCORE_ACCOUNT_TYPE_VARBIT_VALUE: return EscapeCrystalNotifyAccountType.GROUP_HARDCORE;
			default: return EscapeCrystalNotifyAccountType.NON_HARDCORE;
		}
	}

	private void computeAccountTypeMetrics() {
		EscapeCrystalNotifyAccountType previousAccountType = this.accountType;
		this.accountType = determineAccountType();
		this.hardcoreAccountType = this.accountType != EscapeCrystalNotifyAccountType.NON_HARDCORE;
		this.completedWesternEliteDiary = client.getVarbitValue(Varbits.DIARY_WESTERN_ELITE) == 1;

		if (this.accountType != previousAccountType) {
			this.targetRegionIds = getTargetRegionIdsFromConfig(this.accountType);
			this.npcEntranceIds = new HashSet<>(EscapeCrystalNotifyRegion.getEntranceIdsFromTypes(List.of(EscapeCrystalNotifyRegionEntranceObjectType.NPC, EscapeCrystalNotifyRegionEntranceObjectType.ANY), getTargetDeathTypes(this.accountType)));
			this.gameObjectEntranceIds = new HashSet<>(EscapeCrystalNotifyRegion.getEntranceIdsFromTypes(List.of(EscapeCrystalNotifyRegionEntranceObjectType.GAME_OBJECT, EscapeCrystalNotifyRegionEntranceObjectType.ANY), getTargetDeathTypes(this.accountType)));
		}
	}

	private void computeLocationMetrics() {
		this.previousRegionId = this.currentRegionId;
		this.previouslyAtNotifyRegionId = this.atNotifyRegionId;

		this.computeWorldPointMetrics();

		this.atNotifyRegionId = this.checkAtNotifyLocation();
		this.enteredNotifyRegionId = !this.previouslyAtNotifyRegionId && this.atNotifyRegionId;

		this.atLeviathanRegionId = this.leviathanRegionIds.contains(this.currentRegionId);
		this.atLeviathanLobby = LEVIATHAN_LOBBY_CHUNK_IDS.contains(this.currentChunkId);
		this.atDoomRegionId = this.doomRegionIds.contains(this.currentRegionId);
		this.atDoomLobby = DOOM_LOBBY_CHUNK_IDS.contains(this.currentChunkId);
		this.inTzhaarEntranceRegion = this.tzhaarEntranceRegionIds.contains(this.currentRegionId);
		this.atTeleportDisabledRegion = this.isRegionTeleportDisabled(this.currentRegionId);

		this.recheckLocalNpcs();

		this.computeEntranceObjectMetrics();
	}

	private void computeWorldPointMetrics() {
		this.currentWorldPoint = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
		this.currentRegionId = this.currentWorldPoint.getRegionID();
		this.currentPlaneId = this.currentWorldPoint.getPlane();
		this.currentChunkId = this.computeChunkIdFromWorldPoint(this.currentWorldPoint);
	}

	private void computeEntranceObjectMetrics() {
		if (this.currentRegionId == YAMA_REGION_ID) {
			this.clearPossibleChangedEntranceId(NpcID.YAMA_THRONE_OCCUPIED);
		}

		if (!this.atNotifyRegionId && !this.inTzhaarEntranceRegion) {
			this.validEntrances.clear();
			return;
		}

		this.validEntrances.clear();
		for (List<EscapeCrystalNotifyLocatedEntrance> entrances : this.possibleEntrances.values()) {
			for (EscapeCrystalNotifyLocatedEntrance entrance : entrances) {
				if (entrance.isEntranceInValidChunk() && 
					!entrance.hasMoved() && 
					!entrance.isPlayerPastEntrance(this.currentWorldPoint) &&
					entrance.matchesPlayerPlane(this.currentPlaneId)) {
					this.validEntrances.add(entrance);
				}
			}
		}
	}

	private boolean checkAtNotifyLocation() {
		if (config.displayEverywhere()) return true;

		if (this.currentRegionId == ZULRAH_ENTRANCE_REGION_ID) this.updateZulrahRegionsInSet();

		if (!targetRegionIds.contains(this.currentRegionId)) return false;

		if (excludedChunkIds.contains(this.currentChunkId)) return false;

		if (this.chunkRequirements.containsKey(this.currentRegionId)) {
			if (!this.chunkRequirements.get(this.currentRegionId).contains(this.currentChunkId)) return false;
		}

		int planeRequirement = this.planeRequirements.getOrDefault(this.currentRegionId, this.currentPlaneId);
		return this.currentPlaneId == planeRequirement;
	}

	private boolean checkEscapeCrystalWithPlayer() {
		ItemContainer equipmentContainer = client.getItemContainer(InventoryID.EQUIPMENT);
		ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INVENTORY);

		if (equipmentContainer == null && inventoryContainer == null) {
			return false;
		}

		boolean escapeCrystalEquipped = equipmentContainer != null && equipmentContainer.contains(ItemID.TOB_TELEPORT);
		boolean escapeCrystalInInventory = inventoryContainer != null && inventoryContainer.contains(ItemID.TOB_TELEPORT);

        return escapeCrystalEquipped || escapeCrystalInInventory;
    }

	private void computeEscapeCrystalMetrics() {
		if (client.getVarbitValue(ITEMS_STORED_VARBIT) == 0) {
			this.escapeCrystalWithPlayer = checkEscapeCrystalWithPlayer();
		}

		this.escapeCrystalActive = client.getVarbitValue(ESCAPE_CRYSTAL_ACTIVE_VARBIT) == 1;
		this.escapeCrystalInactivityTicks = client.getVarbitValue(ESCAPE_CRYSTAL_INACTIVITY_TICKS_VARBIT);
		this.escapeCrystalRingOfLifeActive = client.getVarbitValue(ESCAPE_CRYSTAL_RING_OF_LIFE_ACTIVE_VARBIT) == 1;

		int currentClientInactivityTicks = Math.min(client.getKeyboardIdleTicks(), client.getMouseIdleTicks());

		if (currentClientInactivityTicks > this.clientInactivityTicks) {
			this.expectedServerInactivityTicks += 1;
		}
		else {
			this.expectedServerInactivityTicks = 0;
			this.notifyTimeRemainingThreshold = false;
		}

		this.clientInactivityTicks = currentClientInactivityTicks;
		this.expectedTicksUntilTeleport = this.escapeCrystalInactivityTicks - this.expectedServerInactivityTicks;

		if (this.expectedTicksUntilTeleport < 0) {
			this.expectedTicksUntilTeleport = 0;
		}

		this.escapeCrystalLeftClickTeleportEnabled = configManager.getConfiguration("menuentryswapper", "item_" + ItemID.TOB_TELEPORT) == null;
	}

	private void computeNotificationMetrics() {
		if (!this.atNotifyRegionId || (config.requireHardcoreAccountType() && !this.hardcoreAccountType)) {
			resetNotificationFlags();
			return;
		}

		if (client.getLocalPlayer().getHealthScale() != -1) {
			this.lastCombatTime = Instant.now();
		}

		if (!this.escapeCrystalWithPlayer && this.enteredNotifyRegionId) {
			this.notifyMissing = true;
		}

		if (!this.escapeCrystalActive && this.enteredNotifyRegionId) {
			this.notifyInactive = true;
		}

		this.previouslyInTimeRemainingThreshold = this.inTimeRemainingThreshold;
		this.inTimeRemainingThreshold = this.expectedTicksUntilTeleport <= this.timeRemainingThresholdTicks;
		this.enteredTimeRemainingThreshold = !this.previouslyInTimeRemainingThreshold && this.inTimeRemainingThreshold;

		if (this.inTimeRemainingThreshold && this.enteredTimeRemainingThreshold && this.escapeCrystalActive && this.escapeCrystalWithPlayer && this.atNotifyRegionId) {
			this.notifyTimeRemainingThreshold = true;
		}

		if (!this.escapeCrystalLeftClickTeleportEnabled && this.enteredNotifyRegionId && this.escapeCrystalWithPlayer) {
			this.notifyNonLeftClickTeleport = true;
		}
	}

	private void resetNotificationFlags() {
		this.notifyMissing = false;
		this.notifyInactive = false;
		this.notifyTimeRemainingThreshold = false;
		this.notifyNonLeftClickTeleport = false;
	}

	private String generateTimeRemainingThresholdMessage() {
		return String.format("Your escape crystal will teleport you in %s %s!", config.notifyTimeUntilTeleportThreshold(), config.notificationInactivityTimeFormat().toString().toLowerCase());
	}

	private int normalizeTimeRemainingThresholdValue() {
		switch (config.onScreenWidgetInactivityTimeFormat()) {
			case SECONDS:
				return convertSecondsToTicks(config.notifyTimeUntilTeleportThreshold());
            default: return config.notifyTimeUntilTeleportThreshold();
		}
    }

	@Provides
	EscapeCrystalNotifyConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(EscapeCrystalNotifyConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		this.targetRegionIds = getTargetRegionIdsFromConfig(this.accountType);
		this.notifyTimeRemainingThresholdMessage = generateTimeRemainingThresholdMessage();
		this.timeRemainingThresholdTicks = normalizeTimeRemainingThresholdValue();
	}

	private Set<Integer> getTargetRegionIdsFromConfig(EscapeCrystalNotifyAccountType accountType) {
		ArrayList<EscapeCrystalNotifyRegionType> targetRegions = new ArrayList<>();

		if (config.displayBosses()) targetRegions.add(EscapeCrystalNotifyRegionType.BOSSES);
		if (config.displayRaids()) targetRegions.add(EscapeCrystalNotifyRegionType.RAIDS);
		if (config.displayDungeons()) targetRegions.add(EscapeCrystalNotifyRegionType.DUNGEONS);
		if (config.displayMinigames()) targetRegions.add(EscapeCrystalNotifyRegionType.MINIGAMES);
		if (config.displayTeleportDisabled()) targetRegions.add(EscapeCrystalNotifyRegionType.TELEPORT_DISABLED);

		Set<Integer> regionIds = new HashSet<>(EscapeCrystalNotifyRegion.getRegionIdsFromTypes(targetRegions, getTargetDeathTypes(accountType)));
		List<Integer> includeRegionIds = parseAdditionalConfigRegionIds(config.includeRegionIds());
		List<Integer> excludeRegionIds = parseAdditionalConfigRegionIds(config.excludeRegionIds());

		regionIds.addAll(includeRegionIds);
		regionIds.removeAll(excludeRegionIds);

		if (config.excludeZulrahWithEliteDiary() && this.completedWesternEliteDiary) {
			regionIds.removeAll(this.zulrahRegionIds);
		}

		return regionIds;
	}

	private List<Integer> parseAdditionalConfigRegionIds(String regionIds) {
		if (regionIds.isEmpty()) return List.of();

		return Arrays.stream(regionIds.split(",")).map(Integer::parseInt).collect(Collectors.toList());
	}

	private List<EscapeCrystalNotifyRegionDeathType> getTargetDeathTypes(EscapeCrystalNotifyAccountType accountType) {
		switch (accountType) {
            case GROUP_HARDCORE: return Arrays.asList(EscapeCrystalNotifyRegionDeathType.UNSAFE, EscapeCrystalNotifyRegionDeathType.UNSAFE_HCGIM);
			default: return List.of(EscapeCrystalNotifyRegionDeathType.UNSAFE);
        }
    }

	private void sendRequestedNotifications() {
		if (config.requireCombatForNotifications() && this.getTimeSinceLastCombat() > config.combatGracePeriodSeconds()) {
			return;
		}

		if (config.notifyMissing() && this.notifyMissing) {
			notifier.notify("You are missing an escape crystal!");
			this.notifyMissing = false;
		} else if (config.notifyInactive() && this.notifyInactive) {
			notifier.notify("Your escape crystal is inactive!");
			this.notifyInactive = false;
		} else if (config.notifyTimeUntilTeleportThreshold() != 0 && this.notifyTimeRemainingThreshold) {
			notifier.notify(this.notifyTimeRemainingThresholdMessage);
			this.notifyTimeRemainingThreshold = false;
		}

		if (config.notifyNonLeftClickTeleport() && this.notifyNonLeftClickTeleport) {
			notifier.notify("Your escape crystal is not set to left click teleport!");
			this.notifyNonLeftClickTeleport = false;
		}
	}

	private void createInfoBox() {
		List<InfoBox> currentInfoBoxes = infoBoxManager.getInfoBoxes();

		if (this.isEscapeCrystalActive() && this.escapeCrystalWithPlayer){
			if (currentInfoBoxes.contains(this.activeInfoBox)) {
				if (this.activeInfoBox.imageId != ItemID.TOB_TELEPORT) {
					this.activeInfoBox.setImage(this.getActiveEscapeCrystalImage());
					this.activeInfoBox.imageId = ItemID.TOB_TELEPORT;
					this.activeInfoBox.setTooltip(getInfoBoxTooltip());
					infoBoxManager.updateInfoBoxImage(this.activeInfoBox);
				}
				return;
			}

			BufferedImage activeImage = this.getActiveEscapeCrystalImage();
			this.activeInfoBox = new EscapeCrystalNotifyInfoBox(ItemID.TOB_TELEPORT, activeImage, this, this.config);
			this.activeInfoBox.setTooltip(getInfoBoxTooltip());
			infoBoxManager.addInfoBox(this.activeInfoBox);

		} else {
			if (currentInfoBoxes.contains(this.activeInfoBox)) {
				if (this.activeInfoBox.imageId != ItemID.GAUNTLET_ESCAPE_CRYSTAL_HM) {
					this.activeInfoBox.setImage(this.getInactiveEscapeCrystalImage());
					this.activeInfoBox.imageId = ItemID.GAUNTLET_ESCAPE_CRYSTAL_HM;
					this.activeInfoBox.setTooltip(getInfoBoxTooltip());
					infoBoxManager.updateInfoBoxImage(this.activeInfoBox);
				}
				return;
			}

			BufferedImage inactiveImage = this.getInactiveEscapeCrystalImage();
			this.activeInfoBox = new EscapeCrystalNotifyInfoBox(ItemID.GAUNTLET_ESCAPE_CRYSTAL_HM, inactiveImage, this, this.config);
			this.activeInfoBox.setTooltip(getInfoBoxTooltip());
			infoBoxManager.addInfoBox(this.activeInfoBox);
		}
	}

	private void removeInfoBoxes() {
		infoBoxManager.removeIf(b -> b instanceof EscapeCrystalNotifyInfoBox);
	}

	private void deprioritizeLogoutButton() {
		MenuEntry[] menuEntries = client.getMenuEntries();

		if (menuEntries.length == 0) return;

		int topEntryIndex = menuEntries.length - 1;
		MenuEntry topEntry = menuEntries[topEntryIndex];
		boolean isLogoutOption = topEntry.getOption().equals("Logout");
		boolean isWorldSwitchOption = topEntry.getOption().equals("Switch") && WidgetUtil.componentToInterface(topEntry.getWidget().getId()) == InterfaceID.WORLD_SWITCHER;

		if (!isLogoutOption && !isWorldSwitchOption) return;

		if (menuEntries.length == 1) {
			client.getMenu().createMenuEntry(0).setType(MenuAction.CANCEL);
		}
		else {
			MenuEntry cancelEntry = menuEntries[0];
			menuEntries[topEntryIndex] = cancelEntry;
			menuEntries[0] = topEntry;
			client.setMenuEntries(menuEntries);
		}
	}

	private void deprioritizeEnterOption() {
		MenuEntry[] menuEntries = client.getMenuEntries();

		if (menuEntries.length == 0) return;

		int topEntryIndex = menuEntries.length - 1;
		MenuEntry topEntry = menuEntries[topEntryIndex];

		if (this.validEntrances.isEmpty()) return;

		EscapeCrystalNotifyLocatedEntrance entranceToDeprioritize = null;
		int entryId;
		if (topEntry.getNpc() != null)  {
			entryId = topEntry.getNpc().getId();
		} else {
			entryId = topEntry.getIdentifier();
		}

		for (EscapeCrystalNotifyLocatedEntrance entrance : this.validEntrances) {
			if (entrance.canDeprioritize() && 
				!entrance.isPlayerPastEntrance(this.currentWorldPoint) &&
				entryId == entrance.getTarget().getId()) {
				entranceToDeprioritize = entrance;
				break;
			}
		}

		if (entranceToDeprioritize == null) return;

		MenuEntry[] newEntries = new MenuEntry[menuEntries.length + 1];
		System.arraycopy(menuEntries, 0, newEntries, 0, menuEntries.length);

		String optionText = ColorUtil.wrapWithColorTag(config.deprioritizedMenuText(), config.deprioritizedMenuTextColor());
		MenuEntry escapeCrystalReminderEntry = client.createMenuEntry(0).setType(MenuAction.CANCEL).setOption(optionText).setTarget("");

		newEntries[newEntries.length - 1] = escapeCrystalReminderEntry;

		client.setMenuEntries(newEntries);
	}

	private BufferedImage combineItemImages(BufferedImage... images) {
		BufferedImage backgroundImage = images[0];

		BufferedImage result = new BufferedImage(backgroundImage.getWidth(), backgroundImage.getHeight(), BufferedImage.TYPE_INT_ARGB);

		Graphics2D graphics = result.createGraphics();

		graphics.setComposite(AlphaComposite.SrcOver);
		graphics.drawImage(backgroundImage, 0, 0, null);

		for (int i = 1; i < images.length; i++) {
			graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));
			graphics.drawImage(images[i], 0, 0, null);
		}

		graphics.dispose();

		return result;
	}

	public String getItemModelDisplayText(EscapeCrystalNotifyConfig.OverlayDisplayType displayFormat, EscapeCrystalNotifyConfig.InactivityTimeFormat timeFormat, String timeExpiredText) {
		String displayText;

		if (!escapeCrystalWithPlayer) {
			displayText = this.config.infoBoxMissingCrystalText();
		}
		else if (displayFormat == EscapeCrystalNotifyConfig.OverlayDisplayType.REMAINING_TIME) {
			if (!isEscapeCrystalActive()) {
				displayText = getItemModelCurrentSettingDisplayText(timeFormat);
			}
			else if (isTimeExpired()) {
				displayText = timeExpiredText;
			}
			else if (timeFormat == EscapeCrystalNotifyConfig.InactivityTimeFormat.SECONDS) {
				displayText = this.getExpectedSecondsUntilTeleport() + "s";
			}
			else if (timeFormat == EscapeCrystalNotifyConfig.InactivityTimeFormat.SECONDS_MMSS) {
				int minutes = (this.getEscapeCrystalInactivitySeconds() % 3600) / 60;
				int seconds = this.getEscapeCrystalInactivitySeconds() % 60;

				displayText = String.format("%02d:%02d", minutes, seconds);
			}
			else {
				displayText = Integer.toString(this.getExpectedTicksUntilTeleport());
			}
		} else if (displayFormat == EscapeCrystalNotifyConfig.OverlayDisplayType.CURRENT_SETTING) {
			displayText = getItemModelCurrentSettingDisplayText(timeFormat);
		} else {
			displayText = "";
		}

		return displayText;
	}

	public String getItemModelCurrentSettingDisplayText(EscapeCrystalNotifyConfig.InactivityTimeFormat timeFormat) {
		switch (timeFormat) {
			case GAME_TICKS: return this.getEscapeCrystalInactivityTicks() + "t";
			case SECONDS: return this.getEscapeCrystalInactivitySeconds() + "s";
			case SECONDS_MMSS: {
				if (this.getEscapeCrystalInactivitySeconds() < 0) return "00:00";

				int minutes = (this.getEscapeCrystalInactivitySeconds() % 3600) / 60;
				int seconds = this.getEscapeCrystalInactivitySeconds() % 60;

				return String.format("%02d:%02d", minutes, seconds);
			}
		}

		return "";
	}

	public String getInfoBoxTooltip() {
		if (!this.escapeCrystalWithPlayer) {
			return "Status: MISSING";
		}
		else if (this.isEscapeCrystalActive()) {
			return "Status: ACTIVE (set to " + this.getEscapeCrystalInactivitySeconds() + " seconds / " + this.getEscapeCrystalInactivityTicks() + " ticks)";
		}
		else {
			return "Status: DISABLED (set to " + this.getEscapeCrystalInactivitySeconds() + " seconds / " + this.getEscapeCrystalInactivityTicks() + " ticks)";
		}
	}

	public Color getItemModelDisplayTextColor(EscapeCrystalNotifyConfig.OverlayDisplayType displayFormat) {
		if (!escapeCrystalWithPlayer) {
			return Color.RED;
		}
		else if (displayFormat == EscapeCrystalNotifyConfig.OverlayDisplayType.REMAINING_TIME) {
			if (isTimeExpired() && isEscapeCrystalActive()) {
				return Color.RED;
			}
		}

		return Color.WHITE;
	}

	public boolean isAccountTypeEnabled() {
		if (config.requireHardcoreAccountType()) {
			return isHardcoreAccountType();
		}
		return true;
	}

	public boolean isEscapeCrystalInactivityTeleportActive() {
		return escapeCrystalWithPlayer && escapeCrystalActive;
	}

	public int getEscapeCrystalInactivitySeconds() {
		return convertTicksToSeconds(escapeCrystalInactivityTicks);
	}

	public int getExpectedServerInactivitySeconds() {
		return convertTicksToSeconds(expectedServerInactivityTicks);
	}

	public int getExpectedSecondsUntilTeleport() {
		return convertTicksToSeconds(expectedTicksUntilTeleport);
	}

	public boolean isTimeExpired() {
		return expectedTicksUntilTeleport == 0;
	}

	public void resetLocatedEntrance() {
		this.validEntrances.clear();
	}

	public BufferedImage getInactiveEscapeCrystalImage() {
		if (inactiveEscapeCrystalImage == null) {
			inactiveEscapeCrystalImage = itemManager.getImage(ItemID.GAUNTLET_ESCAPE_CRYSTAL_HM);
		}
		return inactiveEscapeCrystalImage;
	}

	public BufferedImage getActiveEscapeCrystalImage() {
		if (activeEscapeCrystalImage == null) {
			activeEscapeCrystalImage = itemManager.getImage(ItemID.TOB_TELEPORT);
		}
		return activeEscapeCrystalImage;
	}

	public BufferedImage getBankFillerImage() {
		if (bankFillerImage == null) {
			bankFillerImage = itemManager.getImage(ItemID.BANK_FILLER);
		}
		return bankFillerImage;
	}

	public BufferedImage getEntranceOverlayImage() {
		if (entranceOverlayImage == null) {
			entranceOverlayImage = combineItemImages(this.getActiveEscapeCrystalImage(), this.getBankFillerImage());
		}
		return entranceOverlayImage;
	}

	public boolean isLeviathanSafeguardPanelEnabled() {
		return this.atLeviathanLobby && !config.disableLeviathanSafeguardPanelPopup();
	}

	public boolean isDoomSafeguardPanelEnabled() {
		return this.atDoomLobby && !config.disableDoomSafeguardPanelPopup();
	}

	public boolean isTeleportDisabledPanelEnabled() {
		return this.atTeleportDisabledRegion && config.displayTeleportDisabled();
	}

	public boolean isCloseToSixHourLogout() {
		return ticksSinceLogin >= SIX_HOUR_LOG_WARNING_THRESHOLD_TICKS;
	}

	public boolean hasDiedAtZulrah() {
		return client.getVarbitValue(ZULRAH_REVIVE_VARBIT) == 1;
	}

	public boolean isQuestCompleted(Quest quest) {
		if (client != null && quest != null) {
			return quest.getState(client) == QuestState.FINISHED;
		}
		return false;
	}

	public boolean isRegionTeleportDisabled(int regionId) {
		if (!this.teleportDisabledRegionIds.contains(regionId)) return false;

		for (EscapeCrystalNotifyRegion region : EscapeCrystalNotifyRegion.values()) {
			if (region.getRegionType() == EscapeCrystalNotifyRegionType.TELEPORT_DISABLED) {
				if (Arrays.stream(region.getRegionIds()).anyMatch(id -> id == regionId)) {
					if (region.getQuestNotCompleted() != null) {
						return !this.isQuestCompleted(region.getQuestNotCompleted());
					}
					return true;
				}
			}
		}

		return false;
	}

	private void updateZulrahRegionsInSet() {
		if (config.excludeZulrahWithEliteDiary() && this.completedWesternEliteDiary) {
			if (hasDiedAtZulrah()) {
				this.targetRegionIds.addAll(this.zulrahRegionIds);
				this.targetRegionIds.addAll(this.zulrahEntranceRegionIds);
			} else {
				this.targetRegionIds.removeAll(this.zulrahRegionIds);
				this.targetRegionIds.removeAll(this.zulrahEntranceRegionIds);
			}
		}
	}

	public boolean shouldDeprioritizeEntranceEnterOption() {
		boolean enabled = config.deprioritizeEntranceEnterOption();
		boolean active = this.isEscapeCrystalInactivityTeleportActive();
		boolean notHardcore = config.requireHardcoreAccountType() && !this.isHardcoreAccountType();
		boolean atNotifyRegion = this.isAtNotifyRegionId();
		boolean isInPvpWorld = WorldType.isPvpWorld(client.getWorldType());

		if (!enabled || active || notHardcore || !atNotifyRegion || isInPvpWorld) return false;

		if (this.validEntrances.isEmpty()) return false;

		return this.validEntrances.stream().anyMatch(EscapeCrystalNotifyLocatedEntrance::canDeprioritize);
	}

	public void toggleTestingMode() {
		this.testingModeEnabled = !this.testingModeEnabled;
		log.info("Testing mode " + (this.testingModeEnabled ? "enabled" : "disabled"));
	}

	public WorldPoint resolvePossiblyInstancedWorldPoint(WorldPoint worldPoint, LocalPoint localPoint) {
		if (client.isInInstancedRegion()) {
			return WorldPoint.fromLocalInstance(client, localPoint);
		}
		return worldPoint;
	}

	public void clearPossibleEntranceId(int entranceId) {
		for (int regionId : this.possibleEntrances.keySet()) {
			List<EscapeCrystalNotifyLocatedEntrance> entrances = this.possibleEntrances.get(regionId);

			if (entrances != null) {
				entrances.removeIf(entrance -> entrance.getTarget().getId() == entranceId);

				if (entrances.isEmpty()) {
					this.possibleEntrances.remove(regionId);
				}
			}
		}
	}

	public void clearPossibleChangedEntranceId(int entranceId) {
		for (int regionId : this.possibleEntrances.keySet()) {
			List<EscapeCrystalNotifyLocatedEntrance> entrances = this.possibleEntrances.get(regionId);

			if (entrances != null) {
				entrances.removeIf(entrance -> entrance.getInitialTargetId() == entranceId && entrance.hasChangedTargetId());

				if (entrances.isEmpty()) {
					this.possibleEntrances.remove(regionId);
				}
			}
		}
	}

	public void recheckLocalNpcs() {
		if (!this.recheckLocalNpcs) return;

		this.recheckLocalNpcs = false;

		for (NPC npc : client.getTopLevelWorldView().npcs()) {
			if (npc != null && NPC_ENTRANCE_AUTO_RECHECK_ON_LOAD_NPC_IDS.contains(npc.getId())) {
				onNpcSpawned(new NpcSpawned(npc));
			}
		}
	}

	public int computeChunkIdFromWorldPoint(WorldPoint worldPoint) {
		int currentTileX = worldPoint.getX();
		int currentTileY = worldPoint.getY();
		final int currentChunkX = currentTileX >> 3;
		final int currentChunkY = currentTileY >> 3;

		return (currentChunkX << 11) | currentChunkY;
	}

	private int convertTicksToSeconds(int ticks) {
		return (int) Math.round(ticks * 0.6);
	}

	private int convertSecondsToTicks(int seconds) {
		return (int) Math.round(seconds * 1.6);
	}

	private int getTimeSinceLastCombat() {
		if (this.lastCombatTime == null) {
			return 100000;
		}

		long timeSinceCombat = System.currentTimeMillis() - this.lastCombatTime.toEpochMilli();	
		return (int) Math.round(timeSinceCombat / 1000.0);
	}
}

package com.escapecrystalnotify;

import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;

public class EscapeCrystalNotifyOverlayInactive extends Overlay {
    private static final EscapeCrystalImage previouslyGeneratedImage = new EscapeCrystalImage();
    private static BufferedImage escapeCrystalImage;
    private final EscapeCrystalNotifyPlugin plugin;
    private final EscapeCrystalNotifyConfig config;

    @Inject
    EscapeCrystalNotifyOverlayInactive(EscapeCrystalNotifyPlugin plugin, EscapeCrystalNotifyConfig config) throws PluginInstantiationException {
        super(plugin);
        setPriority(OverlayPriority.LOW);
        setPosition(OverlayPosition.BOTTOM_LEFT);
        setLayer(OverlayLayer.ABOVE_SCENE);

        this.plugin = plugin;
        this.config = config;

        escapeCrystalImage = loadEscapeCrystalImage();

        initializePreviouslyGeneratedImage();
    }

    private static BufferedImage loadEscapeCrystalImage() {
        return ImageUtil.loadImageResource(EscapeCrystalNotifyPlugin.class, "/escape-crystal-inactive.png");
    }

    private void initializePreviouslyGeneratedImage() {
        previouslyGeneratedImage.scale = 1;
        previouslyGeneratedImage.generatedImage = escapeCrystalImage;
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        boolean enabled = config.enableOnScreenWidget();
        boolean active = plugin.isEscapeCrystalInactivityTeleportActive();
        boolean notHardcore = config.requireHardcoreAccountType() && !plugin.isHardcoreAccountType();

        boolean atNotifyRegion;
        if (this.plugin.isAtNotifyRegionId()) {
            atNotifyRegion = true;
        } else {
            atNotifyRegion = this.config.alwaysDisplayOnScreenWidget();
        }

        if (!enabled || notHardcore || !atNotifyRegion || active) {
            return null;
        }

        BufferedImage generatedEscapeCrystalImage = generateEscapeCrystalImage();
        ImageComponent imagePanelComponent = new ImageComponent(generatedEscapeCrystalImage);
        return imagePanelComponent.render(graphics);
    }

    private BufferedImage generateEscapeCrystalImage() {
        double targetScale = Math.max(config.inactiveCrystalWidgetScale(), 1);
        boolean escapeCrystalImageScaleChanged = previouslyGeneratedImage.scale != targetScale;

        if (!escapeCrystalImageScaleChanged) {
            return previouslyGeneratedImage.generatedImage;
        }

        BufferedImage generatedEscapeCrystalImage = scaleImage(escapeCrystalImage, targetScale / 5);

        previouslyGeneratedImage.generatedImage = generatedEscapeCrystalImage;
        previouslyGeneratedImage.scale = targetScale;

        return generatedEscapeCrystalImage;
    }

    private BufferedImage scaleImage(BufferedImage image, double scale) {
        BufferedImage scaledImage = new BufferedImage(
                (int) (scale * image.getWidth()),
                (int) (scale * image.getHeight()),
                BufferedImage.TYPE_INT_ARGB
        );

        AffineTransform at = new AffineTransform();
        at.scale(scale, scale);
        AffineTransformOp scaleOp = new AffineTransformOp(at, AffineTransformOp.TYPE_BILINEAR);
        scaledImage = scaleOp.filter(image, scaledImage);

        return scaledImage;
    }

    private static class EscapeCrystalImage {
        private double scale;
        private BufferedImage generatedImage;

    }
}

package com.escapecrystalnotify;

public enum EscapeCrystalNotifyRegionEntranceOverlayType {
    NONE(false, false),
    PRIORITIZED_WITH_HIGHLIGHT(true, false),
    DEPRIORITIZED_WITH_HIGHLIGHT(true, true),
    DEPRIORITIZED_NO_HIGHLIGHT(false, true);

    private final boolean highlight;
    private final boolean deprioritize;

    EscapeCrystalNotifyRegionEntranceOverlayType(boolean highlight, boolean deprioritize) {
        this.highlight = highlight;
        this.deprioritize = deprioritize;
    }

    public boolean canHighlight() {
        return this.highlight;
    }

    public boolean canDeprioritize() {
        return this.deprioritize;
    }
}

package com.escapecrystalnotify;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;

public class EscapeCrystalNotifyInventoryOverlay extends WidgetItemOverlay {
    private final EscapeCrystalNotifyPlugin plugin;
    private final EscapeCrystalNotifyConfig config;
    private final ItemManager itemManager;
    private final Cache<Long, Image> fillCache;

    @Inject
    EscapeCrystalNotifyInventoryOverlay(ItemManager itemManager, EscapeCrystalNotifyPlugin plugin, EscapeCrystalNotifyConfig config) {
        this.itemManager = itemManager;
        this.plugin = plugin;
        this.config = config;

        showOnInventory();
        showOnEquipment();

        fillCache = CacheBuilder.newBuilder().concurrencyLevel(1).maximumSize(32).build();
    }

    @Override
    public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem) {
        boolean atNotifyRegion;

        if (this.plugin.isAtNotifyRegionId()) {
            atNotifyRegion = true;
        } else {
            atNotifyRegion = this.config.alwaysDisplayInventory();
        }

        if (itemId != ItemID.TOB_TELEPORT) {
            return;
        }

        boolean shouldRenderMainDisplay = this.config.enableInventoryDisplay() && atNotifyRegion && this.plugin.isAccountTypeEnabled();
        
        boolean shouldRenderNonHardcoreHighlight = this.config.enableNonHardcoreInventoryHighlight() && 
            !this.plugin.isHardcoreAccountType() && 
            atNotifyRegion;

        if (!shouldRenderMainDisplay && !shouldRenderNonHardcoreHighlight) {
            return;
        }

        graphics.setFont(FontManager.getRunescapeSmallFont());
        final Rectangle bounds = widgetItem.getCanvasBounds();
        
        if (shouldRenderMainDisplay) {
            renderModelHighlight(graphics, bounds);
            renderCrystalModelSubtext(graphics, bounds);
            renderCrystalModelInfoText(graphics, bounds);
        } else if (shouldRenderNonHardcoreHighlight) {
            renderNonHardcoreModelHighlight(graphics, bounds);
        }
    }

    private void renderCrystalModelSubtext(Graphics2D graphics, Rectangle modelBounds) {
        final TextComponent textComponent = new TextComponent();

        textComponent.setPosition(new Point(modelBounds.x - 1, modelBounds.y + 35));

        if (plugin.isEscapeCrystalActive()) {
            textComponent.setText(config.inventoryActiveText());
            textComponent.setColor(config.inventoryActiveTextColor());
        } else {
            textComponent.setText(config.inventoryInactiveText());
            textComponent.setColor(config.inventoryInactiveTextColor());
        }

        textComponent.render(graphics);
    }

    private void renderModelHighlight(Graphics2D graphics, Rectangle modelBounds) {
        Color color;

        if (plugin.isEscapeCrystalActive()) {
            color = config.inventoryActiveFillColor();
        } else {
            color = config.inventoryInactiveFillColor();
        }

        switch (this.config.inventoryOverlayType()) {
            case ITEM_FILL: {
                Image image = getModelFillImage(ItemID.TOB_TELEPORT, 1, color);
                graphics.drawImage(image, modelBounds.x, modelBounds.y, null);
                break;
            }
            case BACKGROUND_FILL: {
                graphics.setColor(color);
                graphics.fill(modelBounds);
                break;
            }
            default:
        }
    }

    private void renderNonHardcoreModelHighlight(Graphics2D graphics, Rectangle modelBounds) {
        Color color;

        if (plugin.isEscapeCrystalActive()) {
            color = config.nonHardcoreInventoryActiveFillColor();
        } else {
            color = config.nonHardcoreInventoryInactiveFillColor();
        }

        switch (this.config.nonHardcoreInventoryOverlayType()) {
            case ITEM_FILL: {
                Image image = getModelFillImage(ItemID.TOB_TELEPORT, 1, color);
                graphics.drawImage(image, modelBounds.x, modelBounds.y, null);
                break;
            }
            case BACKGROUND_FILL: {
                graphics.setColor(color);
                graphics.fill(modelBounds);
                break;
            }
            default:
        }
    }

    private Image getModelFillImage(int itemId, int quantity, Color color) {
        long key = (((long) itemId) << 32) | color.getRGB() | color.getAlpha();
        Image image = fillCache.getIfPresent(key);
        if (image == null)
        {
            image = ImageUtil.fillImage(itemManager.getImage(itemId, quantity, false), color);
            fillCache.put(key, image);
        }
        return image;
    }

    private void renderCrystalModelInfoText(Graphics2D graphics, Rectangle modelBounds) {
        String infoText = this.plugin.getItemModelDisplayText(this.config.inventoryDisplayFormat(), this.config.inventoryInactivityTimeFormat(), this.config.inventoryTimeExpiredText());

        final TextComponent textComponent = new TextComponent();

        FontMetrics metrics = graphics.getFontMetrics(graphics.getFont());

        int textWidth = metrics.stringWidth(infoText);
        int textAscent = metrics.getAscent();
        int textDescent = metrics.getDescent();

        int xDrawLocation = modelBounds.x + (int) (modelBounds.getWidth() - textWidth) / 2 - 2;
        int yDrawLocation = modelBounds.y +  (int) (modelBounds.getHeight() - (textAscent + (modelBounds.getHeight() - (textAscent + textDescent))) / 3);
        Point position;
        position = new Point(xDrawLocation, yDrawLocation);

        textComponent.setPosition(position);

        textComponent.setText(infoText);
        textComponent.setColor(this.plugin.getItemModelDisplayTextColor(this.config.inventoryDisplayFormat()));

        textComponent.render(graphics);

    }

}

package com.escapecrystalnotify;

// Inclusive directions will include the tile the object is on as past the player
// This is useful for entrances that the player steps in to (i.e. GodWars entrances)

public enum EscapeCrystalNotifyRegionEntranceDirection {
    NORTHWARD,
    NORTHWARD_INCLUSIVE,
    SOUTHWARD,
    SOUTHWARD_INCLUSIVE,
    EASTWARD,
    EASTWARD_INCLUSIVE,
    WESTWARD,
    WESTWARD_INCLUSIVE,
}

package com.escapecrystalnotify;

public enum EscapeCrystalNotifyRegionDeathType {
    UNSAFE,
    UNSAFE_HCGIM,
    SAFE,
}

package com.escapecrystalnotify;

public enum EscapeCrystalNotifyRegionEntranceObjectType {
    NPC,
    GAME_OBJECT,
    ANY,
}

package com.escapecrystalnotify;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class EscapeCrystalNotifyPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(EscapeCrystalNotifyPlugin.class);
		RuneLite.main(args);
	}
}
