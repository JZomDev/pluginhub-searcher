package com.simonflapse.osrs.venom.events;

import com.simonflapse.osrs.venom.VenomTimerConfig;
import com.simonflapse.osrs.venom.ui.OverlayOrchestrator;
import net.runelite.api.Actor;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.annotations.HitsplatType;
import net.runelite.api.events.HitsplatApplied;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.*;

class OnHitsplatAppliedTest {

    OnHitsplatApplied onHitsplatApplied;
    VenomTimerConfig config;
    OverlayOrchestrator overlayOrchestrator;

    @BeforeEach
    void setUp() {
        config = new VenomTimerConfig() {};
        overlayOrchestrator = mock(OverlayOrchestrator.class);
        onHitsplatApplied = new OnHitsplatApplied(config, overlayOrchestrator);
    }

    @Nested
    class onEvent {
        @Test
        void should_update_damage() {
            int damage = 6;
            Actor actor = mock(Actor.class);

            HitsplatApplied hitsplatApplied = getHitsplatApplied(damage, actor);

            onHitsplatApplied.onEvent(hitsplatApplied);
            verify(overlayOrchestrator).updateDamage(actor, damage);
        }

        @Test
        void should_not_update_damage_if_actor_is_dead() {
            Actor actor = mock(Actor.class);
            when(actor.isDead()).thenReturn(true);
            HitsplatApplied hitsplatApplied = getHitsplatApplied(6, actor);

            onHitsplatApplied.onEvent(hitsplatApplied);
            verify(overlayOrchestrator, times(0)).updateDamage(any(), anyInt());
        }

        @Test
        void should_not_update_damage_if_not_venom() {
            Actor actor = mock(Actor.class);
            HitsplatApplied hitsplatApplied = getHitsplatApplied(HitsplatID.DAMAGE_ME, 6, actor);

            onHitsplatApplied.onEvent(hitsplatApplied);
            verify(overlayOrchestrator, times(0)).updateDamage(any(), anyInt());
        }

        @Test
        void should_not_update_damage_if_no_damage() {
            Actor actor = mock(Actor.class);
            HitsplatApplied hitsplatApplied = getHitsplatApplied(0, actor);

            onHitsplatApplied.onEvent(hitsplatApplied);
            verify(overlayOrchestrator, times(0)).updateDamage(any(), anyInt());
        }

        @Test
        void should_not_update_damage_if_overlay_disabled() {
            config = new VenomTimerConfig() {
                @Override
                public boolean overlayEnabled() {
                    return false;
                }
            };
            onHitsplatApplied = new OnHitsplatApplied(config, overlayOrchestrator);
            HitsplatApplied hitsplatApplied = new HitsplatApplied();

            onHitsplatApplied.onEvent(hitsplatApplied);
            verify(overlayOrchestrator, times(0)).updateDamage(any(), anyInt());
        }
    }

    private static HitsplatApplied getHitsplatApplied(int damage, Actor actor) {
        return getHitsplatApplied(HitsplatID.VENOM, damage, actor);
    }

    private static HitsplatApplied getHitsplatApplied(@HitsplatType int type, int damage, Actor actor) {
        HitsplatApplied hitsplatApplied = new HitsplatApplied();
        hitsplatApplied.setHitsplat(new Hitsplat(type, damage, 0));
        hitsplatApplied.setActor(actor);
        return hitsplatApplied;
    }
}
package com.simonflapse.osrs.venom.events;

import com.simonflapse.osrs.venom.VenomTimerConfig;
import com.simonflapse.osrs.venom.ui.OverlayOrchestrator;
import net.runelite.client.events.ConfigChanged;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

class OnConfigChangedTest {

    OnConfigChanged onConfigChanged;
    OverlayOrchestrator overlayOrchestrator;

    @BeforeEach
    void setUp() {
        this.overlayOrchestrator = Mockito.mock(OverlayOrchestrator.class);
        this.onConfigChanged = new OnConfigChanged(overlayOrchestrator);
    }

    @Nested
    class onEvent {
        @Test
        void should_shutdown_overlays_when_overlay_enabled_is_turned_off() {
            ConfigChanged configChanged = getConfigChanged("false");
            onConfigChanged.onEvent(configChanged);

            Mockito.verify(overlayOrchestrator).shutDown();
        }

        @Test
        void should_not_shutdown_overlays_when_overlay_enabled_is_turned_on() {
            ConfigChanged configChanged = getConfigChanged("true");
            onConfigChanged.onEvent(configChanged);

            Mockito.verify(overlayOrchestrator, Mockito.times(0)).shutDown();
        }

        private ConfigChanged getConfigChanged(String newValue) {
            ConfigChanged configChanged = new ConfigChanged();
            configChanged.setGroup(VenomTimerConfig.CONFIG_GROUP);
            configChanged.setKey(VenomTimerConfig.OVERLAY_ENABLED);
            configChanged.setNewValue(newValue);
            return configChanged;
        }
    }
}
package com.simonflapse.osrs.venom;


import com.simonflapse.osrs.venom.events.OnConfigChanged;
import com.simonflapse.osrs.venom.events.OnHitsplatApplied;
import com.simonflapse.osrs.venom.ui.OverlayOrchestrator;
import com.simonflapse.osrs.venom.ui.VenomTimerOverlay;
import com.simonflapse.osrs.venom.ui.utils.GraphicsUtil;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.game.NPCManager;
import net.runelite.client.ui.overlay.OverlayManager;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;

import java.awt.*;

import static org.mockito.Mockito.*;

@ExtendWith({MockitoExtension.class})
@MockitoSettings(strictness = Strictness.STRICT_STUBS)
class VenomTimerPluginTest {
    @InjectMocks
    final VenomTimerPlugin plugin = new VenomTimerPlugin();

    @Spy
    final VenomTimerConfig config = new VenomTimerConfig() {
        @Override
        public boolean timeToDeathEnabled() {
            return true;
        }
    };

    final OverlayManager overlayManager = mock(OverlayManager.class);

    final NPCManager npcManager = mock(NPCManager.class);

    @Spy
    final OverlayOrchestrator overlayOrchestrator = new OverlayOrchestrator(overlayManager, config, npcManager);

    @Spy
    final OnConfigChanged onConfigChanged = new OnConfigChanged(overlayOrchestrator);

    @Spy
    final OnHitsplatApplied onHitsplatApplied = new OnHitsplatApplied(config, overlayOrchestrator);

    @Nested
    class onHitsplatApplied {
        @Test
        void should() {
            HitsplatApplied hitsplatApplied = new HitsplatApplied();
            hitsplatApplied.setHitsplat(new Hitsplat(HitsplatID.VENOM, 6, 0));

            NPC npc = mock(NPC.class);
            when(npc.getHealthRatio()).thenReturn(28);
            when(npc.getHealthScale()).thenReturn(30);
            when(npcManager.getHealth(anyInt())).thenReturn(30);
            hitsplatApplied.setActor(npc);

            plugin.onHitsplatApplied(hitsplatApplied);
            ArgumentCaptor<VenomTimerOverlay> argumentCaptor = ArgumentCaptor.forClass(VenomTimerOverlay.class);
            verify(overlayManager).add(argumentCaptor.capture());

            VenomTimerOverlay overlay = argumentCaptor.getValue();

            Graphics2D graphics2D = GraphicsUtil.getSpyGraphics2D();

            when(npc.getCanvasTextLocation(eq(graphics2D), anyString(), anyInt()))
                    .thenAnswer((invocation) -> new Point(0, invocation.getArgument(2)));

            overlay.render(graphics2D);
        }
    }
}
package com.simonflapse.osrs.venom.ui;

import com.simonflapse.osrs.venom.VenomTimerConfig;
import net.runelite.api.Actor;
import net.runelite.client.game.NPCManager;
import net.runelite.client.ui.overlay.OverlayManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;

import java.awt.*;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class OverlayOrchestratorTest {
    OverlayOrchestrator overlayOrchestrator;
    OverlayManager overlayManager;
    VenomTimerConfig config;
    NPCManager npcManager;

    @BeforeEach
    void setUp() {
        overlayManager = mock(OverlayManager.class);
        config = mock(VenomTimerConfig.class);
        npcManager = mock(NPCManager.class);
        overlayOrchestrator = new OverlayOrchestrator(overlayManager, config, npcManager);
    }

    @Nested
    class updateDamage {
        @Test
        void should_not_throw_exceptions() {
            overlayOrchestrator.updateDamage(mock(Actor.class), 6);
        }

        @Test
        void should_reuse_active_overlay() {
            Actor actor = mock(Actor.class);
            overlayOrchestrator.updateDamage(actor, 6);
            overlayOrchestrator.updateDamage(actor, 6);

            verify(overlayManager, times(1)).add(any());
        }

        @Test
        void should_support_multiple_overlays() {
            overlayOrchestrator.updateDamage(mock(Actor.class), 6);
            overlayOrchestrator.updateDamage(mock(Actor.class), 6);

            verify(overlayManager, times(2)).add(any());
        }

        @Test
        void should_remove_irrelevant_overlay() {
            Actor actor = mock(Actor.class);
            when(actor.isDead()).thenReturn(true);
            overlayOrchestrator.updateDamage(actor, 6);

            ArgumentCaptor<VenomTimerOverlay> captor = ArgumentCaptor.forClass(VenomTimerOverlay.class);
            verify(overlayManager).add(captor.capture());

            captor.getValue().render(mock(Graphics2D.class));

            verify(overlayManager).remove(any());
        }
    }

    @Nested
    class shutdown {
        @Test
        void should_remove_all_active_overlays() {
            overlayOrchestrator.updateDamage(mock(Actor.class), 6);
            overlayOrchestrator.updateDamage(mock(Actor.class), 6);

            overlayOrchestrator.shutDown();

            verify(overlayManager, times(2)).remove(any());
        }
    }
}
package com.simonflapse.osrs.venom.ui.utils;

import net.runelite.api.Point;
import net.runelite.client.util.ColorUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.awt.*;
import java.util.ArrayList;

import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;

public class DrawStringTest {
    Graphics2D graphics2D;

    @BeforeEach
    void setUp() {
        this.graphics2D = GraphicsUtil.getSpyGraphics2D();
    }
    @Nested
    class renderTextLocation {
        @Test
        void should_not_render_text_if_empty_string_list() {
            Point point = new Point(0, 0);
            ArrayList<StringGraphics> strings = new ArrayList<>();
            DrawString.renderTextLocation(graphics2D, point, strings);

            verifyNoInteractions(graphics2D);
        }

        @Test
        void should_not_render_text_if_list_has_empty_string() {
            Point point = new Point(0, 0);
            ArrayList<StringGraphics> strings = new ArrayList<>();
            strings.add(new StringGraphics("", Color.BLACK));
            DrawString.renderTextLocation(graphics2D, point, strings);

            verifyNoInteractions(graphics2D);
        }

        @Test
        void should_render_shadow() {
            Point point = new Point(0, 0);
            ArrayList<StringGraphics> strings = new ArrayList<>();
            strings.add(new StringGraphics("Test", Color.WHITE));
            DrawString.renderTextLocation(graphics2D, point, strings);

            verifyShadow(point);
        }

        private void verifyShadow(Point point) {
            verifyStringRenderedWithColor(Color.BLACK, "", point.getX() + 1, point.getY() + 1);
            verifyStringRenderedWithColor(ColorUtil.colorWithAlpha(Color.BLACK, 50), "", point.getX() + 2, point.getY() + 2);
        }

        @Test
        void should_render_text() {
            Point point = new Point(0, 0);
            ArrayList<StringGraphics> strings = new ArrayList<>();
            String expectedString = "Test";
            Color expectedColor = Color.WHITE;

            strings.add(new StringGraphics(expectedString, expectedColor));
            DrawString.renderTextLocation(graphics2D, point, strings);

            verifyStringRenderedWithColor(expectedColor, expectedString, point.getX(), point.getY());
        }

        @Test
        void should_render_string_consistent_of_multiple_string_graphics() {
            Point point = new Point(0, 0);
            ArrayList<StringGraphics> strings = new ArrayList<>();
            String expectedFirstString = "Test";
            String expectedSecondString = "Hello World";
            Color expectedFirstColor = Color.WHITE;
            Color expectedSecondColor = Color.YELLOW;

            strings.add(new StringGraphics(expectedFirstString, expectedFirstColor));
            strings.add(new StringGraphics(expectedSecondString, expectedSecondColor));
            DrawString.renderTextLocation(graphics2D, point, strings);

            verifyStringRenderedWithColor(expectedFirstColor, expectedFirstString, point.getX(), point.getY());
            verifyStringRenderedWithColor(expectedFirstColor, expectedFirstString, point.getX(), point.getY());
        }
    }

    private void verifyStringRenderedWithColor(Color expectedColor, String string, int expectedX, int expectedY) {
        verifyStringRenderedWithColor(graphics2D, expectedColor, string, expectedX, expectedY);
    }

    public static void verifyStringRenderedWithColor(Graphics2D graphics2D, Color expectedColor, String string, int expectedX, int expectedY) {
        verify(graphics2D).setColor(expectedColor);
        verify(graphics2D).drawString(contains(string), eq(expectedX), eq(expectedY));
    }
}
package com.simonflapse.osrs.venom.ui.utils;

import org.mockito.Mockito;

import java.awt.*;
import java.awt.image.BufferedImage;

public class GraphicsUtil {
    public static Graphics2D getSpyGraphics2D() {
        BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
        return Mockito.spy(image.createGraphics());
    }
}

package com.simonflapse.osrs.venom.ui;

import com.simonflapse.osrs.venom.VenomTimerConfig;
import com.simonflapse.osrs.venom.ui.utils.DrawStringTest;
import com.simonflapse.osrs.venom.ui.utils.GraphicsUtil;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.game.NPCManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import java.awt.*;
import java.time.Clock;
import java.time.Duration;
import java.time.Instant;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

class VenomTimerOverlayTest {

    VenomTimerOverlay overlay;

    VenomTimerConfig config;
    NPCManager npcManager;
    NPC npc;
    ActorOverlayRemover actorOverlayRemover;
    Graphics2D graphics2D;

    @BeforeEach
    void setUp() {
        config = spy(new VenomTimerConfig() {});
        npcManager = mock(NPCManager.class);
        npc = mock(NPC.class);
        actorOverlayRemover = mock(ActorOverlayRemover.class);

        overlay = new VenomTimerOverlay(config, npcManager, npc, actorOverlayRemover);

        graphics2D = GraphicsUtil.getSpyGraphics2D();
    }

    @Nested
    class updateVenom {
        @Test
        void should_update_total_damage() {
            setRenderFlags(false, true, false, false);

            when(npc.getCanvasTextLocation(eq(graphics2D), anyString(), anyInt()))
                    .thenAnswer((invocation) -> new Point(0, invocation.getArgument(2)));

            overlay.updateVenom(6);
            overlay.updateVenom(8);
            overlay.render(graphics2D);

            Color expectedColor = new Color(22,48,40).brighter().brighter();

            verifyStringRenderedWithColor(expectedColor, "Total damage: 14", 0, 100);
        }
    }

    @Nested
    class render {
        @Nested
        class should_not_render_if {
            @Test
            void venom_not_updated_yet() {
                overlay.render(graphics2D);
                verifyNoInteractions(graphics2D);
            }

            @Test
            void canvas_text_location_is_null() {
                when(npc.getCanvasTextLocation(eq(graphics2D), anyString(), anyInt())).thenReturn(null);

                updateVenomAndRender(6);

                verifyNoInteractions(graphics2D);
            }

            @Test
            void time_to_next_venom_is_less_than_1() {
                Clock fixedClock = Clock.fixed(Instant.EPOCH, Clock.systemUTC().getZone());
                Duration duration = Duration.ofSeconds(19);
                Instant instantZeroSeconds = Instant.now(fixedClock);
                Instant instant19Seconds = instantZeroSeconds.plus(duration);

                try (MockedStatic<Instant> mockedStatic = mockStatic(Instant.class, Mockito.CALLS_REAL_METHODS)) {
                    mockedStatic.when(Instant::now).thenReturn(instantZeroSeconds);

                    overlay.updateVenom(6);
                    mockedStatic.when(Instant::now).thenReturn(instant19Seconds);
                    overlay.render(graphics2D);

                    verifyNoInteractions(actorOverlayRemover);
                    verifyNoInteractions(graphics2D);
                }
            }
        }

        @Nested
        class should_remove_overlay_if {
            @Test
            void actor_is_null() {
                overlay = new VenomTimerOverlay(config, npcManager, null, actorOverlayRemover);
                overlay.updateVenom(6);
                verifyOverlayRemovedOnRender(null);
            }

            @Test
            void actor_is_dead() {
                when(npc.isDead()).thenReturn(true);
                overlay.updateVenom(6);
                verifyOverlayRemovedOnRender(npc);
            }

            @Test
            void time_to_next_venom_was_over_9_seconds_ago() {
                Clock fixedClock = Clock.fixed(Instant.EPOCH, Clock.systemUTC().getZone());
                Duration duration = Duration.ofSeconds(30);
                Instant instantZeroSeconds = Instant.now(fixedClock);
                Instant instant30Seconds = instantZeroSeconds.plus(duration);

                try (MockedStatic<Instant> mockedStatic = mockStatic(Instant.class, Mockito.CALLS_REAL_METHODS)) {
                    mockedStatic.when(Instant::now).thenReturn(instantZeroSeconds);

                    overlay.updateVenom(6);

                    mockedStatic.when(Instant::now).thenReturn(instant30Seconds);
                    verifyOverlayRemovedOnRender(npc);
                }
            }

            private void verifyOverlayRemovedOnRender(NPC npc) {
                overlay.render(graphics2D);

                verify(actorOverlayRemover).removeActorOverlay(npc, overlay);
                verifyNoInteractions(graphics2D);
            }
        }


        @Nested
        class should_draw_string {
            static final int EXPECTED_X = 0;
            static final int EXPECTED_Y = 100;

            @Test
            void next_damage() {
                setRenderFlags(true, false, false, false);

                when(npc.getCanvasTextLocation(eq(graphics2D), anyString(), anyInt()))
                        .thenAnswer((invocation) -> new Point(0, invocation.getArgument(2)));

                updateVenomAndRender(6);

                Color expectedColor = new Color(22,48,40).brighter().brighter();

                verifyStringRenderedWithColor(expectedColor, "Next damage: 8", EXPECTED_X, EXPECTED_Y);
            }

            @Test
            void total_damage() {
                setRenderFlags(false, true, false, false);

                when(npc.getCanvasTextLocation(eq(graphics2D), anyString(), anyInt()))
                        .thenAnswer((invocation) -> new Point(0, invocation.getArgument(2)));

                updateVenomAndRender(6);

                Color expectedColor = new Color(22,48,40).brighter().brighter();

                verifyStringRenderedWithColor(expectedColor, "Total damage: 6", EXPECTED_X, EXPECTED_Y);
            }

            @Test
            void venom_in() {
                setRenderFlags(false, false, true, false);

                when(npc.getCanvasTextLocation(eq(graphics2D), anyString(), anyInt()))
                        .thenAnswer((invocation) -> new Point(0, invocation.getArgument(2)));

                updateVenomAndRender(6);

                Color expectedColor = new Color(73,151,126);

                verifyStringRenderedWithColor(expectedColor, "Venom in:", EXPECTED_X, EXPECTED_Y);
            }

            @Test
            void death_in() {
                setRenderFlags(false, false, false, true);

                when(npc.getCanvasTextLocation(eq(graphics2D), anyString(), anyInt()))
                        .thenAnswer((invocation) -> new Point(0, invocation.getArgument(2)));

                when(npc.getHealthRatio()).thenReturn(30);
                when(npc.getHealthScale()).thenReturn(30);
                when(npcManager.getHealth(anyInt())).thenReturn(30);

                updateVenomAndRender(6);

                Color expectedColor = new Color(73,151,126);

                verifyStringRenderedWithColor(expectedColor, "Dead in:", EXPECTED_X, EXPECTED_Y);
            }
        }

        private void updateVenomAndRender(int damage) {
            overlay.updateVenom(damage);
            overlay.render(graphics2D);
        }
    }

    private void setRenderFlags(boolean nextDamage, boolean totalDamage, boolean nextVenom, boolean deathTime) {
        when(config.nextDamageEnabled()).thenReturn(nextDamage);
        when(config.totalDamageEnabled()).thenReturn(totalDamage);
        when(config.timeToNextVenomEnabled()).thenReturn(nextVenom);
        when(config.timeToDeathEnabled()).thenReturn(deathTime);
    }

    private void verifyStringRenderedWithColor(Color expectedColor, String string, int expectedX, int expectedY) {
        DrawStringTest.verifyStringRenderedWithColor(graphics2D, expectedColor, string, expectedX, expectedY);
    }
}
package com.simonflapse.osrs.venom.combat;

import org.junit.jupiter.api.Nested;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import static org.junit.jupiter.api.Assertions.assertEquals;

class HealthUtilTest {

    @Nested
    class getApproximateHealth {
        @ParameterizedTest
        @MethodSource({
                "com.simonflapse.osrs.venom.combat.HealthArgument#badHealthValues",
                "com.simonflapse.osrs.venom.combat.HealthArgument#healthDecreasingByOne",
                "com.simonflapse.osrs.venom.combat.HealthArgument#healthValues"
        })
        void should_get_expected_health(HealthArgument argument) {
            int approximateHealth = HealthUtil.getApproximateHealth(
                    argument.getMaxHealth(),
                    argument.getHealthRatio(),
                    argument.getHealthScale()
            );
            assertEquals(argument.getExpectedHealth(), approximateHealth);
        }
    }
}
package com.simonflapse.osrs.venom.combat;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.ArrayList;
import java.util.stream.Stream;

@AllArgsConstructor
@Getter
class HealthArgument {
    private final String name;
    private final int maxHealth;
    private final int healthRatio;
    private final int healthScale;
    private final int expectedHealth;

    @Override
    public String toString() {
        if (name == null) {
            return String.format("Max Health: %s HealthScale %s/%s ", maxHealth, healthRatio, healthScale);
        }
        return String.format("%s ---- Max Health: %s ---- HealthScale %s/%s ----", name, maxHealth, healthRatio, healthScale);
    }

    static Stream<HealthArgument> badHealthValues() {
        return Stream.of(
                new HealthArgument("Dead without health scale",10, 0, 0, 0),
                new HealthArgument("Dead with health scale",10, 0, 30, 0),
                new HealthArgument("Dead with bugged healthRation",10, 29, 0, 0),
                new HealthArgument("Invalid health ratio",10, -1, 30, -1),
                new HealthArgument("Invalid health scale",10, 29, -1, -1),
                new HealthArgument("Invalid health scale and ratio",10, -1, -1, -1),
                new HealthArgument("Invalid maxHealth",-1, 29, 30, -1)
        );
    }

    static Stream<HealthArgument> healthDecreasingByOne() {
        int healthScale = 30;
        ArrayList<HealthArgument> arguments = new ArrayList<>();
        for (int healthRatio = 30; healthRatio >= 0; healthRatio--) {
            arguments.add(new HealthArgument(
                    String.format("Health left %s", healthRatio),
                    healthScale,
                    healthRatio,
                    healthScale,
                    healthRatio)
            );
        }

        return Stream.of(arguments.toArray(new HealthArgument[0]));
    }

    static Stream<HealthArgument> healthValues() {
        return Stream.of(
                new HealthArgument("Simple taken 1 damage",10, 29, 30, 9),
                new HealthArgument("Truncated taken 1 damage",99, 29, 30, 98),
                new HealthArgument("Simple Boss health ratio",1250, 10, 100, 126),
                new HealthArgument("Simple Boss full health",1250, 10, 100, 126),
                new HealthArgument("Truncated Boss health ratio",3070, 63, 75, 2613),
                new HealthArgument("Truncated Boss full health",3070, 75, 75, 3070),
                new HealthArgument("1 HP only",1, 1, 1, 1)
        );
    }
}

package com.simonflapse.osrs.venom.combat;

import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.client.game.NPCManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.ArgumentMatchers;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import java.time.Clock;
import java.time.Duration;
import java.time.Instant;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.params.ParameterizedTest.DEFAULT_DISPLAY_NAME;
import static org.mockito.Mockito.*;

class VenomDamageTest {
    NPCManager npcManager;
    Actor actor;
    VenomDamage venomDamage;

    @BeforeEach
    void setUp() {
        npcManager = Mockito.mock(NPCManager.class);
        actor = Mockito.mock(NPC.class);
        venomDamage = new VenomDamage(npcManager, actor);
    }

    @Nested
    class updateVenom {
        @Test
        void should_update_total_damage() {
            assertEquals(0, venomDamage.getTotalDamage());

            venomDamage.updateVenom(6);

            assertEquals(6, venomDamage.getTotalDamage());
        }

        @Test
        void should_update_append_total_damage() {
            venomDamage.updateVenom(6);
            venomDamage.updateVenom(8);

            assertEquals(14, venomDamage.getTotalDamage());
        }

        @ParameterizedTest(name = DEFAULT_DISPLAY_NAME + " venom damage")
        @ValueSource(ints = {6, 8, 10, 12, 14, 16, 18, 20})
        void should_update_next_damage(int damage) {
            venomDamage.updateVenom(damage);

            int expectedNextDamage = Math.min(20, damage + 2);

            assertEquals(expectedNextDamage, venomDamage.getNextDamage());
        }
    }

    @Nested
    class timeDifference {
        @Test
        void should_return_5_when_14_seconds_have_elapsed_since_updateVenom() {
            Clock fixedClock = Clock.fixed(Instant.EPOCH, Clock.systemUTC().getZone());
            Duration duration = Duration.ofSeconds(14);
            Instant instantZeroSeconds = Instant.now(fixedClock);
            Instant instant14Seconds = instantZeroSeconds.plus(duration);

            try (MockedStatic<Instant> mockedStatic = mockStatic(Instant.class, Mockito.CALLS_REAL_METHODS)) {
                mockedStatic.when(Instant::now).thenReturn(instantZeroSeconds);
                venomDamage.updateVenom(6);
                mockedStatic.when(Instant::now).thenReturn(instant14Seconds);
                long timeDifference = venomDamage.timeDifference();
                assertEquals(5, timeDifference);
            }
        }
    }

    @Nested
    class calculateTimeToDeath {
        @Test
        void should_return_41_seconds_for_npc_with_20_hp() {
            mockActorHealth(20, 30, 30);
            venomDamage.updateVenom(6);
            long timeToDeath = venomDamage.calculateTimeToDeath(5);
            assertEquals(5, timeToDeath % 18);
            assertEquals(41, timeToDeath);
        }

        @Test
        void should_return_negative_1_seconds_for_player() {
            actor = mock(Player.class);
            venomDamage = new VenomDamage(npcManager, actor);
            long timeToDeath = venomDamage.calculateTimeToDeath(5);
            assertEquals(-1, timeToDeath);
        }

        @Test
        void should_return_negative_1_seconds_for_npc_with_0_max_health() {
            long timeToDeath = venomDamage.calculateTimeToDeath(5);
            assertEquals(-1, timeToDeath);
        }

        @Test
        void should_return_negative_1_seconds_for_npc_with_null_max_health() {
            when(npcManager.getHealth(ArgumentMatchers.anyInt())).thenReturn(null);
            long timeToDeath = venomDamage.calculateTimeToDeath(5);
            assertEquals(-1, timeToDeath);
        }

        @Test
        void should_return_correct_time_even_if_healthScale_and_healthRation_information_is_lost() {
            mockActorHealth(30, 30, 30);
            venomDamage.updateVenom(6);
            venomDamage.calculateTimeToDeath(5);

            mockActorHealth(30, -1, -1);
            long timeToDeath = venomDamage.calculateTimeToDeath(5);
            assertEquals(5, timeToDeath % 18);
            assertEquals(41, timeToDeath);
        }
    }

    private void mockActorHealth(int maxHealth, int healthScale, int healthRatio) {
        when(npcManager.getHealth(ArgumentMatchers.anyInt())).thenReturn(maxHealth);
        when(actor.getHealthScale()).thenReturn(healthScale);
        when(actor.getHealthRatio()).thenReturn(healthRatio);
    }
}
package com.simonflapse.osrs;

import com.simonflapse.osrs.venom.VenomTimerPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import org.junit.jupiter.api.Disabled;

@Disabled("Intended as a main entry point for locally running RuneLite with the plugin enabled")
public class StartRunelite
{
	@SuppressWarnings({"unchecked", "varargs"})
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(VenomTimerPlugin.class);
		RuneLite.main(args);
	}
}
package com.simonflapse.osrs.venom.events;

import com.simonflapse.osrs.venom.VenomTimerConfig;
import com.simonflapse.osrs.venom.ui.OverlayOrchestrator;
import net.runelite.client.events.ConfigChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

@Singleton
public class OnConfigChanged {
    private final Map<String, Consumer<String>> configurationConsumers = new HashMap<>();

    private final OverlayOrchestrator overlayOrchestrator;

    @Inject
    public OnConfigChanged(OverlayOrchestrator overlayOrchestrator) {
        initializeConsumersMap();

        this.overlayOrchestrator = overlayOrchestrator;
    }

    private void initializeConsumersMap() {
        configurationConsumers.put(VenomTimerConfig.OVERLAY_ENABLED, this::overlayConfigChanged);
    }

    public void onEvent(ConfigChanged configChanged) {
        if (!isVenomTimerConfig(configChanged)) {
            return;
        }

        configurationChanged(configChanged);
    }

    private void configurationChanged(ConfigChanged configChanged) {
        String configurationName = configChanged.getKey();
        String configurationValue = configChanged.getNewValue();
        Consumer<String> consumer = configurationConsumers.get(configurationName);
        if (consumer != null) {
            consumer.accept(configurationValue);
        }
    }

    private static boolean isVenomTimerConfig(ConfigChanged configChanged) {
        return configChanged.getGroup().equals(VenomTimerConfig.CONFIG_GROUP);
    }

    private void removeOverlays() {
        overlayOrchestrator.shutDown();
    }

    private void overlayConfigChanged(String newValue) {
        boolean enabled = Boolean.parseBoolean(newValue);
        if (!enabled) {
            removeOverlays();
        }
    }
}

package com.simonflapse.osrs.venom.events;

import com.simonflapse.osrs.venom.VenomTimerConfig;
import com.simonflapse.osrs.venom.ui.OverlayOrchestrator;
import net.runelite.api.Actor;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.events.HitsplatApplied;

import javax.inject.Inject;

public class OnHitsplatApplied {
    private final VenomTimerConfig config;
    private final OverlayOrchestrator overlayOrchestrator;

    @Inject
    public OnHitsplatApplied(VenomTimerConfig config, OverlayOrchestrator overlayOrchestrator) {
        this.config = config;
        this.overlayOrchestrator = overlayOrchestrator;
    }

    public void onEvent(HitsplatApplied hitsplatApplied) {
        if (!config.overlayEnabled()) {
            return;
        }

        updateVenomDamage(hitsplatApplied);
    }

    private void updateVenomDamage(HitsplatApplied hitsplatApplied) {
        Hitsplat hitsplat = hitsplatApplied.getHitsplat();
        Actor target = hitsplatApplied.getActor();

        if (!isHitsplatRelevant(target, hitsplat)) {
            return;
        }

        overlayOrchestrator.updateDamage(target, hitsplat.getAmount());
    }

    private static boolean isHitsplatRelevant(Actor target, Hitsplat hitsplat) {
        if (target.isDead() || hitsplat.getAmount() <= 0) {
            return false;
        }

        return hitsplat.getHitsplatType() == HitsplatID.VENOM;
    }
}

package com.simonflapse.osrs.venom;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import static com.simonflapse.osrs.venom.VenomTimerConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface VenomTimerConfig extends Config {
    String CONFIG_GROUP = "venomtimer";
    String OVERLAY_ENABLED = "venomTimerOverlayEnabled";
    String TIME_TO_NEXT_VENOM_ENABLED = "timeToNextVenomEnabled";
    String TOTAL_DAMAGE_ENABLED = "totalDamageEnabled";
    String NEXT_DAMAGE_ENABLED = "nextDamageEnabled";
    String TIME_TO_DEATH_ENABLED = "timeToDeathEnabled";

    @ConfigItem(
            keyName = OVERLAY_ENABLED,
            name = "Venom Timer Overlay",
            description = "Displays venom information above Players and NPCs that are affected by venom",
            position = 0
    )
    default boolean overlayEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = TIME_TO_NEXT_VENOM_ENABLED,
            name = "Time to next venom splat",
            description = "Displays a timer that indicates when the target next will take damage from venom",
            position = 1
    )
    default boolean timeToNextVenomEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = NEXT_DAMAGE_ENABLED,
            name = "Next venom damage",
            description = "Displays how much the next venom splat will damage the target",
            position = 2
    )
    default boolean nextDamageEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = TOTAL_DAMAGE_ENABLED,
            name = "Total venom damage",
            description = "Displays the total amount of venom damage on the target",
            position = 3
    )
    default boolean totalDamageEnabled() {
        return true;
    }

    @ConfigItem(
        keyName = TIME_TO_DEATH_ENABLED,
        name = "Time to die",
        description = "Displays an additional timer that indicates when the target will die from venom",
        position = 4
    )
    default boolean timeToDeathEnabled() {
        return true;
    }
}

package com.simonflapse.osrs.venom.ui;

import net.runelite.api.Actor;
import net.runelite.client.ui.overlay.Overlay;

public interface ActorOverlayRemover {
    void removeActorOverlay(Actor actor, Overlay overlay);
}

package com.simonflapse.osrs.venom.ui;

import com.simonflapse.osrs.venom.VenomTimerConfig;
import com.simonflapse.osrs.venom.combat.VenomDamage;
import com.simonflapse.osrs.venom.ui.utils.DrawString;
import com.simonflapse.osrs.venom.ui.utils.StringGraphics;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Point;
import net.runelite.client.game.NPCManager;
import net.runelite.client.ui.overlay.Overlay;

import java.awt.*;
import java.util.ArrayList;

@Slf4j
public class VenomTimerOverlay extends Overlay {

    private final VenomTimerConfig config;
    private final NPCManager npcManager;
    private final Actor actor;
    private final ActorOverlayRemover overlayRemover;

    private VenomDamage venomDamage;

    public VenomTimerOverlay(VenomTimerConfig config, NPCManager npcManager, Actor actor, ActorOverlayRemover overlayRemover) {
        this.config = config;
        this.npcManager = npcManager;
        this.actor = actor;
        this.overlayRemover = overlayRemover;
    }

    public void updateVenom(int damage) {
        if (venomDamage == null) {
            this.venomDamage = new VenomDamage(npcManager, actor);
        }
        this.venomDamage.updateVenom(damage);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (venomDamage == null) {
            return null;
        }

        if (!renderActorOverlay(graphics)) {
            overlayRemover.removeActorOverlay(this.actor, this);
        }
        return null;
    }

    private boolean renderActorOverlay(Graphics2D graphics) {
        long timeToNextVenom = this.venomDamage.timeDifference();

        long timeToDead = -1;
        if (config.timeToDeathEnabled()) {
            timeToDead = this.venomDamage.calculateTimeToDeath(timeToNextVenom);
        }

        if (!isActorOverlayRelevant(timeToNextVenom)) {
            return false;
        }

        if (timeToNextVenom <= 0) {
            return true;
        }

        drawText(graphics, timeToNextVenom, timeToDead);
        return true;
    }

    private void drawText(Graphics2D graphics, long timeToNextVenom, long timeToDeath) {
        int yOffset = 0;

        Color lightVenomColor = new Color(73,151,126);
        Color darkVenomColor = new Color(22,48,40).brighter().brighter();

        if (config.totalDamageEnabled()) {
            yOffset = drawSingleLineText(new StringGraphics("Total damage: " + this.venomDamage.getTotalDamage(), darkVenomColor), graphics, yOffset);
        }

        if (config.nextDamageEnabled()) {
            yOffset = drawSingleLineText(new StringGraphics("Next damage: " + this.venomDamage.getNextDamage(), darkVenomColor), graphics, yOffset);
        }

        if (config.timeToNextVenomEnabled()) {
            yOffset = drawSingleLineText(new StringGraphics("Venom in: " + timeToNextVenom + "s", lightVenomColor), graphics, yOffset);
        }

        if (timeToDeath > 0) {
            drawSingleLineText(new StringGraphics("Dead in: " + timeToDeath + "s", lightVenomColor), graphics, yOffset);
        }
    }

    private boolean isActorOverlayRelevant(long timeToNextVenom) {
        if (actor == null || actor.isDead()) {
            return false;
        }

        return timeToNextVenom > -9;
    }

    private int drawSingleLineText(StringGraphics stringGraphic, Graphics2D graphics, int yOffset) {
        ArrayList<StringGraphics> stringGraphics = new ArrayList<>();
        stringGraphics.add(stringGraphic);
        println(stringGraphics, graphics, yOffset);

        return yOffset + 15;
    }

    private void println(ArrayList<StringGraphics> stringGraphics, Graphics2D graphics, int yOffset) {
        Point textLocation = actor.getCanvasTextLocation(graphics, getUnformattedString(stringGraphics), actor.getLogicalHeight() + 100);
        if (textLocation != null)
        {
            textLocation = new Point(textLocation.getX(), textLocation.getY() + yOffset);
            DrawString.renderTextLocation(graphics, textLocation, stringGraphics);
        }
    }

    private static String getUnformattedString(ArrayList<StringGraphics> texts) {
        StringBuilder unformattedString = new StringBuilder();
        for (StringGraphics text : texts) {
            unformattedString.append(text.getString());
        }
        return unformattedString.toString();
    }
}

package com.simonflapse.osrs.venom.ui.utils;

import com.google.common.base.Strings;
import net.runelite.api.Point;
import net.runelite.client.util.ColorUtil;

import java.awt.*;
import java.util.ArrayList;

public final class DrawString {
    private DrawString() {}

    public static void renderTextLocation(Graphics2D graphics, Point txtLoc, ArrayList<StringGraphics> texts) {
        int x = txtLoc.getX();
        int y = txtLoc.getY();

        for (StringGraphics text : texts){
            if (Strings.isNullOrEmpty(text.getString())) {
                return;
            }

            renderTextShadow(graphics, x, y, text.getString());

            graphics.setColor(ColorUtil.colorWithAlpha(text.getColor(), 0xFF));
            graphics.drawString(text.getString(), x, y);
            x += text.width(graphics);
        }
    }

    private static void renderTextShadow(Graphics2D graphics, int x, int y, String text) {
        graphics.setColor(Color.BLACK);
        graphics.drawString(text, x + 1, y + 1);

        graphics.setColor(ColorUtil.colorWithAlpha(Color.BLACK,  50));
        graphics.drawString(text, x + 2, y + 2);
    }
}

package com.simonflapse.osrs.venom.ui.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.awt.*;

@Getter
@AllArgsConstructor
public class StringGraphics {
    private String string;
    private Color color;

    public int width(Graphics graphics) {
        return graphics.getFontMetrics().stringWidth(string);
    }
}

package com.simonflapse.osrs.venom.ui;

import com.simonflapse.osrs.venom.VenomTimerConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.client.game.NPCManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Singleton
public class OverlayOrchestrator {
    private final ConcurrentHashMap<Actor, VenomTimerOverlay> activeOverlays = new ConcurrentHashMap<>();
    private final OverlayManager overlayManager;
    private final VenomTimerConfig config;
    private final NPCManager npcManager;

    @Inject
    public OverlayOrchestrator(OverlayManager overlayManager, VenomTimerConfig config, NPCManager npcManager) {
        this.overlayManager = overlayManager;
        this.config = config;
        this.npcManager = npcManager;
    }

    public void updateDamage(Actor actor, int damage) {
        VenomTimerOverlay actorOverlay = activeOverlays.get(actor);
        if (actorOverlay == null) {
            actorOverlay = initializeNewOverlay(actor);
        }

        actorOverlay.updateVenom(damage);
    }

    private VenomTimerOverlay initializeNewOverlay(Actor actor) {
        VenomTimerOverlay actorOverlay = new VenomTimerOverlay(config, npcManager, actor, this::removeActorOverlay);
        overlayManager.add(actorOverlay);
        activeOverlays.put(actor, actorOverlay);
        return actorOverlay;
    }

    private void removeActorOverlay(Actor actor, Overlay overlay) {
        log.debug("Overlay associated with: {} will be removed", getActorName(actor));
        activeOverlays.remove(actor);
        overlayManager.remove(overlay);
    }

    public void shutDown() {
        for (Overlay overlay : activeOverlays.values()) {
            overlayManager.remove(overlay);
        }
        activeOverlays.clear();
    }

    private static String getActorName(Actor actor) {
        String name = actor.getName();
        if (actor instanceof NPC) {
            name += "#" + ((NPC) actor).getId();
        }
        return name;
    }
}

package com.simonflapse.osrs.venom;

import com.google.inject.Provides;
import com.simonflapse.osrs.venom.events.OnConfigChanged;
import com.simonflapse.osrs.venom.events.OnHitsplatApplied;
import com.simonflapse.osrs.venom.ui.OverlayOrchestrator;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

import javax.inject.Inject;

@Slf4j
@PluginDescriptor(
		name = "Venom Timer",
		description = "Visual indication of venom damage",
		tags = {"combat, venom"}
)
public class VenomTimerPlugin extends Plugin {

	@Inject
	private OnConfigChanged onConfigChanged;

	@Inject
	private OnHitsplatApplied onHitsplatApplied;

	@Inject
	private OverlayOrchestrator overlayOrchestrator;

	@Override
	protected void startUp() {
		log.info("Venom Timer started!");
	}

	@Override
	protected void shutDown() {
		overlayOrchestrator.shutDown();
		log.info("Venom timer stopped!");
	}

	@Provides
	public VenomTimerConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(VenomTimerConfig.class);
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
		this.onHitsplatApplied.onEvent(hitsplatApplied);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		this.onConfigChanged.onEvent(configChanged);
	}
}

package com.simonflapse.osrs.venom.combat;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.client.game.NPCManager;

import java.time.Duration;
import java.time.Instant;

@Slf4j
public class VenomDamage {
    private final NPCManager npcManager;
    private final Actor actor;

    @Getter
    private int totalDamage = 0;
    @Getter
    private int nextDamage;

    private Instant lastHit;
    private int currentHealth = -1;

    public VenomDamage(NPCManager npcManager, Actor actor) {
        this.npcManager = npcManager;
        this.actor = actor;
    }

    public void updateVenom(int damage) {
        this.totalDamage += damage;
        this.nextDamage = getNextVenomDamage(damage);
        lastHit = Instant.now();
    }

    public long timeDifference() {
        Instant now = Instant.now();
        Instant nextExpectedVenom = lastHit.plus(Duration.ofSeconds(18));
        Duration between = Duration.between(now, nextExpectedVenom);
        return between.getSeconds() + 1;
    }

    public long calculateTimeToDeath(long timeToNextVenom) {
        if (this.actor instanceof NPC) {
            return calculateTimeToDeathForNPC((NPC) this.actor, timeToNextVenom);
        }

        return -1;
    }

    private long calculateTimeToDeathForNPC(NPC npc, long timeToNextVenom) {
        Integer maxHealth = npcManager.getHealth(npc.getId());
        if (maxHealth != null && maxHealth != 0) {
            updateCurrentHealth(maxHealth);
            return getTimeToDeath(timeToNextVenom, this.currentHealth);
        }
        return -1;
    }

    private void updateCurrentHealth(int maxHealth) {
        int currentHealth = getCurrentHealth(maxHealth);

        if (currentHealth != this.currentHealth) {
            this.currentHealth = currentHealth;
            log.debug("Current health updated to: {} for NPC: {}", currentHealth, this.actor.getName());
        }
    }

    private int getCurrentHealth(int maxHealth) {
        int currentHealth = HealthUtil.getApproximateHealth(maxHealth, actor.getHealthRatio(), actor.getHealthScale());
        if (currentHealth < 0) {
            return this.currentHealth;
        }
        return currentHealth;
    }

    private long getTimeToDeath(long timeToNextVenom, int currentHealth) {
        int nextDamage = this.nextDamage;
        currentHealth = currentHealth - nextDamage;

        int venomSplatsToDead = getVenomSplatsToDead(currentHealth, nextDamage);

        return timeToNextVenom + (18L * venomSplatsToDead);
    }

    private static int getVenomSplatsToDead(int currentHealth, int nextDamage) {
        int venomSplatsToDead = 0;
        while(currentHealth > 0) {
            venomSplatsToDead++;
            nextDamage = getNextVenomDamage(nextDamage);
            currentHealth -= nextDamage;
        }
        return venomSplatsToDead;
    }


    private static int getNextVenomDamage(int currentDamage) {
        return Math.min(currentDamage + 2, 20);
    }
}

package com.simonflapse.osrs.venom.combat;

public final class HealthUtil {
    private HealthUtil() {}

    /**
     * The servers healthRation calculation is reasoned to be:
     * <code>
     *     {@code healthRatio = (1 + (healthScale - 1) * health) / (maxHealth)}
     * </code>
     * <p>
     * Isolating for the variable `health` gives:
     * </p>
     * <code>
     *     {@code health = (maxHealth * healthRatio - 1) / (healthScale - 1)}
     * </code>
     *
     * @param maxHealth the maximum health of an actor, so that when health ratio = health scale the returned health = maxHealth.
     * @param healthRatio the ration between 0 and healthScale of the actor's health.
     * @param healthScale the scale of an actor's health indicating how many rations the maxHealth can be divided into by the server.
     * @return approximated health or -1 if unable to calculate.
     */
    public static int getApproximateHealth(int maxHealth, int healthRatio, int healthScale) {
        if (!canCalculateHealth(healthRatio, healthScale)) {
            return -1;
        }

        if (isActorDead(healthRatio, healthScale)) {
            return 0;
        }

        if (isHealthBoolean(healthScale)) {
            return maxHealth;
        }

        return calculateHealth(maxHealth, healthRatio, healthScale);
    }

    /**
     * Calculates an approximate integer value of an actor's health based on its max health,
     * the health scale and health ratio.
     *
     * <p>
     *     The calculation is based on this mathematical equation:
     * </p>
     * <code>
     *     {@code health = (maxHealth * healthRatio - 1) / (healthScale - 1)}
     * </code>
     *
     * @param maxHealth the maximum health of an actor, so that when health ratio = health scale the returned health = maxHealth.
     * @param healthRatio the ration between 0 and healthScale of the actor's health.
     * @param healthScale the scale of an actor's health indicating how many rations the maxHealth can be divided into by the server.
     * @return approximated health
     */
    private static int calculateHealth(int maxHealth, int healthRatio, int healthScale) {
        int health = (maxHealth * healthRatio - 1) / (healthScale - 1);
        return Math.min(health, maxHealth);
    }

    /**
     * Checks if the health scale can be considered a boolean.
     * This means that the health ration either indicates full health or dead.
     * @param healthScale the scale of an actor's health indicating how many rations the maxHealth can be divided into by the server.
     * @return true if health ration can only indicate alive or dead, otherwise false.
     */
    private static boolean isHealthBoolean(int healthScale) {
        return healthScale == 1;
    }

    /**
     * Checks if the actor can be considered dead.
     * This means that the actors health is 0.
     * <p>
     *     This happens when the health ratio is 0 or if the health scale is 0.
     * </p>
     * @param healthRatio the ration between 0 and healthScale of the actor's health.
     * @param healthScale the scale of an actor's health indicating how many rations the maxHealth can be divided into by the server.
     * @return true if the actor can be considered dead, otherwise false
     */
    private static boolean isActorDead(int healthRatio, int healthScale) {
        return healthScale == 0 || healthRatio == 0;
    }

    /**
     * Checks if the health ratio and health scale is non-negative.
     * <p>
     *     The health can only be calculated if the health ratio and health scale is 0 or a positive integer
     * </p>
     * @param healthRatio the ration between 0 and healthScale of the actor's health.
     * @param healthScale the scale of an actor's health indicating how many rations the maxHealth can be divided into by the server.
     * @return true if the health ration and health scale is non-negative, otherwise false
     */
    private static boolean canCalculateHealth(int healthRatio, int healthScale) {
        return healthRatio >= 0 && healthScale >= 0;
    }
}

