package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.Hunter;
import com.geel.hunterrumours.enums.Rumour;
import net.runelite.api.Client;
import net.runelite.api.NPCComposition;

import javax.inject.Inject;
import java.util.Locale;

/**
 * Utility functions for parsing game/chat messages to extract rumour-related information,
 * such as which Hunter might be speaking, or which Hunter/Rumour is being referenced.
 */
public class ChatParser {
    private final Client client;

    @Inject
    public ChatParser(Client client) {
        this.client = client;
    }

    public Hunter getSpeakingHunter(String message) {
        for (Hunter hunter : Hunter.allValues()) {
            NPCComposition npc = client.getNpcDefinition(hunter.getNpcId());
            if (message.startsWith(npc.getName() + "|")) {
                return hunter;
            }
        }

        return Hunter.NONE;
    }

    public Hunter getReferencedHunter(String message) {
        message = message.toLowerCase();
        for (var hunterName : Hunter.allCommonNames()) {
            if (!message.contains(hunterName.toLowerCase())) {
                continue;
            }

            return Hunter.fromCommonName(hunterName);
        }

        return Hunter.NONE;
    }

    public Rumour getReferencedRumour(String message) {
        for (var rumour : Rumour.allValues()) {
            if (!message.contains(rumour.getName().toLowerCase())) {
                continue;
            }

            return rumour;
        }

        return Rumour.NONE;
    }
}

package com.geel.hunterrumours.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
public enum BackToBackState {
    UNKNOWN("Unknown"),
    ENABLED("Enabled"),
    DISABLED("Disabled");

    @Getter
    private final String NiceName;
}

package com.geel.hunterrumours.enums;

import java.util.stream.IntStream;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import net.runelite.api.NpcID;

import static com.geel.hunterrumours.enums.Trap.*;

@AllArgsConstructor
public enum Creature {
    NONE(0, ItemID.COINS_995, BOX_TRAP, 0, new int[]{}),

    TROPICAL_WAGTAIL(NpcID.TROPICAL_WAGTAIL, ItemID.TROPICAL_WAGTAIL, SNARE, 19, new int[]{95, 96}),
    WILD_KEBBIT(NpcID.WILD_KEBBIT, ItemID.KEBBIT_9962, DEADFALL, 23, new int[]{128}),
    SAPPHIRE_GLACIALIS(NpcID.SAPPHIRE_GLACIALIS, ItemID.BUTTERFLY_9971, BUTTERFLY, 25, new int[]{34}),

    SWAMP_LIZARD(NpcID.SWAMP_LIZARD, ItemID.SWAMP_LIZARD, NET_TRAP, 29, new int[]{152}),
    SPINED_LARUPIA(NpcID.SPINED_LARUPIA, ItemID.LARUPIA_HAT, PIT, 31, new int[]{180}),
    BARB_TAILED_KEBBIT(NpcID.BARBTAILED_KEBBIT, ItemID.KEBBIT_9958, DEADFALL, 33, new int[]{168}),
    SNOWY_KNIGHT(NpcID.SNOWY_KNIGHT, ItemID.BUTTERFLY_9972, BUTTERFLY, 35, new int[]{44}),
    PRICKLY_KEBBIT(NpcID.PRICKLY_KEBBIT, ItemID.KEBBIT_9957, DEADFALL, 37, new int[]{204}),
    EMBERTAILED_JERBOA(NpcID.EMBERTAILED_JERBOA, ItemID.EMBERTAILED_JERBOA, BOX_TRAP, 39, new int[]{137}),
    HORNED_GRAAHK(NpcID.HORNED_GRAAHK, ItemID.GRAAHK_HEADDRESS, PIT, 41, new int[]{240}),
    SPOTTED_KEBBIT(NpcID.SPOTTED_KEBBIT, ItemID.KEBBIT_9960, FALCONRY, 43, new int[]{104}),
    BLACK_WARLOCK(NpcID.BLACK_WARLOCK, ItemID.BUTTERFLY_9973, BUTTERFLY, 45, new int[]{54}),

    ORANGE_SALAMANDER(NpcID.ORANGE_SALAMANDER, ItemID.ORANGE_SALAMANDER, NET_TRAP, 47, new int[]{224}),
    RAZOR_BACKED_KEBBIT(0, ItemID.KEBBIT_9961, NOOSE, 49, new int[]{348}), //TODO
    SABRE_TOOTHED_KEBBIT(NpcID.SABRETOOTHED_KEBBIT, ItemID.KEBBIT_9959, DEADFALL, 51, new int[]{200}),
    GREY_CHINCHOMPA(NpcID.CHINCHOMPA, ItemID.CHINCHOMPA, BOX_TRAP, 53, new int[]{198, 199}),
    SABRE_TOOTHED_KYATT(NpcID.SABRETOOTHED_KYATT, ItemID.KYATT_HAT, PIT, 53, new int[]{300}),
    DARK_KEBBIT(NpcID.DARK_KEBBIT, ItemID.KEBBIT_9963, FALCONRY, 57, new int[]{132}),
    PYRE_FOX(NpcID.PYRE_FOX, ItemID.PYRE_FOX, DEADFALL, 57, new int[]{222}),
    RED_SALAMANDER(NpcID.RED_SALAMANDER, ItemID.RED_SALAMANDER, NET_TRAP, 59, new int[]{272}),
    RED_CHINCHOMPA(NpcID.CARNIVOROUS_CHINCHOMPA, ItemID.RED_CHINCHOMPA, BOX_TRAP, 63, new int[]{265}),
    SUNLIGHT_MOTH(NpcID.SUNLIGHT_MOTH, ItemID.SUNLIGHT_MOTH, BUTTERFLY, 65, new int[]{74}),
    DASHING_KEBBIT(NpcID.DASHING_KEBBIT, ItemID.KEBBIT_9964, FALCONRY, 69,  new int[]{156}),
    SUNLIGHT_ANTELOPE(NpcID.SUNLIGHT_ANTELOPE, ItemID.SUNLIGHT_ANTELOPE, PIT, 72,  new int[]{380}),
    MOONLIGHT_MOTH(NpcID.MOONLIGHT_MOTH, ItemID.MOONLIGHT_MOTH, BUTTERFLY, 75,  new int[]{84}),
    TECU_SALAMANDER(NpcID.TECU_SALAMANDER, ItemID.TECU_SALAMANDER, NET_TRAP, 79, new int[]{344}),
    HERBIBOAR(NpcID.HERBIBOAR, ItemID.HERBIBOAR, NOOSE_HERBIBOAR, 80, IntStream.rangeClosed(1950, 2461).toArray()),
    MOONLIGHT_ANTELOPE(NpcID.MOONLIGHT_ANTELOPE, ItemID.MOONLIGHT_ANTELOPE, PIT, 91, new int[]{450});

    @Getter
    private final int NpcId;

    @Getter
    private final int ItemId;

    @Getter
    private final com.geel.hunterrumours.enums.Trap Trap;

    @Getter
    private final int HunterLevel;

    @Getter
    private final int[] PossibleXpDrops;
}

package com.geel.hunterrumours.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@AllArgsConstructor
public enum Hunter {
    NONE(0, "Unknown", HunterTier.NONE),

    MASTER_WOLF(13126, "Wolf", HunterTier.MASTER),
    EXPERT_TECO(13125, "Teco", HunterTier.EXPERT),
    EXPERT_ACO(13124, "Aco", HunterTier.EXPERT),
    ADEPT_CERVUS(13123, "Cervus", HunterTier.ADEPT),
    ADEPT_ORNUS(13122, "Ornus", HunterTier.ADEPT),
    NOVICE_GILMAN(13121, "Gilman", HunterTier.NOVICE);

    @Getter
    private final int NpcId;

    @Getter
    private final String CommonName;

    @Getter
    private final HunterTier Tier;

    public static Hunter[] allValues() {
        return Arrays.stream(Hunter.values()).filter(hunter -> hunter.NpcId != 0).toArray(Hunter[]::new);
    }

    private final static Map<Integer, Hunter> npcIdToHunter = new HashMap<Integer, Hunter>() {
        {
            for(var hunter : Hunter.allValues()) {
                put(hunter.NpcId, hunter);
            }
        }
    };

    private final static Map<String, Hunter> npcCommonNameToHunter = new HashMap<String, Hunter>() {
        {
            for(var hunter : Hunter.allValues()) {
                put(hunter.CommonName.toLowerCase(), hunter);
            }
        }
    };

    public static Hunter fromNpcId(int npcId) {
        return npcIdToHunter.getOrDefault(npcId, Hunter.NONE);
    }

    public static Hunter fromCommonName(String commonName) {
        return npcCommonNameToHunter.getOrDefault(commonName.toLowerCase(), Hunter.NONE);
    }

    public static String[] allCommonNames() {
        return npcCommonNameToHunter.keySet().toArray(new String[0]);
    }
}

package com.geel.hunterrumours.enums;

public enum HunterTier {
    NOVICE,
    ADEPT,
    EXPERT,
    MASTER,
    NONE
}

package com.geel.hunterrumours.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;

import java.util.Arrays;

@AllArgsConstructor
public enum Rumour
{
	NONE(Creature.BARB_TAILED_KEBBIT, "Unknown", ItemID.COINS_995, false, false, false, false),

	TROPICAL_WAGTAIL(Creature.TROPICAL_WAGTAIL, "Tropical Wagtail", ItemID.TAILFEATHERS, true, false, false, false),
	WILD_KEBBIT(Creature.WILD_KEBBIT, "Wild Kebbit", ItemID.KEBBITY_TUFT, true, false, false, false),
	SAPPHIRE_GLACIALIS(Creature.SAPPHIRE_GLACIALIS, "Sapphire Glacialis", ItemID.BLUE_BUTTERFLY_WING, true, false, false, false),

	SWAMP_LIZARD(Creature.SWAMP_LIZARD, "Swamp Lizard", ItemID.SWAMP_LIZARD_CLAW, true, true, false, false),
	SPINED_LARUPIA(Creature.SPINED_LARUPIA, "Spined Larupia", ItemID.LARUPIA_EAR, true, true, false, false),
	BARB_TAILED_KEBBIT(Creature.BARB_TAILED_KEBBIT, "Barb-tailed Kebbit", ItemID.KEBBITY_TUFT, true, true, false, false),
	SNOWY_KNIGHT(Creature.SNOWY_KNIGHT, "Snowy Knight", ItemID.WHITE_BUTTERFLY_WING, true, true, false, false),
	PRICKLY_KEBBIT(Creature.PRICKLY_KEBBIT, "Prickly Kebbit", ItemID.KEBBITY_TUFT, true, true, false, false),
	// TODO: Verify jerboa
	EMBERTAILED_JERBOA(Creature.EMBERTAILED_JERBOA, "Embertailed Jerboa", ItemID.LARGE_JERBOA_TAIL, true, true, false, false),
	HORNED_GRAAHK(Creature.HORNED_GRAAHK, "Horned Graahk", ItemID.GRAAHK_HORN_SPUR, true, true, false, false),
	SPOTTED_KEBBIT(Creature.SPOTTED_KEBBIT, "Spotted Kebbit", ItemID.KEBBITY_TUFT, true, true, false, false),
	BLACK_WARLOCK(Creature.BLACK_WARLOCK, "Black Warlock", ItemID.BLACK_BUTTERFLY_WING, true, true, false, false),

	ORANGE_SALAMANDER(Creature.ORANGE_SALAMANDER, "Orange Salamander", ItemID.ORANGE_SALAMANDER_CLAW, true, true, true, false),
	RAZOR_BACKED_KEBBIT(Creature.RAZOR_BACKED_KEBBIT, "Razor-backed Kebbit", ItemID.KEBBITY_TUFT, true, true, true, false), //TODO
	SABRE_TOOTHED_KEBBIT(Creature.SABRE_TOOTHED_KEBBIT, "Sabre-toothed Kebbit", ItemID.KEBBITY_TUFT, true, true, true, false),
	GREY_CHINCHOMPA(Creature.GREY_CHINCHOMPA, "Grey Chinchompa", ItemID.CHINCHOMPA_TUFT, true, true, true, false),
	SABRE_TOOTHED_KYATT(Creature.SABRE_TOOTHED_KYATT, "Sabre-toothed Kyatt", ItemID.KYATT_TOOTH_CHIP, true, true, true, false),
	DARK_KEBBIT(Creature.DARK_KEBBIT, "Dark Kebbit", ItemID.KEBBITY_TUFT, true, true, true, false),
	PYRE_FOX(Creature.PYRE_FOX, "Pyre Fox", ItemID.FOX_FLUFF, true, true, true, true),
	RED_SALAMANDER(Creature.RED_SALAMANDER, "Red Salamander", ItemID.RED_SALAMANDER_CLAW, true, false, true, true),
	RED_CHINCHOMPA(Creature.RED_CHINCHOMPA, "Carnivorous Chinchompa", ItemID.RED_CHINCHOMPA_TUFT, true, false, true, true),
	RED_CHINCHOMPA_2(Creature.RED_CHINCHOMPA, "Red Chinchompa", ItemID.RED_CHINCHOMPA_TUFT, true, false, true, true),
	SUNLIGHT_MOTH(Creature.SUNLIGHT_MOTH, "Sunlight Moth", ItemID.SUNLIGHT_MOTH_WING, true, false, false, true),
	DASHING_KEBBIT(Creature.DASHING_KEBBIT, "Dashing Kebbit", ItemID.KEBBITY_TUFT,true, false, true, true),
	SUNLIGHT_ANTELOPE(Creature.SUNLIGHT_ANTELOPE, "Sunlight Antelope", ItemID.ANTELOPE_HOOF_SHARD,true, false, true, true),
	MOONLIGHT_MOTH(Creature.MOONLIGHT_MOTH, "Moonlight Moth", ItemID.MOONLIGHT_MOTH_WING,true, false, false, true),
	TECU_SALAMANDER(Creature.TECU_SALAMANDER, "Tecu Salamander", ItemID.SALAMANDER_CLAW, true, false, false, true),
	HERBIBOAR(Creature.HERBIBOAR, "Herbiboar", ItemID.HERBY_TUFT, true, false, false, true),
	MOONLIGHT_ANTELOPE(Creature.MOONLIGHT_ANTELOPE, "Moonlight Antelope", ItemID.ANTELOPE_HOOF_SHARD_29241, true, false, false, true);

	@Getter
    private final Creature TargetCreature;

	@Getter
	private final String Name;

	@Getter
	private final int RumourItemID;

	@Getter
	private final boolean Novice;

	@Getter
	private final boolean Adept;

	@Getter
	private final boolean Expert;

	@Getter
	private final boolean Master;

	public static Rumour[] allValues()
	{
		return Arrays.stream(Rumour.values()).filter(rumour -> rumour.getTargetCreature().getHunterLevel() != 0).toArray(Rumour[]::new);
	}

	public Trap getTrap() {
	    return getTargetCreature().getTrap();
    }

	public String getFullName()
	{
		// Don't show the trap if it's NONE
		if (this == NONE)
		{
			return this.getName();
		}

		return this.getName() + " (" + this.getTargetCreature().getTrap().getName() + ")";
	}
}

package com.geel.hunterrumours.enums;

import static com.geel.hunterrumours.enums.Rumour.*;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@AllArgsConstructor
public enum RumourLocation
{
	TROPICAL_WAGTAIL_FELDIP_HUNTER_AREA_1(TROPICAL_WAGTAIL, "Feldip Hunter area", "AKS", new WorldPoint(2526, 2939, 0)),
	TROPICAL_WAGTAIL_FELDIP_HUNTER_AREA_2(TROPICAL_WAGTAIL, "Feldip Hunter area", "AKS", new WorldPoint(2511, 2914, 0)),
	TROPICAL_WAGTAIL_FELDIP_HUNTER_AREA_3(TROPICAL_WAGTAIL, "Feldip Hunter area", "AKS", new WorldPoint(2499, 2890, 0)),
	TROPICAL_WAGTAIL_FELDIP_HUNTER_AREA_4(TROPICAL_WAGTAIL, "Feldip Hunter area", "AKS", new WorldPoint(2545, 2882, 0)),

	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_1(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2307, 3577, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_2(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2362, 3578, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_3(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2350, 3563, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_4(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2316, 3560, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_5(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2330, 3552, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_6(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2342, 3544, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_7(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2306, 3541, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_8(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2363, 3540, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_9(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2315, 3523, 0)),
	WILD_KEBBIT_PISCATORIS_HUNTER_AREA_10(WILD_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2348, 3523, 0)),

	SAPPHIRE_GLACIALIS_RELLEKKA_HUNTER_AREA_1(SAPPHIRE_GLACIALIS, "Rellekka Hunter area", "DKS", new WorldPoint(2703, 3822, 0)),
	SAPPHIRE_GLACIALIS_RELLEKKA_HUNTER_AREA_2(SAPPHIRE_GLACIALIS, "Rellekka Hunter area", "DKS", new WorldPoint(2708, 3822, 0)),
	SAPPHIRE_GLACIALIS_RELLEKKA_HUNTER_AREA_3(SAPPHIRE_GLACIALIS, "Rellekka Hunter area", "DKS", new WorldPoint(2715, 3808, 0)),
	SAPPHIRE_GLACIALIS_RELLEKKA_HUNTER_AREA_4(SAPPHIRE_GLACIALIS, "Rellekka Hunter area", "DKS", new WorldPoint(2720, 3805, 0)),
	SAPPHIRE_GLACIALIS_RELLEKKA_HUNTER_AREA_5(SAPPHIRE_GLACIALIS, "Rellekka Hunter area", "DKS", new WorldPoint(2720, 3834, 0)),
	SAPPHIRE_GLACIALIS_RELLEKKA_HUNTER_AREA_6(SAPPHIRE_GLACIALIS, "Rellekka Hunter area", "DKS", new WorldPoint(2734, 3823, 0)),
	SAPPHIRE_GLACIALIS_FARMING_GUILD_1(SAPPHIRE_GLACIALIS, "Farming Guild", "CIR", new WorldPoint(1237, 3746, 0)),
	SAPPHIRE_GLACIALIS_FARMING_GUILD_2(SAPPHIRE_GLACIALIS, "Farming Guild", "CIR", new WorldPoint(1258, 3746, 0)),

	SWAMP_LIZARD_CANIFIS_HUNTER_AREA(SWAMP_LIZARD, "Canifis Hunter Area", "ALQ", new WorldPoint(3532, 3446, 0)),
	SWAMP_LIZARD_NORTH_WEST_OF_SLEPE(SWAMP_LIZARD, "North-west of Slepe", "", new WorldPoint(3684, 3403, 0)),

	SPINED_LARUPIA_FELDIP_HUNTER_AREA_1(SPINED_LARUPIA, "Feldip Hunter area", "AKS", new WorldPoint(2544, 2910, 0)),
	SPINED_LARUPIA_FELDIP_HUNTER_AREA_2(SPINED_LARUPIA, "Feldip Hunter area", "AKS", new WorldPoint(2550, 2904, 0)),
	SPINED_LARUPIA_FELDIP_HUNTER_AREA_3(SPINED_LARUPIA, "Feldip Hunter area", "AKS", new WorldPoint(2556, 2895, 0)),
	SPINED_LARUPIA_FELDIP_HUNTER_AREA_4(SPINED_LARUPIA, "Feldip Hunter area", "AKS", new WorldPoint(2563, 2888, 0)),
	SPINED_LARUPIA_FELDIP_HUNTER_AREA_5(SPINED_LARUPIA, "Feldip Hunter area", "AKS", new WorldPoint(2573, 2883, 0)),

	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_1(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2572, 2931, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_2(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2572, 2929, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_3(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2575, 2926, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_4(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2577, 2926, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_5(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2575, 2916, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_6(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2584, 2914, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_7(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2584, 2912, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_8(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2574, 2911, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_9(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2574, 2909, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_10(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2567, 2903, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_11(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2565, 2903, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_12(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2573, 2898, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_13(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2573, 2896, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_14(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2581, 2886, 0)),
	BARB_TAILED_KEBBIT_FELDIP_HUNTER_AREA_15(BARB_TAILED_KEBBIT, "Feldip Hunter area", "AKS", new WorldPoint(2581, 2884, 0)),

	SNOWY_KNIGHT_WEISS_1(SNOWY_KNIGHT, "Weiss", "", new WorldPoint(2864, 3957, 0)),
	SNOWY_KNIGHT_WEISS_2(SNOWY_KNIGHT, "Weiss", "", new WorldPoint(2870, 3955, 0)),
	SNOWY_KNIGHT_WEISS_3(SNOWY_KNIGHT, "Weiss", "", new WorldPoint(2867, 3954, 0)),
	SNOWY_KNIGHT_WEISS_4(SNOWY_KNIGHT, "Weiss", "", new WorldPoint(2874, 3952, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_UPPER_1(SNOWY_KNIGHT, "Rellekka Hunter area, Upper level", "DKS", new WorldPoint(2725, 3833, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_UPPER_2(SNOWY_KNIGHT, "Rellekka Hunter area, Upper level", "DKS", new WorldPoint(2708, 3815, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_UPPER_3(SNOWY_KNIGHT, "Rellekka Hunter area, Upper level", "DKS", new WorldPoint(2730, 3806, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_1(SNOWY_KNIGHT, "Rellekka Hunter area", "DKS", new WorldPoint(2701, 3804, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_2(SNOWY_KNIGHT, "Rellekka Hunter area", "DKS", new WorldPoint(2712, 3797, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_3(SNOWY_KNIGHT, "Rellekka Hunter area", "DKS", new WorldPoint(2737, 3792, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_4(SNOWY_KNIGHT, "Rellekka Hunter area", "DKS", new WorldPoint(2696, 3786, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_5(SNOWY_KNIGHT, "Rellekka Hunter area", "DKS", new WorldPoint(2737, 3778, 0)),
	SNOWY_KNIGHT_RELLEKKA_HUNTER_AREA_6(SNOWY_KNIGHT, "Rellekka Hunter area", "DKS", new WorldPoint(2714, 3777, 0)),
	SNOWY_KNIGHT_FARMING_GUILD_1(SNOWY_KNIGHT, "Farming Guild", "CIR", new WorldPoint(1238, 3740, 0)),
	SNOWY_KNIGHT_FARMING_GUILD_2(SNOWY_KNIGHT, "Farming Guild", "CIR", new WorldPoint(1223, 3723, 0)),

	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_1(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2321, 3644, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_2(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2321, 3643, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_3(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2308, 3642, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_4(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2310, 3642, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_5(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2342, 3641, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_6(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2343, 3641, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_7(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2327, 3635, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_8(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2328, 3635, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_9(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2336, 3632, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_10(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2336, 3631, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_11(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2323, 3628, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_12(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2324, 3628, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_13(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2307, 3621, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_14(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2307, 3620, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_15(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2323, 3614, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_16(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2324, 3614, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_17(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2307, 3606, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_18(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2307, 3605, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_19(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2319, 3595, 0)),
	PRICKLY_KEBBIT_PISCATORIS_HUNTER_AREA_20(PRICKLY_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2320, 3595, 0)),

	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_1(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1510, 3046, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_2(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1511, 3050, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_3(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1513, 3043, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_4(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1515, 3049, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_5(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1518, 3051, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_6(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1518, 3041, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_7(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1519, 3045, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_8(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1521, 3048, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_9(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1522, 3043, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_10(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1524, 3050, 0)),
	EMBERTAILED_JERBOA_WEST_OF_HUNTER_GUILD_11(EMBERTAILED_JERBOA, "West of Hunter Guild", "", new WorldPoint(1524, 3046, 0)),
	EMBERTAILED_JERBOA_NORTH_WEST_OF_THE_LOCUS_OASIS_1(EMBERTAILED_JERBOA, "North-west of the Locus Oasis", "AJP", new WorldPoint(1664, 2998, 0)),
	EMBERTAILED_JERBOA_NORTH_WEST_OF_THE_LOCUS_OASIS_2(EMBERTAILED_JERBOA, "North-west of the Locus Oasis", "AJP", new WorldPoint(1664, 3003, 0)),
	EMBERTAILED_JERBOA_NORTH_WEST_OF_THE_LOCUS_OASIS_3(EMBERTAILED_JERBOA, "North-west of the Locus Oasis", "AJP", new WorldPoint(1664, 3005, 0)),
	EMBERTAILED_JERBOA_NORTH_WEST_OF_THE_LOCUS_OASIS_4(EMBERTAILED_JERBOA, "North-west of the Locus Oasis", "AJP", new WorldPoint(1666, 3006, 0)),
	EMBERTAILED_JERBOA_NORTH_WEST_OF_THE_LOCUS_OASIS_5(EMBERTAILED_JERBOA, "North-west of the Locus Oasis", "AJP", new WorldPoint(1667, 2996, 0)),
	EMBERTAILED_JERBOA_NORTH_WEST_OF_THE_LOCUS_OASIS_6(EMBERTAILED_JERBOA, "North-west of the Locus Oasis", "AJP", new WorldPoint(1667, 3001, 0)),
	EMBERTAILED_JERBOA_NORTH_WEST_OF_THE_LOCUS_OASIS_7(EMBERTAILED_JERBOA, "North-west of the Locus Oasis", "AJP", new WorldPoint(1667, 3004, 0)),
	EMBERTAILED_JERBOA_NORTH_WEST_OF_THE_LOCUS_OASIS_8(EMBERTAILED_JERBOA, "North-west of the Locus Oasis", "AJP", new WorldPoint(1671, 3005, 0)),

	HORNED_GRAAHK_KARAMJA_HUNTER_AREA_1(HORNED_GRAAHK, "Karamja Hunter area", "CKR", new WorldPoint(2766, 3008, 0)),
	HORNED_GRAAHK_KARAMJA_HUNTER_AREA_2(HORNED_GRAAHK, "Karamja Hunter area", "CKR", new WorldPoint(2767, 3005, 0)),
	HORNED_GRAAHK_KARAMJA_HUNTER_AREA_3(HORNED_GRAAHK, "Karamja Hunter area", "CKR", new WorldPoint(2774, 3002, 0)),
	HORNED_GRAAHK_KARAMJA_HUNTER_AREA_4(HORNED_GRAAHK, "Karamja Hunter area", "CKR", new WorldPoint(2781, 3001, 0)),

	SPOTTED_KEBBIT_PISCATORIS_FALCONRY_AREA_1(SPOTTED_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2391, 3592, 0)),
	SPOTTED_KEBBIT_PISCATORIS_FALCONRY_AREA_2(SPOTTED_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2370, 3591, 0)),
	SPOTTED_KEBBIT_PISCATORIS_FALCONRY_AREA_3(SPOTTED_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2370, 3587, 0)),
	SPOTTED_KEBBIT_PISCATORIS_FALCONRY_AREA_4(SPOTTED_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2384, 3586, 0)),
	SPOTTED_KEBBIT_PISCATORIS_FALCONRY_AREA_5(SPOTTED_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2379, 3585, 0)),
	SPOTTED_KEBBIT_PISCATORIS_FALCONRY_AREA_6(SPOTTED_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2372, 3584, 0)),
	SPOTTED_KEBBIT_PISCATORIS_FALCONRY_AREA_7(SPOTTED_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2382, 3584, 0)),

	BLACK_WARLOCK_FELDIP_HUNTER_AREA_1(BLACK_WARLOCK, "Feldip Hunter area", "AKS", new WorldPoint(2563, 2920, 0)),
	BLACK_WARLOCK_FELDIP_HUNTER_AREA_2(BLACK_WARLOCK, "Feldip Hunter area", "AKS", new WorldPoint(2551, 2915, 0)),
	BLACK_WARLOCK_FELDIP_HUNTER_AREA_3(BLACK_WARLOCK, "Feldip Hunter area", "AKS", new WorldPoint(2540, 2914, 0)),
	BLACK_WARLOCK_FELDIP_HUNTER_AREA_4(BLACK_WARLOCK, "Feldip Hunter area", "AKS", new WorldPoint(2532, 2905, 0)),
	BLACK_WARLOCK_FELDIP_HUNTER_AREA_5(BLACK_WARLOCK, "Feldip Hunter area", "AKS", new WorldPoint(2540, 2898, 0)),
	BLACK_WARLOCK_FELDIP_HUNTER_AREA_6(BLACK_WARLOCK, "Feldip Hunter area", "AKS", new WorldPoint(2550, 2893, 0)),
	BLACK_WARLOCK_FELDIP_HUNTER_AREA_7(BLACK_WARLOCK, "Feldip Hunter area", "AKS", new WorldPoint(2566, 2886, 0)),
	BLACK_WARLOCK_IN_AND_AROUND_THE_FARMING_GUILD_1(BLACK_WARLOCK, "In and around the Farming Guild", "CIR", new WorldPoint(1224, 3764, 0)),
	BLACK_WARLOCK_IN_AND_AROUND_THE_FARMING_GUILD_2(BLACK_WARLOCK, "In and around the Farming Guild", "CIR", new WorldPoint(1242, 3760, 0)),
	BLACK_WARLOCK_IN_AND_AROUND_THE_FARMING_GUILD_3(BLACK_WARLOCK, "In and around the Farming Guild", "CIR", new WorldPoint(1260, 3750, 0)),
	BLACK_WARLOCK_IN_AND_AROUND_THE_FARMING_GUILD_4(BLACK_WARLOCK, "In and around the Farming Guild", "CIR", new WorldPoint(1220, 3747, 0)),
	BLACK_WARLOCK_IN_AND_AROUND_THE_FARMING_GUILD_5(BLACK_WARLOCK, "In and around the Farming Guild", "CIR", new WorldPoint(1233, 3745, 0)),

	ORANGE_SALAMANDER_NECROPOLIS_HUNTER_1(ORANGE_SALAMANDER, "Necropolis (w/ Beneath Cursed Sands)", "AKP", new WorldPoint(3285, 2741, 0)),
	ORANGE_SALAMANDER_NECROPOLIS_HUNTER_2(ORANGE_SALAMANDER, "Necropolis (w/ Beneath Cursed Sands)", "AKP", new WorldPoint(3285, 2739, 0)),
	ORANGE_SALAMANDER_NECROPOLIS_HUNTER_3(ORANGE_SALAMANDER, "Necropolis (w/ Beneath Cursed Sands)", "AKP", new WorldPoint(3287, 2739, 0)),
	ORANGE_SALAMANDER_NECROPOLIS_HUNTER_4(ORANGE_SALAMANDER, "Necropolis (w/ Beneath Cursed Sands)", "AKP", new WorldPoint(3288, 2738, 0)),
	ORANGE_SALAMANDER_NECROPOLIS_HUNTER_5(ORANGE_SALAMANDER, "Necropolis (w/ Beneath Cursed Sands)", "AKP", new WorldPoint(3286, 2738, 0)),
	ORANGE_SALAMANDER_UZER_HUNTER_AREA_1(ORANGE_SALAMANDER, "Uzer Hunter area", "DLQ", new WorldPoint(3405, 3133, 0)),
	ORANGE_SALAMANDER_UZER_HUNTER_AREA_2(ORANGE_SALAMANDER, "Uzer Hunter area", "DLQ", new WorldPoint(3403, 3090, 0)),
	ORANGE_SALAMANDER_UZER_HUNTER_AREA_3(ORANGE_SALAMANDER, "Uzer Hunter area", "DLQ", new WorldPoint(3417, 3073, 0)),

	RAZOR_BACKED_KEBBIT_PISCATORIS_HUNTER_AREA_1(RAZOR_BACKED_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2353, 3595, 0)),
	RAZOR_BACKED_KEBBIT_PISCATORIS_HUNTER_AREA_2(RAZOR_BACKED_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2360, 3611, 0)),
	RAZOR_BACKED_KEBBIT_PISCATORIS_HUNTER_AREA_3(RAZOR_BACKED_KEBBIT, "Piscatoris Hunter area", "AKQ", new WorldPoint(2357, 3624, 0)),

	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_1(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2705, 3780, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_2(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2715, 3779, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_3(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2711, 3778, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_4(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2717, 3776, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_5(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2707, 3774, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_6(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2712, 3773, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_7(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2714, 3770, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_8(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2716, 3770, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_9(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2711, 3768, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_10(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2715, 3766, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_11(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2715, 3764, 0)),
	SABRE_TOOTHED_KEBBIT_RELLEKKA_HUNTER_AREA_12(SABRE_TOOTHED_KEBBIT, "Rellekka Hunter area", "DKS", new WorldPoint(2720, 3764, 0)),

	GREY_CHINCHOMPA_PISCATORIS_HUNTER_AREA_1(GREY_CHINCHOMPA, "Piscatoris Hunter area", "AKQ", new WorldPoint(2332, 3626, 0)),
	GREY_CHINCHOMPA_PISCATORIS_HUNTER_AREA_2(GREY_CHINCHOMPA, "Piscatoris Hunter area", "AKQ", new WorldPoint(2351, 3534, 0)),
	GREY_CHINCHOMPA_PISCATORIS_HUNTER_AREA_3(GREY_CHINCHOMPA, "Piscatoris Hunter area", "AKQ", new WorldPoint(2317, 3539, 0)),
	GREY_CHINCHOMPA_PISCATORIS_HUNTER_AREA_4(GREY_CHINCHOMPA, "Piscatoris Hunter area", "AKQ", new WorldPoint(2350, 3540, 0)),
	GREY_CHINCHOMPA_PISCATORIS_HUNTER_AREA_5(GREY_CHINCHOMPA, "Piscatoris Hunter area", "AKQ", new WorldPoint(2341, 3618, 0)),
	GREY_CHINCHOMPA_PISCATORIS_HUNTER_AREA_6(GREY_CHINCHOMPA, "Piscatoris Hunter area", "AKQ", new WorldPoint(2321, 3611, 0)),
	GREY_CHINCHOMPA_PISCATORIS_HUNTER_AREA_7(GREY_CHINCHOMPA, "Piscatoris Hunter area", "AKQ", new WorldPoint(2339, 3593, 0)),
	GREY_CHINCHOMPA_KOUREND_WOODLAND(GREY_CHINCHOMPA, "Kourend Woodland", "", new WorldPoint(1480, 3503, 0)),
	GREY_CHINCHOMPA_ISLE_OF_SOULS(GREY_CHINCHOMPA, "Isle of Souls", "BJP", new WorldPoint(2126, 2949, 0)),

	SABRE_TOOTHED_KYAT_RELLEKKA_HUNTER_AREA_1(SABRE_TOOTHED_KYATT, "Rellekka Hunter area", "DKS", new WorldPoint(2708, 3796, 0)),
	SABRE_TOOTHED_KYAT_RELLEKKA_HUNTER_AREA_2(SABRE_TOOTHED_KYATT, "Rellekka Hunter area", "DKS", new WorldPoint(2725, 3791, 0)),
	SABRE_TOOTHED_KYAT_RELLEKKA_HUNTER_AREA_3(SABRE_TOOTHED_KYATT, "Rellekka Hunter area", "DKS", new WorldPoint(2696, 3790, 0)),
	SABRE_TOOTHED_KYAT_RELLEKKA_HUNTER_AREA_4(SABRE_TOOTHED_KYATT, "Rellekka Hunter area", "DKS", new WorldPoint(2702, 3790, 0)),
	SABRE_TOOTHED_KYAT_RELLEKKA_HUNTER_AREA_5(SABRE_TOOTHED_KYATT, "Rellekka Hunter area", "DKS", new WorldPoint(2741, 3790, 0)),
	SABRE_TOOTHED_KYAT_RELLEKKA_HUNTER_AREA_6(SABRE_TOOTHED_KYATT, "Rellekka Hunter area", "DKS", new WorldPoint(2734, 3780, 0)),

	DARK_KEBBIT_PISCATORIS_FALCONRY_AREA_1(DARK_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2389, 3598, 0)),
	DARK_KEBBIT_PISCATORIS_FALCONRY_AREA_2(DARK_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2368, 3594, 0)),
	DARK_KEBBIT_PISCATORIS_FALCONRY_AREA_3(DARK_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2388, 3590, 0)),
	DARK_KEBBIT_PISCATORIS_FALCONRY_AREA_4(DARK_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2368, 3589, 0)),
	DARK_KEBBIT_PISCATORIS_FALCONRY_AREA_5(DARK_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2380, 3581, 0)),
	DARK_KEBBIT_PISCATORIS_FALCONRY_AREA_6(DARK_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2365, 3579, 0)),
	DARK_KEBBIT_PISCATORIS_FALCONRY_AREA_7(DARK_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2374, 3575, 0)),

	PYRE_FOX_AVIUM_SAVANNAH_1(PYRE_FOX, "Avium Savannah", "AJP", new WorldPoint(1613, 2995, 0)),
	PYRE_FOX_AVIUM_SAVANNAH_2(PYRE_FOX, "Avium Savannah", "AJP", new WorldPoint(1617, 2997, 0)),
	PYRE_FOX_AVIUM_SAVANNAH_3(PYRE_FOX, "Avium Savannah", "AJP", new WorldPoint(1621, 2994, 0)),
	PYRE_FOX_AVIUM_SAVANNAH_4(PYRE_FOX, "Avium Savannah", "AJP", new WorldPoint(1616, 3003, 0)),
	PYRE_FOX_AVIUM_SAVANNAH_5(PYRE_FOX, "Avium Savannah", "AJP", new WorldPoint(1613, 3001, 0)),

	RED_SALAMANDER_OURANIA_HUNTER_AREA_1(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2464, 3251, 0)),
	RED_SALAMANDER_OURANIA_HUNTER_AREA_2(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2468, 3242, 0)),
	RED_SALAMANDER_OURANIA_HUNTER_AREA_3(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2472, 3239, 0)),
	RED_SALAMANDER_OURANIA_HUNTER_AREA_4(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2474, 3237, 0)),
	RED_SALAMANDER_OURANIA_HUNTER_AREA_5(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2476, 3236, 0)),
	RED_SALAMANDER_OURANIA_HUNTER_AREA_6(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2449, 3226, 0)),
	RED_SALAMANDER_OURANIA_HUNTER_AREA_7(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2448, 3225, 0)),
	RED_SALAMANDER_OURANIA_HUNTER_AREA_8(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2449, 3224, 0)),
	RED_SALAMANDER_OURANIA_HUNTER_AREA_9(RED_SALAMANDER, "Ourania Hunter area", "", new WorldPoint(2453, 3221, 0)),

	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_1(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2266, 3411, 0)),
	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_2(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2268, 3409, 0)),
	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_3(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2269, 3413, 0)),
	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_4(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2271, 3411, 0)),
	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_5(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2273, 3404, 0)),
	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_6(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2275, 3407, 0)),
	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_7(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2276, 3401, 0)),
	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_8(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2277, 3404, 0)),
	RED_CHINCHOMPA_GWENITH_HUNTER_AREA_9(RED_CHINCHOMPA, "Gwenith Hunter area", "", new WorldPoint(2279, 3405, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_1(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2557, 2936, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_2(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2553, 2935, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_3(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2557, 2932, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_4(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2559, 2918, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_5(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2556, 2914, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_6(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2559, 2911, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_7(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2497, 2909, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_8(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2501, 2906, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_9(RED_CHINCHOMPA, "Feldip Hunter area", "AKS", new WorldPoint(2497, 2901, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_10(RED_CHINCHOMPA, "Feldip Hunter Area", "AKS", new WorldPoint(2507, 2885, 0)),
	RED_CHINCHOMPA_FELDIP_HUNTER_AREA_11(RED_CHINCHOMPA, "Feldip Hunter Area", "AKS", new WorldPoint(2503, 2881, 0)),

	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_1(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2266, 3411, 0)),
	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_2(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2268, 3409, 0)),
	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_3(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2269, 3413, 0)),
	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_4(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2271, 3411, 0)),
	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_5(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2273, 3404, 0)),
	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_6(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2275, 3407, 0)),
	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_7(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2276, 3401, 0)),
	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_8(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2277, 3404, 0)),
	RED_CHINCHOMPA_2_GWENITH_HUNTER_AREA_9(RED_CHINCHOMPA_2, "Gwenith Hunter area", "", new WorldPoint(2279, 3405, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_1(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2557, 2936, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_2(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2553, 2935, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_3(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2557, 2932, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_4(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2559, 2918, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_5(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2556, 2914, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_6(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2559, 2911, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_7(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2497, 2909, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_8(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2501, 2906, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_9(RED_CHINCHOMPA_2, "Feldip Hunter area", "AKS", new WorldPoint(2497, 2901, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_10(RED_CHINCHOMPA_2, "Feldip Hunter Area", "AKS", new WorldPoint(2507, 2885, 0)),
	RED_CHINCHOMPA_2_FELDIP_HUNTER_AREA_11(RED_CHINCHOMPA_2, "Feldip Hunter Area", "AKS", new WorldPoint(2503, 2881, 0)),

	MOONLIGHT_ANTELOPE_HUNTERS_GUILD_1(MOONLIGHT_ANTELOPE, "Hunters' Guild", "", new WorldPoint(1555, 9416, 0)),
	MOONLIGHT_ANTELOPE_HUNTERS_GUILD_2(MOONLIGHT_ANTELOPE, "Hunters' Guild", "", new WorldPoint(1562, 9417, 0)),
	MOONLIGHT_ANTELOPE_HUNTERS_GUILD_3(MOONLIGHT_ANTELOPE, "Hunters' Guild", "", new WorldPoint(1557, 9422, 0)),
	MOONLIGHT_ANTELOPE_HUNTERS_GUILD_4(MOONLIGHT_ANTELOPE, "Hunters' Guild", "", new WorldPoint(1561, 9421, 0)),

	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_1(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3710, 3883, 0)),
	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_2(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3697, 3876, 0)),
	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_3(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3683, 3870, 0)),
	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_4(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3681, 3865, 0)),
	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_5(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3753, 3851, 0)),
	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_6(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3717, 3840, 0)),
	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_7(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3705, 3827, 0)),
	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_8(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3704, 3808, 0)),
	HERBIBOAR_MUSHROOM_FOREST_FOSSIL_ISLAND_9(HERBIBOAR, "Mushroom Forest on Fossil Island", "", new WorldPoint(3696, 3796, 0)),

	TECU_SALAMANDER_RALOS_RISE_1(TECU_SALAMANDER, "Ralos' Rise", "", new WorldPoint(1471, 3087, 0)),
	TECU_SALAMANDER_RALOS_RISE_2(TECU_SALAMANDER, "Ralos' Rise", "", new WorldPoint(1472, 3096, 0)),
	TECU_SALAMANDER_RALOS_RISE_3(TECU_SALAMANDER, "Ralos' Rise", "", new WorldPoint(1473, 3086, 0)),
	TECU_SALAMANDER_RALOS_RISE_4(TECU_SALAMANDER, "Ralos' Rise", "", new WorldPoint(1475, 3101, 0)),
	TECU_SALAMANDER_RALOS_RISE_5(TECU_SALAMANDER, "Ralos' Rise", "", new WorldPoint(1477, 3099, 0)),

	MOONLIGHT_MOTH_HUNTER_GUILD_1(MOONLIGHT_MOTH, "Hunters' Guild", "", new WorldPoint(1562, 9441, 0)),
	MOONLIGHT_MOTH_HUNTER_GUILD_2(MOONLIGHT_MOTH, "Hunters' Guild", "", new WorldPoint(1573, 9441, 0)),
	MOONLIGHT_MOTH_HUNTER_GUILD_3(MOONLIGHT_MOTH, "Hunters' Guild", "", new WorldPoint(1570, 9444, 0)),
	MOONLIGHT_MOTH_HUNTER_GUILD_4(MOONLIGHT_MOTH, "Hunters' Guild", "", new WorldPoint(1573, 9446, 0)),
	MOONLIGHT_MOTH_HUNTER_GUILD_5(MOONLIGHT_MOTH, "Hunters' Guild", "", new WorldPoint(1554, 9443, 0)),
	MOONLIGHT_MOTH_HUNTER_GUILD_6(MOONLIGHT_MOTH, "Hunters' Guild", "", new WorldPoint(1568, 9439, 0)),
	MOONLIGHT_MOTH_HUNTER_GUILD_7(MOONLIGHT_MOTH, "Hunters' Guild", "", new WorldPoint(1557, 9427, 0)),
	MOONLIGHT_MOTH_HUNTER_GUILD_8(MOONLIGHT_MOTH, "Hunters' Guild", "", new WorldPoint(1565, 9432, 0)),
	MOONLIGHT_MOTH_NEYPOTZLI_1(MOONLIGHT_MOTH, "Neypotzli", "", new WorldPoint(1554, 9433, 0)),
	MOONLIGHT_MOTH_NEYPOTZLI_2(MOONLIGHT_MOTH, "Neypotzli", "", new WorldPoint(1349, 9574, 0)),
	MOONLIGHT_MOTH_NEYPOTZLI_3(MOONLIGHT_MOTH, "Neypotzli", "", new WorldPoint(1481, 9690, 0)),
	MOONLIGHT_MOTH_NEYPOTZLI_4(MOONLIGHT_MOTH, "Neypotzli", "", new WorldPoint(1507, 9677, 0)),

	SUNLIGHT_ANTELOPE_AVIUM_SAVANNAH_1(SUNLIGHT_ANTELOPE, "Avium Savannah", "AJP", new WorldPoint(1735, 3008, 0)),
	SUNLIGHT_ANTELOPE_AVIUM_SAVANNAH_2(SUNLIGHT_ANTELOPE, "Avium Savannah", "AJP", new WorldPoint(1738, 3003, 0)),
	SUNLIGHT_ANTELOPE_AVIUM_SAVANNAH_3(SUNLIGHT_ANTELOPE, "Avium Savannah", "AJP", new WorldPoint(1744, 3006, 0)),
	SUNLIGHT_ANTELOPE_AVIUM_SAVANNAH_4(SUNLIGHT_ANTELOPE, "Avium Savannah", "AJP", new WorldPoint(1746, 3011, 0)),
	SUNLIGHT_ANTELOPE_AVIUM_SAVANNAH_5(SUNLIGHT_ANTELOPE, "Avium Savannah", "AJP", new WorldPoint(1749, 3016, 0)),
	SUNLIGHT_ANTELOPE_AVIUM_SAVANNAH_6(SUNLIGHT_ANTELOPE, "Avium Savannah", "AJP", new WorldPoint(1750, 3001, 0)),
	SUNLIGHT_ANTELOPE_AVIUM_SAVANNAH_7(SUNLIGHT_ANTELOPE, "Avium Savannah", "AJP", new WorldPoint(1754, 3006, 0)),
	SUNLIGHT_ANTELOPE_AVIUM_SAVANNAH_8(SUNLIGHT_ANTELOPE, "Avium Savannah", "AJP", new WorldPoint(1755, 3013, 0)),

	DASHING_KEBBIT_PISCATORIS_FALCONRY_AREA_1(DASHING_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2390, 3588, 0)),
	DASHING_KEBBIT_PISCATORIS_FALCONRY_AREA_2(DASHING_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2375, 3578, 0)),
	DASHING_KEBBIT_PISCATORIS_FALCONRY_AREA_3(DASHING_KEBBIT, "Piscatoris falconry area", "AKQ", new WorldPoint(2367, 3576, 0)),

	SUNLIGHT_MOTH_AVIUM_SAVANNAH_1(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1550, 3016, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_2(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1551, 3013, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_3(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1553, 3016, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_4(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1555, 3012, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_5(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1556, 3016, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_6(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1558, 3015, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_7(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1559, 3015, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_8(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1735, 3012, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_9(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1565, 3016, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_10(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1568, 3011, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_11(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1568, 3020, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_12(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1571, 3016, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_13(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1573, 3024, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_14(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1575, 3021, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_15(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1576, 3017, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_16(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1576, 3023, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_17(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1577, 3024, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_18(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1578, 3021, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_19(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1582, 3024, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_20(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1582, 3031, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_21(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1583, 3011, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_22(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1584, 3021, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_23(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1585, 3009, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_24(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1585, 3026, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_25(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1586, 3013, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_26(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1586, 3020, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_27(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1588, 3024, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_28(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1588, 3027, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_29(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1589, 3010, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_30(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1590, 3036, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_31(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1592, 3012, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_32(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1596, 3020, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_33(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1598, 3016, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_34(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1598, 3029, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_35(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1551, 3089, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_36(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1551, 3094, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_37(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1553, 3091, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_38(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1555, 3085, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_39(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1554, 3095, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_40(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1556, 3091, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_41(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1557, 3085, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_42(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1556, 3088, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_43(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1557, 3094, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_44(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1560, 3086, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_45(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1561, 3092, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_46(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1560, 3094, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_47(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1562, 3088, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_48(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1562, 3093, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_49(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1564, 3087, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_50(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1568, 2995, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_51(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1570, 2987, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_52(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1570, 2998, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_53(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1572, 2995, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_54(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1572, 3003, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_55(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1575, 3000, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_56(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1578, 2986, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_57(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1579, 2991, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_58(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1580, 2995, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_59(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1582, 3002, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_60(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1584, 2991, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_61(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1584, 2999, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_62(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1588, 2994, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_63(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1588, 3008, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_64(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1590, 2998, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_65(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1591, 2988, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_66(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1592, 2983, 0)),
	SUNLIGHT_MOTH_AVIUM_SAVANNAH_67(SUNLIGHT_MOTH, "Avium Savannah", "AJP", new WorldPoint(1596, 2985, 0)),

	SUNLIGHT_MOTH_AVIUM_NEYPOTZLI_1(SUNLIGHT_MOTH, "Neypotzli", "", new WorldPoint(1434, 9632, 0)),
	SUNLIGHT_MOTH_AVIUM_NEYPOTZLI_2(SUNLIGHT_MOTH, "Neypotzli", "", new WorldPoint(1437, 9636, 0)),
	SUNLIGHT_MOTH_AVIUM_NEYPOTZLI_3(SUNLIGHT_MOTH, "Neypotzli", "", new WorldPoint(1441, 9626, 0)),
	SUNLIGHT_MOTH_AVIUM_NEYPOTZLI_4(SUNLIGHT_MOTH, "Neypotzli", "", new WorldPoint(1444, 9633, 0));

	@Getter
	private final com.geel.hunterrumours.enums.Rumour Rumour;

	@Getter
	private final String LocationName;

	@Getter
	private final String FairyRingCode;

	@Getter
	private final WorldPoint WorldPoint;

	/**
	 * Gets all RumourLocations linked to the given Rumour
	 */
	public static Set<RumourLocation> getLocationsForRumour(Rumour rumour)
	{
		return getLocationsStreamForRumour(rumour).collect(Collectors.toSet());
	}

	/**
	 * Gets a Set of RumourLocations linked to the given Rumour -- grouped by LocationName, then collapsed to a single
	 * entry per unique LocationName.
	 * @param rumour
	 * @return
	 */
	public static Set<RumourLocation> getCollapsedLocationsForRumour(Rumour rumour) {
		var groupedLocations = getGroupedLocationsForRumour(rumour);
		return groupedLocations.map(l -> l.getValue().get(0)).collect(Collectors.toSet());
	}

	/**
	 * Gets all RumourLocations linked to the given Rumour, grouped by LocationName
	 */
	public static Stream<Map.Entry<String, List<RumourLocation>>> getGroupedLocationsForRumour(Rumour rumour)
	{
		var locations = getLocationsStreamForRumour(rumour).toArray(RumourLocation[]::new);

		// Create a map to remember the ordering of declaration of the locations (by the first instance of
		// each location name). This is so we can group by name (which loses this ordering) and then sort the groups
		// by the original declaration order.
		Map<String, Integer> locationDeclarationOrder = new HashMap<>();
		int i = 0;
		for(RumourLocation location : locations) {
			if(!locationDeclarationOrder.containsKey(location.getLocationName())) {
				locationDeclarationOrder.put(location.getLocationName(), i++);
			}
		}

		// I do not know Java very well and there is surely a better way to do this, but... I think it works, so, oh well.
		// Group the locations by their name, then return those groups sorted by declaration order of their first location.
		return Arrays.stream(locations)
				.collect(Collectors.groupingBy(RumourLocation::getLocationName))
				.entrySet()
				.stream()
				.sorted(Comparator.comparingInt(a -> locationDeclarationOrder.get(a.getKey())));
	}

	private static Stream<RumourLocation> getLocationsStreamForRumour(Rumour rumour)
	{
		return Arrays.stream(RumourLocation.values()).filter(loc -> loc.getRumour() == rumour);
	}
}
package com.geel.hunterrumours.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Item;
import net.runelite.api.ItemID;

@AllArgsConstructor
public enum Trap {
    SNARE("Bird snare", ItemID.BIRD_SNARE, 40, 38),
    DEADFALL("Deadfall", ItemID.LOGS, 30, 28),
    NET_TRAP("Net trap", ItemID.SMALL_FISHING_NET, 50, 46),
    PIT("Pit Trap", ItemID.TEASING_STICK, 30, 28),
    BOX_TRAP("Box Trap", ItemID.BOX_TRAP, 100, 94),
    FALCONRY("Falconry", ItemID.FALCONERS_GLOVE, 20, 18),
    BUTTERFLY("Butterfly Net", ItemID.BUTTERFLY_NET, 150, 142),
    NOOSE("Tracking", ItemID.NOOSE_WAND, 30, 28),
    NOOSE_HERBIBOAR("Tracking", ItemID.NOOSE_WAND, 14, 12);

    @Getter
    private final String Name;

    @Getter
    private final int ItemId;

    @Getter
    private final int pityThreshold;

    @Getter
    private final int pityThresholdWithOutfit;

    public int calculatePityRateForItems(final int items) {
        int difference = pityThreshold - pityThresholdWithOutfit;
        double differenceForItems = difference / 4d * items;
        return (int) Math.floor(pityThreshold - differenceForItems);
    }
}

package com.geel.hunterrumours;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(HunterRumoursConfig.GROUP)
public interface HunterRumoursConfig extends Config {
    String GROUP = "hunterrumours";

    enum HighlightType {
        OUTLINE,
        TILE,
        BOTH,
        NONE
    }

    @ConfigSection(
            name = "Hunter Guild Display",
            description = "Configure the panel that displays information while underground in the Hunter Guild.",
            position = 1
    )
    String hunterGuildDisplaySection = "hunterGuildDisplaySection";

    @ConfigSection(
            name = "Current Rumour Infobox",
            description = "Configure the infobox that shows your current Rumour.",
            position = 2
    )
    String infoBoxSection = "infoBoxSection";

    @ConfigSection(
            name = "World Map",
            description = "Configure the hunter creature locations the plugin adds to the world map.",
            position = 3
    )
    String worldMapSection = "worldMapSection";

    @ConfigSection(
            name = "Fairy Rings",
            description = "Configure the behavior of fairy rings while you have a rumour",
            position = 4
    )
    String fairyRingSection = "fairyRingSection";

    @ConfigSection(
            name = "Chat Messages",
            description = "Configure various chat messages that the plugin creates.",
            position = 5
    )
    String messagesSection = "messagesSection";

    @ConfigSection(
            name = "Hunter Tiers",
            description = "The tiers of hunters that are enabled.",
            position = 6
    )
    String tiersSection = "tiersSection";

    @ConfigSection(
            name = "Highlights",
            description = "Highlights for Hunters and Hunter Targets.",
            position = 7
    )
    String highlightSection = "highlightSection";

    @ConfigItem(
            position = 0,
            keyName = "autoJumpFairyRing",
            name = "Auto-Scroll to Fairy Ring",
            description = "Whether to automatically scroll to the appropriate fairy ring for your current rumour when opening the fairy ring interface",
            section = fairyRingSection
    )
    default boolean autoJumpFairyring() {
        return true;
    }

    @ConfigItem(
            position = 1,
            keyName = "autoJumpFairyRingDisableTimer",
            name = "Auto-Scroll Disable Timer (minutes)",
            description = "Stops auto-scrolling the fairy ring menu after a certain amount of time (in minutes) of no hunter rumour related activity.<br />Turn on 'Force Auto-Scroll Fairy Ring' if you want the fairy ring menu to auto-scroll at all times.",
            section = fairyRingSection
    )
    @Range(min = 1)
    default int autoJumpFairyRingDisableTimer() {
        return 5;
    }

    @ConfigItem(
            position = 2,
            keyName = "forceAutoJumpFairyRing",
            name = "Force Auto-Scroll to Fairy Ring",
            description = "Forces the fairy ring interface to scroll to the appropriate fairy ring for your current rumour even after the time set above.<br />Only works if 'Auto-Scroll to Fairy Ring' is enabled.",
            section = fairyRingSection
    )
    default boolean forceAutoJumpFairyRing() {
        return false;
    }

    @ConfigItem(
            position = 0,
            keyName = "showWorldMapLocations",
            name = "Show World Map Locations",
            description = "Whether the locations of your current rumour should show up on your world map.",
            section = worldMapSection
    )
    default boolean showWorldMapLocations() {
        return true;
    }

    @ConfigItem(
            position = 1,
            keyName = "compactWorldMap",
            name = "Compact World Map Locations",
            description = "Only show 1 icon per location on the World Map.",
            section = worldMapSection
    )
    default boolean compactWorldMap() {
        return false;
    }

    @ConfigItem(
            position = 2,
            keyName = "worldMapLocationsDisableTimer",
            name = "Locations Disable Timer (minutes)",
            description = "Stops showing the locations on the World Map after a certain amount of time (in minutes) of no hunter rumour related activity.<br />Turn on 'Force Show Locations' if you want the info box to be visible at all times.",
            section = worldMapSection
    )
    @Range(min = 1)
    default int worldMapLocationsDisableTimer() {
        return 5;
    }

    @ConfigItem(
            position = 3,
            keyName = "forceShowWorldMapLocations",
            name = "Force Show Locations",
            description = "Forces the World Map Locations to be shown even after the time set above.<br />Only works if 'Show World Map Locations' is enabled.",
            section = worldMapSection
    )
    default boolean forceShowWorldMapLocations() {
        return false;
    }

    @ConfigItem(
            position = 0,
            keyName = "showOverlay",
            name = "Show Hunter Guild Info Panel",
            description = "Show an overlay that lists the current hunter guild rumours when in the burrows.",
            section = hunterGuildDisplaySection
    )
    default boolean showOverlay() {
        return true;
    }

    @ConfigItem(
            position = 1,
            keyName = "showAllHunters",
            name = "List All Hunter Rumours",
            description = "List all tracked hunters and their current rumours in the guild overlay.",
            section = hunterGuildDisplaySection
    )
    default boolean guildOverlayListHunters() {
        return false;
    }

    @ConfigItem(
            position = 2,
            keyName = "showBackToBackState",
            name = "Show Back-to-Back State",
            description = "Displays the back-to-back state (enabled/disabled) in the guild overlay.",
            section = hunterGuildDisplaySection
    )
    default boolean guildOverlayShowBackToBackState() {
        return true;
    }

    @ConfigItem(
            position = 0,
            keyName = "showRumourInfoBox",
            name = "Show Rumour Infobox",
            description = "Whether an infobox containing your current rumour target should be displayed.",
            section = infoBoxSection
    )
    default boolean showInfoBox() {
        return true;
    }

    @ConfigItem(
            position = 1,
            keyName = "showCatchesRemainingUntilPity",
            name = "Show Catches Remaining",
            description = "Show the catches remaining until the pity threshold is reached.",
            section = infoBoxSection
    )
    default boolean showCatchesRemainingUntilPity() {
        return true;
    }

    @ConfigItem(
            position = 2,
            keyName = "infoBoxDisableTimer",
            name = "Info Box Disable Timer (minutes)",
            description = "Disables the info box after a certain amount of time (in minutes) of no hunter rumour related activity.<br />Turn on 'Force Show Info Box' if you want the info box to be visible at all times.",
            section = infoBoxSection
    )
    @Range(min = 1)
    default int infoBoxDisableTimer() {
        return 5;
    }

    @ConfigItem(
            position = 3,
            keyName = "forceShowInfoBox",
            name = "Force Show Info Box",
            description = "Forces the infobox to be shown even after the time set above<br />Only works if 'Show Rumour Infobox' is enabled.",
            section = infoBoxSection
    )
    default boolean forceShowInfoBox() {
        return false;
    }

    @ConfigItem(
            position = 4,
            keyName = "infoBoxCompletedRumourColor",
            name = "Infobox Completed Rumour Color",
            description = "Text color of the infobox when you completed a rumour.",
            section = infoBoxSection
    )
    default Color completedRumourInfoBoxTextColor() {

        return Color.GREEN;
    }

    @ConfigItem(
            position = 5,
            keyName = "infoBoxLuckyRateColor",
            name = "Infobox Lucky Rate Color",
            description = "Text color of the infobox when you're still in the lucky bracket (<50%) for catching creatures based on pity rates.",
            section = infoBoxSection
    )
    default Color luckyRateInfoBoxTextColor() {

        return Color.RED;
    }

    @ConfigItem(
            position = 6,
            keyName = "infoBoxDefaultColor",
            name = "Infobox Default Color",
            description = "The default text color of the infobox.",
            section = infoBoxSection
    )
    default Color defaultInfoBoxTextColor() {

        return Color.WHITE;
    }

    @ConfigItem(
            position = 7,
            keyName = "infoBoxNormalRateColor",
            name = "Infobox Normal Rate Color",
            description = "Text color of the infobox when you're in the normal bracket (between 50% and 75%) for catching creatures based on pity rates.",
            section = infoBoxSection
    )
    default Color normalRateInfoBoxTextColor() {

        return Color.ORANGE.darker();
    }

    @ConfigItem(
            position = 8,
            keyName = "infoBoxUnluckyColor",
            name = "Infobox Unlucky Rate Color",
            description = "Text color of the infobox when you're in the unlucky bracket (75% or more) for catching creatures based on pity rates.",
            section = infoBoxSection
    )
    default Color unluckyRateInfoBoxTextColor() {
        return Color.ORANGE.brighter();
    }

    @ConfigItem(
            position = 0,
            keyName = "currentRumourMessage",
            name = "Current Rumour Message",
            description = "Place a message in chat whenever the current Rumour changes.",
            section = messagesSection
    )
    default boolean currentRumourMessage() {
        return true;
    }

    @ConfigItem(
            position = 1,
            keyName = "backToBackMessage",
            name = "Back-To-Back Message",
            description = "Place a message in chat whenever the current back-to-back status changes.",
            section = messagesSection
    )
    default boolean backToBackMessage() {
        return true;
    }

    @ConfigItem(
            position = 2,
            keyName = "endOfRumourMessage",
            name = "End-of-Rumour Message",
            description = "Place a message in chat whenever you complete a rumour, containing stats about the rumour.",
            section = messagesSection
    )
    default boolean endOfRumourMessage() {
        return false;
    }

    @ConfigItem(
            position = 3,
            keyName = "endOfRumourMessageUnluckyColor",
            name = "End-of-Rumour Unlucky Color",
            description = "Message color if you've caught >= 75% of the pity rate threshold.",
            section = messagesSection
    )
    default Color endOfRumourMessageUnluckyColor() {

        return Color.RED;
    }

    @ConfigItem(
            position = 4,
            keyName = "endOfRumourMessageNormalColor",
            name = "End-of-Rumour Normal Color",
            description = "Message color if you've caught between and including 50 and 74 percent of the pity rate threshold.",
            section = messagesSection
    )
    default Color endOfRumourMessageNormalColor() {

        return Color.ORANGE;
    }

    @ConfigItem(
            position = 5,
            keyName = "endOfRumourMessageLuckyColor",
            name = "End-of-Rumour Lucky Color",
            description = "Message color if you've caught less than 50% of the pity rate threshold.",
            section = messagesSection
    )
    default Color endOfRumourMessageLuckyColor() {

        return Color.GREEN;
    }

    @ConfigItem(
            position = 0,
            keyName = "includeMasterHunters",
            name = "Include Master Hunters",
            description = "Include master hunters in highlighting and info reports.",
            section = tiersSection
    )
    default boolean includeMasterHunters() {
        return true;
    }

    @ConfigItem(
            position = 1,
            keyName = "includeExpertHunters",
            name = "Include Expert Hunters",
            description = "Include Expert hunters in highlighting and info reports.",
            section = tiersSection
    )
    default boolean includeExpertHunters() {
        return true;
    }

    @ConfigItem(
            position = 2,
            keyName = "includeAdeptHunters",
            name = "Include Adept Hunters",
            description = "Include adept hunters in highlighting and info reports.",
            section = tiersSection
    )
    default boolean includeAdeptHunters() {
        return true;
    }

    @ConfigItem(
            position = 3,
            keyName = "includeNoviceHunters",
            name = "Include Novice Hunters",
            description = "Include novice hunters in highlighting and info reports.",
            section = tiersSection
    )
    default boolean includeNoviceHunters() {
        return true;
    }

    @ConfigItem(
            position = 0,
            keyName = "highlightCurrentHunter",
            name = "Highlight current hunter",
            description = "Whether the hunter that assigned your current task should be highlighted.",
            section = highlightSection
    )
    default boolean highlightCurrentHunter() {
        return true;
    }

    @ConfigItem(
            position = 1,
            keyName = "highlightKnownHunters",
            name = "Highlight known hunters",
            description = "Whether hunters whose rumour is known should be highlighted.",
            section = highlightSection
    )
    default boolean highlightKnownHunters() {
        return false;
    }

    @ConfigItem(
            position = 2,
            keyName = "highlightUnknownHunters",
            name = "Highlight unknown hunters",
            description = "Whether hunters whose rumour is unknown should be highlighted.",
            section = highlightSection
    )
    default boolean highlightUnknownHunters() {
        return false;
    }

    @ConfigItem(
            position = 3,
            keyName = "highlightHunterNPCs",
            name = "Highlight Hunter NPCs",
            description = "Whether your current rumour target should be highlighted.",
            section = highlightSection
    )
    default HighlightType highlightHunterNPCs() {
        return HighlightType.OUTLINE;
    }

    @ConfigItem(
            position = 4,
            keyName = "currentHunterHighlightColor",
            name = "Current hunter highlight color",
            description = "Highlight color for hunter who assigned your current rumour.",
            section = highlightSection
    )
    default Color currentHunterHighlightColor() {

        return new Color(0, 0x96, 0);
    }

    @ConfigItem(
            position = 5,
            keyName = "knownHunterHighlightColor",
            name = "Known hunter highlight color",
            description = "Highlight color for hunters whose rumours are known.",
            section = highlightSection
    )
    default Color knownHunterHighlightColor() {
        return new Color(0xC8, 0xC8, 0);
    }

    @ConfigItem(
            position = 6,
            keyName = "unknownHunterHighlightColor",
            name = "Unknown hunter highlight color",
            description = "Highlight color for hunters whose rumours are not known.",
            section = highlightSection
    )
    default Color unknownHunterHighlightColor() {

        return new Color(0x96, 0, 0);
    }

    @ConfigItem(
            position = 7,
            keyName = "hunterNPCHighlightColor",
            name = "Hunter NPC Highlight Color",
            description = "Highlight color for Hunter targets.",
            section = highlightSection
    )
    default Color hunterNPCHighlightColor() {

        return new Color(0x4B, 0x9D, 0xDD);
    }
}

package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.BackToBackState;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;

import static java.util.Arrays.asList;

@Slf4j
class HunterRumoursOverlay extends OverlayPanel {
    private final Client client;
    private final HunterRumoursPlugin plugin;
    private final HunterRumoursConfig config;

    @Inject
    private HunterRumoursOverlay(Client client, HunterRumoursPlugin plugin, HunterRumoursConfig config) {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.isInBurrows() || !config.showOverlay())
            return null;

        var children = panelComponent.getChildren();

        children.addAll(asList(
                TitleComponent.builder()
                        .text("Hunter Rumours")
                        .build(),
                LineComponent.builder()
                        .left("Current Hunter")
                        .right(plugin.currentHunter.getCommonName())
                        .build(),
                LineComponent.builder()
                        .left("Current Rumour")
                        .right(plugin.getCurrentRumour().getFullName())
                        .build()
                )
        );

        // Add back-to-back state if enabled
        if (plugin.getConfig().guildOverlayShowBackToBackState()) {
            children.add(LineComponent.builder()
                    .left("Back-To-Back")
                    .right(plugin.getBackToBackState().getNiceName())
                    .rightColor(BackToBackColor(plugin.getBackToBackState()))
                    .build()
            );
        }

        // Add list of hunters if enabled
        if (plugin.getConfig().guildOverlayListHunters()) {
            var enabledHunters = plugin.getEnabledHunters();

            // If any hunters to add, add a spacing line before listing them
            if (enabledHunters.length > 0) {
                children.add(LineComponent.builder().build());
            }

            // List all hunters
            for (var hunter : enabledHunters) {
                children.add(
                        LineComponent.builder()
                                .left(hunter.getCommonName())
                                .right(HunterRumoursPlugin.hunterRumours.get(hunter).getFullName())
                                .build()
                );
            }

        }

        // Hack to figure out ~~~roughly~~~ how big the panel should be
        panelComponent.setPreferredSize(new Dimension(graphics.getFontMetrics().stringWidth("Current Rumour      Razor-backed Kebbit (Deadfall)"), 0));

        return super.render(graphics);
    }

    private Color BackToBackColor(BackToBackState state) {
        switch (state) {
            case UNKNOWN:
                return Color.YELLOW;
            case ENABLED:
                return Color.GREEN;
            case DISABLED:
                return Color.RED;
            default:
                return Color.PINK;
        }
    }

}

package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.*;
import com.google.errorprone.annotations.Var;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.kit.KitType;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.npcoverlay.HighlightedNpc;
import net.runelite.client.game.npcoverlay.NpcOverlayService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.awt.*;
import java.util.*;

@PluginDescriptor(
        name = "Hunter Rumours",
        description = "Tracks your current hunter rumour, as well as the saved rumours of all masters",
        tags = {"hunter", "hunters", "guild", "rumour", "rumor", "contract", "task", "varlamore"}
)
@Slf4j
public class HunterRumoursPlugin extends Plugin {
    // Varbit value corresponding to the Tier-1 relic Animal Wrangler.
    // This is used because this relic gives double hunter XP for chinchompas, which we need to account for to track kills.
    public static int RELIC_ANIMAL_WRANGLER = 3;

    public static final Map<Hunter, Rumour> hunterRumours = new HashMap<>() {
        {
            for (var hunter : Hunter.allValues()) {
                put(hunter, Rumour.NONE);
            }
        }
    };

    public Hunter currentHunter = Hunter.NONE;
    private boolean currentRumourFinished = false;
    private BackToBackState backToBackState = BackToBackState.UNKNOWN;
    private final Set<HunterRumourWorldMapPoint> currentMapPoints = new HashSet<>();
    private int previousHunterExp = -1; // Tracks Hunter experience -- used to detect XP drops indicating a creature was caught

    @Getter
    private int hunterKitItems = 0;

    @Inject
    @Getter
    private HunterRumoursConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private NpcOverlayService npcOverlayService;

    @Inject
    private InfoBoxManager infoBoxManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private HunterRumoursOverlay overlay;

    @Inject
    private ConfigManager configManager;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ChatParser chatParser;

    @Inject
    private RuneLiteConfig runeLiteConfig;

    @Inject
    private WorldMapPointManager worldMapPointManager;
    private int latestInteractionTime = -1;

    @Provides
    HunterRumoursConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(HunterRumoursConfig.class);
    }

    @Override
    protected void startUp() throws Exception {
        overlayManager.add(overlay);
        npcOverlayService.registerHighlighter(this::highlighterFn);
        clientThread.invoke(this::loadFromConfig);
    }

    @Override
    protected void shutDown() throws Exception {
        overlayManager.remove(overlay);

        removeInfoBox();
        npcOverlayService.unregisterHighlighter(this::highlighterFn);
        npcOverlayService.rebuild();
        clientThread.invoke(this::resetParams);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
            clientThread.invoke(this::loadFromConfig);
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (!configChanged.getGroup().equals(HunterRumoursConfig.GROUP)) {
            return;
        }

        clientThread.invoke(this::loadFromConfig);
        clientThread.invoke(this::refreshAllDisplays);
    }

    @Subscribe
    public void onCommandExecuted(CommandExecuted event) {
        if (event.getCommand().equals("resetrumours")) {
            clientThread.invoke(this::resetConfig);
        }
    }

    @Subscribe
    public void onPlayerChanged(PlayerChanged event) {
        // We only care about ourselves
        if (event.getPlayer().getId() != client.getLocalPlayer().getId()) {
            return;
        }

        // Parse out hunter equipment
        var player = event.getPlayer();
        var comp = player.getPlayerComposition();
        var head = comp.getEquipmentId(KitType.HEAD);
        var top = comp.getEquipmentId(KitType.TORSO);
        var legs = comp.getEquipmentId(KitType.LEGS);
        var boots = comp.getEquipmentId(KitType.BOOTS);

        var isHead = head == ItemID.GUILD_HUNTER_HEADWEAR;
        var isTop = top == ItemID.GUILD_HUNTER_TOP;
        var isLegs = legs == ItemID.GUILD_HUNTER_LEGS;
        var isBoots = boots == ItemID.GUILD_HUNTER_BOOTS;

        var items = 0;

        if (isHead) {
            items++;
        }

        if (isTop) {
            items++;
        }

        if (isLegs) {
            items++;
        }

        if (isBoots) {
            items++;
        }

        if (items != hunterKitItems) {
            hunterKitItems = items;
            if (items > 0) {
                updateLatestInteractionTime();
            }
            refreshAllDisplays();
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.FAIRY_RING_PANEL && config.autoJumpFairyring()) {
            clientThread.invokeLater(this::handleFairyRingPanel);
        }

        if (event.getGroupId() == InterfaceID.DIALOG_OPTION && isInBurrows()) {
            clientThread.invokeLater(this::handleBackToBackDialog);
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        handleBurrowsHunterDialog(event);
        handleQuetzalWhistleChatMessage(event);
        handleBackToBackChatMessage(event);

        // Handle the "rumour finished" chat message at the END of the current tick.
        // This is to ensure that we process the caught creature XP drop and increment the caught count
        // before we display stats about the rumour on completion.
        // Without this, we (sometimes?) handle the rumour finished before we handle the creature being caught,
        // causing us to show incorrect statistics.
        clientThread.invokeAtTickEnd(() -> {
            handleRumourFinishedChatMessage(event);
        });
    }

    @Subscribe
    protected void onStatChanged(StatChanged event) {
        if (event.getSkill() != Skill.HUNTER) {
            return;
        }

        final int currentXp = event.getXp();

        // If previous XP is -1, just update to the current XP.
        if (previousHunterExp == -1) {
            previousHunterExp = currentXp;
            return;
        }

        int xpDiff = (currentXp - previousHunterExp) / getLeaguesXpMultiplier();
        if (xpDiff <= 0) {
            return;
        }

        // RAGING ECHOES LEAGUE: We need to account for the possibility that the player just caught a chinchompa
        // while using the Animal Wrangler relic, which will give them yet double the XP.
        // This is a bit gross. I write good code in my actual job.
        // Mostly.
        if (hasDoubleChinchompaExperience()) {
            final int preChincompaXpDiff = xpDiff;

            if (Arrays.stream(Creature.GREY_CHINCHOMPA.getPossibleXpDrops()).anyMatch(possibleXpDrop -> possibleXpDrop == (preChincompaXpDiff / 2))
                    || Arrays.stream(Creature.RED_CHINCHOMPA.getPossibleXpDrops()).anyMatch(possibleXpDrop -> possibleXpDrop == (preChincompaXpDiff / 2))) {
                // If we just caught a chincompa, just divide xpDiff by 2 here so that the below code will correctly identify
                // the catch as a chinchompa. Smart moves from a smart engineer (me).
                xpDiff /= 2;
            }
        }

        // Create a final int because Java requires that for lambda captures
        final int finalXpDiff = xpDiff;

        // Find the creature that corresponds to the XP drop and mark them as being fucking dead
        if (Arrays.stream(getCurrentRumour().getTargetCreature().getPossibleXpDrops()).anyMatch(possibleXpDrop -> possibleXpDrop == finalXpDiff)) {
            if (!currentRumourFinished) {
                incrementCaughtCreatures();
                refreshAllDisplays();
            }
        }

        previousHunterExp = currentXp;
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        handleInfoBox();

        if (!shouldWorldMapLocationsBeShown()) {
            for (HunterRumourWorldMapPoint location : currentMapPoints) {
                worldMapPointManager.remove(location);
            }

            currentMapPoints.clear();
        }
    }

    /**
     * Sets the back-to-back state in memory and in config.
     * <p>
     * If this is due to a user's choice (eg they changed it), puts a message in chat indicating their current back-to-back status
     */
    public void setBackToBackState(BackToBackState backToBackState, boolean isFromUserChoice) {
        updateLatestInteractionTime();
        configManager.setRSProfileConfiguration(HunterRumoursConfig.GROUP, "backtoback", backToBackState);
        this.backToBackState = backToBackState;

        // If the user changed the current status, put a message in chat
        if (isFromUserChoice && config.backToBackMessage()) {
            Color color = backToBackState == BackToBackState.ENABLED ? Color.GREEN : Color.RED;
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Back-to-back: " + ColorUtil.wrapWithColorTag(backToBackState.getNiceName(), color), "");
        }
    }

    /**
     * Sets whether the user has completed their current rumour
     */
    public void setHunterRumourState(boolean hasFinishedCurrentRumour) {
        updateLatestInteractionTime();
        configManager.setRSProfileConfiguration(HunterRumoursConfig.GROUP, "current.rumour.finished", hasFinishedCurrentRumour);
        this.currentRumourFinished = hasFinishedCurrentRumour;
    }

    /**
     * Gets whether the user has completed their current rumour
     */
    public boolean getHunterRumourState() {
        return this.currentRumourFinished;
    }

    /**
     * Sets the Hunter whose Rumour the user is currently assigned
     */
    public void setCurrentHunter(Hunter hunter) {
        updateLatestInteractionTime();
        configManager.setRSProfileConfiguration(HunterRumoursConfig.GROUP, "current.hunter", hunter);
        currentHunter = hunter;
    }

    /**
     * Sets the current Rumour for the given Hunter, even if they're not the user's current Hunter
     */
    public void setHunterRumour(Hunter hunter, Rumour rumour) {
        updateLatestInteractionTime();
        hunterRumours.put(hunter, rumour);
        configManager.setRSProfileConfiguration(HunterRumoursConfig.GROUP, "hunter." + hunter.getNpcId(), rumour);
    }

    /**
     * @return An array of the hunters that the user has enabled via plugin config.
     */
    public Hunter[] getEnabledHunters() {
        return Arrays.stream(Hunter.allValues()).filter(this::isHunterEnabled).toArray(Hunter[]::new);
    }

    /**
     * Increments the currently caught creatures by one and sets the value.
     */
    public void incrementCaughtCreatures() {
        updateLatestInteractionTime();
        setCaughtCreatures(getCaughtRumourCreatures() + 1);
    }

    /**
     * Sets the currently caught creatures.
     *
     * @param caughtCreatures the amount of creatures currently caught
     */
    private void setCaughtCreatures(int caughtCreatures) {
        configManager.setRSProfileConfiguration(HunterRumoursConfig.GROUP, "current.rumour.caught", caughtCreatures);
    }

    /**
     * @return The current amount of hunter creatures you've caught.
     */
    public int getCaughtRumourCreatures() {
        try {
            final int caughtCreatures = configManager.getRSProfileConfiguration(HunterRumoursConfig.GROUP, "current.rumour.caught", int.class);
            return caughtCreatures;
        } catch (NullPointerException ex) {
            return 0;
        }
    }

    /**
     * @return True if the user has enabled the given hunter's Tier to be tracked/displayed via plugin config.
     */
    public boolean isHunterEnabled(Hunter hunter) {
        switch (hunter.getTier()) {
            case MASTER:
                return config.includeMasterHunters();
            case EXPERT:
                return config.includeExpertHunters();
            case ADEPT:
                return config.includeAdeptHunters();
            case NOVICE:
                return config.includeNoviceHunters();
            case NONE:
            default:
                return false;
        }
    }

    /**
     * @return The current back-to-back state
     */
    public BackToBackState getBackToBackState() {
        return backToBackState;
    }

    /**
     * @return The Rumour that (we think) the player is currently assigned.
     */
    public Rumour getCurrentRumour() {
        // If there's no current Hunter, we don't have a rumour??? obviously?????
        if (currentHunter == Hunter.NONE) {
            return Rumour.NONE;
        }

        // Otherwise, if we know the current Hunter, always use it.
        return hunterRumours.get(currentHunter);
    }

    /**
     * @return True if the player is currently located within the Hunter Burrows
     */
    public boolean isInBurrows() {
        Player local = client.getLocalPlayer();
        if (local == null) {
            return false;
        }

        WorldPoint location = local.getWorldLocation();
        if (location.getPlane() != 0) {
            return false;
        }

        int x = location.getX();
        int y = location.getY();

        return x >= 1549 && x <= 1565 && y >= 9449 && y <= 9464;
    }

    private int getLeaguesXpMultiplier() {
        // This code is specific to Raging Echoes league, so in case I don't patch this before future leagues, don't consider them
        // Make sure current date is before January 23, 2025
        if (System.currentTimeMillis() > (1737608400L * 1000L)) {
            return 1;
        }

        var tier1 = client.getVarbitValue(Varbits.LEAGUE_RELIC_1);
        var tier2 = client.getVarbitValue(Varbits.LEAGUE_RELIC_2);
        var tier5 = client.getVarbitValue(Varbits.LEAGUE_RELIC_5);
        var tier7 = client.getVarbitValue(Varbits.LEAGUE_RELIC_7);

        if (tier1 == 0) {
            return 1; // No relic -- 1x
        }

        if (tier2 == 0) {
            return 5; // Only t1 relic -- 5x
        }

        if (tier5 == 0) {
            return 8; // Only t1 and t2 relics -- 8x
        }

        if (tier7 == 0) {
            return 12; // Only t1, t2, and t5 relics -- 10x
        }

        return 16; // Has t7 relic -- 16x
    }

    private boolean hasDoubleChinchompaExperience() {
        return client.getVarbitValue(Varbits.LEAGUE_RELIC_1) == RELIC_ANIMAL_WRANGLER;
    }

    /**
     * Called when the fairy ring dialog is opened.
     * Responsible for scrolling to the relevant rumour code and highlighting it, if relevant.
     */
    private void handleFairyRingPanel() {
        // TODO: Look into fairy ring plugin and steal its scroll code, which is allegedly much simpler than mine.

        // Ensure we have a current, non-completed rumour
        var currentRumour = getCurrentRumour();
        if (currentRumour == Rumour.NONE) {
            return;
        }

        if (getHunterRumourState()) {
            return;
        }

        // Find the first-declared location for this rumour
        var locationGroups = RumourLocation.getGroupedLocationsForRumour(currentRumour);
        var firstLocationWithFairyRing = locationGroups.filter(g -> g.getValue().get(0).getFairyRingCode().length() == 3).findFirst();

        if (firstLocationWithFairyRing.isEmpty()) {
            return;
        }

        var fairyRingCode = firstLocationWithFairyRing.get().getValue().get(0).getFairyRingCode();

        if (!shouldFairyRingAutoJump()) {
            return;
        }

        // Find all the necessary widgets
        Widget panelList = client.getWidget(ComponentID.FAIRY_RING_PANEL_LIST);
        Widget favoritesList = client.getWidget(ComponentID.FAIRY_RING_PANEL_FAVORITES);
        Widget scrollBar = client.getWidget(ComponentID.FAIRY_RING_PANEL_SCROLLBAR);

        if (panelList == null || scrollBar == null || favoritesList == null) {
            return;
        }

        Widget scrollBarContainer = null, scrollBarHandle = null, scrollBarHandleTop = null,
                scrollBarHandleBottom = null, scrollBarUpButton = null, scrollBarDownButton = null;
        for (var scrollChild : scrollBar.getDynamicChildren()) {
            // This is stupid
            switch (scrollChild.getSpriteId()) {
                case SpriteID.SCROLLBAR_ARROW_DOWN:
                    scrollBarDownButton = scrollChild;
                    break;
                case SpriteID.SCROLLBAR_ARROW_UP:
                    scrollBarUpButton = scrollChild;
                    break;
                case SpriteID.SCROLLBAR_THUMB_MIDDLE:
                    scrollBarHandle = scrollChild;
                    break;
                case SpriteID.SCROLLBAR_THUMB_TOP:
                    scrollBarHandleTop = scrollChild;
                    break;
                case SpriteID.SCROLLBAR_THUMB_BOTTOM:
                    scrollBarHandleBottom = scrollChild;
                    break;
                case SpriteID.SCROLLBAR_THUMB_MIDDLE_DARK:
                    scrollBarContainer = scrollChild; // Weird reuse of a sprite for the inset slider container
                    break;
            }
        }

        // Lol
        if (scrollBarContainer == null || scrollBarHandle == null || scrollBarHandleTop == null
                || scrollBarHandleBottom == null || scrollBarUpButton == null || scrollBarDownButton == null) {
            return;
        }

        // Construct a list of all widgets that are the fairy ring code texts
        // Yes, this is slightly inefficient with memory. You should see what other plugins do!
        var codeWidgets = new ArrayList<Widget>();

        // Add in all children from the big list
        codeWidgets.addAll(Arrays.asList(panelList.getDynamicChildren()));

        // Add in all children from the favorites list
        codeWidgets.addAll(Arrays.asList(favoritesList.getStaticChildren()));

        // Find the widget corresponding to the fairy ring code
        Widget foundCodeWidget = null;
        for (var codeWidget : codeWidgets) {
            if (!codeWidget.getText().replace(" ", "").contentEquals(fairyRingCode)) {
                continue;
            }

            foundCodeWidget = codeWidget;
            break;
        }

        // If no widget found, bail out
        if (foundCodeWidget == null) {
            return;
        }

        // Scroll to the code entry and highlight it
        int panelScrollY = Math.min(foundCodeWidget.getRelativeY(), panelList.getScrollHeight() - panelList.getHeight());
        panelList.setScrollY(panelScrollY);
        panelList.revalidateScroll();
        foundCodeWidget.setTextColor(0x00FF00);
        foundCodeWidget.setText("(Rumour) " + foundCodeWidget.getText());

        // Determine scrollbar placement -- has to be done manually, I think, because just setting the panel
        // scroll value doesn't actually adjust its scrollbar (which makes sense)
        double codeEntryPlacement = (double) foundCodeWidget.getRelativeY() / (double) panelList.getScrollHeight();
        int maxHandleY = scrollBarContainer.getHeight() - 4; // Not sure where the 4 comes from... just padding?
        int handleY = (int) ((double) scrollBarContainer.getHeight() * codeEntryPlacement) + scrollBarUpButton.getHeight();
        handleY = Math.min(handleY, maxHandleY);
        int handleBottomY = handleY + (scrollBarHandle.getHeight() - scrollBarHandleBottom.getHeight());

        scrollBarHandle.setOriginalY(handleY);
        scrollBarHandleTop.setOriginalY(handleY);
        scrollBarHandleBottom.setOriginalY(handleBottomY);
        scrollBarHandle.revalidateScroll();
        scrollBarHandleTop.revalidateScroll();
        scrollBarHandleBottom.revalidateScroll();
    }

    /**
     * Called when the dialog options to enable/disable back-to-back rumours are shown.
     * Hooks in to dialog choice and updates state accordingly.
     */
    private void handleBackToBackDialog() {
        var widget = client.getWidget(ComponentID.DIALOG_OPTION_OPTIONS);
        if (widget == null) {
            return;
        }

        var children = widget.getChildren();
        if (children == null || children.length != 5) {
            return;
        }

        var title = children[0];
        var option1 = children[1];
        var option2 = children[2];

        if (title == null || option1 == null || option2 == null) {
            return;
        }

        boolean isPromptingToDisable = title.getText().contains("Disable back-to-back rumours?");
        boolean isPromptingToEnable = title.getText().contains("Enable back-to-back rumours?");

        if ((!isPromptingToDisable && !isPromptingToEnable)) {
            return;
        }

        BackToBackState ifYesState = isPromptingToEnable ? BackToBackState.ENABLED : BackToBackState.DISABLED;

        // HACK(ish): if the user is 2quick2fast, they can select the option before this callback fires,
        // causing us to fail to attach a listener / cause the text to not be what we expect. So handle
        // that here.
        if (option1.getText().equals("Please wait...")) {
            setBackToBackState(ifYesState, true);
            return;
        }

        // Options should be "Yes" and "No"
        if (!option1.getText().equals("Yes") || !option2.getText().equals("No")) {
            return;
        }

        // Add a key listener to the title (a widget we know doesn't have a listener), to detect the '1'
        // key being pressed. We have to do this because the `onClickListener` doesn't fire if a number key is pressed
        // to activate the menu entry.
        title.setOnKeyListener((JavaScriptCallback) ev -> {
            if (ev.getTypedKeyChar() == '1') {
                setBackToBackState(ifYesState, true);
            }
        });
        title.setHasListener(true);

        // Capture player choice if they click 'Yes'.
        // We don't need to know if they click 'No' because we... don't care at all.
        option1.setOnClickListener((JavaScriptCallback) ev -> {
            setBackToBackState(ifYesState, true);
        });
    }

    /**
     * Handles a chat message indicating that the current Rumour has been completed.
     * <p>
     * Ignores any chat messages that are not relevant.
     */
    private void handleRumourFinishedChatMessage(ChatMessage event) {
        String message = event.getMessage();
        if (event.getType() != ChatMessageType.GAMEMESSAGE) {
            return;
        }

        // Ensure that this is the right chat message
        if (!Text.standardize(message).equalsIgnoreCase("You find a rare piece of the creature! You should take it back to the Hunter Guild.")) {
            return;
        }

        if (config.endOfRumourMessage()) {
            final int caughtCreatures = getCaughtRumourCreatures();
            final int pityThreshold = getCurrentRumour().getTrap().calculatePityRateForItems(hunterKitItems);
            final int percentage = 100 * caughtCreatures / pityThreshold;

            Color color;
            if (percentage >= 75) {
                color = config.endOfRumourMessageUnluckyColor();
            } else if (percentage >= 50) {
                color = config.endOfRumourMessageNormalColor();
            } else {
                color = config.endOfRumourMessageLuckyColor();
            }

            client.addChatMessage(ChatMessageType.GAMEMESSAGE,
                    "Hunter Rumours",
                    "Hunter Rumours: Rumour finished " +
                            ColorUtil.wrapWithColorTag(String.valueOf(percentage), color) +
                            "% of the way towards pity rate of " + pityThreshold,
                    "");
        }

        setHunterRumourState(true);
        refreshAllDisplays();
    }

    /**
     * Handles the chat message that occurs when the player clicks "Rumour" on their Quetzal Whistle.
     * <p>
     * Attempts to extract the current Rumour from the message.
     * <p>
     * Ignores any chat messages that are not relevant.
     */
    private void handleQuetzalWhistleChatMessage(ChatMessage event) {
        String message = event.getMessage();
        if (event.getType() != ChatMessageType.GAMEMESSAGE) {
            return;
        }

        // Ensure that this is the right chat message
        if (!message.contains("Your current rumour target is")) {
            return;
        }

        // Update last interaction time -- checking the whistle indicates a clear intent to participate
        // in Hunter Rumours.
        updateLatestInteractionTime();

        // Determine which Rumour the message is referencing -- if none, bail out.
        Rumour referencedRumour = chatParser.getReferencedRumour(message);
        if (referencedRumour == Rumour.NONE) {
            return;
        }

        // Determine which Hunter the message is referencing -- if none, bail out.
        Hunter referencedHunter = chatParser.getReferencedHunter(message);
        if (referencedHunter == Hunter.NONE) {
            return;
        }

        // If the Hunter or Rumour is different than what we thought it was, update state.
        if (referencedRumour != getCurrentRumour() || referencedHunter != currentHunter) {
            // TODO: too much manual state shit, abstract this away
            setHunterRumour(referencedHunter, referencedRumour);
            setCurrentHunter(referencedHunter);
            setHunterRumourState(false);
            setCaughtCreatures(0);
        }

        refreshAllDisplays();
    }


    /**
     * Handles the chat message from Guild Scribe Verity, in immediate response to the user clicking `Rumour-settings`
     * <p>
     * Attempts to extract the current Back-to-back state from the chat message.
     * <p>
     * Ignores any chat messages that are not relevant.
     */
    private void handleBackToBackChatMessage(ChatMessage event) {
        // If not in hunter master area, can't be for rumours
        if (!isInBurrows()) {
            return;
        }

        // If not NPC dialog, can't be for rumours
        if (event.getType() != ChatMessageType.DIALOG) {
            return;
        }

        // Filter for the specific message we're looking for
        if (!event.getMessage().startsWith("Guild Scribe Verity|Would you like me to filter the rumour information a")) {
            return;
        }

        // Update our back-to-back internal state with what we can glean from the message
        setBackToBackState(event.getMessage().contains("little less") ? BackToBackState.DISABLED : BackToBackState.ENABLED, false);
    }

    /**
     * Handles a chat message from a Hunter relating to Rumours.
     * <p>
     * Attempts to figure out the state of things (which Hunter we're assigned to; which Rumour they've assigned).
     * <p>
     * Ignores any chat messages that are not relevant.
     */
    private void handleBurrowsHunterDialog(ChatMessage event) {
        String dialogMessage = event.getMessage();

        // If not in hunter master area, can't be for rumours
        if (!isInBurrows()) {
            return;
        }

        // If not NPC dialog, can't be for rumours
        if (event.getType() != ChatMessageType.DIALOG) {
            return;
        }

        // Figure out which Hunter we're speaking to -- assuming we are
        Hunter hunter = chatParser.getSpeakingHunter(dialogMessage);
        if (hunter == Hunter.NONE) {
            return;
        }

        // The chat message comes in prefixed with the NPC name and "|" -- strip that out
        String npcNamePrefix = client.getNpcDefinition(hunter.getNpcId()).getName() + "|";
        String actualMessage = dialogMessage.replace(npcNamePrefix, "").toLowerCase(Locale.ROOT);

        // Determine if it's a "rumour complete" message
        if (actualMessage.contains("would you like another rumour?") ||
                actualMessage.contains("here's your reward.") ||
                actualMessage.contains("another one done?")) {
            setHunterRumour(currentHunter, Rumour.NONE);
            setHunterRumourState(false);
            setCaughtCreatures(0);
            refreshAllDisplays();
            return;
        }

        // During the introductory quest (At First Light), Guild Hunter Wolf has a line of dialogue which
        // tricks the plugin into thinking that he's assigning a standard rumour. But he isn't! Ignore it!
        if (actualMessage.contains("stopped off for a bit of hunting first")) {
            return;
        }

        // Determine what hunter and rumour are being talked about in this message
        Hunter dialogHunter = chatParser.getReferencedHunter(actualMessage);
        Rumour dialogRumour = chatParser.getReferencedRumour(actualMessage);

        boolean hasHunter = dialogHunter != Hunter.NONE;
        boolean hasRumour = dialogRumour != Rumour.NONE;
        boolean isNoviceReassignmentOffer = dialogMessage.toLowerCase().contains("would you prefer that one, or a new one entirely");

        // No hunter and no rumour means we ignore this dialog message
        if (!hasHunter && !hasRumour) {
            return;
        }

        // If no hunter is referenced in the dialog, then we assume the rumour is for the current speaker
        if (!hasHunter) {
            dialogHunter = hunter;
        }

        setHunterRumourState(false);
        setHunterRumour(dialogHunter, dialogRumour);

        // Set the current hunter to whoever we now know the current hunter to be.
        // This is either the hunter we're talking to (if the hunter mentioned a target but _not_ another hunter),
        // or a hunter being referenced (if the hunter mentioned both a target _and_ another hunter).
        // The one exception is if the novice hunter is offering a new reassignment offer, where he'll
        // also say a target but not another hunter (but that doesn't mean he's now the current hunter).
        if (!isNoviceReassignmentOffer) {
            setCurrentHunter(dialogHunter);
        }

        if (config.currentRumourMessage()) {
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Current rumour: " + ColorUtil.wrapWithColorTag(dialogRumour.getFullName(), Color.RED) + " | Current hunter: " + ColorUtil.wrapWithColorTag(currentHunter.getCommonName(), Color.RED), "");
        }

        refreshAllDisplays();
    }

    private RumourInfoBox infoBox = null;

    private void refreshAllDisplays() {
        npcOverlayService.rebuild();
        handleWorldMap();

        // Remove the infobox -- then re-enable it if necessary.
        removeInfoBox();
        handleInfoBox();
    }

    /**
     * Manages the InfoBox for the current Rumour -- adds/removes as necessary
     */
    private void handleInfoBox() {
        var isShowing = infoBox != null;
        var shouldShow = shouldInfoBoxBeShown();

        if (isShowing && !shouldShow) {
            removeInfoBox();
        } else if (shouldShow && !isShowing) {
            infoBox = new RumourInfoBox(getCurrentRumour(), this, itemManager, runeLiteConfig);
            infoBoxManager.addInfoBox(infoBox);
        }
    }

    private void removeInfoBox() {
        if (infoBox != null) {
            infoBoxManager.removeInfoBox(infoBox);
            infoBox = null;
        }
    }

    /**
     * Manages the World Map Locations -- adds/removes world map points as necessary
     */
    private void handleWorldMap() {
        for (HunterRumourWorldMapPoint location : currentMapPoints) {
            worldMapPointManager.remove(location);
        }

        currentMapPoints.clear();

        if (!shouldWorldMapLocationsBeShown()) {
            return;
        }

        var rumour = getCurrentRumour();
        if (rumour == Rumour.NONE) {
            return;
        }

        Set<RumourLocation> locations = config.compactWorldMap()
                ? RumourLocation.getCollapsedLocationsForRumour(rumour)
                : RumourLocation.getLocationsForRumour(rumour);

        for (RumourLocation location :
                locations) {
            HunterRumourWorldMapPoint worldMapPoint = new HunterRumourWorldMapPoint(location.getWorldPoint(), itemManager, location);
            currentMapPoints.add(worldMapPoint);
            worldMapPointManager.add(worldMapPoint);
        }
    }

    /**
     * Callback registered with npcOverlayService -- determines if an NPC should be highlighted, and if so, how.
     * <p>
     * Used to highlight Hunters and the current Hunter Target.
     */
    private HighlightedNpc highlighterFn(NPC npc) {
        Hunter hunter = Hunter.fromNpcId(npc.getId());

        // Highlight the current Hunter if relevant
        if (hunter != Hunter.NONE && isHunterEnabled(hunter)) {
            Rumour hunterRumour = hunterRumours.get(hunter);
            boolean isUnknown = hunterRumour == Rumour.NONE;
            boolean isKnown = !isUnknown;
            boolean isCurrent = hunter == currentHunter;

            Color highlightColor = Color.WHITE;
            if (isCurrent && config.highlightCurrentHunter()) {
                highlightColor = config.currentHunterHighlightColor();
            } else if (isKnown && config.highlightKnownHunters()) {
                highlightColor = config.knownHunterHighlightColor();
            } else if (isUnknown && config.highlightUnknownHunters()) {
                highlightColor = config.unknownHunterHighlightColor();
            } else {
                return null;
            }

            return HighlightedNpc
                    .builder()
                    .npc(npc)
                    .highlightColor(highlightColor)
                    .borderWidth(2)
                    .outline(true)
                    .build();
        }

        // Highlight Rumour Target (hunter creature) if relevant
        if (config.highlightHunterNPCs() != HunterRumoursConfig.HighlightType.NONE) {
            Rumour currentRumour = getCurrentRumour();
            if (currentRumour == Rumour.NONE
                    || currentRumour.getTargetCreature().getNpcId() == 0
                    || currentRumourFinished
                    || npc.getId() != currentRumour.getTargetCreature().getNpcId()
            ) {
                return null;
            }

            HighlightedNpc.HighlightedNpcBuilder highlightedNpcBuilder = HighlightedNpc.builder()
                    .npc(npc)
                    .highlightColor(config.hunterNPCHighlightColor())
                    .borderWidth(2);

            switch (config.highlightHunterNPCs()) {
                case TILE:
                    highlightedNpcBuilder.tile(true);
                    break;
                case OUTLINE:
                    highlightedNpcBuilder.outline(true);
                    break;
                case BOTH:
                    highlightedNpcBuilder.tile(true);
                    highlightedNpcBuilder.outline(true);
            }

            return highlightedNpcBuilder.build();
        }

        return null;
    }

    /**
     * Loads all state (current hunter, rumours, etc.) from config
     */
    private void loadFromConfig() {
        // Fetch current hunter XP
        int hunterExperience = client.getSkillExperience(Skill.HUNTER);
        if (hunterExperience > 0) {
            previousHunterExp = hunterExperience;
        }

        // Load current hunter
        Hunter loadedCurrentHunter = configManager.getRSProfileConfiguration("hunterrumours", "current.hunter", Hunter.class);
        if (loadedCurrentHunter == null) {
            loadedCurrentHunter = Hunter.NONE;
        }

        this.currentHunter = loadedCurrentHunter;

        // Load all hunter rumours
        for (var hunter : Hunter.allValues()) {
            Rumour rumour = configManager.getRSProfileConfiguration("hunterrumours", "hunter." + hunter.getNpcId(), Rumour.class);
            if (rumour == null) {
                rumour = Rumour.NONE;
            }

            hunterRumours.put(hunter, rumour);
        }

        // Load has finished current rumour
        try {
            currentRumourFinished = configManager.getRSProfileConfiguration(HunterRumoursConfig.GROUP, "current.rumour.finished", boolean.class);
        } catch (NullPointerException ex) {
            currentRumourFinished = false;
        }

        // Load back-to-back state
        BackToBackState loadedState = configManager.getRSProfileConfiguration(HunterRumoursConfig.GROUP, "backtoback", BackToBackState.class);
        if (loadedState == null) {
            loadedState = BackToBackState.UNKNOWN;
        }
        this.backToBackState = loadedState;

        refreshAllDisplays();
    }

    /**
     * Records the current tick as the "latest interaction time" -- used to track how long it's been since the player has engaged in Hunter Rumour-related behavior
     */
    private void updateLatestInteractionTime() {
        latestInteractionTime = client.getTickCount();
    }

    /**
     * Computes whether the player has interacted with Hunter Rumours in the last N ticks
     */
    private boolean interactedRecently(int tickThreshold) {
        return latestInteractionTime != -1 && (client.getTickCount() - latestInteractionTime <= tickThreshold);
    }

    /**
     * Checks the configurations of the info box, returns true if the info box should be disabled.
     */
    private boolean shouldInfoBoxBeShown() {
        // If infobox isn't enabled, it obviously should not be shown
        if (!config.showInfoBox()) {
            return false;
        }

        // If we have no active rumour, don't show the info box.
        var rumour = getCurrentRumour();
        if (rumour == Rumour.NONE) {
            return false;
        }

        // If "force info box" is enabled, then the infobox should always be shown (if infobox itself is enabled)
        if (config.forceShowInfoBox()) {
            return true;
        }

        // Infobox should be disabled if it's been long enough since the last interaction time
        return interactedRecently(config.infoBoxDisableTimer() * 100);
    }

    /**
     * Checks the configurations of the world map locations, returns true if the world map locations should be enabled.
     */
    private boolean shouldWorldMapLocationsBeShown() {
        // If world map locations aren't enabled, obviously they should not be enabled!
        if (!config.showWorldMapLocations()) {
            return false;
        }

        // If "force show world map locations" is enabled, then we should never disable world map locations.
        if (config.forceShowWorldMapLocations()) {
            return true;
        }

        // World map locations should be disabled if it's been long enough since the last interaction time
        return interactedRecently(config.worldMapLocationsDisableTimer() * 100);
    }

    /**
     * Checks the configurations for auto-scrolling the fairy ring interface, returns true if the fairy ring interface should auto-scroll.
     */
    private boolean shouldFairyRingAutoJump() {
        // If auto jump isn't enabled, obviously it should not be enabled!
        if (!config.autoJumpFairyring()) {
            return false;
        }

        // If "force auto-scroll to fairy ring" is enabled, then we should never disable auto-scroll.
        if (config.forceAutoJumpFairyRing()) {
            return true;
        }

        // Fairy ring auto-scroll should be disabled if it's been long enough since the last interaction time
        return interactedRecently(config.autoJumpFairyRingDisableTimer() * 100);
    }

    /**
     * Wipes plugin config and in-memory game state
     */
    private void resetConfig() {
        configManager.unsetRSProfileConfiguration(HunterRumoursConfig.GROUP, "current.hunter");
        configManager.unsetRSProfileConfiguration(HunterRumoursConfig.GROUP, "current.rumour.finished");
        configManager.unsetRSProfileConfiguration(HunterRumoursConfig.GROUP, "backtoback");
        configManager.unsetRSProfileConfiguration(HunterRumoursConfig.GROUP, "current.rumour.caught");

        for (var hunter : Hunter.allValues()) {
            configManager.unsetRSProfileConfiguration("hunterrumours", "hunter." + hunter.getNpcId());
        }

        resetParams();

        // Reset overlay
        refreshAllDisplays();
    }

    /**
     * Resets internal game state. Doesn't touch persistent config.
     */
    private void resetParams() {
        for (var hunter : hunterRumours.keySet()) {
            hunterRumours.replace(hunter, Rumour.NONE);
        }

        currentHunter = Hunter.NONE;
        backToBackState = BackToBackState.UNKNOWN;
        hunterKitItems = 0;

        refreshAllDisplays();
    }
}

package com.geel.hunterrumours;


import com.geel.hunterrumours.enums.RumourLocation;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.image.BufferedImage;

class HunterRumourWorldMapPoint extends WorldMapPoint {
    private static BufferedImage mapArrow;

    private final BufferedImage hunterRumourWorldImage;
    private final Point hunterRumourWorldImagePoint;

    HunterRumourWorldMapPoint(final WorldPoint worldPoint, ItemManager manager, RumourLocation location) {
        super(worldPoint, null);

        // Prepare the image we're going to draw on the map
        hunterRumourWorldImage = new BufferedImage(getMapArrow().getWidth(), getMapArrow().getHeight(), BufferedImage.TYPE_INT_ARGB);
        Graphics graphics = hunterRumourWorldImage.getGraphics();
        graphics.drawImage(getMapArrow(), 0, 0, null);
        graphics.drawImage(manager.getImage(location.getRumour().getTargetCreature().getItemId()), 0, 0, null);

        // Center image horizontally over world point
        hunterRumourWorldImagePoint = new Point(
                hunterRumourWorldImage.getWidth() / 2,
                hunterRumourWorldImage.getHeight());

        this.setSnapToEdge(true);
        this.setJumpOnClick(true);
        if (location.getFairyRingCode().equals("")) {
            this.setName(location.getRumour().getName() + " (" + location.getLocationName() + ")");
        } else {
            this.setName(location.getRumour().getName() + " (" + location.getLocationName() + ", " + location.getFairyRingCode() + ")");
        }
        this.setImage(hunterRumourWorldImage);
        this.setImagePoint(hunterRumourWorldImagePoint);
    }

    @Override
    public void onEdgeSnap() {
        this.setImage(hunterRumourWorldImage);
        this.setImagePoint(null);
    }

    @Override
    public void onEdgeUnsnap() {
        this.setImage(hunterRumourWorldImage);
        this.setImagePoint(hunterRumourWorldImagePoint);
    }

    private static BufferedImage getMapArrow() {
        if (mapArrow == null) {
            mapArrow = ImageUtil.loadImageResource(HunterRumoursPlugin.class, "/util/hunter_rumour_arrow.png");
        }

        return mapArrow;
    }
}

package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.Rumour;
import com.geel.hunterrumours.enums.RumourLocation;
import com.geel.hunterrumours.enums.Trap;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.util.ColorUtil;

import javax.annotation.Nonnull;
import java.awt.*;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

public class RumourInfoBox extends InfoBox {
    private final HunterRumoursPlugin plugin;

    public RumourInfoBox(
            Rumour rumour,
            @Nonnull HunterRumoursPlugin plugin,
            @Nonnull ItemManager itemManager,
            @Nonnull RuneLiteConfig runeLiteConfig
    ) {
        super(itemManager.getImage(rumour.getTargetCreature().getItemId()), plugin);
        this.plugin = plugin;

        // MacOS (and perhaps other platforms) cannot display the bullet point character we use.
        final char bulletPointCharacter;
        if (runeLiteConfig.tooltipFontType().getFont().canDisplay('')) {
            bulletPointCharacter = '';
        } else {
            bulletPointCharacter = '-';
        }

        final var locations = RumourLocation.getGroupedLocationsForRumour(rumour);
        final StringBuilder locationsStringBuilder = new StringBuilder();

        locations.forEach(entry -> {
            RumourLocation rumourLocation = entry.getValue().get(0);

            locationsStringBuilder.append("</br>  ").append(bulletPointCharacter).append(' ').append(entry.getKey()).append(" (");
            if (!rumourLocation.getFairyRingCode().equals("")) {
                locationsStringBuilder.append(rumourLocation.getFairyRingCode()).append(", ");
            }
            locationsStringBuilder.append(entry.getValue().size()).append(" spawns)");
        });

        final Trap trap = rumour.getTargetCreature().getTrap();
        final int pityThreshold = trap.calculatePityRateForItems(plugin.getHunterKitItems());
        String hasFinishedRumourText = plugin.getHunterRumourState() ? "Yes" : "No";

        this.setTooltip(
                ColorUtil.wrapWithColorTag("Rumour: ", Color.YELLOW) + rumour.getFullName() + "</br>" +
                        ColorUtil.wrapWithColorTag("Finished: ", Color.YELLOW) + hasFinishedRumourText + "</br>" +
                        ColorUtil.wrapWithColorTag("Item: ", Color.YELLOW) + itemManager.getItemComposition(rumour.getRumourItemID()).getName() + "</br>" +
                        ColorUtil.wrapWithColorTag("Caught: ", Color.YELLOW) + plugin.getCaughtRumourCreatures() + " / " + pityThreshold + "</br>" +
                        ColorUtil.wrapWithColorTag("Locations:", Color.YELLOW) + locationsStringBuilder
        );
    }

    @Override
    public String getText() {
        if (plugin.getHunterRumourState()) {
            return "Done";
        }

        final Rumour currentRumour = plugin.getCurrentRumour();
        if (currentRumour != Rumour.NONE && showNumUntilPity()) {
            final int pityThreshold = currentRumour.getTrap().calculatePityRateForItems(plugin.getHunterKitItems());
            return String.valueOf(pityThreshold - plugin.getCaughtRumourCreatures());
        }

        return "";
    }

    @Override
    public Color getTextColor() {
        HunterRumoursConfig config = plugin.getConfig();
        if (plugin.getHunterRumourState()) {
            return config.completedRumourInfoBoxTextColor();
        } else if (!showNumUntilPity()) {
            return config.defaultInfoBoxTextColor();
        } else {
            final Rumour currentRumour = plugin.getCurrentRumour();
            if (currentRumour == Rumour.NONE) {
                return config.defaultInfoBoxTextColor();
            }
            final int caughtCreatures = plugin.getCaughtRumourCreatures();
            final int pityThreshold = currentRumour.getTrap().calculatePityRateForItems(plugin.getHunterKitItems());
            final float percentage = (float) caughtCreatures / pityThreshold * 100f;
            if (percentage >= 75) {
                return config.unluckyRateInfoBoxTextColor();
            } else if (percentage >= 50) {
                return config.normalRateInfoBoxTextColor();
            } else {
                return config.luckyRateInfoBoxTextColor();
            }
        }
    }

    private boolean showNumUntilPity() {
        if (this.plugin == null || this.plugin.getConfig() == null) {
            return false;
        }

        return this.plugin.getConfig().showCatchesRemainingUntilPity();
    }
}
package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.BackToBackState;

import static org.junit.Assert.fail;

import org.junit.Test;

public class BackToBackStateTest {
    @Test
    public void backToBackStateTests() {
        for (BackToBackState state : BackToBackState.values()) {
            if (state.getNiceName() == null || state.getNiceName().isBlank()) {
                fail("Invalid name set for back-to-back state: " + state.name());
            }
        }
    }
}

package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.Hunter;
import com.geel.hunterrumours.enums.Rumour;
import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import net.runelite.api.Client;
import net.runelite.api.NPCComposition;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import javax.inject.Inject;

import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ChatParserTest {
    @Mock
    @Bind
    private Client client;

    @Inject
    private ChatParser chatParser;

    private static String wolfHunterName = "Guild Hunter Wolf (Master)";

    @Before
    public void setUp() {
        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);

        for (Hunter hunter : Hunter.values()) {
            NPCComposition mockHunter = mock(NPCComposition.class);
            // We're using common name as a placeholder since we'll always get the 'real' name anyways
            when(mockHunter.getName()).thenReturn(hunter.getCommonName());
            when(client.getNpcDefinition(hunter.getNpcId())).thenReturn(mockHunter);
        }
    }

    @Test
    public void chatParserTests() {
        if (chatParser.getSpeakingHunter(Hunter.MASTER_WOLF.getCommonName() + "| im testing") != Hunter.MASTER_WOLF) {
            fail("You messed up the getSpeakingHunter method of ChatParser");
        }

        if (chatParser.getReferencedRumour("your next assignment is embertailed jerboa") != Rumour.EMBERTAILED_JERBOA) {
            fail("You messed up the getReferencedRumour method of ChatParser");
        }

        if (chatParser.getReferencedHunter("Your hunter is " + Hunter.MASTER_WOLF.getCommonName() + " testing") != Hunter.MASTER_WOLF) {
            fail("You messed up the getReferencedHunter method of ChatParser");
        }
    }
}

package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.Creature;

import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.fail;

import org.junit.Test;

public class CreatureTest {
    @Test
    public void creatureTests() {
        for (Creature creature : Creature.values()) {
            if (creature == Creature.NONE) {
                continue;
            }

            if (creature.getHunterLevel() <= 0) {
                fail("Invalid hunter level of " + creature.getHunterLevel() + " for creature: " + creature.name());
            }

            if (creature.getItemId() <= 0) {
                fail("Invalid Item id of " + creature.getItemId() + " for creature: " + creature.name());
            }

            if (creature.getTrap() == null) {
                fail("You must select a trap for creature: " + creature.name());
            }

            if (creature.getPossibleXpDrops() == null || creature.getPossibleXpDrops().length == 0) {
                fail("You must have at least one possible xp drop for creature: " + creature.name());
            }

            List<Integer> possibleXpDrops = new ArrayList<>();
            for (int xpDrop : creature.getPossibleXpDrops()) {
                if (possibleXpDrops.contains(xpDrop)) {
                    fail("Duplicate possible xp drop of " + xpDrop + " for creature: " + creature.name());
                }
                if (xpDrop <= 0) {
                    fail("Invalid possible xp drop of " + xpDrop + " for creature: " + creature.name());
                }
                possibleXpDrops.add(xpDrop);
            }

            if (creature.getNpcId() <= 0 && creature != Creature.RAZOR_BACKED_KEBBIT) {
                fail("Invalid NPC id of " + creature.getNpcId() + " for creature: " + creature.name());
            }
        }
    }
}

package com.geel.hunterrumours;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class HunterRumoursPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(HunterRumoursPlugin.class);
        RuneLite.main(args);
    }
}
package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.Rumour;
import org.junit.Test;

import static org.junit.Assert.fail;

public class HunterRumoursTest {
    @Test
    public void hunterRumoursTests() {
        for (final Rumour rumour : Rumour.values()) {
            if (rumour == Rumour.NONE) {
                continue;
            }

            // Should have a name
            if (rumour.getName().equals("")) {
                fail("Rumour has a missing name.");

            }

            // Should have an item id
            // TODO: Refactor into `Creature`-specific tests
            if (rumour.getTargetCreature().getItemId() <= 0) {
                fail("Rumour (" + rumour.getName() + ")" + " has invalid item id: " + rumour.getTargetCreature().getItemId());
            }

            // Should have a hunter level of at least 1
            if (rumour.getTargetCreature().getHunterLevel() <= 0) {
                fail("Rumour (" + rumour.getName() + ")" + " has invalid hunter level: " + rumour.getTargetCreature().getHunterLevel());
            }

            // Should have at least one possible xp drop
            if (rumour.getTargetCreature().getPossibleXpDrops().length == 0) {
                fail("Rumour (" + rumour.getName() + ")" + " has no possible xp drops");
            }

            // Should be at least one of these
            if (!rumour.isAdept() && !rumour.isExpert() && !rumour.isMaster() && !rumour.isNovice()) {
                fail("Rumour (" + rumour.getName() + ")" + " should be adept, novice, master or expert, cannot select none");
            }

            // Cannot have a null (unset) trap
            if (rumour.getTrap() == null) {
                fail("Rumour (" + rumour.getName() + ")" + " has no trap selected");
            }
        }
    }
}

package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.Hunter;

import com.geel.hunterrumours.enums.HunterTier;

import static org.junit.Assert.fail;

import org.junit.Test;

public class HunterTest {
    @Test
    public void hunterTests() {
        for (Hunter hunter : Hunter.values()) {
            if (hunter == Hunter.NONE) {
                continue;
            }

            if (hunter.getNpcId() <= 0) {
                fail("Invalid NPC id of " + hunter.getNpcId() + " for hunter: " + hunter.name());
            }

            if (hunter.getTier() == null || hunter.getTier() == HunterTier.NONE) {
                fail("Invalid hunter tier of " + hunter.getTier() + " for hunter: " + hunter.name());
            }

            if (hunter.getCommonName() == null || hunter.getCommonName().isBlank()) {
                fail("You must set a name for hunter: " + hunter.name());
            }
        }
    }
}

package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.Rumour;
import com.geel.hunterrumours.enums.RumourLocation;

import static org.junit.Assert.fail;

import org.junit.Test;

public class RumourLocationTest {

    @Test
    public void rumourLocationTests() {
        for (RumourLocation location : RumourLocation.values()) {
            if (location.getLocationName() == null || location.getLocationName().isBlank()) {
                fail("Invalid location name for rumour location: " + location.name());
            }

            if (location.getRumour() == null || location.getRumour() == Rumour.NONE) {
                fail("You must set a rumour for rumour location: " + location.name());
            }

            if (location.getFairyRingCode() == null) {
                fail("Invalid fairy ring code for rumour location: " + location.name());
            }

            if (location.getWorldPoint() == null) {
                fail("You must set a world point for rumour location: " + location.name());
            }
        }
    }
}

package com.geel.hunterrumours;

import com.geel.hunterrumours.enums.Trap;
import org.junit.Test;

import static org.junit.Assert.fail;

public class TrapTest {
    @Test
    public void trapTests() {
        for (final Trap trap : Trap.values()) {
            // Check if trap has a name
            if (trap.getName().equals("")) {
                fail("Trap should have a name");
            }

            // Check if trap has an item id
            if (trap.getItemId() <= 0) {
                fail("Trap (" + trap.getName() + ") should have an item id set (>0)");
            }

            // Pity threshold should be > 0
            if (trap.getPityThreshold() <= 0) {
                fail("Trap (" + trap.getName() + ") should have a pity threshold > 0");
            }

            if (trap.getPityThresholdWithOutfit() <= 0) {
                fail("Trap (" + trap.getName() + ") should have a pity threshold (with outfit) > 0");
            }

            if (trap.getPityThresholdWithOutfit() >= trap.getPityThreshold()) {
                fail("Trap (" + trap.getName() + ") should have a pity threshold (with outfit) < pity threshold (without outfit)");
            }
        }
    }
}

