package com.resourcetracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("resourcetracker")
public interface ResourceTrackerConfig extends Config
{
	@ConfigSection(
		name = "Containers",
		description = "Configure which containers to track",
		position = 0
	)
	String containersSection = "containers";

	@ConfigItem(
		keyName = "trackBank",
		name = "Track Bank",
		description = "Track items in the bank",
		section = containersSection
	)
	default boolean trackBank()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackInventory",
		name = "Track Inventory",
		description = "Track items in the inventory",
		section = containersSection
	)
	default boolean trackInventory()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackSeedVault",
		name = "Track Seed Vault",
		description = "Track items in the Seed Vault",
		section = containersSection
	)
	default boolean trackSeedVault()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackRetrievalService",
		name = "Track Retrieval Service",
		description = "Track items in your Retrieval Service / Gravestone",
		section = containersSection
	)
	default boolean trackRetrievalService()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackGroupStorage",
		name = "Track Group Storage",
		description = "Track items in Group Storage",
		section = containersSection
	)
	default boolean trackGroupStorage()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackLootingBag",
		name = "Track Looting Bag",
		description = "Track items in your Looting Bag",
		section = containersSection
	)
	default boolean trackLootingBag()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackBoatInventory",
		name = "Track Boat Inventory",
		description = "Track items in your Sailing boats",
		section = containersSection
	)
	default boolean trackBoatInventory()
	{
		return true;
	}

	@ConfigItem(
		keyName = "trackPotionStorage",
		name = "Track Potion Storage",
		description = "Track potions in your Potion Storage",
		section = containersSection
	)
	default boolean trackPotionStorage()
	{
		return true;
	}
    @ConfigItem(
            keyName = "trackPOHStorage",
            name = "Track POH Storage",
            description = "Track items in the Player Owned House storage room",
            section = containersSection
    )
    default boolean trackPOHStorage()
    {
        return true;
    }

	@ConfigSection(
		name = "Display",
		description = "Configure display options",
		position = 1
	)
	String displaySection = "display";

	@ConfigItem(
		keyName = "showCategoryTotals",
		name = "Show Category Totals",
		description = "Show total current/goal amounts in category headers",
		section = displaySection
	)
	default boolean showCategoryTotals()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showCategoryProgress",
		name = "Show Category Progress",
		description = "Show progress bar in category headers",
		section = displaySection
	)
	default boolean showCategoryProgress()
	{
		return true;
	}
}

package com.resourcetracker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.SwingUtil;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.DocumentFilter;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.ActionEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
public class ResourceTrackerPanel extends PluginPanel implements Scrollable
{
    private static class ItemDefinition
    {
        private final int id;
        private final String name;

        ItemDefinition(int id, String name)
        {
            this.id = id;
            this.name = name;
        }

        public int getId()
        {
            return id;
        }

        public String getName()
        {
            return name;
        }
    }
    // handles amount input like "100k", "2M"
    static class QuantityDocumentFilter extends DocumentFilter {
        private final Pattern pattern = Pattern.compile("\\d*[kKmMbB]?");

        private boolean test(String text) {
            return pattern.matcher(text).matches();
        }

        @Override
        public void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException {
            Document doc = fb.getDocument();
            StringBuilder sb = new StringBuilder();
            sb.append(doc.getText(0, doc.getLength()));
            sb.insert(offset, string);

            if (test(sb.toString())) {
                super.insertString(fb, offset, string, attr);
            }
        }

        @Override
        public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException {
            Document doc = fb.getDocument();
            StringBuilder sb = new StringBuilder();
            sb.append(doc.getText(0, doc.getLength()));
            sb.replace(offset, offset + length, text);

            if (test(sb.toString())) {
                super.replace(fb, offset, length, text, attrs);
            }
        }
    }

    private final ResourceTrackerPlugin plugin;
    private final ItemManager itemManager;
    private final ChatboxPanelManager chatboxPanelManager;

    private final JPanel itemListPanel;
    private final JPanel searchResultsPanel;
    private final JPanel contentWrapper;
    private final JScrollPane searchScrollPane;
    private final JScrollPane itemScrollPane;
    private final IconTextField searchBar;
    private final JTextField categoryNameField;
    private final List<TrackedItem> trackedItems = new CopyOnWriteArrayList<>();
    private final List<CategoryBox> categoryBoxes = new ArrayList<>();
    private String selectedCategory = null;
    private static final int MAX_SEARCH_RESULTS = 50;
    private Timer searchDebounceTimer;


    public ResourceTrackerPanel(ResourceTrackerPlugin plugin, ItemManager itemManager, ChatboxPanelManager chatboxPanelManager)
    {
        super(false);
        this.plugin = plugin;
        this.itemManager = itemManager;
        this.chatboxPanelManager = chatboxPanelManager;

        setBorder(new EmptyBorder(6, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Search area - always visible at top
        JPanel searchAreaPanel = new JPanel();
        searchAreaPanel.setLayout(new BoxLayout(searchAreaPanel, BoxLayout.Y_AXIS));
        searchAreaPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        searchAreaPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR.darker()),
                new EmptyBorder(5, 5, 5, 5)
        ));
        add(searchAreaPanel, BorderLayout.NORTH);

        // Category name input field
        categoryNameField = new JTextField();
        categoryNameField.setPreferredSize(new Dimension(0, 30));
        categoryNameField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        categoryNameField.setForeground(Color.GRAY);
        categoryNameField.setText("Add category...");
        categoryNameField.setCaretColor(Color.WHITE);

        ((AbstractDocument) categoryNameField.getDocument()).setDocumentFilter(new DocumentFilter() {
            private static final int MAX_LENGTH = 30;

            @Override
            public void insertString(FilterBypass fb, int offset, String string, AttributeSet attr) throws BadLocationException {
                if ((fb.getDocument().getLength() + string.length()) <= MAX_LENGTH) {
                    super.insertString(fb, offset, string, attr);
                }
            }

            @Override
            public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException {
                if ((fb.getDocument().getLength() + (text != null ? text.length() : 0) - length) <= MAX_LENGTH) {
                    super.replace(fb, offset, length, text, attrs);
                }
            }
        });

        categoryNameField.addFocusListener(new java.awt.event.FocusAdapter()
        {
            @Override
            public void focusGained(java.awt.event.FocusEvent e)
            {
                if (categoryNameField.getText().equals("Add category..."))
                {
                    categoryNameField.setText("");
                    categoryNameField.setForeground(Color.WHITE);
                }
            }

            @Override
            public void focusLost(java.awt.event.FocusEvent e)
            {
                if (categoryNameField.getText().isEmpty())
                {
                    categoryNameField.setText("Add category...");
                    categoryNameField.setForeground(Color.GRAY);
                }
            }
        });
        categoryNameField.addActionListener(e ->
        {
            String categoryName = categoryNameField.getText().trim();
            if (!categoryName.isEmpty() && !categoryName.equals("Add category..."))
            {
                createNewCategory(categoryName);
                categoryNameField.setText("Add category...");
                categoryNameField.setForeground(Color.GRAY);
            }
        });

        searchAreaPanel.add(categoryNameField);

        // Search bar
        searchBar = new IconTextField();
        searchBar.setIcon(IconTextField.Icon.SEARCH);
        searchBar.setPreferredSize(new Dimension(0, 30));
        searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        searchBar.setEnabled(false); // Disabled by default - only enabled when a category is selected
        searchBar.setEditable(false); // Prevent typing when disabled
        searchBar.setToolTipText("Select a category to add items");
        searchBar.getDocument().addDocumentListener(new DocumentListener()
        {
            @Override
            public void insertUpdate(DocumentEvent e)
            {
                scheduleSearch();
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                scheduleSearch();
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                scheduleSearch();
            }
        });
        searchBar.addClearListener(this::onSearchChanged);

        // Add key listener for Esc key
        searchBar.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
                {
                    searchBar.setText("");
                    onSearchChanged();
                }
            }
        });

        searchAreaPanel.add(Box.createRigidArea(new Dimension(0, 5)));
        searchAreaPanel.add(searchBar);


        // Wrapper panel for content (search results OR tracked items)
        contentWrapper = new JPanel(new BorderLayout());
        contentWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
        add(contentWrapper, BorderLayout.CENTER);

        // Search results panel - shown when searching
        searchResultsPanel = new JPanel();
        searchResultsPanel.setLayout(new BoxLayout(searchResultsPanel, BoxLayout.Y_AXIS));
        searchResultsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        searchScrollPane = new JScrollPane(searchResultsPanel);
        searchScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        searchScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        searchScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        searchScrollPane.setBorder(null);

        // Tracked items panel
        itemListPanel = new JPanel();
        itemListPanel.setLayout(new BoxLayout(itemListPanel, BoxLayout.Y_AXIS));
        itemListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel itemPanelWrapper = new JPanel(new BorderLayout());
        itemPanelWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
        itemPanelWrapper.add(itemListPanel, BorderLayout.NORTH);


        itemScrollPane = new JScrollPane(itemPanelWrapper);
        itemScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        itemScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        itemScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        itemScrollPane.setBorder(null);


        contentWrapper.add(itemScrollPane, BorderLayout.CENTER);

        // Add keybinding for focusing the search bar
        KeyStroke ctrlF = KeyStroke.getKeyStroke(KeyEvent.VK_F, Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx());
        getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(ctrlF, "focusSearch");
        getActionMap().put("focusSearch", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                searchBar.requestFocusInWindow();
            }
        });
    }

    @Override
    public Dimension getPreferredScrollableViewportSize()
    {
        return getPreferredSize();
    }

    @Override
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction)
    {
        return 16;
    }

    @Override
    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction)
    {
        return 16;
    }

    @Override
    public boolean getScrollableTracksViewportWidth()
    {
        return true;
    }

    @Override
    public boolean getScrollableTracksViewportHeight()
    {
        return false;
    }

    public void addTrackedItem(TrackedItem item)
    {
        plugin.addTrackedItem(item);
    }

    public void removeTrackedItem(int itemId, String category)
    {
        plugin.removeTrackedItem(itemId, category);
    }


    public List<TrackedItem> getTrackedItems()
    {
        return new ArrayList<>(plugin.getTrackedItems().values());
    }

    public void loadItems(java.util.Collection<TrackedItem> items)
    {
        trackedItems.clear();
        trackedItems.addAll(items);
        rebuildTrackedItems();
    }

    public void resetPanel()
    {
        SwingUtilities.invokeLater(() -> {
            trackedItems.clear();
            selectedCategory = null;
            searchBar.setEnabled(false); // No category selected, so disable search
            searchBar.setEditable(false); // Prevent typing when disabled
            searchBar.setToolTipText("Select a category to add items");

            categoryNameField.setText("Add category...");
            categoryNameField.setForeground(Color.GRAY);

            rebuildTrackedItems();
        });
    }

    public void rebuild()
    {
        loadItems(plugin.getTrackedItems().values());
    }

    public void setSelectedCategory(String category)
    {
        // Mark the selected category (for adding items), don't collapse others
        selectedCategory = category;

        if (category == null)
        {
            // Deselect all
            searchBar.setEnabled(false);
            searchBar.setEditable(false); // Prevent typing when disabled
            searchBar.setText(""); // Clear search text when deselecting
            searchBar.setToolTipText("Select a category to add items");

            for (CategoryBox box : categoryBoxes)
            {
                box.setSelected(false);
            }

            // Show tracked items view (not search results)
            contentWrapper.removeAll();
            contentWrapper.add(itemScrollPane, BorderLayout.CENTER);
            contentWrapper.revalidate();
            contentWrapper.repaint();
        }
        else
        {
            // Select specific category
            searchBar.setEnabled(true);
            searchBar.setEditable(true); // Allow typing when enabled
            searchBar.setToolTipText("Search items to add to " + category);

            // Update visual selection state for all categories
            for (CategoryBox box : categoryBoxes)
            {
                box.setSelected(box.getCategoryName().equals(category));
            }
        }
    }

    public void deleteCategory(String categoryName)
    {
        // Get items from plugin and remove those in this category
        List<TrackedItem> itemsToRemove = plugin.getTrackedItems().values().stream()
                .filter(item -> item.getCategory().equals(categoryName))
                .collect(Collectors.toList());

        itemsToRemove.forEach(item -> plugin.removeTrackedItem(item.getItemId(), item.getCategory()));

        // Remove from category order
        plugin.removeCategory(categoryName);

        // Clear selected category if it's the one being deleted
        if (categoryName.equals(selectedCategory))
        {
            selectedCategory = null;
            searchBar.setEnabled(false); // No category selected after deletion
            searchBar.setEditable(false); // Prevent typing when disabled
            searchBar.setToolTipText("Select a category to add items");
        }

		rebuildTrackedItems();
	}

	public void resetCategoryCounts(String categoryName)
	{
		// Get all items in this category and reset their counts
		plugin.getTrackedItems().values().stream()
			.filter(item -> item.getCategory().equals(categoryName))
			.forEach(item -> {
				// Reset current amount to 0
				item.setCurrentAmount(0);
				// Clear all container quantities
				item.getContainerQuantities().clear();
			});

		// Save the changes
		plugin.saveData();

		// Rebuild UI to show the reset counts
		rebuildTrackedItems();

		plugin.sendChatMessage("All item counts reset for category '" + categoryName + "'.");
	}

	public void renameCategory(String oldName, String newName)
	{
        // Validate new name
        if (newName == null || newName.trim().isEmpty())
        {
            plugin.sendChatMessage("Category name cannot be empty.");
            return;
        }

        String trimmedNewName = newName.trim();

        // Check if a category with the new name already exists
        boolean exists = plugin.getTrackedItems().values().stream()
                .anyMatch(item -> item.getCategory().equalsIgnoreCase(trimmedNewName) && !item.getCategory().equals(oldName));

        if (exists)
        {
            plugin.sendChatMessage("A category with that name already exists.");
            return;
        }

        // Update all items in the category to use the new name
        plugin.getTrackedItems().values().stream()
                .filter(item -> item.getCategory().equals(oldName))
                .forEach(item -> item.setCategory(trimmedNewName));

        // Update the category order tracking
        plugin.renameCategory(oldName, trimmedNewName);

        // Update selected category if it was the renamed one
        if (oldName.equals(selectedCategory))
        {
            selectedCategory = trimmedNewName;
            searchBar.setToolTipText("Search items to add to " + trimmedNewName);
        }

        rebuildTrackedItems();
        plugin.sendChatMessage("Category renamed to '" + trimmedNewName + "'.");
    }

    public void exportCategory(String categoryName)
    {
        List<TrackedItem> categoryItems = plugin.getTrackedItems().values().stream()
                .filter(item -> item.getCategory().equals(categoryName))
                .collect(Collectors.toList());

        if (categoryItems.isEmpty())
        {
            return;
        }

        // Create a new list of items with amounts reset to 0 for export
        List<TrackedItem> itemsForExport = new ArrayList<>();
        for (TrackedItem originalItem : categoryItems)
        {
            TrackedItem exportItem = new TrackedItem(
                originalItem.getItemId(),
                originalItem.getItemName(),
                originalItem.getGoalAmount(),
                originalItem.getCategory()
            );
            // The constructor already sets currentAmount to 0, but this is explicit
            exportItem.setCurrentAmount(0);
            itemsForExport.add(exportItem);
        }

        String json = plugin.getGson().toJson(itemsForExport);
        final StringSelection stringSelection = new StringSelection(json);
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(stringSelection, null);
    }

    public void importCategoryFromClipboard(String targetCategory)
    {
        final String clipboardText;
        try
        {
            clipboardText = Toolkit.getDefaultToolkit()
                .getSystemClipboard()
                .getData(DataFlavor.stringFlavor)
                .toString();
        }
        catch (IOException | UnsupportedFlavorException ex)
        {
            log.warn("Error reading clipboard", ex);
            plugin.sendChatMessage("Unable to read system clipboard.");
            return;
        }

        if (clipboardText == null || clipboardText.isEmpty())
        {
            plugin.sendChatMessage("You do not have any items copied in your clipboard.");
            return;
        }

        List<TrackedItem> importItems;
        try
        {
            java.lang.reflect.Type listType = new com.google.gson.reflect.TypeToken<ArrayList<TrackedItem>>(){}.getType();
            importItems = plugin.getGson().fromJson(clipboardText, listType);
        }
        catch (com.google.gson.JsonSyntaxException | IllegalStateException e)
        {
            plugin.sendChatMessage("You do not have any valid categories copied in your clipboard.");
            return;
        }

        if (importItems == null || importItems.isEmpty())
        {
            plugin.sendChatMessage("You do not have any valid categories copied in your clipboard.");
            return;
        }

        plugin.getClientUi().requestFocus();

        chatboxPanelManager.openTextMenuInput("Are you sure you want to import " + importItems.size() + " items into '" + targetCategory + "'?")
                .option("Yes", () ->
                {
                    importCategory(importItems, targetCategory);
                    plugin.sendChatMessage(importItems.size() + " items were imported to " + targetCategory + ".");
                })
                .option("No", () -> {})
                .build();
    }

    public void importCategory(List<TrackedItem> importedItems, String targetCategory)
    {
        // Update category and add to list
        for (TrackedItem importedItem : importedItems)
        {
            if (importedItem != null && importedItem.getItemId() > 0 && importedItem.getItemName() != null)
            {
                importedItem.setCategory(targetCategory);
                // Reset current amount, as it's based on container state
                importedItem.setCurrentAmount(0);
                // Remove existing item if present before adding the new one
                plugin.removeTrackedItem(importedItem.getItemId(), targetCategory);
                plugin.addTrackedItem(importedItem);
            }
        }

        rebuildTrackedItems();
    }

    private void createNewCategory(String categoryName)
    {
        if (categoryName == null || categoryName.trim().isEmpty())
        {
            return;
        }

        String trimmedCategoryName = categoryName.trim();

        // Check if category already exists
        boolean exists = plugin.getTrackedItems().values().stream()
                .anyMatch(item -> item.getCategory().equalsIgnoreCase(trimmedCategoryName));

        if (exists)
        {
            return; // Silently ignore duplicates
        }

        // Register the category in the plugin's order tracking
        plugin.registerCategory(trimmedCategoryName);

        // Set as selected and focus search
        selectedCategory = trimmedCategoryName;
        searchBar.setEnabled(true);
        searchBar.setEditable(true); // Allow typing when enabled
        searchBar.requestFocusInWindow();

        // Force rebuild to show the empty category
        rebuildTrackedItems();
    }

    private void scheduleSearch()
    {
        if (searchDebounceTimer != null)
        {
            searchDebounceTimer.stop();
        }

        // Schedule new search with 200ms delay
        searchDebounceTimer = new Timer(200, e -> {
            onSearchChanged();
            searchDebounceTimer = null;
        });
        searchDebounceTimer.setRepeats(false);
        searchDebounceTimer.start();
    }

    private void onSearchChanged()
    {
        String query = searchBar.getText().trim();

        if (query.isEmpty())
        {
            // Show tracked items
            contentWrapper.removeAll();
            contentWrapper.add(itemScrollPane, BorderLayout.CENTER);
            contentWrapper.revalidate();
            contentWrapper.repaint();
        }
        else
        {
            // Show search results
            contentWrapper.removeAll();
            contentWrapper.add(searchScrollPane, BorderLayout.CENTER);
            showSearchResults(query);
            contentWrapper.revalidate();
            contentWrapper.repaint();
        }
    }

    private void showSearchResults(String query)
    {
        SwingUtil.fastRemoveAll(searchResultsPanel);

        if (categoryBoxes.isEmpty())
        {
            JLabel noCategory = new JLabel("Create a category to tracking items");
            noCategory.setForeground(Color.LIGHT_GRAY);
            noCategory.setBorder(new EmptyBorder(10, 10, 10, 10));
            searchResultsPanel.add(noCategory);
            searchResultsPanel.revalidate();
            searchResultsPanel.repaint();
            return;
        }

        String lowerQuery = query.toLowerCase();

        // Use ItemManager to search for items (tradeable items only)
        List<ItemDefinition> results = itemManager.search(query).stream()
                .filter(itemPrice -> {
                    String itemName = itemPrice.getName().toLowerCase();
                    // Filter out placeholder, noted, and other variants
                    return !itemName.contains("->") && !itemName.equals("null");
                })
                .map(itemPrice -> new ItemDefinition(itemPrice.getId(), itemPrice.getName()))
                .sorted(Comparator.comparingInt((ItemDefinition item) -> {
                    String itemName = item.getName().toLowerCase();
                    if (itemName.equals(lowerQuery)) return 0;
                    if (itemName.startsWith(lowerQuery)) return 1;
                    return 2;
                }).thenComparing(item -> item.getName().length()))
                .limit(MAX_SEARCH_RESULTS)
                .collect(Collectors.toList());


        for (ItemDefinition item : results)
        {
            JPanel itemPanel = createSearchResultPanel(item);
            searchResultsPanel.add(itemPanel);
            searchResultsPanel.add(Box.createRigidArea(new Dimension(0, 2)));
        }

        if (results.isEmpty())
        {
            JLabel noResults = new JLabel("No items found");
            noResults.setForeground(Color.LIGHT_GRAY);
            noResults.setBorder(new EmptyBorder(10, 10, 10, 10));
            searchResultsPanel.add(noResults);
        }

        // Add glue to push items to the top
        searchResultsPanel.add(Box.createVerticalGlue());

        searchResultsPanel.revalidate();
        searchResultsPanel.repaint();
    }

    private JPanel createSearchResultPanel(ItemDefinition itemDef)
    {
        JPanel panel = new JPanel(new BorderLayout(5, 0));
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(8, 10, 8, 10));
        panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 50));
        panel.setPreferredSize(new Dimension(panel.getPreferredSize().width, 50));

        // Left: Icon and Name
        JPanel leftPanel = new JPanel(new BorderLayout(5, 0));
        leftPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel iconLabel = new JLabel();
        iconLabel.setPreferredSize(new Dimension(36, 32));
        iconLabel.setToolTipText(itemDef.getName()); // Show full item name on hover
        AsyncBufferedImage itemImage = itemManager.getImage(itemDef.getId());
        if (itemImage != null)
        {
            itemImage.addTo(iconLabel);
        }

        JLabel nameLabel = new JLabel(itemDef.getName());
        nameLabel.setForeground(Color.WHITE);

        leftPanel.add(iconLabel, BorderLayout.WEST);
        leftPanel.add(nameLabel, BorderLayout.CENTER);

        panel.add(leftPanel, BorderLayout.CENTER);

        // Right: Goal input and + button
        JPanel rightPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 0));
        rightPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JTextField goalField = new JTextField(5);
        goalField.setPreferredSize(new Dimension(60, 25));
        goalField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        goalField.setForeground(Color.WHITE);
        goalField.setCaretColor(Color.WHITE);
        goalField.setToolTipText("Enter goal amount");
        ((AbstractDocument) goalField.getDocument()).setDocumentFilter(new QuantityDocumentFilter());

        JButton addButton = new JButton("+");
        goalField.addActionListener(e -> addButton.doClick());

        if (selectedCategory == null)
        {
            goalField.setEnabled(false);
            addButton.setEnabled(false);
            goalField.setToolTipText("Select a category to add an item");
            addButton.setToolTipText("Select a category to add an item");
        }
        else
        {
            goalField.setEnabled(true);
            addButton.setEnabled(true);
            goalField.setToolTipText("Enter goal amount");
            addButton.setToolTipText("Add to tracking");
        }

        addButton.setPreferredSize(new Dimension(35, 25));
        addButton.setMinimumSize(new Dimension(35, 25));
        addButton.setMaximumSize(new Dimension(35, 25));
        addButton.setToolTipText("Add to tracking");
        addButton.addActionListener(e -> {
            String goalText = goalField.getText().trim();
            Integer goal = null;

            try
            {
                if (!goalText.isEmpty())
                {
                    long parsedGoal = QuantityFormatter.parseQuantity(goalText);
                    if (parsedGoal > QuantityFormatter.getMaxStackSize())
                    {
                        parsedGoal = QuantityFormatter.getMaxStackSize();
                    }

                    if (parsedGoal > 0)
                    {
                        goal = (int) parsedGoal;
                    }
                }

                // Check if already tracked in the current category, if so, update it
                TrackedItem existing = plugin.getTrackedItems().get(itemDef.getId() + ":" + selectedCategory);
                if (existing != null && existing.getCategory().equals(selectedCategory))
                {
                    existing.setGoalAmount(goal);
                    plugin.saveData();
                    clearSearchAndRebuild();
                    return;
                }

                // If not tracked, add as a new item
			if (selectedCategory == null || selectedCategory.isEmpty())
			{
				return; // Should not happen
			}

			TrackedItem newItem = new TrackedItem(itemDef.getId(), itemDef.getName(), goal, selectedCategory);

			// Fetch and set GE and HA prices on client thread
			plugin.getClientThread().invoke(() -> {
				int gePrice = itemManager.getItemPrice(itemDef.getId());
				int haPrice = itemManager.getItemComposition(itemDef.getId()).getHaPrice();
				newItem.setGePrice(gePrice);
				newItem.setHaPrice(haPrice);

				// Add the item after prices are fetched
				SwingUtilities.invokeLater(() -> {
					addTrackedItem(newItem);
					clearSearchAndRebuild();
				});
			});
		}
		catch (NumberFormatException ex)
		{
			plugin.sendChatMessage("Please enter a valid number.");
		}
	});

        rightPanel.add(goalField);
        rightPanel.add(addButton);

        panel.add(rightPanel, BorderLayout.EAST);

        return panel;
    }

    private void clearSearchAndRebuild()
    {
        searchBar.setText("");
        contentWrapper.removeAll();
        contentWrapper.add(itemScrollPane, BorderLayout.CENTER);
        contentWrapper.revalidate();
        contentWrapper.repaint();
        rebuildTrackedItems();
    }


    private void rebuildTrackedItems()
    {
        SwingUtilities.invokeLater(() ->
        {
            // Save the current expanded/collapsed state of each category before clearing
            java.util.Map<String, Boolean> expandedStates = new java.util.HashMap<>();
            for (CategoryBox box : categoryBoxes)
            {
                expandedStates.put(box.getCategoryName(), !box.isCollapsed());
            }

            SwingUtil.fastRemoveAll(itemListPanel);
            categoryBoxes.clear();

            // Get items from plugin
            List<TrackedItem> items = new ArrayList<>(plugin.getTrackedItems().values());

            // Ensure all items have a category (for backward compatibility)
            items.forEach(item -> {
                if (item.getCategory() == null || item.getCategory().isEmpty())
                {
                    item.setCategory("Default");
                }
            });

            // Group items by category
            java.util.Map<String, List<TrackedItem>> itemsByCategory = items.stream()
                    .collect(Collectors.groupingBy(TrackedItem::getCategory));

            // Use plugin's category order for consistent ordering
            List<String> categoryNames = new ArrayList<>(plugin.getCategoryOrder());

            // Add any categories from items that aren't in the order yet (shouldn't happen but safety check)
            for (String category : itemsByCategory.keySet())
            {
                if (!categoryNames.contains(category))
                {
                    categoryNames.add(category);
                    plugin.registerCategory(category);
                }
            }

            // Add the currently selected (potentially new and empty) category to the end
            if (selectedCategory != null && !selectedCategory.isEmpty() && !categoryNames.contains(selectedCategory))
            {
                categoryNames.add(selectedCategory);
            }

            // Create all CategoryBoxes first (like LootTracker buildBox pattern)
            for (String categoryName : categoryNames)
            {
                List<TrackedItem> itemsForCategory = itemsByCategory.getOrDefault(categoryName, new ArrayList<>());
                CategoryBox categoryBox = new CategoryBox(categoryName, plugin, itemManager, this, chatboxPanelManager);
                categoryBoxes.add(categoryBox);

                // Build the box with its items
                categoryBox.rebuild(itemsForCategory);

                // Add to panel
                itemListPanel.add(categoryBox);
            }

            for (CategoryBox box : categoryBoxes)
            {
                boolean isThisSelected = box.getCategoryName().equals(selectedCategory);

                // Set selected state for visual indicator
                box.setSelected(isThisSelected);

                // Restore expanded/collapsed state, or expand if it's a new category and selected
                Boolean wasExpanded = expandedStates.get(box.getCategoryName());
                if (wasExpanded != null)
                {
                    // Restore previous state
                    if (wasExpanded)
                    {
                        box.expand();
                    }
                    else
                    {
                        box.collapse();
                    }
                }
                else
                {
                    // New category - expand only if selected
                    if (isThisSelected)
                    {
                        box.expand();
                    }
                    else
                    {
                        box.collapse();
                    }
                }
            }

            itemListPanel.revalidate();
        });
    }
}


package com.resourcetracker;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ScriptID;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.api.ChatMessageType;

import javax.inject.Inject;
import javax.swing.SwingUtilities;
import java.awt.image.BufferedImage;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@PluginDescriptor(
        name = "Resource Tracker",
        description = "Track items in your bank with goals",
        tags = {"bank", "items", "tracker", "goals"}
)
public class ResourceTrackerPlugin extends Plugin
{
    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ResourceTrackerConfig config;

    @Inject
    private Client client;

    @Inject
    @Getter
    private ClientThread clientThread;

    @Inject
    @Getter
    private Gson gson;

    @Inject
    @Getter
    private ChatboxPanelManager chatboxPanelManager;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    @Getter
    private net.runelite.client.ui.ClientUI clientUi;

    public ResourceTrackerConfig getConfig()
    {
        return config;
    }

    private ResourceTrackerPanel panel;
    private NavigationButton navButton;
    private final Map<String, TrackedItem> trackedItems = new HashMap<>();

    // Track category order for consistent display
    private final List<String> categoryOrder = new ArrayList<>();

    // Track which categories are in Inventory Only mode
    private final Set<String> inventoryOnlyCategories = new HashSet<>();

    private String getTrackedItemKey(int itemId, String category) {
        return itemId + ":" + category;
    }
    // Dynamic container cache - one map per container ID
    private final Map<Integer, Map<Integer, Integer>> containerCaches = new HashMap<>();

    // Potion storage tracking
    private boolean rebuildPotions = false;
    private Set<Integer> potionStoreVars;
    private boolean potionRebuildInProgress = false;

    // Account tracking
    private String currentAccountHash = null;

    // Update debouncing
    private boolean updatePending = false;
    private final Object updateLock = new Object();

    @Override
    protected void startUp()
    {
        log.debug("Resource Tracker started");

        panel = new ResourceTrackerPanel(this, itemManager, chatboxPanelManager);

        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/com/resourcetracker/icon.png");

        navButton = NavigationButton.builder()
                .tooltip("Resource Tracker")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);

        loadData();
    }

    @Override
    protected void shutDown()
    {
        log.debug("Resource Tracker stopped!");
        saveData();
        clientToolbar.removeNavigation(navButton);
    }

    private String getAccountHash()
    {
        if (client.getAccountHash() != -1)
        {
            return String.valueOf(client.getAccountHash());
        }
        return null;
    }

    @SuppressWarnings("unused")
    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN)
        {
            String newAccountHash = getAccountHash();

            // Check if we switched accounts
            if (currentAccountHash != null && !currentAccountHash.equals(newAccountHash))
            {
                log.info("Account changed - clearing cached data");
                // Clear in-memory data from previous account
                trackedItems.clear();
                categoryOrder.clear();
                containerCaches.clear();
                inventoryOnlyCategories.clear();
            }

            currentAccountHash = newAccountHash;
            log.info("Logged in as account hash: {}", currentAccountHash);

            // Load tracked items when player logs in
            loadData();

            // Check if bank is already open and potion storage should be initialized
            // Must be called on client thread
            if (config.trackPotionStorage())
            {
                clientThread.invokeLater(() ->
                {
                    if (client.getItemContainer(InventoryID.BANK) != null)
                    {
                        rebuildPotions = true;
                    }
                });
            }
        }
        else if (event.getGameState() == GameState.LOGIN_SCREEN)
        {
            // Save data when logging out
            saveData();
            // Clear panel when logging out
            panel.resetPanel();

            log.info("Logged out from account hash: {}", currentAccountHash);
        }
    }

    public void sendChatMessage(String message)
    {
        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(message)
                .build());
    }

    public void resetAllData()
    {
        // Clear in-memory data
        trackedItems.clear();
        categoryOrder.clear();
        containerCaches.clear();
        inventoryOnlyCategories.clear();

        // Clear from config
        configManager.setRSProfileConfiguration("resourcetracker", "trackedItems", "");
        configManager.setRSProfileConfiguration("resourcetracker", "categoryOrder", "");
        configManager.setRSProfileConfiguration("resourcetracker", "invOnlyCategories", "");
        configManager.setRSProfileConfiguration("resourcetracker", "containerCaches", "");
        configManager.setRSProfileConfiguration("resourcetracker", "cacheTimestamp", "");

        // Reset the panel UI
        SwingUtilities.invokeLater(() -> {
            panel.resetPanel();
            sendChatMessage("All tracked items and categories have been reset.");
        });

        log.info("Reset all tracked items and categories");
    }

    @SuppressWarnings("unused")
    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        int containerId = event.getContainerId();
        ContainerTracker.Container container = ContainerTracker.getContainer(containerId);

        // Check if this is a registered container and if tracking is enabled for it
        if (container != null && isContainerTrackingEnabled(container))
        {
            updateContainerCache(containerId, event.getItemContainer());
            updateTrackedItems();
        }
    }

    /**
     * Check if tracking is enabled for a specific container via config.
     */
    private boolean isContainerTrackingEnabled(ContainerTracker.Container container)
    {
        String configKey = container.getConfigKey();

        // Use reflection or direct mapping to check config
        switch (configKey)
        {
            case "trackBank":
                return config.trackBank();
            case "trackInventory":
                return config.trackInventory();
            case "trackSeedVault":
                return config.trackSeedVault();
            case "trackRetrievalService":
                return config.trackRetrievalService();
            case "trackGroupStorage":
                return config.trackGroupStorage();
            case "trackLootingBag":
                return config.trackLootingBag();
            case "trackPotionStorage":
                return config.trackPotionStorage();
            case "trackBoatInventory":
                return config.trackBoatInventory();
            case "trackPOHStorage":
                return config.trackPOHStorage();
            default:
                return false;
        }
    }

    @Subscribe
    public void onConfigChanged(net.runelite.client.events.ConfigChanged event)
    {
        if (event.getGroup().equals("resourcetracker"))
        {
            // If display settings change, we need to refresh the UI to show/hide labels
            if (event.getKey().equals("showCategoryTotals") || event.getKey().equals("showCategoryProgress"))
            {
                SwingUtilities.invokeLater(() -> panel.rebuild());
            }
        }
    }
    /**
     * Update the cache for a specific container.
     * This method is generic and works for any container type.
     */
    private void updateContainerCache(int containerId, ItemContainer container)
    {
        if (container == null)
        {
            return;
        }

        // Normalize container IDs to use the same cache for alternate IDs
        int cacheId = normalizeContainerId(containerId);

        // Get or create cache for this container
        Map<Integer, Integer> cache = containerCaches.computeIfAbsent(cacheId, k -> new HashMap<>());
        cache.clear();

        // Cache all items in the container
        for (Item item : container.getItems())
        {
            if (item.getId() > 0)
            {
                cache.merge(item.getId(), item.getQuantity(), Integer::sum);
            }
        }
    }

    /**
     * Normalize container IDs to use the same cache for alternate IDs.
     * Examples: 660 -> 93 (temp inventory), 33731 -> 963 (boat 1 alternate)
     */
    private int normalizeContainerId(int containerId)
    {

        // Boats: Normalize alternate IDs (33731-33735) to primary IDs (963-967)
        if (containerId >= 33731 && containerId <= 33735)
        {
            return 963 + (containerId - 33731); // 33731->963, 33732->964, etc.
        }

        return containerId; // No normalization needed
    }

    public void updateTrackedItems()
    {
        // If no items are tracked, skip the update
        if (trackedItems.isEmpty())
        {
            return;
        }

        boolean needsUpdate = false;

        // Only iterate through tracked items, not all container items
        for (TrackedItem trackedItem : trackedItems.values())
        {
            int itemId = trackedItem.getItemId();
            int totalAmount = 0;
            Map<String, Integer> breakdown = new HashMap<>();
            Map<String, Integer> savedBreakdown = trackedItem.getContainerQuantities();
            boolean hasScannedData = false;

            // Check if this item is restricted to inventory only
            boolean isRestrictedToInventory = inventoryOnlyCategories.contains(trackedItem.getCategory()) || trackedItem.isInventoryOnly();

            // Track which normalized cache IDs we've already processed to avoid double-counting
            java.util.Set<Integer> processedCaches = new java.util.HashSet<>();

            // Dynamically check all registered containers
            for (ContainerTracker.Container container : ContainerTracker.getAllContainers().values())
            {
                // If restricted, skip any container that isn't inventory (ID 93)
                if (isRestrictedToInventory && container.getId() != 93)
                {
                    continue;
                }

                // Check if tracking is enabled for this container globally
                if (!isContainerTrackingEnabled(container))
                {
                    continue;
                }

                // Get the normalized cache ID to avoid counting alternate IDs twice
                int normalizedCacheId = normalizeContainerId(container.getId());

                if (processedCaches.contains(normalizedCacheId))
                {
                    continue;
                }

                processedCaches.add(normalizedCacheId);
                Map<Integer, Integer> cache = containerCaches.get(normalizedCacheId);

                if (cache != null)
                {
                    Integer quantity = cache.get(itemId);
                    int qty = (quantity != null ? quantity : 0);
                    breakdown.put(container.getName(), qty);
                    totalAmount += qty;
                    hasScannedData = true;
                }
                else if (savedBreakdown != null && savedBreakdown.containsKey(container.getName()))
                {
                    int savedQty = savedBreakdown.get(container.getName());
                    breakdown.put(container.getName(), savedQty);
                    totalAmount += savedQty;
                }
            }

            if (hasScannedData && (trackedItem.getCurrentAmount() != totalAmount || !breakdown.equals(savedBreakdown)))
            {
                trackedItem.setCurrentAmount(totalAmount);
                trackedItem.setContainerQuantities(breakdown);
                needsUpdate = true;
            }
        }

        // Only save and rebuild if something actually changed
        if (needsUpdate)
        {
            synchronized (updateLock)
            {
                // If an update is already pending, don't schedule another one
                if (updatePending)
                {
                    return;
                }
                updatePending = true;
            }

            // Use invokeLater to batch UI updates and prevent multiple rapid rebuilds
            SwingUtilities.invokeLater(() -> {
                synchronized (updateLock)
                {
                    updatePending = false;
                }
                saveData();
                panel.rebuild();
            });
        }
    }

    public void addTrackedItem(TrackedItem item)
    {
        if (trackedItems.containsKey(getTrackedItemKey(item.getItemId(), item.getCategory())))
        {
            return;
        }

        trackedItems.put(getTrackedItemKey(item.getItemId(), item.getCategory()), item);

        // Force an update immediately to calculate initial values correctly based on current modes
        updateTrackedItems();

        SwingUtilities.invokeLater(() -> panel.rebuild());
        saveData();
    }

    public void removeTrackedItem(int itemId, String category)
    {
        trackedItems.remove(getTrackedItemKey(itemId, category));
        SwingUtilities.invokeLater(() -> panel.rebuild());
        saveData();
    }

    public Map<String, TrackedItem> getTrackedItems()
    {
        return trackedItems;
    }

    // ===== NEW METHODS FOR CATEGORY INVENTORY ONLY MODE =====

    public boolean isCategoryInventoryOnly(String category)
    {
        return inventoryOnlyCategories.contains(category);
    }

    public void toggleCategoryInventoryOnly(String category)
    {
        if (inventoryOnlyCategories.contains(category))
        {
            inventoryOnlyCategories.remove(category);
        }
        else
        {
            inventoryOnlyCategories.add(category);
        }

        // Save state and force an update to items
        saveData();

        // IMPORTANT: We must trigger a full updateTrackedItems scan so that
        // when we toggle OFF, we re-scan the Bank caches that were being ignored.
        // We run it on the client thread to be safe with cache access, though caches are synchronized.
        updateTrackedItems();

        // Force UI rebuild to show the new colors/totals
        SwingUtilities.invokeLater(() -> panel.rebuild());
    }

    /**
     * Detect when bank finishes building to trigger potion storage rebuild.
     */
    @SuppressWarnings("unused")
    @Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        if (event.getScriptId() == ScriptID.BANKMAIN_FINISHBUILDING && config.trackPotionStorage())
        {
            rebuildPotions = true;
        }
    }

    /**
     * On client tick, rebuild potion storage if flagged and cache the varbit triggers.
     */
    @SuppressWarnings("unused")
    @Subscribe
    public void onClientTick(ClientTick event)
    {
        if (rebuildPotions && !potionRebuildInProgress)
        {
            potionRebuildInProgress = true;
            rebuildPotions = false; // Clear the flag immediately to prevent double processing

            updatePotionStorageCache();

            potionRebuildInProgress = false;

            // Cache the varbits that trigger potion store rebuilds (only do this once)
            Widget w = client.getWidget(InterfaceID.Bankmain.POTIONSTORE_ITEMS);
            if (w != null && potionStoreVars == null)
            {
                int[] trigger = w.getVarTransmitTrigger();
                potionStoreVars = new HashSet<>();
                Arrays.stream(trigger).forEach(potionStoreVars::add);
            }
        }
    }

    /**
     * Watch for varbit changes that affect potion storage.
     */
    @SuppressWarnings("unused")
    @Subscribe
    public void onVarbitChanged(VarbitChanged varbitChanged)
    {
        if (potionStoreVars != null && potionStoreVars.contains(varbitChanged.getVarpId()))
        {
            // Only set the flag, don't directly call update
            // This prevents multiple rapid-fire updates
            rebuildPotions = true;
        }
    }

    /**
     * Update the potion storage cache by reading from game enums and scripts.
     * potion storage doesn't have a normal ItemContainer.
     */
    private void updatePotionStorageCache()
    {
        final Map<Integer, Integer> potionQtyMap = new HashMap<>();

        // Get potion enums from the client
        EnumComposition potionStorePotions = client.getEnum(EnumID.POTIONSTORE_POTIONS);
        EnumComposition potionStoreUnfinishedPotions = client.getEnum(EnumID.POTIONSTORE_UNFINISHED_POTIONS);

        // Process both regular and unfinished potions
        for (EnumComposition e : new EnumComposition[]{potionStorePotions, potionStoreUnfinishedPotions})
        {
            for (int potionEnumId : e.getIntVals())
            {
                EnumComposition potionEnum = client.getEnum(potionEnumId);

                // Run the script to get the dose count for this potion
                client.runScript(ScriptID.POTIONSTORE_DOSES, potionEnumId);
                int doses = client.getIntStack()[0];

                if (doses > 0)
                {
                    for (int doseLevel = 1; doseLevel <= 4; doseLevel++)
                    {
                        int itemId = potionEnum.getIntValue(doseLevel);
                        if (itemId > 0)
                        {
                            // Convert total doses into containers of this dose level
                            int quantity = doses / doseLevel;
                            potionQtyMap.put(itemId, quantity);
                        }
                    }
                }
            }
        }

        // Update the cache with potion storage fake container ID
        int potionStorageId = ContainerTracker.POTION_STORAGE.getId();
        int cacheId = normalizeContainerId(potionStorageId);
        Map<Integer, Integer> cache = containerCaches.computeIfAbsent(cacheId, k -> new HashMap<>());

        // Check if the cache actually changed before updating
        boolean cacheChanged = !cache.equals(potionQtyMap);

        if (cacheChanged)
        {
            cache.clear();
            cache.putAll(potionQtyMap);
            log.debug("Updated potion storage cache with {} potion types", potionQtyMap.size());

            // Only update tracked items if the cache actually changed
            updateTrackedItems();
        }
    }


    public void saveData()
    {
        // Verify we're logged in before saving
        String accountHash = getAccountHash();
        if (accountHash == null)
        {
            log.warn("Cannot save data - no account logged in");
            return;
        }

        if (!accountHash.equals(currentAccountHash))
        {
            log.warn("Account mismatch detected - skipping save");
            return;
        }


        // Save tracked items
        if (trackedItems.isEmpty())
        {
            configManager.setRSProfileConfiguration("resourcetracker", "trackedItems", "");
        }
        else
        {
            List<TrackedItem> itemList = new ArrayList<>(trackedItems.values());
            String json = gson.toJson(itemList);
            log.debug("Saving {} tracked items for account {}", trackedItems.size(), accountHash);
            configManager.setRSProfileConfiguration("resourcetracker", "trackedItems", json);
        }

        // Save inventory only categories
        String invOnlyJson = inventoryOnlyCategories.isEmpty() ? "" : gson.toJson(inventoryOnlyCategories);
        configManager.setRSProfileConfiguration("resourcetracker", "invOnlyCategories", invOnlyJson);
        if (!inventoryOnlyCategories.isEmpty())
        {
            log.debug("Saved {} inventory-only categories for account {}", inventoryOnlyCategories.size(), accountHash);
        }

        // Save container caches with timestamp
        if (containerCaches.isEmpty())
        {
            configManager.setRSProfileConfiguration("resourcetracker", "containerCaches", "");
            configManager.setRSProfileConfiguration("resourcetracker", "cacheTimestamp", "");
        }
        else
        {
            String cacheJson = gson.toJson(containerCaches);
            configManager.setRSProfileConfiguration("resourcetracker", "containerCaches", cacheJson);
            configManager.setRSProfileConfiguration("resourcetracker", "cacheTimestamp", String.valueOf(System.currentTimeMillis()));
            log.debug("Saved caches for {} containers for account {}", containerCaches.size(), accountHash);
        }

        // Save category order
        saveCategoryOrder();
    }

    private void saveCategoryOrder()
    {
        String orderJson = gson.toJson(categoryOrder);
        configManager.setRSProfileConfiguration("resourcetracker", "categoryOrder", orderJson);
        log.debug("Saved category order: {}", categoryOrder);
    }

    private void loadCategoryOrder()
    {
        String orderJson = configManager.getRSProfileConfiguration("resourcetracker", "categoryOrder");
        if (orderJson != null && !orderJson.isEmpty())
        {
            try
            {
                Type type = new TypeToken<List<String>>(){}.getType();
                List<String> loaded = gson.fromJson(orderJson, type);
                if (loaded != null)
                {
                    categoryOrder.clear();
                    categoryOrder.addAll(loaded);
                    log.debug("Loaded category order: {}", categoryOrder);
                }
            }
            catch (Exception e)
            {
                log.error("Error loading category order", e);
            }
        }
    }

    public void registerCategory(String categoryName)
    {
        if (!categoryOrder.contains(categoryName))
        {
            categoryOrder.add(categoryName);
            saveCategoryOrder();
            log.debug("Registered new category: {}", categoryName);
        }
    }

    public void removeCategory(String categoryName)
    {
        categoryOrder.remove(categoryName);
        saveCategoryOrder();
        log.debug("Removed category: {}", categoryName);
    }

    public void renameCategory(String oldName, String newName)
    {
        int index = categoryOrder.indexOf(oldName);
        if (index != -1)
        {
            categoryOrder.set(index, newName);
            saveCategoryOrder();
            saveData();
            log.debug("Renamed category '{}' to '{}'", oldName, newName);
        }
    }

    public void moveCategoryOrder(String categoryName, int newIndex)
    {
        categoryOrder.remove(categoryName);
        categoryOrder.add(newIndex, categoryName);
        saveCategoryOrder();
        SwingUtilities.invokeLater(() -> panel.rebuild());
        log.debug("Moved category {} to index {}", categoryName, newIndex);
    }

    public List<String> getCategoryOrder()
    {
        return new ArrayList<>(categoryOrder);
    }

    private void loadData()
    {
        String accountHash = getAccountHash();
        if (accountHash == null)
        {
            log.warn("Cannot load data - no account logged in");
            return;
        }

        log.info("Loading data for account hash: {}", accountHash);


        // Load category order first
        loadCategoryOrder();

        // Load Inventory Only Categories
        String invOnlyJson = configManager.getRSProfileConfiguration("resourcetracker", "invOnlyCategories");
        if (invOnlyJson != null && !invOnlyJson.isEmpty())
        {
            try {
                Type type = new TypeToken<Set<String>>(){}.getType();
                Set<String> loaded = gson.fromJson(invOnlyJson, type);
                if (loaded != null) {
                    inventoryOnlyCategories.clear();
                    inventoryOnlyCategories.addAll(loaded);
                    log.debug("Loaded {} inventory-only categories", inventoryOnlyCategories.size());
                }
            } catch (Exception e) {
                log.error("Error loading inventory only categories", e);
            }
        }

        // Load container caches
        String cacheJson = configManager.getRSProfileConfiguration("resourcetracker", "containerCaches");
        String timestampStr = configManager.getRSProfileConfiguration("resourcetracker", "cacheTimestamp");

        if (cacheJson != null && !cacheJson.isEmpty())
        {
            try {
                Type type = new TypeToken<Map<Integer, Map<Integer, Integer>>>(){}.getType();
                Map<Integer, Map<Integer, Integer>> loadedCache = gson.fromJson(cacheJson, type);
                if (loadedCache != null) {
                    containerCaches.clear();
                    containerCaches.putAll(loadedCache);

                    // Check cache age
                    if (timestampStr != null && !timestampStr.isEmpty())
                    {
                        try {
                            long timestamp = Long.parseLong(timestampStr);
                            long ageHours = (System.currentTimeMillis() - timestamp) / (1000 * 60 * 60);
                            log.info("Loaded caches for {} containers (age: {} hours) for account {}",
                                    containerCaches.size(), ageHours, accountHash);

                            if (ageHours > 24)
                            {
                                log.warn("Container cache is {} hours old - data may be stale", ageHours);
                            }
                        } catch (NumberFormatException e) {
                            log.warn("Invalid cache timestamp");
                        }
                    }
                    else
                    {
                        log.debug("Loaded caches for {} containers (no timestamp)", containerCaches.size());
                    }
                }
            } catch (Exception e) {
                log.error("Error loading container caches", e);
                // Clear potentially corrupted cache
                containerCaches.clear();
            }
        }

        String json = configManager.getRSProfileConfiguration("resourcetracker", "trackedItems");
        if (json == null || json.isEmpty())
        {
            log.debug("No tracked items to load for account {}", accountHash);
            return;
        }

        try
        {
            Type type = new TypeToken<List<TrackedItem>>()
            {
            }.getType();
            List<TrackedItem> itemList = gson.fromJson(json, type);

            if (itemList == null)
            {
                log.warn("Failed to deserialize tracked items - null result");
                return;
            }

            trackedItems.clear();
            for (TrackedItem item : itemList)
            {
                if (item != null && item.getItemId() > 0)
                {
                    // Ensure containerQuantities is not null
                    if (item.getContainerQuantities() == null)
                    {
                        item.setContainerQuantities(new HashMap<>());
                    }
                    // Ensure category is not null
                    if (item.getCategory() == null || item.getCategory().isEmpty())
                    {
                        item.setCategory("Default");
                    }

                    // Fetch and set prices if not already set (for backwards compatibility)
                    if (item.getGePrice() == 0)
                    {
                        item.setGePrice(itemManager.getItemPrice(item.getItemId()));
                    }
                    if (item.getHaPrice() == 0)
                    {
                        item.setHaPrice(itemManager.getItemComposition(item.getItemId()).getHaPrice());
                    }

                    trackedItems.put(getTrackedItemKey(item.getItemId(), item.getCategory()), item);

                    // Register category if not already in order
                    if (!categoryOrder.contains(item.getCategory()))
                    {
                        categoryOrder.add(item.getCategory());
                    }
                }
            }

            // Sync items with the loaded caches immediately
            updateTrackedItems();

            log.info("Loaded {} tracked items for account {}", trackedItems.size(), accountHash);
            // Initial load of UI
            SwingUtilities.invokeLater(() -> panel.loadItems(trackedItems.values()));
        }
        catch (Exception e)
        {
            log.error("Error loading tracked items from config for account {}", accountHash, e);
            // On error, clear potentially corrupted data
            trackedItems.clear();
        }
    }


    @Provides
    ResourceTrackerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(ResourceTrackerConfig.class);
    }
}
package com.resourcetracker;

import java.util.HashMap;
import java.util.Map;

/**
 * Utility class for tracking item quantities across different containers.
 * Highly modular - add new containers by simply adding them to the CONTAINER_REGISTRY.
 */
public class ContainerTracker
{
	/**
	 * Container definition - stores ID, friendly name, and config key.
	 */
	public static class Container
	{
		private final int id;
		private final String name;
		private final String configKey;

		public Container(int id, String name, String configKey)
		{
			this.id = id;
			this.name = name;
			this.configKey = configKey;
		}

		public int getId()
		{
			return id;
		}

		public String getName()
		{
			return name;
		}

		public String getConfigKey()
		{
			return configKey;
		}
	}

	// ===== CONTAINER REGISTRY =====
	// To add a new container: Just add a new line here with (ID, "Display Name", "configKey")
	// Then add the config item to ResourceTrackerConfig.java
	public static final Container BANK = new Container(95, "Bank", "trackBank");
	public static final Container INVENTORY = new Container(93, "Inventory", "trackInventory");
	public static final Container SEED_VAULT = new Container(626, "Seed Vault", "trackSeedVault");
	public static final Container RETRIEVAL_SERVICE = new Container(525, "Retrieval Service", "trackRetrievalService");
	public static final Container GROUP_STORAGE = new Container(659, "Group storage", "trackGroupStorage");
	public static final Container LOOTING_BAG = new Container(516, "Looting Bag", "trackLootingBag");
	public static final Container POTION_STORAGE = new Container(-420, "Potion Storage", "trackPotionStorage"); // Fake ID - no real container
	public static final Container BOAT_1 = new Container(963, "Boat 1", "trackBoatInventory");
	public static final Container BOAT_1_ALT = new Container(33731, "Boat 1", "trackBoatInventory"); // Alternate ID
	public static final Container BOAT_2 = new Container(964, "Boat 2", "trackBoatInventory");
	public static final Container BOAT_2_ALT = new Container(33732, "Boat 2", "trackBoatInventory"); // Alternate ID
	public static final Container BOAT_3 = new Container(965, "Boat 3", "trackBoatInventory");
	public static final Container BOAT_3_ALT = new Container(33733, "Boat 3", "trackBoatInventory"); // Alternate ID
	public static final Container BOAT_4 = new Container(966, "Boat 4", "trackBoatInventory");
	public static final Container BOAT_4_ALT = new Container(33734, "Boat 4", "trackBoatInventory"); // Alternate ID
	public static final Container BOAT_5 = new Container(967, "Boat 5", "trackBoatInventory");
	public static final Container BOAT_5_ALT = new Container(33735, "Boat 5", "trackBoatInventory"); // Alternate ID
	public static final Container POH_STORAGE = new Container(33405, "POH Storage", "trackPOHStorage");

	// Map for quick lookup by ID
	private static final Map<Integer, Container> CONTAINER_BY_ID = new HashMap<>();
	private static final Map<String, Container> CONTAINER_BY_CONFIG_KEY = new HashMap<>();

	static
	{
		// Register all containers
		registerContainer(BANK);
		registerContainer(INVENTORY);
		registerContainer(SEED_VAULT);
		registerContainer(RETRIEVAL_SERVICE);
		registerContainer(GROUP_STORAGE);
		registerContainer(LOOTING_BAG);
		registerContainer(POTION_STORAGE);
		registerContainer(BOAT_1);
		registerContainer(BOAT_1_ALT);
		registerContainer(BOAT_2);
		registerContainer(BOAT_2_ALT);
		registerContainer(BOAT_3);
		registerContainer(BOAT_3_ALT);
		registerContainer(BOAT_4);
		registerContainer(BOAT_4_ALT);
		registerContainer(BOAT_5);
		registerContainer(BOAT_5_ALT);
        registerContainer(POH_STORAGE);
	}

	private static void registerContainer(Container container)
	{
		CONTAINER_BY_ID.put(container.getId(), container);
		CONTAINER_BY_CONFIG_KEY.put(container.getConfigKey(), container);
	}

	/**
	 * Get container by ID.
	 *
	 * @param containerId The container ID
	 * @return The Container object, or null if not found
	 */
	public static Container getContainer(int containerId)
	{
		return CONTAINER_BY_ID.get(containerId);
	}

	/**
	 * Get container by config key.
	 *
	 * @param configKey The config key (e.g., "trackBank")
	 * @return The Container object, or null if not found
	 */
	public static Container getContainerByConfigKey(String configKey)
	{
		return CONTAINER_BY_CONFIG_KEY.get(configKey);
	}

	/**
	 * Get all registered containers.
	 *
	 * @return Map of container ID to Container object
	 */
	public static Map<Integer, Container> getAllContainers()
	{
		return new HashMap<>(CONTAINER_BY_ID);
	}

	/**
	 * Gets the friendly name for a container type.
	 *
	 * @param containerId The ID of the container
	 * @return The friendly name of the container, or "Unknown" if not recognized
	 */
	public static String getContainerFriendlyName(int containerId)
	{
		Container container = CONTAINER_BY_ID.get(containerId);
		return container != null ? container.getName() : "Unknown";
	}

	/**
	 * Check if a container ID is registered.
	 *
	 * @param containerId The container ID to check
	 * @return true if the container is registered
	 */
	public static boolean isRegistered(int containerId)
	{
		return CONTAINER_BY_ID.containsKey(containerId);
	}

	/**
	 * Builds an HTML tooltip showing the breakdown of item quantities by container.
	 *
	 * @param item The tracked item to build a tooltip for
	 * @return HTML-formatted tooltip string, or null if no containers have items
	 */
	public static String buildContainerTooltip(TrackedItem item)
	{
		Map<String, Integer> containers = item.getContainerQuantities();
		if (containers == null || containers.isEmpty())
		{
			return null;
		}

		StringBuilder tooltip = new StringBuilder("<html>");
		containers.entrySet().stream()
				.filter(e -> e.getValue() > 0)
				.sorted(Map.Entry.comparingByKey())
				.forEach(e -> tooltip.append(e.getKey())
						.append(": ")
						.append(String.format("%,d", e.getValue()))
						.append("<br>"));
		tooltip.append("</html>");

		return tooltip.toString();
	}
}

package com.resourcetracker;

import java.awt.Color;
import javax.swing.JLabel;

public final class QuantityFormatter
{
	private static final int MAX_STACK_SIZE = 2_147_483_647;

	/**
	 * Formats a number into a stack-like string, e.g., 100k, 10M.
	 *
	 * @param quantity The number to format.
	 * @return A formatted string.
	 */
	public static String formatNumber(long quantity)
	{
		if (quantity >= 10_000_000)
		{
			return (quantity / 1_000_000) + "M";
		}
		if (quantity >= 100_000)
		{
			return (quantity / 1_000) + "K";
		}
		return String.valueOf(quantity);
	}

	/**
	 * Updates a JLabel with formatted text and color based on the quantity.
	 *
	 * @param label         The JLabel to update.
	 * @param quantity      The quantity to display.
	 * @param defaultColor  The default color for the text.
	 * @param highlightGreen If true, color will be green for quantities >= 10M.
	 */
	public static void formatLabel(JLabel label, long quantity, Color defaultColor, boolean highlightGreen)
	{
		label.setText(formatNumber(quantity));

		if (highlightGreen && quantity >= 10_000_000)
		{
			label.setForeground(Color.GREEN);
		}
		else
		{
			label.setForeground(defaultColor);
		}
	}

	/**
	 * Gets the maximum allowed value for an item stack.
	 *
	 * @return The maximum stack size.
	 */
	public static int getMaxStackSize()
	{
		return MAX_STACK_SIZE;
	}

	/**
	 * Parses a string with suffixes (e.g., 'k', 'm', 'b') into a long.
	 *
	 * @param text The string to parse.
	 * @return The parsed long value.
	 * @throws NumberFormatException if the string is not a valid number or format.
	 */
	public static long parseQuantity(String text) throws NumberFormatException
	{
		if (text == null || text.isEmpty())
		{
			throw new NumberFormatException("Input string is empty");
		}

		text = text.toLowerCase().trim();
		char lastChar = text.charAt(text.length() - 1);
		long multiplier = 1;

		if (Character.isLetter(lastChar))
		{
			switch (lastChar)
			{
				case 'k':
					multiplier = 1_000;
					break;
				case 'm':
					multiplier = 1_000_000;
					break;
				case 'b':
					multiplier = 1_000_000_000;
					break;
				default:
					throw new NumberFormatException("Invalid suffix: " + lastChar);
			}
			// Remove the suffix
			text = text.substring(0, text.length() - 1);
		}

		try
		{
			// Use double parsing to allow for decimals like "1.5m"
			double value = Double.parseDouble(text);
			long result = (long) (value * multiplier);

			// Check for overflow
			if (result < 0) {
				return Long.MAX_VALUE;
			}

			return result;
		}
		catch (NumberFormatException e)
		{
			throw new NumberFormatException("Invalid number format: " + text);
		}
	}
}

package com.resourcetracker;

import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.AsyncBufferedImage;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.dnd.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

public class CategoryBox extends JPanel
{
    private static final int ITEMS_PER_ROW = 5;

    private final String categoryName;
    private final ResourceTrackerPlugin plugin;
    private final ItemManager itemManager;
    private final ResourceTrackerPanel parentPanel;
    private final ChatboxPanelManager chatboxPanelManager;
    private final JPanel itemContainer = new JPanel();
    private final JPanel headerPanel = new JPanel();
    private final JLabel titleLabel = new JLabel();
    private final JPanel progressBarPanel = new JPanel();
    private final JLabel totalLabel = new JLabel();

    private List<TrackedItem> items;
    private boolean isSelected = false;

    public CategoryBox(String categoryName, ResourceTrackerPlugin plugin, ItemManager itemManager, ResourceTrackerPanel parentPanel, ChatboxPanelManager chatboxPanelManager)
    {
        this.categoryName = categoryName;
        this.plugin = plugin;
        this.itemManager = itemManager;
        this.parentPanel = parentPanel;
        this.chatboxPanelManager = chatboxPanelManager;

        setLayout(new BorderLayout(0, 1));
        setBorder(new EmptyBorder(5, 0, 0, 0));

        // Header panel with vertical layout for title row and progress bar
        headerPanel.setLayout(new BoxLayout(headerPanel, BoxLayout.Y_AXIS));
        headerPanel.setBorder(new EmptyBorder(7, 7, 7, 7));
        updateHeaderColor();

        // Title row (category name + total)
        JPanel titleRow = new JPanel();
        titleRow.setLayout(new BoxLayout(titleRow, BoxLayout.X_AXIS));
        titleRow.setOpaque(false);

        titleLabel.setText(categoryName);
        titleLabel.setFont(FontManager.getRunescapeSmallFont());
        titleLabel.setForeground(Color.WHITE);
        titleRow.add(titleLabel);
        titleRow.add(Box.createHorizontalGlue());

        totalLabel.setFont(FontManager.getRunescapeSmallFont());
        totalLabel.setForeground(new Color(200, 200, 200));
        titleRow.add(totalLabel);

        headerPanel.add(titleRow);

        // Progress bar panel
        progressBarPanel.setLayout(new BorderLayout());
        progressBarPanel.setOpaque(false);
        progressBarPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 4));
        progressBarPanel.setPreferredSize(new Dimension(0, 4));
        progressBarPanel.setBorder(new EmptyBorder(3, 0, 0, 0));
        progressBarPanel.setVisible(false); // Initially hidden
        headerPanel.add(progressBarPanel);

        add(headerPanel, BorderLayout.NORTH);
        add(itemContainer, BorderLayout.CENTER);

        // Setup drag and drop for reordering categories
        setupDragAndDrop();

        // Make header clickable for selection and collapse/expand
        headerPanel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                if (e.getButton() == MouseEvent.BUTTON1)
                {
                    if (isCollapsed())
                    {
                        // Collapsed  Expand and select
                        expand();
                        parentPanel.setSelectedCategory(categoryName);
                    }
                    else if (isSelected)
                    {
                        // Expanded and selected  Collapse (deselect)
                        collapse();
                        parentPanel.setSelectedCategory(null);
                    }
                    else
                    {
                        // Expanded but not selected  Just select it
                        parentPanel.setSelectedCategory(categoryName);
                    }
                }
            }
        });

        // Add context menu for category management
        final JPopupMenu categoryPopup = new JPopupMenu();
        categoryPopup.setBorder(new EmptyBorder(5, 5, 5, 5));

        // Category Mode Toggle
        boolean isInvOnly = plugin.isCategoryInventoryOnly(categoryName);
        JMenuItem toggleMode = new JMenuItem(isInvOnly ? "Track All Containers" : "Track Inventory Only");
        toggleMode.addActionListener(e -> {
            plugin.toggleCategoryInventoryOnly(categoryName);
        });
        categoryPopup.add(toggleMode);
        categoryPopup.addSeparator();

        JMenuItem expandItem = new JMenuItem("Expand");
        expandItem.addActionListener(e -> expand());
        categoryPopup.add(expandItem);

        JMenuItem collapseItem = new JMenuItem("Collapse");
        collapseItem.addActionListener(e -> collapse());
        categoryPopup.add(collapseItem);

        categoryPopup.addSeparator();

        JMenuItem exportCategory = new JMenuItem("Export Category");
        exportCategory.addActionListener(e -> parentPanel.exportCategory(categoryName));
        categoryPopup.add(exportCategory);

        JMenuItem importCategory = new JMenuItem("Import from Clipboard");
        importCategory.addActionListener(e -> parentPanel.importCategoryFromClipboard(categoryName));
        categoryPopup.add(importCategory);

        categoryPopup.addSeparator();

        JMenuItem resetCounts = new JMenuItem("Reset Item Counts");
        resetCounts.addActionListener(e -> {
            plugin.getClientUi().requestFocus();
            chatboxPanelManager.openTextMenuInput("Reset all item counts for '" + categoryName + "'?")
                    .option("Yes", () -> parentPanel.resetCategoryCounts(categoryName))
                    .option("No", () -> {})
                    .build();
        });
        categoryPopup.add(resetCounts);

        JMenuItem renameCategory = new JMenuItem("Rename Category");
        renameCategory.addActionListener(e -> {
            plugin.getClientUi().requestFocus();
            chatboxPanelManager.openTextInput("Enter new name for category:")
                    .onDone(newName -> {
                        if (newName != null && !newName.trim().isEmpty())
                        {
                            parentPanel.renameCategory(categoryName, newName.trim());
                        }
                    })
                    .build();
        });
        categoryPopup.add(renameCategory);

        JMenuItem deleteCategory = new JMenuItem("Delete Category");
        deleteCategory.addActionListener(e -> {
            plugin.getClientUi().requestFocus();
            chatboxPanelManager.openTextMenuInput("Delete category '" + categoryName + "' and all its items?")
                    .option("Yes", () -> parentPanel.deleteCategory(categoryName))
                    .option("No", () -> {})
                    .build();
        });
        categoryPopup.add(deleteCategory);

        headerPanel.setComponentPopupMenu(categoryPopup);
    }

    public void collapse()
    {
        if (!isCollapsed())
        {
            itemContainer.setVisible(false);
            parentPanel.revalidate();
            parentPanel.repaint();
        }
    }

    public void expand()
    {
        if (isCollapsed())
        {
            itemContainer.setVisible(true);
            parentPanel.revalidate();
            parentPanel.repaint();
        }
    }

    public boolean isCollapsed()
    {
        return !itemContainer.isVisible();
    }

    public void setSelected(boolean selected)
    {
        this.isSelected = selected;
        updateBorder();
        updateHeaderColor();
    }

    public boolean isSelected()
    {
        return isSelected;
    }

    private void updateBorder()
    {
        if (isSelected)
        {
            // Selected category has a colored border (Orange left strip)
            headerPanel.setBorder(BorderFactory.createCompoundBorder(
                    BorderFactory.createMatteBorder(0, 3, 0, 0, new Color(255, 144, 64)),
                    new EmptyBorder(7, 7, 7, 7)
            ));
        }
        else
        {
            // Non-selected category has default border
            headerPanel.setBorder(new EmptyBorder(7, 7, 7, 7));
        }
        headerPanel.revalidate();
        headerPanel.repaint();
    }

    private void updateHeaderColor()
    {
        boolean isInvOnly = plugin.isCategoryInventoryOnly(categoryName);
        if (isInvOnly)
        {
            // Use a brownish color for inventory only mode
            // If selected, use a slightly lighter brown to indicate selection state
            // while preserving the "inventory only" color cue.
            headerPanel.setBackground(isSelected ? new Color(75, 55, 40) : new Color(60, 45, 30));
        }
        else
        {
            // Standard colors: Dark Gray when selected, Darker Gray when not
            headerPanel.setBackground(isSelected ? ColorScheme.DARKER_GRAY_COLOR : ColorScheme.DARKER_GRAY_COLOR.darker());
        }
    }

    public String getCategoryName()
    {
        return categoryName;
    }

    public void rebuild(List<TrackedItem> items)
    {
        this.items = items;
        buildItems();
        updateHeaderStats();
        updateHeaderColor();
    }

    private void updateHeaderStats()
    {
        // Calculate totals
        long totalContribution = 0; // Capped at the goal for each item
        long totalGoal = 0;
        boolean hasGoals = false;

        if (items != null)
        {
            for (TrackedItem item : items)
            {
                if (item.getGoalAmount() != null)
                {
                    hasGoals = true;
                    int goal = item.getGoalAmount();
                    totalGoal += goal;

                    // Cap the contribution so extra items don't hide
                    // the fact that other items are still missing.
                    totalContribution += Math.min(item.getCurrentAmount(), goal);
                }
            }
        }

        // Update total label
        if (plugin.getConfig().showCategoryTotals() && hasGoals)
        {
            // Now shows "Items Collected / Total Goal" capped at 100%
            String totalText = QuantityFormatter.formatNumber(totalContribution) +
                    " / " + QuantityFormatter.formatNumber(totalGoal);
            totalLabel.setText(totalText);
            totalLabel.setVisible(true);
        }
        else
        {
            totalLabel.setVisible(false);
        }

        // Update progress bar
        if (plugin.getConfig().showCategoryProgress() && hasGoals && totalGoal > 0)
        {
            double progress = (double) totalContribution / totalGoal;
            updateProgressBar(progress);
            progressBarPanel.setVisible(true);
        }
        else
        {
            progressBarPanel.setVisible(false);
        }

        headerPanel.revalidate();
        headerPanel.repaint();
    }

    private void updateProgressBar(double progress)
    {
        progressBarPanel.removeAll();

        JPanel progressBar = new JPanel()
        {
            @Override
            protected void paintComponent(Graphics g)
            {
                super.paintComponent(g);
                Graphics2D g2d = (Graphics2D) g;
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                int width = getWidth();
                int height = getHeight();

                // Background (dark gray)
                g2d.setColor(ColorScheme.DARK_GRAY_COLOR.darker());
                g2d.fillRect(0, 0, width, height);

                // Progress fill
                int progressWidth = (int) (width * Math.min(1.0, progress));
                if (progressWidth > 0)
                {
                    // Color based on progress
                    Color progressColor;
                    if (progress >= 1.0)
                    {
                        progressColor = new Color(0, 200, 0); // Green when complete
                    }
                    else if (progress >= 0.75)
                    {
                        progressColor = new Color(100, 200, 100); // Light green
                    }
                    else if (progress >= 0.5)
                    {
                        progressColor = new Color(255, 200, 0); // Yellow
                    }
                    else if (progress >= 0.25)
                    {
                        progressColor = new Color(255, 150, 0); // Orange
                    }
                    else
                    {
                        progressColor = new Color(200, 100, 100); // Light red
                    }

                    g2d.setColor(progressColor);
                    g2d.fillRect(0, 0, progressWidth, height);
                }
            }
        };

        progressBar.setOpaque(false);
        progressBarPanel.add(progressBar, BorderLayout.CENTER);
    }

    private void buildItems()
    {
        itemContainer.removeAll();

        if (items == null || items.isEmpty())
        {
            itemContainer.setVisible(true);
            itemContainer.setLayout(new BorderLayout());
            JLabel emptyLabel = new JLabel("No items");
            emptyLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            emptyLabel.setHorizontalAlignment(SwingConstants.CENTER);
            emptyLabel.setBorder(new EmptyBorder(10, 10, 10, 10));
            itemContainer.add(emptyLabel, BorderLayout.CENTER);
            itemContainer.setPreferredSize(new Dimension(0, 30));
            itemContainer.revalidate();
            return;
        }

        itemContainer.setVisible(true);

        // Calculate rows needed
        final int rowSize = ((items.size() % ITEMS_PER_ROW == 0) ? 0 : 1) + items.size() / ITEMS_PER_ROW;

        itemContainer.setLayout(new GridLayout(rowSize, ITEMS_PER_ROW, 1, 1));


        for (TrackedItem item : items)
        {
            itemContainer.add(createTrackedItemBox(item));
        }

        // Fill remaining slots with empty panels
        int itemsAdded = items.size();
        for (int i = itemsAdded; i < rowSize * ITEMS_PER_ROW; i++)
        {
            final JPanel emptySlot = new JPanel();
            emptySlot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            itemContainer.add(emptySlot);
        }

        itemContainer.revalidate();
    }

    private JPanel createTrackedItemBox(TrackedItem item)
    {
        JPanel slotContainer = new JPanel(new BorderLayout());
        slotContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // FIX: Ensure consistent sizing by adding a border in both cases
        if (item.isInventoryOnly())
        {
            // 1px colored border
            slotContainer.setBorder(BorderFactory.createLineBorder(ColorScheme.PROGRESS_INPROGRESS_COLOR, 1));
        }
        else
        {
            // 1px transparent border to match size
            slotContainer.setBorder(BorderFactory.createEmptyBorder(1, 1, 1, 1));
        }

        JPanel centerPanel = new JPanel(null);
        centerPanel.setOpaque(false);
        centerPanel.setPreferredSize(new Dimension(40, 40));

        // Current amount (top-left, yellow)
        JLabel currentLabel = new JLabel();
        QuantityFormatter.formatLabel(currentLabel, item.getCurrentAmount(), Color.YELLOW, false);
        currentLabel.setFont(FontManager.getRunescapeSmallFont());
        currentLabel.setBounds(1, 0, 38, 12);
        centerPanel.add(currentLabel);

        // Goal amount (bottom-right, white)
        if (item.getGoalAmount() != null)
        {
            JLabel goalLabel = new JLabel();
            QuantityFormatter.formatLabel(goalLabel, item.getGoalAmount(), Color.WHITE, true);
            goalLabel.setFont(FontManager.getRunescapeSmallFont());
            goalLabel.setHorizontalAlignment(SwingConstants.RIGHT);
            goalLabel.setBounds(0, 28, 40, 12);
            centerPanel.add(goalLabel);
        }

        // Item icon (centered)
        JLabel iconLabel = new JLabel();
        iconLabel.setToolTipText(buildItemTooltip(item));
        iconLabel.setVerticalAlignment(SwingConstants.CENTER);
        iconLabel.setHorizontalAlignment(SwingConstants.CENTER);
        AsyncBufferedImage itemImage = itemManager.getImage(item.getItemId());
        itemImage.addTo(iconLabel);
        iconLabel.setBounds(0, 0, 40, 40);
        centerPanel.add(iconLabel);

        slotContainer.add(centerPanel, BorderLayout.CENTER);

        // Progress bar at bottom
        if (item.getGoalAmount() != null && item.getGoalAmount() > 0)
        {
            JPanel progressBar = new JPanel()
            {
                @Override
                protected void paintComponent(Graphics g)
                {
                    super.paintComponent(g);
                    if (item.getGoalAmount() != null && item.getGoalAmount() > 0)
                    {
                        float progress = Math.min(1.0f, (float) item.getCurrentAmount() / item.getGoalAmount());
                        Color barColor = progress < 0.33f ? new Color(200, 0, 0)
                                : progress < 0.67f ? new Color(255, 165, 0)
                                : progress < 1.0f ? new Color(255, 200, 0)
                                : new Color(0, 200, 0);
                        g.setColor(barColor);
                        g.fillRect(0, 0, (int) (getWidth() * progress), getHeight());
                    }
                }
            };
            progressBar.setPreferredSize(new Dimension(40, 2));
            progressBar.setOpaque(false);
            slotContainer.add(progressBar, BorderLayout.SOUTH);
        }

        // Context menu
        final JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));

        JMenuItem editItem = new JMenuItem("Edit Goal");
        editItem.addActionListener(ev -> openEditDialog(item));
        popupMenu.add(editItem);

        // Inventory Only Toggle (Item Level)
        JMenuItem toggleInvOnly = new JMenuItem(item.isInventoryOnly() ? "Track All Inventories" : "Track Inventory Only");
        toggleInvOnly.addActionListener(ev -> {
            item.setInventoryOnly(!item.isInventoryOnly());
            plugin.saveData();
            plugin.updateTrackedItems(); // Force update to refresh count
        });
        popupMenu.add(toggleInvOnly);

        JMenuItem deleteItem = new JMenuItem("Remove");
        deleteItem.addActionListener(ev -> parentPanel.removeTrackedItem(item.getItemId(), item.getCategory()));
        popupMenu.add(deleteItem);

        setComponentPopupMenu(slotContainer, popupMenu);

        return slotContainer;
    }

    private void setComponentPopupMenu(Component component, final JPopupMenu popup)
    {
        if (component instanceof JComponent)
        {
            ((JComponent) component).setComponentPopupMenu(popup);
        }

        if (component instanceof Container)
        {
            for (Component c : ((Container) component).getComponents())
            {
                setComponentPopupMenu(c, popup);
            }
        }
    }

    private void openEditDialog(TrackedItem item)
    {
        chatboxPanelManager.openTextInput("Enter new goal for " + item.getItemName() + ":")
                .onDone((Consumer<String>) (input) -> {
                    SwingUtilities.invokeLater(() -> {
                        try
                        {
                            Integer newGoal = null;
                            if (input != null && !input.trim().isEmpty())
                            {
                                long parsedGoal = QuantityFormatter.parseQuantity(input.trim());
                                if (parsedGoal > QuantityFormatter.getMaxStackSize())
                                {
                                    parsedGoal = QuantityFormatter.getMaxStackSize();
                                }

                                if (parsedGoal > 0)
                                {
                                    newGoal = (int) parsedGoal;
                                }
                            }

                            item.setGoalAmount(newGoal);
                            plugin.saveData();
                            parentPanel.rebuild();
                        }
                        catch (NumberFormatException ex)
                        {
                            plugin.sendChatMessage("Please enter a valid number.");
                        }
                    });
                })
                .build();
    }

    private String buildItemTooltip(TrackedItem item)
    {
        StringBuilder tooltip = new StringBuilder("<html><b>").append(item.getItemName()).append("</b>");

        int quantity = item.getCurrentAmount();
        if (quantity > 0)
        {
            tooltip.append(" x ").append(QuantityFormatter.formatNumber(quantity));
        }

        // Add GE price if available
        if (item.getGePrice() > 0)
        {
            long totalGePrice = item.getTotalGePrice();
            tooltip.append("<br>GE: ").append(QuantityFormatter.formatNumber(totalGePrice));
            if (quantity > 1)
            {
                tooltip.append(" (").append(QuantityFormatter.formatNumber(item.getGePrice())).append(" ea)");
            }
        }

        // Add HA price if available (skip for coins and platinum tokens)
        if (item.getHaPrice() > 0 && item.getItemId() != 995 && item.getItemId() != 13204)
        {
            long totalHaPrice = item.getTotalHaPrice();
            tooltip.append("<br>HA: ").append(QuantityFormatter.formatNumber(totalHaPrice));
            if (quantity > 1)
            {
                tooltip.append(" (").append(QuantityFormatter.formatNumber(item.getHaPrice())).append(" ea)");
            }
        }

        // Add container breakdown
        Map<String, Integer> containers = item.getContainerQuantities();
        if (containers != null && !containers.isEmpty())
        {
            tooltip.append("<br><br><b>Locations:</b>");
            containers.entrySet().stream()
                    .filter(e -> e.getValue() > 0)
                    .sorted(Map.Entry.comparingByKey())
                    .forEach(e -> tooltip.append("<br>")
                            .append(e.getKey())
                            .append(": ")
                            .append(String.format("%,d", e.getValue())));
        }

        tooltip.append("</html>");
        return tooltip.toString();
    }

    private void setupDragAndDrop()
    {
        // Make the header panel draggable
        headerPanel.setTransferHandler(new TransferHandler("text")
        {
            @Override
            public int getSourceActions(JComponent c)
            {
                return MOVE;
            }

            @Override
            protected Transferable createTransferable(JComponent c)
            {
                return new StringSelection(categoryName);
            }
        });

        // Enable drag gesture
        headerPanel.addMouseMotionListener(new MouseAdapter()
        {
            @Override
            public void mouseDragged(MouseEvent e)
            {
                JComponent comp = (JComponent) e.getSource();
                TransferHandler handler = comp.getTransferHandler();
                handler.exportAsDrag(comp, e, TransferHandler.MOVE);
            }
        });

        // Create a shared drop handler for better responsiveness
        DropTargetAdapter dropHandler = new DropTargetAdapter()
        {
            @Override
            public void drop(DropTargetDropEvent dtde)
            {
                try
                {
                    dtde.acceptDrop(DnDConstants.ACTION_MOVE);
                    String draggedCategoryName = (String) dtde.getTransferable().getTransferData(DataFlavor.stringFlavor);

                    // Don't drop on self
                    if (!draggedCategoryName.equals(categoryName))
                    {
                        // Get the index of this category
                        List<String> order = plugin.getCategoryOrder();
                        int targetIndex = order.indexOf(categoryName);

                        // Move the dragged category to this position
                        if (targetIndex >= 0)
                        {
                            plugin.moveCategoryOrder(draggedCategoryName, targetIndex);
                        }
                    }

                    dtde.dropComplete(true);
                }
                catch (Exception e)
                {
                    dtde.dropComplete(false);
                }
                finally
                {
                    // Restore border
                    setBorder(new EmptyBorder(5, 0, 0, 0));
                    headerPanel.setBorder(new EmptyBorder(7, 7, 7, 7));
                }
            }

            @Override
            public void dragOver(DropTargetDragEvent dtde)
            {
                // Visual feedback - highlight border when dragging over
                setBorder(BorderFactory.createCompoundBorder(
                        BorderFactory.createLineBorder(new Color(255, 144, 64), 2),
                        new EmptyBorder(3, 0, 0, 0)
                ));
                // Also highlight the header
                headerPanel.setBorder(BorderFactory.createCompoundBorder(
                        new EmptyBorder(0, 0, 0, 0),
                        new EmptyBorder(7, 7, 7, 7)
                ));
            }

            @Override
            public void dragExit(DropTargetEvent dte)
            {
                // Remove highlight when drag exits
                setBorder(new EmptyBorder(5, 0, 0, 0));
                headerPanel.setBorder(new EmptyBorder(7, 7, 7, 7));
            }
        };

        // Setup drop target on both the category box AND the header panel
        // This ensures collapsed categories are easy to target
        new DropTarget(this, dropHandler);
        new DropTarget(headerPanel, dropHandler);
    }
}
package com.resourcetracker;

import lombok.Data;
import java.util.HashMap;
import java.util.Map;

@Data
public class TrackedItem
{
    private int itemId;
    private String itemName;
    private int startingAmount;
    private int currentAmount;
    private String category;
    private Integer goalAmount;
    private Map<String, Integer> containerQuantities = new HashMap<>();
    private int gePrice; // Grand Exchange price
    private int haPrice; // High Alchemy price
    private boolean inventoryOnly = false;

    // No-argument constructor for Gson deserialization
    public TrackedItem()
    {
        this.containerQuantities = new HashMap<>();
    }

    public TrackedItem(int itemId, String itemName, Integer goalAmount, String category)
    {
        this.itemId = itemId;
        this.itemName = itemName;
        this.currentAmount = 0;
        this.goalAmount = goalAmount;
        this.category = category;
        this.containerQuantities = new HashMap<>();
    }

    public void setContainerQuantities(Map<String, Integer> containerQuantities)
    {
        this.containerQuantities = (containerQuantities == null) ? new HashMap<>() : containerQuantities;
    }

    public long getTotalGePrice()
    {
        return (long) gePrice * currentAmount;
    }

    public long getTotalHaPrice()
    {
        return (long) haPrice * currentAmount;
    }
}
package com.resourcetracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ResourceTrackerPlugin.class);
		RuneLite.main(args);
	}
}
