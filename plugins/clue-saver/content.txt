/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import org.apache.commons.lang3.StringUtils;

public enum ClueLocation
{
	BANK,
	INVENTORY,
	UNKNOWN;

	@Override
	public String toString()
	{
		return StringUtils.lowerCase(super.toString());
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import lombok.Getter;
import org.apache.commons.lang3.StringUtils;

@Getter
public enum ClueTier
{
	BEGINNER(0),
	EASY(1),
	MEDIUM(2),
	HARD(3),
	ELITE(4),
	MASTER(5);

	private final int value;

	ClueTier(int value)
	{
		this.value = value;
	}

	@Override
	public String toString()
	{
		return StringUtils.capitalize(StringUtils.lowerCase(super.toString()));
	}
}

package com.cluesaver;

import com.cluesaver.ids.Caskets;
import com.cluesaver.ids.ClueScrolls;
import com.cluesaver.ids.ImplingJars;
import com.cluesaver.ids.ScrollBox;
import java.util.List;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.events.MenuOptionClicked;

public class ClueStates
{
	private final Client client;
	private final ClueSaverUtils scrollBoxUtils;

	@Inject
	public ClueStates(Client client, ClueSaverUtils scrollBoxUtils)
	{
		this.client = client;
		this.scrollBoxUtils = scrollBoxUtils;
	}

	private final Integer beginnerClueId =  ItemID.CLUE_SCROLL_BEGINNER;
	private final List<Integer> easyClueIds = ClueScrolls.getEasyIds();
	private final List<Integer> mediumClueIds = ClueScrolls.getMediumIds();
	private final List<Integer> hardClueIds = ClueScrolls.getHardIds();
	private final List<Integer> eliteClueIds = ClueScrolls.getEliteIds();
	private final Integer masterClueId = ItemID.CLUE_SCROLL_MASTER;

	private final ClueScrollState beginnerClueState = new ClueScrollState(ClueTier.BEGINNER);
	private final ClueScrollState easyClueState = new ClueScrollState(ClueTier.EASY);
	private final ClueScrollState mediumClueState = new ClueScrollState(ClueTier.MEDIUM);
	private final ClueScrollState hardClueState = new ClueScrollState(ClueTier.HARD);
	private final ClueScrollState eliteClueState = new ClueScrollState(ClueTier.ELITE);
	private final ClueScrollState masterClueState = new ClueScrollState(ClueTier.MASTER);

	private final ScrollBoxState beginnerBoxState  = new ScrollBoxState(ClueTier.BEGINNER);
	private final ScrollBoxState easyBoxState  = new ScrollBoxState(ClueTier.EASY);
	private final ScrollBoxState mediumBoxState = new ScrollBoxState(ClueTier.MEDIUM);
	private final ScrollBoxState hardBoxState = new ScrollBoxState(ClueTier.HARD);
	private final ScrollBoxState eliteBoxState = new ScrollBoxState(ClueTier.ELITE);
	private final ScrollBoxState masterBoxState  = new ScrollBoxState(ClueTier.MASTER);

	public void trackBankEvents(MenuOptionClicked event)
	{
		boolean depositEvent = event.getMenuOption().contains("Deposit");
		boolean withdrawEvent = event.getMenuOption().contains("Withdraw");

		// Deposited clue scrolls
		if (beginnerClueId == event.getItemId())  beginnerClueState.setDeposited(depositEvent);
		if (easyClueIds.contains(event.getItemId()))  easyClueState.setDeposited(depositEvent);
		if (mediumClueIds.contains(event.getItemId()))  mediumClueState.setDeposited(depositEvent);
		if (hardClueIds.contains(event.getItemId()))  hardClueState.setDeposited(depositEvent);
		if (eliteClueIds.contains(event.getItemId()))  eliteClueState.setDeposited(depositEvent);
		if (masterClueId == event.getItemId())  masterClueState.setDeposited(depositEvent);
		// Deposited scroll boxes
		if (ScrollBox.CLUE_SCROLL_BOX_BEGINNER == event.getItemId())  beginnerBoxState.setDeposited(depositEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_EASY == event.getItemId())  easyBoxState.setDeposited(depositEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_MEDIUM == event.getItemId())  mediumBoxState.setDeposited(depositEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_HARD == event.getItemId())  hardBoxState.setDeposited(depositEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_ELITE == event.getItemId())  eliteBoxState.setDeposited(depositEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_MASTER == event.getItemId())  masterBoxState.setDeposited(depositEvent);
		// Withdrawn scroll boxes
		if (ScrollBox.CLUE_SCROLL_BOX_BEGINNER == event.getItemId()) beginnerBoxState.setWithdrawn(withdrawEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_EASY == event.getItemId()) easyBoxState.setWithdrawn(withdrawEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_MEDIUM == event.getItemId()) mediumBoxState.setWithdrawn(withdrawEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_HARD == event.getItemId()) hardBoxState.setWithdrawn(withdrawEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_ELITE == event.getItemId()) eliteBoxState.setWithdrawn(withdrawEvent);
		if (ScrollBox.CLUE_SCROLL_BOX_MASTER == event.getItemId()) masterBoxState.setWithdrawn(withdrawEvent);
	}

	public void setDepositedState()
	{
		beginnerClueState.setDeposited(true);
		easyClueState.setDeposited(true);
		mediumClueState.setDeposited(true);
		hardClueState.setDeposited(true);
		eliteClueState.setDeposited(true);
		masterClueState.setDeposited(true);
	}

	public void updateWidgetClosed()
	{
		updatePrevInventory(beginnerBoxState);
		updatePrevInventory(easyBoxState);
		updatePrevInventory(mediumBoxState);
		updatePrevInventory(hardBoxState);
		updatePrevInventory(eliteBoxState);
		updatePrevInventory(masterBoxState);
	}

	private void updatePrevInventory(ScrollBoxState state)
	{
		if (state.isWithdrawn() || state.isDeposited())
		{
			state.setPrevInventoryCount(state.getInventoryCount());
		}
	}

	public void updateMasterReward(boolean bool)
	{
		masterBoxState.setInReward(bool);
	}

	public boolean isMasterInReward()
	{
		return masterBoxState.isInReward();
	}

	public void checkContainer(ItemContainer container, ClueLocation location)
	{
		scrollBoxUtils.setClueLocation(container, location, beginnerClueId, beginnerClueState);
		scrollBoxUtils.setClueLocation(container, location, easyClueIds, easyClueState);
		scrollBoxUtils.setClueLocation(container, location, mediumClueIds, mediumClueState);
		scrollBoxUtils.setClueLocation(container, location, hardClueIds, hardClueState);
		scrollBoxUtils.setClueLocation(container, location, eliteClueIds, eliteClueState);
		scrollBoxUtils.setClueLocation(container, location, masterClueId, masterClueState);

		scrollBoxUtils.setBoxLocation(container, location, ScrollBox.CLUE_SCROLL_BOX_BEGINNER, beginnerBoxState);
		scrollBoxUtils.setBoxLocation(container, location, ScrollBox.CLUE_SCROLL_BOX_EASY, easyBoxState);
		scrollBoxUtils.setBoxLocation(container, location, ScrollBox.CLUE_SCROLL_BOX_MEDIUM, mediumBoxState);
		scrollBoxUtils.setBoxLocation(container, location, ScrollBox.CLUE_SCROLL_BOX_HARD, hardBoxState);
		scrollBoxUtils.setBoxLocation(container, location, ScrollBox.CLUE_SCROLL_BOX_ELITE, eliteBoxState);
		scrollBoxUtils.setBoxLocation(container, location, ScrollBox.CLUE_SCROLL_BOX_MASTER, masterBoxState);
	}

	public ClueScrollState getClueStateFromTier(ClueTier tier)
	{
		if (tier == ClueTier.BEGINNER) return beginnerClueState;
		if (tier == ClueTier.EASY) return easyClueState;
		if (tier == ClueTier.MEDIUM) return mediumClueState;
		if (tier == ClueTier.HARD) return hardClueState;
		if (tier == ClueTier.ELITE) return eliteClueState;
		if (tier == ClueTier.MASTER) return masterClueState;
		return null;
	}

	public ScrollBoxState getBoxStateFromTier(ClueTier tier)
	{
		if (tier == ClueTier.BEGINNER) return beginnerBoxState;
		if (tier == ClueTier.EASY) return easyBoxState;
		if (tier == ClueTier.MEDIUM) return mediumBoxState;
		if (tier == ClueTier.HARD) return hardBoxState;
		if (tier == ClueTier.ELITE) return eliteBoxState;
		if (tier == ClueTier.MASTER) return masterBoxState;
		return null;
	}

	public ClueTier getTierFromItemId(ClueSaverConfig config, int itemId)
	{
		if ((config.beginnerEnabled() && maxedBeginners()) && // Account for overlap in implings
			(ScrollBox.CLUE_SCROLL_BOX_BEGINNER == itemId
			|| beginnerClueId == itemId
			|| (ImplingJars.beginnerIds).contains(itemId)))
		{
			return ClueTier.BEGINNER;
		}
		if ((config.easyEnabled() && maxedEasies()) && // Account for overlap in implings
			(ScrollBox.CLUE_SCROLL_BOX_EASY == itemId
			|| easyClueIds.contains(itemId)
			|| (ImplingJars.easyIds).contains(itemId)))
		{
			return ClueTier.EASY;
		}
		if (ScrollBox.CLUE_SCROLL_BOX_MEDIUM == itemId
			|| mediumClueIds.contains(itemId)
			|| (ImplingJars.mediumIds).contains(itemId))
		{
			return ClueTier.MEDIUM;
		}
		if (ScrollBox.CLUE_SCROLL_BOX_HARD == itemId
			|| hardClueIds.contains(itemId)
			|| (ImplingJars.hardIds).contains(itemId))
		{
			return ClueTier.HARD;
		}
		if (ScrollBox.CLUE_SCROLL_BOX_ELITE == itemId
			|| eliteClueIds.contains(itemId)
			|| (ImplingJars.eliteIds).contains(itemId)
			|| ItemID.DARK_TOTEM == itemId
			)
		{
			return ClueTier.ELITE;
		}
		if (ScrollBox.CLUE_SCROLL_BOX_MASTER == itemId
			|| masterClueId == itemId
			|| (Caskets.itemIds).contains(itemId))
		{
			return ClueTier.MASTER;
		}
		return null;
	}

	public boolean maxedTier(ClueScrollState clueState, ScrollBoxState boxState)
	{
		// Max scroll boxes for particular tier
		int tierBonus = ClueSaverUtils.getMaxClueCount(clueState.tier, client);
		// Clue scroll in possession or scroll box in reward reduces max scroll boxes
		int modifier = 0;

		boolean hasClue = !clueState.getLocation().equals(ClueLocation.UNKNOWN);
		if (hasClue)
		{
			modifier = boxState.isInReward() ? 2 : 1;
		}
		else if (boxState.isInReward())
		{
			modifier = 1;
		}
		return boxState.getTotalCount() >= (tierBonus - modifier);
	}

	public boolean shouldShow(ClueSaverConfig config)
	{
		return shouldShowBeginner(config)
			|| shouldShowEasy(config)
			|| shouldShowMedium(config)
			|| shouldShowHard(config)
			|| shouldShowElite(config)
			|| shouldShowMaster(config);
	}

	public boolean shouldShowBeginner(ClueSaverConfig config)
	{
		return config.beginnerEnabled() && (maxedBeginners() || config.showBeginnerInfo());
	}

	public boolean shouldShowEasy(ClueSaverConfig config)
	{
		return config.easyEnabled() && (maxedEasies() || config.showEasyInfo());
	}

	public boolean shouldShowMedium(ClueSaverConfig config)
	{
		return config.mediumEnabled() && (maxedMediums() || config.showMediumInfo());
	}

	public boolean shouldShowHard(ClueSaverConfig config)
	{
		return config.hardEnabled() && (maxedHards() || config.showHardInfo());
	}

	public boolean shouldShowElite(ClueSaverConfig config)
	{
		return config.eliteEnabled() && (maxedElites() || config.showEliteInfo());
	}

	public boolean shouldShowMaster(ClueSaverConfig config)
	{
		return config.masterEnabled() && (maxedMasters() || config.showMasterInfo());
	}

	public boolean maxedBeginners()
	{
		return maxedTier(beginnerClueState, beginnerBoxState);
	}

	public boolean maxedEasies()
	{
		return maxedTier(easyClueState, easyBoxState);
	}

	public boolean maxedMediums()
	{
		return maxedTier(mediumClueState, mediumBoxState);
	}

	public boolean maxedHards()
	{
		return maxedTier(hardClueState, hardBoxState);
	}

	public boolean maxedElites()
	{
		return maxedTier(eliteClueState, eliteBoxState);
	}

	public boolean maxedMasters()
	{
		return maxedTier(masterClueState, masterBoxState);
	}

	public void setFromTierState(TierState loadedTierData, ClueTier tier)
	{
		// Update tier clue scroll state from config
		ClueScrollState scrollState = getClueStateFromTier(tier);
		scrollState.setLocation(loadedTierData.getClueScrollLocation());

		// Update tier scroll box state from config
		ScrollBoxState boxState = getBoxStateFromTier(tier);
		boxState.setInventoryCount(loadedTierData.getScrollBoxInventoryCount());
		boxState.setBankCount(loadedTierData.getScrollBoxBankCount());
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import lombok.Data;
import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
@Data
public class TierState
{
	public ClueLocation clueScrollLocation;
	public int scrollBoxInventoryCount;
	public int scrollBoxBankCount;

	public TierState()
	{
		this.clueScrollLocation = ClueLocation.UNKNOWN;
		this.scrollBoxInventoryCount = 0;
		this.scrollBoxBankCount = 0;
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import lombok.Data;
import lombok.Getter;
import lombok.Setter;

@Getter
@Data
public class ClueScrollState
{
	public ClueTier tier;
	@Setter
	public ClueLocation location;
	@Setter
	public boolean deposited;

	public ClueScrollState(ClueTier tier)
	{
		this.tier = tier;
		this.location = ClueLocation.UNKNOWN;
		this.deposited = false;
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import com.cluesaver.ids.GoldChest;
import com.cluesaver.ids.ImplingJars;
import com.cluesaver.ids.ScrollBox;
import com.cluesaver.ids.ToaChest;
import com.cluesaver.ids.TobChest;
import com.google.inject.Provides;
import java.awt.Color;
import java.util.Objects;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.DecorativeObject;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.GroundObject;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.ObjectID;
import net.runelite.api.Point;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.MenuShouldLeftClick;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.RuneScapeProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.input.MouseManager;

@Slf4j
@PluginDescriptor(
	name = "Clue Saver"
)
public class ClueSaverPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	private InfoBox infoBox = null;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	PluginManager pluginManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ClueSaverOverlay infoOverlay;

	@Inject
	private ClueSaverConfig config;

	@Inject
	private ClueSaverUtils scrollBoxUtils;

	@Inject
	private ClueSaverUI clueSaverUI;

	@Inject
	@Getter
	private ClueStates clueStates;

	@Getter
	@Inject
	private TierStateSaveManager tierSaveManager;

	@Inject
	private MouseManager mouseManager;

	private boolean profileChanged;
	private int casketCooldown;
	private boolean loggingIn;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(infoOverlay);
		tierSaveManager.loadStateFromConfig();
		overlayManager.add(clueSaverUI);
		clueSaverUI.setVisible(true);
		mouseManager.registerMouseListener(clueSaverUI);
		loggingIn = true;
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(infoOverlay);
		removeInfoBox();
		tierSaveManager.saveStateToConfig();
		overlayManager.remove(clueSaverUI);
		clueSaverUI.setVisible(false);
		mouseManager.unregisterMouseListener(clueSaverUI);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN)
		{
			tierSaveManager.saveStateToConfig();
		}

		if (event.getGameState() == GameState.LOGGED_IN)
		{
			if (profileChanged)
			{
				profileChanged = false;
				tierSaveManager.loadStateFromConfig();
			}
		}

		if (event.getGameState() == GameState.LOGGING_IN)
		{
			loggingIn = true;
		}
	}

	@Subscribe
	public void onRuneScapeProfileChanged(RuneScapeProfileChanged event)
	{
		profileChanged = true;
	}

	@Subscribe(priority = 100)
	private void onClientShutdown(ClientShutdown event)
	{
		tierSaveManager.saveStateToConfig();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		// TODO: Normalize config group
		if (event.getGroup().equals("ClueSaver")
			|| event.getGroup().equals(ClueSaverConfig.GROUP))
		{
			clueSaverUI.onConfigChanged();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (event.getContainerId() == InventoryID.INVENTORY.getId())
		{
			checkBank();
			clueStates.checkContainer(event.getItemContainer(), ClueLocation.INVENTORY);
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == InterfaceID.BANK)
		{
			checkBank();
		}
		else if (event.getGroupId() == InterfaceID.CLUESCROLL_REWARD)
		{
			checkReward();
		}
	}

	private void checkBank()
	{
		ItemContainer bankContainer = client.getItemContainer(InventoryID.BANK);

		if (bankContainer != null)
		{
			clueStates.checkContainer(bankContainer, ClueLocation.BANK);
		}
	}

	// Consider scroll boxes in reward screen which count toward max
	private void checkReward()
	{
		final Widget clueScrollReward = client.getWidget(ComponentID.CLUESCROLL_REWARD_ITEM_CONTAINER);

		for (Widget widget : Objects.requireNonNull(clueScrollReward.getChildren()))
		{
			if (widget.getItemId() == ScrollBox.CLUE_SCROLL_BOX_MASTER)
			{
				clueStates.updateMasterReward(true);
			}
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event)
	{
		if (event.getGroupId() == InterfaceID.BANK)
		{
			clueStates.updateWidgetClosed();
		}
		else if (event.getGroupId() == InterfaceID.CLUESCROLL_REWARD
			&& clueStates.isMasterInReward())
		{
			clueStates.updateMasterReward(false);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		// Track event options to detect banking edge cases
		clueStates.trackBankEvents(event);

		// If impling saver is active
		if (event.isItemOp() && ImplingJars.itemIds.contains(event.getItemId()) && event.getMenuOption().equals("Loot"))
		{
			// Consume Impling Loot events
			saveImpling(event);
		}

		// If elite clue method saver is active
		if (config.saveGoldKeys()
			|| config.saveDarkTotems()
			|| config.saveToaRewardsChests()
			|| config.saveTobRewardsChests()
			|| config.saveGauntletRewardChests())
		{
			MenuEntry entry = event.getMenuEntry();
			int objectId = objectIdForEntry(entry);

			// Consume clue method events
			if (objectId != -1 && isEliteClueMethodToSave(objectId, entry.getOption()))
			{
				if (clueStates.maxedElites())
				{
					saveClue(event, ClueTier.ELITE);
				}
			}
		}

		// If master clue method saver is active
		// Consume Casket Open events
		if (event.isItemOp() && isMasterClueMethodToSave(event.getItemId()) && event.getMenuOption().equals("Open"))
		{
			if (clueStates.maxedMasters())
			{
				saveCasket(event);
			}

			if (config.casketCooldown())
			{
				if (casketCooldown == 0)
				{
					casketCooldown = 1;
				}
				else
				{
					event.consume();
				}
			}
		}
	}

	public boolean isEliteClueMethodToSave(Integer itemId)
	{
		return itemId == ItemID.DARK_TOTEM;
	}

	public boolean isEliteClueMethodToSave(Integer objectId, String menuOption)
	{
		// Save Dark totems
		if (config.saveDarkTotems() && objectId == ObjectID.ALTAR_28900 && menuOption.equals("Use"))
		{
			return true;
		}

		// Save Gold keys
		if (config.saveGoldKeys() && GoldChest.getItemIds().contains(objectId) && menuOption.equals("Open"))
		{
			return true;
		}

		// Save Gauntlet Reward Chests
		if (config.saveGauntletRewardChests() && objectId == ObjectID.REWARD_CHEST_36087 && menuOption.equals("Open"))
		{
			return true;
		}

		// Save ToA Rewards Chests
		if (config.saveToaRewardsChests() && ToaChest.getItemIds().contains(objectId)
			&& (menuOption.equals("Open") || menuOption.equals("Claim")))
		{
			return true;
		}

		// Save ToB Rewards Chests
		if (config.saveTobRewardsChests() && TobChest.getItemIds().contains(objectId)
			&& (menuOption.equals("Open") || menuOption.equals("Claim")))
		{
			return true;
		}

		// TODO: Block BA gambles
		return false;
	}

	public boolean isMasterClueMethodToSave(Integer itemId)
	{
		return (itemId == ItemID.REWARD_CASKET_EASY && config.saveEasyCaskets())
			|| (itemId == ItemID.REWARD_CASKET_MEDIUM && config.saveMediumCaskets())
			|| (itemId == ItemID.REWARD_CASKET_HARD && config.saveHardCaskets())
			|| (itemId == ItemID.REWARD_CASKET_ELITE && config.saveEliteCaskets());
	}

	public boolean isImplingToSave(Integer itemId)
	{
		return (ImplingJars.beginnerIds.contains(itemId) && config.saveBeginnerImplings() && clueStates.maxedBeginners())
			|| (ImplingJars.easyIds.contains(itemId) && config.saveEasyImplings() && clueStates.maxedEasies())
			|| (ImplingJars.mediumIds.contains(itemId) && config.saveMediumImplings() && clueStates.maxedMediums())
			|| (ImplingJars.hardIds.contains(itemId) && config.saveHardImplings() && clueStates.maxedHards())
			|| (ImplingJars.eliteIds.contains(itemId) && config.saveEliteImplings() && clueStates.maxedElites());
	}

	public boolean isItemIdMethodToSave(Integer itemId)
	{
		return (isImplingToSave(itemId)
			|| isEliteClueMethodToSave(itemId)
			|| isMasterClueMethodToSave(itemId));
	}

	@Subscribe
	public void onMenuShouldLeftClick(MenuShouldLeftClick event)
	{
		MenuEntry[] menuEntries = client.getMenuEntries();
		for (MenuEntry entry : menuEntries)
		{
			if (entry.getOption().equals("Deposit inventory"))
			{
				clueStates.setDepositedState();
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		handleInfoBox();

		if (config.casketCooldown())
		{
			casketCooldown = 0;
		}

		if (loggingIn)
		{
			loggingIn = false;
			notifyPluginUninstall("ImplingSaver");
			notifyPluginUninstall("CasketSaver");
		}
	}

	@Provides
	ClueSaverConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ClueSaverConfig.class);
	}

	private void handleInfoBox()
	{
		var isShowing = infoBox != null;
		var shouldShow = config.showInfobox() && clueStates.shouldShow(config);

		if (isShowing && !shouldShow)
		{
			removeInfoBox();
		}
		else if (shouldShow)
		{
			if (!isShowing)
			{
				infoBox = new InfoBox(itemManager.getImage(ItemID.MIMIC_SCROLL_CASE), this)
				{
					@Override
					public String getText()
					{
						return "";
					}

					@Override
					public Color getTextColor()
					{
						return null;
					}
				};
			}

			infoBox.setTooltip(getInfoboxSavingCauses());

			if (!isShowing)
			{
				infoBoxManager.addInfoBox(infoBox);
			}
		}
	}

	private void removeInfoBox()
	{
		if (infoBox != null)
		{
			infoBoxManager.removeInfoBox(infoBox);
			infoBox = null;
		}
	}

	public String getInfoboxSavingCauses()
	{
		StringBuilder savingCause = new StringBuilder();

		String beginnerCause = getTierSavingCause(ClueTier.BEGINNER, config.showBeginnerInfo());
		if (beginnerCause != null) savingCause.append(beginnerCause).append("<br>");

		String easyCause = getTierSavingCause(ClueTier.EASY, config.showEasyInfo());
		if (easyCause != null) savingCause.append(easyCause).append("<br>");

		String mediumCause = getTierSavingCause(ClueTier.MEDIUM, config.showMediumInfo());
		if (mediumCause != null) savingCause.append(mediumCause).append("<br>");

		String hardCause = getTierSavingCause(ClueTier.HARD, config.showHardInfo());
		if (hardCause != null) savingCause.append(hardCause).append("<br>");

		String eliteCause = getTierSavingCause(ClueTier.ELITE, config.showEliteInfo());
		if (eliteCause != null) savingCause.append(eliteCause).append("<br>");

		String masterCause = getTierSavingCause(ClueTier.MASTER, config.showMasterInfo());
		if (masterCause != null) savingCause.append(masterCause);

		return savingCause.toString();
	}

	public StringBuilder getActiveSavingText()
	{
		return new StringBuilder()
			.append(ColorUtil.wrapWithColorTag("Clue Saver: ", Color.YELLOW))
			.append(ColorUtil.wrapWithColorTag("active", Color.GREEN))
			.append("<br>");
	}

	public String getTierSavingCause(ClueTier tier)
	{
		return getTierSavingCause(tier, false);
	}

	public String getTierSavingCause(ClueTier tier, boolean override)
	{
		if (!isEnabledTier(tier)) return null;
		ClueScrollState clueState = clueStates.getClueStateFromTier(tier);
		if (clueState == null) return null;
		ScrollBoxState boxState = clueStates.getBoxStateFromTier(tier);
		if (boxState == null) return null;

		if (!clueStates.maxedTier(clueState, boxState) && !override)
		{
			return null;
		}

		if (clueState.getLocation() == ClueLocation.UNKNOWN && boxState.getTotalCount() == 0) return null;

		StringBuilder savingCause = new StringBuilder()
			.append(ColorUtil.wrapWithColorTag(tier.toString(), Color.YELLOW))
			.append(ColorUtil.wrapWithColorTag(": ", Color.YELLOW))
			.append("<br>");

		if (clueState.getLocation() != ClueLocation.UNKNOWN)
		{
			savingCause
				.append("- Clue ")
				.append("in ")
				.append(ColorUtil.wrapWithColorTag(clueState.getLocation().toString(), Color.RED));
		}
		if (boxState.getTotalCount() > 0)
		{
			if (clueState.getLocation() != ClueLocation.UNKNOWN) savingCause.append("<br>");
			if (config.separateBoxCounts())
			{
				savingCause
					.append("- Inv Boxes: ")
					.append(ColorUtil.wrapWithColorTag(String.valueOf(boxState.getInventoryCount()), Color.RED))
					.append("<br>")
					.append("- Bank Boxes: ")
					.append(ColorUtil.wrapWithColorTag(String.valueOf(boxState.getBankCount()), Color.RED));
			}
			else
			{
				savingCause
					.append("- Scroll Boxes: ")
					.append(ColorUtil.wrapWithColorTag(String.valueOf(boxState.getTotalCount()), Color.RED));
			}
		}
		return savingCause.toString();
	}

	private boolean isEnabledTier(ClueTier tier)
	{
		if (tier == ClueTier.BEGINNER) return config.beginnerEnabled();
		if (tier == ClueTier.EASY) return config.easyEnabled();
		if (tier == ClueTier.MEDIUM) return config.mediumEnabled();
		if (tier == ClueTier.HARD) return config.hardEnabled();
		if (tier == ClueTier.ELITE) return config.eliteEnabled();
		if (tier == ClueTier.MASTER) return config.masterEnabled();
		return false;
	}

	private void saveClue(MenuOptionClicked event, ClueTier tier)
	{
		if (isEnabledTier(tier))
		{
			event.consume();
			consumeChatMessage(tier);
		}
	}

	private void saveCasket(MenuOptionClicked event)
	{
		int itemId = event.getItemId();
		if (isMasterClueMethodToSave(itemId))
		{
			saveClue(event, clueStates.getTierFromItemId(config, itemId));
		}
	}

	private void saveImpling(MenuOptionClicked event)
	{
		int itemId = event.getItemId();
		if (isImplingToSave(itemId))
		{
			saveClue(event, clueStates.getTierFromItemId(config, itemId));
		}
	}

	private void notifyPluginUninstall(String pluginName)
	{
		if (pluginManager.getPlugins().stream().anyMatch(plugin -> plugin.getName().equals(pluginName)))
		{
			sendChatConsoleMessage(pluginName + " has been integrated into Clue Saver. You may now uninstall " + pluginName);
		}
	}

	private void sendChatConsoleMessage(String chatMessage)
	{
		final String message = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append(chatMessage)
			.build();

		chatMessageManager.queue(
			QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());
	}

	private void consumeChatMessage(ClueTier tier)
	{
		if (config.showChatMessage())
		{
			String chatMessage = getActiveSavingText() + getTierSavingCause(tier).replace("<br>", " ");
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", chatMessage, "");
		}
	}

	TileObject findTileObject(int x, int y, int id)
	{
		x += (Constants.EXTENDED_SCENE_SIZE - Constants.SCENE_SIZE) / 2;
		y += (Constants.EXTENDED_SCENE_SIZE - Constants.SCENE_SIZE) / 2;
		Scene scene = client.getScene();
		Tile[][][] tiles = scene.getExtendedTiles();
		Tile tile = tiles[client.getPlane()][x][y];
		if (tile != null)
		{
			for (GameObject gameObject : tile.getGameObjects())
			{
				if (gameObject != null && gameObject.getId() == id)
				{
					return gameObject;
				}
			}

			WallObject wallObject = tile.getWallObject();
			if (wallObject != null && wallObject.getId() == id)
			{
				return wallObject;
			}

			DecorativeObject decorativeObject = tile.getDecorativeObject();
			if (decorativeObject != null && decorativeObject.getId() == id)
			{
				return decorativeObject;
			}

			GroundObject groundObject = tile.getGroundObject();
			if (groundObject != null && groundObject.getId() == id)
			{
				return groundObject;
			}
		}
		return null;
	}

	public MenuEntry hoveredMenuEntry(final MenuEntry[] menuEntries)
	{
		final int menuX = client.getMenuX();
		final int menuY = client.getMenuY();
		final int menuWidth = client.getMenuWidth();
		final Point mousePosition = client.getMouseCanvasPosition();

		int dy = mousePosition.getY() - menuY;
		dy -= 19; // Height of Choose Option
		if (dy < 0)
		{
			return menuEntries[menuEntries.length - 1];
		}

		int idx = dy / 15; // Height of each menu option
		idx = menuEntries.length - 1 - idx;

		if (mousePosition.getX() > menuX && mousePosition.getX() < menuX + menuWidth
			&& idx >= 0 && idx < menuEntries.length)
		{
			return menuEntries[idx];
		}
		return menuEntries[menuEntries.length - 1];
	}

	public Integer objectIdForEntry(MenuEntry entry)
	{
		MenuAction menuAction = entry.getType();

		switch (menuAction)
		{
			case WIDGET_TARGET_ON_GAME_OBJECT:
			case GAME_OBJECT_FIRST_OPTION:
			case GAME_OBJECT_SECOND_OPTION:
			case GAME_OBJECT_THIRD_OPTION:
			case GAME_OBJECT_FOURTH_OPTION:
			case GAME_OBJECT_FIFTH_OPTION:
			case EXAMINE_OBJECT:
			{
				int x = entry.getParam0();
				int y = entry.getParam1();
				int id = entry.getIdentifier();
				TileObject tileObject = findTileObject(x, y, id);
				if (tileObject != null)
				{
					return tileObject.getId();
				}
				break;
			}
		}
		return -1;
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("ClueSaver")
public interface ClueSaverConfig extends Config
{
	String GROUP = "cluesaver";

	String BEGINNER_STATE = "beginnerState";
	String EASY_STATE = "easyState";
	String MEDIUM_STATE = "mediumState";
	String HARD_STATE = "hardState";
	String ELITE_STATE = "eliteState";
	String MASTER_STATE = "masterState";

	@ConfigSection(name = "Overlays", description = "Options that effect overlays", position = 0)
	String overlaysSection = "Overlays";

	@ConfigItem(
		keyName = "showUI",
		name = "Show UI",
		description = "Provides a collapsible UI display on the left for clue tracking",
		section = overlaysSection,
		position = 0
	)
	default boolean showUI()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showChatMessage",
		name = "Show chat message",
		description = "Show chat message indicating when clues are being saved",
		section = overlaysSection,
		position = 1
	)
	default boolean showChatMessage()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showTooltip",
		name = "Show tooltip",
		description = "Show tooltip on clue \"Open\" hover when clues are being saved",
		section = overlaysSection,
		position = 2
	)
	default boolean showTooltip()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showInfobox",
		name = "Show infobox",
		description = "Show infobox indicating when clues are being saved",
		section = overlaysSection,
		position = 3
	)
	default boolean showInfobox()
	{
		return false;
	}

	@ConfigSection(name = "Debug", description = "Options that provide additional information", position = 7)
	String debugSection = "Debug";

	@ConfigItem(
		keyName = "separateBoxCounts",
		name = "Separate scroll box counts",
		description = "Show separate scroll box count for inventory and bank (infobox and chat overlays)",
		section = debugSection,
		position = 0
	)
	default boolean separateBoxCounts()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showBeginnerInfo",
		name = "Always show beginner state",
		description = "Always show saving state for beginner clues in UI and infobox (if enabled)",
		section = debugSection,
		position = 1
	)
	default boolean showBeginnerInfo()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showEasyInfo",
		name = "Always show easy state",
		description = "Always show saving state for easy clues in UI and infobox (if enabled)",
		section = debugSection,
		position = 2
	)
	default boolean showEasyInfo()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showMediumInfo",
		name = "Always show medium state",
		description = "Always show saving state for medium clues in UI and infobox (if enabled)",
		section = debugSection,
		position = 3
	)
	default boolean showMediumInfo()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showHardInfo",
		name = "Always show hard state",
		description = "Always show saving state for hard clues in UI and infobox (if enabled)",
		section = debugSection,
		position = 4
	)
	default boolean showHardInfo()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showEliteInfo",
		name = "Always show elite state",
		description = "Always show saving state for elite clues in UI and infobox (if enabled)",
		section = debugSection,
		position = 5
	)
	default boolean showEliteInfo()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showMasterInfo",
		name = "Always show master state",
		description = "Always show saving state for master clues in UI and infobox (if enabled)",
		section = debugSection,
		position = 6
	)
	default boolean showMasterInfo()
	{
		return false;
	}

	@ConfigSection(name = "Beginner Clues", description = "Methods that reward easy clues", position = 6)
	String beginnerSection = "Beginner Clues";

	@ConfigItem(
		keyName = "saveBeginnerImplings",
		name = "Save Beginner Implings",
		description = "Looting baby and young impling jars is blocked while player is ineligible to receive a beginner scroll box",
		section = beginnerSection,
		position = 0
	)
	default boolean saveBeginnerImplings()
	{
		return true;
	}

	@ConfigSection(name = "Easy Clues", description = "Methods that reward easy clues", position = 5)
	String easySection = "Easy Clues";

	@ConfigItem(
		keyName = "saveEasyImplings",
		name = "Save Easy Implings",
		description = "Looting baby, young, and gourmet impling jars is blocked while player is ineligible to receive an easy scroll box",
		section = easySection,
		position = 0
	)
	default boolean saveEasyImplings()
	{
		return true;
	}

	@ConfigSection(name = "Medium Clues", description = "Methods that reward medium clues", position = 4)
	String mediumSection = "Medium Clues";

	@ConfigItem(
		keyName = "saveMediumImplings",
		name = "Save Medium Implings",
		description = "Looting earth, eclectic, and essence impling jars is blocked while player is ineligible to receive a medium scroll box",
		section = mediumSection,
		position = 0
	)
	default boolean saveMediumImplings()
	{
		return true;
	}

	@ConfigSection(name = "Hard Clues", description = "Methods that reward hard clues", position = 3)
	String hardSection = "Hard Clues";

	@ConfigItem(
		keyName = "saveHardImplings",
		name = "Save Hard Implings",
		description = "Looting nature, magpie, and ninja impling jars is blocked while player is ineligible to receive a hard scroll box",
		section = hardSection,
		position = 0
	)
	default boolean saveHardImplings()
	{
		return true;
	}

	@ConfigSection(name = "Elite Clues", description = "Methods that reward elite clues", position = 2)
	String eliteSection = "Elite Clues";

	@ConfigItem(
		keyName = "saveEliteImplings",
		name = "Save Elite Implings",
		description = "Looting crystal and dragon impling jars is blocked while player is ineligible to receive an elite scroll box",
		section = eliteSection,
		position = 0
	)
	default boolean saveEliteImplings()
	{
		return true;
	}

	@ConfigItem(
		keyName = "saveDarkTotems",
		name = "Save Dark Totems",
		description = "Blocks dark totem usage while player is ineligible to receive an elite scroll box",
		section = eliteSection,
		position = 1
	)
	default boolean saveDarkTotems()
	{
		return true;
	}

	@ConfigItem(
		keyName = "saveGoldKeys",
		name = "Save Gold keys",
		description = "Blocks gold key usage while player is ineligible to receive an elite scroll box",
		section = eliteSection,
		position = 2
	)
	default boolean saveGoldKeys()
	{
		return true;
	}

	@ConfigItem(
		keyName = "saveGauntletRewardChests",
		name = "Save Gauntlet Reward Chests",
		description = "Blocks opening Gauntlet reward chest while player is ineligible to receive an elite scroll box",
		section = eliteSection,
		position = 3
	)
	default boolean saveGauntletRewardChests()
	{
		return true;
	}

	@ConfigItem(
		keyName = "saveToaRewardsChests",
		name = "Save ToA Rewards Chests",
		description = "Blocks opening ToA reward chests while player is ineligible to receive an elite scroll box",
		section = eliteSection,
		position = 4
	)
	default boolean saveToaRewardsChests()
	{
		return true;
	}

	@ConfigItem(
		keyName = "saveTobRewardsChests",
		name = "Save ToB Rewards Chests",
		description = "Blocks opening ToB reward chests while player is ineligible to receive an elite scroll box",
		section = eliteSection,
		position = 5
	)
	default boolean saveTobRewardsChests()
	{
		return true;
	}

	@ConfigSection(name = "Master Clues", description = "Methods that reward master clues", position = 1)
	String masterSection = "Master Clues";

	@ConfigItem(
		keyName = "casketCooldown",
		name = "Spamming cooldown",
		description = "Add a cooldown to the open option to help the plugin not miss master clues when spamming",
		section = masterSection,
		position = 0
	)
	default boolean casketCooldown()
	{
		return false;
	}

	@ConfigItem(
		keyName = "saveEasyCaskets",
		name = "Save Easy caskets",
		description = "Easy caskets cannot be opened while player is ineligible to receive a master scroll box",
		section = masterSection,
		position = 1
	)
	default boolean saveEasyCaskets()
	{
		return true;
	}

	@ConfigItem(
		keyName = "saveMediumCaskets",
		name = "Save Medium caskets",
		description = "Medium caskets cannot be opened while player is ineligible to receive a master scroll box",
		section = masterSection,
		position = 2
	)
	default boolean saveMediumCaskets()
	{
		return true;
	}

	@ConfigItem(
		keyName = "saveHardCaskets",
		name = "Save Hard caskets",
		description = "Hard caskets cannot be opened while player is ineligible to receive a master scroll box",
		section = masterSection,
		position = 3
	)
	default boolean saveHardCaskets()
	{
		return true;
	}

	@ConfigItem(
		keyName = "saveEliteCaskets",
		name = "Save Elite caskets",
		description = "Elite caskets cannot be opened while player is ineligible to receive a master scroll box",
		section = masterSection,
		position = 4
	)
	default boolean saveEliteCaskets()
	{
		return true;
	}

	@ConfigSection(name = "Tier Toggles", description = "Options to enable particular clue tiers", position = 8)
	String tierTogglesSection = "Tier Toggles";

	@ConfigItem(
		keyName = "beginnerEnabled",
		name = "Beginner clues",
		description = "Beginner clues are saved and displayed in overlays",
		section = tierTogglesSection,
		position = 0
	)
	default boolean beginnerEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "easyEnabled",
		name = "Easy clues",
		description = "Easy clues are saved and displayed in overlays",
		section = tierTogglesSection,
		position = 1
	)
	default boolean easyEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "mediumEnabled",
		name = "Medium clues",
		description = "Medium clues are saved and displayed in overlays",
		section = tierTogglesSection,
		position = 2
	)
	default boolean mediumEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hardEnabled",
		name = "Hard clues",
		description = "Hard clues are saved and displayed in overlays",
		section = tierTogglesSection,
		position = 3
	)
	default boolean hardEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "eliteEnabled",
		name = "Elite clues",
		description = "Elite clues are saved and displayed in overlays",
		section = tierTogglesSection,
		position = 4
	)
	default boolean eliteEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "masterEnabled",
		name = "Master clues",
		description = "Master clues are saved and displayed in overlays",
		section = tierTogglesSection,
		position = 5
	)
	default boolean masterEnabled()
	{
		return true;
	}

	@ConfigSection(name = "Interface", description = "Options that effect the UI", position = 9)
	String InterfaceSection = "Interface";

	public enum UIAnchor
	{
		LEFT,
		RIGHT
	}
	@ConfigItem(
		keyName = "uiAnchor",
		name = "UI Location",
		description = "Choose which side of the client the UI is on",
		section = InterfaceSection,
		position = 0
	)
	default UIAnchor uiAnchor()
	{
		return UIAnchor.LEFT;
	}

	@Range(min = -500, max = 500)
	@ConfigItem(
		keyName = "uiVerticalOffset",
		name = "UI Vertical Offset",
		description = "Adjusts the vertical position of the UI",
		section = InterfaceSection,
		position = 1
	)
	default int uiVerticalOffset()
	{
		return 0;
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import com.cluesaver.ids.ScrollCase;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;

// Credit to thelaakes for borrowed utiltites from scrollboxcounter
public class ClueSaverUtils
{
	private static final int BASE_CLUE_COUNT = 2;

	public static int getMaxClueCount(ClueTier tier, Client client)
	{
		int tierBonus = getTierBonus(tier, client);
		int mimicBonus = getMimicBonus(client);
		return BASE_CLUE_COUNT + tierBonus + mimicBonus;
	}

	public static int getMimicBonus(Client client)
	{
		return client.getVarbitValue(ScrollCase.SCROLL_CASE_MIMIC);
	}

	public static int getTierBonus(ClueTier tier, Client client)
	{
		int bonus = 0;

		switch (tier)
		{
			case BEGINNER:
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_BEGINNER_MINOR);
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_BEGINNER_MAJOR);
				break;
			case EASY:
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_EASY_MINOR);
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_EASY_MAJOR);
				break;
			case MEDIUM:
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_MEDIUM_MINOR);
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_MEDIUM_MAJOR);
				break;
			case HARD:
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_HARD_MINOR);
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_HARD_MAJOR);
				break;
			case ELITE:
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_ELITE_MINOR);
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_ELITE_MAJOR);
				break;
			case MASTER:
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_MASTER_MINOR);
				bonus += client.getVarbitValue(ScrollCase.SCROLL_CASE_MASTER_MAJOR);
				break;
		}
		return bonus;
	}

	public void setBoxLocation(ItemContainer container, ClueLocation location, Integer boxId, ScrollBoxState state)
	{
		// If scroll boxes found in container, update count
		if (Arrays.stream(container.getItems()).anyMatch(item -> item.getId() == boxId))
		{
			Optional<Item> scrollBox = Arrays.stream(container.getItems())
				.filter(item -> item.getId() == boxId)
				.findFirst();

			if (scrollBox.isPresent())
			{
				int count = scrollBox.get().getQuantity();
				setScrollBoxState(location, count, state);

				// Check if some boxes were withdrawn/deposited
				if (location.equals(ClueLocation.INVENTORY) && state.getPrevInventoryCount() != -1)
				{
					if (state.isWithdrawn())
					{
						// Subtract inventory difference from bank
						setScrollBoxState(
							ClueLocation.BANK,
							state.getBankCount() - (state.getInventoryCount() - state.getPrevInventoryCount()),
							state);
					}
					else if (state.isDeposited())
					{
						// Add inventory difference to bank
						setScrollBoxState(
							ClueLocation.BANK,
							state.getBankCount() + (state.getPrevInventoryCount() - state.getInventoryCount()),
							state);
					}
				}
				// Clear prevInventory count
				state.setPrevInventoryCount(-1);
			}
		}
		// If scroll box were previously located in container and not found, update location
		else
		{
			// Check if all box were banked
			if (location.equals(ClueLocation.INVENTORY)
				&& state.isDeposited())
			{
				// Add inventory count to bank
				setScrollBoxState(
					ClueLocation.BANK,
					state.getBankCount() + state.getInventoryCount(),
					state);
				// Clear inventory count
				setScrollBoxState(ClueLocation.INVENTORY, 0, state);
			}
			// Reset count for container
			else
			{
				setScrollBoxState(location, 0, state);
			}
		}
		// Reset banking edge case tracking
		state.setDeposited(false);
		state.setWithdrawn(false);
	}

	public void setClueLocation(ItemContainer container, ClueLocation location, List<Integer> clues, ClueScrollState state)
	{
		if (Arrays.stream(container.getItems()).anyMatch(item -> clues.contains(item.getId())))
		{
			setClueScrollState(location, state);
		}
		// If clue was previously located in container and not found, update location
		else if (state.getLocation().equals(location))
		{
			// Check if clue was banked
			if (location.equals(ClueLocation.INVENTORY) && state.isDeposited())
			{
				setClueScrollState(ClueLocation.BANK, state);
			}
			else
			{
				setClueScrollState(ClueLocation.UNKNOWN, state);
			}
		}
	}

	public void setClueLocation(ItemContainer container, ClueLocation location, Integer clue, ClueScrollState state)
	{
		if (Arrays.stream(container.getItems()).anyMatch(item -> item.getId() == clue))
		{
			setClueScrollState(location, state);
		}
		// If clue was previously located in container and not found, update location
		else if (state.getLocation().equals(location))
		{
			// Check if clue was banked
			if (location.equals(ClueLocation.INVENTORY) && state.isDeposited())
			{
				setClueScrollState(ClueLocation.BANK, state);
			}
			else
			{
				setClueScrollState(ClueLocation.UNKNOWN, state);
			}
		}
	}

	public void setClueScrollState(ClueLocation location, ClueScrollState state)
	{
		state.setDeposited(false);
		state.setLocation(location);
	}

	public void setScrollBoxState(ClueLocation location, Integer count, ScrollBoxState state)
	{
		if (location == ClueLocation.INVENTORY)
		{
			state.setInventoryCount(count);
		}
		if (location == ClueLocation.BANK)
		{
			state.setBankCount(count);
		}
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver.ids;

import java.util.Arrays;
import java.util.List;
import lombok.Getter;
import net.runelite.api.ObjectID;

public class TobChest
{
	@Getter
	public static final List<Integer> itemIds = Arrays.asList(
		ObjectID.MONUMENTAL_CHEST_32992, // tob treasureroom chest mine standard - Open
		ObjectID.MONUMENTAL_CHEST_32993, // tob treasureroom chest mine rare     - Open
		ObjectID.REWARDS_CHEST_41435);   // tob rewards chest lobby open 		 - Claim
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver.ids;

import java.util.Arrays;
import java.util.List;
import lombok.Getter;
import net.runelite.api.ObjectID;

public class GoldChest
{
	@Getter
	public static final List<Integer> itemIds = Arrays.asList(
		ObjectID.GOLD_CHEST, 		// 41212
		ObjectID.GOLD_CHEST_41213, 	// 41213
		ObjectID.GOLD_CHEST_41214, 	// 41214
		ObjectID.GOLD_CHEST_41215, 	// 41215
		ObjectID.GOLD_CHEST_41216); // 41216
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver.ids;

import java.util.Arrays;
import java.util.List;
import lombok.Getter;
import net.runelite.api.ItemID;

public class Caskets
{
	@Getter
	public static final List<Integer> itemIds = Arrays.asList(
		ItemID.REWARD_CASKET_EASY,
		ItemID.REWARD_CASKET_MEDIUM,
		ItemID.REWARD_CASKET_HARD,
		ItemID.REWARD_CASKET_ELITE);
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver.ids;

import java.util.Arrays;
import java.util.List;
import lombok.Getter;
import net.runelite.api.ItemID;

public class ClueScrolls
{
	@Getter
	public static final List<Integer> easyIds = Arrays.asList(
		ItemID.CLUE_SCROLL_EASY,
		ItemID.CLUE_SCROLL_EASY_2711,
		ItemID.CLUE_SCROLL_EASY_12179,
		ItemID.CLUE_SCROLL_EASY_2719,
		ItemID.CLUE_SCROLL_EASY_19823,
		ItemID.CLUE_SCROLL_EASY_10216,
		ItemID.CLUE_SCROLL_EASY_10222,
		ItemID.CLUE_SCROLL_EASY_10232,
		ItemID.CLUE_SCROLL_EASY_10188,
		ItemID.CLUE_SCROLL_EASY_3516,
		ItemID.CLUE_SCROLL_EASY_10210,
		ItemID.CLUE_SCROLL_EASY_10212,
		ItemID.CLUE_SCROLL_EASY_10192,
		ItemID.CLUE_SCROLL_EASY_10228,
		ItemID.CLUE_SCROLL_EASY_10182,
		ItemID.CLUE_SCROLL_EASY_10206,
		ItemID.CLUE_SCROLL_EASY_10220,
		ItemID.CLUE_SCROLL_EASY_10200,
		ItemID.CLUE_SCROLL_EASY_19831,
		ItemID.CLUE_SCROLL_EASY_10208,
		ItemID.CLUE_SCROLL_EASY_10180,
		ItemID.CLUE_SCROLL_EASY_12170,
		ItemID.CLUE_SCROLL_EASY_25788,
		ItemID.CLUE_SCROLL_EASY_19826,
		ItemID.CLUE_SCROLL_EASY_3510,
		ItemID.CLUE_SCROLL_EASY_22001,
		ItemID.CLUE_SCROLL_EASY_19814,
		ItemID.CLUE_SCROLL_EASY_3518,
		ItemID.CLUE_SCROLL_EASY_19833,
		ItemID.CLUE_SCROLL_EASY_10194,
		ItemID.CLUE_SCROLL_EASY_19816,
		ItemID.CLUE_SCROLL_EASY_19822,
		ItemID.CLUE_SCROLL_EASY_19820,
		ItemID.CLUE_SCROLL_EASY_10214,
		ItemID.CLUE_SCROLL_EASY_10226,
		ItemID.CLUE_SCROLL_EASY_2712,
		ItemID.CLUE_SCROLL_EASY_19818,
		ItemID.CLUE_SCROLL_EASY_7236,
		ItemID.CLUE_SCROLL_EASY_3496,
		ItemID.CLUE_SCROLL_EASY_10186,
		ItemID.CLUE_SCROLL_EASY_10224,
		ItemID.CLUE_SCROLL_EASY_19825,
		ItemID.CLUE_SCROLL_EASY_12166,
		ItemID.CLUE_SCROLL_EASY_12167,
		ItemID.CLUE_SCROLL_EASY_12168,
		ItemID.CLUE_SCROLL_EASY_3495,
		ItemID.CLUE_SCROLL_EASY_3515,
		ItemID.CLUE_SCROLL_EASY_3506,
		ItemID.CLUE_SCROLL_EASY_3509,
		ItemID.CLUE_SCROLL_EASY_12174,
		ItemID.CLUE_SCROLL_EASY_12177,
		ItemID.CLUE_SCROLL_EASY_3499,
		ItemID.CLUE_SCROLL_EASY_3501,
		ItemID.CLUE_SCROLL_EASY_2679,
		ItemID.CLUE_SCROLL_EASY_2685,
		ItemID.CLUE_SCROLL_EASY_2705,
		ItemID.CLUE_SCROLL_EASY_23149,
		ItemID.CLUE_SCROLL_EASY_2692,
		ItemID.CLUE_SCROLL_EASY_12192,
		ItemID.CLUE_SCROLL_EASY_12175,
		ItemID.CLUE_SCROLL_EASY_12172,
		ItemID.CLUE_SCROLL_EASY_23151,
		ItemID.CLUE_SCROLL_EASY_2703,
		ItemID.CLUE_SCROLL_EASY_3493,
		ItemID.CLUE_SCROLL_EASY_2680,
		ItemID.CLUE_SCROLL_EASY_23153,
		ItemID.CLUE_SCROLL_EASY_12185,
		ItemID.CLUE_SCROLL_EASY_2678,
		ItemID.CLUE_SCROLL_EASY_3504,
		ItemID.CLUE_SCROLL_EASY_7238,
		ItemID.CLUE_SCROLL_EASY_3502,
		ItemID.CLUE_SCROLL_EASY_2706,
		ItemID.CLUE_SCROLL_EASY_23154,
		ItemID.CLUE_SCROLL_EASY_2688,
		ItemID.CLUE_SCROLL_EASY_12176,
		ItemID.CLUE_SCROLL_EASY_3491,
		ItemID.CLUE_SCROLL_EASY_2690,
		ItemID.CLUE_SCROLL_EASY_12178,
		ItemID.CLUE_SCROLL_EASY_2695,
		ItemID.CLUE_SCROLL_EASY_25789,
		ItemID.CLUE_SCROLL_EASY_2704,
		ItemID.CLUE_SCROLL_EASY_2682,
		ItemID.CLUE_SCROLL_EASY_12191,
		ItemID.CLUE_SCROLL_EASY_2707,
		ItemID.CLUE_SCROLL_EASY_2709,
		ItemID.CLUE_SCROLL_EASY_2708,
		ItemID.CLUE_SCROLL_EASY_3498,
		ItemID.CLUE_SCROLL_EASY_2710,
		ItemID.CLUE_SCROLL_EASY_2694,
		ItemID.CLUE_SCROLL_EASY_3512,
		ItemID.CLUE_SCROLL_EASY_2689,
		ItemID.CLUE_SCROLL_EASY_3492,
		ItemID.CLUE_SCROLL_EASY_12188,
		ItemID.CLUE_SCROLL_EASY_3507,
		ItemID.CLUE_SCROLL_EASY_3490,
		ItemID.CLUE_SCROLL_EASY_3505,
		ItemID.CLUE_SCROLL_EASY_2691,
		ItemID.CLUE_SCROLL_EASY_2687,
		ItemID.CLUE_SCROLL_EASY_23150,
		ItemID.CLUE_SCROLL_EASY_28913,
		ItemID.CLUE_SCROLL_EASY_19829,
		ItemID.CLUE_SCROLL_EASY_23152,
		ItemID.CLUE_SCROLL_EASY_3503,
		ItemID.CLUE_SCROLL_EASY_12189,
		ItemID.CLUE_SCROLL_EASY_3497,
		ItemID.CLUE_SCROLL_EASY_3500,
		ItemID.CLUE_SCROLL_EASY_3494,
		ItemID.CLUE_SCROLL_EASY_3508,
		ItemID.CLUE_SCROLL_EASY_10202,
		ItemID.CLUE_SCROLL_EASY_3514,
		ItemID.CLUE_SCROLL_EASY_2716,
		ItemID.CLUE_SCROLL_EASY_2700,
		ItemID.CLUE_SCROLL_EASY_2701,
		ItemID.CLUE_SCROLL_EASY_2698,
		ItemID.CLUE_SCROLL_EASY_2684,
		ItemID.CLUE_SCROLL_EASY_2699,
		ItemID.CLUE_SCROLL_EASY_2681,
		ItemID.CLUE_SCROLL_EASY_12184,
		ItemID.CLUE_SCROLL_EASY_2697,
		ItemID.CLUE_SCROLL_EASY_12187,
		ItemID.CLUE_SCROLL_EASY_12186,
		ItemID.CLUE_SCROLL_EASY_2702,
		ItemID.CLUE_SCROLL_EASY_12190,
		ItemID.CLUE_SCROLL_EASY_2686,
		ItemID.CLUE_SCROLL_EASY_3513,
		ItemID.CLUE_SCROLL_EASY_10218,
		ItemID.CLUE_SCROLL_EASY_10196,
		ItemID.CLUE_SCROLL_EASY_12162,
		ItemID.CLUE_SCROLL_EASY_19817,
		ItemID.CLUE_SCROLL_EASY_19819,
		ItemID.CLUE_SCROLL_EASY_23164,
		ItemID.CLUE_SCROLL_EASY_12182,
		ItemID.CLUE_SCROLL_EASY_12181,
		ItemID.CLUE_SCROLL_EASY_23161,
		ItemID.CLUE_SCROLL_EASY_19828,
		ItemID.CLUE_SCROLL_EASY_23162,
		ItemID.CLUE_SCROLL_EASY_23165,
		ItemID.CLUE_SCROLL_EASY_23163,
		ItemID.CLUE_SCROLL_EASY_2683,
		ItemID.CLUE_SCROLL_EASY_12169,
		ItemID.CLUE_SCROLL_EASY_19830,
		ItemID.CLUE_SCROLL_EASY_2693,
		ItemID.CLUE_SCROLL_EASY_12183,
		ItemID.CLUE_SCROLL_EASY_2696,
		ItemID.CLUE_SCROLL_EASY_23166,
		ItemID.CLUE_SCROLL_EASY_12173,
		ItemID.CLUE_SCROLL_EASY_19821,
		ItemID.CLUE_SCROLL_EASY_19824,
		ItemID.CLUE_SCROLL_EASY_10198,
		ItemID.CLUE_SCROLL_EASY_10230,
		ItemID.CLUE_SCROLL_EASY_12164,
		ItemID.CLUE_SCROLL_EASY_10190,
		ItemID.CLUE_SCROLL_EASY_2713,
		ItemID.CLUE_SCROLL_EASY_10184,
		ItemID.CLUE_SCROLL_EASY_28914,
		ItemID.CLUE_SCROLL_EASY_10204,
		ItemID.CLUE_SCROLL_EASY_23155,
		ItemID.CLUE_SCROLL_EASY_23156,
		ItemID.CLUE_SCROLL_EASY_23157,
		ItemID.CLUE_SCROLL_EASY_23158,
		ItemID.CLUE_SCROLL_EASY_23159,
		ItemID.CLUE_SCROLL_EASY_23160,
		ItemID.CLUE_SCROLL_EASY_29853,
		ItemID.CLUE_SCROLL_EASY_29854,
	        ItemID.CLUE_SCROLL_EASY_30928);

	@Getter
	public static final List<Integer> mediumIds = Arrays.asList(
		ItemID.CLUE_SCROLL_MEDIUM,
		ItemID.CLUE_SCROLL_MEDIUM_2809,
		ItemID.CLUE_SCROLL_MEDIUM_3588,
		ItemID.CLUE_SCROLL_MEDIUM_3590,
		ItemID.CLUE_SCROLL_MEDIUM_7313,
		ItemID.CLUE_SCROLL_MEDIUM_2823,
		ItemID.CLUE_SCROLL_MEDIUM_2819,
		ItemID.CLUE_SCROLL_MEDIUM_7309,
		ItemID.CLUE_SCROLL_MEDIUM_2805,
		ItemID.CLUE_SCROLL_MEDIUM_2803,
		ItemID.CLUE_SCROLL_MEDIUM_23136,
		ItemID.CLUE_SCROLL_MEDIUM_12035,
		ItemID.CLUE_SCROLL_MEDIUM_2813,
		ItemID.CLUE_SCROLL_MEDIUM_12041,
		ItemID.CLUE_SCROLL_MEDIUM_7317,
		ItemID.CLUE_SCROLL_MEDIUM_2817,
		ItemID.CLUE_SCROLL_MEDIUM_2815,
		ItemID.CLUE_SCROLL_MEDIUM_7307,
		ItemID.CLUE_SCROLL_MEDIUM_2825,
		ItemID.CLUE_SCROLL_MEDIUM_2807,
		ItemID.CLUE_SCROLL_MEDIUM_12051,
		ItemID.CLUE_SCROLL_MEDIUM_12043,
		ItemID.CLUE_SCROLL_MEDIUM_3584,
		ItemID.CLUE_SCROLL_MEDIUM_2821,
		ItemID.CLUE_SCROLL_MEDIUM_12033,
		ItemID.CLUE_SCROLL_MEDIUM_3592,
		ItemID.CLUE_SCROLL_MEDIUM_2811,
		ItemID.CLUE_SCROLL_MEDIUM_12045,
		ItemID.CLUE_SCROLL_MEDIUM_7311,
		ItemID.CLUE_SCROLL_MEDIUM_28909,
		ItemID.CLUE_SCROLL_MEDIUM_12049,
		ItemID.CLUE_SCROLL_MEDIUM_3582,
		ItemID.CLUE_SCROLL_MEDIUM_3594,
		ItemID.CLUE_SCROLL_MEDIUM_12053,
		ItemID.CLUE_SCROLL_MEDIUM_12047,
		ItemID.CLUE_SCROLL_MEDIUM_3586,
		ItemID.CLUE_SCROLL_MEDIUM_12037,
		ItemID.CLUE_SCROLL_MEDIUM_19774,
		ItemID.CLUE_SCROLL_MEDIUM_7315,
		ItemID.CLUE_SCROLL_MEDIUM_12039,
		ItemID.CLUE_SCROLL_MEDIUM_23135,
		ItemID.CLUE_SCROLL_MEDIUM_7305,
		ItemID.CLUE_SCROLL_MEDIUM_23137,
		ItemID.CLUE_SCROLL_MEDIUM_12057,
		ItemID.CLUE_SCROLL_MEDIUM_3613,
		ItemID.CLUE_SCROLL_MEDIUM_12061,
		ItemID.CLUE_SCROLL_MEDIUM_19758,
		ItemID.CLUE_SCROLL_MEDIUM_19760,
		ItemID.CLUE_SCROLL_MEDIUM_3609,
		ItemID.CLUE_SCROLL_MEDIUM_3616,
		ItemID.CLUE_SCROLL_MEDIUM_7280,
		ItemID.CLUE_SCROLL_MEDIUM_2851,
		ItemID.CLUE_SCROLL_MEDIUM_19746,
		ItemID.CLUE_SCROLL_MEDIUM_19750,
		ItemID.CLUE_SCROLL_MEDIUM_28908,
		ItemID.CLUE_SCROLL_MEDIUM_7290,
		ItemID.CLUE_SCROLL_MEDIUM_3612,
		ItemID.CLUE_SCROLL_MEDIUM_19768,
		ItemID.CLUE_SCROLL_MEDIUM_10260,
		ItemID.CLUE_SCROLL_MEDIUM_10274,
		ItemID.CLUE_SCROLL_MEDIUM_19776,
		ItemID.CLUE_SCROLL_MEDIUM_3602,
		ItemID.CLUE_SCROLL_MEDIUM_7294,
		ItemID.CLUE_SCROLL_MEDIUM_23133,
		ItemID.CLUE_SCROLL_MEDIUM_23131,
		ItemID.CLUE_SCROLL_MEDIUM_10264,
		ItemID.CLUE_SCROLL_MEDIUM_12031,
		ItemID.CLUE_SCROLL_MEDIUM_10272,
		ItemID.CLUE_SCROLL_MEDIUM_12025,
		ItemID.CLUE_SCROLL_MEDIUM_23046,
		ItemID.CLUE_SCROLL_MEDIUM_10276,
		ItemID.CLUE_SCROLL_MEDIUM_19780,
		ItemID.CLUE_SCROLL_MEDIUM_12027,
		ItemID.CLUE_SCROLL_MEDIUM_10266,
		ItemID.CLUE_SCROLL_MEDIUM_7274,
		ItemID.CLUE_SCROLL_MEDIUM_10278,
		ItemID.CLUE_SCROLL_MEDIUM_10254,
		ItemID.CLUE_SCROLL_MEDIUM_12021,
		ItemID.CLUE_SCROLL_MEDIUM_19766,
		ItemID.CLUE_SCROLL_MEDIUM_2845,
		ItemID.CLUE_SCROLL_MEDIUM_2847,
		ItemID.CLUE_SCROLL_MEDIUM_3610,
		ItemID.CLUE_SCROLL_MEDIUM_12055,
		ItemID.CLUE_SCROLL_MEDIUM_2857,
		ItemID.CLUE_SCROLL_MEDIUM_7276,
		ItemID.CLUE_SCROLL_MEDIUM_19772,
		ItemID.CLUE_SCROLL_MEDIUM_3607,
		ItemID.CLUE_SCROLL_MEDIUM_7298,
		ItemID.CLUE_SCROLL_MEDIUM_2858,
		ItemID.CLUE_SCROLL_MEDIUM_12071,
		ItemID.CLUE_SCROLL_MEDIUM_7278,
		ItemID.CLUE_SCROLL_MEDIUM_19742,
		ItemID.CLUE_SCROLL_MEDIUM_19770,
		ItemID.CLUE_SCROLL_MEDIUM_19756,
		ItemID.CLUE_SCROLL_MEDIUM_19736,
		ItemID.CLUE_SCROLL_MEDIUM_12059,
		ItemID.CLUE_SCROLL_MEDIUM_3618,
		ItemID.CLUE_SCROLL_MEDIUM_2837,
		ItemID.CLUE_SCROLL_MEDIUM_2833,
		ItemID.CLUE_SCROLL_MEDIUM_2835,
		ItemID.CLUE_SCROLL_MEDIUM_2839,
		ItemID.CLUE_SCROLL_MEDIUM_3604,
		ItemID.CLUE_SCROLL_MEDIUM_10268,
		ItemID.CLUE_SCROLL_MEDIUM_12029,
		ItemID.CLUE_SCROLL_MEDIUM_12069,
		ItemID.CLUE_SCROLL_MEDIUM_28907,
		ItemID.CLUE_SCROLL_MEDIUM_7284,
		ItemID.CLUE_SCROLL_MEDIUM_12065,
		ItemID.CLUE_SCROLL_MEDIUM_19738,
		ItemID.CLUE_SCROLL_MEDIUM_2831,
		ItemID.CLUE_SCROLL_MEDIUM_3611,
		ItemID.CLUE_SCROLL_MEDIUM_7286,
		ItemID.CLUE_SCROLL_MEDIUM_7288,
		ItemID.CLUE_SCROLL_MEDIUM_7282,
		ItemID.CLUE_SCROLL_MEDIUM_3599,
		ItemID.CLUE_SCROLL_MEDIUM_2843,
		ItemID.CLUE_SCROLL_MEDIUM_19734,
		ItemID.CLUE_SCROLL_MEDIUM_19752,
		ItemID.CLUE_SCROLL_MEDIUM_2856,
		ItemID.CLUE_SCROLL_MEDIUM_10256,
		ItemID.CLUE_SCROLL_MEDIUM_7301,
		ItemID.CLUE_SCROLL_MEDIUM_19762,
		ItemID.CLUE_SCROLL_MEDIUM_19754,
		ItemID.CLUE_SCROLL_MEDIUM_2849,
		ItemID.CLUE_SCROLL_MEDIUM_19740,
		ItemID.CLUE_SCROLL_MEDIUM_12063,
		ItemID.CLUE_SCROLL_MEDIUM_19748,
		ItemID.CLUE_SCROLL_MEDIUM_25783,
		ItemID.CLUE_SCROLL_MEDIUM_3605,
		ItemID.CLUE_SCROLL_MEDIUM_12023,
		ItemID.CLUE_SCROLL_MEDIUM_2827,
		ItemID.CLUE_SCROLL_MEDIUM_7292,
		ItemID.CLUE_SCROLL_MEDIUM_2855,
		ItemID.CLUE_SCROLL_MEDIUM_2848,
		ItemID.CLUE_SCROLL_MEDIUM_3617,
		ItemID.CLUE_SCROLL_MEDIUM_3615,
		ItemID.CLUE_SCROLL_MEDIUM_2841,
		ItemID.CLUE_SCROLL_MEDIUM_3614,
		ItemID.CLUE_SCROLL_MEDIUM_2853,
		ItemID.CLUE_SCROLL_MEDIUM_10258,
		ItemID.CLUE_SCROLL_MEDIUM_19744,
		ItemID.CLUE_SCROLL_MEDIUM_12067,
		ItemID.CLUE_SCROLL_MEDIUM_3598,
		ItemID.CLUE_SCROLL_MEDIUM_3601,
		ItemID.CLUE_SCROLL_MEDIUM_7296,
		ItemID.CLUE_SCROLL_MEDIUM_10270,
		ItemID.CLUE_SCROLL_MEDIUM_7304,
		ItemID.CLUE_SCROLL_MEDIUM_7303,
		ItemID.CLUE_SCROLL_MEDIUM_2829,
		ItemID.CLUE_SCROLL_MEDIUM_7300,
		ItemID.CLUE_SCROLL_MEDIUM_25784,
		ItemID.CLUE_SCROLL_MEDIUM_3596,
		ItemID.CLUE_SCROLL_MEDIUM_19764,
		ItemID.CLUE_SCROLL_MEDIUM_10262,
		ItemID.CLUE_SCROLL_MEDIUM_19778,
		ItemID.CLUE_SCROLL_MEDIUM_23138,
		ItemID.CLUE_SCROLL_MEDIUM_23139,
		ItemID.CLUE_SCROLL_MEDIUM_23140,
		ItemID.CLUE_SCROLL_MEDIUM_23141,
		ItemID.CLUE_SCROLL_MEDIUM_23142,
		ItemID.CLUE_SCROLL_MEDIUM_23143,
		ItemID.CLUE_SCROLL_MEDIUM_29857,
		ItemID.CLUE_SCROLL_MEDIUM_29858,
	        ItemID.CLUE_SCROLL_MEDIUM_30933,
	        ItemID.CLUE_SCROLL_MEDIUM_30935);

	@Getter
	public static final List<Integer> hardIds = Arrays.asList(
		ItemID.CLUE_SCROLL_HARD_3560,
		ItemID.CLUE_SCROLL_HARD_3562,
		ItemID.CLUE_SCROLL_HARD_12554,
		ItemID.CLUE_SCROLL_HARD_3554,
		ItemID.CLUE_SCROLL_HARD_12558,
		ItemID.CLUE_SCROLL_HARD_19844,
		ItemID.CLUE_SCROLL_HARD_12562,
		ItemID.CLUE_SCROLL_HARD_12560,
		ItemID.CLUE_SCROLL_HARD_3552,
		ItemID.CLUE_SCROLL_HARD_3546,
		ItemID.CLUE_SCROLL_HARD_3548,
		ItemID.CLUE_SCROLL_HARD_3538,
		ItemID.CLUE_SCROLL_HARD_7256,
		ItemID.CLUE_SCROLL_HARD_3550,
		ItemID.CLUE_SCROLL_HARD_3542,
		ItemID.CLUE_SCROLL_HARD_3530,
		ItemID.CLUE_SCROLL_HARD_7258,
		ItemID.CLUE_SCROLL_HARD_3540,
		ItemID.CLUE_SCROLL_HARD_3534,
		ItemID.CLUE_SCROLL_HARD_3544,
		ItemID.CLUE_SCROLL_HARD_3536,
		ItemID.CLUE_SCROLL_HARD_3532,
		ItemID.CLUE_SCROLL_HARD_25790,
		ItemID.CLUE_SCROLL_HARD_7262,
		ItemID.CLUE_SCROLL_HARD_3526,
		ItemID.CLUE_SCROLL_HARD_2743,
		ItemID.CLUE_SCROLL_HARD_3528,
		ItemID.CLUE_SCROLL_HARD_7264,
		ItemID.CLUE_SCROLL_HARD_2745,
		ItemID.CLUE_SCROLL_HARD_12564,
		ItemID.CLUE_SCROLL_HARD_23167,
		ItemID.CLUE_SCROLL_HARD_19840,
		ItemID.CLUE_SCROLL_HARD_7266,
		ItemID.CLUE_SCROLL_HARD_7260,
		ItemID.CLUE_SCROLL_HARD_3556,
		ItemID.CLUE_SCROLL_HARD_2747,
		ItemID.CLUE_SCROLL_HARD_23168,
		ItemID.CLUE_SCROLL_HARD_19842,
		ItemID.CLUE_SCROLL_HARD_2741,
		ItemID.CLUE_SCROLL_HARD_2733,
		ItemID.CLUE_SCROLL_HARD_2735,
		ItemID.CLUE_SCROLL_HARD_21526,
		ItemID.CLUE_SCROLL_HARD_2737,
		ItemID.CLUE_SCROLL_HARD_2723,
		ItemID.CLUE_SCROLL_HARD_2731,
		ItemID.CLUE_SCROLL_HARD_21527,
		ItemID.CLUE_SCROLL_HARD_12556,
		ItemID.CLUE_SCROLL_HARD_23169,
		ItemID.CLUE_SCROLL_HARD_3558,
		ItemID.CLUE_SCROLL_HARD_2727,
		ItemID.CLUE_SCROLL_HARD_2739,
		ItemID.CLUE_SCROLL_HARD_2725,
		ItemID.CLUE_SCROLL_HARD_2729,
		ItemID.CLUE_SCROLL_HARD_2788,
		ItemID.CLUE_SCROLL_HARD_28915,
		ItemID.CLUE_SCROLL_HARD_2793,
		ItemID.CLUE_SCROLL_HARD_3564,
		ItemID.CLUE_SCROLL_HARD_3573,
		ItemID.CLUE_SCROLL_HARD_19862,
		ItemID.CLUE_SCROLL_HARD_19864,
		ItemID.CLUE_SCROLL_HARD_19866,
		ItemID.CLUE_SCROLL_HARD_2780,
		ItemID.CLUE_SCROLL_HARD_7243,
		ItemID.CLUE_SCROLL_HARD_19894,
		ItemID.CLUE_SCROLL_HARD_19868,
		ItemID.CLUE_SCROLL_HARD_19870,
		ItemID.CLUE_SCROLL_HARD_19872,
		ItemID.CLUE_SCROLL_HARD_19886,
		ItemID.CLUE_SCROLL_HARD_23170,
		ItemID.CLUE_SCROLL_HARD_28916,
		ItemID.CLUE_SCROLL_HARD_7270,
		ItemID.CLUE_SCROLL_HARD_12544,
		ItemID.CLUE_SCROLL_HARD_10236,
		ItemID.CLUE_SCROLL_HARD_10252,
		ItemID.CLUE_SCROLL_HARD_10238,
		ItemID.CLUE_SCROLL_HARD_7268,
		ItemID.CLUE_SCROLL_HARD_19880,
		ItemID.CLUE_SCROLL_HARD_19874,
		ItemID.CLUE_SCROLL_HARD_12566,
		ItemID.CLUE_SCROLL_HARD_12550,
		ItemID.CLUE_SCROLL_HARD_3575,
		ItemID.CLUE_SCROLL_HARD_3577,
		ItemID.CLUE_SCROLL_HARD_19846,
		ItemID.CLUE_SCROLL_HARD_2774,
		ItemID.CLUE_SCROLL_HARD_7245,
		ItemID.CLUE_SCROLL_HARD_24493,
		ItemID.CLUE_SCROLL_HARD_19888,
		ItemID.CLUE_SCROLL_HARD_19876,
		ItemID.CLUE_SCROLL_HARD_19878,
		ItemID.CLUE_SCROLL_HARD_12576,
		ItemID.CLUE_SCROLL_HARD_19890,
		ItemID.CLUE_SCROLL_HARD_12568,
		ItemID.CLUE_SCROLL_HARD_10242,
		ItemID.CLUE_SCROLL_HARD_25791,
		ItemID.CLUE_SCROLL_HARD_19848,
		ItemID.CLUE_SCROLL_HARD_2785,
		ItemID.CLUE_SCROLL_HARD_19910,
		ItemID.CLUE_SCROLL_HARD_2799,
		ItemID.CLUE_SCROLL_HARD_12578,
		ItemID.CLUE_SCROLL_HARD_19908,
		ItemID.CLUE_SCROLL_HARD_19854,
		ItemID.CLUE_SCROLL_HARD_12542,
		ItemID.CLUE_SCROLL_HARD_7253,
		ItemID.CLUE_SCROLL_HARD_2776,
		ItemID.CLUE_SCROLL_HARD_19858,
		ItemID.CLUE_SCROLL_HARD_2786,
		ItemID.CLUE_SCROLL_HARD_12581,
		ItemID.CLUE_SCROLL_HARD_23172,
		ItemID.CLUE_SCROLL_HARD_3568,
		ItemID.CLUE_SCROLL_HARD_2778,
		ItemID.CLUE_SCROLL_HARD_7254,
		ItemID.CLUE_SCROLL_HARD_3525,
		ItemID.CLUE_SCROLL_HARD_3524,
		ItemID.CLUE_SCROLL_HARD_19853,
		ItemID.CLUE_SCROLL_HARD_3522,
		ItemID.CLUE_SCROLL_HARD_7251,
		ItemID.CLUE_SCROLL_HARD_12548,
		ItemID.CLUE_SCROLL_HARD_10248,
		ItemID.CLUE_SCROLL_HARD_19856,
		ItemID.CLUE_SCROLL_HARD_12574,
		ItemID.CLUE_SCROLL_HARD_19896,
		ItemID.CLUE_SCROLL_HARD_3580,
		ItemID.CLUE_SCROLL_HARD_3574,
		ItemID.CLUE_SCROLL_HARD_2790,
		ItemID.CLUE_SCROLL_HARD_2782,
		ItemID.CLUE_SCROLL_HARD_2797,
		ItemID.CLUE_SCROLL_HARD_7272,
		ItemID.CLUE_SCROLL_HARD_19898,
		ItemID.CLUE_SCROLL_HARD_3566,
		ItemID.CLUE_SCROLL_HARD_10250,
		ItemID.CLUE_SCROLL_HARD_10240,
		ItemID.CLUE_SCROLL_HARD_12546,
		ItemID.CLUE_SCROLL_HARD_7249,
		ItemID.CLUE_SCROLL_HARD_19892,
		ItemID.CLUE_SCROLL_HARD_12570,
		ItemID.CLUE_SCROLL_HARD_3572,
		ItemID.CLUE_SCROLL_HARD_19850,
		ItemID.CLUE_SCROLL_HARD_12572,
		ItemID.CLUE_SCROLL_HARD_10246,
		ItemID.CLUE_SCROLL_HARD_12552,
		ItemID.CLUE_SCROLL_HARD_10234,
		ItemID.CLUE_SCROLL_HARD_2792,
		ItemID.CLUE_SCROLL_HARD_7241,
		ItemID.CLUE_SCROLL_HARD_7239,
		ItemID.CLUE_SCROLL_HARD_2796,
		ItemID.CLUE_SCROLL_HARD_12584,
		ItemID.CLUE_SCROLL_HARD_12590,
		ItemID.CLUE_SCROLL_HARD_26566,
		ItemID.CLUE_SCROLL_HARD_12587,
		ItemID.CLUE_SCROLL_HARD_28918,
		ItemID.CLUE_SCROLL_HARD_2783,
		ItemID.CLUE_SCROLL_HARD_7248,
		ItemID.CLUE_SCROLL_HARD_23045,
		ItemID.CLUE_SCROLL_HARD_2794,
		ItemID.CLUE_SCROLL_HARD_19857,
		ItemID.CLUE_SCROLL_HARD_19852,
		ItemID.CLUE_SCROLL_HARD_3570,
		ItemID.CLUE_SCROLL_HARD_7247,
		ItemID.CLUE_SCROLL_HARD_7255,
		ItemID.CLUE_SCROLL_HARD_19900,
		ItemID.CLUE_SCROLL_HARD_19882,
		ItemID.CLUE_SCROLL_HARD_19906,
		ItemID.CLUE_SCROLL_HARD_19884,
		ItemID.CLUE_SCROLL_HARD_3579,
		ItemID.CLUE_SCROLL_HARD_7252,
		ItemID.CLUE_SCROLL_HARD_19860,
		ItemID.CLUE_SCROLL_HARD_3520,
		ItemID.CLUE_SCROLL_HARD_10244,
		ItemID.CLUE_SCROLL_HARD_7250,
		ItemID.CLUE_SCROLL_HARD_2773,
		ItemID.CLUE_SCROLL_HARD_19904,
		ItemID.CLUE_SCROLL_HARD_19902,
		ItemID.CLUE_SCROLL_HARD_23174,
		ItemID.CLUE_SCROLL_HARD_23175,
		ItemID.CLUE_SCROLL_HARD,
		ItemID.CLUE_SCROLL_HARD_23176,
		ItemID.CLUE_SCROLL_HARD_23177,
		ItemID.CLUE_SCROLL_HARD_23178,
		ItemID.CLUE_SCROLL_HARD_23179,
		ItemID.CLUE_SCROLL_HARD_23180,
		ItemID.CLUE_SCROLL_HARD_23181,
		ItemID.CLUE_SCROLL_HARD_25792,
		ItemID.CLUE_SCROLL_HARD_29859,
	        ItemID.CLUE_SCROLL_HARD_30929,
		ItemID.CLUE_SCROLL_HARD_30931);

	@Getter
	public static final List<Integer> eliteIds = Arrays.asList(
		ItemID.CLUE_SCROLL_ELITE,
		ItemID.CLUE_SCROLL_ELITE_12157,
		ItemID.CLUE_SCROLL_ELITE_28912,
		ItemID.CLUE_SCROLL_ELITE_12089,
		ItemID.CLUE_SCROLL_ELITE_12091,
		ItemID.CLUE_SCROLL_ELITE_12110,
		ItemID.CLUE_SCROLL_ELITE_12086,
		ItemID.CLUE_SCROLL_ELITE_12111,
		ItemID.CLUE_SCROLL_ELITE_12107,
		ItemID.CLUE_SCROLL_ELITE_23770,
		ItemID.CLUE_SCROLL_ELITE_12100,
		ItemID.CLUE_SCROLL_ELITE_12098,
		ItemID.CLUE_SCROLL_ELITE_25499,
		ItemID.CLUE_SCROLL_ELITE_12102,
		ItemID.CLUE_SCROLL_ELITE_12103,
		ItemID.CLUE_SCROLL_ELITE_25498,
		ItemID.CLUE_SCROLL_ELITE_12088,
		ItemID.CLUE_SCROLL_ELITE_12099,
		ItemID.CLUE_SCROLL_ELITE_25787,
		ItemID.CLUE_SCROLL_ELITE_19813,
		ItemID.CLUE_SCROLL_ELITE_12085,
		ItemID.CLUE_SCROLL_ELITE_12108,
		ItemID.CLUE_SCROLL_ELITE_12106,
		ItemID.CLUE_SCROLL_ELITE_26944,
		ItemID.CLUE_SCROLL_ELITE_12096,
		ItemID.CLUE_SCROLL_ELITE_12104,
		ItemID.CLUE_SCROLL_ELITE_23146,
		ItemID.CLUE_SCROLL_ELITE_12090,
		ItemID.CLUE_SCROLL_ELITE_12094,
		ItemID.CLUE_SCROLL_ELITE_12105,
		ItemID.CLUE_SCROLL_ELITE_12087,
		ItemID.CLUE_SCROLL_ELITE_23148,
		ItemID.CLUE_SCROLL_ELITE_12109,
		ItemID.CLUE_SCROLL_ELITE_12101,
		ItemID.CLUE_SCROLL_ELITE_12092,
		ItemID.CLUE_SCROLL_ELITE_12095,
		ItemID.CLUE_SCROLL_ELITE_23147,
		ItemID.CLUE_SCROLL_ELITE_12097,
		ItemID.CLUE_SCROLL_ELITE_12093,
		ItemID.CLUE_SCROLL_ELITE_22000,
		ItemID.CLUE_SCROLL_ELITE_24253,
		ItemID.CLUE_SCROLL_ELITE_12156,
		ItemID.CLUE_SCROLL_ELITE_19797,
		ItemID.CLUE_SCROLL_ELITE_19805,
		ItemID.CLUE_SCROLL_ELITE_19804,
		ItemID.CLUE_SCROLL_ELITE_19798,
		ItemID.CLUE_SCROLL_ELITE_19799,
		ItemID.CLUE_SCROLL_ELITE_19800,
		ItemID.CLUE_SCROLL_ELITE_19806,
		ItemID.CLUE_SCROLL_ELITE_19796,
		ItemID.CLUE_SCROLL_ELITE_19803,
		ItemID.CLUE_SCROLL_ELITE_19801,
		ItemID.CLUE_SCROLL_ELITE_19802,
		ItemID.CLUE_SCROLL_ELITE_12151,
		ItemID.CLUE_SCROLL_ELITE_19809,
		ItemID.CLUE_SCROLL_ELITE_19793,
		ItemID.CLUE_SCROLL_ELITE_19784,
		ItemID.CLUE_SCROLL_ELITE_12075,
		ItemID.CLUE_SCROLL_ELITE_19789,
		ItemID.CLUE_SCROLL_ELITE_12078,
		ItemID.CLUE_SCROLL_ELITE_28910,
		ItemID.CLUE_SCROLL_ELITE_12132,
		ItemID.CLUE_SCROLL_ELITE_12138,
		ItemID.CLUE_SCROLL_ELITE_12076,
		ItemID.CLUE_SCROLL_ELITE_21524,
		ItemID.CLUE_SCROLL_ELITE_12134,
		ItemID.CLUE_SCROLL_ELITE_12079,
		ItemID.CLUE_SCROLL_ELITE_12158,
		ItemID.CLUE_SCROLL_ELITE_19810,
		ItemID.CLUE_SCROLL_ELITE_12150,
		ItemID.CLUE_SCROLL_ELITE_12154,
		ItemID.CLUE_SCROLL_ELITE_21525,
		ItemID.CLUE_SCROLL_ELITE_19785,
		ItemID.CLUE_SCROLL_ELITE_12145,
		ItemID.CLUE_SCROLL_ELITE_12141,
		ItemID.CLUE_SCROLL_ELITE_12140,
		ItemID.CLUE_SCROLL_ELITE_12080,
		ItemID.CLUE_SCROLL_ELITE_19791,
		ItemID.CLUE_SCROLL_ELITE_12155,
		ItemID.CLUE_SCROLL_ELITE_12144,
		ItemID.CLUE_SCROLL_ELITE_12152,
		ItemID.CLUE_SCROLL_ELITE_12153,
		ItemID.CLUE_SCROLL_ELITE_19782,
		ItemID.CLUE_SCROLL_ELITE_12074,
		ItemID.CLUE_SCROLL_ELITE_12083,
		ItemID.CLUE_SCROLL_ELITE_19792,
		ItemID.CLUE_SCROLL_ELITE_12082,
		ItemID.CLUE_SCROLL_ELITE_19790,
		ItemID.CLUE_SCROLL_ELITE_12136,
		ItemID.CLUE_SCROLL_ELITE_12133,
		ItemID.CLUE_SCROLL_ELITE_23144,
		ItemID.CLUE_SCROLL_ELITE_12135,
		ItemID.CLUE_SCROLL_ELITE_19794,
		ItemID.CLUE_SCROLL_ELITE_23145,
		ItemID.CLUE_SCROLL_ELITE_19787,
		ItemID.CLUE_SCROLL_ELITE_12146,
		ItemID.CLUE_SCROLL_ELITE_19795,
		ItemID.CLUE_SCROLL_ELITE_25786,
		ItemID.CLUE_SCROLL_ELITE_12077,
		ItemID.CLUE_SCROLL_ELITE_19807,
		ItemID.CLUE_SCROLL_ELITE_12127,
		ItemID.CLUE_SCROLL_ELITE_19788,
		ItemID.CLUE_SCROLL_ELITE_12130,
		ItemID.CLUE_SCROLL_ELITE_12159,
		ItemID.CLUE_SCROLL_ELITE_12143,
		ItemID.CLUE_SCROLL_ELITE_19786,
		ItemID.CLUE_SCROLL_ELITE_12142,
		ItemID.CLUE_SCROLL_ELITE_12137,
		ItemID.CLUE_SCROLL_ELITE_12149,
		ItemID.CLUE_SCROLL_ELITE_12148,
		ItemID.CLUE_SCROLL_ELITE_19808,
		ItemID.CLUE_SCROLL_ELITE_28911,
		ItemID.CLUE_SCROLL_ELITE_12081,
		ItemID.CLUE_SCROLL_ELITE_19811,
		ItemID.CLUE_SCROLL_ELITE_12147,
		ItemID.CLUE_SCROLL_ELITE_19783,
		ItemID.CLUE_SCROLL_ELITE_12113,
		ItemID.CLUE_SCROLL_ELITE_12114,
		ItemID.CLUE_SCROLL_ELITE_12115,
		ItemID.CLUE_SCROLL_ELITE_12116,
		ItemID.CLUE_SCROLL_ELITE_12117,
		ItemID.CLUE_SCROLL_ELITE_12118,
		ItemID.CLUE_SCROLL_ELITE_12119,
		ItemID.CLUE_SCROLL_ELITE_12120,
		ItemID.CLUE_SCROLL_ELITE_12121,
		ItemID.CLUE_SCROLL_ELITE_12122,
		ItemID.CLUE_SCROLL_ELITE_12123,
		ItemID.CLUE_SCROLL_ELITE_12124,
		ItemID.CLUE_SCROLL_ELITE_12125,
		ItemID.CLUE_SCROLL_ELITE_12126,
		ItemID.CLUE_SCROLL_ELITE_24773,
		ItemID.CLUE_SCROLL_ELITE_26943,
		ItemID.CLUE_SCROLL_ELITE_29855,
		ItemID.CLUE_SCROLL_ELITE_29856,
		ItemID.CLUE_SCROLL_ELITE_30932,
		ItemID.CHALLENGE_SCROLL_ELITE);

}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver.ids;

public class ScrollCase
{
	public static final int SCROLL_CASE_BEGINNER_MINOR = 16565;
	public static final int SCROLL_CASE_BEGINNER_MAJOR = 16566;
	public static final int SCROLL_CASE_EASY_MINOR = 16567;
	public static final int SCROLL_CASE_EASY_MAJOR = 16586;
	public static final int SCROLL_CASE_MEDIUM_MINOR = 16587;
	public static final int SCROLL_CASE_MEDIUM_MAJOR = 16588;
	public static final int SCROLL_CASE_HARD_MINOR = 16589;
	public static final int SCROLL_CASE_HARD_MAJOR = 16590;
	public static final int SCROLL_CASE_ELITE_MINOR = 16591;
	public static final int SCROLL_CASE_ELITE_MAJOR = 16592;
	public static final int SCROLL_CASE_MASTER_MINOR = 16593;
	public static final int SCROLL_CASE_MASTER_MAJOR = 16594;
	public static final int SCROLL_CASE_MIMIC = 16595;
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver.ids;

import java.util.Arrays;
import java.util.List;
import lombok.Getter;
import net.runelite.api.ObjectID;

public class ToaChest
{
	@Getter
	public static final List<Integer> itemIds = Arrays.asList(
		ObjectID.CHEST_44786,       // toa vault chest mine standard     - Open
		ObjectID.SARCOPHAGUS_44826, // toa vault sarcophagus closed rare - Open
		ObjectID.REWARDS_NICHE);    // toa rewards chest lobby open      - Claim
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver.ids;

import java.util.Arrays;
import java.util.List;
import lombok.Getter;
import net.runelite.api.ItemID;

@Getter
public class ImplingJars
{
	@Getter
	public static final List<Integer> itemIds = Arrays.asList(
		ItemID.BABY_IMPLING_JAR,
		ItemID.YOUNG_IMPLING_JAR,
		ItemID.GOURMET_IMPLING_JAR,
		ItemID.EARTH_IMPLING_JAR,
		ItemID.ESSENCE_IMPLING_JAR,
		ItemID.ECLECTIC_IMPLING_JAR,
		ItemID.NATURE_IMPLING_JAR,
		ItemID.MAGPIE_IMPLING_JAR,
		ItemID.NINJA_IMPLING_JAR,
		ItemID.CRYSTAL_IMPLING_JAR,
		ItemID.DRAGON_IMPLING_JAR);

	@Getter
	public static final List<Integer> beginnerIds = Arrays.asList(
		ItemID.BABY_IMPLING_JAR,
		ItemID.YOUNG_IMPLING_JAR);

	@Getter
	public static final List<Integer> easyIds = Arrays.asList(
		ItemID.BABY_IMPLING_JAR,
		ItemID.YOUNG_IMPLING_JAR,
		ItemID.GOURMET_IMPLING_JAR);

	@Getter
	public static final List<Integer> mediumIds = Arrays.asList(
		ItemID.EARTH_IMPLING_JAR,
		ItemID.ESSENCE_IMPLING_JAR,
		ItemID.ECLECTIC_IMPLING_JAR);

	@Getter
	public static final List<Integer> hardIds = Arrays.asList(
		ItemID.NATURE_IMPLING_JAR,
		ItemID.MAGPIE_IMPLING_JAR,
		ItemID.NINJA_IMPLING_JAR);

	@Getter
	public static final List<Integer> eliteIds = Arrays.asList(
		ItemID.CRYSTAL_IMPLING_JAR,
		ItemID.DRAGON_IMPLING_JAR);
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver.ids;

public class ScrollBox
{
	public static final int CLUE_SCROLL_BOX_BEGINNER = 24361;
	public static final int CLUE_SCROLL_BOX_EASY = 24362;
	public static final int CLUE_SCROLL_BOX_MEDIUM = 24363;
	public static final int CLUE_SCROLL_BOX_HARD = 24364;
	public static final int CLUE_SCROLL_BOX_ELITE = 24365;
	public static final int CLUE_SCROLL_BOX_MASTER = 24366;
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

public class ClueSaverOverlay extends OverlayPanel
{
	private final Client client;
	private final ClueSaverPlugin plugin;
	private final ClueSaverConfig config;
	private final TooltipManager tooltipManager;

	@Inject
	public ClueSaverOverlay(Client client, ClueSaverPlugin plugin, ClueSaverConfig config, TooltipManager tooltipManager)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.tooltipManager = tooltipManager;

		setPosition(OverlayPosition.TOOLTIP);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(PRIORITY_HIGHEST);
		setDragTargetable(false);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		renderMouseover();
		return null;
	}

	private void renderMouseover()
	{
		if (!config.showTooltip()) return;

		MenuEntry[] menuEntries = client.getMenuEntries();
		if (menuEntries.length == 0)
		{
			return;
		}

		MenuEntry entry = client.isMenuOpen() ? plugin.hoveredMenuEntry(menuEntries) : menuEntries[menuEntries.length - 1];

		MenuAction menuAction = entry.getType();
		if (!(menuAction == MenuAction.CC_OP
			|| menuAction == MenuAction.GAME_OBJECT_FIRST_OPTION
			|| menuAction == MenuAction.WIDGET_TARGET_ON_GAME_OBJECT)) return;

		int itemId = entry.getItemId();
		int objectId = plugin.objectIdForEntry(entry);

		if ((objectId != -1 && plugin.isEliteClueMethodToSave(objectId, entry.getOption()))
			|| plugin.isItemIdMethodToSave(itemId))
		{
			ClueTier tier = plugin.getClueStates().getTierFromItemId(config, itemId);
			String tooltipText = plugin.getTierSavingCause(tier);

			if (tooltipText != null)
			{
				tooltipText = plugin.getActiveSavingText() + tooltipText;
				tooltipManager.add(new Tooltip(tooltipText));
			}
		}
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import lombok.Data;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Data
public class ScrollBoxState
{
	public ClueTier tier;
	public int inventoryCount;
	public int prevInventoryCount;
	public int bankCount;
	public boolean deposited;
	public boolean withdrawn;
	public boolean inReward;

	public ScrollBoxState(ClueTier tier)
	{
		this.tier = tier;
		this.inventoryCount = 0;
		this.prevInventoryCount = -1;
		this.bankCount = 0;
		this.deposited = false;
		this.withdrawn = false;
		this.inReward = false;
	}

	public int getTotalCount()
	{
		return inventoryCount + bankCount;
	}
}

/*
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

@Slf4j
@Singleton
public class TierStateSaveManager
{
	private final ClueSaverPlugin clueSaverPlugin;
	private final ConfigManager configManager;
	private final Gson gson;

	@Inject
	public TierStateSaveManager(ClueSaverPlugin clueSaverPlugin, ConfigManager configManager, Gson gson)
	{
		this.clueSaverPlugin = clueSaverPlugin;
		this.configManager = configManager;
		this.gson = gson;
	}

	public void saveStateToConfig()
	{
		// Serialize tier states save to config
		TierState beginnerState = getTierData(ClueTier.BEGINNER);
		String beginnerStateData = gson.toJson(beginnerState);
		configManager.setConfiguration(ClueSaverConfig.GROUP, ClueSaverConfig.BEGINNER_STATE, beginnerStateData);

		TierState easyState = getTierData(ClueTier.EASY);
		String easyStateData = gson.toJson(easyState);
		configManager.setConfiguration(ClueSaverConfig.GROUP, ClueSaverConfig.EASY_STATE, easyStateData);

		TierState mediumState = getTierData(ClueTier.MEDIUM);
		String mediumStateData = gson.toJson(mediumState);
		configManager.setConfiguration(ClueSaverConfig.GROUP, ClueSaverConfig.MEDIUM_STATE, mediumStateData);

		TierState hardState = getTierData(ClueTier.HARD);
		String hardStateData = gson.toJson(hardState);
		configManager.setConfiguration(ClueSaverConfig.GROUP, ClueSaverConfig.HARD_STATE, hardStateData);

		TierState eliteState = getTierData(ClueTier.ELITE);
		String eliteStateData = gson.toJson(eliteState);
		configManager.setConfiguration(ClueSaverConfig.GROUP, ClueSaverConfig.ELITE_STATE, eliteStateData);

		TierState masterState = getTierData(ClueTier.MASTER);
		String masterStateData = gson.toJson(masterState);
		configManager.setConfiguration(ClueSaverConfig.GROUP, ClueSaverConfig.MASTER_STATE, masterStateData);
	}

	private TierState getTierData(ClueTier tier)
	{
		TierState newData = new TierState();
		ClueScrollState clueState = clueSaverPlugin.getClueStates().getClueStateFromTier(tier);
		newData.setClueScrollLocation(clueState.getLocation());

		ScrollBoxState boxState = clueSaverPlugin.getClueStates().getBoxStateFromTier(tier);
		newData.setScrollBoxInventoryCount(boxState.getInventoryCount());
		newData.setScrollBoxBankCount(boxState.getBankCount());

		return newData;
	}

	public void loadStateFromConfig()
	{
		loadTierFromConfig(ClueSaverConfig.BEGINNER_STATE, ClueTier.BEGINNER);
		loadTierFromConfig(ClueSaverConfig.EASY_STATE, ClueTier.EASY);
		loadTierFromConfig(ClueSaverConfig.MEDIUM_STATE, ClueTier.MEDIUM);
		loadTierFromConfig(ClueSaverConfig.HARD_STATE, ClueTier.HARD);
		loadTierFromConfig(ClueSaverConfig.ELITE_STATE, ClueTier.ELITE);
		loadTierFromConfig(ClueSaverConfig.MASTER_STATE, ClueTier.MASTER);
	}

	public void loadTierFromConfig(String key, ClueTier tier)
	{
		String tierStateJson = configManager.getConfiguration(ClueSaverConfig.GROUP, key);

		if (tierStateJson != null)
		{
			try
			{
				Type tierDataType = new TypeToken<TierState>()
				{
				}.getType();

				TierState loadedTierData = gson.fromJson(tierStateJson, tierDataType);

				// Convert TierState back to ClueScrollState/ScrollBoxState
				clueSaverPlugin.getClueStates().setFromTierState(loadedTierData, tier);

			} catch (Exception err)
			{
				log.error("e: ", err);
			}
		}
	}
}

/*
 * Copyright (c) 2025, lalochazia <https://github.com/lalochazia>
 * Copyright (c) 2025, TheLope <https://github.com/TheLope>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.cluesaver;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.MouseListener;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ImageUtil;

@Slf4j
public class ClueSaverUI extends Overlay implements MouseListener
{
	private static final int PADDING = 2;
	private static final int POSITION_SPEED_MULTIPLIER = 2;
	private static final int EXPANDED_START_Y_OFFSET = 3;
	private static final int CLUE_X_OFFSET = 4;
	private static final int SAVER_ICON_OFFSET = 4;
	private static final int BUTTON_VERTICAL_OFFSET = 8;
	private static final int EXPANDED_UI_EXTRA_WIDTH = 50;
	private static final int EXPANDED_BUTTON_LEFT_OFFSET = 45;
	private static final int PIP_VERTICAL_OVERLAP = 1;
	private static final int PIP_ADDITIONAL_Y_OFFSET = 6;
	private static final int CLOSED_UI_Y_DIVIDER = 3;
	private final Client client;
	private final ClientThread clientThread;
	private final ClueSaverConfig config;
	private final ClueSaverUtils clueSaverUtils;
	private final ClueSaverPlugin clueSaverPlugin;
	private int cachedVisibleTierCount = 0;
	private int previousTotalBoxes = 0;
	private boolean visibilityNeedsUpdate = true;
	private boolean shouldDraw = false;
	private boolean isButtonHovered = false;
	private boolean isExpanded = false;
	private Rectangle buttonBounds;
	private Rectangle beginnerIconBounds;
	private Rectangle easyIconBounds;
	private Rectangle mediumIconBounds;
	private Rectangle hardIconBounds;
	private Rectangle eliteIconBounds;
	private Rectangle masterIconBounds;
	private final BufferedImage closedUIImage;
	private final BufferedImage buttonUIImage;
	private final BufferedImage buttonUIHoveredImage;
	private final BufferedImage clueScrollBeginnerImage;
	private final BufferedImage clueScrollEasyImage;
	private final BufferedImage clueScrollMediumImage;
	private final BufferedImage clueScrollHardImage;
	private final BufferedImage clueScrollEliteImage;
	private final BufferedImage clueScrollMasterImage;
	private final BufferedImage pipImage;
	private final BufferedImage pipGreenImage;
	private final BufferedImage pipOrangeImage;
	private final BufferedImage pipRedImage;
	private final BufferedImage activeClueSaver;
	private final BufferedImage invIcon;
	private final BufferedImage bankIcon;

	@Inject
	public ClueSaverUI(Client client, ClientThread clientThread,
					   ClueSaverUtils clueSaverUtils, ClueSaverPlugin clueSaverPlugin,
					   ClueSaverConfig config)
	{
		this.config = config;
		this.client = client;
		this.clientThread = clientThread;
		this.clueSaverUtils = clueSaverUtils;
		this.clueSaverPlugin = clueSaverPlugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(100);

		closedUIImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/ClosedUI.png");
		buttonUIImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/buttonUI.png");
		buttonUIHoveredImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/buttonUIhovered.png");
		clueScrollBeginnerImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/cluescrollBeginner.png");
		clueScrollEasyImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/cluescrollEasy.png");
		clueScrollMediumImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/cluescrollMedium.png");
		clueScrollHardImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/cluescrollHard.png");
		clueScrollEliteImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/cluescrollElite.png");
		clueScrollMasterImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/cluescrollMaster.png");
		pipImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/pip.png");
		pipGreenImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/pipGreen.png");
		pipOrangeImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/pipOrange.png");
		pipRedImage = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/pipRed.png");
		invIcon = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/invIcon.png");
		bankIcon = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/bankIcon.png");
		activeClueSaver = ImageUtil.loadImageResource(getClass(), "/com/cluesaver/activeClueSaver.png");
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!shouldDraw || !config.showUI() || closedUIImage == null || buttonUIImage == null || buttonUIHoveredImage == null)
		{
			return null;
		}

		updateVisibilityIfNeeded();

		if (cachedVisibleTierCount == 0)
		{
			return null;
		}

		BufferedImage firstClueImage = getClueImage(ClueTier.values()[0]);
		int clueImageHeight = firstClueImage != null ? firstClueImage.getHeight() : 0;
		int totalHeight = (clueImageHeight + PADDING) * cachedVisibleTierCount;

		final int canvasWidth = client.getCanvasWidth();
		final int canvasHeight = client.getCanvasHeight();

		final boolean anchorRight = config.uiAnchor() == ClueSaverConfig.UIAnchor.RIGHT;

		final int closedUIX = anchorRight
			? canvasWidth - closedUIImage.getWidth()
			: 0;

		final int closedUIY = (canvasHeight - totalHeight) / CLOSED_UI_Y_DIVIDER + POSITION_SPEED_MULTIPLIER * config.uiVerticalOffset();

		int cropHeight = Math.min(closedUIImage.getHeight(), totalHeight);

		graphics.drawImage(
			closedUIImage,
			closedUIX, closedUIY,
			closedUIX + closedUIImage.getWidth(),
			closedUIY + cropHeight,
			0, 0,closedUIImage.getWidth(), cropHeight,
			null
		);

		final int expandedUIWidth = firstClueImage.getWidth() + EXPANDED_UI_EXTRA_WIDTH;

		if (isExpanded)
		{
			final int expandedUIX = anchorRight
				? closedUIX - expandedUIWidth
				: closedUIX + closedUIImage.getWidth();

			final int startY = closedUIY + EXPANDED_START_Y_OFFSET;

			int currentY = startY;

			for (ClueTier tier : ClueTier.values())
			{
				if (!shouldShowTier(tier))
				{
					continue;
				}

				BufferedImage clueImage = getClueImage(tier);
				if (clueImage == null) continue;

				int nextY = currentY + clueImage.getHeight() + PADDING;

				final int clueX = anchorRight
					? expandedUIX + expandedUIWidth - clueImage.getWidth() - CLUE_X_OFFSET
					: expandedUIX + CLUE_X_OFFSET;

				graphics.drawImage(clueImage, clueX, currentY, null);

				TierStats stats = calculateTierStats(tier);

				if (stats.hasClueInInventory() && invIcon != null)
				{
					final int invIconX = anchorRight
						? clueX
						: clueX + clueImage.getWidth() - invIcon.getWidth();

					final int invIconY = currentY + clueImage.getHeight() - invIcon.getHeight();
					graphics.drawImage(invIcon, invIconX, invIconY, null);
				}

				if (stats.hasClueInBank() && bankIcon != null)
				{
					final int bankIconX = anchorRight
						? clueX
						: clueX + clueImage.getWidth() - bankIcon.getWidth();

					final int bankIconY = currentY + clueImage.getHeight() - bankIcon.getHeight();
					graphics.drawImage(bankIcon, bankIconX, bankIconY, null);
				}

				final int pipX = anchorRight
					? clueX + clueImage.getWidth()
					: clueX - pipImage.getWidth();

				final int pipStartY = currentY + clueImage.getHeight();

				if (stats.getTotalBoxes() == stats.getMaxClueCount() && activeClueSaver != null)
				{
					graphics.drawImage(activeClueSaver, clueX, currentY, null);
				}

				for (int pip = stats.getMaxClueCount() - 1; pip >= 0; pip--)
				{
					int pipY = pipStartY - ((pip + 1) * (pipImage.getHeight() - PIP_VERTICAL_OVERLAP)) - PIP_ADDITIONAL_Y_OFFSET;

					BufferedImage pipToDraw;
					if (stats.getTotalBoxes() == stats.getMaxClueCount())
					{
						pipToDraw = pipRedImage;
					}
					else if (stats.getMaxClueCount() - stats.getTotalBoxes() == 1 && pip < stats.getTotalBoxes())
					{
						pipToDraw = pipOrangeImage;
					}
					else if (pip < stats.getTotalBoxes())
					{
						pipToDraw = pipGreenImage;
					}
					else
					{
						pipToDraw = pipImage;
					}

					if (anchorRight)
					{
						graphics.translate(pipX + pipToDraw.getWidth(), pipY);
						graphics.scale(-1, 1);
						graphics.drawImage(pipToDraw, 0, 0, null);
						graphics.scale(-1, 1);
						graphics.translate(-(pipX + pipToDraw.getWidth()), -pipY);
					}
					else
					{
						graphics.drawImage(pipToDraw, pipX, pipY, null);
					}
				}

				updateIconBounds(tier, clueX, currentY, clueImage);

				currentY = nextY;
			}
		}

		BufferedImage buttonToDraw = isButtonHovered ? buttonUIHoveredImage : buttonUIImage;
		final int buttonWidth = buttonToDraw.getWidth();
		final int buttonHeight = buttonToDraw.getHeight();

		final int buttonUIX = anchorRight
			? (isExpanded
			? closedUIX - (int)Math.round(0.5 * expandedUIWidth) - buttonWidth + 1
			: closedUIX - buttonWidth)
			: (closedUIX + closedUIImage.getWidth() + (isExpanded ? EXPANDED_BUTTON_LEFT_OFFSET : 0)) - 1;

		final int buttonUIY = closedUIY + BUTTON_VERTICAL_OFFSET;

		if (anchorRight)
		{
			graphics.drawImage(buttonToDraw,
				buttonUIX + buttonWidth, buttonUIY,
				-buttonWidth, buttonHeight,
				null);
		}
		else
		{
			graphics.drawImage(buttonToDraw, buttonUIX, buttonUIY, null);
		}

		buttonBounds = new Rectangle(buttonUIX, buttonUIY, buttonWidth, buttonHeight);

		return null;
	}

	private void updateIconBounds(ClueTier tier, int x, int y, BufferedImage image)
	{
		Rectangle bounds = new Rectangle(x, y, image.getWidth(), image.getHeight());
		switch (tier)
		{
			case BEGINNER:
				beginnerIconBounds = bounds;
				break;
			case EASY:
				easyIconBounds = bounds;
				break;
			case MEDIUM:
				mediumIconBounds = bounds;
				break;
			case HARD:
				hardIconBounds = bounds;
				break;
			case ELITE:
				eliteIconBounds = bounds;
				break;
			case MASTER:
				masterIconBounds = bounds;
				break;
		}
	}

	private void updateVisibilityIfNeeded()
	{
		if (visibilityNeedsUpdate || hasBoxCountChanged())
		{
			cachedVisibleTierCount = 0;
			for (ClueTier tier : ClueTier.values())
			{
				if (shouldShowTier(tier))
				{
					cachedVisibleTierCount++;
				}
			}
			visibilityNeedsUpdate = false;
		}
	}

	private Rectangle getIconBounds(ClueTier tier)
	{
		switch (tier)
		{
			case BEGINNER: return beginnerIconBounds;
			case EASY: return easyIconBounds;
			case MEDIUM: return mediumIconBounds;
			case HARD: return hardIconBounds;
			case ELITE: return eliteIconBounds;
			case MASTER: return masterIconBounds;
			default: return new Rectangle();
		}
	}

	private BufferedImage getClueImage(ClueTier tier)
	{
		switch (tier)
		{
			case BEGINNER: return clueScrollBeginnerImage;
			case EASY: return clueScrollEasyImage;
			case MEDIUM: return clueScrollMediumImage;
			case HARD: return clueScrollHardImage;
			case ELITE: return clueScrollEliteImage;
			case MASTER: return clueScrollMasterImage;
			default: return null;
		}
	}

	private static class TierStats
	{
		@Getter
		private final int totalBoxes;
		@Getter
		private final int maxClueCount;
		private final boolean hasClueInInventory;
		private final boolean hasClueInBank;

		public TierStats(int totalBoxes, int maxClueCount, boolean hasClueInInventory, boolean hasClueInBank)
		{
			this.totalBoxes = totalBoxes;
			this.maxClueCount = maxClueCount;
			this.hasClueInInventory = hasClueInInventory;
			this.hasClueInBank = hasClueInBank;
		}

		public boolean hasClueInInventory()
		{
			return hasClueInInventory;
		}

		public boolean hasClueInBank()
		{
			return hasClueInBank;
		}
	}

	private TierStats calculateTierStats(ClueTier tier)
	{
		int totalBoxes = 0;
		boolean hasClueInInventory = false;
		boolean hasClueInBank = false;

		String savingCause = clueSaverPlugin.getTierSavingCause(tier, true);
		if (savingCause != null)
		{
			String cleanedCause = savingCause
				.replaceAll("<col=[^>]+>", "")
				.replaceAll("</col>", "");

			String[] parts = cleanedCause.split(" \\| ");
			for (String part : parts)
			{
				if (config.separateBoxCounts())
				{
					String[] lines = part.split("<br>");
					for (String line : lines)
					{
						line = line.trim();
						if (line.contains("Inv Boxes:"))
						{
							try
							{
								String countStr = line.substring(line.indexOf("Inv Boxes:") + "Inv Boxes:".length()).trim();
								totalBoxes += Integer.parseInt(countStr);
							}
							catch (Exception e)
							{
								log.debug("Error processing Inv Boxes", e);
							}
						}
						if (line.contains("Bank Boxes:"))
						{
							try
							{
								String countStr = line.substring(line.indexOf("Bank Boxes:") + "Bank Boxes:".length()).trim();
								totalBoxes += Integer.parseInt(countStr);
							}
							catch (Exception e)
							{
								log.debug("Error processing Bank Boxes", e);
							}
						}
						if (line.contains("Clue in inventory"))
						{
							hasClueInInventory = true;
							totalBoxes++;
						}
						else if (line.contains("Clue in bank"))
						{
							hasClueInBank = true;
							totalBoxes++;
						}
					}
				}
				else
				{
					if (part.contains("Scroll Boxes:"))
					{
						try
						{
							String countStr = part.substring(part.indexOf("Scroll Boxes:") + "Scroll Boxes:".length()).trim();
							totalBoxes = Integer.parseInt(countStr);
						}
						catch (Exception e)
						{
							log.debug("Error processing Scroll Boxes", e);
						}
					}
					if (part.contains("Clue in inventory"))
					{
						hasClueInInventory = true;
						totalBoxes++;
					}
					else if (part.contains("Clue in bank"))
					{
						hasClueInBank = true;
						totalBoxes++;
					}
				}
			}
		}
		int maxClueCount = clueSaverUtils.getMaxClueCount(tier, client);
		return new TierStats(totalBoxes, maxClueCount, hasClueInInventory, hasClueInBank);
	}

	private boolean shouldShowTier(ClueTier tier)
	{
		switch (tier)
		{
			case BEGINNER:
				return clueSaverPlugin.getClueStates().shouldShowBeginner(config);
			case EASY:
				return clueSaverPlugin.getClueStates().shouldShowEasy(config);
			case MEDIUM:
				return clueSaverPlugin.getClueStates().shouldShowMedium(config);
			case HARD:
				return clueSaverPlugin.getClueStates().shouldShowHard(config);
			case ELITE:
				return clueSaverPlugin.getClueStates().shouldShowElite(config);
			case MASTER:
				return clueSaverPlugin.getClueStates().shouldShowMaster(config);
			default:
				return false;
		}
	}

	private boolean hasBoxCountChanged()
	{
		int currentTotalBoxes = 0;
		for (ClueTier tier : ClueTier.values())
		{
			currentTotalBoxes += calculateTierStats(tier).getTotalBoxes();
		}

		if (currentTotalBoxes != previousTotalBoxes)
		{
			previousTotalBoxes = currentTotalBoxes;
			return true;
		}
		return false;
	}

	public void setVisible(boolean visible)
	{
		this.shouldDraw = visible;
	}

	public void onConfigChanged()
	{
		visibilityNeedsUpdate = true;
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e)
	{
		return e;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e)
	{
		if (buttonBounds != null && buttonBounds.contains(e.getPoint()))
		{
			e.consume();
		}
		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e)
	{
		if (buttonBounds != null && buttonBounds.contains(e.getPoint()))
		{
			isExpanded = !isExpanded;
			isButtonHovered = false;
			e.consume();
		}
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e)
	{
		if (buttonBounds != null)
		{
			boolean wasHovered = isButtonHovered;
			isButtonHovered = buttonBounds.contains(e.getPoint());
			if (wasHovered != isButtonHovered)
			{
				e.consume();
			}
		}
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e)
	{
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e)
	{
		isButtonHovered = false;
		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e)
	{
		return e;
	}
}

package com.cluesaver;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ClueSaverPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ClueSaverPlugin.class);
		RuneLite.main(args);
	}
}
