package com.accessibilityplus;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("accessibilityplus")
public interface AccessibilityPlusConfig extends Config
{
    @ConfigSection(
            name = "Dialog",
            description = "Accessibility dialog overlay settings",
            position = 0
    )
    String dialogSection = "dialogSection";

    @ConfigSection(
            name = "Speech",
            description = "Text-to-speech settings",
            position = 1
    )
    String speechSection = "speechSection";

    @ConfigSection(
            name = "Minimap",
            description = "Minimap shapes overlay settings",
            position = 2
    )
    String minimapSection = "minimapSection";

    enum DialogTheme
    {
        PARCHMENT,
        BLACK_PANEL
    }

    // --------------------
    // Dialog
    // --------------------

    @ConfigItem(
            keyName = "enableDialogOverlay",
            name = "Enable accessibility dialog",
            description = "Enable the large, readable dialog overlay.",
            section = dialogSection,
            position = 0
    )
    default boolean enableDialogOverlay()
    {
        return true;
    }

    @ConfigItem(
            keyName = "hideNativeDialog",
            name = "Hide native dialog",
            description = "Draw over the native dialog area so only the accessibility overlay is visible.",
            section = dialogSection,
            position = 1
    )
    default boolean hideNativeDialog()
    {
        return true;
    }

    @ConfigItem(
            keyName = "dialogTheme",
            name = "Dialog theme",
            description = "Visual theme for the dialog overlay.",
            section = dialogSection,
            position = 2
    )
    default DialogTheme dialogTheme()
    {
        return DialogTheme.BLACK_PANEL;
    }

    @Range(min = 12, max = 48)
    @ConfigItem(
            keyName = "dialogFontSize",
            name = "Text size",
            description = "Font size for dialog text and options.",
            section = dialogSection,
            position = 3
    )
    default int dialogFontSize()
    {
        return 28;
    }

    @Range(min = 320, max = 1000)
    @ConfigItem(
            keyName = "dialogPanelWidth",
            name = "Dialog width",
            description = "Width of the dialog overlay in pixels.",
            section = dialogSection,
            position = 4
    )
    default int dialogPanelWidth()
    {
        return 720;
    }

    @Range(min = 40, max = 255)
    @ConfigItem(
            keyName = "dialogOverlayOpacity",
            name = "Background opacity",
            description = "Opacity for the dialog overlay background.",
            section = dialogSection,
            position = 5
    )
    default int dialogOverlayOpacity()
    {
        return 240;
    }

    // --------------------
    // Speech
    // --------------------

    @ConfigItem(
            keyName = "enableTts",
            name = "Enable TTS",
            description = "Enable text-to-speech for dialog and option menus. When enabled, dialog text is sent to a fixed external speech service to generate WAV audio.",
            section = speechSection,
            position = 0
    )
    default boolean enableTts()
    {
        return false;
    }

    /**
     * This exists to satisfy your current code path:
     * AccessibilityPlusPlugin listens for ConfigChanged with key "testTts"
     * and then checks config.testTts().
     *
     * This is implemented as a toggle to restore compilation.
     * If you want a real "button", we can convert your plugin code to use ConfigButtonPressed.
     */
    @ConfigItem(
            keyName = "testTts",
            name = "Test TTS",
            description = "Toggle on to test TTS. If your plugin speaks, toggle back off.",
            section = speechSection,
            position = 1
    )
    default boolean testTts()
    {
        return false;
    }

    @Range(min = 0, max = 10)
    @ConfigItem(
            keyName = "cloudTtsRate",
            name = "Speech rate",
            description = "Speech rate parameter sent to the service.",
            section = speechSection,
            position = 2
    )
    default int cloudTtsRate()
    {
        return 1;
    }

    @Range(min = 0, max = 50)
    @ConfigItem(
            keyName = "cloudTtsVoice",
            name = "Voice",
            description = "Voice parameter sent to the service.",
            section = speechSection,
            position = 3
    )
    default int cloudTtsVoice()
    {
        return 0;
    }

    @ConfigItem(
            keyName = "ttsSpeakDialog",
            name = "Speak dialog lines",
            description = "Speak NPC dialog lines when they appear.",
            section = speechSection,
            position = 10
    )
    default boolean ttsSpeakDialog()
    {
        return true;
    }

    @ConfigItem(
            keyName = "ttsIncludeSpeaker",
            name = "Include speaker name",
            description = "Include the speaker name before dialog lines.",
            section = speechSection,
            position = 11
    )
    default boolean ttsIncludeSpeaker()
    {
        return true;
    }

    @ConfigItem(
            keyName = "ttsSpeakOptions",
            name = "Speak dialog options",
            description = "Speak option menus when they appear.",
            section = speechSection,
            position = 12
    )
    default boolean ttsSpeakOptions()
    {
        return true;
    }

    @Range(min = 0, max = 5000)
    @ConfigItem(
            keyName = "ttsCooldownMs",
            name = "Cooldown (ms)",
            description = "Minimum milliseconds between spoken phrases.",
            section = speechSection,
            position = 13
    )
    default int ttsCooldownMs()
    {
        return 700;
    }

    // --------------------
    // Minimap
    // --------------------

    @ConfigItem(
            keyName = "enableMinimapShapes",
            name = "Enable minimap shapes",
            description = "Enable accessibility shapes on the minimap.",
            section = minimapSection,
            position = 0
    )
    default boolean enableMinimapShapes()
    {
        return true;
    }

    @Range(min = 2, max = 20)
    @ConfigItem(
            keyName = "minimapShapeSize",
            name = "Shape size",
            description = "Size of minimap shapes.",
            section = minimapSection,
            position = 1
    )
    default int minimapShapeSize()
    {
        return 4;
    }

    @ConfigItem(
            keyName = "showLocalPlayerOnMinimapShapes",
            name = "Show local player",
            description = "Draw a shape for your player on the minimap.",
            section = minimapSection,
            position = 2
    )
    default boolean showLocalPlayerOnMinimapShapes()
    {
        return true;
    }

    @ConfigItem(
            keyName = "showPlayersOnMinimapShapes",
            name = "Show other players",
            description = "Draw shapes for other players on the minimap.",
            section = minimapSection,
            position = 3
    )
    default boolean showPlayersOnMinimapShapes()
    {
        return true;
    }

    @ConfigItem(
            keyName = "showNpcsOnMinimapShapes",
            name = "Show NPCs",
            description = "Draw shapes for NPCs on the minimap.",
            section = minimapSection,
            position = 4
    )
    default boolean showNpcsOnMinimapShapes()
    {
        return true;
    }

    @Range(min = 40, max = 255)
    @ConfigItem(
            keyName = "minimapShapeOpacity",
            name = "Opacity",
            description = "Opacity for minimap shapes.",
            section = minimapSection,
            position = 5
    )
    default int minimapShapeOpacity()
    {
        return 220;
    }
}

package com.accessibilityplus;

import com.accessibilityplus.tts.TtsController;
import com.google.inject.Provides;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
    name = "Accessibility Plus",
    description = "Accessibility improvements: large dialog overlay + minimap shapes + optional TTS via cloud service.",
    tags = {"accessibility", "dialog", "overlay", "tts", "minimap"}
)
public class AccessibilityPlusPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private AccessibilityPlusConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private DialogTextOverlay dialogTextOverlay;

    @Inject
    private MinimapShapesOverlay minimapShapesOverlay;

    @Inject
    private TtsController ttsController;

    @Getter
    private String speakerName = "";

    @Getter
    private String dialogText = "";

    @Getter
    private boolean chatboxInputOpen = false;

    @Getter
    private final List<String> dialogOptions = new ArrayList<>();

    @Getter
    private Rectangle dialogBounds = null;

    // --------------------
    // TTS timing / stability helpers
    // --------------------
    private String pendingOptionsKey = "";
    private long pendingOptionsFirstSeenAt = 0L;

    // Cache option roots so we don't brute-scan thousands of widgets every tick
    private final List<WidgetRef> cachedOptionRoots = new ArrayList<>();

    private static final class WidgetRef
    {
        private final int group;
        private final int child;

        private WidgetRef(int group, int child)
        {
            this.group = group;
            this.child = child;
        }
    }

    @Provides
    AccessibilityPlusConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(AccessibilityPlusConfig.class);
    }

    @Override
    protected void startUp()
    {
        overlayManager.add(dialogTextOverlay);
        overlayManager.add(minimapShapesOverlay);

        if (ttsController != null)
        {
            ttsController.refreshEngine();
        }
    }

    @Override
    protected void shutDown()
    {
        overlayManager.remove(dialogTextOverlay);
        overlayManager.remove(minimapShapesOverlay);

        try
        {
            if (ttsController != null)
            {
                ttsController.shutdown();
            }
        }
        catch (Exception ignored)
        {
        }

        speakerName = "";
        dialogText = "";
        chatboxInputOpen = false;
        dialogOptions.clear();
        dialogBounds = null;

        pendingOptionsKey = "";
        pendingOptionsFirstSeenAt = 0L;
        cachedOptionRoots.clear();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!"accessibilityplus".equals(event.getGroup()))
        {
            return;
        }

        // Emulate "button" behavior via boolean toggle
        if ("testTts".equals(event.getKey()) && config.testTts())
        {
            configManager.setConfiguration("accessibilityplus", "testTts", false);
            clientThread.invokeLater(() ->
            {
                try
                {
                    ttsController.speakTest();
                }
                catch (Exception ignored)
                {
                }
            });
            return;
        }

        // Rebuild speech engine on relevant config changes
        String key = event.getKey();
        if ("enableTts".equals(key) || key.startsWith("cloudTts") || key.startsWith("tts"))
        {
            clientThread.invokeLater(() ->
            {
                try
                {
                    ttsController.refreshEngine();
                }
                catch (Exception ignored)
                {
                }
            });
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked ev)
    {
        if (ttsController == null || !config.enableTts())
        {
            return;
        }

        // When the user clicks to continue or chooses an option, immediately stop current playback
        // and suppress reading the old option list again.
        ttsController.onUserAdvanceDialog();
        pendingOptionsKey = "";
        pendingOptionsFirstSeenAt = 0L;
    }

    @Subscribe
    public void onGameTick(GameTick tick)
    {
        if (client == null || client.getGameState() != GameState.LOGGED_IN)
        {
            speakerName = "";
            dialogText = "";
            chatboxInputOpen = false;
            dialogOptions.clear();
            dialogBounds = null;
            return;
        }

        chatboxInputOpen = isChatboxTyping();

        if (!config.enableDialogOverlay())
        {
            speakerName = "";
            dialogText = "";
            dialogOptions.clear();
            dialogBounds = null;
            return;
        }

        String npcName = getTextSafe(ComponentID.DIALOG_NPC_NAME);
        String npcText = getTextSafe(ComponentID.DIALOG_NPC_TEXT);

        if (!isBlank(npcText))
        {
            speakerName = clean(npcName);
            dialogText = clean(npcText);
        }
        else
        {
            String playerText = getTextSafe(ComponentID.DIALOG_PLAYER_TEXT);
            if (!isBlank(playerText))
            {
                speakerName = "You";
                dialogText = clean(playerText);
            }
            else
            {
                speakerName = "";
                dialogText = "";
            }
        }

        updateDialogOptionsAndBounds();

        if (config.enableTts() && ttsController != null)
        {
            String speakSpeaker = speakerName;
            String speakDialog = dialogText;

            List<String> speakOptions = null;

            // Only attempt to speak options when there are options on screen.
            if (!dialogOptions.isEmpty())
            {
                StringBuilder sb = new StringBuilder();
                int n = Math.min(10, dialogOptions.size());
                for (int i = 0; i < n; i++)
                {
                    String o = dialogOptions.get(i);
                    if (o != null)
                    {
                        sb.append(o.trim());
                    }
                    sb.append('|');
                }

                String optionsKey = sb.toString();
                long now = System.currentTimeMillis();

                if (!optionsKey.equals(pendingOptionsKey))
                {
                    pendingOptionsKey = optionsKey;
                    pendingOptionsFirstSeenAt = now;
                }

                // Require a short stable window before speaking.
                if (now - pendingOptionsFirstSeenAt >= 250L)
                {
                    speakOptions = dialogOptions;
                }
            }
            else
            {
                pendingOptionsKey = "";
                pendingOptionsFirstSeenAt = 0L;
            }

            ttsController.updateFromDialog(speakSpeaker, speakDialog, speakOptions);
        }
    }

    private boolean isChatboxTyping()
    {
        Widget chatboxInput = client.getWidget(ComponentID.CHATBOX_INPUT);
        return chatboxInput != null && !chatboxInput.isHidden();
    }

    private String getTextSafe(int componentId)
    {
        try
        {
            Widget w = client.getWidget(componentId);
            return w == null ? null : w.getText();
        }
        catch (Exception e)
        {
            return null;
        }
    }

    private void updateDialogOptionsAndBounds()
    {
        dialogOptions.clear();
        dialogBounds = null;

        // Anchor bounds to actual dialog widgets (safe, small)
        unionBounds(client.getWidget(ComponentID.DIALOG_NPC_TEXT));
        unionBounds(client.getWidget(ComponentID.DIALOG_PLAYER_TEXT));
        unionBounds(client.getWidget(ComponentID.DIALOG_NPC_NAME));

        final int[] candidateGroups = new int[]{219, 231, 193, 162, 161};
        final int maxChildScan = 1400;

        final List<WidgetRef> rootsToScan = new ArrayList<>();

        for (WidgetRef ref : cachedOptionRoots)
        {
            Widget root = client.getWidget(ref.group, ref.child);
            if (root == null || root.isHidden())
            {
                continue;
            }
            if (containsSelectAnOption(root, 0))
            {
                rootsToScan.add(ref);
            }
        }

        if (rootsToScan.isEmpty())
        {
            outer:
            for (int group : candidateGroups)
            {
                for (int child = 0; child < maxChildScan; child++)
                {
                    Widget root = client.getWidget(group, child);
                    if (root == null || root.isHidden())
                    {
                        continue;
                    }
                    if (containsSelectAnOption(root, 0))
                    {
                        rootsToScan.add(new WidgetRef(group, child));
                        if (rootsToScan.size() >= 3)
                        {
                            break outer;
                        }
                    }
                }
            }

            cachedOptionRoots.clear();
            cachedOptionRoots.addAll(rootsToScan);
        }

        if (rootsToScan.isEmpty())
        {
            return;
        }

        final List<OptionCandidate> candidates = new ArrayList<>();

        for (WidgetRef ref : rootsToScan)
        {
            Widget root = client.getWidget(ref.group, ref.child);
            if (root == null || root.isHidden())
            {
                continue;
            }
            collectOptionCandidates(root, 0, candidates);
        }

        candidates.sort(Comparator
            .comparingInt((OptionCandidate c) -> c.bounds != null ? c.bounds.y : Integer.MAX_VALUE)
            .thenComparingInt(c -> c.bounds != null ? c.bounds.x : Integer.MAX_VALUE));

        Map<String, Boolean> seen = new LinkedHashMap<>();
        for (OptionCandidate c : candidates)
        {
            if (!seen.containsKey(c.text))
            {
                seen.put(c.text, Boolean.TRUE);
                dialogOptions.add(c.text);
                unionBoundsByRect(c.bounds);
            }
            if (dialogOptions.size() >= 10)
            {
                break;
            }
        }

        ensureDialogBoundsHeightForOptions(dialogOptions.size());
        clampDialogBoundsToCanvas();
    }

    private void clampDialogBoundsToCanvas()
    {
        if (dialogBounds == null || client == null)
        {
            return;
        }

        int cw = client.getCanvasWidth();
        int ch = client.getCanvasHeight();

        if (cw <= 0 || ch <= 0)
        {
            return;
        }

        int x = Math.max(0, dialogBounds.x);
        int y = Math.max(0, dialogBounds.y);
        int w = Math.min(dialogBounds.width, cw - x);
        int h = Math.min(dialogBounds.height, ch - y);

        if (w <= 0 || h <= 0)
        {
            dialogBounds = null;
            return;
        }

        dialogBounds = new Rectangle(x, y, w, h);
    }

    private void ensureDialogBoundsHeightForOptions(int optionCount)
    {
        if (dialogBounds == null || optionCount <= 0)
        {
            return;
        }

        final int topPadding = 18;
        final int bottomPadding = 18;
        final int perOptionHeight = 32;
        final int headerHeight = 18;

        int needed = topPadding + headerHeight + bottomPadding + (optionCount * perOptionHeight);

        if (dialogBounds.height < needed)
        {
            dialogBounds = new Rectangle(dialogBounds.x, dialogBounds.y, dialogBounds.width, needed);
        }
    }

    private static final class OptionCandidate
    {
        private final String text;
        private final Rectangle bounds;

        private OptionCandidate(String text, Rectangle bounds)
        {
            this.text = text;
            this.bounds = bounds;
        }
    }

    private boolean isOptionMenuHeaderText(String lowerText)
    {
        if (lowerText == null || lowerText.isEmpty())
        {
            return false;
        }

        return lowerText.contains("select an option")
            || lowerText.contains("what would you like to say")
            || lowerText.contains("what would you like to do")
            || lowerText.contains("what would you like to ask");
    }

    private boolean containsSelectAnOption(Widget w, int depth)
    {
        if (w == null || w.isHidden() || depth > 10)
        {
            return false;
        }

        String t = clean(w.getText()).toLowerCase();
        if (isOptionMenuHeaderText(t))
        {
            unionBounds(w);
            return true;
        }

        Widget[] children = w.getChildren();
        if (children != null)
        {
            for (Widget c : children)
            {
                if (containsSelectAnOption(c, depth + 1))
                {
                    return true;
                }
            }
        }

        Widget[] staticChildren = w.getStaticChildren();
        if (staticChildren != null)
        {
            for (Widget c : staticChildren)
            {
                if (containsSelectAnOption(c, depth + 1))
                {
                    return true;
                }
            }
        }

        Widget[] dyn = w.getDynamicChildren();
        if (dyn != null)
        {
            for (Widget c : dyn)
            {
                if (containsSelectAnOption(c, depth + 1))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private void collectOptionCandidates(Widget w, int depth, List<OptionCandidate> out)
    {
        if (w == null || w.isHidden() || depth > 10)
        {
            return;
        }

        String t = clean(w.getText());
        if (!t.isEmpty())
        {
            String lower = t.toLowerCase();

            if (isOptionMenuHeaderText(lower))
            {
                unionBounds(w);
            }
            else if (lower.contains("select an option") || lower.contains("click here to continue"))
            {
                unionBounds(w);
            }
            else
            {
                if (!t.equalsIgnoreCase(clean(dialogText)) && !t.equalsIgnoreCase(clean(speakerName)))
                {
                    if (!isChatTabLabel(lower) && looksLikeOptionLabel(t))
                    {
                        out.add(new OptionCandidate(t, w.getBounds()));
                    }
                }
            }
        }

        Widget[] children = w.getChildren();
        if (children != null)
        {
            for (Widget c : children)
            {
                collectOptionCandidates(c, depth + 1, out);
            }
        }

        Widget[] dyn = w.getDynamicChildren();
        if (dyn != null)
        {
            for (Widget c : dyn)
            {
                collectOptionCandidates(c, depth + 1, out);
            }
        }
    }

    private static boolean isChatTabLabel(String lower)
    {
        return lower.equals("all") || lower.equals("game") || lower.equals("public") || lower.equals("private")
            || lower.equals("channel") || lower.equals("clan") || lower.equals("trade") || lower.equals("friends");
    }

    private static boolean looksLikeOptionLabel(String t)
    {
        if (t == null)
        {
            return false;
        }

        String s = t.trim();
        if (s.length() < 2)
        {
            return false;
        }

        if (s.equalsIgnoreCase("on") || s.equalsIgnoreCase("off"))
        {
            return false;
        }

        if (s.matches("^\\d+\\.$"))
        {
            return false;
        }

        if (s.matches("^\\d+$") || s.matches("^\\d+:\\d+(?::\\d+)?$"))
        {
            return false;
        }

        if (looksLikeChatLine(s))
        {
            return false;
        }

        if (looksLikeSystemChatNoise(s))
        {
            return false;
        }

        return true;
    }

    private static boolean looksLikeChatLine(String s)
    {
        return s != null && s.trim().matches("^[A-Za-z0-9 _\\-]{1,12}:\\s+.+$");
    }

    private static boolean looksLikeSystemChatNoise(String s)
    {
        if (s == null)
        {
            return false;
        }
        String lower = s.trim().toLowerCase();
        return lower.contains("press enter to chat");
    }

    private void unionBoundsByRect(Rectangle b)
    {
        if (b == null)
        {
            return;
        }
        if (dialogBounds == null)
        {
            dialogBounds = new Rectangle(b);
        }
        else
        {
            dialogBounds = dialogBounds.union(b);
        }
    }

    private void unionBounds(Widget w)
    {
        if (w == null)
        {
            return;
        }
        Rectangle b = w.getBounds();
        if (b == null)
        {
            return;
        }
        if (dialogBounds == null)
        {
            dialogBounds = new Rectangle(b);
        }
        else
        {
            dialogBounds = dialogBounds.union(b);
        }
    }

    private static boolean isBlank(String s)
    {
        return s == null || s.trim().isEmpty();
    }

    private static String clean(String s)
    {
        if (s == null)
        {
            return "";
        }
        return s.replaceAll("<[^>]*>", " ")
            .replace('\u00A0', ' ')
            .trim()
            .replaceAll("\\s+", " ");
    }
}

package com.accessibilityplus;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.RoundRectangle2D;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Accessibility-first dialog overlay.
 * Renders a single, authoritative dialog surface:
 *  - Speaker
 *  - Current line (no history)
 *  - Response options (as large blocks)
 *
 * Optionally draws an opaque backdrop over the native dialog widgets.
 */
public class DialogTextOverlay extends Overlay
{
    private final AccessibilityPlusPlugin plugin;
    private final AccessibilityPlusConfig config;

    @Inject
    public DialogTextOverlay(AccessibilityPlusPlugin plugin, AccessibilityPlusConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D g)
    {
        if (!config.enableDialogOverlay())
        {
            return null;
        }

        final String speaker = plugin.getSpeakerName();
        final String line = plugin.getDialogText();
        final List<String> options = plugin.getDialogOptions();
        final Rectangle anchor = plugin.getDialogBounds();

        final boolean hasLine = line != null && !line.isBlank();
        final boolean hasOptions = options != null && !options.isEmpty();

        if (!hasLine && !hasOptions)
        {
            return null;
        }

        Rectangle bounds = anchor != null ? new Rectangle(anchor) : g.getClipBounds();
        if (bounds == null)
        {
            return null;
        }

        // Expand a bit so we cover the full native dialog area
        bounds.grow(8, 8);

        int width = Math.min(config.dialogPanelWidth(), bounds.width);
        int pad = 16;
        int opacity = clamp(config.dialogOverlayOpacity(), 40, 255);

        int x = bounds.x + (bounds.width - width) / 2;
        int yTop = bounds.y;
        int bottomAnchor = bounds.y + bounds.height;

        Palette pal = paletteFor(config.dialogTheme(), x, yTop, bounds.height, opacity);

        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

        Font base = g.getFont();
        Font dialogFont = base.deriveFont((float) config.dialogFontSize());
        Font optFont = base.deriveFont((float) Math.max(12, config.dialogFontSize() - 2));

        // Build wrapped lines for current dialog only
        List<String> dialogLines = new ArrayList<>();
        g.setFont(dialogFont);
        FontMetrics dfm = g.getFontMetrics();
        int innerW = Math.max(160, width - pad * 2);

        if (speaker != null && !speaker.isBlank())
        {
            dialogLines.add(speaker.trim());
        }

        if (hasLine)
        {
            dialogLines.addAll(TextWrapUtil.wrap(dfm, line.trim(), innerW));
        }

        // Wrap options as rows
        List<List<String>> optionWrapped = new ArrayList<>();
        if (hasOptions)
        {
            g.setFont(optFont);
            FontMetrics ofm = g.getFontMetrics();

            int idx = 1;
            for (String opt : options)
            {
                String label = idx + ". " + opt;
                optionWrapped.add(TextWrapUtil.wrap(ofm, label, innerW));
                idx++;
            }
        }

        // Measure height
        int dialogLineH = dfm.getHeight();
        g.setFont(optFont);
        FontMetrics ofm2 = g.getFontMetrics();
        int optLineH = ofm2.getHeight();

        // Row style (Option A: separators)
        int rowPadY = 10;          // vertical padding inside each row
        int rowPadX = 12;          // horizontal padding inside each row
        int wrapGap = 2;           // extra gap between wrapped lines inside a row (OSRS feel)
        int rowGapTop = 8;         // gap between dialog text and first option row

        int contentH = pad * 2;

        // Dialog area
        contentH += dialogLines.size() * dialogLineH;

        // Options rows
        if (!optionWrapped.isEmpty())
        {
            contentH += rowGapTop;

            for (List<String> rowLines : optionWrapped)
            {
                int linesCount = Math.max(1, rowLines.size());
                int rowTextH = (linesCount * optLineH) + ((linesCount - 1) * wrapGap);
                int rowH = (rowPadY * 2) + rowTextH;

                contentH += rowH;

                // Divider line between rows (1px)
                contentH += 1;
            }

            // Remove divider after last row
            contentH -= 1;
        }

        // Allow the overlay to grow beyond the native dialog widget height.
        Rectangle clip = g.getClipBounds();
        int maxH = bounds.height;
        if (clip != null)
        {
            maxH = Math.max(0, clip.height - 8);
        }
        int height = Math.min(contentH, maxH);

        // Anchor to bottom and grow upward
        int y = bottomAnchor - height;
        if (clip != null)
        {
            int minY = clip.y + 4;
            int maxY = (clip.y + clip.height) - height - 4;
            if (y < minY)
            {
                y = minY;
            }
            if (y > maxY)
            {
                y = maxY;
            }
        }

        // Optional: hide the native dialog underneath
        if (config.hideNativeDialog())
        {
            g.setPaint(pal.backdropPaint);
            g.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
        }

        // Main panel
        RoundRectangle2D panel = new RoundRectangle2D.Double(x, y, width, height, 12, 12);
        g.setPaint(pal.panelPaint);
        g.fill(panel);

        // subtle double-frame for a more native bevel feel
        g.setColor(pal.border);
        g.draw(panel);

        RoundRectangle2D inner = new RoundRectangle2D.Double(x + 1, y + 1, width - 2, height - 2, 12, 12);
        g.setColor(pal.innerBorder);
        g.draw(inner);

        int cx = x + pad;
        int cy = y + pad;

        // Draw dialog lines
        g.setFont(dialogFont);

        for (int i = 0; i < dialogLines.size(); i++)
        {
            String l = dialogLines.get(i);

            Color textColor;
            if (i == 0 && speaker != null && !speaker.isBlank())
            {
                textColor = pal.speakerText;
            }
            else
            {
                textColor = pal.dialogText;
            }

            cy += dialogLineH;
            if (cy > y + height - pad)
            {
                break;
            }

            if (pal.textShadow != null)
            {
                g.setColor(pal.textShadow);
                g.drawString(l, cx + 1, cy + 1);
            }

            g.setColor(textColor);
            g.drawString(l, cx, cy);
        }

        // Draw options as rows with dividers
        if (!optionWrapped.isEmpty())
        {
            cy += rowGapTop;

            g.setFont(optFont);

            int rowsX = x + pad;
            int rowsW = width - pad * 2;

            for (int i = 0; i < optionWrapped.size(); i++)
            {
                List<String> rowLines = optionWrapped.get(i);
                int linesCount = Math.max(1, rowLines.size());
                int rowTextH = (linesCount * optLineH) + ((linesCount - 1) * wrapGap);
                int rowH = (rowPadY * 2) + rowTextH;

                // Do not draw if it would exceed the visible panel space
                if (cy + rowH > y + height - pad)
                {
                    break;
                }

                // Row background (flat, inset feel)
                g.setColor(pal.rowFill);
                g.fillRect(rowsX, cy, rowsW, rowH);

                // Row outline (very subtle, optional but helps)
                g.setColor(pal.rowOutline);
                g.drawRect(rowsX, cy, rowsW, rowH);

                int tx = rowsX + rowPadX;
                int ty = cy + rowPadY;

                // Option text
                g.setColor(pal.optionText);

                for (int li = 0; li < rowLines.size(); li++)
                {
                    ty += optLineH;
                    if (li > 0)
                    {
                        ty += wrapGap;
                    }

                    String l = rowLines.get(li);

                    if (pal.textShadow != null)
                    {
                        g.setColor(pal.textShadow);
                        g.drawString(l, tx + 1, ty + 1);
                        g.setColor(pal.optionText);
                    }

                    g.drawString(l, tx, ty);
                }

                cy += rowH;

                // Divider under row except last
                if (i < optionWrapped.size() - 1)
                {
                    g.setColor(pal.rowDivider);
                    g.drawLine(rowsX, cy, rowsX + rowsW, cy);
                    cy += 1;
                }
            }
        }

        g.setFont(base);
        return null;
    }

    private static final class Palette
    {
        final Paint panelPaint;
        final Paint backdropPaint;

        final Color border;
        final Color innerBorder;

        final Color dialogText;
        final Color speakerText;

        final Color optionText;

        // Row style paints
        final Color rowFill;
        final Color rowOutline;
        final Color rowDivider;

        final Color textShadow; // may be null

        private Palette(
                Paint panelPaint,
                Paint backdropPaint,
                Color border,
                Color innerBorder,
                Color dialogText,
                Color speakerText,
                Color optionText,
                Color rowFill,
                Color rowOutline,
                Color rowDivider,
                Color textShadow)
        {
            this.panelPaint = panelPaint;
            this.backdropPaint = backdropPaint;
            this.border = border;
            this.innerBorder = innerBorder;
            this.dialogText = dialogText;
            this.speakerText = speakerText;
            this.optionText = optionText;
            this.rowFill = rowFill;
            this.rowOutline = rowOutline;
            this.rowDivider = rowDivider;
            this.textShadow = textShadow;
        }
    }

    private static Palette paletteFor(AccessibilityPlusConfig.DialogTheme theme, int x, int y, int h, int opacity)
    {
        int a = clamp(opacity, 40, 255);
        int hh = Math.max(1, h);

        if (theme == AccessibilityPlusConfig.DialogTheme.PARCHMENT)
        {
            // Warmer/darker parchment closer to native chatbox
            Color top = new Color(214, 203, 168, a);
            Color bottom = new Color(198, 185, 150, a);
            GradientPaint gp = new GradientPaint(x, y, top, x, y + hh, bottom);

            // Borders/text: full alpha only
            Color border = new Color(112, 98, 68);
            Color innerBorder = new Color(235, 226, 198);

            Color dialogText = new Color(40, 34, 24);
            Color speaker = new Color(255, 184, 0);
            Color optionText = new Color(40, 34, 24);

            // Rows: slightly darker inset tone
            Color rowFill = new Color(205, 193, 160, a);
            Color rowOutline = new Color(140, 126, 92);   // subtle
            Color rowDivider = new Color(170, 158, 126);  // subtle

            Color shadow = new Color(120, 110, 90);

            return new Palette(gp, gp, border, innerBorder, dialogText, speaker, optionText, rowFill, rowOutline, rowDivider, shadow);
        }

        // BLACK_PANEL (default)
        Color bg = new Color(15, 15, 15, a);

        Color border = new Color(235, 235, 235);
        Color innerBorder = new Color(60, 60, 60);

        Color dialogText = new Color(235, 235, 235);
        Color speaker = new Color(255, 215, 0);
        Color optionText = new Color(235, 235, 235);

        Color rowFill = new Color(30, 30, 30, a);
        Color rowOutline = new Color(80, 80, 80);
        Color rowDivider = new Color(70, 70, 70);

        Color shadow = new Color(0, 0, 0);

        return new Palette(bg, bg, border, innerBorder, dialogText, speaker, optionText, rowFill, rowOutline, rowDivider, shadow);
    }

    private static int clamp(int v, int lo, int hi)
    {
        return Math.max(lo, Math.min(hi, v));
    }
}

package com.accessibilityplus;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.geom.Path2D;
import java.util.List;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Colorblind helper: draw high-contrast shapes on the minimap for entities.
 *
 * This does NOT modify the game's minimap colors. It only adds clear shapes
 * on top of the minimap canvas (Plugin Hub safe).
 *
 * Shapes:
 * - You: diamond
 * - Other players: square
 * - NPCs: triangle
 */
public class MinimapShapesOverlay extends Overlay
{
    private final Client client;
    private final AccessibilityPlusConfig config;

    @Inject
    public MinimapShapesOverlay(Client client, AccessibilityPlusConfig config)
    {
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D g)
    {
        if (!config.enableMinimapShapes())
        {
            return null;
        }

        int size = Math.max(2, config.minimapShapeSize());
        int alpha = clamp(config.minimapShapeOpacity(), 30, 255);

        // Very high contrast: white outline, black fill.
        Color outline = new Color(255, 255, 255, alpha);
        Color fill = new Color(0, 0, 0, alpha);

        g.setStroke(new BasicStroke(2f));

        // Local player
        if (config.showLocalPlayerOnMinimapShapes())
        {
            Player me = client.getLocalPlayer();
            if (me != null)
            {
                drawDiamond(g, me.getLocalLocation(), size + 2, fill, outline);
            }
        }

        // Other players
        if (config.showPlayersOnMinimapShapes())
        {
            List<Player> players = client.getPlayers();
            if (players != null)
            {
                for (Player p : players)
                {
                    if (p == null || p == client.getLocalPlayer())
                    {
                        continue;
                    }
                    drawSquare(g, p.getLocalLocation(), size, fill, outline);
                }
            }
        }

        // NPCs
        if (config.showNpcsOnMinimapShapes())
        {
            List<NPC> npcs = client.getNpcs();
            if (npcs != null)
            {
                for (NPC n : npcs)
                {
                    if (n == null)
                    {
                        continue;
                    }
                    drawTriangle(g, n.getLocalLocation(), size, fill, outline);
                }
            }
        }

        return null;
    }

    private void drawSquare(Graphics2D g, LocalPoint lp, int r, Color fill, Color outline)
    {
        Point p = localToMinimap(lp);
        if (p == null)
        {
            return;
        }

        int x = p.x - r;
        int y = p.y - r;
        int d = r * 2;

        g.setColor(fill);
        g.fillRect(x, y, d, d);
        g.setColor(outline);
        g.drawRect(x, y, d, d);
    }

    private void drawTriangle(Graphics2D g, LocalPoint lp, int r, Color fill, Color outline)
    {
        Point p = localToMinimap(lp);
        if (p == null)
        {
            return;
        }

        Path2D tri = new Path2D.Double();
        tri.moveTo(p.x, p.y - r);
        tri.lineTo(p.x - r, p.y + r);
        tri.lineTo(p.x + r, p.y + r);
        tri.closePath();

        g.setColor(fill);
        g.fill(tri);
        g.setColor(outline);
        g.draw(tri);
    }

    private void drawDiamond(Graphics2D g, LocalPoint lp, int r, Color fill, Color outline)
    {
        Point p = localToMinimap(lp);
        if (p == null)
        {
            return;
        }

        Path2D d = new Path2D.Double();
        d.moveTo(p.x, p.y - r);
        d.lineTo(p.x - r, p.y);
        d.lineTo(p.x, p.y + r);
        d.lineTo(p.x + r, p.y);
        d.closePath();

        g.setColor(fill);
        g.fill(d);
        g.setColor(outline);
        g.draw(d);
    }

    private Point localToMinimap(LocalPoint lp)
    {
        if (lp == null)
        {
            return null;
        }

        net.runelite.api.Point p = Perspective.localToMinimap(client, lp);
        if (p == null)
        {
            return null;
        }

        return new Point(p.getX(), p.getY());
    }

    private static int clamp(int v, int lo, int hi)
    {
        return Math.max(lo, Math.min(hi, v));
    }
}

package com.accessibilityplus;

import java.awt.FontMetrics;
import java.util.ArrayList;
import java.util.List;

/**
 * Small utility to wrap text into lines based on pixel width.
 */
public final class TextWrapUtil
{
    private TextWrapUtil()
    {
    }

    public static List<String> wrap(FontMetrics fm, String text, int maxWidthPx)
    {
        final List<String> lines = new ArrayList<>();
        if (text == null)
        {
            return lines;
        }

        String cleaned = text
            .replace('\r', ' ')
            .replace('\n', ' ')
            .replace('\t', ' ')
            .trim();

        if (cleaned.isEmpty())
        {
            return lines;
        }

        String[] words = cleaned.split("\\s+");
        StringBuilder line = new StringBuilder();

        for (String w : words)
        {
            if (line.length() == 0)
            {
                line.append(w);
                continue;
            }

            String candidate = line + " " + w;
            if (fm.stringWidth(candidate) <= maxWidthPx)
            {
                line.append(" ").append(w);
            }
            else
            {
                lines.add(line.toString());
                line.setLength(0);

                // if a single word is too long, hard-break it
                if (fm.stringWidth(w) > maxWidthPx)
                {
                    lines.addAll(hardBreakWord(fm, w, maxWidthPx));
                }
                else
                {
                    line.append(w);
                }
            }
        }

        if (line.length() > 0)
        {
            lines.add(line.toString());
        }

        return lines;
    }

    private static List<String> hardBreakWord(FontMetrics fm, String w, int maxWidthPx)
    {
        List<String> out = new ArrayList<>();
        StringBuilder part = new StringBuilder();
        for (int i = 0; i < w.length(); i++)
        {
            part.append(w.charAt(i));
            if (fm.stringWidth(part.toString()) > maxWidthPx)
            {
                // move last char to next line
                char last = part.charAt(part.length() - 1);
                part.deleteCharAt(part.length() - 1);
                if (part.length() > 0)
                {
                    out.add(part.toString());
                }
                part.setLength(0);
                part.append(last);
            }
        }
        if (part.length() > 0)
        {
            out.add(part.toString());
        }
        return out;
    }
}

package com.accessibilityplus.tts;

import com.accessibilityplus.AccessibilityPlusConfig;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Slf4j
@Singleton
public class CloudSpeechEngine implements SpeechEngine
{
    /**
     * Hardcode the only allowed endpoint for Plugin Hub compliance.
     * If you need to change it later, ship an update rather than allowing arbitrary URLs.
     */
    private static final String TTS_HOST = "ttsplugin.com";
    private static final String TTS_SCHEME = "https";

    private final OkHttpClient http;
    private final AccessibilityPlusConfig config;
    private final ScheduledExecutorService executor;
    private final WavPlayer wavPlayer;

    private volatile Call inFlight;

    @Inject
    public CloudSpeechEngine(
            OkHttpClient http,
            AccessibilityPlusConfig config,
            ScheduledExecutorService executor,
            WavPlayer wavPlayer
    )
    {
        this.http = http;
        this.config = config;
        this.executor = executor;
        this.wavPlayer = wavPlayer;
    }

    @Override
    public boolean isAvailable()
    {
        return config.enableTts();
    }

    @Override
    public void speak(String text)
    {
        if (!isAvailable())
        {
            return;
        }

        if (text == null || text.trim().isEmpty())
        {
            return;
        }

        final long gen = wavPlayer.bumpGeneration();

        Call prev = inFlight;
        if (prev != null)
        {
            prev.cancel();
        }

        executor.execute(() ->
        {
            try
            {
                HttpUrl url = new HttpUrl.Builder()
                        .scheme(TTS_SCHEME)
                        .host(TTS_HOST)
                        // If your service expects a path, set it here:
                        // .addPathSegment("tts")
                        .addQueryParameter("m", text)
                        .addQueryParameter("r", String.valueOf(config.cloudTtsRate()))
                        .addQueryParameter("v", String.valueOf(config.cloudTtsVoice()))
                        .build();

                Request req = new Request.Builder()
                        .url(url)
                        .get()
                        .build();

                Call call = http.newCall(req);
                inFlight = call;

                try (Response res = call.execute())
                {
                    if (!res.isSuccessful() || res.body() == null)
                    {
                        return;
                    }

                    byte[] wav = res.body().bytes();

                    if (wavPlayer.currentGeneration() != gen)
                    {
                        return;
                    }

                    wavPlayer.playBytesIfCurrent(wav, gen);
                }
            }
            catch (IOException e)
            {
                if (!"Canceled".equalsIgnoreCase(e.getMessage()))
                {
                    log.debug("Cloud TTS failed: {}", e.toString());
                }
            }
            catch (Exception e)
            {
                log.debug("Cloud TTS unexpected error: {}", e.toString());
            }
        });
    }

    @Override
    public void stopNow()
    {
        wavPlayer.bumpGeneration();

        Call c = inFlight;
        if (c != null)
        {
            c.cancel();
        }
    }

    @Override
    public void shutdown()
    {
        stopNow();
    }
}

package com.accessibilityplus.tts;

/**
 * No-op TTS backend (used when disabled or misconfigured).
 */
public class NoopSpeechEngine implements SpeechEngine
{
    @Override
    public boolean isAvailable()
    {
        return false;
    }

    @Override
    public void speak(String text)
    {
        // no-op
    }

    @Override
    public void stopNow()
    {
        // no-op
    }

    @Override
    public void shutdown()
    {
        // no-op
    }
}

package com.accessibilityplus.tts;

/**
 * Minimal JSON helper for small payloads like {"text":"..."}.
 * Avoids adding new dependencies.
 */
public final class SimpleJson
{
    private SimpleJson()
    {
    }

    public static String extractString(String json, String key)
    {
        if (json == null || key == null)
        {
            return null;
        }

        // Very small and forgiving parser:
        // finds "key" : "value"
        String needle = "\""+ key +"\"";
        int k = json.indexOf(needle);
        if (k < 0)
        {
            return null;
        }
        int colon = json.indexOf(':', k + needle.length());
        if (colon < 0)
        {
            return null;
        }
        int firstQuote = json.indexOf('"', colon + 1);
        if (firstQuote < 0)
        {
            return null;
        }
        int i = firstQuote + 1;
        StringBuilder sb = new StringBuilder();
        boolean esc = false;
        while (i < json.length())
        {
            char c = json.charAt(i);
            if (esc)
            {
                switch (c)
                {
                    case '"': sb.append('"'); break;
                    case '\\': sb.append('\\'); break;
                    case '/': sb.append('/'); break;
                    case 'b': sb.append('\b'); break;
                    case 'f': sb.append('\f'); break;
                    case 'n': sb.append('\n'); break;
                    case 'r': sb.append('\r'); break;
                    case 't': sb.append('\t'); break;
                    default: sb.append(c); break;
                }
                esc = false;
            }
            else
            {
                if (c == '\\')
                {
                    esc = true;
                }
                else if (c == '"')
                {
                    return sb.toString();
                }
                else
                {
                    sb.append(c);
                }
            }
            i++;
        }
        return sb.toString();
    }
}

package com.accessibilityplus.tts;

/**
 * Simple abstraction so we can swap TTS backends later.
 *
 * Contract:
 * - speak() must return quickly (do work off-thread).
 * - stopNow() should best-effort stop current and cancel queued work.
 */
public interface SpeechEngine
{
    boolean isAvailable();

    void speak(String text);

    void stopNow();

    void shutdown();
}

package com.accessibilityplus.tts;

import com.accessibilityplus.AccessibilityPlusConfig;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import okhttp3.OkHttpClient;

@Singleton
public class SpeechEngineFactory
{
    private final AccessibilityPlusConfig config;
    private final OkHttpClient http;
    private final ScheduledExecutorService executor;
    private final WavPlayer wavPlayer;

    @Inject
    public SpeechEngineFactory(
            AccessibilityPlusConfig config,
            OkHttpClient http,
            ScheduledExecutorService executor,
            WavPlayer wavPlayer
    )
    {
        this.config = config;
        this.http = http;
        this.executor = executor;
        this.wavPlayer = wavPlayer;
    }

    public SpeechEngine create()
    {
        if (!config.enableTts())
        {
            return new NoopSpeechEngine();
        }

        return new CloudSpeechEngine(http, config, executor, wavPlayer);
    }
}

package com.accessibilityplus.tts;

import com.accessibilityplus.AccessibilityPlusConfig;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;

/**
 * High-level TTS coordinator:
 * - De-dupe on dialog/options keys so we do not speak every tick.
 * - Preempt best-effort on user advancing dialog (clicking next / selecting an option).
 * - Delegates actual speech to SpeechEngine.
 */
@Slf4j
@Singleton
public class TtsController
{
    private final AccessibilityPlusConfig config;
    private final SpeechEngineFactory engineFactory;

    private volatile SpeechEngine engine;

    private final AtomicBoolean started = new AtomicBoolean(false);

    private String lastSpokenDialogKey = "";
    private String lastSpokenOptionsKey = "";
    private long lastSpokenAt = 0L;

    // When the user clicks through, suppress speaking stale option lists for a short window.
    private volatile long suppressUntil = 0L;

    @Inject
    public TtsController(AccessibilityPlusConfig config, SpeechEngineFactory engineFactory)
    {
        this.config = config;
        this.engineFactory = engineFactory;
    }

    public synchronized void refreshEngine()
    {
        shutdownEngineOnly();

        if (!config.enableTts())
        {
            engine = null;
            started.set(false);
            return;
        }

        engine = engineFactory.create();
        started.set(true);
    }

    public synchronized void shutdown()
    {
        shutdownEngineOnly();
        started.set(false);
    }

    private void shutdownEngineOnly()
    {
        SpeechEngine e = engine;
        engine = null;

        if (e != null)
        {
            try
            {
                e.shutdown();
            }
            catch (Exception ignored)
            {
            }
        }

        lastSpokenDialogKey = "";
        lastSpokenOptionsKey = "";
        lastSpokenAt = 0L;
        suppressUntil = 0L;
    }

    /**
     * Called when the user clicks "continue" or selects a menu option.
     * We cannot guarantee mid-buffer cut, but we can:
     * - cancel in-flight HTTP work
     * - invalidate any queued playback
     * - suppress repeating the old option list
     */
    public void onUserAdvanceDialog()
    {
        suppressUntil = System.currentTimeMillis() + 750L;

        SpeechEngine e = engine;
        if (e != null)
        {
            try
            {
                e.stopNow();
            }
            catch (Exception ignored)
            {
            }
        }
    }

    public void speakTest()
    {
        if (!config.enableTts())
        {
            return;
        }

        SpeechEngine e = engine;
        if (e == null)
        {
            refreshEngine();
            e = engine;
        }
        if (e == null)
        {
            return;
        }

        e.speak("Accessibility Plus text to speech test.");
    }

    public void updateFromDialog(String speaker, String dialogText, List<String> options)
    {
        if (!config.enableTts())
        {
            return;
        }

        SpeechEngine e = engine;
        if (e == null)
        {
            return;
        }

        long now = System.currentTimeMillis();
        if (now < suppressUntil)
        {
            return;
        }

        String dialogKey = buildDialogKey(speaker, dialogText);
        if (!dialogKey.isEmpty() && shouldSpeakNow(dialogKey, true))
        {
            lastSpokenDialogKey = dialogKey;
            lastSpokenAt = now;

            String phrase = buildDialogPhrase(speaker, dialogText);
            if (!phrase.isEmpty())
            {
                e.speak(phrase);
            }
        }

        if (options != null && !options.isEmpty())
        {
            String optionsKey = buildOptionsKey(options);
            if (!optionsKey.isEmpty() && shouldSpeakNow(optionsKey, false))
            {
                lastSpokenOptionsKey = optionsKey;
                lastSpokenAt = now;

                String phrase = buildOptionsPhrase(options);
                if (!phrase.isEmpty())
                {
                    e.speak(phrase);
                }
            }
        }
    }

    private boolean shouldSpeakNow(String key, boolean isDialog)
    {
        long now = System.currentTimeMillis();

        int cooldown = Math.max(0, config.ttsCooldownMs());
        if (cooldown > 0 && (now - lastSpokenAt) < cooldown)
        {
            return false;
        }

        if (isDialog)
        {
            return !Objects.equals(key, lastSpokenDialogKey);
        }
        return !Objects.equals(key, lastSpokenOptionsKey);
    }

    private static String buildDialogKey(String speaker, String dialogText)
    {
        String s = safe(speaker);
        String t = safe(dialogText);

        if (t.isEmpty())
        {
            return "";
        }

        return s + "|" + t;
    }

    private static String buildOptionsKey(List<String> options)
    {
        StringBuilder sb = new StringBuilder();
        int n = Math.min(10, options.size());
        for (int i = 0; i < n; i++)
        {
            String o = safe(options.get(i));
            if (!o.isEmpty())
            {
                sb.append(o);
            }
            sb.append('|');
        }
        return sb.toString();
    }

    private String buildDialogPhrase(String speaker, String dialogText)
    {
        String t = safe(dialogText);
        if (t.isEmpty())
        {
            return "";
        }

        if (config.ttsIncludeSpeaker() && !safe(speaker).isEmpty())
        {
            return safe(speaker) + ". " + t;
        }

        return t;
    }

    private String buildOptionsPhrase(List<String> options)
    {
        List<String> clean = new ArrayList<>();
        int n = Math.min(10, options.size());
        for (int i = 0; i < n; i++)
        {
            String o = safe(options.get(i));
            if (!o.isEmpty())
            {
                clean.add(o);
            }
        }

        if (clean.isEmpty())
        {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        sb.append("Options. ");
        for (int i = 0; i < clean.size(); i++)
        {
            sb.append(i + 1).append(". ").append(clean.get(i));
            if (i + 1 < clean.size())
            {
                sb.append(". ");
            }
        }
        return sb.toString();
    }

    private static String safe(String s)
    {
        if (s == null)
        {
            return "";
        }
        return s.trim();
    }
}

package com.accessibilityplus.tts;

import java.io.ByteArrayInputStream;
import java.util.concurrent.atomic.AtomicLong;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.audio.AudioPlayer;

@Slf4j
@Singleton
public class WavPlayer
{
    /**
     * Used to invalidate any in-flight or queued audio.
     * Bumping generation also triggers a best-effort hard cut.
     */
    private final AtomicLong generation = new AtomicLong(0);

    /**
     * AudioPlayer has no explicit stop API.
     * We approximate a hard cut by immediately playing a tiny silent WAV.
     */
    private static final float SPEECH_GAIN_DB = 0.0f;
    private static final float SILENT_GAIN_DB = -80.0f;

    // 10ms of silence, 8kHz, 16-bit, mono PCM WAV.
    private static final byte[] SILENT_WAV = new byte[] {
            82, 73, 70, 70, -60, 0, 0, 0, 87, 65, 86, 69, 102, 109, 116, 32,
            16, 0, 0, 0, 1, 0, 1, 0, 64, 31, 0, 0, -128, 62, 0, 0,
            2, 0, 16, 0, 100, 97, 116, 97, -96, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    private final AudioPlayer audioPlayer;

    /**
     * Serialize AudioPlayer calls so overlapping requests do not interleave.
     */
    private final Object playLock = new Object();

    @Inject
    public WavPlayer(final AudioPlayer audioPlayer)
    {
        this.audioPlayer = audioPlayer;
    }

    /**
     * Invalidate all current and pending audio.
     * Call this when the dialog advances, a new line appears, or an option is clicked.
     */
    public long bumpGeneration()
    {
        long gen = generation.incrementAndGet();
        hardCutBestEffort();
        return gen;
    }

    /**
     * Snapshot the current generation.
     */
    public long currentGeneration()
    {
        return generation.get();
    }

    /**
     * Play WAV bytes only if this audio still belongs to the current generation.
     *
     * IMPORTANT:
     * - No Java Sound usage (Plugin Hub rejection)
     * - No disk writes
     * - Audio is played from an in-memory stream via RuneLite's AudioPlayer
     */
    public void playBytesIfCurrent(final byte[] wavBytes, final long expectedGeneration)
    {
        if (wavBytes == null || wavBytes.length == 0)
        {
            return;
        }

        if (generation.get() != expectedGeneration)
        {
            return;
        }

        synchronized (playLock)
        {
            if (generation.get() != expectedGeneration)
            {
                return;
            }

            try
            {
                audioPlayer.play(new ByteArrayInputStream(wavBytes), SPEECH_GAIN_DB);
            }
            catch (Exception e)
            {
                log.debug("RuneLite AudioPlayer playback failed: {}", e.toString());
            }
        }
    }

    private void hardCutBestEffort()
    {
        synchronized (playLock)
        {
            try
            {
                audioPlayer.play(new ByteArrayInputStream(SILENT_WAV), SILENT_GAIN_DB);
            }
            catch (Exception ignored)
            {
            }
        }
    }
}

package com.example;

import com.accessibilityplus.AccessibilityPlusPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import org.junit.Test;

public class ExamplePluginTest
{
	@Test
	public void runClient() throws Exception
	{
		ExternalPluginManager.loadBuiltin(AccessibilityPlusPlugin.class);
		RuneLite.main(new String[]{});

		Thread.currentThread().join();
	}
}

