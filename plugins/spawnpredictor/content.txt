/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SpawnPredictorPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SpawnPredictorPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor.util;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum FightCavesNpc
{
	BAT("Bat", 1),
	BLOB("Blob", 2),
	RANGE("Ranger", 3),
	MELEE("Meleer", 4),
	MAGE("Mager", 5),
	JAD("Jad", 5);

	private final String name;
	private final int size;
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor.util;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.EnumSet;
import java.util.HashMap;

@Getter
@Slf4j
public enum StartLocations
{
	ROTATION_1(1, 2),
	ROTATION_2(2, 13),
	ROTATION_3(3, 8),
	ROTATION_4(4, 12),
	ROTATION_5(5, 7),
	ROTATION_6(6, 3),
	ROTATION_7(7, 6),
	ROTATION_8(8, 6),
	ROTATION_9(9, 14),
	ROTATION_10(10, 5),
	ROTATION_11(11, 0),
	ROTATION_12(12, 9),
	ROTATION_13(13, 1),
	ROTATION_14(14, 10),
	ROTATION_15(15, 4);

	// r = Rotation Column Number (See -> translateRotation)
	private final int r;

	// rsVal = Rotation Start Value (Where the first Bat will spawn) based off the spawn circle -> https://imgur.com/a/EOfNGEa
	private final int rsVal;

	@Getter
	private static final HashMap<Integer, Integer> lookupMap;

	static
	{
		lookupMap = new HashMap<>();

		EnumSet.allOf(StartLocations.class).forEach(n -> lookupMap.put(n.getR(), n.getRsVal()));
	}

	StartLocations(int r, int rsVal)
	{
		this.r = r;
		this.rsVal = rsVal;
	}

	/**
	 * @param r Column Number based off the 'Rotation Times Table' on the Wiki
	 * @return Inputted 'Rotation Column Number' as a proper rotation value
	 */
	public static int translateRotation(int r)
	{
		switch (r)
		{
			case 1: return 4;
			case 2: return 2;
			case 3: return 9;
			case 4: return 11;
			case 5: return 13;
			case 6: return 1;
			case 7: return 6;
			case 8: return 15;
			case 9: return 10;
			case 10: return 8;
			case 11: return 5;
			case 12: return 3;
			case 13: return 12;
			case 14: return 14;
			case 15: return 7;
		}

		log.debug("Invalid Rotation Column Number -> {}", r);
		return -1;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor.util;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class FightCavesNpcSpawn
{
	private final FightCavesNpc npc;
	private final int spawnLocation;

	@Override
	public String toString()
	{
		return String.format("%s -> %d", npc.getName(), spawnLocation);
	}
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor.util;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@EqualsAndHashCode(of = {"rotation", "wave"})
public class AccountMemory
{
    int rotation;
    int wave;

    public AccountMemory(int rotation, int wave)
    {
        this.rotation = rotation;
        this.wave = wave;
    }
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor.util;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Getter
@Slf4j
public enum SpawnLocations
{
	NW(10, 50),
	C(30, 30),
	SE(50, 25),
	S(35, 15),
	SW(10, 15);

	private final int regionX;
	private final int regionY;

	SpawnLocations(final int regionX, final int regionY)
	{
		this.regionX = regionX;
		this.regionY = regionY;
	}

	/**
	 * @param sVal Spawn Value
	 * @see StartLocations
	 * @return a Cardinal Direction holding regionX and regionY
	 */
	public static SpawnLocations lookup(int sVal)
	{
		switch (sVal)
		{
			case 3:
			case 7:
			case 12:
			{
				return SpawnLocations.NW;
			}

			case 2:
			case 8:
			case 13:
			{
				return SpawnLocations.C;
			}

			case 0:
			case 5:
			case 9:
			{
				return SpawnLocations.SE;
			}

			case 6:
			case 11:
			case 14:
			{
				return SpawnLocations.S;
			}

			case 1:
			case 4:
			case 10:
			{
				return SpawnLocations.SW;
			}
		}

		log.debug("Invalid sVal -> {}", sVal);
		return null;
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("spawnpredictor")
public interface SpawnPredictorConfig extends Config
{
	String GROUP = "spawnpredictor";

	@ConfigItem(
			name = "Debug",
			keyName = "debugOverlay",
			description = "",
			position = 0,
			hidden = true
	)
	default boolean debug()
	{
		return false;
	}

	@ConfigItem(
			name = "Lobby Rotation Info",
			keyName = "lobbyRotationInfoOverlay",
			description = "- Displays information about the current/upcoming rotation in the lobby area",
			position = 1
	)
	default boolean lobbyRotationInfoOverlay()
	{
		return false;
	}

	@ConfigItem(
			name = "Include UTC Time",
			keyName = "includeUTCTime",
			description = "- Display the UTC Time within the overlay",
			position = 2
	)
	default boolean includeUTCTime()
	{
		return false;
	}

	@ConfigItem(
			name = "Wave Display Mode",
			keyName = "displayMode",
			description = "- Choose the display mode of the overlays",
			position = 3
	)
	default DisplayMode displayMode()
	{
		return DisplayMode.OFF;
	}

	@ConfigItem(
			name = "Display Current Wave with Key",
			keyName = "displayCurrentWaveToggle",
			description = "- Only works with the 'Next Wave' display mode",
			position = 4
	)
	default CurrentWaveDisplayMode displayCurrentWave()
	{
		return CurrentWaveDisplayMode.OFF;
	}

	@ConfigItem(
			name = "Display Key",
			keyName = "displayCurrentWaveKey",
			description = "- Set a key to display the current wave with when held/pressed to toggle",
			position = 5
	)
	default Keybind displayCurrentWaveKey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			name = "Overlay Stroke Size",
			keyName = "overlayStrokeSize",
			description = "Sets the stroke size of the tile overlay",
			position = 6
	)
	@Range(max = 3, min = 1)
	@Units(Units.PIXELS)
	default int overlayStrokeSize()
	{
		return 2;
	}

	@ConfigItem(
			name = "Multicolor Names",
			keyName = "multicolorNames",
			description = "- Color the overlay names inside the Fight Caves to it's respective color.<br>" +
						  "Example: Current Wave Color = White -> Name = White<br>" +
					      "Next Wave Color = Green -> Name = Green",
			position = 7
	)
	default boolean multicolorNames()
	{
		return false;
	}

	@ConfigItem(
			name = "Current Wave Color",
			keyName = "currentWaveColor",
			description = "- Sets the current wave tile overlay colors",
			position = 8
	)
	@Alpha
	default Color currentWaveColor()
	{
		return Color.WHITE;
	}

	@ConfigItem(
			name = "Next Wave Color",
			keyName = "nextWaveColor",
			description = "- Sets the next wave tile overlay colors",
			position = 9
	)
	@Alpha
	default Color nextWaveColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
			name = "Account Memory",
			keyName = "accountMemory",
			description = "Handles storing rotation and waves on logout",
			position = 99,
			hidden = true
	)
	default Gson accountMemory()
	{
		return null;
	}

	@RequiredArgsConstructor
	@Getter
	enum DisplayMode
	{
		OFF("Off"),
		CURRENT_WAVE("Current"),
		NEXT_WAVE("Next"),
		BOTH("Both");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	@RequiredArgsConstructor
	@Getter
	enum CurrentWaveDisplayMode
	{
		OFF("Off"),
		FLASH("Flash"),
		TOGGLE("Toggle");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor;

import com.google.gson.Gson;
import com.google.inject.Provides;
import com.spawnpredictor.overlays.DebugOverlayPanel;
import com.spawnpredictor.overlays.DisplayModeOverlay;
import com.spawnpredictor.overlays.RotationOverlayPanel;
import com.spawnpredictor.util.AccountMemory;
import com.spawnpredictor.util.FightCavesNpc;
import com.spawnpredictor.util.FightCavesNpcSpawn;
import com.spawnpredictor.util.StartLocations;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.overlay.OverlayManager;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.awt.event.KeyEvent;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@PluginDescriptor(
		name = "FC Spawn Predictor",
		description = "Determine the spawn rotations for Fight Caves",
		tags = {"fight", "caves", "jad", "spawn", "predictor", "waves", "time", "timer", "rotation", "damen"}
)
@Slf4j
public class SpawnPredictorPlugin extends Plugin implements KeyListener
{
	@Inject
	private Client client;

	@Inject
	private KeyManager keyManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private RotationOverlayPanel rotationOverlayPanel;

	@Inject
	private DisplayModeOverlay displayModeOverlay;

	@Inject
	private DebugOverlayPanel debugOverlayPanel;

	@Inject
	private SpawnPredictorConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Gson gson;

	@Provides SpawnPredictorConfig providesConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SpawnPredictorConfig.class);
	}

	@Getter
	private static List<List<FightCavesNpcSpawn>> waveData = new ArrayList<>();

	@Getter
	private LocalTime serverUTCTime;

	private int serverTime = -1;
	private int oldServerTime = -1;
	private int serverTimeSecondOffset = 1;

	@Getter
	private boolean serverUTCTimeSecondSet = false;

	@Getter
	private int currentUTCTime;

	@Getter
	private int rotationCol = -1;

	@Getter
	private int currentWave = -1;

	@Getter
	private int currentRotation = -1;

	@Getter
	private static int rsVal = -1;

	@Getter
	private boolean hotkeyEnabled = false;

	private boolean active = false; // This boolean is required because of loading lines

	private boolean confirmedReset = false;

	private final Pattern WAVE_PATTERN = Pattern.compile(".*Wave: (\\d+).*");

	public boolean isFightCavesActive()
	{
		return ArrayUtils.contains(client.getMapRegions(), 9551) && client.isInInstancedRegion();
	}

	public boolean isInTzhaarArea()
	{
		return ArrayUtils.contains(client.getMapRegions(), 9808) && !client.isInInstancedRegion();
	}

	@Override
	protected void startUp()
	{
		overlayManager.add(rotationOverlayPanel);
		overlayManager.add(displayModeOverlay);
		overlayManager.add(debugOverlayPanel);

		keyManager.registerKeyListener(this);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(rotationOverlayPanel);
		overlayManager.remove(displayModeOverlay);
		overlayManager.remove(debugOverlayPanel);

		keyManager.unregisterKeyListener(this);

		reset();
	}

	private void reset()
	{
		currentUTCTime = -1;
		rotationCol = -1;
		currentWave = -1;
		currentRotation = -1;
		rsVal = -1;
		active = false;
		hotkeyEnabled = false;
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equalsIgnoreCase("spawnpredictor"))
		{
			switch (event.getKey())
			{
				case "displayMode":
				case "displayCurrentWaveToggle":
				case "displayCurrentWaveKey":
				{
					hotkeyEnabled = false;
					break;
				}
			}
		}
	}

	@Subscribe
	private void onGameTick(GameTick event)
	{
		if (!isFightCavesActive() && !confirmedReset && (isInTzhaarArea() || !client.isInInstancedRegion()))
		{
			if (client.getLocalPlayer() != null)
			{
				if (getRotationConfig(client.getLocalPlayer().getName()) != null)
				{
					removeRotationConfig(client.getLocalPlayer().getName());
				}

				confirmedReset = true;
			}
		}
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() != GameState.LOGGED_IN)
		{
			if (event.getGameState() == GameState.HOPPING || event.getGameState() == GameState.LOGIN_SCREEN)
			{
				reset();
				confirmedReset = false;
			}
			return;
		}

		if (isFightCavesActive() && !active)
		{
			AccountMemory memory = getRotationConfig(client.getLocalPlayer().getName());
			if (memory != null)
			{
				rotationCol = memory.getRotation();
				currentRotation = StartLocations.translateRotation(rotationCol);
				currentWave = memory.getWave();
			}
			else
			{
				currentRotation = StartLocations.translateRotation(rotationCol);
				currentWave = 1; // Should fix not displaying 'Wave 1' before seeing the 1st wave chat message
			}

			if (rotationCol == -1 || currentRotation == -1)
			{
				return;
			}

			rsVal = StartLocations.getLookupMap().get(currentRotation);
			updateWaveData(rsVal);
			active = true;
		}
		else if (!isFightCavesActive())
		{
			reset();
			removeRotationConfig(client.getLocalPlayer().getName());
		}
	}

	@Subscribe
	private void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (event.getMessage().contains("Your TzTok-Jad kill count"))
		{
			removeRotationConfig(client.getLocalPlayer().getName());
			return;
		}

		if (isFightCavesActive() && getCurrentRotation() != -1)
		{
			if (event.getMessage().contains("The Fight Cave has been paused."))
			{
				currentWave++;
				saveRotation(client.getLocalPlayer().getName(), rotationCol, currentWave);
				return;
			}

			final Matcher waveMatcher = WAVE_PATTERN.matcher(event.getMessage());

			if (!waveMatcher.matches())
			{
				return;
			}

			currentWave = Integer.parseInt(waveMatcher.group(1));

			if (currentWave != 0)
			{
				saveRotation(client.getLocalPlayer().getName(), rotationCol, currentWave);
			}

			if (currentRotation == 7 && currentWave == 3)
			{
				rsVal = 11; // Different spawn points on the spawn wheel for Wave 4+
				updateWaveData(rsVal);
			}
		}
	}

	private void updateWaveData(int rsVal)
	{
		waveData = calculateSpawns(rsVal);
	}

	private static List<List<FightCavesNpcSpawn>> calculateSpawns(int rsVal)
	{
		ArrayList spawns = new ArrayList<List<FightCavesNpcSpawn>>();

		int currentCycle = rsVal;

		for (FightCavesNpc npc : FightCavesNpc.values())
		{
			if (npc == FightCavesNpc.JAD)
			{
				continue;
			}

			List<List<FightCavesNpcSpawn>> subSpawns = generateSubSpawns((currentCycle + 1) % 15, npc, spawns);

			ArrayList initialSpawn = new ArrayList<FightCavesNpcSpawn>();
			initialSpawn.add(new FightCavesNpcSpawn(npc, currentCycle));
			spawns.add(initialSpawn);
			currentCycle = (currentCycle + 1) % 15;

			spawns.addAll(subSpawns);
			currentCycle = (currentCycle + subSpawns.size()) % 15;

			ArrayList postSpawns = new ArrayList<FightCavesNpcSpawn>();
			postSpawns.add(new FightCavesNpcSpawn(npc, currentCycle));
			postSpawns.add(new FightCavesNpcSpawn(npc, (currentCycle + 1) % 15));
			spawns.add(postSpawns);
			currentCycle = (currentCycle + 1) % 15;
		}

		ArrayList jadSpawn = new ArrayList<FightCavesNpcSpawn>();
		jadSpawn.add(new FightCavesNpcSpawn(FightCavesNpc.JAD, currentCycle));
		spawns.add(jadSpawn);

		return spawns;
	}

	private static List<List<FightCavesNpcSpawn>> generateSubSpawns(int currentCycle, FightCavesNpc npc, List<List<FightCavesNpcSpawn>> existing)
	{
		ArrayList subSpawns = new ArrayList<List<FightCavesNpcSpawn>>();

		for (List<FightCavesNpcSpawn> existingWave : existing)
		{
			ArrayList newSpawn = new ArrayList<FightCavesNpcSpawn>();
			newSpawn.add(new FightCavesNpcSpawn(npc, currentCycle));

			for (int i = 0; i < existingWave.size(); i++)
			{
				FightCavesNpcSpawn existingSpawn = existingWave.get(i);
				newSpawn.add(new FightCavesNpcSpawn(existingSpawn.getNpc(), (currentCycle + i + 1) % 15));
			}

			subSpawns.add(newSpawn);
			currentCycle = (currentCycle + 1) % 15;
		}

		return subSpawns;
	}

	public final LocalTime getUTCTime()
	{
		return LocalTime.now(ZoneId.of("UTC"));
	}

	public final String getUTCFormatted()
	{
		if (serverTime == -1)
		{
			return "";
		}

		return serverUTCTime.format(DateTimeFormatter.ofPattern("HH:mm:ss"));
	}

	@Schedule(period = 500, unit = ChronoUnit.MILLIS)
	public void updateSchedule()
	{
		// Server UTC Time: 2208
		// Hour Calculation: 1328 / 60 = 22
		// Minuted Calculation: 1328 % 60 = 8
		if (client.getGameState() != GameState.LOGGED_IN || !isInTzhaarArea() || client.isInInstancedRegion())
		{
			serverUTCTime = null;
			serverUTCTimeSecondSet = false;
			serverTime = -1;
			oldServerTime = -1;
			serverTimeSecondOffset = -1;
			return;
		}

		int currentLocalSecond = LocalTime.now().getSecond();
		serverTime = client.getVarbitValue(8354);

		if (!serverUTCTimeSecondSet)
		{
			if (oldServerTime > 0 && serverTime != oldServerTime)
			{
				serverUTCTime = LocalTime.of(serverTime / 60, serverTime % 60, 0);
				serverUTCTimeSecondSet = true;
				serverTimeSecondOffset = LocalTime.now().getSecond();
			}
			else
			{
				serverUTCTime = LocalTime.of(serverTime / 60, serverTime % 60, currentLocalSecond);
			}

			oldServerTime = serverTime;
		}
		else if (serverUTCTimeSecondSet && serverTimeSecondOffset != -1)
		{
			oldServerTime = serverTime;

			if (serverTime != oldServerTime)
			{
				serverUTCTime = LocalTime.of(serverTime / 60, serverTime % 60, 0);
				serverTimeSecondOffset = LocalTime.now().getSecond();
			}
			else
			{
				serverUTCTime = LocalTime.of(serverTime / 60, serverTime % 60, OffsetDateTime.now().plusSeconds(-serverTimeSecondOffset).getSecond());
			}
		}

		if (!active && serverUTCTimeSecondSet)
		{
			rotationCol = serverTime % 16;

			int minute = serverUTCTime.getMinute();

			if ((rotationCol == 15 && (minute % 2) != 0) || (rotationCol == 0 && (minute % 2) == 0))
			{
				// Needed in-order to make Rotation 4 (Column 1 and 16) repeat itself
				rotationCol = 1;
			}
			else
			{
				// Because of the modulo above, everything is 1 value lower than it should be ... so +1 to every rotation
				rotationCol++;
			}
		}
	}

	@Override
	public void keyTyped(KeyEvent e)
	{
	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		if (config.displayCurrentWave() != SpawnPredictorConfig.CurrentWaveDisplayMode.OFF && config.displayCurrentWaveKey().matches(e))
		{
			switch (config.displayCurrentWave())
			{
				case FLASH:
				{
					hotkeyEnabled = true;
					break;
				}

				case TOGGLE:
				{
					hotkeyEnabled = !hotkeyEnabled;
					break;
				}
			}
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
		if (config.displayCurrentWave() != SpawnPredictorConfig.CurrentWaveDisplayMode.OFF
				&& config.displayCurrentWave() == SpawnPredictorConfig.CurrentWaveDisplayMode.FLASH
				&& config.displayCurrentWaveKey().matches(e))
		{
			hotkeyEnabled = false;
		}
	}

	private void saveRotation(String name, int rotation, int wave)
	{
		AccountMemory memory = new AccountMemory(rotation, wave);
		setRotationConfig(name, memory);
	}

	AccountMemory getRotationConfig(String name)
	{
		String json = configManager.getConfiguration(SpawnPredictorConfig.GROUP, "spawnpredictor_" + name);

		if (json == null)
		{
			return null;
		}

		return gson.fromJson(json, AccountMemory.class);
	}

	void setRotationConfig(String name, AccountMemory memory)
	{
		String json = gson.toJson(memory);
		configManager.setConfiguration(SpawnPredictorConfig.GROUP, "spawnpredictor_" + name, json);
		log.info("spawnpredictor: set rotation config for {} with rotation: {} and wave: {}", name, memory.getRotation(), memory.getWave());
	}

	void removeRotationConfig(String name)
	{
		if (name == null || getRotationConfig(name) == null)
		{
			return;
		}

		configManager.unsetConfiguration(SpawnPredictorConfig.GROUP, "spawnpredictor_" + name);
		log.info("spawnpredictor: removed rotation config for {}", name);
	}
}
/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor.overlays;

import com.spawnpredictor.SpawnPredictorConfig;
import com.spawnpredictor.SpawnPredictorPlugin;
import com.spawnpredictor.util.FightCavesNpc;
import com.spawnpredictor.util.FightCavesNpcSpawn;
import com.spawnpredictor.util.SpawnLocations;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import java.awt.*;
import java.util.List;

@Slf4j
public class DisplayModeOverlay extends Overlay
{
	private final Client client;
	private final SpawnPredictorPlugin plugin;
	private final SpawnPredictorConfig config;

	@Inject
	private DisplayModeOverlay(Client client, SpawnPredictorPlugin plugin, SpawnPredictorConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		setPriority(OverlayPriority.HIGH);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.isFightCavesActive() || config.displayMode() == SpawnPredictorConfig.DisplayMode.OFF || plugin.getCurrentWave() <= 0 || plugin.getCurrentRotation() == -1)
		{
			return null;
		}

		final int wave = plugin.getCurrentWave() - 1;
		List<FightCavesNpcSpawn> currentWaveContents = plugin.getWaveData().get(wave);

		switch(config.displayMode())
		{
			case CURRENT_WAVE:
			{
				renderWaveContents(graphics, currentWaveContents, config.currentWaveColor());
				break;
			}

			case NEXT_WAVE:
			{
				if (wave == 0 || (config.displayCurrentWave() != SpawnPredictorConfig.CurrentWaveDisplayMode.OFF && plugin.isHotkeyEnabled()))
				{
					renderWaveContents(graphics, currentWaveContents, config.currentWaveColor());
				}

				if (wave != 63)
				{
					renderWaveContents(graphics, plugin.getWaveData().get(wave + 1), config.nextWaveColor());
				}
				break;
			}

			case BOTH:
			{
				renderWaveContents(graphics, currentWaveContents, config.currentWaveColor());

				if (wave != 63)
				{
					renderWaveContents(graphics, plugin.getWaveData().get(wave + 1), config.nextWaveColor());
				}
				break;
			}

			default:
			{
				throw new IllegalStateException("Illegal 'Display Mode' config state... How did this happen? Who knows");
			}
		}

		return null;
	}

	private void renderWaveContents(Graphics2D graphics, List<FightCavesNpcSpawn> waveContents, Color color)
	{
		waveContents.forEach(fcNpc ->
		{
			FightCavesNpc npc = fcNpc.getNpc();
			String name = npc.getName();
			int size = npc.getSize();

			SpawnLocations spawnLoc = SpawnLocations.lookup(fcNpc.getSpawnLocation());

			if (spawnLoc == null)
			{
				return;
			}

			LocalPoint localPoint = getCenterLocalPoint(spawnLoc.getRegionX(), spawnLoc.getRegionY(), size);

			if (localPoint == null)
			{
				return;
			}

			Polygon poly = Perspective.getCanvasTileAreaPoly(client, localPoint, size);
			renderPolygon(graphics, poly, color);

			Point textLocation = Perspective.getCanvasTextLocation(client, graphics, localPoint, name, 0);

			if (textLocation != null)
			{
				OverlayUtil.renderTextLocation(graphics, textLocation, name, config.multicolorNames() ? color : Color.WHITE);
			}
		});
	}

	private LocalPoint getCenterLocalPoint(int regionX, int regionY, int size)
	{
		// Region Coords are treated as the 'SW' tile
		LocalPoint lp = LocalPoint.fromWorld(client,
				WorldPoint.fromRegion(
						client.getLocalPlayer().getWorldLocation().getRegionID(),
						regionX, regionY, client.getPlane())
		);

		if (lp == null)
		{
			return null;
		}

		// Builds outwards from the SW tile and adjusts for NPC size and returns the center-most local point
		return new LocalPoint(lp.getX() + ((size - 1) * Perspective.LOCAL_HALF_TILE_SIZE), lp.getY() + ((size - 1) * Perspective.LOCAL_HALF_TILE_SIZE));
	}

	private void renderPolygon(Graphics2D graphics, @Nullable Shape poly, @Nonnull Color color)
	{
		if (poly == null)
		{
			return;
		}

		graphics.setColor(color);
		graphics.setStroke(new BasicStroke(config.overlayStrokeSize()));
		graphics.draw(poly);
		graphics.setColor(new Color(0, 0, 0, 50));
		graphics.fill(poly);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor.overlays;

import com.google.inject.Inject;
import com.spawnpredictor.SpawnPredictorConfig;
import com.spawnpredictor.SpawnPredictorPlugin;
import com.spawnpredictor.util.StartLocations;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;

import java.awt.*;

public class DebugOverlayPanel extends OverlayPanel
{
	private final SpawnPredictorPlugin plugin;
	private final SpawnPredictorConfig config;

	@Inject
	private DebugOverlayPanel(SpawnPredictorPlugin plugin, SpawnPredictorConfig config)
	{
		this.plugin = plugin;
		this.config = config;

		setPriority(OverlayPriority.HIGH);
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.debug())
		{
			return null;
		}

		panelComponent.setPreferredSize(new Dimension(75, 0));

		if (!plugin.isFightCavesActive() && plugin.isInTzhaarArea())
		{
			int rotationCol = plugin.getRotationCol();

			panelComponent.getChildren().add(LineComponent.builder()
					.left("RCol:")
					.leftColor(Color.WHITE)
					.right(Integer.toString(rotationCol))
					.rightColor(Color.GREEN)
					.build());

			panelComponent.getChildren().add(LineComponent.builder()
					.left("RTrans:")
					.leftColor(Color.WHITE)
					.right(Integer.toString(StartLocations.translateRotation(rotationCol)))
					.rightColor(Color.GREEN)
					.build());
		}

		if (plugin.isFightCavesActive() && !plugin.isInTzhaarArea())
		{
			int rotation = plugin.getCurrentRotation();

			panelComponent.getChildren().add(LineComponent.builder()
					.left("Wave:")
					.leftColor(Color.WHITE)
					.right(Integer.toString(plugin.getCurrentWave()))
					.rightColor(Color.GREEN)
					.build());

			panelComponent.getChildren().add(LineComponent.builder()
					.left("Rotation:")
					.leftColor(Color.WHITE)
					.right(Integer.toString(rotation))
					.rightColor(Color.GREEN)
					.build());

			panelComponent.getChildren().add(LineComponent.builder()
					.left("rsV:")
					.leftColor(Color.WHITE)
					.right(Integer.toString(SpawnPredictorPlugin.getRsVal()))
					.rightColor(Color.ORANGE)
					.build());

			panelComponent.getChildren().add(LineComponent.builder()
					.left("rsF:")
					.leftColor(Color.WHITE)
					.right(Integer.toString(StartLocations.getLookupMap().get(rotation)))
					.rightColor(Color.ORANGE)
					.build());
		}

		return super.render(graphics);
	}
}

/*
 * Copyright (c) 2022, Damen <gh: damencs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:

 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.spawnpredictor.overlays;

import com.spawnpredictor.SpawnPredictorConfig;
import com.spawnpredictor.SpawnPredictorPlugin;
import com.spawnpredictor.util.StartLocations;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;
import java.awt.*;

public class RotationOverlayPanel extends OverlayPanel
{
	private final SpawnPredictorPlugin plugin;
	private final SpawnPredictorConfig config;

	@Inject
	private RotationOverlayPanel(SpawnPredictorPlugin plugin, SpawnPredictorConfig config)
	{
		this.plugin = plugin;
		this.config = config;

		setPriority(OverlayPriority.HIGH);
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.isInTzhaarArea() || !config.lobbyRotationInfoOverlay())
		{
			return null;
		}

		int rotation = plugin.getRotationCol();

		panelComponent.setPreferredSize(new Dimension(125, 0));

		if (config.includeUTCTime())
		{
			panelComponent.getChildren().add(LineComponent.builder()
					.left("Time:")
					.leftColor(Color.WHITE)
					.right(plugin.getUTCFormatted())
					.rightColor(Color.ORANGE)
					.build());
		}

		if (plugin.isServerUTCTimeSecondSet())
		{
			panelComponent.getChildren().add(LineComponent.builder()
					.left("Current Rotation:")
					.leftColor(Color.WHITE)
					.right(Integer.toString(StartLocations.translateRotation(rotation)))
					.rightColor(Color.GREEN)
					.build());

			panelComponent.getChildren().add(LineComponent.builder()
					.left("Next:")
					.leftColor(Color.WHITE)
					.right("[T - "
							+ (60 - plugin.getServerUTCTime().getSecond())
							+ "s, Rot: "
							+ ((rotation + 1) > 15 ? "4" : Integer.toString(StartLocations.translateRotation(rotation + 1)))
							+ "]")
					.rightColor(Color.YELLOW)
					.build());
		}
		else
		{
			panelComponent.getChildren().add(LineComponent.builder()
					.right("Determining...")
					.rightColor(Color.YELLOW)
					.build());
		}

		return super.render(graphics);
	}
}

