package matsyir.pvpperformancetracker.utils;

import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.models.AnimationData;
import net.runelite.api.HeadIcon;
import net.runelite.api.PlayerComposition;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;

import java.util.Arrays;

@Slf4j
public class PvpPerformanceTrackerUtils
{
	/**
	 * Calculates the chance of knocking out an opponent with a single hit.
	 *
	 * @param accuracy           The attacker's accuracy (0.0 to 1.0).
	 * @param minHit             The attacker's minimum possible hit.
	 * @param maxHit             The attacker's maximum possible hit.
	 * @param estimatedOpponentHp The estimated HP of the opponent before the hit.
	 * @return The KO chance (0.0 to 1.0), or null if the max hit is less than the opponent's HP.
	 */
	public static Double calculateKoChance(double accuracy, int minHit, int maxHit, int estimatedOpponentHp)
	{
		// Cannot KO if max hit is less than opponent's current HP.
		if (maxHit < estimatedOpponentHp || estimatedOpponentHp <= 0)
		{
			return null;
		}

		// Ensure minHit is not greater than maxHit (shouldn't happen, but safety check)
		// and not negative.
		minHit = Math.max(0, Math.min(minHit, maxHit));

		int totalPossibleHits = maxHit - minHit + 1;
		if (totalPossibleHits <= 0)
		{
			// Avoid division by zero if minHit somehow exceeds maxHit after clamping.
			log.warn("Calculated totalPossibleHits <= 0 (min: {}, max: {})", minHit, maxHit);
			return null;
		}

		// Number of hits that would result in a KO (damage >= opponent's HP).
		// Clamp estimatedOpponentHp to be at least minHit for calculation,
		// otherwise koHits could be larger than totalPossibleHits.
		int effectiveHpForCalc = Math.max(minHit, estimatedOpponentHp);
		int koHits = maxHit - effectiveHpForCalc + 1;

		// Ensure koHits is not negative (if effectiveHpForCalc > maxHit somehow)
		koHits = Math.max(0, koHits);

		// KO chance = Accuracy * (Number of KO hits / Total possible hits)
		double chance = accuracy * ((double) koHits / totalPossibleHits);

		// Clamp chance between 0 and 1 (due to potential floating point inaccuracies)
		return Math.max(0.0, Math.min(chance, 1.0));
	}

	/**
	 * Returns how many splats an attack animation should produce based on its group pattern.
	 */
	public static int getExpectedHits(AnimationData data)
	{
		if (data == null)
		{
			return 1;
		}
		// Sum the hitsplat groups defined in AnimationData
		return Arrays.stream(data.getHitsplatGroupPattern()).sum();
	}

	/**
	 * Calculates the opponent's HP before a hit based on their health bar ratio/scale after the hit.
	 *
	 * @param ratio      The opponent's health bar ratio after the hit (0-?).
	 * @param scale      The opponent's health bar scale.
	 * @param maxHp      The opponent's maximum HP.
	 * @param damageSum  The total damage dealt by the hitsplat(s).
	 * @return The estimated HP before the hit, or -1 if calculation is not possible.
	 */
	public static int calculateHpBeforeHit(int ratio, int scale, int maxHp, int damageSum)
	{
		if (ratio < 0 || scale <= 0 || maxHp <= 0)
		{
			return -1; // Cannot estimate
		}

		int hpAfter;
		if (ratio == 0)
		{
			hpAfter = 0;
		}
		else
		{
			int minHealth = 1;
			int maxHealth;
			if (scale > 1)
			{
				if (ratio > 1)
				{
					minHealth = (maxHp * (ratio - 1) + scale - 2) / (scale - 1);
				}
				maxHealth = (maxHp * ratio - 1) / (scale - 1);
				if (maxHealth > maxHp)
				{
					maxHealth = maxHp;
				}
			}
			else // scale = 1 implies ratio must be 1
			{
				maxHealth = maxHp;
			}
			hpAfter = (minHealth + maxHealth + 1) / 2; // Average the possible range
		}

		return hpAfter + damageSum;
	}

    public static int getSpriteForSkill(Skill skill)
    {
        switch (skill)
        {
            case ATTACK: return SpriteID.SKILL_ATTACK;
            case STRENGTH: return SpriteID.SKILL_STRENGTH;
            case DEFENCE: return SpriteID.SKILL_DEFENCE;
            case RANGED: return SpriteID.SKILL_RANGED;
            case MAGIC: return SpriteID.SKILL_MAGIC;
            case HITPOINTS: return SpriteID.SKILL_HITPOINTS;
            default: return -1;
        }
    }

	// returns SpriteID for a given HeadIcon. returns -1 if not found
	public static int getSpriteForHeadIcon(HeadIcon icon)
	{
		if (icon == null) { return -1; }
		switch (icon)
		{
			case MELEE: return SpriteID.PRAYER_PROTECT_FROM_MELEE;
			case RANGED: return SpriteID.PRAYER_PROTECT_FROM_MISSILES;
			case MAGIC: return SpriteID.PRAYER_PROTECT_FROM_MAGIC;
			case SMITE: return SpriteID.PRAYER_SMITE;
			case RETRIBUTION: return SpriteID.PRAYER_RETRIBUTION;
			case REDEMPTION: return SpriteID.PRAYER_REDEMPTION;
			default: return -1;
		}
	}

	// fix an itemId that came from getPlayerComposition().getEquipmentIds()
	public static int fixItemId(int itemId)
	{
		return itemId > PlayerComposition.ITEM_OFFSET ? itemId - PlayerComposition.ITEM_OFFSET : itemId;
	}

	// create new array so we don't modify original array
	public static int[] fixItemIds(int[] itemIds)
	{
		if (itemIds == null || itemIds.length < 1)
		{
			return new int[] { 0 };
		}
		int[] fixedItemIds = new int[itemIds.length];
		for (int i = 0; i < itemIds.length; i++)
		{
			fixedItemIds[i] = fixItemId(itemIds[i]);
		}

		return fixedItemIds;
	}
}

package matsyir.pvpperformancetracker.models;

import lombok.Getter;
import net.runelite.api.events.HitsplatApplied;

/**
 * Helper class to store a HitsplatApplied event along with the
 * opponent's health ratio/scale polled shortly after the event occurred.
 */
public class HitsplatInfo
{
	@Getter
	private final HitsplatApplied event;

	// health ratio/scale at the time of the hitsplat
	@Getter
	private int healthRatio = -1;
	@Getter
	private int healthScale = -1;

	public HitsplatInfo(HitsplatApplied event)
	{
		this.event = event;
	}

	// Called to store the HP state
	public void setHp(int ratio, int scale)
	{
		this.healthRatio = ratio;
		this.healthScale = scale;
	}
} 
/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import java.awt.Color;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.time.Instant;
import lombok.Getter;
import lombok.Setter;
import matsyir.pvpperformancetracker.controllers.PvpDamageCalc;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import net.runelite.api.GraphicID;
import net.runelite.api.HeadIcon;
import net.runelite.api.Player;
import net.runelite.client.chat.ChatMessageBuilder;
import org.apache.commons.text.WordUtils;
import matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils;

// A fight log entry for a single Fighter. Will be saved in a List of FightLogEntries in the Fighter class.
@Getter
public class FightLogEntry implements Comparable<FightLogEntry>
{
	public static final NumberFormat nf;
	static
	{
		nf = NumberFormat.getInstance();
		nf.setRoundingMode(RoundingMode.HALF_UP);
		nf.setMaximumFractionDigits(2);
	}

	// general data
	// don't expose attacker name since it is present in the parent class (Fighter), so it is
	// redundant use of storage
	public String attackerName;
	@Expose
	@SerializedName("t")
	private long time;

	@Setter
	@Expose
	@SerializedName("T")
	private int tick;

	// this boolean represents if this is a "complete" fight log entry or not.
	// if a fight log entry is full/complete, then it has all attack data.
	// an "incomplete" fight log entry means it's only holding the current attacker's defensive stats to be used with
	// an opposing attack, to be matched up with fight analysis/data merging
	// very rough way to do this but itll work
	@Expose
	@SerializedName("f")
	private boolean isFullEntry;


	// attacker data
	@Expose
	@SerializedName("G")
	// current attacker's gear. The attacker is not necessarily the competitor.
	// Set using PlayerComposition::getEquipmentIds
	private int[] attackerGear;
	@Expose
	@SerializedName("O")
	private HeadIcon attackerOverhead;
	@Expose
	@SerializedName("m") // m because movement?
	private AnimationData animationData;
	@Setter
	@Expose
	@SerializedName("d")
	private double expectedDamage; // NOTE: previously referred to as "Deserved damage"
	@Expose
	@SerializedName("a")
	private double accuracy;
	@Setter
	@Expose
	@SerializedName("h") // h for highest hit
	private int maxHit;
	@Setter
	@Expose
	@SerializedName("l") // l for lowest hit
	private int minHit;
	@Expose
	@SerializedName("s")
	private boolean splash; // true if it was a magic attack and it splashed

	@Expose
	@SerializedName("C")
	private CombatLevels attackerLevels; // CAN BE NULL

	@Getter
	@Setter
	@Expose
	@SerializedName("k") // k for ko chance
	private Double koChance = null;

	@Getter // Added Getter for isKoChanceCalculated
	@Setter
	private transient boolean koChanceCalculated = false; // Flag to track if KO chance was processed for this entry

	@Getter
	@Setter
	@Expose
	@SerializedName("eH") // Estimated Hp before hit
	private Integer estimatedHpBeforeHit = null;

	@Getter
	@Setter
	@Expose
	@SerializedName("oH") // Opponent max Hp used for calc
	private Integer opponentMaxHp = null;

	@Expose
	@Getter
	@Setter
	@SerializedName("mC") // matched hits count so far
	private int matchedHitsCount;

	@Expose
	@Getter
	@Setter
	@SerializedName("aD") // actual Damage Sum
	private Integer actualDamageSum;

	// defender data
	@Expose
	@SerializedName("g")
	private int[] defenderGear;
	@Expose
	@SerializedName("o")
	private HeadIcon defenderOverhead;

	@Expose
	@SerializedName("p")
	private int attackerOffensivePray; // offensive pray saved as SpriteID since that's all we use it for.

	@Expose
	@Getter
	private int expectedHits; // Declare expectedHits field

	@Expose
	@SerializedName("GMS")
	@Getter
	@Setter
	private boolean isGmaulSpecial = false;

	// Recorded opponent health ratio and scale at the moment of the hitsplat
	private int recordedHealthRatio = -1;
	private int recordedHealthScale = -1;
	// Get the recorded hitsplat landing tick, or -1 if not recorded
	// Set the tick when the hitsplat landed
	// The tick at which the first hitsplat for this entry landed
	@Getter
	@Setter
	private int hitsplatTick = -1;

	// Display/Transient fields calculated during post-processing in onGameTick
	@Expose
	@Getter @Setter
	private Integer displayHpBefore = null;
	@Expose
	@Getter @Setter
	private Integer displayHpAfter = null;
	@Expose
	@Getter @Setter
	private Double displayKoChance = null;
	@Expose
	@Getter @Setter
	private boolean isPartOfTickGroup = false;

	public FightLogEntry(Player attacker, Player defender, PvpDamageCalc pvpDamageCalc, int attackerOffensivePray, CombatLevels levels, AnimationData animationData)
	{
		this.isFullEntry = true;

		// general
		this.attackerName = attacker.getName();
		this.time = Instant.now().toEpochMilli();
		this.tick = PLUGIN.getClient().getTickCount();

		this.animationData = animationData;

		// attacker data
		this.attackerGear = attacker.getPlayerComposition().getEquipmentIds();
		this.attackerOverhead = attacker.getOverheadIcon();

		this.expectedDamage = pvpDamageCalc.getAverageHit();
		this.accuracy = pvpDamageCalc.getAccuracy();
		this.minHit = pvpDamageCalc.getMinHit();
		this.maxHit = pvpDamageCalc.getMaxHit();
		this.splash = animationData.attackStyle == AnimationData.AttackStyle.MAGIC && defender.getGraphic() == GraphicID.SPLASH;
		this.attackerLevels = levels; // CAN BE NULL

		// defender data
		this.defenderGear = defender.getPlayerComposition().getEquipmentIds();
		this.defenderOverhead = defender.getOverheadIcon();
		this.attackerOffensivePray = attackerOffensivePray;
		this.expectedHits = PvpPerformanceTrackerUtils.getExpectedHits(animationData);
		this.matchedHitsCount = 0;
		this.actualDamageSum = 0;
	}

	// create incomplete entry to save competitor's defensive stats which are only client side
	// in this context, the "attacker" is not attacking, only defending.
	public FightLogEntry(String attackerName, CombatLevels levels, int attackerOffensivePray)
	{
		this.isFullEntry = false;

		this.attackerName = attackerName;
		this.time = Instant.now().toEpochMilli();
		this.tick = PLUGIN.getClient().getTickCount();

		this.attackerLevels = levels;
		this.attackerOffensivePray = attackerOffensivePray;
		this.actualDamageSum = 0;
	}

	// create new fightlogentry based on existing entry but new damage calcs (for fight analysis/stat merging)
	public FightLogEntry(FightLogEntry e, PvpDamageCalc pvpDamageCalc)
	{
		this.isFullEntry = true;

		// general
		this.attackerName = e.attackerName;
		this.time = e.time;
		this.tick = e.tick;

		// attacker data
		this.attackerGear = e.attackerGear;
		this.attackerOverhead = e.attackerOverhead;
		this.animationData = e.animationData;
		this.expectedDamage = pvpDamageCalc.getAverageHit();
		this.accuracy = pvpDamageCalc.getAccuracy();
		this.minHit = pvpDamageCalc.getMinHit();
		this.maxHit = pvpDamageCalc.getMaxHit();
		this.splash = e.splash;
		this.attackerLevels = e.attackerLevels;

		// defender data
		this.defenderGear = e.defenderGear;
		this.defenderOverhead = e.defenderOverhead;
		this.attackerOffensivePray = e.attackerOffensivePray;
		this.expectedHits = PvpPerformanceTrackerUtils.getExpectedHits(e.animationData);
		this.matchedHitsCount = 0;
		this.actualDamageSum = 0;
	}

	// randomized entry used for testing
	public FightLogEntry(int [] attackerGear, int expectedDamage, double accuracy, int minHit, int maxHit, int [] defenderGear, String attackerName)
	{
		this.attackerName = attackerName;
		this.attackerGear = attackerGear;
		this.attackerOverhead = HeadIcon.MAGIC;
		this.animationData = Math.random() <= 0.5 ? AnimationData.MELEE_DAGGER_SLASH : AnimationData.MAGIC_ANCIENT_MULTI_TARGET;
		this.expectedDamage = expectedDamage;
		this.accuracy = accuracy;
		this.minHit = minHit;
		this.maxHit = maxHit;
		this.splash = Math.random() >= 0.5;
		this.time = Instant.now().toEpochMilli();
		this.defenderGear = defenderGear;
		this.defenderOverhead = HeadIcon.MAGIC;
		this.actualDamageSum = 0;
	}


	public boolean success()
	{
		return animationData.attackStyle.getProtection() != defenderOverhead;
	}

	public String toChatMessage()
	{
		Color darkRed = new Color(127, 0, 0); // same color as default clan chat color
		return new ChatMessageBuilder()
			.append(darkRed, attackerName + ": ")
			.append(Color.BLACK, "Style: ")
			.append(darkRed, WordUtils.capitalizeFully(animationData.attackStyle.toString()))
			.append(Color.BLACK, "  Hit: ")
			.append(darkRed, getHitRange())
			.append(Color.BLACK, "  Acc: ")
			.append(darkRed, nf.format(accuracy))
			.append(Color.BLACK, "  AvgHit: ")
			.append(darkRed, nf.format(expectedDamage))
			.append(Color.BLACK, " Spec?: ")
			.append(darkRed, animationData.isSpecial ? "Y" : "N")
			.append(Color.BLACK, " OffP?:")
			.append(darkRed, success() ? "Y" : "N")
			.build();
	}

	public String getHitRange()
	{
		return minHit + "-" + maxHit;
	}

	// use to sort by last fight time, to sort fights by date/time.
	@Override
	public int compareTo(FightLogEntry o)
	{
		long diff = tick - o.tick;

		// if diff = 0, return 0. Otherwise, divide diff by its absolute value. This will result in
		// -1 for negative numbers, and 1 for positive numbers, keeping the sign and a safely small int.
		return diff == 0 ? 0 :
			(int)(diff / Math.abs(diff));
	}

}

/*
 * Copyright (c) 2022, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models.oldVersions;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import matsyir.pvpperformancetracker.controllers.Fighter;

// Old stripped down version of FightPerformance, so they can be properly deserialized
// and upgraded to the newer version.
// When going from 1.5.5 -> 1.5.6, the boolean isLmsFight is updated to the FightType enum.
// the core upgrade logic is a simple constructor in FightPerformance
@Getter
public class FightPerformance__1_5_5
{
	@Expose
	@SerializedName("c") // use 1 letter serialized variable names for more compact storage
	public Fighter competitor;
	@Expose
	@SerializedName("o")
	public Fighter opponent;
	@Expose
	@SerializedName("t")
	public long lastFightTime; // last fight time saved as epochMilli timestamp (serializing an Instant was a bad time)
	@Expose
	@SerializedName("l")
	public boolean isLmsFight; // save a boolean if the fight was done in LMS, so we can know those stats/rings/ammo are used.
}
package matsyir.pvpperformancetracker.models;

import lombok.Getter;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.controllers.Fighter;
import matsyir.pvpperformancetracker.views.PanelFactory;
import matsyir.pvpperformancetracker.views.TableComponent;
import net.runelite.client.ui.ColorScheme;

import javax.swing.JPanel;
import java.awt.Color;
import java.math.RoundingMode;
import java.security.InvalidParameterException;
import java.text.NumberFormat;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Supplier;

public enum TrackedStatistic
{
	OFF_PRAY("Off-pray", "OP",
		"Off-pray statistic, # of times you correctly used a different style than your opponent's overhead pray." +
			"<br>For example, when you use melee or ranged vs. protect from magic, that's a successful off-pray hit."),
	EXPECTED_DMG("Expected damage", "eD", // NOTE: previously referred to as "Deserved damage"
		"Expected damage statistic, # of damage you would've dealt if the game had averaged rng, including misses." +
			"<br>Due to the high variance in this game, it's normal for fights to commonly stray from this." +
			"<br><br>This used to be referred to as 'deserved damage'. The functionality was not changed."),
	DMG_DEALT("Damage dealt", "D",
		"Damage dealt statistic, sum of your actual damage hitsplats on your opponent."),
	MAGIC_HITS("Magic hits luck", "M",
		"Magic luck statistic, tracks expected hits vs. # of actual magic hits (as opposed to splashes)."),
	OFFENSIVE_PRAY("Offensive pray", "P",
		"Offensive prayer statistic, tracks # of offensive prays you used correctly, e.g piety for melee."),
	HP_HEALED("HP healed", "HP",
		"HP healed statistic, tracks amount of HP recovered during the fight (from all sources)."),
	ROBE_HITS("Hits on robes", "rH",
		"Hits on robes statistic, tracks # of times you got range/melee'd in robes (don't)."),
	KO_CHANCES("KO chances", "KO",
		"KO chance statistic, tracks every KO chance you got and gives you a total chance of KO." +
			"<br>When you spec your opponent on 20hp and hit a 12, you can find the KO % chance in the fight log."),

	// NOTE: let's keep ghost barrage as the bottom-most statistic:
	// It's only relevant to people fighting in PvP Arena, and it's mostly only relevant
	// to people who can share their tracker with each-other - so pretty rarely useful.
	// ... also, more often than not it literally has 0 data. 0 hits, nothing. so let's just not show
	// this line when there is no data, since it's also the bottom row now, anyway.
	GHOST_BARRAGES("Ghost barrages", "GB",
		"Ghost-barrage statistic, for when you're animation stalled while barraging." +
			"<br>This statistic is hidden if both players have 0gb, which is common." +
			"<br>Weird and for advanced users only.");

	private static final String NO_DATA_SHORT = "-";
	private static final String NO_DATA = "N/A";

	// TODO ideally refactor these NFs into their own Util class or smth, we spam this NF stuff everywhere....
	private static final NumberFormat nf2 = NumberFormat.getInstance();
	private static final NumberFormat nfP1 = NumberFormat.getPercentInstance(); // For KO Chance %

	static
	{
		// initialize number format
		nf2.setMaximumFractionDigits(2);
		nf2.setRoundingMode(RoundingMode.HALF_UP);

		// initialize percent format
		nfP1.setMaximumFractionDigits(1);
		nfP1.setRoundingMode(RoundingMode.HALF_UP);

		// for every TrackedStatistic, init behaviors/functions/providers:
		// 1) Init/generate FightPerformancePanel line for this statistic
		// 2) Init/generate FightPerformanceOverlay line for this statistic (TableComponent)
		// 3) Update TableComponent from step 2 from ongoing fight data
		// these have to be static in order to self-reference themselves and use things like numberFormats
		OFF_PRAY.init(
			(fight, oppFight) -> PanelFactory.createStatsLine(
				OFF_PRAY.acronym, OFF_PRAY.acronymTooltip
				, fight.competitor.getOffPrayStats()
				, (fight.competitor.getName() + " hit " + fight.competitor.getOffPraySuccessCount() + " successful off-pray attacks out of " +
					fight.competitor.getAttackCount() + " total attacks (" +
					nf2.format(fight.competitor.calculateOffPraySuccessPercentage()) + "%)")
				, fight.competitorOffPraySuccessIsGreater() ? Color.GREEN : Color.WHITE

				, fight.opponent.getOffPrayStats()
				, (fight.opponent.getName() + " hit " + fight.opponent.getOffPraySuccessCount() + " successful off-pray attacks out of " +
					fight.opponent.getAttackCount() + " total attacks (" +
					nf2.format(fight.opponent.calculateOffPraySuccessPercentage()) + "%)")
				, fight.opponentOffPraySuccessIsGreater() ? Color.GREEN : Color.WHITE
			),
			() -> PanelFactory.createOverlayStatsLine(OFF_PRAY.acronym, 50, 50,
				NO_DATA_SHORT, Color.WHITE, NO_DATA_SHORT, Color.WHITE),
			(fight, component) -> component.updateLeftRightCells(
				fight.getCompetitor().getOffPrayStats(true)
				, fight.competitorOffPraySuccessIsGreater() ? Color.GREEN : Color.WHITE
				, fight.getOpponent().getOffPrayStats(true)
				, fight.opponentOffPraySuccessIsGreater() ? Color.GREEN : Color.WHITE
			)
		);

		EXPECTED_DMG.init(
			(fight, oppFight) -> PanelFactory.createStatsLine(EXPECTED_DMG.acronym, EXPECTED_DMG.acronymTooltip
				, fight.competitor.getExpectedDmgString(fight.opponent)
				, "On average, " + (fight.competitor.getName() + " could expect to deal " + nf2.format(fight.competitor.getExpectedDamage()) +
					" damage based on gear & overheads (" + fight.competitor.getExpectedDmgString(fight.opponent, 1, true) + " vs opponent)")
				, fight.competitorExpectedDmgIsGreater() ? Color.GREEN : Color.WHITE

				, fight.opponent.getExpectedDmgString(fight.competitor)
				, "On average, " + (fight.opponent.getName() + " could expect to deal " + nf2.format(fight.opponent.getExpectedDamage()) +
					" damage based on gear & overheads (" + fight.opponent.getExpectedDmgString(fight.competitor, 1, true) + " vs you)")
				, fight.opponentExpectedDmgIsGreater() ? Color.GREEN : Color.WHITE
			),
			() -> PanelFactory.createOverlayStatsLine(EXPECTED_DMG.acronym, 70, 30,
				NO_DATA_SHORT, Color.WHITE, NO_DATA_SHORT, Color.WHITE),
			(fight, component) -> component.updateLeftRightCells(
				fight.getCompetitor().getExpectedDmgString(fight.getOpponent())
				, fight.competitorExpectedDmgIsGreater() ? Color.GREEN : Color.WHITE
				, String.valueOf((int) Math.round(fight.getOpponent().getExpectedDamage()))
				, fight.opponentExpectedDmgIsGreater() ? Color.GREEN : Color.WHITE
			)
		);

		DMG_DEALT.init(
			(fight, oppFight) -> PanelFactory.createStatsLine(DMG_DEALT.acronym, DMG_DEALT.acronymTooltip
				, fight.competitor.getDmgDealtString(fight.opponent)
				, fight.competitor.getName() + " dealt " + fight.competitor.getDamageDealt() +
					" damage (" + fight.competitor.getDmgDealtString(fight.opponent, true) + " vs opponent)"
				, fight.competitorDmgDealtIsGreater() ? Color.GREEN : Color.WHITE

				, fight.opponent.getDmgDealtString(fight.competitor)
				, fight.opponent.getName() + " dealt " + fight.opponent.getDamageDealt() +
					" damage (" + fight.opponent.getDmgDealtString(fight.competitor, true) + " vs you)"
				, fight.opponentExpectedDmgIsGreater() ? Color.GREEN : Color.WHITE

			),
			() -> PanelFactory.createOverlayStatsLine(DMG_DEALT.acronym, 70, 30,
				NO_DATA_SHORT, Color.WHITE, NO_DATA_SHORT, Color.WHITE),
			(fight, component) -> component.updateLeftRightCells(
				String.valueOf(fight.getCompetitor().getDmgDealtString(fight.getOpponent()))
				, fight.competitorDmgDealtIsGreater() ? Color.GREEN : Color.WHITE
				, String.valueOf(fight.getOpponent().getDamageDealt())
				, fight.opponentDmgDealtIsGreater() ? Color.GREEN : Color.WHITE
			)
		);

		MAGIC_HITS.init(
			(fight, oppFight) -> PanelFactory.createStatsLine(MAGIC_HITS.acronym, MAGIC_HITS.acronymTooltip
				, String.valueOf(fight.competitor.getMagicHitStats())
				, fight.competitor.getName() + " successfully hit " +
					fight.competitor.getMagicHitCount() + " of " + fight.competitor.getMagicAttackCount() + " magic attacks, but expected to hit " +
					nf2.format(fight.competitor.getMagicHitCountExpected()) + ".<br>Luck percentage: 100% = expected hits, &gt;100% = lucky, &lt;100% = unlucky"
				, fight.competitorMagicHitsLuckier() ? Color.GREEN : Color.WHITE

				, String.valueOf(fight.opponent.getMagicHitStats())
				, fight.opponent.getName() + " successfully hit " +
					fight.opponent.getMagicHitCount() + " of " + fight.opponent.getMagicAttackCount() + " magic attacks, but expected to hit " +
					nf2.format(fight.opponent.getMagicHitCountExpected()) + ".<br>Luck percentage: 100% = expected hits, &gt;100% = lucky, &lt;100% = unlucky" +
					""
				, fight.opponentMagicHitsLuckier() ? Color.GREEN : Color.WHITE

			),
			() -> PanelFactory.createOverlayStatsLine(MAGIC_HITS.acronym, 70, 30,
				NO_DATA_SHORT, Color.WHITE, NO_DATA_SHORT, Color.WHITE),
			(fight, component) -> component.updateLeftRightCells(
				String.valueOf(fight.getCompetitor().getShortMagicHitStats())
				, fight.competitorMagicHitsLuckier() ? Color.GREEN : Color.WHITE
				, String.valueOf(fight.getOpponent().getShortMagicHitStats())
				, fight.opponentMagicHitsLuckier() ? Color.GREEN : Color.WHITE
			)
		);

		OFFENSIVE_PRAY.init(
			(fight, oppFight) -> { // returns FightPerformancePanel component
				// OFFENSIVE PRAYS RIGHT: prepare opponent data if its available
				String oppOffensivePrayStats = NO_DATA;
				String oppOffensivePrayTooltip = "No data is available for the opponent's offensive prayers";
				Color oppOffensivePrayColor = Color.WHITE;
				if (oppFight != null)
				{
					Fighter oppComp = oppFight.getCompetitor();

					oppOffensivePrayStats = String.valueOf(oppComp.getOffensivePrayStats());
					oppOffensivePrayTooltip = (oppComp.getName() + " did " + oppComp.getOffensivePraySuccessCount() + " successful offensive prayers out of " +
						oppComp.getAttackCount() + " total attacks (" +
						nf2.format(oppComp.calculateOffensivePraySuccessPercentage()) + "%)");
					oppOffensivePrayColor = (
						oppFight.getCompetitor().calculateOffensivePraySuccessPercentage() > fight.competitor.calculateOffensivePraySuccessPercentage()
							? Color.GREEN : Color.WHITE);
				}

				// OFFENSIVE PRAYS: player's offensive pray stats (only player's, usually no data for opponent)
				return PanelFactory.createStatsLine(OFFENSIVE_PRAY.acronym, OFFENSIVE_PRAY.acronymTooltip
					, String.valueOf(fight.competitor.getOffensivePrayStats())
					, (fight.competitor.getName() + " did " + fight.competitor.getOffensivePraySuccessCount() + " successful offensive prayers out of " +
						fight.competitor.getAttackCount() + " total attacks (" +
						nf2.format(fight.competitor.calculateOffensivePraySuccessPercentage()) + "%)")
					, ((oppFight != null && fight.competitor.calculateOffensivePraySuccessPercentage() >
						oppFight.getCompetitor().calculateOffensivePraySuccessPercentage()) ?
						Color.GREEN : Color.WHITE)

					, oppOffensivePrayStats
					, oppOffensivePrayTooltip
					, oppOffensivePrayColor
				);
			},
			() -> PanelFactory.createOverlayStatsLine(OFFENSIVE_PRAY.acronym, 80, 20,
				NO_DATA_SHORT, Color.WHITE, NO_DATA_SHORT, Color.WHITE),
			(fight, component) -> component.updateLeftCellText(String.valueOf(fight.getCompetitor().getOffensivePrayStats(true)))
		);

		HP_HEALED.init(
			(fight, oppFight) -> { // returns FightPerformancePanel component
				// hp healed, right
				String oppHpHealedStats = NO_DATA;
				String oppHpHealedTooltip = "No data is available for the opponent's hp healed";
				Color oppHpHealedColor = Color.WHITE;
				if (oppFight != null)
				{
					Fighter oppComp = oppFight.getCompetitor();

					oppHpHealedStats = (String.valueOf(oppComp.getHpHealed()));
					oppHpHealedTooltip = (oppComp.getName() + " recovered " + oppComp.getHpHealed() + " hitpoints during the fight");
					oppHpHealedColor = (oppFight.getCompetitor().getHpHealed() > fight.competitor.getHpHealed() ? Color.GREEN : Color.WHITE);
				}

				// HP healed (only player's, no data for opponent usually)
				return PanelFactory.createStatsLine(HP_HEALED.acronym, HP_HEALED.acronymTooltip
					, String.valueOf(fight.competitor.getHpHealed())
					, (fight.competitor.getName() + " recovered " + fight.competitor.getHpHealed() + " hitpoints during the fight")
					, ((oppFight != null && fight.competitor.getHpHealed() > oppFight.getCompetitor().getHpHealed()) ?
						Color.GREEN : Color.WHITE)

					, oppHpHealedStats
					, oppHpHealedTooltip
					, oppHpHealedColor
				);
			},
			() -> PanelFactory.createOverlayStatsLine(HP_HEALED.acronym, 80, 20,
				NO_DATA_SHORT, Color.WHITE, NO_DATA_SHORT, Color.WHITE),
			(fight, component) -> component.updateLeftCellText(String.valueOf(fight.getCompetitor().getHpHealed()))
		);

		ROBE_HITS.init(
			(fight, oppFight) -> { // returns FightPerformancePanel component
				// Competitor's hits on robes
				int compHits = fight.getCompetitor().getRobeHits();
				int compTotal = fight.getOpponent().getAttackCount() - fight.getOpponent().getTotalMagicAttackCount();
				double compRatio = compTotal > 0 ? (double) compHits / compTotal : 0.0;
				// Opponent's hits on robes
				int oppHits = fight.getOpponent().getRobeHits();
				int oppTotal = fight.getCompetitor().getAttackCount() - fight.getCompetitor().getTotalMagicAttackCount();
				double oppRatio = oppTotal > 0 ? (double) oppHits / oppTotal : 0.0;

				return PanelFactory.createStatsLine(ROBE_HITS.acronym, ROBE_HITS.acronymTooltip
					, (compHits + "/" + compTotal + " (" + nfP1.format(compRatio) + ")")
					, (fight.getCompetitor().getName() + " was hit with range/melee while wearing robes: " +
						compHits + "/" + compTotal + " (" + nfP1.format(compRatio) + ")<br>" +
						"In other words, of his opponent's " + compTotal + " range/melee attacks, " +
						fight.getCompetitor().getName() + " tanked " + compHits + " of them with robes.")
					, (compRatio < ((double) (fight.getOpponent().getRobeHits()) /
						Math.max(1, fight.getCompetitor().getAttackCount() - fight.getCompetitor().getTotalMagicAttackCount())) ?
						Color.GREEN : Color.WHITE)

					, (oppHits + "/" + oppTotal + " (" + nfP1.format(oppRatio) + ")")
					, (fight.getOpponent().getName() + " was hit with range/melee while wearing robes: " +
						oppHits + "/" + oppTotal + " (" + nfP1.format(oppRatio) + ")<br>" +
						"In other words, of his opponent's " + oppTotal + " range/melee attacks, " +
						fight.getOpponent().getName() + " tanked " + oppHits + " of them with robes.")
					, (oppRatio < compRatio ? Color.GREEN : Color.WHITE)
				);
			},
			() -> PanelFactory.createOverlayStatsLine(ROBE_HITS.acronym, 50, 50,
				NO_DATA_SHORT, Color.WHITE, NO_DATA_SHORT, Color.WHITE),
			(fight, component) -> {
				int compHits = fight.getCompetitor().getRobeHits();
				int compTotal = fight.getOpponent().getAttackCount() - fight.getOpponent().getTotalMagicAttackCount();
				double compRatio = compTotal > 0 ? (double) compHits / compTotal : 0.0;
				String compStr = compHits + "/" + compTotal;
				component.updateLeftCell(compStr
					, compRatio < ((double) fight.getOpponent().getRobeHits() / Math.max(1, fight.getCompetitor().getAttackCount() - fight.getCompetitor().getTotalMagicAttackCount())) ?
						Color.GREEN : Color.WHITE
				);

				int oppHits = fight.getOpponent().getRobeHits();
				int oppTotal = fight.getCompetitor().getAttackCount() - fight.getCompetitor().getTotalMagicAttackCount();
				double oppRatio = oppTotal > 0 ? (double) oppHits / oppTotal : 0.0;
				String oppStr = oppHits + "/" + oppTotal;
				component.updateRightCell(oppStr
					, oppRatio < compRatio ? Color.GREEN : Color.WHITE
				);
			}
		);

		KO_CHANCES.init(
			(fight, oppFight) -> { // returns FightPerformancePanel component
				// Total KO Chances
				// Calculate total KO chances and overall probability // MODIFIED Calculation
				int competitorKoChances = 0;
				double competitorSurvivalProb = 1.0; // Start with 100% survival chance
				int opponentKoChances = 0;
				double opponentSurvivalProb = 1.0; // Start with 100% survival chance
				List<FightLogEntry> logs = fight.getAllFightLogEntries();
				for (FightLogEntry log : logs)
				{
					Double koChance = log.getKoChance();
					if (koChance != null)
					{
						if (log.attackerName.equals(fight.competitor.getName()))
						{
							competitorKoChances++;
							competitorSurvivalProb *= (1.0 - koChance); // Calculate survival prob
						}
						else
						{
							opponentKoChances++;
							opponentSurvivalProb *= (1.0 - koChance); // Calculate survival prob
						}
					}
				}

				// Calculate overall KO probability
				Double competitorOverallKoProb = (competitorKoChances > 0) ? (1.0 - competitorSurvivalProb) : 0;
				Double opponentOverallKoProb = (opponentKoChances > 0) ? (1.0 - opponentSurvivalProb) : 0;

				String compTotalKoChanceText = competitorKoChances + (competitorOverallKoProb > 0 ? " (" + nfP1.format(competitorOverallKoProb) + ")" : ""); // Use overall prob
				String oppTotalKoChanceText = opponentKoChances + (opponentOverallKoProb > 0 ? " (" + nfP1.format(opponentOverallKoProb) + ")" : ""); // Use overall prob

				return PanelFactory.createStatsLine(KO_CHANCES.acronym, KO_CHANCES.acronymTooltip
					, compTotalKoChanceText
					, fight.competitor.getName() + " got " + competitorKoChances + " KO attempts with an overall KO probability of " + nfP1.format(competitorOverallKoProb)
					, (competitorOverallKoProb > opponentOverallKoProb ? Color.GREEN : Color.WHITE)

					, oppTotalKoChanceText
					, fight.opponent.getName() + " got " + opponentKoChances + " KO attempts with an overall KO probability of " + nfP1.format(opponentOverallKoProb)
					, (opponentOverallKoProb > competitorOverallKoProb ? Color.GREEN : Color.WHITE)
				);
			},
			() -> PanelFactory.createOverlayStatsLine(KO_CHANCES.acronym, 50, 50,
				NO_DATA_SHORT, Color.WHITE, NO_DATA_SHORT, Color.WHITE),
			(fight, component) -> component.updateLeftRightCells(
				fight.getCompetitorKoChanceCount() + (fight.getCompetitorKoChanceCount() > 0
					? " (" + nfP1.format(fight.getCompetitorTotalKoChance()) + ")"
					: ""),
				Color.WHITE,
				fight.getOpponentKoChanceCount() + (fight.getOpponentKoChanceCount() > 0
					? " (" + nfP1.format(fight.getOpponentTotalKoChance()) + ")"
					: ""),
				Color.WHITE
			)
		);

		GHOST_BARRAGES.init(
			(fight, oppFight) -> { // returns FightPerformancePanel component
				String oppGhostBarrageText = NO_DATA;
				String oppGhostBarrageTooltipText = "No data is available for the opponent's ghost barrages";
				Color oppGhostBarrageColor = ColorScheme.BRAND_ORANGE;

				if (oppFight != null)
				{
					Fighter oppComp = oppFight.getCompetitor();

					oppGhostBarrageText = (oppComp.getGhostBarrageStats());
					oppGhostBarrageTooltipText = ("(Advanced): " + oppComp.getName() + " hit " + oppComp.getGhostBarrageCount()
						+ " ghost barrages during the fight, worth an extra " + nf2.format(oppComp.getGhostBarrageExpectedDamage())
						+ " expected damage.<br>Unless fighting in PvP Arena, your opponent likely had a similar value.");
					oppGhostBarrageColor = (oppFight.getCompetitor().getGhostBarrageExpectedDamage() > fight.competitor.getGhostBarrageExpectedDamage()
						? Color.GREEN : ColorScheme.BRAND_ORANGE);
				}

				return PanelFactory.createStatsLine(GHOST_BARRAGES.acronym, GHOST_BARRAGES.acronymTooltip
					, fight.competitor.getGhostBarrageStats()
					, ("(Advanced): " + fight.competitor.getName() + " hit " + fight.competitor.getGhostBarrageCount()
						+ " ghost barrages during the fight, worth an extra " + nf2.format(fight.competitor.getGhostBarrageExpectedDamage())
						+ " expected damage.<br>Unless fighting in PvP Arena, your opponent likely had a similar value.")
					, ((oppFight != null
						&& fight.competitor.getGhostBarrageExpectedDamage() > oppFight.getCompetitor().getGhostBarrageExpectedDamage())
						? Color.GREEN : ColorScheme.BRAND_ORANGE)

					, oppGhostBarrageText
					, oppGhostBarrageTooltipText
					, oppGhostBarrageColor
				);
			},
			() -> PanelFactory.createOverlayStatsLine(GHOST_BARRAGES.acronym, 80, 20,
				NO_DATA_SHORT, ColorScheme.BRAND_ORANGE, NO_DATA_SHORT, ColorScheme.BRAND_ORANGE),
			(fight, component) -> component.updateLeftCellText(fight.getCompetitor().getGhostBarrageStats())
		);

		// ensure all statistics have been initialized, or else plenty of things will break.
		for (TrackedStatistic stat : TrackedStatistic.values())
		{
			if (!stat.initialized)
			{
				throw new InvalidParameterException("TrackedStatistic: An enum value failed to be initialized.");
			}
		}
	}


	private boolean initialized = false;

	@Getter
	private String name;
	@Getter
	private String acronym;
	@Getter
	private String acronymTooltip;

	private BiFunction<FightPerformance, FightPerformance, JPanel> getPanelComponent;

	public JPanel getPanelComponent(FightPerformance f, FightPerformance oppFight)
	{
		return this.getPanelComponent.apply(f, oppFight);
	}

	private Supplier<TableComponent> getOverlayComponent;

	public TableComponent getOverlayComponent()
	{
		return this.getOverlayComponent.get();
	}

	private BiConsumer<FightPerformance, TableComponent> updateOverlayComponent;

	public void updateOverlayComponent(FightPerformance f, TableComponent t)
	{
		this.updateOverlayComponent.accept(f, t);
	}

	TrackedStatistic(String name, String acronym, String acronymTooltip)
	{
		this.name = name;
		this.acronym = acronym;
		this.acronymTooltip = acronymTooltip;

	}

	private void init(BiFunction<FightPerformance, FightPerformance, JPanel> getPanelComponent,
					  Supplier<TableComponent> getOverlayComponent,
					  BiConsumer<FightPerformance, TableComponent> updateOverlayComponent)
	{
		this.getPanelComponent = getPanelComponent;
		this.getOverlayComponent = getOverlayComponent;
		this.updateOverlayComponent = updateOverlayComponent;
		this.initialized = true;
	}

	public String getPrefixedAcronymTooltip()
	{
		return ("<br><br><b><i>" + this.acronym + "</i></b>: " + this.acronymTooltip);
	}
}

/*
 * Copyright (c)  2020, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import java.util.Arrays;
import java.util.stream.Collectors;
import lombok.Getter;
import org.apache.commons.lang3.StringUtils;

public interface RangeAmmoData
{
	RangeAmmoData[] DIAMOND_BOLTS = {
		BoltAmmo.DIAMOND_BOLTS_E,
		StrongBoltAmmo.DIAMOND_BOLTS_E,
		StrongBoltAmmo.DIAMOND_DRAGON_BOLTS_E
	};

	RangeAmmoData[] OPAL_BOLTS = {
		StrongBoltAmmo.OPAL_DRAGON_BOLTS_E
	};

	int getItemId(); // itemIDs used for DISPLAYING bolts, not getting them.
	int getRangeStr();
	double getBonusMaxHit(int rangeLevel); // damage bonus from bolt specs.
	double getDmgModifier(); // damage modifier from bolt specs.

	interface RangeAmmoConfigData extends RangeAmmoData
	{
		String getName();
	}

	@Getter
	enum BoltAmmo implements RangeAmmoConfigData
	{
		RUNITE_BOLTS("Runite Bolts", 9169, 115, 1),
		DRAGONSTONE_BOLTS_E("Dstone Bolts (e)", 9281, 117, 1, .2, 0.06),
		DIAMOND_BOLTS_E("Diamond Bolts (e)", 9277, 105, 1.015);

		static EquipmentData[] WEAPONS_USING = { EquipmentData.RUNE_CROSSBOW };

		private String name;
		private int itemId;
		private int rangeStr;
		private double specRangeLevelModifier;
		private double specChance;
		private double dmgModifier;

		BoltAmmo(String name, int itemId, int rangeStr, double dmgModifier, double specRangeLevelModifier, double specChance)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.specRangeLevelModifier = specRangeLevelModifier;
			this.specChance = specChance;
			this.dmgModifier = dmgModifier;
		}
		BoltAmmo(String name, int itemId, int rangeStr, double dmgModifier)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.specRangeLevelModifier = 0;
			this.specChance = 0;
			this.dmgModifier = dmgModifier;
		}

		public double getBonusMaxHit(int rangeLevel)
		{
			return rangeLevel * specRangeLevelModifier * specChance;
		}

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	enum StrongBoltAmmo implements RangeAmmoConfigData
	{
		RUNITE_BOLTS("Runite Bolts", 9169, 115, 1),
		DRAGONSTONE_BOLTS_E("Dstone Bolts (e)", 9281, 117, 1, .2, 0.06),
		DIAMOND_BOLTS_E("Diamond Bolts (e)", 9277, 105, 1.015),
		DRAGONSTONE_DRAGON_BOLTS_E("Dstone DBolts (e)", 1668, 122, 1, .2, .06),
		OPAL_DRAGON_BOLTS_E("Opal DBolts (e)", 8729, 122, 1, .1, .05),
		DIAMOND_DRAGON_BOLTS_E("Diamond DBolts (e)", 1690, 122, 1.015);

		static EquipmentData[] WEAPONS_USING = {
			EquipmentData.ARMADYL_CROSSBOW,
			EquipmentData.DRAGON_CROSSBOW,
			EquipmentData.DRAGON_HUNTER_CROSSBOW,
			EquipmentData.ZARYTE_CROSSBOW
		};

		private String name;
		private int rangeStr;
		private int itemId;
		private double specRangeLevelModifier;
		private double specChance;
		private double dmgModifier;

		StrongBoltAmmo(String name, int itemId, int rangeStr, double dmgModifier, double specRangeLevelModifier, double specChance)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.specRangeLevelModifier = specRangeLevelModifier;
			this.specChance = specChance;
			this.dmgModifier = dmgModifier;
		}
		StrongBoltAmmo(String name, int itemId, int rangeStr, double dmgModifier)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.specRangeLevelModifier = 0;
			this.specChance = 0;
			this.dmgModifier = dmgModifier;
		}

		public double getBonusMaxHit(int rangeLevel)
		{
			return rangeLevel * specRangeLevelModifier * specChance;
		}


		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	public enum DartAmmo implements RangeAmmoConfigData
	{
		ADAMANT_DARTS("Adamant Darts", 810, 10),
		RUNE_DARTS("Rune Darts", 811, 14),
		DRAGON_DARTS("Dragon Darts", 11230, 20);

		static EquipmentData[] WEAPONS_USING = { EquipmentData.TOXIC_BLOWPIPE };

		private String name;
		private int itemId;
		private int rangeStr;
		private double bonusMaxHit;
		private double dmgModifier;

		DartAmmo(String name, int itemId, int rangeStr)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.bonusMaxHit = 0;
			this.dmgModifier = 1;
		}

		public double getBonusMaxHit(int rangeLevel)
		{
			return 0;
		}

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	public enum OtherAmmo implements RangeAmmoData
	{
		AMETHYST_ARROWS(4770, 55),
		DRAGON_ARROW(11216, 60),
		DRAGON_JAVELIN(19484, 150),
		BOLT_RACK(4740, 55),
		MOONLIGHT_ANTLER_BOLTS(28878, 60);

		private int rangeStr;
		private int itemId;
		private double bonusMaxHit;
		private double dmgModifier;

		OtherAmmo(int itemId, int rangeStr)
		{
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.bonusMaxHit = 0;
			this.dmgModifier = 1;
		}

		public double getBonusMaxHit(int rangeLevel)
		{
			return 0;
		}

		@Override
		public String toString()
		{
			String[] words = super.toString().toLowerCase().split("_");
			Arrays.stream(words)
				.map(StringUtils::capitalize).collect(Collectors.toList()).toArray(words);

			return String.join(" ", words);
		}
	}
}





/*
 * Copyright (c) 2022, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package matsyir.pvpperformancetracker.models;

import org.apache.commons.lang3.ArrayUtils;

public enum FightType
{
	LMS_MAXMED(new CombatLevels(118, 118, 75, 112, 99, 99)),
	LMS_ZERK(new CombatLevels(91, 118, 45, 112, 99, 99)),
	LMS_1DEF(new CombatLevels(91, 118, 1, 112, 99, 99)),
	NORMAL(CombatLevels.getConfigLevels());

	private static FightType[] LMS_TYPES = { LMS_MAXMED, LMS_ZERK, LMS_1DEF };

	private CombatLevels combatLevelsForType;
	FightType(CombatLevels combatLevelsForType)
	{
		this.combatLevelsForType = combatLevelsForType;
	}

	public CombatLevels getCombatLevelsForType()
	{
		if (this == NORMAL)
		{
			return CombatLevels.getConfigLevels();
		}

		return combatLevelsForType;
	}

	public boolean isLmsFight()
	{
		return ArrayUtils.contains(LMS_TYPES, this);
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import com.google.common.collect.ImmutableMap;
import java.security.InvalidParameterException;
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;
import lombok.Getter;
import net.runelite.api.HeadIcon;
import net.runelite.api.SpriteID;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;

public enum AnimationData
{
	// MELEE
	MELEE_VIGGORAS_CHAINMACE(245, AttackStyle.CRUSH),
	MELEE_DAGGER_SLASH(376, AttackStyle.SLASH), // tested w/ dds
	MELEE_SPEAR_STAB(381, AttackStyle.STAB), // tested w/ zammy hasta
	MELEE_SWORD_STAB(386, AttackStyle.STAB), // tested w/ dragon sword, obby sword, d long
	MELEE_SCIM_SLASH(390, AttackStyle.SLASH), // tested w/ rune & dragon scim, d sword, VLS, obby sword, voidwaker

	MELEE_FANG_STAB(9471, AttackStyle.STAB), // tested w/ fang
	MELEE_FANG_SPEC(11222, AttackStyle.STAB, true), // Osmumten's Fang updated special attack animation

	MELEE_GENERIC_SLASH(393, AttackStyle.SLASH), // tested w/ zuriel's staff, d long slash, dclaws regular slash
	MELEE_STAFF_CRUSH(0, AttackStyle.SLASH), // 393 previously, save name to support old fights but no longer track

	MELEE_BATTLEAXE_SLASH(395, AttackStyle.SLASH), // tested w/ rune baxe
	MELEE_MACE_STAB(400, AttackStyle.STAB), // tested w/ d mace
	MELEE_BATTLEAXE_CRUSH(401, AttackStyle.CRUSH), // tested w/ rune baxe, dwh & statius warhammer animation, d mace
	MELEE_2H_CRUSH(406, AttackStyle.CRUSH), // tested w/ rune & dragon 2h
	MELEE_2H_SLASH(407, AttackStyle.SLASH), // tested w/ rune & dragon 2h
	MELEE_STAFF_CRUSH_2(414, AttackStyle.CRUSH), // tested w/ ancient staff, 3rd age wand
	MELEE_STAFF_CRUSH_3(419, AttackStyle.CRUSH), // Common staff crush. Air/fire/etc staves, smoke battlestaff, SOTD/SOL crush, zammy hasta crush
	MELEE_PUNCH(422, AttackStyle.CRUSH),
	MELEE_KICK(423, AttackStyle.CRUSH),
	MELEE_STAFF_STAB(428, AttackStyle.STAB), // tested w/ SOTD/SOL jab, vesta's spear stab, c hally
	MELEE_SPEAR_CRUSH(429, AttackStyle.CRUSH), // tested w/ vesta's spear
	MELEE_STAFF_SLASH(440, AttackStyle.SLASH), // tested w/ SOTD/SOL slash, zammy hasta slash, vesta's spear slash, c hally
	MELEE_BLUE_MOON_FEND(1710, AttackStyle.CRUSH), // Note: the animation is identical between normal/special attacks
	MELEE_BLUE_MOON_JAB(1711, AttackStyle.STAB), // Note: the animation is identical between normal/special attacks
	MELEE_BLUE_MOON_SWIPE(1712, AttackStyle.SLASH), // Note: the animation is identical between normal/special attacks
	MELEE_DLONG_SPEC(1058, AttackStyle.SLASH, true), // tested w/ d long spec, also thammaron's sceptre crush (????)...
	MELEE_DRAGON_MACE_SPEC(1060, AttackStyle.CRUSH, true),
	MELEE_DRAGON_DAGGER_SPEC(1062, AttackStyle.STAB, true, 2),
	MELEE_DRAGON_WARHAMMER_SPEC(1378, AttackStyle.CRUSH, true), // tested w/ dwh, statius warhammer spec
	MELEE_VOIDWAKER_SPEC(11275, AttackStyle.MAGIC, true),
	MELEE_ABYSSAL_WHIP(1658, AttackStyle.SLASH), // tested w/ whip, tent whip
	MELEE_GRANITE_MAUL(1665, AttackStyle.CRUSH), // tested w/ normal gmaul, ornate maul
	MELEE_GRANITE_MAUL_SPEC(1667, AttackStyle.CRUSH, true), // tested w/ normal gmaul, ornate maul
	MELEE_DHAROKS_GREATAXE_CRUSH(2066, AttackStyle.CRUSH),
	MELEE_DHAROKS_GREATAXE_SLASH(2067, AttackStyle.SLASH),
	MELEE_AHRIMS_STAFF_CRUSH(2078, AttackStyle.CRUSH),
	MELEE_OBBY_MAUL_CRUSH(2661, AttackStyle.CRUSH),
	MELEE_ABYSSAL_DAGGER_STAB(3297, AttackStyle.STAB),
	MELEE_ABYSSAL_BLUDGEON_CRUSH(3298, AttackStyle.CRUSH),
	MELEE_ABYSSAL_DAGGER_SPEC(3300, AttackStyle.SLASH, true, 2),
	MELEE_LEAF_BLADED_BATTLEAXE_CRUSH(3852, AttackStyle.CRUSH),
	MELEE_INQUISITORS_MACE(4503, AttackStyle.CRUSH),
	MELEE_BARRELCHEST_ANCHOR_CRUSH(5865, AttackStyle.CRUSH),
	MELEE_LEAF_BLADED_BATTLEAXE_SLASH(7004, AttackStyle.SLASH),
	MELEE_GODSWORD_SLASH(7045, AttackStyle.SLASH), // tested w/ AGS, BGS, ZGS, SGS, AGS(or) sara sword
	MELEE_GODSWORD_CRUSH(7054, AttackStyle.CRUSH), // tested w/ AGS, BGS, ZGS, SGS, sara sword
	MELEE_DRAGON_CLAWS_SPEC(7514, AttackStyle.SLASH, true, 2, 2),
	MELEE_VLS_SPEC(7515, AttackStyle.SLASH, true), // both VLS and dragon sword spec
	MELEE_ELDER_MAUL(7516, AttackStyle.CRUSH),
	MELEE_ZAMORAK_GODSWORD_SPEC(7638, AttackStyle.SLASH, true), // tested zgs spec
	MELEE_ZAMORAK_GODSWORD_OR_SPEC(7639, AttackStyle.SLASH, true), // UNTESTED, assumed due to ags(or)
	MELEE_SARADOMIN_GODSWORD_SPEC(7640, AttackStyle.SLASH, true), // tested sgs spec
	MELEE_SARADOMIN_GODSWORD_OR_SPEC(7641, AttackStyle.SLASH, true), // UNTESTED, assumed due to ags(or)
	MELEE_BANDOS_GODSWORD_SPEC(7642, AttackStyle.SLASH, true), // tested bgs spec
	MELEE_BANDOS_GODSWORD_OR_SPEC(7643, AttackStyle.SLASH, true), // UNTESTED, assumed due to ags(or)
	MELEE_ARMADYL_GODSWORD_SPEC(7644, AttackStyle.SLASH, true), // tested ags spec
	MELEE_ARMADYL_GODSWORD_OR_SPEC(7645, AttackStyle.SLASH, true), // tested ags(or) spec
	MELEE_ARMADYL_GODSWORD_LMS_SPEC(10427, AttackStyle.SLASH, true), // golden ags spec from LMS
	MELEE_SCYTHE(8056, AttackStyle.SLASH), // tested w/ all scythe styles (so could be crush, but unlikely)
	MELEE_GHAZI_RAPIER_STAB(8145, AttackStyle.STAB), // rapier slash is 390, basic slash animation. Also VLS stab.
	MELEE_ANCIENT_GODSWORD_SPEC(9171, AttackStyle.SLASH, true),
	MELEE_DUAL_MACUACHUITL(10989, AttackStyle.CRUSH), // Note the animation is identical for stab attacks and normal/special attack
	MELEE_ELDER_MAUL2(11124, AttackStyle.CRUSH), // spec anim, but looks like this anim is also used for normal attacks after using the spec. No spec tracking for now, just for normal attacks
    MELEE_BURNING_CLAWS_SPEC(11140, AttackStyle.SLASH, true, 3),
    MELEE_ARKAN_BLADE_SPEC(12297, AttackStyle.SLASH, true),

	// RANGED
	RANGED_SHORTBOW(426, AttackStyle.RANGED), // Confirmed same w/ 3 types of arrows, w/ maple, magic, & hunter's shortbow, craw's bow, dbow, dbow spec
	RANGED_RUNE_KNIFE_PVP(929, AttackStyle.RANGED), // 1 tick animation, has 1 tick delay between attacks. likely same for all knives. Same for morrigan's javelins, both spec & normal attack.
	RANGED_MAGIC_SHORTBOW_SPEC(1074, AttackStyle.RANGED, true),
	RANGED_CROSSBOW_PVP(4230, AttackStyle.RANGED), // Tested RCB & ACB w/ dragonstone bolts (e) & diamond bolts (e)
	RANGED_BLOWPIPE(5061, AttackStyle.RANGED), // tested in PvP with all styles. Has 1 tick delay between animations in pvp.
	RANGED_DARTS(6600, AttackStyle.RANGED), // tested w/ addy darts. Seems to be constant animation but sometimes stalls and doesn't animate
	RANGED_BALLISTA(7218, AttackStyle.RANGED), // Tested w/ dragon javelins.
	RANGED_DRAGON_THROWNAXE_SPEC(7521, AttackStyle.RANGED, true),
	RANGED_RUNE_CROSSBOW(7552, AttackStyle.RANGED),
	RANGED_BALLISTA_2(7555, AttackStyle.RANGED), // tested w/ light & heavy ballista, dragon & iron javelins.
	RANGED_RUNE_KNIFE(7617, AttackStyle.RANGED), // 1 tick animation, has 1 tick delay between attacks. Also d thrownaxe
	RANGED_DRAGON_KNIFE(8194, AttackStyle.RANGED),
	RANGED_DRAGON_KNIFE_POISONED(8195, AttackStyle.RANGED), // tested w/ d knife p++
	RANGED_DRAGON_KNIFE_SPEC(8292, AttackStyle.RANGED, true),
	RANGED_ZARYTE_CROSSBOW(9168, AttackStyle.RANGED),
	RANGED_ZARYTE_CROSSBOW_PVP(9166, AttackStyle.RANGED),
	RANGED_VENATOR(9858, AttackStyle.RANGED),
	RANGED_ECLIPSE_ATLATL(11057, AttackStyle.RANGED),
	RANGED_ECLIPSE_ATLATL_SPEC(11060, AttackStyle.RANGED, true),
	RANGED_KARILS_CROSSBOW(2075, AttackStyle.RANGED),
	RANGED_HUNTERS_SUNLIGHT_CROSSBOW(11465, AttackStyle.RANGED),
	RANGED_DARK_BOW(0, AttackStyle.RANGED, false, 1, 1), // double arrow hits (regular)
	RANGED_DARK_BOW_SPEC(0, AttackStyle.RANGED, true, 1, 1), // spec, same double hitsplat pattern
	RANGED_DRAGON_CROSSBOW_SPEC(0, AttackStyle.RANGED, true), // Annihilate spec

	// MAGIC - uses highest base damage available when animations are re-used. No damage = 0 damage.
	// for example, strike/bolt/blast animation will be fire blast base damage, multi target ancient spells will be ice barrage.
	MAGIC_STANDARD_BIND(710, AttackStyle.MAGIC), // tested w/ bind, snare, entangle
	MAGIC_STANDARD_STRIKE_BOLT_BLAST(711, 16), // tested w/ bolt
	MAGIC_STANDARD_BIND_STAFF(1161, AttackStyle.MAGIC), // tested w/ bind, snare, entangle, various staves
	MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF(1162, 16), // strike, bolt and blast (tested all spells, different weapons)
	MAGIC_STANDARD_WAVE_STAFF(1167, 20), // tested many staves
	MAGIC_STANDARD_SURGE_STAFF(7855, 24), // tested many staves
	MAGIC_STANDARD_GOD_SPELL(811, 30), // Same animation for flames of zamorak, claws of guthix and saradomin strike. Assumes charge is active.
	MAGIC_ANCIENT_SINGLE_TARGET(1978, 26), // Rush & Blitz animations (tested all 8, different weapons)
	MAGIC_ANCIENT_MULTI_TARGET(1979, 30), // Burst & Barrage animations (tested all 8, different weapons)
	MAGIC_VOLATILE_NIGHTMARE_STAFF_SPEC(8532, 66); // assume 99 mage's base damage (does not rise when boosted).

	private static final Map<Integer, AnimationData> DATA;

	public int animationId;
	public boolean isSpecial;
	public AttackStyle attackStyle;
	public int baseSpellDamage;
	@Getter
	private final int[] hitsplatGroupPattern;

	// Simple animation data constructor for all melee and range attacks
	AnimationData(int animationId, AttackStyle attackStyle)
	{
		if (attackStyle == null)
		{
			throw new InvalidParameterException("Attack Style must be valid for AnimationData");
		}
		this.animationId = animationId;
		this.attackStyle = attackStyle;
		this.isSpecial = false;
		this.baseSpellDamage = 0;
		this.hitsplatGroupPattern = new int[] {1};
	}
	// Simple animation data constructor for all melee and range attacks w/ special
	AnimationData(int animationId, AttackStyle attackStyle, boolean isSpecial)
	{
		if (attackStyle == null)
		{
			throw new InvalidParameterException("Attack Style must be valid for AnimationData");
		}
		this.animationId = animationId;
		this.attackStyle = attackStyle;
		this.isSpecial = isSpecial;
		this.baseSpellDamage = 0;
		this.hitsplatGroupPattern = new int[] {1};
	}
	// Magic spell animation data constructor including base spell damage
	AnimationData(int animationId, int baseSpellDamage)
	{
		this.animationId = animationId;
		this.attackStyle = AttackStyle.MAGIC;
		this.isSpecial = false;
		this.baseSpellDamage = baseSpellDamage;
		this.hitsplatGroupPattern = new int[] {1};
	}
	// Constructor for special multi-hit patterns
	AnimationData(int animationId, AttackStyle attackStyle, boolean isSpecial, int... hitsplatGroupPattern)
	{
		if (attackStyle == null)
		{
			throw new InvalidParameterException("Attack Style must be valid for AnimationData");
		}
		this.animationId = animationId;
		this.attackStyle = attackStyle;
		this.isSpecial = isSpecial;
		this.baseSpellDamage = 0;
		this.hitsplatGroupPattern = hitsplatGroupPattern.length > 0
			? hitsplatGroupPattern
			: new int[] {1};
	}

	static
	{
		ImmutableMap.Builder<Integer, AnimationData> builder = new ImmutableMap.Builder<>();

		for (AnimationData data : values())
		{
			// allow to skip animation detection by using 0 or less as the animation id.
			if (data.animationId <= 0) { continue; }
			builder.put(data.animationId, data);
		}

		DATA = builder.build();
	}

	public static AnimationData fromId(int animationId)
	{
		return DATA.get(animationId);
	}

	public static boolean isStandardSpellbookSpell(AnimationData animationData)
	{
		return (animationData == MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF ||
			animationData == MAGIC_STANDARD_STRIKE_BOLT_BLAST ||
			animationData == MAGIC_STANDARD_WAVE_STAFF ||
			animationData == MAGIC_STANDARD_SURGE_STAFF);
	}

	public static boolean isFireSpell(AnimationData animationData)
	{
		return (animationData == MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF ||
			animationData == MAGIC_STANDARD_STRIKE_BOLT_BLAST ||
			animationData == MAGIC_STANDARD_WAVE_STAFF ||
			animationData == MAGIC_STANDARD_SURGE_STAFF);
	}

	@Override
	public String toString()
	{
		String[] words = super.toString().toLowerCase().split("_");
		Arrays.stream(words)
			.map(StringUtils::capitalize).collect(Collectors.toList()).toArray(words);

		return String.join(" ", words);
	}


	// An enum of combat styles (including stab, slash, crush).
	public enum AttackStyle
	{
		STAB(HeadIcon.MELEE, SpriteID.COMBAT_STYLE_SWORD_STAB),
		SLASH(HeadIcon.MELEE, SpriteID.COMBAT_STYLE_SWORD_SLASH),
		CRUSH(HeadIcon.MELEE, SpriteID.COMBAT_STYLE_HAMMER_POUND),
		RANGED(HeadIcon.RANGED, SpriteID.SKILL_RANGED),
		MAGIC(HeadIcon.MAGIC, SpriteID.SKILL_MAGIC);

		static AttackStyle[] MELEE_STYLES = {STAB, SLASH, CRUSH};

		@Getter
		private final HeadIcon protection;

		@Getter
		private final int styleSpriteId;

		AttackStyle(HeadIcon protection, int styleSpriteId)
		{
			this.protection = protection;
			this.styleSpriteId = styleSpriteId;
		}

		public boolean isMelee()
		{
			return ArrayUtils.contains(AttackStyle.MELEE_STYLES, this);
		}

		public boolean isUsingSuccessfulOffensivePray(int pray)
		{
			return (pray > 0 &&
				((isMelee() &&
					(pray == SpriteID.PRAYER_PIETY ||
					 pray == SpriteID.PRAYER_ULTIMATE_STRENGTH)) ||
				(this == RANGED &&
					(pray == SpriteID.PRAYER_RIGOUR ||
					 pray == SpriteID.PRAYER_EAGLE_EYE)) ||
				(this == MAGIC &&
					(pray == SpriteID.PRAYER_AUGURY ||
					 pray == SpriteID.PRAYER_MYSTIC_MIGHT)))
			);
		}


		@Override
		public String toString()
		{
			return StringUtils.capitalize(super.toString().toLowerCase());
		}
	}
}

/*
 * Copyright (c) 2020, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import lombok.Getter;
import net.runelite.api.ItemID;

@Getter
public enum RingData
{
	SEERS_RING("Seers Ring", ItemID.SEERS_RING),
	ARCHERS_RING("Archers Ring", ItemID.ARCHERS_RING),
	BERSERKER_RING("Berserker Ring", ItemID.BERSERKER_RING),
	RING_OF_SUFFERING("Ring of Suffering", ItemID.RING_OF_SUFFERING),
	SEERS_RING_I("Seers Ring (i)", ItemID.SEERS_RING_I),
	ARCHERS_RING_I("Archers Ring (i)", ItemID.ARCHERS_RING_I),
	BERSERKER_RING_I("Berserker Ring (i)", ItemID.BERSERKER_RING_I),
	RING_OF_SUFFERING_I("Ring of Suffering (i)", ItemID.RING_OF_SUFFERING_I),
	BRIMSTONE_RING("Brimstone Ring", ItemID.BRIMSTONE_RING),
	MAGUS_RING("Magus ring", ItemID.MAGUS_RING_28313),
	VENATOR_RING("Venator ring", ItemID.VENATOR_RING_28310),
	BELLATOR_RING("Bellator ring", ItemID.BELLATOR_RING_28316),
	ULTOR_RING("Ultor ring", ItemID.ULTOR_RING_28307),
	RING_OF_SHADOWS("Ring of Shadows", ItemID.RING_OF_SHADOWS),
	NONE("None", -1);

	private String name;
	private int itemId;

	RingData(String name, int itemId)
	{
		this.name = name;
		this.itemId = itemId;
	}

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import net.runelite.api.Client;
import net.runelite.api.Skill;

// Basic class that will be used to save current combat levels (including boosts/drains)
@Getter
public class CombatLevels
{
	public static CombatLevels getConfigLevels()
	{
		return new CombatLevels(CONFIG.attackLevel(),
			CONFIG.strengthLevel(),
			CONFIG.defenceLevel(),
			CONFIG.rangedLevel(),
			CONFIG.magicLevel(),
			99);
	}

	@Expose
	@SerializedName("a")
	public int atk;
	@Expose
	@SerializedName("s")
	public int str;
	@Expose
	@SerializedName("d")
	public int def;
	@Expose
	@SerializedName("r")
	public int range;
	@Expose
	@SerializedName("m")
	public int mage;
	@Expose
	@SerializedName("h")
	public int hp; // not currently used but potential dh support in future?

	public CombatLevels(int atk, int str, int def, int range, int mage, int hp)
	{
		this.atk = atk;
		this.str = str;
		this.def = def;
		this.range = range;
		this.mage = mage;
		this.hp = hp;
	}

	public CombatLevels(Client client)
	{
		this.atk = client.getBoostedSkillLevel(Skill.ATTACK);
		this.str = client.getBoostedSkillLevel(Skill.STRENGTH);
		this.def = client.getBoostedSkillLevel(Skill.DEFENCE);
		this.range = client.getBoostedSkillLevel(Skill.RANGED);
		this.mage = client.getBoostedSkillLevel(Skill.MAGIC);
		this.hp = client.getBoostedSkillLevel(Skill.HITPOINTS);
	}

	public int getSkill(Skill skill)
	{
		switch(skill)
		{
			case ATTACK:    return atk;
			case STRENGTH:  return str;
			case DEFENCE:   return def;
			case RANGED:    return range;
			case MAGIC:     return mage;
			case HITPOINTS: return hp;
			default:        return 0;
		}
	}
}

/*
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * Copyright (c) 2020, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;
import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin;
import matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils;
import net.runelite.api.ItemID;
import net.runelite.api.kit.KitType;
import org.apache.commons.lang3.ArrayUtils;

// Mostly to help fetch LMS gear stats, since LMS items are copies of real items, so their stats aren't
// cached like most items. Each LMS item will have the 'real' itemId so the stats can be looked up.
// A few non-LMS range weapons will be saved in order to help estimate ammo type/range strength based
// on current weapon itemId, or to determine special attacks used.
@SuppressWarnings("deprecation") // ItemID deprecation isnt a problem
public enum EquipmentData
{
	// Non-LMS items:
	DRAGON_CROSSBOW(ItemID.DRAGON_CROSSBOW),
	KARILS_CROSSBOW(ItemID.KARILS_CROSSBOW, ItemID.KARILS_CROSSBOW_100, ItemID.KARILS_CROSSBOW_75, ItemID.KARILS_CROSSBOW_50, ItemID.KARILS_CROSSBOW_25, ItemID.KARILS_CROSSBOW_0),
	HUNTERS_SUNLIGHT_CROSSBOW(ItemID.HUNTERS_SUNLIGHT_CROSSBOW),
	BURNING_CLAWS(ItemID.BURNING_CLAWS),
	DRAGON_HUNTER_CROSSBOW(ItemID.DRAGON_HUNTER_CROSSBOW),
	MAGIC_SHORTBOW(ItemID.MAGIC_SHORTBOW),
	MAGIC_SHORTBOW_I(ItemID.MAGIC_SHORTBOW_I),
	TOXIC_BLOWPIPE(ItemID.TOXIC_BLOWPIPE),
	VOLATILE_NIGHTMARE_STAFF(ItemID.VOLATILE_NIGHTMARE_STAFF, ItemID.VOLATILE_NIGHTMARE_STAFF_DEADMAN),
	//CRAWS_BOW(22550), // ammo bonus is built into weapon so we don't need to include it
	SMOKE_BATTLESTAFF(ItemID.SMOKE_BATTLESTAFF),
	VOID_MAGE_HELM(ItemID.VOID_MAGE_HELM, ItemID.VOID_MAGE_HELM_L),
	VOID_RANGE_HELM(ItemID.VOID_RANGER_HELM, ItemID.VOID_RANGER_HELM_L),
	VOID_MELEE_HELM(ItemID.VOID_MELEE_HELM, ItemID.VOID_MELEE_HELM_L),
	VOID_ELITE_BODY(ItemID.ELITE_VOID_TOP, ItemID.ELITE_VOID_TOP_L),
	VOID_ELITE_LEGS(ItemID.ELITE_VOID_ROBE, ItemID.ELITE_VOID_ROBE_L),
	VOID_GLOVES(ItemID.VOID_KNIGHT_GLOVES, ItemID.VOID_KNIGHT_GLOVES_L),
	VOID_BODY(ItemID.VOID_KNIGHT_TOP, ItemID.VOID_KNIGHT_TOP_L),
	VOID_LEGS(ItemID.VOID_KNIGHT_ROBE, ItemID.VOID_KNIGHT_ROBE_L),
	CRYSTAL_HELM(ItemID.CRYSTAL_HELM),
	CRYSTAL_BODY(ItemID.CRYSTAL_BODY),
	CRYSTAL_LEGS(ItemID.CRYSTAL_LEGS),
	CRYSTAL_BOW(ItemID.CRYSTAL_BOW_FULL, ItemID.CRYSTAL_BOW, ItemID.CRYSTAL_BOW_110, ItemID.CRYSTAL_BOW_210, ItemID.CRYSTAL_BOW_310, ItemID.CRYSTAL_BOW_410, ItemID.CRYSTAL_BOW_510, ItemID.CRYSTAL_BOW_610, ItemID.CRYSTAL_BOW_710, ItemID.CRYSTAL_BOW_810, ItemID.CRYSTAL_BOW_910),
	CRYSTAL_BOW_I(ItemID.CRYSTAL_BOW_FULL_I, ItemID.CRYSTAL_BOW_110_I, ItemID.CRYSTAL_BOW_210_I, ItemID.CRYSTAL_BOW_310_I, ItemID.CRYSTAL_BOW_410_I, ItemID.CRYSTAL_BOW_510_I, ItemID.CRYSTAL_BOW_610_I, ItemID.CRYSTAL_BOW_710_I, ItemID.CRYSTAL_BOW_810_I, ItemID.CRYSTAL_BOW_910_I),
	DRAGON_LONGSWORD(ItemID.DRAGON_LONGSWORD),
	OSMUMTENS_FANG(ItemID.OSMUMTENS_FANG, ItemID.OSMUMTENS_FANG_OR),
	ARKAN_BLADE(ItemID.ARKAN_BLADE),

	// LMS items:
	RUNE_CROSSBOW(ItemID.RUNE_CROSSBOW, ItemID.RUNE_CROSSBOW_23601),
	ARMADYL_CROSSBOW(ItemID.ARMADYL_CROSSBOW, ItemID.ARMADYL_CROSSBOW_23611),
	DARK_BOW(ItemID.DARK_BOW, ItemID.DARK_BOW_20408, ItemID.DARK_BOW_12765, ItemID.DARK_BOW_12766, ItemID.DARK_BOW_12767, ItemID.DARK_BOW_12768, ItemID.DARK_BOW_DEADMAN),
	HEAVY_BALLISTA(ItemID.HEAVY_BALLISTA, ItemID.HEAVY_BALLISTA_23630),

	STATIUS_WARHAMMER(ItemID.STATIUSS_WARHAMMER, ItemID.STATIUSS_WARHAMMER_23620),
	VESTAS_LONGSWORD(ItemID.VESTAS_LONGSWORD, ItemID.VESTAS_LONGSWORD_23615, ItemID.VESTAS_BLIGHTED_LONGSWORD),
	ARMADYL_GODSWORD(ItemID.ARMADYL_GODSWORD, ItemID.ARMADYL_GODSWORD_20593, ItemID.ARMADYL_GODSWORD_OR, ItemID.ARMADYL_GODSWORD_DEADMAN),
	DRAGON_CLAWS(ItemID.DRAGON_CLAWS, ItemID.DRAGON_CLAWS_20784),
	DRAGON_DAGGER(ItemID.DRAGON_DAGGER, ItemID.DRAGON_DAGGER_20407, ItemID.DRAGON_DAGGERP, ItemID.DRAGON_DAGGERP_5680, ItemID.DRAGON_DAGGERP_5698),
	GRANITE_MAUL(ItemID.GRANITE_MAUL, ItemID.GRANITE_MAUL_12848, ItemID.GRANITE_MAUL_20557, ItemID.GRANITE_MAUL_24225, ItemID.GRANITE_MAUL_24227),
	AMULET_OF_FURY(ItemID.AMULET_OF_FURY, ItemID.AMULET_OF_FURY_23640),
	BANDOS_TASSETS(ItemID.BANDOS_TASSETS, ItemID.BANDOS_TASSETS_23646),
	BLESSED_SPIRIT_SHIELD(ItemID.BLESSED_SPIRIT_SHIELD, ItemID.BLESSED_SPIRIT_SHIELD_23642),
	DHAROKS_HELM(ItemID.DHAROKS_HELM, ItemID.DHAROKS_HELM_23639),
	DHAROKS_PLATELEGS(ItemID.DHAROKS_PLATELEGS, ItemID.DHAROKS_PLATELEGS_23633),
	GUTHANS_HELM(ItemID.GUTHANS_HELM, ItemID.GUTHANS_HELM_23638),
	KARILS_TOP(ItemID.KARILS_LEATHERTOP, ItemID.KARILS_LEATHERTOP_23632),
	TORAGS_HELM(ItemID.TORAGS_HELM, ItemID.TORAGS_HELM_23637),
	TORAGS_PLATELEGS(ItemID.TORAGS_PLATELEGS, ItemID.TORAGS_PLATELEGS_23634),
	VERACS_HELM(ItemID.VERACS_HELM, ItemID.VERACS_HELM_23636),
	VERACS_PLATESKIRT(ItemID.VERACS_PLATESKIRT, ItemID.VERACS_PLATESKIRT_23635),
	MORRIGANS_JAVELIN(ItemID.MORRIGANS_JAVELIN, ItemID.MORRIGANS_JAVELIN_23619),
	SPIRIT_SHIELD(ItemID.SPIRIT_SHIELD, ItemID.SPIRIT_SHIELD_23599),
	HELM_OF_NEITIZNOT(ItemID.HELM_OF_NEITIZNOT, ItemID.HELM_OF_NEITIZNOT_23591),
	AMULET_OF_GLORY(ItemID.AMULET_OF_GLORY, ItemID.AMULET_OF_GLORY_20586),
	ABYSSAL_WHIP(ItemID.ABYSSAL_WHIP, ItemID.ABYSSAL_WHIP_20405),
	DRAGON_DEFENDER(ItemID.DRAGON_DEFENDER, ItemID.DRAGON_DEFENDER_23597),
	BLACK_DHIDE_BODY(ItemID.BLACK_DHIDE_BODY, ItemID.BLACK_DHIDE_BODY_20423),
	RUNE_PLATELEGS(ItemID.RUNE_PLATELEGS, ItemID.RUNE_PLATELEGS_20422),
	CLIMBING_BOOTS(ItemID.CLIMBING_BOOTS, ItemID.CLIMBING_BOOTS_20578),
	BARROWS_GLOVES(ItemID.BARROWS_GLOVES, ItemID.BARROWS_GLOVES_23593),
	ELDER_MAUL(ItemID.ELDER_MAUL, ItemID.ELDER_MAUL_21205),
	INFERNAL_CAPE(ItemID.INFERNAL_CAPE, ItemID.INFERNAL_CAPE_23622),
	GHRAZI_RAPIER(ItemID.GHRAZI_RAPIER, ItemID.GHRAZI_RAPIER_23628),

	ZURIELS_STAFF(ItemID.ZURIELS_STAFF, ItemID.ZURIELS_STAFF_23617),
	STAFF_OF_THE_DEAD(ItemID.STAFF_OF_THE_DEAD, ItemID.STAFF_OF_THE_DEAD_23613),
	KODAI_WAND(ItemID.KODAI_WAND, ItemID.KODAI_WAND_23626),
	AHRIMS_STAFF(ItemID.AHRIMS_STAFF, ItemID.AHRIMS_STAFF_23653),
	MYSTIC_ROBE_TOP(ItemID.MYSTIC_ROBE_TOP, ItemID.MYSTIC_ROBE_TOP_20425, ItemID.MYSTIC_ROBE_TOP_DARK_27158, ItemID.MYSTIC_ROBE_TOP_LIGHT_27160),
	MYSTIC_ROBE_BOTTOM(ItemID.MYSTIC_ROBE_BOTTOM, ItemID.MYSTIC_ROBE_BOTTOM_20426, ItemID.MYSTIC_ROBE_BOTTOM_DARK_27159, ItemID.MYSTIC_ROBE_BOTTOM_LIGHT_27161),
	AHRIMS_ROBE_TOP(ItemID.AHRIMS_ROBETOP, ItemID.AHRIMS_ROBETOP_20598),
	AHRIMS_ROBE_SKIRT(ItemID.AHRIMS_ROBESKIRT, ItemID.AHRIMS_ROBESKIRT_20599),
	OCCULT_NECKLACE(ItemID.OCCULT_NECKLACE, ItemID.OCCULT_NECKLACE_23654),
	MAGES_BOOK(ItemID.MAGES_BOOK, ItemID.MAGES_BOOK_23652),
	ETERNAL_BOOTS(ItemID.ETERNAL_BOOTS, ItemID.ETERNAL_BOOTS_23644),
	IMBUED_ZAMORAK_CAPE(ItemID.IMBUED_ZAMORAK_CAPE, ItemID.IMBUED_ZAMORAK_CAPE_23605),
	IMBUED_GUTHIX_CAPE(ItemID.IMBUED_GUTHIX_CAPE, ItemID.IMBUED_GUTHIX_CAPE_23603),
	IMBUED_SARADOMIN_CAPE(ItemID.IMBUED_SARADOMIN_CAPE, ItemID.IMBUED_SARADOMIN_CAPE_23607),

	TOME_OF_FIRE(ItemID.TOME_OF_FIRE, ItemID.TOME_OF_FIRE_27358), // (charged tome)
	WIZARD_BOOTS(ItemID.WIZARD_BOOTS, ItemID.WIZARD_BOOTS_27162),
	GUTHIX_HALO(ItemID.GUTHIX_HALO, ItemID.GUTHIX_HALO_27163),
	ZAMORAK_HALO(ItemID.ZAMORAK_HALO, ItemID.ZAMORAK_HALO_27164),
	SARADOMIN_HALO(ItemID.SARADOMIN_HALO, ItemID.SARADOMIN_HALO_27165),
	GHOSTLY_HOOD(ItemID.GHOSTLY_HOOD, ItemID.GHOSTLY_HOOD_27166),
	GHOSTLY_ROBETOP(ItemID.GHOSTLY_ROBE, ItemID.GHOSTLY_ROBE_27167),
	GHOSTLY_ROBE(ItemID.GHOSTLY_ROBE_6108, ItemID.GHOSTLY_ROBE_27168),
	BERSERKER_HELM(ItemID.BERSERKER_HELM, ItemID.BERSERKER_HELM_27169),
	INFINITY_BOOTS(ItemID.INFINITY_BOOTS, ItemID.INFINITY_BOOTS_27170),
	TORMENTED_BRACELET(ItemID.TORMENTED_BRACELET, ItemID.TORMENTED_BRACELET_27171),
	NECKLACE_OF_ANGUISH(ItemID.NECKLACE_OF_ANGUISH, ItemID.NECKLACE_OF_ANGUISH_27172, ItemID.NECKLACE_OF_ANGUISH_OR),
	ELDER_CHAOS_TOP(ItemID.ELDER_CHAOS_TOP, ItemID.ELDER_CHAOS_TOP_27174, ItemID.ELDER_CHAOS_TOP_OR),
	ELDER_CHAOS_ROBE(ItemID.ELDER_CHAOS_ROBE, ItemID.ELDER_CHAOS_ROBE_27175, ItemID.ELDER_CHAOS_ROBE_OR),
	ELDER_CHAOS_HOOD(ItemID.ELDER_CHAOS_HOOD, ItemID.ELDER_CHAOS_HOOD_27176, ItemID.ELDER_CHAOS_HOOD_OR),
	FREMENNIK_KILT(ItemID.FREMENNIK_KILT, ItemID.FREMENNIK_KILT_27177),
	SPIKED_MANACLES(ItemID.SPIKED_MANACLES, ItemID.SPIKED_MANACLES_27178),
	RANGERS_TUNIC(ItemID.RANGERS_TUNIC, ItemID.RANGERS_TUNIC_27179),
	GUTHIX_CHAPS(ItemID.GUTHIX_CHAPS, ItemID.GUTHIX_CHAPS_27180),
	ZAMORAK_CHAPS(ItemID.ZAMORAK_CHAPS, ItemID.ZAMORAK_CHAPS_27181),
	SARADOMIN_CHAPS(ItemID.SARADOMIN_CHAPS, ItemID.SARADOMIN_CHAPS_27182),
	_3RD_AGE_MAGE_HAT(ItemID._3RD_AGE_MAGE_HAT, ItemID._3RD_AGE_MAGE_HAT_27183),
	ANCIENT_GODSWORD(ItemID.ANCIENT_GODSWORD, ItemID.ANCIENT_GODSWORD_27184),
	RUNE_DEFENDER(ItemID.RUNE_DEFENDER, ItemID.RUNE_DEFENDER_27185),
	ZARYTE_CROSSBOW(ItemID.ZARYTE_CROSSBOW, ItemID.ZARYTE_CROSSBOW_27186),
	BOW_OF_FAERDHINEN(ItemID.BOW_OF_FAERDHINEN, ItemID.BOW_OF_FAERDHINEN_C, ItemID.BOW_OF_FAERDHINEN_C_25869, ItemID.BOW_OF_FAERDHINEN_C_25884, ItemID.BOW_OF_FAERDHINEN_C_25886, ItemID.BOW_OF_FAERDHINEN_C_25888, ItemID.BOW_OF_FAERDHINEN_C_25890, ItemID.BOW_OF_FAERDHINEN_C_25892, ItemID.BOW_OF_FAERDHINEN_C_25894, ItemID.BOW_OF_FAERDHINEN_C_25896, ItemID.BOW_OF_FAERDHINEN_27187),
	LIGHT_BALLISTA(ItemID.LIGHT_BALLISTA, ItemID.LIGHT_BALLISTA_27188),
	VERACS_FLAIL(ItemID.VERACS_FLAIL, ItemID.VERACS_FLAIL_27189),
	VERACS_BRASSARD(ItemID.VERACS_BRASSARD, ItemID.VERACS_BRASSARD_27190),
	UNHOLY_BOOK(ItemID.UNHOLY_BOOK, ItemID.UNHOLY_BOOK_27191),
	// hmmmm OPAL_DRAGON_BOLTS_E(ItemID.OPAL_DRAGON_BOLTS_E, ItemID.OPAL_DRAGON_BOLTS_E_27192)
	ANCESTRAL_ROBE_TOP(ItemID.ANCESTRAL_ROBE_TOP, ItemID.ANCESTRAL_ROBE_TOP_27193, ItemID.TWISTED_ANCESTRAL_ROBE_TOP),
	ANCESTRAL_ROBE_BOTTOM(ItemID.ANCESTRAL_ROBE_BOTTOM, ItemID.ANCESTRAL_ROBE_BOTTOM_27194, ItemID.TWISTED_ANCESTRAL_ROBE_BOTTOM),
	INQUISITORS_GREAT_HELM(ItemID.INQUISITORS_GREAT_HELM, ItemID.INQUISITORS_GREAT_HELM_27195),
	INQUISITORS_HAUBERK(ItemID.INQUISITORS_HAUBERK, ItemID.INQUISITORS_HAUBERK_27196),
	INQUISITORS_PLATESKIRT(ItemID.INQUISITORS_PLATESKIRT, ItemID.INQUISITORS_PLATESKIRT_27197),
	INQUISITORS_MACE(ItemID.INQUISITORS_MACE, ItemID.INQUISITORS_MACE_27198),
	_3RD_AGE_RANGE_TOP(ItemID._3RD_AGE_RANGE_TOP, ItemID._3RD_AGE_RANGE_TOP_27199),
	_3RD_AGE_RANGE_LEGS(ItemID._3RD_AGE_RANGE_LEGS, ItemID._3RD_AGE_RANGE_LEGS_27200),
	_3RD_AGE_RANGE_COIF(ItemID._3RD_AGE_RANGE_COIF, ItemID._3RD_AGE_RANGE_COIF_27201),

	DRAGON_WARHAMMER(ItemID.DRAGON_WARHAMMER, ItemID.DRAGON_WARHAMMER_20785),
	VOIDWAKER(ItemID.VOIDWAKER, ItemID.VOIDWAKER_27869, ItemID.VOIDWAKER_DEADMAN),

	DUAL_MACUAHUITL(ItemID.DUAL_MACUAHUITL, ItemID.DUAL_MACUAHUITL_29850),
	BLOOD_MOON_CHESTPLATE(ItemID.BLOOD_MOON_CHESTPLATE, ItemID.BLOOD_MOON_CHESTPLATE_29846),
	BLOOD_MOON_HELM(ItemID.BLOOD_MOON_HELM, ItemID.BLOOD_MOON_HELM_29848),
	BLOOD_MOON_TASSETS(ItemID.BLOOD_MOON_TASSETS, ItemID.BLOOD_MOON_TASSETS_29847),
	BLUE_MOON_SPEAR(ItemID.BLUE_MOON_SPEAR, ItemID.BLUE_MOON_SPEAR_29849),
	BLUE_MOON_CHESTPLATE(ItemID.BLUE_MOON_CHESTPLATE, ItemID.BLUE_MOON_CHESTPLATE_29843),
	BLUE_MOON_HELM(ItemID.BLUE_MOON_HELM, ItemID.BLUE_MOON_HELM_29845),
	BLUE_MOON_TASSETS(ItemID.BLUE_MOON_TASSETS, ItemID.BLUE_MOON_TASSETS_29844),
	ECLIPSE_ATLATL(ItemID.ECLIPSE_ATLATL, ItemID.ECLIPSE_ATLATL_29851),
	ECLIPSE_MOON_CHESTPLATE(ItemID.ECLIPSE_MOON_CHESTPLATE, ItemID.ECLIPSE_MOON_CHESTPLATE_29840),
	ECLIPSE_MOON_HELM(ItemID.ECLIPSE_MOON_HELM, ItemID.ECLIPSE_MOON_HELM_29842),
	ECLIPSE_MOON_TASSETS(ItemID.ECLIPSE_MOON_TASSETS, ItemID.ECLIPSE_MOON_TASSETS_29841),
	ABYSSAL_DAGGER(ItemID.ABYSSAL_DAGGER, ItemID.ABYSSAL_DAGGER_P, ItemID.ABYSSAL_DAGGER_P_13269, ItemID.ABYSSAL_DAGGER_P_13271, 27861, ItemID.ABYSSAL_DAGGER_BHP, ItemID.ABYSSAL_DAGGER_BHP_27865, ItemID.ABYSSAL_DAGGER_BHP_27867),
	;

	private static final Map<Integer, EquipmentData> itemData = new HashMap<>();

	@Getter
	private final int itemId; // main id to be used for stat lookups
	@Getter
	private final int[] additionalIds; // extra ids that might represent the same item (like LMS versions, or a dragon dagger(p) = dds, or charged items etc)

	EquipmentData(int itemId)
	{
		this.itemId = itemId;
		this.additionalIds = null;
	}

	EquipmentData(int itemId, int... itemIds)
	{
		this.itemId = itemId;
		this.additionalIds = itemIds;
	}

	// Get the saved EquipmentData for a given itemId (could be null)
	public static EquipmentData fromId(int itemId)
	{
		return itemData.get(itemId);
	}

	// get currently selected weapon ammo, based on weapon used & configured bolt choice.
	public static RangeAmmoData getWeaponAmmo(EquipmentData weapon)
	{
		if (ArrayUtils.contains(RangeAmmoData.BoltAmmo.WEAPONS_USING, weapon))
		{
			return PvpPerformanceTrackerPlugin.CONFIG.boltChoice();
		}
		else if (ArrayUtils.contains(RangeAmmoData.StrongBoltAmmo.WEAPONS_USING, weapon))
		{
			return PvpPerformanceTrackerPlugin.CONFIG.strongBoltChoice();
		}
		else if (ArrayUtils.contains(RangeAmmoData.DartAmmo.WEAPONS_USING, weapon))
		{
			return PvpPerformanceTrackerPlugin.CONFIG.bpDartChoice();
		}
		else if (weapon == HEAVY_BALLISTA || weapon == LIGHT_BALLISTA)
		{
			return RangeAmmoData.OtherAmmo.DRAGON_JAVELIN;
		}
		else if (weapon == DARK_BOW)
		{
			return RangeAmmoData.OtherAmmo.DRAGON_ARROW;
		}
		else if (weapon == KARILS_CROSSBOW)
		{
			return RangeAmmoData.OtherAmmo.BOLT_RACK;
		}
		else if (weapon == HUNTERS_SUNLIGHT_CROSSBOW)
		{
			return RangeAmmoData.OtherAmmo.MOONLIGHT_ANTLER_BOLTS;
		}
		else if (weapon == MAGIC_SHORTBOW || weapon == MAGIC_SHORTBOW_I)
		{
			return RangeAmmoData.OtherAmmo.AMETHYST_ARROWS;
		}

		return null;
	}

	static
	{
		for (EquipmentData data : EquipmentData.values())
		{
			itemData.putIfAbsent(data.getItemId(), data);
			if (data.additionalIds != null && data.additionalIds.length > 0)
			{
				for (int id : data.additionalIds)
				{
					itemData.putIfAbsent(id, data);
				}
			}
		}
	}

	public enum VoidStyle
	{
		VOID_MELEE(1.1, 1.1),
		VOID_RANGE(1.1, 1.1),
		VOID_MAGE(1.45, 1),
		VOID_ELITE_MELEE(1.1, 1.1),
		VOID_ELITE_RANGE(1.125, 1.125),
		VOID_ELITE_MAGE(1.45, 1.025),
		NONE(1, 1);

		public double accuracyModifier;
		public double dmgModifier;

		VoidStyle(double accuracyModifier, double dmgModifier)
		{
			this.accuracyModifier = accuracyModifier;
			this.dmgModifier = dmgModifier;
		}

		// return a void style for a given PlayerComposition
		public static VoidStyle getVoidStyleFor(int[] playerComposition)
		{
			if (playerComposition == null) { return NONE; }
			playerComposition = PvpPerformanceTrackerUtils.fixItemIds(playerComposition);

			EquipmentData gloves = EquipmentData.fromId(playerComposition[KitType.HANDS.getIndex()]);

			if (gloves != EquipmentData.VOID_GLOVES) { return NONE; }

			EquipmentData helm = EquipmentData.fromId(playerComposition[KitType.HEAD.getIndex()]);
			EquipmentData torso = EquipmentData.fromId(playerComposition[KitType.TORSO.getIndex()]);
			EquipmentData legs = EquipmentData.fromId(playerComposition[KitType.LEGS.getIndex()]);

			if (torso == EquipmentData.VOID_BODY && legs == EquipmentData.VOID_LEGS)
			{
				return helm == EquipmentData.VOID_MAGE_HELM ? VOID_MAGE
					: helm == EquipmentData.VOID_RANGE_HELM ? VOID_RANGE
					: helm == EquipmentData.VOID_MELEE_HELM ? VOID_MELEE
					: NONE;
			}
			else if (torso == EquipmentData.VOID_ELITE_BODY && legs == EquipmentData.VOID_ELITE_LEGS)
			{
				return helm == EquipmentData.VOID_MAGE_HELM ? VOID_ELITE_MAGE
					: helm == EquipmentData.VOID_RANGE_HELM ? VOID_ELITE_RANGE
					: helm == EquipmentData.VOID_MELEE_HELM ? VOID_ELITE_MELEE
					: NONE;
			}

			return NONE;
		}
	}
}

/*
 * Copyright (c)  2020, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.util.HashMap;
import javax.inject.Inject;

import matsyir.pvpperformancetracker.controllers.FightPerformance;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;

import matsyir.pvpperformancetracker.models.TrackedStatistic;
import matsyir.pvpperformancetracker.views.PanelFactory;
import matsyir.pvpperformancetracker.views.TableComponent;
import net.runelite.client.ui.overlay.Overlay;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class PvpPerformanceTrackerOverlay extends Overlay
{
	private static final String NO_DATA = "-";
	private static final NumberFormat nfP1 = NumberFormat.getPercentInstance(); // For KO Chance %
	static
	{
		nfP1.setMaximumFractionDigits(1);
		nfP1.setRoundingMode(RoundingMode.HALF_UP);
	}

	private final PanelComponent panelComponent = new PanelComponent();
	private final PvpPerformanceTrackerPlugin plugin;
	private final PvpPerformanceTrackerConfig config;

	private final TitleComponent overlayTitle;

	// The main overlay is like the panel, each line is optionally turned off.
	private final LineComponent ovlPlayerNamesLine; // Left: player's RSN, Right: Opponent RSN
	private final HashMap<TrackedStatistic, TableComponent> statisticLines = new HashMap<>();

	// weird overlay-only statistic that isn't on the panel nor considered its own "TrackedStatistic"
	private final TableComponent ovlLastKoChanceLine; // Combined last KO chance

	@Inject
	private PvpPerformanceTrackerOverlay(PvpPerformanceTrackerPlugin plugin, PvpPerformanceTrackerConfig config)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.BOTTOM_RIGHT);
		setPriority(OverlayPriority.LOW);
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "PvP Performance Tracker"));
		panelComponent.setPreferredSize(new Dimension(ComponentConstants.STANDARD_WIDTH, 0));

		overlayTitle = TitleComponent.builder().text("PvP Performance").build();

		ovlPlayerNamesLine = LineComponent.builder().build();

		for (TrackedStatistic stat : TrackedStatistic.values())
		{
			statisticLines.put(stat, stat.getOverlayComponent());
		}

		// weird overlay-only statistic that isn't on the panel
		ovlLastKoChanceLine = PanelFactory.createOverlayStatsLine("pKO", 50, 50, NO_DATA, Color.WHITE, NO_DATA, Color.WHITE);

		setLines();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Rebuild overlay lines in case config toggles have changed
		setLines();
		FightPerformance fight = plugin.getCurrentFight();
		if (!config.showFightOverlay() || fight == null || !fight.fightStarted() ||
			(config.restrictToLms() && !plugin.isAtLMS()))
		{
			return null;
		}

		statisticLines.forEach((stat, component) -> {
			stat.updateOverlayComponent(fight, component);
		});

		// Format Last KO Chance Line
		if (fight.getCompetitorLastKoChance() != null)
		{
			ovlLastKoChanceLine.updateLeftCellText(nfP1.format(fight.getCompetitorLastKoChance()));
		}
		else
		{
			ovlLastKoChanceLine.updateLeftCellText(NO_DATA);
		}
		if (fight.getOpponentLastKoChance() != null)
		{
			ovlLastKoChanceLine.updateRightCellText(nfP1.format(fight.getOpponentLastKoChance()));
		}
		else
		{
			ovlLastKoChanceLine.updateRightCellText(NO_DATA);
		}

		return panelComponent.render(graphics);
	}

	void setLines()
	{
		panelComponent.getChildren().clear();

		// Only display the title if it's enabled (pointless in my opinion, since you can just see
		// what the panel is displaying, but I can see it being useful if you have lots of overlays)
		if (config.showOverlayTitle())
		{
			panelComponent.getChildren().add(overlayTitle);
		}

		if (config.showOverlayNames())
		{
			panelComponent.getChildren().add(ovlPlayerNamesLine);
		}
		if (config.showOverlayOffPray())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.OFF_PRAY));
		}
		if (config.showOverlayExpectedDmg())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.EXPECTED_DMG));
		}
		if (config.showOverlayDmgDealt())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.DMG_DEALT));
		}
		if (config.showOverlayMagicHits())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.MAGIC_HITS));
		}
		if (config.showOverlayOffensivePray())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.OFFENSIVE_PRAY));
		}
		if (config.showOverlayHpHealed())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.HP_HEALED));
		}
		if (config.showOverlayRobeHits())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.ROBE_HITS));
		}
		// Add new KO chance lines based on config
		if (config.showOverlayTotalKoChance())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.KO_CHANCES));
		}
		if (config.showOverlayLastKoChance())
		{
			panelComponent.getChildren().add(ovlLastKoChanceLine);
		}
		if (config.showOverlayGhostBarrage())
		{
			panelComponent.getChildren().add(statisticLines.get(TrackedStatistic.GHOST_BARRAGES));
		}
	}

	void setFight(FightPerformance fight)
	{
		String cName = fight.getCompetitor().getName();
		ovlPlayerNamesLine.setLeft(cName.substring(0, Math.min(6, cName.length())));
		String oName = fight.getOpponent().getName();
		ovlPlayerNamesLine.setRight(oName.substring(0, Math.min(6, oName.length())));
	}
}

/*
 * Copyright (c)  2020, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import javax.inject.Inject;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.views.FightPerformancePanel;
import matsyir.pvpperformancetracker.views.TotalStatsPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

class PvpPerformanceTrackerPanel extends PluginPanel
{
	// The main fight history container, this will hold all the individual FightPerformancePanels.
	private final JPanel fightHistoryContainer = new JPanel();
	private final TotalStatsPanel totalStatsPanel = new TotalStatsPanel();

	private final PvpPerformanceTrackerPlugin plugin;
	private final PvpPerformanceTrackerConfig config;

	@Inject
	private PvpPerformanceTrackerPanel(final PvpPerformanceTrackerPlugin plugin, final PvpPerformanceTrackerConfig config)
	{
		super(false);
		this.plugin = plugin;
		this.config = config;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setBorder(new EmptyBorder(8, 8, 8, 8));
		JPanel mainContent = new JPanel(new BorderLayout());

		fightHistoryContainer.setLayout(new BoxLayout(fightHistoryContainer, BoxLayout.Y_AXIS));

		add(totalStatsPanel);

		// add filter line with label & text field.
		JPanel filterLine = new JPanel(new BorderLayout());
		// filter label
		JLabel filterLabel = new JLabel("Filter Usernames:");
		filterLabel.setHorizontalAlignment(SwingConstants.CENTER);
		// filter textfield
		JTextField nameFilter = new JTextField(config.nameFilter());
		filterLine.setMaximumSize(new Dimension(PANEL_WIDTH, (int)filterLine.getPreferredSize().getHeight()));

		nameFilter.getDocument().addDocumentListener(new DocumentListener() {
			private void updateNameFilterValue()
			{
				plugin.updateNameFilterConfig(nameFilter.getText());

				// do not rebuild the panel if the filter starts with a space. This is because you could spam rebuild()
				// by holding down space and causing massive lag. This isn't really an issue with real filters as the
				// results quickly get filtered down, resulting in less UI elements.
				if (!nameFilter.getText().startsWith(" "))
				{
					PvpPerformanceTrackerPanel.this.rebuild();
				}
			}

			public void changedUpdate(DocumentEvent e) { updateNameFilterValue(); }
			public void removeUpdate(DocumentEvent e) { updateNameFilterValue(); }
			public void insertUpdate(DocumentEvent e) { updateNameFilterValue(); }
		});

		filterLine.add(filterLabel, BorderLayout.NORTH);
		filterLine.add(nameFilter, BorderLayout.CENTER);

		add(Box.createRigidArea(new Dimension(0, 4)));
		add(filterLine);

		// wrap mainContent with scrollpane so it has a scrollbar
		JScrollPane scrollableContainer = new JScrollPane(mainContent);
		scrollableContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollableContainer.getVerticalScrollBar().setPreferredSize(new Dimension(6, 0));

		mainContent.add(fightHistoryContainer, BorderLayout.NORTH);

		add(Box.createRigidArea(new Dimension(0, 4)));
		add(scrollableContainer);
	}

	public void addFight(FightPerformance fight)
	{
		// if the nameFilter isn't blank, skip adding the fight to panels if it doesn't respect the name filter
		if (!config.nameFilter().equals("")
			&& (config.exactNameFilter() ?
				!fight.getCompetitor().getName().toLowerCase().equals(config.nameFilter())
				&& !fight.getOpponent().getName().toLowerCase().equals(config.nameFilter())
				: !fight.getCompetitor().getName().toLowerCase().startsWith(config.nameFilter())
				&& !fight.getOpponent().getName().toLowerCase().startsWith(config.nameFilter())))
		{
			return;
		}

		totalStatsPanel.addFight(fight);

		SwingUtilities.invokeLater(() ->
		{
			fightHistoryContainer.add(new FightPerformancePanel(fight), 0);

			// if we now have more fights than we want to render, then remove fights from the container in order to only render our max.
			if (fightHistoryContainer.getComponentCount() > config.fightHistoryRenderLimit())
			{
				// this will probably only remove 1 fight in most cases, but just in case we need to remove more than that.
				int numFightsToRemove = fightHistoryContainer.getComponentCount() - config.fightHistoryRenderLimit();
				for (int i = 0; i < numFightsToRemove && fightHistoryContainer.getComponentCount() > 0; i++)
				{
					// remove from the last components since we add to 0
					fightHistoryContainer.remove(fightHistoryContainer.getComponentCount() - 1);
				}
			}

			updateUI();
		});
	}

	public void addFights(ArrayList<FightPerformance> fights)
	{
		// if the nameFilter isn't blank, skip adding any fights to panels if they don't respect the name filter
		if (!config.nameFilter().equals(""))
		{
			fights.removeIf((FightPerformance f) ->
				// remove if the names aren't EQUAL when using "exactNameFilter",
				// if not then remove names that don't start with the name filter.
				config.exactNameFilter() ?
					!f.getCompetitor().getName().toLowerCase().equals(config.nameFilter())
						&& !f.getOpponent().getName().toLowerCase().equals(config.nameFilter())
					: !f.getCompetitor().getName().toLowerCase().startsWith(config.nameFilter())
					&& !f.getOpponent().getName().toLowerCase().startsWith(config.nameFilter()));
		}

		totalStatsPanel.addFights(fights);
		SwingUtilities.invokeLater(() ->
		{
			// if we're adding more fights than we want to render at all, then reduce the number of fights and clear all the existing ones
			if (fights.size() > config.fightHistoryRenderLimit())
			{
				int numFightsToRemove = fights.size() - config.fightHistoryRenderLimit();
				fights.removeIf((FightPerformance f) -> fights.indexOf(f) < numFightsToRemove);
				fightHistoryContainer.removeAll();
			}
			// if we're adding a normal number of fights, then check if we actually need to remove existing fights to make room for it.
			else
			{
				int fightsToAdd = fights.size();
				int fightsToRemove = fightHistoryContainer.getComponentCount() - config.fightHistoryRenderLimit() + fightsToAdd;

				if (fightsToRemove > 0)
				{
					// Remove oldest fightHistory until the size is equal to the limit.
					for (int i = 0; i < fightsToRemove && fightHistoryContainer.getComponentCount() > 0; i++)
					{
						// remove from the last components since we add to 0
						fightHistoryContainer.remove(fightHistoryContainer.getComponentCount() - 1);
					}
				}

			}

			fights.forEach((FightPerformance f) -> fightHistoryContainer.add(new FightPerformancePanel(f), 0));
			updateUI();
		});
	}

	public void rebuild()
	{
		totalStatsPanel.reset();
		fightHistoryContainer.removeAll();
		if (plugin.fightHistory.size() > 0)
		{
			// create new arraylist from the main one so we can't modify the fight history
			ArrayList<FightPerformance> fightsToAdd = new ArrayList<>(plugin.fightHistory);

			addFights(fightsToAdd);
		}
		SwingUtilities.invokeLater(this::updateUI);
	}

	public void setConfigWarning(boolean enable)
	{
		totalStatsPanel.setConfigWarning(enable);
	}
}
/*
 * Copyright (c) 2021, Mazhar <https://twitter.com/maz_rs>
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.time.Duration;
import java.util.ArrayList;
import java.util.stream.Collectors;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableCellRenderer;
import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.controllers.AnalyzedFightPerformance;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;

import matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils;
import net.runelite.api.SpriteID;

@Slf4j
public class FightLogFrame extends JFrame
{
	private static JFrame fightLogFrame; // save frame as static instance so there's only one at a time, to avoid window clutter.

	private static final NumberFormat nf = NumberFormat.getInstance();
	private static final NumberFormat nfPercent = NumberFormat.getPercentInstance(); // For KO Chance %

	static
	{
		// initialize number format
		nf.setMaximumFractionDigits(2);
		nf.setRoundingMode(RoundingMode.HALF_UP);

		// initialize percent format
		nfPercent.setMaximumFractionDigits(1);
		nfPercent.setRoundingMode(RoundingMode.HALF_UP);
	}

	private FightLogDetailFrame fightLogDetailFrame;
	private JTable table;
	private ListSelectionListener onRowSelected;
	private ArrayList<FightLogEntry> fightLogEntries;

	public static JFrame createFightLogFrame(FightPerformance fight, AnalyzedFightPerformance analyzedFight, JRootPane rootPane)
	{
		// destroy current frame if it exists so we only have one at a time (static field)
		if (fightLogFrame != null)
		{
			fightLogFrame.dispose();
		}

		// show error modal if the fight has no log entries to display.
		ArrayList<FightLogEntry> fightLogEntries = new ArrayList<>(fight.getAllFightLogEntries());
		fightLogEntries.removeIf(e -> !e.isFullEntry());
		if (fightLogEntries.isEmpty())
		{
			PLUGIN.createConfirmationModal(false, "This fight has no attack logs to display, or the data is outdated.");
		}
		else if (analyzedFight != null) // if analyzed fight is set, then show an analyzed fight's fightLogFrame.
		{
			fightLogFrame = new FightLogFrame(analyzedFight, rootPane);

		}
		else
		{
			fightLogFrame = new FightLogFrame(fight,
				fightLogEntries,
				rootPane);
		}

		return fightLogFrame;
	}

	// expects logEntries composing of only "full" log entries, that contain full attack data, not defender entries.
	private FightLogFrame(FightPerformance fight, ArrayList<FightLogEntry> logEntries, JRootPane rootPane)
	{
		//String title = fight.getCompetitor().getName() + " vs " + fight.getOpponent().getName();
		super("Fight Log - " + fight.getCompetitor().getName() + " vs " + fight.getOpponent().getName()
			+ " on world " + fight.getWorld());

		fightLogEntries = logEntries;
		fightLogEntries.removeIf(e -> !e.isFullEntry());

		// if always on top is supported, and the core RL plugin has "always on top" set, make the frame always
		// on top as well so it can be above the client.
		if (isAlwaysOnTopSupported())
		{
			setAlwaysOnTop(PLUGIN.getRuneliteConfig().gameAlwaysOnTop());
		}

		setIconImage(PLUGIN_ICON);
		setSize(860, 503); // Reverted width increase, removed debug columns
		setLocation(rootPane.getLocationOnScreen());

		JPanel mainPanel = new JPanel(new BorderLayout(4, 4));
		Object[][] stats = new Object[fightLogEntries.size()][14]; // Updated column count to include Actual Dmg
		int i = 0;
		int initialTick = 0;

		for (FightLogEntry fightEntry : fightLogEntries)
		{
			if (i == 0)
			{
				initialTick = fightEntry.getTick();
			}

			int styleIcon = fightEntry.getAnimationData().attackStyle.getStyleSpriteId();
			JLabel styleIconLabel = new JLabel();
			PLUGIN.addSpriteToLabelIfValid(styleIconLabel, styleIcon, this::repaint);
			styleIconLabel.setToolTipText(fightEntry.getAnimationData().attackStyle.toString());

			stats[i][0] = fightEntry.getAttackerName();
			stats[i][1] = styleIconLabel;
			stats[i][2] = fightEntry.getHitRange();
			stats[i][3] = nf.format(fightEntry.getAccuracy() * 100) + '%';
			stats[i][4] = nf.format(fightEntry.getExpectedDamage());
			// Actual Dmg column (Index 5)
			JLabel dmgLabel = new JLabel();
			if (fightEntry.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC && fightEntry.isSplash())
			{
				int splashIcon = SpriteID.SPELL_ICE_BARRAGE_DISABLED;
				PLUGIN.addSpriteToLabelIfValid(dmgLabel, splashIcon, this::repaint);
			}
			else
			{
				Integer actualDmg = fightEntry.getActualDamageSum();
				String dmgText = actualDmg != null ? nf.format(actualDmg) : "-";
				dmgLabel.setText(dmgText);
			}
			stats[i][5] = dmgLabel;
			// HP column (Index 6) - Display as Current/Max
			Integer hp = fightEntry.getDisplayHpBefore();
			Integer maxHp = fightEntry.getOpponentMaxHp();
			stats[i][6] = (hp != null && maxHp != null) ? hp + "/" + maxHp : (hp != null ? String.valueOf(hp) : "-");
			// KO Chance column (Index 7)
			Double koChance = fightEntry.getKoChance();
			stats[i][7] = koChance != null ? nfPercent.format(koChance) : "-";
			// Special? (Index 8)
			stats[i][8] = fightEntry.getAnimationData().isSpecial ? "" : "";
			// Off-Pray? (Index 9)
			stats[i][9] = fightEntry.success() ? "" : "";
			// Def Prayer (Index 10)
			int prayIcon = PvpPerformanceTrackerUtils.getSpriteForHeadIcon(fightEntry.getDefenderOverhead());
			if (prayIcon > 0)
			{
				JLabel defPrayLabel = new JLabel();
				PLUGIN.addSpriteToLabelIfValid(defPrayLabel, prayIcon, this::repaint);
				stats[i][10] = defPrayLabel;
			}
			else
			{
				stats[i][10] = "";
			}
			// Splash (Index 11)
			if (fightEntry.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC)
			{
				int splashIcon = fightEntry.isSplash() ? SpriteID.SPELL_ICE_BARRAGE_DISABLED : SpriteID.SPELL_ICE_BARRAGE;
				JLabel splashLabel = new JLabel();
				PLUGIN.addSpriteToLabelIfValid(splashLabel, splashIcon, this::repaint);
				stats[i][11] = splashLabel;
			}
			else
			{
				stats[i][11] = "";
			}
			// Offensive Pray (Index 12)
			JLabel attPrayLabel = new JLabel();
			if (fightEntry.getAttackerOffensivePray() > 0)
			{
				PLUGIN.addSpriteToLabelIfValid(attPrayLabel, fightEntry.getAttackerOffensivePray(), this::repaint);
				stats[i][12] = attPrayLabel;
			}
			else
			{
				stats[i][12] = "";
			}
			int tickDuration = fightEntry.getTick() - initialTick;
			int durationMillis = (tickDuration * 600); // (* 0.6) to get duration in secs from ticks, so *600 for ms
			Duration duration = Duration.ofMillis(durationMillis);
			String time = String.format("%02d:%02d.%01d",
				duration.toMinutes(),
				duration.getSeconds() % 60,
				durationMillis % 1000 / 100) + " (" + tickDuration + ")";
			stats[i][13] = time;

			i++;
		}

		String[] header = {"Attacker", "Style", "Hit Range", "Accuracy", "Avg Hit", "Actual Dmg", "HP", "KO Chance", "Special?",
			"Off-Pray?", "Def Prayer", "Splash", "Offensive Pray", "Time, (Tick)"};
		table = new JTable(stats, header);
		table.setRowHeight(30);
		table.setDefaultEditor(Object.class, null);

		table.getColumnModel().getColumn(1).setCellRenderer(new BufferedImageCellRenderer()); // Style
		table.getColumnModel().getColumn(5).setCellRenderer(new BufferedImageCellRenderer()); // Actual Dmg
		table.getColumnModel().getColumn(10).setCellRenderer(new BufferedImageCellRenderer()); // Def Prayer
		table.getColumnModel().getColumn(11).setCellRenderer(new BufferedImageCellRenderer()); // Splash
		table.getColumnModel().getColumn(12).setCellRenderer(new BufferedImageCellRenderer()); // Offensive Pray

		onRowSelected = e ->
		{
			int row = table.getSelectedRow();

			if (fightLogDetailFrame != null)
			{
				if (fightLogDetailFrame.rowIdx == row)
				{
					return;
				}

				fightLogDetailFrame.dispose();
				fightLogDetailFrame = null;
			}

			fightLogDetailFrame = new FightLogDetailFrame(fight, fightLogEntries.get(row), row,
				new Point( // place the new detail frame roughly to the right of the fight log window.
					this.getLocation().x + this.getSize().width,
					this.getLocation().y)
			);
		};

		table.getSelectionModel().addListSelectionListener(onRowSelected);

		mainPanel.add(new JScrollPane(table), BorderLayout.CENTER);

		add(mainPanel);
		setVisible(true);
	}

	private static class BufferedImageCellRenderer extends DefaultTableCellRenderer
	{
		@Override
		public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)
		{
			super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
			if (value instanceof BufferedImage)
			{
				setText("");
				setIcon(new ImageIcon((BufferedImage) value));
			}
			else if (value instanceof JLabel)
			{
				JLabel val = (JLabel) value;
				setIcon(val.getIcon());
				setText(val.getText());
				setToolTipText(val.getToolTipText());
			}
			else
			{
				setText("");
				setIcon(null);
			}

			return this;
		}
	}

	// initialize frame using an AnalyzedFight, in order to pass the analyzed fight data
	// to the detailed frame.
	private FightLogFrame(AnalyzedFightPerformance fight, JRootPane rootPane)
	{
		this(fight,
			new ArrayList(fight.getAllFightLogEntries().stream()
				.filter(FightLogEntry::isFullEntry) // send only attacker logs, and don't use the matching logs since
				.collect(Collectors.toList())),    // those have old 'dps' values, they're only used for defender lvls/pray/etc client data
			rootPane);

		// test
		if (new ArrayList(fight.getAllFightLogEntries().stream()
			.filter(FightLogEntry::isFullEntry) // send only attacker logs
			.collect(Collectors.toList())).size() != fight.getAnalyzedMatchingLogs().size())
		{
			log.info("FIGHT ANALYSIS: ERROR! allFightLogEntries.filter::isFullEntry different size than analyzedMatchingLogs - should not happen");
		}

		table.getSelectionModel().removeListSelectionListener(onRowSelected);
		onRowSelected = e -> {
			int row = table.getSelectedRow();

			if (fightLogDetailFrame != null)
			{
				if (fightLogDetailFrame.rowIdx == row)
				{
					return;
				}

				fightLogDetailFrame.dispose();
				fightLogDetailFrame = null;
			}

			fightLogDetailFrame = new FightLogDetailFrame(fight, fightLogEntries.get(row), fight.getAnalyzedMatchingLogs().get(row)[1], row,
				new Point( // place the new detail frame roughly to the right of the fight log window.
					this.getLocationOnScreen().x + (this.getSize().width),
					this.getLocationOnScreen().y)
			);
		};

		table.getSelectionModel().addListSelectionListener(onRowSelected);
	}
}

package matsyir.pvpperformancetracker.views;

import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import net.runelite.api.kit.KitType;

import java.awt.BorderLayout;
import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.stream.Collectors;
import javax.swing.BoxLayout;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRootPane;

import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;

@Slf4j
public class AttackSummaryFrame extends JFrame
{
	private static JFrame attackSummaryFrame; // save frame as static instance so there's only one at a time, to avoid window clutter.

	private final class GroupedWepAnim
	{
		private final AnimationData anim;
		private final int wepId;

		private GroupedWepAnim(AnimationData anim, int wepId)
		{
			this.anim = anim;
			this.wepId = wepId;
		}

		@Override
		public boolean equals(Object o)
		{
			if (this == o)
			{
				return true;
			}
			if (o == null || getClass() != o.getClass())
			{
				return false;
			}
			GroupedWepAnim that = (GroupedWepAnim) o;
			return Objects.equals(anim, that.anim) &&
				Objects.equals(wepId, that.wepId);
		}

		@Override
		public int hashCode()
		{
			return Objects.hash(anim, wepId);
		}
	}

	//BorderLayout container;
	Map<GroupedWepAnim, Integer> countsOfAttacksCompetitor = new HashMap<>();
	int competitorMeleeCount = 0;
	int competitorRangeCount = 0;
	int competitorMageCount = 0;
	Map<GroupedWepAnim, Integer> countsOfAttacksOpponent = new HashMap<>();
	int opponentMeleeCount = 0;
	int opponentRangeCount = 0;
	int opponentMageCount = 0;

	public static JFrame createAttackSummaryFrame(FightPerformance fight, JRootPane rootPane)
	{
		// destroy current frame if it exists so we only have one at a time (static field)
		if (attackSummaryFrame != null)
		{
			attackSummaryFrame.dispose();
		}
		// show error modal if the fight has no log entries to display.
		ArrayList<FightLogEntry> fightLogEntries = new ArrayList<>(fight.getAllFightLogEntries());
		fightLogEntries.removeIf(e -> !e.isFullEntry());
		if (fightLogEntries.isEmpty())
		{
			PLUGIN.createConfirmationModal(false, "This fight has no attack summary to display, or the data is outdated.");
			return attackSummaryFrame;
		}

		attackSummaryFrame = new AttackSummaryFrame(fight, fightLogEntries, rootPane);

		return attackSummaryFrame;
	}

	private AttackSummaryFrame(FightPerformance fight, ArrayList<FightLogEntry> fightLogEntries, JRootPane rootPane)
	{
		super("Attack Summary - " + fight.getCompetitor().getName() + " vs " + fight.getOpponent().getName()
			+ " on world " + fight.getWorld());

		// if always on top is supported, and the core RL plugin has "always on top" set, make the frame always
		// on top as well so it can be above the client.
		if (isAlwaysOnTopSupported())
		{
			setAlwaysOnTop(PLUGIN.getRuneliteConfig().gameAlwaysOnTop());
		}

		setIconImage(PLUGIN_ICON);
		setSize(503, 503);
		setLocation(rootPane.getLocationOnScreen());

		// first, populate countsOfAttacks that will be displayed
		for (FightLogEntry entry : fightLogEntries)
		{
			GroupedWepAnim thisAttack = new GroupedWepAnim(entry.getAnimationData(), entry.getAttackerGear()[KitType.WEAPON.getIndex()]);
			boolean isCompetitor = entry.attackerName.equals(fight.getCompetitor().getName());
			if (isCompetitor)
			{
				if (!countsOfAttacksCompetitor.containsKey(thisAttack))
				{
					countsOfAttacksCompetitor.put(thisAttack, 1);
				}
				else
				{
					countsOfAttacksCompetitor.put(thisAttack, countsOfAttacksCompetitor.get(thisAttack) + 1);
				}

				if (entry.getAnimationData() != null)
				{
					competitorMeleeCount += entry.getAnimationData().attackStyle.isMelee() ? 1 : 0;
					competitorRangeCount += entry.getAnimationData().attackStyle == AnimationData.AttackStyle.RANGED ? 1 : 0;
					competitorMageCount += entry.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC ? 1 : 0;
				}
			}
			else
			{
				if (!countsOfAttacksOpponent.containsKey(thisAttack))
				{
					countsOfAttacksOpponent.put(thisAttack, 1);
				}
				else
				{
					countsOfAttacksOpponent.put(thisAttack, countsOfAttacksOpponent.get(thisAttack) + 1);
				}

				if (entry.getAnimationData() != null)
				{
					opponentMeleeCount += entry.getAnimationData().attackStyle.isMelee() ? 1 : 0;
					opponentRangeCount += entry.getAnimationData().attackStyle == AnimationData.AttackStyle.RANGED ? 1 : 0;
					opponentMageCount += entry.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC ? 1 : 0;
				}
			}
		}

		// sort attacks by count
		countsOfAttacksCompetitor = countsOfAttacksCompetitor.entrySet().stream()
			.sorted(Entry.<GroupedWepAnim, Integer>comparingByValue().reversed())
			.collect(Collectors.toMap(Entry::getKey, Entry::getValue,
				(e1, e2) -> e1, LinkedHashMap::new));
		countsOfAttacksOpponent = countsOfAttacksOpponent.entrySet().stream()
			.sorted(Entry.<GroupedWepAnim, Integer>comparingByValue().reversed())
			.collect(Collectors.toMap(Entry::getKey, Entry::getValue,
				(e1, e2) -> e1, LinkedHashMap::new));


		JLabel competitorNameAndInfo = new JLabel();
		competitorNameAndInfo.setText("<html><strong>" + fight.getCompetitor().getName() + "</strong><br>" +
			competitorMeleeCount + " Melee Attack(s)<br>" +
			competitorRangeCount + " Ranged Attack(s)<br>" +
			competitorMageCount + " Magic Attack(s)");
		competitorNameAndInfo.setForeground(Color.WHITE);

		JLabel opponentNameAndInfo = new JLabel();
		opponentNameAndInfo.setText("<html><strong>" + fight.getOpponent().getName() + "</strong><br>" +
			opponentMeleeCount + " Melee Attack(s)<br>" +
			opponentRangeCount + " Ranged Attack(s)<br>" +
			opponentMageCount + " Magic Attack(s)");
		opponentNameAndInfo.setForeground(Color.WHITE);

		JPanel leftContainer = new JPanel();
		leftContainer.setLayout(new BoxLayout(leftContainer, BoxLayout.Y_AXIS));
		leftContainer.add(competitorNameAndInfo);

		JPanel rightContainer = new JPanel();
		rightContainer.setLayout(new BoxLayout(rightContainer, BoxLayout.Y_AXIS));
		rightContainer.add(opponentNameAndInfo);

		countsOfAttacksCompetitor.forEach((key, val) ->
		{
			JLabel attackLine = new JLabel(val + "x: " + key.anim.toString());
			PLUGIN.addItemToLabelIfValid(attackLine, key.wepId);

			leftContainer.add(attackLine);
		});
		countsOfAttacksOpponent.forEach((key, val) ->
		{
			JLabel attackLine = new JLabel(val + "x: " + key.anim.toString());
			PLUGIN.addItemToLabelIfValid(attackLine, key.wepId);

			rightContainer.add(attackLine);
		});

		setLayout(new BorderLayout());
		this.add(leftContainer, BorderLayout.WEST);
		this.add(rightContainer, BorderLayout.EAST);

		setVisible(true);
	}
}

package matsyir.pvpperformancetracker.views;

import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import java.awt.*;
import java.awt.event.MouseEvent;

public final class PanelFactory
{
	// constants/final values
	public static final float LINE_INDEX_LABEL_FONT_SCALE = 0.65f;
	public static final Color STATS_LINE_INDEX_COLOR = new Color(1f, 1f, 1f, 0.4f);
	public static final Color OVERLAY_STATS_LINE_INDEX_COLOR = new Color(1f, 1f, 1f, 0.2f);

	public static final Font INDEX_FONT = new Font("Monospace", Font.PLAIN, 12);

	public static Font getIndexFontFrom(float initialFontSize)
	{
		return INDEX_FONT.deriveFont(initialFontSize * LINE_INDEX_LABEL_FONT_SCALE);
	}

	public static Font getIndexFontFrom(Font initialFont)
	{
		return getIndexFontFrom(initialFont.getSize());
	}

	public static JPanel createStatsLine(String miniCenterLabelText, String miniCenterLabelTooltip,
										 String leftText, String leftTooltip, Color leftColor,
										 String rightText, String rightTooltip, Color rightColor)
	{
		JPanel statsLine = new JPanel(new GridBagLayout());
		statsLine.setBackground(null);

		String tooltipSuffix = "<br><br><b><i>" + miniCenterLabelText + "</i></b>: " + miniCenterLabelTooltip;

		ForwardingLabel leftLabel = new ForwardingLabel(leftText);
		leftLabel.setToolTipText("<html>" + leftTooltip + tooltipSuffix);
		leftLabel.setForeground(leftColor);
		leftLabel.setHorizontalAlignment(SwingConstants.LEFT);

		ForwardingLabel rightLabel = new ForwardingLabel(rightText);
		rightLabel.setToolTipText("<html>" + rightTooltip + tooltipSuffix);
		rightLabel.setForeground(rightColor);
		rightLabel.setHorizontalAlignment(SwingConstants.RIGHT);

		JLabel indexLabel = new ForwardingLabel(miniCenterLabelText);
		indexLabel.setForeground(STATS_LINE_INDEX_COLOR);
		indexLabel.setFont(PanelFactory.getIndexFontFrom(indexLabel.getFont()));
		indexLabel.setHorizontalAlignment(SwingConstants.CENTER);

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.gridy = 0;
		gbc.weightx = 1;
		gbc.fill = GridBagConstraints.HORIZONTAL;

		// left
		gbc.gridx = 0;
		gbc.anchor = GridBagConstraints.WEST;
		statsLine.add(leftLabel, gbc.clone());

		// right
		gbc.gridx = 1;
		gbc.anchor = GridBagConstraints.EAST;
		statsLine.add(rightLabel, gbc.clone());

		// index/miniCenterLabel centered across full row
		GridBagConstraints gbcIndex = new GridBagConstraints();
		gbcIndex.gridx = 0;
		gbcIndex.gridy = 0;
		gbcIndex.gridwidth = 3;
		gbcIndex.anchor = GridBagConstraints.CENTER;
		gbcIndex.fill = GridBagConstraints.NONE;
		statsLine.add(indexLabel, gbcIndex);

		return statsLine;
	}

	public static TableComponent createOverlayStatsLine(String miniCenterLabelText, int pLeft, int pRight,
														String leftText, Color leftColor,
														String rightText, Color rightColor)
	{
		TableComponent overlayStatsLine = new TableComponent(TableComponent.TableRowStyle.PERCENTAGE_BASED, pLeft, pRight);
		overlayStatsLine.addRow(leftText, miniCenterLabelText, rightText);
		overlayStatsLine.setColumnColors(leftColor, OVERLAY_STATS_LINE_INDEX_COLOR, rightColor);
		overlayStatsLine.setColumnAlignments(TableComponent.TableAlignment.LEFT, TableComponent.TableAlignment.CENTER, TableComponent.TableAlignment.RIGHT);
		overlayStatsLine.setGutter(new Dimension(2, 0));

		return overlayStatsLine;
	}


	// A JLabel that still receives mouse events (so its tooltip works) but forwards them to the parent
	// using SwingUtilities.convertMouseEvent(...) so the parent sees clicks/popup/hover as if the label
	// wasn't there.
	private static class ForwardingLabel extends JLabel
	{
		public ForwardingLabel(String text)
		{
			super(text);
			setOpaque(false);
			setFocusable(false);
		}

		@Override
		protected void processMouseEvent(MouseEvent e)
		{
			// allow label's normal handling (tooltips etc)
			super.processMouseEvent(e);
			forwardToParent(e);
		}

		@Override
		protected void processMouseMotionEvent(MouseEvent e)
		{
			// allow label's normal handling (tooltips)
			super.processMouseMotionEvent(e);
			forwardToParent(e); // forward so parent can show hover effects / track mouse
		}

		private void forwardToParent(MouseEvent e)
		{
			Container parent = getParent();
			if (parent == null)
			{
				return;
			}

			// convert to parent's coordinate system and dispatch there
			MouseEvent parentEvent = SwingUtilities.convertMouseEvent(this, e, parent);
			parent.dispatchEvent(parentEvent);
		}
	}
}

/*
 * Copyright (c) 2025, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Nullable;

import lombok.Setter;
import net.runelite.client.ui.overlay.RenderableEntity;

// initially copied from TextComponent.class
// could have just extended TextComponent & only overridden renderText, but can't override renderText ._.
public class TextComponentShadowless implements RenderableEntity
{
	private static final Pattern COL_TAG_PATTERN = Pattern.compile("<col=([0-9a-fA-F]{2,6})>");
	@Setter
	private String text;
	@Setter
	private Point position = new Point();
	@Setter
	private Color color;
	@Setter
	private boolean outline;
	@Setter
	private boolean shadow;
	@Nullable
	private Font font;

	public TextComponentShadowless()
	{
		this.color = Color.WHITE;
		this.outline = false;
		this.shadow = false;
	}

	public TextComponentShadowless(boolean outline, boolean shadow)
	{
		this.color = Color.WHITE;
		this.outline = outline;
		this.shadow = shadow;
	}

	public Dimension render(Graphics2D graphics)
	{
		Font originalFont = null;
		if (this.font != null)
		{
			originalFont = graphics.getFont();
			graphics.setFont(this.font);
		}

		FontMetrics fontMetrics = graphics.getFontMetrics();
		Matcher matcher = COL_TAG_PATTERN.matcher(this.text);
		Color textColor = this.color;
		int idx = 0;

		int width;
		String color;
		for (width = 0; matcher.find(); textColor = Color.decode("#" + color))
		{
			color = matcher.group(1);
			String s = this.text.substring(idx, matcher.start());
			idx = matcher.end();
			this.renderText(graphics, textColor, this.position.x + width, this.position.y, s);
			width += fontMetrics.stringWidth(s);
		}

		color = this.text.substring(idx);
		this.renderText(graphics, textColor, this.position.x + width, this.position.y, color);
		width += fontMetrics.stringWidth(color);
		int height = fontMetrics.getHeight();
		if (originalFont != null)
		{
			graphics.setFont(originalFont);
		}

		return new Dimension(width, height);
	}

	private void renderText(Graphics2D graphics, Color color, int x, int y, String text)
	{
		if (!text.isEmpty())
		{
			graphics.setColor(Color.BLACK);
			if (this.outline)
			{
				graphics.drawString(text, x, y + 1);
				graphics.drawString(text, x, y - 1);
				graphics.drawString(text, x + 1, y);
				graphics.drawString(text, x - 1, y);
			}
			else if (this.shadow)
			{
				graphics.drawString(text, x + 1, y + 1);
			}

			graphics.setColor(color);
			graphics.drawString(text, x, y);
		}
	}

	public void setFont(@Nullable Font font)
	{
		this.font = font;
	}

	public void updatePosition(int x, int y)
	{
		position.x = x;
		position.y = y;
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.event.ItemEvent;
import java.io.File;
import java.math.RoundingMode;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.NumberFormat;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRootPane;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import lombok.extern.slf4j.Slf4j;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import matsyir.pvpperformancetracker.controllers.AnalyzedFightPerformance;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.LinkBrowser;

@Slf4j
public class FightAnalysisFrame extends JFrame
{
	public static String WIKI_HELP_URL = "https://github.com/Matsyir/pvp-performance-tracker/wiki#fight-analysisfight-merge";
	private static String WINDOW_TITLE = "PvP Performance Tracker: Fight Analysis";
	private static final NumberFormat nf = NumberFormat.getInstance();

	private JPanel mainPanel;
	private JTextField mainFightJsonInput;
	private JTextField opponentFightJsonInput;

	private FightPerformance mainFight;
	private FightPerformance opponentFight;
	private AnalyzedFightPerformance analyzedFight;

	static
	{
		// initialize number format
		nf.setMaximumFractionDigits(2);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}

	FightAnalysisFrame(FightPerformance fight, JRootPane rootPane)
	{
		this(rootPane);
		mainFightJsonInput.setText(PLUGIN.GSON.toJson(fight, FightPerformance.class));
		validate();
		repaint();
	}

	FightAnalysisFrame(JRootPane rootPane)
	{
		super("PvP Performance Tracker: Fight Analysis");
		// if always on top is supported, and the core RL plugin has "always on top" set, make the frame always
		// on top as well so it can be above the client.
		if (isAlwaysOnTopSupported())
		{
			setAlwaysOnTop(PLUGIN.getRuneliteConfig().gameAlwaysOnTop());
		}

		setIconImage(PLUGIN_ICON);
		Dimension size = new Dimension(700, 448);
		setSize(size);
		setMinimumSize(size);
		setLocation(rootPane.getLocationOnScreen());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setPreferredSize(getSize());
		mainPanel.setBorder(BorderFactory.createEmptyBorder(8, 16, 8, 16));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR); //must set all backgrounds to null after for this to work... hmm maybe
		mainPanel.setVisible(true);

		add(mainPanel);

		setVisible(true);
		initializeFrame();
	}

	// setup the initial frame contents, which should be two text inputs used to input
	// two single related fightPerformance json data.
	private void initializeFrame()
	{
		setTitle(WINDOW_TITLE);
		mainPanel.removeAll();

		// init containers
		GridLayout textAreaLayout = new GridLayout(1, 2);
		textAreaLayout.setHgap(4);
		textAreaLayout.setVgap(4);
		JPanel textLabelLine = new JPanel(textAreaLayout);
		textLabelLine.setBackground(null);
		JPanel textAreaLine = new JPanel(textAreaLayout);
		textAreaLine.setBackground(null);

		// wiki link label

		JButton wikiLinkLabel = new JButton("<html><u>Wiki/Example</u>&nbsp;&#8599;</html>");
		wikiLinkLabel.setToolTipText("Open URL to Github wiki with an example & more details");
		wikiLinkLabel.setSize(256, 32);
		wikiLinkLabel.setMaximumSize(new Dimension(256, 32));
		wikiLinkLabel.setHorizontalAlignment(SwingConstants.CENTER);
		wikiLinkLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		wikiLinkLabel.setForeground(ColorScheme.GRAND_EXCHANGE_LIMIT);
		wikiLinkLabel.addActionListener(e -> LinkBrowser.browse(WIKI_HELP_URL));

		// instruction label
		JLabel instructionLabel = new JLabel();
		instructionLabel.setText("<html>This window is used to merge two opposing fighters' fight data in order to " +
			"get more accurate stats about the fight, since some data is only available client-side. Both data " +
			"entries should come from the same fight, but from two different clients. Fighter 2 is Fighter 1's " +
			"opponent. Right click a fight in order to copy its data.<br/><br/>" +
			"When using this, the following stats are applied to expected damage & expected magic hits:<br/>" +
			"&nbsp;&nbsp;&mdash; Offensive prayers, instead of always being correct<br/>" +
			"&nbsp;&nbsp;&mdash; Boosted or drained levels (e.g from brewing down), instead of using config stats or fixed LMS stats<br/>" +
			"&nbsp;&nbsp;&mdash; The magic defence buff from Augury, instead of assuming Piety/Rigour while getting maged (if it's used)" +
			"<br><br><strong>Note: </strong>For now, ghost barrages are not integrated into this, the above improvements " +
			"do not apply for its expected damage, and its expected damage is not included in the main expected damage " +
			"stat. It merely displays what each client had saved.</html>");
		instructionLabel.setForeground(Color.WHITE);
		instructionLabel.setSize(mainPanel.getWidth(), instructionLabel.getHeight());
		instructionLabel.setHorizontalAlignment(SwingConstants.LEFT);
		instructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// fight data input labels
		JLabel firstFightLabel = new JLabel();
		firstFightLabel.setText("<html><strong>Enter fight data for Fighter 1:</strong><br/>You can drag & drop a text file onto the text box.</html>");
		firstFightLabel.setForeground(Color.WHITE);
		textLabelLine.add(firstFightLabel);

		JLabel secondFightLabel = new JLabel();
		secondFightLabel.setText("<html><strong>Enter fight data for Fighter 2:</strong><br/>You can drag & drop a text file onto the text box.</html>");
		secondFightLabel.setForeground(Color.WHITE);
		textLabelLine.add(secondFightLabel);
		textLabelLine.setSize(mainPanel.getWidth(), 48);
		textLabelLine.setMaximumSize(new Dimension(mainPanel.getWidth(), 48));

		// fight data input fields
		mainFightJsonInput = new JTextField(32);
		mainFightJsonInput.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
		mainFightJsonInput.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

		// setup drag & drop file upload support directly into textbox
		// https://stackoverflow.com/a/9111327/7982774
		mainFightJsonInput.setDropTarget(new DropTarget()
		{
			public synchronized void drop(DropTargetDropEvent evt)
			{
				try
				{
					evt.acceptDrop(DnDConstants.ACTION_COPY);
					List<File> droppedFiles = (List<File>)
						evt.getTransferable().getTransferData(DataFlavor.javaFileListFlavor);

					for (File file : droppedFiles)
					{
						String fileData = new String(Files.readAllBytes(Paths.get(file.getAbsolutePath())));
						mainFightJsonInput.setText(fileData);
						FightAnalysisFrame.this.validate();
						break;
					}

					evt.dropComplete(true);
				}
				catch (Exception ex)
				{
					ex.printStackTrace();
				}
			}
		});

		textAreaLine.add(mainFightJsonInput);
		opponentFightJsonInput = new JTextField(32);
		opponentFightJsonInput.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
		opponentFightJsonInput.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

		// setup drag & drop file upload support directly into textbox
		opponentFightJsonInput.setDropTarget(new DropTarget()
		{
			public synchronized void drop(DropTargetDropEvent evt)
			{
				try
				{
					evt.acceptDrop(DnDConstants.ACTION_COPY);
					List<File> droppedFiles = (List<File>)
						evt.getTransferable().getTransferData(DataFlavor.javaFileListFlavor);

					for (File file : droppedFiles)
					{
						String fileData = new String(Files.readAllBytes(Paths.get(file.getAbsolutePath())));
						opponentFightJsonInput.setText(fileData);
						FightAnalysisFrame.this.validate();
						break;
					}

					evt.dropComplete(true);
				}
				catch (Exception ex)
				{
					ex.printStackTrace();
				}
			}
		});

		textAreaLine.add(opponentFightJsonInput);
		textAreaLine.setSize(mainPanel.getWidth(), 32);
		textAreaLine.setMaximumSize(new Dimension(mainPanel.getWidth(), 32));

		// confirm button
		JButton confirmButton = new JButton("<html><strong>Merge Fight Data</strong></html>");
		confirmButton.setSize(256, 32);
		confirmButton.setMaximumSize(new Dimension(256, 32));
		confirmButton.addActionListener(e -> performAnalysis());
		confirmButton.setAlignmentX(Component.CENTER_ALIGNMENT);

		// add all components
		mainPanel.add(wikiLinkLabel);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 4)));
		mainPanel.add(instructionLabel);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 16)));
		mainPanel.add(textLabelLine);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 4)));
		mainPanel.add(textAreaLine);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 16)));
		mainPanel.add(confirmButton);

		validate();
		repaint();
	}

	// parse fights into mainFight / opponentFight. Returns false if either are invalid.
	private boolean parseFights()
	{
		try
		{
			// if either fight or their log entries are null, error
			mainFight = PLUGIN.GSON.fromJson(mainFightJsonInput.getText().trim(), FightPerformance.class);
			if (mainFight == null || mainFight.getAllFightLogEntries() == null || mainFight.getAllFightLogEntries().size() < 1)
			{
				PLUGIN.createConfirmationModal(false, "Error parsing Fighter 1's fight data.");
				mainFight = null;

				return false;
			}

			opponentFight = PLUGIN.GSON.fromJson(opponentFightJsonInput.getText().trim(), FightPerformance.class);
			if (opponentFight == null || opponentFight.getAllFightLogEntries() == null || opponentFight.getAllFightLogEntries().size() < 1)
			{
				PLUGIN.createConfirmationModal(false, "Error parsing Fighter 2's fight data.");
				opponentFight = null;

				return false;
			}


			PLUGIN.initializeImportedFight(mainFight);
			PLUGIN.initializeImportedFight(opponentFight);
		}
		catch (Exception e)
		{
			PLUGIN.createConfirmationModal(false, "Error while parsing fight data.");
			return false;
		}

		return true;
	}

	// start fight parsing, and if fights are valid then move onto the next "state" of the frame
	// where we will display stats about the fight.
	private void performAnalysis()
	{
		boolean fightsValid = parseFights();
		// parseFights includes error messages if the parse fails
		if (!fightsValid)
		{
			return;
		}

		try
		{

			analyzedFight = new AnalyzedFightPerformance(mainFight, opponentFight, this::displayAnalysis);
			// now that we've got the merged fight, display results, this is done with the displayAnalysis callback
		}
		catch (Exception e)
		{
			log.info("Error during fight analysis - could not merge fights. Exception tack trace: ", e);
			PLUGIN.createConfirmationModal(false, "<html>Error while merging fights. Unable to analyze.<br/>If you think this should have been valid, feel free to submit<br/>an issue on the github repo, and include client logs.</html>");
		}
	}

	private void displayAnalysis()
	{
		mainPanel.removeAll();
		setTitle(WINDOW_TITLE + " - " + analyzedFight.competitor.getName() + " vs " + analyzedFight.opponent.getName());

		// intro label
		JLabel mergedFightLabel = new JLabel("<html><strong>Merged Fight &mdash; Click the panel for more details.</strong></html>");
		mergedFightLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		mergedFightLabel.setHorizontalAlignment(SwingConstants.CENTER);

		// analyzed fight
		FightPerformancePanel analyzedFightPanel = new FightPerformancePanel(analyzedFight);
		analyzedFightPanel.setSize(220, 134);
		analyzedFightPanel.setMaximumSize(new Dimension(220, 134));
		analyzedFightPanel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// back to setup/config button
		JButton backButton = new JButton("<html><strong>Back</strong></html>");
		backButton.setSize(256, 32);
		backButton.setMaximumSize(new Dimension(256, 32));
		backButton.addActionListener(e -> initializeFrame());
		backButton.setAlignmentX(Component.CENTER_ALIGNMENT);


		// checkbox to show initial fights
		JCheckBox initialFightCheckbox = new JCheckBox();
		initialFightCheckbox.setText("Show initial fights");
		initialFightCheckbox.setSelected(false);
		initialFightCheckbox.setAlignmentX(Component.CENTER_ALIGNMENT);

		JPanel initialFightsPanel = new JPanel();
		initialFightsPanel.setLayout(new BoxLayout(initialFightsPanel, BoxLayout.X_AXIS));
		initialFightsPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
		// initial fights
		FightPerformancePanel mainFightPanel = new FightPerformancePanel(mainFight, false, true, false, null);
		mainFightPanel.setSize(220, 134);
		mainFightPanel.setMaximumSize(new Dimension(220, 134));
		initialFightsPanel.add(mainFightPanel);
		initialFightsPanel.add(Box.createRigidArea(new Dimension(8, 0)));

		FightPerformancePanel oppFightPanel = new FightPerformancePanel(opponentFight, false, true, false, null);
		oppFightPanel.setSize(220, 134);
		oppFightPanel.setMaximumSize(new Dimension(220, 134));
		initialFightsPanel.add(oppFightPanel);
		initialFightsPanel.setVisible(false);


		initialFightCheckbox.addItemListener(e -> {
			if (e.getStateChange() == ItemEvent.SELECTED)
			{
				initialFightsPanel.setVisible(true);
				validate();
				repaint();
			}
			else
			{
				initialFightsPanel.setVisible(false);
				validate();
				repaint();
			}
		});

		// add all components
		mainPanel.add(mergedFightLabel);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		mainPanel.add(analyzedFightPanel);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		mainPanel.add(backButton);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		mainPanel.add(initialFightCheckbox);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		mainPanel.add(initialFightsPanel);

		validate();
		repaint();
	}
}

/*
 * Copyright (c) 2025, Matsyir <contact@matsyir.com>
 * Copyright (c) 2018, Jordan Atwood <jordan.atwood423@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.security.InvalidParameterException;
import java.util.ArrayList;
import javax.annotation.Nonnull;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.util.Text;

// mostly yoinked from: https://github.com/runelite/runelite/pull/4375
// & https://gist.github.com/Nightfirecat/a1e2187ac0a1bd7b5ef40de76d96aad9
// thanks nightfirecat
//
// then adapted to our usage:
// patch custom 3-column behavior, to have a consistently centered middle column
//
// not sure if original behavior still works at this point, but I did my best to keep it intact &
// patch our behaviors on top of it in case we wanna use it alongside.
@Slf4j
public class TableComponent implements LayoutableRenderableEntity
{
	public enum TableAlignment
	{
		LEFT,
		CENTER,
		RIGHT
	}

	public enum TableRowStyle
	{
		DEFAULT, // default/original TableComponent behavior (maybe if it still works)
		PERCENTAGE_BASED, // 3 column hack fix: 0 is left column, 2 is right, 1 is middle/background. 0 & 2 each take up X% width
	}

	private class Cell
	{
		private String text;
		private TextComponentShadowless component;

		private Cell(String text, TextComponentShadowless component)
		{
			this.text = text;
			this.component = component;
		}
	}

	@Getter
	private final Rectangle bounds = new Rectangle();

	private ArrayList<Cell[]> cells = new ArrayList<>();
	private Cell[] line1;
	private TableAlignment[] columnAlignments;
	private Color[] columnColors;
	private int numCols;
	private int numRows;
	private TableRowStyle rowStyle;
	private final float centerWidthPercent = 1f;
	private final float leftWidthPercent;
	private final float rightWidthPercent;

	private TableAlignment defaultAlignment = TableAlignment.LEFT;
	private Color defaultColor = Color.WHITE;
	private Dimension gutter = new Dimension(3, 0);
	private Point preferredLocation = new Point();
	private Dimension preferredSize = new Dimension(ComponentConstants.STANDARD_WIDTH, 0);

	private boolean fontsInitialized = false;

	public TableComponent()
	{
		this(TableRowStyle.DEFAULT);
	}

	public TableComponent(TableRowStyle rowStyle)
	{
		this(rowStyle, 50, 50);
	}

	public TableComponent(TableRowStyle rowStyle, int leftWidthPercent, int rightWidthPercent)
	{
		super();

		if (leftWidthPercent + rightWidthPercent != 100)
		{
			throw new InvalidParameterException("TableComponent : leftWidthPercent & rightWidthPercent must add to 100");
		}

		this.rowStyle = rowStyle;
		this.leftWidthPercent = (float) leftWidthPercent / 100f;
		this.rightWidthPercent = (float) rightWidthPercent / 100f;
	}

	private boolean is3ColHackFix()
	{
		return numCols == 3 && rowStyle == TableRowStyle.PERCENTAGE_BASED;
	}

	public void updateLeftRightCells(String left, Color leftColor, String right, Color rightColor)
	{
		if (!is3ColHackFix())
		{
			return;
		}

		line1[0].text = left;
		columnColors[0] = leftColor;
		line1[2].text = right;
		columnColors[2] = rightColor;
	}

	public void updateLeftCell(String left, Color leftColor)
	{
		if (!is3ColHackFix())
		{
			return;
		}

		line1[0].text = left;
		columnColors[0] = leftColor;
	}

	public void updateLeftCellText(String left)
	{
		if (!is3ColHackFix())
		{
			return;
		}

		line1[0].text = left;
	}

	public void updateRightCell(String right, Color rightColor)
	{
		if (!is3ColHackFix())
		{
			return;
		}

		line1[2].text = right;
		columnColors[2] = rightColor;
	}

	public void updateRightCellText(String right)
	{
		if (!is3ColHackFix())
		{
			return;
		}

		line1[2].text = right;
	}

	@Override
	public Dimension render(final Graphics2D graphics)
	{
		if (is3ColHackFix())
		{
			return renderFor3ColHackFix(graphics);
		}
		final FontMetrics metrics = graphics.getFontMetrics();
		final int[] columnWidths = getColumnWidths(metrics);
		int height = 0;
		TextComponentShadowless cellTextComponent;

		graphics.translate(preferredLocation.x, preferredLocation.y);

		for (int row = 0; row < numRows; row++)
		{
			int x = 0;
			int startingRowHeight = height;
			for (int col = 0; col < numCols; col++)
			{
				int y = startingRowHeight;
				final String[] lines = lineBreakText(getCellText(col, row), columnWidths[col], metrics);
				for (String line : lines)
				{
					cellTextComponent = getCellComponent(col, row);
					if (cellTextComponent == null)
					{
						continue;
					}

					boolean middleColumnHackFix = is3ColHackFix() && col == 1;
					final int alignmentOffset = getAlignedPosition(line, getColumnAlignment(col), columnWidths[col], metrics);

					y += metrics.getHeight();

					if (middleColumnHackFix && !fontsInitialized)
					{
						cellTextComponent.setFont(PanelFactory.getIndexFontFrom(metrics.getFont()));
						fontsInitialized = true;
					}

					cellTextComponent.updatePosition(x + alignmentOffset,
						y - (middleColumnHackFix ? Math.round((1 - PanelFactory.LINE_INDEX_LABEL_FONT_SCALE) * 9) : 0)
					);
					cellTextComponent.setText(line);
					cellTextComponent.setColor(getColumnColor(col));
					cellTextComponent.render(graphics);
				}
				height = Math.max(height, y);
				x += columnWidths[col] + gutter.width;
			}
			height += gutter.height;
		}

		graphics.translate(-preferredLocation.x, -preferredLocation.y);
		bounds.setLocation(preferredLocation);
		bounds.setSize(preferredSize.width, height);
		return bounds.getSize();
	}

	private Dimension renderFor3ColHackFix(final Graphics2D graphics)
	{
		final FontMetrics metrics = graphics.getFontMetrics();
		final int[] columnWidths = getColumnWidths(metrics);
		int height = 0;
		TextComponentShadowless cellTextComponent;

		graphics.translate(preferredLocation.x, preferredLocation.y);

		// first: draw the background layer/line, which is col=1
		for (int row = 0; row < numRows; row++)
		{
			int x = 0;
			int startingRowHeight = height;
			int col = 1;

			int y = startingRowHeight;
			final String[] lines = lineBreakText(getCellText(col, row), columnWidths[col], metrics);
			for (String line : lines)
			{
				cellTextComponent = getCellComponent(col, row);
				if (cellTextComponent == null)
				{
					continue;
				}

				final int alignmentOffset = getAlignedPosition(line, getColumnAlignment(col), columnWidths[col], metrics);

				y += metrics.getHeight();

				if (!fontsInitialized)
				{
					cellTextComponent.setFont(PanelFactory.getIndexFontFrom(metrics.getFont()));
					fontsInitialized = true;
				}

				cellTextComponent.updatePosition(x + alignmentOffset,
					y - Math.round((1 - PanelFactory.LINE_INDEX_LABEL_FONT_SCALE) * 9)
				);
				cellTextComponent.setText(line);
				cellTextComponent.setColor(getColumnColor(col));
				cellTextComponent.render(graphics);
			}
			height = Math.max(height, y);
			x += columnWidths[col] + gutter.width;
			height += gutter.height;
		}

		height = 0; // reset height for next layer

		// now draw the 2 other columns as usual (skip middle column 1)
		for (int row = 0; row < numRows; row++)
		{
			int x = 0;
			int startingRowHeight = height;
			for (int col = 0; col < numCols; col++)
			{
				if (col == 1)
				{
					continue;
				}

				int y = startingRowHeight;
				final String[] lines = lineBreakText(getCellText(col, row), columnWidths[col], metrics);
				for (String line : lines)
				{
					cellTextComponent = getCellComponent(col, row);
					if (cellTextComponent == null)
					{
						continue;
					}

					final int alignmentOffset = getAlignedPosition(line, getColumnAlignment(col), columnWidths[col], metrics);

					y += metrics.getHeight();

					cellTextComponent.updatePosition(x + alignmentOffset, y);
					cellTextComponent.setText(line);
					cellTextComponent.setColor(getColumnColor(col));
					cellTextComponent.render(graphics);
				}
				height = Math.max(height, y);
				x += columnWidths[col] + gutter.width;
			}
			height += gutter.height;
		}

		graphics.translate(-preferredLocation.x, -preferredLocation.y);
		bounds.setLocation(preferredLocation);
		bounds.setSize(preferredSize.width, height);
		return bounds.getSize();
	}

	@Override
	public void setPreferredLocation(@Nonnull final Point location)
	{
		this.preferredLocation = location;
	}

	@Override
	public void setPreferredSize(@Nonnull final Dimension size)
	{
		this.preferredSize = size;
	}

	public void setDefaultColor(@Nonnull final Color color)
	{
		this.defaultColor = color;
	}

	public void setDefaultAlignment(@Nonnull final TableAlignment alignment)
	{
		this.defaultAlignment = alignment;
	}

	public void setGutter(@Nonnull final Dimension gutter)
	{
		this.gutter = gutter;
	}

	public void setColumnColors(@Nonnull Color... colors)
	{
		columnColors = colors;
	}

	public void setColumnAlignments(@Nonnull TableAlignment... alignments)
	{
		columnAlignments = alignments;
	}

	public void setColumnColor(final int col, final Color color)
	{
		assert columnColors.length > col;
		columnColors[col] = color;
	}

	public void setColumnAlignment(final int col, final TableAlignment alignment)
	{
		assert columnAlignments.length > col;
		columnAlignments[col] = alignment;
	}

	public void addRow(@Nonnull final String... cells)
	{
		numCols = Math.max(numCols, cells.length);
		numRows++;
		Cell[] newRow = new Cell[cells.length];
		for (int col = 0; col < cells.length; col++)
		{
			TextComponentShadowless cellComponent = new TextComponentShadowless(false, !is3ColHackFix() || col != 1);
			newRow[col] = new Cell(cells[col], cellComponent);
		}

		this.cells.add(newRow);
		line1 = this.cells.get(0);
	}

	public void addRows(@Nonnull final String[]... rows)
	{
		for (String[] row : rows)
		{
			addRow(row);
		}
		line1 = this.cells.get(0);
	}

	private Color getColumnColor(final int column)
	{
		if (columnColors == null
			|| columnColors.length <= column
			|| columnColors[column] == null)
		{
			return defaultColor;
		}
		return columnColors[column];
	}

	private TableAlignment getColumnAlignment(final int column)
	{
		if (columnAlignments == null
			|| columnAlignments.length <= column
			|| columnAlignments[column] == null)
		{
			return defaultAlignment;
		}
		return columnAlignments[column];
	}

	private Cell getCell(final int col, final int row)
	{
		assert col < numCols && row < numRows;

		if (cells.get(row).length < col)
		{
			return null;
		}
		return cells.get(row)[col];
	}

	private String getCellText(final int col, final int row)
	{
		assert col < numCols && row < numRows;

		Cell c = getCell(col, row);
		if (c == null)
		{
			return "";
		}
		return c.text;
	}

	private TextComponentShadowless getCellComponent(final int col, final int row)
	{
		assert col < numCols && row < numRows;

		Cell c = getCell(col, row);
		if (c == null)
		{
			return null;
		}
		return c.component;
	}

	private int[] getColumnWidths(final FontMetrics metrics)
	{
		if (numCols <= 0)
		{
			return new int[0];
		}

		int[] finalcolw = new int[numCols];     // final width of columns

		// 3colHackFix: simplified width calculation, dont need to do all that math for this basic percentage column thing
		if (is3ColHackFix() && preferredSize.width >= 4)
		{
			// middle column: to be drawn on its own layer, 100% width
			finalcolw[1] = (int) (preferredSize.width * centerWidthPercent);

			// left column: width * leftPercent
			finalcolw[0] = (int) (preferredSize.width * leftWidthPercent);

			// right column: remaining pixels, minus gutter*2 (idk why we need x2 but it works)
			finalcolw[2] = preferredSize.width - finalcolw[0] - (gutter.width * 2);

			return finalcolw;
		}

		// Based on https://stackoverflow.com/questions/22206825/algorithm-for-calculating-variable-column-widths-for-set-table-width
		int[] maxtextw = new int[numCols];      // max text width over all rows
		int[] maxwordw = new int[numCols];      // max width of longest word
		boolean[] flex = new boolean[numCols];  // is column flexible?
		boolean[] wrap = new boolean[numCols];  // can column be wrapped?

		for (int col = 0; col < numCols; col++)
		{
			for (int row = 0; row < numRows; row++)
			{
				final String cell = getCellText(col, row);
				final int cellWidth = getTextWidth(metrics, cell);

				maxtextw[col] = Math.max(maxtextw[col], cellWidth);
				for (String word : cell.split(" "))
				{
					maxwordw[col] = Math.max(maxwordw[col], getTextWidth(metrics, word));
				}

				if (maxtextw[col] == cellWidth)
				{
					wrap[col] = cell.contains(" ");
				}
			}
		}

		int left = preferredSize.width - (numCols - 1) * gutter.width;
		final double avg = (double) left / numCols;
		int nflex = 0;

		// Determine whether columns should be flexible and assign width of non-flexible cells
		for (int col = 0; col < numCols; col++)
		{
			// This limit can be adjusted as needed
			final double maxNonFlexLimit = 1.5 * avg;

			flex[col] = maxtextw[col] > maxNonFlexLimit;
			if (flex[col])
			{
				nflex++;
			}
			else
			{
				finalcolw[col] = maxtextw[col];
				left -= finalcolw[col];
			}
		}

		// If there is not enough space, make columns that could be word-wrapped flexible too
		if (left < nflex * avg)
		{
			for (int col = 0; col < numCols; col++)
			{
				if (!flex[col] && wrap[col])
				{
					left += finalcolw[col];
					finalcolw[col] = 0;
					flex[col] = true;
					nflex++;
				}
			}
		}

		// Calculate weights for flexible columns. The max width is capped at the table width to
		// treat columns that have to be wrapped more or less equal
		int tot = 0;
		for (int col = 0; col < numCols; col++)
		{
			if (flex[col])
			{
				maxtextw[col] = Math.min(maxtextw[col], preferredSize.width);
				tot += maxtextw[col];
			}
		}

		// Now assign the actual width for flexible columns. Make sure that it is at least as long
		// as the longest word length
		for (int col = 0; col < numCols; col++)
		{
			if (flex[col])
			{
				finalcolw[col] = left * maxtextw[col] / tot;
				finalcolw[col] = Math.max(finalcolw[col], maxwordw[col]);
				left -= finalcolw[col];
			}
		}

		// When the sum of column widths is less than the total space available, distribute the
		// extra space equally across all columns
		final int extraPerCol = left / numCols;
		for (int col = 0; col < numCols; col++)
		{
			finalcolw[col] += extraPerCol;
			left -= extraPerCol;
		}
		// Add any remainder to the right-most column
		finalcolw[finalcolw.length - 1] += left;

		return finalcolw;
	}

	private static int getTextWidth(final FontMetrics metrics, final String cell)
	{
		return metrics.stringWidth(Text.removeTags(cell));
	}

	private static String[] lineBreakText(final String text, final int maxWidth, final FontMetrics metrics)
	{
		final String[] words = text.split(" ");

		if (words.length == 0)
		{
			return new String[0];
		}

		final StringBuilder wrapped = new StringBuilder(words[0]);
		int spaceLeft = maxWidth - getTextWidth(metrics, wrapped.toString());

		for (int i = 1; i < words.length; i++)
		{
			final String word = words[i];
			final int wordLen = getTextWidth(metrics, word);
			final int spaceWidth = metrics.stringWidth(" ");

			if (wordLen + spaceWidth > spaceLeft)
			{
				wrapped.append('\n').append(word);
				spaceLeft = maxWidth - wordLen;
			}
			else
			{
				wrapped.append(' ').append(word);
				spaceLeft -= spaceWidth + wordLen;
			}
		}

		return wrapped.toString().split("\n");
	}

	private static int getAlignedPosition(final String str, final TableAlignment alignment, final int columnWidth, final FontMetrics metrics)
	{
		final int stringWidth = getTextWidth(metrics, str);
		int offset = 0;

		switch (alignment)
		{
			case LEFT:
				break;
			case CENTER:
				offset = (columnWidth / 2) - (stringWidth / 2);
				break;
			case RIGHT:
				offset = columnWidth - stringWidth;
				break;
		}
		return offset;
	}
}
/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import lombok.extern.slf4j.Slf4j;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;
import static matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils.fixItemId;
import matsyir.pvpperformancetracker.controllers.AnalyzedFightPerformance;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.EquipmentData;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.controllers.Fighter;
import matsyir.pvpperformancetracker.controllers.PvpDamageCalc;
import matsyir.pvpperformancetracker.models.RangeAmmoData;
import matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemEquipmentStats;

@Slf4j
class FightLogDetailFrame extends JFrame
{
	public static final int DEFAULT_WIDTH = 400;

	public int rowIdx;

	private boolean isCompetitorLog;
	private Fighter attacker;
	private Fighter defender;

	private JPanel combatLevelsLine;
	private JLabel attackerAtkLvl;
	private JLabel attackerStrLvl;
	private JLabel attackerDefLvl;
	private JLabel attackerRangeLvl;
	private JLabel attackerMageLvl;
	private JLabel attackerHpLvl;

	private JLabel defenderAtkLvl;
	private JLabel defenderStrLvl;
	private JLabel defenderDefLvl;
	private JLabel defenderRangeLvl;
	private JLabel defenderMageLvl;
	private JLabel defenderHpLvl;

	private JLabel attackerOffensiveLabel;
	private JLabel defenderOffensiveLabel;

	// this is a regular fightLogDetailFrame, for a normal non-merged fight.
	FightLogDetailFrame(FightPerformance fight, FightLogEntry log, int rowIdx, Point location)
	{
		super("Fight Log Details - " + fight.getCompetitor().getName() + " vs " + fight.getOpponent().getName()
			+ " on world " + fight.getWorld());

		this.rowIdx = rowIdx;

		setSize(DEFAULT_WIDTH, 640);
		setMinimumSize(new Dimension(DEFAULT_WIDTH, 200));
		setLayout(new BorderLayout());
		setLocation(location);
		setIconImage(PLUGIN_ICON);

		// if always on top is supported, and the core RL plugin has "always on top" set, make the frame always
		// on top as well so it can be above the client.
		if (isAlwaysOnTopSupported())
		{
			setAlwaysOnTop(PLUGIN.getRuneliteConfig().gameAlwaysOnTop());
		}

		JPanel mainPanel = new JPanel(); //new GridLayout(0, 2)
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setVisible(true);
		mainPanel.setBorder(BorderFactory.createEmptyBorder(8, 16, 8, 16));

		isCompetitorLog = log.attackerName.equals(fight.getCompetitor().getName());
		attacker = isCompetitorLog ? fight.getCompetitor() : fight.getOpponent();
		defender = isCompetitorLog ? fight.getOpponent() : fight.getCompetitor();

		JPanel namesLine = new JPanel(new BorderLayout());
		GridLayout attackerNameContainerLayout = new GridLayout(1, 2);
		attackerNameContainerLayout.setHgap(4);
		JPanel attackerNameContainer = new JPanel(attackerNameContainerLayout);
		JLabel attackerName = new JLabel();
		attackerName.setText("<html>Attacker:<br/><strong>" + log.attackerName + "</strong></html>");
		PLUGIN.addSpriteToLabelIfValid(attackerName, log.getAnimationData().attackStyle.getStyleSpriteId());
		attackerName.setToolTipText(log.getAnimationData().attackStyle.toString());
		attackerNameContainer.add(attackerName);

		// if it was a magic attack, display if splash or not:
		if (log.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC)
		{
			int splashIcon = log.isSplash() ? SpriteID.SPELL_ICE_BARRAGE_DISABLED : SpriteID.SPELL_ICE_BARRAGE;
			JLabel splashIconLabel = new JLabel();
			PLUGIN.addSpriteToLabelIfValid(splashIconLabel, splashIcon);
			splashIconLabel.setText("<html> <br/> </html>"); // set text to be 2 lines so the icon lines up with the style icon
			splashIconLabel.setToolTipText("Splashed: " + (log.isSplash() ? "Yes" : "No"));
			splashIconLabel.setHorizontalAlignment(SwingConstants.LEFT);
			attackerNameContainer.add(splashIconLabel);
		}
		namesLine.add(attackerNameContainer, BorderLayout.WEST);

		JLabel defenderName = new JLabel();
		defenderName.setText("<html>Defender:<br/><strong>" + defender.getName() + "</strong></html>");
		namesLine.add(defenderName, BorderLayout.EAST);

		// prayer display line
		JPanel praysUsedLine = new JPanel(new BorderLayout());
		GridLayout attackerPrayLayout = new GridLayout(1, 2);
		attackerPrayLayout.setHgap(4);
		JPanel attackerPrays = new JPanel(attackerPrayLayout);
		// attacker overhead
		int attackerOverheadSpriteId = PvpPerformanceTrackerUtils.getSpriteForHeadIcon(log.getAttackerOverhead());
		JLabel attackerOverheadLabel = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerOverheadLabel, attackerOverheadSpriteId);
		attackerOverheadLabel.setToolTipText("Overhead Prayer");
		attackerPrays.add(attackerOverheadLabel);
		// attacker offensive
		attackerOffensiveLabel = new JLabel();
		attackerOffensiveLabel.setToolTipText("Offensive Prayer");

		// if there's a valid offensive pray, display it.
		PLUGIN.addSpriteToLabelIfValid(attackerOffensiveLabel, log.getAttackerOffensivePray());

		if (!isCompetitorLog) // if it wasn't a competitor log, then this is N/A in most cases, and
		{ // do NOT put a bank filler, to indicate that this is fully N/A, and not "None"
			attackerOffensiveLabel.setText("N/A");
			attackerOffensiveLabel.setIcon(null);
		}

		attackerPrays.add(attackerOffensiveLabel);
		praysUsedLine.add(attackerPrays, BorderLayout.WEST);

		GridLayout defenderPrayLayout = new GridLayout(1, 2);
		defenderPrayLayout.setHgap(4);
		JPanel defenderPrays = new JPanel(defenderPrayLayout);
		// defender overhead
		int defenderOverheadSpriteId = PvpPerformanceTrackerUtils.getSpriteForHeadIcon(log.getDefenderOverhead());
		JLabel defenderOverheadLabel = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderOverheadLabel, defenderOverheadSpriteId);
		defenderOverheadLabel.setToolTipText("Overhead Prayer");
		defenderPrays.add(defenderOverheadLabel);

		// defender offensive (N/A in normal cases)
		defenderOffensiveLabel = new JLabel("N/A");
		defenderOffensiveLabel.setToolTipText("Offensive Prayer");
		defenderPrays.add(defenderOffensiveLabel);

		praysUsedLine.add(defenderPrays, BorderLayout.EAST);

		CombatLevels levels = fight.fightType.getCombatLevelsForType();
		combatLevelsLine = new JPanel(new BorderLayout());
		JPanel attackerCombatLevels = new JPanel(new GridLayout(2, 3));
		attackerAtkLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerAtkLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.ATTACK));
		attackerAtkLvl.setText(String.valueOf(levels.atk));
		attackerAtkLvl.setToolTipText("Attack Level");
		attackerStrLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerStrLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.STRENGTH));
		attackerStrLvl.setText(String.valueOf(levels.str));
		attackerStrLvl.setToolTipText("Strength Level");
		attackerDefLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerDefLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.DEFENCE));
		attackerDefLvl.setText(String.valueOf(levels.def));
		attackerDefLvl.setToolTipText("Defence Level");
		attackerRangeLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerRangeLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.RANGED));
		attackerRangeLvl.setText(String.valueOf(levels.range));
		attackerRangeLvl.setToolTipText("Ranged Level");
		attackerMageLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerMageLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.MAGIC));
		attackerMageLvl.setText(String.valueOf(levels.mage));
		attackerMageLvl.setToolTipText("Magic Level");
		attackerHpLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerHpLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.HITPOINTS));
		attackerHpLvl.setText(String.valueOf(levels.hp));
		attackerHpLvl.setToolTipText("Hitpoints Level");

		attackerCombatLevels.add(attackerAtkLvl);
		attackerCombatLevels.add(attackerStrLvl);
		attackerCombatLevels.add(attackerDefLvl);
		attackerCombatLevels.add(attackerRangeLvl);
		attackerCombatLevels.add(attackerMageLvl);
		attackerCombatLevels.add(attackerHpLvl);
		combatLevelsLine.add(attackerCombatLevels, BorderLayout.WEST);

		JPanel defenderCombatLevels = new JPanel(new GridLayout(2, 3));
		defenderAtkLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderAtkLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.ATTACK));
		defenderAtkLvl.setText(String.valueOf(levels.atk));
		defenderAtkLvl.setToolTipText("Attack Level");
		defenderStrLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderStrLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.STRENGTH));
		defenderStrLvl.setText(String.valueOf(levels.str));
		defenderStrLvl.setToolTipText("Strength Level");
		defenderDefLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderDefLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.DEFENCE));
		defenderDefLvl.setText(String.valueOf(levels.def));
		defenderDefLvl.setToolTipText("Defence Level");
		defenderRangeLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderRangeLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.RANGED));
		defenderRangeLvl.setText(String.valueOf(levels.range));
		defenderRangeLvl.setToolTipText("Ranged Level");
		defenderMageLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderMageLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.MAGIC));
		defenderMageLvl.setText(String.valueOf(levels.mage));
		defenderMageLvl.setToolTipText("Magic Level");
		defenderHpLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderHpLvl, PvpPerformanceTrackerUtils.getSpriteForSkill(Skill.HITPOINTS));
		defenderHpLvl.setText(String.valueOf(levels.hp));
		defenderHpLvl.setToolTipText("Hitpoints Level");

		defenderCombatLevels.add(defenderAtkLvl);
		defenderCombatLevels.add(defenderStrLvl);
		defenderCombatLevels.add(defenderDefLvl);
		defenderCombatLevels.add(defenderRangeLvl);
		defenderCombatLevels.add(defenderMageLvl);
		defenderCombatLevels.add(defenderHpLvl);
		combatLevelsLine.add(defenderCombatLevels, BorderLayout.EAST);


		// equipment stats line (stab attack, slash attack, etc)
		JPanel equipmentStatsLine = new JPanel(new BorderLayout());
		JLabel attackerStatsLabel = new JLabel();
		PLUGIN.getClientThread().invokeLater(() ->
			attackerStatsLabel.setText(getItemEquipmentStatsString(log.getAttackerGear())));
		equipmentStatsLine.add(attackerStatsLabel, BorderLayout.WEST);

		JLabel defenderStatsLabel = new JLabel();
		PLUGIN.getClientThread().invokeLater(() ->
			defenderStatsLabel.setText(getItemEquipmentStatsString(log.getDefenderGear())));
		equipmentStatsLine.add(defenderStatsLabel, BorderLayout.EAST);

		JPanel equipmentRenderLine = new JPanel(new BorderLayout());
		JPanel attackerEquipmentRender = getEquipmentRender(log.getAttackerGear());
		JPanel defenderEquipmentRender = getEquipmentRender(log.getDefenderGear());
		equipmentRenderLine.add(attackerEquipmentRender, BorderLayout.WEST);
		equipmentRenderLine.add(defenderEquipmentRender, BorderLayout.EAST);

		// Animation detected line
		JPanel animationDetectedLine = new JPanel(new BorderLayout());
		JLabel attackerAnimationDetected = new JLabel();
		attackerAnimationDetected.setText("<html><strong>Animation Detected:</strong> " + log.getAnimationData().toString() + "</html>");
		attackerAnimationDetected.setToolTipText("<html>Note that the animation can be misleading, as many animations are re-used, but this is normal.<br/>" +
			"For example, Zammy Hasta and Staff of Fire use the same crush animation.<br/>" +
			"These were not intended to ever be displayed, but why not include them here.</html>");
		animationDetectedLine.add(attackerAnimationDetected, BorderLayout.CENTER);


		mainPanel.add(namesLine);
		mainPanel.add(praysUsedLine);
		mainPanel.add(combatLevelsLine);
		mainPanel.add(equipmentRenderLine);
		mainPanel.add(equipmentStatsLine);
		mainPanel.add(animationDetectedLine);

		this.add(mainPanel, BorderLayout.CENTER);
		this.setVisible(true);
	}

	// extra-detailed frame for a merged fight, which has both an attacker and defender log for each attack
	FightLogDetailFrame(AnalyzedFightPerformance fight, FightLogEntry attackerLog, FightLogEntry defenderLog, int rowIdx, Point location)
	{
		this(fight, attackerLog, rowIdx, location);

		// attacker lvls
		CombatLevels aLvls = attackerLog.getAttackerLevels();
		if (aLvls == null)
		{
			log.info("Fight Analysis: attackerLvls are null! This shouldn't happen.");
			aLvls = fight.fightType.getCombatLevelsForType();
		}
		attackerAtkLvl.setText(String.valueOf(aLvls.atk));
		attackerStrLvl.setText(String.valueOf(aLvls.str));
		attackerDefLvl.setText(String.valueOf(aLvls.def));
		attackerRangeLvl.setText(String.valueOf(aLvls.range));
		attackerMageLvl.setText(String.valueOf(aLvls.mage));
		attackerHpLvl.setText(String.valueOf(aLvls.hp));

		// defender lvls
		CombatLevels dLvls = defenderLog.getAttackerLevels();
		if (dLvls == null)
		{
			log.info("Fight Analysis: defenderLvls are null! This shouldn't happen.");
			dLvls = fight.fightType.getCombatLevelsForType();
		}
		defenderAtkLvl.setText(String.valueOf(dLvls.atk));
		defenderStrLvl.setText(String.valueOf(dLvls.str));
		defenderDefLvl.setText(String.valueOf(dLvls.def));
		defenderRangeLvl.setText(String.valueOf(dLvls.range));
		defenderMageLvl.setText(String.valueOf(dLvls.mage));
		defenderHpLvl.setText(String.valueOf(dLvls.hp));

		defenderOffensiveLabel.setText("");
		PLUGIN.addSpriteToLabelIfValid(defenderOffensiveLabel, defenderLog.getAttackerOffensivePray());

		attackerOffensiveLabel.setText("");
		PLUGIN.addSpriteToLabelIfValid(attackerOffensiveLabel, attackerLog.getAttackerOffensivePray(), () -> {
			validate();
			repaint();
		});
	}

	private JPanel getEquipmentRender(int[] itemIds)
	{
		JPanel equipmentRender = new JPanel();
		equipmentRender.setLayout(new BoxLayout(equipmentRender, BoxLayout.Y_AXIS));

		JPanel helmLine = new JPanel(new BorderLayout()); // helm only
		JPanel capeLine = new JPanel(new BorderLayout()); // cape, amulet, ammo
		JPanel weaponLine = new JPanel(new BorderLayout()); // weapon, torso, shield
		JPanel legsLine = new JPanel(new BorderLayout()); // legs
		JPanel glovesLine = new JPanel(new BorderLayout()); // gloves, boots, ring

		JLabel helm = new JLabel();
		helm.setHorizontalAlignment(SwingConstants.CENTER);
		PLUGIN.addItemToLabelIfValid(helm, itemIds[KitType.HEAD.getIndex()]);
		helmLine.add(helm, BorderLayout.CENTER);

		JLabel cape = new JLabel();
		PLUGIN.addItemToLabelIfValid(cape, itemIds[KitType.CAPE.getIndex()]);
		JLabel amulet = new JLabel();
		PLUGIN.addItemToLabelIfValid(amulet, itemIds[KitType.AMULET.getIndex()]);
		capeLine.add(cape, BorderLayout.WEST);
		capeLine.add(amulet, BorderLayout.CENTER);

		// ammo: get config's ammo for current weapon
		RangeAmmoData weaponAmmo = EquipmentData.getWeaponAmmo(EquipmentData.fromId(fixItemId(itemIds[KitType.WEAPON.getIndex()])));
		if (weaponAmmo != null)
		{
			JLabel ammo = new JLabel();
			PLUGIN.addItemToLabelIfValid(ammo, weaponAmmo, false, null);
			capeLine.add(ammo, BorderLayout.EAST);
		}

		JLabel wep = new JLabel();
		PLUGIN.addItemToLabelIfValid(wep, itemIds[KitType.WEAPON.getIndex()]);
		JLabel torso = new JLabel();
		PLUGIN.addItemToLabelIfValid(torso, itemIds[KitType.TORSO.getIndex()]);
		JLabel shield = new JLabel();
		PLUGIN.addItemToLabelIfValid(shield, itemIds[KitType.SHIELD.getIndex()]);
		weaponLine.add(wep, BorderLayout.WEST);
		weaponLine.add(torso, BorderLayout.CENTER);
		weaponLine.add(shield, BorderLayout.EAST);

		JLabel legs = new JLabel();
		legs.setHorizontalAlignment(SwingConstants.CENTER);
		PLUGIN.addItemToLabelIfValid(legs, itemIds[KitType.LEGS.getIndex()]);
		legsLine.add(legs, BorderLayout.CENTER);

		JLabel gloves = new JLabel();
		PLUGIN.addItemToLabelIfValid(gloves, itemIds[KitType.HANDS.getIndex()]);
		JLabel boots = new JLabel();
		PLUGIN.addItemToLabelIfValid(boots, itemIds[KitType.BOOTS.getIndex()]);
		JLabel ring = new JLabel();
		PLUGIN.addItemToLabelIfValid(ring, CONFIG.ringChoice().getItemId(), false, () -> {
			validate();
			repaint();
		});
		glovesLine.add(gloves, BorderLayout.WEST);
		glovesLine.add(boots, BorderLayout.CENTER);
		glovesLine.add(ring, BorderLayout.EAST);

		equipmentRender.add(helmLine);
		equipmentRender.add(capeLine);
		equipmentRender.add(weaponLine);
		equipmentRender.add(legsLine);
		equipmentRender.add(glovesLine);

		return equipmentRender;
	}

	//
	String getItemEquipmentStatsString(int[] equipment)
	{
		ItemEquipmentStats stats = PvpDamageCalc.calculateBonusesToStats(equipment);
		// ammo: get config's ammo for current weapon
		RangeAmmoData weaponAmmo = EquipmentData.getWeaponAmmo(EquipmentData.fromId(fixItemId(equipment[KitType.WEAPON.getIndex()])));
		int ammoRangeStr = 0;
		if (weaponAmmo != null)
		{
			ammoRangeStr = weaponAmmo.getRangeStr();
		}
		String sep = "<br/>&nbsp;&nbsp;";
		return "<html><strong>Attack bonus</strong>" + sep +
			"Stab: " + prependPlusIfPositive(stats.getAstab()) + sep +
			"Slash: " + prependPlusIfPositive(stats.getAslash()) + sep +
			"Crush: " + prependPlusIfPositive(stats.getAcrush()) + sep +
			"Magic: " + prependPlusIfPositive(stats.getAmagic()) + sep +
			"Range: " + prependPlusIfPositive(stats.getArange()) +
			"<br/><strong>Defence bonus</strong>" + sep +
			"Stab: " + prependPlusIfPositive(stats.getDstab()) + sep +
			"Slash: " + prependPlusIfPositive(stats.getDslash()) + sep +
			"Crush: " + prependPlusIfPositive(stats.getDcrush()) + sep +
			"Magic: " + prependPlusIfPositive(stats.getDmagic()) + sep +
			"Range: " + prependPlusIfPositive(stats.getDrange()) +
			"<br/><strong>Other bonuses</strong>" + sep +
			"Melee strength: " + prependPlusIfPositive(stats.getStr()) + sep +
			"Ranged strength: " + prependPlusIfPositive(stats.getRstr() + ammoRangeStr) + sep +
			"Magic damage: " + prependPlusIfPositive((int) stats.getMdmg()) + "%" + sep +
			"</html>";
	}

	String prependPlusIfPositive(int number)
	{
		if (number >= 0)
		{
			return "+" + number;
		}

		return String.valueOf(number);
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridLayout;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;

import matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.controllers.Fighter;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;

import matsyir.pvpperformancetracker.models.TrackedStatistic;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

// basic panel with 3 rows to show a title, total fight performance stats, and kills/deaths
public class TotalStatsPanel extends JPanel
{
	private static final String WIKI_HELP_URL = "https://github.com/Matsyir/pvp-performance-tracker/wiki#pvp-performance-tracker-wiki";
	// number format for 0 decimal digit (mostly for commas in large numbers)
	private static final NumberFormat nf = NumberFormat.getInstance();

	static // initialize number format
	{
		nf.setMaximumFractionDigits(1);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}

	// number format for 1 decimal digit
	private static final NumberFormat nf1 = NumberFormat.getInstance();

	static // initialize number format
	{
		nf1.setMaximumFractionDigits(1);
		nf1.setRoundingMode(RoundingMode.HALF_UP);
	}

	// number format for 2 decimal digits
	private static final NumberFormat nf2 = NumberFormat.getInstance();

	static // initialize number format
	{
		nf2.setMaximumFractionDigits(2);
		nf2.setRoundingMode(RoundingMode.HALF_UP);
	}

	// number format for percentages
	private static final NumberFormat nfPercent = NumberFormat.getPercentInstance();

	static
	{
		nfPercent.setMaximumFractionDigits(1);
		nfPercent.setRoundingMode(RoundingMode.HALF_UP);
	}

	private static final int LAYOUT_ROWS_WITH_WARNING = 12; // Increased count to include Avg Robe Hits
	private static final int LAYOUT_ROWS_WITHOUT_WARNING = 11; // Increased count to include Avg Robe Hits

	// labels to be updated
	private final JLabel killsLabel;
	private final JLabel deathsLabel;
	private final JLabel offPrayStatsLabel;
	private final JLabel expectedDmgStatsLabel;
	private final JLabel dmgDealtStatsLabel;
	private final JLabel magicHitCountStatsLabel;
	private final JLabel offensivePrayCountStatsLabel;
	private final JLabel hpHealedStatsLabel;
	private final JLabel ghostBarrageStatsLabel;
	private final JLabel avgRobeHitsStatsLabel; // Added label for avg robe hits
	private final JLabel avgKoChanceStatsLabel; // Added label for avg KO chances

	private JLabel settingsWarningLabel; // to be hidden/shown

	private Fighter totalStats;

	private int numFights = 0;

	private int numKills = 0;
	private int numDeaths = 0;

	private double totalExpectedDmg = 0;
	private double totalExpectedDmgDiff = 0;
	private double avgExpectedDmg = 0;
	private double avgExpectedDmgDiff = 0;

	private double killTotalExpectedDmg = 0;
	private double killTotalExpectedDmgDiff = 0;
	private double killAvgExpectedDmg = 0;
	private double killAvgExpectedDmgDiff = 0;

	private double deathTotalExpectedDmg = 0;
	private double deathTotalExpectedDmgDiff = 0;
	private double deathAvgExpectedDmg = 0;
	private double deathAvgExpectedDmgDiff = 0;

	private double totalDmgDealt = 0;
	private double totalDmgDealtDiff = 0;
	private double avgDmgDealt = 0;
	private double avgDmgDealtDiff = 0;

	private double killTotalDmgDealt = 0;
	private double killTotalDmgDealtDiff = 0;
	private double killAvgDmgDealt = 0;
	private double killAvgDmgDealtDiff = 0;

	private double deathTotalDmgDealt = 0;
	private double deathTotalDmgDealtDiff = 0;
	private double deathAvgDmgDealt = 0;
	private double deathAvgDmgDealtDiff = 0;

	private double avgHpHealed = 0;

	// KO Chance totals/averages
	private double totalCompetitorKoChances = 0;
	private double totalOpponentKoChances = 0;
	private double totalCompetitorKoProbSum = 0; // Sum of overall KO probabilities from each fight
	private double totalOpponentKoProbSum = 0; // Sum of overall KO probabilities from each fight
	private double avgCompetitorKoChances = 0;
	private double avgOpponentKoChances = 0;
	private double avgCompetitorKoProb = 0; // Average overall KO probability per fight
	private double avgOpponentKoProb = 0; // Average overall KO probability per fight
	private int numFightsWithKoChance = 0; // Counter for fights that have KO chance data

	// Accumulators for robe hits
	private double totalCompetitorRobeHits = 0;
	private double totalCompetitorRobeHitsAttempted = 0; // 'total attacks attempted', i.e the statistic shows totalCompetitorRobeHits / totalCompetitorRobeHitsAttempted
	private double totalOpponentRobeHits = 0;
	private double totalOpponentRobeHitsAttempted = 0;
	private double avgCompetitorRobeHits = 0;
	private double avgCompetitorRobeHitsPercentage = 0;
	private double avgOpponentRobeHits = 0;
	private double avgOpponentRobeHitsPercentage = 0;

	// let's keep ghost barrage as the bottom-most statistic:
	// It's only relevant to people fighting in PvP Arena, and it's mostly only relevant
	// to people who can share their tracker with each-other - so pretty rarely useful.
	private double avgGhostBarrageCount = 0;
	private double avgGhostBarrageExpectedDamage = 0;

	public TotalStatsPanel()
	{
		totalStats = new Fighter("Player");

		setLayout(new GridLayout(CONFIG.settingsConfigured() ? LAYOUT_ROWS_WITHOUT_WARNING : LAYOUT_ROWS_WITH_WARNING, 1));
		setBorder(new EmptyBorder(4, 6, 4, 6));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Create contextMenu/popupMenu with various general actions
		JPopupMenu contextMenu = new JPopupMenu();
		// Create "View Wiki" URL popup menu/context menu item
		final JMenuItem viewWiki = new JMenuItem("<html><u>View Wiki</u>&nbsp;&#8599;</html>");
		viewWiki.addActionListener(e -> LinkBrowser.browse(WIKI_HELP_URL));
		viewWiki.setForeground(ColorScheme.GRAND_EXCHANGE_LIMIT);

		// Create "Reset All" popup menu/context menu item
		final JMenuItem removeAllFights = new JMenuItem("Remove All Fights");
		removeAllFights.addActionListener(e ->
		{
			int dialogResult = JOptionPane.showConfirmDialog(this, "Are you sure you want to reset all fight history data? This cannot be undone.", "Warning", JOptionPane.YES_NO_OPTION);
			if (dialogResult == JOptionPane.YES_OPTION)
			{
				PLUGIN.resetFightHistory();
			}
		});

		// Create "Configure Settings" popup menu/context menu item
		// TODO? Can't figure out how but would like to in the future. Esp. since there is a warning to setup config.
		//final JMenuItem configureSettings = new JMenuItem("Configure Settings");
		//configureSettings.addActionListener(e -> );

		// Create "Copy Fight History Data" popup menu/context menu item
		final JMenuItem exportFightHistory = new JMenuItem("Copy Fight History Data");
		exportFightHistory.addActionListener(e -> PLUGIN.exportFightHistory());

		// Create "Import Fight History Data" popup menu/context menu item
		final JMenuItem importFightHistory = new JMenuItem("Import Fight History Data");
		importFightHistory.addActionListener(e ->
		{
			// display a simple input dialog to request json data to import.
			String fightHistoryData = JOptionPane.showInputDialog(this, "Enter the fight history data you wish to import:", "Import Fight History", JOptionPane.INFORMATION_MESSAGE);

			// if the string is less than 2 chars, it is definitely invalid (or they pressed Cancel), so skip.
			if (fightHistoryData == null || fightHistoryData.length() < 2)
			{
				return;
			}

			PLUGIN.importUserFightHistoryData(fightHistoryData);
		});

		// Create "Fight Analysis (Advanced)" popup menu/context menu item
		final JMenuItem fightAnalysis = new JMenuItem("Fight Analysis (Advanced)");
		fightAnalysis.addActionListener(e -> new FightAnalysisFrame(TotalStatsPanel.this.getRootPane()));
		fightAnalysis.setForeground(ColorScheme.BRAND_ORANGE);

		contextMenu.add(viewWiki);
		contextMenu.add(removeAllFights);
		contextMenu.add(exportFightHistory);
		contextMenu.add(importFightHistory);
		contextMenu.add(fightAnalysis);
		setComponentPopupMenu(contextMenu);

		// Now initializing all lines:
		// FIRST LINE
		// basic label to display a title.
		JLabel titleLabel = new JLabel();
		titleLabel.setText("PvP Performance Tracker v" + PvpPerformanceTrackerPlugin.PLUGIN_VERSION);
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setForeground(Color.WHITE);
		add(titleLabel);

		// if settings haven't been configured, add a red label to display that they should be.
		if (!CONFIG.settingsConfigured())
		{
			initializeSettingsWarningLabel();
			add(settingsWarningLabel);
		}

		// SECOND LINE
		// panel to show total kills/deaths
		JPanel killDeathPanel = new JPanel(new BorderLayout());

		// left label to show kills
		killsLabel = new JLabel();
		killsLabel.setText(numKills + " Kills");
		killsLabel.setForeground(Color.WHITE);
		killDeathPanel.add(killsLabel, BorderLayout.WEST);

		// right label to show deaths
		deathsLabel = new JLabel();
		deathsLabel.setText(numDeaths + " Deaths");
		deathsLabel.setForeground(Color.WHITE);
		killDeathPanel.add(deathsLabel, BorderLayout.EAST);

		killDeathPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		killDeathPanel.setComponentPopupMenu(contextMenu);
		add(killDeathPanel);

		// THIRD LINE
		// panel to show the total off-pray stats (successful hits/total attacks)
		JPanel offPrayStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's off-pray stats
		JLabel leftLabel = new JLabel();
		leftLabel.setText("Total Off-Pray:");
		leftLabel.setForeground(Color.WHITE);
		offPrayStatsPanel.add(leftLabel, BorderLayout.WEST);

		// right shows off-pray stats
		offPrayStatsLabel = new JLabel();
		offPrayStatsLabel.setForeground(Color.WHITE);
		offPrayStatsPanel.add(offPrayStatsLabel, BorderLayout.EAST);

		offPrayStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		offPrayStatsPanel.setComponentPopupMenu(contextMenu);
		add(offPrayStatsPanel);

		// FOURTH LINE
		// panel to show the average expected damage stats (average damage & average diff)
		JPanel expectedDmgStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's expected dmg stats
		JLabel expectedDmgStatsLeftLabel = new JLabel();
		expectedDmgStatsLeftLabel.setText("Avg Expected Dmg:");
		expectedDmgStatsLeftLabel.setForeground(Color.WHITE);
		expectedDmgStatsPanel.add(expectedDmgStatsLeftLabel, BorderLayout.WEST);

		// label to show expected dmg stats
		expectedDmgStatsLabel = new JLabel();
		expectedDmgStatsLabel.setForeground(Color.WHITE);
		expectedDmgStatsPanel.add(expectedDmgStatsLabel, BorderLayout.EAST);

		expectedDmgStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		expectedDmgStatsPanel.setComponentPopupMenu(contextMenu);
		add(expectedDmgStatsPanel);

		// FIFTH LINE
		// panel to show the average damage dealt stats (average damage & average diff)
		JPanel dmgDealtStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's avg dmg dealt
		JLabel dmgDealtStatsLeftLabel = new JLabel();
		dmgDealtStatsLeftLabel.setText("Avg Damage Dealt:");
		dmgDealtStatsLeftLabel.setForeground(Color.WHITE);
		dmgDealtStatsPanel.add(dmgDealtStatsLeftLabel, BorderLayout.WEST);

		// label to show avg dmg dealt
		dmgDealtStatsLabel = new JLabel();
		dmgDealtStatsLabel.setForeground(Color.WHITE);
		dmgDealtStatsPanel.add(dmgDealtStatsLabel, BorderLayout.EAST);

		dmgDealtStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		dmgDealtStatsPanel.setComponentPopupMenu(contextMenu);
		add(dmgDealtStatsPanel);

		// SIXTH LINE
		// panel to show the total magic hit count and expected hit count
		JPanel magicHitStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's magic hit count stats
		JLabel magicHitStatsLeftLabel = new JLabel();
		magicHitStatsLeftLabel.setText("Magic Luck:");
		magicHitStatsLeftLabel.setForeground(Color.WHITE);
		magicHitStatsPanel.add(magicHitStatsLeftLabel, BorderLayout.WEST);

		// label to show magic hit count stats
		magicHitCountStatsLabel = new JLabel();
		magicHitCountStatsLabel.setForeground(Color.WHITE);
		magicHitStatsPanel.add(magicHitCountStatsLabel, BorderLayout.EAST);

		magicHitStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		magicHitStatsPanel.setComponentPopupMenu(contextMenu);
		add(magicHitStatsPanel);

		// SEVENTH LINE
		// panel to show the offensive prayer success count
		JPanel offensivePrayStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's offensive pray stats
		JLabel offensivePrayStatsLeftLabel = new JLabel();
		offensivePrayStatsLeftLabel.setText("Offensive Pray:");
		offensivePrayStatsLeftLabel.setForeground(Color.WHITE);
		offensivePrayStatsPanel.add(offensivePrayStatsLeftLabel, BorderLayout.WEST);

		// label to show offensive pray stats
		offensivePrayCountStatsLabel = new JLabel();
		offensivePrayCountStatsLabel.setForeground(Color.WHITE);
		offensivePrayStatsPanel.add(offensivePrayCountStatsLabel, BorderLayout.EAST);

		offensivePrayStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		offensivePrayStatsPanel.setComponentPopupMenu(contextMenu);
		add(offensivePrayStatsPanel);

		// EIGTH LINE
		// panel to show the total hp healed
		JPanel hpHealedPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's avg hp healed stats
		JLabel hpHealedLeftLabel = new JLabel();
		hpHealedLeftLabel.setText("Avg HP Healed:");
		hpHealedLeftLabel.setForeground(Color.WHITE);
		hpHealedPanel.add(hpHealedLeftLabel, BorderLayout.WEST);

		// label to show hp healed stats
		hpHealedStatsLabel = new JLabel();
		hpHealedStatsLabel.setForeground(Color.WHITE);
		hpHealedPanel.add(hpHealedStatsLabel, BorderLayout.EAST);

		hpHealedPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		hpHealedPanel.setComponentPopupMenu(contextMenu);
		add(hpHealedPanel);

		// TENTH LINE: Avg Hits on Robes
		JPanel robeHitsStatsPanel = new JPanel(new BorderLayout());
		JLabel robeHitsStatsLeftLabel = new JLabel("Avg Hits on Robes:");
		robeHitsStatsLeftLabel.setForeground(Color.WHITE);
		robeHitsStatsPanel.add(robeHitsStatsLeftLabel, BorderLayout.WEST);
		avgRobeHitsStatsLabel = new JLabel();
		avgRobeHitsStatsLabel.setForeground(Color.WHITE);
		robeHitsStatsPanel.add(avgRobeHitsStatsLabel, BorderLayout.EAST);
		robeHitsStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		robeHitsStatsPanel.setComponentPopupMenu(contextMenu);
		add(robeHitsStatsPanel);

		// TENTH LINE (NEW)
		// panel to show the avg KO chance stats
		JPanel avgKoChanceStatsPanel = new JPanel(new BorderLayout());

		// left label
		JLabel avgKoChanceStatsLeftLabel = new JLabel();
		avgKoChanceStatsLeftLabel.setText("Avg KO Chances:");
		avgKoChanceStatsLeftLabel.setForeground(Color.WHITE);
		avgKoChanceStatsPanel.add(avgKoChanceStatsLeftLabel, BorderLayout.WEST);

		// right label (value)
		avgKoChanceStatsLabel = new JLabel();
		avgKoChanceStatsLabel.setForeground(Color.WHITE);
		avgKoChanceStatsPanel.add(avgKoChanceStatsLabel, BorderLayout.EAST);

		avgKoChanceStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		avgKoChanceStatsPanel.setComponentPopupMenu(contextMenu);
		add(avgKoChanceStatsPanel);

		// panel to show the avg ghost barrage stats
		JPanel ghostBarrageStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's avg ghost barrage stats
		JLabel ghostBarrageStatsLeftLabel = new JLabel();
		ghostBarrageStatsLeftLabel.setText("Avg Ghost Barrages:");
		ghostBarrageStatsLeftLabel.setForeground(Color.WHITE);
		ghostBarrageStatsPanel.add(ghostBarrageStatsLeftLabel, BorderLayout.WEST);

		ghostBarrageStatsLabel = new JLabel();
		ghostBarrageStatsLabel.setForeground(ColorScheme.BRAND_ORANGE);
		ghostBarrageStatsPanel.add(ghostBarrageStatsLabel, BorderLayout.EAST);
		ghostBarrageStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		ghostBarrageStatsPanel.setComponentPopupMenu(contextMenu);
		add(ghostBarrageStatsPanel);


		setLabels();

		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, (int) getPreferredSize().getHeight()));
	}

	private void setLabels()
	{
		String avgExpectedDmgDiffOneDecimal = nf1.format(avgExpectedDmgDiff);
		String avgDmgDealtDiffOneDecimal = nf1.format(avgDmgDealtDiff);

		killsLabel.setText(nf.format(numKills) + " Kill" + (numKills != 1 ? "s" : ""));
		killsLabel.setToolTipText("From a total of " + numFights + " fights, you got " + nf.format(numKills)
			+ " kill" + (numKills != 1 ? "s" : ""));
		deathsLabel.setText(nf.format(numDeaths) + " Death" + (numDeaths != 1 ? "s" : ""));
		deathsLabel.setToolTipText("From a total of " + numFights + " fights, you died "
			+ (numDeaths != 1 ? (nf.format(numDeaths) + " times") : "once"));

		if (totalStats.getAttackCount() >= 10000)
		{
			offPrayStatsLabel.setText(nfWithK(totalStats.getOffPraySuccessCount()) + "/" +
				nfWithK(totalStats.getAttackCount()) + " (" +
				Math.round(totalStats.calculateOffPraySuccessPercentage()) + "%)");
		}
		else
		{
			offPrayStatsLabel.setText(totalStats.getOffPrayStats());
		}

		// put tooltip on parent JPanel so that you can hover anywhere on the line to get the tooltip,
		// rather than having to hover exactly on the statistic label
		((JPanel) offPrayStatsLabel.getParent()).setToolTipText("<html>" + nf.format(totalStats.getOffPraySuccessCount()) + " successful off-pray attacks/" +
			nf.format(totalStats.getAttackCount()) + " total attacks (" +
			nf2.format(totalStats.calculateOffPraySuccessPercentage()) + "%)" +
			TrackedStatistic.OFF_PRAY.getPrefixedAcronymTooltip());

		expectedDmgStatsLabel.setText(nf.format(avgExpectedDmg) + " (" +
			(avgExpectedDmgDiff > 0 ? "+" : "") + avgExpectedDmgDiffOneDecimal + ")");
		((JPanel) expectedDmgStatsLabel.getParent()).setToolTipText("<html>Avg of " + nf1.format(avgExpectedDmg) +
			" expected damage per fight with avg diff of " + (avgExpectedDmgDiff > 0 ? "+" : "") +
			avgExpectedDmgDiffOneDecimal + ".<br>On kills: " + nf1.format(killAvgExpectedDmg) +
			" (" + (killAvgExpectedDmgDiff > 0 ? "+" : "") + nf1.format(killAvgExpectedDmgDiff) +
			"), on deaths: " + nf1.format(deathAvgExpectedDmg) +
			" (" + (deathAvgExpectedDmgDiff > 0 ? "+" : "") + nf1.format(deathAvgExpectedDmgDiff) + ")" +
			TrackedStatistic.EXPECTED_DMG.getPrefixedAcronymTooltip());

		dmgDealtStatsLabel.setText(nf.format(avgDmgDealt) + " (" +
			(avgDmgDealtDiff > 0 ? "+" : "") + avgDmgDealtDiffOneDecimal + ")");
		((JPanel) dmgDealtStatsLabel.getParent()).setToolTipText("<html>Avg of " + nf1.format(avgDmgDealt) +
			" damage per fight with avg diff of " + (avgDmgDealtDiff > 0 ? "+" : "") +
			avgDmgDealtDiffOneDecimal + ".<br>On kills: " + nf1.format(killAvgDmgDealt) +
			" (" + (killAvgDmgDealtDiff > 0 ? "+" : "") + nf1.format(killAvgDmgDealtDiff) +
			"), on deaths: " + nf1.format(deathAvgDmgDealt) +
			" (" + (deathAvgDmgDealtDiff > 0 ? "+" : "") + nf1.format(deathAvgDmgDealtDiff) + ")" +
			TrackedStatistic.DMG_DEALT.getPrefixedAcronymTooltip());

		if (totalStats.getMagicHitCountExpected() >= 10000)
		{
			magicHitCountStatsLabel.setText(nfWithK(totalStats.getMagicHitCount()) + "/" +
				nfWithK((int) totalStats.getMagicHitCountExpected()));
		}
		else
		{
			magicHitCountStatsLabel.setText(totalStats.getMagicHitStats());
		}
		((JPanel) magicHitCountStatsLabel.getParent()).setToolTipText("<html>You successfully hit " +
			totalStats.getMagicHitCount() + " of " + totalStats.getMagicAttackCount() + " magic attacks, but expected to hit " +
			nf1.format(totalStats.getMagicHitCountExpected()) + ".<br>Luck percentage: 100% = expected hits, &gt;100% = lucky, &lt;100% = unlucky" +
			TrackedStatistic.MAGIC_HITS.getPrefixedAcronymTooltip());

		if (totalStats.getAttackCount() >= 10000)
		{
			offensivePrayCountStatsLabel.setText(nfWithK(totalStats.getOffensivePraySuccessCount()) + "/" +
				nfWithK(totalStats.getAttackCount()) + " (" +
				Math.round(totalStats.calculateOffensivePraySuccessPercentage()) + "%)");
		}
		else
		{
			offensivePrayCountStatsLabel.setText(totalStats.getOffensivePrayStats());
		}
		((JPanel) offensivePrayCountStatsLabel.getParent()).setToolTipText("<html>" + nf.format(totalStats.getOffensivePraySuccessCount()) + " successful offensive prayers/" +
			nf.format(totalStats.getAttackCount()) + " total attacks (" +
			nf2.format(totalStats.calculateOffensivePraySuccessPercentage()) + "%)" +
			TrackedStatistic.OFFENSIVE_PRAY.getPrefixedAcronymTooltip());

		hpHealedStatsLabel.setText(nf.format(avgHpHealed));
		((JPanel) hpHealedStatsLabel.getParent()).setToolTipText("<html>" + "A total of " + nf.format(totalStats.getHpHealed())
			+ " hitpoints were recovered, with an average of " + nf.format(avgHpHealed) + " HP per fight." +
			TrackedStatistic.HP_HEALED.getPrefixedAcronymTooltip());

		// Avg Hits on Robes label
		if (numFights > 0)
		{
			avgRobeHitsStatsLabel.setText(nf1.format(avgCompetitorRobeHits) + " / " + nf1.format(avgOpponentRobeHits));
			((JPanel) avgRobeHitsStatsLabel.getParent()).setToolTipText("<html>Average melee/range hits taken while wearing robes per fight:<br>" +
				"Player: " + nf1.format(avgCompetitorRobeHits) + " (" + nf1.format(avgCompetitorRobeHitsPercentage) + "% of melee/range hits taken were on robes)<br>" +
				"Opponent: " + nf1.format(avgOpponentRobeHits) + " (" + nf1.format(avgOpponentRobeHitsPercentage) + "% of melee/range hits taken were on robes)" +
				TrackedStatistic.ROBE_HITS.getPrefixedAcronymTooltip());
		}
		else
		{
			avgRobeHitsStatsLabel.setText("- / -");
			((JPanel) avgRobeHitsStatsLabel.getParent()).setToolTipText("No robe hits data available for calculation.");
		}

		// Set Avg KO Chance label
		if (numFightsWithKoChance > 0)
		{
			avgCompetitorKoChances = totalCompetitorKoChances / numFightsWithKoChance;
			avgOpponentKoChances = totalOpponentKoChances / numFightsWithKoChance;
			avgCompetitorKoProb = totalCompetitorKoProbSum / numFightsWithKoChance;
			avgOpponentKoProb = totalOpponentKoProbSum / numFightsWithKoChance;

			// too long of a line to include both chances & percent/sum, so only include those in tooltip
			avgKoChanceStatsLabel.setText(nf1.format(avgCompetitorKoChances) + " / " + nf1.format(avgOpponentKoChances));
			((JPanel) avgKoChanceStatsLabel.getParent())
				.setToolTipText("<html>Average KO Chances per fight:<br>Player: "
					+ nf1.format(avgCompetitorKoChances) + " (" + nfPercent.format(avgCompetitorKoProb)
					+ ")<br>Opponent: "
					+ nf1.format(avgOpponentKoChances) + " (" + nfPercent.format(avgOpponentKoProb)
					+ ")<br>Total KO Chances: Player: "
					+ nf.format(totalCompetitorKoChances) + ", Opponent: " + nf.format(totalOpponentKoChances)
					+ TrackedStatistic.KO_CHANCES.getPrefixedAcronymTooltip());
		}
		else
		{
			avgKoChanceStatsLabel.setText("- / -");
			((JPanel) avgKoChanceStatsLabel.getParent()).setToolTipText("No KO chance data available for calculation.");
		}

		ghostBarrageStatsLabel.setText(nf.format(avgGhostBarrageCount) + " G.B. (" + nf.format(avgGhostBarrageExpectedDamage) + ")");
		((JPanel) ghostBarrageStatsLabel.getParent()).setToolTipText("<html>You had an average of " + nf.format(avgGhostBarrageCount)
			+ " Ghost Barrages per fight, each worth an extra " + nf.format(avgGhostBarrageExpectedDamage)
			+ " expected damage.<br>In total, you had " + totalStats.getGhostBarrageStats() + ".<br>"
			+ "Unless fighting in PvP Arena, your opponents likely had a similar value."
			+ TrackedStatistic.GHOST_BARRAGES.getPrefixedAcronymTooltip());
	}

	// number format which adds K (representing 1,000) if the given number is over the threshold (10k),
	// with 1 decimal.
	// Ex. could turn 172,308 into 172.3k
	private String nfWithK(int number)
	{
		return nf1.format(number / 1000.0) + "k";
	}

	public void addFight(FightPerformance fight)
	{
		numFights++;

		totalStats.addAttacks(fight.getCompetitor().getOffPraySuccessCount(), fight.getCompetitor().getAttackCount(),
			fight.getCompetitor().getExpectedDamage(), fight.getCompetitor().getDamageDealt(),
			fight.getCompetitor().getMagicAttackCount(), fight.getCompetitor().getMagicHitCount(),
			fight.getCompetitor().getMagicHitCountExpected(), fight.getCompetitor().getOffensivePraySuccessCount(),
			fight.getCompetitor().getHpHealed(), fight.getCompetitor().getGhostBarrageCount(),
			fight.getCompetitor().getGhostBarrageExpectedDamage());

		// Accumulate robe hits
		totalCompetitorRobeHits += fight.getCompetitor().getRobeHits();
		totalCompetitorRobeHitsAttempted += fight.getOpponent().getAttackCount() - fight.getOpponent().getTotalMagicAttackCount();
		totalOpponentRobeHits += fight.getOpponent().getRobeHits();
		totalOpponentRobeHitsAttempted += fight.getCompetitor().getAttackCount() - fight.getCompetitor().getTotalMagicAttackCount();

		avgCompetitorRobeHits = totalCompetitorRobeHits / numFights;
		avgCompetitorRobeHitsPercentage = totalCompetitorRobeHitsAttempted != 0 ? (totalCompetitorRobeHits / totalCompetitorRobeHitsAttempted) * 100.0 : 0;
		avgOpponentRobeHits = totalOpponentRobeHits / numFights;
		avgOpponentRobeHitsPercentage = totalOpponentRobeHitsAttempted != 0 ? (totalOpponentRobeHits / totalOpponentRobeHitsAttempted) * 100.0 : 0;

		// add kill-specific or death-specific stats
		if (fight.getCompetitor().isDead())
		{
			numDeaths++;

			deathTotalExpectedDmg += fight.getCompetitor().getExpectedDamage();
			deathTotalExpectedDmgDiff += fight.getCompetitorExpectedDmgDiff();

			deathTotalDmgDealt += fight.getCompetitor().getDamageDealt();
			deathTotalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();

			deathAvgExpectedDmg = deathTotalExpectedDmg / numDeaths;
			deathAvgExpectedDmgDiff = deathTotalExpectedDmgDiff / numDeaths;

			deathAvgDmgDealt = deathTotalDmgDealt / numDeaths;
			deathAvgDmgDealtDiff = deathTotalDmgDealtDiff / numDeaths;
		}

		if (fight.getOpponent().isDead())
		{
			numKills++;

			killTotalExpectedDmg += fight.getCompetitor().getExpectedDamage();
			killTotalExpectedDmgDiff += fight.getCompetitorExpectedDmgDiff();

			killTotalDmgDealt += fight.getCompetitor().getDamageDealt();
			killTotalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();

			killAvgExpectedDmg = killTotalExpectedDmg / numKills;
			killAvgExpectedDmgDiff = killTotalExpectedDmgDiff / numKills;

			killAvgDmgDealt = killTotalDmgDealt / numKills;
			killAvgDmgDealtDiff = killTotalDmgDealtDiff / numKills;
		}

		totalExpectedDmg += fight.getCompetitor().getExpectedDamage();
		totalExpectedDmgDiff += fight.getCompetitorExpectedDmgDiff();

		totalDmgDealt += fight.getCompetitor().getDamageDealt();
		totalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();

		// calculate avg stats based on total/numFights
		avgExpectedDmg = totalExpectedDmg / numFights;
		avgExpectedDmgDiff = totalExpectedDmgDiff / numFights;

		avgDmgDealt = totalDmgDealt / numFights;
		avgDmgDealtDiff = totalDmgDealtDiff / numFights;

		avgHpHealed = (double) totalStats.getHpHealed() / numFights;

		// Calculate KO chances & sum % for this fight and add to totals
		int fightCompetitorKoChances = 0;
		double fightCompetitorSurvivalProb = 1.0;
		int fightOpponentKoChances = 0;
		double fightOpponentSurvivalProb = 1.0;
		boolean fightHasKoData = false;
		List<FightLogEntry> logs = fight.getAllFightLogEntries();
		for (FightLogEntry log : logs)
		{
			Double koChance = log.getKoChance();
			if (koChance != null)
			{
				fightHasKoData = true; // Mark that this fight has KO data
				if (log.attackerName.equals(fight.getCompetitor().getName()))
				{
					fightCompetitorKoChances++;
					fightCompetitorSurvivalProb *= (1.0 - koChance);
				}
				else
				{
					fightOpponentKoChances++;
					fightOpponentSurvivalProb *= (1.0 - koChance);
				}
			}
		}

		// Only include this fight in KO averages if it had KO data
		if (fightHasKoData)
		{
			numFightsWithKoChance++;
			totalCompetitorKoChances += fightCompetitorKoChances;
			totalOpponentKoChances += fightOpponentKoChances;
			double fightCompetitorKoProb = (fightCompetitorKoChances > 0) ? (1.0 - fightCompetitorSurvivalProb) : 0.0;
			double fightOpponentKoProb = (fightOpponentKoChances > 0) ? (1.0 - fightOpponentSurvivalProb) : 0.0;
			totalCompetitorKoProbSum += fightCompetitorKoProb;
			totalOpponentKoProbSum += fightOpponentKoProb;
		}

		// Recalculate averages using the count of fights with data
		avgCompetitorKoChances = numFightsWithKoChance != 0 ? totalCompetitorKoChances / numFightsWithKoChance : 0;
		avgOpponentKoChances = numFightsWithKoChance != 0 ? totalOpponentKoChances / numFightsWithKoChance : 0;
		avgCompetitorKoProb = numFightsWithKoChance != 0 ? totalCompetitorKoProbSum / numFightsWithKoChance : 0;
		avgOpponentKoProb = numFightsWithKoChance != 0 ? totalOpponentKoProbSum / numFightsWithKoChance : 0;

		avgGhostBarrageCount = (double) totalStats.getGhostBarrageCount() / numFights;
		avgGhostBarrageExpectedDamage = totalStats.getGhostBarrageCount() != 0 ? totalStats.getGhostBarrageExpectedDamage() / totalStats.getGhostBarrageCount() : 0;

		SwingUtilities.invokeLater(this::setLabels);
	}

	public void addFights(ArrayList<FightPerformance> fights)
	{
		if (fights == null || fights.isEmpty())
		{
			return;
		}

		numFights += fights.size();

		// Reset robe hits totals
		totalCompetitorRobeHits = 0;
		totalCompetitorRobeHitsAttempted = 0;
		totalOpponentRobeHits = 0;
		totalOpponentRobeHitsAttempted = 0;

		// Reset KO chance totals before recalculating for all fights
		totalCompetitorKoChances = 0;
		totalOpponentKoChances = 0;
		totalCompetitorKoProbSum = 0;
		totalOpponentKoProbSum = 0;
		numFightsWithKoChance = 0;

		for (FightPerformance fight : fights)
		{
			totalStats.addAttacks(fight.getCompetitor().getOffPraySuccessCount(), fight.getCompetitor().getAttackCount(),
				fight.getCompetitor().getExpectedDamage(), fight.getCompetitor().getDamageDealt(),
				fight.getCompetitor().getMagicAttackCount(), fight.getCompetitor().getMagicHitCount(),
				fight.getCompetitor().getMagicHitCountExpected(), fight.getCompetitor().getOffensivePraySuccessCount(),
				fight.getCompetitor().getHpHealed(), fight.getCompetitor().getGhostBarrageCount(),
				fight.getCompetitor().getGhostBarrageExpectedDamage());

			// Accumulate robe hits
			totalCompetitorRobeHits += fight.getCompetitor().getRobeHits();
			totalCompetitorRobeHitsAttempted += fight.getOpponent().getAttackCount() - fight.getOpponent().getTotalMagicAttackCount();
			totalOpponentRobeHits += fight.getOpponent().getRobeHits();
			totalOpponentRobeHitsAttempted += fight.getCompetitor().getAttackCount() - fight.getCompetitor().getTotalMagicAttackCount();

			if (fight.getCompetitor().isDead())
			{
				numDeaths++;

				deathTotalExpectedDmg += fight.getCompetitor().getExpectedDamage();
				deathTotalExpectedDmgDiff += fight.getCompetitorExpectedDmgDiff();

				deathTotalDmgDealt += fight.getCompetitor().getDamageDealt();
				deathTotalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();
			}
			if (fight.getOpponent().isDead())
			{
				numKills++;

				killTotalExpectedDmg += fight.getCompetitor().getExpectedDamage();
				killTotalExpectedDmgDiff += fight.getCompetitorExpectedDmgDiff();

				killTotalDmgDealt += fight.getCompetitor().getDamageDealt();
				killTotalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();
			}

			totalExpectedDmg += fight.getCompetitor().getExpectedDamage();
			totalExpectedDmgDiff += fight.getCompetitorExpectedDmgDiff();

			totalDmgDealt += fight.getCompetitor().getDamageDealt();
			totalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();

			// Calculate KO chances & sum % for this fight and add to totals if applicable
			int fightCompetitorKoChances = 0;
			double fightCompetitorSurvivalProb = 1.0;
			int fightOpponentKoChances = 0;
			double fightOpponentSurvivalProb = 1.0;
			boolean fightHasKoData = false;
			List<FightLogEntry> logs = fight.getAllFightLogEntries();
			for (FightLogEntry log : logs)
			{
				Double koChance = log.getKoChance();
				if (koChance != null)
				{
					fightHasKoData = true;
					if (log.attackerName.equals(fight.getCompetitor().getName()))
					{
						fightCompetitorKoChances++;
						fightCompetitorSurvivalProb *= (1.0 - koChance);
					}
					else
					{
						fightOpponentKoChances++;
						fightOpponentSurvivalProb *= (1.0 - koChance);
					}
				}
			}
			if (fightHasKoData)
			{
				numFightsWithKoChance++;
				totalCompetitorKoChances += fightCompetitorKoChances;
				totalOpponentKoChances += fightOpponentKoChances;
				double fightCompetitorKoProb = (fightCompetitorKoChances > 0) ? (1.0 - fightCompetitorSurvivalProb) : 0.0;
				double fightOpponentKoProb = (fightOpponentKoChances > 0) ? (1.0 - fightOpponentSurvivalProb) : 0.0;
				totalCompetitorKoProbSum += fightCompetitorKoProb;
				totalOpponentKoProbSum += fightOpponentKoProb;
			}
		}

		// Calculate average robe hits
		avgCompetitorRobeHits = numFights != 0 ? totalCompetitorRobeHits / numFights : 0;
		avgCompetitorRobeHitsPercentage = totalCompetitorRobeHitsAttempted != 0 ? (totalCompetitorRobeHits / totalCompetitorRobeHitsAttempted) * 100.0 : 0;
		avgOpponentRobeHits = numFights != 0 ? totalOpponentRobeHits / numFights : 0;
		avgOpponentRobeHitsPercentage = totalOpponentRobeHitsAttempted != 0 ? (totalOpponentRobeHits / totalOpponentRobeHitsAttempted) * 100.0 : 0;

		// Recalculate averages for all stats
		avgExpectedDmg = numFights != 0 ? totalExpectedDmg / numFights : 0;
		avgExpectedDmgDiff = numFights != 0 ? totalExpectedDmgDiff / numFights : 0;

		avgDmgDealt = numFights != 0 ? totalDmgDealt / numFights : 0;
		avgDmgDealtDiff = numFights != 0 ? totalDmgDealtDiff / numFights : 0;

		killAvgExpectedDmg = numKills != 0 ? killTotalExpectedDmg / numKills : 0;
		killAvgExpectedDmgDiff = numKills != 0 ? killTotalExpectedDmgDiff / numKills : 0;

		deathAvgExpectedDmg = numDeaths != 0 ? deathTotalExpectedDmg / numDeaths : 0;
		deathAvgExpectedDmgDiff = numDeaths != 0 ? deathTotalExpectedDmgDiff / numDeaths : 0;

		killAvgDmgDealt = numKills != 0 ? killTotalDmgDealt / numKills : 0;
		killAvgDmgDealtDiff = numKills != 0 ? killTotalDmgDealtDiff / numKills : 0;

		deathAvgDmgDealt = numDeaths != 0 ? deathTotalDmgDealt / numDeaths : 0;
		deathAvgDmgDealtDiff = numDeaths != 0 ? deathTotalDmgDealtDiff / numDeaths : 0;

		avgHpHealed = numFights != 0 ? (double) totalStats.getHpHealed() / numFights : 0;

		// Recalculate KO averages using the count of fights with data
		avgCompetitorKoChances = numFightsWithKoChance != 0 ? totalCompetitorKoChances / numFightsWithKoChance : 0;
		avgOpponentKoChances = numFightsWithKoChance != 0 ? totalOpponentKoChances / numFightsWithKoChance : 0;
		avgCompetitorKoProb = numFightsWithKoChance != 0 ? totalCompetitorKoProbSum / numFightsWithKoChance : 0;
		avgOpponentKoProb = numFightsWithKoChance != 0 ? totalOpponentKoProbSum / numFightsWithKoChance : 0;

		avgGhostBarrageCount = numFights != 0 ? (double) totalStats.getGhostBarrageCount() / numFights : 0;
		avgGhostBarrageExpectedDamage = totalStats.getGhostBarrageCount() != 0 ? totalStats.getGhostBarrageExpectedDamage() / totalStats.getGhostBarrageCount() : 0;

		SwingUtilities.invokeLater(this::setLabels);
	}

	public void reset()
	{
		numFights = 0;
		numDeaths = 0;
		numKills = 0;

		totalExpectedDmg = 0;
		totalExpectedDmgDiff = 0;
		killTotalExpectedDmg = 0;
		killTotalExpectedDmgDiff = 0;
		deathTotalExpectedDmg = 0;
		deathTotalExpectedDmgDiff = 0;
		totalDmgDealt = 0;
		totalDmgDealtDiff = 0;
		killTotalDmgDealt = 0;
		killTotalDmgDealtDiff = 0;
		deathTotalDmgDealt = 0;
		deathTotalDmgDealtDiff = 0;

		avgExpectedDmg = 0;
		avgExpectedDmgDiff = 0;
		killAvgExpectedDmg = 0;
		killAvgExpectedDmgDiff = 0;
		deathAvgExpectedDmg = 0;
		deathAvgExpectedDmgDiff = 0;
		avgDmgDealt = 0;
		avgDmgDealtDiff = 0;
		killAvgDmgDealt = 0;
		killAvgDmgDealtDiff = 0;
		deathAvgDmgDealt = 0;
		deathAvgDmgDealtDiff = 0;

		avgHpHealed = 0;

		totalCompetitorRobeHits = 0;
		totalCompetitorRobeHitsAttempted = 0;
		totalOpponentRobeHits = 0;
		totalOpponentRobeHitsAttempted = 0;
		avgCompetitorRobeHits = 0;
		avgCompetitorRobeHitsPercentage = 0;
		avgOpponentRobeHits = 0;
		avgOpponentRobeHitsPercentage = 0;

		// Reset KO chance stats
		totalCompetitorKoChances = 0;
		totalOpponentKoChances = 0;
		totalCompetitorKoProbSum = 0;
		totalOpponentKoProbSum = 0;
		avgCompetitorKoChances = 0;
		avgOpponentKoChances = 0;
		avgCompetitorKoProb = 0;
		avgOpponentKoProb = 0;
		numFightsWithKoChance = 0; // Reset new counter

		avgGhostBarrageCount = 0;
		avgGhostBarrageExpectedDamage = 0;

		totalStats = new Fighter("Player");
		SwingUtilities.invokeLater(this::setLabels);
	}

	public void setConfigWarning(boolean enable)
	{
		if (enable)
		{
			setLayout(new GridLayout(LAYOUT_ROWS_WITH_WARNING, 1));

			if (settingsWarningLabel == null)
			{
				initializeSettingsWarningLabel();
			}
			add(settingsWarningLabel, 1);
		}
		else
		{
			if (getComponentCount() > LAYOUT_ROWS_WITHOUT_WARNING)
			{
				remove(settingsWarningLabel);
				settingsWarningLabel = null;
			}
			setLayout(new GridLayout(LAYOUT_ROWS_WITHOUT_WARNING, 1));
		}

		validate();
	}

	private void initializeSettingsWarningLabel()
	{
		settingsWarningLabel = new JLabel();
		settingsWarningLabel.setText("Check plugin config for setup options!");
		settingsWarningLabel.setToolTipText("Please verify that the plugin options are configured according to your needs in the plugin's Configuration Panel.");
		settingsWarningLabel.setForeground(Color.RED);

		// make the warning font bold & smaller font size so we can fit more text.
		Font newFont = settingsWarningLabel.getFont();
		newFont = newFont.deriveFont(newFont.getStyle() | Font.BOLD, 12f);
		settingsWarningLabel.setFont(newFont);

		settingsWarningLabel.setHorizontalAlignment(SwingConstants.CENTER);
	}
}

/*
 * Copyright (c)  2020, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import matsyir.pvpperformancetracker.controllers.AnalyzedFightPerformance;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.controllers.Fighter;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;

import matsyir.pvpperformancetracker.models.TrackedStatistic;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

// Panel to display fight performance. The first line shows player stats while the second is the opponent.
// There is a skull icon beside a player's name if they died. The usernames are fixed to the left and the
// stats are fixed to the right.

public class FightPerformancePanel extends JPanel
{
	private static ImageIcon deathIcon;
	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("HH:mm:ss 'on' yyyy/MM/dd");
	private static final Border normalBorder;
	private static final Border hoverBorder;

	static
	{
		// main border used when not hovering:
		// outer border: matte border with 4px bottom, with same color as the panel behind FightPerformancePanels. Used as invisible 4px offset
		// inner border: padding for the inner content of the panel.
		normalBorder = BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 4, 0, ColorScheme.DARK_GRAY_COLOR),
			new EmptyBorder(4, 6, 4, 6));

		// border used while hovering:
		// outer border: matte border with 4px bottom, with same color as the panel behind FightPerformancePanels. Used as invisible 4px offset
		// "middle" border: outline for the main panel
		// inner border: padding for the inner content of the panel, reduced by 1px to account for the outline
		hoverBorder = BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 4, 0, ColorScheme.DARK_GRAY_COLOR),
			BorderFactory.createCompoundBorder(
				BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
				new EmptyBorder(3, 5, 3, 5)));
	}

	private AnalyzedFightPerformance analyzedFight;
	private boolean showBorders;

	// Panel to display previous fight performance data.
	// intended layout:
	//
	// Player name ; 									Opponent Name
	// Player off-pray hit stats ; 						Opponent off-pray hit stats
	// Player expected dps stats ; 						Opponent expected dps stats
	// Player damage dealt ; 							Opponent damage dealt
	// Player magic hits/expected magic hits ; 			Opponent magic hits/expected magic hits
	// Player offensive pray stats ; 					N/A (no data, client only)
	// Player hp healed ; 								N/A (no data, client only)
	// Player Hits on robes ;							Opponent Hits on robes
	// Player Total KO Chances ;						Opponent Total KO Chances
	// Player Ghost barrages & extra expected damage ; 	N/A (no data, client only)
	// The greater stats will be highlighted green. In this example, the player would have all the green highlights.
	// example:
	//
	//     PlayerName      OpponentName
	//	   32/55 (58%)      28/49 (57%) // off-pray
	//     176 (+12)          164 (-12) // expected
	//     156 (-28)          184 (+28) // dealt
	//     10/16 (92.7)   12/20 (80.7%) // expected magic
	//     27/55 (49%)              N/A // offensive pray
	//     100                      N/A // hp healed
	//	   11/31 (35.5%)  13/34 (38.2%) // hits on robes
	//     2 (110.0%)         1 (65.0%) // ko chances
	//     4 G.B. (37)				N/A // ghost barrages
	//
	// these are the params to use for a normal panel.
	public FightPerformancePanel(FightPerformance fight)
	{
		this(fight, true, true, false, null);
	}

	public FightPerformancePanel(FightPerformance fight, boolean showActions, boolean showBorders, boolean showOpponentClientStats, FightPerformance oppFight)
	{
		this.showBorders = showBorders;
		if (deathIcon == null)
		{
			// load & rescale red skull icon used to show if a player/opponent died in a fight and as the frame icon.
			deathIcon = new ImageIcon(PLUGIN_ICON.getScaledInstance(12, 12, Image.SCALE_DEFAULT));
		}

		// save Fighters temporarily for more direct access
		Fighter competitor = fight.getCompetitor();
		Fighter opponent = fight.getOpponent();

		setLayout(new BorderLayout(5, 0));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		String baseTooltipText = competitor.getName() + " vs. " + opponent.getName() + (fight.getWorld() > 0 ? (" (W" + fight.getWorld()) + ")" : "") +
			": This fight ended at " + DATE_FORMAT.format(Date.from(Instant.ofEpochMilli(fight.getLastFightTime())));
		setToolTipText(baseTooltipText);

		if (showBorders)
		{
			setBorder(normalBorder);
		}

		ArrayList<JPanel> panelLines = new ArrayList<JPanel>();

		// boxlayout panel to hold each of the lines.
		JPanel fightPanel = new JPanel();
		fightPanel.setLayout(new BoxLayout(fightPanel, BoxLayout.Y_AXIS));
		fightPanel.setBackground(null);

		// FIRST LINE: both player names, with centered world label
		JPanel playerNamesLine = new JPanel(new BorderLayout())
		{
			@Override
			protected void paintComponent(Graphics g)
			{
				super.paintComponent(g);
				if (CONFIG.showWorldInSummary() && fight.getWorld() > 0)
				{
					String w = "W" + fight.getWorld();
					FontMetrics fm = g.getFontMetrics(getFont());
					int x = (getWidth() - fm.stringWidth(w)) / 2;
					int y = (getHeight() + fm.getAscent()) / 2 - fm.getDescent();
					g.setColor(Color.LIGHT_GRAY);
					g.drawString(w, x, y);
				}
			}
		};
		playerNamesLine.setBackground(null);

		// player names
		JLabel playerStatsName = new JLabel();

		// player name LEFT: player name
		if (competitor.isDead())
		{
			playerStatsName.setIcon(deathIcon);
		}
		playerStatsName.setText(competitor.getName());
		playerStatsName.setForeground(Color.WHITE);
		playerNamesLine.add(playerStatsName, BorderLayout.WEST);

		// player name RIGHT: opponent name
		JLabel opponentStatsName = new JLabel();
		if (opponent.isDead())
		{
			opponentStatsName.setIcon(deathIcon);
		}
		opponentStatsName.setText(opponent.getName());
		opponentStatsName.setForeground(Color.WHITE);
		playerNamesLine.add(opponentStatsName, BorderLayout.EAST);
		playerNamesLine.setToolTipText(baseTooltipText);

		panelLines.add(playerNamesLine);

		boolean showGhostBarrages = competitor.getGhostBarrageCount() > 0 || opponent.getGhostBarrageCount() > 0;
		for (TrackedStatistic stat : TrackedStatistic.values())
		{
			if (stat == TrackedStatistic.GHOST_BARRAGES && !showGhostBarrages)
			{
				continue;
			}

			panelLines.add(stat.getPanelComponent(fight, oppFight));
		}

		// setup mouse events for hovering and clicking to open the fight log
		MouseAdapter fightPerformanceMouseListener = new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				setFullBackgroundColor(ColorScheme.DARK_GRAY_COLOR);
				setOutline(true);
				setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setFullBackgroundColor(ColorScheme.DARKER_GRAY_COLOR);
				setOutline(false);
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}

			@Override
			public void mouseClicked(MouseEvent e)
			{
				// ignore right clicks since that should be used for context menus/popup menus.
				// btn1: left click, btn2: middle click, btn3: right click
				if (e.getButton() == MouseEvent.BUTTON3)
				{
					return;
				}

				FightLogFrame.createFightLogFrame(fight, analyzedFight, getRootPane());
			}
		};
		addMouseListener(fightPerformanceMouseListener);

		// skip the remaining code if we aren't showing actions.
		if (!showActions)
		{
			return;
		}

		JPopupMenu popupMenu = new JPopupMenu();

		// Create "Show fight log" menu (same action as left click)
		final JMenuItem displayFightLog = new JMenuItem("Display Fight Log");
		displayFightLog.addActionListener(e -> FightLogFrame.createFightLogFrame(fight, analyzedFight, getRootPane()));

		// Create "Show attack summary" menu
		final JMenuItem displayAttackSummary = new JMenuItem("Display Attack Summary");
		displayAttackSummary.addActionListener(e -> AttackSummaryFrame.createAttackSummaryFrame(fight, getRootPane()));

		// Create "Copy Fight Data" popup menu/context menu
		final JMenuItem copyFight = new JMenuItem("Copy Fight Data (Advanced)");
		copyFight.addActionListener(e -> PLUGIN.exportFight(fight));
		copyFight.setForeground(ColorScheme.BRAND_ORANGE);

		final JMenuItem openFightAnalysis = new JMenuItem("Fight Analysis (Advanced)");
		openFightAnalysis.addActionListener(e -> new FightAnalysisFrame(fight, this.getRootPane()));
		openFightAnalysis.setForeground(ColorScheme.BRAND_ORANGE);

		// Create "Remove Fight" popup menu/context menu
		final JMenuItem removeFight = new JMenuItem("Remove Fight");
		removeFight.addActionListener(e ->
		{
			int dialogResult = JOptionPane.showConfirmDialog(this, "Are you sure you want to remove this fight? This cannot be undone.", "Warning", JOptionPane.YES_NO_OPTION);
			if (dialogResult == JOptionPane.YES_OPTION)
			{
				PLUGIN.removeFight(fight);
			}
		});
		removeFight.setForeground(Color.RED);

		popupMenu.add(displayFightLog);
		popupMenu.add(displayAttackSummary);
		popupMenu.add(copyFight);
		popupMenu.add(openFightAnalysis);
		popupMenu.add(removeFight);
		setComponentPopupMenu(popupMenu);

		for (JPanel line : panelLines)
		{
			fightPanel.add(line);
			line.addMouseListener(fightPerformanceMouseListener);
			line.setComponentPopupMenu(popupMenu);
		}

		add(fightPanel, BorderLayout.NORTH);

		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, (int) getPreferredSize().getHeight()));
	}

	public FightPerformancePanel(AnalyzedFightPerformance aFight)
	{
		this(aFight, false, true, true, aFight.getOpposingFight());

		this.analyzedFight = aFight;
	}

	private void setFullBackgroundColor(Color color)
	{
		this.setBackground(color);
		for (Component c : getComponents())
		{
			c.setBackground(color);
		}
	}

	private void setOutline(boolean visible)
	{
		if (showBorders)
		{
			this.setBorder(visible ? hoverBorder : normalBorder);
		}
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker;

import lombok.Getter;
import matsyir.pvpperformancetracker.models.RangeAmmoData;
import matsyir.pvpperformancetracker.models.RingData;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("pvpperformancetracker")
public interface PvpPerformanceTrackerConfig extends Config
{
	/**
	 * Filter for hits on robes statistic.
	 */
	enum RobeHitFilter
	{
		BOTTOM,
		TOP,
		BOTH,
		EITHER
	}

	int LEVEL_MIN = 1;
	int LEVEL_MAX = 120;

	// ================================= Sections =================================

	@ConfigSection(name = "Overlay (5 lines max)",
		description = "Contains overlay settings (MAX of 5 lines allowed)",
		position = 2000,
		closedByDefault = true
	)
	String overlay = "overlay";

	@ConfigSection(name = "Gear/Ammo",
		description = "Contains gear/ammo settings for fights outside LMS",
		position = 11000,
		closedByDefault = false
	)
	String gearAmmo = "gearAmmo";

	@ConfigSection(name = "Levels",
		description = "Contains level settings for fights outside of LMS (including boosts)",
		position = 15000,
		closedByDefault = false
	)
	String levels = "levels";

	// ================================= General =================================

	@ConfigItem(
		keyName = "pluginVersion",
		name = "Plugin Version",
		description = "Hidden plugin version in order to potentially 'gracefully migrate' data in the future.",
		hidden = true
	)
	default String pluginVersion()
	{
		return PvpPerformanceTrackerPlugin.PLUGIN_VERSION;
	}

	@ConfigItem(
		keyName = "settingsConfigured",
		name = "I have verified my settings",
		description = "Some settings affect damage calculations, and every player should set them based on how they're pking." +
			"<br>Please confirm them and tick this box in order to hide the config warning.",
		position = -1
	)
	default boolean settingsConfigured()
	{
		return false;
	}

	@ConfigItem(
		keyName = "restrictToLms",
		name = "Restrict to LMS",
		description = "Restricts functionality and visibility to the LMS areas & its lobby (Ferox Enclave)." +
			"<br>WARNING: can be inaccurate outside LMS, as every attack animation's combat style must be manually mapped.",
		position = 100
	)
	default boolean restrictToLms()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showFightHistoryPanel",
		name = "Show Fight History Panel",
		description = "Enables the side-panel which displays previous fight's statistics.",
		position = 1000
	)
	default boolean showFightHistoryPanel()
	{
		return true;
	}

	@ConfigItem(
		keyName = "robeHitFilter",
		name = "Hits on Robes Filter",
		description = "Which part of the robe to count hits on: bottom, top, both, or either.",
		position = 1100
	)
	default RobeHitFilter robeHitFilter()
	{
		return RobeHitFilter.EITHER;
	}

	// ================================= Overlay =================================

	@ConfigItem(
		keyName = "showFightOverlay",
		name = "Show Fight Overlay",
		description = "Display an overlay of statistics while fighting.",
		position = 2000,
		section = overlay
	)
	default boolean showFightOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayTitle",
		name = "Overlay: Show Title",
		description = "The overlay will have a title to display that it is PvP Performance.",
		position = 4000,
		section = overlay
	)
	default boolean showOverlayTitle()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayNames",
		name = "Overlay: Show Names",
		description = "The overlay will display names.<br>Max. of 5 lines on the overlay",
		position = 5000,
		section = overlay
	)
	default boolean showOverlayNames()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayOffPray",
		name = "Overlay: Show Off-Pray",
		description = "The overlay will display off-pray stats as a fraction & percentage.<br>Max. of 5 lines on the overlay",
		position = 6000,
		section = overlay
	)
	default boolean showOverlayOffPray()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayDeservedDmg", // Not renaming this key so users keep their config.
		name = "Overlay: Show Expected Dmg", // Note: Used to be called Deserved Damage.
		description = "The overlay will display expected damage & difference.<br>Max. of 5 lines on the overlay",
		position = 7000,
		section = overlay
	)
	default boolean showOverlayExpectedDmg()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayDmgDealt",
		name = "Overlay: Show Dmg Dealt",
		description = "The overlay will display damage dealt.<br>Max. of 5 lines on the overlay",
		position = 8000,
		section = overlay
	)
	default boolean showOverlayDmgDealt()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayMagicHits",
		name = "Overlay: Show Magic Hits",
		description = "The overlay will display successful magic hits & expected magic hits.<br>Max. of 5 lines on the overlay",
		position = 9000,
		section = overlay
	)
	default boolean showOverlayMagicHits()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayOffensivePray",
		name = "Overlay: Show Offensive Pray",
		description = "The overlay will display offensive pray stats.<br>Max. of 5 lines on the overlay",
		position = 10000,
		section = overlay
	)
	default boolean showOverlayOffensivePray()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayHpHealed",
		name = "Overlay: Show HP Healed",
		description = "The overlay will display hitpoints healed.<br>Max. of 5 lines on the overlay",
		position = 10500,
		section = overlay
	)
	default boolean showOverlayHpHealed()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayRobeHits",
		name = "Overlay: Show Hits on Robes",
		description = "The overlay will display hits on robes ratio (melee & ranged attacks).<br>Max. of 5 lines on the overlay",
		position = 10700,
		section = overlay
	)
	default boolean showOverlayRobeHits()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayTotalKoChance",
		name = "Overlay: Show Total KO Chance",
		description = "The overlay will display total KO chances and sum percentage.<br>Max. of 5 lines on the overlay",
		position = 10800,
		section = overlay
	)
	default boolean showOverlayTotalKoChance()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayLastKoChance",
		name = "Overlay: Show Last KO Chance",
		description = "The overlay will display the last KO chance percentage.<br>Max. of 5 lines on the overlay",
		position = 10900,
		section = overlay
	)
	default boolean showOverlayLastKoChance()
	{
		return false;
	}

	@ConfigItem(
			keyName = "showOverlayGhostBarrage",
			name = "Overlay: Show Ghost Barrage",
			description = "(Advanced): The overlay will display ghost barrage stats.<br>Max. of 5 lines on the overlay",
			position = 10950,
			section = overlay
	)
	default boolean showOverlayGhostBarrage()
	{
		return false;
	}

	// ================================= Gear/Ammo =================================

	@ConfigItem(
		keyName = "ringChoice",
		name = "Ring Used",
		description = "Rings used for the expected damage calculations outside of LMS.",
		position = 11000,
		section = gearAmmo
	)
	default RingData ringChoice()
	{
		return RingData.BERSERKER_RING;
	}

	@ConfigItem(
		keyName = "boltChoice",
		name = "RCB Ammo",
		description = "Bolts used for rune crossbow's expected damage calculation." +
			"<br>LMS fights always use diamond (e). Dragonfire protection not accounted for.",
		position = 12000,
		section = gearAmmo
	)
	default RangeAmmoData.BoltAmmo boltChoice()
	{
		return RangeAmmoData.BoltAmmo.DIAMOND_BOLTS_E;
	}

	@ConfigItem(
		keyName = "strongBoltChoice",
		name = "ACB/DCB/DHCB Ammo",
		description = "Bolts used for ACB/DCB/DHCB's expected damage calculation." +
			"<br>LMS fights always use regular diamond (e). Dragonfire protection not accounted for.",
		position = 13000,
		section = gearAmmo
	)
	default RangeAmmoData.StrongBoltAmmo strongBoltChoice()
	{
		return RangeAmmoData.StrongBoltAmmo.DIAMOND_DRAGON_BOLTS_E;
	}

	@ConfigItem(
		keyName = "bpDartChoice",
		name = "Blowpipe Ammo",
		description = "Darts used for blowpipe expected damage calculation.",
		position = 14000,
		section = gearAmmo
	)
	default RangeAmmoData.DartAmmo bpDartChoice()
	{
		return RangeAmmoData.DartAmmo.DRAGON_DARTS;
	}

	// ================================= Levels =================================

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "attackLevel",
		name = "Attack Level",
		description = "Attack level used for the expected damage calculations outside of LMS (includes potion boost).",
		position = 16000,
		section = levels
	)
	default int attackLevel()
	{
		return 118;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "strengthLevel",
		name = "Strength Level",
		description = "Strength level used for the expected damage calculations outside of LMS (includes potion boost).",
		position = 17000,
		section = levels
	)
	default int strengthLevel()
	{
		return 118;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "defenceLevel",
		name = "Defence Level",
		description = "Defence level used for the expected damage calculations outside of LMS (includes potion boost).",
		position = 18000,
		section = levels
	)
	default int defenceLevel()
	{
		return 120;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "rangedLevel",
		name = "Ranged Level",
		description = "Ranged level used for the expected damage calculations outside of LMS (includes potion boost).",
		position = 19000,
		section = levels
	)
	default int rangedLevel()
	{
		return 112;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "magicLevel",
		name = "Magic Level",
		description = "Magic level used for the expected damage calculations outside of LMS (includes potion boost).",
		position = 20000,
		section = levels
	)
	default int magicLevel()
	{
		return 99;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "opponentHitpointsLevel",
		name = "Opponent HP Level",
		description = "Assumed Hitpoints level for opponents when calculating KO chance.",
		position = 20100, // Place it after other levels
		section = levels
	)
	default int opponentHitpointsLevel()
	{
		return 99; // Default to 99 HP
	}

	// ================================= Misc/Less-Used-General =================================

	@Range(
		min = 1,
		max = 1000
	)
	@ConfigItem(
		keyName = "fightHistoryRenderLimit",
		name = "Max Rendered Fights",
		description = "Maximum number of previous fights to be displayed and searchable in the fight history side-panel." +
			"<br>WILL cause lag spikes at very high numbers. This should be small if you have low RAM",
		position = 20500
	)
	default int fightHistoryRenderLimit()
	{
		return 200;
	}

	@Range(
		max = 1000000
	)
	@ConfigItem(
		keyName = "fightHistoryLimit",
		name = "Max Saved Fights",
		description = "Maximum number of previous fights to be saved to a local file and used for total/avg stats." +
			"<br>0 means unlimited. May cause lag spikes at extreme numbers on low-end PCs",
		position = 21000
	)
	default int fightHistoryLimit()
	{
		return 10000;
	}

	@ConfigItem(
		keyName = "exactNameFilter",
		name = "Exact Name Filter",
		description = "Makes the username filter look for an exact match (case-insensitive), rather than any name starting with the filter.",
		position = 22000
	)
	default boolean exactNameFilter()
	{
		return false;
	}

	@ConfigItem(
		keyName = "dlongIsVls",
		name = "Dlong = VLS",
		description = "Track Dragon Longsword & its spec as a Vesta's Longsword for expected damage." +
			"<br>Requested/used for for DMM practice purposes.",
		position = 23000
	)
	default boolean dlongIsVls()
	{
		return true;
	}

	@ConfigItem(
		keyName = "fightLogInChat",
		name = "Fight Log In Chat",
		description = "Display basic fight logs in trade chat during a fight." +
			"<br><strong>This is very excessive, mostly for testing/verification.<strong>",
		position = 50000
	)
	default boolean fightLogInChat()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showWorldInSummary",
		name = "Show World in Summary",
		description = "Display the world number between names in the summary panel.",
		position = 51000
	)
	default boolean showWorldInSummary()
	{
		return true;
	}

	@ConfigItem(
		keyName = "nameFilter",
		name = "Name Filter",
		description = "Hidden config used to save user's selected name/RSN filter for the panel views.",
		position = 100000,
		hidden = true
	)
	default String nameFilter()
	{
		return "";
	}


	// ================================= On-update flags for chat message update summaries =================================
	String updateMsgKey = "updateMsgShown1_7_1";
	@ConfigItem(
			keyName = updateMsgKey, // for 1.7.0 -> 1.7.1
			name = "Update Msg 1.7.0->1.7.1 ~Sept12 2025",
			description = "Tracks if the update chat message for 1.7.1 has been shown.",
			hidden = true
	)
	default boolean updateMsgShown1_7_1()
	{
		return false;
	}
}

/*
 * Copyright (c)  2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.controllers;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils.fixItemId;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.EquipmentData;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.kit.KitType;
import net.runelite.api.GraphicID;

@Slf4j
@Getter
public
class Fighter
{
	private static final NumberFormat nf = NumberFormat.getInstance();
	static // initialize number format
	{
		nf.setMaximumFractionDigits(1);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}

	// Target graphics IDs indicating special attacks
	private static final int GFX_TARGET_DBOW_SPEC = 1100;   // dragon-arrow gfx on target
	private static final int GFX_TARGET_DCBOW_SPEC = 157;    // Annihilate AOE gfx on target

	@Setter
	private Player player;
	@Expose
	@SerializedName("n") // use 1 letter serialized variable names for more compact storage
	private String name; // username
	@Expose
	@SerializedName("a")
	private int attackCount; // total number of attacks
	@Expose
	@SerializedName("s")
	private int offPraySuccessCount; // total number of successful off-pray attacks
									 // (when you use a different combat style than your opponent's overhead)
	@Expose
	@SerializedName("d") // NOTE: previously referred to as "Deserved damage"
	private double expectedDamage; // total expected damage based on gear & opponent's pray
	@Expose
	@SerializedName("h") // h for "hitsplats", real hits
	private int damageDealt; // actual damage dealt based on opponent's hitsplats

	@Expose
	@SerializedName("z") // z because idk and want to keep 1 character for most compact storage
	private int totalMagicAttackCount; // total count of magic attacks
	@Expose
	@SerializedName("m")
	private int magicHitCount; // count of 'successful' magic hits (where you don't splash)
	@Expose
	@SerializedName("M")
	private double magicHitCountExpected; // cumulative magic accuracy percentage for each attack

	@Expose
	@SerializedName("p")
	private int offensivePraySuccessCount;

	@Expose
	@SerializedName("g")
	private int ghostBarrageCount;
	@Expose
	@SerializedName("y")
	private double ghostBarrageExpectedDamage;

	@Expose
	@SerializedName("H")
	private int hpHealed;

	@Expose
	@SerializedName("rh") // robe hits
	private int robeHits = 0;

	@Expose
	@SerializedName("x") // x for X_X
	private boolean dead; // will be true if the fighter died in the fight

	@Expose
	@SerializedName("l")
	private ArrayList<FightLogEntry> fightLogEntries;

	private PvpDamageCalc pvpDamageCalc;
	private int lastGhostBarrageCheckedTick = -1;
	@Setter
	private int lastGhostBarrageCheckedMageXp = -1;

	@Getter
	private transient Queue<FightLogEntry> pendingAttacks;

	// fighter that is bound to a player and gets updated during a fight
	Fighter(FightPerformance fight, Player player)
	{
		this.player = player;
		name = player.getName();
		attackCount = 0;
		offPraySuccessCount = 0;
		expectedDamage = 0;
		damageDealt = 0;
		totalMagicAttackCount = 0;
		magicHitCount = 0;
		magicHitCountExpected = 0;
		offensivePraySuccessCount = 0;
		dead = false;
		pvpDamageCalc = new PvpDamageCalc(fight);
		fightLogEntries = new ArrayList<>();
		pendingAttacks = new LinkedList<>();
	}

	// fighter for merging fight logs together for detailed data (fight analysis)
	Fighter(FightPerformance fight, String name, ArrayList<FightLogEntry> logs)
	{
		player = null;
		this.name = name;
		attackCount = 0;
		offPraySuccessCount = 0;
		expectedDamage = 0;
		damageDealt = 0;
		totalMagicAttackCount = 0;
		magicHitCount = 0;
		magicHitCountExpected = 0;
		dead = false;
		pvpDamageCalc = new PvpDamageCalc(fight);
		fightLogEntries = logs;
		pendingAttacks = new LinkedList<>();
	}

	// create a basic Fighter to only hold stats, for the TotalStatsPanel,
	// but not actually updated during a fight.
	public Fighter(String name)
	{
		player = null;
		this.name = name;
		attackCount = 0;
		offPraySuccessCount = 0;
		expectedDamage = 0;
		damageDealt = 0;
		totalMagicAttackCount = 0;
		magicHitCount = 0;
		magicHitCountExpected = 0;
		dead = false;
		pvpDamageCalc = null;
		fightLogEntries = new ArrayList<>();
		pendingAttacks = new LinkedList<>();
	}

	// Fighter for AnalyzedFightPerformance
	public Fighter(FightPerformance fight, String name)
	{
		this(name);
		pvpDamageCalc = new PvpDamageCalc(fight);
	}

	// add an attack to the counters depending if it is successful or not.
	// also update the success rate with the new counts.
	// Used for regular, ongoing fights
	void addAttack(Player opponent, AnimationData animationData, int offensivePray)
	{
		addAttack(opponent, animationData, offensivePray, null);
	}

	// Levels can be null
	void addAttack(Player opponent, AnimationData animationData, int offensivePray, CombatLevels levels)
	{
		int[] attackerItems = player.getPlayerComposition().getEquipmentIds();

		// correct re-used animations into their separate AnimationData so it uses the correct attack style
		// for overhead success & accuracy calcs
		EquipmentData weapon = EquipmentData.fromId(fixItemId(attackerItems[KitType.WEAPON.getIndex()]));

		boolean successful = opponent.getOverheadIcon() != animationData.attackStyle.getProtection();

		// Granite Maul specific handling
		boolean isGmaulSpec = animationData == AnimationData.MELEE_GRANITE_MAUL_SPEC;

		// --- Detect dark bow & dragon crossbow specials via GFX ---
		if (weapon == EquipmentData.DARK_BOW && animationData == AnimationData.RANGED_SHORTBOW)
		{
			boolean spec = opponent.getGraphic() == GFX_TARGET_DBOW_SPEC;

			animationData = spec ? AnimationData.RANGED_DARK_BOW_SPEC : AnimationData.RANGED_DARK_BOW;
		}
		else if (weapon == EquipmentData.DRAGON_CROSSBOW &&
				(animationData == AnimationData.RANGED_CROSSBOW_PVP || animationData == AnimationData.RANGED_RUNE_CROSSBOW))
		{
			boolean spec = opponent.getGraphic() == GFX_TARGET_DCBOW_SPEC;

			if (spec)
			{
				animationData = AnimationData.RANGED_DRAGON_CROSSBOW_SPEC;
			}
			}

		attackCount++;
		if (successful)
		{
			offPraySuccessCount++;
		}
		if (animationData.attackStyle.isUsingSuccessfulOffensivePray(offensivePray))
		{
			offensivePraySuccessCount++;
		}

		// track dragon longsword as VLS if enabled, for dmm practice purposes.
		// also check if weapon = VLS because the itemId stays as VLS if they don't switch weapons between
		// attacks, but we still need to update the animationData in case it's actually a dlong.
		if (CONFIG.dlongIsVls() && weapon == EquipmentData.DRAGON_LONGSWORD || weapon == EquipmentData.VESTAS_LONGSWORD)
		{
			// modifying attackerItems will modify the actual playerComposition, so future
			// .getPlayerComposition().getEquipmentIds() calls will also be modified
			attackerItems[KitType.WEAPON.getIndex()] = EquipmentData.VESTAS_LONGSWORD.getItemId() + PlayerComposition.ITEM_OFFSET;
			animationData = animationData.isSpecial ? AnimationData.MELEE_VLS_SPEC : AnimationData.MELEE_SCIM_SLASH;
		}

		pvpDamageCalc.updateDamageStats(player, opponent, successful, animationData);
		expectedDamage += pvpDamageCalc.getAverageHit();

		if (animationData.attackStyle == AnimationData.AttackStyle.MAGIC)
		{
			totalMagicAttackCount++;
			magicHitCountExpected += pvpDamageCalc.getAccuracy();

			if (opponent.getGraphic() != GraphicID.SPLASH)
			{
				magicHitCount++;
			}
		}

		FightLogEntry fightLogEntry = new FightLogEntry(player, opponent, pvpDamageCalc, offensivePray, levels, animationData);
		fightLogEntry.setGmaulSpecial(isGmaulSpec);
		if (PvpPerformanceTrackerPlugin.CONFIG.fightLogInChat())
		{
			PvpPerformanceTrackerPlugin.PLUGIN.sendTradeChatMessage(fightLogEntry.toChatMessage());
		}
		fightLogEntries.add(fightLogEntry);
		pendingAttacks.add(fightLogEntry);
	}

	// add an attack from fight log, without player references, for merging fight logs (fight analysis)
	void addAttack(FightLogEntry logEntry, FightLogEntry defenderLog)
	{
		attackCount++;
		if (logEntry.success())
		{
			offPraySuccessCount++;
		}
		if (logEntry.getAnimationData().attackStyle.isUsingSuccessfulOffensivePray(logEntry.getAttackerOffensivePray()))
		{
			offensivePraySuccessCount++;
		}

		pvpDamageCalc.updateDamageStats(logEntry, defenderLog);
		expectedDamage += pvpDamageCalc.getAverageHit();

		if (logEntry.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC)
		{
			totalMagicAttackCount++;
			magicHitCountExpected += pvpDamageCalc.getAccuracy();
			// actual magicHitCount is directly added, as it can no longer
			// be detected and should have been accurate initially.
		}

		fightLogEntries.add(new FightLogEntry(logEntry, pvpDamageCalc));
	}

	public void addGhostBarrage(boolean successful, Player opponent, AnimationData animationData, int offensivePray, CombatLevels levels)
	{
		int currentTick = PLUGIN.getClient().getTickCount();
		if (currentTick <= lastGhostBarrageCheckedTick)
		{
			return;
		}
		lastGhostBarrageCheckedTick = currentTick;

		pvpDamageCalc.updateDamageStats(player, opponent, successful, animationData);

		ghostBarrageCount++;
		ghostBarrageExpectedDamage += pvpDamageCalc.getAverageHit();

		// TODO: Create separate FightLog array for ghost barrages and include those in fight log table
		// ^^^ also so they could be used in fight analysis/merge. Unused params will be used for this
	}

	// used to manually build Fighters in AnalyzedFightPerformance.
	public void setTotalGhostBarrageStats(int ghostBarrageCount, double ghostBarrageExpectedDamage)
	{
		this.ghostBarrageCount = ghostBarrageCount;
		this.ghostBarrageExpectedDamage = ghostBarrageExpectedDamage;
	}

	// this is to be used from the TotalStatsPanel which saves a total of multiple fights.
	public void addAttacks(int success, int total, double expectedDamage, int damageDealt, int totalMagicAttackCount, int magicHitCount, double magicHitCountExpected, int offensivePraySuccessCount, int hpHealed, int ghostBarrageCount, double ghostBarrageExpectedDamage)
	{
		offPraySuccessCount += success;
		attackCount += total;
		this.expectedDamage += expectedDamage;
		this.damageDealt += damageDealt;
		this.totalMagicAttackCount += totalMagicAttackCount;
		this.magicHitCount += magicHitCount;
		this.magicHitCountExpected += magicHitCountExpected;
		this.offensivePraySuccessCount += offensivePraySuccessCount;
		this.hpHealed += hpHealed;
		this.ghostBarrageCount += ghostBarrageCount;
		this.ghostBarrageExpectedDamage += ghostBarrageExpectedDamage;
	}

	void addDamageDealt(int damage)
	{
		this.damageDealt += damage;
	}

	// will be used for merging fight logs (fight analysis)
	void addMagicHitCount(int count)
	{
		this.magicHitCount += count;
	}

	void addHpHealed(int hpHealed)
	{
		this.hpHealed += hpHealed;
	}

	void died()
	{
		dead = true;
	}

	AnimationData getAnimationData()
	{
		return AnimationData.fromId(player.getAnimation());
	}

	// the "addAttack" for a defensive log that creates an "incomplete" fight log entry.
	void addDefensiveLogs(CombatLevels levels, int offensivePray)
	{
		fightLogEntries.add(new FightLogEntry(name, levels, offensivePray));
	}

	// Return a simple string to display the current player's success rate.
	// ex. "42/59 (71%)". The name is not included as it will be in a separate view.
	// if shortString is true, the percentage is omitted, it only returns the fraction.
	public String getOffPrayStats(boolean shortString)
	{
		nf.setMaximumFractionDigits(1);
		return shortString ?
			offPraySuccessCount + "/" + attackCount :
			offPraySuccessCount + "/" + attackCount + " (" + nf.format(calculateOffPraySuccessPercentage()) + "%)";
	}

	public String getOffPrayStats()
	{
		return getOffPrayStats(false);
	}

	public String getMagicHitStats()
	{
		nf.setMaximumFractionDigits(0);
		String stats = nf.format(magicHitCount);
		long magicAttackCount = getMagicAttackCount();
		stats += "/" + nf.format(magicAttackCount);
		nf.setMaximumFractionDigits(1);
		String luckPercentage = magicHitCountExpected != 0 ?
			nf.format(((double)magicHitCount / magicHitCountExpected) * 100.0) :
			"0";
		stats += " (" + luckPercentage + "%)";
		return stats;
	}

	public String getShortMagicHitStats()
	{
		nf.setMaximumFractionDigits(1);
		return magicHitCountExpected != 0 ?
			nf.format(((double)magicHitCount / magicHitCountExpected) * 100.0) + "%" :
			"0%";
	}

	public String getExpectedDmgString(Fighter opponent, int precision, boolean onlyDiff)
	{
		nf.setMaximumFractionDigits(precision);
		double difference = expectedDamage - opponent.expectedDamage;
		return onlyDiff ? (difference > 0 ? "+" : "") + nf.format(difference) :
			nf.format(expectedDamage) + " (" + (difference > 0 ? "+" : "") + nf.format(difference) + ")";
	}
	public String getExpectedDmgString(Fighter opponent)
	{
		return getExpectedDmgString(opponent, 0, false);
	}


	public String getDmgDealtString(Fighter opponent, boolean onlyDiff)
	{
		int difference = damageDealt - opponent.damageDealt;
		return onlyDiff ? (difference > 0 ? "+" : "") + difference:
			damageDealt + " (" + (difference > 0 ? "+" : "") + difference + ")";
	}
	public String getDmgDealtString(Fighter opponent)
	{
		return getDmgDealtString(opponent, false);
	}

	public double calculateOffPraySuccessPercentage()
	{
		return attackCount == 0 ? 0 :
		(double) offPraySuccessCount / attackCount * 100.0;
	}

	public double calculateOffensivePraySuccessPercentage()
	{
		return attackCount == 0 ? 0 :
			(double) offensivePraySuccessCount / attackCount * 100.0;
	}

	public int getMagicAttackCount()
	{
		return totalMagicAttackCount;
	}

	// Return a simple string to display the current player's offensive prayer success rate.
	// ex. "42/59 (71%)". The name is not included as it will be in a separate view.
	// if shortString is true, the percentage is omitted, it only returns the fraction.
	public String getOffensivePrayStats(boolean shortString)
	{
		nf.setMaximumFractionDigits(1);
		return shortString ?
			offensivePraySuccessCount + "/" + attackCount :
			offensivePraySuccessCount + "/" + attackCount + " (" + nf.format(calculateOffensivePraySuccessPercentage()) + "%)";
	}

	public String getOffensivePrayStats()
	{
		return getOffensivePrayStats(false);
	}

	public String getGhostBarrageStats()
	{
		return ghostBarrageCount + " G.B. (" + nf.format(ghostBarrageExpectedDamage) + ")";
	}

	public void resetRobeHits()
	{
		this.robeHits = 0;
	}
	public void addRobeHit()
	{
		this.robeHits++;
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.controllers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.stream.Collectors;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import matsyir.pvpperformancetracker.models.FightLogEntry;

@Slf4j
public class AnalyzedFightPerformance extends FightPerformance
{
	// fight's full fight logs, saved in "pairs", as an array:
	// [0]: attacker's full log entry
	// [1]: defender's defensive log entry
	@Getter
	ArrayList<FightLogEntry[]> analyzedMatchingLogs;

	@Getter
	FightPerformance mainFight;
	@Getter
	FightPerformance opposingFight;
	// create a more detailed fight performance by merging data from two opposing fight logs
	// also include the fights for easier access to general info
	public AnalyzedFightPerformance(FightPerformance mainFight, FightPerformance opposingFight, Runnable swingCallback) throws Exception
	{
		this.mainFight = mainFight;
		this.opposingFight = opposingFight;
		String cName = mainFight.competitor.getName();
		String oName = mainFight.opponent.getName();
		this.competitor = new Fighter(mainFight, cName);
		this.opponent = new Fighter(mainFight, oName);
		if (mainFight.competitor.isDead())
		{
			this.competitor.died();
		}
		if (mainFight.opponent.isDead())
		{
			this.opponent.died();
		}
		this.lastFightTime = Math.max(mainFight.lastFightTime, opposingFight.lastFightTime);

		// before looping through logs, set "global"/constant values that won't change depending on dps
		// calculations: successful magic hits, actual damage dealt, and hp healed.
		// in case either fighter somehow missed an attack, use the max potential available data
		// detected, as we could rarely miss an attack but never add an extra one.
		this.competitor.addDamageDealt(Math.max(mainFight.competitor.getDamageDealt(), opposingFight.opponent.getDamageDealt()));
		this.competitor.addMagicHitCount(Math.max(mainFight.competitor.getMagicHitCount(), opposingFight.opponent.getMagicHitCount()));
		this.competitor.addHpHealed(mainFight.competitor.getHpHealed());
		this.competitor.setTotalGhostBarrageStats(mainFight.competitor.getGhostBarrageCount(), mainFight.getCompetitor().getGhostBarrageExpectedDamage());

		this.opponent.addDamageDealt(Math.max(opposingFight.competitor.getDamageDealt(), mainFight.opponent.getDamageDealt()));
		this.opponent.addMagicHitCount(Math.max(opposingFight.competitor.getMagicHitCount(), mainFight.opponent.getMagicHitCount()));
		this.opponent.addHpHealed(opposingFight.competitor.getHpHealed());
		this.opponent.setTotalGhostBarrageStats(opposingFight.competitor.getGhostBarrageCount(), opposingFight.getCompetitor().getGhostBarrageExpectedDamage());

		ArrayList<FightLogEntry> mainFightLogEntries = mainFight.getAllFightLogEntries();
		mainFightLogEntries.sort(FightLogEntry::compareTo);
		ArrayList<FightLogEntry> opponentFightLogEntries = opposingFight.getAllFightLogEntries();
		opponentFightLogEntries.sort(FightLogEntry::compareTo);

		// save only full entries into separate arrays, as we'll loop through those a lot.
		ArrayList<FightLogEntry> fullMainFightLogEntries = mainFightLogEntries.stream()
			.filter(FightLogEntry::isFullEntry).sorted().collect(Collectors.toCollection(ArrayList::new));
		ArrayList<FightLogEntry> fullOpponentFightLogEntries = opponentFightLogEntries.stream()
			.filter(FightLogEntry::isFullEntry).sorted().collect(Collectors.toCollection(ArrayList::new));

		int offsetsToCheck = 2; // total number of fight log offsets to start from and find matches in the opposing fight.
		int attacksToCheck = 12; // total number of opposing logs to check starting from the offset.
		// TODO: THIS SHOULDNT BREAK IF attacksToCheck IS 300+ or unused & using all attacks/logs ????
		// ^ or maybe we dont have specific enough data to have it working 100% this way?

		// save matching logs as "pairs", in an array:
		// [0] = main fight's log entry match
		// [1] = opposing fight's log entry match
		// for each different offset start (from mainFight), save an array of the matching logs.
		ArrayList<ArrayList<FightLogEntry[]>> matchingLogs = new ArrayList<>();


		// go through up to the first 5 full logs to match with the opponent's first 6 attacks.
		// do this with a few different offsets and go with the results that had the most matches in 6 attacks.
		//
		// Why multiple offsets rather than one pass, or setting starting tick to 0?
		// It's possible one of the clients misses the first attack, and that people use the same gear
		// for many attacks, which may cause logs to match each-other while being offset, causing future
		// attacks to often be missed, and always be misleading. This way, if initial attacks are missed
		for (int mainOffset = 0; mainOffset < offsetsToCheck; mainOffset++)
		{
			for (int oppOffset = 0; oppOffset < offsetsToCheck; oppOffset++)
			{
				ArrayList<FightLogEntry[]> currentOffsetMatches = new ArrayList<>();
				int highestMatchIdx = -1;
				for (int i = mainOffset; i < fullMainFightLogEntries.size() && i < attacksToCheck; i++)
				{
					FightLogEntry entry = fullMainFightLogEntries.get(i);

					// .skip: do not check for matches on an attack we already got a match for, so skip it.
					//     if the highestMatchIdx is still <0, no matches were found yet so keep checking with oppOffset.
					int skip = highestMatchIdx < 0 ? oppOffset : highestMatchIdx + 1;
					// .limit: similarly to .skip, reduce the amount of attacks we check by the amount we skipped.
					// .filter: find matching fight log entries from the opposing fight.
					// do not use dps calc values for comparison as they can be different depending on each player's
					// config. could potentially fix this by recalculating fights first, but comparing all of these
					// should be ok enough. if gear and pray is the same, then so would dps anyways (before we do
					// the proper brew/level merge we are currently doing)
					FightLogEntry matchingOppLog = fullOpponentFightLogEntries.stream()
						.skip(skip)
						.limit(attacksToCheck - skip)
						.filter(oppEntry -> entry.attackerName.equals(oppEntry.attackerName) &&
							entry.getAnimationData() == oppEntry.getAnimationData() &&
							Arrays.equals(entry.getAttackerGear(), oppEntry.getAttackerGear()) &&
							Arrays.equals(entry.getDefenderGear(), oppEntry.getDefenderGear()) &&
							entry.getAttackerOverhead() == oppEntry.getAttackerOverhead() &&
							entry.getDefenderOverhead() == oppEntry.getDefenderOverhead() &&
							entry.success() == oppEntry.success() &&
							entry.isSplash() == oppEntry.isSplash())
						.findFirst()
						.orElse(null);

					// if a match was found, save the index of the match, and add both entries to the current offset matches.
					if (matchingOppLog != null)
					{
						int logEntryIdx = fullOpponentFightLogEntries.indexOf(matchingOppLog);

						if (logEntryIdx <= highestMatchIdx) // this should never happen.
						{
							throw new Exception("Invalid state during fight merge: logEntryIdx was under highestMatchIdx");
						}

						highestMatchIdx = logEntryIdx;
						currentOffsetMatches.add(new FightLogEntry[]{entry, matchingOppLog});
					}
				}

				if (currentOffsetMatches.size() >= 2)
				{
					matchingLogs.add(currentOffsetMatches);
				}
			}
		}

		if (matchingLogs.size() < 1)
		{
			throw new Exception("Unable to match initial attacks for fight analysis.");
		}

		// get the array of log entry matches that has the highest number of matches, as it should be the most accurate.
		// we'll use the matches in this array to determine the tick offset between the two sets of logs.
		// sort log matches by size, meaning most matches first.
		matchingLogs.sort(Comparator.comparing(ArrayList<FightLogEntry[]>::size).reversed());

		// ensure the tick difference found is valid: consistent difference between the first few matching attacks found.
		// this could potentially somehow still accept unrelated/invalid fights, as it could accept a single attack match,
		// but it should properly merge actual matching fights
		int bestTickDiff = 0;
		boolean foundValidTickDiff = false;
		for (ArrayList<FightLogEntry[]> logMatches : matchingLogs)
		{
			int tickDiff = 0;
			boolean tickDiffValid = true;
			for (int i = 0; i < logMatches.size(); i++)
			{
				FightLogEntry[] match = logMatches.get(i);

				int curTickDiff = match[0].getTick() - match[1].getTick();

				// ensure we have a consistent tick difference between the first few matching attacks.
				if (i == 0)
				{
					tickDiff = curTickDiff;
					continue;
				}

				if (curTickDiff != tickDiff)
				{
					tickDiffValid = false;
					break;
				}
			}

			if (tickDiffValid)
			{
				bestTickDiff = tickDiff;
				foundValidTickDiff = true;
				break;
			}
		}

		if (!foundValidTickDiff)
		{
			throw new Exception("Could not find matching initial attack logs in order to merge fights.");
		}

		// now that we have the best tick diff, we're ready to actually merge the two sets of log entries.
		// start by adjusting the opponent's logs' ticks so they line up with the main fight.
		for (FightLogEntry log : opponentFightLogEntries)
		{
			log.setTick(log.getTick() + bestTickDiff);
		}

		analyzedMatchingLogs = new ArrayList<>();

		// now that all the ticks should be lined up on the opponent fight log entries, find matching tick pairs for offensive : defensive logs.
		// skip the 'main' client's opponent logs, as those are the ones with less data we are trying to improve by using the opponent's data.
		// so, only loop through the main competitor's logs. We will add opponent attacks when we detect a defensive log.
		PLUGIN.getClientThread().invokeLater(() ->
		{
			mainFightLogEntries.stream()
				.filter(log -> log.attackerName.equals(mainFight.competitor.getName()))
				.forEachOrdered(log -> {
					// if the log is a full entry, then this is an attacking log coming from the competitor,
					// so we need to find a matching defensive log from the opponent.
					if (log.isFullEntry())
					{
						opponentFightLogEntries.stream()
							.filter(ol -> ol.getTick() == log.getTick())
							.filter(ol -> !ol.isFullEntry())
							.filter(ol -> ol.attackerName.equals(mainFight.opponent.getName()))
							.findFirst() // when a match is finally found, add the attack.
							.ifPresent(matchingDefenderLog -> addCompetitorAttack(log, matchingDefenderLog));
					}
					else // if the log is not a full entry, it's a defensive log coming from the competitor,
					{    // meaning we need to match it to an opponent's attacking log.
						opponentFightLogEntries.stream()
							.filter(ol -> ol.getTick() == log.getTick())
							.filter(FightLogEntry::isFullEntry)
							.filter(ol -> ol.attackerName.equals(mainFight.opponent.getName()))
							.findFirst() // when a match is finally found, add the attack.
							.ifPresent(matchingAttackerLog -> addOpponentAttack(matchingAttackerLog, log));
					}
				});

			SwingUtilities.invokeLater(swingCallback);
		});
	}

	void addCompetitorAttack(FightLogEntry attackerLog, FightLogEntry defenderLog)
	{
			this.competitor.addAttack(attackerLog, defenderLog);
			this.analyzedMatchingLogs.add(new FightLogEntry[]{ attackerLog, defenderLog });
	}

	void addOpponentAttack(FightLogEntry attackerLog, FightLogEntry defenderLog)
	{
			this.opponent.addAttack(attackerLog, defenderLog);
			this.analyzedMatchingLogs.add(new FightLogEntry[]{attackerLog, defenderLog});
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.controllers;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.AnimationData.AttackStyle;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.models.FightType;
import matsyir.pvpperformancetracker.models.oldVersions.FightPerformance__1_5_5;
import net.runelite.api.AnimationID;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import matsyir.pvpperformancetracker.PvpPerformanceTrackerConfig;
import net.runelite.api.kit.KitType;
import static matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils.fixItemId;
import static matsyir.pvpperformancetracker.controllers.PvpDamageCalc.RANGE_DEF;

// Holds two Fighters which contain data about PvP fight performance, and has many methods to
// add to the fight, display stats or check the status of the fight.
@Slf4j
@Getter
public class FightPerformance implements Comparable<FightPerformance>
{
	private static final int[] DEATH_ANIMATIONS = {
		AnimationID.DEATH,	// Default
		10629,	// League IV
		11902,	// League V
	};
	// Delay to assume a fight is over. May seem long, but sometimes people barrage &
	// stand under for a while to eat. Fights will automatically end when either competitor dies.
	private static final Duration NEW_FIGHT_DELAY = Duration.ofSeconds(21);
	private static final NumberFormat nf = NumberFormat.getInstance();
	static // initialize number format
	{
		nf.setMaximumFractionDigits(1);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}

	@Expose
	@SerializedName("c") // use 1 letter serialized variable names for more compact storage
	public Fighter competitor;
	@Expose
	@SerializedName("o")
	public Fighter opponent;
	@Expose
	@SerializedName("t")
	public long lastFightTime; // last fight time saved as epochMilli timestamp (serializing an Instant was a bad time)
	@Expose
	@SerializedName("l")
	public FightType fightType; // save a boolean if the fight was done in LMS, so we can know those stats/rings/ammo are used.
	@Expose
	@SerializedName("w")
	private int world;

	private int competitorPrevHp; // intentionally don't serialize this, temp variable used to calculate hp healed.

	// KO Chance stats, updated per-attack. Not serialized.
	@Getter
	private transient double competitorTotalKoChance = 0;
	@Getter
	private transient double opponentTotalKoChance = 0;
	@Getter
	private transient Double competitorLastKoChance = null;
	@Getter
	private transient Double opponentLastKoChance = null;
	@Getter
	private transient int competitorKoChanceCount = 0;
	@Getter
	private transient int opponentKoChanceCount = 0;
	private transient double competitorSurvivalProb = 1.0;
	private transient double opponentSurvivalProb = 1.0;

	// shouldn't be used, just here so we can make a subclass, weird java thing
	public FightPerformance()
	{

	}

	// constructor which initializes a fight from the 2 Players, starting stats at 0. Regular use constructor.
	public FightPerformance(Player competitor, Player opponent)
	{
		int defLvl = PLUGIN.getClient().getBoostedSkillLevel(Skill.DEFENCE);

		// determine fight type based on being at LMS areas & use def level to check for LMS builds.
		this.fightType = !PLUGIN.isAtLMS() ? FightType.NORMAL :
			defLvl <= FightType.LMS_1DEF.getCombatLevelsForType().def ? FightType.LMS_1DEF :
			defLvl <= FightType.LMS_ZERK.getCombatLevelsForType().def ? FightType.LMS_ZERK :
			FightType.LMS_MAXMED;

		// initialize world
		this.world = PLUGIN.getClient().getWorld();

		// this is initialized soon before the NEW_FIGHT_DELAY time because the event we
		// determine the opponent from is not fully reliable.
		lastFightTime = Instant.now().minusSeconds(NEW_FIGHT_DELAY.getSeconds() - 5).toEpochMilli();

		this.competitor = new Fighter(this, competitor);
		this.opponent = new Fighter(this, opponent);

		this.competitorPrevHp = PLUGIN.getClient().getBoostedSkillLevel(Skill.HITPOINTS);
		this.competitor.setLastGhostBarrageCheckedMageXp(PLUGIN.getClient().getSkillExperience(Skill.MAGIC));
	}

	// create a FightPerformance using an old 1.5.5 or earlier version.
	public FightPerformance(FightPerformance__1_5_5 old)
	{
		this.competitor = old.competitor;
		this.opponent = old.opponent;
		this.lastFightTime = old.lastFightTime;
		if (old.isLmsFight)
		{
			if (!competitor.getFightLogEntries().isEmpty())
			{
				int defLvl = competitor.getFightLogEntries().get(0).getAttackerLevels().def;
				this.fightType =
					defLvl <= FightType.LMS_1DEF.getCombatLevelsForType().def ? FightType.LMS_1DEF :
					defLvl <= FightType.LMS_ZERK.getCombatLevelsForType().def ? FightType.LMS_ZERK :
					FightType.LMS_MAXMED;
			}
			else
			{
				this.fightType = FightType.LMS_MAXMED;
			}
		}
		else
		{
			this.fightType = FightType.NORMAL;
		}
	}

	// return a random fightPerformance used for testing UI
	static FightPerformance getTestInstance()
	{
		int cTotal = (int)(Math.random() * 60) + 8;
		int cSuccess = (int)(Math.random() * (cTotal - 4)) + 4;
		double cDamage = (Math.random() * (cSuccess * 25));

		int oTotal = (int)(Math.random() * 60) + 8;
		int oSuccess = (int)(Math.random() * (oTotal - 4)) + 4;
		double oDamage = (Math.random() * (oSuccess * 25));

		int secOffset = (int)(Math.random() * 57600) - 28800;

		boolean cDead = Math.random() >= 0.5;

		ArrayList<FightLogEntry> fightLogEntries = new ArrayList<>();
		int [] attackerItems = {0, 0, 0};
		int [] defenderItems = {0, 0, 0};
		String attackerName = "testname";
		FightLogEntry fightLogEntry = new FightLogEntry(attackerItems, 21, 0.5, 1, 12, defenderItems, attackerName);
		FightLogEntry fightLogEntry2 = new FightLogEntry(attackerItems, 11, 0.2, 1, 41, defenderItems, attackerName);
		FightLogEntry fightLogEntry3 = new FightLogEntry(attackerItems, 12, 0.3, 1, 21, defenderItems, attackerName);
		FightLogEntry fightLogEntry4 = new FightLogEntry(attackerItems, 43, 0.1, 1, 23, defenderItems, attackerName);
		fightLogEntries.add(fightLogEntry);
		fightLogEntries.add(fightLogEntry2);
		fightLogEntries.add(fightLogEntry3);
		fightLogEntries.add(fightLogEntry4);
		return new FightPerformance("Matsyir", "TEST_DATA", cSuccess, cTotal, cDamage, oSuccess, oTotal, oDamage, cDead, secOffset, fightLogEntries);
	}

	// Used for testing purposes
	private FightPerformance(String cName, String oName, int cSuccess, int cTotal, double cDamage, int oSuccess, int oTotal, double oDamage, boolean cDead, int secondOffset, ArrayList<FightLogEntry> fightLogs)
	{
		this.competitor = new Fighter(this, cName, fightLogs);
		this.opponent = new Fighter(this, oName, fightLogs);

		competitor.addAttacks(cSuccess, cTotal, cDamage, (int)cDamage, 20, 12, 13, 11, 22, 25, 26);
		opponent.addAttacks(oSuccess, oTotal, oDamage, (int)oDamage, 20, 14, 13, 11, 22, 25, 26);

		if (cDead)
		{
			competitor.died();
		}
		else
		{
			opponent.died();
		}

		lastFightTime = Instant.now().minusSeconds(secondOffset).toEpochMilli();
	}

	// If the given playerName is in this fight, check the Fighter's current animation,
	// add an attack if attacking, and compare attack style used with the opponent's overhead
	// to determine if successful.
	public void checkForAttackAnimations(Player eventSource, CombatLevels competitorLevels)
	{
		if (eventSource == null || eventSource.getName() == null || eventSource.getInteracting() == null || eventSource.getInteracting().getName() == null)
		{
			return;
		}

		String eName = eventSource.getName(); // event source name
		String interactingName = eventSource.getInteracting().getName();
		boolean addedAttack = false;

		// verify that the player is interacting with their tracked opponent before adding attacks
		if (eName.equals(competitor.getName()) && Objects.equals(interactingName, opponent.getName()))
		{
			competitor.setPlayer(eventSource);
			AnimationData animationData = competitor.getAnimationData();
			if (animationData != null)
			{
				int offensivePray = PLUGIN.currentlyUsedOffensivePray();
				competitor.addAttack(
					opponent.getPlayer(),
					animationData,
					offensivePray,
					competitorLevels);
				lastFightTime = Instant.now().toEpochMilli();
				addedAttack = true;

			}
		}
		else if (eName.equals(opponent.getName()) && Objects.equals(interactingName, competitor.getName()))
		{
			opponent.setPlayer(eventSource);
			AnimationData animationData = opponent.getAnimationData();
			if (animationData != null)
			{
				// there is no offensive prayer data for the opponent so hardcode 0
				opponent.addAttack(competitor.getPlayer(), animationData, 0);
				addedAttack = true;
				// add a defensive log for the competitor while the opponent is attacking, to be used with the fight analysis/merge
				competitor.addDefensiveLogs(competitorLevels, PLUGIN.currentlyUsedOffensivePray());
				lastFightTime = Instant.now().toEpochMilli();
			}
		}

		// Ensure robe hits are calculated for the live overlay when enabled (otherwise, just calc'd once at the end)
		// ideally should be refactored into Fighter, using ongoing counters like most other stats, instead of a loop.
		// However, I think it's mostly negligible due to how fight logs are limited to not becoming too large, due
		// to how long fights last.
		if (addedAttack && CONFIG.showOverlayRobeHits())
		{
			calculateRobeHits(CONFIG.robeHitFilter());
		}
	}

	// this only gets called when the local client player receives a magic xp drop.
	public void checkForLocalGhostBarrage(CombatLevels competitorLevels, Player localPlayer)
	{
		if (localPlayer == null)
		{
			log.info("Client player null while checking for ghost barrage - shouldn't happen");
			return;
		}

		competitor.setPlayer(localPlayer);
		if (localPlayer.getInteracting() instanceof Player && localPlayer.getInteracting().getName().equals(opponent.getName()))
		{
			opponent.setPlayer((Player)localPlayer.getInteracting());
		}

		AnimationData animationData = competitor.getAnimationData();

		if (animationData == null || animationData.attackStyle != AnimationData.AttackStyle.MAGIC)
		{
			animationData = AnimationData.MAGIC_ANCIENT_MULTI_TARGET;

			int offensivePray = PLUGIN.currentlyUsedOffensivePray();
			competitor.addGhostBarrage(opponent.getPlayer().getOverheadIcon() != animationData.attackStyle.getProtection(),
				opponent.getPlayer(),
				AnimationData.MAGIC_ANCIENT_MULTI_TARGET,
				offensivePray,
				competitorLevels);
		}
	}

	// add damage dealt to the opposite player.
	// the player name being passed in is the one who has the hitsplat on them.
	public void addDamageDealt(String playerName, int damage)
	{
		if (playerName == null) { return; }

		if (playerName.equals(competitor.getName()))
		{
			opponent.addDamageDealt(damage);
		}
		else if (playerName.equals(opponent.getName()))
		{
			competitor.addDamageDealt(damage);
		}
	}

	public void updateCompetitorHp(int currentHp)
	{
		if (currentHp > competitorPrevHp)
		{
			int hpHealed = currentHp - competitorPrevHp;
			competitor.addHpHealed(hpHealed);
		}
		competitorPrevHp = currentHp;
	}

	// Will return true if either competitor has died yet
	// Completely ending the fight on despawn is handled by the plugin rather than within FightPerformance.
	public boolean checkForDeathAnimations()
	{
		// If either competitor is playing a death animation, mark dead but do not end the fight here.
		if (Arrays.stream(DEATH_ANIMATIONS).anyMatch(e -> e == opponent.getPlayer().getAnimation()))
		{
			opponent.died();
		}
		if (Arrays.stream(DEATH_ANIMATIONS).anyMatch(e -> e == competitor.getPlayer().getAnimation()))
		{
			competitor.died();
		}

		return competitor.isDead() || opponent.isDead();
	}

	// returns true if the fight is considered inactive due to time. We should end the fight when this happens
	public boolean isInactive()
	{
		// If there was no fight actions in the last NEW_FIGHT_DELAY seconds, consider the fight done, because
		// presumably either the player or the opponent ran away/teleported at this point.
		return Duration.between(Instant.ofEpochMilli(lastFightTime), Instant.now()).compareTo(NEW_FIGHT_DELAY) > 0;
	}

	public ArrayList<FightLogEntry> getAllFightLogEntries()
	{
		if (competitor.getFightLogEntries() == null || opponent.getFightLogEntries() == null)
		{
			return new ArrayList<>();
		}

		ArrayList<FightLogEntry> combinedList = new ArrayList<>();
		combinedList.addAll(competitor.getFightLogEntries());
		combinedList.addAll(opponent.getFightLogEntries());
		combinedList.sort(FightLogEntry::compareTo);
		return combinedList;
	}

	// Count the fight as started if either:
	// 1. The competitor has attacked the opponent
	// 2. The opponent has attacked the competitor
	// Attacks are only counted when there is a confirmed interaction between the two players
	// Checking both makes sure that the very first interaction is counted/tracked
	public boolean fightStarted()
	{
		return competitor.getAttackCount() > 0 || opponent.getAttackCount() > 0;
	}

	// returns true if competitor off-pray hit success rate > opponent success rate.
	// the following functions have similar behaviour.
	public boolean competitorOffPraySuccessIsGreater()
	{
		return competitor.calculateOffPraySuccessPercentage() > opponent.calculateOffPraySuccessPercentage();
	}

	public boolean opponentOffPraySuccessIsGreater()
	{
		return opponent.calculateOffPraySuccessPercentage() > competitor.calculateOffPraySuccessPercentage();
	}

	public boolean competitorExpectedDmgIsGreater()
	{
		return competitor.getExpectedDamage() > opponent.getExpectedDamage();
	}

	public boolean opponentExpectedDmgIsGreater()
	{
		return opponent.getExpectedDamage() > competitor.getExpectedDamage();
	}

	public boolean competitorDmgDealtIsGreater()
	{
		return competitor.getDamageDealt() > opponent.getDamageDealt();
	}

	public boolean opponentDmgDealtIsGreater()
	{
		return opponent.getDamageDealt() > competitor.getDamageDealt();
	}

	public boolean competitorMagicHitsLuckier()
	{
		double competitorRate = (competitor.getMagicHitCountExpected() == 0) ? 0 :
			(competitor.getMagicHitCount() / competitor.getMagicHitCountExpected());
		double opponentRate = (opponent.getMagicHitCountExpected() == 0) ? 0 :
			(opponent.getMagicHitCount() / opponent.getMagicHitCountExpected());

		return competitorRate > opponentRate;
	}

	public boolean opponentMagicHitsLuckier()
	{
		double competitorRate = (competitor.getMagicHitCountExpected() == 0) ? 0 :
			(competitor.getMagicHitCount() / competitor.getMagicHitCountExpected());
		double opponentRate = (opponent.getMagicHitCountExpected() == 0) ? 0 :
			(opponent.getMagicHitCount() / opponent.getMagicHitCountExpected());

		return opponentRate > competitorRate;
	}

	public double getCompetitorExpectedDmgDiff()
	{
		return competitor.getExpectedDamage() - opponent.getExpectedDamage();
	}

	public double getCompetitorDmgDealtDiff()
	{
		return competitor.getDamageDealt() - opponent.getDamageDealt();
	}

	// use to sort by last fight time, to sort fights by date/time.
	@Override
	public int compareTo(FightPerformance o)
	{
		long diff = lastFightTime - o.lastFightTime;

		// if diff = 0, return 0. Otherwise, divide diff by its absolute value. This will result in
		// -1 for negative numbers, and 1 for positive numbers, keeping the sign and a safely small int.
		return diff == 0 ? 0 :
			(int)(diff / Math.abs(diff));
	}

	/**
	 * Calculates robe hits for both competitors based on defender gear in each log entry and the configured filter.
	 */
	public void calculateRobeHits(PvpPerformanceTrackerConfig.RobeHitFilter filter)
	{
		competitor.resetRobeHits();
		opponent.resetRobeHits();
		ArrayList<FightLogEntry> allFightLogEntries	= getAllFightLogEntries();
		if (filter == null || allFightLogEntries == null || allFightLogEntries.isEmpty())
		{
			return;
		}

		for (FightLogEntry entry : allFightLogEntries)
		{
			if (entry == null)
			{
				continue;
			}

			// Only consider melee and ranged attacks for robe hits
			AnimationData ad = entry.getAnimationData();
			if (ad == null)
			{
				continue;
			}
			AttackStyle style = ad.attackStyle;
			if (style == AttackStyle.MAGIC)
			{
				continue;
			}

			// Determine who the defender is for this specific entry
			Fighter defender = entry.getAttackerName().equals(competitor.getName()) ? opponent : competitor;
			if (defender == null)
			{
				continue;
			}

			int[] gear = entry.getDefenderGear();
			if (gear == null || gear.length <= Math.max(KitType.LEGS.getIndex(), KitType.TORSO.getIndex()))
			{
				continue;
			}

			int defenderLegsItemId = fixItemId(gear[KitType.LEGS.getIndex()]);
			int defenderBodyItemId = fixItemId(gear[KitType.TORSO.getIndex()]);

			// Compute stats for robe bottom/top
			boolean wearingRobeBottom = false;
			if (defenderLegsItemId != 0)
			{
				int[] legStats = PvpDamageCalc.getItemStats(defenderLegsItemId);
				if (legStats != null && legStats.length > RANGE_DEF)
				{
					wearingRobeBottom = legStats[RANGE_DEF] <= 0; // ==0 seems reliable but <=0 doesn't hurt
				}
			}

			boolean wearingRobeTop = false;
			if (defenderBodyItemId != 0)
			{
				int[] bodyStats = PvpDamageCalc.getItemStats(defenderBodyItemId);
				if (bodyStats != null && bodyStats.length > RANGE_DEF)
				{
					wearingRobeTop = bodyStats[RANGE_DEF] <= 0; // ==0 seems reliable but <=0 doesn't hurt
				}
			}

			boolean isHitOnRobes = false;
			switch (filter)
			{
				case BOTTOM:
					isHitOnRobes = wearingRobeBottom;
					break;
				case TOP:
					isHitOnRobes = wearingRobeTop;
					break;
				case BOTH:
					isHitOnRobes = wearingRobeBottom && wearingRobeTop;
					break;
				case EITHER:
					isHitOnRobes = wearingRobeBottom || wearingRobeTop;
					break;
			}

			if (isHitOnRobes)
			{
				if (defender == competitor)
				{
					competitor.addRobeHit();
				}
				else if (defender == opponent)
				{
					opponent.addRobeHit();
				}
			}
		}
	}

    public void updateKoChanceStats(FightLogEntry entry)
	{
		if (entry.getDisplayKoChance() == null) { return; }

		double koChance = entry.getDisplayKoChance();

		if (entry.getAttackerName().equals(competitor.getName()))
		{
			competitorKoChanceCount++;
			competitorLastKoChance = koChance;
			competitorSurvivalProb *= (1.0 - koChance);
			competitorTotalKoChance = 1.0 - competitorSurvivalProb;
		}
		else
		{
			opponentKoChanceCount++;
			opponentLastKoChance = koChance;
			opponentSurvivalProb *= (1.0 - koChance);
			opponentTotalKoChance = 1.0 - opponentSurvivalProb;
		}
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.controllers;

import lombok.Getter;
import java.util.Arrays;
import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.models.AnimationData;
import static matsyir.pvpperformancetracker.models.AnimationData.AttackStyle;
import static matsyir.pvpperformancetracker.models.FightLogEntry.nf;
import static matsyir.pvpperformancetracker.models.AnimationData.MAGIC_VOLATILE_NIGHTMARE_STAFF_SPEC;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils.fixItemId;
import matsyir.pvpperformancetracker.models.EquipmentData;
import matsyir.pvpperformancetracker.models.EquipmentData.VoidStyle;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.RangeAmmoData;
import matsyir.pvpperformancetracker.models.RingData;
import net.runelite.api.PlayerComposition;
import net.runelite.api.SpriteID;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemEquipmentStats;
import net.runelite.client.game.ItemStats;
import org.apache.commons.lang3.ArrayUtils;
import net.runelite.api.Player;

// Pvp damage calculations
// call updateDamageStats(...) with required parameters, and retrieve results by using the field getters
// for averageHit, accuracy, maxHit, and minHit.
//
// combat formulas source thread QFC: 317,318,461,66138854
// osrs wiki was also used a lot
@Slf4j
public class PvpDamageCalc
{
	private static final int STAB_ATTACK = 0, SLASH_ATTACK = 1, CRUSH_ATTACK = 2, MAGIC_ATTACK = 3,
		RANGE_ATTACK = 4, STAB_DEF = 5, SLASH_DEF = 6, CRUSH_DEF = 7, MAGIC_DEF = 8;
	public static final int RANGE_DEF = 9;
	private static final int STRENGTH_BONUS = 10, RANGE_STRENGTH = 11, MAGIC_DAMAGE = 12;

	private static final int STANCE_BONUS = 0; // assume they are not in controlled or defensive
	private static final double UNSUCCESSFUL_PRAY_DMG_MODIFIER = 0.6; // modifier for when you unsuccessfully hit off-pray

	// Offensive pray: assume you have valid. Piety for melee, Rigour for range, Augury for mage
	private static final double PIETY_ATK_PRAYER_MODIFIER = 1.2;
	private static final double PIETY_STR_PRAYER_MODIFIER = 1.23;
	private static final double AUGURY_OFFENSIVE_PRAYER_MODIFIER = 1.25;
	private static final double RIGOUR_OFFENSIVE_PRAYER_DMG_MODIFIER = 1.23;
	private static final double RIGOUR_OFFENSIVE_PRAYER_ATTACK_MODIFIER = 1.2;

	// Defensive pray: Assume you have one of the defensive prays active, but don't assume you have augury
	// while getting maged, since you would likely be planning to range or melee & using rigour/piety instead.
	private static final double PIETY_DEF_PRAYER_MODIFIER = 1.25;
	private static final double AUGURY_DEF_PRAYER_MODIFIER = 1.25;
	private static final double AUGURY_MAGEDEF_PRAYER_MODIFIER = 1.25; // assume we never use augury during defence for now (unless merging stats).
	private static final double RIGOUR_DEF_PRAYER_MODIFIER = 1.25;

	private static final double BALLISTA_SPEC_ACCURACY_MODIFIER = 1.25;
	private static final double BALLISTA_SPEC_DMG_MODIFIER = 1.25;

	private static final int ACB_SPEC_ACCURACY_MODIFIER = 2;

	private static final int DBOW_DMG_MODIFIER = 2;
	private static final int DBOW_SPEC_DMG_MODIFIER = 3;
	private static final int DBOW_SPEC_MIN_HIT = 16;
	private static final double DRAGON_CBOW_SPEC_DMG_MODIFIER = 1.2;

	private static final double DDS_SPEC_ACCURACY_MODIFIER = 1.25;
	private static final double DDS_SPEC_DMG_MODIFIER = 2.3;

	private static final int ARMA_GS_SPEC_ACCURACY_MODIFIER = 2;
	private static final double ARMA_GS_SPEC_DMG_MODIFIER = 1.375;
	private static final int ANCIENT_GS_SPEC_ACCURACY_MODIFIER = 2;
	private static final double FANG_SPEC_ACCURACY_MODIFIER = 1.5;
	private static final double ANCIENT_GS_SPEC_DMG_MODIFIER = 1.1;
	private static final int ANCIENT_GS_FIXED_DAMAGE = 25;

	private static final double VLS_SPEC_DMG_MODIFIER = 1.2;
	private static final double VLS_SPEC_MIN_DMG_MODIFIER = .2;
	private static final double VLS_SPEC_DEFENCE_SCALE = .25;
	private static final double SWH_SPEC_DMG_MODIFIER = 1.25;
	private static final double SWH_SPEC_MIN_DMG_MODIFIER = .25;
	private static final double DWH_SPEC_DMG_MODIFIER = 1.5;
	private static final double VOIDWAKER_SPEC_DMG_MODIFIER = 1.5;
	private static final double VOIDWAKER_SPEC_MIN_DMG_MODIFIER = .5;
	private static final double VOIDWAKER_FIXED_ACCURACY = 1;

	private static final double ABYSSAL_DAGGER_SPEC_ACCURACY_MODIFIER = 1.25;
	private static final double ABYSSAL_DAGGER_SPEC_DMG_MODIFIER = 0.85;

	private static final double ARKAN_BLADE_SPEC_ACCURACY_MODIFIER = 1.5;
	private static final double ARKAN_BLADE_SPEC_DMG_MODIFIER = 1.5;

	// 0.975x is a simplified average brimstone mage def formula, where x = opponent's mage def
	// 25% of attacks ignore 10% of mage def, therefore 25% of attacks are 90% mage def and 75% are the usual 100%.
	// original formula: 0.25(0.9x) + 0.75x ==> 0.975x
	public static final double BRIMSTONE_RING_OPPONENT_DEF_MODIFIER = 0.975;
	public static final double SMOKE_BATTLESTAFF_DMG_ACC_MODIFIER = 1.1; // both dmg & accuracy modifier
	public static final double TOME_OF_FIRE_DMG_MODIFIER = 1.5;
	public static final double VOLATILE_NIGHTMARE_STAFF_ACC_MODIFIER = 0.5;


	@Getter
	private double averageHit = 0;
	@Getter
	private double accuracy = 0;
	@Getter
	private int minHit = 0;
	@Getter
	private int maxHit = 0;

	private CombatLevels attackerLevels;
	private CombatLevels defenderLevels;

	private RingData ringUsed;
	boolean isLmsFight;

	public PvpDamageCalc(FightPerformance relatedFight)
	{
		isLmsFight = relatedFight.fightType.isLmsFight();
		this.attackerLevels = relatedFight.fightType.getCombatLevelsForType();
		this.defenderLevels = relatedFight.fightType.getCombatLevelsForType();

		this.ringUsed = isLmsFight ? RingData.BERSERKER_RING : CONFIG.ringChoice();
	}

	// main function used to update stats during an ongoing fight
	public void updateDamageStats(Player attacker, Player defender, boolean success, AnimationData animationData)
	{
		// shouldn't be possible, but just in case
		if (attacker == null || defender == null) { return; }

		averageHit = 0;
		accuracy = 0;
		minHit = 0;
		maxHit = 0;

		int[] attackerItems = attacker.getPlayerComposition().getEquipmentIds();
		int[] defenderItems = defender.getPlayerComposition().getEquipmentIds();

		EquipmentData weapon = EquipmentData.fromId(fixItemId(attackerItems[KitType.WEAPON.getIndex()]));

		int[] playerStats = this.calculateBonusesWithRing(attackerItems);
		int[] opponentStats = this.calculateBonusesWithRing(defenderItems);
		AnimationData.AttackStyle attackStyle = animationData.attackStyle; // basic style: stab/slash/crush/ranged/magic

		// Special attack used will be determined based on the currently used weapon, if its special attack has been implemented.
		// the animation just serves to tell if they actually did a special attack animation, since some animations
		// are used for multiple special attacks.
		boolean isSpecial = animationData.isSpecial;
		VoidStyle voidStyle = VoidStyle.getVoidStyleFor(attacker.getPlayerComposition().getEquipmentIds());

		if (attackStyle.isMelee() || animationData == AnimationData.MELEE_VOIDWAKER_SPEC)
		{
			getMeleeMaxHit(playerStats[STRENGTH_BONUS], isSpecial, weapon, voidStyle, true);
			getMeleeAccuracy(playerStats, opponentStats, attackStyle, isSpecial, weapon, voidStyle, true);
		}
		else if (attackStyle == AttackStyle.RANGED)
		{
			getRangedMaxHit(playerStats[RANGE_STRENGTH], isSpecial, weapon, voidStyle, true, attackerItems);
			getRangeAccuracy(playerStats[RANGE_ATTACK], opponentStats[RANGE_DEF], isSpecial, weapon, voidStyle, true, attackerItems);
		}
		// this should always be true at this point, but just in case. unknown animation styles won't
		// make it here, they should be stopped in FightPerformance::checkForAttackAnimations
		else if (attackStyle == AttackStyle.MAGIC)
		{
			EquipmentData shield = EquipmentData.fromId(fixItemId(attackerItems[KitType.SHIELD.getIndex()]));
			getMagicMaxHit(shield, playerStats[MAGIC_DAMAGE], animationData, weapon, voidStyle, true);
			getMagicAccuracy(playerStats[MAGIC_ATTACK], opponentStats[MAGIC_DEF], weapon, animationData, voidStyle, true, false);
		}

		getAverageHit(success, weapon, isSpecial);

		maxHit = (int)(maxHit * (success ? 1 : UNSUCCESSFUL_PRAY_DMG_MODIFIER));
		minHit = (int)(minHit * (success ? 1 : UNSUCCESSFUL_PRAY_DMG_MODIFIER));

		log.debug("attackStyle: " + attackStyle.toString() + ", avgHit: " + nf.format(averageHit) + ", acc: " + nf.format(accuracy) +
			"\nattacker(" + attacker.getName() + ")stats: " + Arrays.toString(playerStats) +
			"\ndefender(" +  defender.getName() + ")stats: " + Arrays.toString(opponentStats));
	}

	// secondary function used to analyze fights from the fight log (fight analysis/fight merge)
	public void updateDamageStats(FightLogEntry atkLog, FightLogEntry defenderLog)
	{
		this.attackerLevels = atkLog.getAttackerLevels();
		this.defenderLevels = defenderLog.getAttackerLevels();
		int[] attackerItems = atkLog.getAttackerGear();
		int[] defenderItems = atkLog.getDefenderGear();
		boolean success = atkLog.success();
		AnimationData animationData = atkLog.getAnimationData();
		boolean successfulOffensive = atkLog.getAnimationData().attackStyle.isUsingSuccessfulOffensivePray(atkLog.getAttackerOffensivePray());

		averageHit = 0;
		accuracy = 0;
		minHit = 0;
		maxHit = 0;

		EquipmentData weapon = EquipmentData.fromId(fixItemId(attackerItems[KitType.WEAPON.getIndex()]));

		int[] playerStats = this.calculateBonuses(attackerItems);
		int[] opponentStats = this.calculateBonuses(defenderItems);
		AnimationData.AttackStyle attackStyle = animationData.attackStyle; // basic style: stab/slash/crush/ranged/magic

		// Special attack used will be determined based on the currently used weapon, if its special attack has been implemented.
		// the animation just serves to tell if they actually did a special attack animation, since some animations
		// are used for multiple special attacks.
		boolean isSpecial = animationData.isSpecial;
		VoidStyle voidStyle = VoidStyle.getVoidStyleFor(attackerItems);

		if (attackStyle.isMelee())
		{
			getMeleeMaxHit(playerStats[STRENGTH_BONUS], isSpecial, weapon, voidStyle, successfulOffensive);
			getMeleeAccuracy(playerStats, opponentStats, attackStyle, isSpecial, weapon, voidStyle, successfulOffensive);
		}
		else if (attackStyle == AttackStyle.RANGED)
		{
			getRangedMaxHit(playerStats[RANGE_STRENGTH], isSpecial, weapon, voidStyle, successfulOffensive, attackerItems);
			getRangeAccuracy(playerStats[RANGE_ATTACK], opponentStats[RANGE_DEF], isSpecial, weapon, voidStyle, successfulOffensive, attackerItems);
		}
		// this should always be true at this point, but just in case. unknown animation styles won't
		// make it here, they should be stopped in FightPerformance::checkForAttackAnimations
		else if (attackStyle == AttackStyle.MAGIC)
		{
			EquipmentData shield = EquipmentData.fromId(fixItemId(attackerItems[KitType.SHIELD.getIndex()]));
			getMagicMaxHit(shield, playerStats[MAGIC_DAMAGE], animationData, weapon, voidStyle, successfulOffensive);
			getMagicAccuracy(playerStats[MAGIC_ATTACK], opponentStats[MAGIC_DEF], weapon, animationData, voidStyle, successfulOffensive, defenderLog.getAttackerOffensivePray() == SpriteID.PRAYER_AUGURY);
		}

		getAverageHit(success, weapon, isSpecial);

		maxHit = (int)(maxHit * (success ? 1 : UNSUCCESSFUL_PRAY_DMG_MODIFIER));
		minHit = (int)(minHit * (success ? 1 : UNSUCCESSFUL_PRAY_DMG_MODIFIER));
	}

	private void getAverageHit(boolean success, EquipmentData weapon, boolean usingSpec)
	{
		boolean ancientGs = weapon == EquipmentData.ANCIENT_GODSWORD;
		boolean dbow = weapon == EquipmentData.DARK_BOW;
		boolean claws = weapon == EquipmentData.DRAGON_CLAWS;
		boolean fang = weapon == EquipmentData.OSMUMTENS_FANG;
		boolean vls = weapon == EquipmentData.VESTAS_LONGSWORD;
		boolean swh = weapon == EquipmentData.STATIUS_WARHAMMER;
		boolean voidwaker = weapon == EquipmentData.VOIDWAKER;
		boolean burningClaws = weapon == EquipmentData.BURNING_CLAWS;

		double prayerModifier = success ? 1 : UNSUCCESSFUL_PRAY_DMG_MODIFIER;
		double averageSuccessfulHit;
		// average hit calculation for attacks that have minimum hits that are skewed towards hitting minimum hit more often
		if (usingSpec && (dbow || vls || swh))
		{
			double accuracyAdjuster = dbow ? accuracy : 1;
			minHit = dbow ? DBOW_SPEC_MIN_HIT : 0;
			minHit = vls ? (int) (maxHit * VLS_SPEC_MIN_DMG_MODIFIER) : minHit;
			minHit = swh ? (int) (maxHit * SWH_SPEC_MIN_DMG_MODIFIER) : minHit;

			int total = 0;

			// this odd logic is used to calculate avg hit because when there is a minimum hit,
			// it does not simply change the potential hit range as you would expect:
			// potential hit rolls (min=0 max=5): 0, 1, 2, 3, 4, 5
			// potential hit rolls (min=3 max=5): 3, 3, 3, 3, 4, 5 (intuitively it would just be 3, 4, 5, but nope)
			// so, it is more common to roll the minimum hit and that has to be accounted for in the average hit.
			for (int i = 0; i <= maxHit; i++)
			{
				total += i < minHit ? minHit / accuracyAdjuster : i;
			}

			averageSuccessfulHit = (double) total / maxHit;
		}
		else if (usingSpec && claws)
		{
			// if first 1-2 claws miss, it's a 150% dmg multiplier because when the 3rd att hits, the last
			// 2 hits are 75% dmg multiplier, so 75% + 75% = 150%. It's a matter of a 2x multiplier or a
			// 1.5x multiplier and the chance of a 2x multiplier is what higherModifierChance is for

			// inverted accuracy is used to calculate the chances of missing specifically 1, 2 or 3 times in a row
			double invertedAccuracy = 1 - accuracy;
			double averageSuccessfulRegularHit = maxHit / 2;
			double higherModifierChance = (accuracy + (accuracy * invertedAccuracy));
			double lowerModifierChance = ((accuracy * Math.pow(invertedAccuracy, 2)) + (accuracy * Math.pow(invertedAccuracy, 3)));
			double averageSpecialHit = ((higherModifierChance * 2) + (lowerModifierChance * 1.5)) * averageSuccessfulRegularHit;

			averageHit = averageSpecialHit * prayerModifier;
			accuracy = higherModifierChance + lowerModifierChance;
			// the random +1 is not included in avg hit but it is included in the max hit to be seen from fight logs
			maxHit = maxHit * 2 + 1;
			return;
		}
		else if (burningClaws && usingSpec)
		{
			double baseMaxHit = maxHit;
			double acc = accuracy;
			double miss = 1 - acc;

			// Case 1: 1st roll success
			int minD1 = (int)Math.floor(0.75 * baseMaxHit);
			int maxD1 = (int)Math.floor(1.75 * baseMaxHit);
			double avgTotalDmg1 = getAverageBurningClawDamage(minD1, maxD1);

			// Case 2: 1st fail, 2nd success
			int minD2 = (int)Math.floor(0.50 * baseMaxHit);
			int maxD2 = (int)Math.floor(1.50 * baseMaxHit);
			double avgTotalDmg2 = getAverageBurningClawDamage(minD2, maxD2);

			// Case 3: 1st, 2nd fail, 3rd success
			int minD3 = (int)Math.floor(0.25 * baseMaxHit);
			int maxD3 = (int)Math.floor(1.25 * baseMaxHit);
			double avgTotalDmg3 = getAverageBurningClawDamage(minD3, maxD3);

			// Case 4: all 3 fail
			int minD4 = 0;
			int maxD4 = (int)Math.floor(baseMaxHit);
			double avgTotalDmg4 = getAverageBurningClawDamage(minD4, maxD4);

			double expectedDamage =
				(acc) * avgTotalDmg1 +
					(miss * acc) * avgTotalDmg2 +
					(miss * miss * acc) * avgTotalDmg3 +
					(miss * miss * miss) * avgTotalDmg4;

			this.averageHit = expectedDamage * prayerModifier;

			// Keep the original per-swing accuracy; do not override it here.
			this.maxHit = calculateBurningClawTotalDamage(maxD1);
			this.minHit = 0;

			return;
		}
		else if (fang)
		{
			double maxHitMultiplier = usingSpec ? 1: 0.85; // max hit when using spec is 100% but minHit stays the same
			// accuracy rolls twice for the fang, so the accuracy is equal to 1 - chance of hit1 OR hit2
			double invertedAccuracy = 1 - accuracy; // example: if accuracy is 20% and thus 0.2, inverted accuracy is 0.8
			double chanceOfMissingTwice = Math.pow(invertedAccuracy, 2); // 0.8 squared is 0.64 or 64%
			accuracy = 1 - chanceOfMissingTwice; // thus 64% chance of missing, or 36% accuracy
			// max hit is 0.85% and min hit is 15%
			// unlike VLS/SWH/Dbow I believe this rolls between min and max instead of raising hits between 0 - minHit to minHit
			int base = maxHit;
			minHit = (int) Math.ceil(base * 0.15);
			maxHit = (int) Math.ceil(maxHitMultiplier * base); // Use ceil for the upper bound of fang's passive
			averageSuccessfulHit = (minHit + maxHit) / 2.0;
		}
		// average hit calculation for attacks with minimum hits that use a more 'intuitive' average hit, similar to osmuten's fang
		else if (usingSpec && voidwaker)
		{
			// back-calc base hit from floored spec-max, then apply 50% for correct rounding
			minHit = (int) Math.floor((maxHit / VOIDWAKER_SPEC_DMG_MODIFIER) * VOIDWAKER_SPEC_MIN_DMG_MODIFIER);
			averageSuccessfulHit = (minHit + maxHit) / 2.0;
		}
		else
		{
			// divide by double to get accurate decimals, since this is the averageHit result,
			// not a core OSRS damage calc that is meant to be rounded down by int
			// If reaching this part of the code, the minHit should always be 0, but include it anyways
			// just in case.
			averageSuccessfulHit = (minHit + maxHit) / 2.0;

			// Abyssal Dagger Spec: Hits twice, adjust average and double displayed max hit.
			boolean abyssalDagger = weapon == EquipmentData.ABYSSAL_DAGGER;
			if (abyssalDagger && usingSpec)
			{
				averageSuccessfulHit *= 2; // Account for two hits in average
				maxHit *= 2; // Double the max hit for display
			}

			if (minHit > 0)
			{
				log.info("PvpDamageCalc:getAverageHit: Fell into default avg hit calculation with a minHit > 0 (" +
					minHit + "). Shouldn't happen. Weapon: " + weapon.toString());
			}
		}

		averageHit = accuracy * averageSuccessfulHit * prayerModifier;

		if (usingSpec && ancientGs)
		{
			averageHit += ANCIENT_GS_FIXED_DAMAGE;
		}
	}

	private int calculateBurningClawTotalDamage(int D)
	{
		return (int)Math.floor(0.25 * D) + (int)Math.floor(0.25 * D) + (int)Math.floor(0.5 * D);
	}

	private double getAverageBurningClawDamage(int minD, int maxD)
	{
		if (minD > maxD)
		{
			return 0;
		}
		double totalDamageSum = 0;
		for (int D = minD; D <= maxD; D++)
		{
			totalDamageSum += calculateBurningClawTotalDamage(D);
		}
		return totalDamageSum / (maxD - minD + 1);
	}

	private void getMeleeMaxHit(int meleeStrength, boolean usingSpec, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive)
	{
		boolean ags = weapon == EquipmentData.ARMADYL_GODSWORD;
		boolean ancientGs = weapon == EquipmentData.ANCIENT_GODSWORD;
		boolean dds = weapon == EquipmentData.DRAGON_DAGGER;
		boolean vls = weapon == EquipmentData.VESTAS_LONGSWORD;
		boolean swh = weapon == EquipmentData.STATIUS_WARHAMMER;
		boolean dwh = weapon == EquipmentData.DRAGON_WARHAMMER;
		boolean voidwaker = weapon == EquipmentData.VOIDWAKER;
		boolean abyssalDagger = weapon == EquipmentData.ABYSSAL_DAGGER;
		boolean arkanBlade = weapon == EquipmentData.ARKAN_BLADE;

		int effectiveLevel = (int) Math.floor((attackerLevels.str * (successfulOffensive ? PIETY_STR_PRAYER_MODIFIER : 1)) + 8 + 3);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_MELEE || voidStyle == VoidStyle.VOID_MELEE)
		{
			effectiveLevel *= voidStyle.dmgModifier;
		}

		int baseDamage = (int) Math.floor(0.5 + effectiveLevel * (meleeStrength + 64) / 640.0);
		double damageModifier = (ags && usingSpec) ? ARMA_GS_SPEC_DMG_MODIFIER :
			(ancientGs && usingSpec) ? ANCIENT_GS_SPEC_DMG_MODIFIER :
			(swh && usingSpec) ? SWH_SPEC_DMG_MODIFIER :
			(dds && usingSpec) ? DDS_SPEC_DMG_MODIFIER :
			(vls && usingSpec) ? VLS_SPEC_DMG_MODIFIER :
			(dwh && usingSpec) ? DWH_SPEC_DMG_MODIFIER :
			(voidwaker && usingSpec) ? VOIDWAKER_SPEC_DMG_MODIFIER :
			(abyssalDagger && usingSpec) ? ABYSSAL_DAGGER_SPEC_DMG_MODIFIER :
			(arkanBlade && usingSpec) ? ARKAN_BLADE_SPEC_DMG_MODIFIER :
			1;
		maxHit = (int) (damageModifier * baseDamage);
	}

	private void getRangedMaxHit(int rangeStrength, boolean usingSpec, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive, int[] attackerComposition)
	{
		RangeAmmoData weaponAmmo = EquipmentData.getWeaponAmmo(weapon);
		EquipmentData head = EquipmentData.fromId(fixItemId(attackerComposition[KitType.HEAD.getIndex()]));
		EquipmentData body = EquipmentData.fromId(fixItemId(attackerComposition[KitType.TORSO.getIndex()]));
		EquipmentData legs = EquipmentData.fromId(fixItemId(attackerComposition[KitType.LEGS.getIndex()]));

		// if it's an LMS fight and bolts are used, force diamond bolts (e) or opal dragon bolts (e) based on weapon used.
		if (this.isLmsFight)
		{
			weaponAmmo = weaponAmmo instanceof RangeAmmoData.StrongBoltAmmo ? RangeAmmoData.StrongBoltAmmo.OPAL_DRAGON_BOLTS_E :
				weaponAmmo instanceof RangeAmmoData.BoltAmmo ? RangeAmmoData.BoltAmmo.DIAMOND_BOLTS_E : weaponAmmo;
		}

		boolean ballista = weapon == EquipmentData.HEAVY_BALLISTA;
		boolean dbow = weapon == EquipmentData.DARK_BOW;
		boolean dragonCbow = weapon == EquipmentData.DRAGON_CROSSBOW;

		int ammoStrength = weaponAmmo == null ? 0 : weaponAmmo.getRangeStr();

		rangeStrength += ammoStrength;

		double effectiveLevel = Math.floor((attackerLevels.range * (successfulOffensive ? RIGOUR_OFFENSIVE_PRAYER_DMG_MODIFIER : 1)) + 8);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_RANGE || voidStyle == VoidStyle.VOID_RANGE)
		{
			effectiveLevel *= voidStyle.dmgModifier;
		}

		int baseDamage = (int) Math.floor(0.5 + (effectiveLevel * (rangeStrength + 64) / 640.0));

		double modifier = weaponAmmo == null ? 1 : weaponAmmo.getDmgModifier();
		modifier = ballista && usingSpec ? BALLISTA_SPEC_DMG_MODIFIER : modifier;
		modifier = dbow && !usingSpec ? DBOW_DMG_MODIFIER : modifier;
		modifier = dbow && usingSpec ? DBOW_SPEC_DMG_MODIFIER : modifier;
		modifier = dragonCbow && usingSpec ? DRAGON_CBOW_SPEC_DMG_MODIFIER : modifier;

		// Eclipse Atlatl uses Melee Str for max hit but Ranged prayers/void
		if (weapon == EquipmentData.ECLIPSE_ATLATL)
		{
			int[] playerStats = calculateBonusesWithRing(attackerComposition);
			// Recalculate effective level using Strength level but Ranged prayer modifier
			effectiveLevel = Math.floor(((attackerLevels.str * (successfulOffensive ? RIGOUR_OFFENSIVE_PRAYER_DMG_MODIFIER : 1)) + STANCE_BONUS) + 8);

			// Apply Ranged void bonus if applicable
			if (voidStyle == VoidStyle.VOID_ELITE_RANGE || voidStyle == VoidStyle.VOID_RANGE)
			{
				effectiveLevel *= voidStyle.dmgModifier;
			}

			baseDamage = (int) Math.floor(0.5 + (effectiveLevel * (playerStats[STRENGTH_BONUS] + 64) / 640.0));
			maxHit = baseDamage;
		}
		else // Standard Ranged Max Hit Calc
		{
		maxHit = weaponAmmo == null ?
			(int) (modifier * baseDamage) :
			(int) ((modifier * baseDamage) + weaponAmmo.getBonusMaxHit(attackerLevels.range));
		}

		// apply crystal armor bonus if using bow
		if ((weapon == EquipmentData.BOW_OF_FAERDHINEN || weapon == EquipmentData.CRYSTAL_BOW || weapon == EquipmentData.CRYSTAL_BOW_I) &&
			(head == EquipmentData.CRYSTAL_HELM || body == EquipmentData.CRYSTAL_BODY || legs == EquipmentData.CRYSTAL_LEGS))
		{
			double dmgModifier = 1 +
				(head == EquipmentData.CRYSTAL_HELM ? 0.025 : 0) +
				(body == EquipmentData.CRYSTAL_BODY ? 0.075 : 0) +
				(legs == EquipmentData.CRYSTAL_LEGS ? 0.05 : 0);

			maxHit *= dmgModifier;
		}
	}

	private void getMagicMaxHit(EquipmentData shield, int mageDamageBonus, AnimationData animationData, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive)
	{
		boolean smokeBstaff = weapon == EquipmentData.SMOKE_BATTLESTAFF;
		boolean tome = shield == EquipmentData.TOME_OF_FIRE;

		double magicBonus = 1 + (mageDamageBonus / 100.0);
		// provide dmg buff from smoke battlestaff if applicable
		if (smokeBstaff && AnimationData.isStandardSpellbookSpell(animationData))
		{
			magicBonus *= SMOKE_BATTLESTAFF_DMG_ACC_MODIFIER;
		}
		// provide dmg buff from tome of fire if applicable
		if (tome && AnimationData.isFireSpell(animationData))
		{
			magicBonus *= TOME_OF_FIRE_DMG_MODIFIER;
		}
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_MAGE || voidStyle == VoidStyle.VOID_MAGE)
		{
			magicBonus *= voidStyle.dmgModifier;
		}

		maxHit = (int)(animationData.baseSpellDamage * magicBonus);
	}

	private void getMeleeAccuracy(int[] playerStats, int[] opponentStats, AttackStyle attackStyle, boolean usingSpec, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive)
	{
		boolean vls = weapon == EquipmentData.VESTAS_LONGSWORD;
		boolean ags = weapon == EquipmentData.ARMADYL_GODSWORD;
		boolean ancientGs = weapon == EquipmentData.ANCIENT_GODSWORD;
		boolean dds = weapon == EquipmentData.DRAGON_DAGGER;
		boolean fang = weapon == EquipmentData.OSMUMTENS_FANG;
		boolean voidwaker = weapon == EquipmentData.VOIDWAKER;
		boolean abyssalDagger = weapon == EquipmentData.ABYSSAL_DAGGER;
		boolean arkanBlade = weapon == EquipmentData.ARKAN_BLADE;

		if (voidwaker && usingSpec)
		{
			accuracy = VOIDWAKER_FIXED_ACCURACY;
			return;
		}

		double stabBonusPlayer = playerStats[STAB_ATTACK];
		double slashBonusPlayer = playerStats[SLASH_ATTACK];
		double crushBonusPlayer = playerStats[CRUSH_ATTACK];

		double stabBonusTarget = opponentStats[STAB_DEF];
		double slashBonusTarget = opponentStats[SLASH_DEF];
		double crushBonusTarget = opponentStats[CRUSH_DEF];
		double magicBonusTarget = opponentStats[MAGIC_DEF];

		double effectiveLevelPlayer;
		double effectiveLevelTarget;

		double baseChance;
		double attackerChance;
		double defenderChance;

		double accuracyModifier = dds ? DDS_SPEC_ACCURACY_MODIFIER :
			ags ? ARMA_GS_SPEC_ACCURACY_MODIFIER :
			ancientGs ? ANCIENT_GS_SPEC_ACCURACY_MODIFIER :
			fang ? FANG_SPEC_ACCURACY_MODIFIER :
			arkanBlade ? ARKAN_BLADE_SPEC_ACCURACY_MODIFIER :
			1;

		/**
		 * Attacker Chance
		 */
		effectiveLevelPlayer = Math.floor(((attackerLevels.atk * (successfulOffensive ? PIETY_ATK_PRAYER_MODIFIER : 1)) + STANCE_BONUS) + 8);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_MELEE || voidStyle == VoidStyle.VOID_MELEE)
		{
			effectiveLevelPlayer *= voidStyle.accuracyModifier;
		}

		final double attackBonus = attackStyle == AttackStyle.STAB ? stabBonusPlayer
			: attackStyle == AttackStyle.SLASH ? slashBonusPlayer : crushBonusPlayer;

		final double targetDefenceBonus = attackStyle == AttackStyle.STAB ? stabBonusTarget
			: attackStyle == AttackStyle.SLASH ? slashBonusTarget : crushBonusTarget;


		baseChance = Math.floor(effectiveLevelPlayer * (attackBonus + 64));
		if (usingSpec)
		{
			// Don't apply the generic modifier if it's the Abyssal Dagger (handled separately below)
			if (weapon != EquipmentData.ABYSSAL_DAGGER) {
			baseChance = baseChance * accuracyModifier;
			}
		}

		// Apply Abyssal Dagger spec modifier specifically here
		if (abyssalDagger && usingSpec) {
			baseChance *= ABYSSAL_DAGGER_SPEC_ACCURACY_MODIFIER;
		}

		attackerChance = baseChance;

		/**
		 * Defender Chance
		 */
		effectiveLevelTarget = Math.floor(((defenderLevels.def * PIETY_DEF_PRAYER_MODIFIER) + STANCE_BONUS) + 8);

		if (vls && usingSpec)
		{
			defenderChance = Math.floor((effectiveLevelTarget * (stabBonusTarget + 64)) * VLS_SPEC_DEFENCE_SCALE);
		}
		else
		{
			defenderChance = Math.floor(effectiveLevelTarget * (targetDefenceBonus + 64));
		}
//        log.debug("MELEE ATTACK: " + defenderChance );
		/**
		 * Calculate Accuracy
		 */
		if (attackerChance > defenderChance)
		{
			accuracy = 1 - (defenderChance + 2) / (2 * (attackerChance + 1));
		}
		else
		{
			accuracy = attackerChance / (2 * (defenderChance + 1));
		}
	}

	private void getRangeAccuracy(int playerRangeAtt, int opponentRangeDef, boolean usingSpec, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive, int[] attackerComposition)
	{
		RangeAmmoData weaponAmmo = EquipmentData.getWeaponAmmo(weapon);
		// if it's an LMS fight and bolts are used, don't use config bolt, just use diamond bolts(e)
		if (this.isLmsFight && (weaponAmmo instanceof RangeAmmoData.BoltAmmo ||
			weaponAmmo instanceof RangeAmmoData.StrongBoltAmmo))
		{
			weaponAmmo = RangeAmmoData.BoltAmmo.DIAMOND_BOLTS_E;
		}

		boolean diamonds = ArrayUtils.contains(RangeAmmoData.DIAMOND_BOLTS, weaponAmmo);
		boolean opals = ArrayUtils.contains(RangeAmmoData.OPAL_BOLTS, weaponAmmo);
		double effectiveLevelPlayer;
		double effectiveLevelTarget;
		double rangeModifier;
		double attackerChance;
		double defenderChance;

		/**
		 * Attacker Chance
		 */
		effectiveLevelPlayer = Math.floor(((attackerLevels.range * (successfulOffensive ? RIGOUR_OFFENSIVE_PRAYER_ATTACK_MODIFIER : 1)) + STANCE_BONUS) + 8);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_RANGE || voidStyle == VoidStyle.VOID_RANGE)
		{
			effectiveLevelPlayer *= voidStyle.accuracyModifier;
		}

		// apply crystal armor bonus if using bow
		EquipmentData head = EquipmentData.fromId(fixItemId(attackerComposition[KitType.HEAD.getIndex()]));
		EquipmentData body = EquipmentData.fromId(fixItemId(attackerComposition[KitType.TORSO.getIndex()]));
		EquipmentData legs = EquipmentData.fromId(fixItemId(attackerComposition[KitType.LEGS.getIndex()]));

		if ((weapon == EquipmentData.BOW_OF_FAERDHINEN || weapon == EquipmentData.CRYSTAL_BOW || weapon == EquipmentData.CRYSTAL_BOW_I) &&
			(head == EquipmentData.CRYSTAL_HELM || body == EquipmentData.CRYSTAL_BODY || legs == EquipmentData.CRYSTAL_LEGS))
		{
			double accuracyModifier = 1 +
				(head == EquipmentData.CRYSTAL_HELM ? 0.05 : 0) +
				(body == EquipmentData.CRYSTAL_BODY ? 0.15 : 0) +
				(legs == EquipmentData.CRYSTAL_LEGS ? 0.1 : 0);

			effectiveLevelPlayer *= accuracyModifier;
		}

		rangeModifier = Math.floor(effectiveLevelPlayer * ((double) playerRangeAtt + 64));
		if (usingSpec)
		{
			boolean acb = weapon == EquipmentData.ARMADYL_CROSSBOW;
			boolean ballista = weapon == EquipmentData.HEAVY_BALLISTA;

			double specAccuracyModifier = acb ? ACB_SPEC_ACCURACY_MODIFIER :
				ballista ? BALLISTA_SPEC_ACCURACY_MODIFIER : 1;

			attackerChance = Math.floor(rangeModifier * specAccuracyModifier);
		}
		else
		{
			attackerChance = rangeModifier;
		}

		/**
		 * Defender Chance
		 */
		effectiveLevelTarget = Math.floor(((defenderLevels.def * RIGOUR_DEF_PRAYER_MODIFIER) + STANCE_BONUS) + 8);
		defenderChance = Math.floor(effectiveLevelTarget * ((double) opponentRangeDef + 64));

		/**
		 * Calculate Accuracy
		 */
		if (attackerChance > defenderChance)
		{
			accuracy = 1 - (defenderChance + 2) / (2 * (attackerChance + 1));
		}
		else
		{
			accuracy = attackerChance / (2 * (defenderChance + 1));
		}

		// the effect in pvp is 5% instead of 10% like it is for pvm
		// upon further testing this effect applies to opal dragon bolts as well
		// diamond bolts and opal bolts accuracy: 5% of attacks are 100% accuracy, so apply avg accuracy as:
		// (95% of normal accuracy) + (5% of 100% accuracy)
		boolean dragonCbow = weapon == EquipmentData.DRAGON_CROSSBOW;
		// Apply diamond/opal accuracy passive, but skip it during dragon crossbow special so that Annihilate's
		// projectile-based accuracy is not unintentionally boosted.
		accuracy = (diamonds || opals) && !(dragonCbow && usingSpec) ? (accuracy * .95) + .05 : accuracy;
	}

	private void getMagicAccuracy(int playerMageAtt, int opponentMageDef, EquipmentData weapon, AnimationData animationData, VoidStyle voidStyle, boolean successfulOffensive, boolean defensiveAugurySuccess)
	{
		double effectiveLevelPlayer;

		double reducedDefenceLevelTarget;
		double effectiveMagicDefenceTarget;
		double effectiveMagicLevelTarget;

		double effectiveLevelTarget;

		double magicModifier;

		double attackerChance;
		double defenderChance;

		/**
		 * Attacker Chance
		 */
		effectiveLevelPlayer = Math.floor(((attackerLevels.mage * (successfulOffensive ? AUGURY_OFFENSIVE_PRAYER_MODIFIER : 1))) + 8);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_MAGE || voidStyle == VoidStyle.VOID_MAGE)
		{
			effectiveLevelPlayer *= voidStyle.accuracyModifier;
		}

		magicModifier = Math.floor(effectiveLevelPlayer * ((double) playerMageAtt + 64));
		attackerChance = magicModifier;

		/**
		 * Defender Chance
		 */
		effectiveLevelTarget = Math.floor(((defenderLevels.def * AUGURY_DEF_PRAYER_MODIFIER) + STANCE_BONUS) + 8);
		effectiveMagicLevelTarget = Math.floor((defenderLevels.mage * (defensiveAugurySuccess ? AUGURY_MAGEDEF_PRAYER_MODIFIER : 1)) * 0.70);
		reducedDefenceLevelTarget = Math.floor(effectiveLevelTarget * 0.30);
		effectiveMagicDefenceTarget = effectiveMagicLevelTarget + reducedDefenceLevelTarget;

		// 0.975x is a simplified brimstone accuracy formula, where x = mage def
		defenderChance = ringUsed == RingData.BRIMSTONE_RING ?
			Math.floor(effectiveMagicDefenceTarget * ((BRIMSTONE_RING_OPPONENT_DEF_MODIFIER * opponentMageDef) + 64)) :
			Math.floor(effectiveMagicDefenceTarget * ((double) opponentMageDef + 64));

		/**
		 * Calculate Accuracy
		 */
		if (attackerChance > defenderChance)
		{
			accuracy = 1 - (defenderChance + 2) / (2 * (attackerChance + 1));
		}
		else
		{
			accuracy = attackerChance / (2 * (defenderChance + 1));
		}

		boolean smokeBstaff = weapon == EquipmentData.SMOKE_BATTLESTAFF;
		boolean volatileStaff = weapon == EquipmentData.VOLATILE_NIGHTMARE_STAFF;
		// provide accuracy buff from smoke battlestaff or volatile staff spec if applicable
		if (smokeBstaff && AnimationData.isStandardSpellbookSpell(animationData))
		{
			accuracy *= SMOKE_BATTLESTAFF_DMG_ACC_MODIFIER;
		}
		else if (volatileStaff && animationData == MAGIC_VOLATILE_NIGHTMARE_STAFF_SPEC)
		{
			accuracy *= VOLATILE_NIGHTMARE_STAFF_ACC_MODIFIER;
		}
	}

	// Retrieve item stats for a single item, returned as an int array so they can be modified.
	// First, try to get the item stats from the item manager. If stats weren't present in the
	// itemManager, try get the 'real' item id from the EquipmentData. If it's not defined in EquipmentData, it will return null
	// and count as 0 stats, but that should be very rare.
	public static int[] getItemStats(int itemId)
	{
		ItemStats itemStats = PLUGIN.getItemManager().getItemStats(itemId);
		if (itemStats == null)
		{
			EquipmentData itemData = EquipmentData.fromId(itemId);
			if (itemData != null)
			{
				itemId = itemData.getItemId();
				itemStats = PLUGIN.getItemManager().getItemStats(itemId);
			}
		}

		if (itemStats == null)
		{
			return null;
		}
		final ItemEquipmentStats equipmentStats = itemStats.getEquipment();
		if (equipmentStats == null)
		{
			return null;
		}
		return new int[] {
			equipmentStats.getAstab(),	// 0
			equipmentStats.getAslash(),	// 1
			equipmentStats.getAcrush(),	// 2
			equipmentStats.getAmagic(),	// 3
			equipmentStats.getArange(),	// 4
			equipmentStats.getDstab(),	// 5
			equipmentStats.getDslash(),	// 6
			equipmentStats.getDcrush(),	// 7
			equipmentStats.getDmagic(),	// 8
			equipmentStats.getDrange(),	// 9
			equipmentStats.getStr(),	// 10
			equipmentStats.getRstr(),	// 11
			(int)equipmentStats.getMdmg(),	// 12
		};
	}

	// this is used to calculate bonuses including the currently used ring, in case we're in LMS but the config ring
	// is different.
	private int[] calculateBonusesWithRing(int[] itemIds)
	{
		return calculateBonuses(itemIds, this.ringUsed);
	}

	public static int[] calculateBonuses(int[] itemIds)
	{
		return calculateBonuses(itemIds, CONFIG.ringChoice());
	}
	// Calculate total equipment bonuses for all given items
	public static int[] calculateBonuses(int[] itemIds, RingData ringUsed)
	{
		int[] equipmentBonuses = ringUsed == null || ringUsed == RingData.NONE ?
			new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } :
			getItemStats(ringUsed.getItemId());

		if (equipmentBonuses == null) // shouldn't happen, but as a failsafe if the ring lookup fails
		{
			equipmentBonuses = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		}

		for (int item : itemIds)
		{
			if (item > PlayerComposition.ITEM_OFFSET)
			{
				int[] bonuses = getItemStats(item - PlayerComposition.ITEM_OFFSET);

				if (bonuses == null)
				{
					continue;
				}

				for (int id = 0; id < bonuses.length; id++)
				{
					equipmentBonuses[id] += bonuses[id];
				}
			}
		}

		return equipmentBonuses;
	}

	public static ItemEquipmentStats calculateBonusesToStats(int[] itemIds)
	{
		int[] bonuses = calculateBonuses(itemIds);
		return ItemEquipmentStats.builder()
			.astab(bonuses[STAB_ATTACK])	// 0
			.aslash(bonuses[SLASH_ATTACK])	// 1
			.acrush(bonuses[CRUSH_ATTACK])	// 2
			.amagic(bonuses[MAGIC_ATTACK])	// 3
			.arange(bonuses[RANGE_ATTACK])	// 4
			.dstab(bonuses[STAB_DEF])		// 5
			.dslash(bonuses[SLASH_DEF])		// 6
			.dcrush(bonuses[CRUSH_DEF])		// 7
			.dmagic(bonuses[MAGIC_DEF])		// 8
			.drange(bonuses[RANGE_DEF])		// 9
			.str(bonuses[STRENGTH_BONUS])	// 10
			.rstr(bonuses[RANGE_STRENGTH]) 	// 11
			.mdmg(bonuses[MAGIC_DAMAGE])	// 12
			.build();
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker;

import com.google.common.collect.ImmutableSet;
import com.google.gson.Gson;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializer;
import com.google.inject.Provides;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.Writer;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import javax.inject.Inject;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.controllers.Fighter;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.models.HitsplatInfo;
import matsyir.pvpperformancetracker.models.RangeAmmoData;
import matsyir.pvpperformancetracker.models.oldVersions.FightPerformance__1_5_5;
import matsyir.pvpperformancetracker.utils.PvpPerformanceTrackerUtils;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.HitsplatID;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.FakeXpDrop;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreEndpoint;
import net.runelite.client.hiscore.HiscoreManager;
import net.runelite.client.hiscore.HiscoreResult;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;


@Slf4j
@PluginDescriptor(
	name = "PvP Performance Tracker"
)
public class PvpPerformanceTrackerPlugin extends Plugin
{
	// static fields
	public static final String PLUGIN_VERSION = "1.7.1";
	public static final String CONFIG_KEY = "pvpperformancetracker";
	// Data folder naming history:
	// "pvp-performance-tracker": From release, until 1.5.9 update @ 2024-08-19
	// "pvp-performance-tracker2": From 1.5.9 update, until present
	public static final String DATA_FOLDER = "pvp-performance-tracker2";
	public static final String FIGHT_HISTORY_DATA_FNAME = "FightHistoryData.json";
	public static final File FIGHT_HISTORY_DATA_DIR;
	public static PvpPerformanceTrackerConfig CONFIG;
	public static PvpPerformanceTrackerPlugin PLUGIN;
	public static Image PLUGIN_ICON;
	public static AsyncBufferedImage DEFAULT_NONE_SYMBOL; // save bank filler image to display a generic "None" or N/A state.
	public static Gson GSON;

	// Last man standing map regions, including ferox enclave
	private static final Set<Integer> LAST_MAN_STANDING_REGIONS = ImmutableSet.of(12344, 12600, 13658, 13659, 13660, 13914, 13915, 13916, 13918, 13919, 13920, 14174, 14175, 14176, 14430, 14431, 14432);

	static
	{
		FIGHT_HISTORY_DATA_DIR = new File(RuneLite.RUNELITE_DIR, DATA_FOLDER);
		FIGHT_HISTORY_DATA_DIR.mkdirs();
	}

	// "native"/core RL fields/injected fields
	@Getter(AccessLevel.PACKAGE)
	private NavigationButton navButton;
	private boolean navButtonShown = false;

	@Getter(AccessLevel.PACKAGE)
	private PvpPerformanceTrackerPanel panel;

	@Inject
	private PvpPerformanceTrackerConfig config;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Getter
	@Inject
	private Client client;

	@Getter
	@Inject
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ConfigManager configManager;

	@Getter
	@Inject
	private RuneLiteConfig runeliteConfig;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PvpPerformanceTrackerOverlay overlay;

	@Getter
	@Inject
	private ItemManager itemManager;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private Gson injectedGson;

	@Inject
	private HiscoreManager hiscoreManager; // Added injection

	// custom fields/props
	public ArrayList<FightPerformance> fightHistory;
	@Getter
	private FightPerformance currentFight;
	private Map<Integer, ImageIcon> spriteCache; // sprite cache since a small amount of sprites is re-used a lot
	// do not cache items in the same way since we could potentially cache a very large amount of them.
	private final Map<Integer, List<HitsplatInfo>> hitsplatBuffer = new HashMap<>();
	private final Map<Integer, List<HitsplatInfo>> incomingHitsplatsBuffer = new ConcurrentHashMap<>(); // Stores hitsplats *received* by players per tick.
	private HiscoreEndpoint hiscoreEndpoint = HiscoreEndpoint.NORMAL; // Added field

	// #################################################################################################################
	// ##################################### Core RL plugin functions & RL Events ######################################
	// #################################################################################################################

	@Provides
	PvpPerformanceTrackerConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PvpPerformanceTrackerConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		CONFIG = config; // save static instances of config/plugin to easily use in
		PLUGIN = this;   // other contexts without passing them all the way down or injecting
		fightHistory = new ArrayList<>();

		GSON = injectedGson.newBuilder()
			.excludeFieldsWithoutExposeAnnotation()
			.registerTypeAdapter(Double.class, (JsonSerializer<Double>) (value, theType, context) ->
				value.isNaN() ? new JsonPrimitive(0) // Convert NaN to zero, otherwise, return as BigDecimal with scale of 3.
					: new JsonPrimitive(BigDecimal.valueOf(value).setScale(3, RoundingMode.HALF_UP))
			).create();

		if (!config.pluginVersion().equals(PLUGIN_VERSION))
		{
			this.update(config.pluginVersion());
		}

		panel = injector.getInstance(PvpPerformanceTrackerPanel.class);
		final BufferedImage icon = ImageUtil.getResourceStreamFromClass(getClass(), "/skull_red.png");
		PLUGIN_ICON = new ImageIcon(icon).getImage();
		navButton = NavigationButton.builder()
			.tooltip("PvP Fight History")
			.icon(icon)
			.priority(6)
			.panel(panel)
			.build();

		importFightHistoryData();

		// add the panel's nav button depending on config
		if (config.showFightHistoryPanel() &&
			(!config.restrictToLms() || (client.getGameState() == GameState.LOGGED_IN && isAtLMS())))
		{
			navButtonShown = true;
			clientToolbar.addNavigation(navButton);
		}

		overlayManager.add(overlay);

		spriteCache = new HashMap<>(); // prepare sprite cache

		// prepare default N/A or None symbol for eventual use.
		clientThread.invokeLater(() -> DEFAULT_NONE_SYMBOL = itemManager.getImage(20594));
		
		// Explicitly rebuild panel after all setup and import.
        SwingUtilities.invokeLater(() -> {
            if (panel != null) {
                panel.rebuild();
            }
        });
	}

	@Override
	protected void shutDown() throws Exception
	{
		saveFightHistoryData();

		clientToolbar.removeNavigation(navButton);
		overlayManager.remove(overlay);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(CONFIG_KEY)) { return; }

		switch(event.getKey())
		{
			// if a user enables the panel or restricts/unrestricts the location to LMS, hide/show the panel accordingly
			case "showFightHistoryPanel":
			case "restrictToLms":
				boolean isAtLms = isAtLMS();
				if (!navButtonShown && config.showFightHistoryPanel() &&
					(!config.restrictToLms() || isAtLms))
				{
					SwingUtilities.invokeLater(() -> clientToolbar.addNavigation(navButton));
					navButtonShown = true;
				}
				else if (navButtonShown && (!config.showFightHistoryPanel() || (config.restrictToLms() && !isAtLms)))
				{
					SwingUtilities.invokeLater(() -> clientToolbar.removeNavigation(navButton));
					navButtonShown = false;
				}
				break;
			// If a user makes any changes to the overlay configuration, reset the shown lines accordingly
			case "showOverlayTitle":
			case "showOverlayNames":
			case "showOverlayOffPray":
			case "showOverlayDeservedDmg":
			case "showOverlayExpectedDmg":
			case "showOverlayDmgDealt":
			case "showOverlayMagicHits":
			case "showOverlayOffensivePray":
			case "showOverlayHpHealed":
			case "showOverlayGhostBarrage":
				overlay.setLines();
				break;
			// If the user updates the fight history limit, remove fights as necessary
			case "fightHistoryLimit":
			case "fightHistoryRenderLimit":
				if (config.fightHistoryLimit() > 0 && fightHistory.size() > config.fightHistoryLimit())
				{
					int numToRemove = fightHistory.size() - config.fightHistoryLimit();
					// Remove oldest fightHistory until the size is smaller than the limit.
					// Should only remove one fight in most cases.
					fightHistory.removeIf((FightPerformance f) -> fightHistory.indexOf(f) < numToRemove);
				}
				panel.rebuild();
				break;
			case "exactNameFilter":
				panel.rebuild();
				break;
			case "settingsConfigured":
				boolean enableConfigWarning = !config.settingsConfigured();
				panel.setConfigWarning(enableConfigWarning);
				break;
			case "robeHitFilter":
				recalculateAllRobeHits(true);
				break;
				// potential future code for level presets/dynamic config if RL ever supports it.
//			case "attackLevel":
//			case "strengthLevel":
//			case "defenceLevel":
//			case "rangedLevel":
//			case "magicLevel":
//				log.info("TEST-just set a level");
//				configManager.setConfiguration(CONFIG_KEY, "levelPresetChoice", LevelConfigPreset.CUSTOM);
//				break;
//			case "levelPresetChoice":
//				log.info("TEST- just chose level preset choice");
//				LevelConfigPreset p = config.levelPresetChoice();
//				switch (p)
//				{
//					case CUSTOM:
//						break;
//					case LMS_STATS:
//					case NH_STAKE:
//						configManager.setConfiguration(CONFIG_KEY, "attackLevel", p.getAtk());
//						configManager.setConfiguration(CONFIG_KEY, "strengthLevel", p.getStr());
//						configManager.setConfiguration(CONFIG_KEY, "defenceLevel", p.getDef());
//						configManager.setConfiguration(CONFIG_KEY, "rangedLevel", p.getRange());
//						configManager.setConfiguration(CONFIG_KEY, "magicLevel", p.getMage());
//						break;
//
//				}
//				break;
		}
	}

	// Keep track of a player's new target using this event.
	// It's worth noting that if you aren't in a fight, all player interactions including
	// trading & following will trigger a new fight and a new opponent. Due to this, set the lastFightTime
	// (in FightPerformance) in the past to only be 5 seconds before the time NEW_FIGHT_DELAY would trigger
	// and unset the opponent, in case the player follows a different player before actually starting
	// a fight or getting attacked. In other words, remain skeptical of the validity of this event.
	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		if (config.restrictToLms() && !isAtLMS())
		{
			return;
		}

		checkForFightEnd();

		// if the client player already has a valid opponent AND the fight has started,
		// or the event source/target aren't players, skip any processing.
		if ((hasOpponent() && currentFight.fightStarted())
			|| !(event.getSource() instanceof Player)
			|| !(event.getTarget() instanceof Player))
		{
			return;
		}

		Actor opponent;

		// If the event source is the player, then it is the player interacting with their potential opponent.
		if (event.getSource().equals(client.getLocalPlayer()))
		{
			opponent = event.getTarget();
		}
		else if (event.getTarget().equals(client.getLocalPlayer()))
		{
			opponent = event.getSource();
		}
		else // if neither source or target was the player, skip
		{
			return;
		}

		// start a new fight with the newfound opponent, if a new one.
		if (!hasOpponent() || !currentFight.getOpponent().getName().equals(opponent.getName()))
		{
			currentFight = new FightPerformance(client.getLocalPlayer(), (Player)opponent);
			overlay.setFight(currentFight);
			hitsplatBuffer.clear();
			incomingHitsplatsBuffer.clear();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		sendUpdateChatMessage();

		hiscoreEndpoint = HiscoreEndpoint.fromWorldTypes(client.getWorldType()); // Update endpoint on login/world change

		// hide or show panel depending if config is restricted to LMS and if player is at LMS
		if (config.restrictToLms())
		{
			if (isAtLMS())
			{
				if (!navButtonShown && config.showFightHistoryPanel())
				{
					clientToolbar.addNavigation(navButton);
					navButtonShown = true;
				}
			}
			else
			{
				if (navButtonShown)
				{
					clientToolbar.removeNavigation(navButton);
					navButtonShown = false;
				}
			}
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		if (!hasOpponent()) { return; }

		checkForFightEnd();

		// delay the animation processing, since we will also want to use equipment data for expected
		// damage, and equipment updates are loaded after the animation updates.
		clientThread.invokeLater(() ->
		{
			if (hasOpponent() && event.getActor() instanceof Player && event.getActor().getName() != null)
			{
				currentFight.checkForAttackAnimations((Player)event.getActor(), new CombatLevels(client));
			}
		});
	}

	@Subscribe
	// track damage dealt/taken
	public void onHitsplatApplied(HitsplatApplied event)
	{
		Actor target;

		// if there's no opponent, the target is not a player, or the hitsplat is not relevant to pvp damage,
		// skip the hitsplat. Otherwise, add it to the fight, which will only include it if it is one of the
		// Fighters in the fight being hit.
		if (!hasOpponent() || !((target = event.getActor()) instanceof Player))
		{
			return;
		}

		int hitType = event.getHitsplat().getHitsplatType();
		int amount = event.getHitsplat().getAmount();

		// for non-zero hits, only process relevant hitsplat types
		if (amount > 0)
		{
			if (!(hitType == HitsplatID.DAMAGE_ME
				|| hitType == HitsplatID.DAMAGE_ME_ORANGE
				|| hitType == HitsplatID.DAMAGE_OTHER_ORANGE
				|| hitType == HitsplatID.DAMAGE_OTHER
				|| hitType == HitsplatID.DAMAGE_MAX_ME
				|| hitType == HitsplatID.DAMAGE_MAX_ME_ORANGE
				|| hitType == HitsplatID.POISON
				|| hitType == HitsplatID.VENOM
				|| hitType == HitsplatID.BURN))
			{
				return;
			}
		}

		currentFight.addDamageDealt(target.getName(), amount);

		// Exclude certain hitsplat types (like heal, burn, poison, venom, disease)
		// from the buffer used for HP-before-hit calculations.
		boolean isExcludedType = hitType == HitsplatID.HEAL ||
								 hitType == HitsplatID.POISON ||
								 hitType == HitsplatID.VENOM ||
								 hitType == HitsplatID.BURN ||
								 hitType == HitsplatID.DISEASE;

		if (isExcludedType)
		{
			return; // Don't buffer these types for HP calc / matching
		}

		// Store hitsplats received by competitor or opponent for potential vengeance trigger lookup
		Player player = client.getLocalPlayer();
		if (target == player || (hasOpponent() && target == currentFight.getOpponent().getPlayer()))
		{
			int currentTick = client.getTickCount();
			incomingHitsplatsBuffer.computeIfAbsent(currentTick, k -> new CopyOnWriteArrayList<>()).add(new HitsplatInfo(event));
		}

		// Buffer the hitsplat event instead of processing immediately (unless excluded earlier)
		// Vengeance damage hitsplats WILL be included here initially.
		HitsplatInfo info = new HitsplatInfo(event);
		int tick = client.getTickCount();
		List<HitsplatInfo> tickEvents = hitsplatBuffer.computeIfAbsent(tick, k -> new ArrayList<>());
		tickEvents.add(info);

		// Get the HP of the actor on the client thread, after the hitsplat has been applied.
		clientThread.invokeLater(() ->
		{
			Actor hitActor = info.getEvent().getActor();
			if (hitActor != null)
			{
				info.setHp(hitActor.getHealthRatio(), hitActor.getHealthScale());
			}
		});
	}

	@Subscribe
	// track hitpoints healed & ghost barrages for main competitor/client player
	public void onStatChanged(StatChanged statChanged)
	{
		Skill skill = statChanged.getSkill();
		if (!hasOpponent()) { return; }

		if (skill == Skill.HITPOINTS)
		{
			currentFight.updateCompetitorHp(client.getBoostedSkillLevel(Skill.HITPOINTS));
		}

		if (skill == Skill.MAGIC)
		{
			int magicXp = client.getSkillExperience(Skill.MAGIC);
			if (magicXp > currentFight.competitor.getLastGhostBarrageCheckedMageXp())
			{
				currentFight.competitor.setLastGhostBarrageCheckedMageXp(PLUGIN.getClient().getSkillExperience(Skill.MAGIC));
				clientThread.invokeLater(this::checkForGhostBarrage);
			}
		}
	}

	@Subscribe
	// track ghost barrages for main competitor/client player
	public void onFakeXpDrop(FakeXpDrop fakeXpDrop)
	{
		if (!hasOpponent() || fakeXpDrop.getSkill() != Skill.MAGIC) { return; }

		clientThread.invokeLater(this::checkForGhostBarrage);
	}

	// if the player gained magic xp but doesn't have a magic-attack animation, consider it as a ghost barrage.
	// however this won't be added as a normal attack, it is for an extra ghost-barrage statistic as
	// we can only detect this for the local player
	private void checkForGhostBarrage()
	{
		if (!hasOpponent()) { return; }

		currentFight.checkForLocalGhostBarrage(new CombatLevels(client), client.getLocalPlayer());
	}

	// When the config is reset, also reset the fight history data, as a way to restart
	// if the current data is causing problems.
	@Override
	public void resetConfiguration()
	{
		super.resetConfiguration();
		resetFightHistory();
	}

	// when the client shuts down, save the fight history data locally.
	@Subscribe
	public void onClientShutdown(ClientShutdown event)
	{
		event.waitFor(executor.submit(this::saveFightHistoryData));
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		// if there is no ongoing fight, skip any onGameTick processing.
		// We should have enough extra ticks to calc any hitsplats during death animations and empty these queues.
		if (!hasOpponent()) { return; }

		// Process hitsplats from the previous tick
		int currentTick = client.getTickCount();
		int tickToProcess = currentTick - 1;
		int maxWindow = 5;
		List<HitsplatInfo> hitsplatsToProcess = hitsplatBuffer.remove(tickToProcess);

		// --- START: New Pre-processing Logic ---
		if (hitsplatsToProcess != null && !hitsplatsToProcess.isEmpty())
		{
			// 1. Calculate total expected hits from pending attacks for this tick
			int totalExpectedAttackHits = 0;
			Player player = client.getLocalPlayer();
			// Assuming getOpponentName() and getOpponentActor() exist or accessing opponent/competitor directly
			Actor opponentActor = currentFight.getOpponent().getPlayer();

			// Sum expected hits from opponent's pending attacks targeting player
			if (currentFight.getOpponent() != null)
			{
				totalExpectedAttackHits += currentFight.getOpponent().getPendingAttacks().stream()
					.filter(e -> !e.isKoChanceCalculated() && e.isFullEntry() && !e.isSplash() && (tickToProcess - e.getTick() <= 5)) // Check if attack could land now
					.mapToInt(FightLogEntry::getExpectedHits)
					.sum();
			}
			// Sum expected hits from competitor's pending attacks targeting opponent
			if (currentFight.getCompetitor() != null)
			{
				totalExpectedAttackHits += currentFight.getCompetitor().getPendingAttacks().stream()
					.filter(e -> !e.isKoChanceCalculated() && e.isFullEntry() && !e.isSplash() && (tickToProcess - e.getTick() <= 5)) // Check if attack could land now
					.mapToInt(FightLogEntry::getExpectedHits)
					.sum();
			}

			// 2. Compare observed vs expected
			if (hitsplatsToProcess.size() > totalExpectedAttackHits)
			{
				log.debug("Tick {}: Observed hits ({}) > Expected attack hits ({}). Checking for special hits...",
					tickToProcess, hitsplatsToProcess.size(), totalExpectedAttackHits);

				boolean removedHitInIteration;
				int safetyBreakCounter = 0;
				int maxIterations = hitsplatsToProcess.size() * 2; // Allow more iterations to be safe

				// 3. Loop while observed > expected (or until no more candidates found)
				while (hitsplatsToProcess.size() > totalExpectedAttackHits && safetyBreakCounter++ < maxIterations)
				{
					removedHitInIteration = false;
					Iterator<HitsplatInfo> iterator = hitsplatsToProcess.iterator();

					while (iterator.hasNext())
					{
						HitsplatInfo potentialSpecialHit = iterator.next();
						Actor target = potentialSpecialHit.getEvent().getActor();
						int hitAmount = potentialSpecialHit.getEvent().getHitsplat().getAmount();
						boolean isCandidate = false;

						// Determine who the 'other' player is (the one who might have *caused* veng/recoil)
						Actor otherPlayer = null;
						if (target == player)
						{
							otherPlayer = opponentActor;
						}
						else if (target == opponentActor)
						{
							otherPlayer = player;
						}

						// 4. Check Candidates (Vengeance/Recoil)
						if (otherPlayer != null)
						{
							List<HitsplatInfo> incomingHitsOnOther = incomingHitsplatsBuffer.get(tickToProcess);
							if (incomingHitsOnOther != null)
							{
								for (HitsplatInfo incomingHit : incomingHitsOnOther)
								{
									// Only check hits *received* by the other player
									if (incomingHit.getEvent().getActor() == otherPlayer)
									{
										int incomingDamage = incomingHit.getEvent().getHitsplat().getAmount();

										// Vengeance Check
										int expectedVengeance = Math.max(1, (int) Math.floor(incomingDamage * 0.75));
										if (hitAmount == expectedVengeance)
										{
											log.debug("Tick {}: Found potential Vengeance hit ({} damage) on {} based on {} incoming damage on {}",
												tickToProcess, hitAmount, target.getName(), incomingDamage, otherPlayer.getName());
											isCandidate = true;
											break; // Found a reason, no need to check other incoming hits for this potentialSpecialHit
										}

										// Recoil Check
										int expectedRecoil = Math.max(1, (int) Math.floor(incomingDamage * 0.10) + 1);
										if (hitAmount == expectedRecoil)
										{
											log.debug("Tick {}: Found potential Recoil hit ({} damage) on {} based on {} incoming damage on {}",
												tickToProcess, hitAmount, target.getName(), incomingDamage, otherPlayer.getName());
											isCandidate = true;
											break;
										}
									}
								}
							}
						}

						// burn hitsplats are excluded earlier in onHitsplatApplied

						// 5. Remove if Candidate Found
						if (isCandidate)
						{
							iterator.remove();
							removedHitInIteration = true;
							break; // Exit inner loop, re-check outer while condition
						}
					} // End inner iterator loop

					// Safety break if no hits were removed in a full pass
					if (!removedHitInIteration)
					{
						log.debug("Tick {}: No special hit candidates removed in iteration. Breaking pre-emptive removal.", tickToProcess);
						break;
					}
				} // End outer while loop
			} // End if (observed > expected)
		}
		// --- END: New Pre-processing Logic ---


		// Cleanup happens regardless of whether hitsplats were processed this tick
		// Check if hitsplatsToProcess became null or empty after pre-processing
		// If there is no active fight anymore, avoid accessing currentFight below.
		if (hitsplatsToProcess == null || hitsplatsToProcess.isEmpty() || !hasOpponent())
		{
			// Cleanup old entries from buffers
			hitsplatBuffer.keySet().removeIf(tick -> tick < currentTick - maxWindow);
			incomingHitsplatsBuffer.keySet().removeIf(tick -> tick < currentTick - maxWindow);
			return;
		}

		// --- Proceed with Regular Matching using the potentially modified hitsplatsToProcess ---

		// Group hitsplats by the actor receiving them (remaining hitsplats after special removal)
		final List<HitsplatInfo> finalHitsplatsToProcess = hitsplatsToProcess; // Create effectively final list
		Map<Actor, List<HitsplatInfo>> hitsByActor = finalHitsplatsToProcess.stream()
			.collect(Collectors.groupingBy((HitsplatInfo info) -> info.getEvent().getActor()));

		List<FightLogEntry> processedEntriesThisTick = new ArrayList<>();

		hitsByActor.forEach((opponent, hits) -> {
			if (!(opponent instanceof Player)) return; // Only process hits on players

			// Determine max HP to use (config, Hiscores, or LMS override)
			int maxHpToUse;
			if (isAtLMS())
			{
				maxHpToUse = 99;
			}
			else
			{
				maxHpToUse = CONFIG.opponentHitpointsLevel();

				// Hiscores lookup should only happen if not in LMS
				if (opponent.getName() != null)
				{
					final HiscoreResult hiscoreResult = hiscoreManager.lookupAsync(opponent.getName(), hiscoreEndpoint);
					if (hiscoreResult != null)
					{
						final int hp = hiscoreResult.getSkill(HiscoreSkill.HITPOINTS).getLevel();
						if (hp > 0)
						{
							maxHpToUse = hp; // Use Hiscores HP if available
						}
					}
				}
			}

			// Determine attacker safely (handle null names and prefer identity when possible)
			String actorName = ((Player) opponent).getName();
			Fighter attacker;
			Player trackedOppPlayer = currentFight.getOpponent().getPlayer();
			Player trackedCompPlayer = currentFight.getCompetitor().getPlayer();

			boolean opponentIsTrackedOpponent = opponent == trackedOppPlayer || Objects.equals(actorName, currentFight.getOpponent().getName());
			boolean opponentIsTrackedCompetitor = opponent == trackedCompPlayer || Objects.equals(actorName, currentFight.getCompetitor().getName());

			if (opponentIsTrackedOpponent)
			{
				attacker = currentFight.getCompetitor();
			}
			else if (opponentIsTrackedCompetitor)
			{
				attacker = currentFight.getOpponent();
			}
			else
			{
				return;
			}

			// Get all potentially relevant, unprocessed entries sorted by animation tick
			List<FightLogEntry> candidateEntries = attacker.getPendingAttacks().stream()
				.filter(e -> !e.isKoChanceCalculated() && e.isFullEntry() && !e.isSplash())
				.filter(e -> (client.getTickCount() - e.getTick()) <= 5)
				.sorted(Comparator.comparingInt(FightLogEntry::getTick))
				.collect(Collectors.toList());

			List<FightLogEntry> gmaulsMatchedThisTick = new ArrayList<>();
			int totalGmaulHitsMatchedThisTick = 0;

			// Iterate through candidate entries chronologically
			for (FightLogEntry entry : candidateEntries)
			{

				// Apply specific lookback for the entry's style
				int lookback;
				switch (entry.getAnimationData().attackStyle)
				{
					case STAB: case SLASH: case CRUSH: lookback = 3; break;
					case MAGIC: lookback = 5; break;
					case RANGED: default: lookback = 3; break;
				}
				if (client.getTickCount() - entry.getTick() > lookback)
				{
					entry.setKoChanceCalculated(true);
					attacker.getPendingAttacks().remove(entry);
					continue;
				}

				int toMatch = entry.getExpectedHits() - entry.getMatchedHitsCount();
				if (toMatch <= 0)
				{
					entry.setKoChanceCalculated(true);
					attacker.getPendingAttacks().remove(entry);
					continue;
				}

				boolean isInstantGmaulCheck = entry.isGmaulSpecial() && entry.getTick() == tickToProcess;
				boolean isDelayedAttack = !isInstantGmaulCheck;

				// Only try to match if it's either an instant GMaul or a delayed attack landing now
				if (isInstantGmaulCheck || isDelayedAttack)
				{
					int matchedThisCycle = 0;
					int damageThisCycle = 0;
					HitsplatInfo lastMatchedInfo = null;
					Iterator<HitsplatInfo> hitsIter = hits.iterator();

					// Gmaul can hit twice, others match expected hits
					int hitsToFind = entry.isGmaulSpecial() ? 2 : toMatch;

					while (matchedThisCycle < hitsToFind && hitsIter.hasNext())
					{
						HitsplatInfo hInfo = hitsIter.next();
						int amt = hInfo.getEvent().getHitsplat().getAmount();
						damageThisCycle += amt;
						matchedThisCycle++;
						lastMatchedInfo = hInfo;
						hitsIter.remove();
					}

					if (matchedThisCycle > 0)
					{
						entry.setActualDamageSum(entry.getActualDamageSum() + damageThisCycle);
						entry.setMatchedHitsCount(entry.getMatchedHitsCount() + matchedThisCycle);
						processedEntriesThisTick.add(entry);

						if (entry.isGmaulSpecial())
						{
							gmaulsMatchedThisTick.add(entry);
							totalGmaulHitsMatchedThisTick += matchedThisCycle;
						}

						if (entry.getHitsplatTick() < 0 && lastMatchedInfo != null)
						{
							entry.setHitsplatTick(tickToProcess);
						}

						// Calculate and set estimated HP Before using polled HP
						int ratio = -1, scale = -1;
						if (lastMatchedInfo != null)
						{
							ratio = lastMatchedInfo.getHealthRatio();
							scale = lastMatchedInfo.getHealthScale();
						}
						// Fallback to current ratio/scale if polled is unavailable
						if (ratio < 0 || scale <= 0) { ratio = opponent.getHealthRatio(); scale = opponent.getHealthScale(); }
						int hpBefore = -1;
						if (ratio >= 0 && scale > 0 && maxHpToUse > 0)
						{
							hpBefore = PvpPerformanceTrackerUtils.calculateHpBeforeHit(ratio, scale, maxHpToUse, entry.getActualDamageSum());
						}
						if (hpBefore > 0)
						{
							entry.setEstimatedHpBeforeHit(hpBefore);
							entry.setOpponentMaxHp(maxHpToUse);
						}
					}
				}

				// Mark entry as fully processed if all expected hits are matched OR if it's an instant Gmaul (even if only 1 hit matched)
				if (entry.getMatchedHitsCount() >= entry.getExpectedHits() || isInstantGmaulCheck)
				{
					entry.setKoChanceCalculated(true);
					attacker.getPendingAttacks().remove(entry);
				}
			}

			// Gmaul Damage Scaling (Applied after all matching for the tick)
			boolean isMultiHitGmaul = totalGmaulHitsMatchedThisTick >= 2;
			if (isMultiHitGmaul)
			{
				for (FightLogEntry gmaulEntry : gmaulsMatchedThisTick)
				{
					int originalMin = gmaulEntry.getMinHit();
					int originalMax = gmaulEntry.getMaxHit();
					double originalExpected = gmaulEntry.getExpectedDamage();
					gmaulEntry.setMaxHit(originalMax * totalGmaulHitsMatchedThisTick);
					gmaulEntry.setMinHit(originalMin * totalGmaulHitsMatchedThisTick);
					gmaulEntry.setExpectedDamage(originalExpected * totalGmaulHitsMatchedThisTick);
				}
			}
		});

		// Post-processing for Display HP/KO Chance
		if (!processedEntriesThisTick.isEmpty())
		{
			// Group processed entries by the tick they landed and the attacker
			Map<Integer, Map<String, List<FightLogEntry>>> groupedByTickAndAttacker = processedEntriesThisTick.stream()
				.filter(e -> e.getHitsplatTick() >= 0)
				.collect(Collectors.groupingBy(
					FightLogEntry::getHitsplatTick,
					Collectors.groupingBy(
						FightLogEntry::getAttackerName,
						Collectors.toList()
					)
				));

			groupedByTickAndAttacker.forEach((tick, attackerMap) -> {
				attackerMap.forEach((attackerName, entries) -> {
					if (entries.isEmpty()) return;

					// Sort entries within the tick group by their original animation tick
					entries.sort(Comparator.comparingInt(FightLogEntry::getTick));

					boolean isGroup = entries.size() > 1;

					// Calculate Correct Starting HP for Forward Cascade
					Integer hpBeforeSequence = null;
					FightLogEntry lastEntry = entries.get(entries.size() - 1);
					Integer hpBeforeLastHit = lastEntry.getEstimatedHpBeforeHit();
					Integer lastHitDamage = lastEntry.getActualDamageSum();

					// Ensure we have the necessary values from the last hit to calculate final HP
					if (hpBeforeLastHit != null && lastHitDamage != null)
					{
						Integer hpAfterSequence = hpBeforeLastHit - lastHitDamage;

						// Calculate total damage for the sequence
						int totalDamageInSequence = entries.stream()
							.mapToInt((FightLogEntry e) -> e.getActualDamageSum() != null ? e.getActualDamageSum() : 0)
							.sum();

						// Calculate HP Before the entire sequence
						hpBeforeSequence = hpAfterSequence + totalDamageInSequence;
					}

					// If hpBeforeSequence is still null (calculation failed), try fallback using first entry's estimate
					if (hpBeforeSequence == null)
					{
						hpBeforeSequence = entries.get(0).getEstimatedHpBeforeHit();
					}

					// Forward Cascade for Display
					Integer currentHp = hpBeforeSequence;
					for (FightLogEntry entry : entries)
					{
						Integer hpBeforeCurrent = currentHp;
						int damageCurrent = entry.getActualDamageSum() != null ? entry.getActualDamageSum() : 0;
						Integer hpAfterCurrent = (hpBeforeCurrent != null) ? hpBeforeCurrent - damageCurrent : null;

						entry.setDisplayHpBefore(hpBeforeCurrent);
						entry.setDisplayHpAfter(hpAfterCurrent);

						Double koChanceCurrent = (hpBeforeCurrent != null)
							? PvpPerformanceTrackerUtils.calculateKoChance(entry.getAccuracy(), entry.getMinHit(), entry.getMaxHit(), hpBeforeCurrent)
							: null;
						entry.setDisplayKoChance(koChanceCurrent);
						entry.setKoChance(koChanceCurrent);

						currentFight.updateKoChanceStats(entry);

						entry.setPartOfTickGroup(isGroup);

						// Update HP for the next iteration
						currentHp = hpAfterCurrent;
				}
				});
			});
		}

		// Cleanup old entries from buffers at the end of the tick processing
		hitsplatBuffer.keySet().removeIf(tick -> tick < currentTick - maxWindow);
		incomingHitsplatsBuffer.keySet().removeIf(tick -> tick < currentTick - maxWindow);
	}

	@Subscribe
	public void onPlayerDespawned(PlayerDespawned event)
	{
		if (!hasOpponent()) { return; }
		Player despawned = event.getPlayer();
		if (despawned == null || despawned.getName() == null) { return; }

		if (currentFight == null || currentFight.getOpponent() == null) { return; }
		String opponentName = currentFight.getOpponent().getName();
		if (opponentName == null) { return; }

		// End fight when opponent despawns after a death was observed on either side
		if (despawned.getName().equals(opponentName) && (currentFight.getOpponent().isDead() || currentFight.getCompetitor().isDead()))
		{
			onFightEnded();
		}
	}

	// #################################################################################################################
	// ################################## Plugin-specific functions & global helpers ###################################
	// #################################################################################################################

	private void sendUpdateChatMessage()
	{
		if (configManager.getConfiguration(CONFIG_KEY, config.updateMsgKey, boolean.class)) { return; }

		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.GAMEMESSAGE)
				.runeLiteFormattedMessage("PvP Performance Tracker 1.7.1 Update: " +
						"Support for god spells, special attacks for arkan blade, burning claws & dark bow. " +
						"Double deaths now tracked. New statistic labels & improved tooltips. Various calculation & " +
						"detection improvements. Renamed Deserved damage to Expected damage.")
				.build());
		configManager.setConfiguration(CONFIG_KEY, config.updateMsgKey, true);

		// remove any old unnecessary ones after updating
		configManager.unsetConfiguration(CONFIG_KEY, "updateNoteMay72025Shown_v2");
	}

	private void update(String oldVersion)
	{
		switch (oldVersion)
		{
			case "1.4.0":
			case "1.4.1":
			case "1.4.2":
			case "1.4.3":
			case "1.4.4":
			case "1.4.5":
			case "1.4.6":
			case "1.4.7":
			case "1.4.8":
			case "1.5.0":
			case "1.5.1":
			case "1.5.2":
			case "1.5.3":
			case "1.5.4":
			case "1.5.5":
				updateFrom1_5_5to1_5_6();
				break;
			case "1.6.2":
				updateFrom1_6_2to1_6_3();
				break;
		}

		configManager.setConfiguration(CONFIG_KEY, "pluginVersion", PLUGIN_VERSION);
	}

	// very basic update: We added the new hit on robe statistic, instantly recalculate it on launch,
	// so that the statistic will be visible for new players (without having to change the config)
	private void updateFrom1_6_2to1_6_3()
	{
		importFightHistoryData();

		// don't rebuild the panel since it doesn't exist yet at this point, will be rebuilt after this update() call.
		recalculateAllRobeHits(false);

		// re-save the fights that were populated with robe hit statistics
		saveFightHistoryData();
	}

	private void updateFrom1_5_5to1_5_6()
	{
		try
		{
			log.info("Updating data from 1.5.5 (or earlier) to 1.5.6...");

			FIGHT_HISTORY_DATA_DIR.mkdirs();
			File fightHistoryData = new File(FIGHT_HISTORY_DATA_DIR, FIGHT_HISTORY_DATA_FNAME);

			// if the fight history data file doesn't exist, create it with an empty array.
			if (!fightHistoryData.exists())
			{
				Writer writer = new FileWriter(fightHistoryData);
				writer.write("[]");
				writer.close();
				return;
			}

			fightHistory.clear();

			// read the old saved fights from the file into an array, and add them as an updated
			// fight to the fightHistory list.
			Arrays.asList(GSON.fromJson(new FileReader(fightHistoryData), FightPerformance__1_5_5[].class))
				.forEach((oldFight) -> fightHistory.add(new FightPerformance(oldFight)));

			// now that the fights were deserialized and updated to the newest version, simply save them.
			// afterwards, they will be re-loaded normally. Bit inefficient but not a big deal
			saveFightHistoryData();
			log.info("Successfully updated from 1.5.5 to 1.5.6");
		}
		catch (Exception e)
		{
			log.warn("Error while updating fight history data from 1.5.5 to 1.5.6: " + e.getMessage());
			// Display no modal for this error since it could happen on client load and that has odd behavior.
		}
	}
	// Returns true if the player has an opponent.
	private boolean hasOpponent()
	{
		return currentFight != null;
	}


	private void checkForFightEnd()
	{
		if (!hasOpponent()) { return; }

		// ensure we check for death animations so that Fighter.isDead gets set properly, but we don't need to
		// use the state of deaths for ending fights YET (not instantly), we do that within onPlayerDespawned
		// in order to give everything time to process and allow time to check for double deaths, hitsplats etc
		currentFight.checkForDeathAnimations();

		// if the fight has been inactive for 20+ secs however (FightPerformance.NEW_FIGHT_DELAY, plus however long
		// until they triggered an event for this check), just end it.
		if (currentFight.isInactive())
		{
			onFightEnded();
		}
	}

	private void onFightEnded()
	{
		// add fight to fight history if it actually started
		if (currentFight.fightStarted())
		{
			addToFightHistory(currentFight);
		}
		currentFight = null;
		hitsplatBuffer.clear();
		incomingHitsplatsBuffer.clear();
	}

	// save the currently loaded fightHistory to the local json data so it is saved for the next client launch.
	private void saveFightHistoryData()
	{
		// silently ignore errors, which shouldn't really happen - but if they do, don't prevent the plugin
		// from continuing to work, even if there are issues saving the data.
		try
		{
			File fightHistoryData = new File(FIGHT_HISTORY_DATA_DIR, FIGHT_HISTORY_DATA_FNAME);
			Writer writer = new FileWriter(fightHistoryData);
			GSON.toJson(fightHistory, writer);
			writer.flush();
			writer.close();
		}
		catch (Exception e)
		{
			log.warn("Error ignored while updating fight history data: " + e.getMessage());
		}
	}

	// add fight to loaded fight history
	void addToFightHistory(FightPerformance fight)
	{
		if (fight == null) { return; }
		fightHistory.add(fight);
		// no need to sort, since they sort chronologically, but they should automatically be added that way.
		try {
			fight.calculateRobeHits(config.robeHitFilter());
		}
		catch (Exception e)
		{
			log.warn("Error calculating robe hits for new fight ({} vs {}): {}", 
				fight.getCompetitor() != null ? fight.getCompetitor().getName() : "N/A", 
				fight.getOpponent() != null ? fight.getOpponent().getName() : "N/A", 
				e.getMessage());
		}

		// remove fights as necessary to respect the fightHistoryLimit.
		if (config.fightHistoryLimit() > 0 && fightHistory.size() > config.fightHistoryLimit())
		{
			int numToRemove = fightHistory.size() - config.fightHistoryLimit();
			// Remove oldest fightHistory until the size is equal to the limit.
			// Should only remove one fight in most cases.
			fightHistory.removeIf((FightPerformance f) -> fightHistory.indexOf(f) < numToRemove);
			panel.rebuild();
		}
		else
		{
			panel.addFight(fight);
		}
	}

	void recalculateAllRobeHits(boolean rebuildPanel)
	{
		clientThread.invokeLater(() ->
		{
			// Recalculate robe hits for all fights based on the new filter and refresh UI
			for (FightPerformance f : fightHistory)
			{
				f.calculateRobeHits(config.robeHitFilter());
			}
			if (currentFight != null)
			{
				currentFight.calculateRobeHits(config.robeHitFilter());
			}
			if (rebuildPanel)
			{
				// Explicitly rebuild panel after recalculation.
				SwingUtilities.invokeLater(() -> {
					if (panel != null) {
						panel.rebuild();
					}
				});
			}
		});
	}

	// import complete fight history data from the saved json data file
	// this function only handles the direct file processing and json deserialization.
	// more specific FightPerformance processing is done in importFights()
	void importFightHistoryData()
	{
		// catch and ignore any errors we may have forgotten to handle - the import will fail but at least the plugin
		// will continue to function. This should only happen if their fight history data is corrupted/outdated.
		// The user will be notified by a modal if this happens.
		try
		{
			FIGHT_HISTORY_DATA_DIR.mkdirs();
			File fightHistoryData = new File(FIGHT_HISTORY_DATA_DIR, FIGHT_HISTORY_DATA_FNAME);

			// if the fight history data file doesn't exist, create it with an empty array.
			if (!fightHistoryData.exists())
			{
				Writer writer = new FileWriter(fightHistoryData);
				writer.write("[]");
				writer.close();
			}

			// read the saved fights from the file
			List<FightPerformance> savedFights = Arrays.asList(
				GSON.fromJson(new FileReader(fightHistoryData), FightPerformance[].class));

			fightHistory.clear();
			importFights(savedFights);
		}
		catch (Exception e)
		{
			log.warn("Error while deserializing fight history data: " + e.getMessage());
			// Display no modal for this error since it could happen on client load and that has odd behavior.
			return;
		}
	}

	// import additional/extra fight history data supplied by the user
	// this only does the direct json deserialization and success response (modals)
	// more specific FightPerformance processing is done in importFights()
	public void importUserFightHistoryData(String data)
	{
		if (data == null || data.trim().isEmpty()) { return; }
		try
		{
			// read saved fights from the data string and import them
			List<FightPerformance> savedFights = Arrays.asList(GSON.fromJson(data, FightPerformance[].class));
			importFights(savedFights);
			panel.rebuild();
			createConfirmationModal(true, "Successfully imported " + savedFights.size() + " fights.");
		}
		catch (Exception e)
		{
			log.warn("Error while importing user's fight history data: " + e.getMessage());
			// If an error was detected while deserializing fights, display that as a message dialog.
			createConfirmationModal(false, "Fight history data was invalid, and could not be imported.");
			return;
		}
	}

	// set fight log names after importing since they aren't serialized but are on the parent class
	public void initializeImportedFight(FightPerformance f)
	{
		// check for nulls in case the data was corrupted and entries are corrupted.
		if (f.getCompetitor() == null || f.getOpponent() == null ||
			f.getCompetitor().getFightLogEntries() == null || f.getOpponent().getFightLogEntries() == null)
		{
			return;
		}

		f.getCompetitor().getFightLogEntries().forEach((FightLogEntry l) ->
			l.attackerName = f.getCompetitor().getName());
		f.getOpponent().getFightLogEntries().forEach((FightLogEntry l) ->
			l.attackerName = f.getOpponent().getName());
	}

	// process and add a list of deserialized json fights to the currently loaded fights
	// can throw NullPointerException if some of the serialized data is corrupted
	void importFights(List<FightPerformance> fights) throws NullPointerException
	{
		if (fights == null || fights.isEmpty()) { return; }

		fights.removeIf(Objects::isNull);
		fightHistory.addAll(fights);
		fightHistory.sort(FightPerformance::compareTo);

		// remove fights to respect the fightHistoryLimit.
		if (config.fightHistoryLimit() > 0 && fightHistory.size() > config.fightHistoryLimit())
		{
			int numToRemove = fightHistory.size() - config.fightHistoryLimit();
			// Remove oldest fightHistory until the size is equal to the limit.
			// Should only remove one fight in most cases.
			fightHistory.removeIf((FightPerformance f) -> fightHistory.indexOf(f) < numToRemove);
		}

		// set fight log names since they aren't serialized but are on the parent class
		for (FightPerformance f : fightHistory)
		{
			initializeImportedFight(f);
		}
	}

	// reset the loaded fight history as well as the saved json data
	public void resetFightHistory()
	{
		fightHistory.clear();
		saveFightHistoryData();
		panel.rebuild();
	}

	// remove a fight from the loaded fight history
	public void removeFight(FightPerformance fight)
	{
		fightHistory.remove(fight);
		panel.rebuild();
	}

	public boolean isAtLMS()
	{
		final int[] mapRegions = client.getMapRegions();

		for (int region : LAST_MAN_STANDING_REGIONS)
		{
			if (ArrayUtils.contains(mapRegions, region))
			{
				return true;
			}
		}

		return false;
	}

	// Send a message to the chat. Send them messages to the trade chat since it is uncommonly
	// used while fighting, but game, public, private, and clan chat all have their uses.
	public void sendTradeChatMessage(String chatMessage)
	{
		chatMessageManager
			.queue(QueuedMessage.builder()
				.type(ChatMessageType.TRADE)
				.runeLiteFormattedMessage(chatMessage)
				.build());
	}

	// create a simple confirmation modal, using a custom dialog so it can be always
	// on top (if the client is, to prevent being stuck under the client).
	public void createConfirmationModal(boolean success, String message)
	{
		SwingUtilities.invokeLater(() ->
		{
			JOptionPane optionPane = new JOptionPane();
			optionPane.setMessage(message);
			optionPane.setOptionType(JOptionPane.DEFAULT_OPTION);
			JDialog dialog = optionPane.createDialog(panel, "PvP Tracker: " + (success ? "Success" : "Error"));
			if (dialog.isAlwaysOnTopSupported())
			{
				dialog.setAlwaysOnTop(runeliteConfig.gameAlwaysOnTop());
			}
			dialog.setIconImage(PLUGIN_ICON);
			dialog.setVisible(true);
		});
	}

	// save the complete fight history data to the clipboard.
	public void exportFightHistory()
	{
		String fightHistoryDataJson = GSON.toJson(fightHistory.toArray(new FightPerformance[0]), FightPerformance[].class);
		final StringSelection contents = new StringSelection(fightHistoryDataJson);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);

		createConfirmationModal(true, "Fight history data was copied to the clipboard.");
	}

	public void exportFight(FightPerformance fight)
	{
		if (fight == null) { return; }
		String fightDataJson = GSON.toJson(fight, FightPerformance.class);
		final StringSelection contents = new StringSelection(fightDataJson);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);

		boolean success = false;
		String confirmMessage;
		if (fight.getCompetitor() != null && fight.getCompetitor().getName() != null &&
			fight.getOpponent() != null && fight.getOpponent().getName() != null)
		{
			success = true;
			confirmMessage = "Fight data of " + fight.getCompetitor().getName() + " vs " +
				fight.getOpponent().getName() + " was copied to the clipboard.";
		}
		else
		{
			confirmMessage = "Warning: Fight data was copied to the clipboard, but it's likely corrupted.";
		}
		createConfirmationModal(success, confirmMessage);
	}

	// retrieve offensive pray as SpriteID since that's all we will directly use it for,
	// aside from comparison/equality checks, so we save an extra mapping this way
	public int currentlyUsedOffensivePray()
	{
		return client.isPrayerActive(Prayer.PIETY) 				? SpriteID.PRAYER_PIETY :
				client.isPrayerActive(Prayer.ULTIMATE_STRENGTH) ? SpriteID.PRAYER_ULTIMATE_STRENGTH :
				client.isPrayerActive(Prayer.RIGOUR) 			? SpriteID.PRAYER_RIGOUR :
				client.isPrayerActive(Prayer.EAGLE_EYE) 		? SpriteID.PRAYER_EAGLE_EYE :
				client.isPrayerActive(Prayer.AUGURY) 			? SpriteID.PRAYER_AUGURY :
				client.isPrayerActive(Prayer.MYSTIC_MIGHT)		? SpriteID.PRAYER_MYSTIC_MIGHT :
				0;
	}

	public void addSpriteToLabelIfValid(JLabel label, int spriteId, Runnable swingCallback)
	{
		// Invalid sprite: set icon to bank filler and tooltip to N/A
		if (spriteId <= 0)
		{
			DEFAULT_NONE_SYMBOL.addTo(label);
			label.setToolTipText("N/A");

			if (swingCallback != null)
			{
				SwingUtilities.invokeLater(swingCallback);
			}
			return;
		}

		// if sprite id found in sprite cache: use it.
		if (spriteCache.containsKey(spriteId))
		{
			label.setIcon(spriteCache.get(spriteId));
			if (swingCallback != null)
			{
				SwingUtilities.invokeLater(swingCallback);
			}
			return;
		}

		// if sprite id wasn't in sprite cache: get it, use it and add it to the cache
		clientThread.invokeLater(() ->
		{
			BufferedImage sprite = spriteManager.getSprite(spriteId, 0);
			if (sprite != null)
			{
				ImageIcon icon = new ImageIcon(sprite);
				spriteCache.put(spriteId, icon);
				label.setIcon(icon);
			}
			else
			{
				DEFAULT_NONE_SYMBOL.addTo(label);
				label.setToolTipText("N/A");
			}

			if (swingCallback != null)
			{
				SwingUtilities.invokeLater(swingCallback);
			}
		});
	}

	public void addSpriteToLabelIfValid(JLabel label, int spriteId)
	{
		addSpriteToLabelIfValid(label, spriteId, null);
	}

	// if verifyId is true, takes in itemId directly from PlayerComposition
	// otherwise, assume valid itemId
	public void addItemToLabelIfValid(JLabel label, int itemId, boolean verifyId, Runnable swingCallback, String tooltipOverride)
	{
		if (itemId > PlayerComposition.ITEM_OFFSET || !verifyId)
		{
			final int finalItemId = itemId - (verifyId ? PlayerComposition.ITEM_OFFSET : 0);
			clientThread.invokeLater(() -> {
				itemManager.getImage(finalItemId).addTo(label);
				if (tooltipOverride != null && !tooltipOverride.isEmpty())
				{
					label.setToolTipText(tooltipOverride);
				}
				else
				{
					String name = itemManager.getItemComposition(finalItemId).getName();
					label.setToolTipText(name != null ? name : "Item Name Not Found");
				}

				if (swingCallback != null)
				{
					SwingUtilities.invokeLater(swingCallback);
				}
			});
		}
		else
		{
			DEFAULT_NONE_SYMBOL.addTo(label);
			label.setToolTipText("N/A: empty slot or invalid item");
			if (swingCallback != null)
			{
				SwingUtilities.invokeLater(swingCallback);
			}
		}
	}

	public void addItemToLabelIfValid(JLabel label, RangeAmmoData data, boolean verifyId, Runnable swingCallback)
	{
		addItemToLabelIfValid(label, data.getItemId(), verifyId, swingCallback, data.toString());
	}

	public void addItemToLabelIfValid(JLabel label, int itemId, boolean verifyId, Runnable swingCallback)
	{
		addItemToLabelIfValid(label, itemId, verifyId, swingCallback, null);
	}

	public void addItemToLabelIfValid(JLabel label, int itemId)
	{
		addItemToLabelIfValid(label, itemId, true, null);
	}

	public void updateNameFilterConfig(String newFilterName)
	{
		configManager.setConfiguration(CONFIG_KEY, "nameFilter", newFilterName.trim().toLowerCase());
	}
}

package matsyir.pvpperformancetracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PvpPerformanceTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PvpPerformanceTrackerPlugin.class);
		RuneLite.main(args);
	}
}
