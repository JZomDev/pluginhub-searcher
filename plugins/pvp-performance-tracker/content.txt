package matsyir.pvpperformancetracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PvpPerformanceTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PvpPerformanceTrackerPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c)  2020, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.overlay.Overlay;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class PvpPerformanceTrackerOverlay extends Overlay
{
	private final PanelComponent panelComponent = new PanelComponent();
	private final PvpPerformanceTrackerPlugin plugin;
	private final PvpPerformanceTrackerConfig config;

	private TitleComponent overlayTitle;

	// The main overlay is like the panel, each line is optionally turned off.
	private LineComponent overlayFirstLine; // Left: player's RSN, Right: Opponent RSN
	private LineComponent overlaySecondLine; // left: player's off-pray stats, right: opponent's off-pray stats
	private LineComponent overlayThirdLine; // left: player's deserved dps stats, right: opponent's deserved dps stats
	private LineComponent overlayFourthLine; // left: player's damage dealt stats, right: opponent's damage dealt stats
	private LineComponent overlayFifthLine; // left: player's magic attacks hit stats, right: opponent's magic attacks hit stats
	private LineComponent overlaySixthLine; // left: player's offensive pray stats, right: opponent's offensive pray stats
	private LineComponent overlaySeventhLine; // left: player's hp healed pray stats, right: opponent's hp healed
	private LineComponent overlayEighthLine; // left: player's ghost barrage stats, right: opponent's ghost barrage stats

	@Inject
	private PvpPerformanceTrackerOverlay(PvpPerformanceTrackerPlugin plugin, PvpPerformanceTrackerConfig config)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.BOTTOM_RIGHT);
		setPriority(OverlayPriority.LOW);
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "PvP Performance Tracker"));
		panelComponent.setPreferredSize(new Dimension(ComponentConstants.STANDARD_WIDTH, 0));

		overlayTitle = TitleComponent.builder().text("PvP Performance").build();

		overlayFirstLine = LineComponent.builder().build();
		overlaySecondLine = LineComponent.builder().build();
		overlayThirdLine = LineComponent.builder().build();
		overlayFourthLine = LineComponent.builder().build();
		overlayFifthLine = LineComponent.builder().build();
		overlaySixthLine = LineComponent.builder().build();
		overlaySixthLine.setLeftColor(Color.WHITE); // this is static so set onload
		overlaySixthLine.setRight("N/A"); // static
		overlaySixthLine.setRightColor(Color.WHITE); // static
		overlaySeventhLine = LineComponent.builder().build();
		overlaySeventhLine.setLeftColor(Color.WHITE); // this is static so set onload
		overlaySeventhLine.setRight("N/A"); // static
		overlaySeventhLine.setRightColor(Color.WHITE); // static
		overlayEighthLine = LineComponent.builder().build();
		overlayEighthLine.setLeft("N/A"); // not static but possibly unused for some full fights
		overlayEighthLine.setLeftColor(ColorScheme.BRAND_ORANGE); // static
		overlayEighthLine.setRight("N/A"); // static
		overlayEighthLine.setRightColor(ColorScheme.BRAND_ORANGE); // static

		setLines();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		FightPerformance fight = plugin.getCurrentFight();
		if (!config.showFightOverlay() || fight == null || !fight.fightStarted() ||
			(config.restrictToLms() && !plugin.isAtLMS()))
		{
			return null;
		}

		// Second line: off-pray hit success stats
		overlaySecondLine.setLeft(fight.getCompetitor().getOffPrayStats(true));
		overlaySecondLine.setLeftColor(fight.competitorOffPraySuccessIsGreater() ? Color.GREEN : Color.WHITE);
		overlaySecondLine.setRight(fight.getOpponent().getOffPrayStats(true));
		overlaySecondLine.setRightColor(fight.opponentOffPraySuccessIsGreater() ? Color.GREEN : Color.WHITE);

		// Third line: Deserved damage stats
		// only show deserved damage difference on the competitor, since space is restricted here and having both
		// differences is redundant since the sign is simply flipped.
		overlayThirdLine.setLeft(fight.getCompetitor().getDeservedDmgString(fight.getOpponent()));
		overlayThirdLine.setLeftColor(fight.competitorDeservedDmgIsGreater() ? Color.GREEN : Color.WHITE);

		overlayThirdLine.setRight(String.valueOf((int)Math.round(fight.getOpponent().getDeservedDamage())));
		overlayThirdLine.setRightColor(fight.opponentDeservedDmgIsGreater() ? Color.GREEN : Color.WHITE);

		// Fouth line: Damage dealt stats
		// same thing for damage dealt, the difference is only on the competitor.
		overlayFourthLine.setLeft(String.valueOf(fight.getCompetitor().getDmgDealtString(fight.getOpponent())));
		overlayFourthLine.setLeftColor(fight.competitorDmgDealtIsGreater() ? Color.GREEN : Color.WHITE);

		overlayFourthLine.setRight(String.valueOf(fight.getOpponent().getDamageDealt()));
		overlayFourthLine.setRightColor(fight.opponentDmgDealtIsGreater() ? Color.GREEN : Color.WHITE);

		// Fifth line: magic hit stats/luck
		overlayFifthLine.setLeft(String.valueOf(fight.getCompetitor().getShortMagicHitStats()));
		overlayFifthLine.setLeftColor(fight.competitorMagicHitsLuckier() ? Color.GREEN : Color.WHITE);

		overlayFifthLine.setRight(String.valueOf(fight.getOpponent().getShortMagicHitStats()));
		overlayFifthLine.setRightColor(fight.opponentMagicHitsLuckier() ? Color.GREEN : Color.WHITE);

		overlaySixthLine.setLeft(String.valueOf(fight.getCompetitor().getOffensivePrayStats(true)));

		overlaySeventhLine.setLeft(String.valueOf(fight.getCompetitor().getHpHealed()));

		overlayEighthLine.setLeft(fight.getCompetitor().getGhostBarrageStats());

		return panelComponent.render(graphics);
	}

	void setLines()
	{
		panelComponent.getChildren().clear();

		// Only display the title if it's enabled (pointless in my opinion, since you can just see
		// what the panel is displaying, but I can see it being useful if you have lots of overlays)
		if (config.showOverlayTitle())
		{
			panelComponent.getChildren().add(overlayTitle);
		}

		if (config.showOverlayNames())
		{
			panelComponent.getChildren().add(overlayFirstLine);
		}
		if (config.showOverlayOffPray())
		{
			panelComponent.getChildren().add(overlaySecondLine);
		}
		if (config.showOverlayDeservedDmg())
		{
			panelComponent.getChildren().add(overlayThirdLine);
		}
		if (config.showOverlayDmgDealt())
		{
			panelComponent.getChildren().add(overlayFourthLine);
		}
		if (config.showOverlayMagicHits())
		{
			panelComponent.getChildren().add(overlayFifthLine);
		}
		if (config.showOverlayOffensivePray())
		{
			panelComponent.getChildren().add(overlaySixthLine);
		}
		if (config.showOverlayHpHealed())
		{
			panelComponent.getChildren().add(overlaySeventhLine);
		}
		if (config.showOverlayGhostBarrage())
		{
			panelComponent.getChildren().add(overlayEighthLine);
		}
	}

	void setFight(FightPerformance fight)
	{
		String cName = fight.getCompetitor().getName();
		overlayFirstLine.setLeft(cName.substring(0, Math.min(6, cName.length())));
		String oName = fight.getOpponent().getName();
		overlayFirstLine.setRight(oName.substring(0, Math.min(6, oName.length())));
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker;

import matsyir.pvpperformancetracker.models.RangeAmmoData;
import matsyir.pvpperformancetracker.models.RingData;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("pvpperformancetracker")
public interface PvpPerformanceTrackerConfig extends Config
{
	int LEVEL_MIN = 1;
	int LEVEL_MAX = 120;

	// ================================= Sections =================================

	@ConfigSection(name = "Overlay (5 lines max)",
		description = "Contains overlay settings (MAX of 5 lines allowed)",
		position = 20,
		closedByDefault = true
	)
	String overlay = "overlay";

	@ConfigSection(name = "Gear/Ammo",
		description = "Contains gear/ammo settings for fights outside LMS",
		position = 110,
		closedByDefault = false
	)
	String gearAmmo = "gearAmmo";

	@ConfigSection(name = "Levels",
		description = "Contains level settings for fights outside of LMS (including boosts)",
		position = 150,
		closedByDefault = false
	)
	String levels = "levels";

	// ================================= General =================================

	@ConfigItem(
		keyName = "pluginVersion",
		name = "Plugin Version",
		description = "Hidden plugin version in order to potentially 'gracefully migrate' data in the future.",
		hidden = true
	)
	default String pluginVersion()
	{
		return PvpPerformanceTrackerPlugin.PLUGIN_VERSION;
	}

	@ConfigItem(
		keyName = "settingsConfigured",
		name = "I have verified my settings",
		description = "Some settings affect damage calculations, and every player should set them based on how they're pking." +
			"<br>Please confirm them and tick this box in order to hide the config warning.",
		position = -1
	)
	default boolean settingsConfigured()
	{
		return false;
	}

	@ConfigItem(
		keyName = "restrictToLms",
		name = "Restrict to LMS",
		description = "Restricts functionality and visibility to the LMS areas & its lobby (Ferox Enclave)." +
			"<br>WARNING: can be inaccurate outside LMS, as every attack animation's combat style must be manually mapped.",
		position = 0
	)
	default boolean restrictToLms()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showFightHistoryPanel",
		name = "Show Fight History Panel",
		description = "Enables the side-panel which displays previous fight's statistics.",
		position = 10
	)
	default boolean showFightHistoryPanel()
	{
		return true;
	}

	// ================================= Overlay =================================

	@ConfigItem(
		keyName = "showFightOverlay",
		name = "Show Fight Overlay",
		description = "Display an overlay of statistics while fighting.",
		position = 20,
		section = overlay
	)
	default boolean showFightOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayTitle",
		name = "Overlay: Show Title",
		description = "The overlay will have a title to display that it is PvP Performance.",
		position = 40,
		section = overlay
	)
	default boolean showOverlayTitle()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayNames",
		name = "Overlay: Show Names",
		description = "The overlay will display names.<br>Max. of 5 lines on the overlay",
		position = 50,
		section = overlay
	)
	default boolean showOverlayNames()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayOffPray",
		name = "Overlay: Show Off-Pray",
		description = "The overlay will display off-pray stats as a fraction & percentage.<br>Max. of 5 lines on the overlay",
		position = 60,
		section = overlay
	)
	default boolean showOverlayOffPray()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayDeservedDmg",
		name = "Overlay: Show Deserved Dmg",
		description = "The overlay will display deserved damage & difference.<br>Max. of 5 lines on the overlay",
		position = 70,
		section = overlay
	)
	default boolean showOverlayDeservedDmg()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOverlayDmgDealt",
		name = "Overlay: Show Dmg Dealt",
		description = "The overlay will display damage dealt.<br>Max. of 5 lines on the overlay",
		position = 80,
		section = overlay
	)
	default boolean showOverlayDmgDealt()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayMagicHits",
		name = "Overlay: Show Magic Hits",
		description = "The overlay will display successful magic hits & deserved magic hits.<br>Max. of 5 lines on the overlay",
		position = 90,
		section = overlay
	)
	default boolean showOverlayMagicHits()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayOffensivePray",
		name = "Overlay: Show Offensive Pray",
		description = "The overlay will display offensive pray stats.<br>Max. of 5 lines on the overlay",
		position = 100,
		section = overlay
	)
	default boolean showOverlayOffensivePray()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayHpHealed",
		name = "Overlay: Show HP Healed",
		description = "The overlay will display hitpoints healed.<br>Max. of 5 lines on the overlay",
		position = 105,
		section = overlay
	)
	default boolean showOverlayHpHealed()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOverlayGhostBarrage",
		name = "Overlay: Show Ghost Barrage",
		description = "(Advanced): The overlay will display ghost barrage stats.<br>Max. of 5 lines on the overlay",
		position = 106,
		section = overlay
	)
	default boolean showOverlayGhostBarrage()
	{
		return false;
	}

	// ================================= Gear/Ammo =================================

	@ConfigItem(
		keyName = "ringChoice",
		name = "Ring Used",
		description = "Rings used for the deserved damage calculations outside of LMS.",
		position = 110,
		section = gearAmmo
	)
	default RingData ringChoice()
	{
		return RingData.BERSERKER_RING;
	}

	@ConfigItem(
		keyName = "boltChoice",
		name = "RCB Ammo",
		description = "Bolts used for rune crossbow's deserved damage calculation." +
			"<br>LMS fights always use diamond (e). Dragonfire protection not accounted for.",
		position = 120,
		section = gearAmmo
	)
	default RangeAmmoData.BoltAmmo boltChoice()
	{
		return RangeAmmoData.BoltAmmo.DIAMOND_BOLTS_E;
	}

	@ConfigItem(
		keyName = "strongBoltChoice",
		name = "ACB/DCB/DHCB Ammo",
		description = "Bolts used for ACB/DCB/DHCB's deserved damage calculation." +
			"<br>LMS fights always use regular diamond (e). Dragonfire protection not accounted for.",
		position = 130,
		section = gearAmmo
	)
	default RangeAmmoData.StrongBoltAmmo strongBoltChoice()
	{
		return RangeAmmoData.StrongBoltAmmo.DIAMOND_BOLTS_E;
	}

	@ConfigItem(
		keyName = "bpDartChoice",
		name = "Blowpipe Ammo",
		description = "Darts used for blowpipe deserved damage calculation.",
		position = 140,
		section = gearAmmo
	)
	default RangeAmmoData.DartAmmo bpDartChoice()
	{
		return RangeAmmoData.DartAmmo.DRAGON_DARTS;
	}

	// ================================= Levels =================================

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "attackLevel",
		name = "Attack Level",
		description = "Attack level used for the deserved damage calculations outside of LMS (includes potion boost).",
		position = 160,
		section = levels
	)
	default int attackLevel()
	{
		return 118;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "strengthLevel",
		name = "Strength Level",
		description = "Strength level used for the deserved damage calculations outside of LMS (includes potion boost).",
		position = 170,
		section = levels
	)
	default int strengthLevel()
	{
		return 118;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "defenceLevel",
		name = "Defence Level",
		description = "Defence level used for the deserved damage calculations outside of LMS (includes potion boost).",
		position = 180,
		section = levels
	)
	default int defenceLevel()
	{
		return 120;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "rangedLevel",
		name = "Ranged Level",
		description = "Ranged level used for the deserved damage calculations outside of LMS (includes potion boost).",
		position = 190,
		section = levels
	)
	default int rangedLevel()
	{
		return 112;
	}

	@Range(
		min = LEVEL_MIN,
		max = LEVEL_MAX
	)
	@ConfigItem(
		keyName = "magicLevel",
		name = "Magic Level",
		description = "Magic level used for the deserved damage calculations outside of LMS (includes potion boost).",
		position = 200,
		section = levels
	)
	default int magicLevel()
	{
		return 99;
	}

	// ================================= Misc/Less-Used-General =================================

	@Range(
		min = 1,
		max = 1000
	)
	@ConfigItem(
		keyName = "fightHistoryRenderLimit",
		name = "Max Rendered Fights",
		description = "Maximum number of previous fights to be displayed in the fight history side-panel." +
			"<br>WILL cause lag spikes at very high numbers. This should be small if you have low RAM",
		position = 205
	)
	default int fightHistoryRenderLimit()
	{
		return 200;
	}

	@Range(
		max = 1000000
	)
	@ConfigItem(
		keyName = "fightHistoryLimit",
		name = "Max Saved Fights",
		description = "Maximum number of previous fights to be saved to a local file and used for total/avg stats." +
			"<br>0 means unlimited. May cause lag spikes at extreme numbers on low-end PCs",
		position = 210
	)
	default int fightHistoryLimit()
	{
		return 10000;
	}

	@ConfigItem(
		keyName = "exactNameFilter",
		name = "Exact Name Filter",
		description = "Makes the username filter look for an exact match (case-insensitive), rather than any name starting with the filter.",
		position = 220
	)
	default boolean exactNameFilter()
	{
		return false;
	}

	@ConfigItem(
		keyName = "dlongIsVls",
		name = "Dlong = VLS",
		description = "Track Dragon Longsword & its spec as a Vesta's Longsword for deserved damage." +
			"<br>Requested/used for for DMM practice purposes.",
		position = 230
	)
	default boolean dlongIsVls()
	{
		return true;
	}

	@ConfigItem(
		keyName = "fightLogInChat",
		name = "Fight Log In Chat",
		description = "Display basic fight logs in trade chat during a fight." +
			"<br><strong>This is very excessive, mostly for testing/verification.<strong>",
		position = 500
	)
	default boolean fightLogInChat()
	{
		return false;
	}

	@ConfigItem(
		keyName = "nameFilter",
		name = "Name Filter",
		description = "Hidden config used to save user's selected name/RSN filter for the panel views.",
		position = 1000,
		hidden = true
	)
	default String nameFilter()
	{
		return "";
	}
}

/*
 * Copyright (c) 2021, Mazhar <https://twitter.com/maz_rs>
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.time.Duration;
import java.util.ArrayList;
import java.util.stream.Collectors;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRootPane;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableCellRenderer;
import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.controllers.AnalyzedFightPerformance;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;
import net.runelite.api.SpriteID;

@Slf4j
public class FightLogFrame extends JFrame
{
	private static final NumberFormat nf = NumberFormat.getInstance();

	static
	{
		// initialize number format
		nf.setMaximumFractionDigits(2);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}

	private FightLogDetailFrame fightLogDetailFrame;
	private JTable table;
	private ListSelectionListener onRowSelected;
	private ArrayList<FightLogEntry> fightLogEntries;

	// expects logEntries composing of only "full" log entries, that contain full attack data, not defender entries.
	FightLogFrame(FightPerformance fight, ArrayList<FightLogEntry> logEntries, JRootPane rootPane)
	{
		//String title = fight.getCompetitor().getName() + " vs " + fight.getOpponent().getName();
		super(fight.getCompetitor().getName() + " vs " + fight.getOpponent().getName());

		fightLogEntries = logEntries;
		fightLogEntries.removeIf(e -> !e.isFullEntry());

		// if always on top is supported, and the core RL plugin has "always on top" set, make the frame always
		// on top as well so it can be above the client.
		if (isAlwaysOnTopSupported())
		{
			setAlwaysOnTop(PLUGIN.getRuneliteConfig().gameAlwaysOnTop());
		}

		setIconImage(PLUGIN_ICON);
		setSize(765, 503); // default to same as osrs on fixed
		setLocation(rootPane.getLocationOnScreen());

		JPanel mainPanel = new JPanel(new BorderLayout(4, 4));
		Object[][] stats = new Object[fightLogEntries.size()][11];
		int i = 0;
		int initialTick = 0;

		for (FightLogEntry fightEntry : fightLogEntries)
		{
			if (i == 0)
			{
				initialTick = fightEntry.getTick();
			}

			int styleIcon = fightEntry.getAnimationData().attackStyle.getStyleSpriteId();
			JLabel styleIconLabel = new JLabel();
			PLUGIN.addSpriteToLabelIfValid(styleIconLabel, styleIcon, this::repaint);
			styleIconLabel.setToolTipText(fightEntry.getAnimationData().attackStyle.toString());

			stats[i][0] = fightEntry.getAttackerName();
			stats[i][1] = styleIconLabel;
			stats[i][2] = fightEntry.getHitRange();
			stats[i][3] = nf.format(fightEntry.getAccuracy() * 100) + '%';
			stats[i][4] = nf.format(fightEntry.getDeservedDamage());
			stats[i][5] = fightEntry.getAnimationData().isSpecial ? "✔" : "";
			stats[i][6] = fightEntry.success() ? "✔" : "";

			int prayIcon = PLUGIN.getSpriteForHeadIcon(fightEntry.getDefenderOverhead());
			if (prayIcon > 0)
			{
				JLabel prayIconLabel = new JLabel();
				PLUGIN.addSpriteToLabelIfValid(prayIconLabel, prayIcon, this::repaint);
				stats[i][7] = prayIconLabel;
			}
			else
			{
				stats[i][7] = "";
			}

			if (fightEntry.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC)
			{
				int freezeIcon = fightEntry.isSplash() ? SpriteID.SPELL_ICE_BARRAGE_DISABLED : SpriteID.SPELL_ICE_BARRAGE;
				JLabel freezeIconLabel = new JLabel();
				PLUGIN.addSpriteToLabelIfValid(freezeIconLabel, freezeIcon, this::repaint);
				stats[i][8] = freezeIconLabel;
			}
			else
			{
				stats[i][8] = "";
			}

			// offensive pray shown as icon or blank if none(0)
			JLabel attackerOffensivePrayLabel = new JLabel();
			if (fightEntry.getAttackerOffensivePray() > 0)
			{
				PLUGIN.addSpriteToLabelIfValid(attackerOffensivePrayLabel, fightEntry.getAttackerOffensivePray(), this::repaint);
				stats[i][9] = attackerOffensivePrayLabel;
			}
			else
			{
				stats[i][9] = "";
			}

			int tickDuration = fightEntry.getTick() - initialTick;
			int durationMillis = (tickDuration * 600); // (* 0.6) to get duration in secs from ticks, so *600 for ms
			Duration duration = Duration.ofMillis(durationMillis);
			String time = String.format("%02d:%02d.%01d",
				duration.toMinutes(),
				duration.getSeconds() % 60,
				durationMillis % 1000 / 100) + " (" + tickDuration + ")";
			stats[i][10] = time;

			i++;
		}

		String[] header = { "Attacker", "Style", "Hit Range", "Accuracy", "Avg Hit", "Special?", "Off-Pray?", "Def Prayer", "Splash", "Offensive Pray", "Time, (Tick)" };
		table = new JTable(stats, header);
		table.setRowHeight(30);
		table.setDefaultEditor(Object.class, null);

		table.getColumnModel().getColumn(1).setCellRenderer(new BufferedImageCellRenderer());
		table.getColumnModel().getColumn(7).setCellRenderer(new BufferedImageCellRenderer());
		table.getColumnModel().getColumn(8).setCellRenderer(new BufferedImageCellRenderer());
		table.getColumnModel().getColumn(9).setCellRenderer(new BufferedImageCellRenderer());

		onRowSelected = e -> {
			int row = table.getSelectedRow();

			if (fightLogDetailFrame != null)
			{
				if (fightLogDetailFrame.rowIdx == row) { return; }

				fightLogDetailFrame.dispose();
				fightLogDetailFrame = null;
			}

			fightLogDetailFrame = new FightLogDetailFrame(fight, fightLogEntries.get(row), row,
				new Point( // place the new detail frame roughly to the right of the fight log window.
					this.getLocation().x + this.getSize().width,
					this.getLocation().y)
				);
		};

		table.getSelectionModel().addListSelectionListener(onRowSelected);

		mainPanel.add(new JScrollPane(table), BorderLayout.CENTER);

		add(mainPanel);
		setVisible(true);
	}

	static class BufferedImageCellRenderer extends DefaultTableCellRenderer
	{
		@Override
		public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)
		{
			super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
			if (value instanceof BufferedImage)
			{
				setText("");
				setIcon(new ImageIcon((BufferedImage)value));
			}
			else if (value instanceof JLabel)
			{
				JLabel val = (JLabel)value;
				setIcon(val.getIcon());
				setText(val.getText());
				setToolTipText(val.getToolTipText());
			}
			else
			{
				setText("");
				setIcon(null);
			}

			return this;
		}
	}

	// initialize frame using an AnalyzedFight, in order to pass the analyzed fight data
	// to the detailed frame.
	FightLogFrame(AnalyzedFightPerformance fight, JRootPane rootPane)
	{
		this(fight,
			new ArrayList(fight.getAllFightLogEntries().stream()
				.filter(FightLogEntry::isFullEntry) // send only attacker logs, and don't use the matching logs since
				.collect(Collectors.toList())),	// those have old 'dps' values, they're only used for defender lvls/pray/etc client data
			rootPane);

		// test
		if (new ArrayList(fight.getAllFightLogEntries().stream()
			.filter(FightLogEntry::isFullEntry) // send only attacker logs
			.collect(Collectors.toList())).size() != fight.getAnalyzedMatchingLogs().size())
		{
			 log.info("FIGHT ANALYSIS: ERROR! allFightLogEntries.filter::isFullEntry different size than analyzedMatchingLogs - should not happen");
		}

		table.getSelectionModel().removeListSelectionListener(onRowSelected);
		onRowSelected = e -> {
			int row = table.getSelectedRow();

			if (fightLogDetailFrame != null)
			{
				if (fightLogDetailFrame.rowIdx == row) { return; }

				fightLogDetailFrame.dispose();
				fightLogDetailFrame = null;
			}

			fightLogDetailFrame = new FightLogDetailFrame(fight, fightLogEntries.get(row), fight.getAnalyzedMatchingLogs().get(row)[1], row,
				new Point( // place the new detail frame roughly to the right of the fight log window.
					this.getLocationOnScreen().x + (this.getSize().width),
					this.getLocationOnScreen().y)
			);
		};

		table.getSelectionModel().addListSelectionListener(onRowSelected);
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Point;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import lombok.extern.slf4j.Slf4j;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.fixItemId;
import matsyir.pvpperformancetracker.controllers.AnalyzedFightPerformance;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.EquipmentData;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.controllers.Fighter;
import matsyir.pvpperformancetracker.controllers.PvpDamageCalc;
import matsyir.pvpperformancetracker.models.RangeAmmoData;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemEquipmentStats;

@Slf4j
class FightLogDetailFrame extends JFrame
{
	public static final int DEFAULT_WIDTH = 400;

	public int rowIdx;

	private boolean isCompetitorLog;
	private Fighter attacker;
	private Fighter defender;

	private JPanel combatLevelsLine;
	private JLabel attackerAtkLvl;
	private JLabel attackerStrLvl;
	private JLabel attackerDefLvl;
	private JLabel attackerRangeLvl;
	private JLabel attackerMageLvl;
	private JLabel attackerHpLvl;

	private JLabel defenderAtkLvl;
	private JLabel defenderStrLvl;
	private JLabel defenderDefLvl;
	private JLabel defenderRangeLvl;
	private JLabel defenderMageLvl;
	private JLabel defenderHpLvl;

	private JLabel attackerOffensiveLabel;
	private JLabel defenderOffensiveLabel;

	// this is a regular fightLogDetailFrame, for a normal non-merged fight.
	FightLogDetailFrame(FightPerformance fight, FightLogEntry log, int rowIdx, Point location)
	{
		super(fight.getCompetitor().getName() + " vs " + fight.getOpponent().getName() + " - Log Details");

		this.rowIdx = rowIdx;

		setSize(DEFAULT_WIDTH, 640);
		setMinimumSize(new Dimension(DEFAULT_WIDTH, 200));
		setLayout(new BorderLayout());
		setLocation(location);
		setIconImage(PLUGIN_ICON);

		// if always on top is supported, and the core RL plugin has "always on top" set, make the frame always
		// on top as well so it can be above the client.
		if (isAlwaysOnTopSupported())
		{
			setAlwaysOnTop(PLUGIN.getRuneliteConfig().gameAlwaysOnTop());
		}

		JPanel mainPanel = new JPanel(); //new GridLayout(0, 2)
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setVisible(true);
		mainPanel.setBorder(BorderFactory.createEmptyBorder(8, 16, 8, 16));

		isCompetitorLog = log.attackerName.equals(fight.getCompetitor().getName());
		attacker = isCompetitorLog ? fight.getCompetitor() : fight.getOpponent();
		defender = isCompetitorLog ? fight.getOpponent() : fight.getCompetitor();

		JPanel namesLine = new JPanel(new BorderLayout());
		GridLayout attackerNameContainerLayout = new GridLayout(1, 2);
		attackerNameContainerLayout.setHgap(4);
		JPanel attackerNameContainer = new JPanel(attackerNameContainerLayout);
		JLabel attackerName = new JLabel();
		attackerName.setText("<html>Attacker:<br/><strong>" + log.attackerName + "</strong></html>");
		PLUGIN.addSpriteToLabelIfValid(attackerName, log.getAnimationData().attackStyle.getStyleSpriteId());
		attackerName.setToolTipText(log.getAnimationData().attackStyle.toString());
		attackerNameContainer.add(attackerName);

		// if it was a magic attack, display if splash or not:
		if (log.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC)
		{
			int splashIcon = log.isSplash() ? SpriteID.SPELL_ICE_BARRAGE_DISABLED : SpriteID.SPELL_ICE_BARRAGE;
			JLabel splashIconLabel = new JLabel();
			PLUGIN.addSpriteToLabelIfValid(splashIconLabel, splashIcon);
			splashIconLabel.setText("<html> <br/> </html>"); // set text to be 2 lines so the icon lines up with the style icon
			splashIconLabel.setToolTipText("Splashed: " + (log.isSplash() ? "Yes" : "No"));
			splashIconLabel.setHorizontalAlignment(SwingConstants.LEFT);
			attackerNameContainer.add(splashIconLabel);
		}
		namesLine.add(attackerNameContainer, BorderLayout.WEST);

		JLabel defenderName = new JLabel();
		defenderName.setText("<html>Defender:<br/><strong>" + defender.getName() + "</strong></html>");
		namesLine.add(defenderName, BorderLayout.EAST);

		// prayer display line
		JPanel praysUsedLine = new JPanel(new BorderLayout());
		GridLayout attackerPrayLayout = new GridLayout(1, 2);
		attackerPrayLayout.setHgap(4);
		JPanel attackerPrays = new JPanel(attackerPrayLayout);
		// attacker overhead
		int attackerOverheadSpriteId = PLUGIN.getSpriteForHeadIcon(log.getAttackerOverhead());
		JLabel attackerOverheadLabel = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerOverheadLabel, attackerOverheadSpriteId);
		attackerOverheadLabel.setToolTipText("Overhead Prayer");
		attackerPrays.add(attackerOverheadLabel);
		// attacker offensive
		attackerOffensiveLabel = new JLabel();
		attackerOffensiveLabel.setToolTipText("Offensive Prayer");

		// if there's a valid offensive pray, display it.
		PLUGIN.addSpriteToLabelIfValid(attackerOffensiveLabel, log.getAttackerOffensivePray());

		if (!isCompetitorLog) // if it wasn't a competitor log, then this is N/A in most cases, and
		{ // do NOT put a bank filler, to indicate that this is fully N/A, and not "None"
			attackerOffensiveLabel.setText("N/A");
			attackerOffensiveLabel.setIcon(null);
		}

		attackerPrays.add(attackerOffensiveLabel);
		praysUsedLine.add(attackerPrays, BorderLayout.WEST);

		GridLayout defenderPrayLayout = new GridLayout(1, 2);
		defenderPrayLayout.setHgap(4);
		JPanel defenderPrays = new JPanel(defenderPrayLayout);
		// defender overhead
		int defenderOverheadSpriteId = PLUGIN.getSpriteForHeadIcon(log.getDefenderOverhead());
		JLabel defenderOverheadLabel = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderOverheadLabel, defenderOverheadSpriteId);
		defenderOverheadLabel.setToolTipText("Overhead Prayer");
		defenderPrays.add(defenderOverheadLabel);

		// defender offensive (N/A in normal cases)
		defenderOffensiveLabel = new JLabel("N/A");
		defenderOffensiveLabel.setToolTipText("Offensive Prayer");
		defenderPrays.add(defenderOffensiveLabel);

		praysUsedLine.add(defenderPrays, BorderLayout.EAST);

		CombatLevels levels = fight.fightType.getCombatLevelsForType();
		combatLevelsLine = new JPanel(new BorderLayout());
		JPanel attackerCombatLevels = new JPanel(new GridLayout(2, 3));
		attackerAtkLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerAtkLvl, PLUGIN.getSpriteForSkill(Skill.ATTACK));
		attackerAtkLvl.setText(String.valueOf(levels.atk));
		attackerAtkLvl.setToolTipText("Attack Level");
		attackerStrLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerStrLvl, PLUGIN.getSpriteForSkill(Skill.STRENGTH));
		attackerStrLvl.setText(String.valueOf(levels.str));
		attackerStrLvl.setToolTipText("Strength Level");
		attackerDefLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerDefLvl, PLUGIN.getSpriteForSkill(Skill.DEFENCE));
		attackerDefLvl.setText(String.valueOf(levels.def));
		attackerDefLvl.setToolTipText("Defence Level");
		attackerRangeLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerRangeLvl, PLUGIN.getSpriteForSkill(Skill.RANGED));
		attackerRangeLvl.setText(String.valueOf(levels.range));
		attackerRangeLvl.setToolTipText("Ranged Level");
		attackerMageLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerMageLvl, PLUGIN.getSpriteForSkill(Skill.MAGIC));
		attackerMageLvl.setText(String.valueOf(levels.mage));
		attackerMageLvl.setToolTipText("Magic Level");
		attackerHpLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(attackerHpLvl, PLUGIN.getSpriteForSkill(Skill.HITPOINTS));
		attackerHpLvl.setText(String.valueOf(levels.hp));
		attackerHpLvl.setToolTipText("Hitpoints Level");

		attackerCombatLevels.add(attackerAtkLvl);
		attackerCombatLevels.add(attackerStrLvl);
		attackerCombatLevels.add(attackerDefLvl);
		attackerCombatLevels.add(attackerRangeLvl);
		attackerCombatLevels.add(attackerMageLvl);
		attackerCombatLevels.add(attackerHpLvl);
		combatLevelsLine.add(attackerCombatLevels, BorderLayout.WEST);

		JPanel defenderCombatLevels = new JPanel(new GridLayout(2, 3));
		defenderAtkLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderAtkLvl, PLUGIN.getSpriteForSkill(Skill.ATTACK));
		defenderAtkLvl.setText(String.valueOf(levels.atk));
		defenderAtkLvl.setToolTipText("Attack Level");
		defenderStrLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderStrLvl, PLUGIN.getSpriteForSkill(Skill.STRENGTH));
		defenderStrLvl.setText(String.valueOf(levels.str));
		defenderStrLvl.setToolTipText("Strength Level");
		defenderDefLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderDefLvl, PLUGIN.getSpriteForSkill(Skill.DEFENCE));
		defenderDefLvl.setText(String.valueOf(levels.def));
		defenderDefLvl.setToolTipText("Defence Level");
		defenderRangeLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderRangeLvl, PLUGIN.getSpriteForSkill(Skill.RANGED));
		defenderRangeLvl.setText(String.valueOf(levels.range));
		defenderRangeLvl.setToolTipText("Ranged Level");
		defenderMageLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderMageLvl, PLUGIN.getSpriteForSkill(Skill.MAGIC));
		defenderMageLvl.setText(String.valueOf(levels.mage));
		defenderMageLvl.setToolTipText("Magic Level");
		defenderHpLvl = new JLabel();
		PLUGIN.addSpriteToLabelIfValid(defenderHpLvl, PLUGIN.getSpriteForSkill(Skill.HITPOINTS));
		defenderHpLvl.setText(String.valueOf(levels.hp));
		defenderHpLvl.setToolTipText("Hitpoints Level");

		defenderCombatLevels.add(defenderAtkLvl);
		defenderCombatLevels.add(defenderStrLvl);
		defenderCombatLevels.add(defenderDefLvl);
		defenderCombatLevels.add(defenderRangeLvl);
		defenderCombatLevels.add(defenderMageLvl);
		defenderCombatLevels.add(defenderHpLvl);
		combatLevelsLine.add(defenderCombatLevels, BorderLayout.EAST);


		// equipment stats line (stab attack, slash attack, etc)
		JPanel equipmentStatsLine = new JPanel(new BorderLayout());
		JLabel attackerStatsLabel = new JLabel();
		PLUGIN.getClientThread().invokeLater(() ->
			attackerStatsLabel.setText(getItemEquipmentStatsString(log.getAttackerGear())));
		equipmentStatsLine.add(attackerStatsLabel, BorderLayout.WEST);

		JLabel defenderStatsLabel = new JLabel();
		PLUGIN.getClientThread().invokeLater(() ->
			defenderStatsLabel.setText(getItemEquipmentStatsString(log.getDefenderGear())));
		equipmentStatsLine.add(defenderStatsLabel, BorderLayout.EAST);

		JPanel equipmentRenderLine = new JPanel(new BorderLayout());
		JPanel attackerEquipmentRender = getEquipmentRender(log.getAttackerGear());
		JPanel defenderEquipmentRender = getEquipmentRender(log.getDefenderGear());
		equipmentRenderLine.add(attackerEquipmentRender, BorderLayout.WEST);
		equipmentRenderLine.add(defenderEquipmentRender, BorderLayout.EAST);

		// Animation detected line
		JPanel animationDetectedLine = new JPanel(new BorderLayout());
		JLabel attackerAnimationDetected = new JLabel();
		attackerAnimationDetected.setText("<html><strong>Animation Detected:</strong> " + log.getAnimationData().toString() + "</html>");
		attackerAnimationDetected.setToolTipText("<html>Note that the animation can be misleading, as many animations are re-used, but this is normal.<br/>" +
			"For example, Zammy Hasta and Staff of Fire use the same crush animation.<br/>" +
			"These were not intended to ever be displayed, but why not include them here.</html>");
		animationDetectedLine.add(attackerAnimationDetected, BorderLayout.CENTER);


		mainPanel.add(namesLine);
		mainPanel.add(praysUsedLine);
		mainPanel.add(combatLevelsLine);
		mainPanel.add(equipmentRenderLine);
		mainPanel.add(equipmentStatsLine);
		mainPanel.add(animationDetectedLine);

		this.add(mainPanel, BorderLayout.CENTER);
		this.setVisible(true);
	}

	// extra-detailed frame for a merged fight, which has both an attacker and defender log for each attack
	FightLogDetailFrame(AnalyzedFightPerformance fight, FightLogEntry attackerLog, FightLogEntry defenderLog, int rowIdx, Point location)
	{
		this(fight, attackerLog, rowIdx, location);

		// attacker lvls
		CombatLevels aLvls = attackerLog.getAttackerLevels();
		if (aLvls == null)
		{
			log.info("Fight Analysis: attackerLvls are null! This shouldn't happen.");
			aLvls = fight.fightType.getCombatLevelsForType();
		}
		attackerAtkLvl.setText(String.valueOf(aLvls.atk));
		attackerStrLvl.setText(String.valueOf(aLvls.str));
		attackerDefLvl.setText(String.valueOf(aLvls.def));
		attackerRangeLvl.setText(String.valueOf(aLvls.range));
		attackerMageLvl.setText(String.valueOf(aLvls.mage));
		attackerHpLvl.setText(String.valueOf(aLvls.hp));

		// defender lvls
		CombatLevels dLvls = defenderLog.getAttackerLevels();
		if (dLvls == null)
		{
			log.info("Fight Analysis: defenderLvls are null! This shouldn't happen.");
			dLvls = fight.fightType.getCombatLevelsForType();
		}
		defenderAtkLvl.setText(String.valueOf(dLvls.atk));
		defenderStrLvl.setText(String.valueOf(dLvls.str));
		defenderDefLvl.setText(String.valueOf(dLvls.def));
		defenderRangeLvl.setText(String.valueOf(dLvls.range));
		defenderMageLvl.setText(String.valueOf(dLvls.mage));
		defenderHpLvl.setText(String.valueOf(dLvls.hp));

		defenderOffensiveLabel.setText("");
		PLUGIN.addSpriteToLabelIfValid(defenderOffensiveLabel, defenderLog.getAttackerOffensivePray());

		attackerOffensiveLabel.setText("");
		PLUGIN.addSpriteToLabelIfValid(attackerOffensiveLabel, attackerLog.getAttackerOffensivePray(), () -> {
			validate();
			repaint();
		});
	}

	private JPanel getEquipmentRender(int[] itemIds)
	{
		JPanel equipmentRender = new JPanel();
		equipmentRender.setLayout(new BoxLayout(equipmentRender, BoxLayout.Y_AXIS));

		JPanel helmLine = new JPanel(new BorderLayout()); // helm only
		JPanel capeLine = new JPanel(new BorderLayout()); // cape, amulet, ammo
		JPanel weaponLine = new JPanel(new BorderLayout()); // weapon, torso, shield
		JPanel legsLine = new JPanel(new BorderLayout()); // legs
		JPanel glovesLine = new JPanel(new BorderLayout()); // gloves, boots, ring

		JLabel helm = new JLabel();
		helm.setHorizontalAlignment(SwingConstants.CENTER);
		PLUGIN.addItemToLabelIfValid(helm, itemIds[KitType.HEAD.getIndex()]);
		helmLine.add(helm, BorderLayout.CENTER);

		JLabel cape = new JLabel();
		PLUGIN.addItemToLabelIfValid(cape, itemIds[KitType.CAPE.getIndex()]);
		JLabel amulet = new JLabel();
		PLUGIN.addItemToLabelIfValid(amulet, itemIds[KitType.AMULET.getIndex()]);
		capeLine.add(cape, BorderLayout.WEST);
		capeLine.add(amulet, BorderLayout.CENTER);

		// ammo: get config's ammo for current weapon
		RangeAmmoData weaponAmmo = EquipmentData.getWeaponAmmo(EquipmentData.fromId(fixItemId(itemIds[KitType.WEAPON.getIndex()])));
		if (weaponAmmo != null)
		{
			JLabel ammo = new JLabel();
			PLUGIN.addItemToLabelIfValid(ammo, weaponAmmo, false, null);
			capeLine.add(ammo, BorderLayout.EAST);
		}

		JLabel wep = new JLabel();
		PLUGIN.addItemToLabelIfValid(wep, itemIds[KitType.WEAPON.getIndex()]);
		JLabel torso = new JLabel();
		PLUGIN.addItemToLabelIfValid(torso, itemIds[KitType.TORSO.getIndex()]);
		JLabel shield = new JLabel();
		PLUGIN.addItemToLabelIfValid(shield, itemIds[KitType.SHIELD.getIndex()]);
		weaponLine.add(wep, BorderLayout.WEST);
		weaponLine.add(torso, BorderLayout.CENTER);
		weaponLine.add(shield, BorderLayout.EAST);

		JLabel legs = new JLabel();
		legs.setHorizontalAlignment(SwingConstants.CENTER);
		PLUGIN.addItemToLabelIfValid(legs, itemIds[KitType.LEGS.getIndex()]);
		legsLine.add(legs, BorderLayout.CENTER);

		JLabel gloves = new JLabel();
		PLUGIN.addItemToLabelIfValid(gloves, itemIds[KitType.HANDS.getIndex()]);
		JLabel boots = new JLabel();
		PLUGIN.addItemToLabelIfValid(boots, itemIds[KitType.BOOTS.getIndex()]);
		JLabel ring = new JLabel();
		PLUGIN.addItemToLabelIfValid(ring, CONFIG.ringChoice().getItemId(), false, () -> {
			validate();
			repaint();
		});
		glovesLine.add(gloves, BorderLayout.WEST);
		glovesLine.add(boots, BorderLayout.CENTER);
		glovesLine.add(ring, BorderLayout.EAST);

		equipmentRender.add(helmLine);
		equipmentRender.add(capeLine);
		equipmentRender.add(weaponLine);
		equipmentRender.add(legsLine);
		equipmentRender.add(glovesLine);

		return equipmentRender;
	}

	//
	String getItemEquipmentStatsString(int[] equipment)
	{
		ItemEquipmentStats stats = PvpDamageCalc.calculateBonusesToStats(equipment);
		// ammo: get config's ammo for current weapon
		RangeAmmoData weaponAmmo = EquipmentData.getWeaponAmmo(EquipmentData.fromId(fixItemId(equipment[KitType.WEAPON.getIndex()])));
		int ammoRangeStr = 0;
		if (weaponAmmo != null)
		{
			ammoRangeStr = weaponAmmo.getRangeStr();
		}
		String sep = "<br/>&nbsp;&nbsp;";
		return "<html><strong>Attack bonus</strong>" + sep +
			"Stab: " + prependPlusIfPositive(stats.getAstab()) + sep +
			"Slash: " + prependPlusIfPositive(stats.getAslash()) + sep +
			"Crush: " + prependPlusIfPositive(stats.getAcrush()) + sep +
			"Magic: " + prependPlusIfPositive(stats.getAmagic()) + sep +
			"Range: " + prependPlusIfPositive(stats.getArange()) +
			"<br/><strong>Defence bonus</strong>" + sep +
			"Stab: " + prependPlusIfPositive(stats.getDstab()) + sep +
			"Slash: " + prependPlusIfPositive(stats.getDslash()) + sep +
			"Crush: " + prependPlusIfPositive(stats.getDcrush()) + sep +
			"Magic: " + prependPlusIfPositive(stats.getDmagic()) + sep +
			"Range: " + prependPlusIfPositive(stats.getDrange()) +
			"<br/><strong>Other bonuses</strong>" + sep +
			"Melee strength: " + prependPlusIfPositive(stats.getStr()) + sep +
			"Ranged strength: " + prependPlusIfPositive(stats.getRstr() + ammoRangeStr) + sep +
			"Magic damage: " + prependPlusIfPositive((int)stats.getMdmg()) + "%" + sep +
			"</html>";
	}

	String prependPlusIfPositive(int number)
	{
		if (number >= 0)
		{
			return "+" + number;
		}

		return String.valueOf(number);
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridLayout;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.util.ArrayList;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.controllers.Fighter;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;

// basic panel with 3 rows to show a title, total fight performance stats, and kills/deaths
public class TotalStatsPanel extends JPanel
{
	private static final String WIKI_HELP_URL = "https://github.com/Matsyir/pvp-performance-tracker/wiki#pvp-performance-tracker";
	// number format for 0 decimal digit (mostly for commas in large numbers)
	private static final NumberFormat nf = NumberFormat.getInstance();
	static // initialize number format
	{
		nf.setMaximumFractionDigits(1);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}
	// number format for 1 decimal digit
	private static final NumberFormat nf1 = NumberFormat.getInstance();
	static // initialize number format
	{
		nf1.setMaximumFractionDigits(1);
		nf1.setRoundingMode(RoundingMode.HALF_UP);
	}

	// number format for 2 decimal digits
	private static final NumberFormat nf2 = NumberFormat.getInstance();
	static // initialize number format
	{
		nf2.setMaximumFractionDigits(2);
		nf2.setRoundingMode(RoundingMode.HALF_UP);
	}

	private static final int LAYOUT_ROWS_WITH_WARNING = 10;
	private static final int LAYOUT_ROWS_WITHOUT_WARNING = 9;

	// labels to be updated
	private JLabel killsLabel;
	private JLabel deathsLabel;
	private JLabel offPrayStatsLabel;
	private JLabel deservedDmgStatsLabel;
	private JLabel dmgDealtStatsLabel;
	private JLabel magicHitCountStatsLabel;
	private JLabel offensivePrayCountStatsLabel;
	private JLabel hpHealedStatsLabel;
	private JLabel ghostBarrageStatsLabel;

	private JLabel settingsWarningLabel; // to be hidden/shown

	private Fighter totalStats;

	private int numFights = 0;

	private int numKills = 0;
	private int numDeaths = 0;

	private double totalDeservedDmg = 0;
	private double totalDeservedDmgDiff = 0;
	private double avgDeservedDmg = 0;
	private double avgDeservedDmgDiff = 0;

	private double killTotalDeservedDmg = 0;
	private double killTotalDeservedDmgDiff = 0;
	private double killAvgDeservedDmg = 0;
	private double killAvgDeservedDmgDiff = 0;

	private double deathTotalDeservedDmg = 0;
	private double deathTotalDeservedDmgDiff = 0;
	private double deathAvgDeservedDmg = 0;
	private double deathAvgDeservedDmgDiff = 0;

	private double totalDmgDealt = 0;
	private double totalDmgDealtDiff = 0;
	private double avgDmgDealt = 0;
	private double avgDmgDealtDiff = 0;

	private double killTotalDmgDealt = 0;
	private double killTotalDmgDealtDiff = 0;
	private double killAvgDmgDealt = 0;
	private double killAvgDmgDealtDiff = 0;

	private double deathTotalDmgDealt = 0;
	private double deathTotalDmgDealtDiff = 0;
	private double deathAvgDmgDealt = 0;
	private double deathAvgDmgDealtDiff = 0;

	private double avgHpHealed = 0;

	private double avgGhostBarrageCount = 0;
	private double avgGhostBarrageDeservedDamage = 0;

	public TotalStatsPanel()
	{
		totalStats = new Fighter("Player");

		setLayout(new GridLayout(CONFIG.settingsConfigured() ? LAYOUT_ROWS_WITHOUT_WARNING : LAYOUT_ROWS_WITH_WARNING, 1));
		setBorder(new EmptyBorder(4, 6, 4, 6));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Create popupMenu with various general actions
		JPopupMenu popupMenu = new JPopupMenu();
		// Create "View Wiki" URL popup menu/context menu item
		final JMenuItem viewWiki = new JMenuItem("<html><u>View Wiki</u>&nbsp;&#8599;</html>");
		viewWiki.addActionListener(e -> LinkBrowser.browse(WIKI_HELP_URL));
		viewWiki.setForeground(ColorScheme.GRAND_EXCHANGE_LIMIT);

		// Create "Reset All" popup menu/context menu item
		final JMenuItem removeAllFights = new JMenuItem("Remove All Fights");
		removeAllFights.addActionListener(e ->
		{
			int dialogResult = JOptionPane.showConfirmDialog(this, "Are you sure you want to reset all fight history data? This cannot be undone.", "Warning", JOptionPane.YES_NO_OPTION);
			if (dialogResult == JOptionPane.YES_OPTION)
			{
				PLUGIN.resetFightHistory();
			}
		});

		// Create "Configure Settings" popup menu/context menu item
		// TODO? Can't figure out how but would like to in the future. Esp. since there is a warning to setup config.
		//final JMenuItem configureSettings = new JMenuItem("Configure Settings");
		//configureSettings.addActionListener(e -> );

		// Create "Copy Fight History Data" popup menu/context menu item
		final JMenuItem exportFightHistory = new JMenuItem("Copy Fight History Data");
		exportFightHistory.addActionListener(e -> PLUGIN.exportFightHistory());

		// Create "Import Fight History Data" popup menu/context menu item
		final JMenuItem importFightHistory = new JMenuItem("Import Fight History Data");
		importFightHistory.addActionListener(e ->
		{
			// display a simple input dialog to request json data to import.
			String fightHistoryData = JOptionPane.showInputDialog(this, "Enter the fight history data you wish to import:", "Import Fight History", JOptionPane.INFORMATION_MESSAGE);

			// if the string is less than 2 chars, it is definitely invalid (or they pressed Cancel), so skip.
			if (fightHistoryData == null || fightHistoryData.length() < 2) { return; }

			PLUGIN.importUserFightHistoryData(fightHistoryData);
		});

		// Create "Fight Analysis (Advanced)" popup menu/context menu item
		final JMenuItem fightAnalysis = new JMenuItem("Fight Analysis (Advanced)");
		fightAnalysis.addActionListener(e -> new FightAnalysisFrame(TotalStatsPanel.this.getRootPane()));
		fightAnalysis.setForeground(ColorScheme.BRAND_ORANGE);

		popupMenu.add(viewWiki);
		popupMenu.add(removeAllFights);
		popupMenu.add(exportFightHistory);
		popupMenu.add(importFightHistory);
		popupMenu.add(fightAnalysis);
		setComponentPopupMenu(popupMenu);

		// Now initializing all lines:
		// FIRST LINE
		// basic label to display a title.
		JLabel titleLabel = new JLabel();
		titleLabel.setText("PvP Performance Tracker v" + PLUGIN.PLUGIN_VERSION);
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setForeground(Color.WHITE);
		add(titleLabel);

		// if settings haven't been configured, add a red label to display that they should be.
		if (!CONFIG.settingsConfigured())
		{
			initializeSettingsWarningLabel();
			add(settingsWarningLabel);
		}

		// SECOND LINE
		// panel to show total kills/deaths
		JPanel killDeathPanel = new JPanel(new BorderLayout());

		// left label to show kills
		killsLabel = new JLabel();
		killsLabel.setText(numKills + " Kills");
		killsLabel.setForeground(Color.WHITE);
		killDeathPanel.add(killsLabel, BorderLayout.WEST);

		// right label to show deaths
		deathsLabel = new JLabel();
		deathsLabel.setText(numDeaths + " Deaths");
		deathsLabel.setForeground(Color.WHITE);
		killDeathPanel.add(deathsLabel, BorderLayout.EAST);

		killDeathPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		killDeathPanel.setComponentPopupMenu(popupMenu);
		add(killDeathPanel);

		// THIRD LINE
		// panel to show the total off-pray stats (successful hits/total attacks)
		JPanel offPrayStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's off-pray stats
		JLabel leftLabel = new JLabel();
		leftLabel.setText("Total Off-Pray:");
		leftLabel.setForeground(Color.WHITE);
		offPrayStatsPanel.add(leftLabel, BorderLayout.WEST);

		// right shows off-pray stats
		offPrayStatsLabel = new JLabel();
		offPrayStatsLabel.setForeground(Color.WHITE);
		offPrayStatsPanel.add(offPrayStatsLabel, BorderLayout.EAST);

		offPrayStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		offPrayStatsPanel.setComponentPopupMenu(popupMenu);
		add(offPrayStatsPanel);

		// FOURTH LINE
		// panel to show the average deserved damage stats (average damage & average diff)
		JPanel deservedDmgStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's deserved dmg stats
		JLabel deservedDmgStatsLeftLabel = new JLabel();
		deservedDmgStatsLeftLabel.setText("Avg Deserved Dmg:");
		deservedDmgStatsLeftLabel.setForeground(Color.WHITE);
		deservedDmgStatsPanel.add(deservedDmgStatsLeftLabel, BorderLayout.WEST);

		// label to show deserved dmg stats
		deservedDmgStatsLabel = new JLabel();
		deservedDmgStatsLabel.setForeground(Color.WHITE);
		deservedDmgStatsPanel.add(deservedDmgStatsLabel, BorderLayout.EAST);

		deservedDmgStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		deservedDmgStatsPanel.setComponentPopupMenu(popupMenu);
		add(deservedDmgStatsPanel);

		// FIFTH LINE
		// panel to show the average damage dealt stats (average damage & average diff)
		JPanel dmgDealtStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's avg dmg dealt
		JLabel dmgDealtStatsLeftLabel = new JLabel();
		dmgDealtStatsLeftLabel.setText("Avg Damage Dealt:");
		dmgDealtStatsLeftLabel.setForeground(Color.WHITE);
		dmgDealtStatsPanel.add(dmgDealtStatsLeftLabel, BorderLayout.WEST);

		// label to show avg dmg dealt
		dmgDealtStatsLabel = new JLabel();
		dmgDealtStatsLabel.setForeground(Color.WHITE);
		dmgDealtStatsPanel.add(dmgDealtStatsLabel, BorderLayout.EAST);

		dmgDealtStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		dmgDealtStatsPanel.setComponentPopupMenu(popupMenu);
		add(dmgDealtStatsPanel);

		// SIXTH LINE
		// panel to show the total magic hit count and deserved hit count
		JPanel magicHitStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's magic hit count stats
		JLabel magicHitStatsLeftLabel = new JLabel();
		magicHitStatsLeftLabel.setText("Magic Luck:");
		magicHitStatsLeftLabel.setForeground(Color.WHITE);
		magicHitStatsPanel.add(magicHitStatsLeftLabel, BorderLayout.WEST);

		// label to show magic hit count stats
		magicHitCountStatsLabel = new JLabel();
		magicHitCountStatsLabel.setForeground(Color.WHITE);
		magicHitStatsPanel.add(magicHitCountStatsLabel, BorderLayout.EAST);

		magicHitStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		magicHitStatsPanel.setComponentPopupMenu(popupMenu);
		add(magicHitStatsPanel);

		// SEVENTH LINE
		// panel to show the offensive prayer success count
		JPanel offensivePrayStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's offensive pray stats
		JLabel offensivePrayStatsLeftLabel = new JLabel();
		offensivePrayStatsLeftLabel.setText("Offensive Pray:");
		offensivePrayStatsLeftLabel.setForeground(Color.WHITE);
		offensivePrayStatsPanel.add(offensivePrayStatsLeftLabel, BorderLayout.WEST);

		// label to show offensive pray stats
		offensivePrayCountStatsLabel = new JLabel();
		offensivePrayCountStatsLabel.setForeground(Color.WHITE);
		offensivePrayStatsPanel.add(offensivePrayCountStatsLabel, BorderLayout.EAST);

		offensivePrayStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		offensivePrayStatsPanel.setComponentPopupMenu(popupMenu);
		add(offensivePrayStatsPanel);

		// EIGTH LINE
		// panel to show the total hp healed
		JPanel hpHealedPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's avg hp healed stats
		JLabel hpHealedLeftLabel = new JLabel();
		hpHealedLeftLabel.setText("Avg HP Healed:");
		hpHealedLeftLabel.setForeground(Color.WHITE);
		hpHealedPanel.add(hpHealedLeftLabel, BorderLayout.WEST);

		// label to show hp healed stats
		hpHealedStatsLabel = new JLabel();
		hpHealedStatsLabel.setForeground(Color.WHITE);
		hpHealedPanel.add(hpHealedStatsLabel, BorderLayout.EAST);

		hpHealedPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		hpHealedPanel.setComponentPopupMenu(popupMenu);
		add(hpHealedPanel);

		// NINTH LINE
		// panel to show the avg ghost barrage stats
		JPanel ghostBarrageStatsPanel = new JPanel(new BorderLayout());

		// left label with a label to say it's avg ghost barrage stats
		JLabel ghostBarrageStatsLeftLabel = new JLabel();
		ghostBarrageStatsLeftLabel.setText("Avg Ghost Barrages:");
		ghostBarrageStatsLeftLabel.setForeground(Color.WHITE);
		ghostBarrageStatsPanel.add(ghostBarrageStatsLeftLabel, BorderLayout.WEST);

		ghostBarrageStatsLabel = new JLabel();
		ghostBarrageStatsLabel.setForeground(ColorScheme.BRAND_ORANGE);
		ghostBarrageStatsPanel.add(ghostBarrageStatsLabel, BorderLayout.EAST);
		ghostBarrageStatsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		ghostBarrageStatsPanel.setComponentPopupMenu(popupMenu);
		add(ghostBarrageStatsPanel);

		setLabels();

		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, (int)getPreferredSize().getHeight()));
	}

	private void setLabels()
	{
		String avgDeservedDmgDiffOneDecimal = nf1.format(avgDeservedDmgDiff);
		String avgDmgDealtDiffOneDecimal = nf1.format(avgDmgDealtDiff);

		killsLabel.setText(nf.format(numKills) + " Kill" + (numKills != 1 ? "s" : ""));
		killsLabel.setToolTipText("From a total of " + numFights + " fights, you got " + nf.format(numKills)
			+ " kill" + (numKills != 1 ? "s" : ""));
		deathsLabel.setText(nf.format(numDeaths) + " Death" + (numDeaths != 1 ? "s" : ""));
		deathsLabel.setToolTipText("From a total of " + numFights + " fights, you died "
			+ (numDeaths != 1 ? (nf.format(numDeaths) + " times") : "once"));

		if (totalStats.getAttackCount() >= 10000)
		{
			offPrayStatsLabel.setText(nfWithK(totalStats.getOffPraySuccessCount()) + "/" +
				nfWithK(totalStats.getAttackCount()) + " (" +
				Math.round(totalStats.calculateOffPraySuccessPercentage()) + "%)");
		}
		else
		{
			offPrayStatsLabel.setText(totalStats.getOffPrayStats());
		}

		// put tooltip on parent JPanel so that you can hover anywhere on the line to get the tooltip,
		// rather than having to hover exactly on the statistic label
		((JPanel)offPrayStatsLabel.getParent()).setToolTipText(nf.format(totalStats.getOffPraySuccessCount()) + " successful off-pray attacks/" +
			nf.format(totalStats.getAttackCount()) + " total attacks (" +
			nf2.format(totalStats.calculateOffPraySuccessPercentage()) + "%)");

		deservedDmgStatsLabel.setText(nf.format(avgDeservedDmg) + " (" +
			(avgDeservedDmgDiff > 0 ? "+" : "") + avgDeservedDmgDiffOneDecimal + ")");
		((JPanel)deservedDmgStatsLabel.getParent()).setToolTipText("<html>Avg of " + nf1.format(avgDeservedDmg) +
			" deserved damage per fight with avg diff of " + (avgDeservedDmgDiff > 0 ? "+" : "") +
			avgDeservedDmgDiffOneDecimal + ".<br>On kills: " + nf1.format(killAvgDeservedDmg) +
			" (" + (killAvgDeservedDmgDiff > 0 ? "+" : "") + nf1.format(killAvgDeservedDmgDiff) +
			"), on deaths: " + nf1.format(deathAvgDeservedDmg) +
			" (" + (deathAvgDeservedDmgDiff > 0 ? "+" : "") + nf1.format(deathAvgDeservedDmgDiff) + ")</html>");

		dmgDealtStatsLabel.setText(nf.format(avgDmgDealt) + " (" +
			(avgDmgDealtDiff > 0 ? "+" : "") + avgDmgDealtDiffOneDecimal + ")");
		((JPanel)dmgDealtStatsLabel.getParent()).setToolTipText("<html>Avg of " + nf1.format(avgDmgDealt) +
			" damage per fight with avg diff of " + (avgDmgDealtDiff > 0 ? "+" : "") +
			avgDmgDealtDiffOneDecimal + ".<br>On kills: " + nf1.format(killAvgDmgDealt) +
			" (" + (killAvgDmgDealtDiff > 0 ? "+" : "") + nf1.format(killAvgDmgDealtDiff) +
			"), on deaths: " + nf1.format(deathAvgDmgDealt) +
			" (" + (deathAvgDmgDealtDiff > 0 ? "+" : "") + nf1.format(deathAvgDmgDealtDiff) + ")</html>");

		if (totalStats.getMagicHitCountDeserved() >= 10000)
		{
			magicHitCountStatsLabel.setText(nfWithK(totalStats.getMagicHitCount()) + "/" +
				nfWithK((int)totalStats.getMagicHitCountDeserved()));
		}
		else
		{
			magicHitCountStatsLabel.setText(totalStats.getMagicHitStats());
		}
		((JPanel)magicHitCountStatsLabel.getParent()).setToolTipText("<html>You successfully hit " +
			totalStats.getMagicHitCount() + " of " + totalStats.getMagicAttackCount() + " magic attacks, but deserved to hit " +
		nf1.format(totalStats.getMagicHitCountDeserved()) + ".<br>Luck percentage: 100% = expected hits, >100% = lucky, <100% = unlucky</html>");

		if (totalStats.getAttackCount() >= 10000)
		{
			offensivePrayCountStatsLabel.setText(nfWithK(totalStats.getOffensivePraySuccessCount()) + "/" +
				nfWithK(totalStats.getAttackCount()) + " (" +
				Math.round(totalStats.calculateOffensivePraySuccessPercentage()) + "%)");
		}
		else
		{
			offensivePrayCountStatsLabel.setText(totalStats.getOffensivePrayStats());
		}
		((JPanel)offensivePrayCountStatsLabel.getParent()).setToolTipText(nf.format(totalStats.getOffensivePraySuccessCount()) + " successful offensive prayers/" +
			nf.format(totalStats.getAttackCount()) + " total attacks (" +
			nf2.format(totalStats.calculateOffensivePraySuccessPercentage()) + "%)");

		hpHealedStatsLabel.setText(nf.format(avgHpHealed));
		((JPanel)hpHealedStatsLabel.getParent()).setToolTipText("A total of " + nf.format(totalStats.getHpHealed())
			+ " hitpoints were recovered, with an average of " + nf.format(avgHpHealed) + " HP per fight.");

		ghostBarrageStatsLabel.setText(nf.format(avgGhostBarrageCount) + " G.B. (" + nf.format(avgGhostBarrageDeservedDamage) + ")");
		((JPanel)ghostBarrageStatsLabel.getParent()).setToolTipText("<html>You had an average of " + nf.format(avgGhostBarrageCount)
			+ " Ghost Barrages per fight, each worth an extra " + nf.format(avgGhostBarrageDeservedDamage)
			+ " deserved damage.<br>In total, you had " + totalStats.getGhostBarrageStats() + ".<br>"
			+ "Unless fighting in Duel Arena, your opponents likely had a similar value.");
	}

	// number format which adds K (representing 1,000) if the given number is over the threshold (10k),
	// with 1 decimal.
	// Ex. could turn 172,308 into 172.3k
	private String nfWithK(int number)
	{
		return nf1.format(number / 1000.0) + "k";
	}

	public void addFight(FightPerformance fight)
	{
		numFights++;

		totalStats.addAttacks(fight.getCompetitor().getOffPraySuccessCount(), fight.getCompetitor().getAttackCount(),
			fight.getCompetitor().getDeservedDamage(), fight.getCompetitor().getDamageDealt(),
			fight.getCompetitor().getMagicAttackCount(), fight.getCompetitor().getMagicHitCount(),
			fight.getCompetitor().getMagicHitCountDeserved(), fight.getCompetitor().getOffensivePraySuccessCount(),
			fight.getCompetitor().getHpHealed(), fight.getCompetitor().getGhostBarrageCount(),
			fight.getCompetitor().getGhostBarrageDeservedDamage());

		// add kill-specific or death-specific stats
		if (fight.getCompetitor().isDead())
		{
			numDeaths++;

			deathTotalDeservedDmg += fight.getCompetitor().getDeservedDamage();
			deathTotalDeservedDmgDiff += fight.getCompetitorDeservedDmgDiff();

			deathTotalDmgDealt += fight.getCompetitor().getDamageDealt();
			deathTotalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();

			deathAvgDeservedDmg = deathTotalDeservedDmg / numDeaths;
			deathAvgDeservedDmgDiff = deathTotalDeservedDmgDiff / numDeaths;

			deathAvgDmgDealt = deathTotalDmgDealt / numDeaths;
			deathAvgDmgDealtDiff = deathTotalDmgDealtDiff / numDeaths;
		}

		if (fight.getOpponent().isDead())
		{
			numKills++;

			killTotalDeservedDmg += fight.getCompetitor().getDeservedDamage();
			killTotalDeservedDmgDiff += fight.getCompetitorDeservedDmgDiff();

			killTotalDmgDealt += fight.getCompetitor().getDamageDealt();
			killTotalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();

			killAvgDeservedDmg = killTotalDeservedDmg / numKills;
			killAvgDeservedDmgDiff = killTotalDeservedDmgDiff / numKills;

			killAvgDmgDealt = killTotalDmgDealt / numKills;
			killAvgDmgDealtDiff = killTotalDmgDealtDiff / numKills;
		}

		totalDeservedDmg += fight.getCompetitor().getDeservedDamage();
		totalDeservedDmgDiff += fight.getCompetitorDeservedDmgDiff();

		totalDmgDealt += fight.getCompetitor().getDamageDealt();
		totalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();

		// calculate avg stats based on total/numFights
		avgDeservedDmg = totalDeservedDmg / numFights;
		avgDeservedDmgDiff = totalDeservedDmgDiff / numFights;

		avgDmgDealt = totalDmgDealt / numFights;
		avgDmgDealtDiff = totalDmgDealtDiff / numFights;

		avgHpHealed = (double)totalStats.getHpHealed() / numFights;

		avgGhostBarrageCount = (double)totalStats.getGhostBarrageCount() / numFights;
		avgGhostBarrageDeservedDamage = totalStats.getGhostBarrageCount() != 0 ? totalStats.getGhostBarrageDeservedDamage() / totalStats.getGhostBarrageCount() : 0;

		SwingUtilities.invokeLater(this::setLabels);
	}

	public void addFights(ArrayList<FightPerformance> fights)
	{
		if (fights == null || fights.size() < 1) { return; }

		numFights += fights.size();

		for (FightPerformance fight : fights)
		{
			totalStats.addAttacks(fight.getCompetitor().getOffPraySuccessCount(), fight.getCompetitor().getAttackCount(),
				fight.getCompetitor().getDeservedDamage(), fight.getCompetitor().getDamageDealt(),
				fight.getCompetitor().getMagicAttackCount(), fight.getCompetitor().getMagicHitCount(),
				fight.getCompetitor().getMagicHitCountDeserved(), fight.getCompetitor().getOffensivePraySuccessCount(),
				fight.getCompetitor().getHpHealed(), fight.getCompetitor().getGhostBarrageCount(),
				fight.getCompetitor().getGhostBarrageDeservedDamage());

			if (fight.getCompetitor().isDead())
			{
				numDeaths++;

				deathTotalDeservedDmg += fight.getCompetitor().getDeservedDamage();
				deathTotalDeservedDmgDiff += fight.getCompetitorDeservedDmgDiff();

				deathTotalDmgDealt += fight.getCompetitor().getDamageDealt();
				deathTotalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();
			}
			if (fight.getOpponent().isDead())
			{
				numKills++;

				killTotalDeservedDmg += fight.getCompetitor().getDeservedDamage();
				killTotalDeservedDmgDiff += fight.getCompetitorDeservedDmgDiff();

				killTotalDmgDealt += fight.getCompetitor().getDamageDealt();
				killTotalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();
			}

			totalDeservedDmg += fight.getCompetitor().getDeservedDamage();
			totalDeservedDmgDiff += fight.getCompetitorDeservedDmgDiff();

			totalDmgDealt += fight.getCompetitor().getDamageDealt();
			totalDmgDealtDiff += fight.getCompetitorDmgDealtDiff();
		}

		avgDeservedDmg = numFights != 0 ? totalDeservedDmg / numFights : 0;
		avgDeservedDmgDiff = numFights != 0 ? totalDeservedDmgDiff / numFights: 0;

		avgDmgDealt = numFights != 0 ? totalDmgDealt / numFights : 0;
		avgDmgDealtDiff = numFights != 0 ? totalDmgDealtDiff / numFights : 0;

		killAvgDeservedDmg = numKills != 0 ? killTotalDeservedDmg / numKills : 0;
		killAvgDeservedDmgDiff = numKills != 0 ? killTotalDeservedDmgDiff / numKills : 0;

		deathAvgDeservedDmg = numDeaths != 0 ? deathTotalDeservedDmg / numDeaths : 0;
		deathAvgDeservedDmgDiff = numDeaths != 0 ? deathTotalDeservedDmgDiff / numDeaths : 0;

		killAvgDmgDealt = numKills != 0 ? killTotalDmgDealt / numKills : 0;
		killAvgDmgDealtDiff = numKills != 0 ? killTotalDmgDealtDiff / numKills : 0;

		deathAvgDmgDealt = numDeaths != 0 ? deathTotalDmgDealt / numDeaths : 0;
		deathAvgDmgDealtDiff = numDeaths != 0 ? deathTotalDmgDealtDiff / numDeaths : 0;

		avgHpHealed = numFights != 0 ? (double)totalStats.getHpHealed() / numFights : 0;

		avgGhostBarrageCount = numFights != 0 ? (double)totalStats.getGhostBarrageCount() / numFights : 0;
		avgGhostBarrageDeservedDamage = totalStats.getGhostBarrageCount() != 0 ? totalStats.getGhostBarrageDeservedDamage() / totalStats.getGhostBarrageCount() : 0;

		SwingUtilities.invokeLater(this::setLabels);
	}

	public void reset()
	{
		numFights = 0;
		numDeaths = 0;
		numKills = 0;

		totalDeservedDmg = 0;
		totalDeservedDmgDiff = 0;
		killTotalDeservedDmg = 0;
		killTotalDeservedDmgDiff = 0;
		deathTotalDeservedDmg = 0;
		deathTotalDeservedDmgDiff = 0;
		totalDmgDealt = 0;
		totalDmgDealtDiff = 0;
		killTotalDmgDealt = 0;
		killTotalDmgDealtDiff = 0;
		deathTotalDmgDealt = 0;
		deathTotalDmgDealtDiff = 0;

		avgDeservedDmg = 0;
		avgDeservedDmgDiff = 0;
		killAvgDeservedDmg = 0;
		killAvgDeservedDmgDiff = 0;
		deathAvgDeservedDmg = 0;
		deathAvgDeservedDmgDiff = 0;
		avgDmgDealt = 0;
		avgDmgDealtDiff = 0;
		killAvgDmgDealt = 0;
		killAvgDmgDealtDiff = 0;
		deathAvgDmgDealt = 0;
		deathAvgDmgDealtDiff = 0;

		avgHpHealed = 0;

		avgGhostBarrageCount = 0;
		avgGhostBarrageDeservedDamage = 0;

		totalStats = new Fighter("Player");
		SwingUtilities.invokeLater(this::setLabels);
	}

	public void setConfigWarning(boolean enable)
	{
		if (enable)
		{
			setLayout(new GridLayout(LAYOUT_ROWS_WITH_WARNING, 1));

			if (settingsWarningLabel == null)
			{
				initializeSettingsWarningLabel();
			}
			add(settingsWarningLabel, 1);
		}
		else
		{
			if (getComponentCount() > LAYOUT_ROWS_WITHOUT_WARNING)
			{
				remove(settingsWarningLabel);
				settingsWarningLabel = null;
			}
			setLayout(new GridLayout(LAYOUT_ROWS_WITHOUT_WARNING, 1));
		}

		validate();
	}

	private void initializeSettingsWarningLabel()
	{
		settingsWarningLabel = new JLabel();
		settingsWarningLabel.setText("Check plugin config for setup options!");
		settingsWarningLabel.setToolTipText("Please verify that the plugin options are configured according to your needs in the plugin's Configuration Panel.");
		settingsWarningLabel.setForeground(Color.RED);

		// make the warning font bold & smaller font size so we can fit more text.
		Font newFont = settingsWarningLabel.getFont();
		newFont = newFont.deriveFont(newFont.getStyle() | Font.BOLD, 12f);
		settingsWarningLabel.setFont(newFont);

		settingsWarningLabel.setHorizontalAlignment(SwingConstants.CENTER);
	}
}

/*
 * Copyright (c)  2020, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;
import matsyir.pvpperformancetracker.controllers.AnalyzedFightPerformance;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.controllers.Fighter;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

// Panel to display fight performance. The first line shows player stats while the second is the opponent.
// There is a skull icon beside a player's name if they died. The usernames are fixed to the left and the
// stats are fixed to the right.

public class FightPerformancePanel extends JPanel
{
	private static JFrame fightLogFrame; // save frame as static instance so there's only one at a time, to avoid window clutter.
	private static ImageIcon deathIcon;
	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("HH:mm:ss 'on' yyyy/MM/dd");
	private static final NumberFormat nf = NumberFormat.getInstance();
	private static final Border normalBorder;
	private static final Border hoverBorder;
	static
	{
		// initialize number format
		nf.setMaximumFractionDigits(2);
		nf.setRoundingMode(RoundingMode.HALF_UP);

		// main border used when not hovering:
		// outer border: matte border with 4px bottom, with same color as the panel behind FightPerformancePanels. Used as invisible 4px offset
		// inner border: padding for the inner content of the panel.
		normalBorder = BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 4, 0, ColorScheme.DARK_GRAY_COLOR),
			new EmptyBorder(4, 6, 4, 6));

		// border used while hovering:
		// outer border: matte border with 4px bottom, with same color as the panel behind FightPerformancePanels. Used as invisible 4px offset
		// "middle" border: outline for the main panel
		// inner border: padding for the inner content of the panel, reduced by 1px to account for the outline
		hoverBorder = BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 4, 0, ColorScheme.DARK_GRAY_COLOR),
			BorderFactory.createCompoundBorder(
				BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_HOVER_COLOR),
				new EmptyBorder(3, 5, 3, 5)));
	}

	private FightPerformance fight;
	private AnalyzedFightPerformance analyzedFight;
	private boolean showBorders;

	// Panel to display previous fight performance data.
	// intended layout:
	//
	// Line 1: Player name ; 									Opponent Name
	// Line 2: Player off-pray hit stats ; 						Opponent off-pray hit stats
	// Line 3: Player deserved dps stats ; 						Opponent deserved dps stats
	// Line 4: Player damage dealt ; 							Opponent damage dealt
	// Line 5: Player magic hits/deserved magic hits ; 			Opponent magic hits/deserved magic hits
	// Line 6: Player offensive pray stats ; 					N/A (no data, client only)
	// Line 7: Player hp healed ; 								N/A (no data, client only)
	// Line 8: Player Ghost barrages & extra deserved damage ; 	N/A (no data, client only)
	// The greater stats will be highlighted green. In this example, the player would have all the green highlights.
	// example:
	//
	//     PlayerName      OpponentName
	//	   32/55 (58%)      28/49 (57%)
	//     176 (+12)          164 (-12)
	//     156 (-28)          184 (+28)
	//     8/7.62               11/9.21
	//     27/55 (49%)              N/A
	//     100                      N/A
	//     4 G.B. (37)				N/A
	//
	// these are the params to use for a normal panel.
	public FightPerformancePanel(FightPerformance fight)
	{
		this(fight, true, true, false, null);
	}

	public FightPerformancePanel(FightPerformance fight, boolean showActions, boolean showBorders, boolean showOpponentClientStats, FightPerformance oppFight)
	{
		this.showBorders = showBorders;
		if (deathIcon == null)
		{
			// load & rescale red skull icon used to show if a player/opponent died in a fight and as the frame icon.
			deathIcon = new ImageIcon(PLUGIN_ICON.getScaledInstance(12, 12,  Image.SCALE_DEFAULT));
		}

		this.fight = fight;
		// save Fighters temporarily for more direct access
		Fighter competitor = fight.getCompetitor();
		Fighter opponent = fight.getOpponent();

		setLayout(new BorderLayout(5, 0));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		String tooltipText = "This fight ended at " + DATE_FORMAT.format(Date.from(Instant.ofEpochMilli(fight.getLastFightTime())));
		setToolTipText(tooltipText);

		if (showBorders)
		{
			setBorder(normalBorder);
		}

		// boxlayout panel to hold each of the lines.
		JPanel fightPanel = new JPanel();
		fightPanel.setLayout(new BoxLayout(fightPanel, BoxLayout.Y_AXIS));
		fightPanel.setBackground(null);

		// FIRST LINE: both player names
		JPanel playerNamesLine = new JPanel();
		playerNamesLine.setLayout(new BorderLayout());
		playerNamesLine.setBackground(null);

		// first line LEFT: player name
		JLabel playerStatsName = new JLabel();
		if (competitor.isDead())
		{
			playerStatsName.setIcon(deathIcon);
		}
		playerStatsName.setText(competitor.getName());
		playerStatsName.setForeground(Color.WHITE);
		playerNamesLine.add(playerStatsName, BorderLayout.WEST);

		// first line RIGHT: opponent name
		JLabel opponentStatsName = new JLabel();
		if (opponent.isDead())
		{
			opponentStatsName.setIcon(deathIcon);
		}
		opponentStatsName.setText(opponent.getName());
		opponentStatsName.setForeground(Color.WHITE);
		playerNamesLine.add(opponentStatsName, BorderLayout.EAST);

		// SECOND LINE: both player's off-pray hit stats
		JPanel offPrayStatsLine = new JPanel();
		offPrayStatsLine.setLayout(new BorderLayout());
		offPrayStatsLine.setBackground(null);

		// second line LEFT: player's off-pray hit stats
		JLabel playerOffPrayStats = new JLabel();
		playerOffPrayStats.setText(competitor.getOffPrayStats());
		playerOffPrayStats.setToolTipText(competitor.getName() + " hit " + competitor.getOffPraySuccessCount() + " successful off-pray attacks out of " +
			competitor.getAttackCount() + " total attacks (" +
			nf.format(competitor.calculateOffPraySuccessPercentage()) + "%)");
		playerOffPrayStats.setForeground(fight.competitorOffPraySuccessIsGreater() ? Color.GREEN : Color.WHITE);
		offPrayStatsLine.add(playerOffPrayStats, BorderLayout.WEST);

		// second line RIGHT:, opponent's off-pray hit stats
		JLabel opponentOffPrayStats = new JLabel();
		opponentOffPrayStats.setText(opponent.getOffPrayStats());
		opponentOffPrayStats.setToolTipText(opponent.getName() + " hit " + opponent.getOffPraySuccessCount() + " successful off-pray attacks out of " +
			opponent.getAttackCount() + " total attacks (" +
			nf.format(opponent.calculateOffPraySuccessPercentage()) + "%)");
		opponentOffPrayStats.setForeground(fight.opponentOffPraySuccessIsGreater() ? Color.GREEN : Color.WHITE);
		offPrayStatsLine.add(opponentOffPrayStats, BorderLayout.EAST);

		// THIRD LINE: both player's deserved dps stats
		JPanel deservedDpsStatsLine = new JPanel();
		deservedDpsStatsLine.setLayout(new BorderLayout());
		deservedDpsStatsLine.setBackground(null);

		// third line LEFT: player's deserved dps stats
		JLabel playerDeservedDpsStats = new JLabel();
		playerDeservedDpsStats.setText(competitor.getDeservedDmgString(opponent));
		//playerDeservedDpsStats.setToolTipText(fight.getCompetitorDeservedDmgString(1, false) +  ": Average damage deserved based on gear & overheads (difference vs opponent in brackets)");
		playerDeservedDpsStats.setToolTipText(
			competitor.getName() + " deserved to deal " + nf.format(competitor.getDeservedDamage()) +
			" damage based on gear & overheads (" + competitor.getDeservedDmgString(opponent, 1, true) + " vs opponent)");
		playerDeservedDpsStats.setForeground(fight.competitorDeservedDmgIsGreater() ? Color.GREEN : Color.WHITE);
		deservedDpsStatsLine.add(playerDeservedDpsStats, BorderLayout.WEST);

		// third line RIGHT: opponent's deserved dps stats
		JLabel opponentDeservedDpsStats = new JLabel();
		opponentDeservedDpsStats.setText(opponent.getDeservedDmgString(competitor));
		//opponentDeservedDpsStats.setToolTipText(fight.getOpponentDeservedDmgString(1, false) + ": Average damage deserved based on gear & overheads (difference vs opponent in brackets)");
		opponentDeservedDpsStats.setToolTipText(
			opponent.getName() + " deserved to deal " + nf.format(opponent.getDeservedDamage()) +
			" damage based on gear & overheads (" + opponent.getDeservedDmgString(competitor, 1, true) + " vs you)");
		opponentDeservedDpsStats.setForeground(fight.opponentDeservedDmgIsGreater() ? Color.GREEN : Color.WHITE);
		deservedDpsStatsLine.add(opponentDeservedDpsStats, BorderLayout.EAST);

		// FOURTH LINE: both player's damage dealt
		JPanel dmgDealtStatsLine = new JPanel();
		dmgDealtStatsLine.setLayout(new BorderLayout());
		dmgDealtStatsLine.setBackground(null);

		// fourth line LEFT: player's damage dealt
		JLabel playerDmgDealtStats = new JLabel();
		playerDmgDealtStats.setText(competitor.getDmgDealtString(opponent));
		playerDmgDealtStats.setToolTipText(competitor.getName() + " dealt " + competitor.getDamageDealt() +
			" damage (" + competitor.getDmgDealtString(opponent, true) + " vs opponent)");
		playerDmgDealtStats.setForeground(fight.competitorDmgDealtIsGreater() ? Color.GREEN : Color.WHITE);
		dmgDealtStatsLine.add(playerDmgDealtStats, BorderLayout.WEST);

		// fourth line RIGHT: opponent's damage dealt
		JLabel opponentDmgDealtStats = new JLabel();
		opponentDmgDealtStats.setText(opponent.getDmgDealtString(competitor));
		opponentDmgDealtStats.setToolTipText(opponent.getName() + " dealt " + opponent.getDamageDealt() +
			" damage (" + opponent.getDmgDealtString(competitor, true) + " vs you)");
		opponentDmgDealtStats.setForeground(fight.opponentDeservedDmgIsGreater() ? Color.GREEN : Color.WHITE);
		dmgDealtStatsLine.add(opponentDmgDealtStats, BorderLayout.EAST);

		// FIFTH LINE: both player's magic hit stats (successful magic attacks/deserved successful magic attacks)
		JPanel magicHitStatsLine = new JPanel();
		magicHitStatsLine.setLayout(new BorderLayout());
		magicHitStatsLine.setBackground(null);

		// fifth line LEFT: player's magic hit stats
		JLabel playerMagicHitStats = new JLabel();
		playerMagicHitStats.setText(String.valueOf(competitor.getMagicHitStats()));
		playerMagicHitStats.setToolTipText("<html>" + competitor.getName() + " successfully hit " +
			competitor.getMagicHitCount() + " of " + competitor.getMagicAttackCount() + " magic attacks, but deserved to hit " +
			nf.format(competitor.getMagicHitCountDeserved()) + ".<br>Luck percentage: 100% = expected hits, >100% = lucky, <100% = unlucky</html>");
		playerMagicHitStats.setForeground(fight.competitorMagicHitsLuckier() ? Color.GREEN : Color.WHITE);
		magicHitStatsLine.add(playerMagicHitStats, BorderLayout.WEST);

		// fifth line RIGHT: opponent's magic hit stats
		JLabel opponentMagicHitStats = new JLabel();
		opponentMagicHitStats.setText(String.valueOf(opponent.getMagicHitStats()));
		opponentMagicHitStats.setToolTipText("<html>" + opponent.getName() + " successfully hit " +
			opponent.getMagicHitCount() + " of " + opponent.getMagicAttackCount() + " magic attacks, but deserved to hit " +
			nf.format(opponent.getMagicHitCountDeserved()) + ".<br>Luck percentage: 100% = expected hits, >100% = lucky, <100% = unlucky</html>");
		opponentMagicHitStats.setForeground(fight.opponentMagicHitsLuckier() ? Color.GREEN : Color.WHITE);
		magicHitStatsLine.add(opponentMagicHitStats, BorderLayout.EAST);

		// SIXTH LINE: player's offensive pray stats (only player's, no data for opponent)
		JPanel offensivePrayStatsLine = new JPanel();
		offensivePrayStatsLine.setLayout(new BorderLayout());
		offensivePrayStatsLine.setBackground(null);

		// sixth line LEFT: player's offensive pray stats
		JLabel playerOffensivePrayStats = new JLabel();
		playerOffensivePrayStats.setText(String.valueOf(competitor.getOffensivePrayStats()));
		playerOffensivePrayStats.setToolTipText(competitor.getName() + " did " + competitor.getOffensivePraySuccessCount() + " successful offensive prayers out of " +
			competitor.getAttackCount() + " total attacks (" +
			nf.format(competitor.calculateOffensivePraySuccessPercentage()) + "%)");

		playerOffensivePrayStats.setForeground(
			(showOpponentClientStats && competitor.calculateOffensivePraySuccessPercentage() >
				oppFight.getCompetitor().calculateOffensivePraySuccessPercentage()) ?
				Color.GREEN : Color.WHITE);

		offensivePrayStatsLine.add(playerOffensivePrayStats, BorderLayout.WEST);

		//
		// sixth line RIGHT: "N/A", no data.
		JLabel opponentOffensivePrayStats = new JLabel();
		if (showOpponentClientStats)
		{
			Fighter oppComp = oppFight.getCompetitor();

			opponentOffensivePrayStats.setText(String.valueOf(oppComp.getOffensivePrayStats()));
			opponentOffensivePrayStats.setToolTipText(oppComp.getName() + " did " + oppComp.getOffensivePraySuccessCount() + " successful offensive prayers out of " +
				oppComp.getAttackCount() + " total attacks (" +
				nf.format(oppComp.calculateOffensivePraySuccessPercentage()) + "%)");
			opponentOffensivePrayStats.setForeground(
				oppFight.getCompetitor().calculateOffensivePraySuccessPercentage() > competitor.calculateOffensivePraySuccessPercentage()
					? Color.GREEN : Color.WHITE);
		}
		else
		{
			opponentOffensivePrayStats.setText("N/A");
			opponentOffensivePrayStats.setToolTipText("No data is available for the opponent's offensive prayers");
			opponentOffensivePrayStats.setForeground(Color.WHITE);
		}
		offensivePrayStatsLine.add(opponentOffensivePrayStats, BorderLayout.EAST);

		// SEVENTH LINE: player's HP healed (only player's, no data for opponent)
		JPanel hpHealedLine = new JPanel();
		hpHealedLine.setLayout(new BorderLayout());
		hpHealedLine.setBackground(null);

		// SEVENTH LINE LEFT: player's HP healed
		JLabel playerHpHealed = new JLabel();
		playerHpHealed.setText(String.valueOf(competitor.getHpHealed()));
		playerHpHealed.setToolTipText(competitor.getName() + " recovered " + competitor.getHpHealed() + " hitpoints during the fight");

		playerHpHealed.setForeground(
			(showOpponentClientStats && competitor.getHpHealed() > oppFight.getCompetitor().getHpHealed()) ?
				Color.GREEN : Color.WHITE);

		hpHealedLine.add(playerHpHealed, BorderLayout.WEST);

		// SEVENTH LINE RIGHT: "N/A", no data.
		JLabel opponentHpHealed = new JLabel();
		if (showOpponentClientStats)
		{
			Fighter oppComp = oppFight.getCompetitor();

			opponentHpHealed.setText(String.valueOf(oppComp.getHpHealed()));
			opponentHpHealed.setToolTipText(oppComp.getName() + " recovered " + oppComp.getHpHealed() + " hitpoints during the fight");
			opponentHpHealed.setForeground(oppFight.getCompetitor().getHpHealed() > competitor.getHpHealed() ?
				Color.GREEN : Color.WHITE);
		}
		else
		{
			opponentHpHealed.setText("N/A");
			opponentHpHealed.setToolTipText("No data is available for the opponent's hp healed");
			opponentHpHealed.setForeground(Color.WHITE);
		}
		hpHealedLine.add(opponentHpHealed, BorderLayout.EAST);

		// EIGHTH LINE: line container for player's Ghost barrages (only player's, no data for opponent)
		JPanel ghostBarragesLine = new JPanel();
		ghostBarragesLine.setLayout(new BorderLayout());
		ghostBarragesLine.setBackground(null);

		// EIGHTH LINE LEFT: player's ghost barrage stats
		JLabel playerGhostBarrages = new JLabel();
		playerGhostBarrages.setText(competitor.getGhostBarrageStats());
		playerGhostBarrages.setToolTipText("<html>(Advanced): " + competitor.getName() + " hit " + competitor.getGhostBarrageCount()
			+ " ghost barrages during the fight, worth an extra " + nf.format(competitor.getGhostBarrageDeservedDamage())
			+ " deserved damage.<br>Unless fighting in Duel Arena, your opponent likely had a similar value.</html>");

		playerGhostBarrages.setForeground(
			(showOpponentClientStats
				&& competitor.getGhostBarrageDeservedDamage() > oppFight.getCompetitor().getGhostBarrageDeservedDamage())
				? Color.GREEN : ColorScheme.BRAND_ORANGE);

		ghostBarragesLine.add(playerGhostBarrages, BorderLayout.WEST);

		// EIGHTH LINE RIGHT: "N/A", no data.
		JLabel opponentGhostBarrages = new JLabel();
		if (showOpponentClientStats)
		{
			Fighter oppComp = oppFight.getCompetitor();

			opponentGhostBarrages.setText(oppComp.getGhostBarrageStats());
			opponentGhostBarrages.setToolTipText("<html>(Advanced): " + oppComp.getName() + " hit " + oppComp.getGhostBarrageCount()
				+ " ghost barrages during the fight, worth an extra " + nf.format(oppComp.getGhostBarrageDeservedDamage())
				+ " deserved damage.<br>Unless fighting in Duel Arena, your opponent likely had a similar value.</html>");
			opponentGhostBarrages.setForeground(
				oppFight.getCompetitor().getGhostBarrageDeservedDamage() > competitor.getGhostBarrageDeservedDamage()
				? Color.GREEN : ColorScheme.BRAND_ORANGE);
		}
		else
		{
			opponentGhostBarrages.setText("N/A");
			opponentGhostBarrages.setToolTipText("No data is available for the opponent's ghost barrages");
			opponentGhostBarrages.setForeground(ColorScheme.BRAND_ORANGE);
		}
		ghostBarragesLine.add(opponentGhostBarrages, BorderLayout.EAST);

		fightPanel.add(playerNamesLine);
		fightPanel.add(offPrayStatsLine);
		fightPanel.add(deservedDpsStatsLine);
		fightPanel.add(dmgDealtStatsLine);
		fightPanel.add(magicHitStatsLine);
		fightPanel.add(offensivePrayStatsLine);
		fightPanel.add(hpHealedLine);
		fightPanel.add(ghostBarragesLine);

		add(fightPanel, BorderLayout.NORTH);

		// setup mouse events for hovering and clicking to open the fight log
		MouseAdapter fightPerformanceMouseListener = new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				setFullBackgroundColor(ColorScheme.DARK_GRAY_COLOR);
				setOutline(true);
				setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setFullBackgroundColor(ColorScheme.DARKER_GRAY_COLOR);
				setOutline(false);
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}

			@Override
			public void mouseClicked(MouseEvent e)
			{
				// ignore right clicks since that should be used for context menus/popup menus.
				// btn1: left click, btn2: middle click, btn3: right click
				if (e.getButton() == MouseEvent.BUTTON3)
				{
					return;
				}

				createFightLogFrame();
			}
		};
		addMouseListener(fightPerformanceMouseListener);

		// skip the remaining code if we aren't showing actions.
		if (!showActions) { return; }

		JPopupMenu popupMenu = new JPopupMenu();

		// Create "Remove Fight" popup menu/context menu
		final JMenuItem removeFight = new JMenuItem("Remove Fight");
		removeFight.addActionListener(e ->
		{
			int dialogResult = JOptionPane.showConfirmDialog(this, "Are you sure you want to remove this fight? This cannot be undone.", "Warning", JOptionPane.YES_NO_OPTION);
			if (dialogResult == JOptionPane.YES_OPTION)
			{
				PLUGIN.removeFight(fight);
			}
		});

		// Create "Copy as discord message" context menu
		final JMenuItem copyDiscordMsg = new JMenuItem("Copy As Discord Msg");
		copyDiscordMsg.addActionListener(e -> PLUGIN.copyFightAsDiscordMsg(fight));

		// Create "Copy Fight Data" popup menu/context menu
		final JMenuItem copyFight = new JMenuItem("Copy Fight Data (Advanced)");
		copyFight.addActionListener(e -> PLUGIN.exportFight(fight));
		copyFight.setForeground(ColorScheme.BRAND_ORANGE);

		final JMenuItem openFightAnalysis = new JMenuItem("Fight Analysis (Advanced)");
		openFightAnalysis.addActionListener(e -> new FightAnalysisFrame(fight, this.getRootPane()));
		openFightAnalysis.setForeground(ColorScheme.BRAND_ORANGE);

		popupMenu.add(removeFight);
		popupMenu.add(copyDiscordMsg);
		popupMenu.add(copyFight);
		popupMenu.add(openFightAnalysis);
		setComponentPopupMenu(popupMenu);

		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, (int)getPreferredSize().getHeight()));
	}

	public FightPerformancePanel(AnalyzedFightPerformance aFight)
	{
		this(aFight, false, true, true, aFight.getOpposingFight());

		this.analyzedFight = aFight;
	}

	private void setFullBackgroundColor(Color color)
	{
		this.setBackground(color);
		for (Component c : getComponents())
		{
			c.setBackground(color);
		}
	}

	private void setOutline(boolean visible)
	{
		if (showBorders)
		{
			this.setBorder(visible ? hoverBorder : normalBorder);
		}
	}

	private void createFightLogFrame()
	{
		// destroy current frame if it exists so we only have one at a time (static field)
		if (fightLogFrame != null)
		{
			fightLogFrame.dispose();
		}

		// show error modal if the fight has no log entries to display.
		ArrayList<FightLogEntry> fightLogEntries = new ArrayList<>(fight.getAllFightLogEntries());
		fightLogEntries.removeIf(e -> !e.isFullEntry());
		if (fightLogEntries.size() < 1)
		{
			PLUGIN.createConfirmationModal(false, "This fight has no attack logs to display, or the data is outdated.");
		}
		else if (analyzedFight != null) // if analyzed fight is set, then show an analyzed fight's fightLogFrame.
		{
			fightLogFrame = new FightLogFrame(analyzedFight, getRootPane());

		}
		else
		{
			fightLogFrame = new FightLogFrame(fight,
				fightLogEntries,
				getRootPane());
		}
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.views;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.event.ItemEvent;
import java.io.File;
import java.math.RoundingMode;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.NumberFormat;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRootPane;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import lombok.extern.slf4j.Slf4j;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN_ICON;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import matsyir.pvpperformancetracker.controllers.AnalyzedFightPerformance;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.LinkBrowser;

@Slf4j
public class FightAnalysisFrame extends JFrame
{
	public static String WIKI_HELP_URL = "https://github.com/Matsyir/pvp-performance-tracker/wiki#fight-analysisfight-merge";
	private static String WINDOW_TITLE = "PvP Performance Tracker: Fight Analysis";
	private static final NumberFormat nf = NumberFormat.getInstance();

	private JPanel mainPanel;
	private JTextField mainFightJsonInput;
	private JTextField opponentFightJsonInput;

	private FightPerformance mainFight;
	private FightPerformance opponentFight;
	private AnalyzedFightPerformance analyzedFight;

	static
	{
		// initialize number format
		nf.setMaximumFractionDigits(2);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}

	FightAnalysisFrame(FightPerformance fight, JRootPane rootPane)
	{
		this(rootPane);
		mainFightJsonInput.setText(PLUGIN.GSON.toJson(fight, FightPerformance.class));
		validate();
		repaint();
	}

	FightAnalysisFrame(JRootPane rootPane)
	{
		super("PvP Performance Tracker: Fight Analysis");
		// if always on top is supported, and the core RL plugin has "always on top" set, make the frame always
		// on top as well so it can be above the client.
		if (isAlwaysOnTopSupported())
		{
			setAlwaysOnTop(PLUGIN.getRuneliteConfig().gameAlwaysOnTop());
		}

		setIconImage(PLUGIN_ICON);
		Dimension size = new Dimension(700, 448);
		setSize(size);
		setMinimumSize(size);
		setLocation(rootPane.getLocationOnScreen());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setPreferredSize(getSize());
		mainPanel.setBorder(BorderFactory.createEmptyBorder(8, 16, 8, 16));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR); //must set all backgrounds to null after for this to work... hmm maybe
		mainPanel.setVisible(true);

		add(mainPanel);

		setVisible(true);
		initializeFrame();
	}

	// setup the initial frame contents, which should be two text inputs used to input
	// two single related fightPerformance json data.
	private void initializeFrame()
	{
		setTitle(WINDOW_TITLE);
		mainPanel.removeAll();

		// init containers
		GridLayout textAreaLayout = new GridLayout(1, 2);
		textAreaLayout.setHgap(4);
		textAreaLayout.setVgap(4);
		JPanel textLabelLine = new JPanel(textAreaLayout);
		textLabelLine.setBackground(null);
		JPanel textAreaLine = new JPanel(textAreaLayout);
		textAreaLine.setBackground(null);

		// wiki link label

		JButton wikiLinkLabel = new JButton("<html><u>Wiki/Example</u>&nbsp;&#8599;</html>");
		wikiLinkLabel.setToolTipText("Open URL to Github wiki with an example & more details");
		wikiLinkLabel.setSize(256, 32);
		wikiLinkLabel.setMaximumSize(new Dimension(256, 32));
		wikiLinkLabel.setHorizontalAlignment(SwingConstants.CENTER);
		wikiLinkLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		wikiLinkLabel.setForeground(ColorScheme.GRAND_EXCHANGE_LIMIT);
		wikiLinkLabel.addActionListener(e -> LinkBrowser.browse(WIKI_HELP_URL));

		// instruction label
		JLabel instructionLabel = new JLabel();
		instructionLabel.setText("<html>This window is used to merge two opposing fighters' fight data in order to " +
			"get more accurate stats about the fight, since some data is only available client-side. Both data " +
			"entries should come from the same fight, but from two different clients. Fighter 2 is Fighter 1's " +
			"opponent. Right click a fight in order to copy its data.<br/><br/>" +
			"When using this, the following stats are applied to deserved damage & deserved magic hits:<br/>" +
			"&nbsp;&nbsp;&mdash; Offensive prayers, instead of always being correct<br/>" +
			"&nbsp;&nbsp;&mdash; Boosted or drained levels (e.g from brewing down), instead of using config stats or fixed LMS stats<br/>" +
			"&nbsp;&nbsp;&mdash; The magic defence buff from Augury, instead of assuming Piety/Rigour while getting maged (if it's used)" +
			"<br><br><strong>Note: </strong>For now, ghost barrages are not integrated into this, the above improvements " +
			"do not apply for its deserved damage, and its deserved damage is not included in the main deserved damage " +
			"stat. It merely displays what each client had saved.</html>");
		instructionLabel.setForeground(Color.WHITE);
		instructionLabel.setSize(mainPanel.getWidth(), instructionLabel.getHeight());
		instructionLabel.setHorizontalAlignment(SwingConstants.LEFT);
		instructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// fight data input labels
		JLabel firstFightLabel = new JLabel();
		firstFightLabel.setText("<html><strong>Enter fight data for Fighter 1:</strong><br/>You can drag & drop a text file onto the text box.</html>");
		firstFightLabel.setForeground(Color.WHITE);
		textLabelLine.add(firstFightLabel);

		JLabel secondFightLabel = new JLabel();
		secondFightLabel.setText("<html><strong>Enter fight data for Fighter 2:</strong><br/>You can drag & drop a text file onto the text box.</html>");
		secondFightLabel.setForeground(Color.WHITE);
		textLabelLine.add(secondFightLabel);
		textLabelLine.setSize(mainPanel.getWidth(), 48);
		textLabelLine.setMaximumSize(new Dimension(mainPanel.getWidth(), 48));

		// fight data input fields
		mainFightJsonInput = new JTextField(32);
		mainFightJsonInput.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
		mainFightJsonInput.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

		// setup drag & drop file upload support directly into textbox
		// https://stackoverflow.com/a/9111327/7982774
		mainFightJsonInput.setDropTarget(new DropTarget() {
			public synchronized void drop(DropTargetDropEvent evt) {
				try
				{
					evt.acceptDrop(DnDConstants.ACTION_COPY);
					List<File> droppedFiles = (List<File>)
						evt.getTransferable().getTransferData(DataFlavor.javaFileListFlavor);

					for (File file : droppedFiles)
					{
						String fileData = new String(Files.readAllBytes(Paths.get(file.getAbsolutePath())));
						mainFightJsonInput.setText(fileData);
						FightAnalysisFrame.this.validate();
						break;
					}

					evt.dropComplete(true);
				}
				catch (Exception ex)
				{
					ex.printStackTrace();
				}
			}
		});

		textAreaLine.add(mainFightJsonInput);
		opponentFightJsonInput = new JTextField(32);
		opponentFightJsonInput.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
		opponentFightJsonInput.setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));

		// setup drag & drop file upload support directly into textbox
		opponentFightJsonInput.setDropTarget(new DropTarget() {
			public synchronized void drop(DropTargetDropEvent evt) {
				try
				{
					evt.acceptDrop(DnDConstants.ACTION_COPY);
					List<File> droppedFiles = (List<File>)
						evt.getTransferable().getTransferData(DataFlavor.javaFileListFlavor);

					for (File file : droppedFiles)
					{
						String fileData = new String(Files.readAllBytes(Paths.get(file.getAbsolutePath())));
						opponentFightJsonInput.setText(fileData);
						FightAnalysisFrame.this.validate();
						break;
					}

					evt.dropComplete(true);
				}
				catch (Exception ex)
				{
					ex.printStackTrace();
				}
			}
		});

		textAreaLine.add(opponentFightJsonInput);
		textAreaLine.setSize(mainPanel.getWidth(), 32);
		textAreaLine.setMaximumSize(new Dimension(mainPanel.getWidth(), 32));

		// confirm button
		JButton confirmButton = new JButton("<html><strong>Merge Fight Data</strong></html>");
		confirmButton.setSize(256, 32);
		confirmButton.setMaximumSize(new Dimension(256, 32));
		confirmButton.addActionListener(e -> performAnalysis());
		confirmButton.setAlignmentX(Component.CENTER_ALIGNMENT);

		// add all components
		mainPanel.add(wikiLinkLabel);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 4)));
		mainPanel.add(instructionLabel);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 16)));
		mainPanel.add(textLabelLine);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 4)));
		mainPanel.add(textAreaLine);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 16)));
		mainPanel.add(confirmButton);

		validate();
		repaint();
	}

	// parse fights into mainFight / opponentFight. Returns false if either are invalid.
	private boolean parseFights()
	{
		try
		{
			// if either fight or their log entries are null, error
			mainFight = PLUGIN.GSON.fromJson(mainFightJsonInput.getText().trim(), FightPerformance.class);
			if (mainFight == null || mainFight.getAllFightLogEntries() == null || mainFight.getAllFightLogEntries().size() < 1)
			{
				PLUGIN.createConfirmationModal(false, "Error parsing Fighter 1's fight data.");
				mainFight = null;

				return false;
			}

			opponentFight = PLUGIN.GSON.fromJson(opponentFightJsonInput.getText().trim(), FightPerformance.class);
			if (opponentFight == null || opponentFight.getAllFightLogEntries() == null || opponentFight.getAllFightLogEntries().size() < 1)
			{
				PLUGIN.createConfirmationModal(false, "Error parsing Fighter 2's fight data.");
				opponentFight = null;

				return false;
			}


			PLUGIN.initializeImportedFight(mainFight);
			PLUGIN.initializeImportedFight(opponentFight);
		}
		catch(Exception e)
		{
			PLUGIN.createConfirmationModal(false, "Error while parsing fight data.");
			return false;
		}

		return true;
	}

	// start fight parsing, and if fights are valid then move onto the next "state" of the frame
	// where we will display stats about the fight.
	private void performAnalysis()
	{
		boolean fightsValid = parseFights();
		// parseFights includes error messages if the parse fails
		if (!fightsValid) { return; }

		try
		{

			analyzedFight = new AnalyzedFightPerformance(mainFight, opponentFight, this::displayAnalysis);
			// now that we've got the merged fight, display results, this is done with the displayAnalysis callback
		}
		catch(Exception e)
		{
			log.info("Error during fight analysis - could not merge fights. Exception tack trace: ", e);
			PLUGIN.createConfirmationModal(false, "<html>Error while merging fights. Unable to analyze.<br/>If you think this should have been valid, feel free to submit<br/>an issue on the github repo, and include client logs.</html>");
		}
	}

	private void displayAnalysis()
	{
		mainPanel.removeAll();
		setTitle(WINDOW_TITLE + " - " + analyzedFight.competitor.getName() + " vs " + analyzedFight.opponent.getName());

		// intro label
		JLabel mergedFightLabel = new JLabel("<html><strong>Merged Fight &mdash; Click the panel for more details.</strong></html>");
		mergedFightLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		mergedFightLabel.setHorizontalAlignment(SwingConstants.CENTER);

		// analyzed fight
		FightPerformancePanel analyzedFightPanel = new FightPerformancePanel(analyzedFight);
		analyzedFightPanel.setSize(220, 134);
		analyzedFightPanel.setMaximumSize(new Dimension(220, 134));
		analyzedFightPanel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// back to setup/config button
		JButton backButton = new JButton("<html><strong>Back</strong></html>");
		backButton.setSize(256, 32);
		backButton.setMaximumSize(new Dimension(256, 32));
		backButton.addActionListener(e -> initializeFrame());
		backButton.setAlignmentX(Component.CENTER_ALIGNMENT);


		// checkbox to show initial fights
		JCheckBox initialFightCheckbox = new JCheckBox();
		initialFightCheckbox.setText("Show initial fights");
		initialFightCheckbox.setSelected(false);
		initialFightCheckbox.setAlignmentX(Component.CENTER_ALIGNMENT);

		JPanel initialFightsPanel = new JPanel();
		initialFightsPanel.setLayout(new BoxLayout(initialFightsPanel, BoxLayout.X_AXIS));
		initialFightsPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
		// initial fights
		FightPerformancePanel mainFightPanel = new FightPerformancePanel(mainFight, false, true, false, null);
		mainFightPanel.setSize(220, 134);
		mainFightPanel.setMaximumSize(new Dimension(220, 134));
		initialFightsPanel.add(mainFightPanel);
		initialFightsPanel.add(Box.createRigidArea(new Dimension(8, 0)));

		FightPerformancePanel oppFightPanel = new FightPerformancePanel(opponentFight, false, true, false, null);
		oppFightPanel.setSize(220, 134);
		oppFightPanel.setMaximumSize(new Dimension(220, 134));
		initialFightsPanel.add(oppFightPanel);
		initialFightsPanel.setVisible(false);


		initialFightCheckbox.addItemListener(e -> {
			if (e.getStateChange() == ItemEvent.SELECTED)
			{
				initialFightsPanel.setVisible(true);
				validate();
				repaint();
			}
			else
			{
				initialFightsPanel.setVisible(false);
				validate();
				repaint();
			}
		});

		// add all components
		mainPanel.add(mergedFightLabel);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		mainPanel.add(analyzedFightPanel);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		mainPanel.add(backButton);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		mainPanel.add(initialFightCheckbox);
		mainPanel.add(Box.createRigidArea(new Dimension(0, 8)));
		mainPanel.add(initialFightsPanel);

		validate();
		repaint();
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker;

import com.google.common.collect.ImmutableSet;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializer;
import com.google.inject.Provides;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.Writer;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.swing.ImageIcon;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.models.RangeAmmoData;
import matsyir.pvpperformancetracker.models.oldVersions.FightPerformance__1_5_5;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.HeadIcon;
import net.runelite.api.HitsplatID;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.FakeXpDrop;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

@Slf4j
@PluginDescriptor(
	name = "PvP Performance Tracker"
)
public class PvpPerformanceTrackerPlugin extends Plugin
{
	// static fields
	public static final String PLUGIN_VERSION = "1.5.10";
	public static final String CONFIG_KEY = "pvpperformancetracker";
	// Data folder naming history:
	// "pvp-performance-tracker": From release, until 1.5.9 update @ 2024-08-19
	// "pvp-performance-tracker2": From 1.5.9 update, until present
	public static final String DATA_FOLDER = "pvp-performance-tracker2";
	public static final String FIGHT_HISTORY_DATA_FNAME = "FightHistoryData.json";
	public static final File FIGHT_HISTORY_DATA_DIR;
	public static PvpPerformanceTrackerConfig CONFIG;
	public static PvpPerformanceTrackerPlugin PLUGIN;
	public static Image PLUGIN_ICON;
	public static AsyncBufferedImage DEFAULT_NONE_SYMBOL; // save bank filler image to display a generic "None" or N/A state.
	public static Gson GSON;

	// Last man standing map regions, including ferox enclave
	private static final Set<Integer> LAST_MAN_STANDING_REGIONS = ImmutableSet.of(12344, 12600, 13658, 13659, 13660, 13914, 13915, 13916, 13918, 13919, 13920, 14174, 14175, 14176, 14430, 14431, 14432);

	static
	{
		FIGHT_HISTORY_DATA_DIR = new File(RuneLite.RUNELITE_DIR, DATA_FOLDER);
		FIGHT_HISTORY_DATA_DIR.mkdirs();
	}

	// "native"/core RL fields/injected fields
	@Getter(AccessLevel.PACKAGE)
	private NavigationButton navButton;
	private boolean navButtonShown = false;

	@Getter(AccessLevel.PACKAGE)
	private PvpPerformanceTrackerPanel panel;

	@Inject
	private PvpPerformanceTrackerConfig config;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Getter
	@Inject
	private Client client;

	@Getter
	@Inject
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ConfigManager configManager;

	@Getter
	@Inject
	private RuneLiteConfig runeliteConfig;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PvpPerformanceTrackerOverlay overlay;

	@Getter
	@Inject
	private ItemManager itemManager;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private Gson injectedGson;

	// custom fields/props
	public ArrayList<FightPerformance> fightHistory;
	@Getter
	private FightPerformance currentFight;
	private Map<Integer, ImageIcon> spriteCache; // sprite cache since a small amount of sprites is re-used a lot
	// do not cache items in the same way since we could potentially cache a very large amount of them.

	// #################################################################################################################
	// ##################################### Core RL plugin functions & RL Events ######################################
	// #################################################################################################################

	@Provides
	PvpPerformanceTrackerConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PvpPerformanceTrackerConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		CONFIG = config; // save static instances of config/plugin to easily use in
		PLUGIN = this;   // other contexts without passing them all the way down or injecting
		fightHistory = new ArrayList<>();

		GSON = injectedGson.newBuilder()
			.excludeFieldsWithoutExposeAnnotation()
			.registerTypeAdapter(Double.class, (JsonSerializer<Double>) (value, theType, context) ->
				value.isNaN() ? new JsonPrimitive(0) // Convert NaN to zero, otherwise, return as BigDecimal with scale of 3.
					: new JsonPrimitive(BigDecimal.valueOf(value).setScale(3, RoundingMode.HALF_UP))
			).create();

		if (!config.pluginVersion().equals(PLUGIN_VERSION))
		{
			this.update(config.pluginVersion());
		}

		panel = injector.getInstance(PvpPerformanceTrackerPanel.class);
		final BufferedImage icon = ImageUtil.getResourceStreamFromClass(getClass(), "/skull_red.png");
		PLUGIN_ICON = new ImageIcon(icon).getImage();
		navButton = NavigationButton.builder()
			.tooltip("PvP Fight History")
			.icon(icon)
			.priority(6)
			.panel(panel)
			.build();

		importFightHistoryData();

		// add the panel's nav button depending on config
		if (config.showFightHistoryPanel() &&
			(!config.restrictToLms() || (client.getGameState() == GameState.LOGGED_IN && isAtLMS())))
		{
			navButtonShown = true;
			clientToolbar.addNavigation(navButton);
		}

		overlayManager.add(overlay);

		spriteCache = new HashMap<>(); // prepare sprite cache

		// prepare default N/A or None symbol for eventual use.
		clientThread.invokeLater(() -> DEFAULT_NONE_SYMBOL = itemManager.getImage(20594));
	}

	@Override
	protected void shutDown() throws Exception
	{
		saveFightHistoryData();

		clientToolbar.removeNavigation(navButton);
		overlayManager.remove(overlay);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(CONFIG_KEY)) { return; }

		switch(event.getKey())
		{
			// if a user enables the panel or restricts/unrestricts the location to LMS, hide/show the panel accordingly
			case "showFightHistoryPanel":
			case "restrictToLms":
				boolean isAtLms = isAtLMS();
				if (!navButtonShown && config.showFightHistoryPanel() &&
					(!config.restrictToLms() || isAtLms))
				{
					SwingUtilities.invokeLater(() -> clientToolbar.addNavigation(navButton));
					navButtonShown = true;
				}
				else if (navButtonShown && (!config.showFightHistoryPanel() || (config.restrictToLms() && !isAtLms)))
				{
					SwingUtilities.invokeLater(() -> clientToolbar.removeNavigation(navButton));
					navButtonShown = false;
				}
				break;
			// If a user makes any changes to the overlay configuration, reset the shown lines accordingly
			case "showOverlayTitle":
			case "showOverlayNames":
			case "showOverlayOffPray":
			case "showOverlayDeservedDmg":
			case "showOverlayDmgDealt":
			case "showOverlayMagicHits":
			case "showOverlayOffensivePray":
			case "showOverlayHpHealed":
			case "showOverlayGhostBarrage":
				overlay.setLines();
				break;
			// If the user updates the fight history limit, remove fights as necessary
			case "fightHistoryLimit":
			case "fightHistoryRenderLimit":
				if (config.fightHistoryLimit() > 0 && fightHistory.size() > config.fightHistoryLimit())
				{
					int numToRemove = fightHistory.size() - config.fightHistoryLimit();
					// Remove oldest fightHistory until the size is smaller than the limit.
					// Should only remove one fight in most cases.
					fightHistory.removeIf((FightPerformance f) -> fightHistory.indexOf(f) < numToRemove);
				}
				panel.rebuild();
				break;
			case "exactNameFilter":
				panel.rebuild();
				break;
			case "settingsConfigured":
				boolean enableConfigWarning = !config.settingsConfigured();
				panel.setConfigWarning(enableConfigWarning);
				break;
				// potential future code for level presets/dynamic config if RL ever supports it.
//			case "attackLevel":
//			case "strengthLevel":
//			case "defenceLevel":
//			case "rangedLevel":
//			case "magicLevel":
//				log.info("TEST-just set a level");
//				configManager.setConfiguration(CONFIG_KEY, "levelPresetChoice", LevelConfigPreset.CUSTOM);
//				break;
//			case "levelPresetChoice":
//				log.info("TEST- just chose level preset choice");
//				LevelConfigPreset p = config.levelPresetChoice();
//				switch (p)
//				{
//					case CUSTOM:
//						break;
//					case LMS_STATS:
//					case NH_STAKE:
//						configManager.setConfiguration(CONFIG_KEY, "attackLevel", p.getAtk());
//						configManager.setConfiguration(CONFIG_KEY, "strengthLevel", p.getStr());
//						configManager.setConfiguration(CONFIG_KEY, "defenceLevel", p.getDef());
//						configManager.setConfiguration(CONFIG_KEY, "rangedLevel", p.getRange());
//						configManager.setConfiguration(CONFIG_KEY, "magicLevel", p.getMage());
//						break;
//
//				}
//				break;
		}
	}

	// Keep track of a player's new target using this event.
	// It's worth noting that if you aren't in a fight, all player interactions including
	// trading & following will trigger a new fight and a new opponent. Due to this, set the lastFightTime
	// (in FightPerformance) in the past to only be 5 seconds before the time NEW_FIGHT_DELAY would trigger
	// and unset the opponent, in case the player follows a different player before actually starting
	// a fight or getting attacked. In other words, remain skeptical of the validity of this event.
	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		if (config.restrictToLms() && !isAtLMS())
		{
			return;
		}

		stopFightIfOver();

		// if the client player already has a valid opponent,
		// or the event source/target aren't players, skip any processing.
		if ((hasOpponent() && currentFight.fightStarted())
			|| !(event.getSource() instanceof Player)
			|| !(event.getTarget() instanceof Player))
		{
			return;
		}

		Actor opponent;

		// If the event source is the player, then it is the player interacting with their potential opponent.
		if (event.getSource().equals(client.getLocalPlayer()))
		{
			opponent = event.getTarget();
		}
		else if (event.getTarget().equals(client.getLocalPlayer()))
		{
			opponent = event.getSource();
		}
		else // if neither source or target was the player, skip
		{
			return;
		}

		// start a new fight with the new found opponent, if a new one.
		if (!hasOpponent() || !currentFight.getOpponent().getName().equals(opponent.getName()))
		{
			currentFight = new FightPerformance(client.getLocalPlayer(), (Player)opponent);
			overlay.setFight(currentFight);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		// hide or show panel depending if config is restricted to LMS and if player is at LMS
		if (config.restrictToLms())
		{
			if (isAtLMS())
			{
				if (!navButtonShown && config.showFightHistoryPanel())
				{
					clientToolbar.addNavigation(navButton);
					navButtonShown = true;
				}
			}
			else
			{
				if (navButtonShown)
				{
					clientToolbar.removeNavigation(navButton);
					navButtonShown = false;
				}
			}
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		stopFightIfOver();

		// delay the animation processing, since we will also want to use equipment data for deserved
		// damage, and equipment updates are loaded after the animation updates.
		clientThread.invokeLater(() ->
		{
			if (hasOpponent() && event.getActor() instanceof Player && event.getActor().getName() != null)
			{
				currentFight.checkForAttackAnimations((Player)event.getActor(), new CombatLevels(client));
			}
		});
	}

	@Subscribe
	// track damage dealt/taken
	public void onHitsplatApplied(HitsplatApplied event)
	{
		int hitType = event.getHitsplat().getHitsplatType();

		// if there's no opponent, the target is not a player, or the hitsplat is not relevant to pvp damage,
		// skip the hitsplat. Otherwise, add it to the fight, which will only include it if it is one of the
		// Fighters in the fight being hit.
		if (!hasOpponent() || !(event.getActor() instanceof Player) ||
			!(hitType == HitsplatID.DAMAGE_ME || hitType == HitsplatID.DAMAGE_ME_ORANGE || hitType == HitsplatID.DAMAGE_OTHER_ORANGE || hitType == HitsplatID.DAMAGE_OTHER || hitType == HitsplatID.DAMAGE_MAX_ME || hitType == HitsplatID.DAMAGE_MAX_ME_ORANGE ||
				hitType == HitsplatID.POISON || hitType == HitsplatID.VENOM))
		{
			return;
		}

		currentFight.addDamageDealt(event.getActor().getName(), event.getHitsplat().getAmount());
	}

	@Subscribe
	// track hitpoints healed & ghost barrages for main competitor/client player
	public void onStatChanged(StatChanged statChanged)
	{
		Skill skill = statChanged.getSkill();
		if (!hasOpponent()) { return; }

		if (skill == Skill.HITPOINTS)
		{
			currentFight.updateCompetitorHp(client.getBoostedSkillLevel(Skill.HITPOINTS));
		}

		if (skill == Skill.MAGIC)
		{
			int magicXp = client.getSkillExperience(Skill.MAGIC);
			if (magicXp > currentFight.competitor.getLastGhostBarrageCheckedMageXp())
			{
				currentFight.competitor.setLastGhostBarrageCheckedMageXp(PLUGIN.getClient().getSkillExperience(Skill.MAGIC));
				clientThread.invokeLater(this::checkForGhostBarrage);
			}
		}
	}

	@Subscribe
	// track ghost barrages for main competitor/client player
	public void onFakeXpDrop(FakeXpDrop fakeXpDrop)
	{
		if (!hasOpponent() || fakeXpDrop.getSkill() != Skill.MAGIC) { return; }

		clientThread.invokeLater(this::checkForGhostBarrage);
	}

	// if the player gained magic xp but doesn't have a magic-attack animation, consider it as a ghost barrage.
	// however this won't be added as a normal attack, it is for an extra ghost-barrage statistic as
	// we can only detect this for the local player
	private void checkForGhostBarrage()
	{
		if (!hasOpponent()) { return; }

		currentFight.checkForLocalGhostBarrage(new CombatLevels(client), client.getLocalPlayer());
	}

	// When the config is reset, also reset the fight history data, as a way to restart
	// if the current data is causing problems.
	@Override
	public void resetConfiguration()
	{
		super.resetConfiguration();
		resetFightHistory();
	}

	// when the client shuts down, save the fight history data locally.
	@Subscribe
	public void onClientShutdown(ClientShutdown event)
	{
		event.waitFor(executor.submit(this::saveFightHistoryData));
	}

	// #################################################################################################################
	// ################################## Plugin-specific functions & global helpers ###################################
	// #################################################################################################################

	private void update(String oldVersion)
	{
		switch (oldVersion)
		{
			case "1.4.0":
			case "1.4.1":
			case "1.4.2":
			case "1.4.3":
			case "1.4.4":
			case "1.4.5":
			case "1.4.6":
			case "1.4.7":
			case "1.4.8":
			case "1.5.0":
			case "1.5.1":
			case "1.5.2":
			case "1.5.3":
			case "1.5.4":
			case "1.5.5":
				updateFrom1_5_5to1_5_6();
				break;
		}

		configManager.setConfiguration(CONFIG_KEY, "pluginVersion", PLUGIN_VERSION);
	}

	private void updateFrom1_5_5to1_5_6()
	{
		try
		{
			log.info("Updating data from 1.5.5 (or earlier) to 1.5.6...");

			FIGHT_HISTORY_DATA_DIR.mkdirs();
			File fightHistoryData = new File(FIGHT_HISTORY_DATA_DIR, FIGHT_HISTORY_DATA_FNAME);

			// if the fight history data file doesn't exist, create it with an empty array.
			if (!fightHistoryData.exists())
			{
				Writer writer = new FileWriter(fightHistoryData);
				writer.write("[]");
				writer.close();
				return;
			}

			fightHistory.clear();

			// read the old saved fights from the file into an array, and add them as an updated
			// fight to the fightHistory list.
			Arrays.asList(GSON.fromJson(new FileReader(fightHistoryData), FightPerformance__1_5_5[].class))
				.forEach((oldFight) -> fightHistory.add(new FightPerformance(oldFight)));

			// now that the fights were deserialized and updated to the newest version, simply save them.
			// afterwards, they will be re-loaded normally. Bit inefficient but not a big deal
			saveFightHistoryData();
			log.info("Successfully updated from 1.5.5 to 1.5.6");
		}
		catch (Exception e)
		{
			log.warn("Error while updating fight history data from 1.5.5 to 1.5.6: " + e.getMessage());
			// Display no modal for this error since it could happen on client load and that has odd behavior.
		}
	}
	// Returns true if the player has an opponent.
	private boolean hasOpponent()
	{
		return currentFight != null;
	}

	private void stopFightIfOver()
	{
		if (hasOpponent() && currentFight.isFightOver())
		{
			// add fight to fight history if it actually started
			if (currentFight.fightStarted())
			{
				addToFightHistory(currentFight);
			}
			currentFight = null;
		}
	}

	// save the currently loaded fightHistory to the local json data so it is saved for the next client launch.
	private void saveFightHistoryData()
	{
		// silently ignore errors, which shouldn't really happen - but if they do, don't prevent the plugin
		// from continuing to work, even if there are issues saving the data.
		try
		{
			File fightHistoryData = new File(FIGHT_HISTORY_DATA_DIR, FIGHT_HISTORY_DATA_FNAME);
			Writer writer = new FileWriter(fightHistoryData);
			GSON.toJson(fightHistory, writer);
			writer.flush();
			writer.close();
		}
		catch (Exception e)
		{
			log.warn("Error ignored while updating fight history data: " + e.getMessage());
		}
	}

	// add fight to loaded fight history
	void addToFightHistory(FightPerformance fight)
	{
		if (fight == null) { return; }
		fightHistory.add(fight);
		// no need to sort, since they sort chronologically, but they should automatically be added that way.

		// remove fights as necessary to respect the fightHistoryLimit.
		if (config.fightHistoryLimit() > 0 && fightHistory.size() > config.fightHistoryLimit())
		{
			int numToRemove = fightHistory.size() - config.fightHistoryLimit();
			// Remove oldest fightHistory until the size is equal to the limit.
			// Should only remove one fight in most cases.
			fightHistory.removeIf((FightPerformance f) -> fightHistory.indexOf(f) < numToRemove);
			panel.rebuild();
		}
		else
		{
			panel.addFight(fight);
		}
	}

	// import complete fight history data from the saved json data file
	// this function only handles the direct file processing and json deserialization.
	// more specific FightPerformance processing is done in importFights()
	void importFightHistoryData()
	{
		// catch and ignore any errors we may have forgotten to handle - the import will fail but at least the plugin
		// will continue to function. This should only happen if their fight history data is corrupted/outdated.
		// The user will be notified by a modal if this happens.
		try
		{
			FIGHT_HISTORY_DATA_DIR.mkdirs();
			File fightHistoryData = new File(FIGHT_HISTORY_DATA_DIR, FIGHT_HISTORY_DATA_FNAME);

			// if the fight history data file doesn't exist, create it with an empty array.
			if (!fightHistoryData.exists())
			{
				Writer writer = new FileWriter(fightHistoryData);
				writer.write("[]");
				writer.close();
			}

			// read the saved fights from the file
			List<FightPerformance> savedFights = Arrays.asList(
				GSON.fromJson(new FileReader(fightHistoryData), FightPerformance[].class));

			fightHistory.clear();
			importFights(savedFights);
		}
		catch (Exception e)
		{
			log.warn("Error while deserializing fight history data: " + e.getMessage());
			// Display no modal for this error since it could happen on client load and that has odd behavior.
			return;
		}

		panel.rebuild();
	}

	// import additional/extra fight history data supplied by the user
	// this only does the direct json deserialization and success response (modals)
	// more specific FightPerformance processing is done in importFights()
	public void importUserFightHistoryData(String data)
	{
		try
		{
			// read saved fights from the data string and import them
			List<FightPerformance> savedFights = Arrays.asList(GSON.fromJson(data, FightPerformance[].class));
			importFights(savedFights);
			createConfirmationModal(true, "Fight history data was successfully imported.");
		}
		catch (Exception e)
		{
			log.warn("Error while importing user's fight history data: " + e.getMessage());
			// If an error was detected while deserializing fights, display that as a message dialog.
			createConfirmationModal(false, "Fight history data was invalid, and could not be imported.");
			return;
		}

		panel.rebuild();
	}

	// set fight log names after importing since they aren't serialized but are on the parent class
	public void initializeImportedFight(FightPerformance f)
	{
		// check for nulls in case the data was corrupted and entries are corrupted.
		if (f.getCompetitor() == null || f.getOpponent() == null ||
			f.getCompetitor().getFightLogEntries() == null || f.getOpponent().getFightLogEntries() == null)
		{
			return;
		}

		f.getCompetitor().getFightLogEntries().forEach((FightLogEntry l) ->
			l.attackerName = f.getCompetitor().getName());
		f.getOpponent().getFightLogEntries().forEach((FightLogEntry l) ->
			l.attackerName = f.getOpponent().getName());
	}

	// process and add a list of deserialized json fights to the currently loaded fights
	// can throw NullPointerException if some of the serialized data is corrupted
	void importFights(List<FightPerformance> fights) throws NullPointerException
	{
		if (fights == null || fights.size() < 1) { return; }

		fights.removeIf(Objects::isNull);
		fightHistory.addAll(fights);
		fightHistory.sort(FightPerformance::compareTo);

		// remove fights to respect the fightHistoryLimit.
		if (config.fightHistoryLimit() > 0 && fightHistory.size() > config.fightHistoryLimit())
		{
			int numToRemove = fightHistory.size() - config.fightHistoryLimit();
			// Remove oldest fightHistory until the size is equal to the limit.
			// Should only remove one fight in most cases.
			fightHistory.removeIf((FightPerformance f) -> fightHistory.indexOf(f) < numToRemove);
		}

		// set fight log names since they aren't serialized but are on the parent class
		for (FightPerformance f : fightHistory)
		{
			initializeImportedFight(f);
		}
	}

	// reset the loaded fight history as well as the saved json data
	public void resetFightHistory()
	{
		fightHistory.clear();
		saveFightHistoryData();
		panel.rebuild();
	}

	// remove a fight from the loaded fight history
	public void removeFight(FightPerformance fight)
	{
		fightHistory.remove(fight);
		panel.rebuild();
	}

	public boolean isAtLMS()
	{
		final int[] mapRegions = client.getMapRegions();

		for (int region : LAST_MAN_STANDING_REGIONS)
		{
			if (ArrayUtils.contains(mapRegions, region))
			{
				return true;
			}
		}

		return false;
	}

	// Send a message to the chat. Send them messages to the trade chat since it is uncommonly
	// used while fighting, but game, public, private, and clan chat all have their uses.
	public void sendChatMessage(String chatMessage)
	{
		chatMessageManager
			.queue(QueuedMessage.builder()
				.type(ChatMessageType.TRADE)
				.runeLiteFormattedMessage(chatMessage)
				.build());
	}

	// create a simple confirmation modal, using a custom dialog so it can be always
	// on top (if the client is, to prevent being stuck under the client).
	public void createConfirmationModal(boolean success, String message)
	{
		SwingUtilities.invokeLater(() ->
		{
			JOptionPane optionPane = new JOptionPane();
			optionPane.setMessage(message);
			optionPane.setOptionType(JOptionPane.DEFAULT_OPTION);
			JDialog dialog = optionPane.createDialog(panel, "PvP Tracker: " + (success ? "Success" : "Error"));
			if (dialog.isAlwaysOnTopSupported())
			{
				dialog.setAlwaysOnTop(runeliteConfig.gameAlwaysOnTop());
			}
			dialog.setIconImage(PLUGIN_ICON);
			dialog.setVisible(true);
		});
	}

	// save the complete fight history data to the clipboard.
	public void exportFightHistory()
	{
		String fightHistoryDataJson = GSON.toJson(fightHistory.toArray(new FightPerformance[0]), FightPerformance[].class);
		final StringSelection contents = new StringSelection(fightHistoryDataJson);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);

		createConfirmationModal(true, "Fight history data was copied to the clipboard.");
	}

	public void exportFight(FightPerformance fight)
	{
		if (fight == null) { return; }
		String fightDataJson = GSON.toJson(fight, FightPerformance.class);
		final StringSelection contents = new StringSelection(fightDataJson);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);

		boolean success = false;
		String confirmMessage;
		if (fight.getCompetitor() != null && fight.getCompetitor().getName() != null &&
			fight.getOpponent() != null && fight.getOpponent().getName() != null)
		{
			success = true;
			confirmMessage = "Fight data of " + fight.getCompetitor().getName() + " vs " +
				fight.getOpponent().getName() + " was copied to the clipboard.";
		}
		else
		{
			confirmMessage = "Warning: Fight data was copied to the clipboard, but it's likely corrupted.";
		}
		createConfirmationModal(success, confirmMessage);
	}

	public void copyFightAsDiscordMsg(FightPerformance fight)
	{
		if (fight == null) { return; }

		String fightMsg = fight.getAsDiscordMessage();

		final StringSelection contents = new StringSelection(fightMsg);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);

		createConfirmationModal(true, "Discord message of fight data was copied to the clipboard.");
	}

	// retrieve offensive pray as SpriteID since that's all we will directly use it for,
	// aside from comparison/equality checks, so we save an extra mapping this way
	public int currentlyUsedOffensivePray()
	{
		return client.isPrayerActive(Prayer.PIETY) 				? SpriteID.PRAYER_PIETY :
				client.isPrayerActive(Prayer.ULTIMATE_STRENGTH) ? SpriteID.PRAYER_ULTIMATE_STRENGTH :
				client.isPrayerActive(Prayer.RIGOUR) 			? SpriteID.PRAYER_RIGOUR :
				client.isPrayerActive(Prayer.EAGLE_EYE) 		? SpriteID.PRAYER_EAGLE_EYE :
				client.isPrayerActive(Prayer.AUGURY) 			? SpriteID.PRAYER_AUGURY :
				client.isPrayerActive(Prayer.MYSTIC_MIGHT)		? SpriteID.PRAYER_MYSTIC_MIGHT :
				0;
	}

	// returns SpriteID for a given HeadIcon. returns -1 if not found
	public int getSpriteForHeadIcon(HeadIcon icon)
	{
		if (icon == null) { return -1; }
		switch (icon)
		{
			case MELEE: return SpriteID.PRAYER_PROTECT_FROM_MELEE;
			case RANGED: return SpriteID.PRAYER_PROTECT_FROM_MISSILES;
			case MAGIC: return SpriteID.PRAYER_PROTECT_FROM_MAGIC;
			case SMITE: return SpriteID.PRAYER_SMITE;
			case RETRIBUTION: return SpriteID.PRAYER_RETRIBUTION;
			case REDEMPTION: return SpriteID.PRAYER_REDEMPTION;
			default: return -1;
		}
	}

	public int getSpriteForSkill(Skill skill)
	{
		switch (skill)
		{
			case ATTACK: return SpriteID.SKILL_ATTACK;
			case STRENGTH: return SpriteID.SKILL_STRENGTH;
			case DEFENCE: return SpriteID.SKILL_DEFENCE;
			case RANGED: return SpriteID.SKILL_RANGED;
			case MAGIC: return SpriteID.SKILL_MAGIC;
			case HITPOINTS: return SpriteID.SKILL_HITPOINTS;
			default: return -1;
		}
	}

	public void addSpriteToLabelIfValid(JLabel label, int spriteId, Runnable swingCallback)
	{
		// Invalid sprite: set icon to bank filler and tooltip to N/A
		if (spriteId <= 0)
		{
			DEFAULT_NONE_SYMBOL.addTo(label);
			label.setToolTipText("N/A");

			if (swingCallback != null)
			{
				SwingUtilities.invokeLater(swingCallback);
			}
			return;
		}

		// if sprite id found in sprite cache: use it.
		if (spriteCache.containsKey(spriteId))
		{
			label.setIcon(spriteCache.get(spriteId));
			if (swingCallback != null)
			{
				SwingUtilities.invokeLater(swingCallback);
			}
			return;
		}

		// if sprite id wasn't in sprite cache: get it, use it and add it to the cache
		clientThread.invokeLater(() ->
		{
			BufferedImage sprite = spriteManager.getSprite(spriteId, 0);
			if (sprite != null)
			{
				ImageIcon icon = new ImageIcon(sprite);
				spriteCache.put(spriteId, icon);
				label.setIcon(icon);
			}
			else
			{
				DEFAULT_NONE_SYMBOL.addTo(label);
				label.setToolTipText("N/A");
			}

			if (swingCallback != null)
			{
				SwingUtilities.invokeLater(swingCallback);
			}
		});
	}

	public void addSpriteToLabelIfValid(JLabel label, int spriteId)
	{
		addSpriteToLabelIfValid(label, spriteId, null);
	}

	// if verifyId is true, takes in itemId directly from PlayerComposition
	// otherwise, assume valid itemId
	public void addItemToLabelIfValid(JLabel label, int itemId, boolean verifyId, Runnable swingCallback, String tooltipOverride)
	{
		if (itemId > PlayerComposition.ITEM_OFFSET || !verifyId)
		{
			final int finalItemId = itemId - (verifyId ? PlayerComposition.ITEM_OFFSET : 0);
			clientThread.invokeLater(() -> {
				itemManager.getImage(finalItemId).addTo(label);
				if (tooltipOverride != null && tooltipOverride.length() > 0)
				{
					label.setToolTipText(tooltipOverride);
				}
				else
				{
					String name = itemManager.getItemComposition(finalItemId).getName();
					label.setToolTipText(name != null ? name : "Item Name Not Found");
				}

				if (swingCallback != null)
				{
					SwingUtilities.invokeLater(swingCallback);
				}
			});
		}
		else
		{
			DEFAULT_NONE_SYMBOL.addTo(label);
			label.setToolTipText("N/A: empty slot or invalid item");
			if (swingCallback != null)
			{
				SwingUtilities.invokeLater(swingCallback);
			}
		}
	}

	public void addItemToLabelIfValid(JLabel label, RangeAmmoData data, boolean verifyId, Runnable swingCallback)
	{
		addItemToLabelIfValid(label, data.getItemId(), verifyId, swingCallback, data.toString());
	}

	public void addItemToLabelIfValid(JLabel label, int itemId, boolean verifyId, Runnable swingCallback)
	{
		addItemToLabelIfValid(label, itemId, verifyId, swingCallback, null);
	}

	public void addItemToLabelIfValid(JLabel label, int itemId)
	{
		addItemToLabelIfValid(label, itemId, true, null);
	}

	// fix an itemId that came from getPlayerComposition().getEquipmentIds()
	public static int fixItemId(int itemId)
	{
		return itemId > PlayerComposition.ITEM_OFFSET ? itemId - PlayerComposition.ITEM_OFFSET : itemId;
	}

	// create new array so we don't modify original array
	public static int[] fixItemIds(int[] itemIds)
	{
		if (itemIds == null || itemIds.length < 1)
		{
			return new int[] { 0 };
		}
		int[] fixedItemIds = new int[itemIds.length];
		for (int i = 0; i < itemIds.length; i++)
		{
			fixedItemIds[i] = fixItemId(itemIds[i]);
		}

		return fixedItemIds;
	}

	public void updateNameFilterConfig(String newFilterName)
	{
		configManager.setConfiguration(CONFIG_KEY, "nameFilter", newFilterName.trim().toLowerCase());
	}
}

/*
 * Copyright (c)  2021, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.controllers;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.util.ArrayList;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.fixItemId;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.EquipmentData;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import net.runelite.api.GraphicID;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.kit.KitType;

@Slf4j
@Getter
public
class Fighter
{
	private static final NumberFormat nf = NumberFormat.getInstance();
	static // initialize number format
	{
		nf.setMaximumFractionDigits(1);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}

	@Setter
	private Player player;
	@Expose
	@SerializedName("n") // use 1 letter serialized variable names for more compact storage
	private String name; // username
	@Expose
	@SerializedName("a")
	private int attackCount; // total number of attacks
	@Expose
	@SerializedName("s")
	private int offPraySuccessCount; // total number of successful off-pray attacks
									 // (when you use a different combat style than your opponent's overhead)
	@Expose
	@SerializedName("d")
	private double deservedDamage; // total deserved damage based on gear & opponent's pray
	@Expose
	@SerializedName("h") // h for "hitsplats", real hits
	private int damageDealt; // actual damage dealt based on opponent's hitsplats

	@Expose
	@SerializedName("z") // z because idk and want to keep 1 character for most compact storage
	private int totalMagicAttackCount; // total count of magic attacks
	@Expose
	@SerializedName("m")
	private int magicHitCount; // count of 'successful' magic hits (where you don't splash)
	@Expose
	@SerializedName("M")
	private double magicHitCountDeserved; // cumulative magic accuracy percentage for each attack

	@Expose
	@SerializedName("p")
	private int offensivePraySuccessCount;

	@Expose
	@SerializedName("g")
	private int ghostBarrageCount;
	@Expose
	@SerializedName("y")
	private double ghostBarrageDeservedDamage;

	@Expose
	@SerializedName("H")
	private int hpHealed;

	@Expose
	@SerializedName("x") // x for X_X
	private boolean dead; // will be true if the fighter died in the fight

	@Expose
	@SerializedName("l")
	private ArrayList<FightLogEntry> fightLogEntries;

	private PvpDamageCalc pvpDamageCalc;
	private int lastGhostBarrageCheckedTick = -1;
	@Setter
	private int lastGhostBarrageCheckedMageXp = -1;

	// fighter that is bound to a player and gets updated during a fight
	Fighter(FightPerformance fight, Player player)
	{
		this.player = player;
		name = player.getName();
		attackCount = 0;
		offPraySuccessCount = 0;
		deservedDamage = 0;
		damageDealt = 0;
		totalMagicAttackCount = 0;
		magicHitCount = 0;
		magicHitCountDeserved = 0;
		offensivePraySuccessCount = 0;
		dead = false;
		pvpDamageCalc = new PvpDamageCalc(fight);
		fightLogEntries = new ArrayList<>();
	}

	// fighter for merging fight logs together for detailed data (fight analysis)
	Fighter(FightPerformance fight, String name, ArrayList<FightLogEntry> logs)
	{
		player = null;
		this.name = name;
		attackCount = 0;
		offPraySuccessCount = 0;
		deservedDamage = 0;
		damageDealt = 0;
		totalMagicAttackCount = 0;
		magicHitCount = 0;
		magicHitCountDeserved = 0;
		dead = false;
		pvpDamageCalc = new PvpDamageCalc(fight);
		fightLogEntries = logs;
	}

	// create a basic Fighter to only hold stats, for the TotalStatsPanel,
	// but not actually updated during a fight.
	public Fighter(String name)
	{
		player = null;
		this.name = name;
		attackCount = 0;
		offPraySuccessCount = 0;
		deservedDamage = 0;
		damageDealt = 0;
		totalMagicAttackCount = 0;
		magicHitCount = 0;
		magicHitCountDeserved = 0;
		dead = false;
		pvpDamageCalc = null;
		fightLogEntries = new ArrayList<>();
	}

	// Fighter for AnalyzedFightPerformance
	public Fighter(FightPerformance fight, String name)
	{
		this(name);
		pvpDamageCalc = new PvpDamageCalc(fight);
	}

	// add an attack to the counters depending if it is successful or not.
	// also update the success rate with the new counts.
	// Used for regular, ongoing fights
	void addAttack(Player opponent, AnimationData animationData, int offensivePray)
	{
		addAttack(opponent, animationData, offensivePray, null);
	}

	// Levels can be null
	void addAttack(Player opponent, AnimationData animationData, int offensivePray, CombatLevels levels)
	{
		int[] attackerItems = player.getPlayerComposition().getEquipmentIds();

		// correct re-used animations into their separate AnimationData so it uses the correct attack style
		// for overhead success & accuracy calcs
		EquipmentData weapon = EquipmentData.fromId(fixItemId(attackerItems[KitType.WEAPON.getIndex()]));

		boolean successful = opponent.getOverheadIcon() != animationData.attackStyle.getProtection();

		attackCount++;
		if (successful)
		{
			offPraySuccessCount++;
		}
		if (animationData.attackStyle.isUsingSuccessfulOffensivePray(offensivePray))
		{
			offensivePraySuccessCount++;
		}

		// track dragon longsword as VLS if enabled, for dmm practice purposes.
		// also check if weapon = VLS because the itemId stays as VLS if they don't switch weapons between
		// attacks, but we still need to update the animationData in case it's actually a dlong.
		if (CONFIG.dlongIsVls() && weapon == EquipmentData.DRAGON_LONGSWORD || weapon == EquipmentData.VESTAS_LONGSWORD)
		{
			// modifying attackerItems will modify the actual playerComposition, so future
			// .getPlayerComposition().getEquipmentIds() calls will also be modified
			attackerItems[KitType.WEAPON.getIndex()] = EquipmentData.VESTAS_LONGSWORD.getItemId() + PlayerComposition.ITEM_OFFSET;
			animationData = animationData.isSpecial ? AnimationData.MELEE_VLS_SPEC : AnimationData.MELEE_SCIM_SLASH;
		}

		pvpDamageCalc.updateDamageStats(player, opponent, successful, animationData);
		deservedDamage += pvpDamageCalc.getAverageHit();

		if (animationData.attackStyle == AnimationData.AttackStyle.MAGIC)
		{
			totalMagicAttackCount++;
			magicHitCountDeserved += pvpDamageCalc.getAccuracy();

			if (opponent.getGraphic() != GraphicID.SPLASH)
			{
				magicHitCount++;
			}
		}

		FightLogEntry fightLogEntry = new FightLogEntry(player, opponent, pvpDamageCalc, offensivePray, levels, animationData);
		if (PvpPerformanceTrackerPlugin.CONFIG.fightLogInChat())
		{
			PvpPerformanceTrackerPlugin.PLUGIN.sendChatMessage(fightLogEntry.toChatMessage());
		}
		fightLogEntries.add(fightLogEntry);
	}

	// add an attack from fight log, without player references, for merging fight logs (fight analysis)
	void addAttack(FightLogEntry logEntry, FightLogEntry defenderLog)
	{
		attackCount++;
		if (logEntry.success())
		{
			offPraySuccessCount++;
		}
		if (logEntry.getAnimationData().attackStyle.isUsingSuccessfulOffensivePray(logEntry.getAttackerOffensivePray()))
		{
			offensivePraySuccessCount++;
		}

		pvpDamageCalc.updateDamageStats(logEntry, defenderLog);
		deservedDamage += pvpDamageCalc.getAverageHit();

		if (logEntry.getAnimationData().attackStyle == AnimationData.AttackStyle.MAGIC)
		{
			totalMagicAttackCount++;
			magicHitCountDeserved += pvpDamageCalc.getAccuracy();
			// actual magicHitCount is directly added, as it can no longer
			// be detected and should have been accurate initially.
		}

		fightLogEntries.add(new FightLogEntry(logEntry, pvpDamageCalc));
	}

	public void addGhostBarrage(boolean successful, Player opponent, AnimationData animationData, int offensivePray, CombatLevels levels)
	{
		int currentTick = PLUGIN.getClient().getTickCount();
		if (currentTick <= lastGhostBarrageCheckedTick)
		{
			return;
		}
		lastGhostBarrageCheckedTick = currentTick;

		pvpDamageCalc.updateDamageStats(player, opponent, successful, animationData);

		ghostBarrageCount++;
		ghostBarrageDeservedDamage += pvpDamageCalc.getAverageHit();

		// TODO: Create separate FightLog array for ghost barrages and include those in fight log table
		// ^^^ also so they could be used in fight analysis/merge. Unused params will be used for this
	}

	// used to manually build Fighters in AnalyzedFightPerformance.
	public void setTotalGhostBarrageStats(int ghostBarrageCount, double ghostBarrageDeservedDamage)
	{
		this.ghostBarrageCount = ghostBarrageCount;
		this.ghostBarrageDeservedDamage = ghostBarrageDeservedDamage;
	}

	// this is to be used from the TotalStatsPanel which saves a total of multiple fights.
	public void addAttacks(int success, int total, double deservedDamage, int damageDealt, int totalMagicAttackCount, int magicHitCount, double magicHitCountDeserved, int offensivePraySuccessCount, int hpHealed, int ghostBarrageCount, double ghostBarrageDeservedDamage)
	{
		offPraySuccessCount += success;
		attackCount += total;
		this.deservedDamage += deservedDamage;
		this.damageDealt += damageDealt;
		this.totalMagicAttackCount += totalMagicAttackCount;
		this.magicHitCount += magicHitCount;
		this.magicHitCountDeserved += magicHitCountDeserved;
		this.offensivePraySuccessCount += offensivePraySuccessCount;
		this.hpHealed += hpHealed;
		this.ghostBarrageCount += ghostBarrageCount;
		this.ghostBarrageDeservedDamage += ghostBarrageDeservedDamage;
	}

	void addDamageDealt(int damage)
	{
		this.damageDealt += damage;
	}

	// will be used for merging fight logs (fight analysis)
	void addMagicHitCount(int count)
	{
		this.magicHitCount += count;
	}

	void addHpHealed(int hpHealed)
	{
		this.hpHealed += hpHealed;
	}

	void died()
	{
		dead = true;
	}

	AnimationData getAnimationData()
	{
		return AnimationData.fromId(player.getAnimation());
	}

	// the "addAttack" for a defensive log that creates an "incomplete" fight log entry.
	void addDefensiveLogs(CombatLevels levels, int offensivePray)
	{
		fightLogEntries.add(new FightLogEntry(name, levels, offensivePray));
	}

	// Return a simple string to display the current player's success rate.
	// ex. "42/59 (71%)". The name is not included as it will be in a separate view.
	// if shortString is true, the percentage is omitted, it only returns the fraction.
	public String getOffPrayStats(boolean shortString)
	{
		nf.setMaximumFractionDigits(0);
		return shortString ?
			offPraySuccessCount + "/" + attackCount :
			nf.format(offPraySuccessCount) + "/" + nf.format(attackCount) + " (" + Math.round(calculateOffPraySuccessPercentage()) + "%)";
	}

	public String getOffPrayStats()
	{
		return getOffPrayStats(false);
	}

	public String getMagicHitStats()
	{
		nf.setMaximumFractionDigits(0);
		String stats = nf.format(magicHitCount);
		long magicAttackCount = getMagicAttackCount();
		stats += "/" + nf.format(magicAttackCount);
		nf.setMaximumFractionDigits(2);
		String luckPercentage = magicHitCountDeserved != 0 ?
			nf.format(((double)magicHitCount / magicHitCountDeserved) * 100.0) :
			"0";
		stats += " (" + luckPercentage + "%)";
		return stats;
	}

	public String getShortMagicHitStats()
	{
		nf.setMaximumFractionDigits(2);
		return magicHitCountDeserved != 0 ?
			nf.format(((double)magicHitCount / magicHitCountDeserved) * 100.0) + "%" :
			"0%";
	}

	public String getDeservedDmgString(Fighter opponent, int precision, boolean onlyDiff)
	{
		nf.setMaximumFractionDigits(precision);
		double difference = deservedDamage - opponent.deservedDamage;
		return onlyDiff ? (difference > 0 ? "+" : "") + nf.format(difference) :
			nf.format(deservedDamage) + " (" + (difference > 0 ? "+" : "") + nf.format(difference) + ")";
	}
	public String getDeservedDmgString(Fighter opponent)
	{
		return getDeservedDmgString(opponent, 0, false);
	}


	public String getDmgDealtString(Fighter opponent, boolean onlyDiff)
	{
		int difference = damageDealt - opponent.damageDealt;
		return onlyDiff ? (difference > 0 ? "+" : "") + difference:
			damageDealt + " (" + (difference > 0 ? "+" : "") + difference + ")";
	}
	public String getDmgDealtString(Fighter opponent)
	{
		return getDmgDealtString(opponent, false);
	}

	public double calculateOffPraySuccessPercentage()
	{
		return attackCount == 0 ? 0 :
		(double) offPraySuccessCount / attackCount * 100.0;
	}

	public double calculateOffensivePraySuccessPercentage()
	{
		return attackCount == 0 ? 0 :
			(double) offensivePraySuccessCount / attackCount * 100.0;
	}

	public int getMagicAttackCount()
	{
		return totalMagicAttackCount;
	}

	// Return a simple string to display the current player's offensive prayer success rate.
	// ex. "42/59 (71%)". The name is not included as it will be in a separate view.
	// if shortString is true, the percentage is omitted, it only returns the fraction.
	public String getOffensivePrayStats(boolean shortString)
	{
		nf.setMaximumFractionDigits(0);
		return shortString ?
			offensivePraySuccessCount + "/" + attackCount :
			nf.format(offensivePraySuccessCount) + "/" + nf.format(attackCount) + " (" + Math.round(calculateOffensivePraySuccessPercentage()) + "%)";
	}

	public String getOffensivePrayStats()
	{
		return getOffensivePrayStats(false);
	}

	public String getGhostBarrageStats()
	{
		return ghostBarrageCount + " G.B. (" + nf.format(ghostBarrageDeservedDamage) + ")";
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.controllers;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import java.util.Objects;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import matsyir.pvpperformancetracker.models.AnimationData;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.models.FightType;
import matsyir.pvpperformancetracker.models.oldVersions.FightPerformance__1_5_5;
import net.runelite.api.AnimationID;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import org.apache.commons.lang3.StringUtils;

// Holds two Fighters which contain data about PvP fight performance, and has many methods to
// add to the fight, display stats or check the status of the fight.
@Slf4j
@Getter
public class FightPerformance implements Comparable<FightPerformance>
{
	// Delay to assume a fight is over. May seem long, but sometimes people barrage &
	// stand under for a while to eat. Fights will automatically end when either competitor dies.
	private static final Duration NEW_FIGHT_DELAY = Duration.ofSeconds(21);
	private static final NumberFormat nf = NumberFormat.getInstance();
	static // initialize number format
	{
		nf.setMaximumFractionDigits(1);
		nf.setRoundingMode(RoundingMode.HALF_UP);
	}

	@Expose
	@SerializedName("c") // use 1 letter serialized variable names for more compact storage
	public Fighter competitor;
	@Expose
	@SerializedName("o")
	public Fighter opponent;
	@Expose
	@SerializedName("t")
	public long lastFightTime; // last fight time saved as epochMilli timestamp (serializing an Instant was a bad time)
	@Expose
	@SerializedName("l")
	public FightType fightType; // save a boolean if the fight was done in LMS, so we can know those stats/rings/ammo are used.

	private int competitorPrevHp; // intentionally don't serialize this, temp variable used to calculate hp healed.

	// shouldn't be used, just here so we can make a subclass, weird java thing
	public FightPerformance()
	{

	}

	// constructor which initializes a fight from the 2 Players, starting stats at 0. Regular use constructor.
	public FightPerformance(Player competitor, Player opponent)
	{
		int defLvl = PLUGIN.getClient().getBoostedSkillLevel(Skill.DEFENCE);

		// determine fight type based on being at LMS areas & use def level to check for LMS builds.
		this.fightType = !PLUGIN.isAtLMS() ? FightType.NORMAL :
			defLvl <= FightType.LMS_1DEF.getCombatLevelsForType().def ? FightType.LMS_1DEF :
			defLvl <= FightType.LMS_ZERK.getCombatLevelsForType().def ? FightType.LMS_ZERK :
			FightType.LMS_MAXMED;

		// this is initialized soon before the NEW_FIGHT_DELAY time because the event we
		// determine the opponent from is not fully reliable.
		lastFightTime = Instant.now().minusSeconds(NEW_FIGHT_DELAY.getSeconds() - 5).toEpochMilli();

		this.competitor = new Fighter(this, competitor);
		this.opponent = new Fighter(this, opponent);

		this.competitorPrevHp = PLUGIN.getClient().getBoostedSkillLevel(Skill.HITPOINTS);
		this.competitor.setLastGhostBarrageCheckedMageXp(PLUGIN.getClient().getSkillExperience(Skill.MAGIC));
	}

	// create a FightPerformance using an old 1.5.5 or earlier version.
	public FightPerformance(FightPerformance__1_5_5 old)
	{
		this.competitor = old.competitor;
		this.opponent = old.opponent;
		this.lastFightTime = old.lastFightTime;
		if (old.isLmsFight)
		{
			if (competitor.getFightLogEntries().size() > 0)
			{
				int defLvl = competitor.getFightLogEntries().get(0).getAttackerLevels().def;
				this.fightType =
					defLvl <= FightType.LMS_1DEF.getCombatLevelsForType().def ? FightType.LMS_1DEF :
					defLvl <= FightType.LMS_ZERK.getCombatLevelsForType().def ? FightType.LMS_ZERK :
					FightType.LMS_MAXMED;
			}
			else
			{
				this.fightType = FightType.LMS_MAXMED;
			}
		}
		else
		{
			this.fightType = FightType.NORMAL;
		}
	}

	// return a random fightPerformance used for testing UI
	static FightPerformance getTestInstance()
	{
		int cTotal = (int)(Math.random() * 60) + 8;
		int cSuccess = (int)(Math.random() * (cTotal - 4)) + 4;
		double cDamage = (Math.random() * (cSuccess * 25));

		int oTotal = (int)(Math.random() * 60) + 8;
		int oSuccess = (int)(Math.random() * (oTotal - 4)) + 4;
		double oDamage = (Math.random() * (oSuccess * 25));

		int secOffset = (int)(Math.random() * 57600) - 28800;

		boolean cDead = Math.random() >= 0.5;

		ArrayList<FightLogEntry> fightLogEntries = new ArrayList<>();
		int [] attackerItems = {0, 0, 0};
		int [] defenderItems = {0, 0, 0};
		String attackerName = "testname";
		FightLogEntry fightLogEntry = new FightLogEntry(attackerItems, 21, 0.5, 1, 12, defenderItems, attackerName);
		FightLogEntry fightLogEntry2 = new FightLogEntry(attackerItems, 11, 0.2, 1, 41, defenderItems, attackerName);
		FightLogEntry fightLogEntry3 = new FightLogEntry(attackerItems, 12, 0.3, 1, 21, defenderItems, attackerName);
		FightLogEntry fightLogEntry4 = new FightLogEntry(attackerItems, 43, 0.1, 1, 23, defenderItems, attackerName);
		fightLogEntries.add(fightLogEntry);
		fightLogEntries.add(fightLogEntry2);
		fightLogEntries.add(fightLogEntry3);
		fightLogEntries.add(fightLogEntry4);
		return new FightPerformance("Matsyir", "TEST_DATA", cSuccess, cTotal, cDamage, oSuccess, oTotal, oDamage, cDead, secOffset, fightLogEntries);
	}

	// Used for testing purposes
	private FightPerformance(String cName, String oName, int cSuccess, int cTotal, double cDamage, int oSuccess, int oTotal, double oDamage, boolean cDead, int secondOffset, ArrayList<FightLogEntry> fightLogs)
	{
		this.competitor = new Fighter(this, cName, fightLogs);
		this.opponent = new Fighter(this, oName, fightLogs);

		competitor.addAttacks(cSuccess, cTotal, cDamage, (int)cDamage, 20, 12, 13, 11, 22, 25, 26);
		opponent.addAttacks(oSuccess, oTotal, oDamage, (int)oDamage, 20, 14, 13, 11, 22, 25, 26);

		if (cDead)
		{
			competitor.died();
		}
		else
		{
			opponent.died();
		}

		lastFightTime = Instant.now().minusSeconds(secondOffset).toEpochMilli();
	}

	// If the given playerName is in this fight, check the Fighter's current animation,
	// add an attack if attacking, and compare attack style used with the opponent's overhead
	// to determine if successful.
	public void checkForAttackAnimations(Player eventSource, CombatLevels competitorLevels)
	{
		if (eventSource == null || eventSource.getName() == null || eventSource.getInteracting() == null || eventSource.getInteracting().getName() == null)
		{
			return;
		}

		String eName = eventSource.getName(); // event source name
		String interactingName = eventSource.getInteracting().getName();

		// verify that the player is interacting with their tracked opponent before adding attacks
		if (eName.equals(competitor.getName()) && Objects.equals(interactingName, opponent.getName()))
		{
			competitor.setPlayer(eventSource);
			AnimationData animationData = competitor.getAnimationData();
			if (animationData != null)
			{
				int offensivePray = PLUGIN.currentlyUsedOffensivePray();
				competitor.addAttack(
					opponent.getPlayer(),
					animationData,
					offensivePray,
					competitorLevels);
				lastFightTime = Instant.now().toEpochMilli();
			}
		}
		else if (eName.equals(opponent.getName()) && Objects.equals(interactingName, competitor.getName()))
		{
			opponent.setPlayer(eventSource);
			AnimationData animationData = opponent.getAnimationData();
			if (animationData != null)
			{
				// there is no offensive prayer data for the opponent so hardcode 0
				opponent.addAttack(competitor.getPlayer(), animationData, 0);

				// add a defensive log for the competitor while the opponent is attacking, to be used with the fight analysis/merge
				competitor.addDefensiveLogs(competitorLevels, PLUGIN.currentlyUsedOffensivePray());
				lastFightTime = Instant.now().toEpochMilli();
			}
		}
	}

	// this only gets called when the local client player receives a magic xp drop.
	public void checkForLocalGhostBarrage(CombatLevels competitorLevels, Player localPlayer)
	{
		if (localPlayer == null)
		{
			log.info("Client player null while checking for ghost barrage - shouldn't happen");
			return;
		}

		competitor.setPlayer(localPlayer);
		if (localPlayer.getInteracting() instanceof Player && localPlayer.getInteracting().getName().equals(opponent.getName()))
		{
			opponent.setPlayer((Player)localPlayer.getInteracting());
		}

		AnimationData animationData = competitor.getAnimationData();

		if (animationData == null || animationData.attackStyle != AnimationData.AttackStyle.MAGIC)
		{
			animationData = AnimationData.MAGIC_ANCIENT_MULTI_TARGET;

			int offensivePray = PLUGIN.currentlyUsedOffensivePray();
			competitor.addGhostBarrage(opponent.getPlayer().getOverheadIcon() != animationData.attackStyle.getProtection(),
				opponent.getPlayer(),
				AnimationData.MAGIC_ANCIENT_MULTI_TARGET,
				offensivePray,
				competitorLevels);
		}
	}

	// add damage dealt to the opposite player.
	// the player name being passed in is the one who has the hitsplat on them.
	public void addDamageDealt(String playerName, int damage)
	{
		if (playerName == null) { return; }

		if (playerName.equals(competitor.getName()))
		{
			opponent.addDamageDealt(damage);
		}
		else if (playerName.equals(opponent.getName()))
		{
			competitor.addDamageDealt(damage);
		}
	}

	public void updateCompetitorHp(int currentHp)
	{
		if (currentHp > competitorPrevHp)
		{
			int hpHealed = currentHp - competitorPrevHp;
			competitor.addHpHealed(hpHealed);
		}
		competitorPrevHp = currentHp;
	}

	// Will return true and stop the fight if the fight should be over.
	// if either competitor hasn't fought in NEW_FIGHT_DELAY, or either competitor died.
	// Will also add the currentFight to fightHistory if the fight ended.
	public boolean isFightOver()
	{
		boolean isOver = false;
		// if either competitor died, end the fight.
		if (opponent.getPlayer().getAnimation() == AnimationID.DEATH)
		{
			opponent.died();
			isOver = true;
		}
		if (competitor.getPlayer().getAnimation() == AnimationID.DEATH)
		{
			competitor.died();
			isOver = true;
		}
		// If there was no fight actions in the last NEW_FIGHT_DELAY seconds
		if (Duration.between(Instant.ofEpochMilli(lastFightTime), Instant.now()).compareTo(NEW_FIGHT_DELAY) > 0)
		{
			isOver = true;
		}

		if (isOver)
		{
			lastFightTime = Instant.now().toEpochMilli();
		}

		return isOver;
	}

	public ArrayList<FightLogEntry> getAllFightLogEntries()
	{
		if (competitor.getFightLogEntries() == null || opponent.getFightLogEntries() == null)
		{
			return new ArrayList<>();
		}

		ArrayList<FightLogEntry> combinedList = new ArrayList<>();
		combinedList.addAll(competitor.getFightLogEntries());
		combinedList.addAll(opponent.getFightLogEntries());
		combinedList.sort(FightLogEntry::compareTo);
		return combinedList;
	}

	// only count the fight as started if the competitor attacked, not the enemy because
	// the person the competitor clicked on might be attacking someone else
	public boolean fightStarted()
	{
		return competitor.getAttackCount() > 0;
	}

	// returns true if competitor off-pray hit success rate > opponent success rate.
	// the following functions have similar behaviour.
	public boolean competitorOffPraySuccessIsGreater()
	{
		return competitor.calculateOffPraySuccessPercentage() > opponent.calculateOffPraySuccessPercentage();
	}

	public boolean opponentOffPraySuccessIsGreater()
	{
		return opponent.calculateOffPraySuccessPercentage() > competitor.calculateOffPraySuccessPercentage();
	}

	public boolean competitorDeservedDmgIsGreater()
	{
		return competitor.getDeservedDamage() > opponent.getDeservedDamage();
	}

	public boolean opponentDeservedDmgIsGreater()
	{
		return opponent.getDeservedDamage() > competitor.getDeservedDamage();
	}

	public boolean competitorDmgDealtIsGreater()
	{
		return competitor.getDamageDealt() > opponent.getDamageDealt();
	}

	public boolean opponentDmgDealtIsGreater()
	{
		return opponent.getDamageDealt() > competitor.getDamageDealt();
	}

	public boolean competitorMagicHitsLuckier()
	{
		double competitorRate = (competitor.getMagicHitCountDeserved() == 0) ? 0 :
			(competitor.getMagicHitCount() / competitor.getMagicHitCountDeserved());
		double opponentRate = (opponent.getMagicHitCountDeserved() == 0) ? 0 :
			(opponent.getMagicHitCount() / opponent.getMagicHitCountDeserved());

		return competitorRate > opponentRate;
	}

	public boolean opponentMagicHitsLuckier()
	{
		double competitorRate = (competitor.getMagicHitCountDeserved() == 0) ? 0 :
			(competitor.getMagicHitCount() / competitor.getMagicHitCountDeserved());
		double opponentRate = (opponent.getMagicHitCountDeserved() == 0) ? 0 :
			(opponent.getMagicHitCount() / opponent.getMagicHitCountDeserved());

		return opponentRate > competitorRate;
	}

	public double getCompetitorDeservedDmgDiff()
	{
		return competitor.getDeservedDamage() - opponent.getDeservedDamage();
	}

	public double getCompetitorDmgDealtDiff()
	{
		return competitor.getDamageDealt() - opponent.getDamageDealt();
	}

	// get nicely formatted stats for a discord message
	// uses ``` for monospaced fonts, and bash syntax highlighting for basic "success" highlighting.
	// "success entries" must be in double quotes.
	// pad non-success entries with a string, since they aren't in double quotes.
	public String getAsDiscordMessage()
	{
		String msg = "```bash\n";
		final int minLineLength = 36;
		final int lineLength = Math.max(minLineLength, this.competitor.getName().length() + this.opponent.getName().length() + 8);

		// name line
		String competitorName = competitor.getName() + (competitor.isDead() ? "(died)" : "");
		String opponentName = opponent.getName() + (opponent.isDead() ? "(died)" : "");
		msg += StringUtils.rightPad(competitorName, lineLength - opponentName.length(), ' ') + opponentName + "\n";

		// off-pray line
		String offPrayLeft = competitor.getOffPrayStats();
		offPrayLeft = surroundStrIfTrue(offPrayLeft, competitorOffPraySuccessIsGreater());

		String offPrayRight = opponent.getOffPrayStats();
		offPrayRight = surroundStrIfTrue(offPrayRight, opponentOffPraySuccessIsGreater());
		msg += StringUtils.rightPad(offPrayLeft, lineLength - offPrayRight.length(), ' ') + offPrayRight + "\n";

		// deserved dmg line
		String deservedDmgLeft = competitor.getDeservedDmgString(opponent);
		deservedDmgLeft = surroundStrIfTrue(deservedDmgLeft, competitorDeservedDmgIsGreater());

		String deservedDmgRight = opponent.getDeservedDmgString(competitor);
		deservedDmgRight = surroundStrIfTrue(deservedDmgRight, opponentDeservedDmgIsGreater());
		msg += StringUtils.rightPad(deservedDmgLeft, lineLength - deservedDmgRight.length(), ' ') + deservedDmgRight + "\n";

		// dmg dealt line
		String dmgDealtLeft = competitor.getDmgDealtString(opponent);
		dmgDealtLeft = surroundStrIfTrue(dmgDealtLeft, competitorDmgDealtIsGreater());

		String dmgDealtRight = opponent.getDmgDealtString(competitor);
		dmgDealtRight = surroundStrIfTrue(dmgDealtRight, opponentDmgDealtIsGreater());
		msg += StringUtils.rightPad(dmgDealtLeft, lineLength - dmgDealtRight.length(), ' ') + dmgDealtRight + "\n";

		// magic hit stats line
		String magicHitStatsLeft = competitor.getMagicHitStats();
		magicHitStatsLeft = surroundStrIfTrue(magicHitStatsLeft, competitorMagicHitsLuckier());

		String magicHitStatsRight = opponent.getMagicHitStats();
		magicHitStatsRight = surroundStrIfTrue(magicHitStatsRight, opponentMagicHitsLuckier());
		msg += StringUtils.rightPad(magicHitStatsLeft, lineLength - magicHitStatsRight.length(), ' ') + magicHitStatsRight + "\n";

		// offensive pray line
		String offensivePrayLeft = surroundStrIfTrue(competitor.getOffensivePrayStats(), false);
		String offensivePrayRight = "N/A ";
		msg += StringUtils.rightPad(offensivePrayLeft, lineLength - offensivePrayRight.length(), ' ') + offensivePrayRight + "\n";

		// hp healed line
		String hpHealedLeft = surroundStrIfTrue(String.valueOf(competitor.getHpHealed()), false);
		String hpHealedRight = "N/A ";
		msg += StringUtils.rightPad(hpHealedLeft, lineLength - hpHealedRight.length(), ' ') + hpHealedRight + "\n";

		msg += "Ended at " + new SimpleDateFormat("HH:mm:ss 'on' yyyy/MM/dd")
			.format(Date.from(Instant.ofEpochMilli(lastFightTime))) + "\n";
		return msg + "```";
	}

	private String surroundStrIfTrue(String strToSurround, boolean boolToCompare)
	{
		return surroundStrIfTrue(strToSurround, boolToCompare, "'", " ");
	}
	private String surroundStrIfTrue(String strToSurround, boolean boolToCompare, String trueSurround, String falseSurround)
	{
		return boolToCompare ?
			trueSurround + strToSurround + trueSurround :
			falseSurround  + strToSurround + falseSurround;
	}

	// use to sort by last fight time, to sort fights by date/time.
	@Override
	public int compareTo(FightPerformance o)
	{
		long diff = lastFightTime - o.lastFightTime;

		// if diff = 0, return 0. Otherwise, divide diff by its absolute value. This will result in
		// -1 for negative numbers, and 1 for positive numbers, keeping the sign and a safely small int.
		return diff == 0 ? 0 :
			(int)(diff / Math.abs(diff));
	}
}
/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.controllers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.stream.Collectors;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import matsyir.pvpperformancetracker.models.FightLogEntry;

@Slf4j
public class AnalyzedFightPerformance extends FightPerformance
{
	// fight's full fight logs, saved in "pairs", as an array:
	// [0]: attacker's full log entry
	// [1]: defender's defensive log entry
	@Getter
	ArrayList<FightLogEntry[]> analyzedMatchingLogs;

	@Getter
	FightPerformance mainFight;
	@Getter
	FightPerformance opposingFight;
	// create a more detailed fight performance by merging data from two opposing fight logs
	// also include the fights for easier access to general info
	public AnalyzedFightPerformance(FightPerformance mainFight, FightPerformance opposingFight, Runnable swingCallback) throws Exception
	{
		this.mainFight = mainFight;
		this.opposingFight = opposingFight;
		String cName = mainFight.competitor.getName();
		String oName = mainFight.opponent.getName();
		this.competitor = new Fighter(mainFight, cName);
		this.opponent = new Fighter(mainFight, oName);
		if (mainFight.competitor.isDead())
		{
			this.competitor.died();
		}
		if (mainFight.opponent.isDead())
		{
			this.opponent.died();
		}
		this.lastFightTime = Math.max(mainFight.lastFightTime, opposingFight.lastFightTime);

		// before looping through logs, set "global"/constant values that won't change depending on dps
		// calculations: successful magic hits, actual damage dealt, and hp healed.
		// in case either fighter somehow missed an attack, use the max potential available data
		// detected, as we could rarely miss an attack but never add an extra one.
		this.competitor.addDamageDealt(Math.max(mainFight.competitor.getDamageDealt(), opposingFight.opponent.getDamageDealt()));
		this.competitor.addMagicHitCount(Math.max(mainFight.competitor.getMagicHitCount(), opposingFight.opponent.getMagicHitCount()));
		this.competitor.addHpHealed(mainFight.competitor.getHpHealed());
		this.competitor.setTotalGhostBarrageStats(mainFight.competitor.getGhostBarrageCount(), mainFight.getCompetitor().getGhostBarrageDeservedDamage());

		this.opponent.addDamageDealt(Math.max(opposingFight.competitor.getDamageDealt(), mainFight.opponent.getDamageDealt()));
		this.opponent.addMagicHitCount(Math.max(opposingFight.competitor.getMagicHitCount(), mainFight.opponent.getMagicHitCount()));
		this.opponent.addHpHealed(opposingFight.competitor.getHpHealed());
		this.opponent.setTotalGhostBarrageStats(opposingFight.competitor.getGhostBarrageCount(), opposingFight.getCompetitor().getGhostBarrageDeservedDamage());

		ArrayList<FightLogEntry> mainFightLogEntries = mainFight.getAllFightLogEntries();
		mainFightLogEntries.sort(FightLogEntry::compareTo);
		ArrayList<FightLogEntry> opponentFightLogEntries = opposingFight.getAllFightLogEntries();
		opponentFightLogEntries.sort(FightLogEntry::compareTo);

		// save only full entries into separate arrays, as we'll loop through those a lot.
		ArrayList<FightLogEntry> fullMainFightLogEntries = mainFightLogEntries.stream()
			.filter(FightLogEntry::isFullEntry).sorted().collect(Collectors.toCollection(ArrayList::new));
		ArrayList<FightLogEntry> fullOpponentFightLogEntries = opponentFightLogEntries.stream()
			.filter(FightLogEntry::isFullEntry).sorted().collect(Collectors.toCollection(ArrayList::new));

		int offsetsToCheck = 2; // total number of fight log offsets to start from and find matches in the opposing fight.
		int attacksToCheck = 12; // total number of opposing logs to check starting from the offset.
		// TODO: THIS SHOULDNT BREAK IF attacksToCheck IS 300+ or unused & using all attacks/logs ????
		// ^ or maybe we dont have specific enough data to have it working 100% this way?

		// save matching logs as "pairs", in an array:
		// [0] = main fight's log entry match
		// [1] = opposing fight's log entry match
		// for each different offset start (from mainFight), save an array of the matching logs.
		ArrayList<ArrayList<FightLogEntry[]>> matchingLogs = new ArrayList<>();


		// go through up to the first 5 full logs to match with the opponent's first 6 attacks.
		// do this with a few different offsets and go with the results that had the most matches in 6 attacks.
		//
		// Why multiple offsets rather than one pass, or setting starting tick to 0?
		// It's possible one of the clients misses the first attack, and that people use the same gear
		// for many attacks, which may cause logs to match each-other while being offset, causing future
		// attacks to often be missed, and always be misleading. This way, if initial attacks are missed
		for (int mainOffset = 0; mainOffset < offsetsToCheck; mainOffset++)
		{
			for (int oppOffset = 0; oppOffset < offsetsToCheck; oppOffset++)
			{
				ArrayList<FightLogEntry[]> currentOffsetMatches = new ArrayList<>();
				int highestMatchIdx = -1;
				for (int i = mainOffset; i < fullMainFightLogEntries.size() && i < attacksToCheck; i++)
				{
					FightLogEntry entry = fullMainFightLogEntries.get(i);

					// .skip: do not check for matches on an attack we already got a match for, so skip it.
					//     if the highestMatchIdx is still <0, no matches were found yet so keep checking with oppOffset.
					int skip = highestMatchIdx < 0 ? oppOffset : highestMatchIdx + 1;
					// .limit: similarly to .skip, reduce the amount of attacks we check by the amount we skipped.
					// .filter: find matching fight log entries from the opposing fight.
					// do not use dps calc values for comparison as they can be different depending on each player's
					// config. could potentially fix this by recalculating fights first, but comparing all of these
					// should be ok enough. if gear and pray is the same, then so would dps anyways (before we do
					// the proper brew/level merge we are currently doing)
					FightLogEntry matchingOppLog = fullOpponentFightLogEntries.stream()
						.skip(skip)
						.limit(attacksToCheck - skip)
						.filter(oppEntry -> entry.attackerName.equals(oppEntry.attackerName) &&
							entry.getAnimationData() == oppEntry.getAnimationData() &&
							Arrays.equals(entry.getAttackerGear(), oppEntry.getAttackerGear()) &&
							Arrays.equals(entry.getDefenderGear(), oppEntry.getDefenderGear()) &&
							entry.getAttackerOverhead() == oppEntry.getAttackerOverhead() &&
							entry.getDefenderOverhead() == oppEntry.getDefenderOverhead() &&
							entry.success() == oppEntry.success() &&
							entry.isSplash() == oppEntry.isSplash())
						.findFirst()
						.orElse(null);

					// if a match was found, save the index of the match, and add both entries to the current offset matches.
					if (matchingOppLog != null)
					{
						int logEntryIdx = fullOpponentFightLogEntries.indexOf(matchingOppLog);

						if (logEntryIdx <= highestMatchIdx) // this should never happen.
						{
							throw new Exception("Invalid state during fight merge: logEntryIdx was under highestMatchIdx");
						}

						highestMatchIdx = logEntryIdx;
						currentOffsetMatches.add(new FightLogEntry[]{entry, matchingOppLog});
					}
				}

				if (currentOffsetMatches.size() >= 2)
				{
					matchingLogs.add(currentOffsetMatches);
				}
			}
		}

		if (matchingLogs.size() < 1)
		{
			throw new Exception("Unable to match initial attacks for fight analysis.");
		}

		// get the array of log entry matches that has the highest number of matches, as it should be the most accurate.
		// we'll use the matches in this array to determine the tick offset between the two sets of logs.
		// sort log matches by size, meaning most matches first.
		matchingLogs.sort(Comparator.comparing(ArrayList<FightLogEntry[]>::size).reversed());

		// ensure the tick difference found is valid: consistent difference between the first few matching attacks found.
		// this could potentially somehow still accept unrelated/invalid fights, as it could accept a single attack match,
		// but it should properly merge actual matching fights
		int bestTickDiff = 0;
		boolean foundValidTickDiff = false;
		for (ArrayList<FightLogEntry[]> logMatches : matchingLogs)
		{
			int tickDiff = 0;
			boolean tickDiffValid = true;
			for (int i = 0; i < logMatches.size(); i++)
			{
				FightLogEntry[] match = logMatches.get(i);

				int curTickDiff = match[0].getTick() - match[1].getTick();

				// ensure we have a consistent tick difference between the first few matching attacks.
				if (i == 0)
				{
					tickDiff = curTickDiff;
					continue;
				}

				if (curTickDiff != tickDiff)
				{
					tickDiffValid = false;
					break;
				}
			}

			if (tickDiffValid)
			{
				bestTickDiff = tickDiff;
				foundValidTickDiff = true;
				break;
			}
		}

		if (!foundValidTickDiff)
		{
			throw new Exception("Could not find matching initial attack logs in order to merge fights.");
		}

		// now that we have the best tick diff, we're ready to actually merge the two sets of log entries.
		// start by adjusting the opponent's logs' ticks so they line up with the main fight.
		for (FightLogEntry log : opponentFightLogEntries)
		{
			log.setTick(log.getTick() + bestTickDiff);
		}

		analyzedMatchingLogs = new ArrayList<>();

		// now that all the ticks should be lined up on the opponent fight log entries, find matching tick pairs for offensive : defensive logs.
		// skip the 'main' client's opponent logs, as those are the ones with less data we are trying to improve by using the opponent's data.
		// so, only loop through the main competitor's logs. We will add opponent attacks when we detect a defensive log.
		PLUGIN.getClientThread().invokeLater(() ->
		{
			mainFightLogEntries.stream()
				.filter(log -> log.attackerName.equals(mainFight.competitor.getName()))
				.forEachOrdered(log -> {
					// if the log is a full entry, then this is an attacking log coming from the competitor,
					// so we need to find a matching defensive log from the opponent.
					if (log.isFullEntry())
					{
						opponentFightLogEntries.stream()
							.filter(ol -> ol.getTick() == log.getTick())
							.filter(ol -> !ol.isFullEntry())
							.filter(ol -> ol.attackerName.equals(mainFight.opponent.getName()))
							.findFirst() // when a match is finally found, add the attack.
							.ifPresent(matchingDefenderLog -> addCompetitorAttack(log, matchingDefenderLog));
					}
					else // if the log is not a full entry, it's a defensive log coming from the competitor,
					{    // meaning we need to match it to an opponent's attacking log.
						opponentFightLogEntries.stream()
							.filter(ol -> ol.getTick() == log.getTick())
							.filter(FightLogEntry::isFullEntry)
							.filter(ol -> ol.attackerName.equals(mainFight.opponent.getName()))
							.findFirst() // when a match is finally found, add the attack.
							.ifPresent(matchingAttackerLog -> addOpponentAttack(matchingAttackerLog, log));
					}
				});

			SwingUtilities.invokeLater(swingCallback);
		});
	}

	void addCompetitorAttack(FightLogEntry attackerLog, FightLogEntry defenderLog)
	{
			this.competitor.addAttack(attackerLog, defenderLog);
			this.analyzedMatchingLogs.add(new FightLogEntry[]{ attackerLog, defenderLog });
	}

	void addOpponentAttack(FightLogEntry attackerLog, FightLogEntry defenderLog)
	{
			this.opponent.addAttack(attackerLog, defenderLog);
			this.analyzedMatchingLogs.add(new FightLogEntry[]{attackerLog, defenderLog});
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.controllers;

import lombok.Getter;
import java.util.Arrays;
import lombok.extern.slf4j.Slf4j;
import matsyir.pvpperformancetracker.models.FightLogEntry;
import matsyir.pvpperformancetracker.models.AnimationData;
import static matsyir.pvpperformancetracker.models.AnimationData.AttackStyle;
import static matsyir.pvpperformancetracker.models.FightLogEntry.nf;
import static matsyir.pvpperformancetracker.models.AnimationData.MAGIC_VOLATILE_NIGHTMARE_STAFF_SPEC;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.fixItemId;
import matsyir.pvpperformancetracker.models.EquipmentData;
import matsyir.pvpperformancetracker.models.EquipmentData.VoidStyle;
import matsyir.pvpperformancetracker.models.CombatLevels;
import matsyir.pvpperformancetracker.models.RangeAmmoData;
import matsyir.pvpperformancetracker.models.RingData;
import net.runelite.api.PlayerComposition;
import net.runelite.api.SpriteID;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemEquipmentStats;
import net.runelite.client.game.ItemStats;
import org.apache.commons.lang3.ArrayUtils;
import net.runelite.api.Player;

// Pvp damage calculations
// call updateDamageStats(...) with required parameters, and retrieve results by using the field getters
// for averageHit, accuracy, maxHit, and minHit.
//
// combat formulas source thread QFC: 317,318,461,66138854
// osrs wiki was also used a lot
@Slf4j
public class PvpDamageCalc
{
	private static final int STAB_ATTACK = 0, SLASH_ATTACK = 1, CRUSH_ATTACK = 2, MAGIC_ATTACK = 3,
		RANGE_ATTACK = 4, STAB_DEF = 5, SLASH_DEF = 6, CRUSH_DEF = 7, MAGIC_DEF = 8, RANGE_DEF = 9,
		STRENGTH_BONUS = 10, RANGE_STRENGTH = 11, MAGIC_DAMAGE = 12;

	private static final int STANCE_BONUS = 0; // assume they are not in controlled or defensive
	private static final double UNSUCCESSFUL_PRAY_DMG_MODIFIER = 0.6; // modifier for when you unsuccessfully hit off-pray

	// Offensive pray: assume you have valid. Piety for melee, Rigour for range, Augury for mage
	private static final double PIETY_ATK_PRAYER_MODIFIER = 1.2;
	private static final double PIETY_STR_PRAYER_MODIFIER = 1.23;
	private static final double AUGURY_OFFENSIVE_PRAYER_MODIFIER = 1.25;
	private static final double RIGOUR_OFFENSIVE_PRAYER_DMG_MODIFIER = 1.23;
	private static final double RIGOUR_OFFENSIVE_PRAYER_ATTACK_MODIFIER = 1.2;

	// Defensive pray: Assume you have one of the defensive prays active, but don't assume you have augury
	// while getting maged, since you would likely be planning to range or melee & using rigour/piety instead.
	private static final double PIETY_DEF_PRAYER_MODIFIER = 1.25;
	private static final double AUGURY_DEF_PRAYER_MODIFIER = 1.25;
	private static final double AUGURY_MAGEDEF_PRAYER_MODIFIER = 1.25; // assume we never use augury during defence for now (unless merging stats).
	private static final double RIGOUR_DEF_PRAYER_MODIFIER = 1.25;

	private static final double BALLISTA_SPEC_ACCURACY_MODIFIER = 1.25;
	private static final double BALLISTA_SPEC_DMG_MODIFIER = 1.25;

	private static final int ACB_SPEC_ACCURACY_MODIFIER = 2;

	private static final int DBOW_DMG_MODIFIER = 2;
	private static final int DBOW_SPEC_DMG_MODIFIER = 3;
	private static final int DBOW_SPEC_MIN_HIT = 16;

	private static final double DDS_SPEC_ACCURACY_MODIFIER = 1.25;
	private static final double DDS_SPEC_DMG_MODIFIER = 2.3;

	private static final int ARMA_GS_SPEC_ACCURACY_MODIFIER = 2;
	private static final double ARMA_GS_SPEC_DMG_MODIFIER = 1.375;
	private static final int ANCIENT_GS_SPEC_ACCURACY_MODIFIER = 2;
	private static final double FANG_SPEC_ACCURACY_MODIFIER = 1.5;
	private static final double ANCIENT_GS_SPEC_DMG_MODIFIER = 1.1;
	private static final int ANCIENT_GS_FIXED_DAMAGE = 25;

	private static final double VLS_SPEC_DMG_MODIFIER = 1.2;
	private static final double VLS_SPEC_MIN_DMG_MODIFIER = .2;
	private static final double VLS_SPEC_DEFENCE_SCALE = .25;
	private static final double SWH_SPEC_DMG_MODIFIER = 1.25;
	private static final double SWH_SPEC_MIN_DMG_MODIFIER = .25;
	private static final double DWH_SPEC_DMG_MODIFIER = 1.5;
	private static final double VOIDWAKER_SPEC_DMG_MODIFIER = 1.5;
	private static final double VOIDWAKER_SPEC_MIN_DMG_MODIFIER = .5;
	private static final double VOIDWAKER_FIXED_ACCURACY = 1;


	// 0.975x is a simplified average brimstone mage def formula, where x = opponent's mage def
	// 25% of attacks ignore 10% of mage def, therefore 25% of attacks are 90% mage def and 75% are the usual 100%.
	// original formula: 0.25(0.9x) + 0.75x ==> 0.975x
	public static final double BRIMSTONE_RING_OPPONENT_DEF_MODIFIER = 0.975;
	public static final double SMOKE_BATTLESTAFF_DMG_ACC_MODIFIER = 1.1; // both dmg & accuracy modifier
	public static final double TOME_OF_FIRE_DMG_MODIFIER = 1.5;
	public static final double VOLATILE_NIGHTMARE_STAFF_ACC_MODIFIER = 0.5;


	@Getter
	private double averageHit = 0;
	@Getter
	private double accuracy = 0;
	@Getter
	private int minHit = 0;
	@Getter
	private int maxHit = 0;

	private CombatLevels attackerLevels;
	private CombatLevels defenderLevels;

	private RingData ringUsed;
	boolean isLmsFight;

	public PvpDamageCalc(FightPerformance relatedFight)
	{
		isLmsFight = relatedFight.fightType.isLmsFight();
		this.attackerLevels = relatedFight.fightType.getCombatLevelsForType();
		this.defenderLevels = relatedFight.fightType.getCombatLevelsForType();

		this.ringUsed = isLmsFight ? RingData.BERSERKER_RING : CONFIG.ringChoice();
	}

	// main function used to update stats during an ongoing fight
	public void updateDamageStats(Player attacker, Player defender, boolean success, AnimationData animationData)
	{
		// shouldn't be possible, but just in case
		if (attacker == null || defender == null) { return; }

		averageHit = 0;
		accuracy = 0;
		minHit = 0;
		maxHit = 0;

		int[] attackerItems = attacker.getPlayerComposition().getEquipmentIds();
		int[] defenderItems = defender.getPlayerComposition().getEquipmentIds();

		EquipmentData weapon = EquipmentData.fromId(fixItemId(attackerItems[KitType.WEAPON.getIndex()]));

		int[] playerStats = this.calculateBonusesWithRing(attackerItems);
		int[] opponentStats = this.calculateBonusesWithRing(defenderItems);
		AnimationData.AttackStyle attackStyle = animationData.attackStyle; // basic style: stab/slash/crush/ranged/magic

		// Special attack used will be determined based on the currently used weapon, if its special attack has been implemented.
		// the animation just serves to tell if they actually did a special attack animation, since some animations
		// are used for multiple special attacks.
		boolean isSpecial = animationData.isSpecial;
		VoidStyle voidStyle = VoidStyle.getVoidStyleFor(attacker.getPlayerComposition().getEquipmentIds());

		if (attackStyle.isMelee() || animationData == AnimationData.MELEE_VOIDWAKER_SPEC)
		{
			getMeleeMaxHit(playerStats[STRENGTH_BONUS], isSpecial, weapon, voidStyle, true);
			getMeleeAccuracy(playerStats, opponentStats, attackStyle, isSpecial, weapon, voidStyle, true);
		}
		else if (attackStyle == AttackStyle.RANGED)
		{
			getRangedMaxHit(playerStats[RANGE_STRENGTH], isSpecial, weapon, voidStyle, true, attackerItems);
			getRangeAccuracy(playerStats[RANGE_ATTACK], opponentStats[RANGE_DEF], isSpecial, weapon, voidStyle, true, attackerItems);
		}
		// this should always be true at this point, but just in case. unknown animation styles won't
		// make it here, they should be stopped in FightPerformance::checkForAttackAnimations
		else if (attackStyle == AttackStyle.MAGIC)
		{
			EquipmentData shield = EquipmentData.fromId(fixItemId(attackerItems[KitType.SHIELD.getIndex()]));
			getMagicMaxHit(shield, playerStats[MAGIC_DAMAGE], animationData, weapon, voidStyle, true);
			getMagicAccuracy(playerStats[MAGIC_ATTACK], opponentStats[MAGIC_DEF], weapon, animationData, voidStyle, true, false);
		}

		getAverageHit(success, weapon, isSpecial);

		maxHit = (int)(maxHit * (success ? 1 : UNSUCCESSFUL_PRAY_DMG_MODIFIER));

		log.debug("attackStyle: " + attackStyle.toString() + ", avgHit: " + nf.format(averageHit) + ", acc: " + nf.format(accuracy) +
			"\nattacker(" + attacker.getName() + ")stats: " + Arrays.toString(playerStats) +
			"\ndefender(" +  defender.getName() + ")stats: " + Arrays.toString(opponentStats));
	}

	// secondary function used to analyze fights from the fight log (fight analysis/fight merge)
	public void updateDamageStats(FightLogEntry atkLog, FightLogEntry defenderLog)
	{
		this.attackerLevels = atkLog.getAttackerLevels();
		this.defenderLevels = defenderLog.getAttackerLevels();
		int[] attackerItems = atkLog.getAttackerGear();
		int[] defenderItems = atkLog.getDefenderGear();
		boolean success = atkLog.success();
		AnimationData animationData = atkLog.getAnimationData();
		boolean successfulOffensive = atkLog.getAnimationData().attackStyle.isUsingSuccessfulOffensivePray(atkLog.getAttackerOffensivePray());

		averageHit = 0;
		accuracy = 0;
		minHit = 0;
		maxHit = 0;

		EquipmentData weapon = EquipmentData.fromId(fixItemId(attackerItems[KitType.WEAPON.getIndex()]));

		int[] playerStats = this.calculateBonuses(attackerItems);
		int[] opponentStats = this.calculateBonuses(defenderItems);
		AnimationData.AttackStyle attackStyle = animationData.attackStyle; // basic style: stab/slash/crush/ranged/magic

		// Special attack used will be determined based on the currently used weapon, if its special attack has been implemented.
		// the animation just serves to tell if they actually did a special attack animation, since some animations
		// are used for multiple special attacks.
		boolean isSpecial = animationData.isSpecial;
		VoidStyle voidStyle = VoidStyle.getVoidStyleFor(attackerItems);

		if (attackStyle.isMelee())
		{
			getMeleeMaxHit(playerStats[STRENGTH_BONUS], isSpecial, weapon, voidStyle, successfulOffensive);
			getMeleeAccuracy(playerStats, opponentStats, attackStyle, isSpecial, weapon, voidStyle, successfulOffensive);
		}
		else if (attackStyle == AttackStyle.RANGED)
		{
			getRangedMaxHit(playerStats[RANGE_STRENGTH], isSpecial, weapon, voidStyle, successfulOffensive, attackerItems);
			getRangeAccuracy(playerStats[RANGE_ATTACK], opponentStats[RANGE_DEF], isSpecial, weapon, voidStyle, successfulOffensive, attackerItems);
		}
		// this should always be true at this point, but just in case. unknown animation styles won't
		// make it here, they should be stopped in FightPerformance::checkForAttackAnimations
		else if (attackStyle == AttackStyle.MAGIC)
		{
			EquipmentData shield = EquipmentData.fromId(fixItemId(attackerItems[KitType.SHIELD.getIndex()]));
			getMagicMaxHit(shield, playerStats[MAGIC_DAMAGE], animationData, weapon, voidStyle, successfulOffensive);
			getMagicAccuracy(playerStats[MAGIC_ATTACK], opponentStats[MAGIC_DEF], weapon, animationData, voidStyle, successfulOffensive, defenderLog.getAttackerOffensivePray() == SpriteID.PRAYER_AUGURY);
		}

		getAverageHit(success, weapon, isSpecial);

		maxHit = (int)(maxHit * (success ? 1 : UNSUCCESSFUL_PRAY_DMG_MODIFIER));
	}

	private void getAverageHit(boolean success, EquipmentData weapon, boolean usingSpec)
	{
		boolean ancientGs = weapon == EquipmentData.ANCIENT_GODSWORD;
		boolean dbow = weapon == EquipmentData.DARK_BOW;
		boolean claws = weapon == EquipmentData.DRAGON_CLAWS;
		boolean fang = weapon == EquipmentData.OSMUMTENS_FANG;
		boolean vls = weapon == EquipmentData.VESTAS_LONGSWORD;
		boolean swh = weapon == EquipmentData.STATIUS_WARHAMMER;
		boolean voidwaker = weapon == EquipmentData.VOIDWAKER;

		double prayerModifier = success ? 1 : UNSUCCESSFUL_PRAY_DMG_MODIFIER;
		double averageSuccessfulHit;
		// average hit calculation for attacks that have minimum hits that are skewed towards hitting minimum hit more often
		if (usingSpec && (dbow || vls || swh))
		{
			double accuracyAdjuster = dbow ? accuracy : 1;
			minHit = dbow ? DBOW_SPEC_MIN_HIT : 0;
			minHit = vls ? (int) (maxHit * VLS_SPEC_MIN_DMG_MODIFIER) : minHit;
			minHit = swh ? (int) (maxHit * SWH_SPEC_MIN_DMG_MODIFIER) : minHit;

			int total = 0;

			// this odd logic is used to calculate avg hit because when there is a minimum hit,
			// it does not simply change the potential hit range as you would expect:
			// potential hit rolls (min=0 max=5): 0, 1, 2, 3, 4, 5
			// potential hit rolls (min=3 max=5): 3, 3, 3, 3, 4, 5 (intuitively it would just be 3, 4, 5, but nope)
			// so, it is more common to roll the minimum hit and that has to be accounted for in the average hit.
			for (int i = 0; i <= maxHit; i++)
			{
				total += i < minHit ? minHit / accuracyAdjuster : i;
			}

			averageSuccessfulHit = (double) total / maxHit;
		}
		else if (usingSpec && claws)
		{
			// if first 1-2 claws miss, it's a 150% dmg multiplier because when the 3rd att hits, the last
			// 2 hits are 75% dmg multiplier, so 75% + 75% = 150%. It's a matter of a 2x multiplier or a
			// 1.5x multiplier and the chance of a 2x multiplier is what higherModifierChance is for

			// inverted accuracy is used to calculate the chances of missing specifically 1, 2 or 3 times in a row
			double invertedAccuracy = 1 - accuracy;
			double averageSuccessfulRegularHit = maxHit / 2;
			double higherModifierChance = (accuracy + (accuracy * invertedAccuracy));
			double lowerModifierChance = ((accuracy * Math.pow(invertedAccuracy, 2)) + (accuracy * Math.pow(invertedAccuracy, 3)));
			double averageSpecialHit = ((higherModifierChance * 2) + (lowerModifierChance * 1.5)) * averageSuccessfulRegularHit;

			averageHit = averageSpecialHit * prayerModifier;
			accuracy = higherModifierChance + lowerModifierChance;
			// the random +1 is not included in avg hit but it is included in the max hit to be seen from fight logs
			maxHit = maxHit * 2 + 1;
			return;
		}
		else if (fang)
		{
			double maxHitMultiplier = usingSpec ? 1: 0.85; // max hit when using spec is 100% but minHit stays the same
			// accuracy rolls twice for the fang, so the accuracy is equal to 1 - chance of hit1 OR hit2
			double invertedAccuracy = 1 - accuracy; // example: if accuracy is 20% and thus 0.2, inverted accuracy is 0.8
			double chanceOfMissingTwice = Math.pow(invertedAccuracy, 2); // 0.8 squared is 0.64 or 64%
			accuracy = 1 - chanceOfMissingTwice; // thus 64% chance of missing, or 36% accuracy
			// max hit is 0.85% and min hit is 15%
			// unlike VLS/SWH/Dbow I believe this rolls between min and max instead of raising hits between 0 - minHit to minHit
			minHit = (int) (0.15 * maxHit);
			maxHit = (int) (maxHitMultiplier * maxHit);

			averageSuccessfulHit = (minHit + maxHit) / 2.0;
		}
		// average hit calculation for attacks with minimum hits that use a more 'intuitive' average hit, similar to osmuten's fang
		else if (usingSpec && voidwaker)
		{
			minHit = (int) (maxHit * VOIDWAKER_SPEC_MIN_DMG_MODIFIER);

			averageSuccessfulHit = (minHit + maxHit) / 2.0;
		}
		else
		{
			// divide by double to get accurate decimals, since this is the averageHit result,
			// not a core OSRS damage calc that is meant to be rounded down by int
			// If reaching this part of the code, the minHit should always be 0, but include it anyways
			// just in case.
			averageSuccessfulHit = (minHit + maxHit) / 2.0;
			if (minHit > 0)
			{
				log.info("PvpDamageCalc:getAverageHit: Fell into default avg hit calculation with a minHit > 0 (" +
					minHit + "). Shouldn't happen. Weapon: " + weapon.toString());
			}
		}

		averageHit = accuracy * averageSuccessfulHit * prayerModifier;

		if (usingSpec && ancientGs)
		{
			averageHit += ANCIENT_GS_FIXED_DAMAGE;
		}
	}

	private void getMeleeMaxHit(int meleeStrength, boolean usingSpec, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive)
	{
		boolean ags = weapon == EquipmentData.ARMADYL_GODSWORD;
		boolean ancientGs = weapon == EquipmentData.ANCIENT_GODSWORD;
		boolean dds = weapon == EquipmentData.DRAGON_DAGGER;
		boolean vls = weapon == EquipmentData.VESTAS_LONGSWORD;
		boolean swh = weapon == EquipmentData.STATIUS_WARHAMMER;
		boolean dwh = weapon == EquipmentData.DRAGON_WARHAMMER;
		boolean voidwaker = weapon == EquipmentData.VOIDWAKER;

		int effectiveLevel = (int) Math.floor((attackerLevels.str * (successfulOffensive ? PIETY_STR_PRAYER_MODIFIER : 1)) + 8 + 3);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_MELEE || voidStyle == VoidStyle.VOID_MELEE)
		{
			effectiveLevel *= voidStyle.dmgModifier;
		}

		int baseDamage = (int) Math.floor(0.5 + effectiveLevel * (meleeStrength + 64) / 640);
		double damageModifier = (ags && usingSpec) ? ARMA_GS_SPEC_DMG_MODIFIER :
			(ancientGs && usingSpec) ? ANCIENT_GS_SPEC_DMG_MODIFIER :
			(swh && usingSpec) ? SWH_SPEC_DMG_MODIFIER :
			(dds && usingSpec) ? DDS_SPEC_DMG_MODIFIER :
			(vls && usingSpec) ? VLS_SPEC_DMG_MODIFIER :
			(dwh && usingSpec) ? DWH_SPEC_DMG_MODIFIER :
			(voidwaker && usingSpec) ? VOIDWAKER_SPEC_DMG_MODIFIER :
			1;
		maxHit = (int) (damageModifier * baseDamage);
	}

	private void getRangedMaxHit(int rangeStrength, boolean usingSpec, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive, int[] attackerComposition)
	{
		RangeAmmoData weaponAmmo = EquipmentData.getWeaponAmmo(weapon);
		EquipmentData head = EquipmentData.fromId(fixItemId(attackerComposition[KitType.HEAD.getIndex()]));
		EquipmentData body = EquipmentData.fromId(fixItemId(attackerComposition[KitType.TORSO.getIndex()]));
		EquipmentData legs = EquipmentData.fromId(fixItemId(attackerComposition[KitType.LEGS.getIndex()]));

		// if it's an LMS fight and bolts are used, force diamond bolts (e) or opal dragon bolts (e) based on weapon used.
		if (this.isLmsFight)
		{
			weaponAmmo = weaponAmmo instanceof RangeAmmoData.StrongBoltAmmo ? RangeAmmoData.StrongBoltAmmo.OPAL_DRAGON_BOLTS_E :
				weaponAmmo instanceof RangeAmmoData.BoltAmmo ? RangeAmmoData.BoltAmmo.DIAMOND_BOLTS_E : weaponAmmo;
		}

		boolean ballista = weapon == EquipmentData.HEAVY_BALLISTA;
		boolean dbow = weapon == EquipmentData.DARK_BOW;

		int ammoStrength = weaponAmmo == null ? 0 : weaponAmmo.getRangeStr();

		rangeStrength += ammoStrength;

		int effectiveLevel = (int) Math.floor((attackerLevels.range * (successfulOffensive ? RIGOUR_OFFENSIVE_PRAYER_DMG_MODIFIER : 1)) + 8);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_RANGE || voidStyle == VoidStyle.VOID_RANGE)
		{
			effectiveLevel *= voidStyle.dmgModifier;
		}

		int baseDamage = (int) Math.floor(0.5 + (effectiveLevel * (rangeStrength + 64) / 640));

		double modifier = weaponAmmo == null ? 1 : weaponAmmo.getDmgModifier();
		modifier = ballista && usingSpec ? BALLISTA_SPEC_DMG_MODIFIER : modifier;
		modifier = dbow && !usingSpec ? DBOW_DMG_MODIFIER : modifier;
		modifier = dbow && usingSpec ? DBOW_SPEC_DMG_MODIFIER : modifier;
		maxHit = weaponAmmo == null ?
			(int) (modifier * baseDamage) :
			(int) ((modifier * baseDamage) + weaponAmmo.getBonusMaxHit(attackerLevels.range));

		// apply crystal armor bonus if using bow
		if ((weapon == EquipmentData.BOW_OF_FAERDHINEN || weapon == EquipmentData.CRYSTAL_BOW || weapon == EquipmentData.CRYSTAL_BOW_I) &&
			(head == EquipmentData.CRYSTAL_HELM || body == EquipmentData.CRYSTAL_BODY || legs == EquipmentData.CRYSTAL_LEGS))
		{
			double dmgModifier = 1 +
				(head == EquipmentData.CRYSTAL_HELM ? 0.025 : 0) +
				(body == EquipmentData.CRYSTAL_BODY ? 0.075 : 0) +
				(legs == EquipmentData.CRYSTAL_LEGS ? 0.05 : 0);

			maxHit *= dmgModifier;
		}
	}

	private void getMagicMaxHit(EquipmentData shield, int mageDamageBonus, AnimationData animationData, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive)
	{
		boolean smokeBstaff = weapon == EquipmentData.SMOKE_BATTLESTAFF;
		boolean tome = shield == EquipmentData.TOME_OF_FIRE;

		double magicBonus = 1 + (mageDamageBonus / 100.0);
		// provide dmg buff from smoke battlestaff if applicable
		if (smokeBstaff && AnimationData.isStandardSpellbookSpell(animationData))
		{
			magicBonus *= SMOKE_BATTLESTAFF_DMG_ACC_MODIFIER;
		}
		// provide dmg buff from tome of fire if applicable
		if (tome && AnimationData.isFireSpell(animationData))
		{
			magicBonus *= TOME_OF_FIRE_DMG_MODIFIER;
		}
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_MAGE || voidStyle == VoidStyle.VOID_MAGE)
		{
			magicBonus *= voidStyle.dmgModifier;
		}

		maxHit = (int)(animationData.baseSpellDamage * magicBonus);
	}

	private void getMeleeAccuracy(int[] playerStats, int[] opponentStats, AttackStyle attackStyle, boolean usingSpec, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive)
	{
		boolean vls = weapon == EquipmentData.VESTAS_LONGSWORD;
		boolean ags = weapon == EquipmentData.ARMADYL_GODSWORD;
		boolean ancientGs = weapon == EquipmentData.ANCIENT_GODSWORD;
		boolean dds = weapon == EquipmentData.DRAGON_DAGGER;
		boolean fang = weapon == EquipmentData.OSMUMTENS_FANG;
		boolean voidwaker = weapon == EquipmentData.VOIDWAKER;

		if (voidwaker && usingSpec)
		{
			accuracy = VOIDWAKER_FIXED_ACCURACY;
			return;
		}

		double stabBonusPlayer = playerStats[STAB_ATTACK];
		double slashBonusPlayer = playerStats[SLASH_ATTACK];
		double crushBonusPlayer = playerStats[CRUSH_ATTACK];

		double stabBonusTarget = opponentStats[STAB_DEF];
		double slashBonusTarget = opponentStats[SLASH_DEF];
		double crushBonusTarget = opponentStats[CRUSH_DEF];
		double magicBonusTarget = opponentStats[MAGIC_DEF];

		double effectiveLevelPlayer;
		double effectiveLevelTarget;

		double baseChance;
		double attackerChance;
		double defenderChance = 0;

		double accuracyModifier = dds ? DDS_SPEC_ACCURACY_MODIFIER :
			ags ? ARMA_GS_SPEC_ACCURACY_MODIFIER :
			ancientGs ? ANCIENT_GS_SPEC_ACCURACY_MODIFIER :
			fang ? FANG_SPEC_ACCURACY_MODIFIER :
			1;

		/**
		 * Attacker Chance
		 */
		effectiveLevelPlayer = Math.floor(((attackerLevels.atk * (successfulOffensive ? PIETY_ATK_PRAYER_MODIFIER : 1)) + STANCE_BONUS) + 8);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_MELEE || voidStyle == VoidStyle.VOID_MELEE)
		{
			effectiveLevelPlayer *= voidStyle.accuracyModifier;
		}

		final double attackBonus = attackStyle == AttackStyle.STAB ? stabBonusPlayer
			: attackStyle == AttackStyle.SLASH ? slashBonusPlayer : crushBonusPlayer;

		final double targetDefenceBonus = attackStyle == AttackStyle.STAB ? stabBonusTarget
			: attackStyle == AttackStyle.SLASH ? slashBonusTarget : crushBonusTarget;


		baseChance = Math.floor(effectiveLevelPlayer * (attackBonus + 64));
		if (usingSpec)
		{
			baseChance = baseChance * accuracyModifier;
		}

		attackerChance = baseChance;

		/**
		 * Defender Chance
		 */
		effectiveLevelTarget = Math.floor(((defenderLevels.def * PIETY_DEF_PRAYER_MODIFIER) + STANCE_BONUS) + 8);

		if (vls && usingSpec)
		{
			defenderChance = Math.floor((effectiveLevelTarget * (stabBonusTarget + 64)) * VLS_SPEC_DEFENCE_SCALE);
		}
		else
		{
			defenderChance = Math.floor(effectiveLevelTarget * (targetDefenceBonus + 64));
		}
//        log.debug("MELEE ATTACK: " + defenderChance );
		/**
		 * Calculate Accuracy
		 */
		if (attackerChance > defenderChance)
		{
			accuracy = 1 - (defenderChance + 2) / (2 * (attackerChance + 1));
		}
		else
		{
			accuracy = attackerChance / (2 * (defenderChance + 1));
		}
	}

	private void getRangeAccuracy(int playerRangeAtt, int opponentRangeDef, boolean usingSpec, EquipmentData weapon, VoidStyle voidStyle, boolean successfulOffensive, int[] attackerComposition)
	{
		RangeAmmoData weaponAmmo = EquipmentData.getWeaponAmmo(weapon);
		// if it's an LMS fight and bolts are used, don't use config bolt, just use diamond bolts(e)
		if (this.isLmsFight && (weaponAmmo instanceof RangeAmmoData.BoltAmmo ||
			weaponAmmo instanceof RangeAmmoData.StrongBoltAmmo))
		{
			weaponAmmo = RangeAmmoData.BoltAmmo.DIAMOND_BOLTS_E;
		}

		boolean diamonds = ArrayUtils.contains(RangeAmmoData.DIAMOND_BOLTS, weaponAmmo);
		boolean opals = ArrayUtils.contains(RangeAmmoData.OPAL_BOLTS, weaponAmmo);
		double effectiveLevelPlayer;
		double effectiveLevelTarget;
		double rangeModifier;
		double attackerChance;
		double defenderChance;

		/**
		 * Attacker Chance
		 */
		effectiveLevelPlayer = Math.floor(((attackerLevels.range * (successfulOffensive ? RIGOUR_OFFENSIVE_PRAYER_ATTACK_MODIFIER : 1)) + STANCE_BONUS) + 8);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_RANGE || voidStyle == VoidStyle.VOID_RANGE)
		{
			effectiveLevelPlayer *= voidStyle.accuracyModifier;
		}

		// apply crystal armor bonus if using bow
		EquipmentData head = EquipmentData.fromId(fixItemId(attackerComposition[KitType.HEAD.getIndex()]));
		EquipmentData body = EquipmentData.fromId(fixItemId(attackerComposition[KitType.TORSO.getIndex()]));
		EquipmentData legs = EquipmentData.fromId(fixItemId(attackerComposition[KitType.LEGS.getIndex()]));

		if ((weapon == EquipmentData.BOW_OF_FAERDHINEN || weapon == EquipmentData.CRYSTAL_BOW || weapon == EquipmentData.CRYSTAL_BOW_I) &&
			(head == EquipmentData.CRYSTAL_HELM || body == EquipmentData.CRYSTAL_BODY || legs == EquipmentData.CRYSTAL_LEGS))
		{
			double accuracyModifier = 1 +
				(head == EquipmentData.CRYSTAL_HELM ? 0.05 : 0) +
				(body == EquipmentData.CRYSTAL_BODY ? 0.15 : 0) +
				(legs == EquipmentData.CRYSTAL_LEGS ? 0.1 : 0);

			effectiveLevelPlayer *= accuracyModifier;
		}

		rangeModifier = Math.floor(effectiveLevelPlayer * ((double) playerRangeAtt + 64));
		if (usingSpec)
		{
			boolean acb = weapon == EquipmentData.ARMADYL_CROSSBOW;
			boolean ballista = weapon == EquipmentData.HEAVY_BALLISTA;

			double specAccuracyModifier = acb ? ACB_SPEC_ACCURACY_MODIFIER :
				ballista ? BALLISTA_SPEC_ACCURACY_MODIFIER : 1;

			attackerChance = Math.floor(rangeModifier * specAccuracyModifier);
		}
		else
		{
			attackerChance = rangeModifier;
		}

		/**
		 * Defender Chance
		 */
		effectiveLevelTarget = Math.floor(((defenderLevels.def * RIGOUR_DEF_PRAYER_MODIFIER) + STANCE_BONUS) + 8);
		defenderChance = Math.floor(effectiveLevelTarget * ((double) opponentRangeDef + 64));

		/**
		 * Calculate Accuracy
		 */
		if (attackerChance > defenderChance)
		{
			accuracy = 1 - (defenderChance + 2) / (2 * (attackerChance + 1));
		}
		else
		{
			accuracy = attackerChance / (2 * (defenderChance + 1));
		}

		// the effect in pvp is 5% instead of 10% like it is for pvm
		// upon further testing this effect applies to opal dragon bolts as well
		// diamond bolts and opal bolts accuracy: 5% of attacks are 100% accuracy, so apply avg accuracy as:
		// (95% of normal accuracy) + (5% of 100% accuracy)
		accuracy = (diamonds || opals) ? (accuracy * .95) + .05 : accuracy;
	}

	private void getMagicAccuracy(int playerMageAtt, int opponentMageDef, EquipmentData weapon, AnimationData animationData, VoidStyle voidStyle, boolean successfulOffensive, boolean defensiveAugurySuccess)
	{
		double effectiveLevelPlayer;

		double reducedDefenceLevelTarget;
		double effectiveMagicDefenceTarget;
		double effectiveMagicLevelTarget;

		double effectiveLevelTarget;

		double magicModifier;

		double attackerChance;
		double defenderChance;

		/**
		 * Attacker Chance
		 */
		effectiveLevelPlayer = Math.floor(((attackerLevels.mage * (successfulOffensive ? AUGURY_OFFENSIVE_PRAYER_MODIFIER : 1))) + 8);
		// apply void bonus if applicable
		if (voidStyle == VoidStyle.VOID_ELITE_MAGE || voidStyle == VoidStyle.VOID_MAGE)
		{
			effectiveLevelPlayer *= voidStyle.accuracyModifier;
		}

		magicModifier = Math.floor(effectiveLevelPlayer * ((double) playerMageAtt + 64));
		attackerChance = magicModifier;

		/**
		 * Defender Chance
		 */
		effectiveLevelTarget = Math.floor(((defenderLevels.def * AUGURY_DEF_PRAYER_MODIFIER) + STANCE_BONUS) + 8);
		effectiveMagicLevelTarget = Math.floor((defenderLevels.mage * (defensiveAugurySuccess ? AUGURY_MAGEDEF_PRAYER_MODIFIER : 1)) * 0.70);
		reducedDefenceLevelTarget = Math.floor(effectiveLevelTarget * 0.30);
		effectiveMagicDefenceTarget = effectiveMagicLevelTarget + reducedDefenceLevelTarget;

		// 0.975x is a simplified brimstone accuracy formula, where x = mage def
		defenderChance = ringUsed == RingData.BRIMSTONE_RING ?
			Math.floor(effectiveMagicDefenceTarget * ((BRIMSTONE_RING_OPPONENT_DEF_MODIFIER * opponentMageDef) + 64)) :
			Math.floor(effectiveMagicDefenceTarget * ((double) opponentMageDef + 64));

		/**
		 * Calculate Accuracy
		 */
		if (attackerChance > defenderChance)
		{
			accuracy = 1 - (defenderChance + 2) / (2 * (attackerChance + 1));
		}
		else
		{
			accuracy = attackerChance / (2 * (defenderChance + 1));
		}

		boolean smokeBstaff = weapon == EquipmentData.SMOKE_BATTLESTAFF;
		boolean volatileStaff = weapon == EquipmentData.VOLATILE_NIGHTMARE_STAFF;
		// provide accuracy buff from smoke battlestaff or volatile staff spec if applicable
		if (smokeBstaff && AnimationData.isStandardSpellbookSpell(animationData))
		{
			accuracy *= SMOKE_BATTLESTAFF_DMG_ACC_MODIFIER;
		}
		else if (volatileStaff && animationData == MAGIC_VOLATILE_NIGHTMARE_STAFF_SPEC)
		{
			accuracy *= VOLATILE_NIGHTMARE_STAFF_ACC_MODIFIER;
		}
	}

	// Retrieve item stats for a single item, returned as an int array so they can be modified.
	// First, try to get the item stats from the item manager. If stats weren't present in the
	// itemManager, try get the 'real' item id from the EquipmentData. If it's not defined in EquipmentData, it will return null
	// and count as 0 stats, but that should be very rare.
	public static int[] getItemStats(int itemId)
	{
		ItemStats itemStats = PLUGIN.getItemManager().getItemStats(itemId);
		if (itemStats == null)
		{
			EquipmentData itemData = EquipmentData.fromId(itemId);
			if (itemData != null)
			{
				itemId = itemData.getItemId();
				itemStats = PLUGIN.getItemManager().getItemStats(itemId);
			}
		}

		if (itemStats != null)
		{
			final ItemEquipmentStats equipmentStats = itemStats.getEquipment();
			return new int[] {
				equipmentStats.getAstab(),	// 0
				equipmentStats.getAslash(),	// 1
				equipmentStats.getAcrush(),	// 2
				equipmentStats.getAmagic(),	// 3
				equipmentStats.getArange(),	// 4
				equipmentStats.getDstab(),	// 5
				equipmentStats.getDslash(),	// 6
				equipmentStats.getDcrush(),	// 7
				equipmentStats.getDmagic(),	// 8
				equipmentStats.getDrange(),	// 9
				equipmentStats.getStr(),	// 10
				equipmentStats.getRstr(),	// 11
				(int)equipmentStats.getMdmg(),	// 12
			};
		}

		// when combining multiple items' stats, null stats will just be skipped, without affecting
		// the total stats.
		return null;
	}

	// this is used to calculate bonuses including the currently used ring, in case we're in LMS but the config ring
	// is different.
	private int[] calculateBonusesWithRing(int[] itemIds)
	{
		return calculateBonuses(itemIds, this.ringUsed);
	}

	public static int[] calculateBonuses(int[] itemIds)
	{
		return calculateBonuses(itemIds, CONFIG.ringChoice());
	}
	// Calculate total equipment bonuses for all given items
	public static int[] calculateBonuses(int[] itemIds, RingData ringUsed)
	{
		int[] equipmentBonuses = ringUsed == null || ringUsed == RingData.NONE ?
			new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } :
			getItemStats(ringUsed.getItemId());

		if (equipmentBonuses == null) // shouldn't happen, but as a failsafe if the ring lookup fails
		{
			equipmentBonuses = new int[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		}

		for (int item : itemIds)
		{
			if (item > PlayerComposition.ITEM_OFFSET)
			{
				int[] bonuses = getItemStats(item - PlayerComposition.ITEM_OFFSET);

				if (bonuses == null)
				{
					continue;
				}

				for (int id = 0; id < bonuses.length; id++)
				{
					equipmentBonuses[id] += bonuses[id];
				}
			}
		}

		return equipmentBonuses;
	}

	public static ItemEquipmentStats calculateBonusesToStats(int[] itemIds)
	{
		int[] bonuses = calculateBonuses(itemIds);
		return ItemEquipmentStats.builder()
			.astab(bonuses[STAB_ATTACK])	// 0
			.aslash(bonuses[SLASH_ATTACK])	// 1
			.acrush(bonuses[CRUSH_ATTACK])	// 2
			.amagic(bonuses[MAGIC_ATTACK])	// 3
			.arange(bonuses[RANGE_ATTACK])	// 4
			.dstab(bonuses[STAB_DEF])		// 5
			.dslash(bonuses[SLASH_DEF])		// 6
			.dcrush(bonuses[CRUSH_DEF])		// 7
			.dmagic(bonuses[MAGIC_DEF])		// 8
			.drange(bonuses[RANGE_DEF])		// 9
			.str(bonuses[STRENGTH_BONUS])	// 10
			.rstr(bonuses[RANGE_STRENGTH]) 	// 11
			.mdmg(bonuses[MAGIC_DAMAGE])	// 12
			.build();
	}
}

/*
 * Copyright (c)  2020, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import javax.inject.Inject;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import matsyir.pvpperformancetracker.controllers.FightPerformance;
import matsyir.pvpperformancetracker.views.FightPerformancePanel;
import matsyir.pvpperformancetracker.views.TotalStatsPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

class PvpPerformanceTrackerPanel extends PluginPanel
{
	// The main fight history container, this will hold all the individual FightPerformancePanels.
	private final JPanel fightHistoryContainer = new JPanel();
	private final TotalStatsPanel totalStatsPanel = new TotalStatsPanel();

	private final PvpPerformanceTrackerPlugin plugin;
	private final PvpPerformanceTrackerConfig config;

	@Inject
	private PvpPerformanceTrackerPanel(final PvpPerformanceTrackerPlugin plugin, final PvpPerformanceTrackerConfig config)
	{
		super(false);
		this.plugin = plugin;
		this.config = config;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setBorder(new EmptyBorder(8, 8, 8, 8));
		JPanel mainContent = new JPanel(new BorderLayout());

		fightHistoryContainer.setLayout(new BoxLayout(fightHistoryContainer, BoxLayout.Y_AXIS));

		add(totalStatsPanel);

		// add filter line with label & text field.
		JPanel filterLine = new JPanel(new BorderLayout());
		// filter label
		JLabel filterLabel = new JLabel("Filter Usernames:");
		filterLabel.setHorizontalAlignment(SwingConstants.CENTER);
		// filter textfield
		JTextField nameFilter = new JTextField(config.nameFilter());
		filterLine.setMaximumSize(new Dimension(PANEL_WIDTH, (int)filterLine.getPreferredSize().getHeight()));

		nameFilter.getDocument().addDocumentListener(new DocumentListener() {
			private void updateNameFilterValue()
			{
				plugin.updateNameFilterConfig(nameFilter.getText());

				// do not rebuild the panel if the filter starts with a space. This is because you could spam rebuild()
				// by holding down space and causing massive lag. This isn't really an issue with real filters as the
				// results quickly get filtered down, resulting in less UI elements.
				if (!nameFilter.getText().startsWith(" "))
				{
					PvpPerformanceTrackerPanel.this.rebuild();
				}
			}

			public void changedUpdate(DocumentEvent e) { updateNameFilterValue(); }
			public void removeUpdate(DocumentEvent e) { updateNameFilterValue(); }
			public void insertUpdate(DocumentEvent e) { updateNameFilterValue(); }
		});

		filterLine.add(filterLabel, BorderLayout.NORTH);
		filterLine.add(nameFilter, BorderLayout.CENTER);

		add(Box.createRigidArea(new Dimension(0, 4)));
		add(filterLine);

		// wrap mainContent with scrollpane so it has a scrollbar
		JScrollPane scrollableContainer = new JScrollPane(mainContent);
		scrollableContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollableContainer.getVerticalScrollBar().setPreferredSize(new Dimension(6, 0));

		mainContent.add(fightHistoryContainer, BorderLayout.NORTH);

		add(Box.createRigidArea(new Dimension(0, 4)));
		add(scrollableContainer);
	}

	public void addFight(FightPerformance fight)
	{
		// if the nameFilter isn't blank, skip adding the fight to panels if it doesn't respect the name filter
		if (!config.nameFilter().equals("")
			&& (config.exactNameFilter() ?
				!fight.getCompetitor().getName().toLowerCase().equals(config.nameFilter())
				&& !fight.getOpponent().getName().toLowerCase().equals(config.nameFilter())
				: !fight.getCompetitor().getName().toLowerCase().startsWith(config.nameFilter())
				&& !fight.getOpponent().getName().toLowerCase().startsWith(config.nameFilter())))
		{
			return;
		}

		totalStatsPanel.addFight(fight);

		SwingUtilities.invokeLater(() ->
		{
			fightHistoryContainer.add(new FightPerformancePanel(fight), 0);

			// if we now have more fights than we want to render, then remove fights from the container in order to only render our max.
			if (fightHistoryContainer.getComponentCount() > config.fightHistoryRenderLimit())
			{
				// this will probably only remove 1 fight in most cases, but just in case we need to remove more than that.
				int numFightsToRemove = fightHistoryContainer.getComponentCount() - config.fightHistoryRenderLimit();
				for (int i = 0; i < numFightsToRemove && fightHistoryContainer.getComponentCount() > 0; i++)
				{
					// remove from the last components since we add to 0
					fightHistoryContainer.remove(fightHistoryContainer.getComponentCount() - 1);
				}
			}

			updateUI();
		});
	}

	public void addFights(ArrayList<FightPerformance> fights)
	{
		// if the nameFilter isn't blank, skip adding any fights to panels if they don't respect the name filter
		if (!config.nameFilter().equals(""))
		{
			fights.removeIf((FightPerformance f) ->
				// remove if the names aren't EQUAL when using "exactNameFilter",
				// if not then remove names that don't start with the name filter.
				config.exactNameFilter() ?
					!f.getCompetitor().getName().toLowerCase().equals(config.nameFilter())
						&& !f.getOpponent().getName().toLowerCase().equals(config.nameFilter())
					: !f.getCompetitor().getName().toLowerCase().startsWith(config.nameFilter())
					&& !f.getOpponent().getName().toLowerCase().startsWith(config.nameFilter()));
		}

		totalStatsPanel.addFights(fights);
		SwingUtilities.invokeLater(() ->
		{
			// if we're adding more fights than we want to render at all, then reduce the number of fights and clear all the existing ones
			if (fights.size() > config.fightHistoryRenderLimit())
			{
				int numFightsToRemove = fights.size() - config.fightHistoryRenderLimit();
				fights.removeIf((FightPerformance f) -> fights.indexOf(f) < numFightsToRemove);
				fightHistoryContainer.removeAll();
			}
			// if we're adding a normal number of fights, then check if we actually need to remove existing fights to make room for it.
			else
			{
				int fightsToAdd = fights.size();
				int fightsToRemove = fightHistoryContainer.getComponentCount() - config.fightHistoryRenderLimit() + fightsToAdd;

				if (fightsToRemove > 0)
				{
					// Remove oldest fightHistory until the size is equal to the limit.
					for (int i = 0; i < fightsToRemove && fightHistoryContainer.getComponentCount() > 0; i++)
					{
						// remove from the last components since we add to 0
						fightHistoryContainer.remove(fightHistoryContainer.getComponentCount() - 1);
					}
				}

			}

			fights.forEach((FightPerformance f) -> fightHistoryContainer.add(new FightPerformancePanel(f), 0));
			updateUI();
		});
	}

	public void rebuild()
	{
		totalStatsPanel.reset();
		fightHistoryContainer.removeAll();
		if (plugin.fightHistory.size() > 0)
		{
			// create new arraylist from the main one so we can't modify the fight history
			ArrayList<FightPerformance> fightsToAdd = new ArrayList<>(plugin.fightHistory);

			addFights(fightsToAdd);
		}
		SwingUtilities.invokeLater(this::updateUI);
	}

	public void setConfigWarning(boolean enable)
	{
		totalStatsPanel.setConfigWarning(enable);
	}
}
/*
 * Copyright (c) 2022, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models.oldVersions;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import matsyir.pvpperformancetracker.controllers.Fighter;

// Old stripped down version of FightPerformance, so they can be properly deserialized
// and upgraded to the newer version.
// When going from 1.5.5 -> 1.5.6, the boolean isLmsFight is updated to the FightType enum.
// the core upgrade logic is a simple constructor in FightPerformance
@Getter
public class FightPerformance__1_5_5
{
	@Expose
	@SerializedName("c") // use 1 letter serialized variable names for more compact storage
	public Fighter competitor;
	@Expose
	@SerializedName("o")
	public Fighter opponent;
	@Expose
	@SerializedName("t")
	public long lastFightTime; // last fight time saved as epochMilli timestamp (serializing an Instant was a bad time)
	@Expose
	@SerializedName("l")
	public boolean isLmsFight; // save a boolean if the fight was done in LMS, so we can know those stats/rings/ammo are used.
}
/*
 * Copyright (c) 2020, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import lombok.Getter;
import net.runelite.api.ItemID;

@Getter
public enum RingData
{
	SEERS_RING("Seers Ring", ItemID.SEERS_RING),
	ARCHERS_RING("Archers Ring", ItemID.ARCHERS_RING),
	BERSERKER_RING("Berserker Ring", ItemID.BERSERKER_RING),
	RING_OF_SUFFERING("Ring of Suffering", ItemID.RING_OF_SUFFERING),
	SEERS_RING_I("Seers Ring (i)", ItemID.SEERS_RING_I),
	ARCHERS_RING_I("Archers Ring (i)", ItemID.ARCHERS_RING_I),
	BERSERKER_RING_I("Berserker Ring (i)", ItemID.BERSERKER_RING_I),
	RING_OF_SUFFERING_I("Ring of Suffering (i)", ItemID.RING_OF_SUFFERING_I),
	BRIMSTONE_RING("Brimstone Ring", ItemID.BRIMSTONE_RING),
	MAGUS_RING("Magus ring", ItemID.MAGUS_RING),
	VENATOR_RING("Venator ring", ItemID.VENATOR_RING),
	BELLATOR_RING("Bellator ring", ItemID.BELLATOR_RING),
	ULTOR_RING("Ultor ring", ItemID.ULTOR_RING),
	RING_OF_SHADOWS("Ring of Shadows", ItemID.RING_OF_SHADOWS),
	NONE("None", -1);

	private String name;
	private int itemId;

	RingData(String name, int itemId)
	{
		this.name = name;
		this.itemId = itemId;
	}

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package matsyir.pvpperformancetracker.models;

import org.apache.commons.lang3.ArrayUtils;

public enum FightType
{
	LMS_MAXMED(new CombatLevels(118, 118, 75, 112, 99, 99)),
	LMS_ZERK(new CombatLevels(91, 118, 45, 112, 99, 99)),
	LMS_1DEF(new CombatLevels(91, 118, 1, 112, 99, 99)),
	NORMAL(CombatLevels.getConfigLevels());

	private static FightType[] LMS_TYPES = { LMS_MAXMED, LMS_ZERK, LMS_1DEF };

	private CombatLevels combatLevelsForType;
	FightType(CombatLevels combatLevelsForType)
	{
		this.combatLevelsForType = combatLevelsForType;
	}

	public CombatLevels getCombatLevelsForType()
	{
		if (this == NORMAL)
		{
			return CombatLevels.getConfigLevels();
		}

		return combatLevelsForType;
	}

	public boolean isLmsFight()
	{
		return ArrayUtils.contains(LMS_TYPES, this);
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.CONFIG;
import net.runelite.api.Client;
import net.runelite.api.Skill;

// Basic class that will be used to save current combat levels (including boosts/drains)
@Getter
public class CombatLevels
{
	public static CombatLevels getConfigLevels()
	{
		return new CombatLevels(CONFIG.attackLevel(),
			CONFIG.strengthLevel(),
			CONFIG.defenceLevel(),
			CONFIG.rangedLevel(),
			CONFIG.magicLevel(),
			99);
	}

	@Expose
	@SerializedName("a")
	public int atk;
	@Expose
	@SerializedName("s")
	public int str;
	@Expose
	@SerializedName("d")
	public int def;
	@Expose
	@SerializedName("r")
	public int range;
	@Expose
	@SerializedName("m")
	public int mage;
	@Expose
	@SerializedName("h")
	public int hp; // not currently used but potential dh support in future?

	public CombatLevels(int atk, int str, int def, int range, int mage, int hp)
	{
		this.atk = atk;
		this.str = str;
		this.def = def;
		this.range = range;
		this.mage = mage;
		this.hp = hp;
	}

	public CombatLevels(Client client)
	{
		this.atk = client.getBoostedSkillLevel(Skill.ATTACK);
		this.str = client.getBoostedSkillLevel(Skill.STRENGTH);
		this.def = client.getBoostedSkillLevel(Skill.DEFENCE);
		this.range = client.getBoostedSkillLevel(Skill.RANGED);
		this.mage = client.getBoostedSkillLevel(Skill.MAGIC);
		this.hp = client.getBoostedSkillLevel(Skill.HITPOINTS);
	}

	public int getSkill(Skill skill)
	{
		switch(skill)
		{
			case ATTACK:    return atk;
			case STRENGTH:  return str;
			case DEFENCE:   return def;
			case RANGED:    return range;
			case MAGIC:     return mage;
			case HITPOINTS: return hp;
			default:        return 0;
		}
	}
}

/*
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * Copyright (c) 2020, Matsyir <https://github.com/matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;
import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin;
import net.runelite.api.ItemID;
import net.runelite.api.kit.KitType;
import org.apache.commons.lang3.ArrayUtils;

// Mostly to help fetch LMS gear stats, since LMS items are copies of real items, so their stats aren't
// cached like most items. Each LMS item will have the 'real' itemId so the stats can be looked up.
// A few non-LMS range weapons will be saved in order to help estimate ammo type/range strength based
// on current weapon itemId, or to determine special attacks used.
public enum EquipmentData
{
	// Non-LMS items:
	DRAGON_CROSSBOW(ItemID.DRAGON_CROSSBOW),
	DRAGON_HUNTER_CROSSBOW(ItemID.DRAGON_HUNTER_CROSSBOW),
	MAGIC_SHORTBOW(ItemID.MAGIC_SHORTBOW),
	MAGIC_SHORTBOW_I(ItemID.MAGIC_SHORTBOW_I),
	TOXIC_BLOWPIPE(ItemID.TOXIC_BLOWPIPE),
	VOLATILE_NIGHTMARE_STAFF(ItemID.VOLATILE_NIGHTMARE_STAFF),
	//CRAWS_BOW(22550), // ammo bonus is built into weapon so we don't need to include it
	SMOKE_BATTLESTAFF(ItemID.SMOKE_BATTLESTAFF),
	VOID_MAGE_HELM(ItemID.VOID_MAGE_HELM, ItemID.VOID_MAGE_HELM_L),
	VOID_RANGE_HELM(ItemID.VOID_RANGER_HELM, ItemID.VOID_RANGER_HELM_L),
	VOID_MELEE_HELM(ItemID.VOID_MELEE_HELM, ItemID.VOID_MELEE_HELM_L),
	VOID_ELITE_BODY(ItemID.ELITE_VOID_TOP, ItemID.ELITE_VOID_TOP_L),
	VOID_ELITE_LEGS(ItemID.ELITE_VOID_ROBE, ItemID.ELITE_VOID_ROBE_L),
	VOID_GLOVES(ItemID.VOID_KNIGHT_GLOVES, ItemID.VOID_KNIGHT_GLOVES_L),
	VOID_BODY(ItemID.VOID_KNIGHT_TOP, ItemID.VOID_KNIGHT_TOP_L),
	VOID_LEGS(ItemID.VOID_KNIGHT_ROBE, ItemID.VOID_KNIGHT_ROBE_L),
	CRYSTAL_HELM(ItemID.CRYSTAL_HELM),
	CRYSTAL_BODY(ItemID.CRYSTAL_BODY),
	CRYSTAL_LEGS(ItemID.CRYSTAL_LEGS),
	CRYSTAL_BOW(ItemID.CRYSTAL_BOW_FULL, ItemID.CRYSTAL_BOW, ItemID.CRYSTAL_BOW_110, ItemID.CRYSTAL_BOW_210, ItemID.CRYSTAL_BOW_310, ItemID.CRYSTAL_BOW_410, ItemID.CRYSTAL_BOW_510, ItemID.CRYSTAL_BOW_610, ItemID.CRYSTAL_BOW_710, ItemID.CRYSTAL_BOW_810, ItemID.CRYSTAL_BOW_910),
	CRYSTAL_BOW_I(ItemID.CRYSTAL_BOW_FULL_I, ItemID.CRYSTAL_BOW_110_I, ItemID.CRYSTAL_BOW_210_I, ItemID.CRYSTAL_BOW_310_I, ItemID.CRYSTAL_BOW_410_I, ItemID.CRYSTAL_BOW_510_I, ItemID.CRYSTAL_BOW_610_I, ItemID.CRYSTAL_BOW_710_I, ItemID.CRYSTAL_BOW_810_I, ItemID.CRYSTAL_BOW_910_I),
	DRAGON_LONGSWORD(ItemID.DRAGON_LONGSWORD),
	OSMUMTENS_FANG(ItemID.OSMUMTENS_FANG),

	// LMS items:
	RUNE_CROSSBOW(ItemID.RUNE_CROSSBOW, ItemID.RUNE_CROSSBOW_23601),
	ARMADYL_CROSSBOW(ItemID.ARMADYL_CROSSBOW, ItemID.ARMADYL_CROSSBOW_23611),
	DARK_BOW(ItemID.DARK_BOW, ItemID.DARK_BOW_20408, ItemID.DARK_BOW_12765, ItemID.DARK_BOW_12766, ItemID.DARK_BOW_12767, ItemID.DARK_BOW_12768),
	HEAVY_BALLISTA(ItemID.HEAVY_BALLISTA, ItemID.HEAVY_BALLISTA_23630),

	STATIUS_WARHAMMER(ItemID.STATIUSS_WARHAMMER, ItemID.STATIUSS_WARHAMMER_23620),
	VESTAS_LONGSWORD(ItemID.VESTAS_LONGSWORD, ItemID.VESTAS_LONGSWORD_23615, ItemID.VESTAS_BLIGHTED_LONGSWORD),
	ARMADYL_GODSWORD(ItemID.ARMADYL_GODSWORD, ItemID.ARMADYL_GODSWORD_20593, ItemID.ARMADYL_GODSWORD_OR),
	DRAGON_CLAWS(ItemID.DRAGON_CLAWS, ItemID.DRAGON_CLAWS_20784),
	DRAGON_DAGGER(ItemID.DRAGON_DAGGER, ItemID.DRAGON_DAGGER_20407, ItemID.DRAGON_DAGGERP, ItemID.DRAGON_DAGGERP_5680, ItemID.DRAGON_DAGGERP_5698),
	GRANITE_MAUL(ItemID.GRANITE_MAUL, ItemID.GRANITE_MAUL_12848, ItemID.GRANITE_MAUL_20557, ItemID.GRANITE_MAUL_24225, ItemID.GRANITE_MAUL_24227),
	AMULET_OF_FURY(ItemID.AMULET_OF_FURY, ItemID.AMULET_OF_FURY_23640),
	BANDOS_TASSETS(ItemID.BANDOS_TASSETS, ItemID.BANDOS_TASSETS_23646),
	BLESSED_SPIRIT_SHIELD(ItemID.BLESSED_SPIRIT_SHIELD, ItemID.BLESSED_SPIRIT_SHIELD_23642),
	DHAROKS_HELM(ItemID.DHAROKS_HELM, ItemID.DHAROKS_HELM_23639),
	DHAROKS_PLATELEGS(ItemID.DHAROKS_PLATELEGS, ItemID.DHAROKS_PLATELEGS_23633),
	GUTHANS_HELM(ItemID.GUTHANS_HELM, ItemID.GUTHANS_HELM_23638),
	KARILS_TOP(ItemID.KARILS_LEATHERTOP, ItemID.KARILS_LEATHERTOP_23632),
	TORAGS_HELM(ItemID.TORAGS_HELM, ItemID.TORAGS_HELM_23637),
	TORAGS_PLATELEGS(ItemID.TORAGS_PLATELEGS, ItemID.TORAGS_PLATELEGS_23634),
	VERACS_HELM(ItemID.VERACS_HELM, ItemID.VERACS_HELM_23636),
	VERACS_PLATESKIRT(ItemID.VERACS_PLATESKIRT, ItemID.VERACS_PLATESKIRT_23635),
	MORRIGANS_JAVELIN(ItemID.MORRIGANS_JAVELIN, ItemID.MORRIGANS_JAVELIN_23619),
	SPIRIT_SHIELD(ItemID.SPIRIT_SHIELD, ItemID.SPIRIT_SHIELD_23599),
	HELM_OF_NEITIZNOT(ItemID.HELM_OF_NEITIZNOT, ItemID.HELM_OF_NEITIZNOT_23591),
	AMULET_OF_GLORY(ItemID.AMULET_OF_GLORY, ItemID.AMULET_OF_GLORY_20586),
	ABYSSAL_WHIP(ItemID.ABYSSAL_WHIP, ItemID.ABYSSAL_WHIP_20405),
	DRAGON_DEFENDER(ItemID.DRAGON_DEFENDER, ItemID.DRAGON_DEFENDER_23597),
	BLACK_DHIDE_BODY(ItemID.BLACK_DHIDE_BODY, ItemID.BLACK_DHIDE_BODY_20423),
	RUNE_PLATELEGS(ItemID.RUNE_PLATELEGS, ItemID.RUNE_PLATELEGS_20422),
	CLIMBING_BOOTS(ItemID.CLIMBING_BOOTS, ItemID.CLIMBING_BOOTS_20578),
	BARROWS_GLOVES(ItemID.BARROWS_GLOVES, ItemID.BARROWS_GLOVES_23593),
	ELDER_MAUL(ItemID.ELDER_MAUL, ItemID.ELDER_MAUL_21205),
	INFERNAL_CAPE(ItemID.INFERNAL_CAPE, ItemID.INFERNAL_CAPE_23622),
	GHRAZI_RAPIER(ItemID.GHRAZI_RAPIER, ItemID.GHRAZI_RAPIER_23628),

	ZURIELS_STAFF(ItemID.ZURIELS_STAFF, ItemID.ZURIELS_STAFF_23617),
	STAFF_OF_THE_DEAD(ItemID.STAFF_OF_THE_DEAD, ItemID.STAFF_OF_THE_DEAD_23613),
	KODAI_WAND(ItemID.KODAI_WAND, ItemID.KODAI_WAND_23626),
	AHRIMS_STAFF(ItemID.AHRIMS_STAFF, ItemID.AHRIMS_STAFF_23653),
	MYSTIC_ROBE_TOP(ItemID.MYSTIC_ROBE_TOP, ItemID.MYSTIC_ROBE_TOP_20425, ItemID.MYSTIC_ROBE_TOP_DARK_27158, ItemID.MYSTIC_ROBE_TOP_LIGHT_27160),
	MYSTIC_ROBE_BOTTOM(ItemID.MYSTIC_ROBE_BOTTOM, ItemID.MYSTIC_ROBE_BOTTOM_20426, ItemID.MYSTIC_ROBE_BOTTOM_DARK_27159, ItemID.MYSTIC_ROBE_BOTTOM_LIGHT_27161),
	AHRIMS_ROBE_TOP(ItemID.AHRIMS_ROBETOP, ItemID.AHRIMS_ROBETOP_20598),
	AHRIMS_ROBE_SKIRT(ItemID.AHRIMS_ROBESKIRT, ItemID.AHRIMS_ROBESKIRT_20599),
	OCCULT_NECKLACE(ItemID.OCCULT_NECKLACE, ItemID.OCCULT_NECKLACE_23654),
	MAGES_BOOK(ItemID.MAGES_BOOK, ItemID.MAGES_BOOK_23652),
	ETERNAL_BOOTS(ItemID.ETERNAL_BOOTS, ItemID.ETERNAL_BOOTS_23644),
	IMBUED_ZAMORAK_CAPE(ItemID.IMBUED_ZAMORAK_CAPE, ItemID.IMBUED_ZAMORAK_CAPE_23605),
	IMBUED_GUTHIX_CAPE(ItemID.IMBUED_GUTHIX_CAPE, ItemID.IMBUED_GUTHIX_CAPE_23603),
	IMBUED_SARADOMIN_CAPE(ItemID.IMBUED_SARADOMIN_CAPE, ItemID.IMBUED_SARADOMIN_CAPE_23607),

	TOME_OF_FIRE(ItemID.TOME_OF_FIRE, ItemID.TOME_OF_FIRE_27358), // (charged tome)
	WIZARD_BOOTS(ItemID.WIZARD_BOOTS, ItemID.WIZARD_BOOTS_27162),
	GUTHIX_HALO(ItemID.GUTHIX_HALO, ItemID.GUTHIX_HALO_27163),
	ZAMORAK_HALO(ItemID.ZAMORAK_HALO, ItemID.ZAMORAK_HALO_27164),
	SARADOMIN_HALO(ItemID.SARADOMIN_HALO, ItemID.SARADOMIN_HALO_27165),
	GHOSTLY_HOOD(ItemID.GHOSTLY_HOOD, ItemID.GHOSTLY_HOOD_27166),
	GHOSTLY_ROBETOP(ItemID.GHOSTLY_ROBE, ItemID.GHOSTLY_ROBE_27167),
	GHOSTLY_ROBE(ItemID.GHOSTLY_ROBE_6108, ItemID.GHOSTLY_ROBE_27168),
	BERSERKER_HELM(ItemID.BERSERKER_HELM, ItemID.BERSERKER_HELM_27169),
	INFINITY_BOOTS(ItemID.INFINITY_BOOTS, ItemID.INFINITY_BOOTS_27170),
	TORMENTED_BRACELET(ItemID.TORMENTED_BRACELET, ItemID.TORMENTED_BRACELET_27171),
	NECKLACE_OF_ANGUISH(ItemID.NECKLACE_OF_ANGUISH, ItemID.NECKLACE_OF_ANGUISH_27172, ItemID.NECKLACE_OF_ANGUISH_OR),
	ELDER_CHAOS_TOP(ItemID.ELDER_CHAOS_TOP, ItemID.ELDER_CHAOS_TOP_27174, ItemID.ELDER_CHAOS_TOP_OR),
	ELDER_CHAOS_ROBE(ItemID.ELDER_CHAOS_ROBE, ItemID.ELDER_CHAOS_ROBE_27175, ItemID.ELDER_CHAOS_ROBE_OR),
	ELDER_CHAOS_HOOD(ItemID.ELDER_CHAOS_HOOD, ItemID.ELDER_CHAOS_HOOD_27176, ItemID.ELDER_CHAOS_HOOD_OR),
	FREMENNIK_KILT(ItemID.FREMENNIK_KILT, ItemID.FREMENNIK_KILT_27177),
	SPIKED_MANACLES(ItemID.SPIKED_MANACLES, ItemID.SPIKED_MANACLES_27178),
	RANGERS_TUNIC(ItemID.RANGERS_TUNIC, ItemID.RANGERS_TUNIC_27179),
	GUTHIX_CHAPS(ItemID.GUTHIX_CHAPS, ItemID.GUTHIX_CHAPS_27180),
	ZAMORAK_CHAPS(ItemID.ZAMORAK_CHAPS, ItemID.ZAMORAK_CHAPS_27181),
	SARADOMIN_CHAPS(ItemID.SARADOMIN_CHAPS, ItemID.SARADOMIN_CHAPS_27182),
	_3RD_AGE_MAGE_HAT(ItemID._3RD_AGE_MAGE_HAT, ItemID._3RD_AGE_MAGE_HAT_27183),
	ANCIENT_GODSWORD(ItemID.ANCIENT_GODSWORD, ItemID.ANCIENT_GODSWORD_27184),
	RUNE_DEFENDER(ItemID.RUNE_DEFENDER, ItemID.RUNE_DEFENDER_27185),
	ZARYTE_CROSSBOW(ItemID.ZARYTE_CROSSBOW, ItemID.ZARYTE_CROSSBOW_27186),
	BOW_OF_FAERDHINEN(ItemID.BOW_OF_FAERDHINEN, ItemID.BOW_OF_FAERDHINEN_C, ItemID.BOW_OF_FAERDHINEN_C_25869, ItemID.BOW_OF_FAERDHINEN_C_25884, ItemID.BOW_OF_FAERDHINEN_C_25886, ItemID.BOW_OF_FAERDHINEN_C_25888, ItemID.BOW_OF_FAERDHINEN_C_25890, ItemID.BOW_OF_FAERDHINEN_C_25892, ItemID.BOW_OF_FAERDHINEN_C_25894, ItemID.BOW_OF_FAERDHINEN_C_25896, ItemID.BOW_OF_FAERDHINEN_27187),
	LIGHT_BALLISTA(ItemID.LIGHT_BALLISTA, ItemID.LIGHT_BALLISTA_27188),
	VERACS_FLAIL(ItemID.VERACS_FLAIL, ItemID.VERACS_FLAIL_27189),
	VERACS_BRASSARD(ItemID.VERACS_BRASSARD, ItemID.VERACS_BRASSARD_27190),
	UNHOLY_BOOK(ItemID.UNHOLY_BOOK, ItemID.UNHOLY_BOOK_27191),
	// hmmmm OPAL_DRAGON_BOLTS_E(ItemID.OPAL_DRAGON_BOLTS_E, ItemID.OPAL_DRAGON_BOLTS_E_27192)
	ANCESTRAL_ROBE_TOP(ItemID.ANCESTRAL_ROBE_TOP, ItemID.ANCESTRAL_ROBE_TOP_27193, ItemID.TWISTED_ANCESTRAL_ROBE_TOP),
	ANCESTRAL_ROBE_BOTTOM(ItemID.ANCESTRAL_ROBE_BOTTOM, ItemID.ANCESTRAL_ROBE_BOTTOM_27194, ItemID.TWISTED_ANCESTRAL_ROBE_BOTTOM),
	INQUISITORS_GREAT_HELM(ItemID.INQUISITORS_GREAT_HELM, ItemID.INQUISITORS_GREAT_HELM_27195),
	INQUISITORS_HAUBERK(ItemID.INQUISITORS_HAUBERK, ItemID.INQUISITORS_HAUBERK_27196),
	INQUISITORS_PLATESKIRT(ItemID.INQUISITORS_PLATESKIRT, ItemID.INQUISITORS_PLATESKIRT_27197),
	INQUISITORS_MACE(ItemID.INQUISITORS_MACE, ItemID.INQUISITORS_MACE_27198),
	_3RD_AGE_RANGE_TOP(ItemID._3RD_AGE_RANGE_TOP, ItemID._3RD_AGE_RANGE_TOP_27199),
	_3RD_AGE_RANGE_LEGS(ItemID._3RD_AGE_RANGE_LEGS, ItemID._3RD_AGE_RANGE_LEGS_27200),
	_3RD_AGE_RANGE_COIF(ItemID._3RD_AGE_RANGE_COIF, ItemID._3RD_AGE_RANGE_COIF_27201),

	DRAGON_WARHAMMER(ItemID.DRAGON_WARHAMMER, ItemID.DRAGON_WARHAMMER_20785),
	VOIDWAKER(ItemID.VOIDWAKER, ItemID.VOIDWAKER_27869),

	DUAL_MACUAHUITL(ItemID.DUAL_MACUAHUITL, ItemID.DUAL_MACUAHUITL_29850),
	BLOOD_MOON_CHESTPLATE(ItemID.BLOOD_MOON_CHESTPLATE, ItemID.BLOOD_MOON_CHESTPLATE_29846),
	BLOOD_MOON_HELM(ItemID.BLOOD_MOON_HELM, ItemID.BLOOD_MOON_HELM_29848),
	BLOOD_MOON_TASSETS(ItemID.BLOOD_MOON_TASSETS, ItemID.BLOOD_MOON_TASSETS_29847),
	BLUE_MOON_SPEAR(ItemID.BLUE_MOON_SPEAR, ItemID.BLUE_MOON_SPEAR_29849),
	BLUE_MOON_CHESTPLATE(ItemID.BLUE_MOON_CHESTPLATE, ItemID.BLUE_MOON_CHESTPLATE_29843),
	BLUE_MOON_HELM(ItemID.BLUE_MOON_HELM, ItemID.BLUE_MOON_HELM_29845),
	BLUE_MOON_TASSETS(ItemID.BLUE_MOON_TASSETS, ItemID.BLUE_MOON_TASSETS_29844),
	ECLIPSE_ATLATL(ItemID.ECLIPSE_ATLATL, ItemID.ECLIPSE_ATLATL_29851),
	ECLIPSE_MOON_CHESTPLATE(ItemID.ECLIPSE_MOON_CHESTPLATE, ItemID.ECLIPSE_MOON_CHESTPLATE_29840),
	ECLIPSE_MOON_HELM(ItemID.ECLIPSE_MOON_HELM, ItemID.ECLIPSE_MOON_HELM_29842),
	ECLIPSE_MOON_TASSETS(ItemID.ECLIPSE_MOON_TASSETS, ItemID.ECLIPSE_MOON_TASSETS_29841),
	;

	private static final Map<Integer, EquipmentData> itemData = new HashMap<>();

	@Getter
	private final int itemId; // main id to be used for stat lookups
	@Getter
	private final int[] additionalIds; // extra ids that might represent the same item (like LMS versions, or a dragon dagger(p) = dds, or charged items etc)

	EquipmentData(int itemId)
	{
		this.itemId = itemId;
		this.additionalIds = null;
	}

	EquipmentData(int itemId, int... itemIds)
	{
		this.itemId = itemId;
		this.additionalIds = itemIds;
	}

	// Get the saved EquipmentData for a given itemId (could be null)
	public static EquipmentData fromId(int itemId)
	{
		return itemData.get(itemId);
	}

	// get currently selected weapon ammo, based on weapon used & configured bolt choice.
	public static RangeAmmoData getWeaponAmmo(EquipmentData weapon)
	{
		if (ArrayUtils.contains(RangeAmmoData.BoltAmmo.WEAPONS_USING, weapon))
		{
			return PvpPerformanceTrackerPlugin.CONFIG.boltChoice();
		}
		else if (ArrayUtils.contains(RangeAmmoData.StrongBoltAmmo.WEAPONS_USING, weapon))
		{
			return PvpPerformanceTrackerPlugin.CONFIG.strongBoltChoice();
		}
		else if (ArrayUtils.contains(RangeAmmoData.DartAmmo.WEAPONS_USING, weapon))
		{
			return PvpPerformanceTrackerPlugin.CONFIG.bpDartChoice();
		}
		else if (weapon == HEAVY_BALLISTA || weapon == LIGHT_BALLISTA)
		{
			return RangeAmmoData.OtherAmmo.DRAGON_JAVELIN;
		}
		else if (weapon == DARK_BOW)
		{
			return RangeAmmoData.OtherAmmo.DRAGON_ARROW;
		}
		else if (weapon == MAGIC_SHORTBOW || weapon == MAGIC_SHORTBOW_I)
		{
			return RangeAmmoData.OtherAmmo.AMETHYST_ARROWS;
		}

		return null;
	}

	static
	{
		for (EquipmentData data : EquipmentData.values())
		{
			itemData.putIfAbsent(data.getItemId(), data);
			if (data.additionalIds != null && data.additionalIds.length > 0)
			{
				for (int id : data.additionalIds)
				{
					itemData.putIfAbsent(id, data);
				}
			}
		}
	}

	public enum VoidStyle
	{
		VOID_MELEE(1.1, 1.1),
		VOID_RANGE(1.1, 1.1),
		VOID_MAGE(1.45, 1),
		VOID_ELITE_MELEE(1.1, 1.1),
		VOID_ELITE_RANGE(1.125, 1.125),
		VOID_ELITE_MAGE(1.45, 1.025),
		NONE(1, 1);

		public double accuracyModifier;
		public double dmgModifier;

		VoidStyle(double accuracyModifier, double dmgModifier)
		{
			this.accuracyModifier = accuracyModifier;
			this.dmgModifier = dmgModifier;
		}

		// return a void style for a given PlayerComposition
		public static VoidStyle getVoidStyleFor(int[] playerComposition)
		{
			if (playerComposition == null) { return NONE; }
			playerComposition = PvpPerformanceTrackerPlugin.fixItemIds(playerComposition);

			EquipmentData gloves = EquipmentData.fromId(playerComposition[KitType.HANDS.getIndex()]);

			if (gloves != EquipmentData.VOID_GLOVES) { return NONE; }

			EquipmentData helm = EquipmentData.fromId(playerComposition[KitType.HEAD.getIndex()]);
			EquipmentData torso = EquipmentData.fromId(playerComposition[KitType.TORSO.getIndex()]);
			EquipmentData legs = EquipmentData.fromId(playerComposition[KitType.LEGS.getIndex()]);

			if (torso == EquipmentData.VOID_BODY && legs == EquipmentData.VOID_LEGS)
			{
				return helm == EquipmentData.VOID_MAGE_HELM ? VOID_MAGE
					: helm == EquipmentData.VOID_RANGE_HELM ? VOID_RANGE
					: helm == EquipmentData.VOID_MELEE_HELM ? VOID_MELEE
					: NONE;
			}
			else if (torso == EquipmentData.VOID_ELITE_BODY && legs == EquipmentData.VOID_ELITE_LEGS)
			{
				return helm == EquipmentData.VOID_MAGE_HELM ? VOID_ELITE_MAGE
					: helm == EquipmentData.VOID_RANGE_HELM ? VOID_ELITE_RANGE
					: helm == EquipmentData.VOID_MELEE_HELM ? VOID_ELITE_MELEE
					: NONE;
			}

			return NONE;
		}
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;
import java.awt.Color;
import java.math.RoundingMode;
import java.text.NumberFormat;
import java.time.Instant;
import lombok.Getter;
import lombok.Setter;
import matsyir.pvpperformancetracker.controllers.PvpDamageCalc;
import static matsyir.pvpperformancetracker.PvpPerformanceTrackerPlugin.PLUGIN;
import net.runelite.api.GraphicID;
import net.runelite.api.HeadIcon;
import net.runelite.api.Player;
import net.runelite.client.chat.ChatMessageBuilder;
import org.apache.commons.text.WordUtils;

// A fight log entry for a single Fighter. Will be saved in a List of FightLogEntries in the Fighter class.
@Getter
public class FightLogEntry implements Comparable<FightLogEntry>
{
	public static final NumberFormat nf;
	static
	{
		nf = NumberFormat.getInstance();
		nf.setRoundingMode(RoundingMode.HALF_UP);
		nf.setMaximumFractionDigits(2);
	}

	// general data
	// don't expose attacker name since it is present in the parent class (Fighter), so it is
	// redundant use of storage
	public String attackerName;
	@Expose
	@SerializedName("t")
	private long time;

	@Setter
	@Expose
	@SerializedName("T")
	private int tick;

	// this boolean represents if this is a "complete" fight log entry or not.
	// if a fight log entry is full/complete, then it has all attack data.
	// an "incomplete" fight log entry means it's only holding the current attacker's defensive stats to be used with
	// an opposing attack, to be matched up with fight analysis/data merging
	// very rough way to do this but itll work
	@Expose
	@SerializedName("f")
	private boolean isFullEntry;


	// attacker data
	@Expose
	@SerializedName("G")
	// current attacker's gear. The attacker is not necessarily the competitor.
	// Set using PlayerComposition::getEquipmentIds
	private int[] attackerGear;
	@Expose
	@SerializedName("O")
	private HeadIcon attackerOverhead;
	@Expose
	@SerializedName("m") // m because movement?
	private AnimationData animationData;
	@Expose
	@SerializedName("d")
	private double deservedDamage;
	@Expose
	@SerializedName("a")
	private double accuracy;
	@Expose
	@SerializedName("h") // h for highest hit
	private int maxHit;
	@Expose
	@SerializedName("l") // l for lowest hit
	private int minHit;
	@Expose
	@SerializedName("s")
	private boolean splash; // true if it was a magic attack and it splashed

	@Expose
	@SerializedName("C")
	private CombatLevels attackerLevels; // CAN BE NULL


	// defender data
	@Expose
	@SerializedName("g")
	private int[] defenderGear;
	@Expose
	@SerializedName("o")
	private HeadIcon defenderOverhead;

	@Expose
	@SerializedName("p")
	private int attackerOffensivePray; // offensive pray saved as SpriteID since that's all we use it for.

	public FightLogEntry(Player attacker, Player defender, PvpDamageCalc pvpDamageCalc, int attackerOffensivePray, CombatLevels levels, AnimationData animationData)
	{
		this.isFullEntry = true;

		// general
		this.attackerName = attacker.getName();
		this.time = Instant.now().toEpochMilli();
		this.tick = PLUGIN.getClient().getTickCount();

		this.animationData = animationData;

		// attacker data
		this.attackerGear = attacker.getPlayerComposition().getEquipmentIds();
		this.attackerOverhead = attacker.getOverheadIcon();

		this.deservedDamage = pvpDamageCalc.getAverageHit();
		this.accuracy = pvpDamageCalc.getAccuracy();
		this.minHit = pvpDamageCalc.getMinHit();
		this.maxHit = pvpDamageCalc.getMaxHit();
		this.splash = animationData.attackStyle == AnimationData.AttackStyle.MAGIC && defender.getGraphic() == GraphicID.SPLASH;
		this.attackerLevels = levels; // CAN BE NULL

		// defender data
		this.defenderGear = defender.getPlayerComposition().getEquipmentIds();
		this.defenderOverhead = defender.getOverheadIcon();
		this.attackerOffensivePray = attackerOffensivePray;
	}

	// create incomplete entry to save competitor's defensive stats which are only client side
	// in this context, the "attacker" is not attacking, only defending.
	public FightLogEntry(String attackerName, CombatLevels levels, int attackerOffensivePray)
	{
		this.isFullEntry = false;

		this.attackerName = attackerName;
		this.time = Instant.now().toEpochMilli();
		this.tick = PLUGIN.getClient().getTickCount();

		this.attackerLevels = levels;
		this.attackerOffensivePray = attackerOffensivePray;
	}

	// create new fightlogentry based on existing entry but new damage calcs (for fight analysis/stat merging)
	public FightLogEntry(FightLogEntry e, PvpDamageCalc pvpDamageCalc)
	{
		this.isFullEntry = true;

		// general
		this.attackerName = e.attackerName;
		this.time = e.time;
		this.tick = e.tick;

		// attacker data
		this.attackerGear = e.attackerGear;
		this.attackerOverhead = e.attackerOverhead;
		this.animationData = e.animationData;
		this.deservedDamage = pvpDamageCalc.getAverageHit();
		this.accuracy = pvpDamageCalc.getAccuracy();
		this.minHit = pvpDamageCalc.getMinHit();
		this.maxHit = pvpDamageCalc.getMaxHit();
		this.splash = e.splash;
		this.attackerLevels = e.attackerLevels;

		// defender data
		this.defenderGear = e.defenderGear;
		this.defenderOverhead = e.defenderOverhead;
		this.attackerOffensivePray = e.attackerOffensivePray;
	}

	// randomized entry used for testing
	public FightLogEntry(int [] attackerGear, int deservedDamage, double accuracy, int minHit, int maxHit, int [] defenderGear, String attackerName)
	{
		this.attackerName = attackerName;
		this.attackerGear = attackerGear;
		this.attackerOverhead = HeadIcon.MAGIC;
		this.animationData = Math.random() <= 0.5 ? AnimationData.MELEE_DAGGER_SLASH : AnimationData.MAGIC_ANCIENT_MULTI_TARGET;
		this.deservedDamage = deservedDamage;
		this.accuracy = accuracy;
		this.minHit = minHit;
		this.maxHit = maxHit;
		this.splash = Math.random() >= 0.5;
		this.time = Instant.now().toEpochMilli();
		this.defenderGear = defenderGear;
		this.defenderOverhead = HeadIcon.MAGIC;
	}


	public boolean success()
	{
		return animationData.attackStyle.getProtection() != defenderOverhead;
	}

	public String toChatMessage()
	{
		Color darkRed = new Color(127, 0, 0); // same color as default clan chat color
		return new ChatMessageBuilder()
			.append(darkRed, attackerName + ": ")
			.append(Color.BLACK, "Style: ")
			.append(darkRed, WordUtils.capitalizeFully(animationData.attackStyle.toString()))
			.append(Color.BLACK, "  Hit: ")
			.append(darkRed, getHitRange())
			.append(Color.BLACK, "  Acc: ")
			.append(darkRed, nf.format(accuracy))
			.append(Color.BLACK, "  AvgHit: ")
			.append(darkRed, nf.format(deservedDamage))
			.append(Color.BLACK, " Spec?: ")
			.append(darkRed, animationData.isSpecial ? "Y" : "N")
			.append(Color.BLACK, " OffP?:")
			.append(darkRed, success() ? "Y" : "N")
			.build();
	}

	public String getHitRange()
	{
		return minHit + "-" + maxHit;
	}

	// use to sort by last fight time, to sort fights by date/time.
	@Override
	public int compareTo(FightLogEntry o)
	{
		long diff = tick - o.tick;

		// if diff = 0, return 0. Otherwise, divide diff by its absolute value. This will result in
		// -1 for negative numbers, and 1 for positive numbers, keeping the sign and a safely small int.
		return diff == 0 ? 0 :
			(int)(diff / Math.abs(diff));
	}
}

/*
 * Copyright (c) 2021, Matsyir <https://github.com/matsyir>
 * Copyright (c) 2020, Mazhar <https://twitter.com/maz_rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import com.google.common.collect.ImmutableMap;
import java.security.InvalidParameterException;
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;
import lombok.Getter;
import net.runelite.api.HeadIcon;
import net.runelite.api.SpriteID;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;

public enum AnimationData
{
	// MELEE
	MELEE_VIGGORAS_CHAINMACE(245, AttackStyle.CRUSH),
	MELEE_DAGGER_SLASH(376, AttackStyle.SLASH), // tested w/ dds
	MELEE_SPEAR_STAB(381, AttackStyle.STAB), // tested w/ zammy hasta
	MELEE_SWORD_STAB(386, AttackStyle.STAB), // tested w/ dragon sword, obby sword, d long
	MELEE_SCIM_SLASH(390, AttackStyle.SLASH), // tested w/ rune & dragon scim, d sword, VLS, obby sword, voidwaker

	MELEE_FANG_STAB(9471, AttackStyle.STAB), // tested w/ fang
	MELEE_FANG_SPEC(6118, AttackStyle.STAB, true), // tested w/ fang spec

	MELEE_GENERIC_SLASH(393, AttackStyle.SLASH), // tested w/ zuriel's staff, d long slash, dclaws regular slash
	MELEE_STAFF_CRUSH(0, AttackStyle.SLASH), // 393 previously, save name to support old fights but no longer track

	MELEE_BATTLEAXE_SLASH(395, AttackStyle.SLASH), // tested w/ rune baxe
	MELEE_MACE_STAB(400, AttackStyle.STAB), // tested w/ d mace
	MELEE_BATTLEAXE_CRUSH(401, AttackStyle.CRUSH), // tested w/ rune baxe, dwh & statius warhammer animation, d mace
	MELEE_2H_CRUSH(406, AttackStyle.CRUSH), // tested w/ rune & dragon 2h
	MELEE_2H_SLASH(407, AttackStyle.SLASH), // tested w/ rune & dragon 2h
	MELEE_STAFF_CRUSH_2(414, AttackStyle.CRUSH), // tested w/ ancient staff, 3rd age wand
	MELEE_STAFF_CRUSH_3(419, AttackStyle.CRUSH), // Common staff crush. Air/fire/etc staves, smoke battlestaff, SOTD/SOL crush, zammy hasta crush
	MELEE_PUNCH(422, AttackStyle.CRUSH),
	MELEE_KICK(423, AttackStyle.CRUSH),
	MELEE_STAFF_STAB(428, AttackStyle.STAB), // tested w/ SOTD/SOL jab, vesta's spear stab, c hally
	MELEE_SPEAR_CRUSH(429, AttackStyle.CRUSH), // tested w/ vesta's spear
	MELEE_STAFF_SLASH(440, AttackStyle.SLASH), // tested w/ SOTD/SOL slash, zammy hasta slash, vesta's spear slash, c hally
	MELEE_BLUE_MOON_FEND(1710, AttackStyle.CRUSH), // Note: the animation is identical between normal/special attacks
	MELEE_BLUE_MOON_JAB(1711, AttackStyle.STAB), // Note: the animation is identical between normal/special attacks
	MELEE_BLUE_MOON_SWIPE(1712, AttackStyle.SLASH), // Note: the animation is identical between normal/special attacks
	MELEE_DLONG_SPEC(1058, AttackStyle.SLASH, true), // tested w/ d long spec, also thammaron's sceptre crush (????)...
	MELEE_DRAGON_MACE_SPEC(1060, AttackStyle.CRUSH, true),
	MELEE_DRAGON_DAGGER_SPEC(1062, AttackStyle.STAB, true),
	MELEE_DRAGON_WARHAMMER_SPEC(1378, AttackStyle.CRUSH, true), // tested w/ dwh, statius warhammer spec
	MELEE_VOIDWAKER_SPEC(11275, AttackStyle.MAGIC, true),
	MELEE_ABYSSAL_WHIP(1658, AttackStyle.SLASH), // tested w/ whip, tent whip
	MELEE_GRANITE_MAUL(1665, AttackStyle.CRUSH), // tested w/ normal gmaul, ornate maul
	MELEE_GRANITE_MAUL_SPEC(1667, AttackStyle.CRUSH, true), // tested w/ normal gmaul, ornate maul
	MELEE_DHAROKS_GREATAXE_CRUSH(2066, AttackStyle.CRUSH),
	MELEE_DHAROKS_GREATAXE_SLASH(2067, AttackStyle.SLASH),
	MELEE_AHRIMS_STAFF_CRUSH(2078, AttackStyle.CRUSH),
	MELEE_OBBY_MAUL_CRUSH(2661, AttackStyle.CRUSH),
	MELEE_ABYSSAL_DAGGER_STAB(3297, AttackStyle.STAB),
	MELEE_ABYSSAL_BLUDGEON_CRUSH(3298, AttackStyle.CRUSH),
	MELEE_LEAF_BLADED_BATTLEAXE_CRUSH(3852, AttackStyle.CRUSH),
	MELEE_INQUISITORS_MACE(4503, AttackStyle.CRUSH),
	MELEE_BARRELCHEST_ANCHOR_CRUSH(5865, AttackStyle.CRUSH),
	MELEE_LEAF_BLADED_BATTLEAXE_SLASH(7004, AttackStyle.SLASH),
	MELEE_GODSWORD_SLASH(7045, AttackStyle.SLASH), // tested w/ AGS, BGS, ZGS, SGS, AGS(or) sara sword
	MELEE_GODSWORD_CRUSH(7054, AttackStyle.CRUSH), // tested w/ AGS, BGS, ZGS, SGS, sara sword
	MELEE_DRAGON_CLAWS_SPEC(7514, AttackStyle.SLASH, true),
	MELEE_VLS_SPEC(7515, AttackStyle.SLASH, true), // both VLS and dragon sword spec
	MELEE_ELDER_MAUL(7516, AttackStyle.CRUSH),
	MELEE_ZAMORAK_GODSWORD_SPEC(7638, AttackStyle.SLASH, true), // tested zgs spec
	MELEE_ZAMORAK_GODSWORD_OR_SPEC(7639, AttackStyle.SLASH, true), // UNTESTED, assumed due to ags(or)
	MELEE_SARADOMIN_GODSWORD_SPEC(7640, AttackStyle.SLASH, true), // tested sgs spec
	MELEE_SARADOMIN_GODSWORD_OR_SPEC(7641, AttackStyle.SLASH, true), // UNTESTED, assumed due to ags(or)
	MELEE_BANDOS_GODSWORD_SPEC(7642, AttackStyle.SLASH, true), // tested bgs spec
	MELEE_BANDOS_GODSWORD_OR_SPEC(7643, AttackStyle.SLASH, true), // UNTESTED, assumed due to ags(or)
	MELEE_ARMADYL_GODSWORD_SPEC(7644, AttackStyle.SLASH, true), // tested ags spec
	MELEE_ARMADYL_GODSWORD_OR_SPEC(7645, AttackStyle.SLASH, true), // tested ags(or) spec
	MELEE_SCYTHE(8056, AttackStyle.SLASH), // tested w/ all scythe styles (so could be crush, but unlikely)
	MELEE_GHAZI_RAPIER_STAB(8145, AttackStyle.STAB), // rapier slash is 390, basic slash animation. Also VLS stab.
	MELEE_ANCIENT_GODSWORD_SPEC(9171, AttackStyle.SLASH, true),
	MELEE_DUAL_MACUACHUITL(10989, AttackStyle.CRUSH), // Note the animation is identical for stab attacks and normal/special attack

	// RANGED
	RANGED_SHORTBOW(426, AttackStyle.RANGED), // Confirmed same w/ 3 types of arrows, w/ maple, magic, & hunter's shortbow, craw's bow, dbow, dbow spec
	RANGED_RUNE_KNIFE_PVP(929, AttackStyle.RANGED), // 1 tick animation, has 1 tick delay between attacks. likely same for all knives. Same for morrigan's javelins, both spec & normal attack.
	RANGED_MAGIC_SHORTBOW_SPEC(1074, AttackStyle.RANGED, true),
	RANGED_CROSSBOW_PVP(4230, AttackStyle.RANGED), // Tested RCB & ACB w/ dragonstone bolts (e) & diamond bolts (e)
	RANGED_BLOWPIPE(5061, AttackStyle.RANGED), // tested in PvP with all styles. Has 1 tick delay between animations in pvp.
	RANGED_DARTS(6600, AttackStyle.RANGED), // tested w/ addy darts. Seems to be constant animation but sometimes stalls and doesn't animate
	RANGED_BALLISTA(7218, AttackStyle.RANGED), // Tested w/ dragon javelins.
	RANGED_DRAGON_THROWNAXE_SPEC(7521, AttackStyle.RANGED, true),
	RANGED_RUNE_CROSSBOW(7552, AttackStyle.RANGED),
	RANGED_BALLISTA_2(7555, AttackStyle.RANGED), // tested w/ light & heavy ballista, dragon & iron javelins.
	RANGED_RUNE_KNIFE(7617, AttackStyle.RANGED), // 1 tick animation, has 1 tick delay between attacks. Also d thrownaxe
	RANGED_DRAGON_KNIFE(8194, AttackStyle.RANGED),
	RANGED_DRAGON_KNIFE_POISONED(8195, AttackStyle.RANGED), // tested w/ d knife p++
	RANGED_DRAGON_KNIFE_SPEC(8292, AttackStyle.RANGED, true),
	RANGED_ZARYTE_CROSSBOW(9168, AttackStyle.RANGED),
	RANGED_ZARYTE_CROSSBOW_PVP(9166, AttackStyle.RANGED),
	RANGED_VENATOR(9858, AttackStyle.RANGED),
	RANGED_ECLIPSE_ATLATL(11057, AttackStyle.RANGED),
	RANGED_ECLIPSE_ATLATL_SPEC(11060, AttackStyle.RANGED, true),

	// MAGIC - uses highest base damage available when animations are re-used. No damage = 0 damage.
	// for example, strike/bolt/blast animation will be fire blast base damage, multi target ancient spells will be ice barrage.
	MAGIC_STANDARD_BIND(710, AttackStyle.MAGIC), // tested w/ bind, snare, entangle
	MAGIC_STANDARD_STRIKE_BOLT_BLAST(711, AttackStyle.MAGIC, 16), // tested w/ bolt
	MAGIC_STANDARD_BIND_STAFF(1161, AttackStyle.MAGIC), // tested w/ bind, snare, entangle, various staves
	MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF(1162, AttackStyle.MAGIC, 16), // strike, bolt and blast (tested all spells, different weapons)
	MAGIC_STANDARD_WAVE_STAFF(1167, AttackStyle.MAGIC, 20), // tested many staves
	MAGIC_STANDARD_SURGE_STAFF(7855, AttackStyle.MAGIC, 24), // tested many staves
	MAGIC_ANCIENT_SINGLE_TARGET(1978, AttackStyle.MAGIC, 26), // Rush & Blitz animations (tested all 8, different weapons)
	MAGIC_ANCIENT_MULTI_TARGET(1979, AttackStyle.MAGIC, 30), // Burst & Barrage animations (tested all 8, different weapons)
	MAGIC_VOLATILE_NIGHTMARE_STAFF_SPEC(8532, AttackStyle.MAGIC, 66); // assume 99 mage's base damage (does not rise when boosted).

	private static final Map<Integer, AnimationData> DATA;

	public int animationId;
	public boolean isSpecial;
	public AttackStyle attackStyle;
	public int baseSpellDamage;

	// Simple animation data constructor for all melee and range attacks
	AnimationData(int animationId, AttackStyle attackStyle)
	{
		if (attackStyle == null)
		{
			throw new InvalidParameterException("Attack Style must be valid for AnimationData");
		}
		this.animationId = animationId;
		this.attackStyle = attackStyle;
		this.isSpecial = false;
		this.baseSpellDamage = 0;
	}
	// Simple animation data constructor for all melee and range attacks w/ special
	AnimationData(int animationId, AttackStyle attackStyle, boolean isSpecial)
	{
		if (attackStyle == null)
		{
			throw new InvalidParameterException("Attack Style must be valid for AnimationData");
		}
		this.animationId = animationId;
		this.attackStyle = attackStyle;
		this.isSpecial = isSpecial;
		this.baseSpellDamage = 0;
	}
	// Magic spell animation data constructor including base spell damage
	AnimationData(int animationId, AttackStyle attackStyle, int baseSpellDamage)
	{
		if (attackStyle == null)
		{
			throw new InvalidParameterException("Attack Style and Attack Type must be valid for AnimationData");
		}
		this.animationId = animationId;
		this.attackStyle = attackStyle;
		this.isSpecial = false;
		this.baseSpellDamage = baseSpellDamage;
	}

	static
	{
		ImmutableMap.Builder<Integer, AnimationData> builder = new ImmutableMap.Builder<>();

		for (AnimationData data : values())
		{
			// allow to skip animation detection by using 0 or less as the animation id.
			if (data.animationId <= 0) { continue; }
			builder.put(data.animationId, data);
		}

		DATA = builder.build();
	}

	public static AnimationData fromId(int animationId)
	{
		return DATA.get(animationId);
	}

	public static boolean isStandardSpellbookSpell(AnimationData animationData)
	{
		return (animationData == MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF ||
			animationData == MAGIC_STANDARD_STRIKE_BOLT_BLAST ||
			animationData == MAGIC_STANDARD_WAVE_STAFF ||
			animationData == MAGIC_STANDARD_SURGE_STAFF);
	}

	public static boolean isFireSpell(AnimationData animationData)
	{
		return (animationData == MAGIC_STANDARD_STRIKE_BOLT_BLAST_STAFF ||
			animationData == MAGIC_STANDARD_STRIKE_BOLT_BLAST ||
			animationData == MAGIC_STANDARD_WAVE_STAFF ||
			animationData == MAGIC_STANDARD_SURGE_STAFF);
	}

	@Override
	public String toString()
	{
		String[] words = super.toString().toLowerCase().split("_");
		Arrays.stream(words)
			.map(StringUtils::capitalize).collect(Collectors.toList()).toArray(words);

		return String.join(" ", words);
	}


	// An enum of combat styles (including stab, slash, crush).
	public enum AttackStyle
	{
		STAB(HeadIcon.MELEE, SpriteID.COMBAT_STYLE_SWORD_STAB),
		SLASH(HeadIcon.MELEE, SpriteID.COMBAT_STYLE_SWORD_SLASH),
		CRUSH(HeadIcon.MELEE, SpriteID.COMBAT_STYLE_HAMMER_POUND),
		RANGED(HeadIcon.RANGED, SpriteID.SKILL_RANGED),
		MAGIC(HeadIcon.MAGIC, SpriteID.SKILL_MAGIC);

		static AttackStyle[] MELEE_STYLES = {STAB, SLASH, CRUSH};

		@Getter
		private final HeadIcon protection;

		@Getter
		private final int styleSpriteId;

		AttackStyle(HeadIcon protection, int styleSpriteId)
		{
			this.protection = protection;
			this.styleSpriteId = styleSpriteId;
		}

		public boolean isMelee()
		{
			return ArrayUtils.contains(AttackStyle.MELEE_STYLES, this);
		}

		public boolean isUsingSuccessfulOffensivePray(int pray)
		{
			return (pray > 0 &&
				((isMelee() &&
					(pray == SpriteID.PRAYER_PIETY ||
					 pray == SpriteID.PRAYER_ULTIMATE_STRENGTH)) ||
				(this == RANGED &&
					(pray == SpriteID.PRAYER_RIGOUR ||
					 pray == SpriteID.PRAYER_EAGLE_EYE)) ||
				(this == MAGIC &&
					(pray == SpriteID.PRAYER_AUGURY ||
					 pray == SpriteID.PRAYER_MYSTIC_MIGHT)))
			);
		}


		@Override
		public String toString()
		{
			return StringUtils.capitalize(super.toString().toLowerCase());
		}
	}
}

/*
 * Copyright (c)  2020, Matsyir <https://github.com/Matsyir>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package matsyir.pvpperformancetracker.models;

import java.util.Arrays;
import java.util.stream.Collectors;
import lombok.Getter;
import org.apache.commons.lang3.StringUtils;

public interface RangeAmmoData
{
	RangeAmmoData[] DIAMOND_BOLTS = {
		BoltAmmo.DIAMOND_BOLTS_E,
		StrongBoltAmmo.DIAMOND_BOLTS_E,
		StrongBoltAmmo.DIAMOND_DRAGON_BOLTS_E
	};

	RangeAmmoData[] OPAL_BOLTS = {
		StrongBoltAmmo.OPAL_DRAGON_BOLTS_E
	};

	int getItemId(); // itemIDs used for DISPLAYING bolts, not getting them.
	int getRangeStr();
	double getBonusMaxHit(int rangeLevel); // damage bonus from bolt specs.
	double getDmgModifier(); // damage modifier from bolt specs.

	interface RangeAmmoConfigData extends RangeAmmoData
	{
		String getName();
	}

	@Getter
	enum BoltAmmo implements RangeAmmoConfigData
	{
		RUNITE_BOLTS("Runite Bolts", 9169, 115, 1),
		DRAGONSTONE_BOLTS_E("Dstone Bolts (e)", 9281, 117, 1, .2, 0.06),
		DIAMOND_BOLTS_E("Diamond Bolts (e)", 9277, 105, 1.015);

		static EquipmentData[] WEAPONS_USING = { EquipmentData.RUNE_CROSSBOW };

		private String name;
		private int itemId;
		private int rangeStr;
		private double specRangeLevelModifier;
		private double specChance;
		private double dmgModifier;

		BoltAmmo(String name, int itemId, int rangeStr, double dmgModifier, double specRangeLevelModifier, double specChance)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.specRangeLevelModifier = specRangeLevelModifier;
			this.specChance = specChance;
			this.dmgModifier = dmgModifier;
		}
		BoltAmmo(String name, int itemId, int rangeStr, double dmgModifier)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.specRangeLevelModifier = 0;
			this.specChance = 0;
			this.dmgModifier = dmgModifier;
		}

		public double getBonusMaxHit(int rangeLevel)
		{
			return rangeLevel * specRangeLevelModifier * specChance;
		}

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	enum StrongBoltAmmo implements RangeAmmoConfigData
	{
		RUNITE_BOLTS("Runite Bolts", 9169, 115, 1),
		DRAGONSTONE_BOLTS_E("Dstone Bolts (e)", 9281, 117, 1, .2, 0.06),
		DIAMOND_BOLTS_E("Diamond Bolts (e)", 9277, 105, 1.015),
		DRAGONSTONE_DRAGON_BOLTS_E("Dstone DBolts (e)", 1668, 122, 1, .2, .06),
		OPAL_DRAGON_BOLTS_E("Opal DBolts (e)", 8729, 122, 1, .1, .05),
		DIAMOND_DRAGON_BOLTS_E("Diamond DBolts (e)", 1690, 122, 1.015);

		static EquipmentData[] WEAPONS_USING = {
			EquipmentData.ARMADYL_CROSSBOW,
			EquipmentData.DRAGON_CROSSBOW,
			EquipmentData.DRAGON_HUNTER_CROSSBOW,
			EquipmentData.ZARYTE_CROSSBOW
		};

		private String name;
		private int rangeStr;
		private int itemId;
		private double specRangeLevelModifier;
		private double specChance;
		private double dmgModifier;

		StrongBoltAmmo(String name, int itemId, int rangeStr, double dmgModifier, double specRangeLevelModifier, double specChance)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.specRangeLevelModifier = specRangeLevelModifier;
			this.specChance = specChance;
			this.dmgModifier = dmgModifier;
		}
		StrongBoltAmmo(String name, int itemId, int rangeStr, double dmgModifier)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.specRangeLevelModifier = 0;
			this.specChance = 0;
			this.dmgModifier = dmgModifier;
		}

		public double getBonusMaxHit(int rangeLevel)
		{
			return rangeLevel * specRangeLevelModifier * specChance;
		}


		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	public enum DartAmmo implements RangeAmmoConfigData
	{
		ADAMANT_DARTS("Adamant Darts", 810, 10),
		RUNE_DARTS("Rune Darts", 811, 14),
		DRAGON_DARTS("Dragon Darts", 11230, 20);

		static EquipmentData[] WEAPONS_USING = { EquipmentData.TOXIC_BLOWPIPE };

		private String name;
		private int itemId;
		private int rangeStr;
		private double bonusMaxHit;
		private double dmgModifier;

		DartAmmo(String name, int itemId, int rangeStr)
		{
			this.name = name;
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.bonusMaxHit = 0;
			this.dmgModifier = 1;
		}

		public double getBonusMaxHit(int rangeLevel)
		{
			return 0;
		}

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	public enum OtherAmmo implements RangeAmmoData
	{
		AMETHYST_ARROWS(4770, 55),
		DRAGON_ARROW(11216, 60),
		DRAGON_JAVELIN(19484, 150);

		private int rangeStr;
		private int itemId;
		private double bonusMaxHit;
		private double dmgModifier;

		OtherAmmo(int itemId, int rangeStr)
		{
			this.itemId = itemId;
			this.rangeStr = rangeStr;
			this.bonusMaxHit = 0;
			this.dmgModifier = 1;
		}

		public double getBonusMaxHit(int rangeLevel)
		{
			return 0;
		}

		@Override
		public String toString()
		{
			String[] words = super.toString().toLowerCase().split("_");
			Arrays.stream(words)
				.map(StringUtils::capitalize).collect(Collectors.toList()).toArray(words);

			return String.join(" ", words);
		}
	}
}





