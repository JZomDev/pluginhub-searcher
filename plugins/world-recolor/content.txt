package com.github.cubeee.worldrecolor;

public final class ConfigKeys {
    public static final String PLUGIN_CONFIG_GROUP_NAME = "worldRecolor";

    public static final int TILES_SECTION_POSITION = 0;
    public static final int REGIONS_SECTION_POSITION = 100;

    public static final String RECOLOR_TILES = "recolorTiles";
    public static final String TILE_HUE_REDUCTION = "tileHueReduction";
    public static final String TILE_SATURATION_REDUCTION = "tileSaturationReduction";
    public static final String TILE_LIGHTNESS_REDUCTION = "tileLightnessReduction";

    public static final String ENABLE_MENU_OPTIONS = "enableMenuOptions";
    public static final String MENU_OPTIONS_HOTKEY = "menuOptionsHotkey";

    public static final String INCLUDED_REGION_IDS = "includedRegionIds";
    public static final String EXCLUDED_REGION_IDS = "excludedRegionIds";

    private ConfigKeys() {}

}

package com.github.cubeee.worldrecolor;

public final class Utils {
    private Utils() {}

    public static int clamp(int value, int min, int max) {
        return Math.min(Math.max(value, min), max);
    }
}

package com.github.cubeee.worldrecolor;

public final class Colors {
    public static final int MIN_HUE = 0;
    public static final int MAX_HUE = 63;
    public static final int MIN_SATURATION = 0;
    public static final int MAX_SATURATION = 7;
    public static final int MIN_LIGHTNESS = 0;
    public static final int MAX_LIGHTNESS = 127;

    public static final int MIN_HSL = packJagexHsl(MIN_HUE, MIN_SATURATION, MIN_LIGHTNESS);
    public static final int MAX_HSL = packJagexHsl(MAX_HUE, MAX_SATURATION, MAX_LIGHTNESS);

    private Colors() {}

    public static int[] getUnpackedJagexHsl(int jagexHsl) {
        int hue = unpackJagexHue(jagexHsl);
        int saturation = unpackJagexSaturation(jagexHsl);
        int lightness = unpackJagexLightness(jagexHsl);
        return new int[] { hue, saturation, lightness };
    }

    public static int packJagexHsl(int hue, int saturation, int lightness) {
        return hue << 10 | saturation << 7 | lightness;
    }

    public static int unpackJagexHue(int jagexHsl) {
        return jagexHsl >> 10 & 0x3F;
    }

    public static int unpackJagexSaturation(int jagexHsl) {
        return jagexHsl >> 7 & 7;
    }

    public static int unpackJagexLightness(int jagexHsl) {
        return jagexHsl & 0x7F;
    }
}

package com.github.cubeee.worldrecolor;

public class ColorMap {
    private final Integer[] modifiedColors;

    private int lastHueReduction;
    private int lastSaturationReduction;
    private int lastLightnessReduction;

    public ColorMap() {
        this.modifiedColors = new Integer[Colors.MAX_HSL];
    }

    public void updateColors(int hueReduction, int saturationReduction, int lightnessReduction) {
        if (hueReduction == lastHueReduction
            && saturationReduction == lastSaturationReduction
            && lightnessReduction == lastLightnessReduction) {
            return;
        }

        for (int hsl = 0; hsl < modifiedColors.length; hsl++) {
            int modified = getNewHsl(hsl, hueReduction, saturationReduction, lightnessReduction);
            modifiedColors[hsl] = modified;
        }

        this.lastHueReduction = hueReduction;
        this.lastSaturationReduction = saturationReduction;
        this.lastLightnessReduction = lightnessReduction;
    }

    public int getModifiedHsl(int hsl) {
        if (hsl == 12_345_678 || hsl < 0 || hsl > modifiedColors.length - 1) {
            return hsl;
        }
        Integer modified = modifiedColors[hsl];
        return modified == null ? hsl : modified;
    }

    private int getNewHsl(int hsl, int hueReduction, int satReduction, int lightnessReduction) {
        if (hsl == 12_345_678 || hsl < Colors.MIN_HSL || hsl > Colors.MAX_HSL) {
            return hsl;
        }

        if (hueReduction == 0 && satReduction == 0 && lightnessReduction == 0) {
            return hsl;
        }

        int[] unpackedHsl = Colors.getUnpackedJagexHsl(hsl);

        int newHue = getReducedAmount(unpackedHsl[0], hueReduction, Colors.MIN_HUE, Colors.MAX_HUE);
        int newSaturation = getReducedAmount(unpackedHsl[1], satReduction, Colors.MIN_SATURATION, Colors.MAX_SATURATION);
        int newLightness = getReducedAmount(unpackedHsl[2], lightnessReduction, Colors.MIN_LIGHTNESS, Colors.MAX_LIGHTNESS);

        return Colors.packJagexHsl(newHue, newSaturation, newLightness);
    }

    private int getReducedAmount(int value, int reductionPercent, int min, int max) {
        return Utils.clamp(
            (int) Math.ceil(((100 - reductionPercent) / 100.0) * value),
            min,
            max);
    }

}

package com.github.cubeee.worldrecolor;

import net.runelite.api.SceneTileModel;

public final class ColorAdjuster {
    private ColorAdjuster() {}

    public static void adjustSceneTileModel(SceneTileModel model, ColorMap colorMap) {
        adjustColors(model.getTriangleColorA(), model.getTriangleTextureId(), colorMap);
        adjustColors(model.getTriangleColorB(), model.getTriangleTextureId(), colorMap);
        adjustColors(model.getTriangleColorC(), model.getTriangleTextureId(), colorMap);
    }

    public static void adjustColors(int[] colors, int[] textures, ColorMap colorMap) {
        for (int i = 0; i < colors.length; i++) {
            if (textures != null && textures.length >= i && textures[i] != -1) {
                continue;
            }
            colors[i] = colorMap.getModifiedHsl(colors[i]);
        }
    }
}

package com.github.cubeee.worldrecolor;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(ConfigKeys.PLUGIN_CONFIG_GROUP_NAME)
public interface WorldRecolorConfig extends Config {
	String COX_REGIONS = "13136,13137,13393,13138,13394,13139,13395,13140,13396,13141,13397,13145,13401,12889";
	String TOB_REGIONS = "12613,13125,13122,13123,13379,12612,12611";
	String TOA_REGIONS = "14160,15698,15700,14162,14164,15186,15188,14674,14676,15184,15696";

	@ConfigSection(
		name = "Tiles",
		description = "",
		position = ConfigKeys.TILES_SECTION_POSITION
	)
	String TILE_RECOLORS_SECTION = "Tiles";

	@ConfigSection(
		name = "Regions",
		description = "",
		position = ConfigKeys.REGIONS_SECTION_POSITION,
		closedByDefault = true
	)
	String REGIONS_SECTION = "Regions";

	// ---
	// --- TILES
	// ---

	@ConfigItem(
		keyName = ConfigKeys.RECOLOR_TILES,
		name = "Recolor tiles",
		description = "",
		section = TILE_RECOLORS_SECTION
	)
	default boolean isRecolorTiles() {
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.TILE_HUE_REDUCTION,
		name = "Hue reduction",
		description = "",
		position = 0,
		section = TILE_RECOLORS_SECTION
	)
	@Units(Units.PERCENT)
	@Range(min = -100, max = 100)
	default int getTileHueReduction() {
		return 0;
	}

	@ConfigItem(
		keyName = ConfigKeys.TILE_SATURATION_REDUCTION,
		name = "Saturation reduction",
		description = "",
		position = 1,
		section = TILE_RECOLORS_SECTION
	)
	@Units(Units.PERCENT)
	@Range(min = -100, max = 100)
	default int getTileSaturationReduction() {
		return 0;
	}

	@ConfigItem(
		keyName = ConfigKeys.TILE_LIGHTNESS_REDUCTION,
		name = "Lightness reduction",
		description = "",
		position = 2,
		section = TILE_RECOLORS_SECTION
	)
	@Units(Units.PERCENT)
	@Range(min = -100, max = 100)
	default int getTileLightnessReduction() {
		return 80;
	}

	// ---
	// --- REGIONS
	// ---

	@ConfigItem(
		keyName = ConfigKeys.ENABLE_MENU_OPTIONS,
		name = "Enable menu options",
		description = "",
		section = REGIONS_SECTION,
		position = 0
	)
	default boolean isMenuOptionsEnabled() {
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.MENU_OPTIONS_HOTKEY,
		name = "Menu options keybind",
		description = "Show menu options when this key is held down",
		section = REGIONS_SECTION,
		position = 1
	)
	default Keybind getMenuOptionsKeybind() {
		return Keybind.CTRL;
	}

	@ConfigItem(
		keyName = ConfigKeys.INCLUDED_REGION_IDS,
		name = "Included region ids",
		description = "Only recolor inside these regions. Anything added here will always be used instead of excluded regions! Separated by commas and/or new lines.",
		position = 2,
		section = REGIONS_SECTION
	)
	default String getIncludedRegionIds() {
		return "";
	}

	@ConfigItem(
		keyName = ConfigKeys.EXCLUDED_REGION_IDS,
		name = "Excluded region ids",
		description = "Recolor everywhere but inside these regions. Used when included regions is empty. Separated by commas and/or new lines.",
		position = 3,
		section = REGIONS_SECTION
	)
	default String getExcludedRegionIds() {
		return COX_REGIONS + "," + TOB_REGIONS + "," + TOA_REGIONS;
	}
}

package com.github.cubeee.worldrecolor;

import com.google.common.base.Joiner;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Scene;
import net.runelite.api.SceneTileModel;
import net.runelite.api.SceneTilePaint;
import net.runelite.api.Tile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.PreMapLoad;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.HotkeyListener;

import java.util.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;

@Slf4j
@PluginDescriptor(
	name = "World Recolor"
)
public class WorldRecolorPlugin extends Plugin {
	public static final int NEXT_REFRESH_UNSET = -1;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private WorldRecolorConfig config;

	@Inject
	private KeyManager keyManager;

	@Inject
	private ConfigManager configManager;

    private boolean showMenuOptions;
	private int nextReloadTick = NEXT_REFRESH_UNSET;
	private final ColorMap tileColorMap = new ColorMap();

	private final List<Integer> includedRegionIds;
	private final List<Integer> excludedRegionIds;

	private final HotkeyListener hotkeyListener = new HotkeyListener(() -> config.getMenuOptionsKeybind()) {
		@Override
		public void hotkeyPressed() {
			showMenuOptions = true;
		}

		@Override
		public void hotkeyReleased() {
			showMenuOptions = false;
		}
	};

	public WorldRecolorPlugin() {
		super();
		this.includedRegionIds = new ArrayList<>();
		this.excludedRegionIds = new ArrayList<>();
	}

	@Override
	protected void startUp() {
		loadRegionIds();
		reloadMap();
		keyManager.registerKeyListener(hotkeyListener);
	}

	@Override
	protected void shutDown() {
		reloadMap();
		keyManager.unregisterKeyListener(hotkeyListener);
	}

	public void reloadMap() {
		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN) {
				client.setGameState(GameState.LOADING);
			}
		});
	}

    @Subscribe
	@SuppressWarnings({"unused", "PMD.CyclomaticComplexity"})
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(ConfigKeys.PLUGIN_CONFIG_GROUP_NAME)) {
			return;
		}

		String key = event.getKey();

		boolean triggerUpdate = true;

		loadRegionIds();

		// No map reload on irrelevant configs
		if (key.equals(ConfigKeys.ENABLE_MENU_OPTIONS)
			|| key.equals(ConfigKeys.MENU_OPTIONS_HOTKEY)) {
			triggerUpdate = false;
		}

		// Trigger map reloads on tile color adjustments and only if tile recoloring is enabled
		if (!config.isRecolorTiles()
				&& (key.equals(ConfigKeys.TILE_HUE_REDUCTION)
				|| key.equals(ConfigKeys.TILE_SATURATION_REDUCTION)
				|| key.equals(ConfigKeys.TILE_LIGHTNESS_REDUCTION))) {
			triggerUpdate = false;
		}

		// Prevent excessive map reloads when config changes are spammed by running it on the next game tick
		if (triggerUpdate) {
			nextReloadTick = client.getTickCount() + 1;
		}
	}

    @Subscribe
	@SuppressWarnings("unused")
	public void onPreMapLoad(PreMapLoad preMapLoad) {
		long start = System.nanoTime();
		recolorMap(preMapLoad.getScene());
		long end = System.nanoTime();
		long duration = end - start;
		log.debug("Map recolor done in {}ms", duration / 1_000_000);
	}

    @Subscribe
	@SuppressWarnings("unused")
	public void onGameTick(GameTick gameTick) {
		if (nextReloadTick != NEXT_REFRESH_UNSET && client.getTickCount() >= nextReloadTick) {
			reloadMap();
			nextReloadTick = NEXT_REFRESH_UNSET;
		}
	}

	@Subscribe
	@SuppressWarnings("unused")
	public void onMenuOpened(MenuOpened event) {
		MenuEntry[] menuEntries = event.getMenuEntries();
		if (config.isMenuOptionsEnabled() && showMenuOptions && hasWalkHereOption(menuEntries)) {
			addContextMenuEntry(menuEntries.length - 1);
		}
	}

	private boolean hasWalkHereOption(MenuEntry... menuEntries) {
		if (menuEntries == null) {
			return false;
		}
		for (MenuEntry menuEntry : menuEntries) {
			if (menuEntry.getType() == MenuAction.WALK) {
				return true;
			}
		}
		return false;
	}

	private void addContextMenuEntry(int index) {
		Tile selectedTile = client.getTopLevelWorldView().getSelectedSceneTile();
		if (selectedTile == null) {
			return;
		}

		WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, selectedTile.getLocalLocation());
		if (worldPoint == null) {
			return;
		}

		int regionId = worldPoint.getRegionID();
		boolean isIncluded = includedRegionIds.contains(regionId);
		boolean isExcluded = excludedRegionIds.contains(regionId);
		String includeText = isIncluded ? "Remove from included regions": "Add to included regions";
		String excludeText = isExcluded ? "Remove from excluded regions" : "Add to excluded regions";

		MenuEntry groupEntry = client.getMenu().createMenuEntry(index)
			.setOption("World Recolor")
			.setType(MenuAction.RUNELITE);

		Menu subMenu = groupEntry.createSubMenu();

		subMenu.createMenuEntry(0)
			.setOption(includeText)
			.setType(MenuAction.RUNELITE)
			.onClick(e -> {
				if (isIncluded) {
					includedRegionIds.removeIf(i -> i == regionId);
				} else {
					includedRegionIds.add(regionId);
				}
				configManager.setConfiguration(
						ConfigKeys.PLUGIN_CONFIG_GROUP_NAME,
						ConfigKeys.INCLUDED_REGION_IDS,
						Joiner.on(",").join(includedRegionIds));
			});

		subMenu.createMenuEntry(1)
			.setOption(excludeText)
			.setType(MenuAction.RUNELITE)
			.onClick(e -> {
				if (isExcluded) {
					excludedRegionIds.removeIf(i -> i == regionId);
				} else {
					excludedRegionIds.add(regionId);
				}
				configManager.setConfiguration(
						ConfigKeys.PLUGIN_CONFIG_GROUP_NAME,
						ConfigKeys.EXCLUDED_REGION_IDS,
						Joiner.on(",").join(excludedRegionIds));
			});
	}

    @Provides
	@SuppressWarnings({"unused", "PMD.CommentDefaultAccessModifier"})
	WorldRecolorConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(WorldRecolorConfig.class);
	}

	private void recolorMap(Scene scene) {
		boolean recolorTiles = config.isRecolorTiles();

		if (!recolorTiles) {
			return;
		}

		int tileHueReduction = config.getTileHueReduction();
		int tileSaturationReduction = config.getTileSaturationReduction();
		int tileLightnessReduction = config.getTileLightnessReduction();

		// Cache the whole new adjusted color palette at once before recoloring the map
		long colorMapsStart = System.nanoTime();
		tileColorMap.updateColors(tileHueReduction, tileSaturationReduction, tileLightnessReduction);
		long colorMapsEnd = System.nanoTime();

		boolean isInstance = scene.isInstance();
		log.debug("Recolor map... instance={}, tiles={}", isInstance, recolorTiles);
		Tile[][][] tiles = isInstance ? scene.getTiles() : scene.getExtendedTiles();

		long tilesDuration = 0;

		for (Tile[][] zTiles : tiles) {
			for (Tile[] xTiles : zTiles) {
				for (Tile tile : xTiles) {
					if (canRecolorTile(scene, tile)) {
						tilesDuration += recolorTile(tile);
					}
				}
			}
		}

		log.debug("Color maps updated in {}ms, tiles colored in {}ms",
			(colorMapsEnd - colorMapsStart) / 1_000_000,
			tilesDuration / 1_000_000
		);
	}

	private long recolorTile(Tile tile) {
		long start = System.nanoTime();
		SceneTilePaint paint = tile.getSceneTilePaint();
		if (paint != null && paint.getTexture() == -1) {
			int newNw = tileColorMap.getModifiedHsl(paint.getNwColor());
			int newNe = tileColorMap.getModifiedHsl(paint.getNeColor());
			int newSw = tileColorMap.getModifiedHsl(paint.getSwColor());
			int newSe = tileColorMap.getModifiedHsl(paint.getSeColor());

			paint.setNwColor(newNw);
			paint.setNeColor(newNe);
			paint.setSwColor(newSw);
			paint.setSeColor(newSe);

			tile.setSceneTilePaint(paint);
		}

		SceneTileModel model = tile.getSceneTileModel();
		if (model != null) {
			ColorAdjuster.adjustSceneTileModel(model, tileColorMap);
			tile.setSceneTileModel(model);
		}

		long end = System.nanoTime();
		return end - start;
	}

	private boolean canRecolorTile(Scene scene, Tile tile) {
		if (tile == null) {
			return false;
		}
		if (includedRegionIds.isEmpty() && excludedRegionIds.isEmpty()) {
			return true;
		}
		WorldPoint worldPoint = WorldPoint.fromLocalInstance(scene, tile.getLocalLocation(), tile.getPlane());
		return canRecolorRegion(worldPoint.getRegionID());
	}

	private boolean canRecolorRegion(int regionId) {
		if (!includedRegionIds.isEmpty()) {
			return includedRegionIds.contains(regionId);
		}
		return !excludedRegionIds.contains(regionId);
	}

	private void loadRegionIds() {
		includedRegionIds.clear();
		excludedRegionIds.clear();

		String includedRegionIdsString = config.getIncludedRegionIds();
		String excludedRegionIdsString = config.getExcludedRegionIds();
		if (includedRegionIdsString.isEmpty() && excludedRegionIdsString.isEmpty()) {
			return;
		}

		includedRegionIds.addAll(
			Pattern.compile("[,\\n]")
				.splitAsStream(includedRegionIdsString)
				.filter(Predicate.not(String::isEmpty))
				.map(Integer::valueOf)
				.collect(Collectors.toList()));

		excludedRegionIds.addAll(
			Pattern.compile("[,\\n]")
				.splitAsStream(excludedRegionIdsString)
					.filter(Predicate.not(String::isEmpty))
					.map(Integer::valueOf)
					.collect(Collectors.toList()));

		if (log.isDebugEnabled()) {
			log.debug("Included region ids: {}, excluded region ids: {}", includedRegionIds.size(), excludedRegionIds.size());
		}
	}

}

package com.github.cubeee.worldrecolor;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public final class WorldRecolorPluginRunner {
	private WorldRecolorPluginRunner() {}

	@SuppressWarnings({"PMD.SignatureDeclareThrowsException", "unchecked"})
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(WorldRecolorPlugin.class);
		RuneLite.main(args);
	}
}

