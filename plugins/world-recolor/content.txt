package com.github.cubeee.worldrecolor;

public final class ConfigKeys {
    public static final String PLUGIN_CONFIG_GROUP_NAME = "worldRecolor";

    public static final int TILES_SECTION_POSITION = 0;
    public static final int ADVANCED_SECTION_POSITION = 1;

    public static final String RECOLOR_TILES = "recolorTiles";
    public static final String TILE_HUE_REDUCTION = "tileHueReduction";
    public static final String TILE_SATURATION_REDUCTION = "tileSaturationReduction";
    public static final String TILE_LIGHTNESS_REDUCTION = "tileLightnessReduction";

    public static final String INCLUDED_REGION_IDS = "includedRegionIds";
    public static final String EXCLUDED_REGION_IDS = "excludedRegionIds";

    private ConfigKeys() {}

}

package com.github.cubeee.worldrecolor;

public final class Utils {
    private Utils() {}

    public static int clamp(int value, int min, int max) {
        return Math.min(Math.max(value, min), max);
    }
}

package com.github.cubeee.worldrecolor;

public final class Colors {
    public static final int MIN_HUE = 0;
    public static final int MAX_HUE = 63;
    public static final int MIN_SATURATION = 0;
    public static final int MAX_SATURATION = 7;
    public static final int MIN_LIGHTNESS = 0;
    public static final int MAX_LIGHTNESS = 127;

    public static final int MIN_HSL = packJagexHsl(MIN_HUE, MIN_SATURATION, MIN_LIGHTNESS);
    public static final int MAX_HSL = packJagexHsl(MAX_HUE, MAX_SATURATION, MAX_LIGHTNESS);

    private Colors() {}

    public static int[] getUnpackedJagexHsl(int jagexHsl) {
        int hue = unpackJagexHue(jagexHsl);
        int saturation = unpackJagexSaturation(jagexHsl);
        int lightness = unpackJagexLightness(jagexHsl);
        return new int[] { hue, saturation, lightness };
    }

    public static int packJagexHsl(int hue, int saturation, int lightness) {
        return hue << 10 | saturation << 7 | lightness;
    }

    public static int unpackJagexHue(int jagexHsl) {
        return jagexHsl >> 10 & 0x3F;
    }

    public static int unpackJagexSaturation(int jagexHsl) {
        return jagexHsl >> 7 & 7;
    }

    public static int unpackJagexLightness(int jagexHsl) {
        return jagexHsl & 0x7F;
    }
}

package com.github.cubeee.worldrecolor;

public class ColorMap {
    private final Integer[] modifiedColors;

    private int lastHueReduction;
    private int lastSaturationReduction;
    private int lastLightnessReduction;

    public ColorMap() {
        this.modifiedColors = new Integer[Colors.MAX_HSL];
    }

    public void updateColors(int hueReduction, int saturationReduction, int lightnessReduction) {
        if (hueReduction == lastHueReduction
            && saturationReduction == lastSaturationReduction
            && lightnessReduction == lastLightnessReduction) {
            return;
        }

        for (int hsl = 0; hsl < modifiedColors.length; hsl++) {
            int modified = getNewHsl(hsl, hueReduction, saturationReduction, lightnessReduction);
            modifiedColors[hsl] = modified;
        }

        this.lastHueReduction = hueReduction;
        this.lastSaturationReduction = saturationReduction;
        this.lastLightnessReduction = lightnessReduction;
    }

    public int getModifiedHsl(int hsl) {
        if (hsl == 12_345_678 || hsl < 0 || hsl > modifiedColors.length - 1) {
            return hsl;
        }
        Integer modified = modifiedColors[hsl];
        return modified == null ? hsl : modified;
    }

    private int getNewHsl(int hsl, int hueReduction, int satReduction, int lightnessReduction) {
        if (hsl == 12_345_678 || hsl < Colors.MIN_HSL || hsl > Colors.MAX_HSL) {
            return hsl;
        }

        if (hueReduction == 0 && satReduction == 0 && lightnessReduction == 0) {
            return hsl;
        }

        int[] unpackedHsl = Colors.getUnpackedJagexHsl(hsl);

        int newHue = getReducedAmount(unpackedHsl[0], hueReduction, Colors.MIN_HUE, Colors.MAX_HUE);
        int newSaturation = getReducedAmount(unpackedHsl[1], satReduction, Colors.MIN_SATURATION, Colors.MAX_SATURATION);
        int newLightness = getReducedAmount(unpackedHsl[2], lightnessReduction, Colors.MIN_LIGHTNESS, Colors.MAX_LIGHTNESS);

        return Colors.packJagexHsl(newHue, newSaturation, newLightness);
    }

    private int getReducedAmount(int value, int reductionPercent, int min, int max) {
        return Utils.clamp(
            (int) Math.ceil(((100 - reductionPercent) / 100.0) * value),
            min,
            max);
    }

}

package com.github.cubeee.worldrecolor;

import net.runelite.api.SceneTileModel;

public final class ColorAdjuster {
    private ColorAdjuster() {}

    public static void adjustSceneTileModel(SceneTileModel model, ColorMap colorMap) {
        adjustColors(model.getTriangleColorA(), model.getTriangleTextureId(), colorMap);
        adjustColors(model.getTriangleColorB(), model.getTriangleTextureId(), colorMap);
        adjustColors(model.getTriangleColorC(), model.getTriangleTextureId(), colorMap);
    }

    public static void adjustColors(int[] colors, int[] textures, ColorMap colorMap) {
        for (int i = 0; i < colors.length; i++) {
            if (textures != null && textures.length >= i && textures[i] != -1) {
                continue;
            }
            colors[i] = colorMap.getModifiedHsl(colors[i]);
        }
    }
}

package com.github.cubeee.worldrecolor;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(ConfigKeys.PLUGIN_CONFIG_GROUP_NAME)
public interface WorldRecolorConfig extends Config {
	String COX_REGIONS = "13136,13137,13393,13138,13394,13139,13395,13140,13396,13141,13397,13145,13401,12889";
	String TOB_REGIONS = "12613,13125,13122,13123,13379,12612,12611";
	String TOA_REGIONS = "14160,15698,15700,14162,14164,15186,15188,14674,14676,15184,15696";

	@ConfigSection(
		name = "Tiles",
		description = "",
		position = ConfigKeys.TILES_SECTION_POSITION
	)
	String TILE_RECOLORS_SECTION = "Tiles";

	@ConfigSection(
			name = "Advanced",
			description = "",
			position = ConfigKeys.ADVANCED_SECTION_POSITION,
			closedByDefault = true
	)
	String ADVANCED_SECTION = "Advanced";

	// ---
	// --- TILES
	// ---

	@ConfigItem(
		keyName = ConfigKeys.RECOLOR_TILES,
		name = "Recolor tiles",
		description = "",
		section = TILE_RECOLORS_SECTION
	)
	default boolean isRecolorTiles() {
		return false;
	}

	@ConfigItem(
		keyName = ConfigKeys.TILE_HUE_REDUCTION,
		name = "Hue reduction",
		description = "",
		position = 0,
		section = TILE_RECOLORS_SECTION
	)
	@Units(Units.PERCENT)
	@Range(min = -100, max = 100)
	default int getTileHueReduction() {
		return 0;
	}

	@ConfigItem(
		keyName = ConfigKeys.TILE_SATURATION_REDUCTION,
		name = "Saturation reduction",
		description = "",
		position = 1,
		section = TILE_RECOLORS_SECTION
	)
	@Units(Units.PERCENT)
	@Range(min = -100, max = 100)
	default int getTileSaturationReduction() {
		return 0;
	}

	@ConfigItem(
		keyName = ConfigKeys.TILE_LIGHTNESS_REDUCTION,
		name = "Lightness reduction",
		description = "",
		position = 2,
		section = TILE_RECOLORS_SECTION
	)
	@Units(Units.PERCENT)
	@Range(min = -100, max = 100)
	default int getTileLightnessReduction() {
		return 80;
	}

	// ---
	// --- ADVANCED
	// ---

	@ConfigItem(
		keyName = ConfigKeys.INCLUDED_REGION_IDS,
		name = "Included region ids",
		description = "Only recolor inside these regions. Anything added here will always be used instead of excluded regions! Separated by commas and/or new lines.",
		position = 1,
		section = ADVANCED_SECTION
	)
	default String getIncludedRegionIds() {
		return "";
	}

	@ConfigItem(
		keyName = ConfigKeys.EXCLUDED_REGION_IDS,
		name = "Excluded region ids",
		description = "Recolor everywhere but inside these regions. Used when included regions is empty. Separated by commas and/or new lines.",
		position = 2,
		section = ADVANCED_SECTION
	)
	default String getExcludedRegionIds() {
		return COX_REGIONS + "," + TOB_REGIONS + "," + TOA_REGIONS;
	}
}

package com.github.cubeee.worldrecolor;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Scene;
import net.runelite.api.SceneTileModel;
import net.runelite.api.SceneTilePaint;
import net.runelite.api.Tile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.PreMapLoad;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

import java.util.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;

@Slf4j
@PluginDescriptor(
	name = "World Recolor"
)
@SuppressWarnings("PMD.TooManyMethods")
public class WorldRecolorPlugin extends Plugin {
	public static final int NEXT_REFRESH_UNSET = -1;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private WorldRecolorConfig config;

	private int nextReloadTick = NEXT_REFRESH_UNSET;
	private final ColorMap tileColorMap = new ColorMap();

	private final List<Integer> includedRegionIds;
	private final List<Integer> excludedRegionIds;

	public WorldRecolorPlugin() {
		super();
		this.includedRegionIds = new ArrayList<>();
		this.excludedRegionIds = new ArrayList<>();
	}

	@Override
	protected void startUp() {
		loadRegionIds();
		reloadMap();
	}

	@Override
	protected void shutDown() {
		reloadMap();
	}

	public void reloadMap() {
		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN) {
				client.setGameState(GameState.LOADING);
			}
		});
	}

    @Subscribe
	@SuppressWarnings({"unused", "PMD.CyclomaticComplexity"})
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(ConfigKeys.PLUGIN_CONFIG_GROUP_NAME)) {
			return;
		}

		String key = event.getKey();

		boolean triggerUpdate = true;

		if (key.equals(ConfigKeys.INCLUDED_REGION_IDS) || key.equals(ConfigKeys.EXCLUDED_REGION_IDS)) {
			loadRegionIds();
		}

		// Trigger map reloads on tile color adjustments only if tile recoloring is enabled
		if (!config.isRecolorTiles()
				&& (key.equals(ConfigKeys.TILE_HUE_REDUCTION)
				|| key.equals(ConfigKeys.TILE_SATURATION_REDUCTION)
				|| key.equals(ConfigKeys.TILE_LIGHTNESS_REDUCTION))) {
			triggerUpdate = false;
		}

		// Prevent excessive map reloads when config changes are spammed by running them on the next game tick
		if (triggerUpdate) {
			nextReloadTick = client.getTickCount() + 1;
		}
	}

    @Subscribe
	@SuppressWarnings("unused")
	public void onPreMapLoad(PreMapLoad preMapLoad) {
        clientThread.invoke(() -> {
            long start = System.nanoTime();
            recolorMap(preMapLoad.getScene());
            long end = System.nanoTime();
            long duration = end - start;
            log.debug("Map recolor done in {}ms", duration / 1_000_000);
        });
	}

    @Subscribe
	@SuppressWarnings("unused")
	public void onGameTick(GameTick gameTick) {
		if (nextReloadTick != NEXT_REFRESH_UNSET && client.getTickCount() >= nextReloadTick) {
			reloadMap();
			nextReloadTick = NEXT_REFRESH_UNSET;
		}
	}

    @Provides
	@SuppressWarnings({"unused", "PMD.CommentDefaultAccessModifier"})
	WorldRecolorConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(WorldRecolorConfig.class);
	}

	private void recolorMap(Scene scene) {
		if (!canRecolorRegion()) {
			return;
		}

		boolean recolorTiles = config.isRecolorTiles();
		int tileHueReduction = config.getTileHueReduction();
		int tileSaturationReduction = config.getTileSaturationReduction();
		int tileLightnessReduction = config.getTileLightnessReduction();

		// Cache the whole new adjusted color palette at once before recoloring the map
		long colorMapsStart = System.nanoTime();
		tileColorMap.updateColors(tileHueReduction, tileSaturationReduction, tileLightnessReduction);
		long colorMapsEnd = System.nanoTime();

		log.debug("Recolor map... tiles={}", recolorTiles);
		Tile[][][] tiles = scene.getExtendedTiles();

		long tilesDuration = 0;

        for (Tile[][] zTiles : tiles) {
            for (Tile[] xTiles : zTiles) {
                for (Tile tile : xTiles) {
                    if (tile == null) {
                        continue;
                    }

                    tilesDuration += recolorMap(tile, recolorTiles);
                }
            }
        }

		log.debug("Color maps updated in {}ms, tiles colored in {}ms",
			(colorMapsEnd - colorMapsStart) / 1_000_000,
			tilesDuration / 1_000_000
		);
	}

	private long recolorMap(Tile tile, boolean recolor) {
		if (!recolor) {
			return 0;
		}
		long start = System.nanoTime();
		SceneTilePaint paint = tile.getSceneTilePaint();
		if (paint != null && paint.getTexture() == -1) {
			int newNw = tileColorMap.getModifiedHsl(paint.getNwColor());
			int newNe = tileColorMap.getModifiedHsl(paint.getNeColor());
			int newSw = tileColorMap.getModifiedHsl(paint.getSwColor());
			int newSe = tileColorMap.getModifiedHsl(paint.getSeColor());

			paint.setNwColor(newNw);
			paint.setNeColor(newNe);
			paint.setSwColor(newSw);
			paint.setSeColor(newSe);

			tile.setSceneTilePaint(paint);
		}

		SceneTileModel model = tile.getSceneTileModel();
		if (model != null) {
			ColorAdjuster.adjustSceneTileModel(model, tileColorMap);
			tile.setSceneTileModel(model);
		}

		long end = System.nanoTime();
		return end - start;
	}

	public boolean canRecolorRegion() {
		if (includedRegionIds.isEmpty() && excludedRegionIds.isEmpty()) {
			return true;
		}

		WorldPoint worldPoint = client.getLocalPlayer().getWorldLocation();
		WorldPoint instancePoint = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
		int regionId = instancePoint != null ? instancePoint.getRegionID() : worldPoint.getRegionID();

		if (!includedRegionIds.isEmpty()) {
			return includedRegionIds.contains(regionId);
		}

		return !excludedRegionIds.contains(regionId);
	}

	private void loadRegionIds() {
		includedRegionIds.clear();
		excludedRegionIds.clear();

		String includedRegionIdsString = config.getIncludedRegionIds();
		String excludedRegionIdsString = config.getExcludedRegionIds();
		if (includedRegionIdsString.isEmpty() && excludedRegionIdsString.isEmpty()) {
			return;
		}

		includedRegionIds.addAll(
			Pattern.compile("[,\\n]")
				.splitAsStream(includedRegionIdsString)
				.filter(Predicate.not(String::isEmpty))
				.map(Integer::valueOf)
				.collect(Collectors.toList()));

		excludedRegionIds.addAll(
			Pattern.compile("[,\\n]")
				.splitAsStream(excludedRegionIdsString)
					.filter(Predicate.not(String::isEmpty))
					.map(Integer::valueOf)
					.collect(Collectors.toList()));

		if (log.isDebugEnabled()) {
			log.debug("Included region ids: {}, excluded region ids: {}", includedRegionIds.size(), excludedRegionIds.size());
		}
	}

}

package com.github.cubeee.worldrecolor;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public final class WorldRecolorPluginRunner {
	private WorldRecolorPluginRunner() {}

	@SuppressWarnings({"PMD.SignatureDeclareThrowsException", "unchecked"})
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(WorldRecolorPlugin.class);
		RuneLite.main(args);
	}
}

