/*
 * Copyright (c) 2021 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DebugPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DebugPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2021 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicReference;
import lombok.extern.slf4j.Slf4j;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

@Slf4j
public class ProfilerTest
{
	@Before
	public void before()
	{
		Profiler.init();
	}

	private long iteration(long value)
	{
		if ((value & 1) != 0)
		{
			value = value >>> 20 | value << 44;
		}
		else
		{
			value = iteration_inner(value);
		}
		return value;
	}

	private long iteration_inner(long value)
	{
		return value * 31;
	}

	@Test
	public void profile() throws InterruptedException
	{
		Semaphore done = new Semaphore(0);
		AtomicReference<Throwable> failure = new AtomicReference<>();
		Thread test = new Thread(() ->
		{
			long start = System.nanoTime();
			long v = start;
			try
			{
				for (; (System.nanoTime() - start) < 1_000_000_000L; )
				{
					for (long i = 0; i < 0xFFFFL; i++)
					{
						v = iteration(v);
					}
				}
				System.gc();
				for (; (System.nanoTime() - start) < 3_000_000_000L; )
				{
					for (long i = 0; i < 0xFFFFL; i++)
					{
						v = iteration(v);
					}
				}
				Profiler.stop(new byte[0]);
			}
			catch (Throwable t)
			{
				failure.set(t);
				throw t;
			}
			finally
			{
				log.info("got {} in {} ms", v, (System.nanoTime() - start) / 1_000_000);
				done.release();
			}
		}, "profile test thread");
		test.start();
		Profiler.start(new Thread[]{test}, 1024 * 1024, 1000);
		done.acquire();
		if (failure.get() != null)
		{
			Assert.fail();
		}
	}
}

package abex.os.debug;

public class HProfStripperButIntellijIsBroken
{
	// IDEA-220528
	public static void main(String ...args) throws Exception
	{
		HProfStripper.main(args);
	}
}

package abex.os.debug;

import java.io.BufferedOutputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.GZIPOutputStream;
import lombok.RequiredArgsConstructor;

public class HProfStripper
{
	// top-level records
	private final static int
		HPROF_UTF8 = 0x01,
		HPROF_LOAD_CLASS = 0x02,
		HPROF_UNLOAD_CLASS = 0x03,
		HPROF_FRAME = 0x04,
		HPROF_TRACE = 0x05,
		HPROF_ALLOC_SITES = 0x06,
		HPROF_HEAP_SUMMARY = 0x07,
		HPROF_START_THREAD = 0x0A,
		HPROF_END_THREAD = 0x0B,
		HPROF_HEAP_DUMP = 0x0C,
		HPROF_CPU_SAMPLES = 0x0D,
		HPROF_CONTROL_SETTINGS = 0x0E,

	// 1.0.2 record types
	HPROF_HEAP_DUMP_SEGMENT = 0x1C,
		HPROF_HEAP_DUMP_END = 0x2C,

	// field types
	HPROF_ARRAY_OBJECT = 0x01,
		HPROF_NORMAL_OBJECT = 0x02,
		HPROF_BOOLEAN = 0x04,
		HPROF_CHAR = 0x05,
		HPROF_FLOAT = 0x06,
		HPROF_DOUBLE = 0x07,
		HPROF_BYTE = 0x08,
		HPROF_SHORT = 0x09,
		HPROF_INT = 0x0A,
		HPROF_LONG = 0x0B,

	// data-dump sub-records
	HPROF_GC_ROOT_UNKNOWN = 0xFF,
		HPROF_GC_ROOT_JNI_GLOBAL = 0x01,
		HPROF_GC_ROOT_JNI_LOCAL = 0x02,
		HPROF_GC_ROOT_JAVA_FRAME = 0x03,
		HPROF_GC_ROOT_NATIVE_STACK = 0x04,
		HPROF_GC_ROOT_STICKY_CLASS = 0x05,
		HPROF_GC_ROOT_THREAD_BLOCK = 0x06,
		HPROF_GC_ROOT_MONITOR_USED = 0x07,
		HPROF_GC_ROOT_THREAD_OBJ = 0x08,
		HPROF_GC_CLASS_DUMP = 0x20,
		HPROF_GC_INSTANCE_DUMP = 0x21,
		HPROF_GC_OBJ_ARRAY_DUMP = 0x22,
		HPROF_GC_PRIM_ARRAY_DUMP = 0x23;

	private int[] typeSizes;

	private static final byte[] EXPECTED_HEADER = "JAVA PROFILE 1.0.2\0".getBytes(StandardCharsets.UTF_8);

	private final SeekFile in;

	private final DataOutputStream out;

	private long start;
	private int identSize;

	public HProfStripper(File in, File out, boolean zstd) throws IOException
	{
		this.in = new SeekFile(in);
		var fos = new FileOutputStream(out);
		OutputStream gzo;
		if (zstd)
		{
			gzo = new ZstdOutputStream(fos, 9);
		}
		else
		{
			gzo = new GZIPOutputStream(fos)
			{
				{
					this.def.setLevel(3);
				}
			};
		};
		this.out = new DataOutputStream(new BufferedOutputStream(gzo));
	}

	public void run() throws IOException
	{
		try (this.in; this.out)
		{
			{
				byte[] header = new byte[EXPECTED_HEADER.length];
				in.readFully(header);
				if (!Arrays.equals(header, EXPECTED_HEADER))
				{
					throw new IOException("incorrect header " + Arrays.toString(header));
				}
			}
			out.write(EXPECTED_HEADER);

			identSize = in.readInt();
			out.writeInt(identSize);

			typeSizes = new int[]{-1, identSize, identSize, -1, 1, 2, 4, 8, 1, 2, 4, 8};

			// ts
			out.writeInt(in.readInt());
			out.writeInt(in.readInt());

			start = in.offset();

			var fk = new FindKeepers();
			fk.run();
			var emit = new Emit(fk.keepObjects);
			emit.run();
			//emit.sizes.forEach((k, v) -> System.out.println(k + " " + (v / 1024) + "kiB"));
		}
	}

	protected long readId() throws IOException
	{
		if (identSize == 4)
		{
			return in.readU4();
		}
		else if (identSize == 8)
		{
			return in.readLong();
		}
		throw new UnsupportedOperationException("" + identSize);
	}

	protected void writeId(long id) throws IOException
	{
		if (identSize == 4)
		{
			out.writeInt((int) id);
		}
		else if (identSize == 8)
		{
			out.writeLong(id);
		}
		else
		{
			throw new UnsupportedOperationException("" + identSize);
		}
	}

	private class DumpVisitor
	{
		public void run() throws IOException
		{
			try
			{
				in.seek(start);
				for (; in.offset() != in.length(); )
				{
					int tag = in.readByte();
					int ts = in.readInt();
					int bytes = in.readInt();
					section(tag, ts, bytes);
				}
			}
			catch (Exception e)
			{
				throw new IOException(e.getMessage() + " @ " + in.offset(), e);
			}
		}

		protected void section(int tag, int ts, int bytes) throws IOException
		{
			//System.out.println("sect " + tag + " " + in.offset() + " " + (in.offset() + bytes));
			if (tag == HPROF_HEAP_DUMP || tag == HPROF_HEAP_DUMP_SEGMENT)
			{
				long end = in.offset() + bytes;
				for (; in.offset() < end; )
				{
					int dtag = in.readByte();
					long id = readId();
					//System.out.println(dtag + " " + id + " " + in.offset());
					readTag(dtag, id);
				}
				return;
			}
			unknownSection(tag, ts, bytes);
		}

		protected void unknownSection(int tag, int ts, int bytes) throws IOException
		{
			skip(bytes);
		}

		protected void readTag(int tag, long id) throws IOException
		{
			switch (tag)
			{
				case HPROF_GC_ROOT_UNKNOWN:
					break;
				case HPROF_GC_ROOT_THREAD_OBJ:
				case HPROF_GC_ROOT_JNI_LOCAL:
					skip(4 + 4);
					break;
				case HPROF_GC_ROOT_JNI_GLOBAL:
					skip(identSize);
					break;
				case HPROF_GC_ROOT_JAVA_FRAME:
					skip(4 + 4);
					break;
				case HPROF_GC_ROOT_NATIVE_STACK:
					skip(4);
					break;
				case HPROF_GC_ROOT_STICKY_CLASS:
					break;
				case HPROF_GC_ROOT_THREAD_BLOCK:
					skip(4);
					break;
				case HPROF_GC_ROOT_MONITOR_USED:
					break;
				case HPROF_GC_CLASS_DUMP:
				{
					skip(4 + identSize + identSize + identSize + identSize + identSize + identSize + 4);
					int cpsize = in.readUnsignedShort();
					if (cpsize != 0)
					{
						throw new IllegalArgumentException();
					}
					int numStatics = in.readUnsignedShort();
					for (int i = 0; i < numStatics; i++)
					{
						skip(identSize);
						int ty = in.readByte();
						skip(typeSizes[ty]);
					}
					int numInsts = in.readUnsignedShort();
					skip(numInsts * (identSize + 1));
					break;
				}
				case HPROF_GC_INSTANCE_DUMP:
					skip(4 + identSize);
					skip(in.readInt());
					break;
				case HPROF_GC_OBJ_ARRAY_DUMP:
				{
					skip(4);
					int count = in.readInt();
					skip(identSize);
					skip(count * identSize);
					break;
				}
				case HPROF_GC_PRIM_ARRAY_DUMP:
				{
					skip(4);
					int count = in.readInt();
					int type = in.readByte();
					skip(count * typeSizes[type]);
					break;
				}
				default:
					throw new IllegalArgumentException(tag + "@" + in.offset());
			}
		}
	}

	@RequiredArgsConstructor
	private static class ClassMetadata
	{
		final long parent;
		final byte[] types;
	}

	private class FindKeepers extends DumpVisitor
	{
		int pass = 0;
		Map<Long, ClassMetadata> keepObjects = new HashMap<>();
		Map<Long, Integer> recursiveKeepObjects = new HashMap<>();
		boolean added;

		@Override
		public void run() throws IOException
		{
			for (pass = 0; pass == 0 || (recursiveKeepObjects.size() > 0 && added); pass++)
			{
				added = false;
				super.run();
				//System.out.println(pass + " " + recursiveKeepObjects.size() + " " + added);
			}
		}

		@Override
		protected void section(int tag, int ts, int bytes) throws IOException
		{
			if (tag == HPROF_UTF8)
			{
				long id = readId();
				recursiveKeepObjects.remove(id);
				keepObjects.putIfAbsent(id, null);
				skip(bytes - identSize);
				return;
			}

			if (pass == 0)
			{
				if (tag == HPROF_LOAD_CLASS)
				{
					skip(4 + identSize + 4);
					keep(readId(), 2); // class name
					return;
				}
				if (tag == HPROF_FRAME)
				{
					skip(identSize);
					keep(readId(), 1);
					keep(readId(), 1);
					keep(readId(), 1);
					skip(4 + 4);
					return;
				}
				if (tag == HPROF_START_THREAD)
				{
					skip(4 + identSize + 4);
					keep(readId(), 1);
					keep(readId(), 1);
					keep(readId(), 1);
					return;
				}
			}

			super.section(tag, ts, bytes);
		}

		@Override
		protected void readTag(int tag, long id) throws IOException
		{
			Integer keep = recursiveKeepObjects.remove(id);
			if (keep != null)
			{
				keepObjects.putIfAbsent(id, null);
			}
			switch (tag)
			{
				case HPROF_GC_INSTANCE_DUMP:
					if (keep != null)
					{
						skip(4);
						long clazz = readId();
						int size = in.readInt();
						long end = in.offset() + size;
						// strings or smaller
						int sizeClass = size > 5 + identSize ? 1 : 0;

						for (; clazz != 0; )
						{
							ClassMetadata meta = keepObjects.get(clazz);
							if (meta == null)
							{
								recursiveKeepObjects.put(id, keep);
								break;
							}
							for (byte ty : meta.types)
							{
								if (ty == HPROF_ARRAY_OBJECT || ty == HPROF_NORMAL_OBJECT)
								{
									keep(readId(), keep - sizeClass);
								}
								else
								{
									skip(typeSizes[ty]);
								}
							}
							clazz = meta.parent;
						}

						skip((int) (end - in.offset()));
						return;
					}
					break;
				case HPROF_GC_OBJ_ARRAY_DUMP:
					if (keep != null)
					{
						skip(4);
						int count = in.readInt();
						skip(identSize);
						for (int i = 0; i < count; i++)
						{
							keep(readId(), keep - 1);
						}
						return;
					}
					break;
				case HPROF_GC_CLASS_DUMP:
					if (pass == 0)
					{
						skip(4);
						long superclass = readId();
						long cl = readId();
						keep(cl, 3);
						readId();
						readId();
						readId();
						readId();
						in.readInt();
						int cpsize = in.readUnsignedShort();
						if (cpsize != 0)
						{
							throw new IllegalArgumentException();
						}
						int numStatics = in.readUnsignedShort();
						for (int i = 0; i < numStatics; i++)
						{
							long name = readId();
							keep(name, 2);
							int ty = in.readByte();
							skip(typeSizes[ty]);
						}
						int numInsts = in.readUnsignedShort();
						byte[] types = new byte[numInsts];
						for (int i = 0; i < numInsts; i++)
						{
							long name = readId();
							byte ty = in.readByte();
							keep(name, 2);
							types[i] = ty;
						}
						keepObjects.put(id, new ClassMetadata(superclass, types));
						return;
					}
					break;
			}

			super.readTag(tag, id);
		}

		private void keep(long id, int depth)
		{
			if (depth <= 0 || id == 0)
			{
				return;
			}

			Long id0 = id;
			if (!keepObjects.containsKey(id0))
			{
				added |= recursiveKeepObjects.compute(id0, (_k, v) -> Math.max(v == null ? 0 : v, depth)) == depth;
			}
		}
	}


	@RequiredArgsConstructor
	private class Emit extends DumpVisitor
	{
		final Map<Long, ClassMetadata> keepObjects;
		final Map<Integer, Long> sizes = new HashMap<>();

		@Override
		protected void section(int tag, int ts, int bytes) throws IOException
		{
			out.writeByte(tag);
			out.writeInt(ts);
			out.writeInt(bytes);

			sizes.compute(tag, (_k, v) -> bytes + (v == null ? 0 : v));

			if (tag == HPROF_UTF8)
			{
				long id = readId();
				writeId(id);
				int rem = bytes - identSize;
				if (keepObjects.containsKey(id))
				{
					in.copyTo(out, rem);
				}
				else
				{
					zero(rem);
				}
			}
			else
			{
				super.section(tag, ts, bytes);
			}
		}

		@Override
		protected void unknownSection(int tag, int ts, int bytes) throws IOException
		{
			in.copyTo(out, bytes);
		}

		@Override
		protected void readTag(int tag, long obj) throws IOException
		{
			out.writeByte(tag);
			writeId(obj);

			switch (tag)
			{
				case HPROF_GC_ROOT_UNKNOWN:
					break;
				case HPROF_GC_ROOT_THREAD_OBJ:
					out.writeInt(in.readInt());
					out.writeInt(in.readInt());
					break;
				case HPROF_GC_ROOT_JNI_GLOBAL:
					writeId(readId());
					break;
				case HPROF_GC_ROOT_JNI_LOCAL:
					out.writeInt(in.readInt());
					out.writeInt(in.readInt());
					break;
				case HPROF_GC_ROOT_JAVA_FRAME:
					out.writeInt(in.readInt());
					out.writeInt(in.readInt());
					break;
				case HPROF_GC_ROOT_NATIVE_STACK:
					out.writeInt(in.readInt());
					break;
				case HPROF_GC_ROOT_STICKY_CLASS:
					break;
				case HPROF_GC_ROOT_THREAD_BLOCK:
					out.writeInt(in.readInt());
					break;
				case HPROF_GC_ROOT_MONITOR_USED:
					break;
				case HPROF_GC_CLASS_DUMP:
				{
					in.copyTo(out, 4 + identSize + identSize + identSize + identSize + identSize + identSize + 4);
					int cpsize = in.readUnsignedShort();
					out.writeShort(cpsize);
					if (cpsize != 0)
					{
						throw new IllegalArgumentException();
					}
					int numStatics = in.readUnsignedShort();
					out.writeShort(numStatics);
					for (int i = 0; i < numStatics; i++)
					{
						writeId(readId());
						int ty = in.readByte();
						out.writeByte(ty);
						if (ty == HPROF_ARRAY_OBJECT || ty == HPROF_NORMAL_OBJECT)
						{
							writeId(readId());
						}
						else
						{
							in.copyTo(out, typeSizes[ty]);
						}
					}
					int numInsts = in.readUnsignedShort();
					out.writeShort(numInsts);
					in.copyTo(out, numInsts * (identSize + 1L));
					break;
				}
				case HPROF_GC_INSTANCE_DUMP:
				{
					out.writeInt(in.readInt());
					long clazz = readId();
					writeId(clazz);
					int size = in.readInt();
					out.writeInt(size);
					if (keepObjects.containsKey(obj))
					{
						in.copyTo(out, size);
					}
					else
					{
						for (; clazz != 0; )
						{
							ClassMetadata meta = keepObjects.get(clazz);
							for (byte ty : meta.types)
							{
								if (ty == HPROF_ARRAY_OBJECT || ty == HPROF_NORMAL_OBJECT)
								{
									writeId(readId());
								}
								else
								{
									zero(typeSizes[ty]);
								}
							}
							clazz = meta.parent;
						}
					}
					break;
				}
				case HPROF_GC_OBJ_ARRAY_DUMP:
				{
					out.writeInt(in.readInt());
					int count = in.readInt();
					out.writeInt(count);
					in.copyTo(out, identSize + ((long) count * identSize));
					break;
				}
				case HPROF_GC_PRIM_ARRAY_DUMP:
				{
					out.writeInt(in.readInt());
					int count = in.readInt();
					out.writeInt(count);
					int type = in.readByte();
					out.writeByte(type);
					int size = count * typeSizes[type];
					if (keepObjects.containsKey(obj))
					{
						in.copyTo(out, size);
					}
					else
					{
						zero(size);
					}
					break;
				}
				default:
					throw new IllegalArgumentException("" + tag);
			}

			assert out.size() == (int) Math.min(Integer.MAX_VALUE, in.offset()) : tag;
		}
	}

	private final byte[] zero = new byte[256];

	private void zero(int bytes) throws IOException
	{
		skip(bytes);
		for (; bytes > 0; )
		{
			int chunk = Math.min(zero.length, bytes);
			out.write(zero, 0, chunk);
			bytes -= chunk;
		}
	}

	private void skip(int bytes) throws IOException
	{
		for (; bytes > 0; )
		{
			int read = in.skipBytes(bytes);
			if (read < 0)
			{
				throw new EOFException();
			}
			bytes -= read;
		}
	}

	public static void main(String... args) throws IOException
	{
		ZstdOutputStream.init();
		new HProfStripper(new File(args[0]), new File(args[1]), true).run();
	}
}

/*
 * Copyright (c) 2023 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import com.google.common.io.PatternFilenameFilter;
import com.google.gson.Gson;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.Comparator;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.util.OSType;

@Slf4j
@Singleton
public class CoreDumpPanel extends JPanel
{
	private final JLabel statusLabel = new JLabel();
	private final JCheckBox checkBox = new JCheckBox("Core Dumps");
	private final ConfigManager configManager;
	private VMConfigPatch patch;

	@Inject
	public CoreDumpPanel(ConfigManager configManager, Gson gson, @Named("developerMode") boolean developerMode)
	{
		this.configManager = configManager;

		if (developerMode)
		{
			JButton crash = new JButton("crash the client");
			crash.addActionListener(_ev ->
			{
				try
				{
					Class<?> unsafe = Class.forName("sun.misc.Unsafe");
					Field f = unsafe.getDeclaredField("theUnsafe");
					f.setAccessible(true);
					Object theUnsafe = f.get(null);
					unsafe.getMethod("getInt", long.class).invoke(theUnsafe, 0L);
				}
				catch (ReflectiveOperationException e)
				{
					log.warn("", e);
				}
			});
			add(crash);
		}

		if (OSType.getOSType() != OSType.Windows)
		{
			return;
		}

		this.patch = new VMConfigPatch(gson, "Coredumps", "-XX:+CreateCoredumpOnCrash");
		statusLabel.setText(patch.status());

		setLayout(new DynamicGridLayout(0, 1));

		add(checkBox);
		add(statusLabel);

		checkExistingDumps();
		checkBox.setEnabled(VMConfigPatch.isSupported());
		checkBox.setSelected(configManager.getConfiguration(DebugConfig.GROUP, DebugConfig.CREATE_CORE_DUMP, boolean.class) == Boolean.TRUE);
		checkBox.addChangeListener(e ->
		{
			configManager.setConfiguration(DebugConfig.GROUP, DebugConfig.CREATE_CORE_DUMP, checkBox.isSelected());
		});

		patch();
	}

	private void checkExistingDumps()
	{
		File[] dumps = new File(".").getAbsoluteFile().listFiles(new PatternFilenameFilter("hs_err_pid.*\\.mdmp$"));
		if (dumps == null || dumps.length <= 0)
		{
			return;
		}
		if (dumps.length > 1)
		{
			Arrays.sort(dumps, Comparator.comparing(File::lastModified).reversed());
			for (int i = 1; i < dumps.length; i++)
			{
				log.info("deleting {}", dumps[i]);
				dumps[i].delete();
			}
		}

		JButton lastDump = new JButton("Open last coredump");
		lastDump.addActionListener(_ev -> DebugPlugin.openExplorer(dumps[0]));
		add(lastDump);
	}

	public void patch()
	{
		if (OSType.getOSType() != OSType.Windows || !VMConfigPatch.isSupported())
		{
			return;
		}

		boolean enabled = configManager.getConfiguration(DebugConfig.GROUP, DebugConfig.CREATE_CORE_DUMP, boolean.class) == Boolean.TRUE;
		patch.set(enabled);
		SwingUtilities.invokeLater(() ->
		{
			checkBox.setSelected(enabled);
			statusLabel.setText(patch.status());
		});
	}

}

package abex.os.debug;

import java.io.DataInputStream;
import java.io.EOFException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;

public class SeekFile extends DataInputStream
{
	private final Input input;

	public SeekFile(File file) throws IOException
	{
		this(new Input(file));
	}

	private SeekFile(Input input)
	{
		super(input);
		this.input = input;
	}

	private static class Input extends InputStream
	{
		private static final int PAGE_MASK = 4095;
		private final RandomAccessFile raf;
		private long rafPtr;
		private long end;
		private final byte[] page = new byte[PAGE_MASK + 1];
		private long pagePtr = -1;
		private long ptr = 0;

		Input(File file) throws IOException
		{
			raf = new RandomAccessFile(file, "r");
			end = raf.length();
		}

		@Override
		public int read() throws IOException
		{
			buffer();
			if (ptr >= end)
			{
				return -1;
			}
			return page[(int) ptr++ & PAGE_MASK] & 0xFF;
		}

		@Override
		public int read(byte[] b, int off, int len) throws IOException
		{
			if (ptr >= end)
			{
				return -1;
			}

			if (bufAvailable() < 0 && len >= PAGE_MASK)
			{
				if (rafPtr != ptr)
				{
					raf.seek(ptr);
					rafPtr = ptr;
				}
				int read = raf.read(b, off, (len / page.length) * page.length);
				if (read > 0)
				{
					rafPtr += read;
				}
				return read;
			}
			buffer();

			int read = Math.min(len, bufAvailable());
			System.arraycopy(page, (int) ptr & PAGE_MASK, b, off, read);
			ptr += read;
			return read;
		}

		@Override
		public long skip(long n) throws IOException
		{
			long start = ptr;
			ptr = Math.min(ptr + n, end);
			return ptr - start;
		}

		@Override
		public int available() throws IOException
		{
			return (int) Math.min(Integer.MAX_VALUE, end - ptr);
		}

		@Override
		public long transferTo(OutputStream out) throws IOException
		{
			return copyTo(out, end - ptr);
		}

		public long copyTo(OutputStream out, long bytes) throws IOException
		{
			long start = ptr;
			long end = Math.min(this.end, ptr + bytes);
			for (; ptr < end; )
			{
				buffer();
				int read = Math.min((int) (end - ptr), bufAvailable());
				out.write(page, (int) ptr & PAGE_MASK, read);
				ptr += read;
			}
			return ptr - start;
		}

		private void buffer() throws IOException
		{
			if (pagePtr == (ptr & ~PAGE_MASK))
			{
				return;
			}
			pagePtr = ptr & ~PAGE_MASK;
			if (rafPtr != pagePtr)
			{
				raf.seek(pagePtr);
				rafPtr = pagePtr;
			}

			int fill = 0;
			for (; fill < page.length && rafPtr < end; )
			{
				int read = raf.read(page, fill, page.length - fill);
				if (read < 0)
				{
					throw new EOFException();
				}
				fill += read;
				rafPtr += read;
			}
		}

		private int bufAvailable()
		{
			long bufEnd = Math.min(pagePtr + page.length, end);
			return (int) (bufEnd - ptr);
		}

		@Override
		public void close() throws IOException
		{
			super.close();
		}
	}

	public void seek(long to)
	{
		input.ptr = to;
	}

	public long offset()
	{
		return input.ptr;
	}

	public void copyTo(OutputStream out, long bytes) throws IOException
	{
		input.copyTo(out, bytes);
	}

	@Override
	public void close() throws IOException
	{
		super.close();
	}

	public long readU4() throws IOException
	{
		return readInt() & 0xFFFF_FFFFL;
	}

	public long length()
	{
		return input.end;
	}
}

/*
 * Copyright (c) 2022 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import javax.inject.Inject;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigDescriptor;
import net.runelite.client.config.ConfigItemDescriptor;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.ModifierlessKeybind;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;

public class KeybindsPanel extends JPanel
{
	private final ConfigManager configManager;
	private final PluginManager pluginManager;

	@Inject
	public KeybindsPanel(ConfigManager configManager, PluginManager pluginManager)
	{
		this.configManager = configManager;
		this.pluginManager = pluginManager;

		setLayout(new DynamicGridLayout(0, 1));

		JButton displayKeybinds = new JButton("Display Keybinds");
		add(displayKeybinds);
		displayKeybinds.addActionListener(ev -> showKeybindsPanel());
	}

	private void showKeybindsPanel()
	{
		JTextArea textArea = new JTextArea(showKeybinds(), 30, 50);
		textArea.setFont(FontManager.getDefaultFont().deriveFont(12.f));
		JOptionPane.showMessageDialog(null, new JScrollPane(textArea), "Keybinds", JOptionPane.INFORMATION_MESSAGE);
	}

	private String showKeybinds()
	{
		String out = "";
		for (Plugin plugin : pluginManager.getPlugins())
		{
			if (!pluginManager.isPluginEnabled(plugin))
			{
				continue;
			}

			Config config = pluginManager.getPluginConfigProxy(plugin);
			ConfigDescriptor cd = config == null ? null : configManager.getConfigDescriptor(config);
			if (cd == null)
			{
				continue;
			}

			for (ConfigItemDescriptor cid : cd.getItems())
			{
				if (cid.getType() == Keybind.class || cid.getType() == ModifierlessKeybind.class)
				{
					Keybind keybind = configManager.getConfiguration(cd.getGroup().value(), cid.getItem().keyName(), cid.getType());
					if (Keybind.NOT_SET.equals(keybind))
					{
						continue;
					}

					out += plugin.getName() + " " + cid.name() + ": " + keybind + "\n";
				}
			}
		}

		return out;
	}
}

package abex.os.debug;

import java.io.IOException;
import java.io.OutputStream;

public class ZstdOutputStream extends OutputStream
{
	private static final int ZSTD_E_CONTINUE = 0;
	private static final int ZSTD_E_FLUSH = 1;
	private static final int ZSTD_E_END = 2;

	private final OutputStream out;
	private final byte[] outBuf;
	private final byte[] inBuf;
	private int inBufPtr;
	private long stream;

	public static void init()
	{
		// libprofiler uses zstd too, so we just reuse that
		Profiler.init();
	}

	public ZstdOutputStream(OutputStream out, int level)
	{
		this.out = out;
		this.outBuf = new byte[cStreamOutSize()];
		this.inBuf = new byte[cStreamInSize()];
		this.stream = new0(level);
		if (this.stream == 0)
		{
			throw new RuntimeException();
		}
	}

	@Override
	public void write(int b) throws IOException
	{
		if (inBufPtr + 1 >= inBuf.length)
		{
			flushBuffer(ZSTD_E_CONTINUE);
		}

		inBuf[inBufPtr++] = (byte) b;
	}

	@Override
	public void write(byte[] b, int off, int len) throws IOException
	{
		if (len >= 32)
		{
			flushBuffer(ZSTD_E_CONTINUE);
			compress(b, off, len, ZSTD_E_CONTINUE);
		}
		else
		{
			int size = Math.min(len, inBuf.length - inBufPtr);
			System.arraycopy(b, off, inBuf, inBufPtr, size);
			inBufPtr += size;
			if (size != len)
			{
				off += size;
				len = len - size;
				System.arraycopy(b, off, inBuf, inBufPtr, len);
			}
		}
	}

	@Override
	public void flush() throws IOException
	{
		flushBuffer(ZSTD_E_FLUSH);
		out.flush();
	}

	@Override
	public void close() throws IOException
	{
		flushBuffer(ZSTD_E_END);
		free();
		out.close();
	}

	public void free()
	{
		free0(stream);
		stream = 0;
	}

	private void flushBuffer(int endOp) throws IOException
	{
		compress(inBuf, 0, inBufPtr, endOp);
		inBufPtr = 0;
	}

	private void compress(byte[] buf, int off, int len, int endOp) throws IOException
	{
		for (; ; )
		{
			long res = compress0(stream, buf, off, len, outBuf, endOp);
			int wr = (int) (res >> 32);
			off += wr;
			len -= wr;
			int outLen = ((int) res) & 0x7FFF_FFFF;
			if (outLen > 0)
			{
				out.write(outBuf, 0, outLen);
			}
			boolean more = ((res >> 31) & 1) != 0;
			if (len > 0 || (endOp != ZSTD_E_CONTINUE && more))
			{
				continue;
			}
			break;
		}
	}

	private static native int cStreamInSize();

	private static native int cStreamOutSize();

	private static native long new0(int level);

	private static native void free0(long stream);

	private static native long compress0(long stream, byte[] bytes, int off, int len, byte[] out, int endOp) throws IOException;
}

package abex.os.debug;

import com.google.common.base.Strings;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.platform.win32.BaseTSD;
import com.sun.jna.platform.win32.WinNT;
import com.sun.jna.win32.StdCallLibrary;
import com.sun.jna.win32.W32APIOptions;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFileChooser;
import javax.swing.JPanel;
import javax.swing.filechooser.FileSystemView;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.util.OSType;

@Slf4j
public class VirtualMemoryPanel extends JPanel
{
	VirtualMemoryPanel()
	{
		if (OSType.getOSType() != OSType.Windows)
		{
			return;
		}

		setLayout(new DynamicGridLayout(0, 1));

		JButton vmem = new JButton("Virtual Memory");
		vmem.addActionListener(_ev ->
		{
			JFileChooser fc = new JFileChooser();
			fc.setDialogTitle("Save page table");
			fc.setSelectedFile(new File(FileSystemView.getFileSystemView().getDefaultDirectory(), "vmem.txt"));
			if (fc.showSaveDialog(this) != JFileChooser.APPROVE_OPTION)
			{
				return;
			}

			recordVirtualMemory(fc.getSelectedFile());
		});

		JCheckBox onOOM = new JCheckBox("Record VMem on OOM");
		onOOM.addItemListener(ev ->
		{
			if (onOOM.isSelected())
			{
				onOOM.setEnabled(false);

				Thread.UncaughtExceptionHandler rl = Thread.getDefaultUncaughtExceptionHandler();
				Thread.setDefaultUncaughtExceptionHandler((thread, throwable) ->
				{
					if (throwable instanceof OutOfMemoryError)
					{
						recordVirtualMemory(new File(RuneLite.LOGS_DIR, "vmem.txt"));
					}
					rl.uncaughtException(thread, throwable);
				});
			}
		});
		add(onOOM);

		add(vmem);
	}

	private void recordVirtualMemory(File file)
	{
		K32 k32 = Native.load("kernel32", K32.class, W32APIOptions.DEFAULT_OPTIONS);

		try (Writer writer = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8)))
		{
			WinNT.MEMORY_BASIC_INFORMATION info = new WinNT.MEMORY_BASIC_INFORMATION();
			Pointer offset = Pointer.createConstant(0);
			for (; ; )
			{
				long size = k32.VirtualQuery(offset, info, new BaseTSD.SIZE_T(info.size())).longValue();
				if (size <= 0)
				{
					writer.append("err=").append("" + Native.getLastError()).append('\n');
					break;
				}

				long skip = Pointer.nativeValue(info.baseAddress) - Pointer.nativeValue(offset);
				if (skip > 0)
				{
					writer.append(hex(skip)).append(" free\n");
				}

				long end = Pointer.nativeValue(info.baseAddress) + info.regionSize.longValue();
				writer
					.append(hex(Pointer.nativeValue(info.baseAddress)))
					.append('-')
					.append(hex(end))
					.append(' ')
					.append(hex(info.regionSize.longValue()))
					.append(' ')
					.append(Pointer.nativeValue(info.allocationBase) == Pointer.nativeValue(info.baseAddress) ? 's' : ' ')
					.append(" | ")
					.append((info.protect.intValue() & WinNT.PAGE_EXECUTE) != 0 ? "x " : "  ")
					.append((info.protect.intValue() & WinNT.PAGE_EXECUTE_READ) != 0 ? "rx " : "   ")
					.append((info.protect.intValue() & WinNT.PAGE_EXECUTE_READWRITE) != 0 ? "rwx " : "    ")
					.append((info.protect.intValue() & 0x80 /*PAGE_EXECUTE_WRITECOPY*/) != 0 ? "rcx " : "    ")
					.append((info.protect.intValue() & WinNT.PAGE_NOACCESS) != 0 ? "F " : "  ")
					.append((info.protect.intValue() & WinNT.PAGE_READONLY) != 0 ? "r " : "  ")
					.append((info.protect.intValue() & WinNT.PAGE_READWRITE) != 0 ? "rw " : "   ")
					.append((info.protect.intValue() & WinNT.PAGE_WRITECOPY) != 0 ? "rc " : "   ")
					.append((info.protect.intValue() & WinNT.PAGE_GUARD) != 0 ? 'g' : ' ')
					.append((info.protect.intValue() & 0x200 /*PAGE_NOCACHE*/) != 0 ? 'P' : ' ')
					.append(" | ")
					.append((info.state.intValue() & WinNT.MEM_COMMIT) != 0 ? 'c' : ' ')
					.append((info.state.intValue() & WinNT.MEM_FREE) != 0 ? 'f' : ' ')
					.append((info.state.intValue() & WinNT.MEM_RESERVE) != 0 ? 'r' : ' ')
					.append(" | ")
					.append((info.type.intValue() & WinNT.MEM_IMAGE) != 0 ? 'i' : ' ')
					.append((info.type.intValue() & WinNT.MEM_MAPPED) != 0 ? 'm' : ' ')
					.append((info.type.intValue() & WinNT.MEM_PRIVATE) != 0 ? 'p' : ' ')
					.append(" protect=")
					.append(Integer.toHexString(info.protect.intValue()))
					.append(" allocProtect=")
					.append(Integer.toHexString(info.allocationProtect.intValue()))
					.append('\n');

				if (end < Pointer.nativeValue(offset))
				{
					break;
				}

				Pointer.nativeValue(offset, end);
			}
		}
		catch (IOException e)
		{
			log.warn("unable to write page table", e);
		}
	}

	private static String hex(long value)
	{
		return "0x" + Strings.padStart(Long.toHexString(value), Native.POINTER_SIZE * 2, '0');
	}

	public interface K32 extends StdCallLibrary
	{
		BaseTSD.SIZE_T VirtualQuery(Pointer lpAddress, WinNT.MEMORY_BASIC_INFORMATION lpBuffer, BaseTSD.SIZE_T dwLength);
	}
}

/*
 * Copyright (c) 2021 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import com.google.common.io.ByteStreams;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;
import java.lang.management.MemoryUsage;
import java.util.Locale;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.OSType;

@Slf4j
public class Profiler
{
	public enum Status
	{
		NOT_RUNNING(0),
		RUNNING(1),
		FAILED(2),
		STOPPED(3),
		;

		Status(int ordinal)
		{
			assert this.ordinal() == ordinal;
		}
	}

	private static final long[] heapinfo = new long[4];
	private static final MemoryMXBean memBean = ManagementFactory.getMemoryMXBean();

	private static boolean initialized = false;

	public static synchronized void init()
	{
		if (!initialized)
		{
			initialized = true;
			String os = OSType.getOSType().name().toLowerCase(Locale.US);
			String name = "invalid";
			String suffix = ".invalid";
			String arch = System.getProperty("os.arch");
			switch (OSType.getOSType())
			{
				case Windows:
					name = "profiler";
					suffix = ".dll";
					break;
				case Linux:
					name = "libProfiler";
					suffix = ".so";
					break;
				case MacOS:
					name = "libProfiler";
					suffix = ".dylib";
					arch = "universal";
					break;
			}
			String path = "/natives/" + os + "-" + arch + "/" + name + suffix;
			log.info("loading libProfiler from " + path);

			try (InputStream is = Profiler.class.getResourceAsStream(path))
			{
				if (is == null)
				{
					if (Profiler.class.getResource("/natives/cibuilt") == null && System.getenv("RUNELITE_DEBUG_NATIVE_PATH") != null)
					{
						Runtime.getRuntime().load(System.getenv("RUNELITE_DEBUG_NATIVE_PATH"));
						return;
					}

					throw new RuntimeException("no natives: " + path);
				}

				File tmp = File.createTempFile("libprofiler", suffix);
				tmp.deleteOnExit();

				try (FileOutputStream fos = new FileOutputStream(tmp))
				{
					ByteStreams.copy(is, fos);
				}

				Runtime.getRuntime().load(tmp.getAbsolutePath());
			}
			catch (IOException e)
			{
				throw new RuntimeException(e);
			}

			log.info("libProfiler loaded");
		}
	}

	@SuppressWarnings("InstantiatingAThreadWithDefaultRunMethod")
	public static void start(Thread[] threads, int bufferSize, int sampleDelay)
	{
		init();
		int err = start0(new Thread("Profiler Agent"), threads, bufferSize, sampleDelay);
		if (err != 0)
		{
			throw new RuntimeException("Profiler error " + err);
		}
	}

	private static native int start0(Thread agentThread, Thread[] threads, int sampleBufferSize, int sampleDelay);

	public static byte[] stop(byte[] extra)
	{
		int err = stop0(extra);
		if (err != 0)
		{
			free();
			throw new RuntimeException("Profiler error " + err);
		}

		byte[] buf = getBuffer();
		free();

		return buf;
	}

	// called by native code
	private static long[] heapinfo()
	{
		MemoryUsage heap = memBean.getHeapMemoryUsage();
		heapinfo[0] = heap.getUsed();
		heapinfo[1] = heap.getCommitted();

		MemoryUsage offheap = memBean.getNonHeapMemoryUsage();
		heapinfo[2] = offheap.getUsed();
		heapinfo[3] = offheap.getCommitted();

		return heapinfo;
	}

	private static native int pushEvent0(int id, int[] data);

	public static void pushEvent(int id, int[] data)
	{
		int err = pushEvent0(id, data);
		if (err != 0)
		{
			throw new RuntimeException("Profiler error " + err);
		}
	}

	private static native int stop0(byte[] extra);

	private static native int free();

	private static native byte[] getBuffer();

	private static native int status0();

	public static Status status()
	{
		return Status.values()[status0()];
	}

	public static native int bufferOffset();

	public static native int bufferSize();
}

/*
 * Copyright (c) 2021 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import java.awt.Dimension;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.GroupLayout;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

@Slf4j
@Singleton
public class DebugPanel extends PluginPanel
{
	@Inject
	public DebugPanel(
		ManagementPanel managementPanel,
		KeybindsPanel keybindsPanel,
		HeapDumpPanel heapDumpPanel,
		CoreDumpPanel coreDumpPanel,
		VirtualMemoryPanel virtualMemoryPanel,
		ProfilerPanel profilerPanel)
	{
		GroupLayout layout = new GroupLayout(this);
		setLayout(layout);
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));

		layout.setHorizontalGroup(layout.createParallelGroup()
			.addComponent(managementPanel)
			.addComponent(keybindsPanel)
			.addComponent(heapDumpPanel)
			.addComponent(coreDumpPanel)
			.addComponent(virtualMemoryPanel)
			.addComponent(profilerPanel));
		layout.setVerticalGroup(layout.createSequentialGroup()
			.addComponent(managementPanel)
			.addComponent(keybindsPanel)
			.addComponent(heapDumpPanel)
			.addComponent(coreDumpPanel)
			.addComponent(virtualMemoryPanel)
			.addComponent(profilerPanel));
	}
}

/*
 * Copyright (c) 2021 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import com.google.inject.Provider;
import com.google.inject.Provides;
import java.io.File;
import java.io.IOException;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.OSType;

@Slf4j
@PluginDescriptor(
	name = "Debug"
)
public class DebugPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private DebugConfig config;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Provider<DebugPanel> panelProvider;

	@Inject
	private Provider<CoreDumpPanel> coreDumpPanel;

	@Inject
	private Provider<HeapDumpPanel> heapDumpPanel;

	NavigationButton panelButton;

	@Override
	protected void startUp() throws Exception
	{
		panelButton = NavigationButton.builder()
			.panel(panelProvider.get())
			.icon(ImageUtil.loadImageResource(DebugPlugin.class, "panel.png"))
			.tooltip("Debug")
			.priority(9999)
			.build();

		clientToolbar.addNavigation(panelButton);

		coreDumpPanel.get().patch();
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(panelButton);
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged ev)
	{
		if (DebugConfig.GROUP.equals(ev.getGroup()))
		{
			if (DebugConfig.CREATE_CORE_DUMP.equals(ev.getKey()))
			{
				coreDumpPanel.get().patch();
			}
			if (DebugConfig.CREATE_HEAP_DUMP.equals(ev.getKey()))
			{
				heapDumpPanel.get().apply();
			}
		}
	}

	@Provides
	DebugConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DebugConfig.class);
	}

	public static void openExplorer(File path)
	{
		if (OSType.getOSType() == OSType.Windows)
		{
			try
			{
				new ProcessBuilder("explorer", "/select,\"" + path.getAbsolutePath() + "\"")
					.start();
			}
			catch (IOException e)
			{
				log.warn("", e);
			}
		}
		else
		{
			LinkBrowser.open(path.getParentFile().getAbsolutePath());
		}
	}
}

/*
 * Copyright (c) 2021 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import com.google.common.collect.ImmutableList;
import com.google.gson.Gson;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Function;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.Timer;
import javax.swing.filechooser.FileSystemView;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.eventbus.EventBus;

@Slf4j
@Singleton
public class ProfilerPanel extends JPanel
{
	private static final String KEY_SETUP = "setup";
	private static final String KEY_RUNNING = "running";
	private static final String KEY_STOPPED = "stopped";
	private static final String KEY_FAILURE = "failure";

	private final Client client;
	private final Gson gson;
	private final EventBus eventBus;

	private final SetupPanel setupPanel = new SetupPanel();
	private final RunningPanel runningPanel = new RunningPanel();
	private final StoppedPanel stoppedPanel = new StoppedPanel();
	private final FailurePanel failurePanel = new FailurePanel();

	private final CardLayout layout = new CardLayout();

	private final Map<String, Object> extra = new HashMap<>();

	private final List<EventEvent<?>> eventEvents = ImmutableList.of(
		new EventEvent<>(0x10001, GameStateChanged.class, e -> new int[]{e.getGameState().getState()}),
		new EventEvent<>(0x10002, GameTick.class)
	);

	private Thread executorThread;
	private byte[] data;

	private class SetupPanel extends JPanel
	{
		private final JButton start = new JButton("Start profiling");
		private final JSpinner sampleDelay = new JSpinner(new SpinnerNumberModel(1000, 0, 100_000, 100));
		private final JSpinner sampleBufferSize = new JSpinner(new SpinnerNumberModel(7 * 1024, 1024, 128 * 1024, 1));

		{
			start.addActionListener(ev -> startProfiling());
			sampleDelay.setToolTipText("How many µs per sample");
			sampleBufferSize.setToolTipText("How many KiB to reserve for storing samples");

			JLabel sampleDelayLabel = new JLabel("µs per sample");
			JLabel sampleBufferSizeLabel = new JLabel("KiB buffer");

			GroupLayout l = new GroupLayout(this);
			setLayout(l);
			l.setHorizontalGroup(l.createParallelGroup()
				.addGroup(l.createSequentialGroup()
					.addComponent(sampleDelay)
					.addComponent(sampleDelayLabel))
				.addGroup(l.createSequentialGroup()
					.addComponent(sampleBufferSize)
					.addComponent(sampleBufferSizeLabel))
				.addComponent(start));
			l.setVerticalGroup(l.createSequentialGroup()
				.addGroup(l.createParallelGroup(GroupLayout.Alignment.BASELINE)
					.addComponent(sampleDelay)
					.addComponent(sampleDelayLabel))
				.addGroup(l.createParallelGroup(GroupLayout.Alignment.BASELINE)
					.addComponent(sampleBufferSize)
					.addComponent(sampleBufferSizeLabel))
				.addComponent(start));
		}
	}

	private class RunningPanel extends JPanel
	{
		private final JButton stop = new JButton("Stop profiling");
		private final JProgressBar buffer = new JProgressBar();

		{
			stop.addActionListener(ev -> stopProfiling());

			GroupLayout l = new GroupLayout(this);
			setLayout(l);
			l.setHorizontalGroup(l.createParallelGroup()
				.addComponent(stop)
				.addComponent(buffer));
			l.setVerticalGroup(l.createSequentialGroup()
				.addComponent(stop)
				.addComponent(buffer));
		}
	}

	private class StoppedPanel extends JPanel
	{
		private final JButton clear = new JButton("Delete profile");
		private final JButton save = new JButton("Save Profile");
		private final JLabel status = new JLabel("");

		{
			clear.addActionListener(ev ->
			{
				data = null;
				ProfilerPanel.this.show(KEY_SETUP);
			});
			save.addActionListener(ev ->
			{
				JFileChooser fc = new JFileChooser();
				fc.setDialogTitle("Save profile");
				fc.setSelectedFile(new File(FileSystemView.getFileSystemView().getDefaultDirectory(), "profile.rlp"));
				if (fc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION)
				{
					try
					{
						Files.write(fc.getSelectedFile().toPath(), data);
						status.setText("Saved");
					}
					catch (IOException e)
					{
						log.warn("failed to save", e);
						status.setText(e.getMessage());
						status.revalidate();
					}
				}
			});

			GroupLayout l = new GroupLayout(this);
			setLayout(l);
			l.setHorizontalGroup(l.createParallelGroup()
				.addGroup(l.createSequentialGroup()
					.addComponent(clear)
					.addComponent(save))
				.addComponent(status));
			l.setVerticalGroup(l.createSequentialGroup()
				.addGroup(l.createParallelGroup()
					.addComponent(clear)
					.addComponent(save))
				.addComponent(status));
		}
	}

	private class FailurePanel extends JPanel
	{
		private final JLabel label = new JLabel("Profiler not supported");

		{
			setLayout(new BorderLayout());
			add(label, BorderLayout.CENTER);
		}
	}

	@RequiredArgsConstructor
	private static class EventEvent<T>
	{
		private final int id;
		private final Class<T> clazz;
		private final Function<T, int[]> consumer;
		private EventBus.Subscriber subscriber = null;

		EventEvent(int id, Class<T> clazz)
		{
			this(id, clazz, null);
		}

		void register(EventBus eventBus)
		{
			assert this.subscriber == null;
			this.subscriber = eventBus.register(clazz, ev ->
			{
				int[] data = consumer == null ? null : consumer.apply(ev);
				Profiler.pushEvent(id, data);
			}, 0);
		}

		void unregister(EventBus eventBus)
		{
			eventBus.unregister(this.subscriber);
			this.subscriber = null;
		}
	}

	@Inject
	public ProfilerPanel(
		Client client, ScheduledExecutorService executor, Gson gson, EventBus eventBus,
		@Named("runelite.version") String runeliteVersion)
	{
		this.gson = gson;
		this.client = client;
		this.eventBus = eventBus;

		executor.submit(() ->
		{
			executorThread = Thread.currentThread();
		});

		setLayout(layout);
		add(setupPanel, KEY_SETUP);
		add(runningPanel, KEY_RUNNING);
		add(stoppedPanel, KEY_STOPPED);
		add(failurePanel, KEY_FAILURE);
		show(KEY_SETUP);

		extra.put("buildID", client.getBuildID());
		extra.put("version", runeliteVersion);
		extra.put("launcherVersion", RuneLiteProperties.getLauncherVersion());
		for (String prop : new String[]{
			"os.name", "os.version", "os.arch", "java.vendor", "java.version",
		})
		{
			extra.put(prop, System.getProperty(prop));
		}
	}

	private void show(String key)
	{
		layout.show(this, key);
		revalidate();
	}

	public void startProfiling()
	{
		log.info("Starting profiling");
		Thread[] threads = Stream.concat(
			Stream.of(
				client.getClientThread(),
				Thread.currentThread(),
				executorThread
			),
			Thread.getAllStackTraces().entrySet().stream()
				.filter(e -> {
					String name = e.getKey().getName();
					return "AWT-Windows".equals(name)
						|| "AWT-XAWT".equals(name);
				})
				.map(e -> e.getKey())
			).filter(Objects::nonNull)
			.toArray(Thread[]::new);

		int delay = (Integer) setupPanel.sampleDelay.getValue();
		extra.put("delay", delay);
		try
		{
			Profiler.start(
				threads,
				(Integer) setupPanel.sampleBufferSize.getValue() * 1024,
				delay);
		}
		catch (Exception | LinkageError e)
		{
			show(KEY_FAILURE);
			log.info("error starting profiler", e);
			return;
		}

		for (EventEvent<?> ev : eventEvents)
		{
			ev.register(eventBus);
		}

		show(KEY_RUNNING);
		final Timer timer = new Timer(100, null);
		timer.addActionListener(evAction ->
		{
			Profiler.Status status = Profiler.status();
			switch (status)
			{
				case RUNNING:
					runningPanel.buffer.setValue(Profiler.bufferOffset());
					runningPanel.buffer.setMaximum(Profiler.bufferSize());
					break;
				case FAILED:
					stopProfiling();
					// fallthrough
				case STOPPED:
				case NOT_RUNNING:
					show(KEY_STOPPED);
					timer.stop();

					for (EventEvent<?> ev : eventEvents)
					{
						ev.unregister(eventBus);
					}
					break;
			}
		});
		timer.start();
	}

	public void stopProfiling()
	{
		String extraString = gson.toJson(extra);
		data = Profiler.stop(extraString.getBytes(StandardCharsets.UTF_8));
		show(KEY_STOPPED);
		stoppedPanel.status.setText("");
	}
}

/*
 * Copyright (c) 2023 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonIOException;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSyntaxException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.lang.management.ManagementFactory;
import java.nio.channels.FileChannel;
import java.nio.file.AtomicMoveNotSupportedException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.Locale;
import javax.annotation.Nullable;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLiteProperties;

@Slf4j
public class VMConfigPatch
{
	@Nullable
	private static final String unsupported = unsupported();

	@Nullable
	private static File packrConfigFile;

	private static String unsupported()
	{
		String launcherVer = RuneLiteProperties.getLauncherVersion();
		if (launcherVer == null)
		{
			return "Not using launcher";
		}
		if (!launcherVer.startsWith("2"))
		{
			return "Launcher out of date";
		}

		var proc = ProcessHandle.current().info();
		String cmdline = proc.command().get().toLowerCase(Locale.ROOT);

		if (!cmdline.endsWith("runelite.exe"))
		{
			return "Not using EXE launcher";
		}

		packrConfigFile = new File(new File(cmdline).getParentFile().getAbsoluteFile(), "config.json");
		if (!packrConfigFile.exists())
		{
			return "Cannot find config";
		}

		return null;
	}

	public static boolean isSupported()
	{
		return unsupported == null;
	}

	private final Gson gson;
	private final String name;
	private final String[] args;

	public VMConfigPatch(Gson gson, String name, String... args)
	{
		this.gson = gson.newBuilder()
			.setPrettyPrinting()
			.create();;
		this.name = name;
		this.args = args;
	}

	public String status()
	{
		var args = ManagementFactory.getRuntimeMXBean().getInputArguments();
		if (Arrays.stream(this.args).allMatch(args::contains))
		{
			return name + " enabled";
		}

		if (unsupported != null)
		{
			return unsupported;
		}

		return name + " disabled" + (isInConfig() ? " (Restart to enable)" : "");
	}

	public boolean isInConfig()
	{
		JsonObject config = loadConfig();
		return config != null && Arrays.stream(this.args)
			.allMatch(v -> config.get("vmArgs").getAsJsonArray().contains(new JsonPrimitive(v)));
	}

	private JsonObject loadConfig()
	{
		try (FileInputStream fin = new FileInputStream(packrConfigFile))
		{
			return gson.fromJson(new InputStreamReader(fin), JsonObject.class);
		}
		catch (IOException | JsonIOException | JsonSyntaxException e)
		{
			log.warn("error deserializing packr vm args!", e);
			return null;
		}
	}

	public boolean set(boolean enabled)
	{
		JsonObject config = loadConfig();
		if (config == null)
		{
			return false;
		}

		JsonArray vmArgs = config.get("vmArgs").getAsJsonArray();
		setHasArg(vmArgs, "-Drunelite.launcher.reflect=true", enabled);
		for (var arg : this.args)
		{
			setHasArg(vmArgs, arg, enabled);
		}

		try
		{
			File tmpFile = File.createTempFile("runelite", null);

			try (FileOutputStream fout = new FileOutputStream(tmpFile);
				FileChannel channel = fout.getChannel();
				PrintWriter writer = new PrintWriter(fout))
			{
				channel.lock();
				writer.write(gson.toJson(config));
				channel.force(true);
				// FileChannel.close() frees the lock
			}

			try
			{
				Files.move(tmpFile.toPath(), packrConfigFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
			}
			catch (AtomicMoveNotSupportedException ex)
			{
				log.debug("atomic move not supported", ex);
				Files.move(tmpFile.toPath(), packrConfigFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
			}

			log.info("patched packr vm args");
		}
		catch (IOException e)
		{
			log.warn("error updating packr vm args!", e);
		}

		return true;
	}

	private void setHasArg(JsonArray args, String argStr, boolean enabled)
	{
		String prefix = null;
		int index = argStr.indexOf("=");
		if (index > 0)
		{
			prefix = argStr.substring(0, index + 1);
		}

		for (var it = args.iterator(); it.hasNext(); )
		{
			var val = it.next();
			if ((prefix != null && enabled)
				? val.getAsString().startsWith(prefix)
				: val.getAsString().endsWith(argStr))
			{
				it.remove();
			}
		}

		if (enabled)
		{
			args.add(new JsonPrimitive(argStr));
		}
	}
}

/*
 * Copyright (c) 2023 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import com.sun.management.HotSpotDiagnosticMXBean;
import java.awt.Window;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import javax.management.ObjectName;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.Timer;
import javax.swing.border.EmptyBorder;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.filechooser.FileSystemView;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.RuneLite;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.DynamicGridLayout;

@Slf4j
@Singleton
public class HeapDumpPanel extends JPanel
{
	private final Client client;
	private final ConfigManager configManager;
	private final Object[] oomer = new Object[1];
	private final JCheckBox heapDumpOnOOM;
	private final File oomDumpFile = new File(RuneLite.LOGS_DIR, "oom_heap_dump.hprof");
	private File lastDump;

	@Inject
	public HeapDumpPanel(Client client, ConfigManager configManager, @Named("developerMode") boolean developerMode)
	{
		this.client = client;
		this.configManager = configManager;

		setLayout(new DynamicGridLayout(0, 1));

		JButton heapDump = new JButton("Heap dump");
		add(heapDump);
		heapDump.addActionListener(ev -> dumpHeap());

		heapDumpOnOOM = new JCheckBox("Heap dump on OOM");
		heapDumpOnOOM.setSelected(configManager.getConfiguration(DebugConfig.GROUP, DebugConfig.CREATE_HEAP_DUMP, boolean.class) == Boolean.TRUE);
		heapDumpOnOOM.addChangeListener(_ev ->
		{
			configManager.setConfiguration(DebugConfig.GROUP, DebugConfig.CREATE_HEAP_DUMP, heapDumpOnOOM.isSelected());
		});
		add(heapDumpOnOOM);
		apply();

		if (oomDumpFile.exists())
		{
			JButton locateDump = new JButton("Open last dump");
			locateDump.addActionListener(_ev -> DebugPlugin.openExplorer(oomDumpFile));
			add(locateDump);
			lastDump = oomDumpFile;
		}

		JButton stripDump = new JButton("Strip heap dump");
		stripDump.addActionListener(_ev ->
		{
			JFileChooser fc = new JFileChooser();
			fc.setDialogTitle("Open heap dump");
			fc.setSelectedFile(lastDump != null ? lastDump : FileSystemView.getFileSystemView().getDefaultDirectory());
			fc.setFileFilter(new FileNameExtensionFilter("Heap dump", "hprof"));
			if (fc.showOpenDialog(this) != JFileChooser.APPROVE_OPTION)
			{
				return;
			}

			File inFile = fc.getSelectedFile();

			JFrame frame = new JFrame("Stripping heap dump");
			frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
			JLabel l = new JLabel("<html>Stripping heap dump<br>This may take a while...");
			l.setBorder(new EmptyBorder(15, 15, 15, 15));
			frame.add(l);
			frame.setType(Window.Type.POPUP);
			frame.pack();
			frame.setVisible(true);
			frame.toFront();

			new Thread(() ->
			{
				try
				{
					boolean zstd = false;
					try
					{
						ZstdOutputStream.init();
						zstd = true;
					}
					catch (Throwable e)
					{
						log.info("unable to init zstd", e);
					}

					File outFile = new File(inFile.getParentFile(),
						inFile.getName().replaceAll("\\.[^.]+$", "") + "_stripped.hprof." + (zstd ? "zstd" : "gz"));
					new HProfStripper(inFile, outFile, zstd).run();
					DebugPlugin.openExplorer(outFile);
				}
				catch (IOException e)
				{
					log.warn("", e);
				}
				finally
				{
					frame.setVisible(false);
				}
			}).start();
		});
		add(stripDump);

		if (developerMode)
		{
			JButton oom = new JButton("oom the client");
			oom.addActionListener(_ev ->
			{
				Object[] obj = oomer;
				for (; ; )
				{
					Object[] waste = new Object[0xFFFF];
					obj[0] = waste;
					obj = waste;
				}
			});
			add(oom);
		}
	}

	public void apply()
	{
		boolean enabled = configManager.getConfiguration(DebugConfig.GROUP, DebugConfig.CREATE_HEAP_DUMP, boolean.class) == Boolean.TRUE;
		heapDumpOnOOM.setSelected(enabled);

		var hsd = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);
		hsd.setVMOption("HeapDumpOnOutOfMemoryError", "" + enabled);
		if (enabled)
		{
			hsd.setVMOption("HeapDumpPath", oomDumpFile.getAbsolutePath());
		}
	}

	private void dumpHeap()
	{
		JFileChooser fc = new JFileChooser();
		fc.setDialogTitle("Save heap dump");
		fc.setSelectedFile(new File(FileSystemView.getFileSystemView().getDefaultDirectory(), "dump.hprof"));
		if (fc.showSaveDialog(this) != JFileChooser.APPROVE_OPTION)
		{
			return;
		}

		File fi = fc.getSelectedFile();
		fi.delete();
		String filename = fi.getAbsoluteFile().getPath();
		lastDump = fi;

		client.setPassword("");

		JFrame frame = new JFrame("Heap dump");
		frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		JLabel l = new JLabel("<html>Taking heap dump<br>This may take a while...");
		l.setBorder(new EmptyBorder(15, 15, 15, 15));
		frame.add(l);
		frame.setType(Window.Type.POPUP);
		frame.pack();
		frame.setVisible(true);
		frame.toFront();

		Timer t = new Timer(300, v ->
		{
			try
			{
				ManagementFactory.getPlatformMBeanServer().invoke(
					new ObjectName("com.sun.management:type=HotSpotDiagnostic"),
					"dumpHeap",
					new Object[]{filename, true},
					new String[]{String.class.getName(), boolean.class.getName()}
				);
			}
			catch (Exception e)
			{
				log.warn("unable to capture heap dump", e);
				JOptionPane.showMessageDialog(this, e.toString(), "Heap dump error", JOptionPane.ERROR_MESSAGE);
			}

			frame.setVisible(false);
		});
		t.setRepeats(false);
		t.start();
	}
}

/*
 * Copyright (c) 2023 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.util.function.Supplier;
import javax.swing.JButton;
import javax.swing.Timer;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class FeedbackButton extends JButton
{
	private String initialText;

	public FeedbackButton(String text)
	{
		super(text);
		initialText = text;
		addActionListener(_ev -> onClick());
	}

	protected void feedback(String text)
	{
		feedback(text, 5000);
	}

	protected void feedback(String text, int delayMS)
	{
		setText(text);
		Timer t = new Timer(delayMS, ev -> setText(initialText));
		t.setRepeats(false);
		t.start();
	}

	protected abstract void onClick();

	public static class CopyToClipboardButton extends FeedbackButton
	{
		private final Supplier<String> onClick;

		public CopyToClipboardButton(String text, Supplier<String> onClick)
		{
			super(text);
			this.onClick = onClick;
		}

		@Override
		protected void onClick()
		{
			String s;
			try
			{
				s = this.onClick.get();
			}
			catch (Exception e)
			{
				log.info("", e);
				s = e.toString();
			}

			Toolkit.getDefaultToolkit()
				.getSystemClipboard()
				.setContents(new StringSelection(s), null);
			feedback("Copied to clipboard!");
		}
	}
}

/*
 * Copyright (c) 2021 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import com.sun.management.UnixOperatingSystemMXBean;
import java.io.File;
import java.lang.management.ManagementFactory;
import java.lang.management.OperatingSystemMXBean;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import javax.inject.Inject;
import javax.management.ObjectName;
import javax.swing.JCheckBox;
import javax.swing.JPanel;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.ui.DynamicGridLayout;

@Slf4j
public class ManagementPanel extends JPanel
{
	@Inject
	public ManagementPanel()
	{
		setLayout(new DynamicGridLayout(0, 1));
		add(new FeedbackButton.CopyToClipboardButton("Dump threads", () -> invokeDiagnosticCommand("threadPrint")));
		add(new FeedbackButton.CopyToClipboardButton("Dump natives", () -> invokeDiagnosticCommand("vmDynlibs")));

		add(new FeedbackButton.CopyToClipboardButton("OS stats", this::dumpOSStats));

		JCheckBox logGC = new JCheckBox("Log GC details");
		add(logGC);
		logGC.addItemListener(ev -> setXLog("gc", "gc=" + (logGC.isSelected() ? "debug" : "off")));
	}

	@SneakyThrows
	private static String invokeDiagnosticCommand(String action, String... args)
	{
		return (String) ManagementFactory.getPlatformMBeanServer().invoke(
			new ObjectName("com.sun.management:type=DiagnosticCommand"),
			action,
			new Object[]{args},
			new String[]{String[].class.getName()}
		);
	}

	private static void setXLog(String name, String what)
	{
		File f = new File(RuneLite.LOGS_DIR, name + ".log");
		String out = invokeDiagnosticCommand("vmLog",
			"output=file=" + f.getAbsolutePath() + "",
			"what=" + what,
			"decorators=uptime"
		);
		log.info("xlog: {}", out);
	}

	private String dumpOSStats()
	{
		OperatingSystemMXBean bean = ManagementFactory.getOperatingSystemMXBean();
		StringBuilder sb = new StringBuilder();
		Class<?> clazz = OperatingSystemMXBean.class;
		for (Class<?> test : new Class[]{
			UnixOperatingSystemMXBean.class,
			com.sun.management.OperatingSystemMXBean.class
		})
		{
			if (test.isAssignableFrom(bean.getClass()))
			{
				clazz = test;
				break;
			}
		}
		for (Method m : clazz.getMethods())
		{
			if (m.getName().startsWith("get") && Modifier.isPublic(m.getModifiers()) && !Modifier.isStatic(m.getModifiers()) && m.getParameterCount() == 0)
			{
				Object v;
				try
				{
					v = m.invoke(bean);
				}
				catch (Exception e)
				{
					v = e;
				}

				sb.append(m.getName()).append(": ").append(v).append('\n');
			}
		}
		return sb.toString();
	}
}

/*
 * Copyright (c) 2021 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package abex.os.debug;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;

@ConfigGroup(DebugConfig.GROUP)
public interface DebugConfig extends Config
{
	String GROUP = "debug";
	String CREATE_CORE_DUMP = "createCoreDump";
	String CREATE_HEAP_DUMP = "createHeapDump";
}

