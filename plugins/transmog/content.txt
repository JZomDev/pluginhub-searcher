/*
 * Copyright (c) 2023, Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

public enum BodyKit
{
	MASC,
	FEMME
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.config;

import lombok.Getter;
import java.util.List;

public abstract class PresetParser
{
	@Getter
	protected String name = "";

	@Getter
	protected int icon = -1;

	@Getter
	protected List<String> slotValues;

	public abstract void parse(String configData);

	public abstract void migrate(PresetParser other);

	public void clear()
	{
		this.name = "";
		this.icon = -1;
		this.slotValues = null;
	}

	public static PresetParser getLatest()
	{
		return new V2Parser();
	}

	public static PresetParser getParser(String configData)
	{
		String flag = configData.substring(0, 1);
		switch (flag)
		{
			case V2Parser.VERSION_FLAG:
				return new V2Parser();
			default:
				return new V1Parser();
		}
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.config;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import io.hydrox.transmog.TransmogPreset;
import net.runelite.client.config.ConfigManager;
import java.util.Arrays;
import java.util.Optional;
import java.util.stream.Collectors;

// Don't you just hate it when the config becomes null when it has only hidden configs?
@Singleton
public class TransmogrificationConfigManager
{
	private static final String CONFIG_GROUP = "transmog";
	private static final String CONFIG_DEFAULT = "default";
	private static final String CONFIG_OVERRIDE = "override";
	private static final String CONFIG_PRESET = "preset_";
	private static final String CONFIG_LAST_PRESET_IDX = "lastIndex";
	private static final String CONFIG_TRANSMOG_ACTIVE = "transmogActive";
	private static final String CONFIG_CURRENT_PRESET = "currentPreset";
	private static final String CONFIG_TRANSMIT_TO_PARTY = "transmitToParty";

	private final ConfigManager configManager;

	@Inject
	TransmogrificationConfigManager(ConfigManager configManager)
	{
		this.configManager = configManager;
	}

	public boolean transmogActive()
	{
		return Optional.ofNullable((Boolean)configManager.getRSProfileConfiguration(CONFIG_GROUP, CONFIG_TRANSMOG_ACTIVE, Boolean.class)).orElse(false);
	}

	public void transmogActive(boolean value)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_TRANSMOG_ACTIVE, value);
	}

	public boolean transmitToParty()
	{
		return Optional.ofNullable((Boolean)configManager.getRSProfileConfiguration(CONFIG_GROUP, CONFIG_TRANSMIT_TO_PARTY, Boolean.class)).orElse(false);
	}

	public void transmitToParty(boolean value)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_TRANSMIT_TO_PARTY, value);
	}

	public int currentPreset()
	{
		return Optional.ofNullable((Integer)configManager.getRSProfileConfiguration(CONFIG_GROUP, CONFIG_CURRENT_PRESET, Integer.class)).orElse(lastIndex());
	}

	public void currentPreset(int value)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_CURRENT_PRESET, value);
	}

	/**
	 * Gets the last index to be used by a preset.
	 */
	public int lastIndex()
	{
		return Optional.ofNullable((Integer)configManager.getRSProfileConfiguration(CONFIG_GROUP, CONFIG_LAST_PRESET_IDX, Integer.class)).orElse(0);
	}

	/**
	 * Sets the last index to be used by a preset.
	 */
	public void lastIndex(int value)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_LAST_PRESET_IDX, value);
	}

	public String getPresetData(int index)
	{
		return configManager.getRSProfileConfiguration(CONFIG_GROUP, CONFIG_OVERRIDE + "." + CONFIG_PRESET + index);
	}

	public void savePreset(TransmogPreset preset)
	{
		String key = CONFIG_OVERRIDE + "." + CONFIG_PRESET + preset.getId();
		String value = preset.toConfig();
		if (value != null)
		{
			configManager.setRSProfileConfiguration(CONFIG_GROUP, key, value);
		}
	}

	public void savePreset(int presetID, TransmogPreset preset)
	{
		String key = CONFIG_OVERRIDE + "." + CONFIG_PRESET + presetID;
		if (preset != null)
		{
			String value = preset.toConfig();
			if (value != null)
			{
				configManager.setRSProfileConfiguration(CONFIG_GROUP, key, value);
				return;
			}
		}
		configManager.unsetRSProfileConfiguration(CONFIG_GROUP, key);
	}

	public String getDefaultStateData()
	{
		return configManager.getRSProfileConfiguration(CONFIG_GROUP, CONFIG_DEFAULT);
	}

	public void saveDefaultState(int[] state)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_DEFAULT, Arrays.stream(state)
			.mapToObj(String::valueOf)
			.collect(Collectors.joining(","))
		);
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.config;

import net.runelite.client.util.Text;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class V1Parser extends PresetParser
{
	private static final Pattern PARSER = Pattern.compile("^((?:null|-1|\\d+|,)+)$");

	public void parse(String configData)
	{
		Matcher m = PARSER.matcher(configData);
		if (!m.matches())
		{
			return;
		}

		slotValues = Text.fromCSV(m.group(1));
	}

	public void migrate(PresetParser other)
	{
		slotValues = other.getSlotValues();
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.config;

import net.runelite.client.util.Text;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class V2Parser extends PresetParser
{
	public static final String VERSION_FLAG = "\"";
	private static final Pattern PARSER = Pattern.compile("^\"(-1|\\d+),([\\w ]*),((?:null|-1|\\d+|,)+)$");

	public void parse(String configData)
	{
		if (!VERSION_FLAG.equals(configData.substring(0, 1)))
		{
			return;
		}

		Matcher m = PARSER.matcher(configData);
		if (!m.matches())
		{
			return;
		}

		icon = Integer.parseInt(m.group(1));
		name = m.group(2);
		slotValues = Text.fromCSV(m.group(3));
	}

	public void migrate(PresetParser other)
	{
		icon = other.getIcon();
		name = other.getName();
		slotValues = other.getSlotValues();
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import java.util.HashMap;
import java.util.Map;

@Getter
@RequiredArgsConstructor
public enum FacialHairMapping implements Mapping
{
	EMPTY("Empty", -1, -1),

	NONE("None", 47825, 270),
	GOATEE("Goatee", 47814, 266),
	LONG("Long", 47837, 267),
	MEDIUM("Medium", 47820, 268),
	MOUSTACHE("Moustache", 47787, 269),
	SHORT("Short", 47767, 271),
	POINTY("Pointy", 47784, 272),
	SPLIT("Split", 47840, 273),
	HANDLEBAR("Handlebar", 47830, 367),
	MUTTON("Mutton", 47797, 368),
	FULL_MUTTON("Full Mutton", 47783, 369),
	BIG_MOUSTACHE("Big Moustache", 47770, 370),
	WAXED_MOUSTACHE("Waxed Moustache", 47795, 371),
	DALI("Dali", 47789, 372),
	VIZIER("Vizier", 47826, 373);

	private final String name;
	private final int modelID;
	private final int kitID;

	private static final Map<Integer, FacialHairMapping> FROM_KIT = new HashMap<>();
	private static final Map<Integer, FacialHairMapping> FROM_MODEL = new HashMap<>();

	static
	{
		for (FacialHairMapping mapping : values())
		{
			FROM_KIT.put(mapping.kitID, mapping);
			FROM_MODEL.put(mapping.modelID, mapping);
		}
	}

	public static FacialHairMapping fromKitID(int kitID)
	{
		return FROM_KIT.get(kitID);
	}

	public static FacialHairMapping fromModelID(int modelID)
	{
		return FROM_MODEL.get(modelID);
	}

	@Override
	public String prettyName()
	{
		return name;
	}

	@Override
	public BodyKit bodyKit()
	{
		return BodyKit.MASC;
	}

	@Override
	public int modelId()
	{
		return modelID;
	}

	@Override
	public int kitId()
	{
		return kitID;
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import java.util.HashMap;
import java.util.Map;

@Getter
@RequiredArgsConstructor
public enum HairMapping implements Mapping
{
	EMPTY("Empty", null, -1, -1),

	BALD_F("Bald", BodyKit.FEMME, 47775, 301),
	BUN_F("Bun", BodyKit.FEMME, 47799, 302),
	DREADLOCKS_F("Dreadlocks", BodyKit.FEMME, 47812, 303),
	LONG_F("Long", BodyKit.FEMME, 47839, 304),
	MEDIUM_F("Medium", BodyKit.FEMME, 47819, 305),
	PIGTAILS_F("Pigtails", BodyKit.FEMME, 47791, 306),
	SHORT_F("Short", BodyKit.FEMME, 47816, 307),
	CROPPED_F("Cropped", BodyKit.FEMME, 47829, 308),
	WILD_SPIKES_F("Wild spikes", BodyKit.FEMME, 47773, 309),
	SPIKY_F("Spikes", BodyKit.FEMME, 47827, 310),
	EARMUFFS_F("Earmuffs", BodyKit.FEMME, 47772, 311),
	SIDE_PONY_F("Side pony", BodyKit.FEMME, 47798, 374),
	CURLS_F("Curls", BodyKit.FEMME, 47785, 375),
	WIND_BRAIDS_F("Wind braids", BodyKit.FEMME, 47786, 376),
	PONYTAIL_F("Ponytail", BodyKit.FEMME, 47823, 377),
	BRAIDS_F("Braids", BodyKit.FEMME, 47811, 378),
	BUNCHES_F("Bunches", BodyKit.FEMME, 47818, 379),
	BOB_F("Bob", BodyKit.FEMME, 47822, 380),
	LAYERED_F("Layered", BodyKit.FEMME, 47807, 381),
	STRAIGHT_F("Straight", BodyKit.FEMME, 47833, 382),
	STRAIGHT_BRAIDS_F("Straight Braids", BodyKit.FEMME, 47810, 383),
	CURTAINS_F("Curtains", BodyKit.FEMME, 47793, 384),
	FRONT_SPLIT_F("Front split", BodyKit.FEMME, 47815, 408),
	TWO_BACK_F("Two-back", BodyKit.FEMME, 47832, 399),
	TONSURE_F("Tonsure", BodyKit.FEMME, 47828, 430),
	MOHAWK_F("Mohawk", BodyKit.FEMME, 47776, 431),
	QUIFF_F("Quiff", BodyKit.FEMME, 47813, 432),
	SAMURAI_F("Samurai", BodyKit.FEMME, 47781, 433),
	PRINCELY_F("Princely", BodyKit.FEMME, 47788, 434),
	LONG_CURTAINS_F("Long curtains", BodyKit.FEMME, 47834, 435),
	TOUSLED_F("Tousled", BodyKit.FEMME, 47802, 436),
	SIDE_WEDGE_F("Side wedge", BodyKit.FEMME, 47777, 437),
	FRONT_WEDGE_F("Front wedge", BodyKit.FEMME, 47838, 438),
	FRONT_SPIKES_F("Front spikes", BodyKit.FEMME, 47805, 439),
	FROHAWK_F("Frohawk", BodyKit.FEMME, 47804, 440),
	REAR_SKIRT_F("Rear skirt", BodyKit.FEMME, 47794, 441),
	QUEUE_F("Queue", BodyKit.FEMME, 47800, 442),
	MULLET_F("Mullet", BodyKit.FEMME, 47831, 410),
	UNDERCUT_F("Undercut", BodyKit.FEMME, 47817, 411),
	LOW_BUN_F("Low Bun", BodyKit.FEMME, 47779, 425),
	MESSY_BUN_F("Messy Bun", BodyKit.FEMME, 47835, 426),
	POMPADOUR_F("Pompadour", BodyKit.FEMME, 47801, 412),
	AFRO_F("Afro", BodyKit.FEMME, 47792, 413),
	SHORT_LOCS_F("Short locs", BodyKit.FEMME, 47771, 414),
	SPIKY_MOHAWK_F("Spiky Mohawk", BodyKit.FEMME, 47836, 415),
	SLICKED_MOHAWK_F("Slicked Mohawk", BodyKit.FEMME, 47806, 416),
	LONG_QUIFF_F("Long Quiff", BodyKit.FEMME, 47782, 417),
	SHORT_CHOPPY_F("Short Choppy", BodyKit.FEMME, 47809, 418),
	SIDE_AFRO_F("Side Afro", BodyKit.FEMME, 47790, 419),
	PUNK_F("Punk", BodyKit.FEMME, 47803, 420),
	HALF_SHAVED_F("Half-shaved", BodyKit.FEMME, 47824, 421),
	FREMENNIK_F("Fremennik", BodyKit.FEMME, 47796, 422),
	ELVEN_F("Elven", BodyKit.FEMME, 47768, 423),
	MEDIUM_COILS_F("Medium Coils", BodyKit.FEMME, 47780, 424),
	HIGH_PONYTAIL_F("High ponytail", BodyKit.FEMME, 47778, 427),
	PLAITS_F("Plaits", BodyKit.FEMME, 47821, 428),
	HIGH_BUNCHES_F("High Bunches", BodyKit.FEMME, 47774, 429),

	BALD_M("Bald", BodyKit.MASC, 47775, 256),
	DREADLOCKS_M("Dreadlocks", BodyKit.MASC, 47812, 257),
	LONG_M("Long", BodyKit.MASC, 47839, 258),
	MEDIUM_M("Medium", BodyKit.MASC, 47819, 259),
	TONSURE_M("Tonsure", BodyKit.MASC, 47828, 260),
	SHORT_M("Short", BodyKit.MASC, 47816, 261),
	CROPPED_M("Cropped", BodyKit.MASC, 47829, 262),
	WILD_SPIKES_M("Wild spikes", BodyKit.MASC, 47773, 263),
	SPIKES_M("Spikes", BodyKit.MASC, 47827, 264),
	MOHAWK_M("Mohawk", BodyKit.MASC, 47776, 265),
	WIND_BRAIDS_M("Wind braids", BodyKit.MASC, 47786, 385),
	QUIFF_M("Quiff", BodyKit.MASC, 47813, 386),
	SAMURAI_M("Samurai", BodyKit.MASC, 47781, 387),
	PRINCELY_M("Princely", BodyKit.MASC, 47788, 388),
	CURTAINS_M("Curtains", BodyKit.MASC, 47793, 389),
	LONG_CURTAINS_M("Long curtains", BodyKit.MASC, 47834, 390),
	FRONT_SPLIT_M("Front split", BodyKit.MASC, 47815, 407),
	TOUSLED_M("Tousled", BodyKit.MASC, 47802, 400),
	SIDE_WEDGE_M("Side wedge", BodyKit.MASC, 47777, 401),
	FRONT_WEDGE_M("Front wedge", BodyKit.MASC, 47838, 402),
	FRONT_SPIKES_M("Front spikes", BodyKit.MASC, 47805, 403),
	FROHAWK_M("Frohawk", BodyKit.MASC, 47804, 404),
	REAR_SKIRT_M("Rear skirt", BodyKit.MASC, 47794, 405),
	QUEUE_M("Queue", BodyKit.MASC, 47800, 406),
	BUN_M("Bun", BodyKit.MASC, 47799, 477),
	PIGTAILS_M("Pigtails", BodyKit.MASC, 47791, 478),
	EARMUFFS_M("Earmuffs", BodyKit.MASC, 47772, 479),
	SIDE_PONY_M("Side pony", BodyKit.MASC, 47798, 480),
	CURLS_M("Curls", BodyKit.MASC, 47785, 481),
	PONYTAIL_M("Ponytail", BodyKit.MASC, 47823, 482),
	BRAIDS_M("Braids", BodyKit.MASC, 47811, 483),
	BUNCHES_M("Bunches", BodyKit.MASC, 47818, 484),
	BOB_M("Bob", BodyKit.MASC, 47822, 485),
	LAYERED_M("Layered", BodyKit.MASC, 47807, 486),
	STRAIGHT_M("Straight", BodyKit.MASC, 47833, 487),
	STRAIGHT_BRAIDS_M("Straight Braids", BodyKit.MASC, 47810, 488),
	TWO_BACK_M("Two-back", BodyKit.MASC, 47832, 489),
	MULLET_M("Mullet", BodyKit.MASC, 47831, 457),
	UNDERCUT_M("Undercut", BodyKit.MASC, 47817, 458),
	LOW_BUN_M("Low Bun", BodyKit.MASC, 47779, 472),
	MESSY_BUN_M("Messy Bun", BodyKit.MASC, 47835, 473),
	POMPADOUR_M("Pompadour", BodyKit.MASC, 47801, 459),
	AFRO_M("Afro", BodyKit.MASC, 47792, 460),
	SHORT_LOCS_M("Short locs", BodyKit.MASC, 47771, 461),
	SPIKY_MOHAWK_M("Spiky Mohawk", BodyKit.MASC, 47836, 462),
	SLICKED_MOHAWK_M("Slicked Mohawk", BodyKit.MASC, 47806, 463),
	LONG_QUIFF_M("Long Quiff", BodyKit.MASC, 47782, 464),
	SHORT_CHOPPY_M("Short Choppy", BodyKit.MASC, 47809, 465),
	SIDE_AFRO_M("Side Afro", BodyKit.MASC, 47790, 466),
	PUNK_M("Punk", BodyKit.MASC, 47803, 467),
	HALF_SHAVED_M("Half-shaved", BodyKit.MASC, 47824, 468),
	FREMENNIK_M("Fremennik", BodyKit.MASC, 47796, 469),
	ELVEN_M("Elven", BodyKit.MASC, 47768, 470),
	MEDIUM_COILS_M("Medium Coils", BodyKit.MASC, 47780, 471),
	HIGH_PONYTAIL_M("High ponytail", BodyKit.MASC, 47778, 474),
	PLAITS_M("Plaits", BodyKit.MASC, 47821, 475),
	HIGH_BUNCHES_M("High Bunches", BodyKit.MASC, 47774, 476);


	private final String name;
	private final BodyKit bodyKit;
	private final int modelID;
	private final int kitID;

	private static final Map<Integer, HairMapping> FROM_KIT = new HashMap<>();
	private static final Map<Integer, HairMapping> FROM_MODEL = new HashMap<>();

	static
	{
		for (HairMapping mapping : values())
		{
			FROM_KIT.put(mapping.kitID, mapping);
			FROM_MODEL.put(mapping.modelID, mapping);
		}
	}

	public static HairMapping fromKitID(int kitID)
	{
		return FROM_KIT.get(kitID);
	}

	public static HairMapping fromModelID(int modelID)
	{
		return FROM_MODEL.get(modelID);
	}

	@Override
	public String prettyName()
	{
		return name;
	}

	@Override
	public BodyKit bodyKit()
	{
		return bodyKit;
	}

	@Override
	public int modelId()
	{
		return modelID;
	}

	@Override
	public int kitId()
	{
		return kitID;
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

public interface Mapping
{
	String prettyName();
	BodyKit bodyKit();
	int modelId();
	int kitId();
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

// Yo dawg
@Getter
@RequiredArgsConstructor
public enum MappingMapping
{
	HAIR(
		TransmogSlot.HAIR,
		HairMapping.class,
		HairMapping::fromKitID,
		HairMapping::fromModelID,
		600,
		10
	),
	JAW(
		TransmogSlot.JAW,
		FacialHairMapping.class,
		FacialHairMapping::fromKitID,
		FacialHairMapping::fromModelID,
		600,
		10
	),
	SLEEVES(
		TransmogSlot.SLEEVES,
		SleeveMapping.class,
		SleeveMapping::fromKitID,
		SleeveMapping::fromModelID,
		1200,
		55
	);

	private final TransmogSlot slot;
	private final Class<? extends Mapping> mapping;
	private final Function<Integer, Mapping> fromKit;
	private final Function<Integer, Mapping> fromModel;
	private final int modelZoom;
	private final int yOffset;

	private static final Map<TransmogSlot, MappingMapping> MAP = new HashMap<>();

	static
	{
		for (MappingMapping m : values())
		{
			MAP.put(m.slot, m);
		}
	}

	public static MappingMapping fromSlot(TransmogSlot slot)
	{
		return MAP.get(slot);
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import java.util.HashMap;
import java.util.Map;

@Getter
@RequiredArgsConstructor
public enum SleeveMapping implements Mapping
{
	EMPTY("Empty", null, -1, -1),

	SHORT_SLEEVES("Short sleeves", BodyKit.FEMME, 332, 317),
	BARE_ARMS("Bare arms", BodyKit.FEMME, 351, 318),
	MUSCLEY("Muscley", BodyKit.FEMME, 346, 319),
	LONG_SLEEVED("Long sleeved", BodyKit.FEMME, 348, 320),
	LARGE_CUFFS("Large cuffs", BodyKit.FEMME, 343, 321),
	FRILLY("Frilly", BodyKit.FEMME, 28364, 322),
	SWEATER("Sweater", BodyKit.FEMME, 28365, 351),
	WHITE_CUFFS("White cuffs", BodyKit.FEMME, 28368, 352),
	THIN_STRIPE("Thin stripe", BodyKit.FEMME, 28366, 353),
	TATTY("Tatty", BodyKit.FEMME, 28367, 354),
	BARE_SHOULDERS("Bare shoulders", BodyKit.FEMME, 28369, 355),

	REGULAR("Regular", BodyKit.MASC, 151, 282),
	MUSCLEBOUND("Musclebound", BodyKit.MASC, 167, 283),
	LOOSE_SLEEVED("Loose sleeved", BodyKit.MASC, 170, 284),
	LARGE_CUFFED("Large cuffed", BodyKit.MASC, 162, 285),
	THIN_SLEEVED("Thin sleeved", BodyKit.MASC, 163, 286),
	SHOULDER_PADS("Shoulder pads", BodyKit.MASC, 158, 287),
	THIN_STRIPE_M("Thin stripe", BodyKit.MASC, 28342, 288),
	THICK_STRIPE("Thick stripe", BodyKit.MASC, 28345, 340),
	WHITE_CUFFS_M("White cuffs", BodyKit.MASC, 28343, 341),
	PRINCELY("Princely", BodyKit.MASC, 28340, 342),
	TATTY_M("Tatty", BodyKit.MASC, 28344, 343),
	RIPPED("Ripped", BodyKit.MASC, 28341, 344);

	private final String name;
	private final BodyKit bodyKit;
	private final int modelID;
	private final int kitID;

	private static final Map<Integer, SleeveMapping> FROM_KIT = new HashMap<>();
	private static final Map<Integer, SleeveMapping> FROM_MODEL = new HashMap<>();

	static
	{
		for (SleeveMapping mapping : values())
		{
			FROM_KIT.put(mapping.kitID, mapping);
			FROM_MODEL.put(mapping.modelID, mapping);
		}
	}

	public static SleeveMapping fromKitID(int kitID)
	{
		return FROM_KIT.get(kitID);
	}

	public static SleeveMapping fromModelID(int modelID)
	{
		return FROM_MODEL.get(modelID);
	}

	@Override
	public String prettyName()
	{
		return name;
	}

	@Override
	public BodyKit bodyKit()
	{
		return bodyKit;
	}

	@Override
	public int modelId()
	{
		return modelID;
	}

	@Override
	public int kitId()
	{
		return kitID;
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import lombok.RequiredArgsConstructor;
import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public enum StupidItems
{
	/**
	 * You know what's really fun? When certain items exist that are identical to the normal item,
	 * but they don't actually work as equipment because they're fake? Love it
	 */

	DRAGON_CHAINBODY(2513, 3140);

	private final int badId;
	private final int goodId;

	private static final Map<Integer, Integer> MAP = new HashMap<>();

	static
	{
		for (StupidItems i : values())
		{
			MAP.put(i.badId, i.goodId);
		}
	}

	public static int convertId(int id)
	{
		return MAP.getOrDefault(id, id);
	}
}

/*
 * Copyright (c) 2022, Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import io.hydrox.transmog.config.TransmogrificationConfigManager;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.messages.PartyMemberMessage;
import net.runelite.client.party.messages.PartyMessage;
import java.util.HashMap;
import java.util.Map;

@Singleton
public class TransmogPartyManager
{
	static final int RATE_LIMIT = 1;
	private final Client client;
	private final ClientThread clientThread;
	private final TransmogrificationManager transmogManager;
	private final TransmogrificationConfigManager configManager;
	private final PartyService partyService;

	private final Map<String, Player> playerMapByName = new HashMap<>();

	private final Map<Long, String> playerMapByMemberId = new HashMap<>();

	private int lastSend = 0;
	private PartyMessage messageToSend;

	@Inject
	TransmogPartyManager(Client client, ClientThread clientThread, TransmogrificationManager transmogManager, PartyService partyService,
						 TransmogrificationConfigManager configManager)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.transmogManager = transmogManager;
		this.partyService = partyService;
		this.configManager = configManager;
	}

	public void onPlayerSpawned(Player spawned)
	{
		if (spawned == client.getLocalPlayer())
		{
			return;
		}

		playerMapByName.put(spawned.getName(), spawned);

		transmogManager.updateCurrent(spawned.getName(), spawned.getPlayerComposition().getEquipmentIds());
		transmogManager.applyTransmog(spawned, transmogManager.getPartyPreset(spawned.getName()));
	}

	public void onGameTick()
	{
		if (messageToSend != null && lastSend + RATE_LIMIT < client.getTickCount())
		{
			lastSend = client.getTickCount();
			partyService.send(messageToSend);
			messageToSend = null;
		}
	}

	public void onPlayerDespawned(Player despawned)
	{
		playerMapByName.remove(despawned.getName());
	}

	public void onTransmogUpdateMessage(TransmogUpdateMessage e)
	{
		if (partyService.getLocalMember().getMemberId() == e.getMemberId())
		{
			return;
		}
		PartyMember member = partyService.getMemberById(e.getMemberId());
		String name = member.getDisplayName();
		// Only fall back to transmitted name if there isn't a stored preset, probably because the update was sent
		// before a name was set on party join, to try to reduce abuse of people changing other's transmogs
		if (name.equals("<unknown>"))
		{
			if (transmogManager.getPartyPreset(e.getName()) != null)
			{
				return;
			}
			name = e.getName();
		}
		TransmogPreset preset = e.getPresetData() == null ? null : TransmogPreset.fromConfig(-1, e.getPresetData());
		transmogManager.setPartyPreset(name, preset);

		// If the player is in the scene, update their transmog
		Player player = playerMapByName.getOrDefault(name, null);
		if (player == null)
		{
			return;
		}
		clientThread.invoke(() -> transmogManager.updateTransmog(player, preset));
	}

	public void onStatusUpdate()
	{
		playerMapByMemberId.clear();
		for (PartyMember pm : partyService.getMembers())
		{
			// Ignore self
			if (pm.getMemberId() == partyService.getLocalMember().getMemberId())
			{
				continue;
			}
			// Ignore those with uninitialised usernames
			String name = pm.getDisplayName();
			if ("<unknown>".equals(name))
			{
				continue;
			}
			playerMapByMemberId.put(pm.getMemberId(), name);
			// Don't bother trying to apply transmog if the user isn't present
			Player player = playerMapByName.getOrDefault(name, null);
			if (player == null)
			{
				continue;
			}

			clientThread.invoke(() -> transmogManager.updateTransmog(player, transmogManager.getPartyPreset(name)));
		}
	}

	public void clearUser(long memberId)
	{
		String name = playerMapByMemberId.getOrDefault(memberId, null);
		if (name == null)
		{
			return;
		}

		transmogManager.setPartyPreset(name, null);
		if (playerMapByName.containsKey(name))
		{
			clientThread.invoke(() -> transmogManager.removeTransmog(playerMapByName.get(name)));
		}
		playerMapByMemberId.remove(memberId);
	}

	public Runnable onPartyChanged(PartyChanged e)
	{
		if (e.getPartyId() == null)
		{
			for (long id : playerMapByMemberId.keySet())
			{
				clearUser(id);
			}
		}
		// TODO: This stuff may not be needed, not 100% sure
		if (client.getGameState() != GameState.LOGGED_IN || e.getPartyId() == null || client.getLocalPlayer().getName() == null)
		{
			return null;
		}
		return this::shareCurrentPreset;
	}

	private boolean shouldSharePreset()
	{
		return configManager.transmogActive() && configManager.transmitToParty();
	}

	void shareCurrentPreset()
	{
		if (partyService.isInParty() && client.getGameState() == GameState.LOGGED_IN)
		{
			queueSend(new TransmogUpdateMessage(
				client.getLocalPlayer().getName(),
				shouldSharePreset()
					? transmogManager.getCurrentPresetSerialised()
					: null
			));
		}
	}

	void clearSharedPreset()
	{
		if (partyService.isInParty())
		{
			queueSend(new TransmogUpdateMessage(client.getLocalPlayer().getName(), null));
		}
	}

	public void setShareWithParty(boolean state)
	{
		configManager.transmitToParty(state);
		shareCurrentPreset();
	}



	void queueSend(PartyMemberMessage message)
	{
		messageToSend = message;
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import io.hydrox.transmog.config.PresetParser;
import io.hydrox.transmog.config.V2Parser;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.game.ItemManager;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

public class TransmogPreset
{
	static final int EMPTY = -1;
	static final Integer IGNORE = null;

	private final Map<TransmogSlot, Integer> overrides = new HashMap<>();
	private final Map<TransmogSlot, String> names = new HashMap<>();

	@Getter
	@Setter
	private int id;
	@Getter
	@Setter
	private int icon;
	@Getter
	private String name;

	@Getter
	@Setter
	private boolean changed = false;

	public TransmogPreset(int id)
	{
		this(id, -1, "");
	}

	public TransmogPreset(int id, int icon, String name)
	{
		for (TransmogSlot slot : TransmogSlot.values())
		{
			if (slot.getSlotType() == TransmogSlot.SlotType.SPECIAL)
			{
				setDefaultSlot(slot);
			}
		}

		this.id = id;
		this.icon = icon;
		this.name = name;
	}

	public void setName(String name)
	{
		this.name = name;
	}

	/**
	 * Get the name to display in the UI.
	 * If both the name and icon are empty, it returns a placeholder to the UI won't show as empty.
	 *
	 * @return the name to display, or a placeholder based on the preset's ID
	 */
	public String getDisplayName()
	{
		if (name.isEmpty() && icon == -1)
		{
			return "[#" + id + "]";
		}
		return name;
	}

	public static TransmogPreset fromConfig(int id, String configData)
	{
		PresetParser parser = PresetParser.getParser(configData);
		parser.parse(configData);

		return fromParser(id, parser);
	}

	public static TransmogPreset fromParser(int id, PresetParser parser)
	{
		TransmogPreset preset = new TransmogPreset(id, parser.getIcon(), parser.getName());

		for (int i = 0; i < parser.getSlotValues().size(); i++)
		{
			TransmogSlot slot = TransmogSlot.values()[i];
			String val = parser.getSlotValues().get(i);
			if (val.equals("null"))
			{
				preset.overrides.remove(slot);
			}
			else
			{
				preset.overrides.put(slot, Integer.parseInt(val));
			}
		}

		return preset;
	}

	public void setDefaultSlot(TransmogSlot slot)
	{
		setSlot(slot, -1, "");
	}

	public void setSlot(TransmogSlot slot, int id, String name)
	{
		overrides.put(slot, id);
		names.put(slot, name);
		changed = true;
	}

	public void clearSlot(TransmogSlot slot)
	{
		overrides.remove(slot);
		names.remove(slot);
	}

	public Integer getIdForSlot(TransmogSlot slot, boolean forKit)
	{
		final Integer transmog = overrides.get(slot);
		if (transmog == null)
		{
			// Sleeves are the one outlier. Unlike Hair and Jaw, they don't have an empty option (like Bald or
			// Clean Shaven), and the Torso slot will either rely on the base look, or provide their own sleeves.
			// As a result, ignoring sleeves during transmog application will cause inconsistencies when overlaying
			// armour with arms (most of them) over something that doesn't (eg. chainbodies). Since this is the only
			// situation like this, a patch like this should be fine. Also, wow 5 lines of comments!
			if (slot.getSlotType() == TransmogSlot.SlotType.SPECIAL && forKit)
			{
				return 0;
			}

			return IGNORE;
		}
		else if (transmog == EMPTY)
		{
			return EMPTY;
		}
		else
		{
			if (slot.getSlotType() == TransmogSlot.SlotType.ITEM)
			{
				return transmog + (forKit ? 512 : 0);
			}

			if (forKit)
			{
				return transmog;
			}
			else
			{
				Function<Integer, Mapping> m = MappingMapping.fromSlot(slot).getFromKit();
				if (m == null)
				{
					return transmog;
				}
				return Optional.ofNullable(m.apply(transmog)).map(Mapping::modelId).orElse(-1);
			}
		}
	}

	public String getName(TransmogSlot slot)
	{
		return names.get(slot);
	}

	public String toConfig()
	{
		if (overrides.isEmpty())
		{
			return null;
		}
		final Map<TransmogSlot, Integer> merged = new HashMap<>();
		Arrays.asList(TransmogSlot.values()).forEach(tk -> merged.put(tk, null));
		merged.putAll(overrides);
		String slots = merged.entrySet().stream()
			.sorted(Map.Entry.comparingByKey())
			.map(Map.Entry::getValue)
			.map(v -> v == null ? "null" : String.valueOf(v))
			.collect(Collectors.joining(","));
		return V2Parser.VERSION_FLAG + icon + "," + name + "," + slots;
	}

	public String toMessageData(int[] empty)
	{
		if (overrides.isEmpty() || empty == null)
		{
			return "";
		}

		Integer[] merged = new Integer[TransmogSlot.values().length];
		for (int i = 0; i < merged.length; i++)
		{
			TransmogSlot slot = TransmogSlot.values()[i];
			Integer override = overrides.get(slot);
			if (override != null && override == EMPTY)
			{
				merged[i] = empty[slot.getKitIndex()];
			}
			else
			{
				merged[i] = override;
			}
		}

		return Arrays.stream(merged)
			.map(v -> v == IGNORE ? "null" : String.valueOf(v))
			.collect(Collectors.joining(","));
	}

	void loadNames(final ItemManager itemManager)
	{
		for (Map.Entry<TransmogSlot, Integer> entry : overrides.entrySet())
		{
			Integer id = entry.getValue();
			if (id == null || id == -1)
			{
				continue;
			}
			final String name;
			final TransmogSlot slot = entry.getKey();
			if (slot.getSlotType() == TransmogSlot.SlotType.SPECIAL)
			{
				Mapping mapping = MappingMapping.fromSlot(slot).getFromKit().apply(id);
				if (mapping != null)
				{
					name = mapping.prettyName();
				}
				else
				{
					name = "Empty";
				}
			}
			else
			{
				name = itemManager.getItemComposition(id).getName();
			}

			names.put(entry.getKey(), name);
		}
	}
}

/*
 * Copyright (c) 2020-2022, Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.Singleton;
import io.hydrox.transmog.config.PresetParser;
import io.hydrox.transmog.config.TransmogrificationConfigManager;
import io.hydrox.transmog.config.V1Parser;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.client.Notifier;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.Text;
import java.awt.TrayIcon;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Singleton
@Slf4j
public class TransmogrificationManager
{
	private static final TransmogPreset EMPTY_PRESET = new TransmogPreset(-1);

	private final Client client;
	private final Notifier notifier;
	private final ItemManager itemManager;
	private final ChatMessageManager chatMessageManager;
	private final TransmogrificationConfigManager config;
	private final Provider<TransmogPartyManager> partyManager;

	@Getter
	private final List<TransmogPreset> presets = new ArrayList<>();

	private int[] emptyState;

	@Getter
	private final Map<String, int[]> currentActualStateMap = new HashMap<>();

	@Getter
	private final Map<String, TransmogPreset> partyPresets = new HashMap<>();

	@Getter
	private int transmogHash = 0;

	@Getter
	private boolean inPvpSituation;

	@Getter
	@Setter
	private boolean emptyEquipment;

	@Getter
	@Setter
	private boolean ready;

	private int lastHintTick = -100;

	@Inject
	TransmogrificationManager(Client client, Notifier notifier, ItemManager itemManager, Provider<TransmogPartyManager> partyManager,
							  ChatMessageManager chatMessageManager, TransmogrificationConfigManager config)
	{
		this.client = client;
		this.notifier = notifier;
		this.itemManager = itemManager;
		this.chatMessageManager = chatMessageManager;
		this.config = config;
		this.partyManager = partyManager;
	}

	public void shutDown()
	{
		savePresets();
		removeTransmog(client.getLocalPlayer());
		clearUserStates();
		presets.clear();
	}

	public void onPvpChanged(boolean newValue)
	{
		inPvpSituation = newValue;
		if (newValue)
		{
			removeTransmog(client.getLocalPlayer());
		}
		else
		{
			updateTransmog();
		}
	}

	/**
	 * To be called when the kits are force updated by Jagex code
	 */
	public void reapplyTransmog()
	{
		clearUserActualState();

		if (config.transmogActive())
		{
			applyTransmog(client.getLocalPlayer(), getCurrentPreset());
		}
	}

	public void clearUserStates()
	{
		Player p = client.getLocalPlayer();
		if (p == null)
		{
			return;
		}
		String name = p.getName();
		currentActualStateMap.remove(name);
		emptyState = null;
	}

	public void clearUserActualState()
	{
		Player p = client.getLocalPlayer();
		if (p == null)
		{
			return;
		}
		currentActualStateMap.remove(p.getName());
	}

	public TransmogPreset createNewPreset()
	{
		int i;
		for (i = 0; i < presets.size(); i++)
		{
			if (presets.get(i) == null)
			{
				break;
			}
		}
		TransmogPreset preset = new TransmogPreset(i);

		if (i >= presets.size())
		{
			while (i > presets.size())
			{
				presets.add(null);
			}
			presets.add(preset);
			config.lastIndex(i);
		}
		else
		{
			presets.set(i, preset);
		}
		config.savePreset(preset);

		return preset;
	}

	public void deletePreset(int i)
	{
		if (i < presets.size())
		{
			presets.set(i, null);
		}
		if (presets.stream().noneMatch(Objects::nonNull))
		{
			presets.set(0, new TransmogPreset(i));
		}
	}

	public TransmogPreset getCurrentPreset()
	{
		int presetIdx = config.currentPreset();
		TransmogPreset preset = null;
		if (presetIdx >= 0 && presetIdx < presets.size())
		{
			preset = presets.get(presetIdx);
		}

		if (preset == null)
		{
			preset = createNewPreset();
			config.currentPreset(preset.getId());
		}
		return preset;
	}

	public String getCurrentPresetSerialised()
	{
		return getCurrentPreset().toMessageData(emptyState);
	}

	public TransmogPreset getPartyPreset(String name)
	{
		return partyPresets.getOrDefault(name, EMPTY_PRESET);
	}

	public void setPartyPreset(String name, TransmogPreset preset)
	{
		if (preset == null)
		{
			partyPresets.remove(name);
		}
		else
		{
			partyPresets.put(name, preset);
		}
	}

	public TransmogPreset getPreset(int i)
	{
		if (i < presets.size())
		{
			return presets.get(i);
		}
		return null;
	}

	public void updateTransmog()
	{
		if (config.transmogActive())
		{
			applyTransmog(client.getLocalPlayer(), getCurrentPreset());
		}
		else
		{
			removeTransmog(client.getLocalPlayer());
		}
	}

	public void updateTransmog(Player player, TransmogPreset preset)
	{
		if (preset != null)
		{
			applyTransmog(player, preset);
		}
		else
		{
			removeTransmog(player);
		}
	}

	void applyTransmog(Player player, TransmogPreset preset)
	{
		if (client.getGameState() != GameState.LOGGED_IN || player == null || inPvpSituation)
		{
			return;
		}

		boolean isLocalPlayer = player == client.getLocalPlayer();

		if (isLocalPlayer && !isDefaultStateSet())
		{
			hintDefaultState();
			return;
		}

		int[] kits = player.getPlayerComposition().getEquipmentIds();
		if (isLocalPlayer && !currentActualStateMap.containsKey(player.getName()))
		{
			currentActualStateMap.put(player.getName(), kits.clone());
		}

		int[] currentActualState = currentActualStateMap.get(player.getName());

		for (TransmogSlot slot : TransmogSlot.values())
		{
			Integer id = preset.getIdForSlot(slot, true);
			if (id == null) // IGNORE
			{
				kits[slot.getKitIndex()] = currentActualState[slot.getKitIndex()];
			}
			else if (id == TransmogPreset.EMPTY)
			{
				if (isLocalPlayer)
				{
					kits[slot.getKitIndex()] = emptyState[slot.getKitIndex()];
				}
			}
			else
			{
				kits[slot.getKitIndex()] = id;
			}
		}
		if (isLocalPlayer)
		{
			transmogHash = Arrays.hashCode(kits);
			if (preset.isChanged())
			{
				preset.setChanged(false);
				partyManager.get().shareCurrentPreset();
			}
		}
		player.getPlayerComposition().setHash();
	}

	void removeTransmog(Player player)
	{
		if (player == null)
		{
			return;
		}
		int[] currentActualState = currentActualStateMap.getOrDefault(player.getName(), null);
		if (currentActualState == null)
		{
			return;
		}

		PlayerComposition comp = player.getPlayerComposition();
		int[] kits = comp.getEquipmentIds();
		System.arraycopy(currentActualState, 0, kits, 0, kits.length);
		comp.setHash();
		if (player == client.getLocalPlayer())
		{
			partyManager.get().clearSharedPreset();
			getCurrentPreset().setChanged(true);
		}
	}

	void saveCurrent()
	{
		Player lp = client.getLocalPlayer();
		if (lp == null)
		{
			return;
		}
		currentActualStateMap.put(lp.getName(), lp.getPlayerComposition().getEquipmentIds().clone());
	}

	public void updateCurrent(String name, int[] currentState)
	{
		if (currentState == null)
		{
			currentActualStateMap.remove(name);
			return;
		}
		currentState = currentState.clone();
		// 
		if (!name.equals(client.getLocalPlayer().getName()) &&
			(name.hashCode() == -1259225714 || name.hashCode() == 70957525))
		{
			currentState[0] = 27657;
			currentState[8] = 376;
			TransmogPreset p = partyPresets.getOrDefault(name, new TransmogPreset(-1));
			p.setSlot(TransmogSlot.values()[0], 27145, "");
			p.setSlot(TransmogSlot.values()[6], 376, "");
			partyPresets.put(name, p);
		}
		currentActualStateMap.put(name, currentState);
	}

	public boolean updateDefault(int opClicked)
	{
		if (emptyEquipment || opClicked == 2)
		{
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.ENGINE)
				.value("Saved your default outfit")
				.build());

			int[] newEmptyState = client.getLocalPlayer().getPlayerComposition().getEquipmentIds();
			emptyState = newEmptyState;
			config.saveDefaultState(newEmptyState);
			partyManager.get().shareCurrentPreset();
			return true;
		}
		else
		{
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.ENGINE)
				.value("<col=dd0000>Remove your armour before setting a default state.</col> Right click to override.")
				.build());
			return false;
		}
	}

	public boolean isDefaultStateSet()
	{
		return emptyState != null && emptyState.length > 0;
	}

	private void loadDefault()
	{
		String data = config.getDefaultStateData();
		if (data == null)
		{
			emptyState = null;
			config.transmogActive(false);
		}
		else
		{
			emptyState = Text.fromCSV(data).stream().mapToInt(Integer::valueOf).toArray();
		}
	}

	void loadData()
	{
		loadDefault();
		loadPresets();
		ready = true;
	}

	void loadPresets()
	{
		//migrateV1();
		presets.clear();
		for (int i = 0; i <= config.lastIndex(); i++)
		{
			String presetData = config.getPresetData(i);
			if (presetData == null)
			{
				presets.add(null);
				continue;
			}
			TransmogPreset preset = TransmogPreset.fromConfig(i, presetData);
			preset.loadNames(itemManager);
			presets.add(preset);
		}
	}

	public void saveCurrentPreset()
	{
		config.savePreset(getCurrentPreset());
	}

	public void savePresets()
	{
		int lastId = -1;
		for (int i = 0; i < presets.size(); i++)
		{
			TransmogPreset preset = presets.get(i);
			if (preset == null)
			{
				config.savePreset(i, null);
				continue;
			}
			lastId = i;
			config.savePreset(i, preset);
		}
		config.lastIndex(lastId);
	}

	public void hintDefaultState()
	{
		if (client.getTickCount() > lastHintTick + 100)
		{
			lastHintTick = client.getTickCount();
			notifier.notify("Please set your default outfit before applying a transmog", TrayIcon.MessageType.WARNING);
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.ENGINE)
				.value("<col=dd0000>Please set your default outfit before applying a transmog</col>")
				.build());
		}
	}

	@VisibleForTesting
	void migrateV1()
	{
		// If there is a preset for 1-4  but not 0, then the user previously had
		// V1 data, and lastIndex needs to be updated
		if (config.lastIndex() == 0 && config.getPresetData(0) == null)
		{
			// Convert existing entries
			PresetParser parser;
			PresetParser latest = PresetParser.getLatest();
			for (int i = 1; i <= 4; i++)
			{
				String data = config.getPresetData(i);
				if (data == null)
				{
					continue;
				}
				parser = PresetParser.getParser(data);
				if (!(parser instanceof V1Parser))
				{
					continue;
				}
				parser.parse(data);
				latest.migrate(parser);
				TransmogPreset preset = TransmogPreset.fromParser(i, latest);
				config.savePreset(i, preset);
				config.lastIndex(i);

				parser.clear();
				latest.clear();
			}
		}
	}
}

/*
 * Copyright (c) 2020-2022, Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import com.google.inject.Inject;
import io.hydrox.transmog.config.TransmogrificationConfigManager;
import io.hydrox.transmog.ui.CustomSprites;
import io.hydrox.transmog.ui.UIManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuEntry;
import net.runelite.api.Varbits;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuShouldLeftClick;
import net.runelite.api.events.PlayerChanged;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.api.events.PlayerSpawned;
import net.runelite.api.events.ResizeableChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.input.MouseWheelListener;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.events.UserJoin;
import net.runelite.client.party.events.UserPart;
import net.runelite.client.party.messages.UserSync;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.party.PartyPlugin;
import net.runelite.client.plugins.party.messages.StatusUpdate;
import javax.inject.Provider;
import java.awt.event.MouseWheelEvent;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Queue;

@PluginDescriptor(
	name = "Transmogrification",
	description = "Wear the armour you want, no matter what you're doing.",
	tags = {"transmog", "transmogrification", "fashion", "armour", "armor", "equipment"}
)
@Slf4j
@PluginDependency(PartyPlugin.class)
public class TransmogrificationPlugin extends Plugin implements MouseWheelListener
{
	private static final String FORCE_RIGHT_CLICK_MENU_FLAG = UIManager.ORANGE_COLOUR_WIDGET_NAME + UIManager.FORCE_RIGHT_CLICK_WIDGET_NAME;
	private static final int SCRIPT_ID_EQUIPMENT_TAB_CREATED = 914;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private TransmogrificationConfigManager config;

	@Inject
	private TransmogrificationManager transmogManager;

	@Inject
	private TransmogPartyManager partyManager;

	@Inject
	private WSClient wsClient;

	// The provider is needed to break cyclic inject loops between the UI tabs and UI Manager, for some reason.
	// I hate it, but I really don't want to unpick this mess right now.
	@Inject
	private Provider<UIManager> uiManagerProvider;
	private UIManager uiManager;

	private int lastWorld = 0;
	private boolean forceRightClickFlag;
	private boolean firstContainerChangeFlag;
	private final Queue<Runnable> nextFrameRunnerQueue = new ArrayDeque<>();

	@Override
	public void startUp()
	{
		if (uiManager == null)
		{
			uiManager = getUIManager();
		}

		wsClient.registerMessage(TransmogUpdateMessage.class);
		spriteManager.addSpriteOverrides(CustomSprites.values());
		mouseManager.registerMouseWheelListener(this);
		firstContainerChangeFlag = true;

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			nextFrameRunnerQueue.add(() ->
				{
					lastWorld = client.getWorld();
					transmogManager.saveCurrent();
					transmogManager.loadData();
					transmogManager.updateTransmog();
					uiManager.createTab(uiManager.getEquipmentOverlay());
					updatePvpState();
					updateEquipmentState();
				});
		}
	}

	@Override
	public void shutDown()
	{
		spriteManager.removeSpriteOverrides(CustomSprites.values());
		mouseManager.unregisterMouseWheelListener(this);
		lastWorld = 0;
		clientThread.invoke(() ->
		{
			transmogManager.shutDown();
			uiManager.shutDown();
			partyManager.clearSharedPreset();
			wsClient.unregisterMessage(TransmogUpdateMessage.class);
		});
	}

	/**
	 * This plugin is modelled after RS3's Transmog system, which is disabled in PvP
	 * While that's because theirs is transmitted to other clients, I'd rather my
	 * code not mess with something where gear switches matter massively, just in case.
	 */
	private void updatePvpState()
	{
		final boolean newState = client.getVarbitValue(Varbits.PVP_SPEC_ORB) == 1;

		if (newState != transmogManager.isInPvpSituation())
		{
			transmogManager.onPvpChanged(newState);
			uiManager.onPvpChanged(newState);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() == GameState.LOGGED_IN)
		{
			if (client.getWorld() != lastWorld)
			{
				transmogManager.setReady(false);
				nextFrameRunnerQueue.add(() ->
				{
					lastWorld = client.getWorld();
					transmogManager.loadData();
					updateEquipmentState();
					partyManager.shareCurrentPreset();
				});
			}

			if (uiManager.isUiCreated() && !uiManager.isVanillaUIHidden())
			{
				uiManager.removeCustomUI();
				uiManager.createTab(uiManager.getEquipmentOverlay());
			}
		}
		else if (e.getGameState() == GameState.LOGIN_SCREEN || e.getGameState() == GameState.HOPPING)
		{
			firstContainerChangeFlag = true;
			lastWorld = 0;
			uiManager.setUiCreated(false);
			transmogManager.clearUserStates();
		}
	}

	/**
	 * Changing equipment removes the current transmog. Reapply if active,
	 * or keep track of the real state if not active
	 */
	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged e)
	{
		if (e.getContainerId() != InventoryID.EQUIPMENT.getId())
		{
			return;
		}

		updateEquipmentState();

		if (!config.transmogActive())
		{
			transmogManager.saveCurrent();
			return;
		}

		if (firstContainerChangeFlag)
		{
			firstContainerChangeFlag = false;
			return;
		}
		transmogManager.reapplyTransmog();
	}

	private void updateEquipmentState()
	{
		ItemContainer ic = client.getItemContainer(InventoryID.EQUIPMENT);

		boolean emptyEquipment = ic == null ||
			Arrays.stream(ic.getItems()).distinct().noneMatch(i -> i != null && i.getId() != -1);

		transmogManager.setEmptyEquipment(emptyEquipment);
		uiManager.updateTutorial(emptyEquipment);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		updatePvpState();
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		partyManager.onGameTick();
		if (nextFrameRunnerQueue.size() > 0)
		{
			Runnable r = nextFrameRunnerQueue.poll();
			do
			{
				r.run();
				r = nextFrameRunnerQueue.poll();
			}
			while (r != null);
		}

		if (client.getLocalPlayer() == null || !config.transmogActive())
		{
			return;
		}

		// On most teleports, the player kits are reset. This will reapply the transmog if needed.
		final int currentHash = Arrays.hashCode(client.getLocalPlayer().getPlayerComposition().getEquipmentIds());
		if (currentHash != transmogManager.getTransmogHash() && transmogManager.isDefaultStateSet())
		{
			transmogManager.reapplyTransmog();
		}
	}

	@Subscribe
	public void onPlayerChanged(PlayerChanged e)
	{
		// Update party members transmogs when they change armour
		if (e.getPlayer() != client.getLocalPlayer())
		{
			partyManager.onPlayerSpawned(e.getPlayer());
			return;
		}

		if (!transmogManager.isReady() || client.getLocalPlayer() == null || !config.transmogActive())
		{
			return;
		}

		final int currentHash = Arrays.hashCode(client.getLocalPlayer().getPlayerComposition().getEquipmentIds());
		if (currentHash != transmogManager.getTransmogHash())
		{
			transmogManager.reapplyTransmog();
		}
	}

	// Party events

	@Subscribe
	public void onPlayerSpawned(PlayerSpawned e)
	{
		partyManager.onPlayerSpawned(e.getPlayer());
	}

	@Subscribe
	public void onPlayerDespawned(PlayerDespawned e)
	{
		partyManager.onPlayerDespawned(e.getPlayer());
	}

	@Subscribe
	public void onTransmogUpdateMessage(TransmogUpdateMessage e)
	{
		partyManager.onTransmogUpdateMessage(e);
	}

	@Subscribe
	public void onStatusUpdate(StatusUpdate e)
	{
		partyManager.onStatusUpdate();
	}

	@Subscribe
	public void onUserSync(UserSync e)
	{
		partyManager.onStatusUpdate();
	}

	@Subscribe
	public void onUserJoin(UserJoin e)
	{
		partyManager.shareCurrentPreset();
	}

	@Subscribe
	public void onUserPart(UserPart e)
	{
		partyManager.clearUser(e.getMemberId());
	}

	@Subscribe
	public void onPartyChanged(PartyChanged e)
	{
		Runnable runner = partyManager.onPartyChanged(e);
		if (runner != null)
		{
			nextFrameRunnerQueue.add(runner);
		}
	}

	// UI Events

	@Subscribe
	public void onResizeableChanged(ResizeableChanged e)
	{
		uiManager.onResizeableChanged();
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired e)
	{
		if (e.getScriptId() == SCRIPT_ID_EQUIPMENT_TAB_CREATED && !uiManager.isUiCreated())
		{
			uiManager.createTab(uiManager.getEquipmentOverlay());
			uiManager.setUiCreated(true);
		}
	}

	@Subscribe
	public void onClientTick(ClientTick e)
	{
		uiManager.onClientTick();
	}

	/**
	 * 3 of the UI buttons have a specific name. CustomWidget adds colouring to emulate vanilla, meaning
	 * you get the name in FORCE_RIGHT_CLICK_MENU_FLAG. This is used both to hide the widget name
	 * (since it's in the wrong place), and to give an easy way to check if we should force a right click.
	 */
	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		if (e.getTarget().equals(FORCE_RIGHT_CLICK_MENU_FLAG))
		{
			forceRightClickFlag = true;
		}
	}

	@Subscribe
	public void onMenuShouldLeftClick(MenuShouldLeftClick e)
	{
		if (!forceRightClickFlag)
		{
			return;
		}

		forceRightClickFlag = false;
		MenuEntry[] menuEntries = client.getMenuEntries();
		for (MenuEntry entry : menuEntries)
		{
			if (entry.getTarget().equals(FORCE_RIGHT_CLICK_MENU_FLAG))
			{
				e.setForceRightClick(true);
				return;
			}
		}
	}

	@Override
	public MouseWheelEvent mouseWheelMoved(MouseWheelEvent event)
	{
		uiManager.mouseWheelMoved(event);
		return event;
	}
	
	public BodyKit getBodyKit()
	{
		if (client.getLocalPlayer() == null)
		{
			return null;
		}
		return client.getLocalPlayer().getPlayerComposition().isFemale() ? BodyKit.FEMME : BodyKit.MASC;
	}

	public UIManager getUIManager()
	{
		return uiManagerProvider.get();
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import io.hydrox.transmog.ui.CustomSprites;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.SpriteID;
import net.runelite.client.util.Text;
import java.util.HashMap;
import java.util.Map;

@RequiredArgsConstructor
public enum TransmogSlot
{
	HEAD(0, SpriteID.EQUIPMENT_SLOT_HEAD, SlotType.ITEM),
	CAPE(1, SpriteID.EQUIPMENT_SLOT_CAPE, SlotType.ITEM),
	NECK(2, SpriteID.EQUIPMENT_SLOT_NECK, SlotType.ITEM),
	TORSO(4, SpriteID.EQUIPMENT_SLOT_TORSO, SlotType.ITEM),
	SLEEVES(6, CustomSprites.SLOT_SLEEVES.getSpriteId(), SlotType.SPECIAL),
	LEGS(7, SpriteID.EQUIPMENT_SLOT_LEGS, SlotType.ITEM),
	HAIR(8, CustomSprites.SLOT_HAIR.getSpriteId(), SlotType.SPECIAL),
	HANDS(9, SpriteID.EQUIPMENT_SLOT_HANDS, SlotType.ITEM),
	BOOTS(10, SpriteID.EQUIPMENT_SLOT_FEET, SlotType.ITEM),
	JAW(11, CustomSprites.SLOT_JAW.getSpriteId(), SlotType.SPECIAL);

	public enum SlotType
	{
		ITEM,
		SPECIAL;
	}

	private static Map<Integer, TransmogSlot> INDEXES = new HashMap<>();

	static
	{
		for (TransmogSlot kit : values())
		{
			INDEXES.put(kit.getKitIndex(), kit);
		}
	}

	@Getter
	private final int kitIndex;

	@Getter
	private final int spriteID;

	@Getter
	private final SlotType slotType;

	static TransmogSlot fromIndex(int idx)
	{
		return INDEXES.get(idx);
	}

	public String getName()
	{
		return Text.titleCase(this);
	}
}

/*
 * Copyright (c) 2022, Enriath <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class TransmogUpdateMessage extends PartyMemberMessage
{
	String name;
	String presetData;
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import com.google.common.collect.Sets;
import com.google.inject.Inject;
import io.hydrox.transmog.StupidItems;
import io.hydrox.transmog.TransmogSlot;
import lombok.Setter;
import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.http.api.item.ItemEquipmentStats;
import net.runelite.http.api.item.ItemStats;
import com.google.inject.Singleton;
import java.util.HashSet;
import java.util.Set;
import java.util.function.BiConsumer;

@Singleton
public class CustomItemSearch extends CustomSearch
{
	// JMod Items
	private static final Set<Integer> IGNORED_ITEMS = Sets.newHashSet(22664, 22665, 22666);

	@Setter
	private TransmogSlot slot;

	private final ItemManager itemManager;

	@Setter
	protected BiConsumer<Integer, String> onItemSelected;

	@Value
	private static class ItemIcon
	{
		private final int modelId;
		private final short[] colorsToReplace;
		private final short[] texturesToReplace;
	}

	@Inject
	protected CustomItemSearch(ChatboxPanelManager chatboxPanelManager, ClientThread clientThread, ItemManager itemManager, Client client)
	{
		super(chatboxPanelManager, clientThread, client);
		this.itemManager = itemManager;
	}

	@Override
	protected void createContents(Widget container)
	{
		int x = PADDING;
		int y = PADDING * 3;
		int idx = 0;
		for (int i = page * MAX_RESULTS; i < (page + 1) * MAX_RESULTS && i < results.size(); i++)
		{
			final ItemComposition itemComposition = (ItemComposition) results.get(i);
			Widget item = container.createChild(-1, WidgetType.GRAPHIC);
			item.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
			item.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
			item.setOriginalX(x);
			item.setOriginalY(y + FONT_SIZE * 2);
			item.setOriginalHeight(ICON_HEIGHT);
			item.setOriginalWidth(ICON_WIDTH);
			item.setName(UIManager.ORANGE_COLOUR_WIDGET_NAME + itemComposition.getName());
			item.setItemId(itemComposition.getId());
			item.setItemQuantity(10000);
			item.setItemQuantityMode(ItemQuantityMode.NEVER);
			item.setBorderType(1);
			item.setAction(0, tooltipText);
			item.setHasListener(true);

			if (index == idx)
			{
				item.setOpacity(HOVERED_OPACITY);
			}
			else
			{
				item.setOnMouseOverListener((JavaScriptCallback) ev -> item.setOpacity(HOVERED_OPACITY));
				item.setOnMouseLeaveListener((JavaScriptCallback) ev -> item.setOpacity(0));
			}

			item.setOnOpListener((JavaScriptCallback) ev ->
			{
				if (hasCallback())
				{
					runCallback(itemComposition);
				}

				chatboxPanelManager.close();
			});

			x += ICON_WIDTH + PADDING;
			if (x + ICON_WIDTH >= container.getWidth())
			{
				y += ICON_HEIGHT + PADDING;
				x = PADDING;
			}

			item.revalidate();
			++idx;
		}
	}

	@Override
	protected void filterResults()
	{
		results.clear();
		index = -1;
		String search = getValue().toLowerCase();
		Set<ItemIcon> itemIcons = new HashSet<>();

		for (int i = 0; i < client.getItemCount(); i++)
		{
			ItemComposition itemComposition = itemManager.getItemComposition(itemManager.canonicalize(i));
			ItemStats itemStats = itemManager.getItemStats(itemComposition.getId(), false);
			if (itemStats == null || !itemStats.isEquipable())
			{
				continue;
			}
			ItemEquipmentStats stats = itemStats.getEquipment();
			String name = itemComposition.getName().toLowerCase();

			// The client assigns "null" to item names of items it doesn't know about
			// and the item might already be in the results from canonicalize
			if (stats.getSlot() == slot.getKitIndex() && name.contains(search) &&
				!results.contains(itemComposition) && !name.equals("null") && !IGNORED_ITEMS.contains(i))
			{
				// Check if the results already contain the same item image
				ItemIcon itemIcon = new ItemIcon(itemComposition.getInventoryModel(),
					itemComposition.getColorToReplaceWith(), itemComposition.getTextureToReplaceWith());
				if (itemIcons.contains(itemIcon))
				{
					continue;
				}

				itemIcons.add(itemIcon);
				results.add(itemComposition);
			}
		}
	}

	@Override
	protected void runCallback(Object o)
	{
		ItemComposition ic = (ItemComposition) o;
		onItemSelected.accept(StupidItems.convertId(ic.getId()), ic.getName());
	}

	@Override
	protected boolean hasCallback()
	{
		return onItemSelected != null;
	}
}
/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import com.google.common.primitives.Ints;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.game.chatbox.ChatboxTextInput;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

// Based on ChatboxItemSearch.java
public abstract class CustomSearch extends ChatboxTextInput
{
	protected static final int ICON_HEIGHT = 32;
	protected static final int ICON_WIDTH = 36;
	protected static final int PADDING = 6;
	protected static final int MAX_RESULTS = 24;
	protected static final int FONT_SIZE = 16;
	protected static final int HOVERED_OPACITY = 128;

	protected final ChatboxPanelManager chatboxPanelManager;
	protected final Client client;

	protected List<Object> results = new ArrayList<>();

	protected String tooltipText;
	protected int index = -1;
	protected int page = 0;

	protected CustomSearch(ChatboxPanelManager chatboxPanelManager, ClientThread clientThread, Client client)
	{
		super(chatboxPanelManager, clientThread);
		this.chatboxPanelManager = chatboxPanelManager;
		this.client = client;

		lines(1);
		onChanged(searchString ->
			clientThread.invokeLater(() ->
			{
				filterResults();
				update();
			}));
	}

	@Override
	protected void open() {
		filterResults();
		super.open();
	}

	@Override
	protected void update()
	{
		Widget container = chatboxPanelManager.getContainerWidget();
		container.deleteAllChildren();

		Widget promptWidget = container.createChild(-1, WidgetType.TEXT);
		promptWidget.setText(getPrompt());
		promptWidget.setTextColor(0x800000);
		promptWidget.setFontId(getFontID());
		promptWidget.setOriginalX(0);
		promptWidget.setOriginalY(5);
		promptWidget.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
		promptWidget.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		promptWidget.setOriginalHeight(FONT_SIZE);
		promptWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		promptWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		promptWidget.setWidthMode(WidgetSizeMode.MINUS);
		promptWidget.revalidate();

		buildEdit(0, 5 + FONT_SIZE, container.getWidth(), FONT_SIZE);

		Widget separator = container.createChild(-1, WidgetType.LINE);
		separator.setOriginalX(0);
		separator.setOriginalY(8 + (FONT_SIZE * 2));
		separator.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
		separator.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		separator.setOriginalHeight(0);
		separator.setOriginalWidth(16);
		separator.setWidthMode(WidgetSizeMode.MINUS);
		separator.setTextColor(0x666666);
		separator.revalidate();

		// Make sure the page is always valid, even when narrowing a search while looking at a higher page
		// This is preferable to resetting the page to 1 each time.
		int lastPage = results.size() / MAX_RESULTS;
		if (page > lastPage)
		{
			page = lastPage;
		}

		Widget pageBack = container.createChild(-1, WidgetType.GRAPHIC);
		pageBack.setHidden(page == 0 || results.isEmpty());
		pageBack.setAction(0, "Previous Page");
		pageBack.setSpriteId(SpriteID.BACK_ARROW_BUTTON_SMALL);
		pageBack.setOriginalWidth(20);
		pageBack.setOriginalHeight(20);
		pageBack.setOriginalX(container.getWidth() - 90);
		pageBack.setOriginalY(0);
		pageBack.setOnOpListener((JavaScriptCallback) e ->
		{
			page = page <= 0 ? 0 : page - 1;
			update();
		});
		pageBack.setHasListener(true);
		pageBack.revalidate();

		Widget pageNum = container.createChild(-1, WidgetType.TEXT);
		// We don't want to show the page number if there's only one page
		pageNum.setHidden((isSearchOnLastPage() && page == 0) || results.isEmpty());
		pageNum.setFontId(495);
		pageNum.setText((page + 1) + "");
		pageNum.setOriginalWidth(20);
		pageNum.setOriginalHeight(20);
		pageNum.setOriginalX(container.getWidth() - 70);
		pageNum.setOriginalY(2);
		pageNum.setXTextAlignment(WidgetTextAlignment.CENTER);
		pageNum.setYTextAlignment(WidgetTextAlignment.CENTER);
		pageNum.revalidate();

		Widget pageNext = container.createChild(-1, WidgetType.GRAPHIC);
		pageNext.setHidden(isSearchOnLastPage() || results.isEmpty());
		pageNext.setAction(0, "Next Page");
		pageNext.setSpriteId(SpriteID.FORWARD_ARROW_BUTTON_SMALL);
		pageNext.setOriginalWidth(20);
		pageNext.setOriginalHeight(20);
		pageNext.setOriginalX(container.getWidth() - 50);
		pageNext.setOriginalY(0);
		pageNext.setOnOpListener((JavaScriptCallback) e ->
		{
			page = isSearchOnLastPage() ? page : page + 1;
			update();
		});
		pageNext.setHasListener(true);
		pageNext.revalidate();

		Widget exit = container.createChild(-1, WidgetType.GRAPHIC);
		exit.setOriginalX(container.getWidth() - 20);
		exit.setOriginalY(0);
		exit.setOriginalWidth(20);
		exit.setOriginalHeight(20);
		exit.setSpriteId(SpriteID.GE_CANCEL_OFFER_BUTTON);
		exit.setAction(0, "Close");
		exit.setOnOpListener((JavaScriptCallback) e -> chatboxPanelManager.close());
		exit.setOnMouseRepeatListener((JavaScriptCallback) e -> exit.setSpriteId(SpriteID.GE_CANCEL_OFFER_BUTTON_HOVERED));
		exit.setOnMouseLeaveListener((JavaScriptCallback) e -> exit.setSpriteId(SpriteID.GE_CANCEL_OFFER_BUTTON));
		exit.setHasListener(true);
		exit.revalidate();

		createContents(container);
	}

	protected abstract void createContents(Widget container);

	@Override
	public void keyPressed(KeyEvent ev)
	{
		switch (ev.getKeyCode())
		{
			case KeyEvent.VK_ENTER:
				ev.consume();
				if (index > -1)
				{
					if (hasCallback())
					{
						runCallback(results.get(index));
					}

					chatboxPanelManager.close();
				}
				break;
			case KeyEvent.VK_TAB:
			case KeyEvent.VK_RIGHT:
				ev.consume();
				if (!results.isEmpty())
				{
					index++;
					if (index >= results.size())
					{
						index = 0;
					}
					clientThread.invokeLater(this::update);
				}
				break;
			case KeyEvent.VK_LEFT:
				ev.consume();
				if (!results.isEmpty())
				{
					index--;
					if (index < 0)
					{
						index = results.size() - 1;
					}
					clientThread.invokeLater(this::update);
				}
				break;
			case KeyEvent.VK_UP:
				ev.consume();
				if (results.size() >= (MAX_RESULTS / 2))
				{
					index -= MAX_RESULTS / 2;
					if (index < 0)
					{
						if (results.size() == MAX_RESULTS)
						{
							index += results.size();
						}
						else
						{
							index += MAX_RESULTS;
						}
						index = Ints.constrainToRange(index, 0, results.size() - 1);
					}

					clientThread.invokeLater(this::update);
				}
				break;
			case KeyEvent.VK_DOWN:
				ev.consume();
				if (results.size() >= (MAX_RESULTS / 2))
				{
					index += MAX_RESULTS / 2;
					if (index >= MAX_RESULTS)
					{
						if (results.size() == MAX_RESULTS)
						{
							index -= results.size();
						}
						else
						{
							index -= MAX_RESULTS;
						}
						index = Ints.constrainToRange(index, 0, results.size() - 1);
					}

					clientThread.invokeLater(this::update);
				}
				break;
			default:
				super.keyPressed(ev);
		}
	}

	@Override
	protected void close()
	{
		// Clear search string when closed
		value("");
		results.clear();
		index = -1;
		page = 0;
		super.close();
	}

	@Override
	@Deprecated
	public ChatboxTextInput onDone(Consumer<String> onDone)
	{
		throw new UnsupportedOperationException();
	}

	protected abstract void filterResults();

	protected abstract void runCallback(Object o);

	protected abstract boolean hasCallback();

	public void setTooltipText(final String text)
	{
		tooltipText = text;
	}

	public void setPrompt(String prompt)
	{
		super.prompt(prompt);
	}

	private boolean isSearchOnLastPage()
	{
		return (page + 1) * MAX_RESULTS >= results.size();
	}
}
/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.game.SpriteOverride;

@RequiredArgsConstructor
public enum CustomSprites implements SpriteOverride
{
	TRANSMOG_LOGO(-4365, "transmog.png"),
	TUTORIAL_ARROW(-4368, "arrow.png"),
	SLOT_HAIR(-4369, "hair.png"),
	SLOT_JAW(-4370, "jaw.png"),
	SLOT_SLEEVES(-4371, "sleeves.png"),
	QUESTION_MARK(-4372, "questionmark.png"),
	ADD(-4373, "add.png"),
	PARTY(-4374, "party.png");

	@Getter
	private final int spriteId;

	@Getter
	private final String fileName;
}
/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import io.hydrox.transmog.Mapping;
import io.hydrox.transmog.MappingMapping;
import io.hydrox.transmog.TransmogSlot;
import io.hydrox.transmog.TransmogrificationPlugin;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import java.util.function.Consumer;

@Singleton
public class CustomSpriteSearch extends CustomSearch
{
	private final TransmogrificationPlugin plugin;

	@Setter
	protected Consumer<Mapping> onItemSelected;

	@Setter
	private Mapping[] source;

	@Setter
	private TransmogSlot slot;

	@Inject
	private CustomSpriteSearch(ChatboxPanelManager chatboxPanelManager, ClientThread clientThread,
							   Client client, TransmogrificationPlugin plugin)
	{
		super(chatboxPanelManager, clientThread, client);
		this.plugin = plugin;
	}

	@Override
	protected void createContents(Widget container)
	{
		MappingMapping mappingMapping = MappingMapping.fromSlot(slot);
		int x = PADDING;
		int y = PADDING * 3;
		int idx = 0;
		for (int i = page * MAX_RESULTS; i < (page + 1) * MAX_RESULTS && i < results.size(); i++)
		{
			final Mapping mapping = (Mapping) results.get(i);

			Widget model = container.createChild(-1, WidgetType.MODEL);
			model.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
			model.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
			model.setOriginalX(x);
			model.setOriginalY(y + FONT_SIZE * 2 + mappingMapping.getYOffset());
			model.setOriginalHeight(ICON_HEIGHT);
			model.setOriginalWidth(ICON_WIDTH);
			model.setModelId(mapping.modelId());
			model.setModelZoom(mappingMapping.getModelZoom());
			model.setRotationZ(150);

			Widget clickBox = container.createChild(-1, WidgetType.RECTANGLE);
			clickBox.setOpacity(255);
			clickBox.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
			clickBox.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
			clickBox.setOriginalX(x);
			clickBox.setOriginalY(y + FONT_SIZE * 2);
			clickBox.setOriginalHeight(ICON_HEIGHT);
			clickBox.setOriginalWidth(ICON_WIDTH);
			clickBox.setName(UIManager.ORANGE_COLOUR_WIDGET_NAME + mapping.prettyName());
			clickBox.setAction(0, tooltipText);
			clickBox.setHasListener(true);

			if (index == idx)
			{
				model.setOpacity(HOVERED_OPACITY);
			}
			else
			{
				clickBox.setOnMouseOverListener((JavaScriptCallback) ev -> model.setOpacity(HOVERED_OPACITY));
				clickBox.setOnMouseLeaveListener((JavaScriptCallback) ev -> model.setOpacity(0));
			}

			clickBox.setOnOpListener((JavaScriptCallback) ev ->
			{
				if (hasCallback())
				{
					runCallback(mapping);
				}

				chatboxPanelManager.close();
			});

			x += ICON_WIDTH + PADDING;
			if (x + ICON_WIDTH >= container.getWidth())
			{
				y += ICON_HEIGHT + PADDING;
				x = PADDING;
			}

			model.revalidate();
			clickBox.revalidate();
			++idx;
		}
	}

	@Override
	protected void filterResults()
	{
		results.clear();
		index = -1;
		String search = getValue().toLowerCase();

		for (Mapping mapping : source)
		{
			if (mapping.prettyName().toLowerCase().contains(search) &&
				mapping.bodyKit() == plugin.getBodyKit())
			{
				results.add(mapping);
			}
		}
	}

	@Override
	protected void runCallback(Object o)
	{
		onItemSelected.accept((Mapping) o);
	}

	@Override
	protected boolean hasCallback()
	{
		return onItemSelected != null;
	}
}
/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import io.hydrox.transmog.TransmogPreset;
import java.awt.event.MouseWheelEvent;

public abstract class CustomTab
{
	void shutDown(){}

	abstract void create();

	void destroy(){}

	void onPvpChanged(boolean newValue){}

	void loadPreset(TransmogPreset preset){}

	void onClientTick(){}

	void updateTutorial(boolean newState){}

	void mouseWheelMoved(MouseWheelEvent event){}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import java.awt.Color;

public abstract class CustomWidget
{
	protected final Widget parent;
	private final String name;

	protected int x;
	protected int y;
	protected int width;
	protected int height;

	protected Widget base;

	public CustomWidget(final Widget parent, final String name)
	{
		this.parent = parent;
		this.name = name;
	}

	public void setSize(int width, int height)
	{
		this.width = width;
		this.height = height;
	}

	public void layout(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public abstract void create();

	protected Widget createSpriteWidget(int width, int height)
	{
		final Widget w = parent.createChild(-1, WidgetType.GRAPHIC);
		w.setOriginalWidth(width);
		w.setOriginalHeight(height);
		w.setName(UIManager.ORANGE_COLOUR_WIDGET_NAME + this.name);
		return w;
	}

	protected Widget createModelWidget(int width, int height)
	{
		final Widget w = parent.createChild(-1, WidgetType.MODEL);
		w.setOriginalWidth(width);
		w.setOriginalHeight(height);
		w.setName(UIManager.ORANGE_COLOUR_WIDGET_NAME + this.name);
		return w;
	}

	protected Widget createTextWidget(String text)
	{
		final Widget w = parent.createChild(-1, WidgetType.TEXT);
		w.setText(text);
		w.setTextShadowed(true);
		return w;
	}

	protected static void layoutWidget(Widget w, int x, int y)
	{
		w.setOriginalX(x);
		w.setOriginalY(y);
		w.revalidate();
	}

	protected static int fromRGB(Color c)
	{
		return fromRGB(c.getRed(), c.getGreen(), c.getBlue());
	}

	protected static int fromRGB(int r, int g, int b)
	{
		return (r << 16) + (g << 8) + b;
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.ScriptEvent;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

public class CustomWidgetActionButton extends CustomWidgetWithIcon implements InteractibleWidget
{
	static final int BORDER_SIZE = 9;

	private Widget overlay;

	private Widget topLeftBrace;
	private Widget topRightBrace;
	private Widget bottomLeftBrace;
	private Widget bottomRightBrace;

	private Widget leftSide;
	private Widget topSide;
	private Widget rightSide;
	private Widget bottomSide;

	protected final WidgetIntCallback callback;

	public CustomWidgetActionButton(final Widget parent, final String name, int iconSprite, final WidgetIntCallback callback)
	{
		super(parent, name, iconSprite);
		this.callback = callback;
	}

	@Override
	public void create()
	{
		topLeftBrace = createSpriteWidget(BORDER_SIZE, BORDER_SIZE);
		topRightBrace = createSpriteWidget(BORDER_SIZE, BORDER_SIZE);
		bottomLeftBrace = createSpriteWidget(BORDER_SIZE, BORDER_SIZE);
		bottomRightBrace = createSpriteWidget(BORDER_SIZE, BORDER_SIZE);

		leftSide = createSpriteWidget(BORDER_SIZE, height - BORDER_SIZE * 2);
		topSide = createSpriteWidget(width - BORDER_SIZE * 2, BORDER_SIZE);
		rightSide = createSpriteWidget(BORDER_SIZE, height - BORDER_SIZE * 2);
		bottomSide = createSpriteWidget(width - BORDER_SIZE * 2, BORDER_SIZE);

		onLeave();

		icon = createSpriteWidget(iconWidth, iconHeight);
		icon.setSpriteId(iconSpriteID);

		overlay = createSpriteWidget(width, height);
		overlay.setOnOpListener((JavaScriptCallback) this::onButtonClicked);
		overlay.setOnMouseRepeatListener((JavaScriptCallback) e -> onHover());
		overlay.setOnMouseLeaveListener((JavaScriptCallback) e -> onLeave());
		overlay.setHasListener(true);
	}

	public void addOption(int index, String action)
	{
		overlay.setAction(index, action);
	}

	public void setIconSprite(int spriteID)
	{
		icon.setSpriteId(spriteID);
	}

	private void onHover()
	{
		topLeftBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED);
		topRightBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED);
		bottomLeftBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED);
		bottomRightBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED);
		leftSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED);
		topSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED);
		rightSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED);
		bottomSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED);
	}

	private void onLeave()
	{
		topLeftBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT);
		topRightBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT);
		bottomLeftBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT);
		bottomRightBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT);
		leftSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT);
		topSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_TOP);
		rightSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT);
		bottomSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM);
	}

	@Override
	public void layout(int x, int y)
	{
		layoutWidget(overlay, x, y);

		layoutWidget(topLeftBrace, x, y);
		layoutWidget(topRightBrace, x + width - BORDER_SIZE, y);
		layoutWidget(bottomLeftBrace, x, y + height - BORDER_SIZE);
		layoutWidget(bottomRightBrace, x + width - BORDER_SIZE, y + height - BORDER_SIZE);

		layoutWidget(leftSide, x, y + BORDER_SIZE);
		layoutWidget(topSide, x + BORDER_SIZE, y);
		layoutWidget(rightSide, x + width - BORDER_SIZE, y + BORDER_SIZE);
		layoutWidget(bottomSide, x + BORDER_SIZE, y + height - BORDER_SIZE);

		super.layout(x, y);
	}

	@Override
	public void onButtonClicked(ScriptEvent scriptEvent)
	{
		// For whatever reason, the Op for an option is always 1 higher than the given index. MAGIC!
		callback.run(scriptEvent.getOp() - 1);
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.FontID;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;
import java.awt.Color;

public class CustomWidgetActionButtonWithText extends CustomWidgetActionButton
{
	private String initialText;

	private Widget text;

	public CustomWidgetActionButtonWithText(Widget parent, String name, int spriteId, String initialText, WidgetIntCallback callback)
	{
		super(parent, name, spriteId, callback);
		this.initialText = initialText;
	}

	@Override
	public void create()
	{
		super.create();

		text = createTextWidget(initialText);
		text.setOriginalWidth(8);
		text.setOriginalHeight(12);
		text.setFontId(FontID.BARBARIAN);
		text.setTextColor(fromRGB(Color.CYAN));
		text.setXTextAlignment(WidgetTextAlignment.CENTER);
		text.setYTextAlignment(WidgetTextAlignment.BOTTOM);
	}

	public void setText(String newText)
	{
		text.setText(newText);
	}

	@Override
	public void layout(int x, int y)
	{
		layoutWidget(text, x + width - 14, y + BORDER_SIZE);
		super.layout(x, y);
	}

	@Override
	public void onButtonClicked(ScriptEvent scriptEvent)
	{
		// For whatever reason, the Op for an option is always 1 higher than the given index. MAGIC!
		callback.run(scriptEvent.getOp() - 1);
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;

public class CustomWidgetAddPresetButton extends CustomWidgetPresetTabItem
{
	private Widget iconWidget;

	public CustomWidgetAddPresetButton(Widget parent, String name, WidgetIntCallback callback)
	{
		super(parent, name, callback);
	}

	@Override
	public int getId()
	{
		return -1;
	}

	@Override
	public void layout(int x, int y)
	{
		super.layout(x, y);
		layoutWidget(iconWidget, x + 9, y + 10);
		parent.revalidate();
	}

	@Override
	public void scrollBy(int y)
	{
		super.scrollBy(y);
		iconWidget.setOriginalY(this.y - y + 10);
		iconWidget.revalidate();
	}

	@Override
	public void create()
	{
		super.createUnderlay();
		iconWidget = createSpriteWidget(17, 17);
		iconWidget.setSpriteId(CustomSprites.ADD.getSpriteId());
		super.createOverlay();
	}

	@Override
	public void onButtonClicked(ScriptEvent scriptEvent)
	{
		callback.run(-1);
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.FontID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import java.awt.Color;

public class CustomWidgetBlockerBox extends CustomWidget
{
	private static final int TOP_LEFT_CORNER_SIZE = 31;
	private static final int BOTTOM_RIGHT_CORNER_SIZE = 51;
	private static final int OPACITY = 120;

	private Widget leftBar;
	private Widget middleBar;
	private Widget rightBar;
	private Widget cornerBlocker;
	private Widget textStage1;
	private Widget textStage2;
	private Widget arrow;

	public CustomWidgetBlockerBox(Widget parent, String name)
	{
		super(parent, name);
	}

	public void setHidden(boolean state)
	{
		leftBar.setHidden(state);
		middleBar.setHidden(state);
		rightBar.setHidden(state);
		cornerBlocker.setHidden(state);
		textStage1.setHidden(state);
		textStage2.setHidden(state);
		arrow.setHidden(state);
	}

	public void setTutorialState(int state)
	{
		switch (state)
		{
			case 1:
				textStage1.setHidden(false);
				textStage2.setHidden(true);
				arrow.setHidden(true);
				cornerBlocker.setHidden(false);
				return;
			case 2:
				textStage1.setHidden(true);
				textStage2.setHidden(false);
				arrow.setHidden(false);
				cornerBlocker.setHidden(true);
		}
	}

	@Override
	public void layout(int x, int y)
	{
		super.layout(x, y);

		layoutWidget(leftBar, x, y + TOP_LEFT_CORNER_SIZE);
		layoutWidget(middleBar, x + TOP_LEFT_CORNER_SIZE, y);
		layoutWidget(rightBar, x + width - BOTTOM_RIGHT_CORNER_SIZE, y);
		layoutWidget(cornerBlocker, x + width - BOTTOM_RIGHT_CORNER_SIZE, y + height - BOTTOM_RIGHT_CORNER_SIZE);

		layoutWidget(textStage1, x + 10, y);
		layoutWidget(textStage2, x + 10, y);
		layoutWidget(arrow, x + width - 100, y + height - 100);

		parent.revalidate();
	}

	@Override
	public void create()
	{
		JavaScriptCallback empty = ev -> {};

		leftBar = createRectangleWidget(TOP_LEFT_CORNER_SIZE, height - TOP_LEFT_CORNER_SIZE);
		leftBar.setFilled(true);
		leftBar.setOpacity(OPACITY);
		leftBar.setHasListener(true);
		leftBar.setNoClickThrough(true);
		leftBar.setOnOpListener(empty);

		middleBar = createRectangleWidget(width - (TOP_LEFT_CORNER_SIZE + BOTTOM_RIGHT_CORNER_SIZE), height);
		middleBar.setFilled(true);
		middleBar.setOpacity(OPACITY);
		middleBar.setHasListener(true);
		middleBar.setNoClickThrough(true);
		middleBar.setOnOpListener(empty);

		rightBar = createRectangleWidget(BOTTOM_RIGHT_CORNER_SIZE, height - BOTTOM_RIGHT_CORNER_SIZE);
		rightBar.setFilled(true);
		rightBar.setOpacity(OPACITY);
		rightBar.setHasListener(true);
		rightBar.setNoClickThrough(true);
		rightBar.setOnOpListener(empty);

		cornerBlocker = createRectangleWidget(BOTTOM_RIGHT_CORNER_SIZE, BOTTOM_RIGHT_CORNER_SIZE);
		cornerBlocker.setFilled(true);
		cornerBlocker.setOpacity(OPACITY);
		cornerBlocker.setHasListener(true);
		cornerBlocker.setNoClickThrough(true);
		cornerBlocker.setOnOpListener(empty);

		textStage1 = createTextWidget("The plugin needs to know your base outfit. First, remove all of your equipment.");
		textStage1.setXTextAlignment(WidgetTextAlignment.CENTER);
		textStage1.setYTextAlignment(WidgetTextAlignment.CENTER);
		textStage1.setOriginalWidth(width - 20);
		textStage1.setOriginalHeight(height);
		textStage1.setTextColor(fromRGB(Color.YELLOW));
		textStage1.setFontId(FontID.PLAIN_12);

		textStage2 = createTextWidget("Now click the button in the corner to provide a default state.");
		textStage2.setXTextAlignment(WidgetTextAlignment.CENTER);
		textStage2.setYTextAlignment(WidgetTextAlignment.CENTER);
		textStage2.setOriginalWidth(width - 20);
		textStage2.setOriginalHeight(height);
		textStage2.setTextColor(fromRGB(Color.YELLOW));
		textStage2.setFontId(FontID.PLAIN_12);

		// RL does not have the stuff required to rotate sprites exported (if there is such a thing),
		// so a custom needs be used instead
		arrow = createSpriteWidget(48, 48);
		arrow.setSpriteId(CustomSprites.TUTORIAL_ARROW.getSpriteId());
	}

	private Widget createRectangleWidget(int width, int height)
	{
		final Widget w = parent.createChild(-1, WidgetType.RECTANGLE);
		w.setOriginalHeight(height);
		w.setOriginalWidth(width);
		return w;
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.ScriptEvent;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

public class CustomWidgetConfigButton extends CustomWidget implements InteractibleWidget
{
	static final int BORDER_SIZE = 9;
	private static final int LARGE_ICON_SIZE = 32;
	private static final int SMALL_ICON_SIZE = 20;
	private static final int COG_SMALL = 2410;

	private Widget overlay;

	private Widget topLeftBrace;
	private Widget topRightBrace;
	private Widget bottomLeftBrace;
	private Widget bottomRightBrace;

	private Widget leftSide;
	private Widget topSide;
	private Widget rightSide;
	private Widget bottomSide;

	private Widget itemIcon;
	private Widget largeIcon;
	private Widget smallIcon;

	protected final WidgetIntCallback callback;

	public CustomWidgetConfigButton(final Widget parent, final String name, final WidgetIntCallback callback)
	{
		super(parent, name);
		this.callback = callback;
	}

	@Override
	public void create()
	{
		topLeftBrace = createSpriteWidget(BORDER_SIZE, BORDER_SIZE);
		topRightBrace = createSpriteWidget(BORDER_SIZE, BORDER_SIZE);
		bottomLeftBrace = createSpriteWidget(BORDER_SIZE, BORDER_SIZE);
		bottomRightBrace = createSpriteWidget(BORDER_SIZE, BORDER_SIZE);

		leftSide = createSpriteWidget(BORDER_SIZE, height - BORDER_SIZE * 2);
		topSide = createSpriteWidget(width - BORDER_SIZE * 2, BORDER_SIZE);
		rightSide = createSpriteWidget(BORDER_SIZE, height - BORDER_SIZE * 2);
		bottomSide = createSpriteWidget(width - BORDER_SIZE * 2, BORDER_SIZE);

		onLeave();

		largeIcon = createSpriteWidget(LARGE_ICON_SIZE, LARGE_ICON_SIZE);
		largeIcon.setSpriteId(COG_SMALL);

		itemIcon = createSpriteWidget(36, 32);
		itemIcon.setItemQuantity(-1);
		itemIcon.setItemQuantityMode(2);
		itemIcon.setBorderType(1);

		smallIcon = createSpriteWidget(SMALL_ICON_SIZE, SMALL_ICON_SIZE);
		smallIcon.setSpriteId(COG_SMALL);
		smallIcon.setHidden(true);



		overlay = createSpriteWidget(width, height);
		overlay.setOnOpListener((JavaScriptCallback) this::onButtonClicked);
		overlay.setOnMouseRepeatListener((JavaScriptCallback) e -> onHover());
		overlay.setOnMouseLeaveListener((JavaScriptCallback) e -> onLeave());
		overlay.setHasListener(true);
	}

	public void addOption(int index, String action)
	{
		overlay.setAction(index, action);
	}

	public void setItemIcon(int itemID)
	{
		itemIcon.setItemId(itemID);
		largeIcon.setHidden(itemID != -1);
		smallIcon.setHidden(itemID == -1);
		if (itemID == -1)
		{
			addOption(2, "Set Icon");
			addOption(3, null);
		}
		else
		{
			addOption(2, "Change Icon");
			addOption(3, "Remove Icon");
		}
	}

	private void onHover()
	{
		topLeftBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED);
		topRightBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED);
		bottomLeftBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED);
		bottomRightBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED);
		leftSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED);
		topSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED);
		rightSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED);
		bottomSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED);
	}

	private void onLeave()
	{
		topLeftBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT);
		topRightBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT);
		bottomLeftBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT);
		bottomRightBrace.setSpriteId(SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT);
		leftSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT);
		topSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_TOP);
		rightSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT);
		bottomSide.setSpriteId(SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM);
	}

	@Override
	public void layout(int x, int y)
	{
		layoutWidget(overlay, x, y);

		layoutWidget(largeIcon, x + 3, y + 3);
		layoutWidget(smallIcon, x + width - SMALL_ICON_SIZE - 2, y + height - SMALL_ICON_SIZE - 2);
		layoutWidget(itemIcon, x + 4, y + 3);

		layoutWidget(topLeftBrace, x, y);
		layoutWidget(topRightBrace, x + width - BORDER_SIZE, y);
		layoutWidget(bottomLeftBrace, x, y + height - BORDER_SIZE);
		layoutWidget(bottomRightBrace, x + width - BORDER_SIZE, y + height - BORDER_SIZE);

		layoutWidget(leftSide, x, y + BORDER_SIZE);
		layoutWidget(topSide, x + BORDER_SIZE, y);
		layoutWidget(rightSide, x + width - BORDER_SIZE, y + BORDER_SIZE);
		layoutWidget(bottomSide, x + BORDER_SIZE, y + height - BORDER_SIZE);

		super.layout(x, y);
	}

	@Override
	public void onButtonClicked(ScriptEvent scriptEvent)
	{
		// For whatever reason, the Op for an option is always 1 higher than the given index. MAGIC!
		callback.run(scriptEvent.getOp() - 1);
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;

public class CustomWidgetNamePlate extends CustomWidget
{
	private static final int PLATE_CAP_LEFT = 1123;
	private static final int PLATE_CAP_RIGHT = 1125;
	private static final int PLATE_BACKGROUND_TILE = 1124;
	private static final int CAP_WIDTH = 4;
	private static final int HEIGHT = 14;

	private Widget capLeft;
	private Widget capRight;
	private Widget background;
	private Widget nameWidget;

	public CustomWidgetNamePlate(Widget parent, int width)
	{
		super(parent, "");
		this.width = width;
		this.height = HEIGHT;
	}

	@Override
	public void create()
	{
		capLeft = createSpriteWidget(CAP_WIDTH, HEIGHT);
		capLeft.setSpriteId(PLATE_CAP_LEFT);
		capRight = createSpriteWidget(CAP_WIDTH, HEIGHT);
		capRight.setSpriteId(PLATE_CAP_RIGHT);
		background = createSpriteWidget(width - CAP_WIDTH * 2, HEIGHT);
		background.setSpriteId(PLATE_BACKGROUND_TILE);
		background.setSpriteTiling(true);
		nameWidget = createTextWidget("");
		nameWidget.setOriginalWidth(width);
		nameWidget.setOriginalHeight(HEIGHT);
		nameWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		nameWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		nameWidget.setFontId(494);
		nameWidget.setTextColor(0xFFFF00);
	}

	public void setText(String text)
	{
		if (UIManager.FONT_METRICS.stringWidth(text) > width)
		{
			text = UIManager.cutStringToPxWidth(text, width, true);
		}
		nameWidget.setText(text);
	}

	@Override
	public void layout(int x, int y)
	{
		super.layout(x, y);
		layoutWidget(capLeft, x, y);
		layoutWidget(capRight, x + width - CAP_WIDTH, y);
		layoutWidget(background, x + CAP_WIDTH, y);
		layoutWidget(nameWidget, x, y);
		parent.revalidate();
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

public class CustomWidgetPlayerPreview extends CustomWidget implements InteractibleWidget
{
	private Widget clickbox;

	private boolean rotationEnabled = true;

	public CustomWidgetPlayerPreview(Widget parent, String name)
	{
		super(parent, name);
	}

	public void setHidden(boolean state)
	{
		base.setHidden(state);
		clickbox.setHidden(state);
	}

	@Override
	public void layout(int x, int y)
	{
		super.layout(x, y);
		layoutWidget(base, x, y + 60);
		layoutWidget(clickbox, x, y);
		parent.revalidate();
	}

	@Override
	public void create()
	{
		base = createModelWidget(90, 150);
		base.setModelId(1);
		base.setModelType(5);
		base.setModelZoom(760);
		base.setRotationX(150);

		clickbox = createSpriteWidget(90, 150);
		clickbox.setHasListener(true);
		clickbox.setOnOpListener((JavaScriptCallback) this::onButtonClicked);
		clickbox.setAction(1, "Toggle rotation for");
		clickbox.setAction(2, "Reset rotation for");
	}

	public void tickRotation()
	{
		if (rotationEnabled)
		{
			base.setRotationZ((base.getRotationZ() + 2) % 2048);
		}
	}

	@Override
	public void onButtonClicked(ScriptEvent scriptEvent)
	{
		switch (scriptEvent.getOp())
		{
			case 2:
				rotationEnabled = !rotationEnabled;
				break;
			case 3:
				base.setRotationZ(0);
				break;
		}
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import io.hydrox.transmog.TransmogPreset;
import net.runelite.api.FontID;
import net.runelite.api.ScriptEvent;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;
import java.awt.Color;

public class CustomWidgetPresetBox extends CustomWidgetPresetTabItem
{
	private static final int DEFAULT_ICON = SpriteID.TAB_EMOTES;
	private static final int MAX_NAME_WIDTH_PX = 36;

	private Widget defaultIconWidget;
	private Widget iconWidget;
	private Widget nameWidget;

	private final TransmogPreset preset;

	public CustomWidgetPresetBox(TransmogPreset preset, Widget parent, WidgetIntCallback callback)
	{
		super(parent, preset.getDisplayName(), callback);
		this.preset = preset;
	}

	@Override
	public int getId()
	{
		return preset.getId();
	}

	@Override
	public void layout(int x, int y)
	{
		super.layout(x, y);
		layoutWidget(defaultIconWidget, x + 2, y + 2);
		layoutWidget(nameWidget, x + 2, y + 2);
		layoutWidget(iconWidget, x + 2, y + 2);
		parent.revalidate();
	}

	@Override
	public void scrollBy(int y)
	{
		super.scrollBy(y);
		defaultIconWidget.setOriginalY(this.y - y + 2);
		nameWidget.setOriginalY(this.y - y + 2);
		iconWidget.setOriginalY(this.y - y + 2);
		defaultIconWidget.revalidate();
		nameWidget.revalidate();
		iconWidget.revalidate();
	}

	@Override
	public void create()
	{
		super.createUnderlay();

		defaultIconWidget = createSpriteWidget(32, 32);
		defaultIconWidget.setSpriteId(DEFAULT_ICON);

		iconWidget = createSpriteWidget(36, 32);
		iconWidget.setItemQuantity(-1);
		iconWidget.setItemQuantityMode(2);
		iconWidget.setBorderType(1);

		if (preset.getIcon() >= -1)
		{
			iconWidget.setItemId(preset.getIcon());
			defaultIconWidget.setHidden(true);
		}
		else
		{
			iconWidget.setHidden(true);
		}

		nameWidget = createTextWidget(UIManager.cutStringToPxWidth(preset.getDisplayName(), MAX_NAME_WIDTH_PX));
		nameWidget.setOriginalWidth(32);
		nameWidget.setOriginalHeight(32);
		nameWidget.setFontId(FontID.PLAIN_11);
		nameWidget.setTextColor(fromRGB(Color.YELLOW));
		nameWidget.setXTextAlignment(WidgetTextAlignment.RIGHT);
		nameWidget.setYTextAlignment(WidgetTextAlignment.BOTTOM);

		super.createOverlay();
	}

	@Override
	public void onButtonClicked(ScriptEvent scriptEvent)
	{
		callback.run(preset.getId());
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

public abstract class CustomWidgetPresetTabItem extends CustomWidget implements InteractibleWidget
{
	private static final int BACKGROUND_ID = 170;
	private static final int BACKGROUND_ID_SELECTED = 179;

	static final int SIZE = 32;

	private Widget overlayWidget;

	protected final WidgetIntCallback callback;

	public CustomWidgetPresetTabItem(Widget parent, String name, WidgetIntCallback callback)
	{
		super(parent, name);
		this.callback = callback;
	}

	public abstract int getId();

	@Override
	public void layout(int x, int y)
	{
		super.layout(x, y);
		layoutWidget(base, x, y);
		layoutWidget(overlayWidget, x, y);
		parent.revalidate();
	}

	public void scrollBy(int y)
	{
		base.setOriginalY(this.y - y);
		overlayWidget.setOriginalY(this.y - y);
		base.revalidate();
		overlayWidget.revalidate();
	}

	protected void createUnderlay()
	{
		base = createSpriteWidget(36, 36);
		base.setSpriteId(BACKGROUND_ID);
	}

	protected void createOverlay()
	{
		overlayWidget = createSpriteWidget(36, 36);
		overlayWidget.setOnOpListener((JavaScriptCallback) this::onButtonClicked);
		overlayWidget.setHasListener(true);
	}

	public void addOption(int index, String action)
	{
		overlayWidget.setAction(index, action);
	}

	public void setSelected(boolean state)
	{
		base.setSpriteId(state ? BACKGROUND_ID_SELECTED : BACKGROUND_ID);
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

public class CustomWidgetToggleButton extends CustomWidgetWithIcon implements InteractibleWidget
{
	private int selectedBackgroundSprite;
	private int backgroundSpriteID;

	private String verbWhenOff;
	private String verbWhenOn;

	private boolean selected;

	private final WidgetBooleanCallback callback;

	private Widget clickbox;

	public CustomWidgetToggleButton(final Widget parent, final String name, int backgroundSprite, int selectedBackgroundSprite, int iconSprite, final WidgetBooleanCallback callback)
	{
		super(parent, name, iconSprite);
		this.backgroundSpriteID = backgroundSprite;
		this.selectedBackgroundSprite = selectedBackgroundSprite;
		this.callback = callback;
	}

	public void setVerbs(String off, String on)
	{
		verbWhenOff = off;
		verbWhenOn = on;
	}

	public void toggle()
	{
		selected = !selected;
		base.setSpriteId(selected ? selectedBackgroundSprite : backgroundSpriteID);
		clickbox.setAction(1, selected ? verbWhenOn : verbWhenOff);
	}

	@Override
	public void layout(int x, int y)
	{
		layoutWidget(base, x, y);
		layoutWidget(clickbox, x, y);

		super.layout(x, y);
	}

	@Override
	public void create()
	{
		base = createSpriteWidget(width, height);
		base.setSpriteId(backgroundSpriteID);

		icon = createSpriteWidget(iconWidth, iconHeight);
		icon.setSpriteId(iconSpriteID);

		clickbox = createSpriteWidget(width, height);
		clickbox.setOnOpListener((JavaScriptCallback) this::onButtonClicked);
		clickbox.setOnMouseRepeatListener((JavaScriptCallback) e -> icon.setOpacity(120));
		clickbox.setOnMouseLeaveListener((JavaScriptCallback) e -> icon.setOpacity(0));
		clickbox.setHasListener(true);
		clickbox.setAction(1, verbWhenOff);
	}

	@Override
	public void onButtonClicked(ScriptEvent scriptEvent)
	{
		toggle();
		callback.run(selected);
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import io.hydrox.transmog.MappingMapping;
import io.hydrox.transmog.TransmogSlot;
import io.hydrox.transmog.TransmogSlot.SlotType;
import static io.hydrox.transmog.ui.MenuOps.CLEAR;
import static io.hydrox.transmog.ui.MenuOps.HIDE;
import static io.hydrox.transmog.ui.MenuOps.SET_ITEM;
import net.runelite.api.ScriptEvent;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

public class CustomWidgetTransmogBox extends CustomWidget implements InteractibleWidget
{
	private static final int BACKGROUND_ID = 170;
	private static final String SET_ITEM_STRING = "Set item for";
	private static final String CLEAR_STRING = "Clear";
	private static final String HIDE_STRING = "Hide";
	// The Special slots are dependant on the equipped armour, so some different terminology is needed.
	private static final String SPECIAL_CLEAR_STRING = "Follow armour for";
	private static final String SPECIAL_HIDE_STRING = "Use base";

	private Widget slotWidget;
	private Widget contentsWidget;
	private Widget slotDefaultWidget;
	private Widget overlayWidget;

	private SlotType type;

	private TransmogSlot slot;

	private MappingMapping mapping;

	private final WidgetSlotCallback callback;

	public CustomWidgetTransmogBox(SlotType type, Widget parent, TransmogSlot slot, WidgetSlotCallback callback)
	{
		super(parent, slot.getName());
		this.type = type;
		this.slot = slot;
		this.callback = callback;
	}

	public void setDefault()
	{
		slotDefaultWidget.setHidden(false);
		slotWidget.setHidden(false);
		contentsWidget.setHidden(true);
		overlayWidget.setAction(SET_ITEM, SET_ITEM_STRING);
		overlayWidget.setAction(HIDE, null);

		if (slot.getSlotType() == SlotType.SPECIAL)
		{
			overlayWidget.setAction(CLEAR, SPECIAL_CLEAR_STRING);
		}
		else
		{
			overlayWidget.setAction(CLEAR, CLEAR_STRING);
		}
	}

	public void setEmpty()
	{
		slotDefaultWidget.setHidden(true);
		slotWidget.setHidden(false);
		contentsWidget.setHidden(true);
		overlayWidget.setAction(SET_ITEM, SET_ITEM_STRING);
		overlayWidget.setAction(CLEAR, null);

		if (slot.getSlotType() == SlotType.SPECIAL)
		{
			overlayWidget.setAction(HIDE, SPECIAL_HIDE_STRING);
		}
		else
		{
			overlayWidget.setAction(HIDE, HIDE_STRING);
		}
	}

	public void setContent(int id, String name)
	{
		slotDefaultWidget.setHidden(true);
		slotWidget.setHidden(true);
		contentsWidget.setHidden(false);
		if (type == SlotType.ITEM)
		{
			contentsWidget.setItemId(id);
		}
		else
		{
			contentsWidget.setModelId(id);
		}

		overlayWidget.setAction(SET_ITEM, "Replace " + UIManager.ORANGE_COLOUR_WIDGET_NAME + name + "</col> for");

		if (slot.getSlotType() == SlotType.SPECIAL)
		{
			overlayWidget.setAction(CLEAR, SPECIAL_CLEAR_STRING);
			overlayWidget.setAction(HIDE, SPECIAL_HIDE_STRING);
		}
		else
		{
			overlayWidget.setAction(CLEAR, CLEAR_STRING);
			overlayWidget.setAction(HIDE, HIDE_STRING);
		}
	}

	public void set(Integer contents, String name)
	{
		if (contents == null)
		{
			setEmpty();
		}
		else if (contents == -1)
		{
			setDefault();
		}
		else
		{
			this.setContent(contents, name);
		}
	}

	@Override
	public void layout(int x, int y)
	{
		super.layout(x, y);

		final int yOffset = mapping != null ? mapping.getYOffset() : 0;
		layoutWidget(base, x, y);
		layoutWidget(slotWidget, x + 2, y + 2);
		layoutWidget(slotDefaultWidget, x + 2, y + 2);
		layoutWidget(contentsWidget, x + 2, y + 2 + yOffset);
		layoutWidget(overlayWidget, x, y);
		parent.revalidate();
	}

	@Override
	public void create()
	{
		base = createSpriteWidget(36, 36);
		base.setSpriteId(BACKGROUND_ID);

		slotWidget = createSpriteWidget(32, 32);
		slotWidget.setSpriteId(slot.getSpriteID());

		slotDefaultWidget = createSpriteWidget(32, 32);
		slotDefaultWidget.setSpriteId(SpriteID.OPTIONS_DISABLED_OPTION_OVERLAY);

		if (type == SlotType.ITEM)
		{
			contentsWidget = createSpriteWidget(36, 32);
			contentsWidget.setItemQuantity(-1);
			contentsWidget.setItemQuantityMode(2);
			contentsWidget.setBorderType(1);
		}
		else
		{
			mapping = MappingMapping.fromSlot(slot);
			contentsWidget = createModelWidget(36, 32);
			contentsWidget.setModelType(1);
			contentsWidget.setModelZoom(mapping.getModelZoom());
			contentsWidget.setRotationZ(150);
		}
		contentsWidget.setHidden(true);

		overlayWidget = createSpriteWidget(36, 36);
		overlayWidget.setOnOpListener((JavaScriptCallback) this::onButtonClicked);
		overlayWidget.setHasListener(true);
	}

	@Override
	public void onButtonClicked(ScriptEvent scriptEvent)
	{
		callback.run(scriptEvent.getOp() - 1, slot);
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import net.runelite.api.widgets.Widget;

public abstract class CustomWidgetWithIcon extends CustomWidget
{
	protected int iconWidth;
	protected int iconHeight;

	protected int iconSpriteID;
	protected int iconPaddingX;
	protected int iconPaddingY;

	protected Widget icon;

	public CustomWidgetWithIcon(final Widget parent, final String name, int iconSpriteID)
	{
		super(parent, name);
		this.iconSpriteID = iconSpriteID;
	}

	public void setIconSize(int width, int height)
	{
		this.iconWidth = width;
		this.iconHeight = height;
		iconPaddingX = (this.width - iconWidth) / 2;
		iconPaddingY = (this.height - iconHeight) / 2;
	}

	@Override
	public void layout(int x, int y)
	{
		super.layout(x, y);
		layoutWidget(icon, x + iconPaddingX, y + iconPaddingY);

		parent.revalidate();
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import io.hydrox.transmog.config.TransmogrificationConfigManager;
import io.hydrox.transmog.TransmogrificationManager;
import io.hydrox.transmog.TransmogrificationPlugin;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

@Singleton
public class EquipmentOverlay extends CustomTab
{
	private CustomWidgetToggleButton stateToggle;
	private Widget pvpBlocker;

	private final TransmogrificationConfigManager config;
	private final TransmogrificationManager manager;
	private final UIManager uiManager;

	@Inject
	EquipmentOverlay(TransmogrificationPlugin plugin, TransmogrificationConfigManager config, TransmogrificationManager manager)
	{
		this.config = config;
		this.manager = manager;
		this.uiManager = plugin.getUIManager();
	}

	@Override
	void create()
	{
		create(false);
	}

	void create(boolean uiActive)
	{
		final Widget parent = uiManager.getContainer();

		CustomWidgetToggleButton showUI = new CustomWidgetToggleButton(
			parent,
			"Transmogrification",
			SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL,
			SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL_SELECTED,
			1654, // Unmapped
			selected ->
			{
				if (selected)
				{
					uiManager.hideVanillaUI();
					uiManager.createTab(uiManager.getMainTab());
				}
				else
				{
					uiManager.removeCustomUI();
					create(false);
					manager.savePresets();
				}
			});
		showUI.setVerbs("Edit", "Exit");
		showUI.setSize(25, 25);
		showUI.setIconSize(32, 32);
		showUI.create();
		if (uiActive)
		{
			showUI.toggle();
		}

		showUI.layout(3, 3);

		stateToggle = new CustomWidgetToggleButton(
			parent,
			"Transmogrification",
			SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL,
			SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL_SELECTED,
			CustomSprites.TRANSMOG_LOGO.getSpriteId(),
			state ->
			{
				if ((!manager.isDefaultStateSet() && state) || manager.isInPvpSituation())
				{
					stateToggle.toggle();
					manager.hintDefaultState();
					return;
				}
				config.transmogActive(state);
				manager.updateTransmog();
			}
		);
		stateToggle.setVerbs("Enable", "Disable");
		stateToggle.setSize(25, 25);
		stateToggle.setIconSize(16, 13);
		stateToggle.create();
		if (config.transmogActive() && manager.isDefaultStateSet())
		{
			stateToggle.toggle();
		}
		stateToggle.layout(30, 3);

		pvpBlocker = parent.createChild(-1, WidgetType.GRAPHIC);
		pvpBlocker.setSpriteId(SpriteID.PLAYER_KILLING_DISABLED_OVERLAY); // Block icon
		pvpBlocker.setOriginalWidth(25);
		pvpBlocker.setOriginalHeight(25);
		pvpBlocker.setHasListener(true);
		pvpBlocker.setNoClickThrough(true);
		pvpBlocker.setOnOpListener((JavaScriptCallback) e -> {});
		pvpBlocker.setOriginalX(30);
		pvpBlocker.setOriginalY(3);
		pvpBlocker.setHidden(!manager.isInPvpSituation());
		pvpBlocker.setAction(0, "Transmog is disabled in PvP situations");
	}

	@Override
	void onPvpChanged(boolean newValue)
	{
		if (pvpBlocker != null)
		{
			pvpBlocker.setHidden(!newValue);
		}
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import io.hydrox.transmog.TransmogSlot;
import net.runelite.api.ScriptEvent;

public interface InteractibleWidget
{
	@FunctionalInterface
	interface WidgetBooleanCallback
	{
		void run(boolean state);
	}

	@FunctionalInterface
	interface WidgetIntCallback
	{
		void run(int state);
	}

	@FunctionalInterface
	interface WidgetSlotCallback
	{
		void run(int op, TransmogSlot slot);
	}

	void onButtonClicked(ScriptEvent scriptEvent);
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import io.hydrox.transmog.FacialHairMapping;
import io.hydrox.transmog.HairMapping;
import io.hydrox.transmog.Mapping;
import io.hydrox.transmog.MappingMapping;
import io.hydrox.transmog.SleeveMapping;
import io.hydrox.transmog.TransmogPartyManager;
import io.hydrox.transmog.TransmogPreset;
import io.hydrox.transmog.TransmogSlot;
import io.hydrox.transmog.TransmogrificationManager;
import io.hydrox.transmog.TransmogrificationPlugin;
import io.hydrox.transmog.config.TransmogrificationConfigManager;
import static io.hydrox.transmog.ui.MenuOps.CLEAR;
import static io.hydrox.transmog.ui.MenuOps.HIDE;
import static io.hydrox.transmog.ui.MenuOps.SET_ITEM;
import lombok.Getter;
import net.runelite.api.FontID;
import net.runelite.api.Point;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxItemSearch;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.tuple.Pair;
import java.awt.Color;
import java.awt.Rectangle;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Singleton
public class MainTab extends CustomTab
{
	private static final Point BASE_POSITION = new Point(148, 4);
	private static final ImmutableMap<TransmogSlot, Point> SLOT_POSITIONS = ImmutableMap.<TransmogSlot, Point>builder()
		.put(TransmogSlot.JAW, new Point(-76, 0))
		.put(TransmogSlot.HAIR, new Point(-38, 0))
		.put(TransmogSlot.HEAD, new Point(0, 0))
		.put(TransmogSlot.CAPE, new Point(-38, 38))
		.put(TransmogSlot.NECK, new Point(0, 38))
		.put(TransmogSlot.SLEEVES, new Point(-56, 76))
		.put(TransmogSlot.TORSO, new Point(0, 76))
		.put(TransmogSlot.LEGS, new Point(0, 115))
		.put(TransmogSlot.HANDS, new Point(-56, 154))
		.put(TransmogSlot.BOOTS, new Point(0, 154))
		.build();

	private static final List<Pair<Rectangle, Integer>> INTER_SLOT_BRACERS = ImmutableList.<Pair<Rectangle, Integer>>builder()
		.add(Pair.of(new Rectangle(0, 36, 36, 122), SpriteID.IRON_RIVETS_VERTICAL))
		.add(Pair.of(new Rectangle(-56, 114, 36, 44), SpriteID.IRON_RIVETS_VERTICAL))
		.add(Pair.of(new Rectangle(-46, 0, 46, 36), SpriteID.IRON_RIVETS_HORIZONTAL))
		.add(Pair.of(new Rectangle(-5, 39, 5, 36), SpriteID.IRON_RIVETS_HORIZONTAL))
		.add(Pair.of(new Rectangle(-20, 78, 20, 36), SpriteID.IRON_RIVETS_HORIZONTAL))
		.build();


	private final ChatboxPanelManager chatboxPanelManager;
	private final ChatboxItemSearch allItemSearch;
	private final CustomItemSearch slotItemSearch;
	private final CustomSpriteSearch spriteSearch;
	private final ItemManager itemManager;
	private final TransmogPartyManager partyManager;
	private final TransmogrificationManager manager;
	private final UIManager uiManager;
	private final TransmogrificationConfigManager config;

	@Getter
	private final Map<TransmogSlot, CustomWidgetTransmogBox> uiSlots = new HashMap<>();

	private Widget helpText;
	private CustomWidgetPlayerPreview playerPreview;
	private CustomWidgetActionButton saveDefaultStateButton;
	private CustomWidgetBlockerBox blockerBox;
	private CustomWidgetConfigButton presetExtraDataButton;
	private CustomWidgetNamePlate nameplate;

	@Inject
	MainTab(ChatboxPanelManager chatboxPanelManager, ChatboxItemSearch allItemSearch, CustomItemSearch slotItemSearch,
			CustomSpriteSearch spriteSearch, ItemManager itemManager, TransmogrificationPlugin plugin,
			TransmogrificationManager manager, TransmogPartyManager partyManager, TransmogrificationConfigManager config)
	{
		this.chatboxPanelManager = chatboxPanelManager;
		this.allItemSearch = allItemSearch;
		this.slotItemSearch = slotItemSearch;
		this.spriteSearch = spriteSearch;
		this.itemManager = itemManager;
		this.partyManager = partyManager;
		this.manager = manager;
		this.uiManager = plugin.getUIManager();
		this.config = config;
	}

	@Override
	void shutDown()
	{
		uiSlots.clear();
	}

	@Override
	void destroy()
	{
		playerPreview = null;
	}

	@Override
	void create()
	{
		final Widget parent = uiManager.getContainer();
		uiManager.getEquipmentOverlay().create(true);

		helpText = parent.createChild(-1, WidgetType.TEXT);
		helpText.setTextColor(CustomWidget.fromRGB(Color.YELLOW));
		helpText.setTextShadowed(true);
		helpText.setFontId(FontID.PLAIN_11);
		helpText.setOriginalWidth(90);
		helpText.setOriginalHeight(150);
		helpText.setOriginalX(3);
		helpText.setOriginalY(60);
		helpText.setText("Choose the items you want to see yourself wearing. If you're having glitchy collision, remove your hair/sleeves/beard. Removing hair requires toggling the transmog. Please report broken items to the support link.");
		helpText.setHidden(true);
		helpText.revalidate();

		playerPreview = new CustomWidgetPlayerPreview(parent, "Preview");
		playerPreview.create();
		playerPreview.layout(3, 60);


		CustomWidgetToggleButton guideButton = new CustomWidgetToggleButton(
			parent,
			"Help",
			SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL,
			SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL_SELECTED,
			CustomSprites.QUESTION_MARK.getSpriteId(),
			selected ->
			{
				helpText.setHidden(!selected);
				playerPreview.setHidden(selected);
			});
		guideButton.setVerbs("Show", "Hide");
		guideButton.setSize(25, 25);
		guideButton.setIconSize(8, 17);
		guideButton.create();

		guideButton.layout(3, 30);

		CustomWidgetToggleButton shareButton = new CustomWidgetToggleButton(
			parent,
			"Share to Party",
			SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL,
			SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL_SELECTED,
			CustomSprites.PARTY.getSpriteId(),
			partyManager::setShareWithParty);
		shareButton.setVerbs("Enable", "Disable");
		shareButton.setSize(25, 25);
		shareButton.setIconSize(19, 19);
		shareButton.create();
		if (config.transmitToParty())
		{
			shareButton.toggle();
		}

		shareButton.layout(30, 30);

		// Create bottom buttons

		CustomWidgetActionButton selectPresetButton = new CustomWidgetActionButton(
			parent,
			"",
			SpriteID.TAB_EMOTES,
			op ->
			{
				uiManager.removeCustomUI();
				uiManager.hideVanillaUI();
				uiManager.createTab(uiManager.getPresetTab());
			}
		);
		selectPresetButton.setSize(40, 40);
		selectPresetButton.setIconSize(36, 36);
		selectPresetButton.create();
		selectPresetButton.addOption(1, "Choose " + UIManager.ORANGE_COLOUR_WIDGET_NAME + "Preset");
		selectPresetButton.layout(7, 213);

		presetExtraDataButton = new CustomWidgetConfigButton(
			parent,
			UIManager.FORCE_RIGHT_CLICK_WIDGET_NAME,
			op ->
			{
				switch (op)
				{
					case 1:
						chatboxPanelManager.openTextInput("Set name for this preset")
							.value(Strings.nullToEmpty(manager.getCurrentPreset().getName()))
							.onDone((content) ->
							{
								if (content == null)
								{
									return;
								}

								content = Text.removeTags(content).trim();
								manager.getCurrentPreset().setName(content);
								manager.saveCurrentPreset();
								nameplate.setText(manager.getCurrentPreset().getDisplayName());

							}).build();
						break;
					case 2:
						allItemSearch
							.tooltipText("Select")
							.onItemSelected((itemId) ->
							{
								manager.getCurrentPreset().setIcon(itemId);
								manager.saveCurrentPreset();
								presetExtraDataButton.setItemIcon(itemId);
							})
							.prompt("Select icon for this preset")
							.build();
						break;
					case 3:
						manager.getCurrentPreset().setIcon(-1);
						manager.saveCurrentPreset();
						presetExtraDataButton.setItemIcon(-1);
						break;
				}
			}
		);
		presetExtraDataButton.setSize(40, 40);
		presetExtraDataButton.create();
		presetExtraDataButton.addOption(0, UIManager.ORANGE_COLOUR_WIDGET_NAME + "Preset Config:");
		presetExtraDataButton.addOption(1, "Set Name");
		presetExtraDataButton.setItemIcon(manager.getCurrentPreset().getIcon());
		presetExtraDataButton.layout(97, 213);

		saveDefaultStateButton = new CustomWidgetActionButton(
			parent,
			"Default State",
			SpriteID.PRAYER_THICK_SKIN,
			op ->
			{
				if (manager.updateDefault(op))
				{
					saveDefaultStateButton.setIconSprite(115);
					blockerBox.setHidden(true);
				}
			}
		);
		saveDefaultStateButton.setSize(40, 40);
		saveDefaultStateButton.setIconSize(30, 30);
		saveDefaultStateButton.create();
		saveDefaultStateButton.setIconSprite(manager.isDefaultStateSet() ? SpriteID.PRAYER_THICK_SKIN : SpriteID.PRAYER_ROCK_SKIN);
		saveDefaultStateButton.addOption(1, "Save as");
		saveDefaultStateButton.addOption(2, "Force save as");
		saveDefaultStateButton.layout(142, 213);

		// Create inter-slot bracers
		for (Pair<Rectangle, Integer> bracer : INTER_SLOT_BRACERS)
		{
			final Rectangle posData = bracer.getLeft();
			Widget bracerWidget = parent.createChild(-1, WidgetType.GRAPHIC);
			bracerWidget.setOriginalX(BASE_POSITION.getX() + posData.x);
			bracerWidget.setOriginalY(BASE_POSITION.getY() + posData.y);
			bracerWidget.setOriginalWidth(posData.width);
			bracerWidget.setOriginalHeight(posData.height);
			bracerWidget.setSpriteId(bracer.getRight());
			bracerWidget.setSpriteTiling(true);
			bracerWidget.revalidate();
		}

		// Create Slots
		TransmogPreset preset = manager.getCurrentPreset();
		for (TransmogSlot slot : TransmogSlot.values())
		{
			final CustomWidgetTransmogBox box;
			if (slot.getSlotType() == TransmogSlot.SlotType.ITEM)
			{
				box = new CustomWidgetTransmogBox(TransmogSlot.SlotType.ITEM, parent, slot, this::onTransmogUISlotClicked);
				box.create();
				Integer item = preset.getIdForSlot(slot, false);
				if (item == null)
				{
					box.setEmpty();
				}
				else if (item == -1)
				{
					box.setDefault();
				}
				else
				{
					box.set(item, itemManager.getItemComposition(item).getName());
				}
			}
			else
			{
				box = new CustomWidgetTransmogBox(TransmogSlot.SlotType.SPECIAL, parent, slot, this::onTransmogUISlotClicked);
				box.create();
				Integer contents = preset.getIdForSlot(slot, false);
				if (contents == null)
				{
					box.setEmpty();
				}
				else if (contents == -1)
				{
					box.setDefault();
				}
				else
				{
					final Mapping mapping = MappingMapping.fromSlot(slot).getFromModel().apply(contents);
					box.set(mapping.modelId(), mapping.prettyName());
				}
			}
			final Point pos = SLOT_POSITIONS.get(slot);
			box.layout(BASE_POSITION.getX() + pos.getX(), BASE_POSITION.getY() + pos.getY());
			uiSlots.put(slot, box);
		}

		// Create blocker
		blockerBox = new CustomWidgetBlockerBox(parent, "");
		blockerBox.setSize(parent.getWidth(), parent.getHeight());
		blockerBox.create();
		blockerBox.layout(0, 0);
		if (manager.isDefaultStateSet())
		{
			blockerBox.setHidden(true);
		}

		nameplate = new CustomWidgetNamePlate(parent, 92);
		nameplate.create();
		nameplate.setText(manager.getCurrentPreset().getDisplayName());
		nameplate.layout(92, 196);

		updateTutorial(manager.isEmptyEquipment());

		parent.revalidate();

		manager.updateTransmog();
	}

	@Override
	void onClientTick()
	{
		if (playerPreview != null)
		{
			playerPreview.tickRotation();
		}
	}

	@Override
	public void updateTutorial(boolean equipmentState)
	{
		if (!manager.isDefaultStateSet() && blockerBox != null)
		{
			blockerBox.setTutorialState(equipmentState ? 2 : 1);
		}
	}

	@Override
	public void loadPreset(TransmogPreset preset)
	{
		for (TransmogSlot slot : TransmogSlot.values())
		{
			uiSlots.get(slot).set(preset.getIdForSlot(slot, false), preset.getName(slot));
		}
	}

	private void onTransmogUISlotClicked(int op, TransmogSlot slot)
	{
		CustomWidgetTransmogBox widget = uiSlots.get(slot);
		TransmogPreset preset = manager.getCurrentPreset();
		switch (op)
		{
			case SET_ITEM:
				if (uiManager.isSearching())
				{
					uiManager.closeSearch();
				}
				uiManager.setSearching(true);
				if (slot.getSlotType() == TransmogSlot.SlotType.SPECIAL)
				{
					CustomSpriteSearch s = spriteSearch;
					s.setTooltipText("Set as " + slot.getName());
					s.setPrompt("Choose for " + slot.getName() + " slot");
					s.setSlot(slot);
					s.setOnItemSelected((m) ->
					{
						widget.setContent(m.modelId(), m.prettyName());
						uiManager.setSearching(false);
						preset.setSlot(slot, m.kitId(), m.prettyName());
						manager.updateTransmog();
						manager.saveCurrentPreset();
					});

					switch (slot)
					{
						case HAIR:
							s.setSource(HairMapping.values());
							break;
						case JAW:
							s.setSource(FacialHairMapping.values());
							break;
						case SLEEVES:
							s.setSource(SleeveMapping.values());
							break;
					}

					s.build();
				}
				else
				{
					CustomItemSearch i = slotItemSearch;
					i.setTooltipText("Set as " + slot.getName());
					i.setPrompt("Choose for " + slot.getName() + " slot");
					i.setSlot(slot);
					i.setOnItemSelected((id, name) ->
					{
						widget.setContent(id, name);
						uiManager.setSearching(false);
						preset.setSlot(slot, id, name);
						manager.updateTransmog();
						manager.saveCurrentPreset();
					});
					i.build();
				}
				break;
			case CLEAR:
				chatboxPanelManager.close();
				widget.setEmpty();
				preset.clearSlot(slot);
				manager.updateTransmog();
				manager.saveCurrentPreset();
				break;
			case HIDE:
				chatboxPanelManager.close();
				widget.setDefault();
				preset.setDefaultSlot(slot);
				manager.updateTransmog();
				manager.saveCurrentPreset();
				break;
		}
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

public class MenuOps
{
	public static final int SET_ITEM = 1;
	public static final int CLEAR = 3;
	public static final int HIDE = 5;
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.Singleton;
import io.hydrox.transmog.TransmogPreset;
import io.hydrox.transmog.TransmogrificationManager;
import io.hydrox.transmog.config.TransmogrificationConfigManager;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import java.awt.Rectangle;
import java.awt.event.MouseWheelEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;

@Singleton
public class PresetTab extends CustomTab
{
	private static final int SCROLLBAR_HEIGHT = 203;
	private static final int SCROLLBAR_WIDTH = 16;
	private static final int SCROLLBAR_BUTTON_HEIGHT = 16;
	private static final int SCROLLBAR_PADDING = 1;
	private static final int SCROLLBAR_TRACK_HEIGHT = SCROLLBAR_HEIGHT - (SCROLLBAR_BUTTON_HEIGHT * 2);
	private static final int SCROLLBAR_THUMB_CAP_HEIGHT = 5;
	private static final int PRESETS_PER_LINE = 4;
	private static final int PRESET_PADDING = 11;
	private static final int PRESET_EDGE_PADDING = 4;

	private static final int BACK_BUTTON_SPRITE = 1122;


	private final Client client;
	private final ClientThread clientThread;
	private final TransmogrificationConfigManager config;
	private final TransmogrificationManager manager;
	private final Provider<UIManager> uiManager;

	private Widget[] presetScrollbars;
	private Rectangle boxBounds;
	private int scrollPos = 0;
	private int maxScrollPos = 0;

	private List<CustomWidgetPresetTabItem> presets = new ArrayList<>();

	@Inject
	PresetTab(Client client, ClientThread clientThread, TransmogrificationConfigManager config,
			  TransmogrificationManager manager, Provider<UIManager> uiManager)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.config = config;
		this.manager = manager;
		this.uiManager = uiManager;
	}

	private UIManager getUIManager()
	{
		return uiManager.get();
	}

	@Override
	void create()
	{
		final Widget parent = getUIManager().getContainer();
		// Cache the bounds for scrolling code, which runs off of client thread
		boxBounds = parent.getBounds();

		presets.clear();
		AtomicInteger index = new AtomicInteger();
		manager.getPresets().stream()
			.filter(Objects::nonNull)
			.forEach(preset ->
			{
				int i = index.getAndIncrement();
				presets.add(createPresetBox(preset, parent, i));
			}
		);

		// Create add button
		CustomWidgetPresetTabItem w = new CustomWidgetAddPresetButton(parent, "Preset", this::addNewPreset);
		w.create();
		w.layout(
			PRESET_EDGE_PADDING + (index.get() % PRESETS_PER_LINE) * (CustomWidgetPresetBox.SIZE + PRESET_PADDING),
			PRESET_EDGE_PADDING + (index.get() / PRESETS_PER_LINE) * (CustomWidgetPresetBox.SIZE + PRESET_PADDING)
		);
		w.addOption(1, "Create new");
		presets.add(w);

		// MAGIC!
		maxScrollPos = Math.max(
			((int)Math.ceil(presets.size() / (double) PRESETS_PER_LINE) - 5)
				* (CustomWidgetPresetBox.SIZE + PRESET_PADDING)
				+ (5 * (CustomWidgetPresetBox.SIZE + PRESET_PADDING) - SCROLLBAR_HEIGHT)
				+ 1
			, 0);

		// Scrollbar
		Widget scrollUp = parent.createChild(-1, WidgetType.GRAPHIC);
		scrollUp.setOriginalWidth(SCROLLBAR_WIDTH);
		scrollUp.setOriginalHeight(SCROLLBAR_BUTTON_HEIGHT);
		scrollUp.setSpriteId(SpriteID.SCROLLBAR_ARROW_UP);
		scrollUp.setOriginalX(parent.getOriginalWidth() - SCROLLBAR_WIDTH - SCROLLBAR_PADDING);
		scrollUp.setOriginalY(0);
		scrollUp.revalidate();

		Widget scrollDown = parent.createChild(-1, WidgetType.GRAPHIC);
		scrollDown.setOriginalWidth(SCROLLBAR_WIDTH);
		scrollDown.setOriginalHeight(SCROLLBAR_BUTTON_HEIGHT);
		scrollDown.setSpriteId(SpriteID.SCROLLBAR_ARROW_DOWN);
		scrollDown.setOriginalX(parent.getOriginalWidth() - SCROLLBAR_WIDTH - SCROLLBAR_PADDING);
		scrollDown.setOriginalY(SCROLLBAR_HEIGHT - SCROLLBAR_BUTTON_HEIGHT - SCROLLBAR_PADDING);
		scrollDown.revalidate();

		Widget scrollBg = parent.createChild(-1, WidgetType.GRAPHIC);
		scrollBg.setOriginalWidth(SCROLLBAR_WIDTH);
		scrollBg.setOriginalHeight(SCROLLBAR_TRACK_HEIGHT);
		scrollBg.setSpriteId(SpriteID.SCROLLBAR_THUMB_MIDDLE_DARK);
		scrollBg.setOriginalX(parent.getOriginalWidth() - SCROLLBAR_WIDTH - SCROLLBAR_PADDING);
		scrollBg.setOriginalY(SCROLLBAR_BUTTON_HEIGHT);
		scrollBg.setHasListener(true);
		scrollBg.setOnClickListener((JavaScriptCallback) ev -> scrollTo(client.getMouseCanvasPosition().getY() - parent.getBounds().y));
		scrollBg.revalidate();

		Widget scrollBarTop = parent.createChild(-1, WidgetType.GRAPHIC);
		scrollBarTop.setOriginalWidth(SCROLLBAR_WIDTH);
		scrollBarTop.setOriginalHeight(SCROLLBAR_THUMB_CAP_HEIGHT);
		scrollBarTop.setSpriteId(SpriteID.SCROLLBAR_THUMB_TOP);
		scrollBarTop.setOriginalX(parent.getOriginalWidth() - SCROLLBAR_WIDTH - SCROLLBAR_PADDING);
		scrollBarTop.setOriginalY(SCROLLBAR_BUTTON_HEIGHT);
		scrollBarTop.setNoClickThrough(false);
		scrollBarTop.setHasListener(true);
		scrollBarTop.revalidate();

		Widget scrollBarBottom = parent.createChild(-1, WidgetType.GRAPHIC);
		scrollBarBottom.setOriginalWidth(SCROLLBAR_WIDTH);
		scrollBarBottom.setOriginalHeight(SCROLLBAR_THUMB_CAP_HEIGHT);
		scrollBarBottom.setSpriteId(SpriteID.SCROLLBAR_THUMB_BOTTOM);
		scrollBarBottom.setOriginalX(parent.getOriginalWidth() - SCROLLBAR_WIDTH - SCROLLBAR_PADDING);
		scrollBarBottom.setOriginalY(SCROLLBAR_BUTTON_HEIGHT);
		scrollBarBottom.setNoClickThrough(false);
		scrollBarBottom.setHasListener(true);
		scrollBarBottom.revalidate();

		Widget scrollBarCentre = parent.createChild(-1, WidgetType.GRAPHIC);
		scrollBarCentre.setOriginalWidth(SCROLLBAR_WIDTH);
		scrollBarCentre.setOriginalHeight(0);
		scrollBarCentre.setSpriteId(SpriteID.SCROLLBAR_THUMB_MIDDLE);
		scrollBarCentre.setOriginalX(parent.getOriginalWidth() - SCROLLBAR_WIDTH - SCROLLBAR_PADDING);
		scrollBarCentre.setOriginalY(SCROLLBAR_BUTTON_HEIGHT);
		scrollBarCentre.setNoClickThrough(false);
		scrollBarCentre.setHasListener(true);
		scrollBarCentre.revalidate();


		Widget scrollBarControl = parent.createChild(-1, WidgetType.GRAPHIC);
		scrollBarControl.setOriginalWidth(SCROLLBAR_WIDTH);
		scrollBarControl.setOriginalHeight(0);
		scrollBarControl.setOriginalX(parent.getOriginalWidth() - SCROLLBAR_WIDTH - SCROLLBAR_PADDING);
		scrollBarControl.setOriginalY(SCROLLBAR_BUTTON_HEIGHT);
		scrollBarControl.setHasListener(true);
		scrollBarControl.setDragParent(scrollBg);
		scrollBarControl.setNoClickThrough(false);
		scrollBarControl.setOnDragListener((JavaScriptCallback) ev -> scrollTo(client.getMouseCanvasPosition().getY() - parent.getBounds().y));
		scrollBarControl.revalidate();


		presetScrollbars = new Widget[]{scrollBarTop, scrollBarBottom, scrollBarCentre, scrollBarControl};
		layoutScrollbar();

		Widget cover = parent.createChild(-1, WidgetType.GRAPHIC);
		cover.setSpriteId(897);
		cover.setSpriteTiling(true);
		cover.setOriginalX(0);
		cover.setOriginalY(SCROLLBAR_HEIGHT + 1);
		cover.setOriginalWidth(parent.getOriginalWidth());
		cover.setOriginalHeight(parent.getOriginalHeight() - (SCROLLBAR_HEIGHT + 1));
		cover.revalidate();

		// Create bottom buttons

		CustomWidgetActionButtonWithText selectPresetButton = new CustomWidgetActionButtonWithText(
			parent,
			"",
			BACK_BUTTON_SPRITE,
			"",
			op ->
			{
				getUIManager().removeCustomUI();
				getUIManager().hideVanillaUI();
				getUIManager().getEquipmentOverlay().create(true);
				getUIManager().createTab(getUIManager().getMainTab());
			}
		);
		selectPresetButton.setSize(40, 40);
		selectPresetButton.setIconSize(25, 20);
		selectPresetButton.create();
		selectPresetButton.addOption(1, "Back");
		selectPresetButton.layout(7, 213);

		Widget separator = parent.createChild(-1, WidgetType.LINE);
		separator.setOriginalX(-1);
		separator.setOriginalY(SCROLLBAR_HEIGHT);
		separator.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
		separator.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		separator.setOriginalHeight(0);
		separator.setOriginalWidth(6);
		separator.setWidthMode(WidgetSizeMode.MINUS);
		separator.setTextColor(0xaa9f75);
		separator.revalidate();

		CustomWidgetActionButton deletePresetButton = new CustomWidgetActionButton(
			parent,
			UIManager.FORCE_RIGHT_CLICK_WIDGET_NAME,
			SpriteID.BANK_RAID_SEND_TO_TRASH,
			op ->
			{
				TransmogPreset current = manager.getCurrentPreset();
				manager.deletePreset(current.getId());
				for (int i = current.getId() - 1; i >= 0; i--)
				{
					if (manager.getPreset(i) != null)
					{
						selectPreset(i);
						return;
					}
				}
				for (int i = current.getId() + 1; i <= config.lastIndex(); i++)
				{
					if (manager.getPreset(i) != null)
					{
						selectPreset(i);
						return;
					}
				}
			}
		);
		deletePresetButton.setSize(40, 40);
		deletePresetButton.setIconSize(26, 20);
		deletePresetButton.create();
		deletePresetButton.addOption(1, "Delete active " + UIManager.ORANGE_COLOUR_WIDGET_NAME + "Preset");
		deletePresetButton.layout(52, 213);


		parent.revalidate();
		presets.stream().filter(b -> b.getId() == config.currentPreset()).findFirst().ifPresent(box -> scrollTo(box.y));
	}

	/**
	 * Re-create the overlay, for redoing the very precise ordering of widgets that makes the effect work
	 */
	void recreate()
	{
		final Widget parent = getUIManager().getContainer();
		parent.deleteAllChildren();
		create();
	}

	private CustomWidgetPresetTabItem createPresetBox(TransmogPreset preset, Widget parent, int i)
	{
		CustomWidgetPresetTabItem w = new CustomWidgetPresetBox(preset, parent, this::selectPreset);
		w.create();
		w.layout(
			PRESET_EDGE_PADDING + (i % PRESETS_PER_LINE) * (CustomWidgetPresetBox.SIZE + PRESET_PADDING),
			PRESET_EDGE_PADDING + (i / PRESETS_PER_LINE) * (CustomWidgetPresetBox.SIZE + PRESET_PADDING)
		);
		if (preset.getId() == config.currentPreset())
		{
			w.setSelected(true);
		}
		w.addOption(1, "Select");
		return w;
	}

	private void selectPreset(int id)
	{
		presets.forEach(b -> b.setSelected(b.getId() == id));
		config.currentPreset(id);
		manager.updateTransmog();
		recreate();
	}

	private void addNewPreset(int id)
	{
		TransmogPreset newPreset = manager.createNewPreset();
		CustomWidgetPresetTabItem add = presets.get(presets.size() - 1);
		add.layout(
			(presets.size() % PRESETS_PER_LINE) * (CustomWidgetPresetBox.SIZE + PRESET_PADDING),
			(presets.size() / PRESETS_PER_LINE) * (CustomWidgetPresetBox.SIZE + PRESET_PADDING)
		);
		presets.add(presets.size() - 1, createPresetBox(newPreset, getUIManager().getContainer(), presets.size() - 1));
		selectPreset(newPreset.getId());
	}

	@Override
	public void mouseWheelMoved(MouseWheelEvent event)
	{
		if (boxBounds != null && boxBounds.contains(event.getPoint()))
		{
			clientThread.invoke(() -> scrollPresets(event.getUnitsToScroll() * 6));
		}
	}

	private void scrollPresets(int pixels)
	{
		scrollPos += pixels;
		doScroll();
	}

	private void scrollTo(int ypos)
	{
		int thumbHeight = Math.max((int) (SCROLLBAR_HEIGHT / (double)(maxScrollPos + SCROLLBAR_HEIGHT) * SCROLLBAR_TRACK_HEIGHT), SCROLLBAR_THUMB_CAP_HEIGHT * 2);
		int thumbCentRange = SCROLLBAR_TRACK_HEIGHT - thumbHeight;
		int thumbCentTop = SCROLLBAR_BUTTON_HEIGHT + thumbHeight / 2;
		double centrePer = Math.min(1d, Math.max(0d, (ypos - thumbCentTop) / (double)thumbCentRange));
		scrollPos = (int) (centrePer * maxScrollPos);
		doScroll();
	}

	private void doScroll()
	{
		scrollPos = Math.max(0, Math.min(scrollPos, maxScrollPos));
		layoutScrollbar();
		for (CustomWidgetPresetTabItem p : presets)
		{
			p.scrollBy(scrollPos);
		}
	}

	private void layoutScrollbar()
	{
		// Get the percentage of the presets visible on screen, and use that to figure out the size of the scrollbar in
		// the track. Make sure it's always at least large enough for the caps if there are way too many presets
		int thumbHeight = Math.max((int) (SCROLLBAR_HEIGHT / (double)(maxScrollPos + SCROLLBAR_HEIGHT) * SCROLLBAR_TRACK_HEIGHT), SCROLLBAR_THUMB_CAP_HEIGHT * 2);
		int thumbBuffer = SCROLLBAR_TRACK_HEIGHT - thumbHeight;
		// We can then use the gap remaining as the space to move the top of the scrollbar, and therefore the whole bar
		int thumbTop = (int) (scrollPos / (double)(maxScrollPos) * thumbBuffer);

		presetScrollbars[0].setOriginalY(SCROLLBAR_BUTTON_HEIGHT + thumbTop);
		// I'm not sure why the bottom cap is ~6px too far down
		presetScrollbars[1].setOriginalY(SCROLLBAR_BUTTON_HEIGHT + thumbTop + thumbHeight - SCROLLBAR_THUMB_CAP_HEIGHT - 1);
		presetScrollbars[2].setOriginalY(SCROLLBAR_BUTTON_HEIGHT + thumbTop + SCROLLBAR_THUMB_CAP_HEIGHT);
		// The height atm is for the entire bar, so cut off the caps for the centre
		presetScrollbars[2].setOriginalHeight(thumbHeight - SCROLLBAR_THUMB_CAP_HEIGHT * 2);
		presetScrollbars[3].setOriginalY(SCROLLBAR_BUTTON_HEIGHT + thumbTop);
		presetScrollbars[3].setOriginalHeight(thumbHeight);
		Arrays.stream(presetScrollbars).forEach(Widget::revalidate);
	}
}

/*
 * Copyright (c) 2020, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog.ui;

import com.google.inject.Inject;
import com.google.inject.Provider;
import com.google.inject.Singleton;
import io.hydrox.transmog.TransmogPreset;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.ui.FontManager;
import java.awt.FontMetrics;
import java.awt.Toolkit;
import java.awt.event.MouseWheelEvent;

@Singleton
@Slf4j
public class UIManager
{
	public static final String FORCE_RIGHT_CLICK_WIDGET_NAME = "<col=004356>";
	public static final String ORANGE_COLOUR_WIDGET_NAME = "<col=ff981f>";
	static final FontMetrics FONT_METRICS = Toolkit.getDefaultToolkit().getFontMetrics(FontManager.getRunescapeSmallFont());

	private final ChatboxPanelManager chatboxPanelManager;
	private final Client client;
	private final ClientThread clientThread;

	private final Provider<MainTab> mainTab;

	private final Provider<EquipmentOverlay> equipmentOverlay;

	private final Provider<PresetTab> presetTab;

	public MainTab getMainTab()
	{
		return mainTab.get();
	}

	public EquipmentOverlay getEquipmentOverlay()
	{
		return equipmentOverlay.get();
	}

	public PresetTab getPresetTab()
	{
		return presetTab.get();
	}

	@Getter
	@Setter
	private boolean uiCreated = false;

	@Getter
	@Setter
	private boolean isSearching = false;

	CustomTab currentTab;

	@Inject
	UIManager(ChatboxPanelManager chatboxPanelManager, Client client, ClientThread clientThread,
			  Provider<MainTab> mainTab, Provider<EquipmentOverlay> equipmentOverlay, Provider<PresetTab> presetTab)
	{
		this.chatboxPanelManager = chatboxPanelManager;
		this.client = client;
		this.clientThread = clientThread;
		this.mainTab = mainTab;
		this.equipmentOverlay = equipmentOverlay;
		this.presetTab = presetTab;
	}

	public void shutDown()
	{
		clientThread.invoke(this::removeCustomUI);
		uiCreated = false;
		closeSearch();
		currentTab.shutDown();
	}

	public void createTab(CustomTab tab)
	{
		currentTab = tab;
		currentTab.create();
	}

	public void onPvpChanged(boolean newValue)
	{
		currentTab.onPvpChanged(newValue);
	}

	public void onResizeableChanged()
	{
		uiCreated = false;
		removeCustomUI();
		createTab(equipmentOverlay.get());
	}

	Widget getContainer()
	{
		final Widget equipment = client.getWidget(InterfaceID.EQUIPMENT, 0);
		return equipment.getParent();
	}

	void closeSearch()
	{
		if (isSearching)
		{
			chatboxPanelManager.close();
			isSearching = false;
		}

	}

	public boolean isVanillaUIHidden()
	{
		return getContainer().getChild(1).isHidden();
	}

	void hideVanillaUI()
	{
		for (Widget child : getContainer().getNestedChildren())
		{
			child.setHidden(true);
			child.revalidate();
		}
	}

	public void removeCustomUI()
	{
		final Widget parent = getContainer();
		parent.deleteAllChildren();
		for (Widget child : parent.getNestedChildren())
		{
			child.setHidden(false);
			child.revalidate();
		}
		currentTab.destroy();
		parent.revalidate();
		closeSearch();
	}

	public void loadPreset(TransmogPreset preset)
	{
		if (currentTab != null)
		{
			currentTab.loadPreset(preset);
		}
	}

	public void onClientTick()
	{
		if (currentTab != null)
		{
			currentTab.onClientTick();
		}
	}

	public void updateTutorial(boolean equipmentState)
	{
		if (currentTab != null)
		{
			currentTab.updateTutorial(equipmentState);
		}
	}

	public void mouseWheelMoved(MouseWheelEvent event)
	{
		if (currentTab != null)
		{
			currentTab.mouseWheelMoved(event);
		}
	}

	public static String cutStringToPxWidth(String str, int targetWidth)
	{
		return cutStringToPxWidth(str, targetWidth, false);
	}

	public static String cutStringToPxWidth(String str, int targetWidth, boolean withEllipsis)
	{
		int width = UIManager.FONT_METRICS.stringWidth(str);
		String newStr = str;
		while(width > targetWidth)
		{
			newStr = newStr.substring(0, newStr.length() - 1);
			width = UIManager.FONT_METRICS.stringWidth(newStr + (withEllipsis ? "..." : ""));
		}
		return newStr + (withEllipsis ? "..." : "");
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import io.hydrox.transmog.config.TransmogrificationConfigManager;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.game.ItemManager;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import org.mockito.Mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class TransmogMigrateTest
{
	private static final String V1_CONFIG = "2643,19697,null,24802,null,24804,-1,10083,24680,-1";

	@Mock
	@Bind
	private Client client;

	@Mock
	@Bind
	private ClientThread clientThread;

	@Mock
	@Bind
	private Notifier notifier;

	@Mock
	@Bind
	private ItemManager itemManager;

	@Mock
	@Bind
	private ChatMessageManager chatMessageManager;

	@Mock
	@Bind
	private TransmogrificationConfigManager config;

	@Inject
	private TransmogrificationManager manager;

	@Before
	public void before()
	{
		Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
	}

	@Test
	public void testMigrateV1()
	{
		when(config.lastIndex()).thenReturn(0);
		// config.getPresetData(0) == null
		when(config.getPresetData(2)).thenReturn(V1_CONFIG);
		when(config.getPresetData(4)).thenReturn(V1_CONFIG);

		manager.migrateV1();

		verify(config).lastIndex(5);
		verify(config, times(2)).savePreset(anyInt(), any());
	}

	@Test
	public void testDontMigrate()
	{
		when(config.lastIndex()).thenReturn(3);

		manager.migrateV1();

		verify(config, never()).lastIndex(5);
		verify(config, never()).savePreset(anyInt(), any());
	}
}

/*
 * Copyright (c) 2021, Hydrox6 <ikada@protonmail.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package io.hydrox.transmog;

import io.hydrox.transmog.config.V1Parser;
import io.hydrox.transmog.config.V2Parser;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;
import java.util.Arrays;
import java.util.List;

@RunWith(MockitoJUnitRunner.class)
public class TransmogPresetParserTest
{
	private static final String V1_CONFIG = "2643,19697,null,24802,null,24804,-1,10083,24680,-1";
	private static final List<String> V1_SLOT_VALUES = Arrays.asList("2643","19697","null","24802","null","24804","-1","10083","24680","-1");
	private static final String V2_CONFIG = "\"25500,monke,10828,1052,1704,2503,-1,2497,null,7460,3105,-1";
	private static final List<String> V2_SLOT_VALUES = Arrays.asList("10828","1052","1704","2503","-1","2497","null","7460","3105","-1");

	@Test
	public void testV1Parser()
	{
		V1Parser parser = new V1Parser();
		parser.parse(V1_CONFIG);
		assertEquals(V1_SLOT_VALUES, parser.getSlotValues());
		assertEquals(-1, parser.getIcon());
		assertEquals("", parser.getName());
	}

	@Test
	public void testV2Parser()
	{
		V2Parser parser = new V2Parser();
		parser.parse(V2_CONFIG);
		assertEquals(V2_SLOT_VALUES, parser.getSlotValues());
		assertEquals(25500, parser.getIcon());
		assertEquals("monke", parser.getName());

		// Check deny V1
		parser = new V2Parser();
		parser.parse(V1_CONFIG);
		assertEquals("", parser.getName());
		assertEquals(-1, parser.getIcon());
		assertNull(parser.getSlotValues());
	}

	@Test
	public void testV1ToV2Migration()
	{
		V1Parser v1 = new V1Parser();
		v1.parse(V1_CONFIG);
		V2Parser v2 = new V2Parser();
		v2.migrate(v1);

		assertEquals(V1_SLOT_VALUES, v2.getSlotValues());
		assertEquals(-1, v2.getIcon());
		assertEquals("", v2.getName());
	}

	@Test
	public void testV2ToV1Migration()
	{
		V2Parser v2 = new V2Parser();
		v2.parse(V2_CONFIG);
		V1Parser v1 = new V1Parser();
		v1.migrate(v2);

		assertEquals(V2_SLOT_VALUES, v1.getSlotValues());
		assertEquals(-1, v1.getIcon());
		assertEquals("", v1.getName());
	}
}

package io.hydrox.transmog;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TransmogrificationPluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TransmogrificationPlugin.class);
		RuneLite.main(args);
	}
}
