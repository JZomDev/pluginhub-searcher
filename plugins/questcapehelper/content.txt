package com.ironpath.util;

/**
 * OSRS experience table helpers.
 *
 * RuneLite's API does not expose exact per-skill XP for an Ironman plan simulation,
 * so we convert from a conservative baseline: the minimum XP for the current real level.
 *
 * This still improves correctness over heuristics when applying quest XP rewards.
 */
public final class XpTable
{
    private static final int MAX_LEVEL = 126;
    private static final int[] XP_FOR_LEVEL = build();

    private XpTable() {}

    public static int xpForLevel(int level)
    {
        int l = clamp(level, 1, MAX_LEVEL);
        return XP_FOR_LEVEL[l];
    }

    public static int levelForXp(int xp)
    {
        int x = Math.max(0, xp);
        int lo = 1;
        int hi = MAX_LEVEL;

        while (lo < hi)
        {
            int mid = (lo + hi + 1) >>> 1;
            if (XP_FOR_LEVEL[mid] <= x)
            {
                lo = mid;
            }
            else
            {
                hi = mid - 1;
            }
        }

        return lo;
    }

    private static int[] build()
    {
        // Standard RuneScape formula. Index 0 unused; XP_FOR_LEVEL[level] = minimum XP for that level.
        int[] xp = new int[MAX_LEVEL + 1];
        int points = 0;

        xp[1] = 0;
        for (int lvl = 2; lvl <= MAX_LEVEL; lvl++)
        {
            points += (int) Math.floor(lvl - 1 + 300.0 * Math.pow(2.0, (lvl - 1) / 7.0));
            xp[lvl] = points / 4;
        }
        return xp;
    }

    private static int clamp(int v, int lo, int hi)
    {
        if (v < lo) return lo;
        if (v > hi) return hi;
        return v;
    }
}

package com.ironpath;

import com.google.inject.Provides;
import com.ironpath.service.QuestRouteService;
import com.ironpath.service.ProgressionPlanService;
import com.ironpath.overlay.ActiveStepOverlay;
import com.ironpath.ui.IronmanPathPanel;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.SwingUtilities;

@Slf4j
@PluginDescriptor(
        name = "Optimal Quest Order",
        description = "Quest-first ironman progression panel (quest cape route, readiness, search).",
        tags = {"ironman", "quest", "route", "efficiency"}
)
public class IronmanPathPlugin extends Plugin
{
    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private ClientToolbar clientToolbar;
    @Inject private SpriteManager spriteManager;

    @Inject private QuestRouteService questRouteService;
    @Inject private ProgressionPlanService progressionPlanService;

    @Inject private OverlayManager overlayManager;
    @Inject private ActiveStepOverlay activeStepOverlay;

    @Inject private IronmanPathConfig config;

    private IronmanPathPanel panel;
    private NavigationButton navButton;

    // Delay the first refresh after login so skills/quests/varbits settle and we avoid UI thrash.
    private int refreshInTicks = 0;

    // Varbits can change extremely frequently (run energy, timers, etc.).
    // Mark the panel as dirty and refresh at a low, human-friendly rate.
    private boolean panelDirty = false;
    private int varbitRefreshCooldownTicks = 0;

    @Provides
    IronmanPathConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(IronmanPathConfig.class);
    }

    @Override
    protected void startUp()
    {
        panel = new IronmanPathPanel(questRouteService, progressionPlanService, clientThread, spriteManager);

        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/com/ironpath/icon.png");

        navButton = NavigationButton.builder()
                .tooltip("Ironman Path")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);

        // Overlay in the game view (toggled via config).
        overlayManager.add(activeStepOverlay);
        log.info("Ironman Path started");
    }

    @Override
    protected void shutDown()
    {
        if (overlayManager != null && activeStepOverlay != null)
        {
            overlayManager.remove(activeStepOverlay);
        }

        if (navButton != null)
        {
            clientToolbar.removeNavigation(navButton);
            navButton = null;
        }
        panel = null;
        log.info("Ironman Path stopped");
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (panel == null)
        {
            return;
        }

        if (event.getGameState() == GameState.LOGGED_IN)
        {
            // Wait a couple ticks so quest state/skills/varbits are populated.
            refreshInTicks = 2;
            panelDirty = false;
            varbitRefreshCooldownTicks = 0;
            panel.showLoading();
            return;
        }

        if (event.getGameState() == GameState.LOGIN_SCREEN || event.getGameState() == GameState.HOPPING)
        {
            refreshInTicks = 0;
            panelDirty = false;
            varbitRefreshCooldownTicks = 0;
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick)
    {
        if (panel == null)
        {
            return;
        }

        if (refreshInTicks > 0)
        {
            refreshInTicks--;
            if (refreshInTicks == 0)
            {
                requestRefreshIfPanelShowing();
            }
        }

        // Rate-limit refreshes caused by frequent varbit changes.
        if (varbitRefreshCooldownTicks > 0)
        {
            varbitRefreshCooldownTicks--;
        }

        if (panelDirty && varbitRefreshCooldownTicks == 0)
        {
            panelDirty = false;
            // ~1.8s at 0.6s per tick. Keeps UI responsive without constant rebuilds.
            varbitRefreshCooldownTicks = 3;
            requestRefreshIfPanelShowing();
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (panel == null)
        {
            return;
        }

        // Varbits change very frequently. Mark dirty and refresh on a short tick-based cadence.
        // This avoids constant panel rebuilds (and prevents icon flicker).
        panelDirty = true;
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (panel == null)
        {
            return;
        }

        requestRefreshIfPanelShowing();
    }

    private void requestRefreshIfPanelShowing()
    {
        // Only rebuild the sidebar when it's actually visible.
        // This prevents background varbit churn from constantly recreating cards.
        SwingUtilities.invokeLater(() ->
        {
            if (panel != null && panel.isShowing())
            {
                panel.requestRefresh();
            }
        });
    }
}

package com.ironpath.model;

/**
 * A single actionable step in the progression plan.
 *
 * Steps are either a quest to complete or a skill level to train to.
 */
public interface PlanStep
{
    PlanStepType getType();
}

package com.ironpath.model;

import java.util.Collections;
import java.util.List;

public final class PlanSnapshot
{
    private final int completed;
    private final int total;
    private final QuestRow recommended;
    private final List<QuestRow> inProgress;
    private final List<QuestRow> ready;
    private final List<QuestRow> blocked;
    private final List<QuestRow> done;

    public PlanSnapshot(int completed, int total, QuestRow recommended,
                        List<QuestRow> inProgress, List<QuestRow> ready, List<QuestRow> blocked, List<QuestRow> done)
    {
        this.completed = completed;
        this.total = total;
        this.recommended = recommended;
        this.inProgress = inProgress == null ? List.of() : Collections.unmodifiableList(inProgress);
        this.ready = ready == null ? List.of() : Collections.unmodifiableList(ready);
        this.blocked = blocked == null ? List.of() : Collections.unmodifiableList(blocked);
        this.done = done == null ? List.of() : Collections.unmodifiableList(done);
    }

    public int getCompleted() { return completed; }
    public int getTotal() { return total; }
    public QuestRow getRecommended() { return recommended; }
    public List<QuestRow> getInProgress() { return inProgress; }
    public List<QuestRow> getReady() { return ready; }
    public List<QuestRow> getBlocked() { return blocked; }
    public List<QuestRow> getDone() { return done; }
}

package com.ironpath.model;

import net.runelite.api.Skill;

public final class QuestBlocker
{
    public enum Type
    {
        PREREQUISITE_QUEST,
        SKILL_LEVEL
    }

    private final Type type;
    private final String questName;
    private final Skill skill;
    private final int have;
    private final int need;

    private QuestBlocker(Type type, String questName, Skill skill, int have, int need)
    {
        this.type = type;
        this.questName = questName;
        this.skill = skill;
        this.have = have;
        this.need = need;
    }

    public static QuestBlocker prereqQuest(String questName)
    {
        return new QuestBlocker(Type.PREREQUISITE_QUEST, questName, null, 0, 0);
    }

    public static QuestBlocker skill(Skill skill, int have, int need)
    {
        return new QuestBlocker(Type.SKILL_LEVEL, null, skill, have, need);
    }

    public Type getType()
    {
        return type;
    }

    public String getQuestName()
    {
        return questName;
    }

    public Skill getSkill()
    {
        return skill;
    }

    public int getHave()
    {
        return have;
    }

    public int getNeed()
    {
        return need;
    }
}

package com.ironpath.model;

import java.util.Collections;
import java.util.List;
import net.runelite.api.QuestState;

public final class QuestRow
{
    private final QuestEntry entry;
    private final QuestState questState;
    private final QuestReadiness readiness;
    private final List<QuestBlocker> blockers;
    private final double score;
    private final int routeIndex;

    public QuestRow(QuestEntry entry, QuestState questState, QuestReadiness readiness,
                    List<QuestBlocker> blockers, double score, int routeIndex)
    {
        this.entry = entry;
        this.questState = questState;
        this.readiness = readiness;
        this.blockers = blockers == null ? List.of() : Collections.unmodifiableList(blockers);
        this.score = score;
        this.routeIndex = routeIndex;
    }

    public QuestEntry getEntry() { return entry; }
    public QuestState getQuestState() { return questState; }
    public QuestReadiness getReadiness() { return readiness; }
    public List<QuestBlocker> getBlockers() { return blockers; }
    public double getScore() { return score; }
    public int getRouteIndex() { return routeIndex; }
}

package com.ironpath.model;

public enum PlanStepType
{
    QUEST,
    TRAIN,
    MINIQUEST,
    UNLOCK,
    LAMP,
    DIARY,
    NOTE
}

package com.ironpath.model;

public enum QuestReadiness
{
    DONE,
    IN_PROGRESS,
    READY,
    BLOCKED
}

package com.ironpath.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import net.runelite.api.Quest;
import net.runelite.api.Skill;

/**
 * Data model for a single quest in the route.
 *
 * This plugin intentionally keeps requirements conservative. Fields can be expanded over time.
 */
public final class QuestEntry
{
    /**
     * Canonical quest identifier from the RuneLite API.
     *
     * This is the source of truth for quest state and is intentionally NOT derived from user-provided strings.
     * Using {@link Quest} avoids brittle name matching issues (e.g. "Vampyre" vs "Vampire").
     */
    private final Quest quest;

    /**
     * Fallback display name for any temporary/legacy entries that are not backed by a {@link Quest}.
     * Prefer {@link #quest} wherever possible.
     */
    private final String questName;
    private final String shortWhy;
    private final String wikiUrl;

    /** Minimum tracked skill requirements (subset). */
    private final Map<Skill, Integer> minSkills;

    /** Tracked prerequisite quests by display name (subset). */
    private final List<String> prereqQuestNames;

    /** Optional XP reward weights (subset). */
    private final Map<Skill, Integer> xpRewards;

    /** Tags used for scoring and grouping. */
    private final Set<String> tags;

    public QuestEntry(Quest quest, String shortWhy)
    {
        this(quest, shortWhy, null, Map.of(), List.of(), Map.of(), Set.of());
    }

    public QuestEntry(Quest quest, String shortWhy, String wikiUrl)
    {
        this(quest, shortWhy, wikiUrl, Map.of(), List.of(), Map.of(), Set.of());
    }

    public QuestEntry(Quest quest, String shortWhy, Map<Skill, Integer> minSkills)
    {
        this(quest, shortWhy, null, minSkills, List.of(), Map.of(), Set.of());
    }

    public QuestEntry(
            Quest quest,
            String shortWhy,
            String wikiUrl,
            Map<Skill, Integer> minSkills,
            List<String> prereqQuestNames,
            Map<Skill, Integer> xpRewards,
            Set<String> tags)
    {
        this.quest = quest;
        this.questName = quest != null ? quest.getName() : "";
        this.shortWhy = shortWhy;
        this.wikiUrl = wikiUrl;
        this.minSkills = minSkills == null ? Collections.emptyMap() : Collections.unmodifiableMap(minSkills);
        this.prereqQuestNames = prereqQuestNames == null ? List.of() : Collections.unmodifiableList(new ArrayList<>(prereqQuestNames));
        this.xpRewards = xpRewards == null ? Collections.emptyMap() : Collections.unmodifiableMap(xpRewards);
        this.tags = tags == null ? Set.of() : Collections.unmodifiableSet(new LinkedHashSet<>(tags));
    }

    public QuestEntry(String questName, String shortWhy)
    {
        this(null, questName, shortWhy, null, Map.of(), List.of(), Map.of(), Set.of());
    }

    public QuestEntry(String questName, String shortWhy, Map<Skill, Integer> minSkills)
    {
        this(null, questName, shortWhy, null, minSkills, List.of(), Map.of(), Set.of());
    }

    public QuestEntry(
            String questName,
            String shortWhy,
            Map<Skill, Integer> minSkills,
            List<String> prereqQuestNames,
            Map<Skill, Integer> xpRewards,
            Set<String> tags)
    {
        this(null, questName, shortWhy, null, minSkills, prereqQuestNames, xpRewards, tags);
    }

    private QuestEntry(
            Quest quest,
            String questName,
            String shortWhy,
            String wikiUrl,
            Map<Skill, Integer> minSkills,
            List<String> prereqQuestNames,
            Map<Skill, Integer> xpRewards,
            Set<String> tags)
    {
        this.quest = quest;
        this.questName = questName;
        this.shortWhy = shortWhy;
        this.wikiUrl = wikiUrl;
        this.minSkills = minSkills == null ? Collections.emptyMap() : Collections.unmodifiableMap(minSkills);
        this.prereqQuestNames = prereqQuestNames == null ? List.of() : Collections.unmodifiableList(new ArrayList<>(prereqQuestNames));
        this.xpRewards = xpRewards == null ? Collections.emptyMap() : Collections.unmodifiableMap(xpRewards);
        this.tags = tags == null ? Set.of() : Collections.unmodifiableSet(new LinkedHashSet<>(tags));
    }

    public Quest getQuest()
    {
        return quest;
    }

    public String getQuestName()
    {
        return quest != null ? quest.getName() : questName;
    }

    public String getShortWhy()
    {
        return shortWhy;
    }

    public String getWikiUrl()
    {
        return wikiUrl;
    }

    public Map<Skill, Integer> getMinSkills()
    {
        return minSkills;
    }

    public List<String> getPrereqQuestNames()
    {
        return prereqQuestNames;
    }

    public Map<Skill, Integer> getXpRewards()
    {
        return xpRewards;
    }

    public Set<String> getTags()
    {
        return tags;
    }
}

package com.ironpath.model;

import net.runelite.api.Quest;
import net.runelite.api.QuestState;

public final class QuestStatus
{
    private final Quest quest;
    private final QuestState state;

    public QuestStatus(Quest quest, QuestState state)
    {
        this.quest = quest;
        this.state = state;
    }

    public Quest getQuest()
    {
        return quest;
    }

    public QuestState getState()
    {
        return state;
    }

    public boolean isCompleted()
    {
        return state == QuestState.FINISHED;
    }

    public boolean isInProgress()
    {
        return state == QuestState.IN_PROGRESS;
    }
}

package com.ironpath.model;

/**
 * UI metadata wrapper for a plan step that preserves its absolute position within the wiki route spine.
 * This keeps Option A behavior intact: the planner still follows the spine, we just display context.
 */
public final class SpineStepView
{
    private final PlanStep step;
    private final int spineIndex; // 0-based index in wiki_route spine
    private final int spineTotal;

    public SpineStepView(PlanStep step, int spineIndex, int spineTotal)
    {
        this.step = step;
        this.spineIndex = spineIndex;
        this.spineTotal = spineTotal;
    }

    public PlanStep getStep()
    {
        return step;
    }

    public int getSpineIndex()
    {
        return spineIndex;
    }

    public int getSpineTotal()
    {
        return spineTotal;
    }
}

package com.ironpath.model;

import net.runelite.api.Skill;

/**
 * A plan step representing manual skilling needed to unlock the next quest.
 */
public final class TrainPlanStep implements PlanStep
{
    private final Skill skill;
    private final int fromLevel;
    private final int toLevel;
    private final String reason;

    public TrainPlanStep(Skill skill, int fromLevel, int toLevel, String reason)
    {
        this.skill = skill;
        this.fromLevel = fromLevel;
        this.toLevel = toLevel;
        this.reason = reason;
    }

    @Override
    public PlanStepType getType()
    {
        return PlanStepType.TRAIN;
    }

    public Skill getSkill()
    {
        return skill;
    }

    public int getFromLevel()
    {
        return fromLevel;
    }

    public int getToLevel()
    {
        return toLevel;
    }

    public String getReason()
    {
        return reason;
    }
}

package com.ironpath.model;

import net.runelite.api.QuestState;

/**
 * A plan step representing a quest to complete.
 */
public final class QuestPlanStep implements PlanStep
{
    private final QuestEntry entry;
    private final QuestState state;

    public QuestPlanStep(QuestEntry entry, QuestState state)
    {
        this.entry = entry;
        this.state = state;
    }

    @Override
    public PlanStepType getType()
    {
        return PlanStepType.QUEST;
    }

    public QuestEntry getEntry()
    {
        return entry;
    }

    public QuestState getState()
    {
        return state;
    }
}

package com.ironpath.model;

import java.util.Collections;
import java.util.Map;
import java.util.Set;
import net.runelite.api.Quest;
import net.runelite.api.Skill;

/**
 * A single row in the canonical route spine.
 *
 * This represents the *order* of progression and can include non-quest steps
 * like miniquests, unlock activities, lamps/diary rewards, and explicit training guidance.
 *
 * Runtime planning produces {@link PlanStep} instances from this spine by
 * simulating completion and inserting required gates.
 */
public final class RouteStep
{
    private final PlanStepType type;

    // QUEST
    private final Quest quest;

    // TRAIN
    private final Skill skill;
    private final Integer toLevel;

    // Generic display
    private final String displayName;
    private final String why;
    private final String wikiUrl;

    // Optional overrides; primarily used for filler tagging for appended quests.
    private final Set<String> tagsOverride;
    private final Map<Skill, Integer> minSkillsOverride;

    private RouteStep(Builder b)
    {
        this.type = b.type;
        this.quest = b.quest;
        this.skill = b.skill;
        this.toLevel = b.toLevel;
        this.displayName = b.displayName;
        this.why = b.why;
        this.wikiUrl = b.wikiUrl;
        this.tagsOverride = b.tagsOverride == null ? Set.of() : Collections.unmodifiableSet(b.tagsOverride);
        this.minSkillsOverride = b.minSkillsOverride == null ? Map.of() : Collections.unmodifiableMap(b.minSkillsOverride);
    }

    public PlanStepType getType()
    {
        return type;
    }

    public Quest getQuest()
    {
        return quest;
    }

    public Skill getSkill()
    {
        return skill;
    }

    public Integer getToLevel()
    {
        return toLevel;
    }

    public String getDisplayName()
    {
        return displayName;
    }

    public String getWhy()
    {
        return why;
    }

    public String getWikiUrl()
    {
        return wikiUrl;
    }

    public Set<String> getTagsOverride()
    {
        return tagsOverride;
    }

    public Map<Skill, Integer> getMinSkillsOverride()
    {
        return minSkillsOverride;
    }

    public static Builder builder(PlanStepType type)
    {
        return new Builder(type);
    }

    public static final class Builder
    {
        private final PlanStepType type;

        private Quest quest;
        private Skill skill;
        private Integer toLevel;
        private String displayName;
        private String why;
        private String wikiUrl;
        private Set<String> tagsOverride;
        private Map<Skill, Integer> minSkillsOverride;

        private Builder(PlanStepType type)
        {
            this.type = type;
        }

        public Builder quest(Quest quest)
        {
            this.quest = quest;
            return this;
        }

        public Builder skill(Skill skill)
        {
            this.skill = skill;
            return this;
        }

        public Builder toLevel(Integer toLevel)
        {
            this.toLevel = toLevel;
            return this;
        }

        public Builder displayName(String displayName)
        {
            this.displayName = displayName;
            return this;
        }

        public Builder why(String why)
        {
            this.why = why;
            return this;
        }

        public Builder wikiUrl(String wikiUrl)
        {
            this.wikiUrl = wikiUrl;
            return this;
        }

        public Builder tagsOverride(Set<String> tagsOverride)
        {
            this.tagsOverride = tagsOverride;
            return this;
        }

        public Builder minSkillsOverride(Map<Skill, Integer> minSkillsOverride)
        {
            this.minSkillsOverride = minSkillsOverride;
            return this;
        }

        public RouteStep build()
        {
            return new RouteStep(this);
        }
    }
}

package com.ironpath.model;

import net.runelite.api.Skill;

/**
 * A non-quest plan step that cannot be verified automatically by the client.
 *
 * The planner assumes the user completes these steps when they appear, and uses them
 * primarily for guidance and for simulated state (e.g., training or lamp allocation).
 */
public final class InfoPlanStep implements PlanStep
{
    private final PlanStepType type;
    private final String title;
    private final String detail;
    private final String wikiUrl;

    // Optional fields (used by TRAIN/LAMP/DIARY guidance)
    private final Skill skill;
    private final Integer fromLevel;
    private final Integer toLevel;
    private final Integer xp; // best-effort, may be null

    private InfoPlanStep(Builder b)
    {
        this.type = b.type;
        this.title = b.title;
        this.detail = b.detail;
        this.wikiUrl = b.wikiUrl;
        this.skill = b.skill;
        this.fromLevel = b.fromLevel;
        this.toLevel = b.toLevel;
        this.xp = b.xp;
    }

    @Override
    public PlanStepType getType()
    {
        return type;
    }

    public String getTitle()
    {
        return title;
    }

    public String getDetail()
    {
        return detail;
    }

    public String getWikiUrl()
    {
        return wikiUrl;
    }

    public Skill getSkill()
    {
        return skill;
    }

    public Integer getFromLevel()
    {
        return fromLevel;
    }

    public Integer getToLevel()
    {
        return toLevel;
    }

    public Integer getXp()
    {
        return xp;
    }

    public static Builder builder(PlanStepType type)
    {
        return new Builder(type);
    }

    public static final class Builder
    {
        private final PlanStepType type;
        private String title;
        private String detail;
        private String wikiUrl;
        private Skill skill;
        private Integer fromLevel;
        private Integer toLevel;
        private Integer xp;

        private Builder(PlanStepType type)
        {
            this.type = type;
        }

        public Builder title(String title)
        {
            this.title = title;
            return this;
        }

        public Builder detail(String detail)
        {
            this.detail = detail;
            return this;
        }

        public Builder wikiUrl(String wikiUrl)
        {
            this.wikiUrl = wikiUrl;
            return this;
        }

        public Builder skill(Skill skill)
        {
            this.skill = skill;
            return this;
        }

        public Builder fromLevel(Integer fromLevel)
        {
            this.fromLevel = fromLevel;
            return this;
        }

        public Builder toLevel(Integer toLevel)
        {
            this.toLevel = toLevel;
            return this;
        }

        public Builder xp(Integer xp)
        {
            this.xp = xp;
            return this;
        }

        public InfoPlanStep build()
        {
            return new InfoPlanStep(this);
        }
    }
}

package com.ironpath.ui;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.lang.ref.WeakReference;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.SwingUtilities;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;

/**
 * Small UI-only cache for OSRS cache sprites (via RuneLite SpriteManager).
 *
 * Goals:
 * - Avoid repeated fallback->sprite swapping across frequent panel rebuilds.
 * - Ensure sprite requests occur on the client thread.
 * - Update any labels that are currently showing the sprite when it becomes available.
 */
final class SpriteIconCache
{
    private static final Map<Integer, ImageIcon> CACHE = new ConcurrentHashMap<>();
    private static final Set<Integer> IN_FLIGHT = ConcurrentHashMap.newKeySet();
    private static final Map<Integer, CopyOnWriteArrayList<WeakReference<JLabel>>> WATCHERS = new ConcurrentHashMap<>();

    private SpriteIconCache()
    {
    }

    static void attach(JLabel label, SpriteManager spriteManager, ClientThread clientThread, int spriteId, int size)
    {
        if (label == null)
        {
            return;
        }

        ImageIcon cached = CACHE.get(spriteId);
        if (cached != null)
        {
            label.setIcon(cached);
            return;
        }

        if (spriteManager == null)
        {
            // No sprite manager available; leave icon empty but preserve slot sizing in the caller.
            return;
        }

        // Register the label so it will be updated when the sprite is available.
        WATCHERS.computeIfAbsent(spriteId, k -> new CopyOnWriteArrayList<>()).add(new WeakReference<>(label));

        // Only one load per spriteId.
        if (!IN_FLIGHT.add(spriteId))
        {
            return;
        }

        Runnable request = () ->
        {
            BufferedImage img = spriteManager.getSprite(spriteId, 0);
            if (img != null)
            {
                publish(spriteId, img, size);
                return;
            }

            spriteManager.getSpriteAsync(spriteId, 0, sprite ->
            {
                if (sprite != null)
                {
                    publish(spriteId, sprite, size);
                }
                else
                {
                    IN_FLIGHT.remove(spriteId);
                }
            });
        };

        if (clientThread != null)
        {
            clientThread.invokeLater(request);
        }
        else
        {
            request.run();
        }
    }

    private static void publish(int spriteId, BufferedImage img, int size)
    {
        ImageIcon icon = new ImageIcon(scale(img, size));
        CACHE.put(spriteId, icon);
        IN_FLIGHT.remove(spriteId);

        CopyOnWriteArrayList<WeakReference<JLabel>> list = WATCHERS.get(spriteId);
        if (list == null)
        {
            return;
        }

        SwingUtilities.invokeLater(() ->
        {
            Iterator<WeakReference<JLabel>> it = list.iterator();
            while (it.hasNext())
            {
                JLabel l = it.next().get();
                if (l == null)
                {
                    it.remove();
                    continue;
                }
                l.setIcon(icon);
                l.revalidate();
                l.repaint();
            }
        });
    }

    private static Image scale(BufferedImage img, int size)
    {
        return img.getScaledInstance(size, size, Image.SCALE_SMOOTH);
    }
}

package com.ironpath.ui;

import java.awt.Color;
import java.awt.Font;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import net.runelite.client.ui.ColorScheme;

final class ChipButton extends JButton
{
    ChipButton(String text)
    {
        super(text);
        setFocusable(false);
        setFont(getFont().deriveFont(Font.PLAIN, 11f));
        setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR),
                BorderFactory.createEmptyBorder(4, 10, 4, 10)
        ));
        setOpaque(true);
        super.setSelected(false);
        updateBackground();

        addActionListener(e ->
        {
            setSelected(!isSelected());
        });
    }

    @Override
    public boolean isSelected()
    {
        return super.isSelected();
    }

    @Override
    public void setSelected(boolean selected)
    {
        super.setSelected(selected);
        updateBackground();
    }

    private void updateBackground()
    {
        final Color bg = isSelected() ? ColorScheme.DARKER_GRAY_COLOR : new Color(54, 54, 54);
        setBackground(bg);
        repaint();
    }
}

package com.ironpath.ui;

import com.ironpath.model.QuestReadiness;
import com.ironpath.model.QuestRow;
import java.awt.Color;
import java.awt.Font;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.ColorScheme;

final class StatusPill
{
    private StatusPill() {}

    static JPanel build(QuestRow row)
    {
        final String text;
        final Color bg;

        final QuestReadiness r = row.getReadiness();
        switch (r)
        {
            case DONE:
                text = "Done";
                bg = new Color(54, 94, 64);
                break;
            case IN_PROGRESS:
                text = "In progress";
                bg = new Color(88, 86, 58);
                break;
            case BLOCKED:
                text = "Blocked";
                bg = new Color(92, 64, 64);
                break;
            case READY:
            default:
                text = "Ready";
                bg = new Color(56, 76, 94);
                break;
        }

        final JLabel label = new JLabel(text);
        label.setFont(label.getFont().deriveFont(Font.BOLD, 11f));
        label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        final JPanel pill = new JPanel();
        pill.setBackground(bg);
        pill.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR),
                BorderFactory.createEmptyBorder(3, 8, 3, 8)
        ));
        pill.add(label);
        return pill;
    }
}

package com.ironpath.ui;

import com.ironpath.model.InfoPlanStep;
import com.ironpath.model.PlanStep;
import com.ironpath.model.SpineStepView;
import com.ironpath.model.PlanStepType;
import com.ironpath.model.QuestPlanStep;
import com.ironpath.model.TrainPlanStep;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

/**
 * Renders a {@link PlanStep} as a compact sidebar-safe card.
 */
public final class PlanStepCard
{
    private PlanStepCard() {}

    public static JPanel compact(SpriteManager spriteManager, ClientThread clientThread, SpineStepView view)
    {
        if (view == null)
        {
            return empty("Unknown step", -1, -1);
        }

        return compact(spriteManager, clientThread, view.getStep(), view.getSpineIndex(), view.getSpineTotal());
    }

    public static JPanel compact(SpriteManager spriteManager, ClientThread clientThread, PlanStep step, int spineIndex, int spineTotal)
    {
        if (step == null)
        {
            return empty("Unknown step", spineIndex, spineTotal);
        }

        if (step.getType() == PlanStepType.QUEST && step instanceof QuestPlanStep)
        {
            QuestPlanStep q = (QuestPlanStep) step;
            return QuestCard.compact(spriteManager, clientThread, q.getEntry(), q.getState(), spineIndex, spineTotal);
        }

        if (step.getType() == PlanStepType.TRAIN && step instanceof TrainPlanStep)
        {
            return train((TrainPlanStep) step, spineIndex, spineTotal);
        }

        if (step instanceof InfoPlanStep)
        {
            return info(spriteManager, clientThread, (InfoPlanStep) step, spineIndex, spineTotal);
        }

        return empty(step.getType().name(), spineIndex, spineTotal);
    }

    private static JPanel train(TrainPlanStep t, int spineIndex, int spineTotal)
    {
        JPanel p = base();
        String title = "Train " + t.getSkill().getName() + " to " + t.getToLevel();

        p.add(buildHeader(title, spineIndex, spineTotal, true), BorderLayout.NORTH);

        JTextArea body = bodyArea(t.getReason());
        p.add(body, BorderLayout.CENTER);
        return p;
    }

    private static JPanel info(SpriteManager spriteManager, ClientThread clientThread, InfoPlanStep s, int spineIndex, int spineTotal)
    {
        // Render MINIQUEST with quest-like card styling for consistency.
        if (s.getType() == PlanStepType.MINIQUEST)
        {
            String title = s.getTitle() == null ? "Miniquest" : s.getTitle();
            String detail = s.getDetail();
            return MiniquestCard.compact(spriteManager, clientThread, title, detail, s.getWikiUrl(), spineIndex, spineTotal);
        }

        JPanel p = base();

        String label = labelFor(s.getType());
        String title = s.getTitle() == null ? label : s.getTitle();
        String headerTitle = label + ": " + title;

        p.add(buildHeader(headerTitle, spineIndex, spineTotal, true), BorderLayout.NORTH);

        JTextArea body = bodyArea(s.getDetail());
        body.setFont(FontManager.getRunescapeSmallFont());
        body.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        p.add(body, BorderLayout.CENTER);
        return p;
    }


    private static String labelFor(PlanStepType t)
    {
        if (t == null)
        {
            return "";
        }

        switch (t)
        {
            case QUEST: return "";
            case MINIQUEST: return "Miniquest";
            case DIARY: return "Diary";
            case TRAIN: return "Train";
            case NOTE: return "";
            default: return "";
        }
    }

    private static JPanel empty(String title, int spineIndex, int spineTotal)
    {
        JPanel p = base();
        p.add(buildHeader(title, spineIndex, spineTotal, true), BorderLayout.NORTH);
        return p;
    }

    private static JPanel base()
    {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1, 1, 1, 1, ColorScheme.DARK_GRAY_COLOR),
                BorderFactory.createEmptyBorder(8, 8, 8, 8)
        ));
        panel.setAlignmentX(Component.LEFT_ALIGNMENT);
        return panel;
    }

    
    private static JPanel buildHeader(String leftTitle, int spineIndex, int spineTotal, boolean showLongLine)
    {
        JPanel header = new JPanel();
        header.setOpaque(false);
        header.setLayout(new javax.swing.BoxLayout(header, javax.swing.BoxLayout.Y_AXIS));

        // Row 1: title (left) + progress (right)
        JPanel row1 = new JPanel(new BorderLayout());
        row1.setOpaque(false);

        JLabel title = new JLabel(leftTitle == null ? "" : leftTitle);
        title.setAlignmentX(Component.LEFT_ALIGNMENT);
        title.setFont(FontManager.getRunescapeSmallFont());
        title.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        JLabel progress = new JLabel(formatProgressCompact(spineIndex, spineTotal));
        progress.setFont(FontManager.getRunescapeSmallFont());
        progress.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);

        row1.add(title, BorderLayout.WEST);
        row1.add(progress, BorderLayout.EAST);

        header.add(row1);

        if (showLongLine)
        {
            // Row 2: "Step X of Y"
            JLabel stepLine = new JLabel(formatProgressLong(spineIndex, spineTotal));
            stepLine.setFont(FontManager.getRunescapeSmallFont());
            stepLine.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
            stepLine.setAlignmentX(Component.LEFT_ALIGNMENT);
            stepLine.setBorder(BorderFactory.createEmptyBorder(2, 0, 0, 0));
            header.add(stepLine);
        }
        return header;
    }

    private static String formatProgressCompact(int spineIndex, int spineTotal)
    {
        if (spineIndex < 0 || spineTotal <= 0)
        {
            return "";
        }
        return (spineIndex + 1) + " / " + spineTotal;
    }

    private static String formatProgressLong(int spineIndex, int spineTotal)
    {
        if (spineIndex < 0 || spineTotal <= 0)
        {
            return "";
        }
        return "Step " + (spineIndex + 1) + " of " + spineTotal;
    }


private static JTextArea bodyArea(String text)
    {
        JTextArea ta = new JTextArea(text == null ? "" : text);
        ta.setLineWrap(true);
        ta.setWrapStyleWord(true);
        ta.setEditable(false);
        ta.setFocusable(false);
        ta.setOpaque(false);
        // Keep preferred width small so the card never exceeds the sidebar.
        ta.setColumns(1);
        ta.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 8));
        ta.setAlignmentX(Component.LEFT_ALIGNMENT);
        return ta;
    }
}
package com.ironpath.ui;

import com.ironpath.model.QuestEntry;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Image;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import net.runelite.api.QuestState;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;
import java.awt.image.BufferedImage;
import javax.swing.SwingUtilities;

public final class QuestCard
{
    private static final int PAD = 10;
    private static final int ICON_SIZE = 16;

    // Fallback icon only. Real icons are pulled from the OSRS cache via SpriteManager.
    // If the resource is missing, the layout still reserves space and stays stable.
    private static final ImageIcon FALLBACK_QUEST_ICON = loadIcon("icons/quest.png");

    private QuestCard() {}

    public static JPanel summary(int completed, int total, QuestEntry recommended, QuestState state)
    {
        JPanel card = baseCard();
        card.setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.anchor = GridBagConstraints.NORTHWEST;
        c.insets = new Insets(0, 0, 0, 0);

        // Progress line (left)
        JTextArea progress = wrapTextFlush("Progress: " + completed + " / " + total, 13f, true);
        card.add(progress, c);

        // Pill (right)
        if (recommended != null)
        {
            c.gridx = 1;
            c.gridy = 0;
            c.weightx = 0;
            c.fill = GridBagConstraints.NONE;
            c.anchor = GridBagConstraints.NORTHEAST;
            card.add(wikiPill(recommended), c);
        }

        // Title + reason
        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 2;
        c.weightx = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.anchor = GridBagConstraints.NORTHWEST;
        c.insets = new Insets(8, 0, 0, 0);

        if (recommended == null)
        {
            card.add(wrapTextFlush("Quest cape achieved.", 11f, false), c);
        }
        else
        {
            JPanel body = new JPanel();
            body.setOpaque(false);
            body.setLayout(new GridBagLayout());

            GridBagConstraints b = new GridBagConstraints();
            b.gridx = 0;
            b.gridy = 0;
            b.weightx = 1;
            b.fill = GridBagConstraints.HORIZONTAL;
            b.anchor = GridBagConstraints.NORTHWEST;
            b.insets = new Insets(0, 0, 0, 0);

            body.add(wrapTextFlush(recommended.getQuestName(), 13f, true), b);

            String why = recommended.getShortWhy();
            if (why == null || why.isBlank())
            {
                why = "Next best quest in your route.";
            }

            b.gridy = 1;
            b.insets = new Insets(4, 0, 0, 0);
            body.add(wrapTextFlush(why, 11f, false), b);

            card.add(body, c);
        }

        forceFillWidth(card);
        return card;
    }

    public static JPanel compact(QuestEntry entry, QuestState state)
    {
        return compact(null, entry, state, -1, -1);
    }

    public static JPanel compact(QuestEntry entry, QuestState state, int spineIndex, int spineTotal)
    {
        return compact(null, entry, state, spineIndex, spineTotal);
    }

    public static JPanel compact(SpriteManager spriteManager, QuestEntry entry, QuestState state, int spineIndex, int spineTotal)
    {
        return compact(spriteManager, null, entry, state, spineIndex, spineTotal);
    }

    public static JPanel compact(SpriteManager spriteManager, ClientThread clientThread, QuestEntry entry, QuestState state, int spineIndex, int spineTotal)
    {
        JPanel card = baseCard();
        card.setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();
        // Row 1: icon + title (tight)
        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 2;
        c.weightx = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.anchor = GridBagConstraints.NORTHWEST;
        c.insets = new Insets(0, 0, 0, 0);
        // RuneLite SpriteID doesn't expose a consistent "QUESTS_TAB" constant across versions.
        // Use the quests page icon sprite, which is stable and matches the in-game quests UI.
        card.add(iconTitleRow(spriteManager, clientThread, SpriteID.QUESTS_PAGE_ICON_BLUE_QUESTS, FALLBACK_QUEST_ICON, entry.getQuestName()), c);

        // Row 2: "Step X of Y" (left) + Quest Guide (right)
        String stepLine = formatProgressLong(spineIndex, spineTotal);

        c.gridwidth = 1;
        c.gridy = 1;
        c.insets = new Insets(2, 0, 0, 0);

        c.gridx = 0;
        c.weightx = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        JLabel step = new JLabel(stepLine);
        step.setFont(step.getFont().deriveFont(Font.PLAIN, 10.5f));
        step.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
        card.add(step, c);

        c.gridx = 1;
        c.weightx = 0;
        c.fill = GridBagConstraints.NONE;
        c.anchor = GridBagConstraints.NORTHEAST;
        card.add(wikiPill(entry), c);

        // Reason (full width under step line)
        String why = entry.getShortWhy();
        if (why != null && !why.isBlank())
        {
            c.gridx = 0;
            c.gridy = 2;
            c.gridwidth = 2;
            c.weightx = 1;
            c.fill = GridBagConstraints.HORIZONTAL;
            c.anchor = GridBagConstraints.NORTHWEST;
            c.insets = new Insets(6, 0, 0, 0);

            card.add(wrapTextFlush(why, 11f, false), c);
        }

        forceFillWidth(card);
        return card;
    }

    private static String formatProgressCompact(int spineIndex, int spineTotal)
    {
        if (spineIndex < 0 || spineTotal <= 0)
        {
            return "";
        }
        return (spineIndex + 1) + " / " + spineTotal;
    }

    private static String formatProgressLong(int spineIndex, int spineTotal)
    {
        if (spineIndex < 0 || spineTotal <= 0)
        {
            return "";
        }
        return "Step " + (spineIndex + 1) + " of " + spineTotal;
    }

    private static JPanel baseCard()
    {
        JPanel p = new JPanel();
        p.setOpaque(true);
        p.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        p.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR, 1, true),
                BorderFactory.createEmptyBorder(PAD, PAD, PAD, PAD)
        ));
        p.setAlignmentX(Component.LEFT_ALIGNMENT);
        return p;
    }


    private static String resolveWikiUrl(QuestEntry entry)
    {
        if (entry != null)
        {
            String u = entry.getWikiUrl();
            if (u != null && !u.trim().isEmpty())
            {
                return u.trim();
            }

            String name = entry.getQuestName();
            if (name != null && !name.trim().isEmpty())
            {
                final String slug = name.trim().replace(' ', '_');
                try
                {
                    return "https://oldschool.runescape.wiki/w/" + java.net.URLEncoder.encode(slug, java.nio.charset.StandardCharsets.UTF_8)
                            .replace("+", "%20");
                }
                catch (Exception ignored)
                {
                    // fall through
                }
            }
        }
        return "https://oldschool.runescape.wiki/";
    }
    private static JTextArea wrapTextFlush(String text, float fontSize, boolean bold)
    {
        JTextArea area = new JTextArea(text == null ? "" : text);
        area.setRows(1);
        area.setOpaque(false);
        area.setEditable(false);
        area.setFocusable(false);

        area.setLineWrap(true);
        area.setWrapStyleWord(true);

        Font f = new JLabel().getFont().deriveFont(bold ? Font.BOLD : Font.PLAIN, fontSize);
        area.setFont(f);
        area.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        area.setMargin(new Insets(0, 0, 0, 0));
        area.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 8));
        // Keep preferred width small so the card never exceeds the sidebar.
        area.setColumns(1);

        return area;
    }

    private static JPanel wikiPill(QuestEntry entry)
    {
        final String url = resolveWikiUrl(entry);

        JButton b = new JButton("Quest Guide");
        b.setFocusable(false);
        b.setFont(FontManager.getRunescapeSmallFont());
        b.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        b.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        b.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                BorderFactory.createEmptyBorder(2, 6, 2, 6)
        ));
        b.addActionListener(e -> LinkBrowser.browse(url));

        JPanel wrap = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        wrap.setOpaque(false);
        wrap.add(b);

        Dimension pref = wrap.getPreferredSize();
        wrap.setMaximumSize(new Dimension(pref.width, pref.height));
        return wrap;
    }

    private static JPanel iconTitleRow(SpriteManager spriteManager, ClientThread clientThread, int spriteId, ImageIcon fallbackIcon, String titleText)
    {
        JPanel row = new JPanel(new GridBagLayout());
        row.setOpaque(false);

        GridBagConstraints r = new GridBagConstraints();
        r.gridy = 0;
        r.anchor = GridBagConstraints.NORTHWEST;
        r.insets = new Insets(0, 0, 0, 6);

        // Icon (fixed slot, prevents text jitter)
        JLabel iconLabel = buildSpriteIconLabel(spriteManager, clientThread, spriteId, fallbackIcon);
        // OSRS cache sprites often include a small amount of transparent padding.
        // Nudge the icon up slightly so it aligns better with the title text.
        iconLabel.setBorder(BorderFactory.createEmptyBorder(-2, 0, 0, 0));
        iconLabel.setPreferredSize(new Dimension(ICON_SIZE, ICON_SIZE));
        iconLabel.setMinimumSize(new Dimension(ICON_SIZE, ICON_SIZE));
        iconLabel.setMaximumSize(new Dimension(ICON_SIZE, ICON_SIZE));
        r.gridx = 0;
        r.weightx = 0;
        row.add(iconLabel, r);

        // Title (wrapping)
        r.gridx = 1;
        r.weightx = 1;
        r.fill = GridBagConstraints.HORIZONTAL;
        r.insets = new Insets(0, 0, 0, 0);
        JTextArea title = wrapTextFlush(titleText == null ? "" : titleText, 12f, true);
        // Title row is tight, so no extra right padding.
        title.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
        row.add(title, r);

        return row;
    }

    private static JLabel buildSpriteIconLabel(SpriteManager spriteManager, ClientThread clientThread, int spriteId, ImageIcon fallbackIcon)
    {
        JLabel label = new JLabel();
        label.setOpaque(false);

        if (spriteManager == null)
        {
            if (fallbackIcon != null)
            {
                label.setIcon(fallbackIcon);
            }
            return label;
        }

        // Always set fallback first so the layout is stable even if sprite loading is delayed.
        if (fallbackIcon != null)
        {
            label.setIcon(fallbackIcon);
        }

        // SpriteManager access is safest from the client thread.
        Runnable request = () ->
        {
            BufferedImage img = spriteManager.getSprite(spriteId, 0);
            if (img != null)
            {
                SwingUtilities.invokeLater(() ->
                {
                    label.setIcon(new ImageIcon(scale(img)));
                    label.revalidate();
                    label.repaint();
                });
                return;
            }

            spriteManager.getSpriteAsync(spriteId, 0, sprite ->
            {
                if (sprite == null)
                {
                    return;
                }

                SwingUtilities.invokeLater(() ->
                {
                    label.setIcon(new ImageIcon(scale(sprite)));
                    label.revalidate();
                    label.repaint();
                });
            });
        };

        if (clientThread != null)
        {
            clientThread.invokeLater(request);
        }
        else
        {
            // Best-effort if clientThread isn't available.
            request.run();
        }
        return label;
    }

    private static Image scale(java.awt.image.BufferedImage img)
    {
        return img.getScaledInstance(ICON_SIZE, ICON_SIZE, Image.SCALE_SMOOTH);
    }

    private static ImageIcon loadIcon(String relPath)
    {
        try
        {
            java.net.URL u = QuestCard.class.getResource(relPath.startsWith("/") ? relPath : "/com/ironpath/ui/" + relPath);
            if (u == null)
            {
                return null;
            }

            Image img = javax.imageio.ImageIO.read(u);
            if (img == null)
            {
                return null;
            }

            Image scaled = img.getScaledInstance(ICON_SIZE, ICON_SIZE, Image.SCALE_SMOOTH);
            return new ImageIcon(scaled);
        }
        catch (Exception ignored)
        {
            return null;
        }
    }


    private static void forceFillWidth(JPanel panel)
    {
        panel.setAlignmentX(Component.LEFT_ALIGNMENT);
        panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
    }
}
package com.ironpath.ui;

import com.ironpath.model.PlanStep;
import com.ironpath.model.SpineStepView;
import com.ironpath.model.RouteStep;
import com.ironpath.service.ProgressionPlanService;
import com.ironpath.service.QuestRouteService;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

public class IronmanPathPanel extends PluginPanel
{
    private static final int NEXT_STEPS = 10;
    private static final int REFRESH_DEBOUNCE_MS = 150;

    private final QuestRouteService routeService;
    private final ProgressionPlanService planService;
    private final ClientThread clientThread;
    private final SpriteManager spriteManager;

    private final JButton refreshButton = new JButton("Refresh");

    private final JPanel content = new ScrollablePanel();

    // Coalesce refresh requests to avoid layout thrash on login and varbit bursts.
    private final Timer refreshTimer;

    public IronmanPathPanel(QuestRouteService routeService,
                            ProgressionPlanService planService,
                            ClientThread clientThread,
                            SpriteManager spriteManager)
    {
        super();
        setLayout(new BorderLayout());
        this.routeService = routeService;
        this.planService = planService;
        this.clientThread = clientThread;
        this.spriteManager = spriteManager;

        setBackground(ColorScheme.DARK_GRAY_COLOR);

        add(buildHeader(), BorderLayout.NORTH);
        add(buildBody(), BorderLayout.CENTER);

        refreshTimer = new Timer(REFRESH_DEBOUNCE_MS, e -> refreshNow());
        refreshTimer.setRepeats(false);

        refreshButton.addActionListener(e -> requestRefresh());

        requestRefresh();
    }

    /**
     * Request a UI refresh. Multiple calls within a short window are coalesced into a single rebuild.
     */
    public void requestRefresh()
    {
        if (!SwingUtilities.isEventDispatchThread())
        {
            SwingUtilities.invokeLater(this::requestRefresh);
            return;
        }

        refreshTimer.restart();
    }

    /**
     * Show a stable placeholder while the client state settles (login bursts).
     */
    public void showLoading()
    {
        SwingUtilities.invokeLater(() ->
        {
            content.setVisible(false);
            content.removeAll();

            JPanel body = new JPanel();
            body.setOpaque(false);
            body.setLayout(new BoxLayout(body, BoxLayout.Y_AXIS));

            JLabel label = new JLabel("Loading player state...");
            label.setAlignmentX(Component.LEFT_ALIGNMENT);
            body.add(label);

            content.add(buildSection("Next 10 steps", body));
            content.setVisible(true);
            content.revalidate();
            content.repaint();
        });
    }

    private void refreshNow()
    {
        clientThread.invokeLater(() ->
        {
            List<RouteStep> spine = routeService.getSpine();
            List<SpineStepView> next = planService.buildNextStepViews(spine, NEXT_STEPS);

            SwingUtilities.invokeLater(() ->
            {
                content.setVisible(false);
                content.removeAll();
                content.add(buildSection("Next 10 steps", renderNext(next)));
                content.setVisible(true);
                content.revalidate();
                content.repaint();
            });
        });
    }

    private JPanel buildHeader()
    {
        JPanel header = new JPanel(new BorderLayout());
        header.setBackground(ColorScheme.DARK_GRAY_COLOR);
        header.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));

        JPanel left = new JPanel();
        left.setOpaque(false);
        left.setLayout(new BoxLayout(left, BoxLayout.Y_AXIS));

        JLabel title = new JLabel("Optimal Quest Order");
        title.setForeground(ColorScheme.BRAND_ORANGE);

        JLabel subtitle = new JLabel("Order is optimized following OSRS Wiki.");
        subtitle.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
        subtitle.setFont(FontManager.getRunescapeSmallFont());

        title.setAlignmentX(Component.LEFT_ALIGNMENT);
        subtitle.setAlignmentX(Component.LEFT_ALIGNMENT);
        refreshButton.setAlignmentX(Component.LEFT_ALIGNMENT);

        left.add(title);
        left.add(Box.createVerticalStrut(2));
        left.add(subtitle);
        left.add(Box.createVerticalStrut(6));
        left.add(refreshButton);

        header.add(left, BorderLayout.WEST);
        return header;
    }

    private JScrollPane buildBody()
    {
        content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));
        content.setOpaque(false);
        content.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));

        JScrollPane scroll = new JScrollPane(content);
        scroll.setBorder(null);
        scroll.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scroll.getVerticalScrollBar().setUnitIncrement(16);
        return scroll;
    }

    private JPanel buildSection(String title, JPanel body)
    {
        JPanel section = new JPanel();
        section.setOpaque(false);
        section.setLayout(new BoxLayout(section, BoxLayout.Y_AXIS));

        JLabel label = new JLabel(title);
        label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        label.setAlignmentX(Component.LEFT_ALIGNMENT);

        section.add(label);
        section.add(Box.createVerticalStrut(6));
        section.add(body);

        return section;
    }

    private JPanel renderNext(List<SpineStepView> steps)
    {
        JPanel body = new JPanel();
        body.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
        body.setOpaque(false);
        body.setLayout(new BoxLayout(body, BoxLayout.Y_AXIS));

        for (SpineStepView v : steps)
        {
            PlanStep s = v.getStep();
            if (s == null)
            {
                continue;
            }

            JPanel card = PlanStepCard.compact(spriteManager, clientThread, v);
            forceFillWidth(card);
            body.add(card);
            body.add(Box.createVerticalStrut(6));
        }

        if (steps.isEmpty())
        {
            JLabel none = new JLabel("No remaining steps.");
            none.setAlignmentX(Component.LEFT_ALIGNMENT);
            body.add(none);
        }

        return body;
    }

    private static void forceFillWidth(JPanel panel)
    {
        panel.setAlignmentX(Component.LEFT_ALIGNMENT);
        // Allow BoxLayout to compute height naturally (wrapped text needs a real width before preferred height is correct).
        panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
    }
}

package com.ironpath.ui;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Image;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;
import java.awt.image.BufferedImage;
import net.runelite.api.SpriteID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;

/**
 * Quest-like card styling for MINIQUEST steps.
 * Pure UI component: does not change planner behavior.
 */
public final class MiniquestCard
{
    private static final int ICON_SIZE = 16;

    // Fallback icon only. Real icons are pulled from the OSRS cache via SpriteManager.
    // If the resource is missing, the layout still reserves space and stays stable.
    private static final ImageIcon FALLBACK_MINIQUEST_ICON = loadIcon("icons/miniquest.png");

    private MiniquestCard() {}

    public static JPanel compact(String titleText, String detail, int spineIndex, int spineTotal)
    {
        return compact(null, titleText, detail, null, spineIndex, spineTotal);
    }

    public static JPanel compact(SpriteManager spriteManager, String titleText, String detail, String wikiUrl, int spineIndex, int spineTotal)
    {
        return compact(spriteManager, null, titleText, detail, wikiUrl, spineIndex, spineTotal);
    }

    public static JPanel compact(SpriteManager spriteManager, ClientThread clientThread, String titleText, String detail, String wikiUrl, int spineIndex, int spineTotal)
    {
        // Use the quests page icon sprite from the OSRS cache.
        return compact(spriteManager, clientThread, titleText, detail, wikiUrl, spineIndex, spineTotal, SpriteID.QUESTS_PAGE_ICON_BLUE_QUESTS);
    }

    public static JPanel compact(String titleText, String detail, String wikiUrl, int spineIndex, int spineTotal)
    {
        return compact(null, titleText, detail, wikiUrl, spineIndex, spineTotal);
    }

    private static JPanel compact(SpriteManager spriteManager, ClientThread clientThread, String titleText, String detail, String wikiUrl, int spineIndex, int spineTotal, int spriteId)
    {
        JPanel card = baseCard();
        card.setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();

        // Row 1: icon + title (tight)
        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 2;
        c.weightx = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.anchor = GridBagConstraints.NORTHWEST;
        c.insets = new Insets(0, 0, 0, 0);
        card.add(iconTitleRow(spriteManager, clientThread, spriteId, FALLBACK_MINIQUEST_ICON, titleText == null ? "" : titleText), c);

        // Row 2: "Step X of Y" (left) + Quest Guide (right, if present)
        String stepLine = formatProgressLong(spineIndex, spineTotal);

        c.gridwidth = 1;
        c.gridy = 1;
        c.insets = new Insets(2, 0, 0, 0);

        c.gridx = 0;
        c.weightx = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        JLabel step = new JLabel(stepLine);
        step.setFont(step.getFont().deriveFont(Font.PLAIN, 10.5f));
        step.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
        card.add(step, c);

        if (wikiUrl != null && !wikiUrl.trim().isEmpty())
        {
            c.gridx = 1;
            c.weightx = 0;
            c.fill = GridBagConstraints.NONE;
            c.anchor = GridBagConstraints.NORTHEAST;
            card.add(wikiPill(wikiUrl), c);
        }

        // Detail text (full width)
        if (detail != null && !detail.isBlank())
        {
            c.gridx = 0;
            c.gridy = 2;
            c.gridwidth = 2;
            c.weightx = 1;
            c.fill = GridBagConstraints.HORIZONTAL;
            c.anchor = GridBagConstraints.NORTHWEST;
            c.insets = new Insets(6, 0, 0, 0);

            card.add(wrapTextFlush(detail, 11f, false), c);
        }

        return card;
    }

    private static String formatProgressCompact(int spineIndex, int spineTotal)
    {
        if (spineIndex < 0 || spineTotal <= 0)
        {
            return "";
        }
        return (spineIndex + 1) + " / " + spineTotal;
    }

    private static String formatProgressLong(int spineIndex, int spineTotal)
    {
        if (spineIndex < 0 || spineTotal <= 0)
        {
            return "";
        }
        return "Step " + (spineIndex + 1) + " of " + spineTotal;
    }

    private static JPanel baseCard()
    {
        JPanel p = new JPanel();
        p.setOpaque(true);
        p.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        p.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createEmptyBorder(10, 10, 10, 10)
        ));
        p.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
        return p;
    }

    private static JTextArea wrapTextFlush(String text, float fontSize, boolean bold)
    {
        JTextArea area = new JTextArea(text);
        area.setRows(1);
        area.setOpaque(false);
        area.setEditable(false);
        area.setFocusable(false);

        area.setLineWrap(true);
        area.setWrapStyleWord(true);

        Font f = new JLabel().getFont().deriveFont(bold ? Font.BOLD : Font.PLAIN, fontSize);
        area.setFont(f);
        area.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        area.setMargin(new Insets(0, 0, 0, 0));
        area.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 8));
        // Keep preferred width small so the card never exceeds the sidebar.
        area.setColumns(1);

        return area;
    }

    private static JPanel iconTitleRow(SpriteManager spriteManager, ClientThread clientThread, int spriteId, ImageIcon fallbackIcon, String titleText)
    {
        JPanel row = new JPanel(new GridBagLayout());
        row.setOpaque(false);

        GridBagConstraints r = new GridBagConstraints();
        r.gridy = 0;
        r.anchor = GridBagConstraints.NORTHWEST;
        r.insets = new Insets(0, 0, 0, 6);

        JLabel iconLabel = buildSpriteIconLabel(spriteManager, clientThread, spriteId, fallbackIcon);
        // OSRS cache sprites often include a small amount of transparent padding.
        // Nudge the icon up slightly so it aligns better with the title text.
        iconLabel.setBorder(BorderFactory.createEmptyBorder(-2, 0, 0, 0));
        iconLabel.setPreferredSize(new Dimension(ICON_SIZE, ICON_SIZE));
        iconLabel.setMinimumSize(new Dimension(ICON_SIZE, ICON_SIZE));
        iconLabel.setMaximumSize(new Dimension(ICON_SIZE, ICON_SIZE));

        r.gridx = 0;
        r.weightx = 0;
        row.add(iconLabel, r);

        r.gridx = 1;
        r.weightx = 1;
        r.fill = GridBagConstraints.HORIZONTAL;
        r.insets = new Insets(0, 0, 0, 0);
        JTextArea title = wrapTextFlush(titleText == null ? "" : titleText, 12f, true);
        title.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
        row.add(title, r);

        return row;
    }

    private static JLabel buildSpriteIconLabel(SpriteManager spriteManager, ClientThread clientThread, int spriteId, ImageIcon fallbackIcon)
    {
        JLabel label = new JLabel();
        label.setOpaque(false);

        if (spriteManager == null)
        {
            if (fallbackIcon != null)
            {
                label.setIcon(fallbackIcon);
            }
            return label;
        }

        // Always set fallback first so the layout is stable even if sprite loading is delayed.
        if (fallbackIcon != null)
        {
            label.setIcon(fallbackIcon);
        }

        // SpriteManager access is safest from the client thread.
        Runnable request = () ->
        {
            BufferedImage img = spriteManager.getSprite(spriteId, 0);
            if (img != null)
            {
                SwingUtilities.invokeLater(() ->
                {
                    label.setIcon(new ImageIcon(scale(img)));
                    label.revalidate();
                    label.repaint();
                });
                return;
            }

            spriteManager.getSpriteAsync(spriteId, 0, sprite ->
            {
                if (sprite == null)
                {
                    return;
                }

                SwingUtilities.invokeLater(() ->
                {
                    label.setIcon(new ImageIcon(scale(sprite)));
                    label.revalidate();
                    label.repaint();
                });
            });
        };

        if (clientThread != null)
        {
            clientThread.invokeLater(request);
        }
        else
        {
            request.run();
        }
        return label;
    }

    private static Image scale(BufferedImage img)
    {
        return img.getScaledInstance(ICON_SIZE, ICON_SIZE, Image.SCALE_SMOOTH);
    }

    private static JPanel wikiPill(String wikiUrl)
    {
        JButton b = new JButton("Quest Guide");
        b.setFocusable(false);
        b.setFont(FontManager.getRunescapeSmallFont());
        b.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        b.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        b.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                BorderFactory.createEmptyBorder(2, 6, 2, 6)
        ));
        b.addActionListener(e -> LinkBrowser.browse(wikiUrl.trim()));

        JPanel wrap = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        wrap.setOpaque(false);
        wrap.add(b);

        Dimension pref = wrap.getPreferredSize();
        wrap.setMaximumSize(new Dimension(pref.width, pref.height));
        return wrap;
    }

    private static ImageIcon loadIcon(String relPath)
    {
        try
        {
            java.net.URL u = MiniquestCard.class.getResource(relPath.startsWith("/") ? relPath : "/com/ironpath/ui/" + relPath);
            if (u == null)
            {
                return null;
            }

            Image img = javax.imageio.ImageIO.read(u);
            if (img == null)
            {
                return null;
            }

            Image scaled = img.getScaledInstance(ICON_SIZE, ICON_SIZE, Image.SCALE_SMOOTH);
            return new ImageIcon(scaled);
        }
        catch (Exception ignored)
        {
            return null;
        }
    }
}

package com.ironpath.ui;

import java.awt.Dimension;
import java.awt.Rectangle;
import javax.swing.JPanel;
import javax.swing.Scrollable;

/**
 * A JPanel that tracks the viewport width inside a JScrollPane.
 *
 * This prevents horizontal clipping when child components report a wide
 * preferred size (e.g., wrapped JTextArea + BoxLayout in the RuneLite sidebar).
 */
public class ScrollablePanel extends JPanel implements Scrollable
{
    @Override
    public Dimension getPreferredScrollableViewportSize()
    {
        // RuneLite's sidebar layout can honor a scrollpane's preferred size. During a refresh
        // (e.g., after removeAll() and before all cards are re-added), our preferred height can
        // momentarily shrink to a single card, causing the entire list area to collapse.
        //
        // Provide a stable minimum viewport height so the scroll area stays full-sized.
        Dimension pref = getPreferredSize();

        int minH = 400;
        if (getParent() != null)
        {
            // If we're already inside a viewport, prefer its current height.
            minH = Math.max(minH, getParent().getHeight());
        }

        return new Dimension(pref.width, Math.max(pref.height, minH));
    }

    @Override
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction)
    {
        return 16;
    }

    @Override
    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction)
    {
        return Math.max(visibleRect.height - 32, 32);
    }

    @Override
    public boolean getScrollableTracksViewportWidth()
    {
        return true;
    }

    @Override
    public boolean getScrollableTracksViewportHeight()
    {
        return false;
    }
}

package com.ironpath.ui;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class CollapsibleSection<T> extends JPanel
{
    private final JPanel bodyWrap = new JPanel(new BorderLayout());
    private boolean expanded = true;

    public CollapsibleSection(String title, int count, JPanel body)
    {
        setLayout(new BorderLayout());
        setOpaque(false);

        JPanel header = new JPanel(new BorderLayout());
        header.setOpaque(false);
        header.setBorder(BorderFactory.createEmptyBorder(6, 0, 6, 0));

        JLabel label = new JLabel(title + " (" + count + ")");
        label.setAlignmentX(Component.LEFT_ALIGNMENT);
        header.add(label, BorderLayout.WEST);

        JButton toggle = new JButton("Hide");
        toggle.addActionListener(e ->
        {
            expanded = !expanded;
            bodyWrap.setVisible(expanded);
            toggle.setText(expanded ? "Hide" : "Show");
            revalidate();
            repaint();
        });
        header.add(toggle, BorderLayout.EAST);

        add(header, BorderLayout.NORTH);

        bodyWrap.setOpaque(false);
        bodyWrap.add(body, BorderLayout.CENTER);
        add(bodyWrap, BorderLayout.CENTER);

        forceFillWidth(this);
    }

    private static void forceFillWidth(JPanel panel)
    {
        panel.setAlignmentX(Component.LEFT_ALIGNMENT);
        Dimension pref = panel.getPreferredSize();
        panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, pref.height));
    }
}

package com.ironpath.overlay;

import com.ironpath.IronmanPathConfig;
import com.ironpath.model.InfoPlanStep;
import com.ironpath.model.PlanStep;
import com.ironpath.model.SpineStepView;
import com.ironpath.model.PlanStepType;
import com.ironpath.model.QuestPlanStep;
import com.ironpath.model.TrainPlanStep;
import com.ironpath.service.ProgressionPlanService;
import com.ironpath.service.QuestRouteService;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.QuestState;
import net.runelite.api.SpriteID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.PanelComponent;

import java.util.ArrayList;

/**
 * Displays the current active step (first step in the Next N list) in the game view.
 *
 * This intentionally reuses the same PlanStep fields that the sidebar cards render
 * (QuestEntry.shortWhy, TrainPlanStep.reason, InfoPlanStep.detail). No new model accessors.
 */
public class ActiveStepOverlay extends OverlayPanel
{
    private static final int MAX_WIDTH = 240;
    private static final int WRAP_CHARS = 44;

    private static final int PAD = 8;
    private static final int ICON_SIZE = 16;
    private static final int ICON_GAP = 6;
    private static final int LINE_GAP = 3;

    // Cache OSRS sprites for overlay rendering to avoid flicker on refresh.
    private static final Map<Integer, BufferedImage> SPRITE_CACHE = new ConcurrentHashMap<>();
    private static final Set<Integer> SPRITE_IN_FLIGHT = ConcurrentHashMap.newKeySet();

    private final Client client;
    private final IronmanPathConfig config;
    private final QuestRouteService routeService;
    private final ProgressionPlanService planService;

    private final ClientThread clientThread;
    private final SpriteManager spriteManager;

    @Inject
    public ActiveStepOverlay(
            Client client,
            IronmanPathConfig config,
            QuestRouteService routeService,
            ProgressionPlanService planService,
            ClientThread clientThread,
            SpriteManager spriteManager)
    {
        this.client = client;
        this.config = config;
        this.routeService = routeService;
        this.planService = planService;
        this.clientThread = clientThread;
        this.spriteManager = spriteManager;

        setPosition(OverlayPosition.TOP_RIGHT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        PanelComponent pc = getPanelComponent();
        pc.setBackgroundColor(ColorScheme.DARKER_GRAY_COLOR);
        pc.setPreferredSize(new Dimension(MAX_WIDTH, 0));
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.showActiveStepOverlay())
        {
            return null;
        }

        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return null;
        }

        final List<SpineStepView> next = planService.buildNextStepViews(routeService.getSpine(), 1);
        if (next.isEmpty())
        {
            return null;
        }

        final SpineStepView view = next.get(0);
        final PlanStep step = view.getStep();
        final PanelComponent pc = getPanelComponent();
        // We draw a custom overlay that mirrors the quest card layout:
        // Row 1: [icon] Title
        // Row 2: "Step X of Y" (left) and "Quest Guide" (right)
        // Body: why text wrapped
        pc.getChildren().clear();

        final int stepNum = view.getSpineIndex() + 1;
        final int total = view.getSpineTotal();

        String title;
        String why = null;
        boolean showQuestIcon = false;

        if (step instanceof QuestPlanStep)
        {
            QuestPlanStep q = (QuestPlanStep) step;
            title = q.getEntry().getQuestName();
            why = q.getEntry().getShortWhy();
            showQuestIcon = true;
        }
        else if (step instanceof TrainPlanStep)
        {
            TrainPlanStep t = (TrainPlanStep) step;
            title = "Train " + t.getSkill().getName() + " to " + t.getToLevel();
            why = t.getReason();
        }
        else if (step instanceof InfoPlanStep)
        {
            InfoPlanStep s = (InfoPlanStep) step;
            String label = labelFor(s.getType());
            String t = s.getTitle() == null ? "" : s.getTitle();
            title = label.isEmpty() ? t : (label + ": " + t);
            why = s.getDetail();
        }
        else
        {
            title = step.getType().name();
        }

        // Render
        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        final Font base = graphics.getFont();
        final Font titleFont = base.deriveFont(Font.BOLD, base.getSize2D());
        final Font bodyFont = base.deriveFont(Font.PLAIN, base.getSize2D());

        final int width = MAX_WIDTH;
        int x = PAD;
        int y = PAD;

        // Pre-wrap body
        final List<String> wrapped = (why == null || why.isBlank()) ? new ArrayList<>() : wrap(why);

        // Measure
        graphics.setFont(titleFont);
        FontMetrics titleFm = graphics.getFontMetrics();
        int titleLineH = titleFm.getHeight();

        graphics.setFont(bodyFont);
        FontMetrics bodyFm = graphics.getFontMetrics();
        int bodyLineH = bodyFm.getHeight();

        int headerH = titleLineH + LINE_GAP + bodyLineH;
        int bodyH = wrapped.size() * bodyLineH;
        int height = PAD + headerH + (wrapped.isEmpty() ? 0 : (LINE_GAP + bodyH)) + PAD;

        // Background box (match sidebar card feel)
        graphics.setColor(ColorScheme.DARKER_GRAY_COLOR);
        graphics.fillRoundRect(0, 0, width, height, 10, 10);

        // Icon
        BufferedImage icon = null;
        if (showQuestIcon)
        {
            icon = getOrRequestSprite(SpriteID.QUESTS_PAGE_ICON_BLUE_QUESTS);
        }

        graphics.setColor(java.awt.Color.WHITE);

        // Row 1: icon + title
        int titleBaseline = y + titleFm.getAscent();
        int titleX = x;
        if (icon != null)
        {
            // Nudge icon up to match the card alignment
            int iconY = y - 4;
            graphics.drawImage(icon, x, iconY, ICON_SIZE, ICON_SIZE, null);
            titleX += ICON_SIZE + ICON_GAP;
        }

        graphics.setFont(titleFont);
        graphics.drawString(title, titleX, titleBaseline);

        // Row 2: Step X of Y (left) and Quest Guide (right)
        y += titleLineH + LINE_GAP;
        graphics.setFont(bodyFont);
        int row2Baseline = y + bodyFm.getAscent();

        String stepText = "Step " + stepNum + " of " + total;
        graphics.drawString(stepText, x, row2Baseline);

        // Mirror the card's right-side "Quest Guide" affordance for quest steps.
        if (showQuestIcon)
        {
            String guide = "Quest Guide";
            int guideW = bodyFm.stringWidth(guide);
            graphics.drawString(guide, width - PAD - guideW, row2Baseline);
        }

        // Body why text
        if (!wrapped.isEmpty())
        {
            y += bodyLineH + LINE_GAP;
            int lineY = y + bodyFm.getAscent();
            for (String line : wrapped)
            {
                graphics.drawString(line, x, lineY);
                lineY += bodyLineH;
            }
        }

        return new Dimension(width, height);
    }

    private static List<String> wrap(String text)
    {
        final ArrayList<String> lines = new ArrayList<>();
        if (text == null)
        {
            return lines;
        }

        String remaining = text.trim();
        while (remaining.length() > WRAP_CHARS)
        {
            int split = remaining.lastIndexOf(' ', WRAP_CHARS);
            if (split <= 0)
            {
                split = WRAP_CHARS;
            }

            lines.add(remaining.substring(0, split).trim());
            remaining = remaining.substring(split).trim();
        }

        if (!remaining.isEmpty())
        {
            lines.add(remaining);
        }
        return lines;
    }

    private static String labelFor(PlanStepType t)
    {
        if (t == null)
        {
            return "";
        }

        switch (t)
        {
            case MINIQUEST:
                return "Miniquest";
            case DIARY:
                return "Diary";
            case TRAIN:
                return "Train";
            case NOTE:
                return "Note";
            case UNLOCK:
                return "Unlock";
            case LAMP:
                return "Lamp";
            default:
                return "";
        }
    }

    private BufferedImage getOrRequestSprite(int spriteId)
    {
        BufferedImage cached = SPRITE_CACHE.get(spriteId);
        if (cached != null)
        {
            return cached;
        }

        if (spriteManager == null)
        {
            return null;
        }

        if (!SPRITE_IN_FLIGHT.add(spriteId))
        {
            return null;
        }

        Runnable request = () ->
        {
            BufferedImage img = spriteManager.getSprite(spriteId, 0);
            if (img != null)
            {
                SPRITE_CACHE.put(spriteId, img);
                SPRITE_IN_FLIGHT.remove(spriteId);
                return;
            }

            spriteManager.getSpriteAsync(spriteId, 0, sprite ->
            {
                if (sprite != null)
                {
                    SPRITE_CACHE.put(spriteId, sprite);
                }
                SPRITE_IN_FLIGHT.remove(spriteId);
            });
        };

        if (clientThread != null)
        {
            clientThread.invokeLater(request);
        }
        else
        {
            request.run();
        }

        return null;
    }
}

package com.ironpath;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("ironmanpath")
public interface IronmanPathConfig extends Config
{
    @ConfigItem(
            keyName = "showActiveStepOverlay",
            name = "Show active step overlay",
            description = "Show the current active step (next unfinished route step) as an overlay in the top-right of the game view."
    )
    default boolean showActiveStepOverlay()
    {
        return false;
    }
}

package com.ironpath.service;

import com.google.inject.Singleton;
import com.ironpath.model.PlanSnapshot;
import com.ironpath.model.QuestBlocker;
import com.ironpath.model.QuestEntry;
import com.ironpath.model.QuestReadiness;
import com.ironpath.model.QuestRow;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;

@Singleton
public class QuestPlannerService
{
    private final Client client;
    private final QuestStatusService statusService;

    @Inject
    public QuestPlannerService(Client client, QuestStatusService statusService)
    {
        this.client = client;
        this.statusService = statusService;
    }

    public PlanSnapshot compute(List<QuestEntry> route)
    {
        final List<QuestRow> inProgress = new ArrayList<>();
        final List<QuestRow> ready = new ArrayList<>();
        final List<QuestRow> blocked = new ArrayList<>();
        final List<QuestRow> done = new ArrayList<>();

        int completed = 0;
        int i = 0;
        for (QuestEntry e : route)
        {
            final QuestState qs = statusService.getState(e);
            if (qs == QuestState.FINISHED)
            {
                completed++;
            }

            final List<QuestBlocker> blockersForQuest = computeBlockers(e);
            final QuestReadiness readiness = computeReadiness(qs, blockersForQuest);
            final double score = score(e, qs, readiness, blockersForQuest, i);
            final QuestRow row = new QuestRow(e, qs, readiness, blockersForQuest, score, i);

            switch (readiness)
            {
                case DONE:
                    done.add(row);
                    break;
                case IN_PROGRESS:
                    inProgress.add(row);
                    break;
                case READY:
                    ready.add(row);
                    break;
                case BLOCKED:
                default:
                    blocked.add(row);
                    break;
            }
            i++;
        }

        // Choose recommended quest: in-progress first, else best scored READY, else best scored BLOCKED.
        QuestRow recommended = null;
        if (!inProgress.isEmpty())
        {
            recommended = inProgress.stream().max(Comparator.comparingDouble(QuestRow::getScore)).orElse(null);
        }
        if (recommended == null)
        {
            recommended = ready.stream().max(Comparator.comparingDouble(QuestRow::getScore)).orElse(null);
        }
        if (recommended == null)
        {
            recommended = blocked.stream().max(Comparator.comparingDouble(QuestRow::getScore)).orElse(null);
        }

        // Sort each bucket for stable UX.
        final Comparator<QuestRow> byPriority = Comparator
                .comparingDouble(QuestRow::getScore).reversed()
                .thenComparingInt(QuestRow::getRouteIndex);

        inProgress.sort(byPriority);
        ready.sort(byPriority);
        blocked.sort(byPriority);
        done.sort(Comparator.comparingInt(QuestRow::getRouteIndex));

        return new PlanSnapshot(completed, route.size(), recommended, inProgress, ready, blocked, done);
    }

    private List<QuestBlocker> computeBlockers(QuestEntry entry)
    {
        final List<QuestBlocker> blockers = new ArrayList<>();

        // Prerequisite quests (tracked subset).
        for (String prereq : entry.getPrereqQuestNames())
        {
            if (prereq == null || prereq.isBlank())
            {
                continue;
            }
            final QuestState st = statusService.getStateByName(prereq);
            if (st != QuestState.FINISHED)
            {
                blockers.add(QuestBlocker.prereqQuest(prereq));
            }
        }

        // Skill requirements (tracked subset).
        for (var req : entry.getMinSkills().entrySet())
        {
            final Skill s = req.getKey();
            final int need = req.getValue() == null ? 0 : req.getValue();
            if (need <= 0)
            {
                continue;
            }
            final int have = client.getRealSkillLevel(s);
            if (have < need)
            {
                blockers.add(QuestBlocker.skill(s, have, need));
            }
        }

        return blockers;
    }

    private static QuestReadiness computeReadiness(QuestState questState, List<QuestBlocker> blockers)
    {
        if (questState == QuestState.FINISHED)
        {
            return QuestReadiness.DONE;
        }
        if (questState == QuestState.IN_PROGRESS)
        {
            return QuestReadiness.IN_PROGRESS;
        }
        if (blockers == null || blockers.isEmpty())
        {
            return QuestReadiness.READY;
        }
        return QuestReadiness.BLOCKED;
    }

    private static double score(QuestEntry e, QuestState qs, QuestReadiness readiness, List<QuestBlocker> blockers, int routeIndex)
    {
        // Base bias: earlier in the route is generally better for the MVP.
        double score = 10000 - routeIndex;

        // State bias.
        if (qs == QuestState.IN_PROGRESS)
        {
            score += 1000;
        }

        // Readiness bias.
        switch (readiness)
        {
            case READY:
                score += 500;
                break;
            case BLOCKED:
                score -= 250;
                break;
            case DONE:
                score -= 10_000;
                break;
            case IN_PROGRESS:
                score += 750;
                break;
            default:
                break;
        }

        // Penalty for missing levels, scaled by deficit.
        int deficit = 0;
        if (blockers != null)
        {
            for (QuestBlocker b : blockers)
            {
                if (b.getType() == QuestBlocker.Type.SKILL_LEVEL)
                {
                    deficit += Math.max(0, b.getNeed() - b.getHave());
                }
                else
                {
                    deficit += 3; // rough cost per missing prerequisite
                }
            }
        }
        score -= deficit * 40;

        // Tags bias.
        if (e.getTags().contains("combatxp")) score += 200;
        if (e.getTags().contains("unlock")) score += 200;
        if (e.getTags().contains("capstone")) score -= 150;
        if (e.getTags().contains("grandmaster")) score -= 100;
        if (e.getTags().contains("early")) score += 100;

        return score;
    }
}

package com.ironpath.service;

import com.google.inject.Singleton;
import com.ironpath.model.InfoPlanStep;
import com.ironpath.model.PlanStep;
import com.ironpath.model.SpineStepView;
import com.ironpath.model.PlanStepType;
import com.ironpath.model.QuestEntry;
import com.ironpath.model.QuestPlanStep;
import com.ironpath.model.RouteStep;
import com.ironpath.model.TrainPlanStep;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import com.ironpath.service.QuestDatabase;

/**
 * Builds an actionable "next steps" plan from the canonical route spine.
 *
 * Behavior:
 * - Produces a deterministic list of up to N steps.
 * - Steps are either a quest, an explicit training gate, or a non-quest informational step.
 * - Simulates completion in sequence to produce a coherent list.
 *
 * Simulation details:
 * - Finished quests are detected via {@link QuestStatusService}.
 * - Non-quest steps are not verifiable; the planner assumes completion once shown.
 * - Quest XP rewards (from {@link QuestDatabase}) are applied to simulated levels so that
 *   later requirements can be satisfied by earlier quest rewards.
 */
@Singleton
public class ProgressionPlanService
{
    /**
     * When a user is behind the spine's expected skill levels, avoid inserting a single massive training wall.
     * Instead, emit catch-up training in small chunks so the plan stays readable and motivational.
     */
    private static final int CATCH_UP_MAX_LEVEL_DELTA_PER_STEP = 5;

    private static final Pattern LAMP_ON_PATTERN = Pattern.compile("(?i)\\blamp\\s+on\\s+([a-z ]+)\\b");

    private final Client client;
    private final QuestStatusService statusService;
    private final QuestDatabase questDatabase;
    private final StepCompletionService completionService;


    @Inject
    public ProgressionPlanService(Client client, QuestStatusService statusService, QuestDatabase questDatabase, StepCompletionService completionService)
    {
        this.client = client;
        this.statusService = statusService;
        this.questDatabase = questDatabase;
        this.completionService = completionService;
    }

    
    public List<PlanStep> buildNextSteps(List<RouteStep> spine, int maxSteps)
    {
        List<SpineStepView> views = buildNextStepViews(spine, maxSteps);
        List<PlanStep> steps = new ArrayList<>(views.size());
        for (SpineStepView v : views)
        {
            steps.add(v.getStep());
        }
        return steps;
    }

    public List<SpineStepView> buildNextStepViews(List<RouteStep> spine, int maxSteps)
    {
        final List<SpineStepView> steps = new ArrayList<>();
        if (spine == null || spine.isEmpty() || maxSteps <= 0)
        {
            return steps;
        }

        for (int i = 0; i < spine.size() && steps.size() < maxSteps; i++)
        {
            final RouteStep step = spine.get(i);
            if (step == null)
            {
                continue;
            }

            final PlanStepType type = step.getType();

            // QUEST steps: only skip if the journal says finished.
            if (type == PlanStepType.QUEST && step.getQuest() != null)
            {
                final Quest q = step.getQuest();
                final QuestState state = statusService.getState(new QuestEntry(q, mergedWhy(step), resolveWikiUrl(step, q.getName())));
                if (state == QuestState.FINISHED)
                {
                    continue;
                }

                final QuestEntry qe = new QuestEntry(q, mergedWhy(step), resolveWikiUrl(step, q.getName()));
                steps.add(new SpineStepView(new QuestPlanStep(qe, state), i, spine.size()));
                continue;
            }

            // Non-quest steps: use explicit completion checks where available.
            if (completionService.isComplete(step))
            {
                continue;
            }

            // TRAIN steps: skip if current level meets the target.
            if (type == PlanStepType.TRAIN && step.getSkill() != null)
            {
                final Skill skill = step.getSkill();
                // Use real levels only; temporary boosts should not suppress TRAIN steps.
                final int have = safeRealLevel(skill);
                final int target = step.getToLevel();
                if (have >= target)
                {
                    continue;
                }

                steps.add(new SpineStepView(new TrainPlanStep(skill, have, target, mergedWhy(step)), i, spine.size()));
                continue;
            }

            // Generic informational step.
            final String why = mergedWhy(step);
            steps.add(new SpineStepView(InfoPlanStep.builder(type)
                .title(step.getDisplayName())
                .detail(why)
                .wikiUrl(step.getWikiUrl())
                .build(), i, spine.size()));

            // If the step text includes lamp instructions, surface them explicitly.
            final String lamp = extractLampInstruction(why);
            if (lamp != null)
            {
                steps.add(new SpineStepView(InfoPlanStep.builder(PlanStepType.LAMP)
                    .title("Use lamp")
                    .detail(lamp)
                    .build(), i, spine.size()));
            }
        }

        return steps;
    }


    private static String safeTitle(RouteStep s)
    {
        if (s.getDisplayName() != null && !s.getDisplayName().trim().isEmpty())
        {
            return s.getDisplayName().trim();
        }
        if (s.getType() == PlanStepType.QUEST && s.getQuest() != null)
        {
            return s.getQuest().getName();
        }
        if (s.getType() == PlanStepType.TRAIN && s.getSkill() != null && s.getToLevel() != null)
        {
            return "Train " + s.getSkill().getName() + " to " + s.getToLevel();
        }
        return s.getType().name();
    }

    private int safeRealLevel(Skill skill)
    {
        if (skill == null)
        {
            return 1;
        }

        try
        {
            return Math.max(1, client.getRealSkillLevel(skill));
        }
        catch (Exception e)
        {
            return 1;
        }
    }


    private RouteStep nextUnfinished(List<RouteStep> spine, int startIdx,
                                     Set<Quest> simulatedFinished,
                                     Map<Skill, Integer> simulatedLevels)
    {
        for (int i = startIdx; i < spine.size(); i++)
        {
            RouteStep s = spine.get(i);
            if (s == null)
            {
                continue;
            }

            if (s.getType() == PlanStepType.QUEST && s.getQuest() != null)
            {
                if (!simulatedFinished.contains(s.getQuest()))
                {
                    return s;
                }
            }
            else if (s.getType() == PlanStepType.TRAIN && s.getSkill() != null && s.getToLevel() != null)
            {
                int have = simulatedLevels.getOrDefault(s.getSkill(), 1);
                if (have < s.getToLevel())
                {
                    return s;
                }
                // else already done
            }
            else
            {
                // Non-quest steps are not verifiable, but a small subset can be inferred from account state.
                // If inferred complete, skip it so the quest spine remains clean.
                if (completionService.isComplete(s))
                {
                    continue;
                }

                // Otherwise treat as unfinished until shown.
                return s;
            }
        }
        return null;
    }

    private static int indexOf(List<RouteStep> spine, RouteStep step)
    {
        // RouteStep is immutable and small; linear search is OK at plugin scale.
        for (int i = 0; i < spine.size(); i++)
        {
            if (spine.get(i) == step)
            {
                return i;
            }
        }
        return 0;
    }

    private QuestState stateFor(Quest q, Set<Quest> simulatedFinished)
    {
        return simulatedFinished.contains(q) ? QuestState.FINISHED : QuestState.NOT_STARTED;
    }

    private void applyQuestXp(Quest q, Map<Skill, Integer> simulatedLevels)
    {
        Map<Skill, Integer> xp = questDatabase.getXpRewards(q);
        if (xp == null || xp.isEmpty())
        {
            return;
        }

        // MVP: approximate XP -> level by assuming reward is enough to reach at least the requirement gate
        // if the level delta is small. Exact XP tables can be added later.
        for (Map.Entry<Skill, Integer> en : xp.entrySet())
        {
            Skill s = en.getKey();
            int addXp = en.getValue() == null ? 0 : en.getValue();
            if (s == null || addXp <= 0)
            {
                continue;
            }

            int curLevel = simulatedLevels.getOrDefault(s, 1);
            int baseXp = com.ironpath.util.XpTable.xpForLevel(curLevel);
            int bumped = com.ironpath.util.XpTable.levelForXp(baseXp + addXp);
            if (bumped > curLevel)
            {
                simulatedLevels.put(s, bumped);
            }
        }
    }

    private Map<Skill, Integer> mergedMinSkills(RouteStep step)
    {
        Map<Skill, Integer> base = questDatabase.getMinSkills(step.getQuest());
        if (step.getMinSkillsOverride() == null || step.getMinSkillsOverride().isEmpty())
        {
            return base == null ? Map.of() : base;
        }

        Map<Skill, Integer> out = new EnumMap<>(Skill.class);
        if (base != null)
        {
            out.putAll(base);
        }
        out.putAll(step.getMinSkillsOverride());
        return out;
    }

    private String mergedWhy(RouteStep step)
    {
        final Quest q = step == null ? null : step.getQuest();
        String base = null;

        if (q != null)
        {
            base = questDatabase.getWhy(q);
        }

        final String candidate = base != null ? base : (step == null ? null : step.getWhy());
        if (candidate != null && !candidate.trim().isEmpty())
        {
            return candidate.trim();
        }

        if (step == null || step.getType() == null)
        {
            return null;
        }

        // Fallback copy when the quest DB does not have an entry yet.
        switch (step.getType())
        {
            case QUEST:
                return "Complete this quest in the Optimal Quest Guide order to minimise extra training.";
            case MINIQUEST:
                return "Complete this quest in the Optimal Quest Guide order to minimise extra training.";
            case UNLOCK:
                return "Recommended unlock.";
            case DIARY:
                return "Recommended diary step in the Optimal Quest Order.";
            case TRAIN:
                return "Recommended training checkpoint in the Optimal Quest Order.";
            default:
                return "Complete this  in the Optimal Quest Guide order to minimise extra training.";
        }
    }

    private String resolveWikiUrl(RouteStep step, String questName)
    {
        String url = step == null ? null : step.getWikiUrl();
        if (url != null && !url.trim().isEmpty())
        {
            return url.trim();
        }

        if (questName == null || questName.trim().isEmpty())
        {
            return "https://oldschool.runescape.wiki/";
        }

        // Default to the OSRS Wiki article URL for the quest name.
        // Replace spaces with underscores and URL-encode reserved characters (apostrophes, etc.).
        final String slug = questName.trim().replace(' ', '_');
        try
        {
            return "https://oldschool.runescape.wiki/w/" + java.net.URLEncoder.encode(slug, java.nio.charset.StandardCharsets.UTF_8)
                    .replace("+", "%20");
        }
        catch (Exception e)
        {
            return "https://oldschool.runescape.wiki/";
        }
    }

    private static List<TrainPlanStep> missingSkills(RouteStep target, Map<Skill, Integer> req, Map<Skill, Integer> simulatedLevels, int maxDeltaPerStep)
    {
        final List<TrainPlanStep> out = new ArrayList<>();
        if (req == null || req.isEmpty())
        {
            return out;
        }

        String title = target.getDisplayName();
        if (title == null || title.isEmpty())
        {
            title = target.getQuest() != null ? target.getQuest().getName() : "next quest";
        }

        for (Map.Entry<Skill, Integer> en : req.entrySet())
        {
            final Skill s = en.getKey();
            final int need = en.getValue() == null ? 1 : en.getValue();
            final int have = simulatedLevels.getOrDefault(s, 1);
            if (have < need)
            {
                final int to = maxDeltaPerStep > 0 ? Math.min(need, have + maxDeltaPerStep) : need;
                out.add(new TrainPlanStep(s, have, to, "Required for " + title + "."));
            }
        }

        // Stable ordering: biggest deficit first, then skill name.
        out.sort((a, b) ->
        {
            int da = a.getToLevel() - a.getFromLevel();
            int db = b.getToLevel() - b.getFromLevel();
            if (da != db)
            {
                return Integer.compare(db, da);
            }
            return a.getSkill().name().compareToIgnoreCase(b.getSkill().name());
        });

        return out;
    }


    private static String extractLampInstruction(String why)
    {
        if (why == null || why.isBlank())
        {
            return null;
        }

        final Matcher m = LAMP_ON_PATTERN.matcher(why);
        if (!m.find())
        {
            return null;
    }

        return why.substring(m.start()).trim();
    }

    private boolean shouldSkip(RouteStep step)
    {
        if (step == null || step.getType() == null)
        {
            return true;
        }

        switch (step.getType())
        {
            case QUEST:
            case MINIQUEST:
                return step.getQuest() == null;

            case TRAIN:
                return step.getSkill() == null || step.getToLevel() == null;

            case DIARY:
            case NOTE:
                return step.getDisplayName() == null || step.getDisplayName().trim().isEmpty();

            default:
                return false;
        }
    }
}

package com.ironpath.service;

import com.google.inject.Singleton;
import com.ironpath.model.QuestEntry;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;

@Singleton
public class QuestStatusService
{
    private final Client client;
    private final Map<String, Quest> byNormalizedName = new HashMap<>();

    @Inject
    public QuestStatusService(Client client)
    {
        this.client = client;

        for (Quest q : Quest.values())
        {
            byNormalizedName.put(normalize(q.getName()), q);
        }
    }

    /**
     * Resolves a quest name (legacy string) to the canonical RuneLite Quest enum.
     * This exists only as a bridge while prereqs are still stored as strings.
     */
    public Quest resolveQuest(String questName)
    {
        if (questName == null)
        {
            return null;
        }
        return byNormalizedName.get(normalize(questName));
    }

    public QuestState getState(QuestEntry entry)
    {
        if (entry == null)
        {
            return QuestState.NOT_STARTED;
        }

        final Quest direct = entry.getQuest();
        if (direct != null)
        {
            return direct.getState(client);
        }

        // Legacy fallback only. Route entries should be backed by Quest to avoid localization issues.
        final Quest q = resolveQuest(entry.getQuestName());
        return q == null ? QuestState.NOT_STARTED : q.getState(client);
    }

    public QuestState getStateByName(String questName)
    {
        final Quest q = resolveQuest(questName);
        return q == null ? QuestState.NOT_STARTED : q.getState(client);
    }

    public int countCompleted(List<QuestEntry> route)
    {
        int done = 0;
        for (QuestEntry e : route)
        {
            if (getState(e) == QuestState.FINISHED)
            {
                done++;
            }
        }
        return done;
    }

    public QuestEntry findNext(List<QuestEntry> route)
    {
        for (QuestEntry e : route)
        {
            final QuestState state = getState(e);
            if (state != QuestState.FINISHED)
            {
                return e;
            }
        }
        return null;
    }

    private static String normalize(String s)
    {
        if (s == null)
        {
            return "";
        }

        final String lower = s.toLowerCase(Locale.ROOT);
        final StringBuilder sb = new StringBuilder(lower.length());

        for (int i = 0; i < lower.length(); i++)
        {
            final char c = lower.charAt(i);
            if (Character.isLetterOrDigit(c))
            {
                sb.append(c);
            }
        }

        return sb.toString();
    }
}

package com.ironpath.service;

import com.google.inject.Singleton;
import com.ironpath.model.PlanStepType;
import com.ironpath.model.RouteStep;
import java.util.Locale;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Varbits;

/**
 * Centralized completion checks for non-quest progression steps.
 *
 * Plugin Hub compliance: uses only in-client varps/varbits (no networking, no disk).
 */
@Singleton
public class StepCompletionService
{
    private final Client client;

    @Inject
    public StepCompletionService(Client client)
    {
        this.client = client;
    }

    public boolean isComplete(RouteStep step)
    {
        if (step == null)
        {
            return false;
        }

        final PlanStepType type = step.getType();
        final String name = step.getDisplayName();
        final String normalized = name == null ? "" : name.trim().toLowerCase(Locale.ROOT);

        // Tutorial Island is represented as a NOTE/UNLOCK in some spines.
        if (normalized.contains("tutorial island"))
        {
            return isTutorialIslandComplete();
        }

        if (type == PlanStepType.DIARY)
        {
            return isAchievementDiaryTierComplete(normalized);
        }

        // Optional: combat achievements tier completion (if you add steps for it).
        if (normalized.contains("combat achievements") || normalized.contains("combat achievement"))
        {
            return isCombatAchievementTierComplete(normalized);
        }

        return false;
    }

    private boolean isTutorialIslandComplete()
    {
        // Tutorial progress varp is 281 and completion is 1000.
        final int tutorialProgress = client.getVarpValue(281);
        return tutorialProgress >= 1000;
    }

    private boolean isAchievementDiaryTierComplete(String normalizedDisplayName)
    {
        final Tier tier = Tier.parse(normalizedDisplayName);
        final Region region = Region.parse(normalizedDisplayName);
        if (tier == null || region == null)
        {
            return false;
        }

        final int varbitId = diaryVarbitId(region, tier);
        if (varbitId <= 0)
        {
            return false;
        }

        // Diary tier completion varbits are typically 1 when rewards are claimed.
        return client.getVarbitValue(varbitId) >= 1;
    }

    private static int diaryVarbitId(Region region, Tier tier)
    {
        switch (region)
        {
            case ARDOUGNE:
                return tier.pick(Varbits.DIARY_ARDOUGNE_EASY, Varbits.DIARY_ARDOUGNE_MEDIUM, Varbits.DIARY_ARDOUGNE_HARD, Varbits.DIARY_ARDOUGNE_ELITE);
            case DESERT:
                return tier.pick(Varbits.DIARY_DESERT_EASY, Varbits.DIARY_DESERT_MEDIUM, Varbits.DIARY_DESERT_HARD, Varbits.DIARY_DESERT_ELITE);
            case FALADOR:
                return tier.pick(Varbits.DIARY_FALADOR_EASY, Varbits.DIARY_FALADOR_MEDIUM, Varbits.DIARY_FALADOR_HARD, Varbits.DIARY_FALADOR_ELITE);
            case FREMENNIK:
                return tier.pick(Varbits.DIARY_FREMENNIK_EASY, Varbits.DIARY_FREMENNIK_MEDIUM, Varbits.DIARY_FREMENNIK_HARD, Varbits.DIARY_FREMENNIK_ELITE);
            case KANDARIN:
                return tier.pick(Varbits.DIARY_KANDARIN_EASY, Varbits.DIARY_KANDARIN_MEDIUM, Varbits.DIARY_KANDARIN_HARD, Varbits.DIARY_KANDARIN_ELITE);
            case KARAMJA:
                return tier.pick(Varbits.DIARY_KARAMJA_EASY, Varbits.DIARY_KARAMJA_MEDIUM, Varbits.DIARY_KARAMJA_HARD, Varbits.DIARY_KARAMJA_ELITE);
            case KOUREND_KEBOS:
                return tier.pick(Varbits.DIARY_KOUREND_EASY, Varbits.DIARY_KOUREND_MEDIUM, Varbits.DIARY_KOUREND_HARD, Varbits.DIARY_KOUREND_ELITE);
            case LUMBRIDGE_DRAYNOR:
                return tier.pick(Varbits.DIARY_LUMBRIDGE_EASY, Varbits.DIARY_LUMBRIDGE_MEDIUM, Varbits.DIARY_LUMBRIDGE_HARD, Varbits.DIARY_LUMBRIDGE_ELITE);
            case MORYTANIA:
                return tier.pick(Varbits.DIARY_MORYTANIA_EASY, Varbits.DIARY_MORYTANIA_MEDIUM, Varbits.DIARY_MORYTANIA_HARD, Varbits.DIARY_MORYTANIA_ELITE);
            case VARROCK:
                return tier.pick(Varbits.DIARY_VARROCK_EASY, Varbits.DIARY_VARROCK_MEDIUM, Varbits.DIARY_VARROCK_HARD, Varbits.DIARY_VARROCK_ELITE);
            case WESTERN:
                return tier.pick(Varbits.DIARY_WESTERN_EASY, Varbits.DIARY_WESTERN_MEDIUM, Varbits.DIARY_WESTERN_HARD, Varbits.DIARY_WESTERN_ELITE);
            case WILDERNESS:
                return tier.pick(Varbits.DIARY_WILDERNESS_EASY, Varbits.DIARY_WILDERNESS_MEDIUM, Varbits.DIARY_WILDERNESS_HARD, Varbits.DIARY_WILDERNESS_ELITE);
            default:
                return -1;
        }
    }

    private boolean isCombatAchievementTierComplete(String normalizedDisplayName)
    {
        final Tier tier = Tier.parse(normalizedDisplayName);
        if (tier == null)
        {
            return false;
        }

        final int varbitId;
        switch (tier)
        {
            case EASY:
                varbitId = Varbits.COMBAT_ACHIEVEMENT_TIER_EASY;
                break;
            case MEDIUM:
                varbitId = Varbits.COMBAT_ACHIEVEMENT_TIER_MEDIUM;
                break;
            case HARD:
                varbitId = Varbits.COMBAT_ACHIEVEMENT_TIER_HARD;
                break;
            case ELITE:
                varbitId = Varbits.COMBAT_ACHIEVEMENT_TIER_ELITE;
                break;
            case MASTER:
                varbitId = Varbits.COMBAT_ACHIEVEMENT_TIER_MASTER;
                break;
            case GRANDMASTER:
                varbitId = Varbits.COMBAT_ACHIEVEMENT_TIER_GRANDMASTER;
                break;
            default:
                return false;
        }

        return client.getVarbitValue(varbitId) >= 1;
    }

    private enum Tier
    {
        EASY, MEDIUM, HARD, ELITE, MASTER, GRANDMASTER;

        static Tier parse(String normalized)
        {
            if (normalized == null)
            {
                return null;
            }
            if (normalized.contains("grandmaster"))
            {
                return GRANDMASTER;
            }
            if (normalized.contains("master"))
            {
                return MASTER;
            }
            if (normalized.contains("elite"))
            {
                return ELITE;
            }
            if (normalized.contains("hard"))
            {
                return HARD;
            }
            if (normalized.contains("medium"))
            {
                return MEDIUM;
            }
            if (normalized.contains("easy"))
            {
                return EASY;
            }
            return null;
        }

        int pick(int easy, int medium, int hard, int elite)
        {
            switch (this)
            {
                case EASY:
                    return easy;
                case MEDIUM:
                    return medium;
                case HARD:
                    return hard;
                case ELITE:
                    return elite;
                default:
                    return -1;
            }
        }
    }

    private enum Region
    {
        ARDOUGNE,
        DESERT,
        FALADOR,
        FREMENNIK,
        KANDARIN,
        KARAMJA,
        KOUREND_KEBOS,
        LUMBRIDGE_DRAYNOR,
        MORYTANIA,
        VARROCK,
        WESTERN,
        WILDERNESS;

        static Region parse(String normalized)
        {
            if (normalized == null)
            {
                return null;
            }

            if (normalized.contains("ardougne"))
            {
                return ARDOUGNE;
            }
            if (normalized.contains("desert"))
            {
                return DESERT;
            }
            if (normalized.contains("falador"))
            {
                return FALADOR;
            }
            if (normalized.contains("fremennik"))
            {
                return FREMENNIK;
            }
            if (normalized.contains("kandarin"))
            {
                return KANDARIN;
            }
            if (normalized.contains("karamja"))
            {
                return KARAMJA;
            }
            if (normalized.contains("kourend") || normalized.contains("kebos"))
            {
                return KOUREND_KEBOS;
            }
            if (normalized.contains("lumbridge") || normalized.contains("draynor"))
            {
                return LUMBRIDGE_DRAYNOR;
            }
            if (normalized.contains("morytania"))
            {
                return MORYTANIA;
            }
            if (normalized.contains("varrock"))
            {
                return VARROCK;
            }
            if (normalized.contains("western"))
            {
                return WESTERN;
            }
            if (normalized.contains("wilderness"))
            {
                return WILDERNESS;
            }

            return null;
        }
    }
}

package com.ironpath.service;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Singleton;
import com.ironpath.model.PlanStepType;
import com.ironpath.model.RouteStep;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Quest;
import net.runelite.api.Skill;

/**
 * Provides the canonical progression spine.
 *
 * The spine is loaded from a resource file (wiki_route.json) and then completed by appending
 * any missing RuneLite quests so the plugin always remains quest-cape complete.
 *
 * Important: this service provides *order*. Facts (requirements, XP rewards, tags, why) come
 * from {@link QuestDatabase}.
 */
@Slf4j
@Singleton
public class QuestRouteService
{
    private static final String ROUTE_RESOURCE = "/com/ironpath/wiki_route.json";
    private static final String TAG_FILLER = "filler";

    private final Gson gson;

    private final List<RouteStep> spine;

    @Inject
    public QuestRouteService(final Gson gson)
    {
        this.gson = gson;
        this.spine = buildSpine();
    }

    public List<RouteStep> getSpine()
    {
        return spine;
    }

    private List<RouteStep> buildSpine()
    {
        final List<RouteStep> out = new ArrayList<>();
        final Set<Quest> addedQuests = new LinkedHashSet<>();

        // 1) Load route steps from JSON.
        List<RouteStepJson> raw = loadJson();
        if (raw != null)
        {
            Map<String, Quest> questIndex = indexByNormalizedName();

            for (RouteStepJson r : raw)
            {
                if (r == null || r.type == null)
                {
                    continue;
                }

                PlanStepType type;
                try
                {
                    type = PlanStepType.valueOf(r.type.trim().toUpperCase(Locale.ROOT));
                }
                catch (Exception e)
                {
                    continue;
                }

                RouteStep.Builder b = RouteStep.builder(type);

                if (type == PlanStepType.QUEST)
                {
                    Quest q = null;

                    // Prefer explicit enum name
                    if (r.quest != null && !r.quest.trim().isEmpty())
                    {
                        try
                        {
                            q = Quest.valueOf(r.quest.trim());
                        }
                        catch (Exception ignored)
                        {
                            // fall through
                        }
                    }

                    // Fallback: resolve via normalized display name
                    if (q == null && r.displayName != null)
                    {
                        q = questIndex.get(normalize(r.displayName));
                    }

                    if (q == null)
                    {
                        // If we cannot resolve to a RuneLite quest, degrade it to NOTE
                        // so the spine order remains visible and deterministic.
                        out.add(RouteStep.builder(PlanStepType.NOTE)
                                .displayName(r.displayName == null ? "Unresolved quest" : r.displayName)
                                .why(r.why == null ? "Unresolved quest row from wiki route." : r.why)
                                .build());
                        continue;
                    }

                    if (addedQuests.contains(q))
                    {
                        continue;
                    }

                    b.quest(q)
                            .displayName(r.displayName != null ? r.displayName : q.getName())
                            .why(r.why);

                    if (r.tags != null && !r.tags.isEmpty())
                    {
                        b.tagsOverride(Set.copyOf(r.tags));
                    }
                    if (r.minSkills != null && !r.minSkills.isEmpty())
                    {
                        b.minSkillsOverride(parseSkillMap(r.minSkills));
                    }

                    out.add(b.build());
                    addedQuests.add(q);
                }
                else if (type == PlanStepType.TRAIN)
                {
                    Skill s = parseSkill(r.skill);
                    if (s == null || r.toLevel == null || r.toLevel < 1)
                    {
                        continue;
                    }
                    out.add(b.skill(s)
                            .toLevel(r.toLevel)
                            .displayName(r.displayName != null ? r.displayName : ("Train " + s.getName()))
                            .why(r.why)
                            .wikiUrl(r.wikiUrl)
                            .build());
                }
                else
                {
                    out.add(b.displayName(r.displayName).why(r.why).wikiUrl(r.wikiUrl).build());
                }
            }
        }

                // 2) Option A: Do NOT append non-wiki steps or remaining quests here.

return out;
    }


    private List<RouteStepJson> loadJson()
    {
        try (InputStream in = QuestRouteService.class.getResourceAsStream(ROUTE_RESOURCE))
        {
            if (in == null)
            {
                log.warn("Route resource not found: {}", ROUTE_RESOURCE);
                return null;
            }

            Type type = new TypeToken<List<RouteStepJson>>() {}.getType();
            return gson.fromJson(new InputStreamReader(in, StandardCharsets.UTF_8), type);
        }
        catch (Exception e)
        {
            log.warn("Failed to load route JSON: {}", ROUTE_RESOURCE, e);
            return null;
        }
    }

    private static Map<String, Quest> indexByNormalizedName()
    {
        // LinkedHashMap to preserve deterministic iteration if ever needed
        java.util.LinkedHashMap<String, Quest> map = new java.util.LinkedHashMap<>();
        for (Quest q : Quest.values())
        {
            String name = q.getName();
            if (name != null)
            {
                map.put(normalize(name), q);
            }

            // Also index by enum constant formatting as a fallback.
            map.putIfAbsent(normalize(q.name().replace('_', ' ')), q);
            map.putIfAbsent(normalize(q.name()), q);
        }
        return map;
    }

    private static String normalize(String s)
    {
        if (s == null)
        {
            return "";
        }

        String t = s.trim().toLowerCase(Locale.ROOT);
        // Keep letters/digits only to be resilient to punctuation differences (e.g., apostrophes, dashes).
        t = t.replaceAll("[^a-z0-9]+", "");
        return t;
    }

    private static Map<Skill, Integer> parseSkillMap(Map<String, Number> raw)
    {
        java.util.EnumMap<Skill, Integer> out = new java.util.EnumMap<>(Skill.class);
        if (raw == null)
        {
            return out;
        }

        for (Map.Entry<String, Number> e : raw.entrySet())
        {
            Skill s = parseSkill(e.getKey());
            if (s == null || e.getValue() == null)
            {
                continue;
            }
            out.put(s, e.getValue().intValue());
        }
        return out;
    }

    private static Skill parseSkill(String raw)
    {
        if (raw == null)
        {
            return null;
        }

        String key = raw.trim().toUpperCase(Locale.ROOT).replace(' ', '_');
        // Common aliases found in wiki / JSON exports
        if ("HP".equals(key))
        {
            key = "HITPOINTS";
        }
        if ("HITPOINT".equals(key))
        {
            key = "HITPOINTS";
        }
        if ("RUNECRAFTING".equals(key))
        {
            key = "RUNECRAFT";
        }

        try
        {
            return Skill.valueOf(key);
        }
        catch (IllegalArgumentException ex)
        {
            log.debug("Unknown skill in route JSON: {}", raw);
            return null;
        }
    }


    private static final class RouteStepJson
    {
        private String type;
        private String quest;
        private String displayName;
        private String why;
        private String wikiUrl;

        private String skill;
        private Integer toLevel;

        private java.util.Set<String> tags;
        private Map<String, Number> minSkills;
    }
}

package com.ironpath.service;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Singleton;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Quest;
import net.runelite.api.Skill;

/**
 * Central, data-driven quest metadata store.
 *
 * The canonical route defines order; this database defines facts:
 * - minimum skill requirements (for readiness gates)
 * - XP rewards (for simulation)
 * - tags (e.g., filler/capstone/unlock)
 * - "why" blurbs
 *
 * All data is loaded from resources so it can evolve without code changes.
 */
@Slf4j
@Singleton
public class QuestDatabase
{
    private static final String RESOURCE_PATH = "/com/ironpath/quest_db.json";

    private final Gson gson;

    private final Map<Quest, QuestMeta> metaByQuest;

    @Inject
    public QuestDatabase(final Gson gson)
    {
        this.gson = gson;
        this.metaByQuest = Collections.unmodifiableMap(load());
    }

    public Map<Skill, Integer> getMinSkills(Quest quest)
    {
        QuestMeta m = metaByQuest.get(quest);
        return m == null ? Map.of() : m.minSkills;
    }

    public Map<Skill, Integer> getXpRewards(Quest quest)
    {
        QuestMeta m = metaByQuest.get(quest);
        return m == null ? Map.of() : m.xpRewards;
    }

    public Set<String> getTags(Quest quest)
    {
        QuestMeta m = metaByQuest.get(quest);
        return m == null ? Set.of() : m.tags;
    }

    public String getWhy(Quest quest)
    {
        QuestMeta m = metaByQuest.get(quest);
        return m == null ? null : m.why;
    }

    private Map<Quest, QuestMeta> load()
    {
        InputStream in = QuestDatabase.class.getResourceAsStream(RESOURCE_PATH);
        if (in == null)
        {
            log.warn("Quest DB resource not found at {}. Using empty metadata.", RESOURCE_PATH);
            return Map.of();
        }

        try (InputStreamReader r = new InputStreamReader(in, StandardCharsets.UTF_8))
        {
            Type t = new TypeToken<Map<String, QuestMetaJson>>() {}.getType();
            Map<String, QuestMetaJson> raw = gson.fromJson(r, t);
            if (raw == null || raw.isEmpty())
            {
                return Map.of();
            }

            Map<Quest, QuestMeta> out = new EnumMap<>(Quest.class);
            int unresolved = 0;

            for (Map.Entry<String, QuestMetaJson> en : raw.entrySet())
            {
                Quest q = resolveQuestEnum(en.getKey());
                if (q == null)
                {
                    unresolved++;
                    continue;
                }

                QuestMetaJson j = en.getValue();
                QuestMeta meta = new QuestMeta();
                meta.why = j.why;

                meta.tags = j.tags == null ? Set.of() : Collections.unmodifiableSet(new HashSet<>(j.tags));

                // minSkills
                Map<Skill, Integer> req = new EnumMap<>(Skill.class);
                if (j.minSkills != null)
                {
                    for (Map.Entry<String, Number> rs : j.minSkills.entrySet())
                    {
                        Skill s = resolveSkillEnum(rs.getKey());
                        if (s != null && rs.getValue() != null)
                        {
                            req.put(s, rs.getValue().intValue());
                        }
                    }
                }
                meta.minSkills = Collections.unmodifiableMap(req);

                // xpRewards
                Map<Skill, Integer> xp = new EnumMap<>(Skill.class);
                if (j.xpRewards != null)
                {
                    for (Map.Entry<String, Number> xs : j.xpRewards.entrySet())
                    {
                        Skill s = resolveSkillEnum(xs.getKey());
                        if (s != null && xs.getValue() != null)
                        {
                            xp.put(s, xs.getValue().intValue());
                        }
                    }
                }
                meta.xpRewards = Collections.unmodifiableMap(xp);

                out.put(q, meta);
            }

            if (unresolved > 0)
            {
                log.warn("Quest DB had {} entries that did not map to a RuneLite Quest enum.", unresolved);
            }

            return out;
        }
        catch (Exception e)
        {
            log.warn("Failed to load quest metadata; using empty metadata.", e);
            return Map.of();
        }
    }

    private static Quest resolveQuestEnum(String s)
    {
        if (s == null)
        {
            return null;
        }
        String key = s.trim();
        if (key.isEmpty())
        {
            return null;
        }

        try
        {
            return Quest.valueOf(key);
        }
        catch (IllegalArgumentException ignored)
        {
            // Not an enum constant name.
        }

        // Best-effort: match by Quest.getName()
        String norm = normalizeName(key);
        for (Quest q : Quest.values())
        {
            if (normalizeName(q.getName()).equals(norm))
            {
                return q;
            }
        }
        return null;
    }

    private static Skill resolveSkillEnum(String s)
    {
        if (s == null)
        {
            return null;
        }
        String key = s.trim();
        if (key.isEmpty())
        {
            return null;
        }
        try
        {
            return Skill.valueOf(key);
        }
        catch (IllegalArgumentException ignored)
        {
            // not enum name
        }

        // Best-effort common variants.
        String upper = key.toUpperCase();
        upper = upper.replace(' ', '_').replace('-', '_');
        try
        {
            return Skill.valueOf(upper);
        }
        catch (IllegalArgumentException ignored)
        {
            return null;
        }
    }

    private static String normalizeName(String s)
    {
        String lower = s == null ? "" : s.toLowerCase();
        lower = lower.replaceAll("[^a-z0-9]", "");
        return lower;
    }

    private static final class QuestMeta
    {
        private Map<Skill, Integer> minSkills = Map.of();
        private Map<Skill, Integer> xpRewards = Map.of();
        private Set<String> tags = Set.of();
        private String why;
    }

    private static final class QuestMetaJson
    {
        private Map<String, Number> minSkills;
        private Map<String, Number> xpRewards;
        private Set<String> tags;
        private String why;
    }
}

