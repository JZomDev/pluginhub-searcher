/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * Copyright (c) 2025, Jamal <http://github.com/1Defence>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.example;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.awt.*;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import java.util.Map;

@Slf4j
public class ImportExportHandler
{
    SpellbookPresetsPlugin plugin;
    Gson gson;

    @Inject
    public ImportExportHandler(SpellbookPresetsPlugin plugin, Gson gson){
        this.plugin = plugin;
        this.gson = gson;
    }

    /**Export saved preset of specified name and saves to clipboard*/
    public void exportPreset(String preset){
        Map<Integer, Map<Integer, SpellData>> spellbooks = plugin.getSpellbooks(preset);
        if(spellbooks == null)
            return;

        String json = gson.toJson(new SpellbookPresetJsonObject(preset, spellbooks));
        if(Strings.isNullOrEmpty(json))
            return;

        Toolkit.getDefaultToolkit()
                .getSystemClipboard()
                .setContents(new StringSelection(json), null);
        log.debug("Exported spellbook preset \"{}\" : {}", preset,json);
    }

    /**Stash the pending import into an object
     * used to extract data like the name prior to accepting the import.
     * thrown to GC if the user declines.*/
    SpellbookPresetJsonObject StashImportObject(){
        try
        {
            final String clipboardText = Toolkit.getDefaultToolkit()
                    .getSystemClipboard()
                    .getData(DataFlavor.stringFlavor)
                    .toString();
            if (Strings.isNullOrEmpty(clipboardText))
            {
                log.warn("nothing to import");
            }else{

                //quick check to prevent json parse in the common event that the clipboard text is obviously not a valid import.
                if (!clipboardText.trim().startsWith("{")) {
                    return null;
                }

                //clipboard text present and potentially a json.
                try
                {
                    return gson.fromJson(clipboardText, SpellbookPresetJsonObject.class);
                }
                catch (JsonSyntaxException e)
                {
                    log.debug("Malformed JSON for clipboard import");
                }
            }
        }
        catch (IOException | UnsupportedFlavorException ex)
        {
            log.warn("error reading clipboard", ex);
        }
        return null;
    }

    /**confirm the import, saves the import to config.*/
    public void confirmImport(SpellbookPresetJsonObject jsonObject){
        plugin.saveSpellbooks(jsonObject.preset,jsonObject.data);
        log.debug("Imported spellbook preset \"{}\"", jsonObject.preset);
    }



}

/*
 * Copyright (c) 2025, Jamal <http://github.com/1Defence>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.example;

import net.runelite.client.ui.components.FlatTextField;

import javax.swing.*;
import java.awt.*;
import java.util.List;

public class PresetRowPanel extends JPanel
{
    SpellbookPresetsPlugin plugin;

    String presetName;

    JLabel presetNameOutputField;
    FlatTextField presetNameInputField;

    List<String> presetListHandle;

    List<String> savedPresetList;

    public JLabel renameButtonLabel;
    public JLabel saveButtonLabel;
    public JLabel cancelButtonLabel;

    public PresetRowPanel(LayoutManager layout,String presetName,List<String> savedPresetList, List<String> presetListHandle, SpellbookPresetsPlugin plugin){
        super(layout,true);
        this.presetName = presetName;
        this.savedPresetList = savedPresetList;
        this.presetListHandle = presetListHandle;
        this.plugin = plugin;
    }

    public void SetNameFields(JLabel presetNameOutputField,FlatTextField presetNameInputField){
        this.presetNameOutputField = presetNameOutputField;
        this.presetNameInputField = presetNameInputField;
    }

    public void SetButtonFields(JLabel renameButtonLabel,JLabel saveButtonLabel,JLabel cancelButtonLabel){
        this.renameButtonLabel = renameButtonLabel;
        this.saveButtonLabel = saveButtonLabel;
        this.cancelButtonLabel = cancelButtonLabel;
    }

    public String GetPresetName(){
        return presetName;
    }

    /**Attempt to save a pending rename to config*/
    public void ChangePresetName(){
        String originalName = GetPresetName();
        String updatedName = presetNameInputField.getText().trim();
        //rename succeeded, update UI accordingly.
        if(!updatedName.isEmpty() && plugin.renameSpellbooks(originalName,updatedName)){
            presetName = updatedName;
            presetNameOutputField.setText(presetName);

            //modify the name in actives/inactives list
            int handleIndex = presetListHandle.indexOf(originalName);
            if (handleIndex != -1) {
                presetListHandle.set(handleIndex, presetName);
            }

            //modify the name in saves list if present, add it otherwise
            int saveIndex = savedPresetList.indexOf(originalName);
            if (saveIndex != -1) {
                savedPresetList.set(saveIndex, presetName);
            }else{
                savedPresetList.add(presetName);
            }

            //attempt to change to the new preset.
            if(plugin.currentPreset.equals(originalName)){
                plugin.changePreset(presetName);
            }
        }

        //update regardless of success, as we need to revert to origin
        ToggleRenameUI();
    }

    /**toggle and update the renaming UI of the row
     * essentially rename mode on/off */
    public void ToggleRenameUI(){

        boolean editEnabled = presetNameInputField.isBlocked();

        cancelButtonLabel.setVisible(editEnabled);
        saveButtonLabel.setVisible(editEnabled);
        renameButtonLabel.setVisible(!editEnabled);

        presetNameInputField.setEditable(editEnabled);
        presetNameInputField.setText(presetNameOutputField.getText());

        if(editEnabled){
            presetNameOutputField.setVisible(false);

            presetNameInputField.setFocusable(true);
            presetNameInputField.setVisible(true);
            presetNameInputField.requestFocusInWindow();
            presetNameInputField.getTextField().selectAll();
        }else{
            presetNameInputField.setVisible(false);
            presetNameInputField.setFocusable(false);

            presetNameOutputField.setVisible(true);
            presetNameOutputField.requestFocusInWindow();
        }
    }

    /**Moves preset string from current container to other container
     * i.e current container is active, other is inactive
     * removes preset from active and adds it to inactive.*/
    public void MoveTo(List<String> otherPresetContainer){
        presetListHandle.remove(presetName);
        otherPresetContainer.add(presetName);
    }

    /**Export Row's preset and saves to clipboard*/
    public void Export(){
        plugin.importExportHandler.exportPreset(GetPresetName());
    }
}

/*
 * Copyright (c) 2025, Jamal <http://github.com/1Defence>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.example;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.DragAndDropReorderPane;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.example.SpellbookPresetsConfig.ACTIVE_PRESETS_KEY;
import static com.example.SpellbookPresetsConfig.GROUP;

@Slf4j
public class SaveEditPanel extends PluginPanel
{

    SpellbookPresetsPlugin plugin;
    ConfigManager configManager;
    Gson gson;

    //arbitrary cap on presets, even 10 is high may reduce in future.
    private static final int MAX_ACTIVE_PRESETS_COUNT = 10;
    //"name (garbage) (number)"
    Pattern importCopyPattern = Pattern.compile("^(.+?)\\s*\\((\\d+)\\)$");
    //"Preset #"
    Pattern newPresetPattern = Pattern.compile("^Preset\\s*(\\d+)$");
    private final IconTextField searchBar;
    public String queryText = "";
    public Timer configUpdateTimer;

    /**Row Containers*/
    private final JPanel inactivePresetsContainer;
    private final DragAndDropReorderPane activePresetsContainer;
    public static List<String> inactivePresetList = new ArrayList<>();
    public static List<String> activePresetList = new ArrayList<>();

    //generated on start, parses what we have in the config.
    public static List<String> savedPresetList = new ArrayList<>();
    /***/

    public static final ImageIcon EXPORT_ICON;
    public static final ImageIcon DELETE_ICON;
    public static final ImageIcon REMOVE_ICON, REMOVE_ICON_FADED;
    public static final ImageIcon ADD_ICON, ADD_ICON_FADED;
    public static final ImageIcon IMPORT_ICON, IMPORT_ICON_FADED;
    static
    {
        final BufferedImage exportImg = ImageUtil.loadImageResource(SpellbookPresetsPlugin.class, "export_icon.png");
        EXPORT_ICON = new ImageIcon(exportImg);
        final BufferedImage deleteImg = ImageUtil.loadImageResource(SpellbookPresetsPlugin.class, "delete_icon.png");
        DELETE_ICON = new ImageIcon(deleteImg);

        final BufferedImage removeImg = ImageUtil.loadImageResource(SpellbookPresetsPlugin.class, "remove_icon.png");
        REMOVE_ICON = new ImageIcon(removeImg);
        REMOVE_ICON_FADED = new ImageIcon(ImageUtil.alphaOffset(removeImg, -180));

        final BufferedImage addImg = ImageUtil.loadImageResource(SpellbookPresetsPlugin.class, "add_icon.png");
        ADD_ICON = new ImageIcon(addImg);
        ADD_ICON_FADED = new ImageIcon(ImageUtil.alphaOffset(addImg, -180));

        final BufferedImage importImg = ImageUtil.loadImageResource(SpellbookPresetsPlugin.class, "import_icon.png");
        IMPORT_ICON = new ImageIcon(importImg);
        IMPORT_ICON_FADED = new ImageIcon(ImageUtil.alphaOffset(importImg, -180));
    }


    SaveEditPanel(SpellbookPresetsPlugin plugin, ConfigManager configManager, Gson gson)
    {
        super();
        this.plugin = plugin;
        this.configManager = configManager;
        this.gson = gson;

        setLayout(new BorderLayout());

        final JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
        layoutPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        add(layoutPanel, BorderLayout.CENTER);

        final JPanel headerPanel;
        headerPanel = buildHeaderPanel();
        headerPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, headerPanel.getPreferredSize().height));
        layoutPanel.add(headerPanel);

        final JPanel searchPanel = new JPanel(new GridLayout(1, 3, 10, 0));
        searchPanel.setBorder(new EmptyBorder(2, 0, 0, 0)); //initial gap before presets

        //Search bar to filter Inactive presets by query.
        searchBar = new IconTextField();
        searchBar.setIcon(IconTextField.Icon.SEARCH);
        searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        searchBar.setMinimumSize(new Dimension(0, 30));
        searchBar.addKeyListener(new KeyAdapter() {
            @Override
            public void keyReleased(KeyEvent e) {
                SetSearchQuery();
            }
        });
        searchBar.addClearListener(this::SetSearchQuery);
        searchPanel.add(searchBar);


        //Holder of Active-Preset rows (Presets that are currently active)
        activePresetsContainer = new DragAndDropReorderPane ();
        activePresetsContainer.setBorder(new EmptyBorder(10, 0, 0, 0)); //initial gap before presets
        activePresetsContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
        activePresetsContainer.setAlignmentX(LEFT_ALIGNMENT);

        //Detect preset swapping in active list
        activePresetsContainer.addDragListener(
        new DragAndDropReorderPane.DragListener()
            {
               @Override
               public void onDrag(Component component)
               {
                    activePresetList = activePresetsFromComponents();
                    requestConfigUpdate();
                    rebuildActiveList();
               }
            });

        //Holder of Inactive-Preset rows (Presets that are not currently active, but still stored.)
        inactivePresetsContainer = new JPanel ();
        inactivePresetsContainer.setBorder(new EmptyBorder(10, 0, 0, 0)); //initial gap before presets
        inactivePresetsContainer.setLayout(new BoxLayout(inactivePresetsContainer, BoxLayout.Y_AXIS));
        inactivePresetsContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
        inactivePresetsContainer.setAlignmentX(LEFT_ALIGNMENT);

        addComponents(layoutPanel,
                searchPanel,
                activePresetsContainer,
                inactivePresetsContainer);
        initPresetLists();
        rebuildActiveList();
        rebuildInactiveList(true);
    }

    /**Build panel containing :
     * header title
     * import preset button
     * create new preset button*/
    private JPanel buildHeaderPanel()
    {
        final JPanel headerContainer = new JPanel(new BorderLayout());
        headerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerContainer.setPreferredSize(new Dimension(0, 30));
        headerContainer.setBorder(new EmptyBorder(5, 5, 5, 0));
        headerContainer.setVisible(true);

        final JLabel headerTitle = new JLabel();
        headerTitle.setFont(FontManager.getRunescapeFont());
        headerTitle.setForeground(Color.WHITE);
        headerTitle.setText("Spellbook Presets");

        JButton addButton;
        addButton = CreateButton("Create new preset",ADD_ICON_FADED);
        addButton.setRolloverIcon(ADD_ICON);
        addButton.addActionListener(e -> {
            String nextPresetName = getNextAvailablePreset();
            if(plugin.addSpellBooksKey(nextPresetName)){
                AddNewPresetToCollection(nextPresetName,true);
            }
        });

        JButton importButton;
        importButton = CreateButton("Import preset",IMPORT_ICON_FADED);
        importButton.setRolloverIcon(IMPORT_ICON);


        importButton.addActionListener(e -> {
            SpellbookPresetJsonObject stashedImport = plugin.importExportHandler.StashImportObject();
            if(stashedImport != null)
            {
                String presetName = stashedImport.preset;
                boolean exists = plugin.spellbooksKeyExists(presetName);
                if(exists){
                    presetName =  getNextAvailableImport(presetName);
                }
                stashedImport.preset = presetName;
                String messagePrompt = "Import preset (" + presetName + ") ?";

                int confirm = JOptionPane.showConfirmDialog(headerContainer, messagePrompt, "Confirm", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION)
                {
                    log.debug("Importing " + stashedImport.preset + " : " + stashedImport.data);
                    plugin.importExportHandler.confirmImport(stashedImport);
                    AddNewPresetToCollection(presetName,exists);
                }

            }
        });

        JPanel buttonsPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 2));
        buttonsPanel.setOpaque(false);
        buttonsPanel.add(importButton);
        buttonsPanel.add(addButton);


        headerContainer.add(buttonsPanel, BorderLayout.EAST);
        headerContainer.add(headerTitle, BorderLayout.WEST);
        return headerContainer;
    }

    /**Used when a new preset is either created or imported
     *  determines the correct collection to add the row to
     *  additionally prompt the user to edit the name*/
    public void AddNewPresetToCollection(String preset, boolean startEdit){
        PresetRowPanel editRow;
        savedPresetList.add(preset);

        if(activePresetsContainer.getComponentCount() < MAX_ACTIVE_PRESETS_COUNT){
            //user hasn't hit the active preset limit, the new row is the last element of our active list
            activePresetList.add(preset);
            rebuildInactiveList(true);
            rebuildActiveList();
            editRow = (PresetRowPanel) activePresetsContainer.getComponent(activePresetsContainer.getComponentCount()-1);
        }else{
            //user has hit the active preset limit, the new row is the first element of our inactive list (prevents confusion as user will see it right away)
            inactivePresetList.add(0,preset);
            rebuildActiveList();
            rebuildInactiveList(false);
            editRow = (PresetRowPanel) inactivePresetsContainer.getComponent(0);
        }

        requestConfigUpdate();

        //attempt to change to the new preset.
        plugin.changePreset(preset);

        if(startEdit)
        {
            editRow.ToggleRenameUI();
        }
    }

    /**update search query to the text of the search bar
     * rebuilds the list of inactive saves that contain the query text*/
    public void SetSearchQuery(){
        if(searchBar != null){
            queryText = searchBar.getText().toLowerCase();
        }
        rebuildActiveList();
        rebuildInactiveList(true);
    }

    /**initial list generation, mostly from config*/
    void initPresetLists(){
        //generate saved list from config
        savedPresetList = savedPresetsFromConfig();

        //generate active list from config
        activePresetList = plugin.activePresetsFromConfig();

        //generate inactive list from whats in saved but not in active
        inactivePresetList = generateInactivePresetList();
        inactivePresetList.sort(ALPHANUMERICAL_COMPARATOR);
    }

    /**returns list of active preset names, specifically from the components in the "activePresetsContainer" panel*
     * used to update the active list to the state of the drag panel.
     */
    public List<String> activePresetsFromComponents(){
        List<String> presetList = new ArrayList<>();
        for (Component presetComponent : activePresetsContainer.getComponents()) {
            if (presetComponent instanceof PresetRowPanel) {
                PresetRowPanel presetRowPanel = (PresetRowPanel) presetComponent;
                presetList.add(presetRowPanel.GetPresetName());
            }
        }
        return presetList;
    }


    /**generates list of inactive preset names
     * this is effectively the list of saved presets with the list of active presets omitted.
     */
    public List<String> generateInactivePresetList(){
        if(savedPresetList.isEmpty())
            return new ArrayList<>();
        //parse the saves

        List<String> presetList = new ArrayList<>();

        //any preset not part of active, is considered to be an inactive.
        for (String preset : savedPresetList)
        {
            if(activePresetList.contains(preset))
                continue;
            presetList.add(preset);
        }
        return presetList;
    }

    /**returns a list of saved presets
     * generated by collecting all "data" keys from the config and filtering them into their preset names.
     */
    public List<String> savedPresetsFromConfig(){
        List<String> presetList = new ArrayList<>();
        for (var key : configManager.getConfigurationKeys(GROUP + ".spellbookData_"))
        {
            String[] splitKey = key.split("\\.", 2);
            if (splitKey.length == 2)
            {
                String[] splitSave = splitKey[1].split("_",2);
                if(splitSave.length == 2){
                    String foundSave = splitSave[1];
                    presetList.add(foundSave);
                }
            }
        }
        return presetList;
    }

    /**rebuilds the active presets container
     * creates a new row of PresetRowPanel for every preset in the active list.
     */
    private void rebuildActiveList(){
        activePresetsContainer.removeAll();

        for(String presetName : activePresetList)
        {
            activePresetsContainer.add(createPresetRow(presetName,true));
        }
        revalidate();
    }

    /**rebuilds the inactive presets container
     * creates a new row of PresetRowPanel for every preset in the inactive list
     * if a query is present, the preset name must contain the query
     * in most cases the list is sorted alphanumerically.
     */
    private void rebuildInactiveList(boolean sort)
    {
        if(sort)
            inactivePresetList.sort(ALPHANUMERICAL_COMPARATOR);

        inactivePresetsContainer.removeAll();

        for(String presetName : inactivePresetList)
        {
            if(!queryText.isEmpty() && !presetName.toLowerCase().contains(queryText)){
                //filters presets to only show if name contains search text
                continue;
            }
            inactivePresetsContainer.add(createPresetRow(presetName,false));
        }
        revalidate();
    }

    /**Creates a managed row for use of the following
     *
     * |-/+|   |Preset-Name|          |Edit| ^| X|
     *
     * Renaming the associated preset
     * Deleting(unsetting from config, removing from containers)
     * Exporting(copying preset data to clipboard for other users to import)
     *
     * Swapping between active container(presets that user can switch between) and inactive container(stored presets that user can later activate to switch between)
     *
     * the passed state "active" determines which container and lists the row in question is moved to.
     * Actives are draggable this is to translate in-game to change the order of your active presets, as such inactives don't support dragging.
     */
    private JPanel createPresetRow(String presetName, boolean active)
    {
        PresetRowPanel row = new PresetRowPanel(new BorderLayout(),presetName,savedPresetList,active ? activePresetList : inactivePresetList,plugin);
        JPanel buttonsPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 4, 8));
        JPanel nameContainer = new JPanel(new FlowLayout(FlowLayout.RIGHT, 4, 8));

        JLabel save = CreateButton("Save",ColorScheme.PROGRESS_COMPLETE_COLOR,false);
        JLabel cancel = CreateButton("Cancel",ColorScheme.PROGRESS_ERROR_COLOR,false);
        JLabel rename = CreateButton("Edit",ColorScheme.LIGHT_GRAY_COLOR.darker(),true);
        JLabel nameOutput = new JLabel();
        FlatTextField nameInput = new FlatTextField();


        row.SetNameFields(nameOutput,nameInput);
        row.SetButtonFields(rename,save,cancel);
        row.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        row.setBorder(BorderFactory.createMatteBorder(0, 3, 1, 0, active ? ColorScheme.PROGRESS_INPROGRESS_COLOR : ColorScheme.MEDIUM_GRAY_COLOR));


        //The editable name field, which is only visible during renaming
        nameInput.setBorder(new EmptyBorder(0, 2, 0, 0));
        nameInput.setText(presetName);
        nameInput.setFont(FontManager.getRunescapeFont());
        nameInput.getTextField().setForeground(Color.WHITE);
        nameInput.setOpaque(false);
        nameInput.setEditable(false);
        nameInput.setFocusable(false);
        nameInput.setVisible(false);
        nameInput.setPreferredSize(new Dimension(82, nameInput.getPreferredSize().height));

        nameInput.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() == KeyEvent.VK_ENTER)
                {
                    row.ChangePresetName();
                    requestConfigUpdate();
                }
                else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
                {
                    row.ToggleRenameUI();
                }
            }
        });


        //The non-editable name field, which is visible when the editable field is hidden.
        nameOutput.setBorder(new EmptyBorder(0, 2, 0, 0));
        nameOutput.setText(presetName);
        nameOutput.setFont(FontManager.getRunescapeFont());
        nameOutput.setForeground(Color.WHITE);
        nameOutput.setOpaque(false);
        nameOutput.setFocusable(false);
        nameOutput.setPreferredSize(new Dimension(130, nameOutput.getPreferredSize().height));


        //conditional button that's setup differently depending on which container the row is in(active or inactive)
        JButton swapActiveButton;

        if(active){
            //row is currently active, the associated button will be a removal button that moves the row from active->inactive
            swapActiveButton = CreateButton("Remove",REMOVE_ICON_FADED);
            swapActiveButton.setRolloverIcon(REMOVE_ICON);

            //when removing a preset, your mouse is hovered over another remove post-refresh but rollover doesn't occur so we manually set it here if valid.
            //why is this needed for the minus button but rows work fine?....
            SwingUtilities.invokeLater(() ->
            {
                Point mousePoint = MouseInfo.getPointerInfo().getLocation();
                SwingUtilities.convertPointFromScreen(mousePoint, swapActiveButton);

                if (swapActiveButton.contains(mousePoint))
                {
                    swapActiveButton.getModel().setRollover(true);
                }
            });

            swapActiveButton.addMouseListener(new MouseAdapter()
            {
                @Override
                public void mousePressed(MouseEvent mouseEvent)
                {
                    row.MoveTo(inactivePresetList);
                    requestConfigUpdate();
                    rebuildActiveList();
                    rebuildInactiveList(true);
                }
            });

        }else{
            //row is currently inactive, the associated button will be an add button that moves the row from inactive->active
            swapActiveButton = CreateButton("Add",ADD_ICON_FADED);
            swapActiveButton.setRolloverIcon(ADD_ICON);

            if(activePresetsContainer.getComponentCount() < MAX_ACTIVE_PRESETS_COUNT)
            {
                //store the event so both the row and the button can perform it.
                MouseAdapter addEvent = new MouseAdapter()
                {
                    @Override
                    public void mousePressed(MouseEvent mouseEvent)
                    {
                        row.MoveTo(activePresetList);
                        requestConfigUpdate();
                        rebuildActiveList();
                        rebuildInactiveList(true);
                    }

                    @Override
                    public void mouseEntered(MouseEvent mouseEvent)
                    {
                        swapActiveButton.setIcon(ADD_ICON);
                    }

                    @Override
                    public void mouseExited(MouseEvent mouseEvent)
                    {
                        swapActiveButton.setIcon(ADD_ICON_FADED);
                    }
                };

                //add the event to both the row and the button, similar to the entire row being a click box for the button for easier adding.
                row.addMouseListener(addEvent);
                swapActiveButton.addMouseListener(addEvent);

            }else{

                swapActiveButton.setEnabled(false);

            }

        }

        //two elements in the exact same position to hotswap whats active between the edit and the display text
        //inputfields have drag listeners that steal the events of DragAndDropReorderPane's and forwarding the events leads to inconsistencies
        nameContainer.setOpaque(false);
        addComponents(nameContainer,
                swapActiveButton,
                nameOutput,
                nameInput);


        //Save a preset name change
        save.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                row.ChangePresetName();
                requestConfigUpdate();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
            }
        });

        //Cancel a preset name change
        cancel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                row.ToggleRenameUI();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
            }
        });


        //Initiate a preset name change
        rename.setToolTipText("Rename preset");
        rename.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                row.ToggleRenameUI();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
            }
        });

        //Export button
        JButton exportBtn = CreateButton("Export", EXPORT_ICON);
        exportBtn.addActionListener(e -> {
            row.Export();
            log.debug("Exporting " + row.GetPresetName());
        });

        //Delete button
        JButton deleteBtn = CreateButton("Delete",DELETE_ICON);
        deleteBtn.addActionListener(e -> {
            forcePendingConfig();
            String rowPresetName = row.GetPresetName();
            int confirm = JOptionPane.showConfirmDialog(this, "Delete \"" + rowPresetName + "\"?", "Confirm", JOptionPane.YES_NO_OPTION);
            if (confirm == JOptionPane.YES_OPTION) {
                log.debug("Deleting " + rowPresetName);
                if(active){
                    activePresetList.remove(rowPresetName);
                    requestConfigUpdate();
                }else
                {
                    inactivePresetList.remove(rowPresetName);
                }
                savedPresetList.remove(rowPresetName);
                plugin.removeSpellbooksKey(rowPresetName);
                rebuildActiveList();
                rebuildInactiveList(true);
            }
        });

        buttonsPanel.setOpaque(false);
        addComponents(buttonsPanel,
                rename,
                save,
                cancel,
                exportBtn,
                deleteBtn);


        //+Name --------- Rename [ ] [ ]
        row.add(nameContainer,BorderLayout.WEST);
        row.add(buttonsPanel, BorderLayout.EAST);

        return row;
    }

    /**convenience method to create row button in the form of a label with predefined values*/
    JLabel CreateButton(String label,Color color,boolean initialVisibility){
        JLabel buttonLabel = new JLabel(label);
        buttonLabel.setVisible(initialVisibility);
        buttonLabel.setFont(FontManager.getRunescapeSmallFont());
        buttonLabel.setForeground(color);
        buttonLabel.setBorder(new EmptyBorder(3, 0, 0, 3));
        return buttonLabel;
    }

    /**convenience method to create row button with predefined values*/
    JButton CreateButton(String tooltip, ImageIcon icon){
        JButton button = new JButton();
        SwingUtil.removeButtonDecorations(button);
        button.setOpaque(false);
        button.setIcon(icon);
        button.setToolTipText(tooltip);
        button.setPreferredSize(new Dimension(16,16));
        return button;
    }

    /**convenience method to add a collection of components to a parent component*/
    public void addComponents(JComponent parent, JComponent... components) {
        for (JComponent component : components) {
            parent.add(component);
        }
    }

    /**comparer used to sort a list alphanumerically abc1, abc2, abc19...*/
    Comparator<String> ALPHANUMERICAL_COMPARATOR = new Comparator<>()
    {
        @Override
        public int compare(String a, String b)
        {
            int ia = 0, ib = 0;

            while (ia < a.length() && ib < b.length())
            {
                char ca = a.charAt(ia);
                char cb = b.charAt(ib);

                if (Character.isDigit(ca) && Character.isDigit(cb))
                {
                    int sa = ia, sb = ib;

                    while (ia < a.length() && Character.isDigit(a.charAt(ia))) ia++;
                    while (ib < b.length() && Character.isDigit(b.charAt(ib))) ib++;

                    int na = Integer.parseInt(a.substring(sa, ia));
                    int nb = Integer.parseInt(b.substring(sb, ib));

                    if (na != nb)
                    {
                        return Integer.compare(na, nb);
                    }
                }
                else
                {
                    ca = Character.toLowerCase(ca);
                    cb = Character.toLowerCase(cb);

                    if (ca != cb)
                    {
                        return ca - cb;
                    }

                    ia++;
                    ib++;
                }
            }
            return a.length() - b.length();
        }
    };

    /**config functions to prevent stressing the configmanager, there is no need to update 10 times a second if user is spam dragging/swapping actives
     * for now it's only for actives, because saves are modifed at a much less frequent rate(Addition,rename,deletion) and need to be immediate for stability.
     * request an update to config, if theres a pending update refresh the timer, otherwise set and start it.*/
    private void requestConfigUpdate(){
        if(configUpdateTimer != null){
            configUpdateTimer.restart();
            return;
        }

        ActionListener actionListener = new ActionListener() {
            public void actionPerformed(ActionEvent actionEvent) {
                updateConfig();
            }
        };

        configUpdateTimer = new Timer(2000, actionListener);
        configUpdateTimer.setRepeats(false);
        configUpdateTimer.start();
    }

    /**immediate update called when delay timer(configUpdateTimer) has finished.*/
    public void updateConfig(){
        String json = gson.toJson(activePresetList);
        configManager.setConfiguration(GROUP, ACTIVE_PRESETS_KEY, json);
        log.debug("updating configs... "+json);
        configUpdateTimer = null;
    }

    /**If theres a pending config change instantly update the config and thus the options.*/
    public void forcePendingConfig(){
        if(configUpdateTimer == null)
            return;
        configUpdateTimer.stop();
        updateConfig();
    }


    /**find the next valid name of the given import
     * used if the name of the import already exists in the users saves.
     * appends (1),(2)..... to the preset name
     * incremented number if the name we're checking already has a number or if the resulting new string exists
     * ex: import is "pvm"
     * import 1, "pvm"
     * import 2, "pvm (1)"
     * import 3, "pvm (2)"
     * if you now import "pvm (1)", "pvm (3)"*/
    public String getNextAvailableImport(String preset) {

        preset = preset.trim();

        Matcher matcher = importCopyPattern.matcher(preset);
        String baseName;
        int count = 1;

        if (matcher.matches()) {
            baseName = matcher.group(1).trim();
            try {
                count = Integer.parseInt(matcher.group(2))+1;
            } catch (NumberFormatException e) {
                //NaN
                baseName = preset;
            }
        } else {
            baseName = preset;
        }

        String importName = baseName;
        while (savedPresetList.contains(importName)) {
            importName = baseName + " (" + count + ")";
            count++;
        }

        return importName;
    }

    /**find the next valid preset name
     * used when creating a new preset to generate the default name
     * "Preset 1", "Preset 2" .....*/
    public String getNextAvailablePreset() {

        int maxNumber = 0;
        for (String name : savedPresetList) {
            if (name != null) {
                Matcher matcher = newPresetPattern.matcher(name.trim());
                if (matcher.matches()) {
                    int num = Integer.parseInt(matcher.group(1));
                    if (num > maxNumber) {
                        maxNumber = num;
                    }
                }
            }
        }

        return "Preset " + (maxNumber + 1);
    }

    /**When a drastic change has occurred and an entire reset on the panel is required
     * currently this is used on resetting the configuration keys of the plugin*/
    public void Refresh(){
        initPresetLists();
        rebuildActiveList();
        rebuildInactiveList(true);
    }

}
/*
 * Copyright (c) 2025, Jamal <http://github.com/1Defence>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.example;

import java.util.Map;

public class SpellbookPresetJsonObject {
    public String preset;
    public Map<Integer, Map<Integer, SpellData>> data;

    public SpellbookPresetJsonObject(String preset, Map<Integer, Map<Integer, SpellData>> data) {
        this.preset = preset;
        this.data = data;
    }
}
/*
 * Copyright (c) 2025, Jamal <http://github.com/1Defence>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.example;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

import java.awt.*;
import java.awt.event.KeyEvent;

@ConfigGroup(SpellbookPresetsConfig.GROUP)
public interface SpellbookPresetsConfig extends Config
{
	String GROUP = "spellbookpresets";
	String ACTIVE_PRESETS_KEY = "activePresetsList";
	String SHOW_ALL_IF_EMPTY_KEY = "showAllIfEmpty";
	String SPELL_MOVE_MODE_KEY = "spellMoveMode";

	String CURRENT_PRESET_KEY = "currentPreset";

	String CURRENT_OPTION_RENDER_KEY = "currentOpRenderStyle";

	String CURRENT_OPTION_COLOR_KEY = "currentOpCustomColor";

	String MODIFY_OPTION_RENDER_KEY = "moidfyOpRenderStyle";
	String MODIFY_OPTION_HOTKEY_KEY = "modifyOpsHotkey";

	String NO_LOAD_OPTIONS_KEY = "noLoadOps";

	String OPEN_TAB_CONDITION_KEY = "openTabCondition";

	String DISPLAY_PRESETS_PANEL_KEY = "displayPresetsPanel";

	//in the situation that our data formatting/saving/loading changes. the version allows us to know how to handle migration.
	//for now it just gets set and exists.
	String LAST_VERSION_KEY = "version";
	String LIVE_VERSION_STRING = "1.0.0";

	enum SWAP_MODE { SWAP, INSERT}

	enum CURRENT_OPTION_STYLE {STANDARD, GREY_OUT, CUSTOM_COLOR, NO_RENDER}

	enum MODIFY_OPTION_STYLE {ALWAYS_RENDER,HOTKEY}

	enum OPEN_TAB_CONDITION {
		NONE(0),
		EDIT_PRESET(1),
		LOAD_PRESET(1 << 1),
		BOTH(EDIT_PRESET.value | LOAD_PRESET.value);
		public final int value;
		OPEN_TAB_CONDITION(int value) {
			this.value = value;
		}
	}

	@ConfigSection(name="Spellbook Presets", description="General settings", position=0)
	String defaultPanel = "defaultPanel";
	@ConfigSection(name="Current Option Style", description="Style settings for the currently selected preset : load (current)", position=1, closedByDefault=true)
	String currentOptionStylePanel = "currentOptionStylePanel";

	@ConfigSection(name="Modify Option Style", description="Style settings for the Edit and Hide preset options", position=2, closedByDefault=true)
	String modifyOptionStylePanel = "modifyOptionStylePanel";

	@ConfigItem(
			position = 0,
			keyName = SHOW_ALL_IF_EMPTY_KEY,
			name = "Show All If Empty",
			description = "Show all spells if none have been specified to show",
			section = defaultPanel
	)
	default boolean showAllIfEmpty()
	{
		return true;
	}

	@ConfigItem(
			position = 1,
			keyName = SPELL_MOVE_MODE_KEY,
			name = "Spell Move Mode",
			description = "Insert spell (all spells shift forward), Swap spell (spell A swaps position with spell B)",
			section = defaultPanel
	)
	default SWAP_MODE spellMoveMode()
	{
		return SWAP_MODE.SWAP;
	}

	@ConfigItem(
			position = 2,
			keyName = OPEN_TAB_CONDITION_KEY,
			name = "Open Tab",
			description = "The options that will additionally open the magic tab in game",
			section = defaultPanel
	)
	default OPEN_TAB_CONDITION openTabCondition()
	{
		return OPEN_TAB_CONDITION.EDIT_PRESET;
	}

	@ConfigItem(
			position = 3,
			keyName = DISPLAY_PRESETS_PANEL_KEY,
			name = "Display Presets Panel",
			description = "[WARNING] You will NOT be able to create,delete,rename or move presets with this disabled!. Configures whether the presets side panel should be displayed.",
			section = defaultPanel
	)
	default boolean displayPresetsPanel()
	{
		return true;
	}

	@ConfigItem(
			position = 4,
			keyName = CURRENT_OPTION_RENDER_KEY,
			name = "Current Render",
			description = "The rendering style of the load menu option for the currently enabled preset",
			section = currentOptionStylePanel
	)
	default CURRENT_OPTION_STYLE currentOptionRendering()
	{
		return CURRENT_OPTION_STYLE.GREY_OUT;
	}

	@ConfigItem(
			position = 5,
			keyName = CURRENT_OPTION_COLOR_KEY,
			name = "Current Custom Color",
			description = "The custom color used for the current load menu option, when Current Render is set to [Custom Coloring]",
			section = currentOptionStylePanel
	)
	default Color currentOptionCustomColor()
	{
		return new Color(37, 150, 190);
	}

	@ConfigItem(
			position = 6,
			keyName = MODIFY_OPTION_RENDER_KEY,
			name = "Modify Render",
			description = "The rendering style of the Edit-preset and Hide-preset options",
			section = modifyOptionStylePanel
	)
	default MODIFY_OPTION_STYLE modifyOptionRendering()
	{
		return MODIFY_OPTION_STYLE.ALWAYS_RENDER;
	}

	@ConfigItem(
			position = 7,
			keyName = MODIFY_OPTION_HOTKEY_KEY,
			name = "Modify Key",
			description = "Holding this key renders the edit and hide preset options on spellbook right-click, when Modify Render is set to [Hotkey]",
			section = modifyOptionStylePanel
	)
	default Keybind modifyOptionsKey()
	{
		return new Keybind(KeyEvent.VK_E, 0);
	}

	@ConfigItem(
			position = 8,
			keyName = NO_LOAD_OPTIONS_KEY,
			name = "No Load Ops",
			description = "When hotkey is held, load preset options won't be rendered",
			section = modifyOptionStylePanel
	)
	default boolean noLoadOps()
	{
		return true;
	}
}

/*
 * Copyright (c) 2024, Adam <Adam@sigterm.info>
 * Copyright (c) 2025, Jamal <http://github.com/1Defence>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.example;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.IntStream;
import javax.inject.Inject;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.ItemComposition;
import net.runelite.api.ParamID;
import net.runelite.api.ScriptID;
import net.runelite.api.events.DraggingWidgetChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

import static com.example.SpellbookPresetsConfig.*;
import static net.runelite.api.widgets.WidgetConfig.DRAG;
import static net.runelite.api.widgets.WidgetConfig.DRAG_ON;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.menus.WidgetMenuOption;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;

import net.runelite.client.util.ColorUtil;

@PluginDescriptor(
		name = "Spellbook Presets",
		description = "Filtered spellbook presets, select spells you want to show for each given preset",
		conflicts = "Spellbook"
)
@Slf4j
public class SpellbookPresetsPlugin extends Plugin
{

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MenuManager menuManager;

	@Inject
	private Gson gson;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	public ConfigManager configManager;

	@Inject
	private SpellbookPresetsConfig config;

	@Inject
	public ImportExportHandler importExportHandler;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private KeyManager keyManager;

	private static final String LOCK = "Save-spells";
	private static final String UNLOCK = "Edit-spells";
	// [proc,magic_spellbook_modifyops] shifts around ops, but seems to only use
	// 1 2 3 4 5 10. So use 6 for Hide/Unhide.
	private static final int HIDE_UNHIDE_OP = 6;

	private static final String DISABLE = "Hide preset";
	private static final String ENABLE = "Show preset";

	private static final Color MENU_NAME_COLOR_STANDARD = new Color(255, 144, 64);
	private static final Color MENU_NAME_COLOR_GREYOUT = new Color(128,128,128);

	//menu ops for the 3 client sizes for editing/saving a preset & hiding/showing a preset
	private static final int FIXED_MAGIC_TAB_ID = InterfaceID.Toplevel.STONE6;
	private static final int RESIZABLE_A_MAGIC_TABID = InterfaceID.ToplevelOsrsStretch.STONE6;
	private static final int RESIZABLE_B_MAGIC_TABID = InterfaceID.ToplevelPreEoc.STONE6;

	/**Fixed**/
	private static final WidgetMenuOption LOCK_MENU_FIXED = new WidgetMenuOption(LOCK, "", FIXED_MAGIC_TAB_ID);
	private static final WidgetMenuOption UNLOCK_MENU_FIXED = new WidgetMenuOption(UNLOCK, "", FIXED_MAGIC_TAB_ID);
	private static final WidgetMenuOption DISABLE_MENU_FIXED = new WidgetMenuOption(DISABLE, "", FIXED_MAGIC_TAB_ID);
	private static final WidgetMenuOption ENABLE_MENU_FIXED = new WidgetMenuOption(ENABLE, "", FIXED_MAGIC_TAB_ID);

	/**Resizable Top**/
	private static final WidgetMenuOption LOCK_MENU_RESIZE_A = new WidgetMenuOption(LOCK, "", RESIZABLE_A_MAGIC_TABID);
	private static final WidgetMenuOption UNLOCK_MENU_RESIZE_A = new WidgetMenuOption(UNLOCK, "", RESIZABLE_A_MAGIC_TABID);
	private static final WidgetMenuOption DISABLE_MENU_RESIZE_A = new WidgetMenuOption(DISABLE, "", RESIZABLE_A_MAGIC_TABID);
	private static final WidgetMenuOption ENABLE_MENU_RESIZE_A = new WidgetMenuOption(ENABLE, "", RESIZABLE_A_MAGIC_TABID);

	/**Resizable Bottom**/
	private static final WidgetMenuOption LOCK_MENU_RESIZE_B = new WidgetMenuOption(LOCK, "", RESIZABLE_B_MAGIC_TABID);
	private static final WidgetMenuOption UNLOCK_MENU_RESIZE_B = new WidgetMenuOption(UNLOCK, "", RESIZABLE_B_MAGIC_TABID);
	private static final WidgetMenuOption DISABLE_MENU_RESIZE_B = new WidgetMenuOption(DISABLE, "", RESIZABLE_B_MAGIC_TABID);
	private static final WidgetMenuOption ENABLE_MENU_RESIZE_B = new WidgetMenuOption(ENABLE, "", RESIZABLE_B_MAGIC_TABID);


	private final int visibleOpacity = 0;
	private final int hiddenOpacity = 200;

	private boolean reordering;
	private boolean showAllIfEmpty;
	private boolean filteringEnabled;

	public String currentPreset = "";

	private SWAP_MODE configSwapMode;
	private CURRENT_OPTION_STYLE configCurrentOpRenderStyle;
	private Color configCurrentOpCustomColor;
	private MODIFY_OPTION_STYLE configModifyOpRenderStyle;
	private boolean configNoLoadOps = false;
	private OPEN_TAB_CONDITION configOpenTabCondition;
	private boolean configDisplayPresetsPanel = false;
	private boolean modifyOpHotkeyHeld = false;

	@Getter(AccessLevel.PACKAGE)
	private List<String> presets = new ArrayList<>();
	private final List<WidgetMenuOption> managedMenus = new ArrayList<>();

	private Map<Integer, Map<Integer, SpellData>> spellbooks = new HashMap<>();

	public SaveEditPanel sidePanel;

	private NavigationButton navButton_panel;

	private final HotkeyListener modifyOptionsKeyListener = new HotkeyListener(() -> config.modifyOptionsKey())
	{
		@Override
		public void hotkeyPressed()
		{
			modifyOpHotkeyHeld = true;
			refreshReorderMenus();
		}
		@Override
		public void hotkeyReleased()
		{
			modifyOpHotkeyHeld = false;
			refreshReorderMenus();
		}
	};

	@Provides
	SpellbookPresetsConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SpellbookPresetsConfig.class);
	}

	@Override
	protected void startUp()
	{
		//currently just sets and exists, used for future migration if data handling changes.
		configManager.setConfiguration(GROUP,LAST_VERSION_KEY, LIVE_VERSION_STRING);
		cacheConfigs();

		modifyOpHotkeyHeld = false;
		if(configModifyOpRenderStyle == MODIFY_OPTION_STYLE.HOTKEY){
			keyManager.registerKeyListener(modifyOptionsKeyListener);
		}

		String cachedPreset = configManager.getConfiguration(GROUP,CURRENT_PRESET_KEY);
		if(!Strings.isNullOrEmpty(cachedPreset) && presets.contains(cachedPreset)){
			changePreset(cachedPreset);
		}else{
			updatePreset();
		}

		filteringEnabled = true;
		reordering = false;
		refreshReorderMenus();
		clientThread.invokeLater(this::reinitializeSpellbook);

		sidePanel = new SaveEditPanel(this, configManager, gson);

		final BufferedImage icon = ImageUtil.loadImageResource(SpellbookPresetsPlugin.class, "icon_panel.png");
		navButton_panel = NavigationButton.builder()
				.tooltip("Spellbook Presets")
				.icon(icon)
				.priority(1)
				.panel(sidePanel)
				.build();

		if(configDisplayPresetsPanel)
		{
			clientToolbar.addNavigation(navButton_panel);
		}
	}

	@Override
	protected void shutDown()
	{
		keyManager.unregisterKeyListener(modifyOptionsKeyListener);
		clearReoderMenus();
		clientThread.invokeLater(this::cleanupSpellbook);
		clientThread.invokeLater(this::reinitializeSpellbook);
		clientToolbar.removeNavigation(navButton_panel);
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged event)
	{
		clientThread.invokeLater(this::redrawSpellbook);
	}

	/**Generate preset list from config actives*/
	public List<String> activePresetsFromConfig(){
		String json = configManager.getConfiguration(GROUP, ACTIVE_PRESETS_KEY);
		if (Strings.isNullOrEmpty(json))
		{
			return new ArrayList<>();
		}
		return gson.fromJson(json, new TypeToken<List<String>>(){}.getType());
	}

	/**cache config values on start*/
	public void cacheConfigs(){
		showAllIfEmpty = config.showAllIfEmpty();
		presets = activePresetsFromConfig();
		configSwapMode = config.spellMoveMode();
		configCurrentOpRenderStyle = config.currentOptionRendering();
		configCurrentOpCustomColor = config.currentOptionCustomColor();
		configModifyOpRenderStyle = config.modifyOptionRendering();
		configNoLoadOps = config.noLoadOps();
		configOpenTabCondition = config.openTabCondition();
		configDisplayPresetsPanel = config.displayPresetsPanel();
	}

	/**updates current preset if actives no longer contains it*/
	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(GROUP))
		{
			return;
		}

		switch (configChanged.getKey()){
			case SPELL_MOVE_MODE_KEY:
				configSwapMode = config.spellMoveMode();
				break;
			case SHOW_ALL_IF_EMPTY_KEY:
				showAllIfEmpty = config.showAllIfEmpty();
				clientThread.invokeLater(this::reinitializeSpellbook);
				break;
			case ACTIVE_PRESETS_KEY:
				presets = activePresetsFromConfig();
				if(!presets.contains(currentPreset)){
					//current preset should no longer be active, update it.
					updatePreset();
				}else{
					//list changed refresh menu ops
					refreshReorderMenus();
				}
				break;
			case CURRENT_OPTION_RENDER_KEY:
			case CURRENT_OPTION_COLOR_KEY:
				configCurrentOpCustomColor = config.currentOptionCustomColor();
				configCurrentOpRenderStyle = config.currentOptionRendering();
				refreshReorderMenus();
				break;
			case MODIFY_OPTION_RENDER_KEY:
				configModifyOpRenderStyle = config.modifyOptionRendering();
				if(configModifyOpRenderStyle == MODIFY_OPTION_STYLE.ALWAYS_RENDER){
					keyManager.unregisterKeyListener(modifyOptionsKeyListener);
					modifyOpHotkeyHeld = false;
				}else{
					keyManager.registerKeyListener(modifyOptionsKeyListener);
				}
				refreshReorderMenus();
				break;
			case NO_LOAD_OPTIONS_KEY:
				configNoLoadOps = config.noLoadOps();
				break;
			case OPEN_TAB_CONDITION_KEY:
				configOpenTabCondition = config.openTabCondition();
				break;
			case DISPLAY_PRESETS_PANEL_KEY:
				configDisplayPresetsPanel = config.displayPresetsPanel();
				if(configDisplayPresetsPanel)
				{
					clientToolbar.addNavigation(navButton_panel);
				}else{
					clientToolbar.removeNavigation(navButton_panel);
				}
				break;

		}

	}

	/**resets all stored config data of our presets.*/
	@Override
	public void resetConfiguration()
	{
		for (var key : configManager.getConfigurationKeys(GROUP + ".spellbookData_"))
		{
			String[] str = key.split("\\.", 2);
			if (str.length == 2)
			{
				configManager.unsetConfiguration(str[0], str[1]);
			}
		}

		configManager.unsetConfiguration(GROUP,ACTIVE_PRESETS_KEY);
		sidePanel.Refresh();

		clientThread.invokeLater(this::redrawSpellbook);

		log.debug("Reset spellbooks");
	}

	/**slight changes to SpellbookPlugin, removes the extra static menus and the list of dynamic menus created in refreshReorderMenus*/
	private void clearReoderMenus()
	{
		menuManager.removeManagedCustomMenu(LOCK_MENU_FIXED);
		menuManager.removeManagedCustomMenu(LOCK_MENU_RESIZE_A);
		menuManager.removeManagedCustomMenu(LOCK_MENU_RESIZE_B);

		menuManager.removeManagedCustomMenu(UNLOCK_MENU_FIXED);
		menuManager.removeManagedCustomMenu(UNLOCK_MENU_RESIZE_A);
		menuManager.removeManagedCustomMenu(UNLOCK_MENU_RESIZE_B);

		menuManager.removeManagedCustomMenu(DISABLE_MENU_FIXED);
		menuManager.removeManagedCustomMenu(DISABLE_MENU_RESIZE_A);
		menuManager.removeManagedCustomMenu(DISABLE_MENU_RESIZE_B);

		menuManager.removeManagedCustomMenu(ENABLE_MENU_FIXED);
		menuManager.removeManagedCustomMenu(ENABLE_MENU_RESIZE_A);
		menuManager.removeManagedCustomMenu(ENABLE_MENU_RESIZE_B);

		for (WidgetMenuOption widgetMenuOption : managedMenus)
		{
			menuManager.removeManagedCustomMenu(widgetMenuOption);
		}
		managedMenus.clear();
	}

	/**rather than disabling the plugin for a one-off spell(i.e a teleport), user can temporarily disable filtering*/
	private void toggleFiltering(boolean state){
		filteringEnabled = state;
		refreshReorderMenus();
		redrawSpellbook();
	}

	/**many changes to SpellbookPlugin, added menu for every active preset and menu for enabling and disabling filters to the 3 client sizes.
	 * this might be excessive due to the 3 client sizes, possibly add checks and conditionally add the menus instead.*/
	private void refreshReorderMenus()
	{
		clearReoderMenus();

		if(presets.isEmpty())
		{
			return;
		}

		if (reordering)
		{
			menuManager.addManagedCustomMenu(LOCK_MENU_FIXED, e -> reordering(false));
			menuManager.addManagedCustomMenu(LOCK_MENU_RESIZE_A, e -> reordering(false));
			menuManager.addManagedCustomMenu(LOCK_MENU_RESIZE_B, e -> reordering(false));
		}
		else
		{

			//for those who don't want the extra clutter of options they don't use often they will only render while holding their chosen key.
			if(configModifyOpRenderStyle == MODIFY_OPTION_STYLE.ALWAYS_RENDER || modifyOpHotkeyHeld)
			{
				String currentPresetColored = ColorUtil.wrapWithColorTag(currentPreset, MENU_NAME_COLOR_STANDARD);
				String currentOp = "Edit " + currentPresetColored;

				UNLOCK_MENU_FIXED.setMenuOption(currentOp);
				menuManager.addManagedCustomMenu(UNLOCK_MENU_FIXED, e -> reordering(true));
				UNLOCK_MENU_RESIZE_A.setMenuOption(currentOp);
				menuManager.addManagedCustomMenu(UNLOCK_MENU_RESIZE_A, e -> reordering(true));
				UNLOCK_MENU_RESIZE_B.setMenuOption(currentOp);
				menuManager.addManagedCustomMenu(UNLOCK_MENU_RESIZE_B, e -> reordering(true));

				if (filteringEnabled)
				{
					menuManager.addManagedCustomMenu(DISABLE_MENU_FIXED, e -> toggleFiltering(false));
					menuManager.addManagedCustomMenu(DISABLE_MENU_RESIZE_A, e -> toggleFiltering(false));
					menuManager.addManagedCustomMenu(DISABLE_MENU_RESIZE_B, e -> toggleFiltering(false));
				} else
				{
					menuManager.addManagedCustomMenu(ENABLE_MENU_FIXED, e -> toggleFiltering(true));
					menuManager.addManagedCustomMenu(ENABLE_MENU_RESIZE_A, e -> toggleFiltering(true));
					menuManager.addManagedCustomMenu(ENABLE_MENU_RESIZE_B, e -> toggleFiltering(true));
				}

				if(modifyOpHotkeyHeld && configNoLoadOps){
					return;
				}

			}

			for (String preset : presets)
			{
				Color col = MENU_NAME_COLOR_STANDARD;
				if(preset.equals(currentPreset)){
					switch (configCurrentOpRenderStyle){
						case NO_RENDER:
							continue;
						case GREY_OUT:
							col = MENU_NAME_COLOR_GREYOUT;
							break;
						case CUSTOM_COLOR:
							col = configCurrentOpCustomColor;
							break;
					}
				}

				String presetColored = ColorUtil.wrapWithColorTag(preset, col);
				String option = "Load "+presetColored;

				WidgetMenuOption unlockFixed = new WidgetMenuOption(option, "", FIXED_MAGIC_TAB_ID);
				menuManager.addManagedCustomMenu(unlockFixed, e -> changePreset(preset));
				managedMenus.add(unlockFixed);

				WidgetMenuOption unlockResizebleA = new WidgetMenuOption(option, "", RESIZABLE_A_MAGIC_TABID);
				menuManager.addManagedCustomMenu(unlockResizebleA, e -> changePreset(preset));
				managedMenus.add(unlockResizebleA);

				WidgetMenuOption unlockResizebleB = new WidgetMenuOption(option, "", RESIZABLE_B_MAGIC_TABID);
				menuManager.addManagedCustomMenu(unlockResizebleB, e -> changePreset(preset));
				managedMenus.add(unlockResizebleB);
			}

		}
	}

	/**change to a specifed preset, additionally re-enabling filtering if disabled.*/
	public void changePreset(String preset){
		filteringEnabled = true;
		currentPreset = preset;
		reordering = false;
		spellbooks = getSpellbooks(preset);
		refreshReorderMenus();
		configManager.setConfiguration(GROUP, CURRENT_PRESET_KEY, preset);
		clientThread.invokeLater(this::reinitializeSpellbook);
		requestMagicTabOpen(OPEN_TAB_CONDITION.LOAD_PRESET);
	}

	/**update the current preset after changes have occured*/
	private void updatePreset(){
		if(presets.isEmpty() ){
			//if no presets, cleanup spellbook and menu ops similar to a shutdown
			clientThread.invokeLater(() ->
			{
				clearReoderMenus();
				cleanupSpellbook();
				reinitializeSpellbook();
			});
		}else if(currentPreset.isEmpty() || !presets.contains(currentPreset)){
			//list of actives exists, current preset is blank or no longer part of the active presets list, default to the first active preset
			changePreset(presets.get(0));
		}else{
			//current preset active and exists, it's likely changed in some other manner refresh it.
			changePreset(currentPreset);
		}
	}

	/**Slight changes to SpellbookPlugin, saves collection of spells to config on reorder-end, modified game message.*/
	private void reordering(boolean state)
	{
		reordering = state;

		var message = reordering ?
				"[Spellbook Presets] Editing spellbook ("+currentPreset+")." :
				"[Spellbook Presets] Saved spellbook ("+currentPreset+")." ;

		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());

		if(!state){
			//spellbook has just been edited, more than likely the user wants the spells to be filtered again.
			filteringEnabled = true;
			//save spells all at once on reorder-end
			saveSpellbooks(currentPreset,spellbooks);
		}

		refreshReorderMenus();

		redrawSpellbook();

		if(reordering){
			requestMagicTabOpen(OPEN_TAB_CONDITION.EDIT_PRESET);
		}

	}

	/**Attempt to open the magic tab
	 * occurs on menu-op selection & if user starts the plugin or removes their current preset from active list
	 * which menu triggers this depends on user-preference
	 * Edit-spellbook | Load-preset | None*/
	public void requestMagicTabOpen(OPEN_TAB_CONDITION condition){
		if((configOpenTabCondition.value & condition.value) == 0)
			return;

		int tabScriptId = 915;
		int magicTabId = 6;
		clientThread.invokeLater(() ->
		{
			client.runScript(tabScriptId, magicTabId);
		});
	}

	/**Unchanged, matches SpellbookPlugin*/
	@Subscribe
	public void onScriptPreFired(ScriptPreFired event)
	{
		if (event.getScriptId() == ScriptID.MAGIC_SPELLBOOK_INITIALISESPELLS)
		{
			int[] stack = client.getIntStack();
			int sz = client.getIntStackSize();
			int spellBookEnum = stack[sz - 12]; // eg 1982, 5285, 1983, 1984, 1985
			clientThread.invokeLater(() -> initializeSpells(spellBookEnum));
		}
	}

	/**Slight changes to SpellbookPlugin, option to swap spell instead of inserting.*/
	@Subscribe
	public void onDraggingWidgetChanged(DraggingWidgetChanged event)
	{
		if (event.isDraggingWidget() && client.getMouseCurrentButton() == 0)
		{
			Widget draggedWidget = client.getDraggedWidget();
			Widget draggedOnWidget = client.getDraggedOnWidget();
			if (draggedWidget == null || draggedOnWidget == null)
			{
				return;
			}

			int draggedGroupId = WidgetUtil.componentToInterface(draggedWidget.getId());
			int draggedOnGroupId = WidgetUtil.componentToInterface(draggedOnWidget.getId());
			if (draggedGroupId != InterfaceID.MAGIC_SPELLBOOK || draggedOnGroupId != InterfaceID.MAGIC_SPELLBOOK)
			{
				return;
			}

			// from ~magic_spellbook_redraw
			int subSpellbookId = client.getEnum(EnumID.SPELLBOOKS_SUB).getIntValue(client.getVarbitValue(VarbitID.SPELLBOOK));
			int spellbookId = client.getEnum(subSpellbookId).getIntValue(client.getVarbitValue(VarbitID.SPELLBOOK_SUBLIST));

			EnumComposition spellbook = client.getEnum(spellbookId);
			int[] order = calculateSpellbookOrder(spellbookId, spellbook); // in enum indices

			int fromIdx = findSpellIdxForComponent(spellbook, order, draggedWidget);
			int toIdx = findSpellIdxForComponent(spellbook, order, draggedOnWidget);

			ItemComposition fromSpell = client.getItemDefinition(spellbook.getIntValue(order[fromIdx]));
			ItemComposition toSpell = client.getItemDefinition(spellbook.getIntValue(order[toIdx]));

			log.debug("Insert {} ({}) at {} ({}) spellbook {}",
					fromSpell.getStringValue(ParamID.SPELL_NAME), fromIdx,
					toSpell.getStringValue(ParamID.SPELL_NAME), toIdx,
					spellbookId);

			log.debug("Set {} to {}", client.getItemDefinition(spellbook.getIntValue(order[fromIdx])).getStringValue(ParamID.SPELL_NAME), toIdx);
			setPosition(spellbookId, spellbook.getIntValue(order[fromIdx]), toIdx);

			if(configSwapMode == SWAP_MODE.SWAP)
			{
				log.debug("Set {} to {}", client.getItemDefinition(spellbook.getIntValue(order[toIdx])).getStringValue(ParamID.SPELL_NAME), fromIdx);
				setPosition(spellbookId, spellbook.getIntValue(order[toIdx]), fromIdx);
			}else if(configSwapMode == SWAP_MODE.INSERT){
				if (fromIdx < toIdx)
				{
					for (int i = fromIdx + 1; i <= toIdx; ++i)
					{
						log.debug("Set {} to {}", client.getItemDefinition(spellbook.getIntValue(order[i])).getStringValue(ParamID.SPELL_NAME), i - 1);
						setPosition(spellbookId, spellbook.getIntValue(order[i]), i - 1);
					}
				}
				else
				{
					for (int i = toIdx; i < fromIdx; ++i)
					{
						log.debug("Set {} to {}", client.getItemDefinition(spellbook.getIntValue(order[i])).getStringValue(ParamID.SPELL_NAME), i + 1);
						setPosition(spellbookId, spellbook.getIntValue(order[i]), i + 1);
					}
				}
			}
			redrawSpellbook();
		}
	}

	/**Unchanged, matches SpellbookPlugin*/
	private int findSpellIdxForComponent(EnumComposition spellbook, int[] spells, Widget c)
	{
		for (int i = 0; i < spells.length; ++i)
		{
			ItemComposition spellObj = client.getItemDefinition(spellbook.getIntValue(spells[i]));
			Widget w = client.getWidget(spellObj.getIntValue(ParamID.SPELL_BUTTON));
			if (w == c)
			{
				return i;
			}
		}
		return -1;
	}

	/**Many changes to SpellbookPlugin,
	 * invoke later on set opacity recolors CoolDown spells(H group,veng magic imbue etc) -- not proper fix for core plugin cause it can cause a slight flicker.
	 * cleans up spells if no filters selected or filtering is disabled
	 * additionally isHidden->isShown and different opacity defaults.
	 * Occurs on load, reorder start, reorder end*/
	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!"spellbookSort".equals(event.getEventName()))
		{
			return;
		}

		createWarning(reordering);

		// this is called after ~magic_spellbook_redraw has built and sorted the array of visible spells
		// based on the vanilla filtering

		int[] stack = client.getIntStack();
		int size = client.getIntStackSize();

		int spellbookEnumId = stack[size - 3];
		int spellArrayId = stack[size - 2];
		int numSpells = stack[size - 1];

		EnumComposition spellbookEnum = client.getEnum(spellbookEnumId);
		int[] spells = client.getArray(spellArrayId); // enum indices
		int[] newSpells = new int[numSpells];
		int numNewSpells = 0;


		// the specified book has no modifications and the user wants all spells to be displayed in said situation.
		// this likely makes more sense than displaying an empty book.
		// additionally, if the user has temporarily disabled filtering (e.x to use a one off teleport) display the entire spellbook.
		// if the user has no presets active, display spellbook as normal.
		Map<Integer, SpellData> book = spellbooks.get(spellbookEnumId);
		boolean bookIsEmpty = book == null || book.isEmpty();
		if(showAllIfEmpty && !bookIsEmpty){
			//Verify the contents aren't all hidden, this can happen when spells have a modified position but none of them are set visible by user.
			//while you could clear the map on save to prevent said situation, we want to retain the current positioning status incase the user wants to modify this set later.
			boolean hasAnyModifiedSpell = false;
			for (SpellData spellData : book.values())
			{
				if(spellData.getHidden()){
					hasAnyModifiedSpell = true;
					break;
				}
			}
			if(!hasAnyModifiedSpell){
				bookIsEmpty = true;
			}
		}
		if(!reordering
				&& ((bookIsEmpty && showAllIfEmpty) || !filteringEnabled || presets.isEmpty())){
			cleanupSpells(spellbookEnumId);
			return;
		}

		for (int i = 0; i < numSpells; ++i)
		{
			ItemComposition spellObj = client.getItemDefinition(spellbookEnum.getIntValue(spells[i]));
			Widget w = client.getWidget(spellObj.getIntValue(ParamID.SPELL_BUTTON));
			boolean shown = isShown(spellbookEnumId, spellObj.getId());

			int widgetConfig = w.getClickMask();
			if (reordering)
			{
				if (shown)
				{
					clientThread.invokeLater(() ->
					{
						w.setOpacity(visibleOpacity);
						w.setAction(HIDE_UNHIDE_OP, "Hide");
					});
				}
				else
				{
					clientThread.invokeLater(() ->
					{
						w.setOpacity(hiddenOpacity);
						w.setAction(HIDE_UNHIDE_OP, "Show");
					});
				}

				newSpells[numNewSpells++] = spells[i];
				widgetConfig |= DRAG | DRAG_ON;
			}
			else
			{
				if (shown)
				{
					newSpells[numNewSpells++] = spells[i];
					w.setOpacity(visibleOpacity);
					w.setAction(HIDE_UNHIDE_OP, null);
				}
				else
				{
					w.setHidden(true);
				}

				widgetConfig &= ~(DRAG | DRAG_ON);
			}
			w.setClickMask(widgetConfig);
		}

		// Sort newSpells based on their configured order
		int[] order = calculateSpellbookOrder(spellbookEnumId, spellbookEnum);
		int[] indices = new int[order.length];
		for (int i = 0; i < order.length; ++i)
		{
			indices[order[i]] = i;
		}
		newSpells = Arrays.stream(newSpells, 0, numNewSpells)
				.boxed()
				.sorted(Comparator.comparingInt(i -> indices[i]))
				.mapToInt(i -> i)
				.toArray();

		System.arraycopy(newSpells, 0, spells, 0, numNewSpells);
		stack[size - 1] = numSpells = numNewSpells;
	}

	/**If theres a pending config change and user is about to rightclick the spellbook, instantly update the config and thus the options.
	 * move functionality if theres ever an event for cursor leaving the panel.*/
	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e){
		if(sidePanel.configUpdateTimer == null)
			return;
		if(e.getOption().equals("Magic")){
			sidePanel.forcePendingConfig();
		}
	}

	/**Slight changes to SpellbookPlugin, added null check for widget so shutdown doesn't cause NPE*/
	private void createWarning(boolean unlocked)
	{
		Widget w = client.getWidget(InterfaceID.MagicSpellbook.UNIVERSE);
		if(w != null)
		{
			w.deleteAllChildren();

			if (unlocked)
			{
				Widget c = w.createChild(WidgetType.RECTANGLE);
				c.setHeightMode(WidgetSizeMode.MINUS);
				c.setWidthMode(WidgetSizeMode.MINUS);
				c.setTextColor(0xff0000);
				c.setFilled(true);
				c.setOpacity(220);
				c.revalidate();
			}

		}
	}

	/**Slight changes to SpellbookPlugin, mainly isHidden->isShown and different opacity defaults.
	 * This is called when hiding/unhiding spells*/
	private void initializeSpells(int spellbookEnum)
	{
		EnumComposition spellbook = client.getEnum(spellbookEnum);
		for (int i = 0; i < spellbook.size(); ++i)
		{
			int spellObjId = spellbook.getIntValue(i);
			ItemComposition spellObj = client.getItemDefinition(spellObjId);
			int spellComponent = spellObj.getIntValue(ParamID.SPELL_BUTTON);
			Widget w = client.getWidget(spellComponent);

			// spells with no target mask have an existing op listener, capture it to
			// call it later
			Object[] opListener = w.getOnOpListener();
			w.setOnOpListener((JavaScriptCallback) e ->
			{
				if (e.getOp() == HIDE_UNHIDE_OP + 1)
				{
					Widget s = e.getSource();

					// Spells can be shared between spellbooks, so we can't assume spellbookEnum is the current spellbook.
					// from ~magic_spellbook_redraw
					int subSpellbookId = client.getEnum(EnumID.SPELLBOOKS_SUB).getIntValue(client.getVarbitValue(VarbitID.SPELLBOOK));
					int spellbookId = client.getEnum(subSpellbookId).getIntValue(client.getVarbitValue(VarbitID.SPELLBOOK_SUBLIST));

					boolean shown = isShown(spellbookId, spellObjId);
					shown = !shown;

					log.debug("Changing {} to hidden: {}", s.getName(), shown);
					setHidden(spellbookId, spellObjId, shown);

					s.setOpacity(shown ? visibleOpacity : hiddenOpacity);
					s.setAction(HIDE_UNHIDE_OP, shown ? "Hide" : "Show");
					return;
				}

				if (opListener != null)
				{
					client.runScript(opListener);
				}
			});
		}
	}

	/**for the given spellbook, remove hide/unhide op and reset the opacity of the spells*/
	private void cleanupSpells(int spellbookEnum)
	{
		EnumComposition spellbook = client.getEnum(spellbookEnum);
		for (int i = 0; i < spellbook.size(); ++i)
		{
			int spellObjId = spellbook.getIntValue(i);
			ItemComposition spellObj = client.getItemDefinition(spellObjId);
			int spellComponent = spellObj.getIntValue(ParamID.SPELL_BUTTON);
			Widget w = client.getWidget(spellComponent);
			if(w != null)
			{
				w.setAction(HIDE_UNHIDE_OP, null);
				w.setOpacity(visibleOpacity);
			}
		}
	}

	/**Unchanged, matches SpellbookPlugin*/
	private void reinitializeSpellbook()
	{
		Widget w = client.getWidget(InterfaceID.MagicSpellbook.UNIVERSE);
		if (w != null && w.getOnLoadListener() != null)
		{
			client.createScriptEvent(w.getOnLoadListener())
					.setSource(w)
					.run();
		}
	}

	/**Unchanged, matches SpellbookPlugin*/
	private void redrawSpellbook()
	{
		Widget w = client.getWidget(InterfaceID.MagicSpellbook.UNIVERSE);
		if (w != null && w.getOnInvTransmitListener() != null)
		{
			client.createScriptEvent(w.getOnInvTransmitListener())
					.setSource(w)
					.run();
		}
	}

	/**called on shutdown, removes hide/unhide ops and restores opacity to all spells & deletes red warning pane if present.*/
	private void cleanupSpellbook()
	{
		reordering = false;

		Widget w = client.getWidget(InterfaceID.MagicSpellbook.UNIVERSE);
		if(w != null)
		{
			w.deleteAllChildren();
		}

		cleanupSpells(1982);
		cleanupSpells(5285);
		cleanupSpells(1983);
		cleanupSpells(1984);
		cleanupSpells(1985);
	}

	/**Unchanged, matches SpellbookPlugin*/
	private int[] calculateSpellbookOrder(int spellbookId, EnumComposition spellbook)
	{
		int[] spells = defaultSpellbookOrder(spellbook);
		int[] indices = new int[spells.length]; // spell to desired index
		for (int i = 0; i < spells.length; ++i)
		{
			int pos = getPosition(spellbookId, spellbook.getIntValue(spells[i]));
			indices[spells[i]] = pos != -1 ? pos : i;
		}

		// sort by desired index
		return Arrays.stream(spells)
				.boxed()
				.sorted(Comparator.comparingInt(i -> indices[i]))
				.mapToInt(i -> i)
				.toArray();
	}

	/**Unchanged, matches SpellbookPlugin*/
	private int[] defaultSpellbookOrder(EnumComposition spellbook)
	{
		return IntStream.range(0, spellbook.size())
				.boxed()
				.sorted((idx1, idx2) ->
				{
					var i1 = client.getItemDefinition(spellbook.getIntValue(idx1));
					var i2 = client.getItemDefinition(spellbook.getIntValue(idx2));
					int l1 = i1.getIntValue(ParamID.SPELL_LEVELREQ);
					int l2 = i2.getIntValue(ParamID.SPELL_LEVELREQ);
					return Integer.compare(l1, l2);
				})
				.mapToInt(i -> i)
				.toArray();
	}

	/**Rename preset, return the result of its success.*/
	public boolean renameSpellbooks(String originalPreset, String updatedPreset){
		if(updatedPreset.length() >= 50)
			return false;

		boolean configAlreadyExists = spellbooksKeyExists(updatedPreset);
		if(configAlreadyExists)
			return false;

		saveSpellbooks(
				updatedPreset,
				getSpellbooks(originalPreset));
		removeSpellbooksKey(originalPreset);
		return true;
	}

	/**Check if preset config key exists*/
	public boolean spellbooksKeyExists(String preset)
	{
		return configManager.getConfiguration(GROUP,"spellbookData_"+preset) != null;
	}

	/**Clear preset from config*/
	public void removeSpellbooksKey(String preset){
		configManager.unsetConfiguration(GROUP,"spellbookData_"+preset);
	}


	/**Add empty preset of name to config*/
	public boolean addSpellBooksKey(String preset){
		boolean configAlreadyExists = configManager.getConfiguration(GROUP,"spellbookData_"+preset) != null;
		if(configAlreadyExists)
		{
			return false;
		}

		saveSpellbooks(preset,new HashMap<>());
		return true;
	}


	/**Converts collection of spellbooks (spellbookid->(spellid,spelldata)) to json
	 * Saves the json to config with the name of given preset
	 * Only called on redorder-end for performance.*/
	public void saveSpellbooks(String preset, Map<Integer, Map<Integer, SpellData>> data){
		String json = gson.toJson(data);
		configManager.setConfiguration(GROUP, "spellbookData_"+preset, json);
		log.debug("setting "+preset +" > "+json);
	}

	/**returns a collection of spellbook > spellData
	 * ex lunarId, {spellid,spelldata}
	 * .. normalId, {spell,spelldata}
	 * instead of editing the config every spell edit, we modify this mapping. when edit mode is left we save the mapping to config as a whole.*/
	public Map<Integer, Map<Integer, SpellData>> getSpellbooks(String preset){
		String json = configManager.getConfiguration(GROUP, "spellbookData_"+preset);
		if (Strings.isNullOrEmpty(json))
		{
			return new HashMap<>();
		}
		return gson.fromJson(json, new TypeToken<Map<Integer, Map<Integer, SpellData>>>(){}.getType());
	}

	/**sets spelldata to be hidden, adds book of spellbookId to spellbooks if missing*/
	private void setHidden(int spellbookId, int spellId, boolean hidden) {
		Map<Integer, SpellData> book = spellbooks.computeIfAbsent(spellbookId, k -> new HashMap<>());

		SpellData spell = book.computeIfAbsent(spellId, k -> new SpellData(-1, false));
		spell.setHidden(hidden);

		if (spell.isUnused()) {
			book.remove(spellId);
		}
	}

	/**sets spelldata position, adds book of spellbookId to spellbooks if missing*/
	private void setPosition(int spellbookId, int spellId, int position) {
		Map<Integer, SpellData> book = spellbooks.computeIfAbsent(spellbookId, k -> new HashMap<>());

		SpellData spell = book.computeIfAbsent(spellId, k -> new SpellData(-1, false));
		spell.setPosition(position);

		if (spell.isUnused()) {
			book.remove(spellId);
		}
	}

	/**indicates the spell in the current book should be visible (defaults to false if not present)*/
	private boolean isShown(int spellbookId, int spellId) {
		Map<Integer, SpellData> book = spellbooks.get(spellbookId);
		if (book == null) {
			return false;
		}
		SpellData spell = book.get(spellId);
		if (spell == null) {
			return false;
		}
		return spell.getHidden();
	}

	/**the position of the current spell if tracked. (defaults to -1 if not present)*/
	private int getPosition(int spellbookId, int spellId) {
		Map<Integer, SpellData> book = spellbooks.get(spellbookId);
		if (book == null) {
			return -1;
		}
		SpellData spell = book.get(spellId);
		if (spell == null) {
			return -1;
		}
		return spell.getPosition();
	}
}
/*
 * Copyright (c) 2025, Jamal <http://github.com/1Defence>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.example;

public class SpellData
{
    //short names to reduce clutter and save space in serialized json
    int p;//spell position
    int h;//spell hidden

    public SpellData(int position,boolean hidden){
        this.p = position;
        this.h = convertBooleanToInt(hidden);
    }

    public int getPosition(){return p;}
    public boolean getHidden(){return h == 1;}

    public void setHidden(boolean hidden){
        this.h = convertBooleanToInt(hidden);
    }

    public void setPosition(int position){
        this.p = position;
    }

    /**this indicates the spells values are default; as such we want to avoid saving the extra data to config.*/
    public boolean isUnused(){
        return p == -1 && h == 0;
    }

    /**storing boolean as an int to save space in the json
     * this method converts the passed boolean into its integer value
     */
    public static int convertBooleanToInt(boolean hidden){
        return hidden ? 1 : 0;
    }

}

package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SpellbookPresetsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SpellbookPresetsPlugin.class);
		RuneLite.main(args);
	}
}
