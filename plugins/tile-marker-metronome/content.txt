package com.tilemarkermetronome;

import java.awt.Color;

import com.tilemarkermetronome.TileMarkerMetronomeGroup.AnimationType;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

import static com.tilemarkermetronome.TileMarkerMetronomeConfig.TILE_MARKER_METRONOME_CONFIG_GROUP;
import static com.tilemarkermetronome.TileMarkerMetronomeGroup.AnimationType.SYNCED;
import static java.awt.Color.CYAN;
import static java.awt.Color.WHITE;

@ConfigGroup(TILE_MARKER_METRONOME_CONFIG_GROUP)
public interface TileMarkerMetronomeConfig extends Config {

    String TILE_MARKER_METRONOME_CONFIG_GROUP = "tileMarkerMetronome";

    @ConfigSection(
            position = 0,
            name = "Defaults",
            description = "Color config"
    )
    String defaultConfigSection = "defaults";

    @Alpha
    @ConfigItem(
            keyName = "color1",
            name = "Color 1",
            description = "The first default colors for marked tiles",
            section = defaultConfigSection,
            position = 1
    )
    default Color color1() {
        return WHITE;
    }

    @Alpha
    @ConfigItem(
            keyName = "color2",
            name = "Color 2",
            description = "The second default colors for marked tiles",
            section = defaultConfigSection,
            position = 2
    )
    default Color color2() {
        return CYAN;
    }

    @ConfigItem(
            keyName = "animationType",
            name = "Animation type",
            description = "Changes how the colors are animated in a group",
            section = defaultConfigSection,
            position = 4
    )
    default AnimationType animationType() {
        return SYNCED;
    }

    @ConfigItem(
            keyName = "tickCounter",
            name = "Tick Counter",
            description = "Amount of ticks after which tile color should change",
            section = defaultConfigSection,
            position = 5
    )
    @Range(max = 100)
    default int tickCounter() {
        return 1;
    }

    @ConfigItem(
            keyName = "fillOpacity",
            name = "Fill opacity",
            description = "Opacity of the tile fill color",
            section = defaultConfigSection,
            position = 6
    )
    @Range(max = 255)
    default int fillOpacity() {
        return 50;
    }

    @ConfigItem(
            keyName = "borderWidth",
            name = "Border width",
            description = "Width of the marked tile border",
            section = defaultConfigSection,
            position = 7
    )
    default double borderWidth() {
        return 2;
    }
}

package com.tilemarkermetronome;

import com.google.common.base.Strings;
import com.google.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;

public class TileMarkerMetronomeOverlay extends Overlay {
    private static final int MAX_DRAW_DISTANCE = 32;

    private final Client client;
    private final TileMarkerMetronomePlugin plugin;

    @Inject
    private TileMarkerMetronomeOverlay(Client client, TileMarkerMetronomePlugin plugin) {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        plugin.getGroups()
                .stream()
                .filter(TileMarkerMetronomeGroup::isVisible)
                .forEach(group -> group.getTileMarkerMetronomePoints()
                        .forEach(point -> drawTile(graphics, point, group)));
        return null;
    }

    private void drawTile(Graphics2D graphics, TileMarkerMetronomePoint point, TileMarkerMetronomeGroup group) {
        WorldPoint.toLocalInstance(client, point.getWorldPoint())
                .stream()
                .filter(this::isOnCurrentPlane)
                .forEach(wp -> drawTile(graphics, point, group, wp));
    }

    private void drawTile(Graphics2D graphics, TileMarkerMetronomePoint point, TileMarkerMetronomeGroup group, WorldPoint worldPoint) {
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

        if (worldPoint.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE) {
            return;
        }

        LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);
        if (localPoint == null) {
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, localPoint);
        if (poly != null) {
            Stroke stroke = new BasicStroke((float) group.getBorderWidth());
            Color currentColor = group.getCurrentColor(point);
            Color currentFillColor = getFillColor(currentColor, group.getFillOpacity());
            OverlayUtil.renderPolygon(graphics, poly, currentColor, currentFillColor, stroke);

            String label = point.getLabel();
            if (!Strings.isNullOrEmpty(label)) {
                Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, localPoint, label, 0);
                if (canvasTextLocation != null) {
                    OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, currentColor);
                }
            }
        }
    }

    private Color getFillColor(Color color, int fillOpacity) {
        return new Color(color.getRed(),
                color.getGreen(),
                color.getBlue(), fillOpacity);
    }

    private boolean isOnCurrentPlane(WorldPoint worldPoint) {
        return worldPoint.getPlane() == client.getPlane();
    }
}

package com.tilemarkermetronome;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import com.tilemarkermetronome.ui.TileMarkerMetronomePluginPanel;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.Keybind;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.SwingUtilities;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

import static com.tilemarkermetronome.TileMarkerMetronomeGroup.AnimationType.DISABLED;


@PluginDescriptor(name = "Tile Marker Metronome")
public class TileMarkerMetronomePlugin extends Plugin implements KeyListener {
    private static final String CONFIG_GROUP = "tileMarkerMetronome";
    private static final String CONFIG_METRONOME_GROUPS_KEY = "metronomeGroups";
    private static final String WALK_HERE = "Walk here";
    private static final String REGION_PREFIX = "region_";
    private static final String PANEL_ICON = "panel_icon.png";
    private static final String PLUGIN_NAME = "Tile Marker Metronome";

    @Getter(AccessLevel.PACKAGE)
    private final List<TileMarkerMetronomeGroup> tileMarkerMetronomeGroups = new ArrayList<>();
    private TileMarkerMetronomePluginPanel pluginPanel;
    private NavigationButton navigationButton;
    private int currentTick;

    @Inject
    private Client client;
    @Inject
    private ConfigManager configManager;
    @Inject
    private TileMarkerMetronomeConfig config;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private TileMarkerMetronomeOverlay overlay;
    @Inject
    private ClientToolbar clientToolbar;
    @Inject
    private EventBus eventBus;
    @Inject
    private ChatboxPanelManager chatboxPanelManager;
    @Getter
    @Inject
    private ColorPickerManager colorPickerManager;
    @Inject
    private Gson gson;
    @Inject
    private KeyManager keyManager;

    @Override
    public void startUp() {
        overlayManager.add(overlay);
        loadGroups();
        loadPoints();

        pluginPanel = new TileMarkerMetronomePluginPanel(this);

        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), PANEL_ICON);
        navigationButton = NavigationButton.builder().tooltip(PLUGIN_NAME).icon(icon).priority(10000).panel(pluginPanel).build();
        clientToolbar.addNavigation(navigationButton);
        SwingUtilities.invokeLater(() -> pluginPanel.rebuild());
        keyManager.registerKeyListener(this);
    }

    @Override
    public void shutDown() {
        overlayManager.remove(overlay);
        tileMarkerMetronomeGroups.clear();
        clientToolbar.removeNavigation(navigationButton);
        keyManager.unregisterKeyListener(this);
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        tileMarkerMetronomeGroups.forEach(this::tickGroup);
        currentTick++;
    }

    void tickGroup(TileMarkerMetronomeGroup group) {
        if (group.getAnimationType() == DISABLED) {
            return;
        }
        group.incrementTick();
        if (group.getCurrentTick() % group.getTickCounter() == 0) {
            group.setNextColor();
        }
    }

    @Subscribe
    public void onProfileChanged(ProfileChanged profileChanged) {
        loadGroups();
        loadPoints();
        SwingUtilities.invokeLater(() -> pluginPanel.rebuild());
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() != GameState.LOGGED_IN) {
            return;
        }
        loadPoints();
        SwingUtilities.invokeLater(() -> pluginPanel.rebuild());
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        final boolean hotKeyPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
        if (hotKeyPressed && event.getOption().equals(WALK_HERE)) {
            Tile selectedSceneTile = client.getSelectedSceneTile();

            if (selectedSceneTile == null) {
                return;
            }

            final WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, selectedSceneTile.getLocalLocation(), client.getPlane());
            Optional<TileMarkerMetronomePoint> markedTile = getActiveGroup()
                    .getTileMarkerMetronomePoints()
                    .stream()
                    .filter(tileMarker -> tileMarker.isSameAs(worldPoint))
                    .findFirst();

            client.createMenuEntry(-1)
                    .setOption("Add to group")
                    .setTarget("Tile")
                    .setType(MenuAction.RUNELITE)
                    .onClick(e -> {
                        Tile target = client.getSelectedSceneTile();
                        if (target != null) {
                            markTile(target.getLocalLocation());
                        }
                    });
            markedTile.ifPresent(tileMarkerMetronomePoint -> {
                client.createMenuEntry(-1)
                        .setOption("Remove from group")
                        .setTarget("Tile")
                        .setType(MenuAction.RUNELITE)
                        .onClick(e -> {
                            Tile target = client.getSelectedSceneTile();
                            if (target != null) {
                                unmarkTile(target.getLocalLocation());
                            }
                        });
                client.createMenuEntry(-1)
                        .setOption("Label")
                        .setTarget("Tile")
                        .setType(MenuAction.RUNELITE)
                        .onClick(e -> labelTile(tileMarkerMetronomePoint));
            });
        }
    }

    public void addGroup() {
        tileMarkerMetronomeGroups.forEach(group -> group.setActive(false));
        tileMarkerMetronomeGroups.add(new TileMarkerMetronomeGroup("New group", config, true, true));
        saveGroupsAndRebuild();
    }

    public void removeGroup(TileMarkerMetronomeGroup group) {
        group.getTileMarkerMetronomePoints().clear();
        removePoints(group.getId());
        tileMarkerMetronomeGroups.remove(group);
        saveGroupsAndRebuild();
    }

    public List<TileMarkerMetronomeGroup> getGroups() {
        return tileMarkerMetronomeGroups;
    }

    public void saveGroupsAndRebuild() {
        saveGroups();
        SwingUtilities.invokeLater(() -> pluginPanel.rebuild());
    }

    public void saveGroups() {
        if (tileMarkerMetronomeGroups.isEmpty()) {
            configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_METRONOME_GROUPS_KEY);
        } else {
            String json = gson.toJson(tileMarkerMetronomeGroups);
            configManager.setConfiguration(CONFIG_GROUP, CONFIG_METRONOME_GROUPS_KEY, json);
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
    }

    @Override
    public void keyPressed(KeyEvent e) {
        tileMarkerMetronomeGroups.forEach(group -> {
            if (group.getTickResetHotkey().matches(e)) {
                group.setCurrentColor(0);
                group.setCurrentTick(0);
            }
            if (group.getVisibilityHotkey().matches(e)) {
                group.toggleVisibility();
            }
        });
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    private void markTile(LocalPoint localPoint) {
        if (localPoint == null) {
            return;
        }

        WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);

        int regionId = worldPoint.getRegionID();
        UUID groupId = getActiveGroup().getId();
        TileMarkerMetronomePoint point = new TileMarkerMetronomePoint(regionId, worldPoint, null);

        List<TileMarkerMetronomePoint> currentGroupTileMarkerMetronomePoints = getActiveGroup().getTileMarkerMetronomePoints();
        currentGroupTileMarkerMetronomePoints.add(point);

        savePoints(groupId, regionId);
        loadPoints();
    }

    private void unmarkTile(LocalPoint localPoint) {
        if (localPoint == null) {
            return;
        }

        WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);

        int regionId = worldPoint.getRegionID();
        UUID groupId = getActiveGroup().getId();
        TileMarkerMetronomePoint point = new TileMarkerMetronomePoint(regionId, worldPoint, null);

        List<TileMarkerMetronomePoint> currentGroupTileMarkerMetronomePoints = getActiveGroup().getTileMarkerMetronomePoints();
        currentGroupTileMarkerMetronomePoints.stream()
                .filter(p -> p.isSameAs(point.getWorldPoint()))
                .forEach(currentGroupTileMarkerMetronomePoints::remove);

        savePoints(groupId, regionId);
        loadPoints();
    }

    private void labelTile(TileMarkerMetronomePoint existing) {
        chatboxPanelManager.openTextInput("Tile label")
                .value(Optional.ofNullable(existing.getLabel())
                        .orElse(""))
                .onDone(existing::setLabel)
                .build();
    }

    private void savePoints(UUID groupId, int regionId) {
        Optional<List<TileMarkerMetronomePoint>> groupPoints = getGroups()
                .stream()
                .filter(group -> group.getId().equals(groupId))
                .map(TileMarkerMetronomeGroup::getTileMarkerMetronomePoints)
                .findFirst();

        groupPoints.ifPresentOrElse(points -> {
                    String json = gson.toJson(points);
                    configManager.setConfiguration(CONFIG_GROUP, createConfigKey(groupId, regionId), json);
                },
                () -> configManager.unsetConfiguration(CONFIG_GROUP, createConfigKey(groupId, regionId)));
    }

    private void loadPoints() {
        int[] regions = client.getMapRegions();

        if (regions == null) {
            return;
        }

        getGroups()
                .forEach(group -> {
                    group.getTileMarkerMetronomePoints().clear();
                    group.getTileMarkerMetronomePoints().addAll(
                            Arrays.stream(regions)
                                    .mapToObj(regionId -> loadPoints(group.getId(), regionId))
                                    .flatMap(Collection::stream)
                                    .collect(Collectors.toList()));
                });
    }

    private List<TileMarkerMetronomePoint> loadPoints(UUID groupId, int regionId) {
        String json = configManager.getConfiguration(CONFIG_GROUP, groupId + "_" + REGION_PREFIX + regionId);
        if (Strings.isNullOrEmpty(json)) {
            return Collections.emptyList();
        }

        return gson.fromJson(json, new TypeToken<List<TileMarkerMetronomePoint>>() {
        }.getType());
    }

    private void removePoints(UUID groupId) {
        configManager.unsetConfiguration(CONFIG_GROUP, groupId.toString());
    }

    private void loadGroups() {
        String json = configManager.getConfiguration(CONFIG_GROUP, CONFIG_METRONOME_GROUPS_KEY);
        tileMarkerMetronomeGroups.clear();
        if (Strings.isNullOrEmpty(json)) {
            tileMarkerMetronomeGroups.add(new TileMarkerMetronomeGroup("Group 1", config, true, true));
            saveGroups();
        } else {
            List<TileMarkerMetronomeGroup> savedGroups = gson.fromJson(json, new TypeToken<ArrayList<TileMarkerMetronomeGroup>>() {
            }.getType());

            //Add default for older saved groups
            savedGroups.forEach(tileMarkerMetronomeGroup -> {
                if (tileMarkerMetronomeGroup.getTickResetHotkey() == null) {
                    tileMarkerMetronomeGroup.setTickResetHotkey(Keybind.NOT_SET);
                }
                if (tileMarkerMetronomeGroup.getVisibilityHotkey() == null) {
                    tileMarkerMetronomeGroup.setVisibilityHotkey(Keybind.NOT_SET);
                }
            });

            tileMarkerMetronomeGroups.addAll(savedGroups);
        }
    }

    private TileMarkerMetronomeGroup getActiveGroup() {
        return tileMarkerMetronomeGroups
                .stream()
                .filter(TileMarkerMetronomeGroup::isActive)
                .findFirst()
                .orElseGet(() -> {
                            TileMarkerMetronomeGroup firstGroup = tileMarkerMetronomeGroups.get(0);
                            firstGroup.setActive(true);
                            return firstGroup;
                        }
                );
    }

    private String createConfigKey(UUID groupId, int regionId) {
        return groupId + "_" + REGION_PREFIX + regionId;
    }

    @Provides
    TileMarkerMetronomeConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TileMarkerMetronomeConfig.class);
    }
}

package com.tilemarkermetronome;

import lombok.Getter;
import lombok.Setter;
import net.runelite.client.config.Keybind;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Getter
@Setter
public class TileMarkerMetronomeGroup {

    private final UUID id = UUID.randomUUID();
    private final List<TileMarkerMetronomePoint> tileMarkerMetronomePoints = new ArrayList<>();

    private String label;
    private transient int currentColor;
    private List<Color> colors;
    private AnimationType animationType;
    private int fillOpacity;
    private double borderWidth;
    private int tickCounter;
    private boolean isVisible;
    private boolean isActive;
    private transient int currentTick;
    private Keybind tickResetHotkey;
    private Keybind visibilityHotkey;
    private boolean collapsed;

    public TileMarkerMetronomeGroup(String label, TileMarkerMetronomeConfig config, boolean isVisible, boolean isActive) {
        this.label = label;
        this.colors = new ArrayList<>(List.of(config.color1(), config.color2()));
        this.fillOpacity = config.fillOpacity();
        this.borderWidth = config.borderWidth();
        this.tickCounter = config.tickCounter();
        this.animationType = config.animationType();
        this.isVisible = isVisible;
        this.isActive = isActive;
        this.tickResetHotkey = Keybind.NOT_SET;
        this.visibilityHotkey = Keybind.NOT_SET;
        this.collapsed = false;
    }

    public void setActive() {
        this.isActive = true;
    }

    public void setInactive() {
        this.isActive = false;
    }

    public void incrementTick() {
        currentTick++;
    }

    public void setNextColor() {
        currentColor++;
        if (currentColor >= colors.size()) {
            currentColor = 0;
        }
    }

    public Color getCurrentColor(TileMarkerMetronomePoint point) {
        if (animationType == AnimationType.SYNCED) {
            return colors.get(currentColor);
        }
        int pointIndex = tileMarkerMetronomePoints.indexOf(point);
        int currentTileColor = currentColor;
        for (int i = 0; i < pointIndex; i++) {
            currentTileColor++;
            currentTileColor %= colors.size();
        }
        return colors.get(currentTileColor);
    }

    public void toggleVisibility() {
        this.isVisible = !this.isVisible;
    }

    public enum AnimationType {
        DISABLED,
        SYNCED,
        TRAIN
    }
}
package com.tilemarkermetronome.ui;

import com.tilemarkermetronome.TileMarkerMetronomeGroup;
import com.tilemarkermetronome.TileMarkerMetronomeGroup.AnimationType;
import com.tilemarkermetronome.TileMarkerMetronomePlugin;
import com.tilemarkermetronome.ui.util.HotkeyButton;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.text.NumberFormatter;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;
import java.util.List;

import static com.tilemarkermetronome.ui.util.ComponentUtil.configureMouseListener;
import static java.awt.BorderLayout.CENTER;
import static java.awt.BorderLayout.EAST;
import static java.awt.BorderLayout.WEST;
import static java.awt.Color.GRAY;
import static java.awt.Color.ORANGE;
import static java.awt.Color.WHITE;
import static java.awt.FlowLayout.LEFT;
import static java.awt.event.KeyEvent.VK_ENTER;
import static java.awt.event.KeyEvent.VK_ESCAPE;
import static net.runelite.client.ui.ColorScheme.DARKER_GRAY_COLOR;
import static net.runelite.client.ui.ColorScheme.LIGHT_GRAY_COLOR;
import static net.runelite.client.ui.ColorScheme.PROGRESS_COMPLETE_COLOR;
import static net.runelite.client.ui.ColorScheme.PROGRESS_ERROR_COLOR;
import static net.runelite.client.ui.FontManager.getRunescapeFont;

public class TileMarkerGroupPanel extends JPanel {
    private static final Border LABEL_BOTTOM_BORDER = BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR);

    private static final BufferedImage DELETE_IMAGE = ImageUtil.loadImageResource(TileMarkerMetronomePlugin.class, "delete_icon.png");
    private static final ImageIcon DELETE_ICON = new ImageIcon(DELETE_IMAGE);
    private static final ImageIcon DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(DELETE_IMAGE, -100));

    private static final BufferedImage EDIT_IMAGE = ImageUtil.loadImageResource(TileMarkerMetronomePlugin.class, "edit_icon.png");
    private static final ImageIcon EDIT_ICON = new ImageIcon(EDIT_IMAGE);
    private static final ImageIcon EDIT_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(EDIT_IMAGE, -100));

    private static final BufferedImage ADD_IMAGE = ImageUtil.loadImageResource(TileMarkerMetronomePlugin.class, "add_icon.png");
    private static final ImageIcon ADD_ICON = new ImageIcon(ADD_IMAGE);
    private static final ImageIcon ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(ADD_IMAGE, -100));

    private static final BufferedImage VISIBLE_IMAGE = ImageUtil.loadImageResource(TileMarkerMetronomePlugin.class, "visible_icon.png");
    private static final ImageIcon VISIBLE_ICON = new ImageIcon(VISIBLE_IMAGE);
    private static final ImageIcon VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(VISIBLE_IMAGE, -100));

    private static final BufferedImage INVISIBLE_IMAGE = ImageUtil.loadImageResource(TileMarkerMetronomePlugin.class, "invisible_icon.png");
    private static final ImageIcon INVISIBLE_ICON = new ImageIcon(INVISIBLE_IMAGE);
    private static final ImageIcon INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(INVISIBLE_IMAGE, -100));

    private final JLabel saveLabel = new JLabel("Save");
    private final JLabel cancelLabel = new JLabel("Cancel");
    private final JLabel renameLabel = new JLabel(EDIT_ICON);
    private final JLabel deleteLabel = new JLabel(DELETE_ICON);
    private final JLabel visibilityLabel = new JLabel(">");

    private final FlatTextField labelInput = new FlatTextField();

    private final TileMarkerMetronomePlugin plugin;
    private final TileMarkerMetronomeGroup group;

    public TileMarkerGroupPanel(TileMarkerMetronomePlugin plugin, TileMarkerMetronomeGroup group) {
        this.plugin = plugin;
        this.group = group;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(DARKER_GRAY_COLOR);
        if (group.isActive()) {
            setBorder(new MatteBorder(1, 1, 1, 1, ORANGE));
        } else {
            setBorder(new EmptyBorder(1, 1, 1, 1));
        }

        add(createGroupNameComponent());
        add(createGroupConfigComponent());
    }

    private JPanel createGroupNameComponent() {
        JPanel groupNamePanel = new JPanel(new BorderLayout());
        groupNamePanel.setBackground(DARKER_GRAY_COLOR);
        groupNamePanel.setBorder(LABEL_BOTTOM_BORDER);

        JPanel labelActionsContainer = new JPanel(new BorderLayout(3, 0));
        JPanel labelActions = new JPanel(new FlowLayout());
        labelActionsContainer.setBorder(new EmptyBorder(0, 0, 0, 0));
        labelActionsContainer.setBackground(DARKER_GRAY_COLOR);
        labelActions.setBorder(new EmptyBorder(0, 0, 0, 8));
        labelActions.setBackground(DARKER_GRAY_COLOR);

        labelInput.setText(group.getLabel());
        labelInput.setBorder(null);
        labelInput.setEditable(false);
        labelInput.setBackground(DARKER_GRAY_COLOR);
        labelInput.setPreferredSize(new Dimension(0, 24));
        labelInput.getTextField().setForeground(WHITE);
        labelInput.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));
        labelInput.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent keyEvent) {
                switch (keyEvent.getKeyChar()) {
                    case VK_ENTER: {
                        save();
                        break;
                    }
                    case VK_ESCAPE: {
                        cancel();
                        break;
                    }
                }
            }
        });

        saveLabel.setVisible(false);
        saveLabel.setFont(getRunescapeFont());
        saveLabel.setForeground(PROGRESS_COMPLETE_COLOR);
        configureMouseListener(
                saveLabel,
                ignored -> save(),
                ignored -> saveLabel.setForeground(PROGRESS_COMPLETE_COLOR.darker()),
                ignored -> saveLabel.setForeground(PROGRESS_COMPLETE_COLOR));

        cancelLabel.setVisible(false);
        cancelLabel.setFont(getRunescapeFont());
        cancelLabel.setForeground(PROGRESS_ERROR_COLOR);
        configureMouseListener(
                cancelLabel,
                ignored -> cancel(),
                ignored -> cancelLabel.setForeground(PROGRESS_ERROR_COLOR.darker()),
                ignored -> cancelLabel.setForeground(PROGRESS_ERROR_COLOR));

        renameLabel.setVisible(true);
        renameLabel.setForeground(LIGHT_GRAY_COLOR.darker());
        configureMouseListener(
                renameLabel,
                ignored -> {
                    labelInput.setEditable(true);
                    showSaveAndCancelActions();
                },
                ignored -> renameLabel.setIcon(EDIT_HOVER_ICON),
                ignored -> renameLabel.setIcon(EDIT_ICON));

        deleteLabel.setToolTipText("Delete group");
        deleteLabel.setVisible(true);
        configureMouseListener(
                deleteLabel,
                ignored -> confirmDeleteGroup(),
                ignored -> deleteLabel.setIcon(DELETE_HOVER_ICON),
                ignored -> deleteLabel.setIcon(DELETE_ICON)
        );

        configureMouseListener(
                visibilityLabel,
                ignored -> collapseGroup(),
                ignored -> {
                },
                ignored -> {
                }
        );

        labelActions.add(saveLabel);
        labelActions.add(cancelLabel);
        labelActions.add(renameLabel);
        labelActions.add(deleteLabel);
        labelActions.add(visibilityLabel);
        labelActionsContainer.add(labelActions);

        groupNamePanel.add(labelInput, CENTER);
        groupNamePanel.add(labelActionsContainer, EAST);
        return groupNamePanel;
    }

    private JPanel createGroupConfigComponent() {
        JPanel groupConfigPanel = new JPanel();
        groupConfigPanel.setLayout(new BoxLayout(groupConfigPanel, BoxLayout.Y_AXIS));
        groupConfigPanel.setBorder(new EmptyBorder(0, 0, 0, 0));
        groupConfigPanel.add(createColorConfigPanel());
        groupConfigPanel.add(createVisibilityConfigPanel());
        groupConfigPanel.add(createSettingsConfigPanel());
        groupConfigPanel.setVisible(!group.isCollapsed());

        return groupConfigPanel;
    }

    private JPanel createSettingsConfigPanel() {
        JPanel settingsConfigPanel = new JPanel();
        settingsConfigPanel.setLayout(new BoxLayout(settingsConfigPanel, BoxLayout.Y_AXIS));
        settingsConfigPanel.setBorder(new EmptyBorder(4, 8, 0, 0));
        settingsConfigPanel.setBackground(DARKER_GRAY_COLOR);

        settingsConfigPanel.add(createHotkeysPanel());
        settingsConfigPanel.add(createRenderTypePanel());
        settingsConfigPanel.add(createTickCounterPanel());
        settingsConfigPanel.add(createFillOpacityPanel());
        settingsConfigPanel.add(createBorderWidthPanel());

        return settingsConfigPanel;
    }

    private JPanel createBorderWidthPanel() {
        JPanel borderWidthPanel = new JPanel(new GridLayout(1, 2));
        borderWidthPanel.setBorder(new EmptyBorder(1, 0, 0, 0));
        borderWidthPanel.setBackground(DARKER_GRAY_COLOR);

        JLabel borderWidthLabel = new JLabel("Border width");
        borderWidthLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        borderWidthLabel.setBackground(DARKER_GRAY_COLOR);

        JSpinner borderWidthSpinner = new JSpinner();
        borderWidthSpinner.setModel(new SpinnerNumberModel(group.getBorderWidth(), 0, 50, 0.1));
        JFormattedTextField txt = ((JSpinner.NumberEditor) borderWidthSpinner.getEditor()).getTextField();
        NumberFormatter formatter = (NumberFormatter) txt.getFormatter();
        formatter.setFormat(new DecimalFormat("0.0"));
        formatter.setAllowsInvalid(false);

        borderWidthSpinner.addChangeListener(action -> updateBorderWidth(borderWidthSpinner));

        borderWidthPanel.add(borderWidthLabel);
        borderWidthPanel.add(borderWidthSpinner);
        return borderWidthPanel;
    }

    private JPanel createFillOpacityPanel() {
        JPanel fillOpacityPanel = new JPanel(new GridLayout(1, 2));
        fillOpacityPanel.setBorder(new EmptyBorder(1, 0, 0, 0));
        fillOpacityPanel.setBackground(DARKER_GRAY_COLOR);

        JLabel fillOpacityLabel = new JLabel("Fill opacity");
        fillOpacityLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        fillOpacityLabel.setBackground(DARKER_GRAY_COLOR);

        JSpinner fillOpacitySpinner = new JSpinner();
        fillOpacitySpinner.setModel(new SpinnerNumberModel(group.getFillOpacity(), 0, 255, 10));
        JFormattedTextField txt = ((JSpinner.NumberEditor) fillOpacitySpinner.getEditor()).getTextField();
        ((NumberFormatter) txt.getFormatter()).setAllowsInvalid(false);
        fillOpacitySpinner.addChangeListener(action -> updateFillOpacity(fillOpacitySpinner));

        fillOpacityPanel.add(fillOpacityLabel);
        fillOpacityPanel.add(fillOpacitySpinner);
        return fillOpacityPanel;
    }

    private JPanel createTickCounterPanel() {
        JPanel tickCounterPanel = new JPanel(new GridLayout(1, 2));
        tickCounterPanel.setBorder(new EmptyBorder(1, 0, 0, 0));
        tickCounterPanel.setBackground(DARKER_GRAY_COLOR);

        JLabel tickCounterLabel = new JLabel("Tick counter");
        tickCounterLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        tickCounterLabel.setBackground(DARKER_GRAY_COLOR);

        JSpinner tickCounterSpinner = new JSpinner();
        tickCounterSpinner.setModel(new SpinnerNumberModel(group.getTickCounter(), 1, 100, 1));
        JFormattedTextField txt = ((JSpinner.NumberEditor) tickCounterSpinner.getEditor()).getTextField();
        ((NumberFormatter) txt.getFormatter()).setAllowsInvalid(false);
        tickCounterSpinner.addChangeListener(action -> updateTickCounter(tickCounterSpinner));

        tickCounterPanel.add(tickCounterLabel);
        tickCounterPanel.add(tickCounterSpinner);
        return tickCounterPanel;
    }

    private JPanel createHotkeysPanel() {
        JPanel hotKeysPanel = new JPanel(new GridLayout(2, 1));

        hotKeysPanel.setBackground(DARKER_GRAY_COLOR);
        hotKeysPanel.setBorder(new EmptyBorder(1, 0, 5, 0));

        JLabel hotkeysLabel = new JLabel("Hotkeys");
        hotkeysLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        hotkeysLabel.setBackground(DARKER_GRAY_COLOR);


        JPanel hotkeysListPanel = new JPanel(new GridLayout(0, 2));
        hotkeysListPanel.setBackground(DARKER_GRAY_COLOR);
        hotkeysListPanel.setBorder(new EmptyBorder(0, 0, 0, 0));

        JLabel tickResetLabel = new JLabel("Cycle reset");
        tickResetLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        tickResetLabel.setBackground(DARKER_GRAY_COLOR);
        HotkeyButton tickResetHotkeyButton = new HotkeyButton(group.getTickResetHotkey(), group::setTickResetHotkey, false);

        JLabel visibilityLabel = new JLabel("Visibility");
        visibilityLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        visibilityLabel.setBackground(DARKER_GRAY_COLOR);
        HotkeyButton visibilityHotkeyButton = new HotkeyButton(group.getVisibilityHotkey(), group::setVisibilityHotkey, false);

        hotkeysListPanel.add(tickResetLabel);
        hotkeysListPanel.add(tickResetHotkeyButton);
        hotkeysListPanel.add(visibilityLabel);
        hotkeysListPanel.add(visibilityHotkeyButton);

        hotKeysPanel.add(hotkeysLabel);
        hotKeysPanel.add(hotkeysListPanel);
        return hotKeysPanel;
    }

    private JPanel createRenderTypePanel() {
        JPanel renderTypePanel = new JPanel(new GridLayout(1, 2));
        renderTypePanel.setBorder(new EmptyBorder(1, 0, 0, 0));
        renderTypePanel.setBackground(DARKER_GRAY_COLOR);

        JLabel renderTypeLabel = new JLabel("Animation");
        renderTypeLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        renderTypeLabel.setBackground(DARKER_GRAY_COLOR);

        JComboBox<AnimationType> renderTypeDropdown = new JComboBox<>(AnimationType.values());
        renderTypeDropdown.setSelectedItem(group.getAnimationType());
        renderTypeDropdown.addActionListener(action -> updateRenderType(renderTypeDropdown));

        renderTypePanel.add(renderTypeLabel);
        renderTypePanel.add(renderTypeDropdown);
        return renderTypePanel;
    }

    private JPanel createVisibilityConfigPanel() {
        JPanel renderConfigPanel = new JPanel(new BorderLayout());
        renderConfigPanel.setBorder(new EmptyBorder(8, 10, 0, 0));
        renderConfigPanel.setBackground(DARKER_GRAY_COLOR);

        JButton setActiveButton = new JButton("Activate group");
        setActiveButton.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(GRAY, 1),
                BorderFactory.createEmptyBorder(0, 3, 1, 3)));
        setActiveButton.setBackground(DARKER_GRAY_COLOR);

        setActiveButton.setToolTipText("Marking tiles will add them to the active group.");
        configureMouseListener(
                setActiveButton,
                ignored -> activateGroup(),
                ignored -> setForeground(getForeground().darker()),
                ignored -> setForeground(getForeground().brighter())
        );

        JLabel isVisibleIcon = new JLabel(group.isVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
        isVisibleIcon.setBorder(new EmptyBorder(0, 0, 0, 0));
        isVisibleIcon.setBackground(DARKER_GRAY_COLOR);

        configureMouseListener(
                isVisibleIcon,
                ignored -> toggleVisibility(isVisibleIcon),
                ignored -> isVisibleIcon.setIcon(group.isVisible() ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON),
                ignored -> isVisibleIcon.setIcon(group.isVisible() ? VISIBLE_ICON : INVISIBLE_ICON)
        );

        renderConfigPanel.add(setActiveButton, WEST);
        renderConfigPanel.add(isVisibleIcon, CENTER);
        return renderConfigPanel;
    }

    private JPanel createColorConfigPanel() {
        JPanel colorConfigPanel = new JPanel(new GridLayout(0, 1));
        colorConfigPanel.setBorder(new EmptyBorder(1, 0, 1, 0));
        colorConfigPanel.setBackground(DARKER_GRAY_COLOR);

        JLabel colorLabel = new JLabel("Tile colors");
        colorLabel.setBorder(new EmptyBorder(0, 8, 0, 0));
        colorConfigPanel.add(colorLabel, LEFT_ALIGNMENT);

        JPanel colorGridLayout = new JPanel();
        colorGridLayout.setLayout(new FlowLayout(FlowLayout.LEFT, 1, 2));
        colorGridLayout.setBorder(new EmptyBorder(0, 8, 0, 0));
        colorGridLayout.setBackground(DARKER_GRAY_COLOR);
        colorConfigPanel.add(colorGridLayout);

        group.getColors()
                .stream()
                .map(this::createColorIndicator)
                .forEach(colorIndicator -> colorGridLayout.add(colorIndicator, LEFT_ALIGNMENT));
        colorGridLayout.add(createAddColorPanel());

        colorConfigPanel.setBorder(LABEL_BOTTOM_BORDER);
        return colorConfigPanel;
    }

    private JPanel createColorIndicator(Color color) {
        ColorPanel colorPanel = new ColorPanel(color);
        colorPanel.setBorder(new EmptyBorder(0, 0, 0, 0));
        colorPanel.setBackground(DARKER_GRAY_COLOR);

        colorPanel.setColor(color);
        colorPanel.setToolTipText("Click to edit tile color.\n Shift click to remove.");

        configureMouseListener(colorPanel,
                mouseEvent -> {
                    if (mouseEvent.isShiftDown()) {
                        deleteColor(color);
                    } else {
                        editColor(colorPanel, color);
                    }
                },
                ignored -> colorPanel.setColor(ColorUtil.colorWithAlpha(color, color.getAlpha() - 100)),
                ignored -> colorPanel.setColor(color)
        );
        return colorPanel;
    }

    private JPanel createAddColorPanel() {
        JPanel addColorPanel = new JPanel(new FlowLayout(LEFT));
        addColorPanel.setBorder(new EmptyBorder(0, 8, 0, 0));
        addColorPanel.setBackground(DARKER_GRAY_COLOR);

        JLabel addColorIcon = new JLabel(ADD_ICON);
        addColorIcon.setBorder(new EmptyBorder(0, 0, 0, 0));
        addColorIcon.setBackground(DARKER_GRAY_COLOR);
        addColorIcon.setToolTipText("Add color");

        configureMouseListener(addColorIcon,
                ignored -> addColor(),
                ignored -> addColorIcon.setIcon(ADD_HOVER_ICON),
                ignored -> addColorIcon.setIcon(ADD_ICON)
        );

        addColorPanel.add(addColorIcon);
        return addColorPanel;
    }

    private void collapseGroup() {
        group.setCollapsed(!group.isCollapsed());
        plugin.saveGroupsAndRebuild();
    }

    private void save() {
        group.setLabel(labelInput.getText());
        plugin.saveGroupsAndRebuild();

        labelInput.setEditable(false);
        showRenameAndDeleteActions();
        requestFocusInWindow();
    }

    private void cancel() {
        labelInput.setEditable(false);
        labelInput.setText(group.getLabel());
        showRenameAndDeleteActions();
        requestFocusInWindow();
    }

    private void showSaveAndCancelActions() {
        saveLabel.setVisible(true);
        cancelLabel.setVisible(true);
        renameLabel.setVisible(false);
        deleteLabel.setVisible(false);

        labelInput.getTextField().requestFocusInWindow();
        labelInput.getTextField().selectAll();
    }

    private void showRenameAndDeleteActions() {
        renameLabel.setVisible(true);
        deleteLabel.setVisible(true);
        saveLabel.setVisible(false);
        cancelLabel.setVisible(false);
    }

    private void confirmDeleteGroup() {
        int confirm = JOptionPane.showConfirmDialog(this,
                "Are you sure you want to permanently delete this group and all grouped tiles?",
                "Warning", JOptionPane.OK_CANCEL_OPTION);

        if (confirm == 0) {
            plugin.removeGroup(group);
        }
    }

    private void editColor(ColorPanel colorPanel, Color previousColor) {
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                previousColor,
                group.getLabel() + " Border",
                false);
        colorPicker.setLocationRelativeTo(this);
        colorPicker.setOnClose(newColor -> {
            List<Color> colors = group.getColors();
            colors.set(colors.indexOf(previousColor), newColor);
            plugin.saveGroupsAndRebuild();
            colorPanel.setColor(newColor);
        });
        colorPicker.setVisible(true);
    }

    private void addColor() {
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                WHITE,
                group.getLabel() + " Border",
                false);
        colorPicker.setLocationRelativeTo(this);
        colorPicker.setOnClose(newColor -> {
            group.getColors().add(newColor);
            plugin.saveGroupsAndRebuild();
        });
        colorPicker.setVisible(true);
    }

    private void deleteColor(Color color) {
        group.getColors().remove(color);
        plugin.saveGroupsAndRebuild();
    }

    private void toggleVisibility(JLabel isVisibleIcon) {
        group.setVisible(!group.isVisible());
        isVisibleIcon.setIcon(group.isVisible() ? VISIBLE_ICON : INVISIBLE_ICON);
        plugin.saveGroupsAndRebuild();
    }

    private void activateGroup() {
        plugin.getGroups().forEach(TileMarkerMetronomeGroup::setInactive);
        group.setActive();
        plugin.saveGroupsAndRebuild();
    }

    private void updateRenderType(JComboBox<AnimationType> renderTypeDropdown) {
        group.setAnimationType((AnimationType) renderTypeDropdown.getSelectedItem());
        plugin.saveGroupsAndRebuild();
    }

    private void updateTickCounter(JSpinner tickCounter) {
        group.setTickCounter((int) tickCounter.getValue());
        plugin.saveGroupsAndRebuild();
    }

    private void updateFillOpacity(JSpinner fillOpacity) {
        group.setFillOpacity((int) fillOpacity.getValue());
        plugin.saveGroupsAndRebuild();
    }

    private void updateBorderWidth(JSpinner borderWidth) {
        group.setBorderWidth((double) borderWidth.getValue());
        plugin.saveGroupsAndRebuild();
    }
}

package com.tilemarkermetronome.ui.util;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;
import javax.swing.JButton;
import lombok.Getter;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.ModifierlessKeybind;
import net.runelite.client.ui.FontManager;

public class HotkeyButton extends JButton {

    @Getter
    private Consumer<Keybind> keybindConsumer;

    public HotkeyButton(Keybind initialKeybind, Consumer<Keybind> keybindConsumer, boolean modifierless) {
        this.keybindConsumer = keybindConsumer;
        // Disable focus traversal keys such as tab to allow tab key to be bound
        setFocusTraversalKeysEnabled(false);
        setFont(FontManager.getDefaultFont().deriveFont(12.f));
        setKeybind(initialKeybind);
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseReleased(MouseEvent e) {
                // Mouse buttons other than button1 don't give focus
                if (e.getButton() == MouseEvent.BUTTON1) {
                    // We have to use a mouse adapter instead of an action listener so the press action key (space) can be bound
                    setKeybind(Keybind.NOT_SET);
                }
            }
        });

        addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (modifierless) {
                    setKeybind(new ModifierlessKeybind(e));
                } else {
                    setKeybind(new Keybind(e));
                }
            }
        });
    }

    public void setKeybind(Keybind keybind) {
        if (keybind == null) {
            keybind = Keybind.NOT_SET;
        }
        keybindConsumer.accept(keybind);
        setText(keybind.toString());
    }
}

package com.tilemarkermetronome.ui.util;

import java.awt.Component;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;

public class ComponentUtil {

    public static void configureMouseListener(Component component, Consumer<MouseEvent> onMousePressed, Consumer<MouseEvent> onMouseEntered, Consumer<MouseEvent> onMouseExited) {
        component.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent mouseEvent) {
                onMousePressed.accept(mouseEvent);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent) {
                onMouseEntered.accept(mouseEvent);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent) {
                onMouseExited.accept(mouseEvent);
            }
        });
    }
}

package com.tilemarkermetronome.ui;

import lombok.AllArgsConstructor;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
@AllArgsConstructor
public class ColorPanel extends JPanel {
    private static final int CHECKER_SIZE = 10;

    private Color color;

    protected void setColor(Color color) {
        this.color = color;
        this.paintImmediately(0, 0, this.getWidth(), this.getHeight());
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);

        if (this.color.getAlpha() != 255) {
            for (int x = 0; x < getWidth(); x += CHECKER_SIZE) {
                for (int y = 0; y < getHeight(); y += CHECKER_SIZE) {
                    int val = (x / CHECKER_SIZE + y / CHECKER_SIZE) % 2;
                    g.setColor(val == 0 ? Color.LIGHT_GRAY : Color.WHITE);
                    g.fillRect(x, y, CHECKER_SIZE, CHECKER_SIZE);
                }
            }
        }
        g.setColor(color);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());
    }
}

package com.tilemarkermetronome.ui;

import com.tilemarkermetronome.TileMarkerMetronomePlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.Box;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.image.BufferedImage;

import static com.tilemarkermetronome.ui.util.ComponentUtil.configureMouseListener;

public class TileMarkerMetronomePluginPanel extends PluginPanel {
    private static final BufferedImage ADD_IMAGE = ImageUtil.loadImageResource(TileMarkerMetronomePlugin.class, "add_icon.png");
    private static final ImageIcon ADD_ICON = new ImageIcon(ADD_IMAGE);
    private static final ImageIcon ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(ADD_IMAGE, -100));

    private final JLabel createGroup = new JLabel(ADD_ICON);
    private final JLabel title = new JLabel();
    private final PluginErrorPanel noGroupsPanel = new PluginErrorPanel();
    private final JPanel groupsView = new JPanel(new GridBagLayout());

    private final TileMarkerMetronomePlugin plugin;

    public TileMarkerMetronomePluginPanel(TileMarkerMetronomePlugin tileMarkerMetronomePlugin) {
        this.plugin = tileMarkerMetronomePlugin;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));

        JPanel northPanel = new JPanel(new BorderLayout());
        northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));

        title.setText("Tile marker metronome groups");
        title.setForeground(Color.WHITE);

        northPanel.add(title, BorderLayout.WEST);
        northPanel.add(createGroup, BorderLayout.EAST);

        JPanel centerPanel = new JPanel(new BorderLayout());
        centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        groupsView.setBackground(ColorScheme.DARK_GRAY_COLOR);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        noGroupsPanel.setContent("Tile Marker Metronome", "Create tile group");
        noGroupsPanel.setVisible(false);

        groupsView.add(noGroupsPanel, constraints);
        constraints.gridy++;

        createGroup.setToolTipText("Create tile group");
        configureMouseListener(createGroup,
                ignored -> plugin.addGroup(),
                ignored -> createGroup.setIcon(ADD_HOVER_ICON),
                ignored -> createGroup.setIcon(ADD_ICON)
        );

        centerPanel.add(groupsView, BorderLayout.CENTER);

        add(northPanel, BorderLayout.NORTH);
        add(centerPanel, BorderLayout.CENTER);
    }

    public void rebuild() {
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        groupsView.removeAll();

        plugin.getGroups()
                .forEach(group -> {
                            groupsView.add(new TileMarkerGroupPanel(plugin, group), constraints);
                            constraints.gridy++;
                            groupsView.add(Box.createRigidArea(new Dimension(0, 10)), constraints);
                            constraints.gridy++;
                        }
                );

        boolean empty = constraints.gridy == 0;
        noGroupsPanel.setVisible(empty);
        title.setVisible(!empty);

        groupsView.add(noGroupsPanel, constraints);
        constraints.gridy++;

        repaint();
        revalidate();
    }
}

package com.tilemarkermetronome;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.util.UUID;

@Getter
@Setter
@EqualsAndHashCode(exclude = "label")
public class TileMarkerMetronomePoint {
    private final UUID uuid;
    private final int regionId;
    private final WorldPoint worldPoint;
    @Nullable
    private String label;

    public TileMarkerMetronomePoint(int regionId, WorldPoint worldPoint, @Nullable String label) {
        this.uuid = UUID.randomUUID();
        this.regionId = regionId;
        this.worldPoint = worldPoint;
        this.label = label;
    }

    public boolean isSameAs(WorldPoint other) {
        return worldPoint.getRegionX() == other.getRegionX()
                && worldPoint.getRegionY() == other.getRegionY()
                && worldPoint.getPlane() == other.getPlane();
    }
}

package com.tilemarkermetronome;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TileMarkerMetronomePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TileMarkerMetronomePlugin.class);
		RuneLite.main(args);
	}
}
