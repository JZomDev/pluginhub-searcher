package org.agilityfc.util;

import com.google.common.collect.EvictingQueue;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.clan.ClanID;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;

import javax.inject.Inject;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;

// NOTE: Adapted from `net.runelite.client.plugins.hiscore.NameAutocompleter`.

@Slf4j
public class NameAutocompleter implements KeyListener
{
    /**
     * Non-breaking space character.
     */
    private static final String NBSP = Character.toString((char)160);

    /**
     * Character class for characters that cannot be in an RSN.
     */
    private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

    private static final int MAX_SEARCH_HISTORY = 25;

    @Inject
    private Client client;

    private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

    /**
     * The name currently being autocompleted.
     */
    private String autocompleteName;

    /**
     * Pattern for the name currently being autocompleted.
     */
    private Pattern autocompleteNamePattern;

    @Override
    public void keyPressed(KeyEvent e)
    {
    }

    @Override
    public void keyReleased(KeyEvent e)
    {
    }

    @Override
    public void keyTyped(KeyEvent e)
    {
        final JTextComponent input = (JTextComponent)e.getSource();
        final String inputText = input.getText();

        // Only autocomplete if the selection end is at the end of the text.
        if (input.getSelectionEnd() != inputText.length())
        {
            return;
        }

        // Character to be inserted at the selection start.
        final String charToInsert = Character.toString(e.getKeyChar());

        // Don't attempt to autocomplete if the name is invalid.
        // This condition is also true when the user presses a key like backspace.
        if (INVALID_CHARS.matcher(charToInsert).find()
            || INVALID_CHARS.matcher(inputText).find())
        {
            return;
        }

        // Check if we are already autocompleting.
        if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches())
        {
            if (isExpectedNext(input, charToInsert))
            {
                try
                {
                    // Insert the character and move the selection.
                    final int insertIndex = input.getSelectionStart();
                    Document doc = input.getDocument();
                    doc.remove(insertIndex, 1);
                    doc.insertString(insertIndex, charToInsert, null);
                    input.select(insertIndex + 1, input.getSelectionEnd());
                }
                catch (BadLocationException ex)
                {
                    log.warn("Could not insert character.", ex);
                }

                // Prevent default behavior.
                e.consume();
            }
            else // Character to insert does not match current autocompletion. Look for another name.
            {
                newAutocomplete(e);
            }
        }
        else // Search for a name to autocomplete
        {
            newAutocomplete(e);
        }
    }

    private void newAutocomplete(KeyEvent e)
    {
        final JTextComponent input = (JTextComponent)e.getSource();
        final String inputText = input.getText();
        final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

        if (findAutocompleteName(nameStart))
        {
            // Assert this.autocompleteName != null
            final String name = this.autocompleteName;
            SwingUtilities.invokeLater(() ->
            {
                try
                {
                    input.getDocument().insertString(
                        nameStart.length(),
                        name.substring(nameStart.length()),
                        null);
                    input.select(nameStart.length(), name.length());
                }
                catch (BadLocationException ex)
                {
                    log.warn("Could not autocomplete name.", ex);
                }
            });
        }
    }

    private boolean findAutocompleteName(String nameStart)
    {
        final Pattern pattern;
        Optional<String> autocompleteName;

        // Pattern to match names that start with nameStart.
        // Allows spaces to be represented as common whitespaces, underscores,
        // hyphens, or non-breaking spaces.
        // Matching non-breaking spaces is necessary because the API
        // returns non-breaking spaces when a name has whitespace.
        pattern = Pattern.compile(
            "(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

        // Search all previous successful queries
        autocompleteName = searchHistory.stream()
            .filter(n -> pattern.matcher(n).matches())
            .findFirst();

        // Search friends if previous searches weren't matched
        if (!autocompleteName.isPresent())
        {
            NameableContainer<Friend> friendContainer = client.getFriendContainer();
            if (friendContainer != null)
            {
                autocompleteName = Arrays.stream(friendContainer.getMembers())
                    .map(Nameable::getName)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
            }
        }

        // Search friends chat if a friend wasn't found
        if (!autocompleteName.isPresent())
        {
            final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
            if (friendsChatManager != null)
            {
                autocompleteName = Arrays.stream(friendsChatManager.getMembers())
                    .map(Nameable::getName)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
            }
        }

        // Search clans
        if (!autocompleteName.isPresent())
        {
            final ClanSettings[] clanSettings = {
                client.getClanSettings(ClanID.CLAN),
                client.getClanSettings(ClanID.GROUP_IRONMAN),
                client.getGuestClanSettings()
            };
            autocompleteName = Arrays.stream(clanSettings)
                .filter(Objects::nonNull)
                .flatMap(cs -> cs.getMembers().stream())
                .map(ClanMember::getName)
                .filter(n -> pattern.matcher(n).matches())
                .findFirst();
        }

        // Search cached players if a friend wasn't found
        if (!autocompleteName.isPresent())
        {
            WorldView wv = client.getTopLevelWorldView();
            autocompleteName = wv.players().stream()
                .filter(Objects::nonNull)
                .map(Player::getName)
                .filter(Objects::nonNull)
                .filter(n -> pattern.matcher(n).matches())
                .findFirst();
        }

        if (autocompleteName.isPresent())
        {
            this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
            this.autocompleteNamePattern = Pattern.compile(
                "(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
        }
        else
        {
            this.autocompleteName = null;
            this.autocompleteNamePattern = null;
        }

        return autocompleteName.isPresent();
    }

    void addToSearchHistory(@NonNull String name)
    {
        if (!searchHistory.contains(name))
        {
            searchHistory.offer(name);
        }
    }

    private boolean isExpectedNext(JTextComponent input, String nextChar)
    {
        String expected;
        if (input.getSelectionStart() < input.getSelectionEnd())
        {
            try
            {
                expected = input.getText(input.getSelectionStart(), 1);
            }
            catch (BadLocationException ex)
            {
                log.warn("Could not get first character from input selection.", ex);
                return false;
            }
        }
        else
        {
            expected = "";
        }
        return nextChar.equalsIgnoreCase(expected);
    }
}

package org.agilityfc.util;

import lombok.SneakyThrows;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.FutureTask;

public class ClientUtil
{
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private DrawManager drawManager;

    @SneakyThrows
    public <T> T runOnClientThread(Callable<T> c)
    {
        FutureTask<T> r = new FutureTask<>(c);
        clientThread.invoke(r);
        return r.get();
    }

    @SneakyThrows
    public BufferedImage takeScreenshot()
    {
        assert !client.isClientThread();

        CompletableFuture<BufferedImage> r = new CompletableFuture<>();
        drawManager.requestNextFrameListener(
            img -> r.complete(ImageUtil.bufferedImageFromImage(img)));

        return r.get();
    }
}

package org.agilityfc.util;

import java.awt.GridBagConstraints;
import java.awt.Insets;

// NOTE: Adapted from
// <https://github.com/anleu/GridBagConstraintsBuilder/blob/master/gridbagconstraintsbuilder/src/com/ztz/gridbagconstraintsbuilder/GridBagContraintsBuilder.java>.

public class GridBagConstraintsBuilder
{
    private final GridBagConstraints init;
    private GridBagConstraints config;

    public GridBagConstraintsBuilder(GridBagConstraints init)
    {
        this.init = init;
        this.config = (GridBagConstraints) init.clone();
    }

    public GridBagConstraintsBuilder()
    {
        this(new GridBagConstraints());
    }

    public GridBagConstraintsBuilder x(int x)
    {
        config.gridx = x;
        return this;
    }

    public GridBagConstraintsBuilder y(int y)
    {
        config.gridy = y;
        return this;
    }

    public GridBagConstraintsBuilder width(int width)
    {
        config.gridwidth = width;
        return this;
    }

    public GridBagConstraintsBuilder height(int height)
    {
        config.gridheight = height;
        return this;
    }

    public GridBagConstraintsBuilder weightX(double weightX)
    {
        config.weightx = weightX;
        return this;
    }

    public GridBagConstraintsBuilder weightY(double weightY)
    {
        config.weighty = weightY;
        return this;
    }

    public GridBagConstraintsBuilder anchor(int anchor)
    {
        config.anchor = anchor;
        return this;
    }

    public GridBagConstraintsBuilder fill(int fill)
    {
        config.fill = fill;
        return this;
    }

    public GridBagConstraintsBuilder insets(int top, int left, int bottom, int right)
    {
        config.insets = new Insets(top, left, bottom, right);
        return this;
    }

    public GridBagConstraintsBuilder insets(Insets insets)
    {
        return insets(insets.top, insets.left, insets.bottom, insets.right);
    }

    /**
     * Set the same inset at top, left, bottom and right.
     */
    public GridBagConstraintsBuilder insets(int inset)
    {
        return insets(inset, inset, inset, inset);
    }

    public GridBagConstraintsBuilder fillNone()
    {
        config.fill = GridBagConstraints.NONE;
        return this;
    }

    public GridBagConstraintsBuilder fillHorizontal()
    {
        config.fill = GridBagConstraints.HORIZONTAL;
        return this;
    }

    public GridBagConstraintsBuilder fillVertical()
    {
        config.fill = GridBagConstraints.VERTICAL;
        return this;
    }

    public GridBagConstraintsBuilder fillBoth()
    {
        config.fill = GridBagConstraints.BOTH;
        return this;
    }

    /**
     * Set fill to GridBagConstraints.HORIZONTAL and horizontal weight to 1.
     */
    public GridBagConstraintsBuilder expandHorizontal()
    {
        config.weightx = 1;
        config.fill = GridBagConstraints.HORIZONTAL;
        return this;
    }

    /**
     * Set fill to GridBagConstraints.VERTICAL and vertical weight to 1.
     */
    public GridBagConstraintsBuilder expandVertical()
    {
        config.weighty = 1;
        config.fill = GridBagConstraints.VERTICAL;
        return this;
    }

    /**
     * Set fill to GridBagConstraints.BOTH and both weights to 1.
     */
    public GridBagConstraintsBuilder expandBoth()
    {
        config.weightx = 1;
        config.weighty = 1;
        config.fill = GridBagConstraints.BOTH;
        return this;
    }

    public GridBagConstraintsBuilder rowRemainder()
    {
        config.gridwidth = GridBagConstraints.REMAINDER;
        return this;
    }

    public GridBagConstraintsBuilder colRemainder()
    {
        config.gridheight = GridBagConstraints.REMAINDER;
        return this;
    }

    public GridBagConstraintsBuilder west()
    {
        config.anchor = GridBagConstraints.WEST;
        return this;
    }

    public GridBagConstraintsBuilder east()
    {
        config.anchor = GridBagConstraints.EAST;
        return this;
    }

    public GridBagConstraintsBuilder north()
    {
        config.anchor = GridBagConstraints.NORTH;
        return this;
    }

    public GridBagConstraintsBuilder northEast()
    {
        config.anchor = GridBagConstraints.NORTHEAST;
        return this;
    }

    public GridBagConstraintsBuilder northWest()
    {
        config.anchor = GridBagConstraints.NORTHWEST;
        return this;
    }

    public GridBagConstraintsBuilder center()
    {
        config.anchor = GridBagConstraints.CENTER;
        return this;
    }

    public GridBagConstraintsBuilder south()
    {
        config.anchor = GridBagConstraints.SOUTH;
        return this;
    }

    public GridBagConstraintsBuilder southEast()
    {
        config.anchor = GridBagConstraints.SOUTHEAST;
        return this;
    }

    public GridBagConstraintsBuilder southWest()
    {
        config.anchor = GridBagConstraints.SOUTHWEST;
        return this;
    }

    public GridBagConstraintsBuilder lineStart()
    {
        config.anchor = GridBagConstraints.LINE_START;
        return this;
    }

    public GridBagConstraintsBuilder lineEnd()
    {
        config.anchor = GridBagConstraints.LINE_END;
        return this;
    }

    public GridBagConstraintsBuilder firstLineStart()
    {
        config.anchor = GridBagConstraints.FIRST_LINE_START;
        return this;
    }

    public GridBagConstraintsBuilder firstLineEnd()
    {
        config.anchor = GridBagConstraints.FIRST_LINE_END;
        return this;
    }

    public GridBagConstraintsBuilder lastLineStart()
    {
        config.anchor = GridBagConstraints.LAST_LINE_START;
        return this;
    }

    public GridBagConstraintsBuilder lastLineEnd()
    {
        config.anchor = GridBagConstraints.LAST_LINE_END;
        return this;
    }

    public GridBagConstraintsBuilder pageStart()
    {
        config.anchor = GridBagConstraints.PAGE_START;
        return this;
    }

    public GridBagConstraintsBuilder pageEnd()
    {
        config.anchor = GridBagConstraints.PAGE_END;
        return this;
    }

    /**
     * Increase the current row position by the current height.
     */
    public GridBagConstraintsBuilder newRow()
    {
        config.gridy += config.gridheight;
        config.gridx = 0;
        return this;
    }

    /**
     * Increase the current column position by the current width.
     */
    public GridBagConstraintsBuilder newCol()
    {
        config.gridx += config.gridwidth;
        return this;
    }

    /**
     * Build the GridBagConstraints and keep the current configuration.
     *
     * @return GridBagConstraints with the given configuration
     */
    public GridBagConstraints build()
    {
        return (GridBagConstraints) config.clone();
    }

    /**
     * Build the GridBagConstraints and reset to the initial configuration.
     *
     * @return GridBagConstraints with the given configuration
     */
    public GridBagConstraints buildAndReset()
    {
        var config = build();
        this.config = (GridBagConstraints) init.clone();
        return config;
    }
}

package org.agilityfc;

import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.Request;
import okhttp3.RequestBody;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

public class DonationRequest
{
    private static final MediaType MEDIA_TYPE = MediaType.parse("image/png");
    private static final String FILENAME = "screenshot.png";

    private static RequestBody screenshot(BufferedImage img)
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        try
        {
            ImageIO.write(img, "png", baos);
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }

        return RequestBody.create(MEDIA_TYPE, baos.toByteArray());
    }

    private static MultipartBody body(DonationInfo di)
    {
        return new MultipartBody.Builder()
            .setType(MultipartBody.FORM)
            .addFormDataPart("from", di.getFrom())
            .addFormDataPart("to", di.getTo())
            .addFormDataPart("amount", Integer.toString(di.getAmount()))
            .addFormDataPart("screenshot", FILENAME, screenshot(di.getScreenshot()))
            .build();
    }

    public static Request.Builder builder(DonationInfo di)
    {
        assert di != null && di.getFrom() != null;
        return new Request.Builder().post(body(di));
    }
}

package org.agilityfc;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.ImageCapture;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.client.util.Text;
import okhttp3.Call;
import okhttp3.Response;
import org.agilityfc.util.GridBagConstraintsBuilder;
import org.agilityfc.util.NameAutocompleter;

import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSeparator;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.SwingWorker;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.util.concurrent.CancellationException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@Slf4j
public class AgilityFcPanel extends PluginPanel
{
    private static final int MAX_USERNAME_LENGTH = 12;

    private static final Dimension STANDARD_DIM = new Dimension(
        PluginPanel.PANEL_WIDTH - 20, 30);

    private static final Dimension SCREENSHOT_DIM = new Dimension(
        PluginPanel.PANEL_WIDTH - 20, (int) (0.75 * PluginPanel.PANEL_WIDTH));

    private static final BufferedImage AGILITY_ICON =
        ImageUtil.loadImageResource(AgilityFcPlugin.class, "icon.png");

    private static final String SCREENSHOT_DIR = "AFC";

    @Inject
    private ImageCapture imageCapture;

    @Inject
    private DonationScraper scraper;

    @Inject
    private AgilityFcPlugin plugin;

    private DonationInfo scrapedDono;
    private SendWorker sendWorker;
    private final IconTextField fromField;
    private final JTextField toField;
    private final JTextField amountField;
    private final JLabel screenshotLabel;
    private final JButton scrapeButton;
    private final JButton sendButton;

    private static JPanel labeledComponent(String name, JComponent component)
    {
        JPanel panel = new JPanel();
        panel.setLayout(new BorderLayout());

        JLabel label = new JLabel(name);
        label.setFont(FontManager.getRunescapeSmallFont());
        label.setBorder(new EmptyBorder(0, 0, 4, 0));
        label.setForeground(Color.WHITE);

        panel.add(label, BorderLayout.NORTH);
        panel.add(component, BorderLayout.CENTER);

        return panel;
    }

    private static BufferedImage fitImage(BufferedImage img, Dimension dim)
    {
        int iw = img.getWidth();
        int ih = img.getHeight();
        int dw = (int) dim.getWidth();
        int dh = (int) dim.getHeight();

        if (iw == dw && ih == dh) return img;

        if (iw > dw || ih > dh)
        {
            double fact = Math.min((double) dw / iw, (double) dh / ih);

            AffineTransform xform = AffineTransform.getScaleInstance(fact, fact);
            AffineTransformOp op = new AffineTransformOp(
                xform, AffineTransformOp.TYPE_BILINEAR);

            img = op.filter(img, null);
            iw = img.getWidth();
            ih = img.getHeight();
        }

        BufferedImage r = new BufferedImage(dw, dh, BufferedImage.TYPE_INT_ARGB);
        Graphics g = r.getGraphics();
        g.drawImage(img, (dw - iw) / 2, (dh - ih) / 2, null);
        g.dispose();

        return r;
    }

    private static void copyString(String s)
    {
        Toolkit.getDefaultToolkit().getSystemClipboard()
            .setContents(new StringSelection(s), null);
    }

    private static String screenshotName(DonationInfo di)
    {
        assert di.getFrom() != null;
        return String.format("Donation (%s) (%s)",
            di.getFrom(),
            QuantityFormatter.quantityToRSDecimalStack(di.getAmount(), true)
                .toLowerCase());
    }

    private static boolean isNameValid(String from)
    {
        String clean = Text.toJagexName(from);
        int length = clean.length();

        return from.length() == clean.length() &&
            length > 0 &&
            length <= MAX_USERNAME_LENGTH;
    }

    private void setScreenshot(BufferedImage img)
    {
        screenshotLabel.setIcon(new ImageIcon(fitImage(img, SCREENSHOT_DIM)));
    }

    private void clearDonation()
    {
        scrapedDono = null;
        fromField.setText("");
        toField.setText("");
        amountField.setText("");
        setScreenshot(AGILITY_ICON);
    }

    private void scrapeDonation()
    {
        DonationInfo di = scraper.scrapeDonation();
        if (di == null) return;

        // Use the scraped `from` if present, otherwise keep the current one.
        String scrapedFrom = di.getFrom();
        String from = scrapedFrom != null ? scrapedFrom : fromField.getText();

        // Reset the icon if the `from` name is now valid.
        if (isNameValid(from)) fromField.setIcon(IconTextField.Icon.SEARCH);

        scrapedDono = di;
        fromField.setText(from);
        toField.setText(di.getTo());
        amountField.setText(QuantityFormatter.formatNumber(di.getAmount()));
        setScreenshot(di.getScreenshot());
        sendButton.setEnabled(true);
    }

    class SendWorker extends SwingWorker<Void, Void>
    {
        private final DonationInfo di;
        private final CompletableFuture<Call> future;

        public SendWorker(DonationInfo di)
        {
            this.di = di;
            this.future = new CompletableFuture<>();
        }

        public DonationInfo getDonationInfo()
        {
            return di;
        }

        public void cancel()
        {
            cancel(true);
            future.thenAccept(Call::cancel);
        }

        @Override
        protected Void doInBackground() throws Exception
        {
            Call call = plugin.makeCall(di);
            future.complete(call);

            try (Response r = call.execute())
            {
                if (r.code() != 200)
                {
                    throw new RuntimeException(
                        String.format("Unexpected response code: %s", r.code()));
                }
            }

            return null;
        }

        private void saveScreenshot(DonationInfo di, boolean success)
        {
            CompletableFuture.runAsync(() -> {
                String name = screenshotName(di);
                imageCapture.saveScreenshot(
                    di.getScreenshot(), success ? name : name + " (Failed)",
                    SCREENSHOT_DIR, true, true);
            });
        }

        @Override
        protected void done()
        {
            fromField.setEditable(true);
            scrapeButton.setEnabled(true);

            try
            {
                get();
                fromField.setIcon(IconTextField.Icon.SEARCH);
                clearDonation();
                saveScreenshot(di, true);
            }
            catch (InterruptedException | ExecutionException |
                   CancellationException e)
            {
                log.error("Send failed", e);
                fromField.setIcon(IconTextField.Icon.ERROR);
                sendButton.setEnabled(true);
                saveScreenshot(di, false);
            }
        }
    }

    private void sendDonation()
    {
        assert scrapedDono != null;
        String from = fromField.getText();

        if (isNameValid(from))
        {
            fromField.setIcon(IconTextField.Icon.LOADING);
            fromField.setEditable(false);
            scrapeButton.setEnabled(false);
            sendButton.setEnabled(false);

            DonationInfo di = scrapedDono.withFrom(from);
            sendWorker = new SendWorker(di);
            sendWorker.execute();
        }
        else
        {
            fromField.setIcon(IconTextField.Icon.ERROR);
        }
    }

    @Inject
    public AgilityFcPanel(
        NameAutocompleter nameAutocompleter, AgilityFcConfig config)
    {
        setBorder(BorderFactory.createEmptyBorder(10, 10, 0, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        fromField = new IconTextField();
        fromField.setIcon(IconTextField.Icon.SEARCH);
        fromField.setPreferredSize(STANDARD_DIM);
        fromField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        fromField.addKeyListener(nameAutocompleter);
        fromField.addActionListener(e ->
        {
            // NOTE: Toggle the editable status to end the autocomplete.
            fromField.setEditable(false);
            fromField.setEditable(true);
        });
        fromField.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                if (e.getClickCount() != 2) return;
                fromField.setText("AFC always wins");
            }
        });
        fromField.addClearListener(() ->
        {
            if (sendWorker == null)
            {
                fromField.setIcon(IconTextField.Icon.SEARCH);
            }
            else
            {
                sendWorker.cancel();

                if (sendWorker.isCancelled())
                {
                    // NOTE: Set back the cleared text and leave it up to the
                    // worker's `done()` method to do the rest.
                    fromField.setText(sendWorker.getDonationInfo().getFrom());
                }
                else
                {
                    fromField.setIcon(IconTextField.Icon.SEARCH);
                }

                sendWorker = null;
            }
        });

        toField = new JTextField();
        toField.setPreferredSize(STANDARD_DIM);
        toField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        toField.setEditable(false);

        amountField = new JTextField();
        amountField.setPreferredSize(STANDARD_DIM);
        amountField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        amountField.setEditable(false);

        screenshotLabel = new JLabel();
        screenshotLabel.setHorizontalAlignment(SwingConstants.CENTER);

        scrapeButton = new JButton("Scrape");
        scrapeButton.addActionListener(e -> scrapeDonation());
        scrapeButton.setPreferredSize(STANDARD_DIM);

        sendButton = new JButton("Send");
        sendButton.addActionListener(e -> sendDonation());
        sendButton.setPreferredSize(STANDARD_DIM);
        sendButton.setEnabled(false);

        JButton copyKeyButton = new JButton("Copy key");
        copyKeyButton.addActionListener(e -> copyString(config.key()));
        copyKeyButton.setPreferredSize(STANDARD_DIM);

        GridBagConstraintsBuilder b = new GridBagConstraintsBuilder()
            .x(0)
            .insets(3, 0, 3, 0)
            .fill(GridBagConstraints.HORIZONTAL);

        add(labeledComponent("From", fromField), b.y(0).build());
        add(labeledComponent("To", toField), b.y(1).build());
        add(labeledComponent("Amount", amountField), b.y(2).build());
        add(labeledComponent("Screenshot", screenshotLabel), b.y(3).build());
        add(scrapeButton, b.y(4).build());
        add(sendButton, b.y(5).build());
        add(new JSeparator(), b.y(6).build());
        add(copyKeyButton, b.y(7).build());

        clearDonation();
    }
}

package org.agilityfc;

import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import okhttp3.Call;
import okhttp3.Credentials;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import org.apache.commons.lang3.StringUtils;

import javax.inject.Inject;
import java.time.Duration;

@Slf4j
@PluginDescriptor(
    name = "Agility FC"
)
public class AgilityFcPlugin extends Plugin
{
    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private OkHttpClient httpClient;

    @Inject
    private AgilityFcConfig config;

    private OkHttpClient myHttpClient;
    private NavigationButton navButton;

    private OkHttpClient makeClient(String key)
    {
        OkHttpClient.Builder builder = httpClient.newBuilder()
            .callTimeout(Duration.ofSeconds(10));

        if (StringUtils.isNotEmpty(key))
        {
            builder.addInterceptor(chain ->
                chain.proceed(chain.request().newBuilder()
                    .header("Authorization", Credentials.basic("", key))
                    .build()));
        }

        return builder.build();
    }

    public Call makeCall(DonationInfo di)
    {
        Request request = DonationRequest.builder(di)
            .url(config.url())
            .build();

        return myHttpClient.newCall(request);
    }

    @Override
    protected void startUp() throws Exception
    {
        myHttpClient = makeClient(config.key());
        navButton = NavigationButton.builder()
            .tooltip("Agility FC")
            .icon(ImageUtil.loadImageResource(getClass(), "icon.png"))
            .priority(10)
            .panel(injector.getInstance(AgilityFcPanel.class))
            .build();

        clientToolbar.addNavigation(navButton);
    }

    @Subscribe
    private void onConfigChanged(ConfigChanged e)
    {
        myHttpClient = makeClient(config.key());
    }

    @Override
    protected void shutDown() throws Exception
    {
        clientToolbar.removeNavigation(navButton);
    }

    @Provides
    AgilityFcConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(AgilityFcConfig.class);
    }
}

package org.agilityfc;

import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.Text;
import org.agilityfc.util.ClientUtil;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.ImmutableTriple;

import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class DonationScraper
{
    private static final Pattern TRADE_OPPONENT_PAT =
        Pattern.compile("(?i)trading with: ?(.+)");
    private static final Pattern TRADE_VALUE_PAT =
        Pattern.compile("(?i)value: (.+) coins");
    private static final Pattern LOOT_KEY_VALUE_PAT =
        Pattern.compile("(?i)value in chest: (.+)gp");
    private static final Pattern PRICE_CHECK_VALUE_PAT =
        Pattern.compile("(?i)total guide price: ?(.+)");

    @Inject
    private Client client;

    @Inject
    private ClientUtil clientUtil;

    private static String findWidgetText(Widget w, Pattern pat)
    {
        String text = w.getText();
        if (text == null) return null;

        Matcher m = pat.matcher(Text.removeTags(text));
        return m.find() ? m.group(1) : null;
    }

    private static int parseValue(String value)
    {
        return Integer.parseInt(value.replaceAll(",", ""));
    }

    private static Rectangle scaleBounds(
        Rectangle bounds, double scaleX, double scaleY)
    {
        return new Rectangle(
            (int) (scaleX * bounds.x),
            (int) (scaleY * bounds.y),
            (int) (scaleX * bounds.width),
            (int) (scaleY * bounds.height));
    }

    private BufferedImage cropScreenshot(BufferedImage img, Rectangle bounds)
    {
        if (client.isStretchedEnabled())
        {
            Dimension real = client.getRealDimensions();
            Dimension stretched = client.getStretchedDimensions();

            bounds = scaleBounds(
                bounds,
                stretched.getWidth() / real.getWidth(),
                stretched.getHeight() / real.getHeight());
        }

        return img.getSubimage(bounds.x, bounds.y, bounds.width, bounds.height);
    }

    public DonationInfo scrapeDonation(
        int containerId,
        int opponentId, Pattern opponentPat,
        int valueId, Pattern valuePat)
    {
        assert !client.isClientThread();

        var t = clientUtil.runOnClientThread(() ->
        {
            Player p = client.getLocalPlayer();
            if (p == null) return null;

            Widget w = client.getWidget(containerId);
            if (w == null || w.isHidden()) return null;

            BiFunction<Integer, Pattern, String> extract = (id, pat) ->
            {
                Widget w2 = client.getWidget(id);
                assert w2 != null && !w2.isHidden();

                String name = findWidgetText(w2, pat);
                assert name != null;

                return name;
            };

            return new ImmutableTriple<>(
                new ImmutablePair<>(
                    opponentId != -1 ? extract.apply(opponentId, opponentPat) : null,
                    p.getName()),
                extract.apply(valueId, valuePat),
                w.getBounds());
        });

        if (t == null) return null;

        return new DonationInfo(
            t.getLeft().getLeft(),
            t.getLeft().getRight(),
            parseValue(t.getMiddle()),
            cropScreenshot(clientUtil.takeScreenshot(), t.getRight()));
    }

    public DonationInfo scrapeDonation(
        int containerId, int valueId, Pattern valuePat)
    {
        return scrapeDonation(containerId, -1, null, valueId, valuePat);
    }

    public DonationInfo scrapeTradeMainScreen()
    {
        return scrapeDonation(
            InterfaceID.Trademain.UNIVERSE,
            InterfaceID.Trademain.TITLE, TRADE_OPPONENT_PAT,
            InterfaceID.Trademain.OTHER_OFFER_HEADER, TRADE_VALUE_PAT);
    }

    public DonationInfo scrapeTradeConfirmScreen()
    {
        return scrapeDonation(
            InterfaceID.Tradeconfirm.UNIVERSE,
            InterfaceID.Tradeconfirm.TRADEOPPONENT, TRADE_OPPONENT_PAT,
            InterfaceID.Tradeconfirm.YOU_WILL_RECEIVE, TRADE_VALUE_PAT);
    }

    public DonationInfo scrapeLootKeyScreen()
    {
        return scrapeDonation(
            InterfaceID.WildyLootChest.CONTENTS,
            InterfaceID.WildyLootChest.VALUE, LOOT_KEY_VALUE_PAT);
    }

    public DonationInfo scrapePriceCheckScreen()
    {
        return scrapeDonation(
            InterfaceID.GePricechecker.UNIVERSE,
            InterfaceID.GePricechecker.OUTPUT, PRICE_CHECK_VALUE_PAT);
    }

    public DonationInfo scrapeDonation()
    {
        List<Supplier<DonationInfo>> scrapers = List.of(
            this::scrapeTradeMainScreen,
            this::scrapeTradeConfirmScreen,
            this::scrapeLootKeyScreen,
            this::scrapePriceCheckScreen);

        for (var s : scrapers)
        {
            DonationInfo di = s.get();
            if (di != null) return di;
        }

        return null;
    }
}

package org.agilityfc;

import lombok.NonNull;
import lombok.Value;
import lombok.With;

import java.awt.image.BufferedImage;

@Value
public class DonationInfo
{
    /// Display name of the donor.
    @With
    String from;

    /// Display name of the receiver.
    @NonNull
    String to;

    /// A non-negative amount of GP.
    int amount;

    /// Screenshot of the trade, loot key or price check screen.
    @NonNull
    BufferedImage screenshot;
}

package org.agilityfc;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.util.UUID;

@ConfigGroup("agilityfc")
public interface AgilityFcConfig extends Config
{
    @ConfigSection(
        name = "Donation Service",
        description = "For AFC moderators",
        position = 0)
    String donationSection = "Donation Service";

    @ConfigItem(
        keyName = "url",
        name = "URL",
        description = "The URL of the service to send donation data to",
        secret = true,
        section = donationSection,
        position = 0
    )
    default String url()
    {
        return "";
    }

    @ConfigItem(
        keyName = "key",
        name = "Key",
        description = "The key to use to authenticate with the service",
        secret = true,
        section = donationSection,
        position = 1
    )
    default String key()
    {
        return UUID.randomUUID().toString();
    }
}

package org.agilityfc;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AgilityFcPluginTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(AgilityFcPlugin.class);
        RuneLite.main(args);
    }
}

