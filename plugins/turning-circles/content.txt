package com.turningcircles;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;

import java.awt.*;

@ConfigGroup("turningcircles")
public interface TurningCirclesConfig extends Config {
    @ConfigItem(
            keyName = "nSteps",
            name = "Number of steps",
            description = "Number of steps to simulate in the turning circle",
            position = 0
    )
    @Range(max = 20, min = 1)
    default int nSteps() {
        return 10;
    }

    @ConfigItem(
            keyName = "renderColor",
            name = "Render color",
            description = "The color of the turning circle",
            position = 1
    )
    default Color renderColor() {
        return Color.WHITE;
    }
}

package com.turningcircles;

public class Rect {
    public float centreX, centreY, width, height;
    float[] coordsX, coordsY;

    public Rect(float centreX, float centreY, float width, float height) {
        this.centreX = centreX;
        this.centreY = centreY;
        this.width = width;
        this.height = height;

        var hw = width / 2;
        var hh = height / 2;

        coordsX = new float[]{
                centreX + hw,
                centreX + hw,
                centreX - hw,
                centreY - hw
        };

        coordsY = new float[]{
                centreY - hh,
                centreY + hh,
                centreY + hh,
                centreY - hh
        };
    }
}

package com.turningcircles;

import net.runelite.api.coords.LocalPoint;

public class SailingMath {
    public static int roundToQuarterTile(int offset) {
        return Math.round(offset / 32f) * 32;
    }

    public static double orientationToDegrees(int angle) {
        return 270 - angle / (2048 / 360f);
    }

    public static int degreesToOrientation(double degrees) {
        return (int) (-(degrees - 270) * (2048 / 360f));
    }

    public static int cycleOrientation(int orientation) {
        if (orientation < 0)
            return (2048 + orientation) % 2048;

        return orientation % 2048;
    }

    /**
     * Returns how the angle should change (1 means angle increases, -1 means decreases between two orientations
     *
     * @param start  the first orientation
     * @param target the target orientation
     */
    public static int calculateAngleDirectionBetweenOrientations(int start, int target) {
        var d1 = orientationToDegrees(start);
        var d2 = orientationToDegrees(target);
        var dA = d2 - d1;
        if (dA < -180)
            return -1;
        if (dA > 180)
            return 1;
        return -(int) (dA / Math.abs(dA));
    }

    /// speed in frac of tiles which should be a multiple of 0.5
    public static double getSpeed(int vx, int vy) {
        return Math.round(Math.sqrt(Math.pow(vx / 128f, 2) + Math.pow(vy / 128f, 2)) / 0.5f) * 0.5f;
    }

    public static BoatStep[] GenerateSteps(int nSteps, int fromOrientation, int toOrientation, LocalPoint currentLocation, int vx, int vy) {
        // show boat movement preview
        var steps = new BoatStep[nSteps];
        var dA = 128;
        int a = fromOrientation;
        var dirA = SailingMath.calculateAngleDirectionBetweenOrientations(a, toOrientation);
        var currentSpeed = SailingMath.getSpeed(vx, vy);
        var pos = currentLocation.dx(0).dy(0);
        for (int i = 0; i < nSteps; i++) {
            if (a != toOrientation) {
                a += dA * dirA;
            }
            a = SailingMath.cycleOrientation(a);
            var aDeg = SailingMath.orientationToDegrees(a);
            var vSx = SailingMath.roundToQuarterTile((int) (Math.cos(Math.toRadians(aDeg)) * currentSpeed * 128));
            var vSy = SailingMath.roundToQuarterTile((int) (Math.sin(Math.toRadians(aDeg)) * currentSpeed * 128));
            pos = pos.plus(vSx, vSy);
            steps[i] = new BoatStep(pos, a);
        }

        return steps;
    }
}

package com.turningcircles;

import net.runelite.api.coords.LocalPoint;

public class BoatStep {
    public LocalPoint location;
    public int orientation;

    public BoatStep(LocalPoint location, int orientation) {
        this.location = location;
        this.orientation = orientation;
    }
}

package com.turningcircles;

public class Line {
    public int x1, y1, x2, y2;

    public Line(int x1, int y1, int x2, int y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }

    /// returns side of the line that point x,y is on
    /// if > 0 on left, if < 0 right, if = 0 on line
    public int calculateSide(int x, int y) {
        return (x2 - x1) * (y - y1) - (y2 - y1) * (x - x1);
    }
}

package com.turningcircles;

import com.google.inject.Provides;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WorldEntityDespawned;
import net.runelite.api.events.WorldEntitySpawned;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(
        name = "Turning Circles"
)
public class TurningCirclePlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private TurningCirclesConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private TurningCirclesOverlay turningCirclesOverlay;

    // track boats
    private Map<Integer, WorldEntity> spawnedEntities = new HashMap<>();

    // track velocity of the boat
    public int vx;
    public int vy;
    private LocalPoint lastLoc = null;

    @Override
    protected void startUp() throws Exception {
        overlayManager.add(turningCirclesOverlay);
    }

    @Override
    protected void shutDown() throws Exception {
        overlayManager.remove(turningCirclesOverlay);
        spawnedEntities.clear();
    }

    // Returns the boat world entity if sailing, otherwise null
    public WorldEntity getBoatEntity() {
        if (!isOnBoat())
            return null;

        var playerWvId = client.getLocalPlayer().getWorldView().getId();

        if (spawnedEntities.containsKey(playerWvId)) {
            return spawnedEntities.get(playerWvId);
        }

        return null;
    }

    public boolean isOnBoat() {
        return client.getVarbitValue(VarbitID.SAILING_BOARDED_BOAT) == 1;
    }

    public boolean isNavigating() {
        return client.getTopLevelWorldView().getYellowClickAction() == Constants.CLICK_ACTION_SET_HEADING;
    }

    @Subscribe
    public void onGameTick(GameTick e) {
        var boatEntity = getBoatEntity();
        if (boatEntity == null)
            return;

        var loc = boatEntity.getTargetLocation();
        if (lastLoc != null) {
            vx = loc.getX() - lastLoc.getX();
            vy = loc.getY() - lastLoc.getY();
        }
        lastLoc = loc;
    }

    @Subscribe
    public void onWorldEntitySpawned(WorldEntitySpawned e) {
        // keep track of the world views that a boat is in
        // when the player's world view id matches then they are on the boat
        spawnedEntities.put(e.getWorldEntity().getWorldView().getId(), e.getWorldEntity());
    }

    @Subscribe
    public void onWorldEntityDespawned(WorldEntityDespawned e) {
        spawnedEntities.remove(e.getWorldEntity().getWorldView().getId(), e.getWorldEntity());
    }

    @Provides
    TurningCirclesConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TurningCirclesConfig.class);
    }

    /// Returns the orientation that the user's mouse is pointing towards
    public int calculateMouseHeading(Client client, LocalPoint boatCentre) {

        // This kind of ridiculous, and there must be a better way.
        // But make lines that evenly divide the heading sectors from the centre
        // of the boat outwards in the canvas space.
        // Then check which side of each line the mouse point is to determine
        // which sector we are in.
        int nLines = 16;

        // Boat's centre on canvas
        var centre = Perspective.localToCanvas(client, boatCentre, 0);
        if (centre == null)
            return 0;

        var lineX = new float[]{0, 0};
        var lineY = new float[]{1000, -1000};
        var lineZ = new float[]{0, 0};

        var lines = new Line[nLines];
        for (int n = 0; n < nLines; n++) {
            // start at 64 as we are evenly dividing the sectors
            // south is zero/2048, north is 1024
            int a = 64 + 128 * n;
            int[] cx = new int[2];
            int[] cy = new int[2];
            Perspective.modelToCanvas(
                    client,
                    client.getTopLevelWorldView(),
                    2,
                    boatCentre.getX(), boatCentre.getY(),
                    0,
                    a,
                    lineX,
                    lineY,
                    lineZ,
                    cx,
                    cy
            );
            lines[n] = new Line(centre.getX(), centre.getY(), cx[1], cy[1]);
        }

        var cMouse = client.getMouseCanvasPosition();
        for (int i = 0; i < nLines - 1; i++) {
            var line = lines[i];
            var line1 = lines[i + 1];
            var val0 = line.calculateSide(cMouse.getX(), cMouse.getY());
            var val1 = line1.calculateSide(cMouse.getX(), cMouse.getY());
            if (val0 >= 0 && val1 < 0)
                return 128 + i * 128;
        }

        return 0; // sse
    }
}

package com.turningcircles;

import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.*;

@Slf4j
public class TurningCirclesOverlay extends Overlay {

    private final Client client;
    private final TurningCirclePlugin plugin;
    private final TurningCirclesConfig config;

    @Inject
    public TurningCirclesOverlay(Client client, TurningCirclePlugin plugin, TurningCirclesConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPosition(OverlayPosition.DYNAMIC);
    }

    @Override
    public Dimension render(Graphics2D g) {
        if (!plugin.isNavigating())
            return null;

        var boat = plugin.getBoatEntity();
        if (boat == null) return null;

        var bc = boat.getConfig();
        var boatRect = new Rect(bc.getBoundsX(), bc.getBoundsY(), bc.getBoundsWidth(), bc.getBoundsHeight());

        var mouseHeading = plugin.calculateMouseHeading(client, boat.getLocalLocation());
        if (plugin.vx == 0 && plugin.vy == 0)
            return null;

        var paths = SailingMath.GenerateSteps(
                config.nSteps(),
                boat.getTargetOrientation(),
                mouseHeading,
                boat.getTargetLocation(), plugin.vx, plugin.vy);

        g.setColor(config.renderColor());

        for (var path : paths) {
            renderRotatedRect(client, g, path.location, boatRect, path.orientation);
        }

        return null;
    }

    private void renderRotatedRect(Client client, Graphics2D g, LocalPoint p, Rect r, int angle) {

        float[] coordsZ = new float[]{0, 0, 0, 0};
        int[] cx = new int[4];
        int[] cy = new int[4];

        Perspective.modelToCanvas(
                client,
                client.getTopLevelWorldView(),
                r.coordsX.length,
                p.getX(),
                p.getY(),
                0,
                angle,
                r.coordsX,
                r.coordsY,
                coordsZ,
                cx,
                cy
        );

        Polygon canvasPoly = new Polygon();
        for (int i = 0; i < cx.length; i++) {
            canvasPoly.addPoint(cx[i], cy[i]);
        }
        g.draw(canvasPoly);
    }

}

package com.turningcircles;

import org.junit.Assert;
import org.junit.Test;

public class SailingMathTests {
    @Test
    public void orientationToDegreesReturnsCorrectValues() {
        Assert.assertEquals(90, SailingMath.orientationToDegrees(1024), 0.001);
        Assert.assertEquals(270, SailingMath.orientationToDegrees(0), 0.001);
        Assert.assertEquals(22.5, SailingMath.orientationToDegrees(1536 - 128), 0.001);
    }

    @Test
    public void cycleOrientationReturnsCorrectValues() {
        Assert.assertEquals(1024, SailingMath.cycleOrientation(1024), 0.001);
        Assert.assertEquals(0, SailingMath.cycleOrientation(0), 0.001);
        Assert.assertEquals(2048 - 128, SailingMath.cycleOrientation(-128), 0.001);
        Assert.assertEquals(128, SailingMath.cycleOrientation(2048 + 128), 0.001);
    }

    @Test
    public void degreesToOrientationReturnsCorrectValues() {
        Assert.assertEquals(1536, SailingMath.degreesToOrientation(0), 0.001);
        Assert.assertEquals(1024, SailingMath.degreesToOrientation(90), 0.001);
        Assert.assertEquals(0, SailingMath.degreesToOrientation(270), 0.001);
    }

    @Test
    public void calculateOrientationDirectionReturnsCorrectValues() {
        Assert.assertEquals(-1, SailingMath.calculateAngleDirectionBetweenOrientations(0, 1536));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(1536, 0));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(1920, 0));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(512, 1024));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(0, 512));
    }
}

package com.turningcircles;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TurningCirclesPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TurningCirclePlugin.class);
		RuneLite.main(args);
	}
}
