package com.turningcircles;

import net.runelite.client.config.*;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

@ConfigGroup("turningcircles")
public interface TurningCirclesConfig extends Config {
    @ConfigSection(
            name = "Path",
            description = "Settings for the pathing",
            position = 0
    )
    String SECTION_PATH = "path";

    @ConfigSection(
            name = "Styling",
            description = "Settings for the colors used to draw the path",
            position = 10
    )
    String SECTION_STYLING = "styling";

    @ConfigItem(
            keyName = "nSteps",
            name = "Number of steps",
            description = "Number of steps to simulate in the turning circle",
            position = 0,
            section = SECTION_PATH
    )
    @Range(max = 20, min = 1)
    default int nSteps() {
        return 10;
    }

    @ConfigItem(
            keyName = "showWhenStopped",
            name = "Show when stopped",
            description = "Shows the turning circle when the boat is stopped",
            position = 10,
            section = SECTION_PATH
    )
    default boolean showWhenStopped() {
        return true;
    }

    @ConfigItem(
            keyName = "showBoatSpeed",
            name = "Show boat speed/acceleration",
            description = "Show the current boat speed and acceleration",
            position = 20,
            section = SECTION_PATH
    )
    default boolean showBoatSpeed() {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "renderColor",
            name = "Outline color",
            description = "The outline color of the turning circle",
            position = 0,
            section = SECTION_STYLING
    )
    default Color renderColor() {
        return ColorUtil.colorWithAlpha(Color.WHITE, 140);
    }

    @ConfigItem(
            keyName = "fadeOutlineAlpha",
            name = "Fade outline alpha",
            description = "Fades the outline alpha to the setting below",
            position = 10,
            section = SECTION_STYLING
    )
    default boolean fadeOutlineAlpha() {
        return true;
    }

    @ConfigItem(
            keyName = "finalOutlineAlpha",
            name = "Final outline alpha",
            description = "The opacity/alpha of the final outline colour will fade to this if the fade setting is on.",
            position = 20,
            section = SECTION_STYLING
    )
    @Range(max = 255)
    default int finalOutlineAlpha() {
        return 90;
    }

    @Alpha
    @ConfigItem(
            keyName = "fillColor",
            name = "Background color",
            description = "The background color of the turning circle",
            position = 30,
            section = SECTION_STYLING
    )
    default Color fillColor() {
        return ColorUtil.colorWithAlpha(Color.WHITE, 0);
    }

    @ConfigItem(
            keyName = "fadeBackgroundAlpha",
            name = "Fade background alpha",
            description = "Fades the background alpha to the setting below",
            position = 40,
            section = SECTION_STYLING
    )
    default boolean fadeBackgroundAlpha() {
        return false;
    }

    @ConfigItem(
            keyName = "finalBackgroundAlpha",
            name = "Final background alpha",
            description = "The opacity/alpha of the final background colour will fade to this if the fade setting is on.",
            position = 50,
            section = SECTION_STYLING
    )
    @Range(max = 255)
    default int finalBackgroundAlpha() {
        return 0;
    }


}

package com.turningcircles;

public class Rect {
    public float centreX, centreY, width, height;
    float[] coordsX, coordsY;

    public Rect(float centreX, float centreY, float width, float height) {
        this.centreX = centreX;
        this.centreY = centreY;
        this.width = width;
        this.height = height;

        var hw = width / 2;
        var hh = height / 2;

        coordsX = new float[]{
                centreX + hw,
                centreX + hw,
                centreX - hw,
                centreX - hw
        };

        coordsY = new float[]{
                centreY - hh,
                centreY + hh,
                centreY + hh,
                centreY - hh
        };
    }
}

package com.turningcircles;

import net.runelite.api.Point;

public class SailingMath {
    public static int roundToQuarterTile(int offset) {
        return round(offset / 32f) * 32;
    }

    public static double orientationToDegrees(int angle) {
        return 270 - angle / (2048 / 360f);
    }

    public static int degreesToOrientation(double degrees) {
        return (int) (-(degrees - 270) * (2048 / 360f));
    }

    public static int cycleOrientation(int orientation) {
        if (orientation < 0)
            return (2048 + orientation) % 2048;

        return orientation % 2048;
    }

    /**
     * Returns how the angle should change (1 means angle increases, -1 means decreases between two orientations
     *
     * @param start                the first orientation
     * @param target               the target orientation
     * @param currentTurnDirection the current angular speed, for the edge case where we are turning around.
     */
    public static int calculateAngleDirectionBetweenOrientations(int start, int target, int currentTurnDirection) {
        var d1 = orientationToDegrees(start);
        var d2 = orientationToDegrees(target);
        var dA = d2 - d1;
        if (dA < -180)
            return -1;
        else if (dA > 180)
            return 1;
        else if (dA == 180 || dA == -180) {
            // in the case we do a full 180 deg turn, we always turn clockwise
            // unless we are already turning anticlockwise in which case we keep doing that.
            if (currentTurnDirection < 0)
                return -1;
            else
                return 1;
        }
        return -(int) (dA / Math.abs(dA));
    }

    /// speed in frac of tiles which should be a multiple of 0.5
    public static double getSpeed(int vx, int vy) {
        return Math.round(Math.sqrt(Math.pow(vx / 128f, 2) + Math.pow(vy / 128f, 2)) / 0.5f) * 0.5f;
    }

    public static int round(double value) {
        // behave as in +ve numbers - round to the large abs number
        var rounded = Math.round(Math.abs(value)) * Math.signum(value);
        return (int) rounded;
    }

    public static Point getVelocity(double speed, double angle) {
        var dx = Math.cos(Math.toRadians(angle)) * speed * 128;
        var dy = Math.sin(Math.toRadians(angle)) * speed * 128;
        var vx = roundToQuarterTile(round(dx));
        var vy = roundToQuarterTile(round(dy));
        return new Point(vx, vy);
    }
}

package com.turningcircles;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.WorldEntity;
import net.runelite.api.events.*;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@Singleton
public class BoatManager {

    private final Client client;
    private final TurningCirclesConfig config;

    // track boats
    private final Map<Integer, WorldEntity> spawnedEntities = new HashMap<>();

    // going over a crystal event increases your max speed by 0.5
    public int ticksSinceCrystalEvent = -1;
    private int lastCrystalEventTick;

    public boolean isOnBoat = false;

    /// The max speed of the boat without any special considerations
    public double boatSpeedCap = 0;
    /// The base speed of the boat when in moveMode 2
    public double boatBaseSpeed = 0;
    /// The acceleration the boat is capable of
    public double boatAcceleration = 0;
    /// The number of ticks that a speed boost lasts
    public double boostTickDuration = 0;
    /// The move mode. 1 = low speed, 2 = full speed, 3 = reverse, 4 = not moving but will move to 2. 0 = not moving.
    public double moveMode = 0;
    // Store previous move mode here so we can check which move mode to move to from 0
    private double lastMoveMode = 2;

    private static final String SAIL_SPEED_BOOST = "You trim the sails, catching the wind for a burst of speed!";
    private static final String MOTE_SPEED_BOOST = "You release the wind mote for a burst of speed!";
    private static final String CRYSTAL_MOTE_SPEED_BOOST = "The crystal mote grants both a small burst of speed as well as a wind mote.";
    private static final String GWENITH_GLIDE_PORTAL_SPEED_BOOST = "The boat is sucked through the portal and sent somewhere else.";
    private static final String CRYSTALS_REMOVED_SPEED_BOOST = "The crystals have been successfully removed from the helm, granting a burst of speed.";

    private int lastWindBoostTick;
    public int ticksSinceLastWindBoost = -1;

    protected void startUp() {
    }

    protected void shutDown() {
        spawnedEntities.clear();
    }

    @Inject
    public BoatManager(Client client, TurningCirclesConfig config) {
        this.client = client;
        this.config = config;
    }

    /***
     * Returns true if the crystal boost is active for nTicks from now.
     * @param nTicks the number of ticks from now
     * @return
     */
    public boolean isCrystalSpeedBoostActive(int nTicks) {
        return ticksSinceCrystalEvent >= 0 && ticksSinceCrystalEvent + nTicks <= boostTickDuration;
    }

    /***
     * Returns true if the crystal boost is active.
     */
    public boolean isCrystalSpeedBoostActive() {
        return isCrystalSpeedBoostActive(0);
    }

    /***
     * Returns true if the wind speed boost is active for nTicks from now.
     * @param nTicks the number of ticks from now
     */
    public boolean isWindSpeedBoostActive(int nTicks) {
        return ticksSinceLastWindBoost >= 0 && ticksSinceLastWindBoost + nTicks <= boostTickDuration;
    }

    /***
     * Returns true if the wind speed boost is active
     */
    public boolean isWindSpeedBoostActive() {
        return isWindSpeedBoostActive(0);
    }

    /***
     * Returns the actual max speed taking into consideration boosts
     * and move mode, nTicks from now. This considers boosts running out.
     */
    public double getMaxSpeed(int nTicks) {
        if (isReversing())
            return 0.5;

        var cappedSpeed = 1.0; // for half-speed
        if (moveMode == 2 || moveMode == 4 || (moveMode == 0 && lastMoveMode == 4)) {
            cappedSpeed = boatBaseSpeed;
        }
        if (isWindSpeedBoostActive(nTicks))
            cappedSpeed = Math.max(cappedSpeed + 0.5, boatSpeedCap);

        if (isCrystalSpeedBoostActive(nTicks)) {
            cappedSpeed += 0.5; // deliberately don't take max with cappedSpeed as I think it's additional
        }

        return cappedSpeed;
    }

    /***
     * Returns the actual max speed taking into consideration boosts
     * and move mode.
     */
    public double getMaxSpeed() {
        return getMaxSpeed(0);
    }

    @Subscribe
    public void onGameTick(GameTick e) {
        if (lastCrystalEventTick > 0)
            ticksSinceCrystalEvent = client.getTickCount() - lastCrystalEventTick;

        if (lastWindBoostTick > 0)
            ticksSinceLastWindBoost = client.getTickCount() - lastWindBoostTick;
    }

    @Subscribe
    public void onChatMessage(ChatMessage c) {
        if (c.getMessage().contains(CRYSTAL_MOTE_SPEED_BOOST) ||
                c.getMessage().contains(GWENITH_GLIDE_PORTAL_SPEED_BOOST) ||
                c.getMessage().contains(CRYSTALS_REMOVED_SPEED_BOOST)) {
            lastCrystalEventTick = client.getTickCount();
        }
        if (c.getMessage().equals(SAIL_SPEED_BOOST) || c.getMessage().equals(MOTE_SPEED_BOOST)) {
            lastWindBoostTick = client.getTickCount();
        }
    }

    @Subscribe
    public void onWorldEntitySpawned(WorldEntitySpawned e) {
        // keep track of the world views that a boat is in
        // when the player's world view id matches then they are on the boat
        spawnedEntities.put(e.getWorldEntity().getWorldView().getId(), e.getWorldEntity());
    }

    @Subscribe
    public void onWorldEntityDespawned(WorldEntityDespawned e) {
        spawnedEntities.remove(e.getWorldEntity().getWorldView().getId(), e.getWorldEntity());
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged e) {
        if (e.getVarbitId() == VarbitID.SAILING_BOARDED_BOAT) {
            isOnBoat = e.getValue() == 1;
        } else if (e.getVarbitId() == VarbitID.SAILING_SIDEPANEL_BOAT_SPEEDCAP) {
            boatSpeedCap = e.getValue() / 128f;
        } else if (e.getVarbitId() == VarbitID.SAILING_SIDEPANEL_BOAT_BASESPEED) {
            boatBaseSpeed = e.getValue() / 128f;
        } else if (e.getVarbitId() == VarbitID.SAILING_SIDEPANEL_BOAT_ACCELERATION) {
            boatAcceleration = e.getValue() / 128f;
        } else if (e.getVarbitId() == VarbitID.SAILING_SIDEPANEL_BOAT_MOVE_MODE) {
            lastMoveMode = moveMode;
            moveMode = e.getValue();
        } else if (e.getVarbitId() == VarbitID.SAILING_SIDEPANEL_BOAT_SPEEDBOOST_DURATION) {
            boostTickDuration = e.getValue();
        }
    }

    // Returns the boat world entity if sailing, otherwise null
    public WorldEntity getBoatEntity() {
        if (!isOnBoat)
            return null;

        var playerWvId = client.getLocalPlayer().getWorldView().getId();

        if (spawnedEntities.containsKey(playerWvId)) {
            return spawnedEntities.get(playerWvId);
        }

        return null;
    }

    public boolean isReversing() {
        return moveMode == 3;
    }

    /***
     * Whether the player is currently navigating the boat
     * @return
     */
    public boolean isNavigating() {
        return client.getTopLevelWorldView().getYellowClickAction() == Constants.CLICK_ACTION_SET_HEADING;
    }

}

package com.turningcircles;

import com.google.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.*;

public class BoatStatsOverlay extends Overlay {

    private final Client client;
    private final TurningCirclePlugin plugin;
    private final TurningCirclesConfig config;
    private final BoatManager boatManager;

    @Inject
    public BoatStatsOverlay(Client client, TurningCirclePlugin plugin, TurningCirclesConfig config, BoatManager boatManager) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.boatManager = boatManager;
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPosition(OverlayPosition.TOP_CENTER);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!boatManager.isOnBoat)
            return null;

        if (!config.showBoatSpeed())
            return null;

        graphics.setColor(Color.YELLOW);
        graphics.drawString("Speed: " + plugin.currentSpeed, 10, 20);
        graphics.drawString("Acceleration: " + plugin.currentAcceleration, 10, 40);
        graphics.setBackground(new Color(0, 0, 0, 20));
        graphics.setStroke(new BasicStroke(1));
        graphics.setColor(Color.WHITE);
        graphics.drawRect(0, 0, 110, 50);

        return new Dimension(100, 50);
    }
}

package com.turningcircles;

import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;

public class BoatStep {
    public Point offset;
    public int orientation;

    public BoatStep(Point offset, int orientation) {
        this.offset = offset;
        this.orientation = orientation;
    }
}

package com.turningcircles;

public class Line {
    public int x1, y1, x2, y2;

    public Line(int x1, int y1, int x2, int y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }

    /// returns side of the line that point x,y is on
    /// if > 0 on left, if < 0 right, if = 0 on line
    public int calculateSide(int x, int y) {
        return (x2 - x1) * (y - y1) - (y2 - y1) * (x - x1);
    }
}

package com.turningcircles;

import com.google.inject.Provides;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.*;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.GameEventManager;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(
        name = "Turning Circles"
)
public class TurningCirclePlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private TurningCirclesConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private GameEventManager gameEventManager;

    @Inject
    private TurningCirclesOverlay turningCirclesOverlay;

    @Inject
    private BoatStatsOverlay boatStatsOverlay;

    @Inject
    private EventBus eventBus;

    @Inject
    private BoatManager boatManager;

    // track velocity of the boat
    public double currentSpeed;
    public int currentTurnDirection;
    public int lastAngle;
    public double lastSpeed;
    public double currentAcceleration;
    private LocalPoint lastLoc = null;


    @Override
    protected void startUp() throws Exception {
        overlayManager.add(turningCirclesOverlay);
        overlayManager.add(boatStatsOverlay);

        boatManager.startUp();
        eventBus.register(boatManager);
        gameEventManager.simulateGameEvents(boatManager);
    }

    @Override
    protected void shutDown() throws Exception {
        overlayManager.remove(turningCirclesOverlay);
        overlayManager.remove(boatStatsOverlay);

        eventBus.unregister(boatManager);
        boatManager.shutDown();
    }

    @Subscribe
    public void onGameTick(GameTick e) {
        var boatEntity = boatManager.getBoatEntity();
        if (boatEntity == null)
            return;

        var loc = boatEntity.getTargetLocation();
        if (lastLoc != null) {
            var vx = loc.getX() - lastLoc.getX();
            var vy = loc.getY() - lastLoc.getY();

            var speed = SailingMath.getSpeed(vx, vy);

            var accel = (speed - lastSpeed);

            currentTurnDirection = SailingMath.calculateAngleDirectionBetweenOrientations(
                    lastAngle, boatEntity.getTargetOrientation(), 0);

            lastAngle = boatEntity.getTargetOrientation();

            // help protect against moving chunks with large acceleration
            // don't update speed if really big change
            if (accel < 10) {
                currentSpeed = speed;
                lastSpeed = currentSpeed;
                currentAcceleration = accel;
            }

        }

        lastLoc = loc;
    }

    @Provides
    TurningCirclesConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TurningCirclesConfig.class);
    }

    /// Returns the orientation that the user's mouse is pointing towards
    public int calculateMouseHeading(Client client, LocalPoint boatCentre) {

        // This kind of ridiculous, and there must be a better way.
        // But make lines that evenly divide the heading sectors from the centre
        // of the boat outwards in the canvas space.
        // Then check which side of each line the mouse point is to determine
        // which sector we are in.
        int nLines = 16;

        // Boat's centre on canvas
        var centre = Perspective.localToCanvas(client, boatCentre, 0);
        if (centre == null)
            return 0;

        var lineX = new float[]{0, 0};
        var lineY = new float[]{1000, -1000};
        var lineZ = new float[]{0, 0};

        var lines = new Line[nLines];
        for (int n = 0; n < nLines; n++) {
            // start at 64 as we are evenly dividing the sectors
            // south is zero/2048, north is 1024
            int a = 64 + 128 * n;
            int[] cx = new int[2];
            int[] cy = new int[2];
            Perspective.modelToCanvas(
                    client,
                    client.getTopLevelWorldView(),
                    2,
                    boatCentre.getX(), boatCentre.getY(),
                    0,
                    a,
                    lineX,
                    lineY,
                    lineZ,
                    cx,
                    cy
            );
            lines[n] = new Line(centre.getX(), centre.getY(), cx[1], cy[1]);
        }

        var cMouse = client.getMouseCanvasPosition();
        for (int i = 0; i < nLines - 1; i++) {
            var line = lines[i];
            var line1 = lines[i + 1];
            var val0 = line.calculateSide(cMouse.getX(), cMouse.getY());
            var val1 = line1.calculateSide(cMouse.getX(), cMouse.getY());
            if (val0 >= 0 && val1 < 0)
                return 128 + i * 128;
        }

        return 0; // sse
    }
}

package com.turningcircles;

import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

@Slf4j
public class TurningCirclesOverlay extends Overlay {

    private final Client client;
    private final TurningCirclePlugin plugin;
    private final TurningCirclesConfig config;
    private final BoatManager boatManager;

    @Inject
    public TurningCirclesOverlay(
            Client client,
            TurningCirclePlugin plugin,
            TurningCirclesConfig config,
            BoatManager boatManager) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.boatManager = boatManager;
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPosition(OverlayPosition.DYNAMIC);
    }

    @Override
    public Dimension render(Graphics2D g) {
        if (!boatManager.isNavigating())
            return null;

        if (plugin.currentSpeed == 0 && !config.showWhenStopped())
            return null;

        var boat = boatManager.getBoatEntity();
        if (boat == null) return null;

        var bc = boat.getConfig();
        var boatRect = new Rect(bc.getBoundsX(), bc.getBoundsY(), bc.getBoundsWidth(), bc.getBoundsHeight());

        var mouseHeading = plugin.calculateMouseHeading(client, boat.getLocalLocation());

        var paths = generateSteps(
                config.nSteps(),
                boat.getTargetOrientation(),
                mouseHeading);

        var outline = config.renderColor();
        var bg = config.fillColor();

        for (int i = 0; i < paths.length; i++) {
            var path = paths[i];
            var newLoc = boat.getTargetLocation().plus(path.offset.getX(), path.offset.getY());

            var frac = 1 - (double) i / (double) paths.length;

            if (config.fadeOutlineAlpha())
                outline = ColorUtil.colorWithAlpha(outline, (int) ((outline.getAlpha() - config.finalOutlineAlpha()) * frac + config.finalOutlineAlpha()));

            if (config.fadeBackgroundAlpha())
                bg = ColorUtil.colorWithAlpha(bg, (int) ((bg.getAlpha() - config.finalBackgroundAlpha()) * frac + config.finalBackgroundAlpha()));

            renderRotatedRect(client, g, newLoc, boatRect, path.orientation, outline, bg);
        }

        return null;
    }

    private void renderRotatedRect(Client client, Graphics2D g, LocalPoint p, Rect r, int angle, Color outline, Color fill) {

        float[] coordsZ = new float[]{0, 0, 0, 0};
        int[] cx = new int[4];
        int[] cy = new int[4];

        Perspective.modelToCanvas(
                client,
                client.getTopLevelWorldView(),
                r.coordsX.length,
                p.getX(),
                p.getY(),
                0,
                angle,
                r.coordsX,
                r.coordsY,
                coordsZ,
                cx,
                cy
        );

        Polygon canvasPoly = new Polygon();
        for (int i = 0; i < cx.length; i++) {
            canvasPoly.addPoint(cx[i], cy[i]);
        }
        g.setColor(outline);
        g.draw(canvasPoly);
        g.setColor(fill);
        g.fill(canvasPoly);
    }


    public BoatStep[] generateSteps(int nSteps, int fromOrientation, int toOrientation) {
        // show boat movement preview
        var steps = new BoatStep[nSteps];
        var dA = 128;
        int orientation = fromOrientation;

        var acceleration = boatManager.boatAcceleration;
        var speed = plugin.currentSpeed;

        if (boatManager.isReversing()) {
            speed *= -1;
            acceleration *= -1;
        }

        var dirA = SailingMath.calculateAngleDirectionBetweenOrientations(orientation, toOrientation, plugin.currentTurnDirection);
        var pos = new Point(0, 0);
        for (int i = 0; i < nSteps; i++) {

            // take the max just in case we aren't accounting for something in max speed calculation
            var maxSpeed = Math.max(boatManager.getMaxSpeed(i), plugin.currentSpeed);

            if (orientation != toOrientation) {
                orientation += dA * dirA;
            }

            speed += acceleration;
            speed = !boatManager.isReversing() ? Math.min(maxSpeed, speed) : Math.max(-maxSpeed, speed);

            orientation = SailingMath.cycleOrientation(orientation);

            var angleInDegrees = SailingMath.orientationToDegrees(orientation);
            var v = SailingMath.getVelocity(speed, angleInDegrees);
            pos = new Point(pos.getX() + v.getX(), pos.getY() + v.getY());
            steps[i] = new BoatStep(pos, orientation);
        }

        return steps;
    }

}

package com.turningcircles;

import org.junit.Assert;
import org.junit.Test;

public class SailingMathTests {
    @Test
    public void orientationToDegreesReturnsCorrectValues() {
        Assert.assertEquals(90, SailingMath.orientationToDegrees(1024), 0.001);
        Assert.assertEquals(270, SailingMath.orientationToDegrees(0), 0.001);
        Assert.assertEquals(22.5, SailingMath.orientationToDegrees(1536 - 128), 0.001);
    }

    @Test
    public void cycleOrientationReturnsCorrectValues() {
        Assert.assertEquals(1024, SailingMath.cycleOrientation(1024), 0.001);
        Assert.assertEquals(0, SailingMath.cycleOrientation(0), 0.001);
        Assert.assertEquals(2048 - 128, SailingMath.cycleOrientation(-128), 0.001);
        Assert.assertEquals(128, SailingMath.cycleOrientation(2048 + 128), 0.001);
    }

    @Test
    public void degreesToOrientationReturnsCorrectValues() {
        Assert.assertEquals(1536, SailingMath.degreesToOrientation(0), 0.001);
        Assert.assertEquals(1024, SailingMath.degreesToOrientation(90), 0.001);
        Assert.assertEquals(0, SailingMath.degreesToOrientation(270), 0.001);
    }

    @Test
    public void calculateOrientationDirectionReturnsCorrectValues() {
        Assert.assertEquals(-1, SailingMath.calculateAngleDirectionBetweenOrientations(0, 1536, 0));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(1536, 0, 0));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(1920, 0, 0));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(512, 1024, 0));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(0, 512, 0));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(0, 1024, 0));
        Assert.assertEquals(1, SailingMath.calculateAngleDirectionBetweenOrientations(0, 1024, 0));
        Assert.assertEquals(-1, SailingMath.calculateAngleDirectionBetweenOrientations(0, 1024, -1));
    }

    @Test
    public void getSpeedReturnsCorrectValues() {
        Assert.assertEquals(3.0, SailingMath.getSpeed(-288, -288), 0.001);
        Assert.assertEquals(3.0, SailingMath.getSpeed(288, 288), 0.001);
    }

    @Test
    public void getVelocityReturnsCorrectValues() {
        Assert.assertEquals(0, SailingMath.getVelocity(0, 0).getX());
        Assert.assertEquals(0, SailingMath.getVelocity(0, 0).getY());
        Assert.assertEquals(0, SailingMath.getVelocity(0, 0).getY());

        Assert.assertEquals(-288, SailingMath.getVelocity(3.0, 135).getX());
        Assert.assertEquals(288, SailingMath.getVelocity(3.0, 135).getY());
    }
}

package com.turningcircles;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TurningCirclesPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TurningCirclePlugin.class);
		RuneLite.main(args);
	}
}
