package com.nohintarrow;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.ui.overlay.OverlayManager;
import java.util.Optional;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.coords.WorldPoint;

@Slf4j
@PluginDescriptor(
	name = "No Hint-Arrow",
	description ="Completely remove the flashing yellow hint arrow, or let it only show for a set length of seconds. Optional substitute marker.",
	tags = {"accessibility","epilepsy","flashing","tutorial","arrow","marker"}
)
public class NoHintArrowPlugin extends Plugin
{

	@Inject
	private Client client;

	@Inject
	private NoHintArrowConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	//region overlay
	@Inject
	private OverlayManager overlayManager;

	@Inject
	private NoHintArrowOverlay overlay;
	//endregion

	// Tracks how many ticks the arrow has been active for when to clear hint arrow
	private int arrowActiveTicks = 0;

	//track what has been marked by the substitute marker in order to remove the marker
	private boolean isSubstituteMarkerSet = false;
	private int substituteMarkerActiveTicks = 0;


	@Override
	protected void startUp() throws Exception
	{
		log.info("noHintArrow plugin started!");
		overlayManager.add(overlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		log.info("noHintArrow plugin stopped!");
	}

	@Provides
	NoHintArrowConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(NoHintArrowConfig.class);
	}


	@Subscribe
	public void onGameTick(GameTick event)
	{
		//region timers
		//region Arrow timer
		if(client.hasHintArrow())
		{
			arrowActiveTicks++; //increment counter

		}
		else
		{
			// No arrow active, reset counter
			arrowActiveTicks = 0;
		}
		//endregion

		//region Substitute Marker timer
		if(isSubstituteMarkerSet){
			substituteMarkerActiveTicks++; //increment counter
		}
		else
		{
			// No substitute marker active, reset counter
			substituteMarkerActiveTicks = 0;
		}
		//endregion
		//endregion


		if (client.hasHintArrow() && (arrowActiveTicks >= getClearDelayTicks()))
		{
			clearHintArrow();
		}


		if (
				(isSubstituteMarkerSet && (substituteMarkerActiveTicks >= getSubstituteMarkerDurationTicks())) // remove marker after duration
				|| client.hasHintArrow() // remove marker if new hint arrow has been set
		)
		{
			clearSubstituteMarker();
		}
	}



	//region remove hint-arrow
	// the user config for clear delay converted to game ticks (1 tick = 0.6s)
	private int getClearDelayTicks(){
		return (int) Math.ceil(config.clearDelaySeconds() / 0.6);
	}


	private void clearHintArrow()
	{
		debugHintArrowValues();

		updateSubstituteMarker();

		arrowActiveTicks = 0; // reset counter

		client.clearHintArrow();
	}
	//endregion



	//region substitute marker
	// the user config for substitute marker duration converted to game ticks (1 tick = 0.6s)
	private int getSubstituteMarkerDurationTicks(){
		return (int) Math.ceil(config.substituteMarkerDurationSeconds() / 0.6);
	}


	private void updateSubstituteMarker()
	{
		clearSubstituteMarker();

		if (client.hasHintArrow() && (client.getHintArrowType() != HintArrowType.NONE))
		{
			isSubstituteMarkerSet = overlay.updateSubstituteMarker();
		}
	}


	private void clearSubstituteMarker()
	{
		isSubstituteMarkerSet = false;
		substituteMarkerActiveTicks = 0;

		overlay.clearSubstituteMarker();
	}
	//endregion



	//region debug
	// use for testing, manually set hint arrows when shift clicking on things
	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		if (!config.doDebugManualHints()){ return; } // only add debug options if debug mode on

		final boolean hotKeyPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
		if (!hotKeyPressed){ return; } // only add debug options if shift key is held

		MenuAction menuAction = event.getMenuEntry().getType();


		//region add setHintArrow options to menu

		// Coordinate from ground
		if (menuAction == MenuAction.WALK) {
			final int worldId = event.getMenuEntry().getWorldViewId();
			Optional.ofNullable(client.getWorldView(worldId))
					.map(WorldView::getSelectedSceneTile)
					.map(e->WorldPoint.fromLocalInstance(client, e.getLocalLocation()))
					.ifPresent(worldPoint ->
						client.getMenu().createMenuEntry(-1)
								.setOption("setHintArrow")
								.setTarget("Tile")
								.setType(MenuAction.RUNELITE)
								.onClick(e ->
										client.setHintArrow(worldPoint)));
		}

		// NPC
		if (menuAction == MenuAction.EXAMINE_NPC) {
			client.getMenu().createMenuEntry(-1)
					.setOption("setHintArrow")
					.setTarget(event.getTarget())
					.setType(MenuAction.RUNELITE)
					.onClick(e ->
							client.setHintArrow(event.getMenuEntry().getNpc()));
		}

		// Player
		Player player = event.getMenuEntry().getPlayer();
		String option = event.getMenuEntry().getOption();
		if ((player != null) && (option.equals("Follow"))) {
			client.getMenu().createMenuEntry(-1)
					.setOption("setHintArrow")
					.setTarget(event.getTarget())
					.setType(MenuAction.RUNELITE)
					.onClick(e ->
							client.setHintArrow(player));
		}

		//endregion

	}


	private void printInChatbox(String message)
	{
		log.info(message);
		chatMessageManager.queue(
				QueuedMessage.builder()
						.type(ChatMessageType.GAMEMESSAGE) // Game info style
						.runeLiteFormattedMessage(
								String.format("<col=%06x>", config.debugMessageColor().getRGB() & 0xFFFFFF)
										+ message
										+ "</col>"
						)
						.build()
		);
	}


	// use for testing, debug info put in chatbox
	private void debugHintArrowValues()
	{
		switch(config.doDebugMessages()) {
			case INFORMATIVE:
				printInChatbox("Hint arrow removed.");

				String[] hintArrowTypeNames = {
						"NONE",
						"NPC",
						"COORDINATE",
						"PLAYER",
						"WORLDENTITY"
				};
				int hintArrowTypeIndex = client.getHintArrowType();
				String hintArrowTypeName = hintArrowTypeNames[client.getHintArrowType()];
				printInChatbox("Hint arrow type " + hintArrowTypeIndex + " (" + hintArrowTypeName + ")");

				switch (hintArrowTypeName) {
					case "NPC":
						printInChatbox(
								"NPC name "
										+ Optional.ofNullable(client.getHintArrowNpc())
										.map(NPC::getName)
										.orElse("-null-")
						);
						break;

					case "COORDINATE":
						printInChatbox(
								"Coordinates "
										+ Optional.ofNullable(client.getHintArrowPoint())
										.map(p -> p.getX() + "," + p.getY())
										.orElse("-null-")
						);
						break;

					case "PLAYER":
						printInChatbox(
								"player name "
										+ Optional.ofNullable(client.getHintArrowPlayer())
										.map(Player::getName)
										.orElse("-null-")
						);
						break;

					default:
						//pass
						break;
				}
				break;

			case MINIMAL:
				printInChatbox("Hint arrow removed.");
				break;

			default:
				break;
		}

	}
	//endregion
}

package com.nohintarrow;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import net.runelite.api.HintArrowType;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.coords.LocalPoint;

import javax.inject.Inject;
import java.awt.*;
import javax.annotation.Nullable;
import com.google.common.base.Strings;

public class NoHintArrowOverlay extends Overlay{

    private static final int MAX_DRAW_DISTANCE = 32;

    private int hintArrowType = HintArrowType.NONE;
    private NPC hintArrowNPC;
    private Player hintArrowPlayer;
    private WorldPoint hintArrowPoint;


    @Inject
    private Client client;

    @Inject
    private NoHintArrowConfig config;

    @Inject
    public NoHintArrowOverlay() {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        if (isVisible()) {
            String label = config.showSubstituteMarkerLabel() ? "Hint" : null;
            switch (hintArrowType){
                case HintArrowType.NPC:
                    OverlayUtil.renderActorOverlay(graphics, hintArrowNPC, label, config.substituteMarkerColor());
                    break;
                case HintArrowType.COORDINATE:
                    drawTile( graphics,  hintArrowPoint,  config.substituteMarkerColor(), label);
                    break;
                case HintArrowType.PLAYER:
                    OverlayUtil.renderActorOverlay(graphics, hintArrowPlayer, label, config.substituteMarkerColor());
                    break;

                //case HintArrowType.WORLDENTITY:
                case HintArrowType.NONE:
                default:
                    //I don't see any way to handle the hint-arrow when type is HintArrowType.WORLDENTITY
                    //do nothing
                    break;
            }
        }
        return null;
    }

    private boolean isVisible()
    {
        return config.doSubstituteMarker() && (hintArrowType != HintArrowType.NONE);
    }

    public void clearSubstituteMarker()
    {
        hintArrowType = HintArrowType.NONE;
        hintArrowNPC = null;
        hintArrowPlayer = null;
        hintArrowPoint = null;
    }

    /**
     *
     * @return whether the marker has been set
     */
    public boolean updateSubstituteMarker()
    {
        clearSubstituteMarker();

        if (client.hasHintArrow())
        {
            hintArrowType = client.getHintArrowType();

            switch (hintArrowType) {
                case HintArrowType.NPC:
                    hintArrowNPC = client.getHintArrowNpc();
                    break;
                case HintArrowType.COORDINATE:
                    hintArrowPoint = client.getHintArrowPoint();
                    break;
                case HintArrowType.PLAYER:
                    hintArrowPlayer = client.getHintArrowPlayer();
                    break;

                case HintArrowType.WORLDENTITY:
                    /* there is no client.getHintArrowWorldEntity? */
                case HintArrowType.NONE:
                default:
                    clearSubstituteMarker();
                    return false;
            }
        }
        return true;
    }


    // based on GroundMarkerOverlay.drawTile from runelite/runelite-client/src/main/java/net/runelite/client/plugins/groundmarkers/GroundMarkerOverlay.java
    private void drawTile(Graphics2D graphics, WorldPoint point, Color color, @Nullable String label)
    {
        //region set parameters
        final int borderWidth = 2;
        final Stroke borderStroke = new BasicStroke((float) borderWidth);
        final int fillOpacity =50;
        //endregion

        if (client.getLocalPlayer().getWorldView().isTopLevel())
        {
            WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

            if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
            {
                return;
            }
        }

        LocalPoint lp = LocalPoint.fromWorld(client.findWorldViewFromWorldPoint(point), point);
        if (lp == null)
        {
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly != null)
        {
            OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, fillOpacity), borderStroke);
        }

        if (!Strings.isNullOrEmpty(label))
        {
            Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);
            if (canvasTextLocation != null)
            {
                OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color);
            }
        }
    }
}

package com.nohintarrow;

/**
 * Levels for how much information to put in debug messages.
 */
public enum DebugMessagesDetailLevel {
    NONE("None"),
    MINIMAL("Minimnal"),
    INFORMATIVE("Informative");

    private final String caption;

    DebugMessagesDetailLevel(String caption)
    {
        this.caption = caption;
    }

    public String getCaption()
    {
        return caption;
    }
}

package com.nohintarrow;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import java.awt.Color;

@ConfigGroup("noHintArrow")
public interface NoHintArrowConfig extends Config
{
	//boolean ENABLE_DEBUG_MODE = false; // use false in production, set to true when debugging to access debug tools



	@ConfigItem(
			keyName = "clearDelaySeconds",
			name = "Clear Delay (seconds)",
			description = "How many seconds before the hint arrow is cleared automatically",
			position=0
	)
	default int clearDelaySeconds()
	{
		return 0; // default 0 seconds
	}



	//region Substitute Marker Settings
	@ConfigSection(
			name = "Substitute Marker Settings",
			description = "Substitute Marker configuration",
			position = 2,
			closedByDefault = true
	)
	String substituteMarkerSection = "substituteMarkerSection";


	@ConfigItem(
			keyName = "doSubstituteMarker",
			name = "Use a substitute marker",
			description = "Show a substitute marker for the removed hint arrow",
			section = substituteMarkerSection,
			position = 0
	)
	default boolean doSubstituteMarker()
	{
		return false; // default won't use a substitute marker
	}


	@ConfigItem(
			keyName = "substituteMarkerDurationSeconds",
			name = "Duration (seconds)",
			description = "How many seconds before the substitute marker is cleared",
			section = substituteMarkerSection,
			position = 1
	)
	default int substituteMarkerDurationSeconds()
	{
		return 60; // default 1 minute
	}


	@ConfigItem(
			keyName = "substituteMarkerColor",
			name = "Marker Color",
			description = "Choose the color for the substitute marker",
			section = substituteMarkerSection,
			position = 2
	)
	default Color substituteMarkerColor() {
		return Color.YELLOW; // default yellow
	}


	@ConfigItem(
			keyName = "showSubstituteMarkerLabel",
			name = "Show Label",
			description = "Show a text label (\"Hint\") on the substitute marker",
			section = substituteMarkerSection,
			position = 3
	)
	default boolean showSubstituteMarkerLabel()
	{
		return true; // default will show label for substitute marker
	}
	//endregion



	//region debug
	@ConfigSection(
			name = "Debug Options",
			description = "Various options for debugging",
			position = 3,
			closedByDefault = true
	)
	String debugSection = "debugSection";


	@ConfigItem(
			keyName = "doDebugManualHints",
			name = "Manually add Hint-Arrows",
			description = "Enable shift click to manually set hint arrows",
			section = debugSection,
			position = 0
	)
	default boolean doDebugManualHints()
	{
		return false; // default won't show debug menu options
	}


	@ConfigItem(
			keyName = "doDebugMessages",
			name = "Debug Messages",
			description = "Show debug messages in chatbox",
			section = debugSection,
			position = 1
	)
	default DebugMessagesDetailLevel doDebugMessages()
	{
		return DebugMessagesDetailLevel.NONE; // default won't show debug messages
	}


	@ConfigItem(
			keyName = "debugMessageColor",
			name = "Debug Message Color",
			description = "Choose the color for debug text",
			section = debugSection,
			position = 2
	)
	default Color debugMessageColor()
	{
		return new Color(0x7F007F); // default same purple as incoming trade requests
	}
	//endregion
}

package com.nohintarrow;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class NoHintArrowPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(NoHintArrowPlugin.class);
		RuneLite.main(args);
	}
}
