package com.nohintarrow;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.ui.overlay.OverlayManager;
import java.util.Optional;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.coords.WorldPoint;

@Slf4j
@PluginDescriptor(
	name = "No Hint-Arrow",
	description ="Completely remove the flashing yellow hint arrow, or let it only show for a set length of seconds. Optional substitute marker.",
	tags = {"accessibility","epilepsy","flashing","tutorial","arrow","marker"}
)
public class NoHintArrowPlugin extends Plugin
{

	@Inject
	private Client client;

	@Inject
	private NoHintArrowConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	//region overlay
	@Inject
	private OverlayManager overlayManager;

	@Inject
	private NoHintArrowOverlay overlay;
	//endregion

	// Tracks how many ticks the arrow has been active for when to clear hint arrow
	private int arrowActiveTicks = 0;

	//track what has been marked by the substitute marker in order to remove the marker
	private boolean isSubstituteMarkerSet = false;
	private int substituteMarkerActiveTicks = 0;


	@Override
	protected void startUp() throws Exception
	{
		log.info("noHintArrow plugin started!");
		overlayManager.add(overlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		log.info("noHintArrow plugin stopped!");
	}

	@Provides
	NoHintArrowConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(NoHintArrowConfig.class);
	}


	@Subscribe
	public void onGameTick(GameTick event)
	{
		//region timers
		substituteMarkerActiveTicks++; //increment counter
		if(client.hasHintArrow())
		{
			arrowActiveTicks++; //increment counter
			substituteMarkerActiveTicks = 0; // refresh the counter for keeping substitute up

		}
		else
		{
			// No arrow active, reset counter
			arrowActiveTicks = 0;
		}
		//endregion


		overlay.updateSubstituteMarker(substituteMarkerActiveTicks);


		if (client.hasHintArrow() && (arrowActiveTicks >= getClearDelayTicks())) // clear hint arrow if duration elapsed
		{
			clearHintArrow();
		}
	}



	//region remove hint-arrow
	// the user config for clear delay converted to game ticks (1 tick = 0.6s)
	private int getClearDelayTicks(){
		return (int) Math.ceil(config.clearDelaySeconds() / 0.6);
	}


	private void clearHintArrow()
	{
		debugHintArrowValues();

		arrowActiveTicks = 0; // reset counter

		client.clearHintArrow();
	}
	//endregion



	//region debug
	// use for testing, manually set hint arrows when shift clicking on things
	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		if (!config.doDebugManualHints()){ return; } // only add debug options if debug mode on

		final boolean hotKeyPressed = client.isKeyPressed(KeyCode.KC_SHIFT);
		if (!hotKeyPressed){ return; } // only add debug options if shift key is held

		MenuAction menuAction = event.getMenuEntry().getType();


		//region add setHintArrow options to menu

		// Coordinate from ground
		if (menuAction == MenuAction.WALK) {
			final int worldId = event.getMenuEntry().getWorldViewId();
			Optional.ofNullable(client.getWorldView(worldId))
					.map(WorldView::getSelectedSceneTile)
					.map(e->WorldPoint.fromLocalInstance(client, e.getLocalLocation()))
					.ifPresent(worldPoint ->
						client.getMenu().createMenuEntry(-1)
								.setOption("setHintArrow")
								.setTarget("Tile")
								.setType(MenuAction.RUNELITE)
								.onClick(e ->
										client.setHintArrow(worldPoint)));
		}

		// NPC
		if (menuAction == MenuAction.EXAMINE_NPC) {
			client.getMenu().createMenuEntry(-1)
					.setOption("setHintArrow")
					.setTarget(event.getTarget())
					.setType(MenuAction.RUNELITE)
					.onClick(e ->
							client.setHintArrow(event.getMenuEntry().getNpc()));
		}

		// Player
		Player player = event.getMenuEntry().getPlayer();
		String option = event.getMenuEntry().getOption();
		if ((player != null) && (option.equals("Follow"))) {
			client.getMenu().createMenuEntry(-1)
					.setOption("setHintArrow")
					.setTarget(event.getTarget())
					.setType(MenuAction.RUNELITE)
					.onClick(e ->
							client.setHintArrow(player));
		}

		//endregion

	}


	private void printInChatbox(String message)
	{
		log.info(message);
		chatMessageManager.queue(
				QueuedMessage.builder()
						.type(ChatMessageType.GAMEMESSAGE) // Game info style
						.runeLiteFormattedMessage(
								String.format("<col=%06x>", config.debugMessageColor().getRGB() & 0xFFFFFF)
										+ message
										+ "</col>"
						)
						.build()
		);
	}


	// use for testing, debug info put in chatbox
	private void debugHintArrowValues()
	{
		switch(config.doDebugMessages()) {
			case INFORMATIVE:
				printInChatbox("Hint arrow removed.");

				String[] hintArrowTypeNames = {
						"NONE",
						"NPC",
						"COORDINATE",
						"PLAYER",
						"WORLDENTITY"
				};
				int hintArrowTypeIndex = client.getHintArrowType();
				String hintArrowTypeName = hintArrowTypeNames[client.getHintArrowType()];
				printInChatbox("Hint arrow type " + hintArrowTypeIndex + " (" + hintArrowTypeName + ")");

				switch (hintArrowTypeName) {
					case "NPC":
						printInChatbox(
								"NPC name "
										+ Optional.ofNullable(client.getHintArrowNpc())
										.map(NPC::getName)
										.orElse("-null-")
						);
						break;

					case "COORDINATE":
						printInChatbox(
								"Coordinates "
										+ Optional.ofNullable(client.getHintArrowPoint())
										.map(p -> p.getX() + "," + p.getY())
										.orElse("-null-")
						);
						break;

					case "PLAYER":
						printInChatbox(
								"player name "
										+ Optional.ofNullable(client.getHintArrowPlayer())
										.map(Player::getName)
										.orElse("-null-")
						);
						break;

					default:
						//pass
						break;
				}
				break;

			case MINIMAL:
				printInChatbox("Hint arrow removed.");
				break;

			default:
				break;
		}

	}
	//endregion
}

/*
BSD 2-Clause License

Copyright (c) 2025, LlemonDuck
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package com.nohintarrow;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Polygon;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import static net.runelite.api.Perspective.LOCAL_HALF_TILE_SIZE;
import static net.runelite.api.Perspective.LOCAL_TILE_SIZE;

import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;


public class ArrowDrawer //based on the boat arrow from LlemonDuck/sailing plugin
{


    // arrow facing right
    // spans about 2 full tiles
    private static final float[] ARROW_X = new float[]{
            0,
            -3 * ((float) LOCAL_TILE_SIZE / 4),
            -3 * ((float) LOCAL_TILE_SIZE / 4),
            0,
            0,
            +3 * ((float) (5 * LOCAL_TILE_SIZE) / 16),
            0,
    };
    private static final float[] ARROW_Y = new float[]{
            +((float) LOCAL_TILE_SIZE / 8), // box top right
            +((float) LOCAL_TILE_SIZE / 8), // box bottom right
            -((float) LOCAL_TILE_SIZE / 8), // box bottom left
            -((float) LOCAL_TILE_SIZE / 8), // box top left
            -((float) (5 * LOCAL_TILE_SIZE) / 16), // head left
            0, // head top
            +((float) (5 * LOCAL_TILE_SIZE) / 16), // head right
    };

    public static int jauBetween(LocalPoint p1, LocalPoint p2)
    {
        int dx = p2.getX() - p1.getX();
        int dy = p2.getY() - p1.getY();
        double radialStep = 2048. / (Math.PI * 2.);
        return ((int) Math.round(Math.atan2(dy, -dx) * radialStep)) & 2047;
    }

    public static float[] translate(float[] src, int offset)
    {
        float[] translated = new float[src.length];
        for (int i = 0; i < src.length; i++)
        {
            translated[i] = src[i] + offset;
        }
        return translated;
    }

    public static void renderArrowTowardPoint(Graphics2D g, Client client, WorldPoint destination, Color color, int clearRadius)
    {

        WorldView tlwv = client.getTopLevelWorldView();
        int baseX = tlwv.getBaseX();
        int baseY = tlwv.getBaseY();

        LocalPoint targetLp = LocalPoint.fromScene(destination.getX() - baseX, destination.getY() - baseY, tlwv); // maybe outside the scene
        LocalPoint playerLp = client.getLocalPlayer().getLocalLocation();

        float[] arrowX = ArrowDrawer.translate(ARROW_X, clearRadius * LOCAL_HALF_TILE_SIZE); // push the arrow outside the boat
        float[] arrowY = ARROW_Y;

        int[] outXs = new int[arrowX.length];
        int[] outYs = new int[arrowY.length];
        Perspective.modelToCanvas(
                client,
                client.getTopLevelWorldView(),
                arrowX.length,
                playerLp.getX(),
                playerLp.getY(),
                getPlayerZ3dCentre(client),//0,
                ArrowDrawer.jauBetween(targetLp, playerLp),
                arrowX,
                arrowY,
                new float[arrowX.length],
                outXs,
                outYs
        );

        g.setColor(color);
        g.fill(new Polygon(outXs, outYs, outXs.length));
    }
    /**
      * @return the 3d z coordinate of the ground under the player for the Perspective.modelToCanvas call
     */
    static int getPlayerZ3dCentre(Client client){
        Player localPlayer = client.getLocalPlayer();
        LocalPoint lp = localPlayer.getLocalLocation();
        int sceneX = lp.getSceneX();
        int sceneY = lp.getSceneY();
        WorldView wv = client.getTopLevelWorldView();
        int z3dCentre = wv.getTileHeights()[wv.getPlane()][sceneX][sceneY];
        return z3dCentre;
    }

}

package com.nohintarrow;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import net.runelite.api.HintArrowType;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.coords.LocalPoint;

import javax.inject.Inject;
import java.awt.*;
import javax.annotation.Nullable;
import com.google.common.base.Strings;


public class NoHintArrowOverlay extends Overlay{

    private static final int MAX_DRAW_DISTANCE = 32;

    private int hintArrowType = HintArrowType.NONE;
    private NPC hintArrowNPC;
    private Player hintArrowPlayer;
    private WorldPoint hintArrowPoint;
    private int substituteMarkerActiveTicks;


    @Inject
    private Client client;

    @Inject
    private NoHintArrowConfig config;

    @Inject
    public NoHintArrowOverlay() {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        if (isTileMarkerVisible()) {
            String label = config.showSubstituteTileMarkerLabel() ? "Hint" : null;
            switch (hintArrowType){
                case HintArrowType.NPC:
                    OverlayUtil.renderActorOverlay(graphics, hintArrowNPC, label, config.substituteTileMarkerColor());
                    break;
                case HintArrowType.COORDINATE:
                    drawTile( graphics,  hintArrowPoint,  config.substituteTileMarkerColor(), label);
                    break;
                case HintArrowType.PLAYER:
                    OverlayUtil.renderActorOverlay(graphics, hintArrowPlayer, label, config.substituteTileMarkerColor());
                    break;

                //case HintArrowType.WORLDENTITY:
                case HintArrowType.NONE:
                default:
                    //I don't see any way to handle the hint-arrow when type is HintArrowType.WORLDENTITY
                    //do nothing
                    break;
            }
        }

        if (isSubstituteArrowVisible()) {
            switch (hintArrowType){
                case HintArrowType.NPC:
                    ArrowDrawer.renderArrowTowardPoint(
                            graphics,
                            client,
                            hintArrowNPC.getWorldLocation(),
                            config.substituteArrowColor(),
                            config.substituteArrowClearRadius()
                    );
                    break;
                case HintArrowType.COORDINATE:
                    ArrowDrawer.renderArrowTowardPoint(
                            graphics,
                            client,
                            hintArrowPoint,
                            config.substituteArrowColor(),
                            config.substituteArrowClearRadius()
                    );
                    break;
                case HintArrowType.PLAYER:
                    ArrowDrawer.renderArrowTowardPoint(
                            graphics,
                            client,
                            hintArrowPlayer.getWorldLocation(),
                            config.substituteArrowColor(),
                            config.substituteArrowClearRadius()
                    );
                    break;

                //case HintArrowType.WORLDENTITY:
                case HintArrowType.NONE:
                default:
                    //I don't see any way to handle the hint-arrow when type is HintArrowType.WORLDENTITY
                    //do nothing
                    break;
            }
        }
        return null;
    }

    private boolean isTileMarkerVisible()
    {
        int maxDuration = (int) Math.ceil(config.substituteTileMarkerDurationSeconds() / 0.6); //duration converted to game ticks (1 tick = 0.6s)
        return (
            config.doSubstituteTileMarker()
            && (hintArrowType != HintArrowType.NONE)
            && (substituteMarkerActiveTicks <= maxDuration)
        );
    }

    private boolean isSubstituteArrowVisible()
    {
        int maxDuration = (int) Math.ceil(config.substituteArrowDurationSeconds() / 0.6); //duration converted to game ticks (1 tick = 0.6s)
        return (
            config.doSubstituteArrow()
            && (hintArrowType != HintArrowType.NONE)
            && (substituteMarkerActiveTicks <= maxDuration)
        );
    }

    public void updateSubstituteMarker(int substituteMarkerActiveTicks)
    {
        this.substituteMarkerActiveTicks = substituteMarkerActiveTicks;
        if (client.hasHintArrow())
        {
            hintArrowType = client.getHintArrowType();

            switch (hintArrowType) {
                case HintArrowType.NPC:
                    hintArrowNPC = client.getHintArrowNpc();
                    break;
                case HintArrowType.COORDINATE:
                    hintArrowPoint = client.getHintArrowPoint();
                    break;
                case HintArrowType.PLAYER:
                    hintArrowPlayer = client.getHintArrowPlayer();
                    break;

                case HintArrowType.WORLDENTITY:
                    /* there is no client.getHintArrowWorldEntity? */
                case HintArrowType.NONE:
                default:
                    break;
            }
        }
    }


    // based on GroundMarkerOverlay.drawTile from runelite/runelite-client/src/main/java/net/runelite/client/plugins/groundmarkers/GroundMarkerOverlay.java
    private void drawTile(Graphics2D graphics, WorldPoint point, Color color, @Nullable String label)
    {
        //region set parameters
        final int borderWidth = 2;
        final Stroke borderStroke = new BasicStroke((float) borderWidth);
        final int fillOpacity =50;
        //endregion

        if (client.getLocalPlayer().getWorldView().isTopLevel())
        {
            WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

            if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
            {
                return;
            }
        }

        LocalPoint lp = LocalPoint.fromWorld(client.findWorldViewFromWorldPoint(point), point);
        if (lp == null)
        {
            return;
        }

        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly != null)
        {
            OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, fillOpacity), borderStroke);
        }

        if (!Strings.isNullOrEmpty(label))
        {
            Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);
            if (canvasTextLocation != null)
            {
                OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color);
            }
        }
    }
}

package com.nohintarrow;

/**
 * Levels for how much information to put in debug messages.
 */
public enum DebugMessagesDetailLevel {
    NONE("None"),
    MINIMAL("Minimnal"),
    INFORMATIVE("Informative");

    private final String caption;

    DebugMessagesDetailLevel(String caption)
    {
        this.caption = caption;
    }

    public String getCaption()
    {
        return caption;
    }
}

package com.nohintarrow;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import java.awt.Color;

@ConfigGroup("noHintArrow")
public interface NoHintArrowConfig extends Config
{
	//boolean ENABLE_DEBUG_MODE = false; // use false in production, set to true when debugging to access debug tools



	@ConfigItem(
			keyName = "clearDelaySeconds",
			name = "Clear Delay (seconds)",
			description = "How many seconds before the hint arrow is cleared automatically",
			position=0
	)
	default int clearDelaySeconds()
	{
		return 0; // default 0 seconds
	}



	//region Substitute Tile Marker Settings
	@ConfigSection(
			name = "Substitute Tile Marker Settings",
			description = "Substitute Tile Marker configuration",
			position = 2,
			closedByDefault = true
	)
	String substituteTileMarkerSection = "substituteTileMarkerSection";


	@ConfigItem(
			keyName = "doSubstituteTileMarker",
			name = "Use a substitute tile marker",
			description = "Show a substitute tile marker for the removed hint arrow",
			section = substituteTileMarkerSection,
			position = 0
	)
	default boolean doSubstituteTileMarker()
	{
		return true; // default will use a substitute tile marker
	}


	@ConfigItem(
			keyName = "substituteTileMarkerDurationSeconds",
			name = "Duration (seconds)",
			description = "How many seconds before the substitute tile marker is cleared",
			section = substituteTileMarkerSection,
			position = 1
	)
	default int substituteTileMarkerDurationSeconds()
	{
		return 60; // default 1 minute
	}


	@ConfigItem(
			keyName = "substituteTileMarkerColor",
			name = "Color",
			description = "Choose the color for the substitute tile marker",
			section = substituteTileMarkerSection,
			position = 2
	)
	default Color substituteTileMarkerColor() {
		return Color.YELLOW; // default yellow
	}


	@ConfigItem(
			keyName = "showSubstituteTileMarkerLabel",
			name = "Show Label",
			description = "Show a text label (\"Hint\") on the substitute tile marker",
			section = substituteTileMarkerSection,
			position = 3
	)
	default boolean showSubstituteTileMarkerLabel()
	{
		return true; // default will show label for substitute marker
	}
	//endregion



	//region Substitute Arrow Settings
	@ConfigSection(
			name = "Substitute Arrow Settings",
			description = "Substitute Arrow configuration",
			position = 3,
			closedByDefault = true
	)
	String substituteArrowSection = "substituteArrowSection";


	@ConfigItem(
			keyName = "doSubstituteArrow",
			name = "Use a substitute arrow",
			description = "Show a substitute arrow for the removed hint arrow",
			section = substituteArrowSection,
			position = 0
	)
	default boolean doSubstituteArrow()
	{
		return true; // default will use a substitute arrow
	}


	@ConfigItem(
			keyName = "substituteArrowDurationSeconds",
			name = "Duration (seconds)",
			description = "How many seconds before the substitute arrow is cleared",
			section = substituteArrowSection,
			position = 1
	)
	default int substituteArrowDurationSeconds()
	{
		return 60; // default 1 minute
	}


	@ConfigItem(
			keyName = "substituteArrowColor",
			name = "Color",
			description = "Choose the color for the substitute arrow",
			section = substituteArrowSection,
			position = 2
	)
	default Color substituteArrowColor() {
		return Color.ORANGE; // default yellow
	}


	@ConfigItem(
			keyName = "substituteArrowClearRadius",
			name = "Clear radius",
			description = "Radius of clear space around player before the arrow starts",
			section = substituteArrowSection,
			position = 3
	)
	default int substituteArrowClearRadius() {
		return 3; // default about 1 tile
	}
	//endregion



	//region debug
	@ConfigSection(
			name = "Debug Options",
			description = "Various options for debugging",
			position = 4,
			closedByDefault = true
	)
	String debugSection = "debugSection";


	@ConfigItem(
			keyName = "doDebugManualHints",
			name = "Manually add Hint-Arrows",
			description = "Enable shift click to manually set hint arrows",
			section = debugSection,
			position = 0
	)
	default boolean doDebugManualHints()
	{
		return false; // default won't show debug menu options
	}


	@ConfigItem(
			keyName = "doDebugMessages",
			name = "Debug Messages",
			description = "Show debug messages in chatbox",
			section = debugSection,
			position = 1
	)
	default DebugMessagesDetailLevel doDebugMessages()
	{
		return DebugMessagesDetailLevel.NONE; // default won't show debug messages
	}


	@ConfigItem(
			keyName = "debugMessageColor",
			name = "Debug Message Color",
			description = "Choose the color for debug text",
			section = debugSection,
			position = 2
	)
	default Color debugMessageColor()
	{
		return new Color(0x7F007F); // default same purple as incoming trade requests
	}
	//endregion
}

package com.nohintarrow;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class NoHintArrowPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(NoHintArrowPlugin.class);
		RuneLite.main(args);
	}
}
