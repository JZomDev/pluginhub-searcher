package com.oneshot.modules;

import net.runelite.api.gameval.VarbitID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Set;

public final class DiaryImages
{
    private static final Logger log = LoggerFactory.getLogger(DiaryImages.class);
    public static class DiaryInfo
    {
        private final String area;
        private final String tier;

        public DiaryInfo(String area, String tier)
        {
            this.area = area;
            this.tier = tier;
        }

        public String getArea()
        {
            return area;
        }

        public String getTier()
        {
            return tier;
        }
    }

    private static String getDiaryTier(int varbitId) {
        Set<Integer> easy = Set.of(
                VarbitID.ARDOUGNE_DIARY_EASY_COMPLETE,
                VarbitID.FALADOR_DIARY_EASY_COMPLETE,
                VarbitID.WILDERNESS_DIARY_EASY_COMPLETE,
                VarbitID.WESTERN_DIARY_EASY_COMPLETE,
                VarbitID.KANDARIN_DIARY_EASY_COMPLETE,
                VarbitID.VARROCK_DIARY_EASY_COMPLETE,
                VarbitID.DESERT_DIARY_EASY_COMPLETE,
                VarbitID.MORYTANIA_DIARY_EASY_COMPLETE,
                VarbitID.FREMENNIK_DIARY_EASY_COMPLETE,
                VarbitID.LUMBRIDGE_DIARY_EASY_COMPLETE,
                VarbitID.KOUREND_DIARY_EASY_COMPLETE,
                VarbitID.ATJUN_EASY_DONE
        );

        Set<Integer> medium = Set.of(
                VarbitID.ARDOUGNE_DIARY_MEDIUM_COMPLETE,
                VarbitID.FALADOR_DIARY_MEDIUM_COMPLETE,
                VarbitID.WILDERNESS_DIARY_MEDIUM_COMPLETE,
                VarbitID.WESTERN_DIARY_MEDIUM_COMPLETE,
                VarbitID.KANDARIN_DIARY_MEDIUM_COMPLETE,
                VarbitID.VARROCK_DIARY_MEDIUM_COMPLETE,
                VarbitID.DESERT_DIARY_MEDIUM_COMPLETE,
                VarbitID.MORYTANIA_DIARY_MEDIUM_COMPLETE,
                VarbitID.FREMENNIK_DIARY_MEDIUM_COMPLETE,
                VarbitID.LUMBRIDGE_DIARY_MEDIUM_COMPLETE,
                VarbitID.KOUREND_DIARY_MEDIUM_COMPLETE,
                VarbitID.ATJUN_MED_DONE
        );

        Set<Integer> hard = Set.of(
                VarbitID.ARDOUGNE_DIARY_HARD_COMPLETE,
                VarbitID.FALADOR_DIARY_HARD_COMPLETE,
                VarbitID.WILDERNESS_DIARY_HARD_COMPLETE,
                VarbitID.WESTERN_DIARY_HARD_COMPLETE,
                VarbitID.KANDARIN_DIARY_HARD_COMPLETE,
                VarbitID.VARROCK_DIARY_HARD_COMPLETE,
                VarbitID.DESERT_DIARY_HARD_COMPLETE,
                VarbitID.MORYTANIA_DIARY_HARD_COMPLETE,
                VarbitID.FREMENNIK_DIARY_HARD_COMPLETE,
                VarbitID.LUMBRIDGE_DIARY_HARD_COMPLETE,
                VarbitID.KOUREND_DIARY_HARD_COMPLETE,
                VarbitID.ATJUN_HARD_DONE
        );

        Set<Integer> elite = Set.of(
                VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE,
                VarbitID.FALADOR_DIARY_ELITE_COMPLETE,
                VarbitID.WILDERNESS_DIARY_ELITE_COMPLETE,
                VarbitID.WESTERN_DIARY_ELITE_COMPLETE,
                VarbitID.KANDARIN_DIARY_ELITE_COMPLETE,
                VarbitID.VARROCK_DIARY_ELITE_COMPLETE,
                VarbitID.DESERT_DIARY_ELITE_COMPLETE,
                VarbitID.MORYTANIA_DIARY_ELITE_COMPLETE,
                VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE,
                VarbitID.LUMBRIDGE_DIARY_ELITE_COMPLETE,
                VarbitID.KOUREND_DIARY_ELITE_COMPLETE,
                VarbitID.KARAMJA_DIARY_ELITE_COMPLETE
        );

        if (easy.contains(varbitId)) return "Easy";
        if (medium.contains(varbitId)) return "Medium";
        if (hard.contains(varbitId)) return "Hard";
        if (elite.contains(varbitId)) return "Elite";

        return "Unknown"; // fallback if no match
    }

    public static DiaryInfo getDiaryInfo(int varbitId)
    {
        String area;
        String tier;

        // ----- AREA -----
        if (varbitId == VarbitID.ATJUN_EASY_DONE
                || varbitId == VarbitID.ATJUN_MED_DONE
                || varbitId == VarbitID.ATJUN_HARD_DONE
                || varbitId == VarbitID.KARAMJA_DIARY_ELITE_COMPLETE)
        {
            area = "Karamja";
        }
        else if (varbitId >= VarbitID.ARDOUGNE_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE)
        {
            area = "Ardougne";
        }
        else if (varbitId >= VarbitID.FALADOR_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.FALADOR_DIARY_ELITE_COMPLETE)
        {
            area = "Falador";
        }
        else if (varbitId >= VarbitID.WILDERNESS_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.WILDERNESS_DIARY_ELITE_COMPLETE)
        {
            area = "Wilderness";
        }
        else if (varbitId >= VarbitID.WESTERN_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.WESTERN_DIARY_ELITE_COMPLETE)
        {
            area = "Western Provinces";
        }
        else if (varbitId >= VarbitID.KANDARIN_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.KANDARIN_DIARY_ELITE_COMPLETE)
        {
            area = "Kandarin";
        }
        else if (varbitId >= VarbitID.VARROCK_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.VARROCK_DIARY_ELITE_COMPLETE)
        {
            area = "Varrock";
        }
        else if (varbitId >= VarbitID.DESERT_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.DESERT_DIARY_ELITE_COMPLETE)
        {
            area = "Desert";
        }
        else if (varbitId >= VarbitID.MORYTANIA_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.MORYTANIA_DIARY_ELITE_COMPLETE)
        {
            area = "Morytania";
        }
        else if (varbitId >= VarbitID.FREMENNIK_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE)
        {
            area = "Fremennik Province";
        }
        else if (varbitId >= VarbitID.LUMBRIDGE_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.LUMBRIDGE_DIARY_ELITE_COMPLETE)
        {
            area = "Lumbridge & Draynor";
        }
        else if (varbitId >= VarbitID.KOUREND_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.KOUREND_DIARY_ELITE_COMPLETE)
        {
            area = "Kourend & Kebos";
        }
        else
        {
            return null;
        }

        // ----- TIER -----
        tier = getDiaryTier(varbitId);

        return new DiaryInfo(area, tier);
    }
}


package com.oneshot.modules;

import com.oneshot.OneShotConfig;
import com.oneshot.utils.Constants;
import com.oneshot.utils.Icons;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.Skill;
import net.runelite.api.annotations.Component;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.http.api.item.ItemPrice;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.concurrent.CompletableFuture;

import okhttp3.*;

import java.util.Base64;

@Singleton
public class DiscordClient {

    private static final Logger log = LoggerFactory.getLogger(DiscordClient.class);

    private final String partypete = "PARTYPETE";
    private final String towncrier = "TOWNCRIER";
    private final String death = "DEATHS";
    private final String appreciator = "APPRECIATOR";

    private DrawManager drawManager;
    private ClientThread clientThread;
    private OneShotConfig config;
    private Client client;
    private ChatIconManager chatIconManager;
    private SkillIconManager skillIconManager;

    private CompletableFuture<Image> pendingScreenshot;
    private Constants.chatPrivacy pendingChatPrivacy = Constants.chatPrivacy.ALL;
    private Integer previousPrivateChatMode = null;
    private boolean chatHiddenForScreenshot;
    private boolean hideSplitChatForScreenshot;
    private int screenshotDelayTicks;

    // Variables related to menu actions for setting private chat to all, friends only and off
    // Necessary to hide private chat when screenshotting (if chat privacy configs are set to ChatPrivacy.PRIVATE
    // If configs are set to ChatPrivacy.ALL, it hides the whole chatbox and does nothing if set to ChatPrivacy.NONE
    private static final int PRIVATE_CHAT_P0 = -1;
    private static final int PRIVATE_CHAT_P1 = 10616847;
    private static final int PRIVATE_CHAT_ITEM_ID = -1;
    private static final int PRIVATE_CHAT_ID_SHOW_NONE = 5;
    private static final int PRIVATE_CHAT_ID_SHOW_FRIENDS = 4;
    private static final int PRIVATE_CHAT_ID_SHOW_ALL  = 3;
    private static final String PRIVATE_CHAT_OPT_SHOW_NONE = "<col=ffff00>Private:</col> Show none";
    private static final String PRIVATE_CHAT_OPT_SHOW_FRIENDS  = "<col=ffff00>Private:</col> Show friends";
    private static final String PRIVATE_CHAT_OPT_SHOW_ALL  = "<col=ffff00>Private:</col> Show all";
    private static final String PRIVATE_CHAT_TARGET = "";

    private static final MediaType JSON_MEDIA = MediaType.get("application/json; charset=utf-8");
    private static final String WORKER_URL = Constants.WORKER_URL;

    @Inject
    private OkHttpClient httpClient;


    @Inject
    private ItemManager itemManager;

    @Inject
    private ItemSearcher itemSearcher;

    @Inject
    public DiscordClient(
            OneShotConfig config,
            Client client,
            DrawManager drawManager,
            ClientThread clientThread,
            ChatIconManager chatIconManager,
            SkillIconManager skillIconManager
    ) {
        this.config = config;
        this.client = client;
        this.drawManager = drawManager;
        this.clientThread = clientThread;
        this.chatIconManager = chatIconManager;
        this.skillIconManager = skillIconManager;
    }

    public void sendLevelUp(Skill skill, int level) throws IOException {
        log.debug("Leveled up {}:{}", skill.getName(), level);
        if (level != 99) return;
        notifyDiscordAnnouncement("Leveled up " + skill.getName() + ": 99");

        // ---- Level values ------------------------------------------------------
        String description = "";
        String title = String.format("Achieved %s Level %d", skill.getName(), level);

        // ---- Static values -----------------------------------------------------
        String playerName = client.getLocalPlayer().getName();

        List<DiscordField> fields = List.of();

        BufferedImage skillIcon = skillIconManager.getSkillImage(skill);
        byte[] thumbnail = bufferedImageToBytes(skillIcon);

        byte[] rankIcon = getRankIcon(playerName);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.announceLevelScreenshot()
                ? getScreenshot(config.announceLevelChatPrivacy())
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        partypete,
                        title,
                        Constants.DISCORD_LEVELS_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        thumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendLevelMaxed(int level) throws IOException {
        // ---- Static values -----------------------------------------------------
        notifyDiscordAnnouncement("Max Total Level " + level);
        String description = "";
        String title = String.format("Achieved Max Total Level %d", level);
        String playerName = client.getLocalPlayer().getName();
        List<DiscordField> fields = List.of();

        // ---- Thumbnail -----------------------------------------------------
        byte[] levelThumbnail = scaleWithPadding(
                Icons.LEVEL_IMAGE,
                Constants.DISCORD_THUMBNAIL_SIZE,
                1
        );

        byte[] rankIcon = getRankIcon(playerName);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.announceMaxedScreenshot()
                ? getScreenshot(config.announceMaxedChatPrivacy())
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        partypete,
                        title,
                        Constants.DISCORD_LEVELS_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        levelThumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendXP200(Skill skill) throws IOException {
        String description = "";
        String title = String.format("Achieved 200M XP in %s", skill.getName());
        notifyDiscordAnnouncement(title);

        // ---- Static values -----------------------------------------------------
        String playerName = client.getLocalPlayer().getName();

        List<DiscordField> fields = List.of();

        BufferedImage skillIcon = skillIconManager.getSkillImage(skill);
        byte[] thumbnail = bufferedImageToBytes(skillIcon);


        byte[] rankIcon = getRankIcon(playerName);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.announce200MScreenshot()
                ? getScreenshot(config.announce200MChatPrivacy())
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        partypete,
                        title,
                        Constants.DISCORD_LEVELS_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        thumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendQuest(String questText) throws IOException {
        // ---- Quest values ------------------------------------------------------
        int completedQuests = client.getVarbitValue(VarbitID.QUESTS_COMPLETED_COUNT);
        int totalQuests = client.getVarbitValue(VarbitID.QUESTS_TOTAL_COUNT);
        boolean validQuests = completedQuests > 0 && totalQuests > 0;

        int questPoints = client.getVarpValue(VarPlayerID.QP);
        int totalQuestPoints = client.getVarbitValue(VarbitID.QP_MAX);
        boolean validPoints = questPoints > 0 && totalQuestPoints > 0;

        if (!validPoints && !validQuests) { return; }

        String questName = QuestUtils.parseQuestWidget(questText);
        log.debug("Completed quest: {}", questText);
        if (questName == null || !Constants.GM_QUESTS.contains(questName))
            return;
        notifyDiscordAnnouncement("Quest completed: " + questName);

        // ---- Static values -----------------------------------------------------
        String url = getWikiUrl(questName);
        String playerName = client.getLocalPlayer().getName();
        String description = String.format("[%s](%s)",questName,url);
        String title = "Quest completed";
        List<DiscordField> fields = new ArrayList<>();

        if (config.announceQuestsStats())
        {
            fields.add(new DiscordField(
                    "Quests completed",
                    String.format("%d/%d",completedQuests, totalQuests),
                    true
            ));
            fields.add(new DiscordField(
                    "Quest points",
                    String.format("%d/%d",questPoints, totalQuestPoints),
                    true
            ));
        }

        byte[] questThumbnail = scaleWithPadding(
                Icons.QUEST_IMAGE,
                Constants.DISCORD_THUMBNAIL_SIZE,
                1
        );

        byte[] rankIcon = getRankIcon(playerName);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.announceQuestsScreenshot()
                ? getScreenshot(config.announceQuestsChatPrivacy())
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        towncrier,
                        title,
                        Constants.DISCORD_QUESTS_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        questThumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendAchievementDiary(String areaStr, String tierStr) throws IOException {
        if (!Objects.equals(tierStr, "Elite")) return;
        notifyDiscordAnnouncement("Elite " + areaStr + " Diaries Completed");
        // Capture client-thread-safe data first
        String playerName = client.getLocalPlayer().getName();

        String title = String.format("%s %s diaries completed", areaStr, tierStr);
        String descriptionText = String.format("%s %s Diaries", areaStr, tierStr);
        String itemWikiUrl = getWikiUrl(String.format("%s Diary#%s", areaStr, tierStr));
        String description = String.format("[%s](%s)", descriptionText, itemWikiUrl);

        // ---- Rank icon -----------------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        byte[] taskThumbnail = scaleWithPadding(
                Icons.TASKS_IMAGE,
                Constants.DISCORD_THUMBNAIL_SIZE,
                1
        );

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.announceDiariesScreenshot()
                ? getScreenshot(config.announceDiariesChatPrivacy())
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        towncrier,
                        title,
                        Constants.DISCORD_DIARIES_COLOR,
                        playerName,
                        description,
                        null,
                        screenshot,
                        rankIcon,
                        taskThumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });
    }

    public void sendCombatAchievement(String combatTier) throws IOException {
        List<String> allowedTiers = List.of("Elite","Master","Grandmaster");
        log.debug("Combat Achievement: {}", allowedTiers);
        if (!allowedTiers.contains(combatTier)) return;

        String playerName = client.getLocalPlayer().getName();

        // ---- Text ----------------------------------------------------------
        String title = combatTier + " Tier Rewards unlocked";
        String itemWikiUrl = Constants.WIKI_COMBAT_ACHIEVEMENTS_REWARDS;
        String description = String.format("[%s](%s)","Combat Achievement Rewards",itemWikiUrl);
        notifyDiscordAnnouncement(title);

        // ---- Rank icon -----------------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        String itemImageUrl = Constants.COMBAT_ACHIEVEMENT_REWARDS_IMAGE_URL.get(combatTier);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.announceCombatAchievementsScreenshot()
                ? getScreenshot(config.announceCombatAchievementsChatPrivacy())
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        towncrier,
                        title,
                        Constants.DISCORD_COMBAT_ACHIEVEMENTS_COLOR,
                        playerName,
                        description,
                        null,
                        screenshot,
                        rankIcon,
                        itemImageUrl
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendPet(String itemName) throws IOException {
        String playerName = client.getLocalPlayer().getName();
        notifyDiscordAnnouncement("New pet: " + itemName);

        // ---- Text ----------------------------------------------------------
        String title = "New pet";
        String itemWikiUrl = getWikiUrl(itemName);
        String description = String.format("[%s](%s)",itemName,itemWikiUrl);

        // ---- Rank icon -----------------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        int itemID = getItemID(itemName);
        String itemImageUrl;
        if (itemID >= 0){
            itemImageUrl = itemImageUrl(itemID);
        } else {
            itemImageUrl = null;
        }

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.announcePetsScreenshot()
                ? getScreenshot(4, config.announcePetsChatPrivacy())
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        appreciator,
                        title,
                        Constants.DISCORD_PETS_COLOR,
                        playerName,
                        description,
                        null,
                        screenshot,
                        rankIcon,
                        itemImageUrl
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendLootDrop(String itemName) throws IOException {
        String playerName = client.getLocalPlayer().getName();
        boolean isAllowed = Constants.ITEMS_WHITELIST.contains(itemName);
        log.debug("new collection log: {} - {}", itemName, isAllowed ? "Allowed" : "Not allowed");
        if (!isAllowed) return;
        notifyDiscordAnnouncement("New collection log: " + itemName);

        // ---- Text ----------------------------------------------------------
        String title = "New collection log";
        String itemWikiUrl = getWikiUrl(itemName);
        int itemHAPrice = getHAPrice(itemName);
        int itemPrice = getWikiPrice(itemName);
        String description = String.format("[%s](%s)",itemName,itemWikiUrl);

        //if (itemPrice < 5e6) return;

        List<DiscordField> fields;

        fields = new ArrayList<>();
        if (itemPrice > 0) {
            fields.add(new DiscordField(
                    "GE price",
                    String.format("%s", QuantityFormatter.formatNumber(itemPrice)),
                    true
            ));
        }
        if (itemHAPrice > 0) {
            fields.add(new DiscordField(
                    "HA price",
                    String.format("%s", QuantityFormatter.formatNumber(itemHAPrice)),
                    true
            ));
        }
        clientThread.invokeLater(() -> {
            int totalCollectionLogs = client.getVarpValue(VarPlayerID.COLLECTION_COUNT_MAX);
            int collectedLogs = client.getVarpValue(VarPlayerID.COLLECTION_COUNT);

            fields.add(new DiscordField(
                    "Collections logged",
                    String.format("%d/%d", collectedLogs, totalCollectionLogs),
                    true
            ));
        });

        // ---- Rank icon -----------------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        int itemID = getItemID(itemName);
        String itemImageUrl;
        if (itemID >= 0){
            itemImageUrl = itemImageUrl(itemID);
        } else {
            itemImageUrl = null;
        }

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.announceCollectionLogsScreenshot()
                ? getScreenshot(4, config.announceCollectionLogsChatPrivacy())
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        appreciator,
                        title,
                        Constants.DISCORD_LOOT_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        itemImageUrl
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendDeath(String actorInteraction, CompletableFuture<Image> screenshotFuture) throws IOException {
        String playerName = client.getLocalPlayer().getName();

        // ---- Text ----------------------------------------------------------
        String title = Objects.equals(actorInteraction, "") ?  playerName + " has died!" : playerName + " has died to " + actorInteraction + "!";
        String description = "";

        // ---- Fields --------------------------------------------------------
        List<DiscordField> fields;
        if (config.announceDeathsStats()) {
            fields = new ArrayList<>();
            fields.add(new DiscordField("Total Level", String.valueOf(client.getTotalLevel()), true));
            fields.add(new DiscordField(
                    "Combat Level",
                    String.valueOf(client.getLocalPlayer().getCombatLevel()),
                    true
            ));
        } else {
            fields = null;
        }

        // ---- Rank icon + field ---------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        byte[] deathThumbnail = scaleWithPadding(
                Icons.DEATH_IMAGE,
                Constants.DISCORD_THUMBNAIL_SIZE,
                1
        );

        // ---- Screenshot handling -------------------------------------------
        if (config.announceDeathsScreenshot())
        {
            screenshotFuture.thenAcceptAsync(img -> {
                try {
                    byte[] screenshot = bufferedImageToBytes((BufferedImage) img);

                    sendDiscordEmbed(
                            death,
                            title,
                            Constants.DISCORD_DEATHS_COLOR,
                            playerName,
                            description,
                            fields,
                            screenshot,
                            rankIcon,
                            deathThumbnail
                    );
                } catch (Exception e) {
                    log.error("Failed to send death embed", e);
                }
            });
        }
        else
        {
            sendDiscordEmbed(
                    death,
                    title,
                    Constants.DISCORD_DEATHS_COLOR,
                    playerName,
                    description,
                    fields,
                    null,
                    rankIcon,
                    deathThumbnail
            );
        }
    }

    private String getWikiUrl(String wikiName) {
        String encoded = wikiName.replace(" ", "_");
        return Constants.WIKI_SEARCH + encoded;
    }

    private static String itemImageUrl(int itemId) {
        return "https://static.runelite.net/cache/item/icon/" + itemId + ".png";
    }

    @Nullable
    private Integer getItemID(String itemName)
    {
        return itemSearcher.findItemId(itemName);
    }

    private int getHAPrice(String itemName) {
        ItemPrice item = findItem(itemName);
        if (item == null) return -1;

        return client.getItemDefinition(item.getId()).getHaPrice();
    }

    private int getWikiPrice(String itemName) {
        ItemPrice item = findItem(itemName);
        if (item == null) return -1;

        return itemManager.getWikiPrice(item);
    }

    private ItemPrice findItem(String itemName) {
        return itemManager.search(itemName).stream()
                .filter(it -> it.getName().equalsIgnoreCase(itemName))
                .findFirst()
                .orElse(null);
    }

    private byte[] getRankIcon(String playerName) throws IOException {
        ClanSettings clan = client.getClanSettings();
        if (clan == null)
            return null;

        ClanRank rank = clan.findMember(playerName).getRank();
        ClanTitle title = clan.titleForRank(rank);

        BufferedImage icon = chatIconManager.getRankImage(title);
        return scaleWithPadding(icon,
                Constants.DISCORD_AUTHOR_ICON_SIZE,
                Constants.DISCORD_AUTHOR_ICON_SCALE);
    }

    public byte[] scaleWithPadding(BufferedImage original, int iconSize, double scaleFactor) {
        int visibleSize = (int) (iconSize * scaleFactor);

        // Create 20×20 transparent canvas
        BufferedImage padded = new BufferedImage(iconSize, iconSize, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = padded.createGraphics();

        // Enable high-quality scaling
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Scale original image to visibleSize
        Image scaled = original.getScaledInstance(visibleSize, visibleSize, Image.SCALE_SMOOTH);

        // Center inside the transparent 20×20 canvas
        int x = (iconSize - visibleSize) / 2;
        int y = (iconSize - visibleSize) / 2;

        g.drawImage(scaled, x, y, null);
        g.dispose();

        return bufferedImageToBytes(padded);
    }

    private byte[] bufferedImageToBytes(BufferedImage img) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            ImageIO.write(img, "png", baos);
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void onGameTick() {
        if (pendingScreenshot == null)
        {
            return;
        }

        if (screenshotDelayTicks > 0)
        {
            screenshotDelayTicks--;
            return;
        }



        // STEP 1 — run on client thread
        clientThread.invoke(() ->
        {
            final Constants.chatPrivacy privacy = pendingChatPrivacy;
            applyPrivateChatPrivacy(privacy);

            chatHiddenForScreenshot = hideWidget(
                    shouldHidePublicChat(privacy),
                    client,
                    InterfaceID.Chatbox.CHATAREA
            );

            hideSplitChatForScreenshot = hideWidget(
                    shouldHidePrivateChat(privacy),
                    client,
                    InterfaceID.PmChat.CONTAINER
            );

            // STEP 2 — request render AFTER widgets are hidden
            drawManager.requestNextFrameListener(image ->
            {
                pendingScreenshot.complete(image);

                // STEP 3 — restore UI AFTER screenshot is taken
                clientThread.invoke(() ->
                {
                    unhideWidget(
                            chatHiddenForScreenshot,
                            client,
                            clientThread,
                            InterfaceID.Chatbox.CHATAREA
                    );
                    unhideWidget(
                            hideSplitChatForScreenshot,
                            client,
                            clientThread,
                            InterfaceID.PmChat.CONTAINER
                    );

                    restorePrivateChatPrivacy();
                    pendingScreenshot = null;
                });
            });
        });
    }

    public CompletableFuture<Image> getScreenshot(Constants.chatPrivacy chatPrivacy) {
        return getScreenshot(1, chatPrivacy);
    }

    public CompletableFuture<Image> getScreenshot(int delayTicks, Constants.chatPrivacy chatPrivacy) {
        CompletableFuture<Image> future = new CompletableFuture<>();

        pendingScreenshot = future;
        pendingChatPrivacy = (chatPrivacy != null) ? chatPrivacy : Constants.chatPrivacy.NONE;

        if (pendingChatPrivacy == Constants.chatPrivacy.PRIVATE)
        {
            screenshotDelayTicks = Math.max(delayTicks, 2);
        }
        else
        {
            screenshotDelayTicks = delayTicks;
        }

        return future;
    }

    public static boolean hideWidget(boolean shouldHide, Client client, @Component int info) {
        if (!shouldHide)
            return false;

        Widget widget = client.getWidget(info);
        if (widget == null || widget.isHidden())
            return false;

        widget.setHidden(true);
        return true;
    }

    public static void unhideWidget(boolean shouldUnhide, Client client, ClientThread clientThread, @Component int info) {
        if (!shouldUnhide)
            return;

        clientThread.invoke(() -> {
            Widget widget = client.getWidget(info);
            if (widget != null)
                widget.setHidden(false);
        });
    }

    private static class DiscordField{

        private final String name;
        private final String value;
        private final boolean inline;

        public DiscordField(String name, String value, boolean inline)
        {
            this.name = name;
            this.value = value;
            this.inline = inline;
        }

        public String getName() { return this.name; }

        public String getValue() { return this.value; }

        public boolean getInline() { return this.inline; }
    }

    private void sendDiscordEmbed(
            String webhookKey,
            String title,
            Color color,
            @Nullable String authorName,
            @Nullable String description,
            @Nullable List<DiscordField> fields,
            @Nullable byte[] screenshot,
            @Nullable byte[] userIcon,
            @Nullable byte[] thumbnailBytes
    ) {
        byte[] footerIcon = bufferedImageToBytes(Icons.RED_HELM_IMAGE);

        DiscordWebhook.EmbedObject embed = new DiscordWebhook.EmbedObject()
                .setTitle(title)
                .setColor(color)
                .setFooter("One Shot Plugin", footerIcon, "footericon.png");

        if (description != null) embed.setDescription(description);
        if (userIcon != null) embed.setAuthor(authorName, userIcon, "usericon.png");
        if (thumbnailBytes != null) embed.setThumbnail(thumbnailBytes, "thumb.png");
        if (screenshot != null) embed.setImage(screenshot, "screenshot.png");

        if (fields != null) {
            for (DiscordField f : fields) {
                embed.addField(f.getName(), f.getValue(), f.getInline());
            }
        }

        sendViaWorker(
                webhookKey,
                embed,
                screenshot,
                userIcon,
                footerIcon,
                thumbnailBytes
        );
    }


    private void sendDiscordEmbed(
            String webhookKey,
            String title,
            Color color,
            @Nullable String authorName,
            @Nullable String description,
            @Nullable List<DiscordField> fields,
            @Nullable byte[] screenshot,
            @Nullable byte[] userIcon,
            @Nullable String thumbnailUrl
    ) {
        byte[] footerIcon = bufferedImageToBytes(Icons.RED_HELM_IMAGE);

        DiscordWebhook.EmbedObject embed = new DiscordWebhook.EmbedObject()
                .setTitle(title)
                .setColor(color)
                .setFooter("One Shot Plugin", footerIcon, "footericon.png");

        if (description != null) embed.setDescription(description);
        if (userIcon != null) embed.setAuthor(authorName, userIcon, "usericon.png");
        if (thumbnailUrl != null) embed.setThumbnail(thumbnailUrl);
        if (screenshot != null) embed.setImage(screenshot, "screenshot.png");

        if (fields != null) {
            for (DiscordField f : fields) {
                embed.addField(f.getName(), f.getValue(), f.getInline());
            }
        }

        sendViaWorker(
                webhookKey,
                embed,
                screenshot,
                userIcon,
                footerIcon,
                null
        );
    }

    private void sendViaWorker(
            String webhookKey,
            DiscordWebhook.EmbedObject embed,
            @Nullable byte[] screenshot,
            @Nullable byte[] userIcon,
            @Nullable byte[] footerIcon,
            @Nullable byte[] thumbnailBytes
    ) {
        try {
            // 1. Build embed JSON (like your toJson() method)
            DiscordWebhook.JSONObject embedJsonObj = embed.toJson(); // you added this earlier
            String embedJson = embedJsonObj.toString();

            String playerName = client.getLocalPlayer().getName();

            StringBuilder attachmentsJson = new StringBuilder();
            attachmentsJson.append("[");

            boolean first = true;

            if (screenshot != null) {
                first = false;
                attachmentsJson.append(buildAttachmentJson("screenshot.png", screenshot));
            }
            if (userIcon != null) {
                if (!first) attachmentsJson.append(",");
                first = false;
                attachmentsJson.append(buildAttachmentJson("usericon.png", userIcon));
            }
            if (footerIcon != null) {
                if (!first) attachmentsJson.append(",");
                first = false;
                attachmentsJson.append(buildAttachmentJson("footericon.png", footerIcon));
            }
            if (thumbnailBytes != null) {
                if (!first) attachmentsJson.append(",");
                attachmentsJson.append(buildAttachmentJson("thumb.png", thumbnailBytes));
            }

            attachmentsJson.append("]");

            String jsonBody =
                    "{"
                            + "\"username\":\"" + escape(playerName) + "\","
                            + "\"clan_name\":\"One Shot\","
                            + "\"webhook\":\"" + escape(webhookKey) + "\","
                            + "\"content\":null,"
                            + "\"embeds\":[" + embedJson + "],"
                            + "\"attachments\":" + attachmentsJson
                            + "}";

            RequestBody body = RequestBody.create(JSON_MEDIA, jsonBody);

            Request request = new Request.Builder()
                    .url(WORKER_URL)
                    .post(body)
                    .build();

            httpClient.newCall(request).enqueue(new Callback() {
                @Override public void onFailure(Call call, IOException e) {
                    log.error("Failed to send to Worker", e);
                }

                @Override public void onResponse(Call call, Response response) {
                    response.close();
                }
            });
        } catch (Exception e) {
            log.error("Error building Worker request", e);
        }
    }

    private String buildAttachmentJson(String filename, byte[] data) {
        String b64 = Base64.getEncoder().encodeToString(data);
        return "{"
                + "\"filename\":\"" + escape(filename) + "\","
                + "\"content_type\":\"image/png\","
                + "\"data\":\"" + b64 + "\""
                + "}";
    }

    private String escape(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\").replace("\"", "\\\"");
    }

    private void notifyDiscordAnnouncement(String content)
    {
        if (!config.infoMessage()) return;
        clientThread.invoke(() ->
        {
            final String msg = "<col=ff0000>[One Shot]</col> Sent to Discord -> " + content;
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null);
        });
    }

    private boolean shouldHidePublicChat(Constants.chatPrivacy privacy) {
        return privacy == Constants.chatPrivacy.ALL;
    }

    private boolean shouldHidePrivateChat(Constants.chatPrivacy privacy) {
        return privacy == Constants.chatPrivacy.ALL
            || privacy == Constants.chatPrivacy.PRIVATE;
    }

    // gave up on trying to set VarbitID.CHAT_FILTER_PRIVATE to 0,1,2
    // instead, I'm replicating the menu clicks done by the user
    // it's ugly, but it works
    //
    // when the config is enabled, the chat will be set to private off
    // to hide private chats before screenshotting, and then restoring the previous state
    private void applyPrivateChatPrivacy(Constants.chatPrivacy privacy)
    {
        if (privacy != Constants.chatPrivacy.PRIVATE)
            return;

        int current = client.getVarbitValue(VarbitID.CHAT_FILTER_PRIVATE);
        if (current != 2)
        {
            previousPrivateChatMode = current;
            setPrivateChatNone();
        }
    }

    private void restorePrivateChatPrivacy()
    {
        if (previousPrivateChatMode == null)
            return;

        if (previousPrivateChatMode == 0)
        {
            setPrivateChatAll();
        }
        else if (previousPrivateChatMode == 1)
        {
            setPrivateChatFriends();
        }

        previousPrivateChatMode = null;
    }

    private void setPrivateChatNone()
    {
        client.menuAction(
                PRIVATE_CHAT_P0,
                PRIVATE_CHAT_P1,
                MenuAction.CC_OP,
                PRIVATE_CHAT_ID_SHOW_NONE,
                PRIVATE_CHAT_ITEM_ID,
                PRIVATE_CHAT_OPT_SHOW_NONE,
                PRIVATE_CHAT_TARGET
        );
    }

    private void setPrivateChatFriends()
    {
        client.menuAction(
                PRIVATE_CHAT_P0,
                PRIVATE_CHAT_P1,
                MenuAction.CC_OP,
                PRIVATE_CHAT_ID_SHOW_FRIENDS,
                PRIVATE_CHAT_ITEM_ID,
                PRIVATE_CHAT_OPT_SHOW_FRIENDS,
                PRIVATE_CHAT_TARGET
        );
    }

    private void setPrivateChatAll()
    {
        client.menuAction(
                PRIVATE_CHAT_P0,
                PRIVATE_CHAT_P1,
                MenuAction.CC_OP,
                PRIVATE_CHAT_ID_SHOW_ALL,
                PRIVATE_CHAT_ITEM_ID,
                PRIVATE_CHAT_OPT_SHOW_ALL,
                PRIVATE_CHAT_TARGET
        );
    }


}

package com.oneshot.modules;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.Color;
import java.util.*;

/**
 * Class used to execute Discord Webhooks with low effort
 * Come from: https://gist.github.com/k3kdude/fba6f6b37594eae3d6f9475330733bdb
 */
public class DiscordWebhook {
    private static final Logger log = LoggerFactory.getLogger(DiscordWebhook.class);

    public static class EmbedObject {

        private String title;
        private String description;
        private Color color;

        private Footer footer;
        private Thumbnail thumbnail;
        private Image image;
        private Author author;
        private List<Field> fields = new ArrayList<>();

        public byte[] imageBytes;
        public String imageFileName;

        public byte[] authorImageBytes;
        public String authorImageFileName;

        public byte[] footerImageBytes;
        public String footerImageFileName;

        public byte[] thumbnailImageBytes;
        public String thumbnailImageFileName;


        // ----- Builder methods -----
        public EmbedObject setTitle(String t) { this.title = t; return this; }
        public EmbedObject setDescription(String d) { this.description = d; return this; }
        public EmbedObject setColor(Color c) { this.color = c; return this; }

        public EmbedObject setFooter(String text, byte[] img, String fileName) {
            this.footer = new Footer(text, null);
            this.footerImageBytes = img;
            this.footerImageFileName = fileName;
            return this;
        }

        public EmbedObject setThumbnail(byte[] img, String fileName) {
            this.thumbnailImageBytes = img;
            this.thumbnailImageFileName = fileName;
            this.thumbnail = new Thumbnail(null);
            return this;
        }

        public EmbedObject setThumbnail(String url) {
            this.thumbnail = new Thumbnail(url);
            return this;
        }

        public EmbedObject setImage(byte[] img, String fileName) {
            this.imageBytes = img;
            this.imageFileName = fileName;
            this.image = new Image(null);
            return this;
        }

        public EmbedObject setAuthor(String name, byte[] img, String fileName) {
            this.author = new Author(name, null, null);
            this.authorImageBytes = img;
            this.authorImageFileName = fileName;
            return this;
        }

        public EmbedObject addField(String name, String value, boolean inline) {
            fields.add(new Field(name, value, inline));
            return this;
        }

        // ----- JSON Builder -----
        public JSONObject toJson() {
            JSONObject json = new JSONObject();

            json.put("title", title);
            json.put("description", description);

            if (color != null) {
                int rgb = (color.getRed() << 16) | (color.getGreen() << 8) | color.getBlue();
                json.put("color", rgb);
            }

            // Footer
            if (footer != null) {
                JSONObject f = new JSONObject();
                f.put("text", footer.text);

                f.put("icon_url",
                        footerImageBytes != null
                                ? "attachment://" + footerImageFileName
                                : footer.iconUrl
                );

                json.put("footer", f);
            }

            // Image
            if (imageBytes != null) {
                JSONObject i = new JSONObject();
                i.put("url", "attachment://" + imageFileName);
                json.put("image", i);
            } else if (image != null && image.url != null) {
                JSONObject i = new JSONObject();
                i.put("url", image.url);
                json.put("image", i);
            }

            // Thumbnail
            if (thumbnailImageBytes != null) {
                JSONObject t = new JSONObject();
                t.put("url", "attachment://" + thumbnailImageFileName);
                json.put("thumbnail", t);
            } else if (thumbnail != null && thumbnail.url != null) {
                JSONObject t = new JSONObject();
                t.put("url", thumbnail.url);
                json.put("thumbnail", t);
            }

            // Author
            if (author != null) {
                JSONObject a = new JSONObject();
                a.put("name", author.name);
                a.put("url", author.url);
                a.put("icon_url",
                        authorImageBytes != null
                                ? "attachment://" + authorImageFileName
                                : author.iconUrl
                );
                json.put("author", a);
            }

            // Fields
            if (!fields.isEmpty()) {
                List<JSONObject> arr = new ArrayList<>();
                for (Field f : fields) {
                    JSONObject jf = new JSONObject();
                    jf.put("name", f.name);
                    jf.put("value", f.value);
                    jf.put("inline", f.inline);
                    arr.add(jf);
                }
                json.put("fields", arr.toArray());
            }

            return json;
        }

        // ----- Inner classes -----

        private static class Footer {
            String text, iconUrl;
            Footer(String t, String u) { text = t; iconUrl = u; }
        }

        private static class Thumbnail {
            String url;
            Thumbnail(String u) { url = u; }
        }

        private static class Image {
            String url;

            Image(String u) { this.url = u; }

        }

        private static class Author {
            String name, url, iconUrl;
            Author(String n, String u, String i) { name = n; url = u; iconUrl = i; }
        }

        private static class Field {
            String name, value;
            boolean inline;

            Field(String n, String v, boolean i) {
                name = n;
                value = v;
                inline = i;
            }
        }
    }


    static class JSONObject {

        private final HashMap<String, Object> map = new HashMap<>();

        void put(String key, Object value) {
            if (value != null) {
                map.put(key, value);
            }
        }

        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            Set<Map.Entry<String, Object>> entrySet = map.entrySet();
            builder.append("{");

            int i = 0;
            for (Map.Entry<String, Object> entry : entrySet) {
                Object val = entry.getValue();
                builder.append(quote(entry.getKey())).append(":");

                if (val instanceof String) {
                    builder.append(quote(String.valueOf(val)));
                } else if (val instanceof Integer) {
                    builder.append(Integer.valueOf(String.valueOf(val)));
                } else if (val instanceof Boolean) {
                    builder.append(val);
                } else if (val instanceof JSONObject) {
                    builder.append(val.toString());
                } else if (val instanceof Object[]) {
                    Object[] arr = (Object[]) val;
                    builder.append("[");
                    for (int j = 0; j < arr.length; j++) {
                        builder.append(arr[j].toString());
                        if (j != arr.length - 1) {
                            builder.append(",");
                        }
                    }
                    builder.append("]");
                }


                builder.append(++i == entrySet.size() ? "}" : ",");
            }

            return builder.toString();
        }

        private String quote(String string) {
            return "\"" + string
                    .replace("\\", "\\\\")
                    .replace("\"", "\\\"")
                    .replace("\n", "\\n")
                    .replace("\r", "\\r")
                    .replace("\t", "\\t")
                    + "\"";
        }
    }
}

package com.oneshot.modules;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import okhttp3.*;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.Reader;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

/**
 * This thread-safe singleton holds a mapping of item names to their item id, using the RuneLite API.
 * <p>
 * Unlike {@link net.runelite.client.game.ItemManager#search(String)}, this mapping supports untradable items.
 */
@Singleton
public class ItemSearcher {
    private static final Logger log = LoggerFactory.getLogger(ItemSearcher.class);

    private final Map<String, Integer> itemIdByName = Collections.synchronizedMap(new HashMap<>(16384));
    private @Inject OkHttpClient httpClient;
    private @Inject Gson gson;

    /**
     * @param name the exact in-game name of an item
     * @return the id associated with the item name, or null if not found
     */
    @Nullable
    public Integer findItemId(String name) {
        return itemIdByName.get(name);
    }

    /**
     * Begins the initialization process for {@link #itemIdByName}
     * by querying item names and noted item ids from the RuneLite API,
     * before passing them to {@link #populate(Map, Set)}
     *
     * @implNote This operation does not block the current thread,
     * by utilizing OkHttp's thread pool and Java's Fork-Join common pool.
     */
    @Inject
    void init() {
        queryNamesById()
                .thenAcceptBothAsync(
                        queryNotedItemIds().exceptionally(e -> {
                            log.error("Failed to read noted items", e);
                            return Collections.emptySet();
                        }),
                        this::populate
                )
                .exceptionally(e -> {
                    log.error("Failed to read item names", e);
                    return null;
                });
    }

    /**
     * Populates {@link #itemIdByName} with the inverted mappings of {@code namesById},
     * while skipping noted items specified in {@code notedIds}.
     *
     * @param namesById a mapping of item id's to the corresponding in-game name
     * @param notedIds  the id's of noted items
     * @implNote When multiple non-noted item id's have the same in-game name, only the earliest id is saved
     */

    void populate(Map<Integer, String> namesById, Set<Integer> notedIds) {
        namesById.forEach((id, name) -> {
            if (!notedIds.contains(id))
                itemIdByName.putIfAbsent(name, id);
        });

        log.debug("Completed initialization of item cache with {} entries", itemIdByName.size());
    }

    /**
     * @return a mapping of item ids to their in-game names, provided by the RuneLite API
     */
    private CompletableFuture<Map<Integer, String>> queryNamesById() {
        return queryCache("names.json", new TypeToken<Map<Integer, String>>() {});
    }

    /**
     * @return a set of id's of noted items, provided by the RuneLite API
     */
    private CompletableFuture<Set<Integer>> queryNotedItemIds() {
        return queryCache("notes.json", new TypeToken<Map<Integer, Integer>>() {})
                .thenApply(Map::keySet);
    }

    /**
     * @param fileName the name of the file to query from RuneLite's cache
     * @param type     a type token that indicates how the json response should be parsed
     * @return the transformed cache response, wrapped in a future
     */
    private <T> CompletableFuture<T> queryCache(String fileName, TypeToken<T> type) {
        return readJson(httpClient, gson, "https://static.runelite.net/cache/item/" + fileName, type);
    }

    public <T> CompletableFuture<T> readJson(OkHttpClient httpClient, Gson gson, String url, TypeToken<T> type) {
        return readUrl(httpClient, url, reader -> gson.fromJson(reader, type.getType()));
    }

    public <T> CompletableFuture<T> readUrl( OkHttpClient httpClient, String url, Function<Reader, T> transformer) {
        CompletableFuture<T> future = new CompletableFuture<>();
        Request request = new Request.Builder().url(url).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                assert response.body() != null;
                try (response; Reader reader = response.body().charStream()) {
                    future.complete(transformer.apply(reader));
                } catch (Exception e) {
                    future.completeExceptionally(e);
                }
            }
        });
        return future;
    }
}

package com.oneshot.modules;
import net.runelite.client.plugins.Plugin;
import javax.inject.Singleton;

@Singleton
public class ModTools extends Plugin {

    private ModToolsPanel modToolsPanel;

    public void init(ModToolsPanel modToolsPanel)
    {
        this.modToolsPanel = modToolsPanel;
    }
}

package com.oneshot.modules;

import com.google.gson.*;

import com.oneshot.OneShotConfig;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableRowSorter;

import net.runelite.client.config.*;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import okhttp3.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

//@Singleton
public class ModToolsPanel extends PluginPanel
{
    @Inject
    private OkHttpClient httpClient;

    @Inject
    private Gson gson;

    private static final Logger log = LoggerFactory.getLogger(ModToolsPanel.class);
    private final ConfigManager configManager;
    private final OneShotConfig config;

    private Map<String, String> womPlayers = new HashMap<>();
    private JTable womTable;
    private String womFilter = "All";


    private JLabel queuedLabel;
    private JLabel checkedLabel;
    private JLabel hcimLabel;

    private JPanel titlePanel = new JPanel();
    private JPanel checkPanel = new JPanel();

    {
        titlePanel.setLayout(new BoxLayout(titlePanel, BoxLayout.Y_AXIS));
        checkPanel.setLayout(new BoxLayout(checkPanel, BoxLayout.Y_AXIS));
    }

    private boolean statsChildHidden = true;


    @Inject
    public ModToolsPanel(ConfigManager configManager, OneShotConfig config, ModTools modTools)
    {
//        log.debug("ModToolsPanel constructed, instance: {}", System.identityHashCode(this));

        this.configManager = configManager;
        this.config = config;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        init();

        add(titlePanel);
        add(checkPanel);

        createTitlePanel();
        createIronmanCheckSection();

    }

    public void init()
    {
        queuedLabel = new JLabel();
        checkedLabel = new JLabel();
        hcimLabel = new JLabel();
        queuedLabel.setText("In Queue: 0");
        checkedLabel.setText("Total Checked: 0");
        hcimLabel.setText("Total HCIM: 0");
    }

    private void createTitlePanel()
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                BorderFactory.createEmptyBorder(4, 6, 4, 6) // Padding sized to text height
        ));
        JLabel titleText = new JLabel("Mod Tools", SwingConstants.CENTER);
        container.add(titleText);
        titlePanel.add(container);
    }

    private void createIronmanCheckSection()
    {
        JPanel childPanel = createIronmanCheckContentPanel();

        checkPanel.add(createCollapsibleHeader("WOM Non-Hardcore Status", childPanel));
        checkPanel.add(childPanel);
        childPanel.setVisible(!statsChildHidden);
    }

    private JPanel createIronmanCheckContentPanel()
    {
        JPanel container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setBorder(BorderFactory.createEmptyBorder(4, 6, 4, 6));

        JButton btn = new JButton("Fetch from WOM");
        btn.setForeground(ColorScheme.TEXT_COLOR);
        btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        btn.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR));
        btn.setFocusPainted(false);
        btn.setOpaque(true);

        btn.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Hover effect
        btn.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                btn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }

            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                fetchWiseOldManGroup(ModToolsPanel.this::refreshWomTable);
            }
        });

        container.add(btn);
        container.add(createWomFilter());
        container.add(createWomList());

        return container;
    }

    private JPanel createWomFilter() {
        JPanel container = new JPanel(new BorderLayout());

        // ---------- FILTER DROPDOWN ----------
        String[] filterOptions = {"All", "Regular", "Ironman"};
        JComboBox<String> filterBox = new JComboBox<>(filterOptions);
        filterBox.setSelectedItem("All");
        filterBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        filterBox.addActionListener(e -> {
            womFilter = (String) filterBox.getSelectedItem();
            refreshWomTable();
        });

        JPanel filterPanel = new JPanel(new BorderLayout());
        filterPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        filterPanel.add(new JLabel("Type: "), BorderLayout.WEST);
        filterPanel.add(filterBox, BorderLayout.CENTER);

        container.add(filterPanel, BorderLayout.NORTH);

        return container;
    }

    private JPanel createWomList()
    {
        JPanel container = new JPanel(new BorderLayout());

        // --- TABLE ---
        womTable = new JTable(womTableModel);
        TableRowSorter<DefaultTableModel> sorter =
                new TableRowSorter<>(womTableModel);
        womTable.setRowSorter(sorter);
        womTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        womTable.setForeground(ColorScheme.TEXT_COLOR);
        womTable.setFillsViewportHeight(true);
        womTable.setShowGrid(false);

        // Fill with current data
        refreshWomTable();

        // --- CENTER ALIGN COLUMNS ---
        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(SwingConstants.CENTER);
        womTable.getColumnModel().getColumn(0).setCellRenderer(centerRenderer);
        womTable.getColumnModel().getColumn(1).setCellRenderer(centerRenderer);

        // --- COLUMN WIDTHS (70% / 30%) ---
        int totalWidth = PluginPanel.PANEL_WIDTH - 20; // minus scroll padding
        womTable.getColumnModel().getColumn(0).setPreferredWidth((int)(totalWidth * 0.50));
        womTable.getColumnModel().getColumn(1).setPreferredWidth((int)(totalWidth * 0.50));

        // --- SCROLLPANE (scrolls when needed) ---
        JScrollPane scrollPane = new JScrollPane(womTable);
        scrollPane.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR));
        scrollPane.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 12, 160));

        container.add(scrollPane, BorderLayout.CENTER);

        return container;
    }

    private void refreshWomTable()
    {
        womTableModel.setRowCount(0); // clear

        if (womPlayers.isEmpty())
        {
            womTableModel.addRow(new Object[]{"Empty", ""});
        }
        else
        {
            womPlayers.forEach((name, type) -> {
                // FILTER logic:
                if (womFilter.equals("All") || womFilter.toLowerCase().equals(type))
                {
                    womTableModel.addRow(new Object[]{name, type});
                }
            });
        }

        womTable.revalidate();
        womTable.repaint();
    }

    private void fetchWiseOldManGroup(Runnable onFinished)
    {
        // WOM group ID — hardcoded for now
        int groupId = 2647;

        String url = "https://api.wiseoldman.net/v2/groups/" + groupId;

        Request request = new Request.Builder()
                .url(url)
                .build();

        httpClient.newCall(request).enqueue(new okhttp3.Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.error("Failed to fetch WOM group data", e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                if (!response.isSuccessful())
                {
                    log.error("Bad response from WOM: {}", response.code());
                    return;
                }

                String json = response.body().string();
                parseWom(json);

                SwingUtilities.invokeLater(onFinished);
            }
        });
    }

    private void parseWom(String json)
    {
        JsonObject root = gson.fromJson(json, JsonObject.class);
        JsonArray memberships = root.getAsJsonArray("memberships");
        womPlayers.clear();

        for (JsonElement el : memberships)
        {
            JsonObject membership = el.getAsJsonObject();
            JsonObject player = membership.getAsJsonObject("player");

            String name = player.get("displayName").getAsString();
            String type = player.get("type").getAsString();

            if (!type.equals("hardcore"))
            {
                // Add to your UI list:
                SwingUtilities.invokeLater(() ->
                        womPlayers.put(name, type)
                );
            }
        }
    }

    private DefaultTableModel womTableModel = new DefaultTableModel(
            new Object[]{"Player", "Type"}, 0
    ) {
        @Override
        public boolean isCellEditable(int row, int column) {
            return false; // NON-EDITABLE
        }
    };

    private JPanel createCollapsibleHeader(String text, JPanel childPanel)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        container.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                BorderFactory.createEmptyBorder(4, 6, 4, 6) // Padding sized to text height
        ));

        JLabel title = new JLabel(text);
        JButton toggleBtn = createHeaderToggleButton(childPanel);

        container.add(title, BorderLayout.WEST);
        container.add(toggleBtn, BorderLayout.EAST);

        return container;
    }

    private JButton createHeaderToggleButton(JPanel childPanel)
    {
        JButton btn = new JButton("▼");

        btn.setForeground(ColorScheme.TEXT_COLOR);
        btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        btn.setBorder(BorderFactory.createEmptyBorder(2, 6, 2, 6));
        btn.setFocusPainted(false);
        btn.setOpaque(true);

        // Hover effect
        btn.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                btn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }

            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                boolean isVisible = childPanel.isVisible();
                childPanel.setVisible(!isVisible);
                btn.setText(!isVisible ? "▲" : "▼");

                // Force relayout and repaint so the gap collapses
                childPanel.getParent().revalidate();
                childPanel.getParent().repaint();
            }
        });

        return btn;
    }
}
package com.oneshot.modules;

import com.google.common.collect.ImmutableList;
import com.oneshot.OneShotPlugin;
import lombok.experimental.UtilityClass;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.Collection;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@UtilityClass
public class QuestUtils {
    private static final Logger log = LoggerFactory.getLogger(OneShotPlugin.class);

    private static final Pattern QUEST_PATTERN_1 = Pattern.compile(".+?ve\\.*? (?<verb>been|rebuilt|.+?ed)? ?(?:the )?'?(?<quest>.+?)'?(?: [Qq]uest)?[!.]?$");
    private static final Pattern QUEST_PATTERN_2 = Pattern.compile("'?(?<quest>.+?)'?(?: [Qq]uest)? (?<verb>[a-z]\\w+?ed)?(?: f.*?)?[!.]?$");
    private static final Collection<String> RFD_TAGS = ImmutableList.of("Another Cook", "freed", "defeated", "saved");
    private static final Collection<String> WORD_QUEST_IN_NAME_TAGS = ImmutableList.of("Another Cook", "Doric", "Heroes", "Legends", "Observatory", "Olaf", "Waterfall");
    private static final Map<String, String> QUEST_REPLACEMENTS = Map.of(
            "Lumbridge Cook... again", "Another Cook's",
            "Skrach 'Bone Crusher' Uglogwee", "Skrach Uglogwee"
    );

    @Nullable
    public static String parseQuestWidget(final String text) {
        Matcher matcher = getMatcher(text);
        if (matcher == null) {
            log.warn("Unable to match quest: {}", text);
            return null;
        }

        String quest = matcher.group("quest");
        quest = QUEST_REPLACEMENTS.getOrDefault(quest, quest);

        String verb = StringUtils.defaultString(matcher.group("verb"));

        if (verb.contains("kind of")) {
            log.debug("Skipping partial completion of quest: {}", quest);
            return null;
        } else if (verb.contains("completely")) {
            quest += " II";
        }

        if (RFD_TAGS.stream().anyMatch((quest + verb)::contains)) {
            quest = "Recipe for Disaster - " + quest;
        }

        if (WORD_QUEST_IN_NAME_TAGS.stream().anyMatch(quest::contains)) {
            quest += " Quest";
        }

        return quest;
    }

    @Nullable
    private static Matcher getMatcher(String text) {
        if (text == null)
            return null;

        // "You have completed The Corsair Curse!"
        Matcher questMatch1 = QUEST_PATTERN_1.matcher(text);
        if (questMatch1.matches())
            return questMatch1;

        // "'One Small Favour' completed!"
        Matcher questMatch2 = QUEST_PATTERN_2.matcher(text);
        if (questMatch2.matches())
            return questMatch2;

        return null;
    }

}

package com.oneshot;

import com.oneshot.utils.Constants.*;
import net.runelite.client.config.*;


@ConfigGroup(OneShotConfig.GROUP)
public interface OneShotConfig extends Config
{

    String GROUP = "oneshot";

    // --- Version Control ---
    @ConfigItem(
            keyName = "version",
            position = 0,
            name = "version",
            description = "version",
            hidden = true)
    default String version() {return "v1.2.0"; }

    // --- Sections ---
    @ConfigSection(
            name = "Discord Global",
            description = "",
            position = 1,
            closedByDefault = true
    )
    String DISCORD_GLOBAL = "Discord Global";

    @ConfigSection(
            name = "Discord Level 99",
            description = "",
            position = 1,
            closedByDefault = true
    )
    String DISCORD_LEVEL = "Discord Level 99";

    @ConfigSection(
            name = "Discord Maxed Level",
            description = "",
            position = 2,
            closedByDefault = true
    )
    String DISCORD_MAXED = "Discord Maxed Level";

    @ConfigSection(
            name = "Discord 200M Exp",
            description = "",
            position = 3,
            closedByDefault = true
    )
    String DISCORD_200M_XP = "Discord 200M Exp";

    @ConfigSection(
            name = "Discord GM Quests",
            description = "",
            position = 4,
            closedByDefault = true
    )
    String DISCORD_QUESTS = "Discord GM Quests";

    @ConfigSection(
            name = "Discord Elite Diaries",
            description = "",
            position = 5,
            closedByDefault = true
    )
    String DISCORD_DIARIES = "Discord Elite Diaries";

    @ConfigSection(
            name = "Discord Combat Achievements",
            description = "",
            position = 6,
            closedByDefault = true
    )
    String DISCORD_CA = "";

    @ConfigSection(
            name = "Discord Collection Logs",
            description = "",
            position = 7,
            closedByDefault = true
    )
    String DISCORD_CLOG = "Discord Collection Logs";

    @ConfigSection(
            name = "Discord Pets",
            description = "",
            position = 8,
            closedByDefault = true
    )
    String DISCORD_PET = "Discord Pets";

    @ConfigSection(
            name = "Discord Death",
            description = "",
            position = 9,
            closedByDefault = true
    )
    String DISCORD_DEATH = "Discord Death";

    @ConfigSection(
            name = "Leaderboards",
            description = "",
            position = 10,
            closedByDefault = true
    )
    String LEADERBOARDS = "Leaderboards";

    // --- Items ---
    @ConfigItem(
            keyName = "infoMessage",
            name = "Show notification in chat",
            description = "Sends a notification in chat whenever an announcement is sent to discord",
            section = DISCORD_GLOBAL,
            position = 1
    )
    default boolean infoMessage(){ return true; }

    @ConfigItem(
            keyName = "announceLevel",
            name = "Enable level announcements",
            description = "",
            section = DISCORD_LEVEL,
            position = 1
    )
    default boolean announceLevel(){ return true; }

    @ConfigItem(
            keyName = "announceLevelScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_LEVEL,
            position = 2
    )
    default boolean announceLevelScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announceLevelChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_LEVEL,
            position = 3
    )
    default chatPrivacy announceLevelChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announceMaxed",
            name = "Enable maxed announcements",
            description = "",
            section = DISCORD_MAXED,
            position = 1
    )
    default boolean announceMaxed(){ return true; }

    @ConfigItem(
            keyName = "announceMaxedScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_MAXED,
            position = 2
    )
    default boolean announceMaxedScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announceMaxedChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_MAXED,
            position = 3
    )
    default chatPrivacy announceMaxedChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announce200M",
            name = "Enable 200M XP announcements",
            description = "",
            section = DISCORD_200M_XP,
            position = 1
    )
    default boolean announce200M(){ return true; }

    @ConfigItem(
            keyName = "announce200MScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_200M_XP,
            position = 2
    )
    default boolean announce200MScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announce200MChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_200M_XP,
            position = 3
    )
    default chatPrivacy announce200MChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announceQuests",
            name = "Enable GM Quest announcements",
            description = "",
            section = DISCORD_QUESTS,
            position = 1
    )
    default boolean announceQuests(){ return true; }

    @ConfigItem(
            keyName = "announceQuestsScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_QUESTS,
            position = 2
    )
    default boolean announceQuestsScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announceQuestsChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_QUESTS,
            position = 3
    )
    default chatPrivacy announceQuestsChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announceQuestsStats",
            name = "Include total quest points",
            description = "",
            section = DISCORD_QUESTS,
            position = 4
    )
    default boolean announceQuestsStats(){ return true; }

    @ConfigItem(
            keyName = "announceDiaries",
            name = "Enable Elite Diary announcements",
            description = "",
            section = DISCORD_DIARIES,
            position = 1
    )
    default boolean announceDiaries(){ return true; }

    @ConfigItem(
            keyName = "announceDiariesScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_DIARIES,
            position = 2
    )
    default boolean announceDiariesScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announceDiariesChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_DIARIES,
            position = 3
    )
    default chatPrivacy announceDiariesChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announceCombatAchievements",
            name = "Enable CA rewards announcements",
            description = "",
            section = DISCORD_CA,
            position = 1
    )
    default boolean announceCombatAchievements(){ return true; }

    @ConfigItem(
            keyName = "announceCombatAchievementsScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_CA,
            position = 2
    )
    default boolean announceCombatAchievementsScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announceCombatAchievementsChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_CA,
            position = 3
    )
    default chatPrivacy announceCombatAchievementsChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announceCollectionLogs",
            name = "Enable clog announcements",
            description = "",
            section = DISCORD_CLOG,
            position = 1
    )
    default boolean announceCollectionLogs(){ return true; }

    @ConfigItem(
            keyName = "announceCollectionLogsScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_CLOG,
            position = 2
    )
    default boolean announceCollectionLogsScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announceCollectionLogsChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_CLOG,
            position = 3
    )
    default chatPrivacy announceCollectionLogsChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announceCollectionLogsStats",
            name = "Include total clogs",
            description = "",
            section = DISCORD_CLOG,
            position = 4
    )
    default boolean announceCollectionLogsStats(){ return true; }

    @ConfigItem(
            keyName = "announcePets",
            name = "Enable pet announcements",
            description = "",
            section = DISCORD_PET,
            position = 1
    )
    default boolean announcePets(){ return true; }

    @ConfigItem(
            keyName = "announcePetsScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_PET,
            position = 2
    )
    default boolean announcePetsScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announcePetsChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_PET,
            position = 3
    )
    default chatPrivacy announcePetsChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announceDeaths",
            name = "Enable death announcements",
            description = "",
            section = DISCORD_DEATH,
            position = 1
    )
    default boolean announceDeaths(){ return true; }

    @ConfigItem(
            keyName = "announceDeathsScreenshot",
            name = "Include screenshot",
            description = "",
            section = DISCORD_DEATH,
            position = 2
    )
    default boolean announceDeathsScreenshot(){ return true; }

    @ConfigItem(
            keyName = "announceDeathsChatPrivacy",
            name = "Chat privacy",
            description = "",
            section = DISCORD_DEATH,
            position = 3
    )
    default chatPrivacy announceDeathsChatPrivacy(){ return chatPrivacy.ALL; }

    @ConfigItem(
            keyName = "announceDeathsStats",
            name = "Include combat and total level",
            description = "",
            section = DISCORD_DEATH,
            position = 4
    )
    default boolean announceDeathsStats(){ return true; }

    @ConfigItem(
            keyName = "displayVirtualLevels",
            name = "Display Virtual Levels",
            description = "Should virtual levels be displayed in the skills leaderboards?",
            section = LEADERBOARDS,
            position = 1
    )
    default boolean displayVirtualLevels() { return true; }

}

package com.oneshot;

import com.google.gson.*;

import com.oneshot.modules.ModToolsPanel;
import com.oneshot.utils.Constants;
import com.oneshot.utils.Icons;

import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.*;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellRenderer;
import javax.swing.text.StyleContext;

import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableRowSorter;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.Experience;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.*;

import static com.oneshot.utils.Constants.BOSSES;
import static com.oneshot.utils.Constants.SKILLS;
import static com.oneshot.utils.Constants.ACTIVITIES;
import static net.runelite.client.hiscore.HiscoreSkill.*;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.QuantityFormatter;

import okhttp3.*;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class OneShotPanel extends PluginPanel
{
    private static final Logger log = LoggerFactory.getLogger(OneShotPanel.class);

    private ModToolsPanel modToolsPanel;
    private OneShotConfig config;

    private final Map<HiscoreSkill, JButton> skillButtons = new HashMap<>();
    private RateLimitedHttpCache rateLimitedHttpCache;

    JLabel intro_top_text = new JLabel("", SwingConstants.CENTER);
    JLabel intro_bottom_text = new JLabel("", SwingConstants.CENTER);
    JPanel panelMainContent = new JPanel();

    private JTable currentTable;
    private JScrollPane currentScroll;
    private PlayerTableModel currentModel;
    private JPanel skillViewRoot;

    private HiscoreSkill currentSkill;

    // --- Skill view search state ---
    private SuggestionTextField playerSearchField;
    private JLabel playerSearchCount;
    private final String[] playerSearchSuggestion = { null };

    private JsonArray currentSkillArr;
    private List<Integer> currentSkillFilteredIdx;
    private String currentSkillQuery = "";

    String playerRank;

    ArrayList<OneShotPlugin.OneShotMember> allMembersRanksInfo;
    Map<String, ImageIcon> allMembersIcons;
    Map<String, String> allMembersDisplayNames;

    private boolean isInInfoPanel = false;
    private boolean isModerator = false;

    private Font titleFont;

    ClientThread clientThread;
    Client client;

    @Inject
    private OkHttpClient httpClient;

    @Inject
    private SpriteManager spriteManager;
    private String playerName;

    private final Map<String, JButton> tabButtons = new HashMap<>();
    private final Map<String, JPanel> tabUnderlines = new HashMap<>();
    private String activeTabKey = "info";
    private static final Color TAB_UNDERLINE = new Color(139, 0, 0); // Dark red
    private static final Color TAB_UNDERLINE_OFF = new Color(0, 0, 0, 0); // No color

    private static final Color ROW_A = new Color(26, 26, 26);
    private static final Color ROW_B = new Color(32, 32, 32);

    public void init(Client client, ClientThread clientThread, ModToolsPanel modToolsPanel, OneShotConfig config)
    {
        this.clientThread = clientThread;
        this.client = client;
        this.modToolsPanel = modToolsPanel;
        this.config = config;
        loadFonts();
        buildIntroPanel();
        rateLimitedHttpCache = new RateLimitedHttpCache(20, 5);
    }

    public void deinit()
    {
        isInInfoPanel = false;
        rateLimitedHttpCache.shutdown();
    }

    private void update()
    {
        revalidate();
        repaint();
    }

    public void refresh(boolean isModerator, String playerName, String clanRankName,
                        ArrayList<OneShotPlugin.OneShotMember> allMembersRanksInfo, Map<String, ImageIcon> members,
                        Map<String, String> allMembersDisplayNames) throws IOException, InterruptedException {
        this.allMembersRanksInfo = allMembersRanksInfo;
        this.allMembersIcons = members;
        this.allMembersDisplayNames = allMembersDisplayNames;
        this.playerRank = clanRankName;
        if (isModerator != this.isModerator)
        {
            buildMainPanel(isModerator, playerName, clanRankName,
                allMembersRanksInfo, members,
                allMembersDisplayNames);
        }
        if (isInInfoPanel) buildInfoPanel();
        update();
    }

    private void loadFonts()
    {
        try (InputStream in = FontManager.class.getResourceAsStream("runescape.ttf"))
        {
            Font baseFont = Font.createFont(0, in).deriveFont(Font.PLAIN, 16.0F);
            titleFont = StyleContext.getDefaultStyleContext().getFont(baseFont.getName(), 0, 64);
        }
        catch (Exception e)
        {
            throw new RuntimeException("Failed to load runescape.ttf", e);
        }
    }

    private JPanel createWorldPanel()
    {
        JPanel container = new JPanel();
        container.setLayout(new BorderLayout());
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        container.setBorder(BorderFactory.createEmptyBorder(3, 0, 3, 0));

        JLabel worldLabel = new JLabel("507", Icons.WORLD, SwingConstants.CENTER);
        worldLabel.setHorizontalAlignment(SwingConstants.CENTER);
        worldLabel.setHorizontalTextPosition(SwingConstants.RIGHT);
        worldLabel.setForeground(client.getWorld() == 507 ? Color.GREEN : Color.RED);

        container.add(worldLabel, BorderLayout.CENTER);

        int h = 28;
        container.setPreferredSize(new Dimension(0, h));
        container.setMinimumSize(new Dimension(0, h));
        container.setMaximumSize(new Dimension(Integer.MAX_VALUE, h));

        return container;
    }

    private JPanel createTitlePanel(String text)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setBorder(BorderFactory.createEmptyBorder(4, 6, 4, 6));
        JLabel titleText = new JLabel(text, SwingConstants.CENTER);
        titleText.setFont(FontManager.getRunescapeBoldFont());
        container.add(titleText);
        return container;
    }

    public void buildIntroPanel()
    {
        removeAll();
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Main title
        JLabel title = new JLabel("One Shot", SwingConstants.CENTER);
        title.setFont(titleFont);

        // Icon
        JLabel iconLabel = new JLabel(Icons.RED_HELM);

        // Default intro text
        changeIntroText1("Welcome to One Shot Plugin");
        changeIntroText2("Please enter the clan chat to continue");

        // Footer label
        JLabel hardcoreInfo = new JLabel("Hardcore Ironman exclusive", SwingConstants.CENTER);

        add(title);
        add(hardcoreInfo);
        add(Box.createVerticalStrut(10));
        add(iconLabel);
        add(Box.createVerticalStrut(15));
        add(intro_top_text);
        add(intro_bottom_text);

        revalidate();
        repaint();
    }

    public void changeIntroText1(String text)
    {
        intro_top_text.setText(text);
    }

    public void changeIntroText2(String text)
    {
        intro_bottom_text.setText(text);
    }


    public void buildMainPanel(boolean isModerator, String playerName, String clanRankName,
                               ArrayList<OneShotPlugin.OneShotMember> allMembersRanksInfo, Map<String, ImageIcon> members,
                               Map<String, String> allMembersDisplayNames) throws IOException, InterruptedException {

        this.allMembersRanksInfo = allMembersRanksInfo;
        this.allMembersIcons = members;
        this.allMembersDisplayNames = allMembersDisplayNames;
        this.playerName = playerName;
        this.playerRank = clanRankName;
        this.isModerator = isModerator;

        removeAll();

        Font fontTitle;

        try (
                InputStream inRunescape = FontManager.class.getResourceAsStream("runescape.ttf")
        ) {
            Font font = Font.createFont(0, inRunescape).deriveFont(Font.PLAIN, 16.0F);
            fontTitle = StyleContext.getDefaultStyleContext().getFont(font.getName(), 0, 32);
        } catch (FontFormatException ex) {
            throw new RuntimeException("Font loaded, but format incorrect.", ex);
        } catch (IOException ex) {
            throw new RuntimeException("Font file not found.", ex);
        }

        JPanel header = new JPanel();
        header.setLayout(new BoxLayout(header, BoxLayout.Y_AXIS));
        header.setOpaque(false);

        header.setMaximumSize(new Dimension(Integer.MAX_VALUE, header.getPreferredSize().height));

        JLabel iconLabel = new JLabel(Icons.RED_HELM_SMALLER);
        iconLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

        JLabel titleLabel = new JLabel("One Shot", SwingConstants.CENTER);
        titleLabel.setFont(fontTitle);
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        titleLabel.setMaximumSize(new Dimension(Integer.MAX_VALUE, titleLabel.getPreferredSize().height));
        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);

        header.add(iconLabel);
        header.add(Box.createVerticalStrut(4));
        header.add(titleLabel);

        add(header);

        // button panel
        JPanel tabsPanel = new JPanel();
        tabsPanel.setLayout(new BoxLayout(tabsPanel, BoxLayout.X_AXIS));
        tabsPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
        tabsPanel.setAlignmentX(Component.CENTER_ALIGNMENT);

        tabButtons.clear();
        tabUnderlines.clear();

        tabsPanel.add(Box.createHorizontalGlue());

        tabsPanel.add(makeTab("info", "Info", () -> {
            try { buildInfoPanel(); } catch (Exception ex) { throw new RuntimeException(ex); }
        }));
        tabsPanel.add(Box.createHorizontalGlue());

        tabsPanel.add(makeTab("ranks", "Ranks", this::buildLeaderboardsPanel));
        tabsPanel.add(Box.createHorizontalGlue());

        tabsPanel.add(makeTab("discord", "Discord", this::buildDiscordPanel));

        if (isModerator)
        {
            tabsPanel.add(Box.createHorizontalGlue());
            tabsPanel.add(makeTab("dev", "Dev", this::buildModToolsPanel));
        }

        tabsPanel.add(Box.createHorizontalGlue());
        add(tabsPanel);

        // Main Panel
        panelMainContent.removeAll();
        panelMainContent.setLayout(new BorderLayout());
        add(panelMainContent);

        setActiveTab("info");

        SwingUtilities.invokeLater(() -> {
            buildInfoPanel();
            panelMainContent.revalidate();
            panelMainContent.repaint();
        });

        update();
    }

    private JComponent makeTab(String key, String text, Runnable onClick)
    {
        JButton button = buildTab(text, () -> {
            onClick.run();
            setActiveTab(key);
        });

        // Make the button not grow / not add padding changes
        button.setMargin(new Insets(0, 0, 0, 0));

        button.addMouseListener(new MouseAdapter() {
            @Override public void mouseEntered(MouseEvent e) {
                if (!key.equals(activeTabKey)) button.setForeground(Color.WHITE);
            }
            @Override public void mouseExited(MouseEvent e) {
                button.setForeground(key.equals(activeTabKey) ? Color.WHITE : ColorScheme.TEXT_COLOR.darker());
            }
        });

        JPanel underline = new JPanel();
        underline.setOpaque(true);
        underline.setPreferredSize(new Dimension(button.getPreferredSize().width + 15, 2));
        underline.setMinimumSize(new Dimension(1, 2));
        underline.setMaximumSize(new Dimension(Integer.MAX_VALUE, 2));
        underline.setBackground(TAB_UNDERLINE_OFF);

        JPanel tab = new JPanel();
        tab.setLayout(new BoxLayout(tab, BoxLayout.Y_AXIS));
        tab.setOpaque(false);

        // keep width stable: use the button’s preferred size
        Dimension d = button.getPreferredSize();
        tab.setPreferredSize(new Dimension(d.width + 15, d.height + 4));
        tab.setMinimumSize(tab.getPreferredSize());
        tab.setMaximumSize(tab.getPreferredSize());

        // Center the button inside the tab container
        button.setAlignmentX(Component.CENTER_ALIGNMENT);
        underline.setAlignmentX(Component.CENTER_ALIGNMENT);

        tab.add(button);
        tab.add(Box.createVerticalStrut(2));
        tab.add(underline);

        tabButtons.put(key, button);
        tabUnderlines.put(key, underline);

        return tab;
    }

    private static JButton buildTab(String text, Runnable callback)
    {
        JButton button = new JButton(text);

        button.setOpaque(false);
        button.setContentAreaFilled(false);
        button.setBorderPainted(false);
        button.setFocusPainted(false);
        button.setRolloverEnabled(false);

        button.setBackground(ColorScheme.DARK_GRAY_COLOR);
        button.setForeground(ColorScheme.TEXT_COLOR);



        button.addMouseListener(new MouseAdapter() {
            @Override public void mouseReleased(MouseEvent e) {
                callback.run();
            }
        });

        return button;
    }

    private void setActiveTab(String key)
    {
        activeTabKey = key;

        for (Map.Entry<String, JPanel> e : tabUnderlines.entrySet())
        {
            boolean active = e.getKey().equals(key);
            e.getValue().setBackground(active ? TAB_UNDERLINE : TAB_UNDERLINE_OFF);
        }

        for (Map.Entry<String, JButton> e : tabButtons.entrySet())
        {
            boolean active = e.getKey().equals(key);
            e.getValue().setForeground(active ? Color.WHITE : ColorScheme.TEXT_COLOR.darker());
        }

        revalidate();
        repaint();
    }

    private void buildInfoPanel() {
        isInInfoPanel = true;

        panelMainContent.removeAll();
        JPanel container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        container.add(createTitlePanel("Clan World"));
        container.add(createWorldPanel());
        container.add(Box.createVerticalStrut(4));
        container.add(createTitlePanel("Roles"));
        JPanel allMembersRanks = buildAllMembersRanksTotal();
        container.setOpaque(false);
        container.setAlignmentX(Component.CENTER_ALIGNMENT);
        allMembersRanks.setAlignmentX(Component.CENTER_ALIGNMENT);
        container.add(allMembersRanks);
        panelMainContent.add(container, BorderLayout.CENTER);
        panelMainContent.revalidate();
        panelMainContent.repaint();
        update();
    }


    private JPanel buildAllMembersRanksTotal()
    {
        JPanel wrapper = new JPanel();
        wrapper.setOpaque(false);
        wrapper.setLayout(new BoxLayout(wrapper, BoxLayout.Y_AXIS));

        // ---- Build table model data ----

        DefaultTableModel model = new DefaultTableModel(new String[] { "", "Rank", "Online", "Total" }, 0)
        {
            @Override public boolean isCellEditable(int r, int c) { return false; }

            @Override public Class<?> getColumnClass(int c)
            {
                switch (c)
                {
                    case 0: return Icon.class;
                    case 2:
                    case 3:
                        return Integer.class;
                    default: return String.class;
                }
            }
        };

        for (OneShotPlugin.OneShotMember m : allMembersRanksInfo)
        {
            if (m == null) continue;

            String name = m.getName();
            if (name == null || name.trim().isEmpty()) continue; // <-- prevents blank trailing row

            model.addRow(new Object[] { m.getIcon(), name, m.getOnline(), m.getTotal() });
        }

        JTable table = new JTable(model);
        applyBaseTableStyle(table);

        // Column sizing
        table.getColumnModel().getColumn(2).setMaxWidth(60);  // online
        table.getColumnModel().getColumn(3).setMaxWidth(60);  // total

        // --- Icon column renderer ---
        table.getColumnModel().getColumn(0).setCellRenderer(new DefaultTableCellRenderer()
        {
            @Override
            public Component getTableCellRendererComponent(JTable t, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int col)
            {
                super.getTableCellRendererComponent(t, "", false, false, row, col);

                setHorizontalAlignment(SwingConstants.CENTER);
                setIcon(value instanceof Icon ? (Icon) value : null);

                setBackground(row % 2 == 0 ? ROW_B : ROW_A);
                setForeground(ColorScheme.TEXT_COLOR);

                String rankName = String.valueOf(t.getModel().getValueAt(row, 1));
                if (Objects.equals(playerRank, rankName))
                    setForeground(Color.GREEN);

                return this;
            }
        });

        // --- Rank column renderer (text) ---
        table.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer()
        {
            @Override
            public Component getTableCellRendererComponent(JTable t, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int col)
            {
                super.getTableCellRendererComponent(t, value, false, false, row, col);

                setHorizontalAlignment(SwingConstants.LEFT);
                setBackground(row % 2 == 0 ? ROW_B : ROW_A);
                setForeground(ColorScheme.TEXT_COLOR);

                String rankName = String.valueOf(t.getModel().getValueAt(row, 1));
                if (Objects.equals(playerRank, rankName))
                    setForeground(Color.GREEN);

                return this;
            }
        });

        // --- Number columns renderer (center) ---
        DefaultTableCellRenderer number = new DefaultTableCellRenderer()
        {
            @Override
            public Component getTableCellRendererComponent(JTable t, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int col)
            {
                super.getTableCellRendererComponent(t, value, false, false, row, col);

                setHorizontalAlignment(SwingConstants.CENTER);
                setBackground(row % 2 == 0 ? ROW_B : ROW_A);
                setForeground(ColorScheme.TEXT_COLOR);

                String rankName = String.valueOf(t.getModel().getValueAt(row, 1));
                if (Objects.equals(playerRank, rankName))
                    setForeground(Color.GREEN);

                return this;
            }
        };

        table.getColumnModel().getColumn(2).setCellRenderer(number);
        table.getColumnModel().getColumn(3).setCellRenderer(number);

        JTableHeader header = table.getTableHeader();
        header.setReorderingAllowed(false);
        header.setResizingAllowed(false);
        header.setBorder(BorderFactory.createEmptyBorder());

        header.setDefaultRenderer(new TableCellRenderer()
        {
            private final DefaultTableCellRenderer r = new DefaultTableCellRenderer();

            @Override
            public Component getTableCellRendererComponent(JTable tbl, Object value,
                                                           boolean isSelected, boolean hasFocus,
                                                           int row, int col)
            {
                r.setOpaque(true);
                r.setBackground(ROW_A);
                r.setForeground(Color.WHITE);
                r.setFont(FontManager.getRunescapeSmallFont());
                r.setBorder(BorderFactory.createEmptyBorder());

                r.setText(value == null ? "" : value.toString());

                // Rank header left aligned, others centered
                if (col == 1) {
                    r.setHorizontalAlignment(SwingConstants.LEFT);
                    r.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 0)); // just padding
                } else {
                    r.setHorizontalAlignment(SwingConstants.CENTER);
                    r.setBorder(BorderFactory.createEmptyBorder());
                }

                return r;
            }
        });

        table.getColumnModel().getColumn(0).setPreferredWidth(32);
        table.getColumnModel().getColumn(0).setMaxWidth(32);

        table.getColumnModel().getColumn(2).setPreferredWidth(50);
        table.getColumnModel().getColumn(2).setMaxWidth(50);

        table.getColumnModel().getColumn(3).setPreferredWidth(50);
        table.getColumnModel().getColumn(3).setMaxWidth(50);

        table.setAutoResizeMode(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS);

        JScrollPane scroll = new JScrollPane(table);
        // ---- Clamp scroll height to exactly header + rows (removes bottom gap) ----
        int rowsH = table.getRowHeight() * table.getRowCount();
        int headerH = table.getTableHeader().getPreferredSize().height;
        int totalH = rowsH + headerH;

        Dimension fixed = new Dimension(Short.MAX_VALUE, totalH);
        scroll.setPreferredSize(new Dimension(0, totalH));
        scroll.setMaximumSize(fixed);
        scroll.setMinimumSize(new Dimension(0, totalH));

        // No need for a vertical scrollbar if we're exact-height
        scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        scroll.setBorder(BorderFactory.createEmptyBorder());
        scroll.setViewportBorder(BorderFactory.createEmptyBorder());
        scroll.setOpaque(false);
        scroll.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JViewport vp = scroll.getViewport();
        vp.setOpaque(false);
        vp.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Optional: keep the horizontal scrollbar away
        scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        wrapper.add(scroll);
        wrapper.add(Box.createVerticalStrut(2));

        JLabel discordPlug = new JLabel("/rank in discord #bot-commands", SwingConstants.CENTER);
        discordPlug.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        discordPlug.setAlignmentX(Component.CENTER_ALIGNMENT);
        wrapper.add(discordPlug);

        return wrapper;
    }

    private void applyBaseTableStyle(JTable table)
    {
        table.setRowHeight(22);
        table.setShowGrid(false);
        table.setIntercellSpacing(new Dimension(0, 0));
        table.setFocusable(false);
        table.setRowSelectionAllowed(false);
        table.setColumnSelectionAllowed(false);
        table.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        table.setForeground(ColorScheme.TEXT_COLOR);
        table.setFont(FontManager.getRunescapeSmallFont());
    }

    private JPanel buildTopChartsSkeleton()
    {
        final int GAP = 4;

        JPanel container = new JPanel();
        container.setBorder(BorderFactory.createEmptyBorder(4, 6, 4, 6));
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));

        skillButtons.clear();

        // Skills: 3 columns
        container.add(createTitlePanel("Skills"));
        container.add(buildButtonGrid(SKILLS, GAP));
        container.add(Box.createVerticalStrut(GAP));

        // Overall: 1 column
        container.add(buildButtonGrid(Collections.singletonList(OVERALL), GAP));
        container.add(Box.createVerticalStrut(GAP));

        // Activities: 2 columns
        container.add(createTitlePanel("Activities"));
        container.add(buildButtonGrid(ACTIVITIES, GAP));
        container.add(Box.createVerticalStrut(GAP));

        // Bosses: 3 columns
        container.add(createTitlePanel("Bosses"));
        container.add(buildButtonGrid(BOSSES, GAP));

        return container;
    }

    private void fetchAndPopulateTopChartsAsync()
    {
        SwingWorker<JsonElement, Void> worker = new SwingWorker<>()
        {
            @Override
            protected JsonElement doInBackground() throws Exception
            {
                String response = rateLimitedHttpCache.fetch(Constants.URI_WOM_LEADERS);
                if (response == null) return null;

                JsonParser jsonParser = new JsonParser();
                JsonElement jsonElement = jsonParser.parse(response);
                return jsonElement.getAsJsonObject().get(Constants.URI_WOM_LEADERS_OBJECT);
            }

            @Override
            protected void done()
            {
                try
                {
                    JsonElement metricLeaders = get();
                    if (metricLeaders == null) return;

                    populateMetricLeadersAsync(metricLeaders);
                }
                catch (Exception e)
                {
                    log.error(e.getMessage());
                }
            }
        };

        worker.execute();
    }

    private void populateMetricLeadersAsync(JsonElement metricLeaders) {

        SwingWorker<Map<JButton, ButtonUpdate>, Void> worker = new SwingWorker<>() {

            @Override
            protected Map<JButton, ButtonUpdate> doInBackground() {
                Map<JButton, ButtonUpdate> updates = new HashMap<>();

                for (Map.Entry<HiscoreSkill, JButton> entry : skillButtons.entrySet()) {

                    HiscoreSkill skill = entry.getKey();
                    JButton button = entry.getValue();

                    // compute everything in the background
                    ButtonUpdate update = computeButtonInfo(skill, metricLeaders);

                    // store result (no Swing calls here!)
                    updates.put(button, update);
                }

                return updates;
            }

            @Override
            protected void done() {
                try {
                    // safely apply updates on the Swing thread
                    Map<JButton, ButtonUpdate> updates = get();

                    for (Map.Entry<JButton, ButtonUpdate> entry : updates.entrySet()) {
                        JButton button = entry.getKey();
                        ButtonUpdate update = entry.getValue();

                        button.setForeground(update.color);
                        button.setText(update.text);
                        button.setToolTipText(update.tooltip);
                    }

                } catch (Exception e) {
                    log.error(e.getMessage());
                }
            }
        };

        worker.execute();
    }

    private ButtonUpdate computeButtonInfo(HiscoreSkill skill, JsonElement metricLeaders) {

        String name = normalizeSkillName(skill);
        String element;
        String id;
        JsonElement metric;

        if (SKILLS.contains(skill) || name.equals("overall")) {
            element = "skills";
            id = "experience";
            metric = metricLeaders.getAsJsonObject().get(element)
                    .getAsJsonObject().get(name);

            Color col = metric.getAsJsonObject()
                    .get("player").getAsJsonObject()
                    .get("displayName").getAsString().equals(playerName)
                    ? Color.GREEN : Color.WHITE;

            String text = name.equals("overall")
                    ? metric.getAsJsonObject().get("level").getAsString()
                    : String.valueOf(Experience.getLevelForXp(
                    metric.getAsJsonObject().get(id).getAsInt()));

            return new ButtonUpdate(col, text, detailsHtml(skill, metric));
        }

        else if (BOSSES.contains(skill)) {
            element = "bosses";
            id = "kills";
            metric = metricLeaders.getAsJsonObject().get(element)
                    .getAsJsonObject().get(name);

            double kills = metric.getAsJsonObject().get(id).getAsDouble();
            Color col = kills == 0 ? Color.RED :
                    metric.getAsJsonObject().get("player")
                            .getAsJsonObject().get("displayName")
                            .getAsString().equals(playerName)
                            ? Color.GREEN : Color.WHITE;

            return new ButtonUpdate(col, metric.getAsJsonObject().get(id).getAsString(),
                    detailsHtml(skill, metric));
        }

        else if (ACTIVITIES.contains(skill)) {
            element = "activities";
            id = "score";
            metric = metricLeaders.getAsJsonObject().get(element)
                    .getAsJsonObject().get(name);

            double score = metric.getAsJsonObject().get(id).getAsDouble();
            Color col = score == 0 ? Color.RED :
                    metric.getAsJsonObject().get("player")
                            .getAsJsonObject().get("displayName")
                            .getAsString().equals(playerName)
                            ? Color.GREEN : Color.WHITE;

            return new ButtonUpdate(col,
                    metric.getAsJsonObject().get(id).getAsString(),
                    detailsHtml(skill, metric));
        }

        // fallback
        return new ButtonUpdate(Color.WHITE, "?", "Unknown");
    }

    private static class ButtonUpdate {
        final Color color;
        final String text;
        final String tooltip;

        ButtonUpdate(Color color, String text, String tooltip) {
            this.color = color;
            this.text = text;
            this.tooltip = tooltip;
        }
    }

    private String detailsHtml(HiscoreSkill skill, JsonElement metricLeader) {

        JsonObject obj = metricLeader.getAsJsonObject();
        JsonObject player = obj.getAsJsonObject("player");
        String displayName = player.get("displayName").getAsString();

        StringBuilder sb = new StringBuilder();
        sb.append("<html><body style='padding:5px;color:#989898'>");

        boolean isSkill = SKILLS.contains(skill) || skill.getName().equalsIgnoreCase("overall");
        boolean isBoss  = BOSSES.contains(skill);
        boolean isActivity = ACTIVITIES.contains(skill);

        if (isSkill) {
            sb.append("<p><span style='color:white'>Skill:</span> ").append(skill.getName()).append("</p>");
            sb.append("<p><span style='color:white'>Name:</span> ").append(displayName).append("</p>");
            sb.append("<p><span style='color:white'>Rank:</span> ").append(QuantityFormatter.formatNumber(obj.get("rank").getAsDouble())).append("</p>");
            //sb.append("<p><span style='color:white'>Level:</span> ").append(QuantityFormatter.formatNumber(obj.get("level").getAsDouble())).append("</p>");
            sb.append("<p><span style='color:white'>Experience:</span> ").append(QuantityFormatter.formatNumber(obj.get("experience").getAsDouble())).append("</p>");
        }
        else if (isBoss) {
            sb.append("<p><span style='color:white'>Boss:</span> ").append(skill.getName()).append("</p>");

            double kills = obj.get("kills").getAsDouble();
            if (kills > 0) {
                double rank = obj.get("rank").getAsDouble();

                sb.append("<p><span style='color:white'>Name:</span> ").append(displayName).append("</p>");
                sb.append("<p><span style='color:white'>Rank:</span> ")
                        .append(rank > 0 ? QuantityFormatter.formatNumber(rank) : "--")
                        .append("</p>");
                //sb.append("<p><span style='color:white'>KC:</span> ").append(QuantityFormatter.formatNumber(kills)).append("</p>");
            } else {
                sb.append("<p>No one is ranked yet</p>");
            }
        }
        else if (isActivity) {
            sb.append("<p><span style='color:white'>").append(skill.getName()).append("</span></p>");

            double rank = obj.get("rank").getAsDouble();
            if (rank > 0) {
                sb.append("<p><span style='color:white'>Name:</span> ").append(displayName).append("</p>");
                sb.append("<p><span style='color:white'>Rank:</span> ").append(QuantityFormatter.formatNumber(rank))
                        .append("</p>");
            } else {
                sb.append("<p>No one is ranked yet</p>");
            }
        }
        else {
            log.debug("Houston, we have a problem");
            return "";
        }

        sb.append("</body></html>");
        return sb.toString();
    }


    private JPanel makeHiscorePanel(HiscoreSkill skill)
    {
        HiscoreSkillType skillType = skill == null ? HiscoreSkillType.SKILL : skill.getType();

        JButton button = new JButton();
        button.setToolTipText(skill == null ? "Combat" : skill.getName());
        button.setFont(FontManager.getRunescapeSmallFont());
        button.setText(pad(skillType));
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setMargin(new Insets(0,0,0,0));
        button.setBorderPainted(false);
        button.setPreferredSize(new Dimension(0, 35));
        button.setMinimumSize(new Dimension(0, 35));


        BufferedImage clueImg = getClueScrollIcon(skill);
        if (clueImg != null) {
            final BufferedImage scaledSprite = ImageUtil.resizeImage(ImageUtil.resizeCanvas(clueImg, 25, 25), 20, 20);
            button.setIcon(new ImageIcon(scaledSprite));
        }
        else {
            spriteManager.getSpriteAsync(skill == null ? SpriteID.SideIcons.COMBAT : skill.getSpriteId(), 0, (sprite) ->
                    SwingUtilities.invokeLater(() ->
                    {
                        // Icons are all 25x25 or smaller, so they're fit into a 25x25 canvas to give them a consistent size for
                        // better alignment. Further, they are then scaled down to 20x20 to not be overly large in the panel.
                        final BufferedImage scaledSprite = ImageUtil.resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                        button.setIcon(new ImageIcon(scaledSprite));
                    }));
        }

        boolean totalLabel = skill == OVERALL || skill == null; //overall or combat
        button.setIconTextGap(totalLabel ? 10 : 4);


        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                button.setBackground(pressedColor);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                buildSkillPlayersAsync(skill);
                button.setBackground(hoverColor);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(hoverColor);
                button.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                button.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });

        JPanel skillPanel = new JPanel(new BorderLayout());
        skillPanel.setOpaque(false);
        skillPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
        skillPanel.add(button, BorderLayout.CENTER);

        skillButtons.put(skill, button);

        return skillPanel;
    }

    private JPanel buildButtonGrid(List<HiscoreSkill> items, int gap)
    {
        int count = items.size();
        int cols = Math.max(1, Math.min(3, count));

        JPanel grid = new JPanel(new GridLayout(0, cols, gap, gap));
        grid.setOpaque(false);

        for (HiscoreSkill s : items)
        {
            grid.add(makeHiscorePanel(s));
        }
        return grid;
    }

    private void showLoadingIfFirstOpenForSkill()
    {
        boolean firstOpenForThisSkill = (skillViewRoot == null);

        if (!firstOpenForThisSkill)
        {
            return;
        }

        panelMainContent.removeAll();
        panelMainContent.setLayout(new BorderLayout());

        JPanel loading = new JPanel(new BorderLayout());
        loading.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel loadingText = new JLabel("Loading...", SwingConstants.CENTER);
        loading.add(loadingText, BorderLayout.CENTER);

        panelMainContent.add(loading, BorderLayout.CENTER);
        panelMainContent.revalidate();
        panelMainContent.repaint();
    }


    private void buildSkillPlayersAsync(HiscoreSkill skill) {

        final HiscoreSkill requestedSkill = skill;

        SwingUtilities.invokeLater(this::showLoadingIfFirstOpenForSkill);

        SwingWorker<JsonArray, Void> worker = new SwingWorker<>() {

            @Override
            protected JsonArray doInBackground() throws Exception {
                String skillName = normalizeSkillName(requestedSkill);
                return fetchSkillData(skillName);   // <-- NO UI freeze now
            }

            @Override
            protected void done() {
                try {
                    JsonArray arr = get();
                    // now build UI on EDT
                    buildSkillPlayersUI(requestedSkill, arr);

                } catch (Exception e) {
                    log.error(e.getMessage());
                    buildSkillPlayersUI(requestedSkill, null);
                }
            }
        };

        worker.execute();
    }

    private void showSkillMessage(String line1, String line2, Color c1, Color c2)
    {
        panelMainContent.removeAll();
        JPanel p = new JPanel();
        p.setLayout(new BoxLayout(p, BoxLayout.Y_AXIS));
        p.add(goBackButton());

        JLabel a = new JLabel(line1);
        a.setForeground(c1);
        p.add(a);

        if (line2 != null)
        {
            JLabel b = new JLabel(line2);
            b.setForeground(c2);
            p.add(b);
        }

        panelMainContent.add(p);
        update();
    }

    private void buildSkillPlayersUI(HiscoreSkill skill, JsonArray arr) {

        if (arr == null) {
            showSkillMessage("Hey wow, too fast!", "Please slow down", Color.RED, Color.RED);
            return;
        }

        if (arr.size() == 0) {
            showSkillMessage("Seems no one is on the Hiscores", null, Color.RED, Color.RED);
            return;
        }

        // Cache full dataset for the skill search bar
        currentSkillArr = arr;

        // ---- reset search/filter when opening a (new) skill/boss ----
        currentSkillQuery = "";
        currentSkillFilteredIdx = null;
        playerSearchSuggestion[0] = null;

        if (playerSearchField != null)
        {
            playerSearchField.setText("");
            playerSearchField.setSuggestion(null);
        }

        // Apply current query (if any) and render from filtered set
        rebuildSkillFilterAndShow(skill);
    }


    private void ensureSkillViewBuilt(HiscoreSkill skill, boolean isSkill, boolean isBoss) {
        if (skillViewRoot != null && currentSkill == skill) {
            // if user navigated away via tabs, the view is no longer in panelMainContent
            if (skillViewRoot.getParent() == null || skillViewRoot.getParent() != panelMainContent)
            {
                panelMainContent.removeAll();
                panelMainContent.setLayout(new BorderLayout());
                panelMainContent.add(skillViewRoot, BorderLayout.CENTER);
                panelMainContent.revalidate();
                panelMainContent.repaint();
            }
            return;
        }

        currentSkill = skill;

        // Root container
        skillViewRoot = new JPanel(new BorderLayout());
        skillViewRoot.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        /* ---------------- Header ---------------- */

        JPanel header = new JPanel();
        header.setLayout(new BoxLayout(header, BoxLayout.Y_AXIS));
        header.setBackground(ColorScheme.DARK_GRAY_COLOR);

        /* --- Top row: Go Back (left aligned) --- */
        JPanel backRow = new JPanel(new BorderLayout());
        backRow.setBackground(ColorScheme.DARK_GRAY_COLOR);
        backRow.add(goBackButton(), BorderLayout.WEST);

        /* --- Bottom row: Skill header (centered) --- */
        JPanel skillHeaderRow = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 5));
        skillHeaderRow.setBackground(ColorScheme.DARK_GRAY_COLOR);
        skillHeaderRow.add(buildSkillHeader(skill));

        header.add(backRow);
        header.add(skillHeaderRow);

        // --- Player search row (ghost suggestion + TAB commit) ---
        JPanel searchRow = new JPanel();
        searchRow.setLayout(new BoxLayout(searchRow, BoxLayout.Y_AXIS));
        searchRow.setBackground(ColorScheme.DARK_GRAY_COLOR);

        playerSearchField = new SuggestionTextField();
        playerSearchField.setFont(FontManager.getRunescapeSmallFont());
        playerSearchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        playerSearchField.setForeground(ColorScheme.TEXT_COLOR);
        playerSearchField.setCaretColor(Color.WHITE);
        playerSearchField.setBorder(BorderFactory.createEmptyBorder(6, 6, 6, 6));
        playerSearchField.setToolTipText("Search players (TAB accepts suggestion)");
        playerSearchField.setFocusTraversalKeysEnabled(false);

        int initialCount = 0;

        // If we already have data, show total (or filtered total if filter is already built)
        if (currentSkillFilteredIdx != null)
        {
            initialCount = currentSkillFilteredIdx.size();
        }
        else if (currentSkillArr != null)
        {
            // If there's a query already, count matching rows; otherwise just total size
            String q = currentSkillQuery == null ? "" : currentSkillQuery.trim().toLowerCase();
            if (q.isEmpty())
            {
                initialCount = currentSkillArr.size();
            }
            else
            {
                int c = 0;
                for (int i = 0; i < currentSkillArr.size(); i++)
                {
                    JsonObject entry = currentSkillArr.get(i).getAsJsonObject();
                    String display = getDisplayNameFromEntry(entry);
                    if (display != null && display.toLowerCase().contains(q)) c++;
                }
                initialCount = c;
            }
        }

        playerSearchCount = new JLabel(initialCount + " results");
        playerSearchCount.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        playerSearchCount.setFont(FontManager.getRunescapeSmallFont());
        playerSearchCount.setBorder(BorderFactory.createEmptyBorder(2, 2, 0, 0));

        searchRow.add(playerSearchField);
        searchRow.add(playerSearchCount);

        header.add(searchRow);

        // TAB commits suggestion
        playerSearchField.getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke("TAB"), "acceptPlayerSuggestion");
        playerSearchField.getActionMap().put("acceptPlayerSuggestion", new AbstractAction()
        {
            @Override public void actionPerformed(ActionEvent e)
            {
                String sugg = playerSearchSuggestion[0];
                if (sugg == null) return;

                playerSearchField.setText(sugg);
                playerSearchField.setCaretPosition(sugg.length());
                playerSearchField.setSuggestion(null);
            }
        });

        // On typing: filter + compute ghost suggestion
        Runnable applySearch = () -> {
            String q = playerSearchField.getText();
            String qLower = q == null ? "" : q.trim().toLowerCase();

            currentSkillQuery = qLower;

            // ghost suggestion (prefix only)
            String sugg = findFirstPrefixPlayerSuggestion(qLower);
            if (sugg != null && sugg.equalsIgnoreCase(q.trim())) sugg = null;

            playerSearchSuggestion[0] = sugg;
            playerSearchField.setSuggestion(sugg);

            // filter results immediately based on typed text
            rebuildSkillFilterAndShow(skill);
        };

        playerSearchField.getDocument().addDocumentListener(new DocumentListener()
        {
            private void update() { SwingUtilities.invokeLater(applySearch); }
            @Override public void insertUpdate(DocumentEvent e) { update(); }
            @Override public void removeUpdate(DocumentEvent e) { update(); }
            @Override public void changedUpdate(DocumentEvent e) { update(); }
        });

        skillViewRoot.add(header, BorderLayout.NORTH);

        /* ---------------- Table ---------------- */

        currentModel = new PlayerTableModel(new ArrayList<>(), isSkill, isBoss);

        currentTable = new JTable(currentModel)
        {
            @Override
            public Component prepareRenderer(TableCellRenderer r, int row, int col)
            {
                Component c = super.prepareRenderer(r, row, col);
                if (!isRowSelected(row))
                {
                    c.setBackground(row % 2 == 0 ? ROW_B : ROW_A);
                }
                return c;
            }
        };

        styleTable(currentTable, isSkill);

        currentScroll = new JScrollPane(currentTable);
        currentScroll.setBorder(BorderFactory.createEmptyBorder());
        currentScroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        currentScroll.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);

        int clampH = 300;
        currentScroll.setPreferredSize(new Dimension(0, clampH));
        currentScroll.setMaximumSize(new Dimension(Integer.MAX_VALUE, clampH));

        skillViewRoot.add(currentScroll, BorderLayout.CENTER);

        /* ---------------- Attach ---------------- */

        panelMainContent.removeAll();
        panelMainContent.setLayout(new BorderLayout());
        panelMainContent.add(skillViewRoot, BorderLayout.CENTER);
        panelMainContent.revalidate();
        panelMainContent.repaint();
    }

    private void rebuildSkillFilterAndShow(HiscoreSkill skill)
    {

        if (currentSkillArr == null)
        {
            return;
        }

        // Build filtered indices
        List<Integer> idx = new ArrayList<>();
        String q = currentSkillQuery == null ? "" : currentSkillQuery.trim().toLowerCase();

        for (int i = 0; i < currentSkillArr.size(); i++)
        {
            JsonObject entry = currentSkillArr.get(i).getAsJsonObject();
            String display = getDisplayNameFromEntry(entry);
            if (display == null) continue;

            if (q.isEmpty() || display.toLowerCase().contains(q))
            {
                idx.add(i);
            }
        }

        currentSkillFilteredIdx = idx;

        // Update count label if it exists
        if (playerSearchCount != null)
        {
            playerSearchCount.setText(idx.size() + " results");
        }

        // Re-render using existing buildSkillPlayersUI logic, but with filtered indices
        buildSkillPlayersUIFiltered(skill);
    }

    private void buildSkillPlayersUIFiltered(HiscoreSkill skill)
    {
        if (currentSkillArr == null)
        {
            buildSkillPlayersUI(skill, null);
            return;
        }

        if (currentSkillFilteredIdx == null)
        {
            currentSkillFilteredIdx = new ArrayList<>();
            for (int i = 0; i < currentSkillArr.size(); i++) currentSkillFilteredIdx.add(i);
        }

        String skillName = normalizeSkillName(skill);
        boolean isSkill = SKILLS.contains(skill) || skillName.equals("overall");
        boolean isBoss  = BOSSES.contains(skill);

        ensureSkillViewBuilt(skill, isSkill, isBoss);

        if (currentSkillFilteredIdx.isEmpty())
        {
            currentModel.setRows(Collections.emptyList());
            if (playerSearchCount != null) playerSearchCount.setText("0 results");
            currentTable.repaint();
            return;
        }

        List<PlayerRow> allRows = new ArrayList<>(currentSkillFilteredIdx.size());

        for (int arrIndex : currentSkillFilteredIdx) {
            JsonObject entry = currentSkillArr.get(arrIndex).getAsJsonObject();
            JsonObject pdata = entry.getAsJsonObject("player");
            JsonObject ddata = entry.getAsJsonObject("data");

            String username = pdata.get("username").getAsString();
            String lower = username.replace("\u00A0", " ");
            String display = allMembersDisplayNames.get(lower);
            ImageIcon icon = allMembersIcons.get(lower);


            boolean isPlayer = normName(username).equals(normName(playerName));

            long xp = isSkill && ddata.has("experience") ? ddata.get("experience").getAsLong() : -1;
            if (xp < 0) xp = 0;

            int stat;
            if (isSkill) {
                if (config.displayVirtualLevels() && !skillName.equals("overall")) {
                    stat = Experience.getLevelForXp((int) Math.min(Integer.MAX_VALUE, xp));
                } else {
                    stat = ddata.has("level") ? Math.max(0, ddata.get("level").getAsInt()) : 0;
                }
            } else if (isBoss) {
                stat = ddata.has("kills") ? Math.max(0, ddata.get("kills").getAsInt()) : 0;
            } else {
                stat = ddata.has("score") ? Math.max(0, ddata.get("score").getAsInt()) : 0;
            }

            String expStr = isSkill ? (xp > 0 ? formatNumber(xp) : "--") : "";

            // IMPORTANT: keep # as global/unfiltered rank
            allRows.add(new PlayerRow(
                    arrIndex + 1,
                    display,
                    icon,
                    stat,
                    expStr,
                    isPlayer
            ));
        }

        currentModel.setRows(allRows);
        currentTable.repaint();
    }

    private static String normName(String s)
    {
        if (s == null) return "";
        return s.replace('\u00A0', ' ')   // NBSP -> space
                .trim()
                .replaceAll("\\s+", " ")  // collapse multiple spaces
                .toLowerCase();
    }

    private String getDisplayNameFromEntry(JsonObject entry)
    {
        try
        {
            JsonObject pdata = entry.getAsJsonObject("player");
            String lower = pdata.get("username").getAsString().replace("\u00A0", " ");
            return allMembersDisplayNames.get(lower);
        }
        catch (Exception ignored)
        {
            return null;
        }
    }

    private String findFirstPrefixPlayerSuggestion(String qLower)
    {
        if (currentSkillArr == null || qLower == null || qLower.isEmpty()) return null;

        for (int i = 0; i < currentSkillArr.size(); i++)
        {
            String display = getDisplayNameFromEntry(currentSkillArr.get(i).getAsJsonObject());
            if (display == null) continue;

            if (display.toLowerCase().startsWith(qLower))
            {
                return display;
            }
        }
        return null;
    }

    private static final NavigableMap<Long, String> suffixes = new TreeMap<> ();
    static {
        suffixes.put(1_000L, "k");
        suffixes.put(1_000_000L, "M");
        suffixes.put(1_000_000_000L, "B");
    }

    private String formatNumber (long value)
    {
        //Long.MIN_VALUE == -Long.MIN_VALUE so we need an adjustment here
        if (value == Long.MIN_VALUE) return formatNumber(Long.MIN_VALUE + 1);
        if (value < 0) return "-" + formatNumber(-value);
        if (value < 1000) return Long.toString(value); //deal with easy case

        Map.Entry<Long, String> e = suffixes.floorEntry(value);
        Long divideBy = e.getKey();
        String suffix = e.getValue();

        long div = value / divideBy;          // Whole part
        long dec1 = (value * 10 / divideBy) % 10;     // One decimal
        long dec2 = (value * 100 / divideBy) % 100;   // Two decimals

        boolean show2 = div < 10;
        boolean show1 = div < 100;

        if (show2) {
            return String.format("%d.%02d%s", div, dec2, suffix);
        } else if (show1) {
            return String.format("%d.%d%s", div, dec1, suffix);
        } else {
            return String.format("%d%s", div, suffix);
        }
    }

    private JButton goBackButton() {
        JButton goBack = new JButton("< Go Back");
        goBack.setBorderPainted(false);

        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        // Optional: smaller preferred width to reduce horizontal space
        goBack.setPreferredSize(new Dimension(90, 20));
        goBack.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        goBack.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                goBack.setBackground(pressedColor);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                // reset cached skill view so clicking again rebuilds/reattaches
                skillViewRoot = null;
                currentSkill = null;
                currentTable = null;
                currentScroll = null;
                currentModel = null;

                panelMainContent.removeAll();
                buildLeaderboardsPanel();
                goBack.setBackground(hoverColor);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                goBack.setBackground(hoverColor);
                goBack.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                goBack.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                goBack.setCursor(Cursor.getDefaultCursor());
            }
        });

        // Align to the left in its container
        goBack.setHorizontalAlignment(SwingConstants.LEFT);

        return goBack;
    }

    private static String pad(HiscoreSkillType type)
    {
        // Left pad label text to keep labels aligned
        int pad = type == HiscoreSkillType.BOSS ? 4 : 2;
        return StringUtils.leftPad("--", pad);
    }


    private void buildDiscordPanel()
    {
        panelMainContent.removeAll();
        isInInfoPanel = false;
        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        JPanel container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        container.add(Box.createVerticalStrut(8));

        JLabel stats = new JLabel("Loading server stats…");
        stats.setHorizontalAlignment(SwingConstants.CENTER);
        stats.setAlignmentX(Component.CENTER_ALIGNMENT);
        container.add(stats);
        container.add(Box.createVerticalStrut(8));

        JPanel buttons = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
        buttons.setAlignmentX(Component.CENTER_ALIGNMENT);

        JButton joinDiscord = getJoinDiscord(pressedColor, hoverColor);
        JButton copyInvite = getCopyInvite(pressedColor, hoverColor);
        buttons.add(joinDiscord);
        buttons.add(copyInvite);
        container.add(buttons);
        container.add(Box.createVerticalStrut(10));

        JLabel helpText = getHelpText();
        container.add(helpText);
        container.add(Box.createVerticalStrut(10));
        container.add(createTitlePanel("Announceable clogs"));
        container.add(buildSearchTablePanel());

        panelMainContent.add(container);

        populateDiscordCountsAsync(stats);

        update();
    }

    private JPanel buildSearchTablePanel()
    {
        JPanel root = new JPanel();
        root.setOpaque(false);
        root.setLayout(new BoxLayout(root, BoxLayout.Y_AXIS));

        // ---------- Build rows ----------
        final List<Row> rows = new ArrayList<>(Constants.Pets.size() + Constants.ITEMS_WHITELIST.size());
        for (String p : Constants.Pets) rows.add(new Row("Pet", p));
        for (String i : Constants.ITEMS_WHITELIST) rows.add(new Row("Item", i));

        rows.sort((a, b) -> {
            int n = a.name.compareToIgnoreCase(b.name);
            return n != 0 ? n : a.type.compareToIgnoreCase(b.type);
        });

        final RowTableModel model = new RowTableModel(rows);

        // ---------- Search ----------
        final SuggestionTextField search = new SuggestionTextField();
        search.setToolTipText("Search (TAB accepts suggestion)");
        search.setFont(FontManager.getRunescapeSmallFont());
        search.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        search.setForeground(ColorScheme.TEXT_COLOR);
        search.setCaretColor(Color.WHITE);
        search.setBorder(BorderFactory.createEmptyBorder(6, 6, 6, 6));
        search.setFocusTraversalKeysEnabled(false); // capture TAB

        final JLabel count = new JLabel(rows.size() + " results", SwingConstants.LEFT);
        count.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        count.setFont(FontManager.getRunescapeSmallFont());
        count.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 0));

        JPanel searchWrap = new JPanel();
        searchWrap.setOpaque(false);
        searchWrap.setLayout(new BoxLayout(searchWrap, BoxLayout.Y_AXIS));
        searchWrap.add(search);
        searchWrap.add(Box.createVerticalStrut(2));
        searchWrap.add(count);

        root.add(searchWrap);
        root.add(Box.createVerticalStrut(4));

        // ---------- Table ----------
        final JTable table = new JTable(model);
        applyBaseTableStyle(table);

        // Column sizing
        table.getColumnModel().getColumn(0).setPreferredWidth(55);
        table.getColumnModel().getColumn(0).setMaxWidth(55);

        // Type column (center)
        table.getColumnModel().getColumn(0).setCellRenderer(new DefaultTableCellRenderer()
        {
            @Override
            public Component getTableCellRendererComponent(JTable t, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int col)
            {
                super.getTableCellRendererComponent(t, value, false, false, row, col);
                setHorizontalAlignment(SwingConstants.CENTER);
                setBackground(row % 2 == 0 ? ROW_B : ROW_A);
                setForeground(ColorScheme.TEXT_COLOR);
                setBorder(BorderFactory.createEmptyBorder());
                return this;
            }
        });

        // Name column (left, padded)
        table.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer()
        {
            @Override
            public Component getTableCellRendererComponent(JTable t, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int col)
            {
                super.getTableCellRendererComponent(t, value, false, false, row, col);
                setHorizontalAlignment(SwingConstants.LEFT);
                setBackground(row % 2 == 0 ? ROW_B : ROW_A);
                setForeground(ColorScheme.TEXT_COLOR);
                setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 0));
                return this;
            }
        });

        // Header styling
        JTableHeader header = table.getTableHeader();
        header.setReorderingAllowed(false);
        header.setResizingAllowed(false);
        header.setBorder(BorderFactory.createEmptyBorder());

        header.setDefaultRenderer(new TableCellRenderer()
        {
            private final DefaultTableCellRenderer r = new DefaultTableCellRenderer();

            @Override
            public Component getTableCellRendererComponent(JTable tbl, Object value,
                                                           boolean isSelected, boolean hasFocus,
                                                           int row, int col)
            {
                r.setOpaque(true);
                r.setBackground(ROW_A);
                r.setForeground(Color.WHITE);
                r.setFont(FontManager.getRunescapeSmallFont());
                r.setBorder(BorderFactory.createEmptyBorder());

                r.setText(value == null ? "" : value.toString());

                if (col == 1)
                {
                    r.setHorizontalAlignment(SwingConstants.LEFT);
                    r.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 0));
                }
                else
                {
                    r.setHorizontalAlignment(SwingConstants.CENTER);
                }

                return r;
            }
        });

        // ---------- Sorter + Filter ----------
        final TableRowSorter<RowTableModel> sorter = new TableRowSorter<>(model);
        table.setRowSorter(sorter);

        // Scrollpane style
        JScrollPane scroll = new JScrollPane(table);
        scroll.setBorder(BorderFactory.createEmptyBorder());
        scroll.setViewportBorder(BorderFactory.createEmptyBorder());
        scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scroll.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Clamp height: keep it inside RL panel
        scroll.setPreferredSize(new Dimension(0, 240));
        scroll.setMaximumSize(new Dimension(Integer.MAX_VALUE, 240));

        root.add(scroll);

        // ---------- Suggestion state ----------
        final String[] currentSuggestion = { null };

        // TAB commits suggestion
        search.getInputMap(JComponent.WHEN_FOCUSED).put(KeyStroke.getKeyStroke("TAB"), "acceptSuggestion");
        search.getActionMap().put("acceptSuggestion", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                String sugg = currentSuggestion[0];
                if (sugg == null) return;

                search.setText(sugg);
                search.setCaretPosition(sugg.length());
                search.setSuggestion(null);
            }
        });

        // Filtering + ghost suggestion computation
        Runnable apply = () -> {
            String q = search.getText();
            String qLower = q.trim().toLowerCase();

            if (qLower.isEmpty())
            {
                sorter.setRowFilter(null);
                count.setText(rows.size() + " results");
                currentSuggestion[0] = null;
                search.setSuggestion(null);
                return;
            }

            final String needle = qLower;

            sorter.setRowFilter(new RowFilter<>() {
                @Override
                public boolean include(Entry<? extends RowTableModel, ? extends Integer> entry) {
                    int modelRow = entry.getIdentifier();
                    Row r = model.getRow(modelRow);
                    return r.name.toLowerCase().contains(needle) || r.type.toLowerCase().contains(needle);
                }
            });

            count.setText(table.getRowCount() + " results");

            String sugg = findFirstPrefixSuggestion(rows, qLower);
            if (sugg != null && sugg.equalsIgnoreCase(q.trim())) sugg = null;

            currentSuggestion[0] = sugg;
            search.setSuggestion(sugg);
        };

        search.getDocument().addDocumentListener(new DocumentListener()
        {
            private void update() { SwingUtilities.invokeLater(apply); }
            @Override public void insertUpdate(DocumentEvent e) { update(); }
            @Override public void removeUpdate(DocumentEvent e) { update(); }
            @Override public void changedUpdate(DocumentEvent e) { update(); }
        });

        SwingUtilities.invokeLater(apply);

        return root;
    }

    private String findFirstPrefixSuggestion(List<Row> rows, String qLower)
    {
        if (qLower == null || qLower.isEmpty()) return null;

        for (Row r : rows)
        {
            String n = r.name.toLowerCase();
            if (n.startsWith(qLower))
            {
                return r.name;
            }
        }
        return null;
    }

    private static class Row
    {
        final String type;
        final String name;
        Row(String type, String name) { this.type = type; this.name = name; }
    }

    private static class RowTableModel extends AbstractTableModel
    {
        private final List<Row> rows;
        private final String[] cols = { "Type", "Name" };

        RowTableModel(List<Row> rows) { this.rows = rows; }

        Row getRow(int modelRow) { return rows.get(modelRow); }

        @Override public int getRowCount() { return rows.size(); }
        @Override public int getColumnCount() { return cols.length; }
        @Override public String getColumnName(int c) { return cols[c]; }
        @Override public Class<?> getColumnClass(int c) { return String.class; }

        @Override
        public Object getValueAt(int r, int c)
        {
            Row row = rows.get(r);
            return c == 0 ? row.type : row.name;
        }
    }

    /**
     * A JTextField that paints a "ghost" suggestion after the user's typed text.
     * The suggestion is purely cosmetic and does NOT affect the document content.
     */
    private static class SuggestionTextField extends JTextField
    {
        private String suggestion;

        public void setSuggestion(String suggestion)
        {
            this.suggestion = suggestion;
            repaint();
        }

        @Override
        protected void paintComponent(Graphics g)
        {
            super.paintComponent(g);

            if (suggestion == null) return;

            String typed = getText();
            if (typed == null) typed = "";

            // Only show ghost remainder when suggestion starts with typed text
            if (typed.isEmpty()) return;
            if (typed.length() >= suggestion.length()) return;

            String sugLower = suggestion.toLowerCase();
            String typedLower = typed.toLowerCase();
            if (!sugLower.startsWith(typedLower)) return;

            String remainder = suggestion.substring(typed.length());

            Graphics2D g2 = (Graphics2D) g.create();
            try
            {
                // Use a subtle color similar to placeholder text
                g2.setColor(new Color(180, 180, 180, 120)); // light + semi-transparent
                g2.setFont(getFont().deriveFont(Font.ITALIC));

                Insets insets = getInsets();
                FontMetrics fm = g2.getFontMetrics(getFont());

                // X position = start + width of typed text
                int x = insets.left + fm.stringWidth(typed);

                // Y position = baseline of text in field
                int y = (getHeight() - fm.getHeight()) / 2 + fm.getAscent();

                g2.drawString(remainder, x, y);
            }
            finally
            {
                g2.dispose();
            }
        }
    }

    private static JLabel getHelpText() {
        JLabel helpText = new JLabel(
                "<html><div style='text-align:center; line-height:1.3'>" +
                        "<b>Rankings • Events • Discussion</b><br>" +
                        "Join the clan community!" +
                        "</div></html>"
        );

        helpText.setAlignmentX(Component.CENTER_ALIGNMENT);
        helpText.setHorizontalAlignment(SwingConstants.CENTER);
        helpText.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        return helpText;
    }

    private JButton getCopyInvite(Color pressedColor, Color hoverColor) {
        JButton copyInvite = new JButton("Copy Invite");
        copyInvite.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        copyInvite.addMouseListener(new MouseAdapter()
        {
            @Override public void mousePressed(MouseEvent e) {
                copyInvite.setBackground(pressedColor);
            }
            @Override public void mouseReleased(MouseEvent e) {
                copyToClipboard(Constants.LINK_DISCORD);
                copyInvite.setBackground(hoverColor);
            }
            @Override public void mouseEntered(MouseEvent e) {
                copyInvite.setBackground(hoverColor);
                copyInvite.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }
            @Override public void mouseExited(MouseEvent e)  {
                copyInvite.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                copyInvite.setCursor(Cursor.getDefaultCursor());
            }
        });
        return copyInvite;
    }

    private static JButton getJoinDiscord(Color pressedColor, Color hoverColor) {
        JButton joinDiscord = new JButton("Join Discord");
        joinDiscord.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        joinDiscord.addMouseListener(new MouseAdapter()
        {
            @Override public void mousePressed(MouseEvent e) {
                joinDiscord.setBackground(pressedColor);
            }
            @Override public void mouseReleased(MouseEvent e) {
                LinkBrowser.browse(Constants.LINK_DISCORD);
                joinDiscord.setBackground(hoverColor);
            }
            @Override public void mouseEntered(MouseEvent e) {
                joinDiscord.setBackground(hoverColor);
                joinDiscord.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }
            @Override public void mouseExited(MouseEvent e)  {
                joinDiscord.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                joinDiscord.setCursor(Cursor.getDefaultCursor());
            }
        });
        return joinDiscord;
    }

    private void populateDiscordCountsAsync(JLabel statsLabel) {

        SwingWorker<DiscordCounts, Void> worker = new SwingWorker<>() {

            @Override
            protected DiscordCounts doInBackground() throws Exception {
                return fetchDiscordCounts();
            }

            @Override
            protected void done() {
                try {
                    DiscordCounts counts = get();

                    if (counts == null) {
                        statsLabel.setText("Discord stats unavailable");
                        return;
                    }

                    statsLabel.setText(
                            "<html><div style='text-align:center'>" +
                                    "👥 "
                                    + formatNumber(counts.members) + " members"
                                    + nonBreakingSpaces(5) +
                                    "<span style='color:#00ff00;'>⬤</span> "
                                    + formatNumber(counts.online) + " online" +
                                    "</div></html>"
                    );

                } catch (Exception e) {
                    statsLabel.setText("Discord stats unavailable.");
                    log.debug("Discord stats error", e);
                }
            }
        };

        worker.execute();
    }

    private String nonBreakingSpaces(int n)
    {
        return "&nbsp;".repeat(Math.max(0, n));
    }

    private void copyToClipboard(String text)
    {
        try
        {
            Toolkit.getDefaultToolkit()
                    .getSystemClipboard()
                    .setContents(new StringSelection(text), null);
        }
        catch (Exception ignored)
        {
            // ignored
        }
    }

    private void buildLeaderboardsPanel()
    {
        isInInfoPanel = false;
        panelMainContent.removeAll();
        panelMainContent.setLayout(new BorderLayout());

        // 1) show UI immediately (unpopulated)
        JPanel skeleton = buildTopChartsSkeleton();
        panelMainContent.add(skeleton, BorderLayout.CENTER);

        panelMainContent.revalidate();
        panelMainContent.repaint();

        // 2) populate afterward
        fetchAndPopulateTopChartsAsync();
    }

    private void buildModToolsPanel() {
        panelMainContent.removeAll();
        isInInfoPanel = false;
        panelMainContent.add(modToolsPanel);

        update();
    }

    private String normalizeSkillName(HiscoreSkill skill) {
        String name = skill.toString().toLowerCase();
        return Constants.NORMALIZED_NAMES.getOrDefault(name, name);
    }

    private JsonArray fetchSkillData(String name)
            throws IOException, InterruptedException
    {
        String url = Constants.URI_WOM_SKILL_LEADERS + name + Constants.URI_WOM_SKILL_LEADERS_LIMIT;
        String response = rateLimitedHttpCache.fetch(url);
        if (response == null) { return null; }

        JsonParser jsonParser = new JsonParser();
        JsonArray arr = jsonParser.parse(response).getAsJsonArray();

        return cleanSkillJson(arr);
    }


    private JsonArray cleanSkillJson(JsonArray arr) {
        JsonArray cleaned = new JsonArray();

        for (int i = 0; i < arr.size(); i++) {
            JsonObject obj = arr.get(i).getAsJsonObject();
            JsonObject player = obj.getAsJsonObject("player");
            JsonObject data = obj.getAsJsonObject("data");

            String username = player.get("username").getAsString().replace("\u00A0", " ");

            if (
                    (data.has("kills") && data.get("kills").getAsInt() <= 0) ||
                    (data.has("experience") && data.get("experience").getAsLong() <= 0) ||
                    (data.has("score") && data.get("score").getAsInt() <= 0)
            ) {
                break; // stop processing the rest of the array
            }

            if (!allMembersDisplayNames.containsKey(username)) {
                //log.debug("Removed unknown username {} ({})", i, username);
                continue; // skip this element, don’t add to cleaned array
            }

            cleaned.add(obj); // only valid elements are added
        }

        //log.debug("Array size after cleaning: {}", cleaned.size());

        return cleaned;
    }


    private static class PlayerRow {
        final int rank;
        final String name;
        final ImageIcon icon;
        final int level;
        final String exp;
        final boolean highlight;

        PlayerRow(int rank, String name, ImageIcon icon,
                  int level, String exp, boolean highlight)
        {
            this.rank = rank;
            this.name = name;
            this.icon = icon;
            this.level = level;
            this.exp = exp;
            this.highlight = highlight;
        }
    }

    private JLabel buildAutoSizedTitle(String text, int maxWidth, float startSize) {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);

        Font base = FontManager.getRunescapeBoldFont().deriveFont(startSize);
        FontMetrics fm = label.getFontMetrics(base);

        float size = startSize;
        while (fm.stringWidth(text) > maxWidth && size > 8f) {
            size -= 1f;
            base = base.deriveFont(size);
            fm = label.getFontMetrics(base);
        }

        label.setFont(base);
        return label;
    }


    private JPanel buildSkillHeader(HiscoreSkill skill) {
        JPanel header = new JPanel() {
            @Override
            public Dimension getMaximumSize() {
                return new Dimension(Integer.MAX_VALUE, super.getPreferredSize().height);
            }
        };
        header.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 5));
        header.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Skill icon
        JLabel iconLabel = new JLabel();
        BufferedImage clueImg = getClueScrollIcon(skill);

        if (clueImg != null) {
            BufferedImage scaled = ImageUtil.resizeImage(ImageUtil.resizeCanvas(clueImg, 25, 25), 30, 30);
            iconLabel.setIcon(new ImageIcon(scaled));
        }
        else {
            spriteManager.getSpriteAsync(
                    skill == null ? SpriteID.SideIcons.COMBAT : skill.getSpriteId(),
                    0,
                    sprite -> SwingUtilities.invokeLater(() -> {
                        BufferedImage scaled = ImageUtil.resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 30, 30);
                        iconLabel.setIcon(new ImageIcon(scaled));
                    })
            );
        }

        JLabel nameLabel = buildAutoSizedTitle(skill.getName(), 180, 18f);

        header.add(iconLabel);
        header.add(nameLabel);

        return header;
    }



    private static class PlayerTableModel extends AbstractTableModel {

        private List<PlayerRow> rows;
        private final String[] cols;

        PlayerTableModel(List<PlayerRow> rows, boolean skill, boolean boss)
        {
            this.rows = rows;
            this.cols = skill
                    ? new String[]{"#", "Player", "Level", "Exp"}
                    : boss ? new String[]{"#", "Player", "Kills"}
                    : new String[]{"#", "Player", "Total"};
        }

        void setRows(List<PlayerRow> newRows) {
            this.rows = newRows;
            fireTableDataChanged();
        }

        List<PlayerRow> getRows() {
            return rows;
        }

        @Override public int getRowCount() { return rows.size(); }
        @Override public int getColumnCount() { return cols.length; }
        @Override public String getColumnName(int c) { return cols[c]; }

        @Override
        public Object getValueAt(int r, int c)
        {
            PlayerRow row = rows.get(r);

            if (cols.length == 4) { // Skill
                switch(c) {
                    case 0: return row.rank;
                    case 1: return row;
                    case 2: return row.level;
                    case 3: return row.exp;
                }
            } else { // Boss / Activity
                switch(c) {
                    case 0: return row.rank;
                    case 1: return row;
                    case 2: return row.level; // kills or total
                }
            }

            return null;
        }


        @Override
        public Class<?> getColumnClass(int col)
        {
            return col == 0 || col == 2 ? Integer.class : Object.class;
        }
    }

    private void styleTable(JTable table, boolean isSkill) {
        applyBaseTableStyle(table);

        JTableHeader header = table.getTableHeader();
        header.setReorderingAllowed(false);
        header.setResizingAllowed(false);
        header.setBorder(BorderFactory.createEmptyBorder());

        // Header renderer
        header.setDefaultRenderer(new TableCellRenderer()
        {
            private final DefaultTableCellRenderer r = new DefaultTableCellRenderer();

            @Override
            public Component getTableCellRendererComponent(JTable tbl, Object value,
                                                           boolean isSelected, boolean hasFocus,
                                                           int row, int col)
            {
                r.setOpaque(true);
                r.setBackground(ROW_A);
                r.setForeground(Color.WHITE);
                r.setFont(FontManager.getRunescapeSmallFont());
                r.setBorder(BorderFactory.createEmptyBorder());

                r.setText(value == null ? "" : value.toString());

                // "#": center, "Player": left padded, rest center
                if (col == 1) {
                    r.setHorizontalAlignment(SwingConstants.LEFT);
                    r.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 0));
                } else {
                    r.setHorizontalAlignment(SwingConstants.CENTER);
                }

                return r;
            }
        });

        if (isSkill){
            table.getColumnModel().getColumn(0).setMaxWidth(30);  // #
            table.getColumnModel().getColumn(2).setMaxWidth(40);  // level/total
            table.getColumnModel().getColumn(3).setMaxWidth(40);  // exp
        }
        else {
            table.getColumnModel().getColumn(0).setMaxWidth(30);  // #
            table.getColumnModel().getColumn(2).setMaxWidth(40);  // kills/score
        }

        table.getColumnModel().getColumn(1).setCellRenderer(new PlayerRenderer());

        for (int col = 0; col < table.getColumnCount(); col++) {
            if (col != 1) {
                table.getColumnModel().getColumn(col).setCellRenderer(new DefaultTableCellRenderer() {
                    @Override
                    public Component getTableCellRendererComponent(
                            JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                        super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                        PlayerTableModel model = (PlayerTableModel) table.getModel();
                        PlayerRow playerRow = model.getRows().get(row);

                        if (playerRow.highlight) {
                            setForeground(Color.GREEN);
                        } else {
                            setForeground(ColorScheme.TEXT_COLOR);
                        }
                        setBackground(row % 2 == 0 ? ROW_B : ROW_A);

                        setHorizontalAlignment(SwingConstants.CENTER);
                        setBorder(BorderFactory.createEmptyBorder());
                        return this;
                    }
                });
            }
        }

        table.setFillsViewportHeight(true);

        table.setAutoResizeMode(isSkill
                ? JTable.AUTO_RESIZE_LAST_COLUMN
                : JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS);
    }
    @Nullable
    private static BufferedImage getClueScrollIcon(HiscoreSkill skill)
    {
        if (skill == null)
            return null;

        switch (skill)
        {
            case CLUE_SCROLL_BEGINNER: return Icons.CLUE_SCROLL_BEGINNER;
            case CLUE_SCROLL_EASY:     return Icons.CLUE_SCROLL_EASY;
            case CLUE_SCROLL_MEDIUM:   return Icons.CLUE_SCROLL_MEDIUM;
            case CLUE_SCROLL_HARD:     return Icons.CLUE_SCROLL_HARD;
            case CLUE_SCROLL_ELITE:    return Icons.CLUE_SCROLL_ELITE;
            case CLUE_SCROLL_MASTER:   return Icons.CLUE_SCROLL_MASTER;
            default: return null;
        }
    }



    private static class PlayerRenderer extends DefaultTableCellRenderer {
        @Override
        public Component getTableCellRendererComponent(
                JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int col)
        {
            super.getTableCellRendererComponent(table, "", false, false, row, col);

            // Always reset everything (renderer is reused)
            setIcon(null);
            setText("");
            setHorizontalAlignment(LEFT);
            setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 0));

            // Default row striping
            setForeground(ColorScheme.TEXT_COLOR);
            setBackground(row % 2 == 0 ? ROW_B : ROW_A);

            PlayerRow pr = value instanceof PlayerRow ? (PlayerRow) value : null;
            if (pr != null)
            {
                setText(" " + pr.name);
                setIcon(pr.icon);

                if (pr.highlight)
                {
                    setForeground(Color.GREEN);
                }
            }

            return this;
        }
    }

    private static class DiscordCounts {
        final int members;
        final int online;

        DiscordCounts(int members, int online) {
            this.members = members;
            this.online = online;
        }
    }

    private DiscordCounts fetchDiscordCounts() throws IOException, InterruptedException {
        String response = rateLimitedHttpCache.fetch(Constants.LINK_DISCORD_API);
        if (response == null) {
            return null;
        }

        JsonParser jsonParser = new JsonParser();
        JsonObject obj = jsonParser.parse(response).getAsJsonObject();

        int members = obj.has("approximate_member_count") ? obj.get("approximate_member_count").getAsInt() : -1;
        int online  = obj.has("approximate_presence_count") ? obj.get("approximate_presence_count").getAsInt() : -1;

        return new DiscordCounts(members, online);
    }


    public class RateLimitedHttpCache {

        private static final long TTL_MILLIS = 60 * 1000; // 1 minute
        private final ConcurrentHashMap<String, CachedItem> cache = new ConcurrentHashMap<>();
        private final Semaphore rateLimiter;
        private final ScheduledExecutorService scheduler;


        private class CachedItem {
            final String response;
            final long timestamp;

            CachedItem(String response, long timestamp) {
                this.response = response;
                this.timestamp = timestamp;
            }
        }

        public RateLimitedHttpCache(int maxRequests, int refillIntervalSeconds) {
            this.rateLimiter = new Semaphore(maxRequests);
            this.scheduler = Executors.newScheduledThreadPool(1);

            // Refill one token every interval
            scheduler.scheduleAtFixedRate(() -> {
                if (rateLimiter.availablePermits() < maxRequests) {
                    rateLimiter.release();
                }
            }, refillIntervalSeconds, refillIntervalSeconds, TimeUnit.SECONDS);
        }

        /**
         * Fetch a URL: returns cached response if fresh.
         * Returns null if rate limit has been exhausted.
         */
        public String fetch(String url) throws IOException {
            CachedItem item = cache.get(url);
            long now = System.currentTimeMillis();

            if (item != null && now - item.timestamp < TTL_MILLIS) {
                return item.response;
            }

            // Non-blocking check for rate limiter
            boolean allowed = rateLimiter.tryAcquire();
            if (!allowed) {
                // Rate limit exhausted → return null immediately
                log.debug("no more tokens available");
                return null;
            }

            Request request = new Request.Builder()
                    .url(url)
                    .get()
                    .build();

            Call call = httpClient.newCall(request);

            try (Response response = call.execute())
            {
                if (!response.isSuccessful())
                {
                    log.debug("HTTP error {} for {}", response.code(), url);
                    return null;
                }

                ResponseBody body = response.body();
                if (body == null)
                {
                    return null;
                }

                String responseBody = body.string();
                cache.put(url, new CachedItem(responseBody, now));
                return responseBody;
            }
        }

        public void shutdown() {
            scheduler.shutdown();
        }
    }

}

package com.oneshot;

import com.oneshot.modules.DiaryImages;
import com.oneshot.modules.DiscordClient;
import com.oneshot.modules.ModTools;
import com.oneshot.modules.ModToolsPanel;
import com.oneshot.utils.Constants;
import com.oneshot.utils.Icons;

import com.google.inject.Provides;

import net.runelite.api.*;
import net.runelite.api.annotations.Component;
import net.runelite.api.clan.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.ClientToolbar;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.concurrent.CompletableFuture;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;

import net.runelite.client.util.Text;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static net.runelite.api.Experience.MAX_REAL_LEVEL;

@PluginDescriptor(
	name = Constants.PLUGIN_NAME
)

public class OneShotPlugin extends Plugin
{
    private static final Logger log = LoggerFactory.getLogger(OneShotPlugin.class);

    @Inject
    private ModTools modTools;

    @Inject
	private Client client;

    @Inject
    private OneShotConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ChatIconManager chatIconManager;

    @Inject
    private DrawManager drawManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private DiscordClient discordClient;

    @Inject
    private ConfigManager configManager;

    private static final String CURRENT_VERSION = "v1.2.0"; // bump when releasing

    private boolean isMember = false;
    private boolean isModerator = false;

    private NavigationButton navButton;
    private OneShotPanel panel;
    private ModToolsPanel modToolsPanel;

    private CompletableFuture<Image> pendingDeathScreenshot = null;
    private String pendingDeathKiller = null;
    private boolean deathAwaitingVarbit = false;

    private volatile boolean levelsInitialized = false;
    private volatile boolean diariesInitialized = false;
    private final Map<String, Integer> currentLevels = new HashMap<>();
    private final Map<Skill, Integer> currentXp = new EnumMap<>(Skill.class);
    public static final int LEVEL_FOR_MAX_XP = Experience.MAX_VIRT_LEVEL + 1; // 127
    private static final Set<WorldType> SPECIAL_WORLDS = Set.of(WorldType.PVP_ARENA, WorldType.QUEST_SPEEDRUNNING, WorldType.BETA_WORLD, WorldType.NOSAVE_MODE, WorldType.TOURNAMENT_WORLD, WorldType.DEADMAN, WorldType.SEASONAL);
    private static final int LOGIN_IGNORE_TICKS = 5;
    private int ticksSinceLogin = LOGIN_IGNORE_TICKS;
    private final Map<Integer, Integer> lastVarbitValues = new HashMap<>();

    private String clanRankName;

    private static final Pattern COLLECTION_LOG_ITEM_REGEX = Pattern.compile("New item added to your collection log:.*");
    private static final String COLLECTION_LOG_TEXT = "New item added to your collection log: ";
//    private static final Pattern PET_LOG_ITEM_REGEX = Pattern.compile("You (?:have a funny feeling like you|feel something weird sneaking).*");
    private static final Pattern COMBAT_TIER_REGEX = Pattern.compile("You've completed enough Combat Achievement tasks to unlock (\\w+) Tier rewards!.*");
//    private static final Pattern COMPLETION_REGEX = Pattern.compile("Congratulations! You have completed all of the (?<difficulty>.+) tasks in the (?<area>.+) area");

    @Provides
    OneShotConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(OneShotConfig.class);
    }

    @Override
    protected void startUp() {
        log.debug("Startup");

        clientThread.invoke(() ->
        {
            panel = injector.getInstance(OneShotPanel.class);
            modToolsPanel = injector.getInstance(ModToolsPanel.class);
            panel.init(client, clientThread, modToolsPanel, config);

            ClanChannel clan = client.getClanChannel();
            if (clan != null)
            {
                ClanChannelMember local = clan.findMember(client.getLocalPlayer().getName());

                if (local != null)
                {
                    ClanRank clanRank = local.getRank();
                    ClanSettings clanSettings = client.getClanSettings();
                    ClanTitle clanTitle = clanSettings.titleForRank(clanRank);

                    this.clanRankName = mapRankTitle(clanTitle);

                    boolean moderator = isModerator(clanRank);
                    isMember = true;
                    isModerator = moderator;

                    if (moderator)
                        modTools.init(modToolsPanel);

                    try {
                        panel.buildMainPanel(
                                moderator,
                                client.getLocalPlayer().getName(),
                                mapRankTitle(clanTitle),
                                getAllMembersInfo(),
                                getMembersIcons(),
                                getMembersDisplayName()
                        );
                    } catch (IOException | InterruptedException e) {
                        log.error(e.getMessage());
                    }
                }
            }

            // UI BUTTON MUST BE ADDED ON SWING THREAD
            SwingUtilities.invokeLater(() -> {
                navButton = NavigationButton.builder()
                        .tooltip(Constants.PLUGIN_NAME)
                        .icon(Icons.RED_HELM_IMAGE)
                        .priority(Constants.DEFAULT_PRIORITY)
                        .panel(panel)
                        .build();

                clientToolbar.addNavigation(navButton);
            });
        });
    }


    @Override
	protected void shutDown() {
        log.debug("Shutdown");
        panel.deinit();
        clientToolbar.removeNavigation(navButton);
        panel = null;
        navButton = null;
	}

    private void updateClanPanel() throws IOException, InterruptedException
    {
        if (!isMember)
            return;

        ClanChannel clan = client.getClanChannel();
        if (clan == null)
            return;

        ClanChannelMember local = clan.findMember(client.getLocalPlayer().getName());
        if (local == null)
            return;

        ClanRank rank = local.getRank();
        ClanSettings settings = client.getClanSettings();
        ClanTitle title = settings.titleForRank(rank);

        isModerator = isModerator(rank);

        panel.refresh(
                isModerator,
                client.getLocalPlayer().getName(),
                mapRankTitle(title),
                getAllMembersInfo(),
                getMembersIcons(),
                getMembersDisplayName()
        );
    }

    private void sendGameMessage(String msg)
    {
        clientThread.invoke(() ->
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null)
        );
    }


    private void checkAndAnnouncePluginUpdate()
    {
        // Read what is actually stored (may be null if never set)
        String stored = configManager.getConfiguration(OneShotConfig.GROUP, "version");

        // If nothing stored yet, treat as "first run"
        if (stored == null)
        {
            configManager.setConfiguration(OneShotConfig.GROUP, "version", CURRENT_VERSION);
            return;
        }

        if (!CURRENT_VERSION.equals(stored))
        {
            sendGameMessage("One Shot updated to " + CURRENT_VERSION + "!");

            // Persist so it doesn't spam next login
            configManager.setConfiguration(OneShotConfig.GROUP, "version", CURRENT_VERSION);
        }
    }



    @Subscribe
    public void onClanMemberJoined(ClanMemberJoined e) throws IOException, InterruptedException
    {
        updateClanPanel();
    }

    @Subscribe
    public void onClanMemberLeft(ClanMemberLeft e) throws IOException, InterruptedException
    {
        updateClanPanel();
    }


    @Subscribe
    public void onClanChannelChanged(ClanChannelChanged clanChannelChanged) throws IOException, InterruptedException {
        ClanChannel channel = clanChannelChanged.getClanChannel();

        if (channel == null)
        {
            panel.buildIntroPanel();
            isMember = false;
            isModerator = false;
            return;
        }

        String clanName = channel.getName();
        panel.buildIntroPanel();

        // Not One Shot CC
        if (!isOneShotMember(clanName))
        {
            panel.changeIntroText1("You are not part of One Shot CC");
            panel.changeIntroText2("You don't have access, sorry");

            isMember = false;
            isModerator = false;
            return;
        }

        // Guest of One Shot
        if (clanChannelChanged.isGuest())
        {
            panel.changeIntroText1("You are currently a guest of One Shot");
            panel.changeIntroText2("Become a member today!");

            isMember = false;
            isModerator = false;
            return;
        }

        // REAL MEMBER
        String playerName = client.getLocalPlayer().getName();
        ClanSettings settings = Objects.requireNonNull(client.getClanSettings());
        ClanRank rank = Objects.requireNonNull(settings.findMember(playerName)).getRank();
        ClanTitle title = Objects.requireNonNull(settings.titleForRank(rank));

        isMember = true;
        isModerator = isModerator(rank);

        if (isModerator)
            modTools.init(modToolsPanel);

        panel.buildMainPanel(
                isModerator,
                playerName,
                mapRankTitle(title),
                getAllMembersInfo(),
                getMembersIcons(),
                getMembersDisplayName()
        );
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged e) throws IOException
    {
        if (!isMember)
            return;

        int id = e.getVarbitId();
        int value = e.getValue();

        // -----------------------------------------------------
        // 1. HANDLE HCIM DEATH VARBIT
        // -----------------------------------------------------
        handleHardcoreDeathVarbit(id);

        // -----------------------------------------------------
        // 2. HANDLE DIARY COMPLETION VARBITS
        // -----------------------------------------------------
        if (diariesInitialized)
            handleDiaryVarbit(id, value);
    }

    private void handleHardcoreDeathVarbit(int id)
    {
        if (id != VarbitID.IRONMAN_HARDCORE_DEAD)
            return;

        if (!deathAwaitingVarbit)
            return;

        log.debug("HCIM death varbit triggered!");

        if (config.announceDeaths() && discordAnnouncementsEnabled() && isMember)
        {
            CompletableFuture<Image> screenshotFuture =
                    (config.announceDeathsScreenshot() && pendingDeathScreenshot != null)
                            ? pendingDeathScreenshot
                            : CompletableFuture.completedFuture(null);

            screenshotFuture.thenAccept(img -> {
                try
                {
                    discordClient.sendDeath(
                            pendingDeathKiller != null ? pendingDeathKiller : "",
                            CompletableFuture.completedFuture(img)
                    );
                }
                catch (Exception ex)
                {
                    log.error("Failed sending HCIM death notification", ex);
                }
            });
        }

        // Reset death-tracking state
        deathAwaitingVarbit = false;
        pendingDeathScreenshot = null;
        pendingDeathKiller = null;
    }

    private void handleDiaryVarbit(int varbitId, int newValue) throws IOException {
        if (!Constants.ACHIEVEMENT_DIARIES_COMPLETE_VARBITS.contains(varbitId))
            return;

        if (newValue == 0)
            return;

        Integer oldValue = lastVarbitValues.put(varbitId, newValue);

        if (oldValue == null || oldValue.equals(newValue))
            return;

        log.debug("ID: {} - Val: {}->{} - Area: {} - Tier: {}",
                varbitId,
                oldValue,
                newValue,
                DiaryImages.getDiaryInfo(varbitId).getArea(),
                DiaryImages.getDiaryInfo(varbitId).getTier()
        );

        if (!config.announceDiaries() || !discordAnnouncementsEnabled() || !isMember)
            return;

        if (isDiaryComplete(varbitId, newValue))
        {
            DiaryImages.DiaryInfo info = DiaryImages.getDiaryInfo(varbitId);

            if (info == null)
            {
                log.warn("Missing diary mapping for varbit {}", varbitId);
                return;
            }

            discordClient.sendAchievementDiary(info.getArea(), info.getTier());
        }
    }

    public static boolean isDiaryComplete(int id, int value) {
        if (id == VarbitID.ATJUN_EASY_DONE || id == VarbitID.ATJUN_MED_DONE || id == VarbitID.ATJUN_HARD_DONE) {
            // Karamja special case (except Elite): 0 = not started, 1 = started, 2 = completed tasks
            return value > 1;
        } else {
            // otherwise: 0 = not started, 1 = completed
            return value > 0;
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath actorDeath)
    {
        if (!isMember && !config.announceDeaths()) return;
        if (!discordAnnouncementsEnabled()) return;

        Actor actor = actorDeath.getActor();

        if (!(actor instanceof Player))
            return;

        Player player = (Player) actor;

        if (player != client.getLocalPlayer())
            return;

        // Save the killer’s name (may be null)
        Actor killer = actor.getInteracting();
        pendingDeathKiller = (killer != null) ? killer.getName() : "";

        // Capture screenshot now
        pendingDeathScreenshot = discordClient.getScreenshot(0, config.announceDeathsChatPrivacy());

        // Signal that a death has occurred
        deathAwaitingVarbit = true;

        log.debug("Player death recorded; waiting for HCIM varbit.");
    }

    public static boolean hideWidget(boolean shouldHide, Client client, @net.runelite.api.annotations.Component int info) {
        if (!shouldHide)
            return false;

        Widget widget = client.getWidget(info);
        log.debug(widget.getName());
        if (widget == null || widget.isHidden())
            return false;

        widget.setHidden(true);
        return true;
    }

    public static void unhideWidget(boolean shouldUnhide, Client client, ClientThread clientThread, @Component int info) {
        if (!shouldUnhide)
            return;

        clientThread.invoke(() -> {
            Widget widget = client.getWidget(info);
            if (widget != null)
                widget.setHidden(false);
        });
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) throws IOException {
        if (!isMember || !discordAnnouncementsEnabled()) return;
        // quest
        if (event.getGroupId() == InterfaceID.QUESTSCROLL && config.announceQuests()) {
            Widget quest = client.getWidget(InterfaceID.Questscroll.QUEST_TITLE);
            if (quest != null) {
                String questText = quest.getText();
                log.debug(questText);
                // 1 tick delay to ensure relevant varbits have been processed by the client
                discordClient.sendQuest(questText);
            }
        }
    }


    @Subscribe
    public void onChatMessage(ChatMessage event) throws IOException {
        if (!isMember) return;
        if (!discordAnnouncementsEnabled()) return;
        if ((event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)) return;

        String inputMessage = event.getMessage();
        String outputMessage = Text.removeTags(inputMessage);
        String item;

        boolean isCollectionLog = COLLECTION_LOG_ITEM_REGEX.matcher(outputMessage).matches();
        boolean isCombatAchievement = COMBAT_TIER_REGEX.matcher(outputMessage).matches();

        if (isCollectionLog)
        {
            item = outputMessage.substring(COLLECTION_LOG_TEXT.length());
            boolean isPet = Constants.Pets.contains(item);
            if (isPet && config.announcePets())  discordClient.sendPet(item);
            if (!isPet && config.announceCollectionLogs()) discordClient.sendLootDrop(item);
        }

        if (isCombatAchievement && config.announceCombatAchievements())
            discordClient.sendCombatAchievement(parseCombatTier(outputMessage));

    }

    private boolean isInSpecialWorld()
    {
        final Set<WorldType> types = client.getWorldType();
        if (types == null || types.isEmpty()) { return false; }

        for (WorldType t : types)
        {
            if (SPECIAL_WORLDS.contains(t)) { return true; }
        }
        return false;
    }

    private boolean discordAnnouncementsEnabled() { return !isInSpecialWorld(); }

    @Nullable
    public static String parseCombatTier(String message)
    {
        Matcher m = COMBAT_TIER_REGEX.matcher(message);
        if (m.find())
        {
            return m.group(1);
        }
        return null;
    }

    @Subscribe
    public void onStatChanged(StatChanged statChange) throws IOException {
        if (!isMember || !discordAnnouncementsEnabled()) return;
        handleLevelUp(statChange.getSkill(), statChange.getLevel(), statChange.getXp());
    }

    @Subscribe
    public void onGameTick(final GameTick tick) throws IOException, InterruptedException
    {
        if (!isMember)
            return;

        updateRankAndPanel();
        discordClient.onGameTick();

        handleLoginInitialization();
    }

    private void updateRankAndPanel() throws IOException, InterruptedException
    {
        ClanChannel clan = client.getClanChannel();
        if (clan == null)
            return;

        ClanChannelMember local = clan.findMember(client.getLocalPlayer().getName());
        if (local == null)
            return;

        ClanRank rank = local.getRank();
        ClanTitle title = client.getClanSettings().titleForRank(rank);

        String newRankName = mapRankTitle(title);

        // Only update interface if rank actually changed
        if (!Objects.equals(newRankName, clanRankName))
        {
            boolean nowModerator = isModerator(rank);

            if (this.isModerator != nowModerator)
            {
                this.isModerator = nowModerator;
                if (nowModerator) modTools.init(modToolsPanel);
            }

            panel.refresh(
                    nowModerator,
                    client.getLocalPlayer().getName(),
                    newRankName,
                    getAllMembersInfo(),
                    getMembersIcons(),
                    getMembersDisplayName()
            );

            clanRankName = newRankName;
        }
    }

    private void handleLoginInitialization()
    {
        //log.debug(String.format("%d <> %d", ticksSinceLogin, LOGIN_IGNORE_TICKS));
        if (ticksSinceLogin >= LOGIN_IGNORE_TICKS)
            return;

        ticksSinceLogin++;

        if (ticksSinceLogin == LOGIN_IGNORE_TICKS)
        {
            clientThread.invoke(this::initLevels);
            clientThread.invoke(this::initDiaries);
            clientThread.invoke(this::initCollectionLogs);
        }
    }

    private void initCollectionLogs() {
        int collectionlogs = client.getVarpValue(VarPlayerID.COLLECTION_COUNT);
//        log.debug(String.format("initCollectionLogs: %d",collectionlogs));
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
        if (gameStateChanged.getGameState() == GameState.LOADING) return;
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
            this.resetLevels();
            this.resetDiaries();
            panel.buildIntroPanel();
        } else if (gameStateChanged.getGameState() == GameState.LOGGED_IN && !SPECIAL_WORLDS.contains(client.getWorldType())) {
            ticksSinceLogin = 0;
            clientThread.invoke(this::initLevels);
            clientThread.invoke(this::initDiaries);

            checkAndAnnouncePluginUpdate();
        }
    }

    private void initLevels() {
        // make sure we run on client thread - if not, re-schedule and return
        if (!client.isClientThread())
        {
            clientThread.invoke(this::initLevels);
            return;
        }
//        log.debug("Levels initialized");

        currentXp.clear();
        currentLevels.clear();

        for (Skill skill : Skill.values()) {
            int xp = client.getSkillExperience(skill);
            int level = client.getRealSkillLevel(skill); // O(1)
            if (level >= MAX_REAL_LEVEL) {
                level = getLevel(xp);
            }
            currentLevels.put(skill.getName(), level);
            currentXp.put(skill, xp);
        }

        levelsInitialized = true; // <-- only set after maps are populated
        //log.debug("Initialized current skill levels: {}", currentLevels);
    }

    private void initDiaries() {
        // make sure we run on client thread - if not, re-schedule and return
        diariesInitialized = false;
        if (!client.isClientThread())
        {
            clientThread.invoke(this::initDiaries);
            return;
        }
//        log.debug("Diaries initialized");

        Integer value = null;
        currentLevels.clear();

        for (int varbitID : Constants.ACHIEVEMENT_DIARIES_COMPLETE_VARBITS)
        {
            value = lastVarbitValues.put(varbitID, client.getVarbitValue(varbitID));
            //log.debug(String.format("Init varbit %d with value %d",varbitID,value));
        }

        if (value == null)
        {
            ticksSinceLogin = 0;
            return;
        }

        for (Skill skill : Skill.values()) {
            int xp = client.getSkillExperience(skill);
            int level = client.getRealSkillLevel(skill); // O(1)
            if (level >= MAX_REAL_LEVEL) {
                level = getLevel(xp);
            }
            currentLevels.put(skill.getName(), level);
            currentXp.put(skill, xp);
        }
        diariesInitialized = true; // <-- only set after maps are populated
    }




    private int getLevel(int xp) {
        // treat 200M XP as level 127
        if (xp >= Experience.MAX_SKILL_XP)
            return LEVEL_FOR_MAX_XP;

        // log(n) operation to support virtual levels
        return Experience.getLevelForXp(xp);
    }

    public void resetLevels() {
        levelsInitialized = false;

        clientThread.invoke(() -> {
            currentXp.clear();
            currentLevels.clear();
            levelsInitialized = false;
            log.debug("resetLevels: cleared level state on client thread");
        });
    }

    public void resetDiaries() {
        lastVarbitValues.clear();
        diariesInitialized = false;
    }

    private void handleLevelUp(Skill skill, int level, int xp) throws IOException {
        if (ticksSinceLogin < LOGIN_IGNORE_TICKS)
        {
            log.debug("Ignoring StatChanged on login: {}", skill);
            return;
        }

        if (xp <= 0 || level <= 1) return;

        if (!levelsInitialized) {
            // optionally track ticks to force init later, but do not process level-ups
            log.debug("Ignoring StatChanged for {} while levels not initialised", skill);
            return;
        }


        Integer previousXp = currentXp.put(skill, xp);
        if (previousXp == null) {
            return;
        }

        String skillName = skill.getName();
        int virtualLevel = level < MAX_REAL_LEVEL ? level : getLevel(xp); // avoid log(n) query when not needed
        Integer previousLevel = currentLevels.put(skillName, virtualLevel);


        if (previousLevel == null || previousLevel == 0) {
            return;
        }

        if (virtualLevel < previousLevel || xp < previousXp) {
            // base skill level should never regress; reset notifier state
            resetLevels();
            return;
        }

        int totalLevel = client.getTotalLevel();

        // Check normal skill level up for only 99 and maxed
        if (virtualLevel > previousLevel && virtualLevel <= MAX_REAL_LEVEL) {
            if (totalLevel == Constants.MAX_TOTAL_LEVEL && config.announceMaxed()) {
                discordClient.sendLevelMaxed(totalLevel);
            }
            else if (config.announceLevel()) {
                discordClient.sendLevelUp(skill, virtualLevel);
            }
        }

        // 200M XP announcement (independent of level-up)
        if (level >= MAX_REAL_LEVEL
                && xp > previousXp
                && xp >= Experience.MAX_SKILL_XP
                && config.announce200M())
        {
            discordClient.sendXP200(skill);
        }
    }

    public ImageIcon getRankIcon(ClanTitle clanTitle)
    {
        BufferedImage chatIcon = chatIconManager.getRankImage(clanTitle);
        assert chatIcon != null;
        return new ImageIcon(chatIcon.getScaledInstance(Constants.TEXT_ICON_SIZE, Constants.TEXT_ICON_SIZE, Image.SCALE_DEFAULT));
    }

    private static boolean isModerator(ClanRank clanRank)
    {
        return Arrays.asList(Constants.RANK_OWNER, Constants.RANK_DEPUTY_OWNER, Constants.RANK_ASTRAL,
                Constants.RANK_CAPTAIN).contains(clanRank);
    }

    private static boolean isOneShotMember(String clanName)
    {
        return Objects.equals(clanName, Constants.CLAN_NAME);
    }

    private ArrayList<OneShotMember> getAllMembersInfo() {

        ArrayList<OneShotMember> oneShotMembers = new ArrayList<>();
        ArrayList<Integer> tmpIndexList = new ArrayList<>();

        // checks all members offline and online
        ClanSettings clanSettings = client.getClanSettings();
        assert clanSettings != null;
        java.util.List<ClanMember> clanMembers = clanSettings.getMembers();

        for (ClanMember clanMember : clanMembers)
        {
            ClanRank clanRank = clanMember.getRank();
            int index = clanRank.getRank();
            if (!tmpIndexList.contains(index))
            {
                tmpIndexList.add(index);
                ClanTitle clanTitle = clanSettings.titleForRank(clanRank);
                String displayTitle = mapRankTitle(clanTitle);

                OneShotMember oneShotMember = new OneShotMember(index, clanTitle, displayTitle);
                oneShotMember.addTotal();
                oneShotMembers.add(oneShotMember);
            }
            else
            {
                for (OneShotMember oneShotMember : oneShotMembers)
                {
                    if (oneShotMember.index == index)
                    {
                        oneShotMember.addTotal();
                    }
                }
            }
        }

        // checks for online members only
        ClanChannel clanChannel = client.getClanChannel();
        assert clanChannel != null;
        List<ClanChannelMember> clanChannelMembers = clanChannel.getMembers();

        for (ClanChannelMember clanChannelMember : clanChannelMembers)
        {
            int index = clanChannelMember.getRank().getRank();
            for (OneShotMember oneShotMember : oneShotMembers)
            {
                if (oneShotMember.index == index)
                {
                    oneShotMember.addOnline();
                }
            }
        }

        oneShotMembers.sort(Comparator.comparing(OneShotMember::getIndex).reversed());

        return oneShotMembers;
    }

    private String mapRankTitle(ClanTitle title)
    {
        if (title == null)
        {
            return "Unknown";
        }

        switch (title.getName())
        {
            case "Owner":
                return "Founder";

            case "Deputy Owner":
                return "Co-Founder";

            case "Astral":
                return "Administrator";

            case "Captain":
                return "Moderator";

            case "Lieutenant":
                return "Trial Moderator";

            case "Witch":
                return "Event Team";

            default:
                return title.getName();
        }
    }


    private Map<String, ImageIcon> getMembersIcons()
    {
        Map<String, ImageIcon> Members = new HashMap<>();

        ClanSettings clanSettings = client.getClanSettings();
        assert clanSettings != null;
        java.util.List<ClanMember> clanMembers = clanSettings.getMembers();

        for (ClanMember clanMember : clanMembers)
        {
            String memberName = clanMember.getName();
//            log.debug(memberName.toLowerCase().replace(" ", " ") + ": " + convertToHexString(memberName.toLowerCase().replace(" ", " ").getBytes()));
            ImageIcon icon = getRankIcon(clanSettings.titleForRank(clanMember.getRank()));
            Members.put(memberName.toLowerCase().replace(" ", " "), icon);
        }
        return Members;
    }

    private Map<String, String> getMembersDisplayName()
    {
        Map<String, String> Members = new HashMap<>();

        ClanSettings clanSettings = client.getClanSettings();
        assert clanSettings != null;
        java.util.List<ClanMember> clanMembers = clanSettings.getMembers();

        for (ClanMember clanMember : clanMembers)
        {
            String memberName = clanMember.getName();
            Members.put(memberName.toLowerCase().replace(" ", " "), memberName);
        }
        return Members;
    }

    public class OneShotMember {
        int index;
        ImageIcon icon;
        String name;
        int online = 0;
        int total = 0;

        public OneShotMember(int index, ClanTitle clanTitle, String displayTitle)
        {
            this.index = index;
            this.icon = getRankIcon(clanTitle);
            this.name = displayTitle;
        }

        public void addOnline()
        {
            this.online++;
        }

        public void addTotal()
        {
            this.total++;
        }

        public String toString()
        {
            return name + " | " + online + " | " + total;
        }

        public int getIndex()
        {
            return index;
        }

        public ImageIcon getIcon()
        {
            return icon;
        }

        public String getName()
        {
            return name;
        }

        public int getOnline()
        {
            return online;
        }

        public int getTotal()
        {
            return total;
        }
    }


}


package com.oneshot.utils;


import com.google.common.collect.ImmutableList;
import lombok.Getter;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.hiscore.HiscoreSkill;

import java.awt.*;
import java.util.*;
import java.util.List;

import static net.runelite.client.hiscore.HiscoreSkill.*;


public class Constants {
    public static final String PLUGIN_NAME = "One Shot";
    public static final String CLAN_NAME = "One Shot";
    public static final int DEFAULT_PRIORITY = 5;

    public static String WORKER_URL = "https://runelite-webhook-api.pqnarte.workers.dev/send";

    // Panel
    public static final String LINK_DISCORD = "https://www.discord.gg/one-shot";
    public static final String LINK_DISCORD_API = "https://discord.com/api/invites/one-shot?with_counts=true";
    public static final int BUTTON_SIZE = 40;
    public static final int TEXT_ICON_SIZE = 12;

    // WiseOldMan Links
    public static final String URI_WOM_LEADERS = "https://api.wiseoldman.net/v2/groups/2647/statistics";
    public static final String URI_WOM_LEADERS_OBJECT = "metricLeaders";
    public static final String URI_WOM_SKILL_LEADERS = "https://api.wiseoldman.net/v2/groups/2647/hiscores?metric=";
    public static final String URI_WOM_SKILL_LEADERS_LIMIT = "&limit=500";

    // clan moderators
    public static final ClanRank RANK_OWNER = new ClanRank(126);
    public static final ClanRank RANK_DEPUTY_OWNER = new ClanRank(125);
    public static final ClanRank RANK_ASTRAL = new ClanRank(120);
    public static final ClanRank RANK_CAPTAIN = new ClanRank(115);

    // Discord Embeds
    public static final Color DISCORD_LEVELS_COLOR = EmbedColors.NEON_GREEN;
    public static final Color DISCORD_DIARIES_COLOR = EmbedColors.WHITE;
    public static final Color DISCORD_COMBAT_ACHIEVEMENTS_COLOR = EmbedColors.PURPLE;
    public static final Color DISCORD_QUESTS_COLOR = EmbedColors.NEON_BLUE;
    public static final Color DISCORD_PETS_COLOR = EmbedColors.NEON_PINK;
    public static final Color DISCORD_LOOT_COLOR = EmbedColors.NEON_YELLOW;
    public static final Color DISCORD_DEATHS_COLOR = EmbedColors.DARK_RED;

    public static final int DISCORD_THUMBNAIL_SIZE = 25;
    public static final int DISCORD_AUTHOR_ICON_SIZE = 20;
    public static final double DISCORD_AUTHOR_ICON_SCALE = 0.7;

    public static final String WIKI_SEARCH = "https://oldschool.runescape.wiki/w/Special:Search?search=";
    public static final String WIKI_COMBAT_ACHIEVEMENTS_REWARDS = "https://oldschool.runescape.wiki/w/Combat_Achievements#Rewards";

    public static final int MAX_TOTAL_LEVEL = 2376;



    //Real skills, ordered in the way they should be displayed in the panel.
    public static final List<HiscoreSkill> SKILLS = ImmutableList.of(
            ATTACK, HITPOINTS, MINING,
            STRENGTH, AGILITY, SMITHING,
            DEFENCE, HERBLORE, FISHING,
            RANGED, THIEVING, COOKING,
            PRAYER, CRAFTING, FIREMAKING,
            MAGIC, FLETCHING, WOODCUTTING,
            RUNECRAFT, SLAYER, FARMING,
            CONSTRUCTION, HUNTER, SAILING
    );

    //Bosses, ordered in the way they should be displayed in the panel.
    public static final List<HiscoreSkill> BOSSES = ImmutableList.of(
            ABYSSAL_SIRE, ALCHEMICAL_HYDRA, AMOXLIATL,
            ARAXXOR, ARTIO, BARROWS_CHESTS,
            BRYOPHYTA, CALLISTO, CALVARION,
            CERBERUS, CHAMBERS_OF_XERIC, CHAMBERS_OF_XERIC_CHALLENGE_MODE,
            CHAOS_ELEMENTAL, CHAOS_FANATIC, COMMANDER_ZILYANA,
            CORPOREAL_BEAST, CRAZY_ARCHAEOLOGIST, DAGANNOTH_PRIME,
            DAGANNOTH_REX, DAGANNOTH_SUPREME, DERANGED_ARCHAEOLOGIST,
            DOOM_OF_MOKHAIOTL, DUKE_SUCELLUS, GENERAL_GRAARDOR,
            GIANT_MOLE, GROTESQUE_GUARDIANS, HESPORI,
            KALPHITE_QUEEN, KING_BLACK_DRAGON, KRAKEN,
            KREEARRA, KRIL_TSUTSAROTH, LUNAR_CHESTS,
            MIMIC, NEX, NIGHTMARE,
            PHOSANIS_NIGHTMARE, OBOR, PHANTOM_MUSPAH,
            SARACHNIS, SCORPIA, SCURRIUS,
            SHELLBANE_GRYPHON, SKOTIZO, SOL_HEREDIT,
            SPINDEL, TEMPOROSS, THE_GAUNTLET,
            THE_CORRUPTED_GAUNTLET, THE_HUEYCOATL, THE_LEVIATHAN,
            THE_ROYAL_TITANS, THE_WHISPERER, THEATRE_OF_BLOOD,
            THEATRE_OF_BLOOD_HARD_MODE, THERMONUCLEAR_SMOKE_DEVIL, TOMBS_OF_AMASCUT,
            TOMBS_OF_AMASCUT_EXPERT, TZKAL_ZUK, TZTOK_JAD,
            VARDORVIS, VENENATIS, VETION,
            VORKATH, WINTERTODT, YAMA,
            ZALCANO, ZULRAH
    );

    // Activities
    public static final List<HiscoreSkill> ACTIVITIES = ImmutableList.of(
            CLUE_SCROLL_BEGINNER, CLUE_SCROLL_EASY, CLUE_SCROLL_MEDIUM,
            CLUE_SCROLL_HARD, CLUE_SCROLL_ELITE, CLUE_SCROLL_MASTER,
            CLUE_SCROLL_ALL, LEAGUE_POINTS, LAST_MAN_STANDING,
            SOUL_WARS_ZEAL, RIFTS_CLOSED, COLOSSEUM_GLORY,
            COLLECTIONS_LOGGED, BOUNTY_HUNTER_ROGUE, BOUNTY_HUNTER_HUNTER,
            PVP_ARENA_RANK
    );

    // Mapping for WOM queries
    public static final Map<String, String> NORMALIZED_NAMES = Map.ofEntries(
            Map.entry("runecraft", "runecrafting"),
            Map.entry("clue_scroll_all", "clue_scrolls_all"),
            Map.entry("clue_scroll_beginner", "clue_scrolls_beginner"),
            Map.entry("clue_scroll_easy", "clue_scrolls_easy"),
            Map.entry("clue_scroll_medium", "clue_scrolls_medium"),
            Map.entry("clue_scroll_hard", "clue_scrolls_hard"),
            Map.entry("clue_scroll_elite", "clue_scrolls_elite"),
            Map.entry("clue_scroll_master", "clue_scrolls_master"),
            Map.entry("pvp_arena_rank", "pvp_arena"),
            Map.entry("rifts_closed", "guardians_of_the_rift")
    );

    public static final List<Integer> ACHIEVEMENT_DIARIES_COMPLETE_VARBITS = List.of(
            VarbitID.ARDOUGNE_DIARY_EASY_COMPLETE,
            VarbitID.ARDOUGNE_DIARY_MEDIUM_COMPLETE,
            VarbitID.ARDOUGNE_DIARY_HARD_COMPLETE,
            VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE,
            VarbitID.FALADOR_DIARY_EASY_COMPLETE,
            VarbitID.FALADOR_DIARY_MEDIUM_COMPLETE,
            VarbitID.FALADOR_DIARY_HARD_COMPLETE,
            VarbitID.FALADOR_DIARY_ELITE_COMPLETE,
            VarbitID.WILDERNESS_DIARY_EASY_COMPLETE,
            VarbitID.WILDERNESS_DIARY_MEDIUM_COMPLETE,
            VarbitID.WILDERNESS_DIARY_HARD_COMPLETE,
            VarbitID.WILDERNESS_DIARY_ELITE_COMPLETE,
            VarbitID.WESTERN_DIARY_EASY_COMPLETE,
            VarbitID.WESTERN_DIARY_MEDIUM_COMPLETE,
            VarbitID.WESTERN_DIARY_HARD_COMPLETE,
            VarbitID.WESTERN_DIARY_ELITE_COMPLETE,
            VarbitID.KANDARIN_DIARY_EASY_COMPLETE,
            VarbitID.KANDARIN_DIARY_MEDIUM_COMPLETE,
            VarbitID.KANDARIN_DIARY_HARD_COMPLETE,
            VarbitID.KANDARIN_DIARY_ELITE_COMPLETE,
            VarbitID.VARROCK_DIARY_EASY_COMPLETE,
            VarbitID.VARROCK_DIARY_MEDIUM_COMPLETE,
            VarbitID.VARROCK_DIARY_HARD_COMPLETE,
            VarbitID.VARROCK_DIARY_ELITE_COMPLETE,
            VarbitID.DESERT_DIARY_EASY_COMPLETE,
            VarbitID.DESERT_DIARY_MEDIUM_COMPLETE,
            VarbitID.DESERT_DIARY_HARD_COMPLETE,
            VarbitID.DESERT_DIARY_ELITE_COMPLETE,
            VarbitID.MORYTANIA_DIARY_EASY_COMPLETE,
            VarbitID.MORYTANIA_DIARY_MEDIUM_COMPLETE,
            VarbitID.MORYTANIA_DIARY_HARD_COMPLETE,
            VarbitID.MORYTANIA_DIARY_ELITE_COMPLETE,
            VarbitID.FREMENNIK_DIARY_EASY_COMPLETE,
            VarbitID.FREMENNIK_DIARY_MEDIUM_COMPLETE,
            VarbitID.FREMENNIK_DIARY_HARD_COMPLETE,
            VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_EASY_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_MEDIUM_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_HARD_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_ELITE_COMPLETE,
            VarbitID.KOUREND_DIARY_EASY_COMPLETE,
            VarbitID.KOUREND_DIARY_MEDIUM_COMPLETE,
            VarbitID.KOUREND_DIARY_HARD_COMPLETE,
            VarbitID.KOUREND_DIARY_ELITE_COMPLETE,
            VarbitID.KARAMJA_DIARY_ELITE_COMPLETE,
            VarbitID.ATJUN_EASY_DONE,
            VarbitID.ATJUN_MED_DONE,
            VarbitID.ATJUN_HARD_DONE
    );

    // Pets
    public static final Set<String> Pets = Set.of(
            "Abyssal orphan",
            "Ikkle hydra",
            "Chompy chick",
            "Quetzin",
            "Herbi",
            "Rock golem",
            "Rocky",
            "Beaver",
            "Heron",
            "Tangleroot",
            "Giant squirrel",
            "Rift guardian",
            "Baby chinchompa",
            "Moxi",
            "Nid",
            "Pet penance queen",
            "Callisto cub",
            "Hellpuppy",
            "Olmlet",
            "Pet chaos elemental",
            "Pet zilyana",
            "Pet dark core",
            "Pet dagannoth rex",
            "Pet dagannoth supreme",
            "Pet dagannoth prime",
            "Dom",
            "Baron",
            "Smol heredit",
            "Pet general graardor",
            "Baby mole",
            "Noon",
            "Abyssal protector",
            "Kalphite princess",
            "Prince black dragon",
            "Pet kraken",
            "Pet kree'arra",
            "Pet k'ril tsutsaroth",
            "Bloodhound",
            "Nexling",
            "Muphin",
            "Bran",
            "Sraracha",
            "Scorpia's offspring",
            "Scurry",
            "Gull (pet)",
            "Soup",
            "Skotos",
            "Lil' creator",
            "Tiny tempor",
            "Tzrek-jad",
            "Youngllef",
            "Huberte",
            "Jal-nib-rek",
            "Lil'viathan",
            "Little nightmare",
            "Wisp",
            "Lil' zik",
            "Pet smoke devil",
            "Tumeken's guardian",
            "Butch",
            "Venenatis spiderling",
            "Vet'ion jr.",
            "Vorki",
            "Phoenix",
            "Yami",
            "Smolcano",
            "Pet snakeling"
    );

    // Items whitelisting and blacklisting
    public static final Set<String> ITEMS_WHITELIST = Set.of(
            "Golden tench",
            "Hydra leather",
            "Hydra's claw",
            "Noxious point",
            "Noxious blade",
            "Noxious pommel",
            "Araxyte fang",
            "Fighter torso",
            "Ahrim's robetop",
            "Karil's leathertop",
            "Ahrim's robeskirt",
            "Karil's leatherskirt",
            "Pirate's hook",
            "Bryophyta's essence",
            "Voidwaker hilt",
            "Dragon pickaxe",
            "Pegasian crystal",
            "Eternal crystal",
            "Primordial crystal",
            "Arcane prayer scroll",
            "Dinh's bulwark",
            "Twisted buckler",
            "Dragon hunter crossbow",
            "Dexterous prayer scroll",
            "Dragon claws",
            "Ancestral hat",
            "Kodai insignia",
            "Elder maul",
            "Ancestral robe bottom",
            "Ancestral robe top",
            "Twisted bow",
            "Giant champion scroll",
            "Goblin champion scroll",
            "Skeleton champion scroll",
            "Zombie champion scroll",
            "Imp champion scroll",
            "Lesser demon champion scroll",
            "Hobgoblin champion scroll",
            "Ghoul champion scroll",
            "Earth warrior champion scroll",
            "Jogre champion scroll",
            "Champion's cape",
            "Saradomin hilt",
            "Armadyl crossbow",
            "Holy elixir",
            "Spectral sigil",
            "Arcane sigil",
            "Elysian sigil",
            "Dragon defender",
            "Berserker ring",
            "Dragon axe",
            "Avernic treads",
            "Eye of ayak",
            "Mokhaiotl cloth",
            "Ice quartz",
            "Eye of the duke",
            "Magus vestige",
            "Virtus mask",
            "Virtus robe bottom",
            "Virtus robe top",
            "Gilded coif",
            "Gilded boots",
            "Gilded d'hide body",
            "Gilded spade",
            "Gilded pickaxe",
            "Gilded d'hide vambraces",
            "Gilded axe",
            "Gilded d'hide chaps",
            "Gilded scimitar",
            "3rd age cloak",
            "3rd age wand",
            "3rd age bow",
            "3rd age longsword",
            "Ring of 3rd age",
            "Sunfire fanatic helm",
            "Echo crystal",
            "Sunfire fanatic cuirass",
            "Sunfire fanatic chausses",
            "Tonalztics of ralos (uncharged)",
            "Dizana's quiver (uncharged)",
            "Bandos hilt",
            "Bandos tassets",
            "Bandos chestplate",
            "Zenyte shard",
            "Granite hammer",
            "Abyssal needle",
            "Abyssal lantern",
            "Ring of endurance (uncharged)",
            "Gilded hasta",
            "Gilded plateskirt",
            "Gilded sq shield",
            "Gilded med helm",
            "Gilded spear",
            "Gilded chainbody",
            "Gilded 2h sword",
            "Gilded full helm",
            "Gilded platelegs",
            "Gilded kiteshield",
            "Gilded platebody",
            "3rd age vambraces",
            "3rd age range coif",
            "3rd age range legs",
            "3rd age mage hat",
            "3rd age range top",
            "3rd age robe",
            "3rd age plateskirt",
            "3rd age full helmet",
            "3rd age amulet",
            "3rd age kiteshield",
            "3rd age platelegs",
            "3rd age robe top",
            "3rd age platebody",
            "Bottomless compost bucket",
            "Draconic visage",
            "Trident of the seas (full)",
            "Armadyl hilt",
            "Armadyl helmet",
            "Armadyl chainskirt",
            "Armadyl chestplate",
            "Zamorakian spear",
            "Staff of the dead",
            "Zamorak hilt",
            "Victor's cape (50)",
            "Victor's cape (100)",
            "Victor's cape (500)",
            "Victor's cape (1000)",
            "Master wand",
            "Mage's book",
            "3rd age druidic staff",
            "3rd age druidic cloak",
            "3rd age axe",
            "3rd age druidic robe bottoms",
            "3rd age pickaxe",
            "3rd age druidic robe top",
            "Ranger boots",
            "Dragon limbs",
            "Broken zombie axe",
            "Pharaoh's sceptre (uncharged)",
            "Dragon warhammer",
            "Amulet of eternal glory",
            "Dragon full helm",
            "Dragon metal slice",
            "Expert mining gloves",
            "Eclipse atlatl",
            "Dual macuahuitl",
            "Ancient hilt",
            "Zaryte vambraces",
            "Torva platelegs (damaged)",
            "Torva platebody (damaged)",
            "Torva full helm (damaged)",
            "Nihil horn",
            "Venator shard",
            "Stale baguette",
            "Amulet of avarice",
            "Thammaron's sceptre (u)",
            "Viggora's chainmace (u)",
            "Ancient effigy",
            "Craw's bow (u)",
            "Ancient relic",
            "Fire element staff crown",
            "Ice element staff crown",
            "Deadeye prayer scroll",
            "Mystic vigour prayer scroll",
            "Dragon cannon barrel",
            "Bottled storm",
            "Broken dragon hook",
            "Minor master scroll case",
            "Major master scroll case",
            "Mimic scroll case",
            "Belle's folly (tarnished)",
            "Teleport anchoring scroll",
            "Mystic hat (dusk)",
            "Leaf-bladed battleaxe",
            "Mystic robe bottom (dusk)",
            "Mystic robe top (dusk)",
            "Dagon'hai hat",
            "Dagon'hai robe bottom",
            "Dagon'hai robe top",
            "Blood shard",
            "Horn of plenty (empty)",
            "Eternal gem",
            "Aquanite tendon",
            "Basilisk jaw",
            "Wyvern visage",
            "Imbued heart",
            "Black mask (10)",
            "Tome of water (empty)",
            "Fish barrel",
            "Dragon harpoon",
            "Fire cape",
            "Crystal armour seed",
            "Enhanced crystal weapon seed",
            "Tome of earth (empty)",
            "Dragon hunter wand",
            "Infernal cape",
            "Scarred tablet",
            "Smoke quartz",
            "Leviathan's lure",
            "Venator vestige",
            "Inquisitor's great helm",
            "Nightmare staff",
            "Volatile orb",
            "Inquisitor's hauberk",
            "Inquisitor's plateskirt",
            "Eldritch orb",
            "Inquisitor's mace",
            "Harmonised orb",
            "Parasitic egg",
            "Sirenic tablet",
            "Shadow quartz",
            "Siren's staff",
            "Bellator vestige",
            "Justiciar legguards",
            "Justiciar chestguard",
            "Justiciar faceguard",
            "Sanguinesti staff (uncharged)",
            "Ghrazi rapier",
            "Avernic defender hilt",
            "Scythe of vitur (uncharged)",
            "Holy ornament kit",
            "Sanguine ornament kit",
            "Sanguine dust",
            "Occult necklace",
            "Elidinis' ward",
            "Lightbearer",
            "Masori mask",
            "Osmumten's fang",
            "Masori chaps",
            "Masori body",
            "Tumeken's shadow (uncharged)",
            "Thread of elidinis",
            "Masori crafting kit",
            "Burning claw",
            "Tormented synapse",
            "Blood quartz",
            "Ultor vestige",
            "Voidwaker gem",
            "Voidwaker blade",
            "Dragon pickaxe (broken)",
            "Skeletal visage",
            "Vorkath's head",
            "Tome of fire (empty)",
            "Oathplate helm",
            "Oathplate legs",
            "Oathplate chest",
            "Crystal tool seed",
            "Serpentine visage",
            "Magic fang",
            "Tanzanite fang"
    );

    // Combat Achievements
    public static final Map<String, String> COMBAT_ACHIEVEMENT_REWARDS_IMAGE_URL = Map.of(
//            "Easy", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_easy_tier_icon.png",
//            "Medium", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_medium_tier_icon.png",
//            "Hard", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_hard_tier_icon.png",
            "Elite", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_elite_tier_icon.png",
            "Master", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_master_tier_icon.png",
            "Grandmaster", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_grandmaster_tier_icon.png"
    );

    // Achievement Diaries
//    public static final Map<String, String> ELITE_ACHIEVEMENT_DIARIES_IMAGE_URL;
//
//    static
//    {
//        Map<Integer, String> map = new HashMap<>();
//
//        map.put(VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Ardougne_cloak_4_detail.png");
//        map.put(VarbitID.DESERT_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Desert_amulet_4_detail.png");
//        map.put(VarbitID.FALADOR_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Falador_shield_4_detail.png");
//        map.put(VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Fremennik_sea_boots_4_detail.png");
//        map.put(VarbitID.KANDARIN_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Kandarin_headgear_4_detail.png");
//        map.put(VarbitID.KARAMJA_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Karamja_gloves_4_detail.png");
//        map.put("Kourend & Kebos", "https://oldschool.runescape.wiki/images/Radas_blessing_4_detail.png");
//        map.put("Lumbridge & Draynor", "https://oldschool.runescape.wiki/images/Explorers_ring_4_detail.png");
//        map.put("Morytania", "https://oldschool.runescape.wiki/images/Morytania_legs_4_detail.png");
//        map.put("Varrock", "https://oldschool.runescape.wiki/images/Varrock_armour_4_detail.png");
//        map.put("Western Provinces", "https://oldschool.runescape.wiki/images/Western_banner_4_detail.png");
//        map.put("Wilderness", "https://oldschool.runescape.wiki/images/Wilderness_sword_4_detail.png");
//
//        ELITE_ACHIEVEMENT_DIARIES_IMAGE_URL = Collections.unmodifiableMap(map);
//    }


    // Grandmaster quests
    public static final Set<String> GM_QUESTS = Set.of(
            "Desert Treasure II - The Fallen Empire",
            "Dragon Slayer II",
            "Monkey Madness II",
            "Song of the Elves",
            "While Guthix Sleeps");

    // --- Enums ---
    @Getter
    public enum chatPrivacy
    {
        ALL("Hide All"),
        PRIVATE("Hide Private"),
        NONE("Show All");

        @Getter
        private final String group;

        chatPrivacy(String group) {
            this.group = group;
        }

        @Override
        public String toString()
        {
            return group;
        }
    }
}
package com.oneshot.utils;

import java.awt.*;

public final class EmbedColors {
    private EmbedColors() {}

    // Reds
    public static final Color MAROON = new Color(128, 0, 0);
    public static final Color DARK_RED = new Color(139, 0, 0);
    public static final Color BROWN = new Color(165, 42, 42);
    public static final Color FIREBRICK = new Color(178, 34, 34);
    public static final Color CRIMSON = new Color(220, 20, 60);
    public static final Color RED = new Color(255, 0, 0);
    public static final Color TOMATO = new Color(255, 99, 71);
    public static final Color CORAL = new Color(255, 127, 80);
    public static final Color INDIAN_RED = new Color(205, 92, 92);
    public static final Color LIGHT_CORAL = new Color(240, 128, 128);

    // Oranges and gold
    public static final Color ORANGE_RED = new Color(255, 69, 0);
    public static final Color DARK_ORANGE = new Color(255, 140, 0);
    public static final Color ORANGE = new Color(255, 165, 0);
    public static final Color GOLD = new Color(255, 215, 0);

    // Yellows
    public static final Color YELLOW = new Color(255, 255, 0);
    public static final Color YELLOW_GREEN = new Color(154, 205, 50);
    public static final Color NEON_YELLOW = new Color(255,231,0);

    // Greens
    public static final Color DARK_GREEN = new Color(0, 100, 0);
    public static final Color GREEN = new Color(0, 128, 0);
    public static final Color FOREST_GREEN = new Color(34, 139, 34);
    public static final Color LIME = new Color(0, 255, 0);
    public static final Color LIGHT_GREEN = new Color(144, 238, 144);
    public static final Color NEON_GREEN = new Color(116,238,21);

    // Blues & Cyans
    public static final Color TEAL = new Color(0, 128, 128);
    public static final Color AQUA = new Color(0, 255, 255);
    public static final Color TURQUOISE = new Color(64, 224, 208);
    public static final Color DODGER_BLUE = new Color(30, 144, 255);
    public static final Color BLUE = new Color(0, 0, 255);
    public static final Color ROYAL_BLUE = new Color(65, 105, 225);
    public static final Color NAVY = new Color(0, 0, 128);
    public static final Color NEON_BLUE = new Color(77,238,234);

    // Purples
    public static final Color PURPLE = new Color(128, 0, 128);
    public static final Color DARK_VIOLET = new Color(148, 0, 211);
    public static final Color MAGENTA = new Color(255, 0, 255);

    // Pinks
    public static final Color HOT_PINK = new Color(255, 105, 180);
    public static final Color DEEP_PINK = new Color(255, 20, 147);
    public static final Color NEON_PINK = new Color(255,19,240);

    // Neutrals
    public static final Color WHITE = new Color(255, 255, 255);
    public static final Color LIGHT_GRAY = new Color(211, 211, 211);
    public static final Color GRAY = new Color(128, 128, 128);
    public static final Color DARK_GRAY = new Color(169, 169, 169);
    public static final Color BLACK = new Color(0, 0, 0);
}

package com.oneshot.utils;

import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class Icons {
    public static final BufferedImage RED_HELM_IMAGE = ImageUtil.loadImageResource(Icons.class, "/redHelm.png");

    public static final BufferedImage WORLD_IMAGE = ImageUtil.loadImageResource(Icons.class, "/World_map_icon.png");

    public static final BufferedImage QUEST_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconQuestHelper.png");
    public static final BufferedImage DEATH_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconDamageHitsplat.png");
    public static final BufferedImage LEVEL_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconStats.png");
    public static final BufferedImage TASKS_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconTasks.png");

    public static final BufferedImage CLUE_SCROLL_BEGINNER = ImageUtil.loadImageResource(Icons.class, "/Clue_scroll_(beginner)_detail.png");
    public static final BufferedImage CLUE_SCROLL_EASY = ImageUtil.loadImageResource(Icons.class, "/Clue_scroll_(easy)_detail.png");
    public static final BufferedImage CLUE_SCROLL_MEDIUM = ImageUtil.loadImageResource(Icons.class, "/Clue_scroll_(medium)_detail.png");
    public static final BufferedImage CLUE_SCROLL_HARD = ImageUtil.loadImageResource(Icons.class, "/Clue_scroll_(hard)_detail.png");
    public static final BufferedImage CLUE_SCROLL_ELITE = ImageUtil.loadImageResource(Icons.class, "/Clue_scroll_(elite)_detail.png");
    public static final BufferedImage CLUE_SCROLL_MASTER = ImageUtil.loadImageResource(Icons.class, "/Clue_scroll_(master)_detail.png");

    public static final ImageIcon RED_HELM = new ImageIcon(RED_HELM_IMAGE);
    public static final ImageIcon RED_HELM_SMALLER = new ImageIcon(RED_HELM_IMAGE.getScaledInstance(Constants.BUTTON_SIZE -2, Constants.BUTTON_SIZE -2, Image.SCALE_DEFAULT));
    public static final ImageIcon WORLD = new ImageIcon(WORLD_IMAGE.getScaledInstance(12, 12, Image.SCALE_SMOOTH));

}
package com.oneshot;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class OneShotTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(OneShotPlugin.class);
		RuneLite.main(args);
	}
}
