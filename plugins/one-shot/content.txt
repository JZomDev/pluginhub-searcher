package com.oneshot.utils;

import java.awt.*;

public final class EmbedColors {
    private EmbedColors() {}

    // Reds
    public static final Color MAROON = new Color(128, 0, 0);
    public static final Color DARK_RED = new Color(139, 0, 0);
    public static final Color BROWN = new Color(165, 42, 42);
    public static final Color FIREBRICK = new Color(178, 34, 34);
    public static final Color CRIMSON = new Color(220, 20, 60);
    public static final Color RED = new Color(255, 0, 0);
    public static final Color TOMATO = new Color(255, 99, 71);
    public static final Color CORAL = new Color(255, 127, 80);
    public static final Color INDIAN_RED = new Color(205, 92, 92);
    public static final Color LIGHT_CORAL = new Color(240, 128, 128);

    // Oranges and gold
    public static final Color ORANGE_RED = new Color(255, 69, 0);
    public static final Color DARK_ORANGE = new Color(255, 140, 0);
    public static final Color ORANGE = new Color(255, 165, 0);
    public static final Color GOLD = new Color(255, 215, 0);

    // Yellows
    public static final Color YELLOW = new Color(255, 255, 0);
    public static final Color YELLOW_GREEN = new Color(154, 205, 50);
    public static final Color NEON_YELLOW = new Color(255,231,0);

    // Greens
    public static final Color DARK_GREEN = new Color(0, 100, 0);
    public static final Color GREEN = new Color(0, 128, 0);
    public static final Color FOREST_GREEN = new Color(34, 139, 34);
    public static final Color LIME = new Color(0, 255, 0);
    public static final Color LIGHT_GREEN = new Color(144, 238, 144);
    public static final Color NEON_GREEN = new Color(116,238,21);

    // Blues & Cyans
    public static final Color TEAL = new Color(0, 128, 128);
    public static final Color AQUA = new Color(0, 255, 255);
    public static final Color TURQUOISE = new Color(64, 224, 208);
    public static final Color DODGER_BLUE = new Color(30, 144, 255);
    public static final Color BLUE = new Color(0, 0, 255);
    public static final Color ROYAL_BLUE = new Color(65, 105, 225);
    public static final Color NAVY = new Color(0, 0, 128);
    public static final Color NEON_BLUE = new Color(77,238,234);

    // Purples
    public static final Color PURPLE = new Color(128, 0, 128);
    public static final Color DARK_VIOLET = new Color(148, 0, 211);
    public static final Color MAGENTA = new Color(255, 0, 255);

    // Pinks
    public static final Color HOT_PINK = new Color(255, 105, 180);
    public static final Color DEEP_PINK = new Color(255, 20, 147);
    public static final Color NEON_PINK = new Color(255,19,240);

    // Neutrals
    public static final Color WHITE = new Color(255, 255, 255);
    public static final Color LIGHT_GRAY = new Color(211, 211, 211);
    public static final Color GRAY = new Color(128, 128, 128);
    public static final Color DARK_GRAY = new Color(169, 169, 169);
    public static final Color BLACK = new Color(0, 0, 0);
}

package com.oneshot.utils;


import com.google.common.collect.ImmutableList;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.hiscore.HiscoreSkill;

import java.awt.*;
import java.util.*;
import java.util.List;

import static net.runelite.client.hiscore.HiscoreSkill.*;


public class Constants {
    public static final String PLUGIN_NAME = "One Shot";
    public static final String CLAN_NAME = "One Shot";
    public static final int DEFAULT_PRIORITY = 5;

    public static String WORKER_URL = "https://runelite-webhook-api.pqnarte.workers.dev/send";

    // Main Panel Buttons
    public static final String LINK_DISCORD = "https://www.discord.gg/one-shot";
    public static final String TIP_DISCORD = "Opens One Shot discord invitation on your browser";
    public static final String TIP_LEADERBOARDS = "Check One Shot leaderboards";
    public static final String TIP_ROLES = "Show clan roles";
    public static final String TIP_MODTOOLS = "Open mod tools";
    public static final int BUTTON_NUMBER = 4;
    public static final int BUTTON_SIZE = 40;
    public static final int TEXT_ICON_SIZE = 12;

    // WiseOldMan Links
    public static final String URI_WOM_LEADERS = "https://api.wiseoldman.net/v2/groups/2647/statistics";
    public static final String URI_WOM_LEADERS_OBJECT = "metricLeaders";
    public static final String URI_WOM_SKILL_LEADERS = "https://api.wiseoldman.net/v2/groups/2647/hiscores?metric=";
    public static final String URI_WOM_SKILL_LEADERS_LIMIT = "&limit=500";

    // clan moderators
    public static final ClanRank RANK_OWNER = new ClanRank(126);
    public static final ClanRank RANK_DEPUTY_OWNER = new ClanRank(125);
    public static final ClanRank RANK_ASTRAL = new ClanRank(120);
    public static final ClanRank RANK_CAPTAIN = new ClanRank(115);

    // Discord Embeds
    public static final Color DISCORD_LEVELS_COLOR = EmbedColors.NEON_GREEN;
    public static final Color DISCORD_DIARIES_COLOR = EmbedColors.WHITE;
    public static final Color DISCORD_COMBAT_ACHIEVEMENTS_COLOR = EmbedColors.PURPLE;
    public static final Color DISCORD_QUESTS_COLOR = EmbedColors.NEON_BLUE;
    public static final Color DISCORD_PETS_COLOR = EmbedColors.NEON_PINK;
    public static final Color DISCORD_LOOT_COLOR = EmbedColors.NEON_YELLOW;
    public static final Color DISCORD_DEATHS_COLOR = EmbedColors.DARK_RED;

    public static final int DISCORD_THUMBNAIL_SIZE = 25;
    public static final int DISCORD_AUTHOR_ICON_SIZE = 20;
    public static final double DISCORD_AUTHOR_ICON_SCALE = 0.7;

    public static final String WIKI_SEARCH = "https://oldschool.runescape.wiki/w/Special:Search?search=";
    public static final String WIKI_COMBAT_ACHIEVEMENTS_REWARDS = "https://oldschool.runescape.wiki/w/Combat_Achievements#Rewards";



    //Real skills, ordered in the way they should be displayed in the panel.
    public static final List<HiscoreSkill> SKILLS = ImmutableList.of(
            ATTACK, HITPOINTS, MINING,
            STRENGTH, AGILITY, SMITHING,
            DEFENCE, HERBLORE, FISHING,
            RANGED, THIEVING, COOKING,
            PRAYER, CRAFTING, FIREMAKING,
            MAGIC, FLETCHING, WOODCUTTING,
            RUNECRAFT, SLAYER, FARMING,
            CONSTRUCTION, HUNTER, SAILING
    );

    //Bosses, ordered in the way they should be displayed in the panel.
    public static final List<HiscoreSkill> BOSSES = ImmutableList.of(
            ABYSSAL_SIRE, ALCHEMICAL_HYDRA, AMOXLIATL,
            ARAXXOR, ARTIO, BARROWS_CHESTS,
            BRYOPHYTA, CALLISTO, CALVARION,
            CERBERUS, CHAMBERS_OF_XERIC, CHAMBERS_OF_XERIC_CHALLENGE_MODE,
            CHAOS_ELEMENTAL, CHAOS_FANATIC, COMMANDER_ZILYANA,
            CORPOREAL_BEAST, CRAZY_ARCHAEOLOGIST, DAGANNOTH_PRIME,
            DAGANNOTH_REX, DAGANNOTH_SUPREME, DERANGED_ARCHAEOLOGIST,
            DOOM_OF_MOKHAIOTL, DUKE_SUCELLUS, GENERAL_GRAARDOR,
            GIANT_MOLE, GROTESQUE_GUARDIANS, HESPORI,
            KALPHITE_QUEEN, KING_BLACK_DRAGON, KRAKEN,
            KREEARRA, KRIL_TSUTSAROTH, LUNAR_CHESTS,
            MIMIC, NEX, NIGHTMARE,
            PHOSANIS_NIGHTMARE, OBOR, PHANTOM_MUSPAH,
            SARACHNIS, SCORPIA, SCURRIUS,
            SHELLBANE_GRYPHON, SKOTIZO, SOL_HEREDIT,
            SPINDEL, TEMPOROSS, THE_GAUNTLET,
            THE_CORRUPTED_GAUNTLET, THE_HUEYCOATL, THE_LEVIATHAN,
            THE_ROYAL_TITANS, THE_WHISPERER, THEATRE_OF_BLOOD,
            THEATRE_OF_BLOOD_HARD_MODE, THERMONUCLEAR_SMOKE_DEVIL, TOMBS_OF_AMASCUT,
            TOMBS_OF_AMASCUT_EXPERT, TZKAL_ZUK, TZTOK_JAD,
            VARDORVIS, VENENATIS, VETION,
            VORKATH, WINTERTODT, YAMA,
            ZALCANO, ZULRAH
    );

    // Activities
    public static final List<HiscoreSkill> ACTIVITIES = ImmutableList.of(
            CLUE_SCROLL_ALL, //LEAGUE_POINTS, LAST_MAN_STANDING,
            //SOUL_WARS_ZEAL, RIFTS_CLOSED, COLOSSEUM_GLORY,
            COLLECTIONS_LOGGED//, BOUNTY_HUNTER_ROGUE, BOUNTY_HUNTER_HUNTER,
            //PVP_ARENA_RANK
    );

    public static final List<Integer> ACHIEVEMENT_DIARIES_COMPLETE_VARBITS = List.of(
            VarbitID.ARDOUGNE_DIARY_EASY_COMPLETE,
            VarbitID.ARDOUGNE_DIARY_MEDIUM_COMPLETE,
            VarbitID.ARDOUGNE_DIARY_HARD_COMPLETE,
            VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE,
            VarbitID.FALADOR_DIARY_EASY_COMPLETE,
            VarbitID.FALADOR_DIARY_MEDIUM_COMPLETE,
            VarbitID.FALADOR_DIARY_HARD_COMPLETE,
            VarbitID.FALADOR_DIARY_ELITE_COMPLETE,
            VarbitID.WILDERNESS_DIARY_EASY_COMPLETE,
            VarbitID.WILDERNESS_DIARY_MEDIUM_COMPLETE,
            VarbitID.WILDERNESS_DIARY_HARD_COMPLETE,
            VarbitID.WILDERNESS_DIARY_ELITE_COMPLETE,
            VarbitID.WESTERN_DIARY_EASY_COMPLETE,
            VarbitID.WESTERN_DIARY_MEDIUM_COMPLETE,
            VarbitID.WESTERN_DIARY_HARD_COMPLETE,
            VarbitID.WESTERN_DIARY_ELITE_COMPLETE,
            VarbitID.KANDARIN_DIARY_EASY_COMPLETE,
            VarbitID.KANDARIN_DIARY_MEDIUM_COMPLETE,
            VarbitID.KANDARIN_DIARY_HARD_COMPLETE,
            VarbitID.KANDARIN_DIARY_ELITE_COMPLETE,
            VarbitID.VARROCK_DIARY_EASY_COMPLETE,
            VarbitID.VARROCK_DIARY_MEDIUM_COMPLETE,
            VarbitID.VARROCK_DIARY_HARD_COMPLETE,
            VarbitID.VARROCK_DIARY_ELITE_COMPLETE,
            VarbitID.DESERT_DIARY_EASY_COMPLETE,
            VarbitID.DESERT_DIARY_MEDIUM_COMPLETE,
            VarbitID.DESERT_DIARY_HARD_COMPLETE,
            VarbitID.DESERT_DIARY_ELITE_COMPLETE,
            VarbitID.MORYTANIA_DIARY_EASY_COMPLETE,
            VarbitID.MORYTANIA_DIARY_MEDIUM_COMPLETE,
            VarbitID.MORYTANIA_DIARY_HARD_COMPLETE,
            VarbitID.MORYTANIA_DIARY_ELITE_COMPLETE,
            VarbitID.FREMENNIK_DIARY_EASY_COMPLETE,
            VarbitID.FREMENNIK_DIARY_MEDIUM_COMPLETE,
            VarbitID.FREMENNIK_DIARY_HARD_COMPLETE,
            VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_EASY_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_MEDIUM_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_HARD_COMPLETE,
            VarbitID.LUMBRIDGE_DIARY_ELITE_COMPLETE,
            VarbitID.KOUREND_DIARY_EASY_COMPLETE,
            VarbitID.KOUREND_DIARY_MEDIUM_COMPLETE,
            VarbitID.KOUREND_DIARY_HARD_COMPLETE,
            VarbitID.KOUREND_DIARY_ELITE_COMPLETE,
            VarbitID.KARAMJA_DIARY_ELITE_COMPLETE,
            VarbitID.ATJUN_EASY_DONE,
            VarbitID.ATJUN_MED_DONE,
            VarbitID.ATJUN_HARD_DONE
    );

    // Pets
    public static final Set<String> Pets = Set.of(
            "Abyssal orphan",
            "Ikkle hydra",
            "Chompy chick",
            "Quetzin",
            "Herbi",
            "Rock golem",
            "Rocky",
            "Beaver",
            "Heron",
            "Tangleroot",
            "Giant squirrel",
            "Rift guardian",
            "Baby chinchompa",
            "Moxi",
            "Nid",
            "Pet penance queen",
            "Callisto cub",
            "Hellpuppy",
            "Olmlet",
            "Pet chaos elemental",
            "Pet zilyana",
            "Pet dark core",
            "Pet dagannoth rex",
            "Pet dagannoth supreme",
            "Pet dagannoth prime",
            "Dom",
            "Baron",
            "Smol heredit",
            "Pet general graardor",
            "Baby mole",
            "Noon",
            "Abyssal protector",
            "Kalphite princess",
            "Prince black dragon",
            "Pet kraken",
            "Pet kree'arra",
            "Pet k'ril tsutsaroth",
            "Bloodhound",
            "Nexling",
            "Muphin",
            "Bran",
            "Sraracha",
            "Scorpia's offspring",
            "Scurry",
            "Gull (pet)",
            "Soup",
            "Skotos",
            "Lil' creator",
            "Tiny tempor",
            "Tzrek-jad",
            "Youngllef",
            "Huberte",
            "Jal-nib-rek",
            "Lil'viathan",
            "Little nightmare",
            "Wisp",
            "Lil' zik",
            "Pet smoke devil",
            "Tumeken's guardian",
            "Butch",
            "Venenatis spiderling",
            "Vet'ion jr.",
            "Vorki",
            "Phoenix",
            "Yami",
            "Smolcano",
            "Pet snakeling"
    );

    // Items whitelisting and blacklisting
    public static final Set<String> ITEMS_WHITELIST = Set.of(
            "Golden tench",
            "Hydra leather",
            "Hydra's claw",
            "Noxious point",
            "Noxious blade",
            "Noxious pommel",
            "Araxyte fang",
            "Fighter torso",
            "Ahrim's robetop",
            "Karil's leathertop",
            "Ahrim's robeskirt",
            "Karil's leatherskirt",
            "Bryophyta's essence",
            "Voidwaker hilt",
            "Dragon pickaxe",
            "Pegasian crystal",
            "Eternal crystal",
            "Primordial crystal",
            "Arcane prayer scroll",
            "Dinh's bulwark",
            "Twisted buckler",
            "Dragon hunter crossbow",
            "Dexterous prayer scroll",
            "Dragon claws",
            "Ancestral hat",
            "Kodai insignia",
            "Elder maul",
            "Ancestral robe bottom",
            "Ancestral robe top",
            "Twisted bow",
            "Giant champion scroll",
            "Goblin champion scroll",
            "Skeleton champion scroll",
            "Zombie champion scroll",
            "Imp champion scroll",
            "Lesser demon champion scroll",
            "Hobgoblin champion scroll",
            "Ghoul champion scroll",
            "Earth warrior champion scroll",
            "Jogre champion scroll",
            "Champion's cape",
            "Saradomin hilt",
            "Armadyl crossbow",
            "Holy elixir",
            "Spectral sigil",
            "Arcane sigil",
            "Elysian sigil",
            "Dragon defender",
            "Berserker ring",
            "Dragon axe",
            "Avernic treads",
            "Eye of ayak",
            "Mokhaiotl cloth",
            "Virtus mask",
            "Virtus robe bottom",
            "Virtus robe top",
            "Gilded d'hide vambraces",
            "Gilded axe",
            "Gilded d'hide chaps",
            "Gilded scimitar",
            "3rd age cloak",
            "3rd age wand",
            "3rd age bow",
            "3rd age longsword",
            "Sunfire fanatic chausses",
            "Tonalztics of ralos (uncharged)",
            "Dizana's quiver (uncharged)",
            "Bandos hilt",
            "Bandos tassets",
            "Bandos chestplate",
            "Zenyte shard",
            "Granite hammer",
            "Ring of endurance (uncharged)",
            "Gilded 2h sword",
            "Gilded full helm",
            "Gilded platelegs",
            "Gilded kiteshield",
            "Gilded platebody",
            "3rd age vambraces",
            "3rd age range coif",
            "3rd age range legs",
            "3rd age mage hat",
            "3rd age range top",
            "3rd age robe",
            "3rd age plateskirt",
            "3rd age full helmet",
            "3rd age amulet",
            "3rd age kiteshield",
            "3rd age platelegs",
            "3rd age robe top",
            "3rd age platebody",
            "Bottomless compost bucket",
            "Trident of the seas (full)",
            "Armadyl hilt",
            "Armadyl helmet",
            "Armadyl chainskirt",
            "Armadyl chestplate",
            "Zamorakian spear",
            "Staff of the dead",
            "Zamorak hilt",
            "Victor's cape (1000)",
            "3rd age druidic staff",
            "3rd age druidic cloak",
            "3rd age axe",
            "3rd age druidic robe bottoms",
            "3rd age pickaxe",
            "3rd age druidic robe top",
            "Ranger boots",
            "Broken zombie axe",
            "Dragon warhammer",
            "Amulet of eternal glory",
            "Dragon full helm",
            "Dragon metal slice",
            "Eclipse atlatl",
            "Dual macuahuitl",
            "Ancient hilt",
            "Zaryte vambraces",
            "Torva platelegs (damaged)",
            "Torva platebody (damaged)",
            "Torva full helm (damaged)",
            "Nihil horn",
            "Venator shard",
            "Stale baguette",
            "Ancient effigy",
            "Craw's bow (u)",
            "Ancient relic",
            "Dragon cannon barrel",
            "Bottled storm",
            "Broken dragon hook",
            "Belle's folly (tarnished)",
            "Leaf-bladed battleaxe",
            "Blood shard",
            "Horn of plenty (empty)",
            "Eternal gem",
            "Aquanite tendon",
            "Basilisk jaw",
            "Wyvern visage",
            "Imbued heart",
            "Black mask (10)",
            "Fish barrel",
            "Dragon harpoon",
            "Fire cape",
            "Crystal armour seed",
            "Enhanced crystal weapon seed",
            "Dragon hunter wand",
            "Infernal cape",
            "Inquisitor's great helm",
            "Nightmare staff",
            "Volatile orb",
            "Inquisitor's hauberk",
            "Inquisitor's plateskirt",
            "Eldritch orb",
            "Inquisitor's mace",
            "Harmonised orb",
            "Justiciar legguards",
            "Justiciar chestguard",
            "Justiciar faceguard",
            "Sanguinesti staff (uncharged)",
            "Ghrazi rapier",
            "Avernic defender hilt",
            "Scythe of vitur (uncharged)",
            "Occult necklace",
            "Lightbearer",
            "Masori mask",
            "Osmumten's fang",
            "Masori chaps",
            "Masori body",
            "Tumeken's shadow (uncharged)",
            "Thread of elidinis",
            "Tormented synapse",
            "Voidwaker gem",
            "Dragon pickaxe (broken)",
            "Skeletal visage",
            "Vorkath's head",
            "Oathplate helm",
            "Oathplate legs",
            "Oathplate chest",
            "Crystal tool seed",
            "Serpentine visage",
            "Magic fang",
            "Tanzanite fang"
    );

    // Combat Achievements
    public static final Map<String, String> COMBAT_ACHIEVEMENT_REWARDS_IMAGE_URL = Map.of(
//            "Easy", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_easy_tier_icon.png",
//            "Medium", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_medium_tier_icon.png",
//            "Hard", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_hard_tier_icon.png",
            "Elite", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_elite_tier_icon.png",
            "Master", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_master_tier_icon.png",
            "Grandmaster", "https://oldschool.runescape.wiki/images/Combat_Achievements_-_grandmaster_tier_icon.png"
    );

    // Achievement Diaries
//    public static final Map<String, String> ELITE_ACHIEVEMENT_DIARIES_IMAGE_URL;
//
//    static
//    {
//        Map<Integer, String> map = new HashMap<>();
//
//        map.put(VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Ardougne_cloak_4_detail.png");
//        map.put(VarbitID.DESERT_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Desert_amulet_4_detail.png");
//        map.put(VarbitID.FALADOR_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Falador_shield_4_detail.png");
//        map.put(VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Fremennik_sea_boots_4_detail.png");
//        map.put(VarbitID.KANDARIN_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Kandarin_headgear_4_detail.png");
//        map.put(VarbitID.KARAMJA_DIARY_ELITE_COMPLETE, "https://oldschool.runescape.wiki/images/Karamja_gloves_4_detail.png");
//        map.put("Kourend & Kebos", "https://oldschool.runescape.wiki/images/Radas_blessing_4_detail.png");
//        map.put("Lumbridge & Draynor", "https://oldschool.runescape.wiki/images/Explorers_ring_4_detail.png");
//        map.put("Morytania", "https://oldschool.runescape.wiki/images/Morytania_legs_4_detail.png");
//        map.put("Varrock", "https://oldschool.runescape.wiki/images/Varrock_armour_4_detail.png");
//        map.put("Western Provinces", "https://oldschool.runescape.wiki/images/Western_banner_4_detail.png");
//        map.put("Wilderness", "https://oldschool.runescape.wiki/images/Wilderness_sword_4_detail.png");
//
//        ELITE_ACHIEVEMENT_DIARIES_IMAGE_URL = Collections.unmodifiableMap(map);
//    }


    // Grandmaster quests
    public static final Set<String> GM_QUESTS = Set.of(
            "Desert Treasure II - The Fallen Empire",
            "Dragon Slayer II",
            "Monkey Madness II",
            "Song of the Elves",
            "While Guthix Sleeps");
}
package com.oneshot.utils;

import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class Icons {
    public static final BufferedImage RED_HELM_IMAGE = ImageUtil.loadImageResource(Icons.class, "/redHelm.png");

    private static final BufferedImage DISCORD_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconDiscordON.png");
    private static final BufferedImage RANKING_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconLeaderboardsON.png");
    private static final BufferedImage MODTOOLS_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconModToolsON.png");
    private static final BufferedImage INFO_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconRankingsON.png");

    public static final BufferedImage QUEST_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconQuestHelper.png");
    public static final BufferedImage DEATH_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconDamageHitsplat.png");
    public static final BufferedImage LEVEL_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconStats.png");
    public static final BufferedImage TASKS_IMAGE = ImageUtil.loadImageResource(Icons.class, "/iconTasks.png");

    public static final ImageIcon RED_HELM = new ImageIcon(RED_HELM_IMAGE);
    public static final ImageIcon RED_HELM_SMALLER = new ImageIcon(RED_HELM_IMAGE.getScaledInstance(Constants.BUTTON_SIZE -2, Constants.BUTTON_SIZE -2, Image.SCALE_DEFAULT));
    public static final ImageIcon RED_HELM_TINY = new ImageIcon(RED_HELM_IMAGE.getScaledInstance(24, 24, Image.SCALE_SMOOTH));
    public static final ImageIcon DISCORD = new ImageIcon(DISCORD_IMAGE.getScaledInstance(Constants.BUTTON_SIZE -2, Constants.BUTTON_SIZE -2, Image.SCALE_SMOOTH));
    public static final ImageIcon RANKING = new ImageIcon(RANKING_IMAGE.getScaledInstance(Constants.BUTTON_SIZE -2, Constants.BUTTON_SIZE -2, Image.SCALE_SMOOTH));
    public static final ImageIcon MODTOOLS = new ImageIcon(MODTOOLS_IMAGE.getScaledInstance(Constants.BUTTON_SIZE -2, Constants.BUTTON_SIZE -2, Image.SCALE_SMOOTH));
    public static final ImageIcon INFO = new ImageIcon(INFO_IMAGE.getScaledInstance(Constants.BUTTON_SIZE -2, Constants.BUTTON_SIZE -2, Image.SCALE_SMOOTH));

}
package com.oneshot;

import net.runelite.client.config.*;


@ConfigGroup(OneShotConfig.GROUP)
public interface OneShotConfig extends Config
{

    String GROUP = "oneshot";

    @ConfigItem(
            keyName = "version",
            position = 0,
            name = "version",
            description = "version")
    default String version() {return "v1.0.1"; }

    @ConfigSection(
            name = "Discord Announcements",
            description = "Which achievements should be posted in One Shot discord?",
            position = 1
    )
    String DISCORD_SECTION = "Game Achievements";

    @ConfigItem(
            keyName = "announceLevel",
            name = "Announce Level 99 or 200M XP",
            description = "Should we announce when you reach Level 99 or 200M XP in a skill to discord #achievements?",
            section = DISCORD_SECTION,
            position = 3
    )
    default boolean announceLevel(){
        return true;
    }

    @ConfigItem(
            keyName = "announceelites",
            name = "Announce Elite Diaries",
            description = "Should we announce when you complete Elite Diaries to discord #achievements?",
            section = DISCORD_SECTION,
            position = 4
    )
    default boolean announceelites(){
        return true;
    }

    @ConfigItem(
            keyName = "announcegmquests",
            name = "Announce Grandmaster Quests",
            description = "Should we announce when you complete Grandmaster quests to discord #achievements?",
            section = DISCORD_SECTION,
            position = 5
    )
    default boolean announcegmquests(){
        return true;
    }

    @ConfigItem(
            keyName = "announcepets",
            name = "Announce Pets",
            description = "Should we announce when you receive a new pet in #loot-drop",
            section = DISCORD_SECTION,
            position = 7
    )
    default boolean announcepets(){
        return true;
    }

    @ConfigItem(
            keyName = "announceloot",
            name = "Announce Poggers Collection Logs",
            description = "Should we announce when you receive a poggers collection log to discord #loot-drop",
            section = DISCORD_SECTION,
            position = 8
    )
    default boolean announceloot(){
        return true;
    }


    @ConfigItem(
            keyName = "announcedeaths",
            name = "Announce Deaths",
            description = "Should we announce when you die to discord #deaths?",
            section = DISCORD_SECTION,
            position = 9
    )
    default boolean announcedeaths(){
        return true;
    }


    @ConfigItem(
            keyName = "announcecas",
            name = "Announce Combat Achievements Tier Rewards",
            description = "Should we announce when you unlock a new elite/master/grandmaster combat achievement tier reward?",
            section = DISCORD_SECTION,
            position = 10
    )
    default boolean announcecas(){
        return true;
    }



    @ConfigSection(
            name = "Discord Options",
            description = "To customize your announcements a bit more",
            position = 1
    )
    String DISCORD_SECTION_OPTIONS = "Discord Options";

    @ConfigItem(
            keyName = "uploadscreenshots",
            name = "Upload screenshots",
            description = "Should we include a screenshot of your achievements?",
            section = DISCORD_SECTION_OPTIONS,
            position = 1
    )
    default boolean uploadscreenshots(){
        return true;
    }

    @ConfigItem(
            keyName = "hidechat",
            name = "Hide chats",
            description = "Hides chat when sending screenshots",
            section = DISCORD_SECTION_OPTIONS,
            position = 2
    )
    default boolean hidechats(){
        return true;
    }


    @ConfigItem(
            keyName = "uploadTotalQuestPoints",
            name = "Include quest stats",
            description = "Should we include total quests done and quest points when announcing a quest completion?",
            section = DISCORD_SECTION_OPTIONS,
            position = 3
    )
    default boolean uploadTotalQuestPoints(){
        return true;
    }


}

package com.oneshot.modules;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import okhttp3.*;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.Reader;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

/**
 * This thread-safe singleton holds a mapping of item names to their item id, using the RuneLite API.
 * <p>
 * Unlike {@link net.runelite.client.game.ItemManager#search(String)}, this mapping supports untradable items.
 */
@Singleton
public class ItemSearcher {
    private static final Logger log = LoggerFactory.getLogger(ItemSearcher.class);

    private final Map<String, Integer> itemIdByName = Collections.synchronizedMap(new HashMap<>(16384));
    private @Inject OkHttpClient httpClient;
    private @Inject Gson gson;

    /**
     * @param name the exact in-game name of an item
     * @return the id associated with the item name, or null if not found
     */
    @Nullable
    public Integer findItemId(String name) {
        return itemIdByName.get(name);
    }

    /**
     * Begins the initialization process for {@link #itemIdByName}
     * by querying item names and noted item ids from the RuneLite API,
     * before passing them to {@link #populate(Map, Set)}
     *
     * @implNote This operation does not block the current thread,
     * by utilizing OkHttp's thread pool and Java's Fork-Join common pool.
     */
    @Inject
    void init() {
        queryNamesById()
                .thenAcceptBothAsync(
                        queryNotedItemIds().exceptionally(e -> {
                            log.error("Failed to read noted items", e);
                            return Collections.emptySet();
                        }),
                        this::populate
                )
                .exceptionally(e -> {
                    log.error("Failed to read item names", e);
                    return null;
                });
    }

    /**
     * Populates {@link #itemIdByName} with the inverted mappings of {@code namesById},
     * while skipping noted items specified in {@code notedIds}.
     *
     * @param namesById a mapping of item id's to the corresponding in-game name
     * @param notedIds  the id's of noted items
     * @implNote When multiple non-noted item id's have the same in-game name, only the earliest id is saved
     */

    void populate(Map<Integer, String> namesById, Set<Integer> notedIds) {
        namesById.forEach((id, name) -> {
            if (!notedIds.contains(id))
                itemIdByName.putIfAbsent(name, id);
        });

        log.debug("Completed initialization of item cache with {} entries", itemIdByName.size());
    }

    /**
     * @return a mapping of item ids to their in-game names, provided by the RuneLite API
     */
    private CompletableFuture<Map<Integer, String>> queryNamesById() {
        return queryCache("names.json", new TypeToken<Map<Integer, String>>() {});
    }

    /**
     * @return a set of id's of noted items, provided by the RuneLite API
     */
    private CompletableFuture<Set<Integer>> queryNotedItemIds() {
        return queryCache("notes.json", new TypeToken<Map<Integer, Integer>>() {})
                .thenApply(Map::keySet);
    }

    /**
     * @param fileName the name of the file to query from RuneLite's cache
     * @param type     a type token that indicates how the json response should be parsed
     * @return the transformed cache response, wrapped in a future
     */
    private <T> CompletableFuture<T> queryCache(String fileName, TypeToken<T> type) {
        return readJson(httpClient, gson, "https://static.runelite.net/cache/item/" + fileName, type);
    }

    public <T> CompletableFuture<T> readJson(OkHttpClient httpClient, Gson gson, String url, TypeToken<T> type) {
        return readUrl(httpClient, url, reader -> gson.fromJson(reader, type.getType()));
    }

    public <T> CompletableFuture<T> readUrl( OkHttpClient httpClient, String url, Function<Reader, T> transformer) {
        CompletableFuture<T> future = new CompletableFuture<>();
        Request request = new Request.Builder().url(url).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                assert response.body() != null;
                try (response; Reader reader = response.body().charStream()) {
                    future.complete(transformer.apply(reader));
                } catch (Exception e) {
                    future.completeExceptionally(e);
                }
            }
        });
        return future;
    }
}

package com.oneshot.modules;

import com.google.common.collect.ImmutableList;
import com.oneshot.OneShotPlugin;
import lombok.experimental.UtilityClass;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.Collection;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@UtilityClass
public class QuestUtils {
    private static final Logger log = LoggerFactory.getLogger(OneShotPlugin.class);

    private static final Pattern QUEST_PATTERN_1 = Pattern.compile(".+?ve\\.*? (?<verb>been|rebuilt|.+?ed)? ?(?:the )?'?(?<quest>.+?)'?(?: [Qq]uest)?[!.]?$");
    private static final Pattern QUEST_PATTERN_2 = Pattern.compile("'?(?<quest>.+?)'?(?: [Qq]uest)? (?<verb>[a-z]\\w+?ed)?(?: f.*?)?[!.]?$");
    private static final Collection<String> RFD_TAGS = ImmutableList.of("Another Cook", "freed", "defeated", "saved");
    private static final Collection<String> WORD_QUEST_IN_NAME_TAGS = ImmutableList.of("Another Cook", "Doric", "Heroes", "Legends", "Observatory", "Olaf", "Waterfall");
    private static final Map<String, String> QUEST_REPLACEMENTS = Map.of(
            "Lumbridge Cook... again", "Another Cook's",
            "Skrach 'Bone Crusher' Uglogwee", "Skrach Uglogwee"
    );

    @Nullable
    public static String parseQuestWidget(final String text) {
        Matcher matcher = getMatcher(text);
        if (matcher == null) {
            log.warn("Unable to match quest: {}", text);
            return null;
        }

        String quest = matcher.group("quest");
        quest = QUEST_REPLACEMENTS.getOrDefault(quest, quest);

        String verb = StringUtils.defaultString(matcher.group("verb"));

        if (verb.contains("kind of")) {
            log.debug("Skipping partial completion of quest: {}", quest);
            return null;
        } else if (verb.contains("completely")) {
            quest += " II";
        }

        if (RFD_TAGS.stream().anyMatch((quest + verb)::contains)) {
            quest = "Recipe for Disaster - " + quest;
        }

        if (WORD_QUEST_IN_NAME_TAGS.stream().anyMatch(quest::contains)) {
            quest += " Quest";
        }

        return quest;
    }

    @Nullable
    private static Matcher getMatcher(String text) {
        if (text == null)
            return null;

        // "You have completed The Corsair Curse!"
        Matcher questMatch1 = QUEST_PATTERN_1.matcher(text);
        if (questMatch1.matches())
            return questMatch1;

        // "'One Small Favour' completed!"
        Matcher questMatch2 = QUEST_PATTERN_2.matcher(text);
        if (questMatch2.matches())
            return questMatch2;

        return null;
    }

}

package com.oneshot.modules;

import com.google.gson.*;

import com.oneshot.OneShotConfig;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableRowSorter;

import net.runelite.client.config.*;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import okhttp3.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.*;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

//@Singleton
public class ModToolsPanel extends PluginPanel
{
    @Inject
    private OkHttpClient httpClient;

    @Inject
    private Gson gson;

    private static final Logger log = LoggerFactory.getLogger(ModToolsPanel.class);
    private final ConfigManager configManager;
    private final OneShotConfig config;

    private Map<String, String> womPlayers = new HashMap<>();
    private JTable womTable;
    private String womFilter = "All";


    private JLabel queuedLabel;
    private JLabel checkedLabel;
    private JLabel hcimLabel;

    private JPanel titlePanel = new JPanel();
    private JPanel checkPanel = new JPanel();

    {
        titlePanel.setLayout(new BoxLayout(titlePanel, BoxLayout.Y_AXIS));
        checkPanel.setLayout(new BoxLayout(checkPanel, BoxLayout.Y_AXIS));
    }

    private boolean statsChildHidden = true;


    @Inject
    public ModToolsPanel(ConfigManager configManager, OneShotConfig config, ModTools modTools)
    {
//        log.debug("ModToolsPanel constructed, instance: {}", System.identityHashCode(this));

        this.configManager = configManager;
        this.config = config;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        init();

        add(titlePanel);
        add(checkPanel);

        createTitlePanel();
        createIronmanCheckSection();

    }

    public void init()
    {
        queuedLabel = new JLabel();
        checkedLabel = new JLabel();
        hcimLabel = new JLabel();
        queuedLabel.setText("In Queue: 0");
        checkedLabel.setText("Total Checked: 0");
        hcimLabel.setText("Total HCIM: 0");
    }

    private void createTitlePanel()
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                BorderFactory.createEmptyBorder(4, 6, 4, 6) // Padding sized to text height
        ));
        JLabel titleText = new JLabel("Mod Tools", SwingConstants.CENTER);
        container.add(titleText);
        titlePanel.add(container);
    }

    private void createIronmanCheckSection()
    {
        JPanel childPanel = createIronmanCheckContentPanel();

        checkPanel.add(createCollapsibleHeader("WOM Non-Hardcore Status", childPanel));
        checkPanel.add(childPanel);
        childPanel.setVisible(!statsChildHidden);
    }

    private JPanel createIronmanCheckContentPanel()
    {
        JPanel container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setBorder(BorderFactory.createEmptyBorder(4, 6, 4, 6));

        JButton btn = new JButton("Fetch from WOM");
        btn.setForeground(ColorScheme.TEXT_COLOR);
        btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        btn.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR));
        btn.setFocusPainted(false);
        btn.setOpaque(true);

        btn.setAlignmentX(Component.CENTER_ALIGNMENT);

        // Hover effect
        btn.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                btn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }

            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                fetchWiseOldManGroup(ModToolsPanel.this::refreshWomTable);
            }
        });

        container.add(btn);
        container.add(createWomFilter());
        container.add(createWomList());

        return container;
    }

    private JPanel createWomFilter() {
        JPanel container = new JPanel(new BorderLayout());

        // ---------- FILTER DROPDOWN ----------
        String[] filterOptions = {"All", "Regular", "Ironman"};
        JComboBox<String> filterBox = new JComboBox<>(filterOptions);
        filterBox.setSelectedItem("All");
        filterBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        filterBox.addActionListener(e -> {
            womFilter = (String) filterBox.getSelectedItem();
            refreshWomTable();
        });

        JPanel filterPanel = new JPanel(new BorderLayout());
        filterPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        filterPanel.add(new JLabel("Type: "), BorderLayout.WEST);
        filterPanel.add(filterBox, BorderLayout.CENTER);

        container.add(filterPanel, BorderLayout.NORTH);

        return container;
    }

    private JPanel createWomList()
    {
        JPanel container = new JPanel(new BorderLayout());

        // --- TABLE ---
        womTable = new JTable(womTableModel);
        TableRowSorter<DefaultTableModel> sorter =
                new TableRowSorter<>(womTableModel);
        womTable.setRowSorter(sorter);
        womTable.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        womTable.setForeground(ColorScheme.TEXT_COLOR);
        womTable.setFillsViewportHeight(true);
        womTable.setShowGrid(false);

        // Fill with current data
        refreshWomTable();

        // --- CENTER ALIGN COLUMNS ---
        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(SwingConstants.CENTER);
        womTable.getColumnModel().getColumn(0).setCellRenderer(centerRenderer);
        womTable.getColumnModel().getColumn(1).setCellRenderer(centerRenderer);

        // --- COLUMN WIDTHS (70% / 30%) ---
        int totalWidth = PluginPanel.PANEL_WIDTH - 20; // minus scroll padding
        womTable.getColumnModel().getColumn(0).setPreferredWidth((int)(totalWidth * 0.50));
        womTable.getColumnModel().getColumn(1).setPreferredWidth((int)(totalWidth * 0.50));

        // --- SCROLLPANE (scrolls when needed) ---
        JScrollPane scrollPane = new JScrollPane(womTable);
        scrollPane.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR));
        scrollPane.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 12, 160));

        container.add(scrollPane, BorderLayout.CENTER);

        return container;
    }

    private void refreshWomTable()
    {
        womTableModel.setRowCount(0); // clear

        if (womPlayers.isEmpty())
        {
            womTableModel.addRow(new Object[]{"Empty", ""});
        }
        else
        {
            womPlayers.forEach((name, type) -> {
                // FILTER logic:
                if (womFilter.equals("All") || womFilter.toLowerCase().equals(type))
                {
                    womTableModel.addRow(new Object[]{name, type});
                }
            });
        }

        womTable.revalidate();
        womTable.repaint();
    }

    private void fetchWiseOldManGroup(Runnable onFinished)
    {
        // WOM group ID — hardcoded for now
        int groupId = 2647;

        String url = "https://api.wiseoldman.net/v2/groups/" + groupId;

        Request request = new Request.Builder()
                .url(url)
                .build();

        httpClient.newCall(request).enqueue(new okhttp3.Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.error("Failed to fetch WOM group data", e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                if (!response.isSuccessful())
                {
                    log.error("Bad response from WOM: {}", response.code());
                    return;
                }

                String json = response.body().string();
                parseWom(json);

                SwingUtilities.invokeLater(onFinished);
            }
        });
    }

    private void parseWom(String json)
    {
        JsonObject root = gson.fromJson(json, JsonObject.class);
        JsonArray memberships = root.getAsJsonArray("memberships");
        womPlayers.clear();

        for (JsonElement el : memberships)
        {
            JsonObject membership = el.getAsJsonObject();
            JsonObject player = membership.getAsJsonObject("player");

            String name = player.get("displayName").getAsString();
            String type = player.get("type").getAsString();

            if (!type.equals("hardcore"))
            {
                // Add to your UI list:
                SwingUtilities.invokeLater(() ->
                        womPlayers.put(name, type)
                );
            }
        }
    }

    private DefaultTableModel womTableModel = new DefaultTableModel(
            new Object[]{"Player", "Type"}, 0
    ) {
        @Override
        public boolean isCellEditable(int row, int column) {
            return false; // NON-EDITABLE
        }
    };

    private JPanel createCollapsibleHeader(String text, JPanel childPanel)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        container.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                BorderFactory.createEmptyBorder(4, 6, 4, 6) // Padding sized to text height
        ));

        JLabel title = new JLabel(text);
        JButton toggleBtn = createHeaderToggleButton(childPanel);

        container.add(title, BorderLayout.WEST);
        container.add(toggleBtn, BorderLayout.EAST);

        return container;
    }

    private JButton createHeaderToggleButton(JPanel childPanel)
    {
        JButton btn = new JButton("▼");

        btn.setForeground(ColorScheme.TEXT_COLOR);
        btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        btn.setBorder(BorderFactory.createEmptyBorder(2, 6, 2, 6));
        btn.setFocusPainted(false);
        btn.setOpaque(true);

        // Hover effect
        btn.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                btn.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }

            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                boolean isVisible = childPanel.isVisible();
                childPanel.setVisible(!isVisible);
                btn.setText(!isVisible ? "▲" : "▼");

                // Force relayout and repaint so the gap collapses
                childPanel.getParent().revalidate();
                childPanel.getParent().repaint();
            }
        });

        return btn;
    }
}
package com.oneshot.modules;
import net.runelite.client.plugins.Plugin;
import javax.inject.Singleton;

@Singleton
public class ModTools extends Plugin {

    private ModToolsPanel modToolsPanel;

    public void init(ModToolsPanel modToolsPanel)
    {
        this.modToolsPanel = modToolsPanel;
    }
}

package com.oneshot.modules;

import net.runelite.api.gameval.VarbitID;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Set;

public final class DiaryImages
{
    private static final Logger log = LoggerFactory.getLogger(DiaryImages.class);
    public static class DiaryInfo
    {
        private final String area;
        private final String tier;

        public DiaryInfo(String area, String tier)
        {
            this.area = area;
            this.tier = tier;
        }

        public String getArea()
        {
            return area;
        }

        public String getTier()
        {
            return tier;
        }
    }

    private static String getDiaryTier(int varbitId) {
        Set<Integer> easy = Set.of(
                VarbitID.ARDOUGNE_DIARY_EASY_COMPLETE,
                VarbitID.FALADOR_DIARY_EASY_COMPLETE,
                VarbitID.WILDERNESS_DIARY_EASY_COMPLETE,
                VarbitID.WESTERN_DIARY_EASY_COMPLETE,
                VarbitID.KANDARIN_DIARY_EASY_COMPLETE,
                VarbitID.VARROCK_DIARY_EASY_COMPLETE,
                VarbitID.DESERT_DIARY_EASY_COMPLETE,
                VarbitID.MORYTANIA_DIARY_EASY_COMPLETE,
                VarbitID.FREMENNIK_DIARY_EASY_COMPLETE,
                VarbitID.LUMBRIDGE_DIARY_EASY_COMPLETE,
                VarbitID.KOUREND_DIARY_EASY_COMPLETE,
                VarbitID.ATJUN_EASY_DONE
        );

        Set<Integer> medium = Set.of(
                VarbitID.ARDOUGNE_DIARY_MEDIUM_COMPLETE,
                VarbitID.FALADOR_DIARY_MEDIUM_COMPLETE,
                VarbitID.WILDERNESS_DIARY_MEDIUM_COMPLETE,
                VarbitID.WESTERN_DIARY_MEDIUM_COMPLETE,
                VarbitID.KANDARIN_DIARY_MEDIUM_COMPLETE,
                VarbitID.VARROCK_DIARY_MEDIUM_COMPLETE,
                VarbitID.DESERT_DIARY_MEDIUM_COMPLETE,
                VarbitID.MORYTANIA_DIARY_MEDIUM_COMPLETE,
                VarbitID.FREMENNIK_DIARY_MEDIUM_COMPLETE,
                VarbitID.LUMBRIDGE_DIARY_MEDIUM_COMPLETE,
                VarbitID.KOUREND_DIARY_MEDIUM_COMPLETE,
                VarbitID.ATJUN_MED_DONE
        );

        Set<Integer> hard = Set.of(
                VarbitID.ARDOUGNE_DIARY_HARD_COMPLETE,
                VarbitID.FALADOR_DIARY_HARD_COMPLETE,
                VarbitID.WILDERNESS_DIARY_HARD_COMPLETE,
                VarbitID.WESTERN_DIARY_HARD_COMPLETE,
                VarbitID.KANDARIN_DIARY_HARD_COMPLETE,
                VarbitID.VARROCK_DIARY_HARD_COMPLETE,
                VarbitID.DESERT_DIARY_HARD_COMPLETE,
                VarbitID.MORYTANIA_DIARY_HARD_COMPLETE,
                VarbitID.FREMENNIK_DIARY_HARD_COMPLETE,
                VarbitID.LUMBRIDGE_DIARY_HARD_COMPLETE,
                VarbitID.KOUREND_DIARY_HARD_COMPLETE,
                VarbitID.ATJUN_HARD_DONE
        );

        Set<Integer> elite = Set.of(
                VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE,
                VarbitID.FALADOR_DIARY_ELITE_COMPLETE,
                VarbitID.WILDERNESS_DIARY_ELITE_COMPLETE,
                VarbitID.WESTERN_DIARY_ELITE_COMPLETE,
                VarbitID.KANDARIN_DIARY_ELITE_COMPLETE,
                VarbitID.VARROCK_DIARY_ELITE_COMPLETE,
                VarbitID.DESERT_DIARY_ELITE_COMPLETE,
                VarbitID.MORYTANIA_DIARY_ELITE_COMPLETE,
                VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE,
                VarbitID.LUMBRIDGE_DIARY_ELITE_COMPLETE,
                VarbitID.KOUREND_DIARY_ELITE_COMPLETE,
                VarbitID.KARAMJA_DIARY_ELITE_COMPLETE
        );

        if (easy.contains(varbitId)) return "Easy";
        if (medium.contains(varbitId)) return "Medium";
        if (hard.contains(varbitId)) return "Hard";
        if (elite.contains(varbitId)) return "Elite";

        return "Unknown"; // fallback if no match
    }

    public static DiaryInfo getDiaryInfo(int varbitId)
    {
        String area;
        String tier;

        // ----- AREA -----
        if (varbitId == VarbitID.ATJUN_EASY_DONE
                || varbitId == VarbitID.ATJUN_MED_DONE
                || varbitId == VarbitID.ATJUN_HARD_DONE
                || varbitId == VarbitID.KARAMJA_DIARY_ELITE_COMPLETE)
        {
            area = "Karamja";
        }
        else if (varbitId >= VarbitID.ARDOUGNE_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE)
        {
            area = "Ardougne";
        }
        else if (varbitId >= VarbitID.FALADOR_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.FALADOR_DIARY_ELITE_COMPLETE)
        {
            area = "Falador";
        }
        else if (varbitId >= VarbitID.WILDERNESS_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.WILDERNESS_DIARY_ELITE_COMPLETE)
        {
            area = "Wilderness";
        }
        else if (varbitId >= VarbitID.WESTERN_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.WESTERN_DIARY_ELITE_COMPLETE)
        {
            area = "Western Provinces";
        }
        else if (varbitId >= VarbitID.KANDARIN_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.KANDARIN_DIARY_ELITE_COMPLETE)
        {
            area = "Kandarin";
        }
        else if (varbitId >= VarbitID.VARROCK_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.VARROCK_DIARY_ELITE_COMPLETE)
        {
            area = "Varrock";
        }
        else if (varbitId >= VarbitID.DESERT_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.DESERT_DIARY_ELITE_COMPLETE)
        {
            area = "Desert";
        }
        else if (varbitId >= VarbitID.MORYTANIA_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.MORYTANIA_DIARY_ELITE_COMPLETE)
        {
            area = "Morytania";
        }
        else if (varbitId >= VarbitID.FREMENNIK_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.FREMENNIK_DIARY_ELITE_COMPLETE)
        {
            area = "Fremennik Province";
        }
        else if (varbitId >= VarbitID.LUMBRIDGE_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.LUMBRIDGE_DIARY_ELITE_COMPLETE)
        {
            area = "Lumbridge & Draynor";
        }
        else if (varbitId >= VarbitID.KOUREND_DIARY_EASY_COMPLETE
                && varbitId <= VarbitID.KOUREND_DIARY_ELITE_COMPLETE)
        {
            area = "Kourend & Kebos";
        }
        else
        {
            return null;
        }

        // ----- TIER -----
        tier = getDiaryTier(varbitId);

        return new DiaryInfo(area, tier);
    }
}


package com.oneshot.modules;

import com.oneshot.OneShotConfig;
import com.oneshot.utils.Constants;
import com.oneshot.utils.Icons;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.annotations.Component;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.http.api.item.ItemPrice;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.concurrent.CompletableFuture;

import okhttp3.*;

import java.util.Base64;

@Singleton
public class DiscordClient {

    private static final Logger log = LoggerFactory.getLogger(DiscordClient.class);

    private final String partypete = "PARTYPETE";
    private final String towncrier = "TOWNCRIER";
    private final String death = "DEATHS";
    private final String appreciator = "APPRECIATOR";

    private DrawManager drawManager;
    private ClientThread clientThread;
    private OneShotConfig config;
    private Client client;
    private ChatIconManager chatIconManager;
    private SkillIconManager skillIconManager;

    private CompletableFuture<Image> pendingScreenshot;
    private boolean chatHiddenForScreenshot;
    private int screenshotDelayTicks;

    private static final MediaType JSON_MEDIA = MediaType.get("application/json; charset=utf-8");
    private static final String WORKER_URL = Constants.WORKER_URL;

    @Inject
    private OkHttpClient httpClient;


    @Inject
    private ItemManager itemManager;

    @Inject
    private ItemSearcher itemSearcher;

    @Inject
    public DiscordClient(
            OneShotConfig config,
            Client client,
            DrawManager drawManager,
            ClientThread clientThread,
            ChatIconManager chatIconManager,
            SkillIconManager skillIconManager
    ) {
        this.config = config;
        this.client = client;
        this.drawManager = drawManager;
        this.clientThread = clientThread;
        this.chatIconManager = chatIconManager;
        this.skillIconManager = skillIconManager;
    }

    public void sendLevelUp(Skill skill, int level) throws IOException
    {
        log.debug(String.format("Leveled up %s:%d",skill.getName(),level));
        if (level != 99) return;

        // ---- Level values ------------------------------------------------------
        String description = "";
        String title = String.format("Achieved %s Level %d", skill.getName(), level);

        // ---- Static values -----------------------------------------------------
        String username = null;
        String playerName = client.getLocalPlayer().getName();

        List<DiscordField> fields = List.of();

        BufferedImage skillIcon = skillIconManager.getSkillImage(skill);
        byte[] thumbnail = bufferedImageToBytes(skillIcon);

        byte[] rankIcon = getRankIcon(playerName);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.uploadscreenshots()
                ? getScreenshot()
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        partypete,
                        title,
                        Constants.DISCORD_LEVELS_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        thumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void send200(Skill skill) throws IOException
    {
        String description = "";
        String title = String.format("Achieved 200M XP in %s", skill.getName());

        // ---- Static values -----------------------------------------------------
        String playerName = client.getLocalPlayer().getName();

        List<DiscordField> fields = List.of();

        BufferedImage skillIcon = skillIconManager.getSkillImage(skill);
        byte[] thumbnail = bufferedImageToBytes(skillIcon);


        byte[] rankIcon = getRankIcon(playerName);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.uploadscreenshots()
                ? getScreenshot()
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        partypete,
                        title,
                        Constants.DISCORD_LEVELS_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        thumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendQuest(String questText) throws IOException {
        // ---- Quest values ------------------------------------------------------
        int completedQuests = client.getVarbitValue(VarbitID.QUESTS_COMPLETED_COUNT);
        int totalQuests = client.getVarbitValue(VarbitID.QUESTS_TOTAL_COUNT);
        boolean validQuests = completedQuests > 0 && totalQuests > 0;

        int questPoints = client.getVarpValue(VarPlayerID.QP);
        int totalQuestPoints = client.getVarbitValue(VarbitID.QP_MAX);
        boolean validPoints = questPoints > 0 && totalQuestPoints > 0;

        if (!validPoints && !validQuests) { return; }

        String questName = QuestUtils.parseQuestWidget(questText);
        log.debug("Completed quest: " + questText);
        if (questName == null || !Constants.GM_QUESTS.contains(questName))
            return;

        // ---- Static values -----------------------------------------------------
        String url = getWikiUrl(questName);
        String playerName = client.getLocalPlayer().getName();
        String description = String.format("[%s](%s)",questName,url);
        String title = "Quest completed";
        List<DiscordField> fields = new ArrayList<>();

        if (config.uploadTotalQuestPoints())
        {
            fields.add(new DiscordField(
                    "Quests completed",
                    String.format("%d/%d",completedQuests, totalQuests),
                    true
            ));
            fields.add(new DiscordField(
                    "Quest points",
                    String.format("%d/%d",questPoints, totalQuestPoints),
                    true
            ));
        }

        byte[] questThumbnail = scaleWithPadding(
                Icons.QUEST_IMAGE,
                Constants.DISCORD_THUMBNAIL_SIZE,
                1
        );

        byte[] rankIcon = getRankIcon(playerName);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.uploadscreenshots()
                ? getScreenshot()
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        towncrier,
                        title,
                        Constants.DISCORD_QUESTS_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        questThumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendAchievementDiary(String areaStr, String tierStr) throws IOException {
        if (!Objects.equals(tierStr, "Elite")) return;
        // Capture client-thread-safe data first
        String playerName = client.getLocalPlayer().getName();

        String title = String.format("%s %s diaries completed", areaStr, tierStr);
        String descriptionText = String.format("%s %s Diaries", areaStr, tierStr);
        String itemWikiUrl = getWikiUrl(String.format("%s Diary#%s", areaStr, tierStr));
        String description = String.format("[%s](%s)", descriptionText, itemWikiUrl);

        // ---- Rank icon -----------------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        byte[] taskThumbnail = scaleWithPadding(
                Icons.TASKS_IMAGE,
                Constants.DISCORD_THUMBNAIL_SIZE,
                1
        );

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.uploadscreenshots()
                ? getScreenshot()
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        towncrier,
                        title,
                        Constants.DISCORD_DIARIES_COLOR,
                        playerName,
                        description,
                        null,
                        screenshot,
                        rankIcon,
                        taskThumbnail
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });
    }


    public void sendCombatAchievement(String combatTier) throws IOException
    {
        List<String> allowedTiers = List.of("Elite","Master","Grandmaster");
        log.debug(String.format("Combat Achievement: %s", allowedTiers));
        if (!allowedTiers.contains(combatTier)) return;

        String playerName = client.getLocalPlayer().getName();

        // ---- Text ----------------------------------------------------------
        String title = combatTier + " Tier Rewards unlocked";
        String itemWikiUrl = Constants.WIKI_COMBAT_ACHIEVEMENTS_REWARDS;
        String description = String.format("[%s](%s)","Combat Achievement Rewards",itemWikiUrl);

        // ---- Rank icon -----------------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        String itemImageUrl = Constants.COMBAT_ACHIEVEMENT_REWARDS_IMAGE_URL.get(combatTier);

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.uploadscreenshots()
                ? getScreenshot()
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        towncrier,
                        title,
                        Constants.DISCORD_COMBAT_ACHIEVEMENTS_COLOR,
                        playerName,
                        description,
                        null,
                        screenshot,
                        rankIcon,
                        itemImageUrl
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }



    public void sendPet(String itemName) throws IOException
    {
        String playerName = client.getLocalPlayer().getName();

        // ---- Text ----------------------------------------------------------
        String title = "New pet";
        String itemWikiUrl = getWikiUrl(itemName);
        String description = String.format("[%s](%s)",itemName,itemWikiUrl);

        // ---- Rank icon -----------------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        int itemID = getItemID(itemName);
        String itemImageUrl;
        if (itemID >= 0){
            itemImageUrl = itemImageUrl(itemID);
        } else {
            itemImageUrl = null;
        }

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.uploadscreenshots()
                ? getScreenshot(4)
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        appreciator,
                        title,
                        Constants.DISCORD_PETS_COLOR,
                        playerName,
                        description,
                        null,
                        screenshot,
                        rankIcon,
                        itemImageUrl
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendLootDrop(String itemName) throws IOException
    {
        if (appreciator == null) return;
        String playerName = client.getLocalPlayer().getName();
        boolean isAllowed = Constants.ITEMS_WHITELIST.contains(itemName);
        log.debug(String.format("new collection log: %s - %s",itemName,isAllowed ? "Allowed" : "Not allowed"));
        if (!isAllowed) return;

        // ---- Text ----------------------------------------------------------
        String title = "New collection log";
        String itemWikiUrl = getWikiUrl(itemName);
        int itemHAPrice = getHAPrice(itemName);
        int itemPrice = getWikiPrice(itemName);
        String description = String.format("[%s](%s)",itemName,itemWikiUrl);

        //if (itemPrice < 5e6) return;

        List<DiscordField> fields;

        fields = new ArrayList<>();
        if (itemPrice > 0) {
            fields.add(new DiscordField(
                    "GE price",
                    String.format("%s", QuantityFormatter.formatNumber(itemPrice)),
                    true
            ));
        }
        if (itemHAPrice > 0) {
            fields.add(new DiscordField(
                    "HA price",
                    String.format("%s", QuantityFormatter.formatNumber(itemHAPrice)),
                    true
            ));
        }
        clientThread.invokeLater(() -> {
            int totalCollectionLogs = client.getVarpValue(VarPlayerID.COLLECTION_COUNT_MAX);
            int collectedLogs = client.getVarpValue(VarPlayerID.COLLECTION_COUNT) + 1; // varp is not updated on time

            fields.add(new DiscordField(
                    "Collections logged",
                    String.format("%d/%d", collectedLogs, totalCollectionLogs),
                    true
            ));
        });

        // ---- Rank icon -----------------------------------------------------
        byte[] rankIcon = getRankIcon(playerName);

        // ---- Thumbnail -----------------------------------------------------
        int itemID = getItemID(itemName);
        String itemImageUrl;
        if (itemID >= 0){
            itemImageUrl = itemImageUrl(itemID);
        } else {
            itemImageUrl = null;
        }

        // ---- Send --------------------------------------------------------------
        CompletableFuture<Image> screenshotFuture = config.uploadscreenshots()
                ? getScreenshot(4)
                : CompletableFuture.completedFuture(null);

        screenshotFuture.thenAcceptAsync(img -> {
            try {
                byte[] screenshot = img != null
                        ? bufferedImageToBytes((BufferedImage) img)
                        : null;

                sendDiscordEmbed(
                        appreciator,
                        title,
                        Constants.DISCORD_LOOT_COLOR,
                        playerName,
                        description,
                        fields,
                        screenshot,
                        rankIcon,
                        itemImageUrl
                );
            } catch (Exception e) {
                log.error("Failed to send quest embed", e);
            }
        });

    }

    public void sendDeath(String actorInteraction, CompletableFuture<Image> screenshotFuture) throws IOException
    {
        String playerName = client.getLocalPlayer().getName();

        // ---- Text ----------------------------------------------------------
        String title = Objects.equals(actorInteraction, "") ?  playerName + " has died!" : playerName + " has died to " + actorInteraction + "!";
        String description = "";

        // ---- Fields --------------------------------------------------------
        List<DiscordField> fields = new ArrayList<>();
        fields.add(new DiscordField("Total Level", String.valueOf(client.getTotalLevel()), true));
        fields.add(new DiscordField(
                "Combat Level",
                String.valueOf(client.getLocalPlayer().getCombatLevel()),
                true
        ));

        // ---- Rank icon + field ---------------------------------------------
        byte[] chatImageBytes;
        ClanSettings clan = client.getClanSettings();

        if (clan != null)
        {
            ClanRank rank = clan.findMember(playerName).getRank();
            ClanTitle titleRank = clan.titleForRank(rank);

            fields.add(new DiscordField("Rank", titleRank.getName(), true));

            BufferedImage rankImage = chatIconManager.getRankImage(titleRank);
            chatImageBytes = scaleWithPadding(
                    rankImage,
                    Constants.DISCORD_AUTHOR_ICON_SIZE,
                    Constants.DISCORD_AUTHOR_ICON_SCALE
            );
        }
        else
        {
            chatImageBytes = null;
            fields.add(new DiscordField("Rank", "not in clan", true));
        }

        // ---- Thumbnail -----------------------------------------------------
        byte[] deathThumbnail = scaleWithPadding(
                Icons.DEATH_IMAGE,
                Constants.DISCORD_THUMBNAIL_SIZE,
                1
        );

        // ---- Screenshot handling -------------------------------------------
        if (config.uploadscreenshots())
        {
            screenshotFuture.thenAcceptAsync(img -> {
                try {
                    byte[] screenshot = bufferedImageToBytes((BufferedImage) img);

                    sendDiscordEmbed(
                            death,
                            title,
                            Constants.DISCORD_DEATHS_COLOR,
                            playerName,
                            description,
                            fields,
                            screenshot,
                            chatImageBytes,
                            deathThumbnail
                    );
                } catch (Exception e) {
                    log.error("Failed to send death embed", e);
                }
            });
        }
        else
        {
            sendDiscordEmbed(
                    death,
                    title,
                    Constants.DISCORD_DEATHS_COLOR,
                    playerName,
                    description,
                    fields,
                    null,
                    chatImageBytes,
                    deathThumbnail
            );
        }
    }

    private String getWikiUrl(String wikiName){
        String encoded = wikiName.replace(" ", "_");
        return Constants.WIKI_SEARCH + encoded;
    }

    private static String itemImageUrl(int itemId)
    {
        return "https://static.runelite.net/cache/item/icon/" + itemId + ".png";
    }

    @Nullable
    private Integer getItemID(String itemName)
    {
        return itemSearcher.findItemId(itemName);
    }


    private int getHAPrice(String itemName) {
        ItemPrice item = findItem(itemName);
        if (item == null) return -1;

        return client.getItemDefinition(item.getId()).getHaPrice();
    }


    private int getWikiPrice(String itemName) {
        ItemPrice item = findItem(itemName);
        if (item == null) return -1;

        return itemManager.getWikiPrice(item);
    }


    private ItemPrice findItem(String itemName) {
        return itemManager.search(itemName).stream()
                .filter(it -> it.getName().equalsIgnoreCase(itemName))
                .findFirst()
                .orElse(null);
    }

    private byte[] getRankIcon(String playerName) throws IOException
    {
        ClanSettings clan = client.getClanSettings();
        if (clan == null)
            return null;

        ClanRank rank = clan.findMember(playerName).getRank();
        ClanTitle title = clan.titleForRank(rank);

        BufferedImage icon = chatIconManager.getRankImage(title);
        return scaleWithPadding(icon,
                Constants.DISCORD_AUTHOR_ICON_SIZE,
                Constants.DISCORD_AUTHOR_ICON_SCALE);
    }

    public byte[] scaleWithPadding(BufferedImage original, int iconSize, double scaleFactor) throws IOException
    {
        int visibleSize = (int) (iconSize * scaleFactor);

        // Create 20×20 transparent canvas
        BufferedImage padded = new BufferedImage(iconSize, iconSize, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = padded.createGraphics();

        // Enable high-quality scaling
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Scale original image to visibleSize
        Image scaled = original.getScaledInstance(visibleSize, visibleSize, Image.SCALE_SMOOTH);

        // Center inside the transparent 20×20 canvas
        int x = (iconSize - visibleSize) / 2;
        int y = (iconSize - visibleSize) / 2;

        g.drawImage(scaled, x, y, null);
        g.dispose();

        return bufferedImageToBytes(padded);
    }

    private byte[] bufferedImageToBytes(BufferedImage img) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            ImageIO.write(img, "png", baos);
            return baos.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }


//    public CompletableFuture<Image> getScreenshot()
//    {
//        CompletableFuture<Image> f = new CompletableFuture<>();
//        boolean privacyMode = config.hidechats();
//
//        clientThread.invoke(() ->
//        {
//            boolean chatHidden = hideWidget(privacyMode, client, InterfaceID.Chatbox.CHATAREA);
//
//            drawManager.requestNextFrameListener(image ->
//            {
//                f.complete(image);
//
//                clientThread.invoke(() ->
//                        unhideWidget(chatHidden, client, clientThread, InterfaceID.Chatbox.CHATAREA)
//                );
//            });
//        });
//
//        return f;
//    }

    public void onGameTick()
    {
        if (pendingScreenshot == null)
        {
            return;
        }

//        if (screenshotDelayTicks == 1)
//        {
//            boolean privacyMode = config.hidechats();
//
//            clientThread.invoke(() ->
//            {
//                chatHiddenForScreenshot = hideWidget(
//                        privacyMode,
//                        client,
//                        InterfaceID.Chatbox.CHATAREA
//                );
//            });
//        }

        if (screenshotDelayTicks > 0)
        {
            screenshotDelayTicks--;
            return;
        }

        boolean privacyMode = config.hidechats();

        // STEP 1 — run on client thread
        clientThread.invoke(() ->
        {
            chatHiddenForScreenshot = hideWidget(
                    privacyMode,
                    client,
                    InterfaceID.Chatbox.CHATAREA
            );

            // STEP 2 — request render AFTER widgets are hidden
            drawManager.requestNextFrameListener(image ->
            {
                pendingScreenshot.complete(image);

                // STEP 3 — restore UI AFTER screenshot is taken
                clientThread.invoke(() ->
                {
                    unhideWidget(
                            chatHiddenForScreenshot,
                            client,
                            clientThread,
                            InterfaceID.Chatbox.CHATAREA
                    );

                    pendingScreenshot = null;
                });
            });
        });
    }

    public CompletableFuture<Image> getScreenshot()
    {
        return getScreenshot(1);
    }

    public CompletableFuture<Image> getScreenshot(int delayTicks)
    {
        CompletableFuture<Image> future = new CompletableFuture<>();

        pendingScreenshot = future;
        screenshotDelayTicks = delayTicks;
        return future;
    }


    public static boolean hideWidget(boolean shouldHide, Client client, @Component int info) {
        if (!shouldHide)
            return false;

        Widget widget = client.getWidget(info);
        if (widget == null || widget.isHidden())
            return false;

        widget.setHidden(true);
        return true;
    }

    public static void unhideWidget(boolean shouldUnhide, Client client, ClientThread clientThread, @Component int info) {
        if (!shouldUnhide)
            return;

        clientThread.invoke(() -> {
            Widget widget = client.getWidget(info);
            if (widget != null)
                widget.setHidden(false);
        });
    }

    private static class DiscordField{

        private final String name;
        private final String value;
        private final boolean inline;

        public DiscordField(String name, String value, boolean inline)
        {
            this.name = name;
            this.value = value;
            this.inline = inline;
        }

        public String getName() { return this.name; }

        public String getValue() { return this.value; }

        public boolean getInline() { return this.inline; }
    }

    private void sendDiscordEmbed(
            String webhookKey,
            String title,
            Color color,
            @Nullable String authorName,
            @Nullable String description,
            @Nullable List<DiscordField> fields,
            @Nullable byte[] screenshot,
            @Nullable byte[] userIcon,
            @Nullable byte[] thumbnailBytes
    ) {
        byte[] footerIcon = bufferedImageToBytes(Icons.RED_HELM_IMAGE);

        DiscordWebhook.EmbedObject embed = new DiscordWebhook.EmbedObject()
                .setTitle(title)
                .setColor(color)
                .setFooter("One Shot Plugin", footerIcon, "footericon.png");

        if (description != null) embed.setDescription(description);
        if (userIcon != null) embed.setAuthor(authorName, userIcon, "usericon.png");
        if (thumbnailBytes != null) embed.setThumbnail(thumbnailBytes, "thumb.png");
        if (screenshot != null) embed.setImage(screenshot, "screenshot.png");

        if (fields != null) {
            for (DiscordField f : fields) {
                embed.addField(f.getName(), f.getValue(), f.getInline());
            }
        }

        sendViaWorker(
                webhookKey,
                embed,
                screenshot,
                userIcon,
                footerIcon,
                thumbnailBytes
        );
    }


    private void sendDiscordEmbed(
            String webhookKey,
            String title,
            Color color,
            @Nullable String authorName,
            @Nullable String description,
            @Nullable List<DiscordField> fields,
            @Nullable byte[] screenshot,
            @Nullable byte[] userIcon,
            @Nullable String thumbnailUrl
    ) throws IOException //throws IOException
    {
        byte[] footerIcon = bufferedImageToBytes(Icons.RED_HELM_IMAGE);

        DiscordWebhook.EmbedObject embed = new DiscordWebhook.EmbedObject()
                .setTitle(title)
                .setColor(color)
                .setFooter("One Shot Plugin", footerIcon, "footericon.png");

        if (description != null) embed.setDescription(description);
        if (userIcon != null) embed.setAuthor(authorName, userIcon, "usericon.png");
        if (thumbnailUrl != null) embed.setThumbnail(thumbnailUrl);
        if (screenshot != null) embed.setImage(screenshot, "screenshot.png");

        if (fields != null) {
            for (DiscordField f : fields) {
                embed.addField(f.getName(), f.getValue(), f.getInline());
            }
        }

        sendViaWorker(
                webhookKey,
                embed,
                screenshot,
                userIcon,
                footerIcon,
                null
        );
    }

    private void sendViaWorker(
            String webhookKey,
            DiscordWebhook.EmbedObject embed,
            @Nullable byte[] screenshot,
            @Nullable byte[] userIcon,
            @Nullable byte[] footerIcon,
            @Nullable byte[] thumbnailBytes
    ) {
        try {
            // 1. Build embed JSON (like your toJson() method)
            DiscordWebhook.JSONObject embedJsonObj = embed.toJson(); // you added this earlier
            String embedJson = embedJsonObj.toString();

            String playerName = client.getLocalPlayer().getName();

            StringBuilder attachmentsJson = new StringBuilder();
            attachmentsJson.append("[");

            boolean first = true;

            if (screenshot != null) {
                if (!first) attachmentsJson.append(",");
                first = false;
                attachmentsJson.append(buildAttachmentJson("screenshot.png", screenshot));
            }
            if (userIcon != null) {
                if (!first) attachmentsJson.append(",");
                first = false;
                attachmentsJson.append(buildAttachmentJson("usericon.png", userIcon));
            }
            if (footerIcon != null) {
                if (!first) attachmentsJson.append(",");
                first = false;
                attachmentsJson.append(buildAttachmentJson("footericon.png", footerIcon));
            }
            if (thumbnailBytes != null) {
                if (!first) attachmentsJson.append(",");
                first = false;
                attachmentsJson.append(buildAttachmentJson("thumb.png", thumbnailBytes));
            }

            attachmentsJson.append("]");

            String jsonBody =
                    "{"
                            + "\"username\":\"" + escape(playerName) + "\","
                            + "\"clan_name\":\"One Shot\","
                            + "\"webhook\":\"" + escape(webhookKey) + "\","
                            + "\"content\":null,"
                            + "\"embeds\":[" + embedJson + "],"
                            + "\"attachments\":" + attachmentsJson
                            + "}";

            RequestBody body = RequestBody.create(JSON_MEDIA, jsonBody);

            Request request = new Request.Builder()
                    .url(WORKER_URL)
                    .post(body)
                    .build();

            httpClient.newCall(request).enqueue(new Callback() {
                @Override public void onFailure(Call call, IOException e) {
                    log.error("Failed to send to Worker", e);
                }

                @Override public void onResponse(Call call, Response response) throws IOException {
                    response.close();
                }
            });
        } catch (Exception e) {
            log.error("Error building Worker request", e);
        }
    }

    private String buildAttachmentJson(String filename, byte[] data) {
        String b64 = Base64.getEncoder().encodeToString(data);
        return "{"
                + "\"filename\":\"" + escape(filename) + "\","
                + "\"content_type\":\"image/png\","
                + "\"data\":\"" + b64 + "\""
                + "}";
    }

    private String escape(String s) {
        if (s == null) return "";
        return s.replace("\\", "\\\\").replace("\"", "\\\"");
    }

}

package com.oneshot.modules;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.awt.Color;
import java.util.*;

/**
 * Class used to execute Discord Webhooks with low effort
 * Come from: https://gist.github.com/k3kdude/fba6f6b37594eae3d6f9475330733bdb
 */
public class DiscordWebhook {
    private static final Logger log = LoggerFactory.getLogger(DiscordWebhook.class);

    public static class EmbedObject {

        private String title;
        private String description;
        private Color color;

        private Footer footer;
        private Thumbnail thumbnail;
        private Image image;
        private Author author;
        private List<Field> fields = new ArrayList<>();

        public byte[] imageBytes;
        public String imageFileName;

        public byte[] authorImageBytes;
        public String authorImageFileName;

        public byte[] footerImageBytes;
        public String footerImageFileName;

        public byte[] thumbnailImageBytes;
        public String thumbnailImageFileName;


        // ----- Builder methods -----
        public EmbedObject setTitle(String t) { this.title = t; return this; }
        public EmbedObject setDescription(String d) { this.description = d; return this; }
        public EmbedObject setColor(Color c) { this.color = c; return this; }

        public EmbedObject setFooter(String text, byte[] img, String fileName) {
            this.footer = new Footer(text, null);
            this.footerImageBytes = img;
            this.footerImageFileName = fileName;
            return this;
        }

        public EmbedObject setThumbnail(byte[] img, String fileName) {
            this.thumbnailImageBytes = img;
            this.thumbnailImageFileName = fileName;
            this.thumbnail = new Thumbnail(null);
            return this;
        }

        public EmbedObject setThumbnail(String url) {
            this.thumbnail = new Thumbnail(url);
            return this;
        }

        public EmbedObject setImage(byte[] img, String fileName) {
            this.imageBytes = img;
            this.imageFileName = fileName;
            this.image = new Image(null);
            return this;
        }

        public EmbedObject setAuthor(String name, byte[] img, String fileName) {
            this.author = new Author(name, null, null);
            this.authorImageBytes = img;
            this.authorImageFileName = fileName;
            return this;
        }

        public EmbedObject addField(String name, String value, boolean inline) {
            fields.add(new Field(name, value, inline));
            return this;
        }

        // ----- JSON Builder -----
        public JSONObject toJson() {
            JSONObject json = new JSONObject();

            json.put("title", title);
            json.put("description", description);

            if (color != null) {
                int rgb = (color.getRed() << 16) | (color.getGreen() << 8) | color.getBlue();
                json.put("color", rgb);
            }

            // Footer
            if (footer != null) {
                JSONObject f = new JSONObject();
                f.put("text", footer.text);

                f.put("icon_url",
                        footerImageBytes != null
                                ? "attachment://" + footerImageFileName
                                : footer.iconUrl
                );

                json.put("footer", f);
            }

            // Image
            if (imageBytes != null) {
                JSONObject i = new JSONObject();
                i.put("url", "attachment://" + imageFileName);
                json.put("image", i);
            } else if (image != null && image.url != null) {
                JSONObject i = new JSONObject();
                i.put("url", image.url);
                json.put("image", i);
            }

            // Thumbnail
            if (thumbnailImageBytes != null) {
                JSONObject t = new JSONObject();
                t.put("url", "attachment://" + thumbnailImageFileName);
                json.put("thumbnail", t);
            } else if (thumbnail != null && thumbnail.url != null) {
                JSONObject t = new JSONObject();
                t.put("url", thumbnail.url);
                json.put("thumbnail", t);
            }

            // Author
            if (author != null) {
                JSONObject a = new JSONObject();
                a.put("name", author.name);
                a.put("url", author.url);
                a.put("icon_url",
                        authorImageBytes != null
                                ? "attachment://" + authorImageFileName
                                : author.iconUrl
                );
                json.put("author", a);
            }

            // Fields
            if (!fields.isEmpty()) {
                List<JSONObject> arr = new ArrayList<>();
                for (Field f : fields) {
                    JSONObject jf = new JSONObject();
                    jf.put("name", f.name);
                    jf.put("value", f.value);
                    jf.put("inline", f.inline);
                    arr.add(jf);
                }
                json.put("fields", arr.toArray());
            }

            return json;
        }

        // ----- Inner classes -----

        private static class Footer {
            String text, iconUrl;
            Footer(String t, String u) { text = t; iconUrl = u; }
        }

        private static class Thumbnail {
            String url;
            Thumbnail(String u) { url = u; }
        }

        private static class Image {
            String url;

            Image(String u) { this.url = u; }

        }

        private static class Author {
            String name, url, iconUrl;
            Author(String n, String u, String i) { name = n; url = u; iconUrl = i; }
        }

        private static class Field {
            String name, value;
            boolean inline;

            Field(String n, String v, boolean i) {
                name = n;
                value = v;
                inline = i;
            }
        }
    }


    static class JSONObject {

        private final HashMap<String, Object> map = new HashMap<>();

        void put(String key, Object value) {
            if (value != null) {
                map.put(key, value);
            }
        }

        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            Set<Map.Entry<String, Object>> entrySet = map.entrySet();
            builder.append("{");

            int i = 0;
            for (Map.Entry<String, Object> entry : entrySet) {
                Object val = entry.getValue();
                builder.append(quote(entry.getKey())).append(":");

                if (val instanceof String) {
                    builder.append(quote(String.valueOf(val)));
                } else if (val instanceof Integer) {
                    builder.append(Integer.valueOf(String.valueOf(val)));
                } else if (val instanceof Boolean) {
                    builder.append(val);
                } else if (val instanceof JSONObject) {
                    builder.append(val.toString());
                } else if (val instanceof Object[]) {
                    Object[] arr = (Object[]) val;
                    builder.append("[");
                    for (int j = 0; j < arr.length; j++) {
                        builder.append(arr[j].toString());
                        if (j != arr.length - 1) {
                            builder.append(",");
                        }
                    }
                    builder.append("]");
                }


                builder.append(++i == entrySet.size() ? "}" : ",");
            }

            return builder.toString();
        }

        private String quote(String string) {
            return "\"" + string
                    .replace("\\", "\\\\")
                    .replace("\"", "\\\"")
                    .replace("\n", "\\n")
                    .replace("\r", "\\r")
                    .replace("\t", "\\t")
                    + "\"";
        }
    }
}

package com.oneshot;

import com.google.gson.*;

import com.oneshot.modules.ModToolsPanel;
import com.oneshot.utils.Constants;
import com.oneshot.utils.Icons;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.List;
import java.util.concurrent.*;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.text.StyleContext;

import net.runelite.api.Client;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.Experience;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.*;

import static com.oneshot.utils.Constants.BOSSES;
import static com.oneshot.utils.Constants.SKILLS;
import static com.oneshot.utils.Constants.ACTIVITIES;
import static net.runelite.client.hiscore.HiscoreSkill.*;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.QuantityFormatter;

import okhttp3.*;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class OneShotPanel extends PluginPanel
{
    private static final Logger log = LoggerFactory.getLogger(OneShotPanel.class);

    private ModToolsPanel modToolsPanel;

    private final Map<HiscoreSkill, JButton> skillButtons = new HashMap<>();
    private RateLimitedHttpCache rateLimitedHttpCache;

    JLabel intro_top_text = new JLabel("", SwingConstants.CENTER);
    JLabel intro_bottom_text = new JLabel("", SwingConstants.CENTER);
    JPanel panelMainContent = new JPanel();

    String playerRank;

    ArrayList<OneShotPlugin.OneShotMember> allMembersRanksInfo;
    Map<String, ImageIcon> allMembersIcons;
    Map<String, String> allMembersDisplayNames;

    private boolean isInInfoPanel = false;
    private boolean isModerator = false;

    private Font titleFont;

    ClientThread clientThread;
    Client client;

    @Inject
    private OkHttpClient httpClient;

    @Inject
    private SpriteManager spriteManager;
    private String playerName;

    public void init(Client client, ClientThread clientThread, ModToolsPanel modToolsPanel)
    {
        this.clientThread = clientThread;
        this.client = client;
        this.modToolsPanel = modToolsPanel;
        loadFonts();
        buildIntroPanel();
        rateLimitedHttpCache = new RateLimitedHttpCache(20, 5);
    }

    public void deinit()
    {
        isInInfoPanel = false;
        rateLimitedHttpCache.shutdown();
    }

    private void update()
    {
        revalidate();
        repaint();
    }

    public void refresh(boolean isModerator, String playerName, String clanRankName, ImageIcon iconRank,
                        ArrayList<OneShotPlugin.OneShotMember> allMembersRanksInfo, Map<String, ImageIcon> members,
                        Map<String, String> allMembersDisplayNames) throws IOException, InterruptedException {
        this.allMembersRanksInfo = allMembersRanksInfo;
        this.allMembersIcons = members;
        this.allMembersDisplayNames = allMembersDisplayNames;
        this.playerRank = clanRankName;
        if (isModerator != this.isModerator)
        {
            buildMainPanel(isModerator, playerName, clanRankName, iconRank,
                allMembersRanksInfo, members,
                allMembersDisplayNames);
        }
        if (isInInfoPanel) buildRolesPanel();
        update();
    }

    private void loadFonts()
    {
        try (InputStream in = FontManager.class.getResourceAsStream("runescape.ttf"))
        {
            Font baseFont = Font.createFont(0, in).deriveFont(0, 16.0F);
            titleFont = StyleContext.getDefaultStyleContext().getFont(baseFont.getName(), 0, 64);
        }
        catch (Exception e)
        {
            throw new RuntimeException("Failed to load runescape.ttf", e);
        }
    }

    private JPanel createTitlePanel(String text)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                BorderFactory.createEmptyBorder(4, 6, 4, 6) // Padding sized to text height
        ));
        JLabel titleText = new JLabel(text, SwingConstants.CENTER);
        container.add(titleText);
        return container;
    }

    public void buildIntroPanel()
    {
        removeAll();
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Main title
        JLabel title = new JLabel("One Shot", SwingConstants.CENTER);
        title.setFont(titleFont);

        // Icon
        JLabel iconLabel = new JLabel(Icons.RED_HELM);

        // Default intro text
        changeIntroText1("Welcome to One Shot Plugin");
        changeIntroText2("Please enter the clan chat to continue");

        // Footer label
        JLabel hardcoreInfo = new JLabel("Hardcore Ironman exclusive", SwingConstants.CENTER);

        add(title);
        add(hardcoreInfo);
        add(Box.createVerticalStrut(10));
        add(iconLabel);
        add(Box.createVerticalStrut(15));
        add(intro_top_text);
        add(intro_bottom_text);

        revalidate();
        repaint();
    }

    public void changeIntroText1(String text)
    {
        intro_top_text.setText(text);
    }

    public void changeIntroText2(String text)
    {
        intro_bottom_text.setText(text);
    }


    public void buildMainPanel(boolean isModerator, String playerName, String clanRankName, ImageIcon iconRank,
                               ArrayList<OneShotPlugin.OneShotMember> allMembersRanksInfo, Map<String, ImageIcon> members,
                               Map<String, String> allMembersDisplayNames)
    {

        this.allMembersRanksInfo = allMembersRanksInfo;
        this.allMembersIcons = members;
        this.allMembersDisplayNames = allMembersDisplayNames;

        removeAll();

        this.playerName = playerName;
        this.playerRank = clanRankName;

        // button panel
        int nIcons = isModerator ? Constants.BUTTON_NUMBER : Constants.BUTTON_NUMBER - 1;
        this.isModerator = isModerator;

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(1, nIcons, 5, 5));

        ImageIcon iconInfo = Icons.INFO;
        ImageIcon iconRanks = Icons.RANKING;
        ImageIcon iconDiscord = Icons.DISCORD;
        ImageIcon iconScout = Icons.MODTOOLS;

        JButton infoButton = buildButton(iconInfo, () -> {
            try {
                buildRolesPanel();
            } catch (IOException | InterruptedException e) {
                throw new RuntimeException(e);
            }
        }, Constants.TIP_ROLES);
        JButton ranksButtons = buildButton(iconRanks, this::buildLeaderboardsPanel, Constants.TIP_LEADERBOARDS);
        JButton discordButton = buildButton(iconDiscord, this::buildDiscordPanel, Constants.TIP_DISCORD);
        JButton scoutButton = buildButton(iconScout, this::buildModToolsPanel, Constants.TIP_MODTOOLS);


        ImageIcon icon = Icons.RED_HELM_SMALLER;
        JLabel image = new JLabel(icon);

        Font fontTitle;

        try (
                InputStream inRunescape = FontManager.class.getResourceAsStream("runescape.ttf");
        ) {
            Font font = Font.createFont(0, inRunescape).deriveFont(0, 16.0F);
            fontTitle = StyleContext.getDefaultStyleContext().getFont(font.getName(), 0, 32);
        } catch (FontFormatException ex) {
            throw new RuntimeException("Font loaded, but format incorrect.", ex);
        } catch (IOException ex) {
            throw new RuntimeException("Font file not found.", ex);
        }

        JLabel title = new JLabel("One Shot", SwingConstants.CENTER);
        title.setFont(fontTitle);

        add(image);
        add(Box.createGlue());
        add(title);

        buttonPanel.add(infoButton);
        buttonPanel.add(ranksButtons);
        buttonPanel.add(discordButton);
        if (isModerator)
        {
            buttonPanel.add(scoutButton);
        }
        add(buttonPanel);

        // Main Panel
        panelMainContent.removeAll();
        add(panelMainContent);


        update();
    }

    private void buildRolesPanel() throws IOException, InterruptedException {
        isInInfoPanel = true;

        panelMainContent.removeAll();
        JPanel container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        JPanel titlePanel = createTitlePanel("Clan Roles");
        titlePanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 24));
        container.add(titlePanel);
        JPanel allMembersRanks = buildAllMembersRanksTotal();
        container.add(allMembersRanks);
        panelMainContent.add(container);
        update();
    }

    private JPanel buildAllMembersRanksTotal() {
        JPanel wrapper = new JPanel(new BorderLayout());
//        wrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
//        wrapper.setBorder(BorderFactory.createEmptyBorder(4, 6, 4, 6)); // padding from edges

        JPanel container = new JPanel();
        container.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        container.setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 0;
        c.ipadx = 10;
        c.ipady = 1;
        c.weightx=0.5;

        JLabel HeaderIcon = new JLabel("Icon");
        HeaderIcon.setHorizontalAlignment(SwingConstants.CENTER);
        JLabel HeaderRank = new JLabel("Rank");
        JLabel HeaderOnline = new JLabel("Online");
        HeaderOnline.setHorizontalAlignment(SwingConstants.CENTER);
        JLabel HeaderTotal = new JLabel("Total");
        HeaderTotal.setHorizontalAlignment(SwingConstants.CENTER);
        container.add(HeaderIcon, c);
        c.gridx = 1;
        container.add(HeaderRank, c);
        c.gridx = 2;
        container.add(HeaderOnline, c);
        c.gridx = 3;
        container.add(HeaderTotal, c);

        //ArrayList<OneShotPlugin.MemberRank> allMembersRanksInfo;

        for (OneShotPlugin.OneShotMember oneShotMember : allMembersRanksInfo)
        {
            JLabel iconLabel = new JLabel();
            iconLabel.setHorizontalAlignment(SwingConstants.CENTER);
            iconLabel.setIcon(oneShotMember.getIcon());
            JLabel rankLabel = new JLabel();
            rankLabel.setText(oneShotMember.getName());
            JLabel onlineLabel = new JLabel();
            onlineLabel.setHorizontalAlignment(SwingConstants.CENTER);
            onlineLabel.setText(String.valueOf(oneShotMember.getOnline()));
            JLabel totalLabel = new JLabel();
            totalLabel.setHorizontalAlignment(SwingConstants.CENTER);
            totalLabel.setText(String.valueOf(oneShotMember.getTotal()));
            if (Objects.equals(playerRank, oneShotMember.getName())) {
                rankLabel.setForeground(Color.GREEN);
                onlineLabel.setForeground(Color.GREEN);
                totalLabel.setForeground(Color.GREEN);
            };

            c.gridy++;
            c.gridx = 0;
            container.add(iconLabel, c);
            c.gridx = 1;
            container.add(rankLabel, c);
            c.gridx = 2;
            container.add(onlineLabel, c);
            c.gridx = 3;
            container.add(totalLabel, c);
        }

        c.gridy++;
        c.gridx = 0;
        c.gridwidth = 4;

        JLabel discordPlug = new JLabel("/rank in discord #bot-commands", SwingConstants.CENTER);
        discordPlug.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        container.add(discordPlug, c);

        wrapper.add(container, BorderLayout.CENTER);
        return wrapper;
    }

    private JPanel buildTopChartsPanel() throws IOException, InterruptedException {
        JPanel container = new JPanel();
        container.setBorder(BorderFactory.createEmptyBorder(4, 6, 4, 6));
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));

        JPanel title = createTitlePanel("Top players Skills and KCs");

        String response = rateLimitedHttpCache.fetch(Constants.URI_WOM_LEADERS);

        JsonParser jsonParser = new JsonParser();
        JsonElement jsonElement = jsonParser.parse(response);

        JsonElement metricLeaders = jsonElement.getAsJsonObject().get(Constants.URI_WOM_LEADERS_OBJECT);

        container.add(title);

        // Panel that holds skill icons
        JPanel statsPanel = new JPanel();
        statsPanel.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        statsPanel.setLayout(new GridLayout(8, 3));
        statsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // For each skill on the ingame skill panel, create a Label and add it to the UI
        for (HiscoreSkill skill : SKILLS)
        {
            JPanel panel = makeHiscorePanel(skill);
            statsPanel.add(panel);
        }

        container.add(statsPanel);

        JPanel totalPanel = new JPanel();
        totalPanel.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        totalPanel.setLayout(new GridLayout(1, 1));
        totalPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        totalPanel.add(makeHiscorePanel(OVERALL));

        container.add(totalPanel);

        JPanel minigamePanel = new JPanel();
        minigamePanel.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        minigamePanel.setLayout(new GridLayout(1, 2));
        minigamePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        for (HiscoreSkill skill : ACTIVITIES)
        {
            JPanel panel = makeHiscorePanel(skill);
            minigamePanel.add(panel);
        }

        container.add(minigamePanel);

        JPanel bossPanel = new JPanel();
        bossPanel.setBorder(BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        bossPanel.setLayout(new GridLayout(0, 3));
        bossPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // For each boss on the hi-scores, create a Label and add it to the UI
        for (HiscoreSkill skill : BOSSES)
        {
            JPanel panel = makeHiscorePanel(skill);
            bossPanel.add(panel);
        }

        container.add(bossPanel);

        populateMetricLeadersAsync(metricLeaders);

        return container;
    }

    private void buildTopChartsAsync() {

        SwingWorker<JPanel, Void> worker = new SwingWorker<>() {

            @Override
            protected JPanel doInBackground() throws Exception {
                // EVERYTHING SLOW happens here
                return buildTopChartsPanel();
            }

            @Override
            protected void done() {
                try {
                    JPanel panel = get();

                    // Add panel to your UI (EDT)
                    panelMainContent.removeAll();
                    panelMainContent.add(panel);
                    panelMainContent.revalidate();
                    panelMainContent.repaint();

                } catch (Exception ex) {
                    ex.printStackTrace();
                }
            }
        };

        worker.execute();
    }

    private void populateMetricLeadersAsync(JsonElement metricLeaders) {

        SwingWorker<Map<JButton, ButtonUpdate>, Void> worker = new SwingWorker<>() {

            @Override
            protected Map<JButton, ButtonUpdate> doInBackground() {
                Map<JButton, ButtonUpdate> updates = new HashMap<>();

                for (Map.Entry<HiscoreSkill, JButton> entry : skillButtons.entrySet()) {

                    HiscoreSkill skill = entry.getKey();
                    JButton button = entry.getValue();

                    // compute everything in the background
                    ButtonUpdate update = computeButtonInfo(skill, metricLeaders);

                    // store result (no Swing calls here!)
                    updates.put(button, update);
                }

                return updates;
            }

            @Override
            protected void done() {
                try {
                    // safely apply updates on the Swing thread
                    Map<JButton, ButtonUpdate> updates = get();

                    for (Map.Entry<JButton, ButtonUpdate> entry : updates.entrySet()) {
                        JButton button = entry.getKey();
                        ButtonUpdate update = entry.getValue();

                        button.setForeground(update.color);
                        button.setText(update.text);
                        button.setToolTipText(update.tooltip);
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        };

        worker.execute();
    }

    private ButtonUpdate computeButtonInfo(HiscoreSkill skill, JsonElement metricLeaders) {

        String name = normalizeSkillName(skill);
        String element;
        String id;
        JsonElement metric;

        if (SKILLS.contains(skill) || name.equals("overall")) {
            element = "skills";
            id = "experience";
            metric = metricLeaders.getAsJsonObject().get(element)
                    .getAsJsonObject().get(name);

            Color col = metric.getAsJsonObject()
                    .get("player").getAsJsonObject()
                    .get("displayName").getAsString().equals(playerName)
                    ? Color.GREEN : Color.WHITE;

            String text = name.equals("overall")
                    ? metric.getAsJsonObject().get("level").getAsString()
                    : String.valueOf(Experience.getLevelForXp(
                    metric.getAsJsonObject().get(id).getAsInt()));

            return new ButtonUpdate(col, text, detailsHtml(skill, metric));
        }

        else if (BOSSES.contains(skill)) {
            element = "bosses";
            id = "kills";
            metric = metricLeaders.getAsJsonObject().get(element)
                    .getAsJsonObject().get(name);

            double kills = metric.getAsJsonObject().get(id).getAsDouble();
            Color col = kills == 0 ? Color.RED :
                    metric.getAsJsonObject().get("player")
                            .getAsJsonObject().get("displayName")
                            .getAsString().equals(playerName)
                            ? Color.GREEN : Color.WHITE;

            return new ButtonUpdate(col, metric.getAsJsonObject().get(id).getAsString(),
                    detailsHtml(skill, metric));
        }

        else if (ACTIVITIES.contains(skill)) {
            element = "activities";
            id = "score";
            metric = metricLeaders.getAsJsonObject().get(element)
                    .getAsJsonObject().get(name);

            double score = metric.getAsJsonObject().get(id).getAsDouble();
            Color col = score == 0 ? Color.RED :
                    metric.getAsJsonObject().get("player")
                            .getAsJsonObject().get("displayName")
                            .getAsString().equals(playerName)
                            ? Color.GREEN : Color.WHITE;

            return new ButtonUpdate(col,
                    metric.getAsJsonObject().get(id).getAsString(),
                    detailsHtml(skill, metric));
        }

        // fallback
        return new ButtonUpdate(Color.WHITE, "?", "Unknown");
    }

    private static class ButtonUpdate {
        final Color color;
        final String text;
        final String tooltip;

        ButtonUpdate(Color color, String text, String tooltip) {
            this.color = color;
            this.text = text;
            this.tooltip = tooltip;
        }
    }

    private String detailsHtml(HiscoreSkill skill, JsonElement metricLeader) {

        JsonObject obj = metricLeader.getAsJsonObject();
        JsonObject player = obj.getAsJsonObject("player");
        String displayName = player.get("displayName").getAsString();

        StringBuilder sb = new StringBuilder();
        sb.append("<html><body style='padding:5px;color:#989898'>");

        boolean isSkill = SKILLS.contains(skill) || skill.getName().equalsIgnoreCase("overall");
        boolean isBoss  = BOSSES.contains(skill);
        boolean isActivity = ACTIVITIES.contains(skill);

        if (isSkill) {
            sb.append("<p><span style='color:white'>Skill:</span> ").append(skill.getName()).append("</p>");
            sb.append("<p><span style='color:white'>Name:</span> ").append(displayName).append("</p>");
            sb.append("<p><span style='color:white'>Rank:</span> ").append(QuantityFormatter.formatNumber(obj.get("rank").getAsDouble())).append("</p>");
            //sb.append("<p><span style='color:white'>Level:</span> ").append(QuantityFormatter.formatNumber(obj.get("level").getAsDouble())).append("</p>");
            sb.append("<p><span style='color:white'>Experience:</span> ").append(QuantityFormatter.formatNumber(obj.get("experience").getAsDouble())).append("</p>");
        }
        else if (isBoss) {
            sb.append("<p><span style='color:white'>Boss:</span> ").append(skill.getName()).append("</p>");

            double kills = obj.get("kills").getAsDouble();
            if (kills > 0) {
                double rank = obj.get("rank").getAsDouble();

                sb.append("<p><span style='color:white'>Name:</span> ").append(displayName).append("</p>");
                sb.append("<p><span style='color:white'>Rank:</span> ")
                        .append(rank > 0 ? QuantityFormatter.formatNumber(rank) : "--")
                        .append("</p>");
                //sb.append("<p><span style='color:white'>KC:</span> ").append(QuantityFormatter.formatNumber(kills)).append("</p>");
            } else {
                sb.append("<p>No one is ranked yet</p>");
            }
        }
        else if (isActivity) {
            sb.append("<p><span style='color:white'>").append(skill.getName()).append("</span></p>");

            double rank = obj.get("rank").getAsDouble();
            if (rank > 0) {
                sb.append("<p><span style='color:white'>Name:</span> ").append(displayName).append("</p>");
                sb.append("<p><span style='color:white'>Rank:</span> ").append(QuantityFormatter.formatNumber(rank))
                        .append("</p>");
            } else {
                sb.append("<p>No one is ranked yet</p>");
            }
        }
        else {
            log.debug("Houston, we have a problem");
            return "";
        }

        sb.append("</body></html>");
        return sb.toString();
    }


    private JPanel makeHiscorePanel(HiscoreSkill skill)
    {
        HiscoreSkillType skillType = skill == null ? HiscoreSkillType.SKILL : skill.getType();

        JButton button = new JButton();
        button.setToolTipText(skill == null ? "Combat" : skill.getName());
        button.setFont(FontManager.getRunescapeSmallFont());
        button.setText(pad("--", skillType));
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setMargin(new Insets(0,0,0,0));
        button.setBorderPainted(false);
        button.setPreferredSize(new Dimension(60,25));


        spriteManager.getSpriteAsync(skill == null ? SpriteID.SideIcons.COMBAT : skill.getSpriteId(), 0, (sprite) ->
                SwingUtilities.invokeLater(() ->
                {
                    // Icons are all 25x25 or smaller, so they're fit into a 25x25 canvas to give them a consistent size for
                    // better alignment. Further, they are then scaled down to 20x20 to not be overly large in the panel.
                    final BufferedImage scaledSprite = ImageUtil.resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                    button.setIcon(new ImageIcon(scaledSprite));
                }));

        boolean totalLabel = skill == OVERALL || skill == null; //overall or combat
        button.setIconTextGap(totalLabel ? 10 : 4);


        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                button.setBackground(pressedColor);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                buildSkillPlayersAsync(skill, 1);
                button.setBackground(hoverColor);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(hoverColor);
                button.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                button.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });

        JPanel skillPanel = new JPanel();
        skillPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        skillPanel.setBorder(new EmptyBorder(2, 0, 2, 0));
        skillButtons.put(skill, button);
        skillPanel.add(button);

        return skillPanel;
    }

    private void buildSkillPlayersAsync(HiscoreSkill skill, int pageNumber) {

        // STEP 1: show a temporary loading indicator
        panelMainContent.removeAll();
        panelMainContent.add(new JLabel("Loading...", SwingConstants.CENTER));
        update(); // revalidate+repaint

        SwingWorker<JsonArray, Void> worker = new SwingWorker<>() {

            @Override
            protected JsonArray doInBackground() throws Exception {
                String skillName = normalizeSkillName(skill);
                return fetchSkillData(skillName);   // <-- NO UI freeze now
            }

            @Override
            protected void done() {
                try {
                    JsonArray arr = get();
                    // now build UI on EDT
                    buildSkillPlayersUI(skill, pageNumber, arr);

                } catch (Exception e) {
                    e.printStackTrace();
                    buildSkillPlayersUI(skill, pageNumber, null);
                }
            }
        };

        worker.execute();
    }

    private void buildSkillPlayersUI(HiscoreSkill skill, int pageNumber, JsonArray arr) {
        panelMainContent.removeAll();

        if (arr == null)
        {
            JPanel empty = new JPanel();
            empty.setLayout(new BoxLayout(empty, BoxLayout.Y_AXIS));
            empty.add(goBackButton());

            JLabel message1 = new JLabel("Hey wow, too fast!");
            message1.setForeground(Color.RED);
            empty.add(message1);

            JLabel message2 = new JLabel("Please slow down");
            message2.setForeground(Color.RED);
            empty.add(message2);

            panelMainContent.add(empty);
            update();
            return;
        }

        if (arr.size() == 0) {
            JPanel empty = new JPanel();
            empty.setLayout(new BoxLayout(empty, BoxLayout.Y_AXIS));
            empty.add(goBackButton());

            JLabel message = new JLabel("Seems no one is on the Hiscores");
            message.setForeground(Color.RED);
            empty.add(message);

            panelMainContent.add(empty);
            update();
            return;
        }

        String skillName = normalizeSkillName(skill);

        int nPages = (int) Math.ceil(arr.size() / 10.0);
        int playerIndex = (pageNumber - 1) * 10;
        int playerLimit = Math.min(10, arr.size() - playerIndex);

        int highlightPosition = findPlayerPosition(arr, this.playerName);

        JPanel container = new JPanel(new GridBagLayout());
        GridBagConstraints c = createDefaultGBC();


        // Add skill header
        addHeader(container, c, skill);

        JComponent table = buildPlayerTable(
                arr, skill, skillName,
                playerIndex, playerLimit, highlightPosition);

        container.add(table, c);
        c.gridy++;

        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.weighty = 0;
        container.add(
                buildSkillPlayersScroller(skill, pageNumber, nPages, highlightPosition),
                c
        );
        c.gridy++;

        panelMainContent.add(container);
        update();
    }



    private JPanel buildSkillPlayersScroller(HiscoreSkill skill, int currentPage, int nPages, int playerPosition) {

        JPanel container = new JPanel(new GridBagLayout());

        GridBagConstraints c = createDefaultGBC();
//        log.debug(String.valueOf(playerPosition));

        int playerPage = (playerPosition / 10) + 1; // each page shows 10 players

        // Navigation actions
        Runnable goFirst = () -> safeBuildSkillPlayers(skill, 1);
        Runnable goPrev  = () -> safeBuildSkillPlayers(skill, currentPage - 1);
        Runnable goNext  = () -> safeBuildSkillPlayers(skill, currentPage + 1);
        Runnable goLast  = () -> safeBuildSkillPlayers(skill, nPages);
        Runnable gotoPlayer  = () -> safeBuildSkillPlayers(skill, playerPage);

        // Create the navigation buttons
        JButton btnFirst = buildButton("<<", currentPage > 1, 35, 20, goFirst);
        JButton btnPrev  = buildButton("<",  currentPage > 1, 35, 20, goPrev);
        JButton btnNext  = buildButton(">",  currentPage < nPages, 35, 20, goNext);
        JButton btnLast  = buildButton(">>", currentPage < nPages, 35, 20, goLast);
        JButton btnGoToPlayer = buildButton("Go to my position", currentPage != playerPage && playerPosition != -1, 0, 20, gotoPlayer);

        JLabel pageLabel = new JLabel(String.valueOf(currentPage), SwingConstants.CENTER);

        // Layout
        container.add(btnFirst, c);
        c.gridx++;
        container.add(btnPrev, c);
        c.gridx++;
        container.add(pageLabel, c);
        c.gridx++;
        container.add(btnNext, c);
        c.gridx++;
        container.add(btnLast, c);

        // -----------------------------
        // Add "Go to Player" button below
        c.gridx = 0;
        c.gridy++;
        c.gridwidth = 5;
        c.fill = GridBagConstraints.HORIZONTAL;

        container.add(btnGoToPlayer, c);

        return container;
    }

    private void safeBuildSkillPlayers(HiscoreSkill skill, int page) {
        SwingUtilities.invokeLater(() -> {   // safe UI thread update
            buildSkillPlayersAsync(skill, page);
        });
    }


    private JButton buildButton(String displayText, boolean enableClick, int width, int height, Runnable callback)
    {
        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();
        final Color defaultColor = enableClick ? ColorScheme.DARKER_GRAY_COLOR : ColorScheme.DARK_GRAY_COLOR;

        JButton button = new JButton(displayText);
        button.setPreferredSize(new Dimension(width, height));
        button.setBackground(defaultColor);
        button.setBorderPainted(enableClick);

        if (enableClick) {
            button.addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    button.setBackground(pressedColor);
                }

                @Override
                public void mouseReleased(MouseEvent e) {
                    callback.run();
                    button.setBackground(hoverColor);
                }

                @Override
                public void mouseEntered(MouseEvent e) {
                    button.setBackground(hoverColor);
                    button.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                }

                @Override
                public void mouseExited(MouseEvent e) {
                    button.setBackground(defaultColor);
                    button.setCursor(Cursor.getDefaultCursor());
                }
            });
        } else {
            button.setForeground(defaultColor);
            // Disabled button: just ensure consistent color, no hover effects needed
            button.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseEntered(MouseEvent e) { button.setBackground(defaultColor); }
                @Override
                public void mouseExited(MouseEvent e) { button.setBackground(defaultColor); }
                @Override
                public void mousePressed(MouseEvent e) { button.setBackground(defaultColor); }
                @Override
                public void mouseReleased(MouseEvent e) { button.setBackground(defaultColor); }
            });
            button.setRolloverEnabled(false);
            button.setFocusPainted(false);
//            button.setEnabled(false);
        }

        return button;
    }

    private int findPlayerPosition(JsonArray jsonArray, String playerName){
        for (int i = 0; i < jsonArray.size(); i++){
            String displayName = jsonArray.get(i).getAsJsonObject().get("player").getAsJsonObject().get("username").getAsString();
            displayName = displayName.replace(" ", " ");
            if (Objects.equals(playerName.toLowerCase(), displayName)) { return i; }
        }
        return -1;
    }

    private static final NavigableMap<Long, String> suffixes = new TreeMap<> ();
    static {
        suffixes.put(1_000L, "k");
        suffixes.put(1_000_000L, "M");
        suffixes.put(1_000_000_000L, "B");
    }

    private String formatNumber (long value)
    {
        //Long.MIN_VALUE == -Long.MIN_VALUE so we need an adjustment here
        if (value == Long.MIN_VALUE) return formatNumber(Long.MIN_VALUE + 1);
        if (value < 0) return "-" + formatNumber(-value);
        if (value < 1000) return Long.toString(value); //deal with easy case

        Map.Entry<Long, String> e = suffixes.floorEntry(value);
        Long divideBy = e.getKey();
        String suffix = e.getValue();

        long div = value / divideBy;          // Whole part
        long dec1 = (value * 10 / divideBy) % 10;     // One decimal
        long dec2 = (value * 100 / divideBy) % 100;   // Two decimals

        boolean show2 = div < 10;
        boolean show1 = div < 100;

        if (show2) {
            return String.format("%d.%02d%s", div, dec2, suffix);
        } else if (show1) {
            return String.format("%d.%d%s", div, dec1, suffix);
        } else {
            return String.format("%d%s", div, suffix);
        }
    }

    private JButton goBackButton() {
        JButton goBack = new JButton("< Go Back"); // added "<"
        goBack.setBorderPainted(false);

        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        // Optional: smaller preferred width to reduce horizontal space
        goBack.setPreferredSize(new Dimension(80, 20));
        goBack.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        goBack.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                goBack.setBackground(pressedColor);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                panelMainContent.removeAll();
                buildTopChartsAsync();
                goBack.setBackground(hoverColor);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                goBack.setBackground(hoverColor);
                goBack.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                goBack.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                goBack.setCursor(Cursor.getDefaultCursor());
            }
        });

        // Align to the left in its container
        goBack.setHorizontalAlignment(SwingConstants.LEFT);

        return goBack;
    }

    private static String pad(String str, HiscoreSkillType type)
    {
        // Left pad label text to keep labels aligned
        int pad = type == HiscoreSkillType.BOSS ? 4 : 2;
        return StringUtils.leftPad(str, pad);
    }


    private void buildDiscordPanel() {
        LinkBrowser.browse(Constants.LINK_DISCORD);
//        clientThread.invokeLater(() ->
//        {
//            client.addChatMessage(
//                    ChatMessageType.GAMEMESSAGE,
//                    "",
//                    "You've completed enough Combat Achievement tasks to unlock Easy Tier rewards! You can now claim your rewards from Ghommal.",
//                    null
//            );
//        });
    }

    private void buildLeaderboardsPanel()
    {
        isInInfoPanel = false;
        panelMainContent.removeAll();
        try {
            buildTopChartsAsync();
        } catch (NullPointerException e)
        {
            panelMainContent.add(new JLabel("Something went wrong"));
            log.error(e.getMessage());
        }
        update();
    }

    private void buildModToolsPanel() {
        panelMainContent.removeAll();
        isInInfoPanel = false;
        panelMainContent.add(modToolsPanel);

        update();
    }

    private static JButton buildButton(ImageIcon icon, Runnable callback)
    {
        return buildButton(icon, callback, "");
    }

    private static JButton buildButton(ImageIcon icon, Runnable callback, String tip)
    {
        JButton button = new JButton(icon);

        button.setBackground(ColorScheme.DARK_GRAY_COLOR);
        button.setBorderPainted(false);

        if (!Objects.equals(tip, ""))
        {
            button.setToolTipText(tip);
        }

        final Color hoverColor = ColorScheme.DARKER_GRAY_HOVER_COLOR;
        final Color pressedColor = ColorScheme.DARKER_GRAY_COLOR.brighter();

        button.setPreferredSize(new Dimension(Constants.BUTTON_SIZE, Constants.BUTTON_SIZE));

        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                button.setBackground(pressedColor);
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                callback.run();
                button.setBackground(hoverColor);
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(hoverColor);
                button.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(ColorScheme.DARK_GRAY_COLOR);
                button.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            }
        });

        return button;
    }


    private static JPanel buildPlayerPanel(String playerName, String clanRankName, ImageIcon iconRank)
    {

        JPanel container  = new JPanel();
        container.setLayout(new GridLayout(1, 1));

        JPanel rankPanel = buildRankPanel(clanRankName, iconRank);

        JLabel playerLabel = new JLabel(playerName);
        JPanel playerPanel = new JPanel();
        playerPanel.add(playerLabel, BorderLayout.CENTER);
        container.add(playerPanel, BorderLayout.WEST);
        container.add(rankPanel, BorderLayout.EAST);

        return container;
    }

    private static JPanel buildRankPanel(String clanRankName, ImageIcon iconRank)
    {
        JLabel clanRankLabel = new JLabel(clanRankName);
        JLabel iconLabel = new JLabel(iconRank);
        JPanel container = new JPanel();

        container.add(iconLabel, BorderLayout.CENTER);
        container.add(clanRankLabel, BorderLayout.CENTER);

        return container;
    }

    private GridBagConstraints createDefaultGBC()
    {
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridx = 0;
        c.gridy = 0;
        c.ipadx = 10;
        c.ipady = 1;
        c.weightx = 1;
        c.weighty = 0;
        return c;
    }

    private void addHeader(JPanel container, GridBagConstraints c, HiscoreSkill skill) {
        c.fill = GridBagConstraints.NONE;
        c.anchor = GridBagConstraints.WEST;
        c.weightx = 0;
        container.add(goBackButton(), c);
        c.gridy++;
        c.weightx = 1;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.anchor = GridBagConstraints.CENTER;
        container.add(buildSkillHeader(skill), c);
        c.gridy++;
    }

    private String normalizeSkillName(HiscoreSkill skill) {
        String name = skill.toString().toLowerCase();
        return name.equals("runecraft") ? "runecrafting" : name.equals("clue_scroll_all") ? "clue_scrolls_all" : name;
    }

    private JsonArray fetchSkillData(String name)
            throws IOException, InterruptedException
    {
        String url = Constants.URI_WOM_SKILL_LEADERS + name + Constants.URI_WOM_SKILL_LEADERS_LIMIT;
        String response = rateLimitedHttpCache.fetch(url);
        if (response == null) { return null; }

        JsonParser jsonParser = new JsonParser();
        JsonArray arr = jsonParser.parse(response).getAsJsonArray();

        return cleanSkillJson(arr);
    }


    private JsonArray cleanSkillJson(JsonArray arr) {
        JsonArray cleaned = new JsonArray();

        for (int i = 0; i < arr.size(); i++) {
            JsonObject obj = arr.get(i).getAsJsonObject();
            JsonObject player = obj.getAsJsonObject("player");
            JsonObject data = obj.getAsJsonObject("data");

            int rank = data.get("rank").getAsInt();
            String username = player.get("username").getAsString().replace("\u00A0", " ");

            if (rank == -1) {
                //log.debug("Rank -1 found at index {} ({}), stopping and cutting the tail", i, username);
                break; // stop processing the rest of the array
            }

            if (!allMembersDisplayNames.containsKey(username)) {
                //log.debug("Removed unknown username {} ({})", i, username);
                continue; // skip this element, don’t add to cleaned array
            }

            cleaned.add(obj); // only valid elements are added
        }

        //log.debug("Array size after cleaning: {}", cleaned.size());

        return cleaned;
    }

    private JComponent buildPlayerTable(
            JsonArray arr,
            HiscoreSkill skill,
            String skillName,
            int startIndex,
            int count,
            int highlightIndex)
    {
        boolean isSkill = SKILLS.contains(skill) || skillName.equals("overall");
        boolean isBoss = BOSSES.contains(skill);

        List<PlayerRow> rows = new ArrayList<>();

        for (int i = startIndex; i < startIndex + count && i < arr.size(); i++)
        {
            JsonObject entry = arr.get(i).getAsJsonObject();
            JsonObject pdata = entry.getAsJsonObject("player");
            JsonObject ddata = entry.getAsJsonObject("data");

            String lower = pdata.get("username").getAsString().replace("\u00A0", " ");
            String display = allMembersDisplayNames.get(lower);
            ImageIcon icon = allMembersIcons.get(lower);

            int level = isSkill ? ddata.get("level").getAsInt()
                    : isBoss ? ddata.get("kills").getAsInt()
                    : ddata.get("score").getAsInt();

            long xp = isSkill ? ddata.get("experience").getAsLong() : 0;

            rows.add(new PlayerRow(
                    i + 1,
                    display,
                    icon,
                    level,
                    isSkill ? formatNumber(xp) : "",
                    i == highlightIndex
            ));
        }

        PlayerTableModel model = new PlayerTableModel(rows, isSkill, isBoss);
        JTable table = new JTable(model)
        {
            @Override
            public Component prepareRenderer(
                    javax.swing.table.TableCellRenderer r, int row, int col)
            {
                Component c = super.prepareRenderer(r, row, col);

                if (!isRowSelected(row))
                {
                    c.setBackground(
                            row % 2 == 0
                                    ? new Color(26, 26, 26)
                                    : new Color(32, 32, 32)
                    );
                }

                return c;
            }
        };

        styleTable(table, isSkill);

        // Fix phantom extra column
        while (table.getColumnModel().getColumnCount() > model.getColumnCount())
        {
            table.getColumnModel().removeColumn(
                    table.getColumnModel().getColumn(
                            table.getColumnModel().getColumnCount() - 1
                    )
            );
        }

        // Optional: stop JTable from resizing last column to fill viewport
        table.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);

        JScrollPane scrollPane = new JScrollPane(table);
        scrollPane.setBorder(null); // optional: cleaner look
        return scrollPane;
    }


    private static class PlayerRow {
        final int rank;
        final String name;
        final ImageIcon icon;
        final int level;
        final String exp;
        final boolean highlight;

        PlayerRow(int rank, String name, ImageIcon icon,
                  int level, String exp, boolean highlight)
        {
            this.rank = rank;
            this.name = name;
            this.icon = icon;
            this.level = level;
            this.exp = exp;
            this.highlight = highlight;
        }
    }

    private JPanel buildSkillHeader(HiscoreSkill skill) {
        JPanel header = new JPanel() {
            @Override
            public Dimension getMaximumSize() {
                return new Dimension(Integer.MAX_VALUE, super.getPreferredSize().height);
            }
        };
        header.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 5));
        header.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Skill icon
        JLabel iconLabel = new JLabel();
        spriteManager.getSpriteAsync(
                skill == null ? SpriteID.SideIcons.COMBAT : skill.getSpriteId(),
                0,
                sprite -> SwingUtilities.invokeLater(() -> {
                    BufferedImage scaled = ImageUtil.resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 30, 30);
                    iconLabel.setIcon(new ImageIcon(scaled));
                })
        );

        // Skill name (with shrinking only if needed)
        final float originalFontSize = 18f;
        JLabel nameLabel = new JLabel(skill.getName()) {
            @Override
            protected void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g;
                Font font = getFont().deriveFont(originalFontSize);
                FontMetrics fm = g2d.getFontMetrics(font);

                int availableWidth = 180; // small padding
                String text = getText();

                // Only shrink if text width exceeds available width
                if (fm.stringWidth(text) > availableWidth) {
                    while (fm.stringWidth(text) > availableWidth && font.getSize() > 8) {
                        font = font.deriveFont((float) (font.getSize() - 1));
                        fm = g2d.getFontMetrics(font);
                    }
                }

                setFont(font);
                super.paintComponent(g);
            }
        };

        nameLabel.setForeground(Color.WHITE);
        nameLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(originalFontSize));

        header.add(iconLabel);
        header.add(nameLabel);

        return header;
    }



    private static class PlayerTableModel extends javax.swing.table.AbstractTableModel {

        private final List<PlayerRow> rows;
        private final String[] cols;

        PlayerTableModel(List<PlayerRow> rows, boolean skill, boolean boss)
        {
            this.rows = rows;
            this.cols = skill
                    ? new String[]{"#", "Player", "Level", "Exp"}
                    : boss ? new String[]{"#", "Player", "Kills"}
                    : new String[]{"#", "Player", "Total"};
        }

        @Override public int getRowCount() { return rows.size(); }
        @Override public int getColumnCount() { return cols.length; }
        @Override public String getColumnName(int c) { return cols[c]; }

        @Override
        public Object getValueAt(int r, int c)
        {
            PlayerRow row = rows.get(r);

            if (cols.length == 4) { // Skill
                switch(c) {
                    case 0: return row.rank;
                    case 1: return row;
                    case 2: return row.level;
                    case 3: return row.exp;
                }
            } else { // Boss / Activity
                switch(c) {
                    case 0: return row.rank;
                    case 1: return row;
                    case 2: return row.level; // kills or total
                }
            }

            return null;
        }


        @Override
        public Class<?> getColumnClass(int col)
        {
            return col == 0 || col == 2 ? Integer.class : Object.class;
        }
    }

    private void styleTable(JTable table, boolean isSkill) {
        table.setRowHeight(22);
        table.setShowGrid(false);
        table.setIntercellSpacing(new Dimension(0, 0));
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(Color.WHITE);
        table.setFont(FontManager.getRunescapeSmallFont());

        table.getTableHeader().setReorderingAllowed(false);
        table.getTableHeader().setResizingAllowed(false);

        // Column widths
        if (isSkill){
            table.getColumnModel().getColumn(0).setMaxWidth(35);  // #
            table.getColumnModel().getColumn(1).setMaxWidth(125); // name + icon
            table.getColumnModel().getColumn(2).setMaxWidth(40);  // level/total
            table.getColumnModel().getColumn(3).setMaxWidth(50); // only for skills
        }
        else {
            table.getColumnModel().getColumn(0).setMaxWidth(55);  // #
            table.getColumnModel().getColumn(1).setMaxWidth(130); // name + icon
            table.getColumnModel().getColumn(2).setMaxWidth(60);  // kills/score
        }


        table.getColumnModel().getColumn(1).setCellRenderer(new PlayerRenderer());

        // Numeric columns
        for (int col = 0; col < table.getColumnCount(); col++) {
            if (col != 1) {
                table.getColumnModel().getColumn(col).setCellRenderer(new DefaultTableCellRenderer() {
                    @Override
                    public Component getTableCellRendererComponent(
                            JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                        super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                        PlayerTableModel model = (PlayerTableModel) table.getModel();
                        PlayerRow playerRow = model.rows.get(row);

                        if (playerRow.highlight) {
                            setForeground(Color.GREEN);
                            setBackground(new Color(0, 40, 0));
                        } else if (isSelected) {
                            setForeground(Color.WHITE);
                            setBackground(new Color(50, 50, 50));
                        } else {
                            setForeground(Color.WHITE);
                            setBackground(row % 2 == 0 ? new Color(26, 26, 26) : new Color(32, 32, 32));
                        }

                        setHorizontalAlignment(SwingConstants.CENTER);
                        return this;
                    }
                });
            }
        }

        // Adaptive width for the last column (Exp/Kills/Total)
        if (isSkill) {
            table.getColumnModel().getColumn(3).setMaxWidth(80);
            table.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
        } else {
            table.setAutoResizeMode(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS);
        }

        table.setPreferredScrollableViewportSize(
                new Dimension(panelMainContent.getWidth(), table.getRowHeight() * table.getRowCount())
        );
        table.setFillsViewportHeight(true);
    }



    private static class PlayerRenderer extends DefaultTableCellRenderer {
        @Override
        public Component getTableCellRendererComponent(
                JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int col)
        {
            super.getTableCellRendererComponent(table, "", isSelected, hasFocus, row, col);

            PlayerRow r = value instanceof PlayerRow ? (PlayerRow) value : null;

            if (r != null) {
                setText(" " + r.name);
                setIcon(r.icon);
                setHorizontalAlignment(LEFT);

                if (r.highlight) {
                    setForeground(Color.GREEN);
                    setBackground(new Color(0, 40, 0)); // optional darker green background
                } else if (isSelected) {
                    setForeground(Color.WHITE);
                    setBackground(new Color(50, 50, 50)); // selection color
                } else {
                    setForeground(Color.WHITE);
                    setBackground(row % 2 == 0 ? new Color(26, 26, 26) : new Color(32, 32, 32));
                }
            }

            return this;
        }
    }



    public class RateLimitedHttpCache {

        private static final long TTL_MILLIS = 60 * 1000; // 1 minute
        private final ConcurrentHashMap<String, CachedItem> cache = new ConcurrentHashMap<>();
        private final Semaphore rateLimiter;
        private final ScheduledExecutorService scheduler;


        private class CachedItem {
            final String response;
            final long timestamp;

            CachedItem(String response, long timestamp) {
                this.response = response;
                this.timestamp = timestamp;
            }
        }

        public RateLimitedHttpCache(int maxRequests, int refillIntervalSeconds) {
            this.rateLimiter = new Semaphore(maxRequests);
            this.scheduler = Executors.newScheduledThreadPool(1);

            // Refill one token every interval
            scheduler.scheduleAtFixedRate(() -> {
                if (rateLimiter.availablePermits() < maxRequests) {
                    rateLimiter.release();
                }
            }, refillIntervalSeconds, refillIntervalSeconds, TimeUnit.SECONDS);
        }

        /**
         * Fetch a URL: returns cached response if fresh.
         * Returns null if rate limit has been exhausted.
         */
        public String fetch(String url) throws IOException, InterruptedException {
            CachedItem item = cache.get(url);
            long now = System.currentTimeMillis();

            if (item != null && now - item.timestamp < TTL_MILLIS) {
                return item.response;
            }

            // Non-blocking check for rate limiter
            boolean allowed = rateLimiter.tryAcquire();
            if (!allowed) {
                // Rate limit exhausted → return null immediately
                log.debug("no more tokens available");
                return null;
            }

            Request request = new Request.Builder()
                    .url(url)
                    .get()
                    .build();

            Call call = httpClient.newCall(request);

            try (Response response = call.execute())
            {
                if (!response.isSuccessful())
                {
                    log.debug("HTTP error {} for {}", response.code(), url);
                    return null;
                }

                ResponseBody body = response.body();
                if (body == null)
                {
                    return null;
                }

                String responseBody = body.string();
                cache.put(url, new CachedItem(responseBody, now));
                return responseBody;
            }
        }

        public void shutdown() {
            scheduler.shutdown();
        }
    }

}




package com.oneshot;

import com.oneshot.modules.DiaryImages;
import com.oneshot.modules.DiscordClient;
import com.oneshot.modules.ModTools;
import com.oneshot.modules.ModToolsPanel;
import com.oneshot.utils.Constants;
import com.oneshot.utils.Icons;

import com.google.inject.Provides;

import net.runelite.api.*;
import net.runelite.api.annotations.Component;
import net.runelite.api.clan.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.ClientToolbar;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.concurrent.CompletableFuture;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;

import net.runelite.client.util.Text;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static net.runelite.api.Experience.MAX_REAL_LEVEL;

@PluginDescriptor(
	name = Constants.PLUGIN_NAME
)

public class OneShotPlugin extends Plugin
{
    private static final Logger log = LoggerFactory.getLogger(OneShotPlugin.class);

    @Inject
    private ModTools modTools;

    @Inject
	private Client client;

    @Inject
    private OneShotConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ChatIconManager chatIconManager;

    @Inject
    private DrawManager drawManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private DiscordClient discordClient;

    private boolean isMember = false;
    private boolean isModerator = false;

    private NavigationButton navButton;
    private OneShotPanel panel;
    private ModToolsPanel modToolsPanel;

    private CompletableFuture<Image> pendingDeathScreenshot = null;
    private String pendingDeathKiller = null;
    private boolean deathAwaitingVarbit = false;
    private CompletableFuture<Image> pendingScreenshot;
    private boolean hideChatForScreenshot;
    private int screenshotDelayTicks;

    private volatile boolean levelsInitialized = false;
    private volatile boolean diariesInitialized = false;
    private final Map<String, Integer> currentLevels = new HashMap<>();
    private final Map<Skill, Integer> currentXp = new EnumMap<>(Skill.class);
    public static final int LEVEL_FOR_MAX_XP = Experience.MAX_VIRT_LEVEL + 1; // 127
    private static final Set<WorldType> SPECIAL_WORLDS = Set.of(WorldType.PVP_ARENA, WorldType.QUEST_SPEEDRUNNING, WorldType.BETA_WORLD, WorldType.NOSAVE_MODE, WorldType.TOURNAMENT_WORLD, WorldType.DEADMAN, WorldType.SEASONAL);
    private static final int LOGIN_IGNORE_TICKS = 5;
    private int ticksSinceLogin = LOGIN_IGNORE_TICKS;
    private final Map<Integer, Integer> lastVarbitValues = new HashMap<>();

    private String clanRankName;

    private static final Pattern COLLECTION_LOG_ITEM_REGEX = Pattern.compile("New item added to your collection log:.*");
    private static final String COLLECTION_LOG_TEXT = "New item added to your collection log: ";
//    private static final Pattern PET_LOG_ITEM_REGEX = Pattern.compile("You (?:have a funny feeling like you|feel something weird sneaking).*");
    private static final Pattern COMBAT_TIER_REGEX = Pattern.compile("You've completed enough Combat Achievement tasks to unlock (\\w+) Tier rewards!.*");
//    private static final Pattern COMPLETION_REGEX = Pattern.compile("Congratulations! You have completed all of the (?<difficulty>.+) tasks in the (?<area>.+) area");

    @Provides
    OneShotConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(OneShotConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
        log.debug("Startup");

        clientThread.invoke(() ->
        {
            panel = injector.getInstance(OneShotPanel.class);
            modToolsPanel = injector.getInstance(ModToolsPanel.class);
            panel.init(client, clientThread, modToolsPanel);

            ClanChannel clan = client.getClanChannel();
            if (clan != null)
            {
                ClanChannelMember local = clan.findMember(client.getLocalPlayer().getName());

                if (local != null)
                {
                    ClanRank clanRank = local.getRank();
                    ClanSettings clanSettings = client.getClanSettings();
                    ClanTitle clanTitle = clanSettings.titleForRank(clanRank);

                    this.clanRankName = mapRankTitle(clanTitle);

                    boolean moderator = isModerator(clanRank);
                    isMember = true;
                    isModerator = moderator;

                    if (moderator)
                        modTools.init(modToolsPanel);

                    panel.buildMainPanel(
                            moderator,
                            client.getLocalPlayer().getName(),
                            mapRankTitle(clanTitle),
                            getRankIcon(clanTitle),
                            getAllMembersInfo(),
                            getMembersIcons(),
                            getMembersDisplayName()
                    );
                }
            }

            // UI BUTTON MUST BE ADDED ON SWING THREAD
            SwingUtilities.invokeLater(() -> {
                navButton = NavigationButton.builder()
                        .tooltip(Constants.PLUGIN_NAME)
                        .icon(Icons.RED_HELM_IMAGE)
                        .priority(Constants.DEFAULT_PRIORITY)
                        .panel(panel)
                        .build();

                clientToolbar.addNavigation(navButton);
            });
        });
    }


    @Override
	protected void shutDown() throws Exception
	{
        log.debug("Shutdown");
        panel.deinit();
        clientToolbar.removeNavigation(navButton);
        panel = null;
        navButton = null;
	}

    private void updateClanPanel() throws IOException, InterruptedException
    {
        if (!isMember)
            return;

        ClanChannel clan = client.getClanChannel();
        if (clan == null)
            return;

        ClanChannelMember local = clan.findMember(client.getLocalPlayer().getName());
        if (local == null)
            return;

        ClanRank rank = local.getRank();
        ClanSettings settings = client.getClanSettings();
        ClanTitle title = settings.titleForRank(rank);

        isModerator = isModerator(rank);

        panel.refresh(
                isModerator,
                client.getLocalPlayer().getName(),
                mapRankTitle(title),
                getRankIcon(title),
                getAllMembersInfo(),
                getMembersIcons(),
                getMembersDisplayName()
        );
    }


    @Subscribe
    public void onClanMemberJoined(ClanMemberJoined e) throws IOException, InterruptedException
    {
        updateClanPanel();
    }

    @Subscribe
    public void onClanMemberLeft(ClanMemberLeft e) throws IOException, InterruptedException
    {
        updateClanPanel();
    }


    @Subscribe
    public void onClanChannelChanged(ClanChannelChanged clanChannelChanged)
    {
        ClanChannel channel = clanChannelChanged.getClanChannel();

        if (channel == null)
        {
            panel.buildIntroPanel();
            isMember = false;
            isModerator = false;
            return;
        }

        String clanName = channel.getName();
        panel.buildIntroPanel();

        // Not One Shot CC
        if (!isOneShotMember(clanName))
        {
            panel.changeIntroText1("You are not part of One Shot CC");
            panel.changeIntroText2("You don't have access, sorry");

            isMember = false;
            isModerator = false;
            return;
        }

        // Guest of One Shot
        if (clanChannelChanged.isGuest())
        {
            panel.changeIntroText1("You are currently a guest of One Shot");
            panel.changeIntroText2("Become a member today!");

            isMember = false;
            isModerator = false;
            return;
        }

        // REAL MEMBER
        String playerName = client.getLocalPlayer().getName();
        ClanSettings settings = Objects.requireNonNull(client.getClanSettings());
        ClanRank rank = Objects.requireNonNull(settings.findMember(playerName)).getRank();
        ClanTitle title = Objects.requireNonNull(settings.titleForRank(rank));

        isMember = true;
        isModerator = isModerator(rank);

        if (isModerator)
            modTools.init(modToolsPanel);

        panel.buildMainPanel(
                isModerator,
                playerName,
                mapRankTitle(title),
                getRankIcon(title),
                getAllMembersInfo(),
                getMembersIcons(),
                getMembersDisplayName()
        );
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged e) throws IOException
    {
        if (!isMember)
            return;

        int id = e.getVarbitId();
        int value = e.getValue();

        // -----------------------------------------------------
        // 1. HANDLE HCIM DEATH VARBIT
        // -----------------------------------------------------
        handleHardcoreDeathVarbit(id);

        // -----------------------------------------------------
        // 2. HANDLE DIARY COMPLETION VARBITS
        // -----------------------------------------------------
        if (diariesInitialized)
            handleDiaryVarbit(id, value);
    }

    private void handleHardcoreDeathVarbit(int id)
    {
        if (id != VarbitID.IRONMAN_HARDCORE_DEAD)
            return;

        if (!deathAwaitingVarbit)
            return;

        log.debug("HCIM death varbit triggered!");

        if (pendingDeathScreenshot != null && config.announcedeaths())
        {
            pendingDeathScreenshot.thenAccept(img -> {
                try
                {
                    discordClient.sendDeath(
                            pendingDeathKiller != null ? pendingDeathKiller : "",
                            CompletableFuture.completedFuture(img)
                    );
                }
                catch (Exception ex)
                {
                    log.error("Failed sending HCIM death notification", ex);
                }
            });
        }

        // Reset death-tracking state
        deathAwaitingVarbit = false;
        pendingDeathScreenshot = null;
        pendingDeathKiller = null;
    }

    private void handleDiaryVarbit(int varbitId, int newValue) throws IOException {
        if (!Constants.ACHIEVEMENT_DIARIES_COMPLETE_VARBITS.contains(varbitId))
            return;

        if (newValue == 0)
            return;

        Integer oldValue = lastVarbitValues.put(varbitId, newValue);

        if (oldValue == null || oldValue.equals(newValue))
            return;

        log.debug("ID: {} - Val: {}->{} - Area: {} - Tier: {}",
                varbitId,
                oldValue,
                newValue,
                DiaryImages.getDiaryInfo(varbitId).getArea(),
                DiaryImages.getDiaryInfo(varbitId).getTier()
        );

        if (!config.announceelites())
            return;

        if (isDiaryComplete(varbitId, newValue))
        {
            DiaryImages.DiaryInfo info = DiaryImages.getDiaryInfo(varbitId);

            if (info == null)
            {
                log.warn("Missing diary mapping for varbit {}", varbitId);
                return;
            }

            discordClient.sendAchievementDiary(info.getArea(), info.getTier());
        }
    }

    public static boolean isDiaryComplete(int id, int value) {
        if (id == VarbitID.ATJUN_EASY_DONE || id == VarbitID.ATJUN_MED_DONE || id == VarbitID.ATJUN_HARD_DONE) {
            // Karamja special case (except Elite): 0 = not started, 1 = started, 2 = completed tasks
            return value > 1;
        } else {
            // otherwise: 0 = not started, 1 = completed
            return value > 0;
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath actorDeath)
    {
        if (!isMember) return;

        Actor actor = actorDeath.getActor();

        if (!(actor instanceof Player))
            return;

        Player player = (Player) actor;

        if (player != client.getLocalPlayer())
            return;

        // Save the killer’s name (may be null)
        Actor killer = actor.getInteracting();
        pendingDeathKiller = (killer != null) ? killer.getName() : "";

        // Capture screenshot now
        pendingDeathScreenshot = getScreenshot(0);

        // Signal that a death has occurred
        deathAwaitingVarbit = true;

        log.debug("Player death recorded; waiting for HCIM varbit.");
    }

    public CompletableFuture<Image> getScreenshot(int delayTicks)
    {
        CompletableFuture<Image> future = new CompletableFuture<>();
        boolean privacyMode = config.hidechats();

        clientThread.invoke(() ->
        {
            hideChatForScreenshot = hideWidget(
                    privacyMode,
                    client,
                    InterfaceID.Chatbox.CHATAREA
            );

            pendingScreenshot = future;
            screenshotDelayTicks = delayTicks;
        });

        return future;
    }

    public static boolean hideWidget(boolean shouldHide, Client client, @net.runelite.api.annotations.Component int info) {
        if (!shouldHide)
            return false;

        Widget widget = client.getWidget(info);
        if (widget == null || widget.isHidden())
            return false;

        widget.setHidden(true);
        return true;
    }

    public static void unhideWidget(boolean shouldUnhide, Client client, ClientThread clientThread, @Component int info) {
        if (!shouldUnhide)
            return;

        clientThread.invoke(() -> {
            Widget widget = client.getWidget(info);
            if (widget != null)
                widget.setHidden(false);
        });
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) throws IOException {
        if (!isMember) return;
        // quest
        if (event.getGroupId() == InterfaceID.QUESTSCROLL && config.announcegmquests()) {
            Widget quest = client.getWidget(InterfaceID.Questscroll.QUEST_TITLE);
            if (quest != null) {
                String questText = quest.getText();
                log.debug(questText);
                // 1 tick delay to ensure relevant varbits have been processed by the client
                discordClient.sendQuest(questText);
            }
        }
    }


    @Subscribe
    public void onChatMessage(ChatMessage event) throws IOException {
        if (!isMember) return;

        if (client.getWorldType().contains(WorldType.SEASONAL)) return;
        if ((event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)) return;

        String inputMessage = event.getMessage();
        String outputMessage = Text.removeTags(inputMessage);
        String item;

        boolean isCollectionLog = COLLECTION_LOG_ITEM_REGEX.matcher(outputMessage).matches();
        boolean isCombatAchievement = COMBAT_TIER_REGEX.matcher(outputMessage).matches();

        if (isCollectionLog)
        {
            item = outputMessage.substring(COLLECTION_LOG_TEXT.length());
            boolean isPet = Constants.Pets.contains(item);
            if (isPet && config.announcepets()) discordClient.sendPet(item);
            if (!isPet && config.announceloot()) discordClient.sendLootDrop(item);
        }

        if (isCombatAchievement && config.announcecas())
            discordClient.sendCombatAchievement(parseCombatTier(outputMessage));

    }

    @Nullable
    public static String parseCombatTier(String message)
    {
        Matcher m = COMBAT_TIER_REGEX.matcher(message);
        if (m.find())
        {
            return m.group(1);
        }
        return null;
    }

    @Subscribe
    public void onStatChanged(StatChanged statChange) throws IOException {
        if (!isMember) return;
        handleLevelUp(statChange.getSkill(), statChange.getLevel(), statChange.getXp());
    }

    @Subscribe
    public void onGameTick(final GameTick tick) throws IOException, InterruptedException
    {
        if (!isMember)
            return;

        updateRankAndPanel();
        discordClient.onGameTick();

        handleLoginInitialization();
        handlePendingScreenshot();
    }

    private void updateRankAndPanel() throws IOException, InterruptedException
    {
        ClanChannel clan = client.getClanChannel();
        if (clan == null)
            return;

        ClanChannelMember local = clan.findMember(client.getLocalPlayer().getName());
        if (local == null)
            return;

        ClanRank rank = local.getRank();
        ClanTitle title = client.getClanSettings().titleForRank(rank);

        String newRankName = mapRankTitle(title);

        // Only update interface if rank actually changed
        if (!Objects.equals(newRankName, clanRankName))
        {
            boolean nowModerator = isModerator(rank);

            if (this.isModerator != nowModerator)
            {
                this.isModerator = nowModerator;
                if (nowModerator) modTools.init(modToolsPanel);
            }

            panel.refresh(
                    nowModerator,
                    client.getLocalPlayer().getName(),
                    newRankName,
                    getRankIcon(title),
                    getAllMembersInfo(),
                    getMembersIcons(),
                    getMembersDisplayName()
            );

            clanRankName = newRankName;
        }
    }

    private void handleLoginInitialization()
    {
        //log.debug(String.format("%d <> %d", ticksSinceLogin, LOGIN_IGNORE_TICKS));
        if (ticksSinceLogin >= LOGIN_IGNORE_TICKS)
            return;

        ticksSinceLogin++;

        if (ticksSinceLogin == LOGIN_IGNORE_TICKS)
        {
            clientThread.invoke(this::initLevels);
            clientThread.invoke(this::initDiaries);
            clientThread.invoke(this::initCollectionLogs);
        }
    }

    private void handlePendingScreenshot()
    {
        if (pendingScreenshot == null)
            return;

        if (screenshotDelayTicks-- > 0)
            return;

        drawManager.requestNextFrameListener(image ->
        {
            pendingScreenshot.complete(image);

            clientThread.invoke(() ->
                    unhideWidget(
                            hideChatForScreenshot,
                            client,
                            clientThread,
                            InterfaceID.Chatbox.CHATAREA
                    )
            );

            pendingScreenshot = null;
        });
    }

    private void initCollectionLogs() {
        int collectionlogs = client.getVarpValue(VarPlayerID.COLLECTION_COUNT);
//        log.debug(String.format("initCollectionLogs: %d",collectionlogs));
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
//        log.debug(String.format("GameStateChanged: %s", gameStateChanged.getGameState()));
        if (gameStateChanged.getGameState() == GameState.LOADING) return;
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
            this.resetLevels();
            this.resetDiaries();
            panel.buildIntroPanel();
        } else if (gameStateChanged.getGameState() == GameState.LOGGED_IN && !SPECIAL_WORLDS.contains(client.getWorldType())) {
            ticksSinceLogin = 0;
            clientThread.invoke(this::initLevels);
            clientThread.invoke(this::initDiaries);
        }
    }

    private void initLevels() {
        // make sure we run on client thread - if not, re-schedule and return
        if (!client.isClientThread())
        {
            clientThread.invoke(this::initLevels);
            return;
        }
//        log.debug("Levels initialized");

        currentXp.clear();
        currentLevels.clear();

        for (Skill skill : Skill.values()) {
            int xp = client.getSkillExperience(skill);
            int level = client.getRealSkillLevel(skill); // O(1)
            if (level >= MAX_REAL_LEVEL) {
                level = getLevel(xp);
            }
            currentLevels.put(skill.getName(), level);
            currentXp.put(skill, xp);
        }

        levelsInitialized = true; // <-- only set after maps are populated
        //log.debug("Initialized current skill levels: {}", currentLevels);
    }

    private void initDiaries() {
        // make sure we run on client thread - if not, re-schedule and return
        diariesInitialized = false;
        if (!client.isClientThread())
        {
            clientThread.invoke(this::initDiaries);
            return;
        }
//        log.debug("Diaries initialized");

        Integer value = null;
        currentLevels.clear();

        for (int varbitID : Constants.ACHIEVEMENT_DIARIES_COMPLETE_VARBITS)
        {
            value = lastVarbitValues.put(varbitID, client.getVarbitValue(varbitID));
            //log.debug(String.format("Init varbit %d with value %d",varbitID,value));
        }

        if (value == null)
        {
            ticksSinceLogin = 0;
            return;
        }

        for (Skill skill : Skill.values()) {
            int xp = client.getSkillExperience(skill);
            int level = client.getRealSkillLevel(skill); // O(1)
            if (level >= MAX_REAL_LEVEL) {
                level = getLevel(xp);
            }
            currentLevels.put(skill.getName(), level);
            currentXp.put(skill, xp);
        }
        diariesInitialized = true; // <-- only set after maps are populated
    }




    private int getLevel(int xp) {
        // treat 200M XP as level 127
        if (xp >= Experience.MAX_SKILL_XP)
            return LEVEL_FOR_MAX_XP;

        // log(n) operation to support virtual levels
        return Experience.getLevelForXp(xp);
    }

    public void resetLevels() {
        levelsInitialized = false;

        clientThread.invoke(() -> {
            currentXp.clear();
            currentLevels.clear();
            levelsInitialized = false;
            log.debug("resetLevels: cleared level state on client thread");
        });
    }

    public void resetDiaries() {
        lastVarbitValues.clear();
        diariesInitialized = false;
    }

    private void handleLevelUp(Skill skill, int level, int xp) throws IOException {
        if (ticksSinceLogin < LOGIN_IGNORE_TICKS)
        {
            log.debug("Ignoring StatChanged on login: {}", skill);
            return;
        }

        if (xp <= 0 || level <= 1 || !config.announceLevel()) return;

        if (!levelsInitialized) {
            // optionally track ticks to force init later, but do not process level-ups
            log.debug("Ignoring StatChanged for {} while levels not initialised", skill);
            return;
        }


        Integer previousXp = currentXp.put(skill, xp);
        if (previousXp == null) {
            return;
        }

        String skillName = skill.getName();
        int virtualLevel = level < MAX_REAL_LEVEL ? level : getLevel(xp); // avoid log(n) query when not needed
        Integer previousLevel = currentLevels.put(skillName, virtualLevel);


        if (previousLevel == null || previousLevel == 0) {
            return;
        }

        if (virtualLevel < previousLevel || xp < previousXp) {
            // base skill level should never regress; reset notifier state
            resetLevels();
            return;
        }

        // Check normal skill level up
        if (virtualLevel > previousLevel)
            discordClient.sendLevelUp(skill, virtualLevel);

        // Check if xp milestone reached
        if (level >= MAX_REAL_LEVEL && xp > previousXp) {

            if (xp >= Experience.MAX_SKILL_XP) {
                discordClient.send200(skill);
            }
        }
    }

    public ImageIcon getRankIcon(ClanTitle clanTitle)
    {
        BufferedImage chatIcon = chatIconManager.getRankImage(clanTitle);
        assert chatIcon != null;
        return new ImageIcon(chatIcon.getScaledInstance(Constants.TEXT_ICON_SIZE, Constants.TEXT_ICON_SIZE, Image.SCALE_DEFAULT));
    }

    private static boolean isModerator(ClanRank clanRank)
    {
        return Arrays.asList(Constants.RANK_OWNER, Constants.RANK_DEPUTY_OWNER, Constants.RANK_ASTRAL,
                Constants.RANK_CAPTAIN).contains(clanRank);
    }

    private static boolean isOneShotMember(String clanName)
    {
        return Objects.equals(clanName, Constants.CLAN_NAME);
    }

    private ArrayList<OneShotMember> getAllMembersInfo() {

        ArrayList<OneShotMember> oneShotMembers = new ArrayList<OneShotMember>();
        ArrayList<Integer> tmpIndexList = new ArrayList<Integer>();

        // checks all members offline and online
        ClanSettings clanSettings = client.getClanSettings();
        assert clanSettings != null;
        java.util.List<ClanMember> clanMembers = clanSettings.getMembers();

        for (ClanMember clanMember : clanMembers)
        {
            ClanRank clanRank = clanMember.getRank();
            int index = clanRank.getRank();
            if (!tmpIndexList.contains(index))
            {
                tmpIndexList.add(index);
                ClanTitle clanTitle = clanSettings.titleForRank(clanRank);
                String displayTitle = mapRankTitle(clanTitle);

                OneShotMember oneShotMember = new OneShotMember(index, clanTitle, displayTitle);
                oneShotMember.addTotal();
                oneShotMembers.add(oneShotMember);
            }
            else
            {
                for (OneShotMember oneShotMember : oneShotMembers)
                {
                    if (oneShotMember.index == index)
                    {
                        oneShotMember.addTotal();
                    }
                }
            }
        }

        // checks for online members only
        ClanChannel clanChannel = client.getClanChannel();
        assert clanChannel != null;
        List<ClanChannelMember> clanChannelMembers = clanChannel.getMembers();

        for (ClanChannelMember clanChannelMember : clanChannelMembers)
        {
            int index = clanChannelMember.getRank().getRank();
            for (OneShotMember oneShotMember : oneShotMembers)
            {
                if (oneShotMember.index == index)
                {
                    oneShotMember.addOnline();
                }
            }
        }

        oneShotMembers.sort(Comparator.comparing(OneShotMember::getIndex).reversed());

        return oneShotMembers;
    }

    private String mapRankTitle(ClanTitle title)
    {
        if (title == null)
        {
            return "Unknown";
        }

        switch (title.getName())
        {
            case "Owner":
                return "Founder";

            case "Deputy Owner":
                return "Co-Founder";

            case "Astral":
                return "Administrator";

            case "Captain":
                return "Moderator";

            case "Lieutenant":
                return "Trial Moderator";

            case "Witch":
                return "Event Team";

            default:
                return title.getName();
        }
    }


    private Map<String, ImageIcon> getMembersIcons()
    {
        Map<String, ImageIcon> Members = new HashMap<String, ImageIcon>();

        ClanSettings clanSettings = client.getClanSettings();
        assert clanSettings != null;
        java.util.List<ClanMember> clanMembers = clanSettings.getMembers();

        for (ClanMember clanMember : clanMembers)
        {
            String memberName = clanMember.getName();
//            log.debug(memberName.toLowerCase().replace(" ", " ") + ": " + convertToHexString(memberName.toLowerCase().replace(" ", " ").getBytes()));
            ImageIcon icon = getRankIcon(clanSettings.titleForRank(clanMember.getRank()));
            Members.put(memberName.toLowerCase().replace(" ", " "), icon);
        }
        return Members;
    }

    private Map<String, String> getMembersDisplayName()
    {
        Map<String, String> Members = new HashMap<String, String>();

        ClanSettings clanSettings = client.getClanSettings();
        assert clanSettings != null;
        java.util.List<ClanMember> clanMembers = clanSettings.getMembers();

        for (ClanMember clanMember : clanMembers)
        {
            String memberName = clanMember.getName();
//            log.debug(memberName.toLowerCase().replace(" ", " ") + ": " + convertToHexString(memberName.toLowerCase().replace(" ", " ").getBytes()));
            Members.put(memberName.toLowerCase().replace(" ", " "), memberName);
        }
        return Members;
    }

    public class OneShotMember {
        int index;
        ImageIcon icon;
        String name;
        int online = 0;
        int total = 0;

        public OneShotMember(int index, ClanTitle clanTitle, String displayTitle)
        {
            this.index = index;
            this.icon = getRankIcon(clanTitle);
            this.name = displayTitle;
        }

        public void addOnline()
        {
            this.online++;
        }

        public void addTotal()
        {
            this.total++;
        }

        public String toString()
        {
            return name + " | " + online + " | " + total;
        }

        public int getIndex()
        {
            return index;
        }

        public ImageIcon getIcon()
        {
            return icon;
        }

        public String getName()
        {
            return name;
        }

        public int getOnline()
        {
            return online;
        }

        public int getTotal()
        {
            return total;
        }
    }


}


package com.oneshot;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class OneShotTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(OneShotPlugin.class);
		RuneLite.main(args);
	}
}
