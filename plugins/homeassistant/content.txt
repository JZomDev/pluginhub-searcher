package com.homeassistant;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("homeassistant")
public interface HomeassistantConfig extends Config
{
	String CONFIG_GROUP = "homeassistant";

	@ConfigItem(
			keyName = "homeassistant_url",
			name = "Homeassistant Base URL",
			description = "example: http://homeassistant.local:8123",
			position = 1
	)
	default String homeassistantUrl()
	{
		return "";
	}

	@ConfigItem(
			keyName = "homeassistant_token",
			name = "Homeassistant Access token",
			description = "Your home assistant access token",
			position = 2
	)
	default String homeassistantToken()
	{
		return "";
	}

	@ConfigItem(
			keyName = "validate_token",
			name = "Validate Home Assistant Token",
			description = "Turn on to validate your homeassistant setup, will provide details in game messages. ",
			position = 3
	)
	default boolean validateToken()
	{
		return false;
	}

	@ConfigItem(
			keyName = "ignorefarmingguild",
			name = "Ignore Farming Guild",
			description = "Ignore patches in the farming guild when determining the next update.",
			position = 4
	)
	default boolean ignoreFarmingGuild() {
		return true;
	}


	@ConfigSection(
			name = "Miscellaneous",
			description = "Settings for miscellaneous infoboxes",
			position = 100
	)
	String miscellaneousSection = "Miscellaneous";

	@ConfigSection(
			name = "Farming patches",
			description = "Settings for farming patch infoboxes",
			position = 200
	)
	String farmingPatchesSection = "Farming patches";

	// -- Miscellaneous infoboxes ---

	@ConfigItem(
			keyName = "birdhouses",
			name = "Bird houses",
			description = "Create an entity for when your bird houses are ready.",
			section = miscellaneousSection,
			position = 101
	)
	default boolean birdHouses() {
		return true;
	}

	@ConfigItem(
			keyName = "farmingcontract",
			name = "Farming contract",
			description = "Create an entity for when your farming contract is ready.",
			section = miscellaneousSection,
			position = 102
	)
	default boolean farmingContract() {
		return true;
	}

	@ConfigItem(
			keyName = "hespori",
			name = "Hespori",
			description = "Create an entity for when your Hespori patch is ready.",
			section = miscellaneousSection,
			position = 103
	)
	default boolean hespori() {
		return true;
	}

	@ConfigItem(
			keyName = "giantcompostbin",
			name = "Giant compost bin",
			description = "Create an entity for when your giant compost bin is ready.",
			section = miscellaneousSection,
			position = 104
	)
	default boolean giantCompostBin() {
		return true;
	}

	// -- Farming patch infoboxes ---

	@ConfigItem(
			keyName = "herbpatches",
			name = "Herb patches",
			description = "Create an entity for when your herb patches are ready.",
			section = farmingPatchesSection,
			position = 201
	)
	default boolean herbPatches() {
		return false;
	}

	@ConfigItem(
			keyName = "treepatches",
			name = "Tree patches",
			description = "Create an entity for when your tree patches are ready.",
			section = farmingPatchesSection,
			position = 202
	)
	default boolean treePatches() {
		return false;
	}

	@ConfigItem(
			keyName = "fruittreepatches",
			name = "Fruit tree patches",
			description = "Create an entity for when your fruit tree patches are ready.",
			section = farmingPatchesSection,
			position = 203
	)
	default boolean fruitTreePatches() {
		return false;
	}

	@ConfigItem(
			keyName = "celastrusPatch",
			name = "Celastrus patch",
			description = "Create an entity for when your celastrus patch is ready.",
			section = farmingPatchesSection,
			position = 204
	)
	default boolean celastrusPatch() {
		return false;
	}

	@ConfigItem(
			keyName = "hardwoodpatches",
			name = "Hardwood patches",
			description = "Create an entity for when your hardwood patches are ready.",
			section = farmingPatchesSection,
			position = 204
	)
	default boolean hardwoodPatches() {
		return false;
	}

	@ConfigItem(
			keyName = "calquatpatch",
			name = "Calquat patch",
			description = "Create an entity for when your calquat patch is ready.",
			section = farmingPatchesSection,
			position = 205
	)
	default boolean calquatPatch() {
		return false;
	}

	@ConfigItem(
			keyName = "redwoodpatch",
			name = "Redwood patch",
			description = "Create an entity for when your redwood patch is ready.",
			section = farmingPatchesSection,
			position = 206
	)
	default boolean redwoodPatch() {
		return false;
	}

	@ConfigItem(
			keyName = "seaweedpatches",
			name = "Seaweed patches",
			description = "Create an entity for when your seaweed patches are ready.",
			section = farmingPatchesSection,
			position = 207
	)
	default boolean seaweedPatches() {
		return false;
	}

	@ConfigItem(
			keyName = "hopspatches",
			name = "Hops patches",
			description = "Create an entity for when your hops patches are ready.",
			section = farmingPatchesSection,
			position = 208
	)
	default boolean hopsPatches() {
		return false;
	}

	@ConfigItem(
			keyName = "bushpatches",
			name = "Bush patches",
			description = "Create an entity for when your bush patches are ready.",
			section = farmingPatchesSection,
			position = 209
	)
	default boolean bushPatches() {
		return false;
	}

	@ConfigItem(
			keyName = "cactuspatches",
			name = "Cactus patches",
			description = "Create an entity for when your cactus patches are ready.",
			section = farmingPatchesSection,
			position = 210
	)
	default boolean cactusPatches() {
		return false;
	}

	@ConfigItem(
			keyName = "mushroompatch",
			name = "Mushroom patch",
			description = "Create an entity for when your mushroom patch is ready.",
			section = farmingPatchesSection,
			position = 211
	)
	default boolean mushroomPatch() {
		return false;
	}

	@ConfigItem(
			keyName = "belladonnapatch",
			name = "Belladonna patch",
			description = "Create an entity for when your belladonna patch is ready.",
			section = farmingPatchesSection,
			position = 212
	)
	default boolean belladonnaPatch() {
		return false;
	}

	@ConfigItem(
			keyName = "crystalpatch",
			name = "Crystal patch",
			description = "Create an entity for when your crystal patch is ready.",
			section = farmingPatchesSection,
			position = 213
	)
	default boolean crystalPatch() {
		return false;
	}

	@ConfigItem(
			keyName = "allotmentpatches",
			name = "Allotment patches",
			description = "Create an entity for when your allotment patches are ready.",
			section = farmingPatchesSection,
			position = 214
	)
	default boolean allotmentPatches() {
		return false;
	}

	@ConfigItem(
			keyName = "flowerpatches",
			name = "Flower patches",
			description = "Create an entity for when your flower patches are ready.",
			section = farmingPatchesSection,
			position = 215
	)
	default boolean flowerPatches() {
		return false;
	}

	@ConfigItem(
			keyName = "animapatch",
			name = "Anima patch",
			description = "Create an entity for when your anima patch is ready to be replaced.",
			section = farmingPatchesSection,
			position = 216
	)
	default boolean animaPatch() {
		return false;
	}
}

package com.homeassistant.enums;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public enum PatchStatus {
    IN_PROGRESS("in_progress", 1),
    READY("ready", 0),
    OTHER("other", -1),
    NEVER_PLANTED("not_planted", -2);


    private final String name;
    private final int itemID;
}

package com.homeassistant;

import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;

import com.homeassistant.enums.PatchStatus;
import com.homeassistant.runelite.farming.*;
import com.homeassistant.runelite.hunter.BirdHouseTracker;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;
import okhttp3.*;

import java.io.IOException;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.CompletableFuture;

@Slf4j
@PluginDescriptor(
	name = "Homeassistant"
)
public class HomeassistantPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private HomeassistantConfig config;

	@Inject
	private ConfigManager configManager;

	private BirdHouseTracker birdHouseTracker;
	private FarmingTracker farmingTracker;
	private FarmingContractManager farmingContractManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private Gson gson;

	@Inject
	private Notifier notifier;

	@Inject
	private OkHttpClient okHttpClient;

	private int farmingTickOffset = 0;
	private final Map<Tab, Long> previousFarmingCompletionTimes = new EnumMap<>(Tab.class);
	private long previousBirdhouseCompletionTime = -2L;
	private long previousFarmingContractCompletionTime = -2L;


	private final Map<Tab, Long> nextFarmingCompletionTimes = new EnumMap<>(Tab.class);
	private long nextBirdhouseCompletionTime = -2L;
	private long nextFarmingContractCompletionTime = -2L;

	@Override
	protected void startUp() throws Exception
	{
		log.debug("Homeassistant started!");
		resetCompletionTimes();
		initializeTrackers();
	}

	private boolean isRelevantFarmingTab(Tab tab) {
		return tab != Tab.OVERVIEW && tab != Tab.CLOCK && tab != Tab.TIME_OFFSET && tab != Tab.SPECIAL && tab != Tab.GRAPE; // Exclude overview, clock, offset, special (might need more specific handling), and grape
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Homeassistant stopped!");
	}


	@Provides
	HomeassistantConfig provideConfig(ConfigManager configManager)
	{
        return configManager.getConfig(HomeassistantConfig.class);
	}


	private void initializeTrackers() {
		TimeTrackingConfig timeTrackingConfig = configManager.getConfig(TimeTrackingConfig.class);
		FarmingWorld farmingWorld = new FarmingWorld();

		CompostTracker compostTracker = new CompostTracker(
				client,
				farmingWorld,
				configManager
		);

		PaymentTracker paymentTracker = new PaymentTracker(
				client,
				configManager,
				farmingWorld
		);

		birdHouseTracker = new BirdHouseTracker(
				client,
				itemManager,
				configManager,
				timeTrackingConfig,
				notifier
		);

		farmingTracker = new FarmingTracker(
				client,
				itemManager,
				configManager,
				timeTrackingConfig,
				farmingWorld,
				notifier,
				compostTracker,
				paymentTracker
		);
		farmingTracker.setIgnoreFarmingGuild(config.ignoreFarmingGuild());

		farmingContractManager = new FarmingContractManager(
				client,
				itemManager,
				configManager,
				timeTrackingConfig,
				farmingWorld,
				farmingTracker
		);
	}

	private void resetCompletionTimes(){
		for (Tab tab : Tab.values()) {
			previousFarmingCompletionTimes.put(tab, -2L);
		}
		previousBirdhouseCompletionTime = -2L;
		previousFarmingContractCompletionTime = -2L;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (gameStateChanged.getGameState() != GameState.LOGGED_IN) {
			return;
		}
		resetCompletionTimes();

		birdHouseTracker.loadFromConfig();
		farmingTracker.loadCompletionTimes();
		farmingContractManager.loadContractFromConfig();
		updateAllEntities();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		String group = event.getGroup();
		if (!group.equals(TimeTrackingConfig.CONFIG_GROUP) && !group.equals(HomeassistantConfig.CONFIG_GROUP)) {
			return;
		}

		if (event.getKey().equals("validate_token") && config.validateToken())
		{
			testHomeAssistant();
        }
		birdHouseTracker.loadFromConfig();
		farmingTracker.setIgnoreFarmingGuild(config.ignoreFarmingGuild());
		farmingTracker.loadCompletionTimes();
		farmingContractManager.loadContractFromConfig();

		updateAllEntities();
	}

	private void updateAllEntities() {
		String username = getUsername();
		if(username == null){
			return;
		}

		List<Map<String, Object>> entities = new ArrayList<>();

		for (Tab tab : Tab.values()) {
			if (getConfigFromTab(tab)) {
				nextFarmingCompletionTimes.put(tab, farmingTracker.getCompletionTime(tab));
			}
		}

		if (config.birdHouses()) {
			nextBirdhouseCompletionTime = birdHouseTracker.getCompletionTime();
		}

		if (config.farmingContract()) {
			nextFarmingContractCompletionTime = farmingContractManager.getCompletionTime();
		}

		// Farming Patches
		for (Tab tab : Tab.values()) {
			if (getConfigFromTab(tab)) {
				if (!Objects.equals(previousFarmingCompletionTimes.get(tab), nextFarmingCompletionTimes.get(tab))) {
					String entityId = generateFarmingPatchEntityId(tab);
					if (entityId == null) continue;

					Map<String, Object> attributes = new HashMap<>();
					attributes.put("entity_id", entityId);

					long completionTime = nextFarmingCompletionTimes.get(tab);
					PatchStatus patchStatus = PatchStatus.READY;

					if (completionTime > 0) {
						patchStatus = PatchStatus.IN_PROGRESS;
						attributes.put("completion_time", Instant.ofEpochSecond(completionTime).toString());
					} else if (completionTime == -1) {
						patchStatus = PatchStatus.NEVER_PLANTED;
					}

					attributes.put("status", patchStatus.getName());

					entities.add(attributes); // ✅ add to array
					previousFarmingCompletionTimes.put(tab, nextFarmingCompletionTimes.get(tab));
				}
			}
		}

		// Birdhouse
		if (previousBirdhouseCompletionTime != nextBirdhouseCompletionTime) {
			String entityId = generateBirdhouseEntityId();
			if (entityId != null) {
				Map<String, Object> attributes = new HashMap<>();
				attributes.put("entity_id", entityId);
				attributes.put("status", PatchStatus.IN_PROGRESS.getName());
				attributes.put("completion_time", Instant.ofEpochSecond(nextBirdhouseCompletionTime).toString());

				entities.add(attributes); // ✅ add to array
				previousBirdhouseCompletionTime = nextBirdhouseCompletionTime;
			}
		}

		// Farming Contract
		if (previousFarmingContractCompletionTime != nextFarmingContractCompletionTime) {
			String entityId = generateFarmingContractEntityId();
			if (entityId != null) {

				Map<String, Object> attributes = new HashMap<>();
				attributes.put("entity_id", entityId);
				attributes.put("status", PatchStatus.IN_PROGRESS.getName());
				String contractName = farmingContractManager.getContractName();
				Tab tab = farmingContractManager.getContractTab();
				try {
                    assert tab != null;
                    attributes.put("patch_type", tab.name().toLowerCase());
					attributes.put("crop_type", contractName);
				}catch (NullPointerException e){
					log.debug("Error getting contract name or tab: {}", e.getMessage());
				}

				log.info("Farming contract completion time: {}", nextFarmingContractCompletionTime);
				PatchStatus patchStatus = PatchStatus.READY;
				if (nextFarmingContractCompletionTime > 0) {
					patchStatus = PatchStatus.IN_PROGRESS;
					if(nextFarmingContractCompletionTime == Long.MAX_VALUE){
						patchStatus = PatchStatus.OTHER;
					}else{
//				log.info("Farming contract completion time: {}", Instant.ofEpochSecond(completionTime).toString());
						attributes.put("completion_time", Instant.ofEpochSecond(nextFarmingContractCompletionTime).toString());
					}
				}else if(nextFarmingContractCompletionTime == -1){
					patchStatus = PatchStatus.NEVER_PLANTED;
				}
				attributes.put("status", patchStatus.getName());

				entities.add(attributes); // ✅ add to array
				previousFarmingContractCompletionTime = nextFarmingContractCompletionTime;
			}
		}

		if(entities.isEmpty()){
			return;
		}
		// ✅ Wrap it into the final payload and serialize
		Map<String, Object> payload = new HashMap<>();
		payload.put("entities", entities);


		Gson gson = this.gson.newBuilder().create();
		String jsonPayload = gson.toJson(payload);

		// ✅ Send it to HA using your existing HTTP call method
		sendPayloadToHomeAssistant(jsonPayload);


		int offset = configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, TimeTrackingConfig.FARM_TICK_OFFSET, int.class);
		offset = offset * -1;

		if (offset != farmingTickOffset) {
			farmingTickOffset = offset;
			Map<String, Object> farmingTickAttributes = new HashMap<>();
			farmingTickAttributes.put("username", username);
			farmingTickAttributes.put("farming_tick_offset", offset);
			sendPayloadToHomeAssistant(gson.toJson(farmingTickAttributes), "/services/runelite/set_farming_tick_offset");
		}
	}

	private void sendPayloadToHomeAssistant(String jsonPayload) {
		sendPayloadToHomeAssistant(jsonPayload, "/services/runelite/set_multi_entity_data");
	}

	private void sendPayloadToHomeAssistant(String jsonPayload, String url) {
		String homeAssistantUrl = config.homeassistantUrl(); // Assuming you have this in your config
		String accessToken = config.homeassistantToken(); // Assuming you have this in your config

		if (homeAssistantUrl.isEmpty() || accessToken.isEmpty()) {
			log.warn("Home Assistant URL or Access Token not configured.");
			return;
		}

		String apiUrl = homeAssistantUrl + "/api" + url;
		RequestBody requestBody = RequestBody.create(MediaType.parse("application/json; charset=utf-8"), jsonPayload);
		log.debug("Sending payload to home assistant, {}: {}", apiUrl, jsonPayload);
		Request request = new Request.Builder()
				.url(Objects.requireNonNull(HttpUrl.parse(apiUrl)))
				.header("Authorization", "Bearer " + accessToken)
				.header("Content-Type", "application/json")
				.post(requestBody)
				.build();

		okHttpClient.newCall(request).enqueue(new Callback() {
			@Override
			public void onFailure(Call call, IOException e) {
				log.error("Error submitting the entity to homeassistant ", e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException {
				log.info("Successfully created/updated entity {}.", jsonPayload);
				response.close();
			}
		});
	}

	private void testHomeAssistant()
	{
		String homeAssistantUrl = config.homeassistantUrl();
		String accessToken = config.homeassistantToken();


		if (homeAssistantUrl.isEmpty() || accessToken.isEmpty())
		{
			log.warn("Home Assistant URL or Access Token not configured.");
			return;
		}

		String apiUrl = homeAssistantUrl + "/api/";

		Request request = new Request.Builder()
				.url(Objects.requireNonNull(HttpUrl.parse(apiUrl)))
				.header("Authorization", "Bearer " + accessToken)
				.get()
				.build();

		log.info("Testing Home Assistant connection with URL: {}", apiUrl);

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Error connecting to the Home Assistant API", e);
				clientThread.invoke(() -> client.addChatMessage(
					ChatMessageType.GAMEMESSAGE,
					"",
					"Invalid Home Assistant token or URL.",
					null
				));
			}

			@Override
			public void onResponse(Call call, Response response)
			{
				int code  = response.code();
				String message = response.message();
				if(code != 200){
					clientThread.invoke(() -> client.addChatMessage(
						ChatMessageType.GAMEMESSAGE,
						"",
							String.format("Invalid Home Assistant token or URL. Code: %s, message: %s", code, message),
						null
					));
				}else{
					clientThread.invoke(() -> client.addChatMessage(
						ChatMessageType.GAMEMESSAGE,
						"",
						"Home Assistant token and URL are valid.",
						null
					));

					String apiUrl = homeAssistantUrl + "/api/services";

					Request request = new Request.Builder()
							.url(Objects.requireNonNull(HttpUrl.parse(apiUrl)))
							.header("Authorization", "Bearer " + accessToken)
							.get()
							.build();

					log.info("Listing home assistant services: {}", apiUrl);
					okHttpClient.newCall(request).enqueue(new Callback()
					{
						@Override
						public void onFailure(Call call, IOException e)
						{
							log.error("Error listing home assistant services", e);
							clientThread.invoke(() -> client.addChatMessage(
									ChatMessageType.GAMEMESSAGE,
									"",
									"Could not list home assistant services",
									null
							));
						}

						@Override
						public void onResponse(Call call, Response response)
						{
							int code  = response.code();
							String message = response.message();
							if(code != 200){
								clientThread.invoke(() -> client.addChatMessage(
										ChatMessageType.GAMEMESSAGE,
										"",
										String.format("Could not list home assistant services. Code: %s, message: %s", code, message),
										null
								));
							}else{
								log.info("Successfully listed home assistant services.");
								try {
									String responseBody = response.body().string();
									List<Map<String, Object>> services = gson.fromJson(responseBody, List.class);
									Set<String> domains = new HashSet<>();
									for (Map<String, Object> service : services) {
										domains.add((String) service.get("domain"));
									}
									log.info("Available service domains: {}", domains);
									if (!domains.contains("runelite")) {
										clientThread.invoke(() -> client.addChatMessage(
											ChatMessageType.GAMEMESSAGE,
											"",
											"Warning: 'runelite' service domain not found in Home Assistant",
											null
										));

										clientThread.invoke(() -> client.addChatMessage(
											ChatMessageType.GAMEMESSAGE,
											"",
											"To make this plugin work, please add the 'runelite' integration to Home Assistant, more information in this plugin's GitHub repository.",
											null
										));
									}else{
										clientThread.invoke(() -> client.addChatMessage(
											ChatMessageType.GAMEMESSAGE,
											"",
											"Successfully found the runelite plugin",
											null
										));

									}
								} catch (Exception e) {
									log.error("Error parsing Home Assistant services response", e);
								}
							}
							response.close();
						}
					});
				}
				response.close();
			}
		});
	}

	private boolean getConfigFromTab(Tab tab) {
		switch (tab) {
			case BUSH:
				return config.bushPatches();
			case HERB:
				return config.herbPatches();
			case ALLOTMENT:
				return config.allotmentPatches();
			case FLOWER:
				return config.flowerPatches();
			case TREE:
				return config.treePatches();
			case FRUIT_TREE:
				return config.fruitTreePatches();
			case HOPS:
				return config.hopsPatches();
			case SPECIAL:
			case MUSHROOM:
				return config.mushroomPatch();
			case BELLADONNA:
				return config.belladonnaPatch();
			case BIG_COMPOST:
				return config.giantCompostBin();
			case SEAWEED:
				return config.seaweedPatches();
			case CALQUAT:
				return config.calquatPatch();
			case CELASTRUS:
				return config.celastrusPatch();
			case HARDWOOD:
				return config.hardwoodPatches();
			case REDWOOD:
				return config.redwoodPatch();
			case CACTUS:
				return config.cactusPatches();
			case HESPORI:
				return config.hespori();
			case CRYSTAL:
				return config.crystalPatch();
			case ANIMA:
				return config.animaPatch();
			default:
				return false;
		}
	}

	private String generateFarmingPatchEntityId(Tab tab) {
		try {
			return String.format("sensor.runelite_%s_%s_patch", getUsername(), tab.name().toLowerCase());
		}catch (NullPointerException e){
			log.error("Error generating entity id for {}: {}", tab.name(), e.getMessage());
			return null;
		}
	}

	private String generateBirdhouseEntityId() {
		try{
			return String.format("sensor.runelite_%s_birdhouses", getUsername());
		}catch (NullPointerException e){
			log.error("Error generating entity id for birdhouses: {}", e.getMessage());
			return null;
		}

	}

	private String generateFarmingContractEntityId() {
		try{
			return String.format("sensor.runelite_%s_farming_contract", getUsername());
		}catch (NullPointerException e){
			log.error("Error generating entity id for farming contract: {}", e.getMessage());
			return null;
		}
	}

	private String generateFarmingTickEntityId() {
		try{
			return String.format("runelite_%s_farming_tick_offset", getUsername());
		}catch (NullPointerException e){
			log.error("Error generating entity id for farming contract: {}", e.getMessage());
			return null;
		}
	}

	private String getUsername(){
		try{
			return Objects.requireNonNull(client.getLocalPlayer().getName()).toLowerCase();
		}catch (NullPointerException e){
			log.error("Error fetching username: {}", e.getMessage());
			return null;
		}
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.hunter;

import net.runelite.api.ItemID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.timetracking.TabContentPanel;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;
import net.runelite.client.plugins.timetracking.TimeablePanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;

import javax.swing.*;
import java.awt.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class BirdHouseTabPanel extends TabContentPanel
{
	private static final Color COMPLETED_COLOR = ColorScheme.PROGRESS_COMPLETE_COLOR.darker();

	private final ConfigManager configManager;
	private final ItemManager itemManager;
	private final BirdHouseTracker birdHouseTracker;
	private final TimeTrackingConfig config;
	private final List<TimeablePanel<BirdHouseSpace>> spacePanels;

	BirdHouseTabPanel(ConfigManager configManager, ItemManager itemManager, BirdHouseTracker birdHouseTracker,
		TimeTrackingConfig config)
	{
		this.configManager = configManager;
		this.itemManager = itemManager;
		this.birdHouseTracker = birdHouseTracker;
		this.config = config;
		this.spacePanels = new ArrayList<>();

		setLayout(new DynamicGridLayout(0, 1, 0, 0));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		boolean first = true;
		for (BirdHouseSpace space : BirdHouseSpace.values())
		{
			TimeablePanel<BirdHouseSpace> panel = new TimeablePanel<>(space, space.getName(), BirdHouseTracker.BIRD_HOUSE_DURATION);

			spacePanels.add(panel);
			add(panel);

			// remove the top border on the first panel
			if (first)
			{
				first = false;
				panel.setBorder(null);
			}

			JToggleButton toggleNotify = panel.getNotifyButton();

			toggleNotify.addActionListener(e ->
			{
				if (configManager.getRSProfileKey() != null)
				{
					// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
				}
				spacePanels.forEach(p -> p.getNotifyButton().setSelected(toggleNotify.isSelected()));
			});
		}
	}

	@Override
	public int getUpdateInterval()
	{
		return 50; // 10 seconds
	}

	@Override
	public void update()
	{
		long unixNow = Instant.now().getEpochSecond();

		boolean notifications = Boolean.TRUE
			.equals(configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, TimeTrackingConfig.BIRDHOUSE_NOTIFY, boolean.class));

		for (TimeablePanel<BirdHouseSpace> panel : spacePanels)
		{
			BirdHouseSpace space = panel.getTimeable();
			BirdHouseData data = birdHouseTracker.getBirdHouseData().get(space);
			int value = -1;
			long startTime = 0;

			if (data != null)
			{
				value = data.getVarp();
				startTime = data.getTimestamp();
			}

			BirdHouse birdHouse = BirdHouse.fromVarpValue(value);
			BirdHouseState state = BirdHouseState.fromVarpValue(value);

			if (birdHouse == null)
			{
				itemManager.getImage(ItemID.FEATHER).addTo(panel.getIcon());
				panel.getProgress().setVisible(false);
			}
			else
			{
				itemManager.getImage(birdHouse.getItemID()).addTo(panel.getIcon());
				panel.getIcon().setToolTipText(birdHouse.getName());
				panel.getProgress().setVisible(true);
			}

			panel.getNotifyButton().setSelected(notifications);

			panel.getProgress().setForeground(state.getColor().darker());

			switch (state)
			{
				case EMPTY:
					panel.getIcon().setToolTipText("Empty");
					panel.getEstimate().setText("Empty");
					break;
				case BUILT:
					panel.getProgress().setValue(0);
					panel.getEstimate().setText("Built");
					break;
				case SEEDED:
					long remainingTime = startTime + BirdHouseTracker.BIRD_HOUSE_DURATION - unixNow;
					if (remainingTime <= 0)
					{
						panel.getProgress().setValue(BirdHouseTracker.BIRD_HOUSE_DURATION);
						panel.getProgress().setForeground(COMPLETED_COLOR);
						panel.getEstimate().setText("Done");
					}
					else
					{
						panel.getProgress().setValue((int) (BirdHouseTracker.BIRD_HOUSE_DURATION - remainingTime));
						panel.getEstimate().setText("Done " + getFormattedEstimate(remainingTime, config.timeFormatMode()));
					}
					break;
				default:
					panel.getIcon().setToolTipText("Unknown state");
					panel.getEstimate().setText("Unknown");
					break;
			}
		}
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.hunter;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;

import javax.annotation.Nullable;

@AllArgsConstructor
@Getter
enum BirdHouse
{
	NORMAL("Bird House", ItemID.BIRD_HOUSE),
	OAK("Oak Bird House", ItemID.OAK_BIRD_HOUSE),
	WILLOW("Willow Bird House", ItemID.WILLOW_BIRD_HOUSE),
	TEAK("Teak Bird House", ItemID.TEAK_BIRD_HOUSE),
	MAPLE("Maple Bird House", ItemID.MAPLE_BIRD_HOUSE),
	MAHOGANY("Mahogany Bird House", ItemID.MAHOGANY_BIRD_HOUSE),
	YEW("Yew Bird House", ItemID.YEW_BIRD_HOUSE),
	MAGIC("Magic Bird House", ItemID.MAGIC_BIRD_HOUSE),
	REDWOOD("Redwood Bird House", ItemID.REDWOOD_BIRD_HOUSE);

	private final String name;
	private final int itemID;

	/**
	 * Gets the {@code BirdHouse} corresponding to the given {@code VarPlayer} value.
	 */
	@Nullable
	static BirdHouse fromVarpValue(int varp)
	{
		int index = (varp - 1) / 3;

		if (varp <= 0 || index >= values().length)
		{
			return null;
		}

		return values()[index];
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.hunter;

import lombok.Value;

/**
 * Contains data about the state of a particular {@link BirdHouseSpace}, at a particular point in time.
 */
@Value
class BirdHouseData
{
	private BirdHouseSpace space;
	private int varp;
	private long timestamp;
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.hunter;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.VarPlayer;
import net.runelite.api.annotations.Varp;

@AllArgsConstructor
@Getter
enum BirdHouseSpace
{
	MEADOW_NORTH("Mushroom Meadow (North)", VarPlayer.BIRD_HOUSE_MEADOW_NORTH),
	MEADOW_SOUTH("Mushroom Meadow (South)", VarPlayer.BIRD_HOUSE_MEADOW_SOUTH),
	VALLEY_NORTH("Verdant Valley (Northeast)", VarPlayer.BIRD_HOUSE_VALLEY_NORTH),
	VALLEY_SOUTH("Verdant Valley (Southwest)", VarPlayer.BIRD_HOUSE_VALLEY_SOUTH);

	private final String name;
	@Varp
	private final int varp;
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.hunter;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;

@AllArgsConstructor
@Getter
enum BirdHouseState
{
	SEEDED(ColorScheme.PROGRESS_COMPLETE_COLOR),
	BUILT(ColorScheme.PROGRESS_INPROGRESS_COLOR),
	EMPTY(ColorScheme.MEDIUM_GRAY_COLOR),
	UNKNOWN(ColorScheme.MEDIUM_GRAY_COLOR);

	private final Color color;

	/**
	 * Gets the {@code BirdHouseState} corresponding to the given {@code VarPlayer} value.
	 */
	static BirdHouseState fromVarpValue(int varp)
	{
		if (varp < 0 || varp > BirdHouse.values().length * 3)
		{
			return UNKNOWN;
		}
		else if (varp == 0)
		{
			return EMPTY;
		}
		else if (varp % 3 == 0)
		{
			return SEEDED;
		}
		else
		{
			return BUILT;
		}
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * Copyright (c) 2018, Daniel Teo <https://github.com/takuyakanbr>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.hunter;

import com.google.common.collect.ImmutableSet;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.timetracking.SummaryState;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;

import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class BirdHouseTracker
{
	// average time taken to harvest 10 birds, in seconds
	static final int BIRD_HOUSE_DURATION = (int) Duration.ofMinutes(50).getSeconds();

	private static ImmutableSet<Integer> FOSSIL_ISLAND_REGIONS = ImmutableSet.of(14650, 14651, 14652, 14906, 14907, 15162, 15163);

	private final Client client;
	private final ItemManager itemManager;
	private final ConfigManager configManager;
	private final TimeTrackingConfig config;
	private final Notifier notifier;

	@Getter(AccessLevel.PACKAGE)
	private final ConcurrentMap<BirdHouseSpace, BirdHouseData> birdHouseData = new ConcurrentHashMap<>();

	@Getter
	private SummaryState summary = SummaryState.UNKNOWN;

	/**
	 * The time at which all the bird houses will be ready to be dismantled,
	 * or {@code -1} if we have no data about any of the bird house spaces.
	 */
	@Getter
	private long completionTime = -1;

	public BirdHouseTracker(Client client, ItemManager itemManager, ConfigManager configManager,
		TimeTrackingConfig config, Notifier notifier)
	{
		this.client = client;
		this.itemManager = itemManager;
		this.configManager = configManager;
		this.config = config;
		this.notifier = notifier;
	}

	public BirdHouseTabPanel createBirdHouseTabPanel()
	{
		return new BirdHouseTabPanel(configManager, itemManager, this, config);
	}

	public void loadFromConfig()
	{
		birdHouseData.clear();

		for (BirdHouseSpace space : BirdHouseSpace.values())
		{
			String key = TimeTrackingConfig.BIRD_HOUSE + "." + space.getVarp();
			String storedValue = configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, key);

			if (storedValue != null)
			{
				String[] parts = storedValue.split(":");
				if (parts.length == 2)
				{
					try
					{
						int varp = Integer.parseInt(parts[0]);
						long timestamp = Long.parseLong(parts[1]);
						birdHouseData.put(space, new BirdHouseData(space, varp, timestamp));
					}
					catch (NumberFormatException e)
					{
						// ignored
					}
				}
			}
		}

		updateCompletionTime();
	}

	/**
	 * Updates tracker data if player is within range of any bird house. Returns true if any data was changed.
	 */
	public boolean updateData(WorldPoint location)
	{
		boolean changed = false;

		if (FOSSIL_ISLAND_REGIONS.contains(location.getRegionID()) && location.getPlane() == 0)
		{
			final Map<BirdHouseSpace, BirdHouseData> newData = new HashMap<>();
			final long currentTime = Instant.now().getEpochSecond();
			int removalCount = 0;

			for (BirdHouseSpace space : BirdHouseSpace.values())
			{
				int varp = client.getVarpValue(space.getVarp());
				BirdHouseData oldData = birdHouseData.get(space);
				int oldVarp = oldData == null ? -1 : oldData.getVarp();

				// update data if there isn't one, or if the varp doesn't match
				if (varp != oldVarp)
				{
					newData.put(space, new BirdHouseData(space, varp, currentTime));
					changed = true;
				}

				if (varp <= 0 && oldVarp > 0)
				{
					removalCount++;
				}
			}

			// Prevent the resetting of bird house data that could occur if the varps have not been updated yet
			// after the player enters the region. We assume that players would generally have 3 or 4 bird houses
			// built at any time, and that dropping from 3/4 to 0 built bird houses is not normally possible.
			if (removalCount > 2)
			{
				return false;
			}

			if (changed)
			{
				birdHouseData.putAll(newData);
				updateCompletionTime();
				saveToConfig(newData);
			}
		}

		return changed;
	}

	/**
	 * Checks if the bird houses have become ready to be dismantled,
	 * and sends a notification if required.
	 */
	public boolean checkCompletion()
	{
		if (summary == SummaryState.IN_PROGRESS && completionTime < Instant.now().getEpochSecond())
		{
			summary = SummaryState.COMPLETED;
			completionTime = 0;

			if (Boolean.TRUE.equals(configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, TimeTrackingConfig.BIRDHOUSE_NOTIFY, boolean.class)))
			{
				notifier.notify("Your bird houses are ready to be dismantled.");
			}

			return true;
		}

		return false;
	}

	/**
	 * Updates the overall completion time of the bird houses.
	 * @see #completionTime
	 */
	public void updateCompletionTime()
	{
		if (birdHouseData.isEmpty())
		{
			summary = SummaryState.UNKNOWN;
			completionTime = -1;
			return;
		}

		boolean allEmpty = true;
		long maxCompletionTime = 0;
		for (BirdHouseData data : birdHouseData.values())
		{
			final BirdHouseState state = BirdHouseState.fromVarpValue(data.getVarp());

			if (state != BirdHouseState.EMPTY)
			{
				allEmpty = false;
			}

			if (state == BirdHouseState.SEEDED)
			{
				maxCompletionTime = Math.max(maxCompletionTime, data.getTimestamp() + BIRD_HOUSE_DURATION);
			}
		}

		if (allEmpty)
		{
			summary = SummaryState.EMPTY;
			completionTime = 0;
		}
		else if (maxCompletionTime <= Instant.now().getEpochSecond())
		{
			summary = SummaryState.COMPLETED;
			completionTime = 0;
		}
		else
		{
			summary = SummaryState.IN_PROGRESS;
			completionTime = maxCompletionTime;
		}
	}

	private void saveToConfig(Map<BirdHouseSpace, BirdHouseData> updatedData)
	{
		for (BirdHouseData data : updatedData.values())
		{
			String key = TimeTrackingConfig.BIRD_HOUSE + "." + data.getSpace().getVarp();
			// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
		}
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2021 Hannah Ryan <https://github.com/loldudester>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Value;

@Value
class ProfilePatch
{
	FarmingPatch patch;
	String rsProfileKey;
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import com.google.common.annotations.VisibleForTesting;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Varbits;
import net.runelite.api.WidgetNode;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.WidgetModalMode;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfile;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.timetracking.SummaryState;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;
import net.runelite.client.util.Text;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.time.Instant;
import java.util.*;

@Slf4j
@RequiredArgsConstructor(
	
	onConstructor = @__({@Inject})
)
public class FarmingTracker
{
	private final int FARMING_GUILD_REGION_ID = 4922;

	// Categories of patches that exist both within and outside the farming guild, thus effected by the ignore flag
	private final Set<Tab> FARMING_GUILD_EFFECTED_TABS = new HashSet<Tab>(Arrays.asList(
			Tab.ALLOTMENT,
			Tab.FLOWER,
			Tab.HERB,
			Tab.TREE,
			Tab.FRUIT_TREE,
			Tab.BUSH,
			Tab.CACTUS
	));

	private final Client client;
	private final ItemManager itemManager;
	private final ConfigManager configManager;
	private final TimeTrackingConfig config;
	private final FarmingWorld farmingWorld;
	private final Notifier notifier;
	private final CompostTracker compostTracker;
	private final PaymentTracker paymentTracker;

	private final Map<Tab, SummaryState> summaries = new EnumMap<>(Tab.class);
	private final Map<Tab, Boolean> harvestable = new EnumMap<>(Tab.class);

	/**
	 * The time at which all patches of a particular type will be ready to be harvested,
	 * or {@code -1} if we have no data about any patch of the given type.
	 */
	private final Map<Tab, Long> completionTimes = new EnumMap<>(Tab.class);
	Map<ProfilePatch, Boolean> wasNotified = new HashMap<>();

	private Map<Tab, Set<FarmingPatch>> customizedTabData = null;

	private boolean newRegionLoaded;
	private Collection<FarmingRegion> lastRegions;
	private boolean firstNotifyCheck = true;

	@Setter
	private boolean ignoreFarmingGuild = false;

	public FarmingTabPanel createTabPanel(Tab tab, FarmingContractManager farmingContractManager)
	{
		return new FarmingTabPanel(this, compostTracker, paymentTracker, itemManager, configManager, config, farmingWorld.getTabs().get(tab), farmingContractManager);
	}

	/**
	 * Updates tracker data for the current region. Returns true if any data was changed.
	 */
	public boolean updateData(WorldPoint location, int timeSinceModalClose)
	{
		boolean changed = false;

		//Varbits don't get sent when a modal widget is open so just return
		for (WidgetNode widgetNode : client.getComponentTable())
		{
			if (widgetNode.getModalMode() != WidgetModalMode.NON_MODAL)
			{
				return false;
			}
		}

		{
			String autoweed = Integer.toString(client.getVarbitValue(Varbits.AUTOWEED));
			if (!autoweed.equals(configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, TimeTrackingConfig.AUTOWEED)))
			{
				// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
				changed = true;
			}
		}

		Collection<FarmingRegion> newRegions = farmingWorld.getRegionsForLocation(location);

		if (!newRegions.equals(lastRegions))
		{
			newRegionLoaded = true;
			log.debug("New region loaded. {} at {} ticks", newRegions.toString(), client.getTickCount());
		}

		for (FarmingRegion region : newRegions)
		{
			// Write config with new varbits
			// timetracking.<rsprofile>.<regionID>.<VarbitID>=<varbitValue>:<unix time>
			long unixNow = Instant.now().getEpochSecond();
			for (FarmingPatch patch : region.getPatches())
			{
				// Write the config value if it doesn't match what is current, or it is more than 5 minutes old
				int varbit = patch.getVarbit();
				String key = patch.configKey();
				String strVarbit = Integer.toString(client.getVarbitValue(varbit));
				String storedValue = configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, key);

				PatchState currentPatchState = patch.getImplementation().forVarbitValue(client.getVarbitValue(varbit));
				if (currentPatchState == null)
				{
					continue;
				}

				if (storedValue != null)
				{
					String[] parts = storedValue.split(":");
					if (parts.length == 2)
					{
						if (parts[0].equals(strVarbit))
						{
							long unixTime = 0;
							try
							{
								unixTime = Long.parseLong(parts[1]);
							}
							catch (NumberFormatException e)
							{
								// ignored
							}
							if (unixTime + (5 * 60) > unixNow && unixNow + 30 > unixTime)
							{
								continue;
							}
						}
						else if (!newRegionLoaded && timeSinceModalClose > 1)
						{
							PatchState previousPatchState = patch.getImplementation().forVarbitValue(Integer.parseInt(parts[0]));

							if (previousPatchState == null)
							{
								continue;
							}

							int patchTickRate = previousPatchState.getTickRate();

							if (isObservedGrowthTick(previousPatchState, currentPatchState))
							{
								Integer storedOffsetPrecision = configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, TimeTrackingConfig.FARM_TICK_OFFSET_PRECISION, int.class);
								Integer storedOffsetMins = configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, TimeTrackingConfig.FARM_TICK_OFFSET, int.class);

								int offsetMins = (int) Math.abs(((Instant.now().getEpochSecond() / 60) % patchTickRate) - patchTickRate);
								log.debug("Observed an exact growth tick. Offset is: {} from a {} minute tick", offsetMins, patchTickRate);

								if (storedOffsetMins != null && storedOffsetMins != 0 && offsetMins != storedOffsetMins % patchTickRate)
								{
									WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
									log.error("Offset error! Observed new offset of {}, previous observed offset was {} ({}) Player Loc:{}", offsetMins, storedOffsetMins, storedOffsetMins % patchTickRate, playerLocation);
								}

								if (storedOffsetPrecision == null || patchTickRate >= storedOffsetPrecision)
								{
									log.debug("Found a longer growth tick {}, saving new offset", patchTickRate);

									// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
									// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
								}
							}
							if (currentPatchState.getTickRate() != 0
								// Don't set wasNotified to false if witnessing a check-health action
								&& !(previousPatchState.getCropState() == CropState.GROWING && currentPatchState.getCropState() == CropState.HARVESTABLE && currentPatchState.getProduce().getPatchImplementation().isHealthCheckRequired()))
							{
								wasNotified.put(new ProfilePatch(patch, configManager.getRSProfileKey()), false);
							}
						}
						else
						{
							log.debug("ignoring growth tick for offset calculation; newRegionLoaded={} timeSinceModalClose={}", newRegionLoaded, timeSinceModalClose);
						}
					}
				}

				if (currentPatchState.getCropState() == CropState.DEAD ||
					currentPatchState.getCropState() == CropState.HARVESTABLE ||
					currentPatchState.getCropState() == CropState.EMPTY)
				{
					compostTracker.setCompostState(patch, null);
					paymentTracker.setProtectedState(patch, false);
				}

				String value = strVarbit + ":" + unixNow;
				// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
				changed = true;
			}
		}

		//Do one scan after loading a new region before possibly updating tick offsets
		newRegionLoaded = false;
		lastRegions = newRegions;

		if (changed)
		{
			updateCompletionTime();
		}

		return changed;
	}

	private boolean isObservedGrowthTick(PatchState previous, PatchState current)
	{
		//Check the previous state so it will still calculate during the final growth tick
		int patchTickRate = previous.getTickRate();
		CropState previousCropState = previous.getCropState();
		CropState currentCropState = current.getCropState();
		Produce previousProduce = previous.getProduce();

		//Ignore weeds growing or being cleared.
		if (previousProduce == Produce.WEEDS || current.getProduce() == Produce.WEEDS
			|| current.getProduce() != previousProduce
			|| patchTickRate <= 0)
		{
			return false;
		}

		if (previousCropState == CropState.GROWING)
		{
			if ((currentCropState == CropState.GROWING && current.getStage() - previous.getStage() == 1)
				|| currentCropState == CropState.DISEASED)
			{
				log.debug("Found GROWING -> GROWING or GROWING -> DISEASED");
				return true;
			}

			if (currentCropState == CropState.HARVESTABLE && !previousProduce.getPatchImplementation().isHealthCheckRequired())
			{
				log.debug("Found GROWING -> HARVESTABLE");
				return true;
			}
		}

		if (previousCropState == CropState.DISEASED && currentCropState == CropState.DEAD)
		{
			log.debug("Found DISEASED -> DEAD");
			return true;
		}

		return false;
	}

	@Nullable
	public PatchPrediction predictPatch(FarmingPatch patch)
	{
		return predictPatch(patch, configManager.getRSProfileKey());
	}

	@Nullable
	public PatchPrediction predictPatch(FarmingPatch patch, String profile)
	{
		long unixNow = Instant.now().getEpochSecond();

		boolean autoweed = Integer.toString(Autoweed.ON.ordinal())
			.equals(configManager.getConfiguration(TimeTrackingConfig.CONFIG_GROUP, profile, TimeTrackingConfig.AUTOWEED));

		String key = patch.configKey();
		String storedValue = configManager.getConfiguration(TimeTrackingConfig.CONFIG_GROUP, profile, key);

		if (storedValue == null)
		{
			return null;
		}

		long unixTime = 0;
		int value = 0;
		{
			String[] parts = storedValue.split(":");
			if (parts.length == 2)
			{
				try
				{
					value = Integer.parseInt(parts[0]);
					unixTime = Long.parseLong(parts[1]);
				}
				catch (NumberFormatException e)
				{
				}
			}
		}

		if (unixTime <= 0)
		{
			return null;
		}

		PatchState state = patch.getImplementation().forVarbitValue(value);

		if (state == null)
		{
			return null;
		}

		int stage = state.getStage();
		int stages = state.getStages();
		int tickrate = state.getTickRate();

		if (autoweed && state.getProduce() == Produce.WEEDS)
		{
			stage = 0;
			stages = 1;
			tickrate = 0;
		}

		long doneEstimate = 0;
		if (tickrate > 0)
		{
			long tickNow = getTickTime(tickrate, 0, unixNow, profile);
			long tickTime = getTickTime(tickrate, 0, unixTime, profile);
			int delta = (int) (tickNow - tickTime) / (tickrate * 60);

			doneEstimate = getTickTime(tickrate, stages - 1 - stage, tickTime, profile);

			stage += delta;
			if (stage >= stages)
			{
				stage = stages - 1;
			}
		}

		return new PatchPrediction(
			state.getProduce(),
			state.getCropState(),
			doneEstimate,
			stage,
			stages
		);
	}

	public long getTickTime(int tickRate, int ticks)
	{
		return getTickTime(tickRate, ticks, Instant.now().getEpochSecond(), configManager.getRSProfileKey());
	}

	public long getTickTime(int tickRate, int ticks, long requestedTime, String profile)
	{
		Integer offsetPrecisionMins = configManager.getConfiguration(TimeTrackingConfig.CONFIG_GROUP, profile, TimeTrackingConfig.FARM_TICK_OFFSET_PRECISION, int.class);
		Integer offsetTimeMins = configManager.getConfiguration(TimeTrackingConfig.CONFIG_GROUP, profile, TimeTrackingConfig.FARM_TICK_OFFSET, int.class);

		//All offsets are negative but are stored as positive
		long calculatedOffsetTime = 0L;
		if (offsetPrecisionMins != null && offsetTimeMins != null && (offsetPrecisionMins >= tickRate || offsetPrecisionMins >= 40))
		{
			calculatedOffsetTime = (offsetTimeMins % tickRate) * 60;
		}

		//Calculate "now" as +offset seconds in the future so we calculate the correct ticks
		long unixNow = requestedTime + calculatedOffsetTime;

		//The time that the tick requested will happen
		long timeOfCurrentTick = (unixNow - (unixNow % (tickRate * 60)));
		long timeOfGoalTick = timeOfCurrentTick + (ticks * tickRate * 60);

		//Move ourselves back to real time
		return timeOfGoalTick - calculatedOffsetTime;
	}

	public void loadCompletionTimes()
	{
		summaries.clear();
		harvestable.clear();
		completionTimes.clear();
		lastRegions = null;
		updateCompletionTime();
	}

	public SummaryState getSummary(Tab patchType)
	{
		SummaryState summary = summaries.get(patchType);
		return summary == null ? SummaryState.UNKNOWN : summary;
	}

	public Boolean getHarvestable(Tab patchType)
	{
		Boolean isHarvestable = harvestable.get(patchType);
		return isHarvestable != null && isHarvestable;
	}

	/**
	 * Gets the overall completion time for the given patch type.
	 *
	 * @see #completionTimes
	 */
	public long getCompletionTime(Tab patchType)
	{
		Long completionTime = completionTimes.get(patchType);
		return completionTime == null ? -1 : completionTime;
	}

	/**
	 * Updates the overall completion time for the given patch type.
	 *
	 * @see #completionTimes
	 */
	public void updateCompletionTime()
	{
		for (Map.Entry<Tab, Set<FarmingPatch>> tab : getTabData())
		{
			long extremumCompletionTime = config.preferSoonest() ? Long.MAX_VALUE : 0;
			boolean allUnknown = true;
			boolean allEmpty = true;
			boolean anyHarvestable = false;
			boolean allHarvestable = true;

			for (FarmingPatch patch : tab.getValue())
			{
				if (shouldSkipFarmingGuildPatch(tab.getKey(), patch)) {
					continue;
				}

				PatchPrediction prediction = predictPatch(patch);
				if (prediction == null || prediction.getProduce().getItemID() < 0)
				{
					continue; // unknown state
				}

				allUnknown = false;

				if (prediction.getProduce() != Produce.WEEDS && prediction.getProduce() != Produce.SCARECROW)
				{
					allEmpty = false;

					// update max duration if this patch takes longer to grow
					if (config.preferSoonest())
					{
						extremumCompletionTime = Math.min(extremumCompletionTime, prediction.getDoneEstimate());
					}
					else
					{
						extremumCompletionTime = Math.max(extremumCompletionTime, prediction.getDoneEstimate());
					}
					boolean isHarvestable = false;
					if (prediction.getCropState() == CropState.GROWING)
					{
						isHarvestable = prediction.getStage() == (prediction.getStages() - 1);
					}
					else if (prediction.getCropState() == CropState.HARVESTABLE || prediction.getCropState() == CropState.DEAD)
					{
						PatchImplementation patchImplementation = prediction.getProduce().getPatchImplementation();
						if (patchImplementation.equals(PatchImplementation.BUSH)
							|| patchImplementation.equals(PatchImplementation.HERB)
							|| patchImplementation.equals(PatchImplementation.ALLOTMENT)
							|| patchImplementation.equals(PatchImplementation.BELLADONNA)
							|| patchImplementation.equals(PatchImplementation.FLOWER)
							|| patchImplementation.equals(PatchImplementation.SEAWEED)
							|| patchImplementation.equals(PatchImplementation.HOPS)
							|| patchImplementation.equals(PatchImplementation.MUSHROOM)
							|| patchImplementation.equals(PatchImplementation.GRAPES)
							|| patchImplementation.equals(PatchImplementation.HESPORI)
							|| patchImplementation.equals(PatchImplementation.COMPOST))
						{
							isHarvestable = true;
						}
						else
						{
							isHarvestable = prediction.getStage() > 0;
						}
					}

					anyHarvestable |= isHarvestable;
					allHarvestable &= isHarvestable;
				}
			}
			allHarvestable &= !allEmpty;

			final SummaryState state;
			final long completionTime;

			if (allUnknown)
			{
				state = SummaryState.UNKNOWN;
				completionTime = -1L;
			}
			else if (allEmpty)
			{
				state = SummaryState.EMPTY;
				completionTime = -1L;
			}
			else if (extremumCompletionTime <= Instant.now().getEpochSecond())
			{
				state = SummaryState.COMPLETED;
				completionTime = 0;
			}
			else
			{
				state = SummaryState.IN_PROGRESS;
				completionTime = extremumCompletionTime;
			}
			summaries.put(tab.getKey(), state);
			harvestable.put(tab.getKey(), config.preferSoonest() ? anyHarvestable : allHarvestable);
			completionTimes.put(tab.getKey(), completionTime);
		}
	}

	public void checkCompletion()
	{
		List<RuneScapeProfile> rsProfiles = configManager.getRSProfiles();
		long unixNow = Instant.now().getEpochSecond();

		for (RuneScapeProfile profile : rsProfiles)
		{
			Integer offsetPrecisionMins = configManager.getConfiguration(TimeTrackingConfig.CONFIG_GROUP, profile.getKey(), TimeTrackingConfig.FARM_TICK_OFFSET_PRECISION, int.class);
			Integer offsetTimeMins = configManager.getConfiguration(TimeTrackingConfig.CONFIG_GROUP, profile.getKey(), TimeTrackingConfig.FARM_TICK_OFFSET, int.class);

			for (Map.Entry<Tab, Set<FarmingPatch>> tab : getTabData())
			{
				for (FarmingPatch patch : tab.getValue())
				{
					ProfilePatch profilePatch = new ProfilePatch(patch, profile.getKey());
					boolean patchNotified = wasNotified.getOrDefault(profilePatch, false);
					String configKey = patch.notifyConfigKey();
					boolean shouldNotify = Boolean.TRUE
						.equals(configManager.getConfiguration(TimeTrackingConfig.CONFIG_GROUP, profile.getKey(), configKey, Boolean.class));
					PatchPrediction prediction = predictPatch(patch, profile.getKey());

					if (prediction == null)
					{
						continue;
					}

					int tickRate = prediction.getProduce().getTickrate();

					if (offsetPrecisionMins == null || offsetTimeMins == null || (offsetPrecisionMins < tickRate && offsetPrecisionMins < 40) || prediction.getProduce() == Produce.WEEDS
						|| unixNow <= prediction.getDoneEstimate() || patchNotified || prediction.getCropState() == CropState.FILLING || prediction.getCropState() == CropState.EMPTY)
					{
						continue;
					}

					wasNotified.put(profilePatch, true);

					if (!firstNotifyCheck && shouldNotify)
					{
						sendNotification(profile, prediction, patch);
					}
				}
			}
		}
		firstNotifyCheck = false;
	}

	private Set<Map.Entry<Tab, Set<FarmingPatch>>> getTabData() {
		if (customizedTabData == null) {
			customizedTabData = buildCustomTabData();
		}
		return customizedTabData.entrySet();
	}

	// Build our own copy of FarmingWorld's Tab->FarmingPatch map to allow customizations
	private Map<Tab, Set<FarmingPatch>> buildCustomTabData() {
		Map<Tab, Set<FarmingPatch>> customTabData = new HashMap<>();

		Map<Tab, Set<FarmingPatch>> vanillaTabData = farmingWorld.getTabs();
		for (Tab defaultTab : vanillaTabData.keySet()) {
			for (FarmingPatch patch : vanillaTabData.get(defaultTab)) {
				Tab tab = determineTabForPatch(patch, defaultTab);
				{
					Set<FarmingPatch> values = customTabData.getOrDefault(tab, new HashSet<>());
					values.add(patch);
					customTabData.put(tab, values);
				}
			}
		}

		return customTabData;
	}

	private Tab determineTabForPatch(FarmingPatch patch, Tab defaultTab) {
		if (patch.getImplementation() == PatchImplementation.ANIMA) {
			return Tab.ANIMA;
		}
		return defaultTab;
	}

	@VisibleForTesting
	void sendNotification(RuneScapeProfile profile, PatchPrediction prediction, FarmingPatch patch)
	{
		final RuneScapeProfileType profileType = profile.getType();

		final StringBuilder stringBuilder = new StringBuilder();
		// Same RS account
		if (client.getGameState() == GameState.LOGGED_IN && profile.getDisplayName().equals(client.getLocalPlayer().getName()))
		{
			// Same RS account but different profile type
			if (profileType != RuneScapeProfileType.getCurrent(client))
			{
				stringBuilder.append('(')
					.append(Text.titleCase(profile.getType()))
					.append(") ");
			}
			// Same RS account AND profile falls through here so no bracketed prefix is added
		}
		else
		{
			// Different RS account AND profile type
			if (profileType != RuneScapeProfileType.getCurrent(client) || client.getGameState() == GameState.LOGIN_SCREEN)
			{
				//Don't print profile type when logged out if is STANDARD
				if (client.getGameState() == GameState.LOGIN_SCREEN && profileType == RuneScapeProfileType.STANDARD)
				{
					stringBuilder.append('(')
						.append(profile.getDisplayName())
						.append(") ");
				}
				else
				{
					stringBuilder.append('(')
						.append(profile.getDisplayName())
						.append(" - ")
						.append(Text.titleCase(profile.getType()))
						.append(") ");
				}
			}
			// Different RS account but same profile type
			else
			{
				stringBuilder.append('(')
					.append(profile.getDisplayName())
					.append(") ");
			}
		}

		stringBuilder
			.append("Your ")
			.append(prediction.getProduce().getName());

		switch (prediction.getCropState())
		{
			case HARVESTABLE:
			case GROWING:
				if (prediction.getProduce().getName().toLowerCase(Locale.ENGLISH).contains("compost"))
				{
					stringBuilder.append(" is ready to collect in ");
				}
				else
				{
					stringBuilder.append(" is ready to harvest in ");
				}
				break;
			case DISEASED:
				stringBuilder.append(" has become diseased in ");
				break;
			case DEAD:
				stringBuilder.append(" has died in ");
				break;
			default:
				// EMPTY and FILLING are caught above
				throw new IllegalStateException();
		}

		stringBuilder.append(patch.getRegion().isDefinite() ? "the " : "")
			.append(patch.getRegion().getName())
			.append('.');

		notifier.notify(stringBuilder.toString());
	}

	private boolean shouldSkipFarmingGuildPatch(Tab tab, FarmingPatch patch) {
		boolean isFarmingGuildEffectedTab = FARMING_GUILD_EFFECTED_TABS.contains(tab);
		boolean isFarmingGuildPatch = patch.getRegion().getRegionID() == FARMING_GUILD_REGION_ID;
		return ignoreFarmingGuild && isFarmingGuildEffectedTab && isFarmingGuildPatch;
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;

@RequiredArgsConstructor
@Getter
public enum CropState
{
	HARVESTABLE(ColorScheme.PROGRESS_COMPLETE_COLOR),
	GROWING(ColorScheme.PROGRESS_COMPLETE_COLOR),
	DISEASED(ColorScheme.PROGRESS_INPROGRESS_COLOR),
	DEAD(ColorScheme.PROGRESS_ERROR_COLOR),
	EMPTY(ColorScheme.MEDIUM_GRAY_COLOR),
	FILLING(ColorScheme.PROGRESS_INPROGRESS_COLOR);

	private final Color color;
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

/**
 * An enumeration of possible autoweed settings.
 */
enum Autoweed
{
	/**
	 * Access to autoweed has not been unlocked.
	 */
	UNOWNED,
	/**
	 * Autoweed is disabled.
	 */
	OFF,
	/**
	 * Autoweed is enabled.
	 */
	ON
}

package com.homeassistant.runelite.farming;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@RequiredArgsConstructor
@Getter
public enum Tab {
    OVERVIEW("Overview", ItemID.OLD_NOTES),
    CLOCK("Timers & Stopwatches", ItemID.WATCH),
    BIRD_HOUSE("Bird Houses", ItemID.OAK_BIRD_HOUSE),
    ALLOTMENT("Allotment Patches", ItemID.CABBAGE),
    FLOWER("Flower Patches", ItemID.RED_FLOWERS),
    HERB("Herb Patches", ItemID.GRIMY_RANARR_WEED),
    TREE("Tree Patches", ItemID.YEW_LOGS),
    FRUIT_TREE("Fruit Tree Patches", ItemID.PINEAPPLE),
    HOPS("Hops Patches", ItemID.BARLEY),
    BUSH("Bush Patches", ItemID.POISON_IVY_BERRIES),
    GRAPE("Grape Patches", ItemID.GRAPES),
    SPECIAL("Special Patches", ItemID.MUSHROOM),
    MUSHROOM("Mushroom Patch", ItemID.MUSHROOM),
    BELLADONNA("Belladonna Patch", ItemID.CAVE_NIGHTSHADE),
    BIG_COMPOST("Giant Compost Bin", ItemID.ULTRACOMPOST),
    SEAWEED("Seaweed Patches", ItemID.GIANT_SEAWEED),
    CALQUAT("Calquat Patch", ItemID.CALQUAT_FRUIT),
    CELASTRUS("Celastrus Patch", ItemID.BATTLESTAFF),
    HARDWOOD("Hardwood Patches", ItemID.TEAK_LOGS),
    REDWOOD("Redwood Patch", ItemID.REDWOOD_LOGS),
    CACTUS("Cactus Patches", ItemID.POTATO_CACTUS),
    HESPORI("Hespori Patch", ItemID.TANGLEROOT),
    CRYSTAL("Crystal Patch", ItemID.CRYSTAL_SHARD),
    TIME_OFFSET("Farming Tick Offset", ItemID.WATERING_CAN),

    // Custom Tabs
    ANIMA("Anima Patch", ItemID.ANIMAINFUSED_BARK)
    ;

    public static final Tab[] FARMING_TABS = {HERB, TREE, FRUIT_TREE, SPECIAL, FLOWER, ALLOTMENT, BUSH, GRAPE, HOPS, CRYSTAL};

    private final String name;
    private final int itemID;
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Value;

@Value
public class PatchPrediction
{
	private final Produce produce;
	private final CropState cropState;
	private final long doneEstimate;
	private final int stage;
	private final int stages;
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2019, Koekkruimels <https://github.com/koekkruimels>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Getter;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.timetracking.SummaryState;
import net.runelite.client.plugins.timetracking.TabContentPanel;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.util.ColorUtil;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Instant;

class FarmingContractInfoBox extends InfoBox
{
	@Getter
	private final Produce contract;
	private final FarmingContractManager manager;
	private final TimeTrackingConfig config;

	FarmingContractInfoBox(BufferedImage image, Plugin plugin, Produce contract, TimeTrackingConfig config, FarmingContractManager manager)
	{
		super(image, plugin);
		this.contract = contract;
		this.config = config;
		this.manager = manager;
	}

	@Override
	public String getText()
	{
		return null;
	}

	@Override
	public Color getTextColor()
	{
		return null;
	}

	@Override
	public String getTooltip()
	{
		SummaryState summary = manager.getSummary();

		Color contractColor;
		String contractDescription;
		switch (summary)
		{
			case COMPLETED:
				contractDescription = "Ready";
				contractColor = ColorScheme.PROGRESS_COMPLETE_COLOR;
				break;
			case OCCUPIED:
				contractDescription = "Occupied";
				contractColor = ColorScheme.PROGRESS_ERROR_COLOR;
				break;
			case IN_PROGRESS:
				CropState cropState = manager.getContractCropState();
				switch (cropState)
				{
					case DISEASED:
						contractDescription = "Diseased";
						contractColor = cropState.getColor();
						break;
					case DEAD:
						contractDescription = "Dead";
						contractColor = cropState.getColor();
						break;
					default:
						contractDescription = "Ready " + TabContentPanel.getFormattedEstimate(manager.getCompletionTime() - Instant.now().getEpochSecond(),
							config.timeFormatMode());
						contractColor = Color.GRAY;
						break;
				}
				break;
			case EMPTY:
			case UNKNOWN:
			default:
				contractDescription = null;
				contractColor = Color.GRAY;
				break;
		}

		StringBuilder sb = new StringBuilder();
		sb.append(ColorUtil.wrapWithColorTag("Farming Contract", Color.WHITE));
		sb.append("</br>");
		sb.append(ColorUtil.wrapWithColorTag(contract.getName(), contractColor));

		if (contractDescription != null)
		{
			sb.append("</br>");
			sb.append(ColorUtil.wrapWithColorTag(contractDescription, contractColor));
		}

		return sb.toString();
	}

	@Override
	public boolean render()
	{
		return config.farmingContractInfoBox();
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2022, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetModelType;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;

import javax.inject.Inject;

@Slf4j
@RequiredArgsConstructor(
	
	onConstructor = @__({@Inject})
)
public class PaymentTracker
{
	private static final String PAYMENT_MALE = "That'll do nicely, sir. Leave it with me - I'll make sure<br>that patch grows for you.";
	private static final String PAYMENT_FEMALE = "That'll do nicely, madam. Leave it with me - I'll make<br>sure that patch grows for you.";

	private final Client client;
	private final ConfigManager configManager;
	private final FarmingWorld farmingWorld;

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		Widget text = client.getWidget(ComponentID.DIALOG_NPC_TEXT);
		if (text == null || (!PAYMENT_MALE.equals(text.getText()) && !PAYMENT_FEMALE.equals(text.getText())))
		{
			return;
		}

		Widget name = client.getWidget(ComponentID.DIALOG_NPC_NAME);
		Widget head = client.getWidget(ComponentID.DIALOG_NPC_HEAD_MODEL);
		if (name == null || head == null || head.getModelType() != WidgetModelType.NPC_CHATHEAD)
		{
			return;
		}

		final int npcId = head.getModelId();
		final FarmingPatch patch = findPatchForNpc(npcId);
		if (patch == null)
		{
			return;
		}

		if (getProtectedState(patch))
		{
			return;
		}

		log.debug("Detected patch payment for {} ({})", name.getText(), npcId);
		setProtectedState(patch, true);
	}

	private static String configKey(FarmingPatch fp)
	{
		return fp.configKey() + "." + TimeTrackingConfig.PROTECTED;
	}

	public void setProtectedState(FarmingPatch fp, boolean state)
	{
		if (!state)
		{
			configManager.unsetRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, configKey(fp));
		}
		else
		{
			// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
		}
	}

	public boolean getProtectedState(FarmingPatch fp)
	{
		return Boolean.TRUE.equals(configManager.getRSProfileConfiguration(
			TimeTrackingConfig.CONFIG_GROUP,
			configKey(fp),
			Boolean.class));
	}

	private FarmingPatch findPatchForNpc(int npcId)
	{
		FarmingPatch p = null;
		for (FarmingRegion region : farmingWorld.getRegionsForLocation(client.getLocalPlayer().getWorldLocation()))
		{
			for (FarmingPatch patch : region.getPatches())
			{
				if (patch.getFarmer() == npcId)
				{
					if (p != null)
					{
						log.debug("Ambiguous payment to {} between {} and {}", npcId, p, patch);
						return null;
					}

					p = patch;
				}
			}
		}
		return p;
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import com.google.common.base.Strings;
import net.runelite.api.ItemID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.timetracking.TabContentPanel;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;
import net.runelite.client.plugins.timetracking.TimeablePanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.AsyncBufferedImage;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class FarmingTabPanel extends TabContentPanel
{
	private final FarmingTracker farmingTracker;
	private final CompostTracker compostTracker;
	private final PaymentTracker paymentTracker;
	private final ItemManager itemManager;
	private final ConfigManager configManager;
	private final TimeTrackingConfig config;
	private final List<TimeablePanel<FarmingPatch>> patchPanels;
	private final FarmingContractManager farmingContractManager;

	FarmingTabPanel(
		FarmingTracker farmingTracker,
		CompostTracker compostTracker,
		PaymentTracker paymentTracker,
		ItemManager itemManager,
		ConfigManager configManager,
		TimeTrackingConfig config,
		Set<FarmingPatch> patches,
		FarmingContractManager farmingContractManager
	)
	{
		this.farmingTracker = farmingTracker;
		this.compostTracker = compostTracker;
		this.paymentTracker = paymentTracker;
		this.itemManager = itemManager;
		this.configManager = configManager;
		this.config = config;
		this.patchPanels = new ArrayList<>();
		this.farmingContractManager = farmingContractManager;

		setLayout(new GridBagLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 1;
		c.gridx = 0;
		c.gridy = 0;

		PatchImplementation lastImpl = null;

		boolean first = true;
		for (FarmingPatch patch : patches)
		{
			String title = patch.getRegion().getName() + (Strings.isNullOrEmpty(patch.getName()) ? "" : " (" + patch.getName() + ")");
			TimeablePanel<FarmingPatch> p = new TimeablePanel<>(patch, title, 1);

			/* Show labels to subdivide tabs into sections */
			if (patch.getImplementation() != lastImpl && !Strings.isNullOrEmpty(patch.getImplementation().getName()))
			{
				JLabel groupLabel = new JLabel(patch.getImplementation().getName());

				if (first)
				{
					first = false;
					groupLabel.setBorder(new EmptyBorder(4, 0, 0, 0));
				}
				else
				{
					groupLabel.setBorder(new EmptyBorder(15, 0, 0, 0));
				}

				groupLabel.setFont(FontManager.getRunescapeSmallFont());

				add(groupLabel, c);
				c.gridy++;
				lastImpl = patch.getImplementation();
			}

			// Set toggle state of notification menu on icon click;
			JToggleButton toggleNotify = p.getNotifyButton();
			String configKey = patch.notifyConfigKey();

			toggleNotify.addActionListener(e ->
			{
				if (configManager.getRSProfileKey() != null)
				{
					// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
				}
			});

			patchPanels.add(p);
			add(p, c);
			c.gridy++;

			/* This is a weird hack to remove the top border on the first tracker of every tab */
			if (first)
			{
				first = false;
				p.setBorder(null);
			}
		}
	}

	@Override
	public int getUpdateInterval()
	{
		return 50; // 10 seconds
	}

	@Override
	public void update()
	{
		long unixNow = Instant.now().getEpochSecond();

		for (TimeablePanel<FarmingPatch> panel : patchPanels)
		{
			FarmingPatch patch = panel.getTimeable();
			PatchPrediction prediction = farmingTracker.predictPatch(patch);

			final boolean protected_ = paymentTracker.getProtectedState(patch);
			final CompostState compostState = compostTracker.getCompostState(patch);
			final AsyncBufferedImage img = getPatchImage(compostState, protected_);
			final String tooltip = getPatchTooltip(compostState, protected_);

			if (img != null)
			{
				img.onLoaded(() -> panel.setOverlayIconImage(img));
			}
			else
			{
				panel.setOverlayIconImage(null);
			}

			if (prediction == null)
			{
				itemManager.getImage(Produce.WEEDS.getItemID()).addTo(panel.getIcon());
				panel.getIcon().setToolTipText("Unknown state" + tooltip);
				panel.getProgress().setMaximumValue(0);
				panel.getProgress().setValue(0);
				panel.getProgress().setVisible(false);
				panel.getEstimate().setText("Unknown");
				panel.getProgress().setBackground(null);
			}
			else
			{
				if (prediction.getProduce().getItemID() < 0)
				{
					panel.getIcon().setIcon(null);
					panel.getIcon().setToolTipText("Unknown state" + tooltip);
				}
				else
				{
					itemManager.getImage(prediction.getProduce().getItemID()).addTo(panel.getIcon());
					panel.getIcon().setToolTipText(prediction.getProduce().getName() + tooltip);
				}

				switch (prediction.getCropState())
				{
					case HARVESTABLE:
						panel.getEstimate().setText("Done");
						break;
					case GROWING:
						if (prediction.getDoneEstimate() < unixNow)
						{
							panel.getEstimate().setText("Done");
						}
						else
						{
							panel.getEstimate().setText("Done " + getFormattedEstimate(prediction.getDoneEstimate() - unixNow, config.timeFormatMode()));
						}
						break;
					case DISEASED:
						panel.getEstimate().setText("Diseased");
						break;
					case DEAD:
						panel.getEstimate().setText("Dead");
						break;
					case EMPTY:
						panel.getEstimate().setText("Empty");
						break;
					case FILLING:
						panel.getEstimate().setText("Filling");
						break;
				}

				/* Hide any fully grown weeds' progress bar. */
				if (prediction.getProduce() != Produce.WEEDS || prediction.getStage() < prediction.getStages() - 1)
				{
					panel.getProgress().setVisible(true);
					panel.getProgress().setForeground(prediction.getCropState().getColor().darker());
					panel.getProgress().setMaximumValue(prediction.getStages() - 1);
					panel.getProgress().setValue(prediction.getStage());
				}
				else
				{
					panel.getProgress().setVisible(false);
				}
			}

			JLabel farmingContractIcon = panel.getFarmingContractIcon();
			if (farmingContractManager.shouldHighlightFarmingTabPanel(patch))
			{
				itemManager.getImage(ItemID.SEED_PACK).addTo(farmingContractIcon);
				farmingContractIcon.setToolTipText(farmingContractManager.getContract().getName());
			}
			else
			{
				farmingContractIcon.setIcon(null);
				farmingContractIcon.setToolTipText("");
			}

			String configKey = patch.notifyConfigKey();
			JToggleButton toggleNotify = panel.getNotifyButton();
			boolean notifyEnabled = Boolean.TRUE
				.equals(configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, configKey, Boolean.class));

			toggleNotify.setSelected(notifyEnabled);
		}
	}

	private AsyncBufferedImage getPatchImage(CompostState compostState, boolean protected_)
	{
		return protected_ ? itemManager.getImage(ItemID.APPLES5) :
			(compostState != null ? itemManager.getImage(compostState.getItemId()) : null);
	}

	private String getPatchTooltip(CompostState compostState, boolean protected_)
	{
		StringBuilder stringBuilder = new StringBuilder();
		if (protected_)
		{
			stringBuilder.append(" protected");
			if (compostState != null)
			{
				stringBuilder.append(" and ").append(compostState.name().toLowerCase()).append("ed");
			}
		}
		else if (compostState != null)
		{
			stringBuilder.append(" with ").append(compostState.name().toLowerCase());
		}
		return stringBuilder.toString();
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2022 LlemonDuck
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@RequiredArgsConstructor
@Getter
public enum CompostState
{

	COMPOST(ItemID.COMPOST),
	SUPERCOMPOST(ItemID.SUPERCOMPOST),
	ULTRACOMPOST(ItemID.ULTRACOMPOST),
	;

	private final int itemId;

}
// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2019, Koekkruimels <https://github.com/koekkruimels>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.NullNpcID;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.timetracking.SummaryState;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;
import net.runelite.client.plugins.timetracking.TimeTrackingPlugin;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.time.Instant;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class FarmingContractManager
{
	private static final int GUILDMASTER_JANE_NPC_ID = NullNpcID.NULL_8628;
	private static final int FARMING_GUILD_REGION_ID = 4922;
	private static final Pattern CONTRACT_ASSIGN_PATTERN = Pattern.compile("(?:We need you to grow|Please could you grow) (?:some|a|an) ([a-zA-Z ]+)(?: for us\\?|\\.)");
	private static final String CONTRACT_REWARDED = "You'll be wanting a reward then. Here you go.";
	private static final String CONFIG_KEY_CONTRACT = "contract";

	@Getter
	private SummaryState summary = SummaryState.UNKNOWN;

	@Getter
	private CropState contractCropState;

	private Client client;

	private ItemManager itemManager;

	private TimeTrackingConfig config;

	private TimeTrackingPlugin plugin;

	private FarmingWorld farmingWorld;

	private FarmingTracker farmingTracker;

	private InfoBoxManager infoBoxManager;

	private ConfigManager configManager;

	@Getter
	private Produce contract = null;

	@Getter
	@Setter
	private FarmingContractInfoBox infoBox;

	@Getter
	private long completionTime;

	public FarmingContractManager(Client client, ItemManager itemManager, ConfigManager configManager, TimeTrackingConfig config, FarmingWorld farmingWorld, FarmingTracker farmingTracker)
	{
		this.client = client;
		this.itemManager = itemManager;
		this.configManager = configManager;
		this.config = config;
		this.farmingWorld = farmingWorld;
		this.farmingTracker = farmingTracker;
	}

	public void setContract(@Nullable Produce contract)
	{
		this.contract = contract;
		setStoredContract(contract);
		handleContractState();
	}

	public boolean hasContract()
	{
		return contract != null;
	}

	@Nullable
	public Tab getContractTab()
	{
		return hasContract() ? contract.getPatchImplementation().getTab() : null;
	}

	@Nullable
	public String getContractName()
	{
		return hasContract() ? contract.getContractName() : null;
	}

	public boolean shouldHighlightFarmingTabPanel(@Nonnull FarmingPatch patch)
	{
		PatchPrediction patchPrediction = farmingTracker.predictPatch(patch);
		if (contract != null &&
			patch.getRegion().getRegionID() == FARMING_GUILD_REGION_ID &&
			contract.getPatchImplementation() == patch.getImplementation() &&
			patchPrediction != null &&
			(summary == SummaryState.EMPTY &&
				(patchPrediction.getProduce() == null || patchPrediction.getProduce() == Produce.WEEDS)
				|| patchPrediction.getProduce().equals(contract)))
		{
			return true;
		}
		return false;
	}

	public void loadContractFromConfig()
	{
		contract = getStoredContract();
		handleContractState();
	}

	public boolean updateData(WorldPoint loc)
	{
		SummaryState oldSummary = summary;

		handleContractState();
		if (loc.getRegionID() == FARMING_GUILD_REGION_ID)
		{
			handleGuildmasterJaneWidgetDialog();
			handleInfoBox();
		}
		else
		{
			if (infoBox != null)
			{
				infoBoxManager.removeInfoBox(infoBox);
				infoBox = null;
			}
		}
		return oldSummary != summary;
	}

	private void handleInfoBox()
	{
		if (contract != (infoBox == null ? null : infoBox.getContract()))
		{
			if (infoBox != null)
			{
				infoBoxManager.removeInfoBox(infoBox);
				infoBox = null;
			}
			if (contract != null)
			{
				infoBox = new FarmingContractInfoBox(itemManager.getImage(contract.getItemID()), plugin, contract, config, this);
				infoBoxManager.addInfoBox(infoBox);
			}
		}
	}

	private void handleGuildmasterJaneWidgetDialog()
	{
		Widget npcDialog = client.getWidget(ComponentID.DIALOG_NPC_HEAD_MODEL);

		if (npcDialog == null || npcDialog.getModelId() != GUILDMASTER_JANE_NPC_ID)
		{
			return;
		}

		String dialogText = Text.removeTags(client.getWidget(ComponentID.DIALOG_NPC_TEXT).getText());

		if (dialogText.equals(CONTRACT_REWARDED))
		{
			setContract(null);
		}

		Matcher matcher = CONTRACT_ASSIGN_PATTERN.matcher(dialogText);

		if (!matcher.find())
		{
			return;
		}

		String name = matcher.group(1);

		Produce farmingContract = Produce.getByContractName(name);

		if (farmingContract == null)
		{
			return;
		}

		Produce currentFarmingContract = contract;

		if (farmingContract == currentFarmingContract)
		{
			return;
		}

		setContract(farmingContract);
	}

	public void handleContractState()
	{
		if (contract == null)
		{
			summary = SummaryState.UNKNOWN;
			return;
		}

		PatchImplementation patchImplementation = contract.getPatchImplementation();

		boolean hasEmptyPatch = false;
		boolean hasDiseasedPatch = false;
		boolean hasDeadPatch = false;
		completionTime = Long.MAX_VALUE;
		contractCropState = null;
		for (FarmingPatch patch : farmingWorld.getFarmingGuildRegion().getPatches())
		{
			if (patch.getImplementation() != patchImplementation)
			{
				continue;
			}

			PatchPrediction prediction = farmingTracker.predictPatch(patch);
			if (prediction == null)
			{
				continue;
			}

			Produce produce = prediction.getProduce();
			CropState state = prediction.getCropState();
			if (completionTime == Long.MAX_VALUE)
			{
				if (produce == null || produce == Produce.WEEDS)
				{
					// Don't report the empty state if there's a dead or diseased one
					if (!(hasDiseasedPatch || hasDeadPatch))
					{
						summary = SummaryState.EMPTY;
					}
					hasEmptyPatch = true;
					continue;
				}

				if ((contract.getPatchImplementation().isHealthCheckRequired() && state == CropState.HARVESTABLE)
					&& !(hasEmptyPatch || hasDiseasedPatch || hasDeadPatch))
				{
					summary = SummaryState.OCCUPIED;
					// Don't let this run into the "Completed" section!
					continue;
				}
			}

			// Herbs always turn into ANYHERB when dead, so let them through.
			if (produce != contract && produce != Produce.ANYHERB)
			{
				if (!(hasEmptyPatch || hasDiseasedPatch || hasDeadPatch) && completionTime == Long.MAX_VALUE)
				{
					summary = SummaryState.OCCUPIED;
				}
			}
			else
			{
				// Ignore if crop is dead but there's another one in progress (either normal or diseased)
				if (state == CropState.DEAD && (hasDiseasedPatch || completionTime != Long.MAX_VALUE))
				{
					continue;
				}

				// Ignore if crop is diseased but there's another patch in progress
				if (state == CropState.DISEASED && completionTime != Long.MAX_VALUE)
				{
					continue;
				}

				contractCropState = state;
				if (contractCropState == CropState.DISEASED)
				{
					hasDiseasedPatch = true;
					summary = SummaryState.IN_PROGRESS;
				}
				else if (contractCropState == CropState.DEAD)
				{
					hasDeadPatch = true;
					summary = SummaryState.IN_PROGRESS;
				}
				else
				{
					long estimatedTime = Math.min(prediction.getDoneEstimate(), completionTime);
					if (estimatedTime <= Instant.now().getEpochSecond())
					{
						summary = SummaryState.COMPLETED;
						completionTime = 0;
						break;
					}
					else
					{
						summary = SummaryState.IN_PROGRESS;
						completionTime = estimatedTime;
					}
				}
			}
		}
	}


	@Nullable
	private Produce getStoredContract()
	{
		try
		{
			return Produce.getByItemID(Integer.parseInt(configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, CONFIG_KEY_CONTRACT)));
		}
		catch (NumberFormatException ignored)
		{
			return null;
		}
	}

	private void setStoredContract(@Nullable Produce contract)
	{
		if (contract != null)
		{
			// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
		}
		else
		{
			configManager.unsetRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, CONFIG_KEY_CONTRACT);
		}
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.*;
import net.runelite.api.annotations.Varbit;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;

@RequiredArgsConstructor(
	
)
@Getter
@ToString(onlyExplicitlyIncluded = true)
public class FarmingPatch
{
	@Setter(AccessLevel.PACKAGE)
	@ToString.Include
	private FarmingRegion region;
	@ToString.Include
	private final String name;
	@Getter(onMethod_ = {@Varbit})
	private final int varbit;
	@ToString.Include
	private final PatchImplementation implementation;
	private int farmer = -1;

	FarmingPatch(String name, @Varbit int varbit, PatchImplementation implementation, int farmer)
	{
		this(name, varbit, implementation);
		this.farmer = farmer;
	}

	String configKey()
	{
		return region.getRegionID() + "." + varbit;
	}

	String notifyConfigKey()
	{
		return TimeTrackingConfig.NOTIFY + "." + region.getRegionID() + "." + varbit;
	}
}
// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2022 LlemonDuck
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;

import javax.inject.Inject;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class CompostTracker
{

	@Value
	@VisibleForTesting
	static class PendingCompost
	{
		Instant timeout;
		WorldPoint patchLocation;
		FarmingPatch farmingPatch;
	}

	private static final Duration COMPOST_ACTION_TIMEOUT = Duration.ofSeconds(30);

	private static final Pattern COMPOST_USED_ON_PATCH = Pattern.compile(
		"You treat the .+ with (?<compostType>ultra|super|)compost\\.");
	private static final Pattern FERTILE_SOIL_CAST = Pattern.compile(
		"^The .+ has been treated with (?<compostType>ultra|super|)compost");
	private static final Pattern ALREADY_TREATED = Pattern.compile(
		"This .+ has already been (treated|fertilised) with (?<compostType>ultra|super|)compost(?: - the spell can't make it any more fertile)?\\.");
	private static final Pattern INSPECT_PATCH = Pattern.compile(
		"This is an? .+\\. The soil has been treated with (?<compostType>ultra|super|)compost\\..*");

	private static final ImmutableSet<Integer> COMPOST_ITEMS = ImmutableSet.of(
		ItemID.COMPOST,
		ItemID.SUPERCOMPOST,
		ItemID.ULTRACOMPOST,
		ItemID.BOTTOMLESS_COMPOST_BUCKET_22997
	);

	private final Client client;
	private final FarmingWorld farmingWorld;
	private final ConfigManager configManager;

	@VisibleForTesting
	final Map<FarmingPatch, PendingCompost> pendingCompostActions = new HashMap<>();

	private static String configKey(FarmingPatch fp)
	{
		return fp.configKey() + "." + TimeTrackingConfig.COMPOST;
	}

	public void setCompostState(FarmingPatch fp, CompostState state)
	{
		log.debug("Storing compost state [{}] for patch [{}]", state, fp);
		if (state == null)
		{
			configManager.unsetRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, configKey(fp));
		}
		else
		{
			// configManager.setRSProfileConfiguration call removed. This code path should never be executed, but just in case.
		}
	}

	public CompostState getCompostState(FarmingPatch fp)
	{
		return configManager.getRSProfileConfiguration(
			TimeTrackingConfig.CONFIG_GROUP,
			configKey(fp),
			CompostState.class
		);
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked e)
	{
		if (!isCompostAction(e))
		{
			return;
		}

		ObjectComposition patchDef = client.getObjectDefinition(e.getId());
		WorldPoint actionLocation = WorldPoint.fromScene(client, e.getParam0(), e.getParam1(), client.getPlane());
		FarmingPatch targetPatch = farmingWorld.getRegionsForLocation(actionLocation)
			.stream()
			.flatMap(fr -> Arrays.stream(fr.getPatches()))
			.filter(fp -> fp.getVarbit() == patchDef.getVarbitId())
			.filter(fp -> fp.getImplementation() != PatchImplementation.COMPOST && fp.getImplementation() != PatchImplementation.BIG_COMPOST)
			.findFirst()
			.orElse(null);
		if (targetPatch == null)
		{
			return;
		}

		log.debug("Storing pending compost action for patch [{}]", targetPatch);
		PendingCompost pc = new PendingCompost(
			Instant.now().plus(COMPOST_ACTION_TIMEOUT),
			actionLocation,
			targetPatch
		);
		pendingCompostActions.put(targetPatch, pc);
	}

	private boolean isCompostAction(MenuOptionClicked e)
	{
		switch (e.getMenuAction())
		{
			case WIDGET_TARGET_ON_GAME_OBJECT:
				Widget w = client.getSelectedWidget();
				assert w != null;
				return COMPOST_ITEMS.contains(w.getItemId()) || w.getId() == ComponentID.SPELLBOOK_FERTILE_SOIL;

			case GAME_OBJECT_FIRST_OPTION:
			case GAME_OBJECT_SECOND_OPTION:
			case GAME_OBJECT_THIRD_OPTION:
			case GAME_OBJECT_FOURTH_OPTION:
			case GAME_OBJECT_FIFTH_OPTION:
				return "Inspect".equals(e.getMenuOption());

			default:
				return false;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (e.getType() != ChatMessageType.GAMEMESSAGE && e.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		CompostState compostUsed = determineCompostUsed(e.getMessage());
		if (compostUsed == null)
		{
			return;
		}

		this.expirePendingActions();

		pendingCompostActions.values()
			.stream()
			.filter(this::playerIsBesidePatch)
			.findFirst()
			.ifPresent(pc ->
			{
				setCompostState(pc.getFarmingPatch(), compostUsed);
				pendingCompostActions.remove(pc.getFarmingPatch());
			});
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		switch (e.getGameState())
		{
			case LOGGED_IN:
			case LOADING:
				return;

			default:
				pendingCompostActions.clear();
		}
	}

	private boolean playerIsBesidePatch(PendingCompost pendingCompost)
	{
		// find gameobject instance in scene
		// it is possible that the scene has reloaded between use and action occurring so we use worldpoint
		// instead of storing scene coords in the menuoptionclicked event
		LocalPoint localPatchLocation = LocalPoint.fromWorld(client, pendingCompost.getPatchLocation());
		if (localPatchLocation == null)
		{
			return false;
		}

		@Varbit int patchVarb = pendingCompost.getFarmingPatch().getVarbit();
		Tile patchTile = client.getScene()
			.getTiles()[client.getPlane()][localPatchLocation.getSceneX()][localPatchLocation.getSceneY()];
		GameObject patchObject = null;
		for (GameObject go : patchTile.getGameObjects())
		{
			if (go != null && client.getObjectDefinition(go.getId()).getVarbitId() == patchVarb)
			{
				patchObject = go;
				break;
			}
		}
		assert patchObject != null;

		// player coords
		final WorldPoint playerPos = client.getLocalPlayer().getWorldLocation();
		final int playerX = playerPos.getX();
		final int playerY = playerPos.getY();

		// patch coords
		final WorldPoint patchBase = pendingCompost.getPatchLocation();
		final int minX = patchBase.getX();
		final int minY = patchBase.getY();
		final int maxX = minX + patchObject.sizeX() - 1;
		final int maxY = minY + patchObject.sizeY() - 1;

		// player should be within one tile of these coords
		return playerX >= (minX - 1) && playerX <= (maxX + 1) && playerY >= (minY - 1) && playerY <= (maxY + 1);
	}

	private void expirePendingActions()
	{
		pendingCompostActions.values().removeIf(e -> Instant.now().isAfter(e.getTimeout()));
	}

	@VisibleForTesting
	static CompostState determineCompostUsed(String chatMessage)
	{
		if (!chatMessage.contains("compost"))
		{
			return null;
		}

		Matcher matcher;
		if ((matcher = COMPOST_USED_ON_PATCH.matcher(chatMessage)).matches() ||
			(matcher = FERTILE_SOIL_CAST.matcher(chatMessage)).find() ||
			(matcher = ALREADY_TREATED.matcher(chatMessage)).matches() ||
			(matcher = INSPECT_PATCH.matcher(chatMessage)).matches())
		{
			String compostGroup = matcher.group("compostType");
			switch (compostGroup)
			{
				case "ultra":
					return CompostState.ULTRACOMPOST;
				case "super":
					return CompostState.SUPERCOMPOST;
				default:
					return CompostState.COMPOST;
			}
		}

		return null;
	}

}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018, NotFoxtrot <https://github.com/NotFoxtrot>
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import lombok.Getter;
import net.runelite.api.NpcID;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;

import java.util.*;
import java.util.stream.Collectors;

public class FarmingWorld
{
	@SuppressWarnings("PMD.ImmutableField")
	private Multimap<Integer, FarmingRegion> regions = HashMultimap.create();

	@Getter
	private Map<Tab, Set<FarmingPatch>> tabs = new HashMap<>();

	private final Comparator<FarmingPatch> tabSorter = Comparator
		.comparing(FarmingPatch::getImplementation)
		.thenComparing((FarmingPatch p) -> p.getRegion().getName())
		.thenComparing(FarmingPatch::getName);

	@Getter
	private final FarmingRegion farmingGuildRegion;

	public FarmingWorld()
	{
		// Some of these patches get updated in multiple regions.
		// It may be worth it to add a specialization for these patches
		add(new FarmingRegion("Al Kharid", 13106, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.CACTUS, NpcID.AYESHA)
		), 13362, 13105);

		add(new FarmingRegion("Ardougne", 10290, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.BUSH, NpcID.TORRELL)
		), 10546);
		add(new FarmingRegion("Ardougne", 10548, false,
			new FarmingPatch("North", Varbits.FARMING_4771, PatchImplementation.ALLOTMENT, NpcID.KRAGEN),
			new FarmingPatch("South", Varbits.FARMING_4772, PatchImplementation.ALLOTMENT, NpcID.KRAGEN),
			new FarmingPatch("", Varbits.FARMING_4773, PatchImplementation.FLOWER),
			new FarmingPatch("", Varbits.FARMING_4774, PatchImplementation.HERB),
			new FarmingPatch("", Varbits.FARMING_4775, PatchImplementation.COMPOST)
		));

		add(new FarmingRegion("Brimhaven", 11058, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.FRUIT_TREE, NpcID.GARTH),
			new FarmingPatch("", Varbits.FARMING_4772, PatchImplementation.SPIRIT_TREE, NpcID.PRAISTAN_EBOLA)
		), 11057);

		add(new FarmingRegion("Catherby", 11062, false,
			new FarmingPatch("North", Varbits.FARMING_4771, PatchImplementation.ALLOTMENT, NpcID.DANTAERA),
			new FarmingPatch("South", Varbits.FARMING_4772, PatchImplementation.ALLOTMENT, NpcID.DANTAERA),
			new FarmingPatch("", Varbits.FARMING_4773, PatchImplementation.FLOWER),
			new FarmingPatch("", Varbits.FARMING_4774, PatchImplementation.HERB),
			new FarmingPatch("", Varbits.FARMING_4775, PatchImplementation.COMPOST)
		)
		{
			@Override
			public boolean isInBounds(WorldPoint loc)
			{
				if (loc.getX() >= 2816 && loc.getY() < 3456)
				{
					//Upstairs sends different varbits
					return loc.getX() < 2840 && loc.getY() >= 3440 && loc.getPlane() == 0;
				}
				return true;
			}
		}, 11061, 11318, 11317);
		add(new FarmingRegion("Catherby", 11317, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.FRUIT_TREE, NpcID.ELLENA)
		)
		{
			//The fruit tree patch is always sent when upstairs in 11317
			@Override
			public boolean isInBounds(WorldPoint loc)
			{
				return loc.getX() >= 2840 || loc.getY() < 3440 || loc.getPlane() == 1;
			}
		});

		add(new FarmingRegion("Champions' Guild", 12596, true,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.BUSH, NpcID.DREVEN)
		));

		add(new FarmingRegion("Draynor Manor", 12340, false,
			new FarmingPatch("Belladonna", Varbits.FARMING_4771, PatchImplementation.BELLADONNA)
		));

		add(new FarmingRegion("Entrana", 11060, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.HOPS, NpcID.FRANCIS)
		), 11316);

		add(new FarmingRegion("Etceteria", 10300, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.BUSH, NpcID.RHAZIEN),
			new FarmingPatch("", Varbits.FARMING_4772, PatchImplementation.SPIRIT_TREE, NpcID.YULF_SQUECKS)
		));

		add(new FarmingRegion("Falador", 11828, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.TREE, NpcID.HESKEL)
		), 12084);
		add(new FarmingRegion("Falador", 12083, false,
			new FarmingPatch("North West", Varbits.FARMING_4771, PatchImplementation.ALLOTMENT, NpcID.ELSTAN),
			new FarmingPatch("South East", Varbits.FARMING_4772, PatchImplementation.ALLOTMENT, NpcID.ELSTAN),
			new FarmingPatch("", Varbits.FARMING_4773, PatchImplementation.FLOWER),
			new FarmingPatch("", Varbits.FARMING_4774, PatchImplementation.HERB),
			new FarmingPatch("", Varbits.FARMING_4775, PatchImplementation.COMPOST)
		)
		{
			@Override
			public boolean isInBounds(WorldPoint loc)
			{
				//Not on region boundary due to Port Sarim Spirit Tree patch
				return loc.getY() >= 3272;
			}
		});

		add(new FarmingRegion("Fossil Island", 14651, false,
			new FarmingPatch("East", Varbits.FARMING_4771, PatchImplementation.HARDWOOD_TREE, NpcID.SQUIRREL_7754),
			new FarmingPatch("Middle", Varbits.FARMING_4772, PatchImplementation.HARDWOOD_TREE, NpcID.SQUIRREL_7755),
			new FarmingPatch("West", Varbits.FARMING_4773, PatchImplementation.HARDWOOD_TREE, NpcID.SQUIRREL_7756)
		)
		{
			@Override
			public boolean isInBounds(WorldPoint loc)
			{
				//Hardwood tree varbits are sent anywhere on plane 0 of fossil island.
				//Varbits get sent 1 tick earlier than expected when climbing certain ladders and stairs

				//Stairs to house on the hill
				if (loc.getX() == 3753 && loc.getY() >= 3868 && loc.getY() <= 3870)
				{
					return false;
				}

				//East and west ladders to rope bridge
				if ((loc.getX() == 3729 || loc.getX() == 3728 || loc.getX() == 3747 || loc.getX() == 3746)
					&& loc.getY() <= 3832 && loc.getY() >= 3830)
				{
					return false;
				}

				return loc.getPlane() == 0;
			}
		}, 14907, 14908, 15164, 14652, 14906, 14650, 15162, 15163);
		add(new FarmingRegion("Seaweed", 15008, false,
			new FarmingPatch("North", Varbits.FARMING_4771, PatchImplementation.SEAWEED, NpcID.MERNIA),
			new FarmingPatch("South", Varbits.FARMING_4772, PatchImplementation.SEAWEED, NpcID.MERNIA)
		));

		add(new FarmingRegion("Gnome Stronghold", 9781, true,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.TREE, NpcID.PRISSY_SCILLA),
			new FarmingPatch("", Varbits.FARMING_4772, PatchImplementation.FRUIT_TREE, NpcID.BOLONGO)
		), 9782, 9526, 9525);

		add(new FarmingRegion("Harmony", 15148, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.ALLOTMENT),
			new FarmingPatch("", Varbits.FARMING_4772, PatchImplementation.HERB)
		));

		add(new FarmingRegion("Kourend", 6967, false,
			new FarmingPatch("North East", Varbits.FARMING_4771, PatchImplementation.ALLOTMENT, NpcID.MARISI),
			new FarmingPatch("South West", Varbits.FARMING_4772, PatchImplementation.ALLOTMENT, NpcID.MARISI),
			new FarmingPatch("", Varbits.FARMING_4773, PatchImplementation.FLOWER),
			new FarmingPatch("", Varbits.FARMING_4774, PatchImplementation.HERB),
			new FarmingPatch("", Varbits.FARMING_4775, PatchImplementation.COMPOST),
			new FarmingPatch("", Varbits.FARMING_7904, PatchImplementation.SPIRIT_TREE, NpcID.LAMMY_LANGLE)
		), 6711);
		add(new FarmingRegion("Kourend", 7223, false,
			new FarmingPatch("East 1", Varbits.GRAPES_4953, PatchImplementation.GRAPES),
			new FarmingPatch("East 2", Varbits.GRAPES_4954, PatchImplementation.GRAPES),
			new FarmingPatch("East 3", Varbits.GRAPES_4955, PatchImplementation.GRAPES),
			new FarmingPatch("East 4", Varbits.GRAPES_4956, PatchImplementation.GRAPES),
			new FarmingPatch("East 5", Varbits.GRAPES_4957, PatchImplementation.GRAPES),
			new FarmingPatch("East 6", Varbits.GRAPES_4958, PatchImplementation.GRAPES),
			new FarmingPatch("West 1", Varbits.GRAPES_4959, PatchImplementation.GRAPES),
			new FarmingPatch("West 2", Varbits.GRAPES_4960, PatchImplementation.GRAPES),
			new FarmingPatch("West 3", Varbits.GRAPES_4961, PatchImplementation.GRAPES),
			new FarmingPatch("West 4", Varbits.GRAPES_4962, PatchImplementation.GRAPES),
			new FarmingPatch("West 5", Varbits.GRAPES_4963, PatchImplementation.GRAPES),
			new FarmingPatch("West 6", Varbits.GRAPES_4964, PatchImplementation.GRAPES)
		));

		add(new FarmingRegion("Lletya", 9265, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.FRUIT_TREE, NpcID.LILIWEN)
		), 11103);

		add(new FarmingRegion("Lumbridge", 12851, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.HOPS, NpcID.VASQUEN)
		));
		add(new FarmingRegion("Lumbridge", 12594, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.TREE, NpcID.FAYETH)
		), 12850);

		add(new FarmingRegion("Morytania", 13622, false,
			new FarmingPatch("Mushroom", Varbits.FARMING_4771, PatchImplementation.MUSHROOM)
		), 13878);
		add(new FarmingRegion("Morytania", 14391, false,
			new FarmingPatch("North West", Varbits.FARMING_4771, PatchImplementation.ALLOTMENT, NpcID.LYRA),
			new FarmingPatch("South East", Varbits.FARMING_4772, PatchImplementation.ALLOTMENT, NpcID.LYRA),
			new FarmingPatch("", Varbits.FARMING_4773, PatchImplementation.FLOWER),
			new FarmingPatch("", Varbits.FARMING_4774, PatchImplementation.HERB),
			new FarmingPatch("", Varbits.FARMING_4775, PatchImplementation.COMPOST)
		), 14390);

		add(new FarmingRegion("Port Sarim", 12082, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.SPIRIT_TREE, NpcID.FRIZZY_SKERNIP)
		)
		{
			@Override
			public boolean isInBounds(WorldPoint loc)
			{
				return loc.getY() < 3272;
			}
		}, 12083);

		add(new FarmingRegion("Rimmington", 11570, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.BUSH, NpcID.TARIA)
		), 11826);

		add(new FarmingRegion("Seers' Village", 10551, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.HOPS, NpcID.RHONEN)
		), 10550);

		add(new FarmingRegion("Tai Bwo Wannai", 11056, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.CALQUAT, NpcID.IMIAGO)
		));

		add(new FarmingRegion("Taverley", 11573, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.TREE, NpcID.ALAIN)
		), 11829);

		add(new FarmingRegion("Tree Gnome Village", 9777, true,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.FRUIT_TREE, NpcID.GILETH)
		), 10033);

		add(new FarmingRegion("Troll Stronghold", 11321, true,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.HERB)
		));

		add(new FarmingRegion("Varrock", 12854, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.TREE, NpcID.TREZNOR_11957)
		), 12853);

		add(new FarmingRegion("Yanille", 10288, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.HOPS, NpcID.SELENA)
		));

		add(new FarmingRegion("Weiss", 11325, false,
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.HERB)
		));

		add(new FarmingRegion("Farming Guild", 5021, true,
			new FarmingPatch("Hespori", Varbits.FARMING_7908, PatchImplementation.HESPORI)
		));

		//Full 3x3 region area centered on farming guild
		add(farmingGuildRegion = new FarmingRegion("Farming Guild", 4922, true,
			new FarmingPatch("", Varbits.FARMING_7905, PatchImplementation.TREE, NpcID.ROSIE),
			new FarmingPatch("", Varbits.FARMING_4775, PatchImplementation.HERB),
			new FarmingPatch("", Varbits.FARMING_4772, PatchImplementation.BUSH, NpcID.ALAN),
			new FarmingPatch("", Varbits.FARMING_7906, PatchImplementation.FLOWER),
			new FarmingPatch("North", Varbits.FARMING_4773, PatchImplementation.ALLOTMENT, NpcID.ALAN),
			new FarmingPatch("South", Varbits.FARMING_4774, PatchImplementation.ALLOTMENT, NpcID.ALAN),
			new FarmingPatch("", Varbits.FARMING_7912, PatchImplementation.BIG_COMPOST),
			new FarmingPatch("", Varbits.FARMING_7904, PatchImplementation.CACTUS, NpcID.ALAN),
			new FarmingPatch("", Varbits.FARMING_4771, PatchImplementation.SPIRIT_TREE, NpcID.LATLINK_FASTBELL),
			new FarmingPatch("", Varbits.FARMING_7909, PatchImplementation.FRUIT_TREE, NpcID.NIKKIE),
			new FarmingPatch("Anima", Varbits.FARMING_7911, PatchImplementation.ANIMA),
			new FarmingPatch("", Varbits.FARMING_7910, PatchImplementation.CELASTRUS, NpcID.TAYLOR),
			new FarmingPatch("", Varbits.FARMING_7907, PatchImplementation.REDWOOD, NpcID.ALEXANDRA)
		), 5177, 5178, 5179, 4921, 4923, 4665, 4666, 4667);

		//All of Prifddinas, and all of Prifddinas Underground
		add(new FarmingRegion("Prifddinas", 13151, false,
				new FarmingPatch("North", Varbits.FARMING_4771, PatchImplementation.ALLOTMENT, NpcID.OSWALLT),
				new FarmingPatch("South", Varbits.FARMING_4772, PatchImplementation.ALLOTMENT, NpcID.OSWALLT),
				new FarmingPatch("", Varbits.FARMING_4773, PatchImplementation.FLOWER),
				new FarmingPatch("", Varbits.FARMING_4775, PatchImplementation.CRYSTAL_TREE),
				new FarmingPatch("", Varbits.FARMING_4774, PatchImplementation.COMPOST) // TODO: Find correct varbit
			), 12895, 12894, 13150,
			/* Underground */ 12994, 12993, 12737, 12738, 12126, 12127, 13250);

		// Finalize
		this.regions = Multimaps.unmodifiableMultimap(this.regions);
		Map<Tab, Set<FarmingPatch>> umtabs = new TreeMap<>();
		for (Map.Entry<Tab, Set<FarmingPatch>> e : tabs.entrySet())
		{
			umtabs.put(e.getKey(), Collections.unmodifiableSet(e.getValue()));
		}
		this.tabs = Collections.unmodifiableMap(umtabs);
	}

	private void add(FarmingRegion r, int... extraRegions)
	{
		regions.put(r.getRegionID(), r);
		for (int er : extraRegions)
		{
			regions.put(er, r);
		}
		for (FarmingPatch p : r.getPatches())
		{
			tabs
				.computeIfAbsent(p.getImplementation().getTab(), k -> new TreeSet<>(tabSorter))
				.add(p);
		}
	}

	Collection<FarmingRegion> getRegionsForLocation(WorldPoint location)
	{
		return this.regions.get(location.getRegionID()).stream()
			.filter(region -> region.isInBounds(location))
			.collect(Collectors.toSet());
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2020 Morgan Lewis
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.timetracking.TabContentPanel;
import net.runelite.client.plugins.timetracking.TimeTrackingConfig;
import net.runelite.client.plugins.timetracking.TimeablePanel;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

public class FarmingNextTickPanel extends TabContentPanel
{
	private final FarmingTracker farmingTracker;
	private final TimeTrackingConfig config;
	private final ConfigManager configManager;
	private final List<TimeablePanel<Void>> patchPanels;
	private final JTextArea infoTextArea;

	public FarmingNextTickPanel(
		FarmingTracker farmingTracker,
		TimeTrackingConfig config,
		ConfigManager configManager
	)
	{
		this.farmingTracker = farmingTracker;
		this.config = config;
		this.configManager = configManager;
		this.patchPanels = new ArrayList<>();

		setLayout(new GridBagLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.weightx = 1;
		c.gridx = 0;
		c.gridy = 0;

		int[] times = {5, 10, 20, 40, 80, 160, 320, 640};

		for (int time : times)
		{
			TimeablePanel<Void> panel = new TimeablePanel<>(null, time + " minute tick", time);
			patchPanels.add(panel);
			add(panel, c);
			c.gridy++;
		}

		infoTextArea = new JTextArea();
		add(infoTextArea, c);
		c.gridy++;
	}

	@Override
	public int getUpdateInterval()
	{
		return 50;
	}

	@Override
	public void update()
	{
		long unixNow = Instant.now().getEpochSecond();

		for (TimeablePanel<Void> panel : patchPanels)
		{
			int tickLength = panel.getProgress().getMaximumValue();
			long nextTick = farmingTracker.getTickTime(tickLength, 1);
			panel.getEstimate().setText(getFormattedEstimate(nextTick - unixNow, config.timeFormatMode()));
		}

		String offsetPrecisionMins = configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, TimeTrackingConfig.FARM_TICK_OFFSET_PRECISION);
		String offsetTimeMins = configManager.getRSProfileConfiguration(TimeTrackingConfig.CONFIG_GROUP, TimeTrackingConfig.FARM_TICK_OFFSET);

		infoTextArea.setText("Offset precision:" + offsetPrecisionMins + "\nFarming tick offset: -" + offsetTimeMins);
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class FarmingRegion
{
	private final String name;
	private final int regionID;
	private final boolean definite;
	private final FarmingPatch[] patches;

	public FarmingRegion(String name, int regionID, boolean definite, FarmingPatch... patches)
	{
		this.name = name;
		this.regionID = regionID;
		this.definite = definite;
		this.patches = patches;
		for (FarmingPatch p : patches)
		{
			p.setRegion(this);
		}
	}

	public boolean isInBounds(WorldPoint loc)
	{
		return true;
	}

	@Override
	public String toString()
	{
		return name;
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Value;

@Value
class PatchState
{
	private final Produce produce;
	private final CropState cropState;
	private final int stage;

	int getStages()
	{
		return cropState == CropState.HARVESTABLE || cropState == CropState.FILLING ? produce.getHarvestStages() : produce.getStages();
	}

	int getTickRate()
	{
		switch (cropState)
		{
			case HARVESTABLE:
				return produce.getRegrowTickrate();
			case GROWING:
				return produce.getTickrate();
			default:
				return 0;
		}
	}
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2019 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import javax.annotation.Nullable;

@RequiredArgsConstructor
@Getter
public enum PatchImplementation
{
	BELLADONNA(Tab.BELLADONNA, "", false)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Belladonna patch[Rake,Inspect,Guide] 7560,7559,7558,7557
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Belladonna[Inspect,Guide] 7561,7562,7563,7564
					return new PatchState(Produce.BELLADONNA, CropState.GROWING, value - 4);
				}
				if (value == 8)
				{
					// Belladonna[Pick,Inspect,Guide] 7565
					return new PatchState(Produce.BELLADONNA, CropState.HARVESTABLE, 0);
				}
				if (value >= 9 && value <= 11)
				{
					// Diseased Belladonna[Cure,Inspect,Guide] 7566,7567,7568
					return new PatchState(Produce.BELLADONNA, CropState.DISEASED, value - 8);
				}
				if (value >= 12 && value <= 14)
				{
					// Dead Belladonna[Clear,Inspect,Guide] 7569,7570,7571
					return new PatchState(Produce.BELLADONNA, CropState.DEAD, value - 11);
				}
				if (value >= 15 && value <= 255)
				{
					// Belladonna patch[Rake,Inspect,Guide] 7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560,7560
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	MUSHROOM(Tab.MUSHROOM, "", false)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Mushroom patch[Rake,Inspect,Guide] 8314,8313,8312,8311
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 9)
				{
					// Bittercap Mushrooms[Inspect,Guide] 8315,8316,8317,8318,8319,8320
					return new PatchState(Produce.MUSHROOM, CropState.GROWING, value - 4);
				}
				if (value >= 10 && value <= 15)
				{
					// Bittercap Mushrooms[Pick,Inspect,Guide] 8321,8322,8323,8324,8325,8326
					return new PatchState(Produce.MUSHROOM, CropState.HARVESTABLE, value - 10);
				}
				if (value >= 16 && value <= 20)
				{
					// Diseased Bittercap Mushrooms[Cure,Inspect,Guide] 8327,8328,8329,8330,8331
					return new PatchState(Produce.MUSHROOM, CropState.DISEASED, value - 15);
				}
				if (value >= 21 && value <= 25)
				{
					// Dead Bittercap Mushrooms[Clear,Inspect,Guide] 8332,8333,8334,8335,8336
					return new PatchState(Produce.MUSHROOM, CropState.DEAD, value - 20);
				}
				if (value >= 26 && value <= 255)
				{
					// Mushroom patch[Rake,Inspect,Guide] 8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314,8314
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	HESPORI(Tab.HESPORI, "", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Hespori patch[Rake,Inspect,Guide] 33722,33723,33724,33725
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 6)
				{
					// Hespori[Inspect,Guide] 33726,33727,33728
					return new PatchState(Produce.HESPORI, CropState.GROWING, value - 4);
				}
				if (value >= 7 && value <= 8)
				{
					// Hespori[Harvest,Inspect,Guide,Clear] 33729,33730
					return new PatchState(Produce.HESPORI, CropState.HARVESTABLE, value - 7);
				}
				if (value == 9)
				{
					// Hespori patch[Rake,Inspect,Guide] 33722
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	ALLOTMENT(Tab.ALLOTMENT, "", false)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8575,8574,8573
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 5)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 6 && value <= 9)
				{
					// Potato seed,Potato plant[Inspect,Guide] 8558,8559,8560,8561
					return new PatchState(Produce.POTATO, CropState.GROWING, value - 6);
				}
				if (value >= 10 && value <= 12)
				{
					// Potato[Harvest,Inspect,Guide] 8562,8562,8562
					return new PatchState(Produce.POTATO, CropState.HARVESTABLE, value - 10);
				}
				if (value >= 13 && value <= 16)
				{
					// Onion seeds,Onion plant[Inspect,Guide] 8580,8581,8582,8583
					return new PatchState(Produce.ONION, CropState.GROWING, value - 13);
				}
				if (value >= 17 && value <= 19)
				{
					// Onion[Harvest,Inspect,Guide] 8584,8584,8584
					return new PatchState(Produce.ONION, CropState.HARVESTABLE, value - 17);
				}
				if (value >= 20 && value <= 23)
				{
					// Cabbages[Inspect,Guide] 8535,8536,8537,8538
					return new PatchState(Produce.CABBAGE, CropState.GROWING, value - 20);
				}
				if (value >= 24 && value <= 26)
				{
					// Cabbages[Harvest,Inspect,Guide] 8539,8539,8539
					return new PatchState(Produce.CABBAGE, CropState.HARVESTABLE, value - 24);
				}
				if (value >= 27 && value <= 30)
				{
					// Tomato plant[Inspect,Guide] 8641,8642,8643,8644
					return new PatchState(Produce.TOMATO, CropState.GROWING, value - 27);
				}
				if (value >= 31 && value <= 33)
				{
					// Tomato[Harvest,Inspect,Guide] 8645,8645,8645
					return new PatchState(Produce.TOMATO, CropState.HARVESTABLE, value - 31);
				}
				if (value >= 34 && value <= 39)
				{
					// Sweetcorn seed,Sweetcorn plant[Inspect,Guide] 8618,8619,8620,8621,8622,8623
					return new PatchState(Produce.SWEETCORN, CropState.GROWING, value - 34);
				}
				if (value >= 40 && value <= 42)
				{
					// Sweetcorn[Harvest,Inspect,Guide] 8624,8624,8624
					return new PatchState(Produce.SWEETCORN, CropState.HARVESTABLE, value - 40);
				}
				if (value >= 43 && value <= 48)
				{
					// Strawberry seed,Strawberry plant[Inspect,Guide] 8595,8596,8597,8598,8599,8600
					return new PatchState(Produce.STRAWBERRY, CropState.GROWING, value - 43);
				}
				if (value >= 49 && value <= 51)
				{
					// Strawberry[Harvest,Inspect,Guide] 8601,8601,8601
					return new PatchState(Produce.STRAWBERRY, CropState.HARVESTABLE, value - 49);
				}
				if (value >= 52 && value <= 59)
				{
					// Watermelon seed,Watermelons[Inspect,Guide] 8656,8657,8658,8659,8660,8661,8662,8663
					return new PatchState(Produce.WATERMELON, CropState.GROWING, value - 52);
				}
				if (value >= 60 && value <= 62)
				{
					// Watermelon[Harvest,Inspect,Guide] 8664,8664,8664
					return new PatchState(Produce.WATERMELON, CropState.HARVESTABLE, value - 60);
				}
				if (value >= 63 && value <= 69)
				{
					// Snape grass seedling,Snape grass plant[Inspect,Guide] 33674,33675,33676,33677,33678,33679,33680
					return new PatchState(Produce.SNAPE_GRASS, CropState.GROWING, value - 63);
				}
				if (value >= 70 && value <= 73)
				{
					// Potato seed,Potato plant[Inspect,Guide] 8563,8564,8565,8566
					return new PatchState(Produce.POTATO, CropState.GROWING, value - 70);
				}
				if (value >= 74 && value <= 76)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 77 && value <= 80)
				{
					// Onion seeds,Onion plant[Inspect,Guide] 8585,8586,8587,8588
					return new PatchState(Produce.ONION, CropState.GROWING, value - 77);
				}
				if (value >= 81 && value <= 83)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 84 && value <= 87)
				{
					// Cabbages[Inspect,Guide] 8540,8541,8542,8543
					return new PatchState(Produce.CABBAGE, CropState.GROWING, value - 84);
				}
				if (value >= 88 && value <= 90)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 91 && value <= 94)
				{
					// Tomato plant[Inspect,Guide] 8646,8647,8648,8649
					return new PatchState(Produce.TOMATO, CropState.GROWING, value - 91);
				}
				if (value >= 95 && value <= 97)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 98 && value <= 103)
				{
					// Sweetcorn seed,Sweetcorn plant[Inspect,Guide] 8625,8626,8627,8628,8629,8630
					return new PatchState(Produce.SWEETCORN, CropState.GROWING, value - 98);
				}
				if (value >= 104 && value <= 106)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 107 && value <= 112)
				{
					// Strawberry seed,Strawberry plant[Inspect,Guide] 8602,8603,8604,8605,8606,8607
					return new PatchState(Produce.STRAWBERRY, CropState.GROWING, value - 107);
				}
				if (value >= 113 && value <= 115)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 116 && value <= 123)
				{
					// Watermelon seed,Watermelons[Inspect,Guide] 8665,8666,8667,8668,8669,8670,8671,8672
					return new PatchState(Produce.WATERMELON, CropState.GROWING, value - 116);
				}
				if (value >= 124 && value <= 127)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 128 && value <= 134)
				{
					// Snape grass seedling,Snape grass plant[Inspect,Guide] 33666,33667,33668,33669,33670,33671,33672
					return new PatchState(Produce.SNAPE_GRASS, CropState.GROWING, value - 128);
				}
				if (value >= 135 && value <= 137)
				{
					// Diseased potatoes[Cure,Inspect,Guide] 8567,8568,8569
					return new PatchState(Produce.POTATO, CropState.DISEASED, value - 134);
				}
				if (value >= 138 && value <= 140)
				{
					// Snape grass plant[Harvest,Inspect,Guide] 33673,33673,33673
					return new PatchState(Produce.SNAPE_GRASS, CropState.HARVESTABLE, value - 138);
				}
				if (value == 141)
				{
					// Allotment[Rake,Inspect,Guide] 8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 142 && value <= 144)
				{
					// Diseased onions[Cure,Inspect,Guide] 8589,8590,8591
					return new PatchState(Produce.ONION, CropState.DISEASED, value - 141);
				}
				if (value >= 145 && value <= 148)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 149 && value <= 151)
				{
					// Diseased cabbages[Cure,Inspect,Guide] 8544,8545,8546
					return new PatchState(Produce.CABBAGE, CropState.DISEASED, value - 148);
				}
				if (value >= 152 && value <= 155)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 156 && value <= 158)
				{
					// Diseased tomato plant[Cure,Inspect,Guide] 8650,8651,8652
					return new PatchState(Produce.TOMATO, CropState.DISEASED, value - 155);
				}
				if (value >= 159 && value <= 162)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 163 && value <= 167)
				{
					// Diseased sweetcorn plant[Cure,Inspect,Guide] 8631,8632,8633,8634,8635
					return new PatchState(Produce.SWEETCORN, CropState.DISEASED, value - 162);
				}
				if (value >= 168 && value <= 171)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 172 && value <= 176)
				{
					// Diseased strawberry plant[Cure,Inspect,Guide] 8608,8609,8610,8611,8612
					return new PatchState(Produce.STRAWBERRY, CropState.DISEASED, value - 171);
				}
				if (value >= 177 && value <= 180)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 181 && value <= 187)
				{
					// Diseased watermelons[Cure,Inspect,Guide] 8673,8674,8675,8676,8677,8678,8679
					return new PatchState(Produce.WATERMELON, CropState.DISEASED, value - 180);
				}
				if (value >= 188 && value <= 192)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 193 && value <= 195)
				{
					// Dead Snape grass[Clear,Inspect,Guide] 33687,33688,33689
					return new PatchState(Produce.SNAPE_GRASS, CropState.DEAD, value - 192);
				}
				if (value >= 196 && value <= 198)
				{
					// Diseased Snape grass[Cure,Inspect,Guide] 33681,33682,33683
					return new PatchState(Produce.SNAPE_GRASS, CropState.DISEASED, value - 195);
				}
				if (value >= 199 && value <= 201)
				{
					// Dead potatoes[Clear,Inspect,Guide] 8570,8571,8572
					return new PatchState(Produce.POTATO, CropState.DEAD, value - 198);
				}
				if (value >= 202 && value <= 204)
				{
					// Diseased Snape grass[Cure,Inspect,Guide] 33684,33685,33686
					return new PatchState(Produce.SNAPE_GRASS, CropState.DISEASED, 3 + value - 201);
				}
				if (value == 205)
				{
					// Allotment[Rake,Inspect,Guide] 8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 206 && value <= 208)
				{
					// Dead onions[Clear,Inspect,Guide] 8592,8593,8594
					return new PatchState(Produce.ONION, CropState.DEAD, value - 205);
				}
				if (value >= 209 && value <= 211)
				{
					// Dead Snape grass[Clear,Inspect,Guide] 33690,33691,33692
					return new PatchState(Produce.SNAPE_GRASS, CropState.DEAD, 3 + value - 208);
				}
				if (value == 212)
				{
					// Allotment[Rake,Inspect,Guide] 8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 213 && value <= 215)
				{
					// Dead cabbages[Clear,Inspect,Guide] 8547,8548,8549
					return new PatchState(Produce.CABBAGE, CropState.DEAD, value - 212);
				}
				if (value >= 216 && value <= 219)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 220 && value <= 222)
				{
					// Dead tomato plant[Clear,Inspect,Guide] 8653,8654,8655
					return new PatchState(Produce.TOMATO, CropState.DEAD, value - 219);
				}
				if (value >= 223 && value <= 226)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 227 && value <= 231)
				{
					// Dead sweetcorn plant[Clear,Inspect,Guide] 8636,8637,8638,8639,8640
					return new PatchState(Produce.SWEETCORN, CropState.DEAD, value - 226);
				}
				if (value >= 232 && value <= 235)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 236 && value <= 240)
				{
					// Dead strawberry plant[Clear,Inspect,Guide] 8613,8614,8615,8616,8617
					return new PatchState(Produce.STRAWBERRY, CropState.DEAD, value - 235);
				}
				if (value >= 241 && value <= 244)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 245 && value <= 251)
				{
					// Dead watermelons[Clear,Inspect,Guide] 8680,8681,8682,8683,8684,8685,8686
					return new PatchState(Produce.WATERMELON, CropState.DEAD, value - 244);
				}
				if (value >= 252 && value <= 255)
				{
					// Allotment[Rake,Inspect,Guide] 8576,8576,8576,8576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	HERB(Tab.HERB, "", false)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Herb patch[Rake,Inspect,Guide] 8135,8134,8133,8132
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.GUAM, CropState.GROWING, value - 4);
				}
				if (value >= 8 && value <= 10)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.GUAM, CropState.HARVESTABLE, 10 - value);
				}
				if (value >= 11 && value <= 14)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.MARRENTILL, CropState.GROWING, value - 11);
				}
				if (value >= 15 && value <= 17)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.MARRENTILL, CropState.HARVESTABLE, 17 - value);
				}
				if (value >= 18 && value <= 21)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.TARROMIN, CropState.GROWING, value - 18);
				}
				if (value >= 22 && value <= 24)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.TARROMIN, CropState.HARVESTABLE, 24 - value);
				}
				if (value >= 25 && value <= 28)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.HARRALANDER, CropState.GROWING, value - 25);
				}
				if (value >= 29 && value <= 31)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.HARRALANDER, CropState.HARVESTABLE, 31 - value);
				}
				if (value >= 32 && value <= 35)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.RANARR, CropState.GROWING, value - 32);
				}
				if (value >= 36 && value <= 38)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.RANARR, CropState.HARVESTABLE, 38 - value);
				}
				if (value >= 39 && value <= 42)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.TOADFLAX, CropState.GROWING, value - 39);
				}
				if (value >= 43 && value <= 45)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.TOADFLAX, CropState.HARVESTABLE, 45 - value);
				}
				if (value >= 46 && value <= 49)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.IRIT, CropState.GROWING, value - 46);
				}
				if (value >= 50 && value <= 52)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.IRIT, CropState.HARVESTABLE, 52 - value);
				}
				if (value >= 53 && value <= 56)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.AVANTOE, CropState.GROWING, value - 53);
				}
				if (value >= 57 && value <= 59)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.AVANTOE, CropState.HARVESTABLE, 59 - value);
				}
				if (value >= 60 && value <= 67)
				{
					// Herb patch[Rake,Inspect,Guide] 8135,8135,8135,8135,8135,8135,8135,8135
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 68 && value <= 71)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.KWUARM, CropState.GROWING, value - 68);
				}
				if (value >= 72 && value <= 74)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.KWUARM, CropState.HARVESTABLE, 74 - value);
				}
				if (value >= 75 && value <= 78)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.SNAPDRAGON, CropState.GROWING, value - 75);
				}
				if (value >= 79 && value <= 81)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.SNAPDRAGON, CropState.HARVESTABLE, 81 - value);
				}
				if (value >= 82 && value <= 85)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.CADANTINE, CropState.GROWING, value - 82);
				}
				if (value >= 86 && value <= 88)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.CADANTINE, CropState.HARVESTABLE, 88 - value);
				}
				if (value >= 89 && value <= 92)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.LANTADYME, CropState.GROWING, value - 89);
				}
				if (value >= 93 && value <= 95)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.LANTADYME, CropState.HARVESTABLE, 95 - value);
				}
				if (value >= 96 && value <= 99)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.DWARF_WEED, CropState.GROWING, value - 96);
				}
				if (value >= 100 && value <= 102)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.DWARF_WEED, CropState.HARVESTABLE, 102 - value);
				}
				if (value >= 103 && value <= 106)
				{
					// Herbs[Inspect,Guide] 8139,8140,8141,8142
					return new PatchState(Produce.TORSTOL, CropState.GROWING, value - 103);
				}
				if (value >= 107 && value <= 109)
				{
					// Herbs[Pick,Inspect,Guide] 8143,8143,8143
					return new PatchState(Produce.TORSTOL, CropState.HARVESTABLE, 109 - value);
				}
				if (value >= 128 && value <= 130)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.GUAM, CropState.DISEASED, value - 127);
				}
				if (value >= 131 && value <= 133)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.MARRENTILL, CropState.DISEASED, value - 130);
				}
				if (value >= 134 && value <= 136)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.TARROMIN, CropState.DISEASED, value - 133);
				}
				if (value >= 137 && value <= 139)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.HARRALANDER, CropState.DISEASED, value - 136);
				}
				if (value >= 140 && value <= 142)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.RANARR, CropState.DISEASED, value - 139);
				}
				if (value >= 143 && value <= 145)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.TOADFLAX, CropState.DISEASED, value - 142);
				}
				if (value >= 146 && value <= 148)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.IRIT, CropState.DISEASED, value - 145);
				}
				if (value >= 149 && value <= 151)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.AVANTOE, CropState.DISEASED, value - 148);
				}
				if (value >= 152 && value <= 154)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.KWUARM, CropState.DISEASED, value - 151);
				}
				if (value >= 155 && value <= 157)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.SNAPDRAGON, CropState.DISEASED, value - 154);
				}
				if (value >= 158 && value <= 160)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.CADANTINE, CropState.DISEASED, value - 157);
				}
				if (value >= 161 && value <= 163)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.LANTADYME, CropState.DISEASED, value - 160);
				}
				if (value >= 164 && value <= 166)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.DWARF_WEED, CropState.DISEASED, value - 163);
				}
				if (value >= 167 && value <= 169)
				{
					// Diseased herbs[Cure,Inspect,Guide] 8144,8145,8146
					return new PatchState(Produce.TORSTOL, CropState.DISEASED, value - 166);
				}
				if (value >= 170 && value <= 172)
				{
					// Dead herbs[Clear,Inspect,Guide] 8147,8148,8149
					return new PatchState(Produce.ANYHERB, CropState.DEAD, value - 169);
				}
				if (value >= 173 && value <= 191)
				{
					// Herb patch[Rake,Inspect,Guide] 8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 192 && value <= 195)
				{
					// Goutweed[Inspect,Guide] 9044,9045,9046,9047
					return new PatchState(Produce.GOUTWEED, CropState.GROWING, value - 192);
				}
				if (value >= 196 && value <= 197)
				{
					// Goutweed[Pick,Inspect,Guide] 9048,9048
					return new PatchState(Produce.GOUTWEED, CropState.HARVESTABLE, 197 - value);
				}
				if (value >= 198 && value <= 200)
				{
					// Diseased goutweed[Cure,Inspect,Guide] 9049,9050,9051
					return new PatchState(Produce.GOUTWEED, CropState.DISEASED, value - 197);
				}
				if (value >= 201 && value <= 203)
				{
					// Dead goutweed[Clear,Inspect,Guide] 9052,9053,9054
					return new PatchState(Produce.GOUTWEED, CropState.DEAD, value - 200);
				}
				if (value >= 204 && value <= 219)
				{
					// Herb patch[Rake,Inspect,Guide] 8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 221 && value <= 255)
				{
					// Herb patch[Rake,Inspect,Guide] 8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135,8135
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	FLOWER(Tab.FLOWER, "", false)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7842,7841,7840
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843,7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 11)
				{
					// Marigold[Inspect,Guide] 7867,7868,7869,7870
					return new PatchState(Produce.MARIGOLD, CropState.GROWING, value - 8);
				}
				if (value == 12)
				{
					// Marigold[Pick,Inspect,Guide] 7871
					return new PatchState(Produce.MARIGOLD, CropState.HARVESTABLE, 0);
				}
				if (value >= 13 && value <= 16)
				{
					// Rosemary[Inspect,Guide] 7899,7900,7901,7902
					return new PatchState(Produce.ROSEMARY, CropState.GROWING, value - 13);
				}
				if (value == 17)
				{
					// Rosemary[Pick,Inspect,Guide] 7903
					return new PatchState(Produce.ROSEMARY, CropState.HARVESTABLE, 0);
				}
				if (value >= 18 && value <= 21)
				{
					// Nasturtium[Inspect,Guide] 7883,7884,7885,7886
					return new PatchState(Produce.NASTURTIUM, CropState.GROWING, value - 18);
				}
				if (value == 22)
				{
					// Nasturtium[Pick,Inspect,Guide] 7887
					return new PatchState(Produce.NASTURTIUM, CropState.HARVESTABLE, 0);
				}
				if (value >= 23 && value <= 26)
				{
					// Woad plant[Inspect,Guide] 7919,7920,7921,7922
					return new PatchState(Produce.WOAD, CropState.GROWING, value - 23);
				}
				if (value == 27)
				{
					// Woad plant[Pick,Inspect,Guide] 7923
					return new PatchState(Produce.WOAD, CropState.HARVESTABLE, 0);
				}
				if (value >= 28 && value <= 31)
				{
					// Limpwurt plant[Inspect,Guide] 7851,7852,7853,7854
					return new PatchState(Produce.LIMPWURT, CropState.GROWING, value - 28);
				}
				if (value == 32)
				{
					// Limpwurt plant[Pick,Inspect,Guide] 7855
					return new PatchState(Produce.LIMPWURT, CropState.HARVESTABLE, 0);
				}
				if (value >= 33 && value <= 35)
				{
					// Scarecrow[Rake,Inspect,Guide,Remove] 7918,7917,7916
					return new PatchState(Produce.SCARECROW, CropState.GROWING, 35 - value);
				}
				if (value == 36)
				{
					// Scarecrow[Remove,Inspect,Guide] 7915
					return new PatchState(Produce.SCARECROW, CropState.GROWING, 0);
				}
				if (value >= 37 && value <= 40)
				{
					// White lily[Inspect,Guide] 33650,33651,33652,33653
					return new PatchState(Produce.WHITE_LILY, CropState.GROWING, value - 37);
				}
				if (value == 41)
				{
					// White lily[Pick,Inspect,Guide] 33654
					return new PatchState(Produce.WHITE_LILY, CropState.HARVESTABLE, 0);
				}
				if (value >= 42 && value <= 71)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 72 && value <= 75)
				{
					// Marigold[Inspect,Guide] 7872,7873,7874,7875
					return new PatchState(Produce.MARIGOLD, CropState.GROWING, value - 72);
				}
				if (value == 76)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 77 && value <= 80)
				{
					// Rosemary[Inspect,Guide] 7904,7905,7906,7907
					return new PatchState(Produce.ROSEMARY, CropState.GROWING, value - 77);
				}
				if (value == 81)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 82 && value <= 85)
				{
					// Nasturtium[Inspect,Guide] 7888,7889,7890,7891
					return new PatchState(Produce.NASTURTIUM, CropState.GROWING, value - 82);
				}
				if (value == 86)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 87 && value <= 90)
				{
					// Woad plant[Inspect,Guide] 7924,7925,7926,7927
					return new PatchState(Produce.WOAD, CropState.GROWING, value - 87);
				}
				if (value == 91)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 92 && value <= 95)
				{
					// Limpwurt plant[Inspect,Guide] 7856,7857,7858,7859
					return new PatchState(Produce.LIMPWURT, CropState.GROWING, value - 92);
				}
				if (value >= 96 && value <= 100)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843,7843,7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 101 && value <= 104)
				{
					// White lily[Inspect,Guide] 33655,33656,33657,33658
					return new PatchState(Produce.WHITE_LILY, CropState.GROWING, value - 101);
				}
				if (value >= 105 && value <= 136)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 137 && value <= 139)
				{
					// Diseased marigold[Cure,Inspect,Guide] 7876,7877,7878
					return new PatchState(Produce.MARIGOLD, CropState.DISEASED, value - 136);
				}
				if (value >= 140 && value <= 141)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 142 && value <= 144)
				{
					// Diseased rosemary[Cure,Inspect,Guide] 7908,7909,7910
					return new PatchState(Produce.ROSEMARY, CropState.DISEASED, value - 141);
				}
				if (value >= 145 && value <= 146)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 147 && value <= 149)
				{
					// Diseased nasturtium[Cure,Inspect,Guide] 7892,7893,7894
					return new PatchState(Produce.NASTURTIUM, CropState.DISEASED, value - 146);
				}
				if (value >= 150 && value <= 151)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 152 && value <= 154)
				{
					// Diseased woad plant[Cure,Inspect,Guide] 7928,7929,7930
					return new PatchState(Produce.WOAD, CropState.DISEASED, value - 151);
				}
				if (value >= 155 && value <= 156)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 157 && value <= 159)
				{
					// Diseased limpwurt plant[Cure,Inspect,Guide] 7860,7861,7862
					return new PatchState(Produce.LIMPWURT, CropState.DISEASED, value - 156);
				}
				if (value >= 160 && value <= 165)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843,7843,7843,7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 166 && value <= 168)
				{
					// Diseased White lily[Cure,Inspect,Guide] 33659,33660,33661
					return new PatchState(Produce.WHITE_LILY, CropState.DISEASED, value - 165);
				}
				if (value >= 169 && value <= 200)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 201 && value <= 204)
				{
					// Dead marigold[Clear,Inspect,Guide] 7879,7880,7881,7882
					return new PatchState(Produce.MARIGOLD, CropState.DEAD, value - 200);
				}
				if (value == 205)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 206 && value <= 209)
				{
					// Dead rosemary[Clear,Inspect,Guide] 7911,7912,7913,7914
					return new PatchState(Produce.ROSEMARY, CropState.DEAD, value - 205);
				}
				if (value == 210)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 211 && value <= 214)
				{
					// Dead nasturtium[Clear,Inspect,Guide] 7895,7896,7897,7898
					return new PatchState(Produce.NASTURTIUM, CropState.DEAD, value - 210);
				}
				if (value == 215)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 216 && value <= 219)
				{
					// Dead woad plant[Clear,Inspect,Guide] 7931,7932,7933,7934
					return new PatchState(Produce.WOAD, CropState.DEAD, value - 215);
				}
				if (value == 220)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 221 && value <= 224)
				{
					// Dead limpwurt plant[Clear,Inspect,Guide] 7863,7864,7865,7866
					return new PatchState(Produce.LIMPWURT, CropState.DEAD, value - 220);
				}
				if (value >= 225 && value <= 229)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843,7843,7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 230 && value <= 233)
				{
					// Dead White lily[Clear,Inspect,Guide] 33662,33663,33664,33665
					return new PatchState(Produce.WHITE_LILY, CropState.DEAD, value - 229);
				}
				if (value >= 234 && value <= 255)
				{
					// Flower Patch[Rake,Inspect,Guide] 7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843,7843
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	BUSH(Tab.BUSH, "", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7575,7574,7573
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value == 4)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 5 && value <= 9)
				{
					// Redberry bush[Inspect,Guide] 7692,7693,7694,7695,7696
					return new PatchState(Produce.REDBERRIES, CropState.GROWING, value - 5);
				}
				if (value >= 10 && value <= 14)
				{
					// Redberry bush[Clear,Inspect,Guide,Pick-from] 7697,7701,7701,7701,7701
					return new PatchState(Produce.REDBERRIES, CropState.HARVESTABLE, value - 10);
				}
				if (value >= 15 && value <= 20)
				{
					// Cadavaberry bush[Inspect,Guide] 7581,7582,7583,7584,7585,7586
					return new PatchState(Produce.CADAVABERRIES, CropState.GROWING, value - 15);
				}
				if (value >= 21 && value <= 25)
				{
					// Cadavaberry bush[Clear,Inspect,Guide,Pick-from] 7587,7591,7591,7591,7591
					return new PatchState(Produce.CADAVABERRIES, CropState.HARVESTABLE, value - 21);
				}
				if (value >= 26 && value <= 32)
				{
					// Dwellberry bush[Inspect,Guide] 7605,7606,7607,7608,7609,7610,7611
					return new PatchState(Produce.DWELLBERRIES, CropState.GROWING, value - 26);
				}
				if (value >= 33 && value <= 37)
				{
					// Dwellberry bush[Clear,Inspect,Guide,Pick-from] 7612,7616,7616,7616,7616
					return new PatchState(Produce.DWELLBERRIES, CropState.HARVESTABLE, value - 33);
				}
				if (value >= 38 && value <= 45)
				{
					// Jangerberry bush[Inspect,Guide] 7632,7633,7634,7635,7636,7637,7638,7639
					return new PatchState(Produce.JANGERBERRIES, CropState.GROWING, value - 38);
				}
				if (value >= 46 && value <= 50)
				{
					// Jangerberry bush[Clear,Inspect,Guide,Pick-from] 7640,7644,7644,7644,7644
					return new PatchState(Produce.JANGERBERRIES, CropState.HARVESTABLE, value - 46);
				}
				if (value >= 51 && value <= 58)
				{
					// Whiteberry bush[Inspect,Guide] 7713,7714,7715,7716,7717,7718,7719,7720
					return new PatchState(Produce.WHITEBERRIES, CropState.GROWING, value - 51);
				}
				if (value >= 59 && value <= 63)
				{
					// Whiteberry bush[Clear,Inspect,Guide,Pick-from] 7721,7725,7725,7725,7725
					return new PatchState(Produce.WHITEBERRIES, CropState.HARVESTABLE, value - 59);
				}
				if (value >= 64 && value <= 69)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 70 && value <= 74)
				{
					// Diseased redberry bush[Prune,Inspect,Guide] 7703,7704,7705,7706,7707
					return new PatchState(Produce.REDBERRIES, CropState.DISEASED, value - 69);
				}
				if (value >= 75 && value <= 79)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 80 && value <= 85)
				{
					// Diseased cadavaberry bush[Prune,Inspect,Guide] 7593,7594,7595,7596,7597,7598
					return new PatchState(Produce.CADAVABERRIES, CropState.DISEASED, value - 79);
				}
				if (value >= 86 && value <= 90)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 91 && value <= 97)
				{
					// Diseased dwellberry bush[Prune,Inspect,Guide] 7618,7619,7620,7621,7622,7623,7624
					return new PatchState(Produce.DWELLBERRIES, CropState.DISEASED, value - 90);
				}
				if (value >= 98 && value <= 102)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 103 && value <= 110)
				{
					// Diseased jangerberry bush[Prune,Inspect,Guide] 7646,7647,7648,7649,7650,7651,7652,7653
					return new PatchState(Produce.JANGERBERRIES, CropState.DISEASED, value - 102);
				}
				if (value >= 111 && value <= 115)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 116 && value <= 123)
				{
					// Diseased whiteberry bush[Prune,Inspect,Guide] 7727,7728,7729,7730,7731,7732,7733,7734
					return new PatchState(Produce.WHITEBERRIES, CropState.DISEASED, value - 115);
				}
				if (value >= 124 && value <= 133)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576,7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 134 && value <= 138)
				{
					// Dead redberry bush[Clear,Inspect,Guide] 7708,7709,7710,7711,7712
					return new PatchState(Produce.REDBERRIES, CropState.DEAD, value - 133);
				}
				if (value >= 139 && value <= 143)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 144 && value <= 149)
				{
					// Dead cadavaberry bush[Clear,Inspect,Guide] 7599,7600,7601,7602,7603,7604
					return new PatchState(Produce.CADAVABERRIES, CropState.DEAD, value - 143);
				}
				if (value >= 150 && value <= 154)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 155 && value <= 161)
				{
					// Dead dwellberry bush[Clear,Inspect,Guide] 7625,7626,7627,7628,7629,7630,7631
					return new PatchState(Produce.DWELLBERRIES, CropState.DEAD, value - 154);
				}
				if (value >= 162 && value <= 166)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 167 && value <= 174)
				{
					// Dead jangerberry bush[Clear,Inspect,Guide] 7654,7655,7656,7657,7658,7659,7660,7661
					return new PatchState(Produce.JANGERBERRIES, CropState.DEAD, value - 166);
				}
				if (value >= 175 && value <= 179)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 180 && value <= 187)
				{
					// Dead whiteberry bush[Clear,Inspect,Guide] 7735,7736,7737,7738,7739,7740,7741,7742
					return new PatchState(Produce.WHITEBERRIES, CropState.DEAD, value - 179);
				}
				if (value >= 188 && value <= 196)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 197 && value <= 204)
				{
					// Poison Ivy bush[Inspect,Guide] 7662,7663,7664,7665,7666,7667,7668,7669
					return new PatchState(Produce.POISON_IVY, CropState.GROWING, value - 197);
				}
				if (value >= 205 && value <= 209)
				{
					// Poison Ivy bush[Clear,Inspect,Guide,Pick-from] 7670,7674,7674,7674,7674
					return new PatchState(Produce.POISON_IVY, CropState.HARVESTABLE, value - 205);
				}
				if (value >= 210 && value <= 216)
				{
					// Diseased Poison Ivy bush[Prune,Inspect,Guide] 7676,7677,7678,7679,7680,7681,7682
					return new PatchState(Produce.POISON_IVY, CropState.DISEASED, value - 209);
				}
				if (value >= 217 && value <= 224)
				{
					// Dead Poison Ivy bush[Clear,Inspect,Guide] 7684,7685,7686,7687,7688,7689,7690,7691
					return new PatchState(Produce.POISON_IVY, CropState.DEAD, value - 216);
				}
				if (value == 225)
				{
					// Diseased Poison Ivy bush[Prune,Inspect,Guide] 7683
					return new PatchState(Produce.POISON_IVY, CropState.DISEASED, 8);
				}
				if (value >= 226 && value <= 249)
				{
					// Bush Patch[Rake,Inspect,Guide] 7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576,7576
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value == 250)
				{
					// Redberry bush[Check-health,Inspect,Guide] 7702
					return new PatchState(Produce.REDBERRIES, CropState.GROWING, Produce.REDBERRIES.getStages() - 1);
				}
				if (value == 251)
				{
					// Cadavaberry bush[Check-health,Inspect,Guide] 7592
					return new PatchState(Produce.CADAVABERRIES, CropState.GROWING, Produce.CADAVABERRIES.getStages() - 1);
				}
				if (value == 252)
				{
					// Dwellberry bush[Check-health,Inspect,Guide] 7617
					return new PatchState(Produce.DWELLBERRIES, CropState.GROWING, Produce.DWELLBERRIES.getStages() - 1);
				}
				if (value == 253)
				{
					// Jangerberry bush[Check-health,Inspect,Guide] 7645
					return new PatchState(Produce.JANGERBERRIES, CropState.GROWING, Produce.JANGERBERRIES.getStages() - 1);
				}
				if (value == 254)
				{
					// Whiteberry bush[Check-health,Inspect,Guide] 7726
					return new PatchState(Produce.WHITEBERRIES, CropState.GROWING, Produce.WHITEBERRIES.getStages() - 1);
				}
				if (value == 255)
				{
					// Poison Ivy bush[Check-health,Inspect,Guide] 7675
					return new PatchState(Produce.POISON_IVY, CropState.GROWING, Produce.POISON_IVY.getStages() - 1);
				}
				return null;
			}
		},
	FRUIT_TREE(Tab.FRUIT_TREE, "", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Fruit Tree Patch[Rake,Inspect,Guide] 8050,8049,8048,8047
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Fruit Tree Patch[Rake,Inspect,Guide] 8050,8050,8050,8050
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 13)
				{
					// Apple tree[Inspect,Guide] 7935,7936,7937,7938,7939,7940
					return new PatchState(Produce.APPLE, CropState.GROWING, value - 8);
				}
				if (value >= 14 && value <= 20)
				{
					// Apple tree[Chop-down,Inspect,Guide,Pick-apple] 7941,7942,7943,7944,7945,7946,7947
					return new PatchState(Produce.APPLE, CropState.HARVESTABLE, value - 14);
				}
				if (value >= 21 && value <= 26)
				{
					// Diseased apple tree[Prune,Inspect,Guide] 7949,7950,7951,7952,7953,7954
					return new PatchState(Produce.APPLE, CropState.DISEASED, value - 20);
				}
				if (value >= 27 && value <= 32)
				{
					// Dead apple tree[Clear,Inspect,Guide] 7955,7956,7957,7958,7959,7960
					return new PatchState(Produce.APPLE, CropState.DEAD, value - 26);
				}
				if (value == 33)
				{
					// Apple tree stump[Clear,Inspect,Guide] 7961
					return new PatchState(Produce.APPLE, CropState.HARVESTABLE, 0);
				}
				if (value == 34)
				{
					// Apple tree[Check-health,Inspect,Guide] 7948
					return new PatchState(Produce.APPLE, CropState.GROWING, Produce.APPLE.getStages() - 1);
				}
				if (value >= 35 && value <= 40)
				{
					// Banana tree[Inspect,Guide] 7993,7994,7995,7996,7997,7998
					return new PatchState(Produce.BANANA, CropState.GROWING, value - 35);
				}
				if (value >= 41 && value <= 47)
				{
					// Banana tree[Chop-down,Inspect,Guide,Pick-banana] 8000,8001,8002,8003,8004,8005,8006
					return new PatchState(Produce.BANANA, CropState.HARVESTABLE, value - 41);
				}
				if (value >= 48 && value <= 53)
				{
					// Diseased banana tree[Prune,Inspect,Guide] 8007,8008,8009,8010,8011,8012
					return new PatchState(Produce.BANANA, CropState.DISEASED, value - 47);
				}
				if (value >= 54 && value <= 59)
				{
					// Dead banana tree[Clear,Inspect,Guide] 8013,8014,8015,8016,8017,8018
					return new PatchState(Produce.BANANA, CropState.DEAD, value - 53);
				}
				if (value == 60)
				{
					// Banana tree stump[Clear,Inspect,Guide] 8019
					return new PatchState(Produce.BANANA, CropState.HARVESTABLE, 0);
				}
				if (value == 61)
				{
					// Banana tree[Check-health,Inspect,Guide] 7999
					return new PatchState(Produce.BANANA, CropState.GROWING, Produce.BANANA.getStages() - 1);
				}
				if (value >= 62 && value <= 71)
				{
					// Fruit Tree Patch[Rake,Inspect,Guide] 8050,8050,8050,8050,8050,8050,8050,8050,8050,8050
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 72 && value <= 77)
				{
					// Orange tree[Inspect,Guide] 8051,8052,8053,8054,8055,8056
					return new PatchState(Produce.ORANGE, CropState.GROWING, value - 72);
				}
				if (value >= 78 && value <= 84)
				{
					// Orange tree[Chop-down,Inspect,Guide,Pick-orange] 8057,8058,8059,8060,8061,8062,8063
					return new PatchState(Produce.ORANGE, CropState.HARVESTABLE, value - 78);
				}
				if (value >= 85 && value <= 89)
				{
					// Diseased orange tree[Prune,Inspect,Guide] 8065,8066,8067,8068,8069
					return new PatchState(Produce.ORANGE, CropState.DISEASED, value - 84);
				}
				if (value == 90)
				{
					// Diseased orange tree[Chop-down,Inspect,Guide] 8070
					return new PatchState(Produce.ORANGE, CropState.DISEASED, 6);
				}
				if (value >= 91 && value <= 96)
				{
					// Dead orange tree[Clear,Inspect,Guide] 8071,8072,8073,8074,8075,8076
					return new PatchState(Produce.ORANGE, CropState.DEAD, value - 90);
				}
				if (value == 97)
				{
					// Orange tree stump[Clear,Inspect,Guide] 8077
					return new PatchState(Produce.ORANGE, CropState.HARVESTABLE, 0);
				}
				if (value == 98)
				{
					// Orange tree[Check-health,Inspect,Guide] 8064
					return new PatchState(Produce.ORANGE, CropState.GROWING, Produce.ORANGE.getStages() - 1);
				}
				if (value >= 99 && value <= 104)
				{
					// Curry tree[Inspect,Guide] 8020,8021,8022,8023,8024,8025
					return new PatchState(Produce.CURRY, CropState.GROWING, value - 99);
				}
				if (value >= 105 && value <= 111)
				{
					// Curry tree[Chop-down,Inspect,Guide,Pick-leaf] 8026,8027,8028,8029,8030,8031,8032
					return new PatchState(Produce.CURRY, CropState.HARVESTABLE, value - 105);
				}
				if (value >= 112 && value <= 117)
				{
					// Diseased curry tree[Prune,Inspect,Guide] 8034,8035,8036,8037,8038,8039
					return new PatchState(Produce.CURRY, CropState.DISEASED, value - 111);
				}
				if (value >= 118 && value <= 123)
				{
					// Dead curry tree[Clear,Inspect,Guide] 8040,8041,8042,8043,8044,8045
					return new PatchState(Produce.CURRY, CropState.DEAD, value - 117);
				}
				if (value == 124)
				{
					// Curry tree stump[Clear,Inspect,Guide] 8046
					return new PatchState(Produce.CURRY, CropState.HARVESTABLE, 0);
				}
				if (value == 125)
				{
					// Curry tree[Check-health,Inspect,Guide] 8033
					return new PatchState(Produce.CURRY, CropState.GROWING, Produce.CURRY.getStages() - 1);
				}
				if (value >= 126 && value <= 135)
				{
					// Fruit Tree Patch[Rake,Inspect,Guide] 8050,8050,8050,8050,8050,8050,8050,8050,8050,8050
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 136 && value <= 141)
				{
					// Pineapple plant[Inspect,Guide] 7966,7967,7968,7969,7970,7971
					return new PatchState(Produce.PINEAPPLE, CropState.GROWING, value - 136);
				}
				if (value >= 142 && value <= 148)
				{
					// Pineapple plant[Chop down,Inspect,Guide,Pick-pineapple] 7972,7973,7974,7975,7976,7977,7978
					return new PatchState(Produce.PINEAPPLE, CropState.HARVESTABLE, value - 142);
				}
				if (value >= 149 && value <= 154)
				{
					// Diseased pineapple plant[Prune,Inspect,Guide] 7980,7981,7982,7983,7984,7985
					return new PatchState(Produce.PINEAPPLE, CropState.DISEASED, value - 148);
				}
				if (value >= 155 && value <= 160)
				{
					// Dead pineapple plant[Clear,Inspect,Guide] 7986,7987,7988,7989,7990,7991
					return new PatchState(Produce.PINEAPPLE, CropState.DEAD, value - 154);
				}
				if (value == 161)
				{
					// Pineapple plant stump[Clear,Inspect,Guide] 7992
					return new PatchState(Produce.PINEAPPLE, CropState.HARVESTABLE, 0);
				}
				if (value == 162)
				{
					// Pineapple plant[Check-health,Inspect,Guide] 7979
					return new PatchState(Produce.PINEAPPLE, CropState.GROWING, Produce.PINEAPPLE.getStages() - 1);
				}
				if (value >= 163 && value <= 168)
				{
					// Papaya tree[Inspect,Guide] 8105,8106,8107,8108,8109,8110
					return new PatchState(Produce.PAPAYA, CropState.GROWING, value - 163);
				}
				if (value >= 169 && value <= 175)
				{
					// Papaya tree[Chop-down,Inspect,Guide,Pick-fruit] 8111,8112,8113,8114,8115,8116,8117
					return new PatchState(Produce.PAPAYA, CropState.HARVESTABLE, value - 169);
				}
				if (value >= 176 && value <= 181)
				{
					// Diseased papaya tree[Prune,Inspect,Guide] 8119,8120,8121,8122,8123,8124
					return new PatchState(Produce.PAPAYA, CropState.DISEASED, value - 175);
				}
				if (value >= 182 && value <= 187)
				{
					// Dead papaya tree[Clear,Inspect,Guide] 8125,8126,8127,8128,8129,8130
					return new PatchState(Produce.PAPAYA, CropState.DEAD, value - 181);
				}
				if (value == 188)
				{
					// Papaya tree stump[Clear,Inspect,Guide] 8131
					return new PatchState(Produce.PAPAYA, CropState.HARVESTABLE, 0);
				}
				if (value == 189)
				{
					// Papaya tree[Check-health,Inspect,Guide] 8118
					return new PatchState(Produce.PAPAYA, CropState.GROWING, Produce.PAPAYA.getStages() - 1);
				}
				if (value >= 190 && value <= 199)
				{
					// Fruit Tree Patch[Rake,Inspect,Guide] 8050,8050,8050,8050,8050,8050,8050,8050,8050,8050
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 200 && value <= 205)
				{
					// Palm tree[Inspect,Guide] 8078,8079,8080,8081,8082,8083
					return new PatchState(Produce.PALM, CropState.GROWING, value - 200);
				}
				if (value >= 206 && value <= 212)
				{
					// Palm tree[Chop-down,Inspect,Guide,Pick-coconut] 8084,8085,8086,8087,8088,8089,8090
					return new PatchState(Produce.PALM, CropState.HARVESTABLE, value - 206);
				}
				if (value >= 213 && value <= 218)
				{
					// Diseased palm tree[Prune,Inspect,Guide] 8092,8093,8094,8095,8096,8097
					return new PatchState(Produce.PALM, CropState.DISEASED, value - 212);
				}
				if (value >= 219 && value <= 224)
				{
					// Dead palm tree[Clear,Inspect,Guide] 8098,8099,8100,8101,8102,8103
					return new PatchState(Produce.PALM, CropState.DEAD, value - 218);
				}
				if (value == 225)
				{
					// Palm tree stump[Clear,Inspect,Guide] 8104
					return new PatchState(Produce.PALM, CropState.HARVESTABLE, 0);
				}
				if (value == 226)
				{
					// Palm tree[Check-health,Inspect,Guide] 8091
					return new PatchState(Produce.PALM, CropState.GROWING, Produce.PALM.getStages() - 1);
				}
				if (value >= 227 && value <= 232)
				{
					// Dragonfruit tree[Inspect,Guide] 34008,34009,34010,34011,34012,34013
					return new PatchState(Produce.DRAGONFRUIT, CropState.GROWING, value - 227);
				}
				if (value >= 233 && value <= 239)
				{
					// Dragonfruit tree[Chop down,Inspect,Guide,Pick-dragonfruit] 34014,34015,34016,34017,34018,34019,34020
					return new PatchState(Produce.DRAGONFRUIT, CropState.HARVESTABLE, value - 233);
				}
				if (value >= 240 && value <= 245)
				{
					// Diseased dragonfruit plant[Prune,Inspect,Guide] 34022,34023,34024,34025,34026,34027
					return new PatchState(Produce.DRAGONFRUIT, CropState.DISEASED, value - 239);
				}
				if (value >= 246 && value <= 251)
				{
					// Dead dragonfruit plant[Clear,Inspect,Guide] 34028,34029,34030,34031,34032,34033
					return new PatchState(Produce.DRAGONFRUIT, CropState.DEAD, value - 245);
				}
				if (value == 252)
				{
					// Dragonfruit tree stump[Clear,Inspect,Guide] 34034
					return new PatchState(Produce.DRAGONFRUIT, CropState.HARVESTABLE, 0);
				}
				if (value == 253)
				{
					// Dragonfruit tree[Check-health,Inspect,Guide] 34021
					return new PatchState(Produce.DRAGONFRUIT, CropState.GROWING, Produce.DRAGONFRUIT.getStages() - 1);
				}
				if (value >= 254 && value <= 255)
				{
					// Fruit Tree Patch[Rake,Inspect,Guide] 8050,8050
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	HOPS(Tab.HOPS, "", false)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8209,8208,8207
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Hammerstone Hops[Inspect,Guide] 8177,8178,8179,8180
					return new PatchState(Produce.HAMMERSTONE, CropState.GROWING, value - 4);
				}
				if (value >= 8 && value <= 10)
				{
					// Hammerstone Hops[Harvest,Inspect,Guide] 8181,8181,8181
					return new PatchState(Produce.HAMMERSTONE, CropState.HARVESTABLE, value - 8);
				}
				if (value >= 11 && value <= 15)
				{
					// Asgarnian Hops[Inspect,Guide] 8154,8155,8156,8157,8158
					return new PatchState(Produce.ASGARNIAN, CropState.GROWING, value - 11);
				}
				if (value >= 16 && value <= 18)
				{
					// Asgarnian Hops[Harvest,Inspect,Guide] 8159,8159,8159
					return new PatchState(Produce.ASGARNIAN, CropState.HARVESTABLE, value - 16);
				}
				if (value >= 19 && value <= 24)
				{
					// Yanillian Hops[Inspect,Guide] 8288,8289,8290,8291,8292,8293
					return new PatchState(Produce.YANILLIAN, CropState.GROWING, value - 19);
				}
				if (value >= 25 && value <= 27)
				{
					// Yanillian Hops[Harvest,Inspect,Guide] 8294,8294,8294
					return new PatchState(Produce.YANILLIAN, CropState.HARVESTABLE, value - 25);
				}
				if (value >= 28 && value <= 34)
				{
					// Krandorian Hops[Inspect,Guide] 8211,8212,8213,8214,8215,8216,8217
					return new PatchState(Produce.KRANDORIAN, CropState.GROWING, value - 28);
				}
				if (value >= 35 && value <= 37)
				{
					// Krandorian Hops[Harvest,Inspect,Guide] 8218,8218,8218
					return new PatchState(Produce.KRANDORIAN, CropState.HARVESTABLE, value - 35);
				}
				if (value >= 38 && value <= 45)
				{
					// Wildblood Hops[Inspect,Guide] 8257,8258,8259,8260,8261,8262,8263,8264
					return new PatchState(Produce.WILDBLOOD, CropState.GROWING, value - 38);
				}
				if (value >= 46 && value <= 48)
				{
					// Wildblood Hops[Harvest,Inspect,Guide] 8265,8265,8265
					return new PatchState(Produce.WILDBLOOD, CropState.HARVESTABLE, value - 46);
				}
				if (value >= 49 && value <= 52)
				{
					// Barley[Inspect,Guide] 8192,8193,8194,8195
					return new PatchState(Produce.BARLEY, CropState.GROWING, value - 49);
				}
				if (value >= 53 && value <= 55)
				{
					// Barley[Harvest,Inspect,Guide] 8196,8196,8196
					return new PatchState(Produce.BARLEY, CropState.HARVESTABLE, value - 53);
				}
				if (value >= 56 && value <= 60)
				{
					// Jute[Inspect,Guide] 8238,8239,8240,8241,8242
					return new PatchState(Produce.JUTE, CropState.GROWING, value - 56);
				}
				if (value >= 61 && value <= 63)
				{
					// Jute[Harvest,Inspect,Guide] 8243,8243,8243
					return new PatchState(Produce.JUTE, CropState.HARVESTABLE, value - 61);
				}
				if (value >= 64 && value <= 67)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 68 && value <= 71)
				{
					// Hammerstone Hops[Inspect,Guide] 8182,8183,8184,8185
					return new PatchState(Produce.HAMMERSTONE, CropState.GROWING, value - 68);
				}
				if (value >= 72 && value <= 74)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 75 && value <= 79)
				{
					// Asgarnian Hops[Inspect,Guide] 8160,8161,8162,8163,8164
					return new PatchState(Produce.ASGARNIAN, CropState.GROWING, value - 75);
				}
				if (value >= 80 && value <= 82)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 83 && value <= 88)
				{
					// Yanillian Hops[Inspect,Guide] 8295,8296,8297,8298,8299,8300
					return new PatchState(Produce.YANILLIAN, CropState.GROWING, value - 83);
				}
				if (value >= 89 && value <= 91)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 92 && value <= 98)
				{
					// Krandorian Hops[Inspect,Guide] 8219,8220,8221,8222,8223,8224,8225
					return new PatchState(Produce.KRANDORIAN, CropState.GROWING, value - 92);
				}
				if (value >= 99 && value <= 101)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 102 && value <= 109)
				{
					// Wildblood Hops[Inspect,Guide] 8266,8267,8268,8269,8270,8271,8272,8273
					return new PatchState(Produce.WILDBLOOD, CropState.GROWING, value - 102);
				}
				if (value >= 110 && value <= 112)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 113 && value <= 116)
				{
					// Barley[Inspect,Guide] 8197,8198,8199,8200
					return new PatchState(Produce.BARLEY, CropState.GROWING, value - 113);
				}
				if (value >= 117 && value <= 119)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 120 && value <= 124)
				{
					// Jute[Inspect,Guide] 8244,8245,8246,8247,8248
					return new PatchState(Produce.JUTE, CropState.GROWING, value - 120);
				}
				if (value >= 125 && value <= 132)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210,8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 133 && value <= 135)
				{
					// Diseased Hammerstone Hops[Cure,Inspect,Guide] 8186,8187,8188
					return new PatchState(Produce.HAMMERSTONE, CropState.DISEASED, value - 132);
				}
				if (value >= 136 && value <= 139)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 140 && value <= 143)
				{
					// Diseased Asgarnian Hops[Cure,Inspect,Guide] 8165,8166,8167,8168
					return new PatchState(Produce.ASGARNIAN, CropState.DISEASED, value - 139);
				}
				if (value >= 144 && value <= 147)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 148 && value <= 152)
				{
					// Diseased Yanillian Hops[Cure,Inspect,Guide] 8301,8302,8303,8304,8305
					return new PatchState(Produce.YANILLIAN, CropState.DISEASED, value - 147);
				}
				if (value >= 153 && value <= 156)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 157 && value <= 162)
				{
					// Diseased Krandorian Hops[Cure,Inspect,Guide] 8226,8227,8228,8229,8230,8231
					return new PatchState(Produce.KRANDORIAN, CropState.DISEASED, value - 156);
				}
				if (value >= 163 && value <= 166)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 167 && value <= 173)
				{
					// Diseased Wildblood Hops[Cure,Inspect,Guide] 8274,8275,8276,8277,8278,8279,8280
					return new PatchState(Produce.WILDBLOOD, CropState.DISEASED, value - 166);
				}
				if (value >= 174 && value <= 177)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 178 && value <= 180)
				{
					// Diseased Barley[Cure,Inspect,Guide] 8201,8202,8203
					return new PatchState(Produce.BARLEY, CropState.DISEASED, value - 177);
				}
				if (value == 181)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 183 && value <= 184)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 185 && value <= 188)
				{
					// Diseased Jute[Cure,Inspect,Guide] 8249,8250,8251,8252
					return new PatchState(Produce.JUTE, CropState.DISEASED, value - 184);
				}
				if (value >= 189 && value <= 196)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210,8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 197 && value <= 199)
				{
					// Dead Hammerstone Hops[Clear,Inspect,Guide] 8189,8190,8191
					return new PatchState(Produce.HAMMERSTONE, CropState.DEAD, value - 196);
				}
				if (value >= 200 && value <= 203)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 204 && value <= 207)
				{
					// Dead Asgarnian Hops[Clear,Inspect,Guide] 8169,8170,8171,8172
					return new PatchState(Produce.ASGARNIAN, CropState.DEAD, value - 203);
				}
				if (value >= 208 && value <= 211)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 212 && value <= 216)
				{
					// Dead Yanillian Hops[Clear,Inspect,Guide] 8306,8307,8308,8309,8310
					return new PatchState(Produce.YANILLIAN, CropState.DEAD, value - 211);
				}
				if (value >= 217 && value <= 220)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 221 && value <= 226)
				{
					// Dead Krandorian Hops[Clear,Inspect,Guide] 8232,8233,8234,8235,8236,8237
					return new PatchState(Produce.KRANDORIAN, CropState.DEAD, value - 220);
				}
				if (value >= 227 && value <= 230)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 231 && value <= 237)
				{
					// Dead Wildblood Hops[Clear,Inspect,Guide] 8281,8282,8283,8284,8285,8286,8287
					return new PatchState(Produce.WILDBLOOD, CropState.DEAD, value - 230);
				}
				if (value >= 238 && value <= 241)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 242 && value <= 244)
				{
					// Dead Barley[Clear,Inspect,Guide] 8204,8205,8206
					return new PatchState(Produce.BARLEY, CropState.DEAD, value - 241);
				}
				if (value >= 245 && value <= 248)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 249 && value <= 252)
				{
					// Dead Jute[Clear,Inspect,Guide] 8253,8254,8255,8256
					return new PatchState(Produce.JUTE, CropState.DEAD, value - 248);
				}
				if (value >= 253 && value <= 255)
				{
					// Hops Patch[Rake,Inspect,Guide] 8210,8210,8210
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	TREE(Tab.TREE, "", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8394,8393,8392
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395,8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 11)
				{
					// Oak[Inspect,Guide] 8462,8463,8464,8465
					return new PatchState(Produce.OAK, CropState.GROWING, value - 8);
				}
				if (value == 12)
				{
					// Oak[Check-health,Inspect,Guide] 8466
					return new PatchState(Produce.OAK, CropState.GROWING, Produce.OAK.getStages() - 1);
				}
				if (value == 13)
				{
					// Oak[Chop down,Inspect,Guide] 8467
					return new PatchState(Produce.OAK, CropState.HARVESTABLE, 0);
				}
				if (value == 14)
				{
					// Oak tree stump[Clear,Inspect,Guide] 8468
					return new PatchState(Produce.OAK, CropState.HARVESTABLE, 0);
				}
				if (value >= 15 && value <= 20)
				{
					// Willow Tree[Inspect,Guide] 8481,8482,8483,8484,8485,8486
					return new PatchState(Produce.WILLOW, CropState.GROWING, value - 15);
				}
				if (value == 21)
				{
					// Willow Tree[Check-health,Inspect,Guide] 8487
					return new PatchState(Produce.WILLOW, CropState.GROWING, Produce.WILLOW.getStages() - 1);
				}
				if (value == 22)
				{
					// Willow Tree[Chop down,Inspect,Guide] 8488
					return new PatchState(Produce.WILLOW, CropState.HARVESTABLE, 0);
				}
				if (value == 23)
				{
					// Willow tree stump[Clear,Inspect,Guide] 8489
					return new PatchState(Produce.WILLOW, CropState.HARVESTABLE, 0);
				}
				if (value >= 24 && value <= 31)
				{
					// Maple Tree[Inspect,Guide] 8435,8436,8437,8438,8439,8440,8441,8442
					return new PatchState(Produce.MAPLE, CropState.GROWING, value - 24);
				}
				if (value == 32)
				{
					// Maple Tree[Check-health,Inspect,Guide] 8443
					return new PatchState(Produce.MAPLE, CropState.GROWING, Produce.MAPLE.getStages() - 1);
				}
				if (value == 33)
				{
					// Maple Tree[Chop down,Inspect,Guide] 8444
					return new PatchState(Produce.MAPLE, CropState.HARVESTABLE, 0);
				}
				if (value == 34)
				{
					// Tree stump[Clear,Inspect,Guide] 8445
					return new PatchState(Produce.MAPLE, CropState.HARVESTABLE, 0);
				}
				if (value >= 35 && value <= 44)
				{
					// Yew sapling,Yew tree[Inspect,Guide] 8502,8503,8504,8505,8506,8507,8508,8509,8510,8511
					return new PatchState(Produce.YEW, CropState.GROWING, value - 35);
				}
				if (value == 45)
				{
					// Yew tree[Check-health,Inspect,Guide] 8512
					return new PatchState(Produce.YEW, CropState.GROWING, Produce.YEW.getStages() - 1);
				}
				if (value == 46)
				{
					// Yew tree[Chop down,Inspect,Guide] 8513
					return new PatchState(Produce.YEW, CropState.HARVESTABLE, 0);
				}
				if (value == 47)
				{
					// Yew tree stump[Clear,Inspect,Guide] 8514
					return new PatchState(Produce.YEW, CropState.HARVESTABLE, 0);
				}
				if (value >= 48 && value <= 59)
				{
					// Magic Tree[Inspect,Guide] 8396,8397,8398,8399,8400,8401,8402,8403,8404,8405,8406,8407
					return new PatchState(Produce.MAGIC, CropState.GROWING, value - 48);
				}
				if (value == 60)
				{
					// Magic Tree[Check-health,Inspect,Guide] 8408
					return new PatchState(Produce.MAGIC, CropState.GROWING, Produce.MAGIC.getStages() - 1);
				}
				if (value == 61)
				{
					// Magic Tree[Chop down,Inspect,Guide] 8409
					return new PatchState(Produce.MAGIC, CropState.HARVESTABLE, 0);
				}
				if (value == 62)
				{
					// Magic Tree Stump[Clear,Inspect,Guide] 8410
					return new PatchState(Produce.MAGIC, CropState.HARVESTABLE, 0);
				}
				if (value >= 63 && value <= 72)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395,8395,8395,8395,8395,8395,8395,8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 73 && value <= 75)
				{
					// Diseased Oak[Prune,Inspect,Guide] 8473,8474,8475
					return new PatchState(Produce.OAK, CropState.DISEASED, value - 72);
				}
				if (value == 77)
				{
					// Diseased Oak[Prune,Inspect,Guide] 8476
					return new PatchState(Produce.OAK, CropState.DISEASED, 4);
				}
				if (value >= 78 && value <= 79)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 80 && value <= 84)
				{
					// Diseased Willow[Prune,Inspect,Guide] 8490,8491,8492,8493,8494
					return new PatchState(Produce.WILLOW, CropState.DISEASED, value - 79);
				}
				if (value == 86)
				{
					// Diseased Willow[Prune,Inspect,Guide] 8495
					return new PatchState(Produce.WILLOW, CropState.DISEASED, 6);
				}
				if (value >= 87 && value <= 88)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 89 && value <= 95)
				{
					// Diseased Maple[Prune,Inspect,Guide] 8446,8447,8448,8449,8450,8451,8452
					return new PatchState(Produce.MAPLE, CropState.DISEASED, value - 88);
				}
				if (value == 97)
				{
					// Diseased Maple[Prune,Inspect,Guide] 8453
					return new PatchState(Produce.MAPLE, CropState.DISEASED, 8);
				}
				if (value >= 98 && value <= 99)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 100 && value <= 108)
				{
					// Diseased Yew[Prune,Inspect,Guide] 8515,8516,8517,8518,8519,8520,8521,8522,8523
					return new PatchState(Produce.YEW, CropState.DISEASED, value - 99);
				}
				if (value == 110)
				{
					// Diseased Yew[Prune,Inspect,Guide] 8524
					return new PatchState(Produce.YEW, CropState.DISEASED, 10);
				}
				if (value >= 111 && value <= 112)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 113 && value <= 123)
				{
					// Diseased Magic Tree[Prune,Inspect,Guide] 8411,8412,8413,8414,8415,8416,8417,8418,8419,8420,8421
					return new PatchState(Produce.MAGIC, CropState.DISEASED, value - 112);
				}
				if (value == 125)
				{
					// Diseased Magic Tree[Prune,Inspect,Guide] 8422
					return new PatchState(Produce.MAGIC, CropState.DISEASED, 12);
				}
				if (value >= 126 && value <= 136)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 137 && value <= 139)
				{
					// Dead Oak[Clear,Inspect,Guide] 8477,8478,8479
					return new PatchState(Produce.OAK, CropState.DEAD, value - 136);
				}
				if (value == 141)
				{
					// Dead Oak[Clear,Inspect,Guide] 8480
					return new PatchState(Produce.OAK, CropState.DEAD, 4);
				}
				if (value >= 142 && value <= 143)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 144 && value <= 148)
				{
					// Dead Willow[Clear,Inspect,Guide] 8496,8497,8498,8499,8500
					return new PatchState(Produce.WILLOW, CropState.DEAD, value - 143);
				}
				if (value == 150)
				{
					// Dead Willow[Clear,Inspect,Guide] 8501
					return new PatchState(Produce.WILLOW, CropState.DEAD, 6);
				}
				if (value >= 151 && value <= 152)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 153 && value <= 159)
				{
					// Dead Maple[Clear,Inspect,Guide] 8454,8455,8456,8457,8458,8459,8460
					return new PatchState(Produce.MAPLE, CropState.DEAD, value - 152);
				}
				if (value == 161)
				{
					// Dead Maple[Clear,Inspect,Guide] 8461
					return new PatchState(Produce.MAPLE, CropState.DEAD, 8);
				}
				if (value >= 162 && value <= 163)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 164 && value <= 172)
				{
					// Dead Yew[Clear,Inspect,Guide] 8525,8526,8527,8528,8529,8530,8531,8532,8533
					return new PatchState(Produce.YEW, CropState.DEAD, value - 163);
				}
				if (value == 174)
				{
					// Dead Yew[Clear,Inspect,Guide] 8534
					return new PatchState(Produce.YEW, CropState.DEAD, 10);
				}
				if (value >= 175 && value <= 176)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 177 && value <= 187)
				{
					// Dead Magic Tree[Clear,Inspect,Guide] 8423,8424,8425,8426,8427,8428,8429,8430,8431,8432,8433
					return new PatchState(Produce.MAGIC, CropState.DEAD, value - 176);
				}
				if (value == 189)
				{
					// Dead Magic Tree[Clear,Inspect,Guide] 8434
					return new PatchState(Produce.MAGIC, CropState.DEAD, 12);
				}
				if (value >= 190 && value <= 191)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 192 && value <= 197)
				{
					// Willow Tree[Chop down,Inspect,Guide] 8488,8488,8488,8488,8488,8488
					return new PatchState(Produce.WILLOW, CropState.HARVESTABLE, 0);
				}
				if (value >= 198 && value <= 255)
				{
					// Tree patch[Rake,Inspect,Guide] 8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395,8395
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	HARDWOOD_TREE(Tab.HARDWOOD, "Hardwood Trees", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Tree patch[Rake,Inspect,Guide] 30479,30478,30477,30476
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Tree patch[Rake,Inspect,Guide] 30479,30479,30479,30479
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 14)
				{
					// Teak Tree[Inspect,Guide] 30437,30438,30439,30440,30441,30442,30443
					return new PatchState(Produce.TEAK, CropState.GROWING, value - 8);
				}
				if (value == 15)
				{
					// Teak Tree[Check-health,Inspect,Guide] 30444
					return new PatchState(Produce.TEAK, CropState.GROWING, Produce.TEAK.getStages() - 1);
				}
				if (value == 16)
				{
					// Teak Tree[Chop down,Inspect,Guide] 30445
					return new PatchState(Produce.TEAK, CropState.HARVESTABLE, 0);
				}
				if (value == 17)
				{
					// Tree stump[Clear,Inspect,Guide] 30446
					return new PatchState(Produce.TEAK, CropState.HARVESTABLE, 0);
				}
				if (value >= 18 && value <= 23)
				{
					// Diseased Teak[Prune,Inspect,Guide] 30447,30448,30449,30450,30451,30452
					return new PatchState(Produce.TEAK, CropState.DISEASED, value - 17);
				}
				if (value >= 24 && value <= 29)
				{
					// Dead Teak[Clear,Inspect,Guide] 30453,30454,30455,30456,30457,30458
					return new PatchState(Produce.TEAK, CropState.DEAD, value - 23);
				}
				if (value >= 30 && value <= 37)
				{
					// Mahogany sapling,Mahogany tree[Inspect,Guide] 30406,30407,30408,30409,30410,30411,30412,30413
					return new PatchState(Produce.MAHOGANY, CropState.GROWING, value - 30);
				}
				if (value == 38)
				{
					// Mahogany tree[Check-health,Inspect,Guide] 30416
					return new PatchState(Produce.MAHOGANY, CropState.GROWING, Produce.MAHOGANY.getStages() - 1);
				}
				if (value == 39)
				{
					// Mahogany tree[Chop down,Inspect,Guide] 30417
					return new PatchState(Produce.MAHOGANY, CropState.HARVESTABLE, 0);
				}
				if (value == 40)
				{
					// Mahogany tree stump[Clear,Inspect,Guide] 30418
					return new PatchState(Produce.MAHOGANY, CropState.HARVESTABLE, 0);
				}
				if (value >= 41 && value <= 47)
				{
					// Diseased Mahogany[Prune,Inspect,Guide] 30419,30420,30421,30422,30423,30424,30425
					return new PatchState(Produce.MAHOGANY, CropState.DISEASED, value - 40);
				}
				if (value >= 48 && value <= 54)
				{
					// Dead Mahogany[Clear,Inspect,Guide] 30428,30429,30430,30431,30432,30433,30434
					return new PatchState(Produce.MAHOGANY, CropState.DEAD, value - 47);
				}
				if (value >= 55 && value <= 255)
				{
					// Tree patch[Rake,Inspect,Guide] 30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479,30479
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	REDWOOD(Tab.REDWOOD, "Redwood Trees", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Redwood tree patch[Rake,Inspect,Guide] 34050,34049,34048,34047
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Redwood tree patch[Rake,Inspect,Guide] 34050,34050,34050,34050
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 17)
				{
					// Redwood tree[Inspect,Guide] 34205,34206,34207,34208,34209,34210,34215,34224,34242,34260
					return new PatchState(Produce.REDWOOD, CropState.GROWING, value - 8);
				}
				if (value == 18)
				{
					// Redwood tree[Clear,Inspect,Guide] 34278
					return new PatchState(Produce.REDWOOD, CropState.HARVESTABLE, 0);
				}
				if (value >= 19 && value <= 27)
				{
					// Diseased Redwood tree[Prune,Inspect,Guide] 34130,34131,34132,34133,34134,34139,34148,34166,34184
					return new PatchState(Produce.REDWOOD, CropState.DISEASED, value - 18);
				}
				if (value >= 28 && value <= 36)
				{
					// Dead Redwood tree[Clear,Inspect,Guide] 34061,34062,34063,34064,34065,34070,34079,34097,34115
					return new PatchState(Produce.REDWOOD, CropState.DEAD, value - 27);
				}
				if (value == 37)
				{
					// Redwood tree[Check-health,Inspect,Guide] 34297
					return new PatchState(Produce.REDWOOD, CropState.GROWING, Produce.REDWOOD.getStages() - 1);
				}
				if (value >= 41 && value <= 55)
				{
					// Redwood tree[Clear,Inspect,Guide] 34278,34278,34278,34278,34278,34278,34278,34278,34278,34278,34278,34278,34278,34278,34278
					return new PatchState(Produce.REDWOOD, CropState.HARVESTABLE, 0);
				}
				return null;
			}
		},
	SPIRIT_TREE(Tab.SPECIAL, "Spirit Trees", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Spirit Tree Patch[Rake,Inspect,Guide] 8342,8341,8340,8339
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Spirit Tree Patch[Rake,Inspect,Guide] 8342,8342,8342,8342
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 19)
				{
					// Spirit Tree[Inspect,Guide] 8343,8344,8345,8346,8347,8348,8349,8350,8351,8352,8353,8354
					return new PatchState(Produce.SPIRIT_TREE, CropState.GROWING, value - 8);
				}
				if (value == 20)
				{
					// Spirit Tree[Travel,Talk-to,Inspect,Guide,Clear] 8355
					return new PatchState(Produce.SPIRIT_TREE, CropState.GROWING, 12);
				}
				if (value >= 21 && value <= 31)
				{
					// Diseased Spirit Tree[Prune,Inspect,Guide] 8358,8359,8360,8361,8362,8363,8364,8365,8366,8367,8368
					return new PatchState(Produce.SPIRIT_TREE, CropState.DISEASED, value - 20);
				}
				if (value >= 32 && value <= 43)
				{
					// Dead Spirit Tree[Clear,Inspect,Guide] 8370,8371,8372,8373,8374,8375,8376,8377,8378,8379,8380,8381
					return new PatchState(Produce.SPIRIT_TREE, CropState.DEAD, value - 31);
				}
				if (value == 44)
				{
					// Spirit Tree[Check-health,Inspect,Guide] 8356
					return new PatchState(Produce.SPIRIT_TREE, CropState.GROWING, Produce.SPIRIT_TREE.getStages() - 1);
				}
				if (value >= 45 && value <= 63)
				{
					// Spirit Tree Patch[Rake,Inspect,Guide] 8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342,8342
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	ANIMA(Tab.SPECIAL, "", false)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Anima patch[Rake,Inspect,Guide] 33983,33982,33981,33980
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Anima patch[Rake,Inspect,Guide] 33983,33983,33983,33983
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 16)
				{
					// Attas plant[Inspect,Guide] 33991,33992,33993,33994,33995
					// Attas plant[Inspect,Guide] 33995,33995
					// Withering Attas plant[Inspect,Guide] 33996
					// Dead Attas plant[Clear,Inspect,Guide] 33997
					return new PatchState(Produce.ATTAS, CropState.GROWING, value - 8);
				}
				if (value >= 17 && value <= 25)
				{
					// Iasor plant[Inspect,Guide] 33984,33985,33986,33987,33988
					// Iasor plant[Inspect,Guide] 33988,33988
					// Withering Iasor plant[Inspect,Guide] 33989
					// Dead Iasor plant[Clear,Inspect,Guide] 33990
					return new PatchState(Produce.IASOR, CropState.GROWING, value - 17);
				}
				if (value >= 26 && value <= 34)
				{
					// Kronos plant[Inspect,Guide] 33999,34000,34001,34002,34003
					// Kronos plant[Inspect,Guide] 34003,34003
					// Withering Kronos plant[Inspect,Guide] 34004
					// Dead Kronos plant[Clear,Inspect,Guide] 34005
					return new PatchState(Produce.KRONOS, CropState.GROWING, value - 26);
				}
				if (value >= 35 && value <= 255)
				{
					// Anima patch[Rake,Inspect,Guide] 33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983,33983
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	CACTUS(Tab.CACTUS, "Cactus", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Cactus patch[Rake,Inspect,Guide] 7746,7745,7744,7743
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Cactus patch[Rake,Inspect,Guide] 7746,7746,7746,7746
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 14)
				{
					// Cactus[Inspect,Guide] 7747,7748,7749,7750,7751,7752,7753
					return new PatchState(Produce.CACTUS, CropState.GROWING, value - 8);
				}
				if (value >= 15 && value <= 18)
				{
					// Cactus[Clear,Inspect,Guide,Pick-spine] 7754,7757,7757,7757
					return new PatchState(Produce.CACTUS, CropState.HARVESTABLE, value - 15);
				}
				if (value >= 19 && value <= 24)
				{
					// Diseased cactus[Cure,Inspect,Guide] 7759,7760,7761,7762,7763,7764
					return new PatchState(Produce.CACTUS, CropState.DISEASED, value - 18);
				}
				if (value >= 25 && value <= 30)
				{
					// Dead cactus[Clear,Inspect,Guide] 7765,7766,7767,7768,7769,7770
					return new PatchState(Produce.CACTUS, CropState.DEAD, value - 24);
				}
				if (value == 31)
				{
					// Cactus[Check-health,Inspect,Guide] 7758
					return new PatchState(Produce.CACTUS, CropState.GROWING, Produce.CACTUS.getStages() - 1);
				}
				if (value >= 32 && value <= 38)
				{
					// Potato cactus[Inspect,Guide] 33734,33735,33736,33737,33738,33739,33740
					return new PatchState(Produce.POTATO_CACTUS, CropState.GROWING, value - 32);
				}
				if (value >= 39 && value <= 45)
				{
					// Potato cactus[Clear,Inspect,Guide,Pick] 33741,33742,33743,33744,33745,33746,33747
					return new PatchState(Produce.POTATO_CACTUS, CropState.HARVESTABLE, value - 39);
				}
				if (value >= 46 && value <= 51)
				{
					// Diseased Potato cactus[Cure,Inspect,Guide] 33749,33750,33751,33752,33753,33754
					return new PatchState(Produce.POTATO_CACTUS, CropState.DISEASED, value - 45);
				}
				if (value >= 52 && value <= 57)
				{
					// Dead Potato cactus[Clear,Inspect,Guide] 33755,33756,33757,33758,33759,33760
					return new PatchState(Produce.POTATO_CACTUS, CropState.DEAD, value - 51);
				}
				if (value == 58)
				{
					// Potato cactus[Check-health,Inspect,Guide] 33748
					return new PatchState(Produce.POTATO_CACTUS, CropState.GROWING, Produce.POTATO_CACTUS.getStages() - 1);
				}
				if (value >= 59 && value <= 255)
				{
					// Cactus patch[Rake,Inspect,Guide] 7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746,7746
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	SEAWEED(Tab.SEAWEED, "Seaweed", false)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Seaweed patch[Rake,Inspect,Guide] 30486,30485,30484,30483
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Seaweed[Inspect,Guide] 30487,30488,30489,30490
					return new PatchState(Produce.SEAWEED, CropState.GROWING, value - 4);
				}
				if (value >= 8 && value <= 10)
				{
					// Seaweed[Pick,Inspect,Guide] 30491,30492,30493
					return new PatchState(Produce.SEAWEED, CropState.HARVESTABLE, value - 8);
				}
				if (value >= 11 && value <= 13)
				{
					// Diseased seaweed[Cure,Inspect,Guide] 30494,30495,30496
					return new PatchState(Produce.SEAWEED, CropState.DISEASED, value - 10);
				}
				if (value >= 14 && value <= 16)
				{
					// Dead seaweed[Clear,Inspect,Guide] 30497,30498,30499
					return new PatchState(Produce.SEAWEED, CropState.DEAD, value - 13);
				}
				if (value >= 17 && value <= 255)
				{
					// Seaweed patch[Rake,Inspect,Guide] 30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486,30486
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	CALQUAT(Tab.CALQUAT, "Calquat", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Calquat patch[Rake,Inspect,Guide] 7775,7774,7773,7772
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 11)
				{
					// Calquat Tree[Inspect,Guide] 7776,7777,7778,7779,7780,7781,7782,7783
					return new PatchState(Produce.CALQUAT, CropState.GROWING, value - 4);
				}
				if (value >= 12 && value <= 18)
				{
					// Calquat Tree[Clear,Inspect,Guide,Pick-fruit] 7784,7785,7786,7787,7788,7789,7790
					return new PatchState(Produce.CALQUAT, CropState.HARVESTABLE, value - 12);
				}
				if (value >= 19 && value <= 25)
				{
					// Diseased Calquat[Prune,Inspect,Guide] 7792,7793,7794,7795,7796,7797,7798
					return new PatchState(Produce.CALQUAT, CropState.DISEASED, value - 18);
				}
				if (value >= 26 && value <= 33)
				{
					// Dead Calquat[Clear,Inspect,Guide] 7799,7800,7801,7802,7803,7804,7805,7806
					return new PatchState(Produce.CALQUAT, CropState.DEAD, value - 25);
				}
				if (value == 34)
				{
					// Calquat Tree[Check-health,Inspect,Guide] 7791
					return new PatchState(Produce.CALQUAT, CropState.GROWING, Produce.CALQUAT.getStages() - 1);
				}
				if (value >= 35 && value <= 255)
				{
					// Calquat patch[Rake,Inspect,Guide] 7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775,7775
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	CELASTRUS(Tab.CELASTRUS, "Celastrus", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Celastrus patch[Rake,Inspect,Guide] 33698,33697,33696,33695
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 4 && value <= 7)
				{
					// Celastrus patch[Rake,Inspect,Guide] 33698,33698,33698,33698
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 8 && value <= 12)
				{
					// Celastrus tree[Inspect,Guide] 33699,33700,33701,33702,33703
					return new PatchState(Produce.CELASTRUS, CropState.GROWING, value - 8);
				}
				if (value == 13)
				{
					// Celastrus tree[Check-health,Inspect,Guide] 33704
					return new PatchState(Produce.CELASTRUS, CropState.GROWING, Produce.CELASTRUS.getStages() - 1);
				}
				if (value >= 14 && value <= 16)
				{
					// Celastrus tree[Harvest,Inspect,Guide] 33719,33718,33717
					return new PatchState(Produce.CELASTRUS, CropState.HARVESTABLE, value - 14);
				}
				if (value == 17)
				{
					// Harvested Celastrus tree[Chop,Inspect,Guide] 33720
					return new PatchState(Produce.CELASTRUS, CropState.HARVESTABLE, 0);
				}
				if (value >= 18 && value <= 22)
				{
					// Diseased celastrus tree[Prune,Inspect,Guide] 33705,33706,33707,33708,33709
					return new PatchState(Produce.CELASTRUS, CropState.DISEASED, value - 17);
				}
				if (value >= 23 && value <= 27)
				{
					// Dead celastrus tree[Clear,Inspect,Guide] 33711,33712,33713,33714,33715
					return new PatchState(Produce.CELASTRUS, CropState.DEAD, value - 22);
				}
				if (value == 28)
				{
					// Celastrus tree stump[Clear,Inspect,Guide] 33721
					return new PatchState(Produce.CELASTRUS, CropState.HARVESTABLE, 0);
				}
				if (value >= 29 && value <= 255)
				{
					// Celastrus patch[Rake,Inspect,Guide] 33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698,33698
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				return null;
			}
		},
	GRAPES(Tab.GRAPE, "", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 1)
				{
					// Empty, empty+fertilizer
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3);
				}
				if (value >= 2 && value <= 9)
				{
					return new PatchState(Produce.GRAPE, CropState.GROWING, value - 2);
				}
				if (value == 10)
				{
					return new PatchState(Produce.GRAPE, CropState.GROWING, 7);
				}
				if (value >= 11 && value <= 15)
				{
					return new PatchState(Produce.GRAPE, CropState.HARVESTABLE, value - 11);
				}
				return null;
			}
		},
	CRYSTAL_TREE(Tab.CRYSTAL, "Crystal Tree", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value >= 0 && value <= 3)
				{
					// Crystal tree patch[Rake,Inspect,Guide] 34910,34909,34908,34907
					return new PatchState(Produce.WEEDS, CropState.GROWING, 3 - value);
				}
				if (value >= 8 && value <= 13)
				{
					// Crystal tree[Inspect,Guide] 34911,34912,34913,34914,34915,34916
					return new PatchState(Produce.CRYSTAL_TREE, CropState.GROWING, value - 8);
				}
				if (value == 14)
				{
					// Crystal tree[Check-health,Inspect,Guide] 34917
					return new PatchState(Produce.CRYSTAL_TREE, CropState.GROWING, Produce.CRYSTAL_TREE.getStages() - 1);
				}
				if (value == 15)
				{
					// Crystal tree[Chop-down,Inspect,Guide] 34918
					return new PatchState(Produce.CRYSTAL_TREE, CropState.HARVESTABLE, 0);
				}
				return null;
			}
		},
	COMPOST(Tab.SPECIAL, "Compost Bin", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value == 0)
				{
					// Compost bin[Examine] 7808
					return new PatchState(Produce.EMPTY_COMPOST_BIN, CropState.EMPTY, 0);
				}
				if (value >= 1 && value <= 15)
				{
					// Compost bin[Examine,Dump] 3830
					return new PatchState(Produce.COMPOST, CropState.FILLING, value - 1);
				}
				if (value >= 16 && value <= 30)
				{
					// Compost bin[Take,Examine,Dump] 19050,19051,19052,19053,19054,19055,19056,19057,19058,19059,19060,19061,19062,19063,19064
					return new PatchState(Produce.COMPOST, CropState.HARVESTABLE, value - 16);
				}
				if (value == 31 || value == 32)
				{
					// Compost bin[Open,Examine,Dump] 3849,3849
					return new PatchState(Produce.COMPOST, CropState.GROWING, value - 31);
				}
				if (value >= 33 && value <= 47)
				{
					// Compost bin[Examine,Dump] 19066,19067,19068,19069,19070,19071,19072,19073,19074,19075,19076,19077,19078,19079,19080
					return new PatchState(Produce.SUPERCOMPOST, CropState.FILLING, value - 33); // 33 means there is 1 item
				}
				if (value >= 48 && value <= 62)
				{
					// Compost bin[Take,Examine,Dump] 19097
					return new PatchState(Produce.SUPERCOMPOST, CropState.HARVESTABLE, value - 48); // 48 means there is only 1 bucket left
				}
				if (value == 94)
				{
					// Compost bin[Open,Examine,Dump] 3850
					return new PatchState(Produce.COMPOST, CropState.GROWING, Produce.COMPOST.getStages() - 1);
				}
				if (value == 95 || value == 96)
				{
					// Compost bin[Open,Examine,Dump] 19082,19082
					return new PatchState(Produce.SUPERCOMPOST, CropState.GROWING, value - 95);
				}
				if (value == 126)
				{
					// Compost bin[Open,Examine,Dump] 19082
					return new PatchState(Produce.SUPERCOMPOST, CropState.GROWING, Produce.SUPERCOMPOST.getStages() - 1);
				}
				if (value >= 129 && value <= 143)
				{
					// Giant compost bin[Close,Examine,Dump] 19098..19111,20099
					return new PatchState(Produce.ROTTEN_TOMATO, CropState.FILLING, value - 129);
				}
				if (value >= 144 && value <= 158)
				{
					// Giant compost bin[Take,Examine,Dump] 20102..20116
					return new PatchState(Produce.ROTTEN_TOMATO, CropState.HARVESTABLE, value - 144);
				}
				if (value >= 159 && value <= 160)
				{
					// Giant compost bin[Open,Examine,Dump] 20100
					return new PatchState(Produce.ROTTEN_TOMATO, CropState.GROWING, value - 159);
				}
				if (value >= 176 && value <= 190)
				{
					// Compost bin[Take,Examine,Dump] 30502,30503,30504,30505,30506,30507,30508,30509,30510,30511,30512,30513,30514,30515,30516
					return new PatchState(Produce.ULTRACOMPOST, CropState.HARVESTABLE, value - 176);
				}
				return null;
			}
		},
	BIG_COMPOST(Tab.BIG_COMPOST, "Big Compost Bin", true)
		{
			@Override
			PatchState forVarbitValue(int value)
			{
				if (value == 0)
				{
					// Big compost bin[Examine] 33762
					return new PatchState(Produce.EMPTY_BIG_COMPOST_BIN, CropState.EMPTY, 0);
				}
				if (value >= 1 && value <= 15)
				{
					// Big compost bin[Examine,Dump] 33763..33777
					return new PatchState(Produce.BIG_COMPOST, CropState.FILLING, value - 1);
				}
				if (value >= 16 && value <= 30)
				{
					// Big compost bin[Take,Examine,Dump] 33795..33809
					return new PatchState(Produce.BIG_COMPOST, CropState.HARVESTABLE, value - 16);
				}
				if (value >= 33 && value <= 47)
				{
					// Big compost bin[Examine,Dump] 33825..33839
					return new PatchState(Produce.BIG_SUPERCOMPOST, CropState.FILLING, value - 33);
				}
				if (value >= 48 && value <= 62)
				{
					// Big compost bin[Take,Examine,Dump] 33857..33871
					return new PatchState(Produce.BIG_SUPERCOMPOST, CropState.HARVESTABLE, value - 48);
				}
				if (value >= 63 && value <= 77)
				{
					// Big compost bin[Examine,Dump] 33778..33792
					return new PatchState(Produce.BIG_COMPOST, CropState.FILLING, 15 + value - 63);
				}
				if (value >= 78 && value <= 92)
				{
					// Giant compost bin[Take,Examine,Dump] 33810..33824
					return new PatchState(Produce.BIG_COMPOST, CropState.HARVESTABLE, 15 + value - 78);
				}
				if (value == 93)
				{
					// Giant compost bin[Open,Examine,Dump] 33794
					return new PatchState(Produce.BIG_COMPOST, CropState.GROWING, Produce.BIG_COMPOST.getStages() - 1);
				}
				if (value >= 97 && value <= 99)
				{
					// Giant compost bin[Open,Examin,Dump] 33855,33855
					return new PatchState(Produce.BIG_SUPERCOMPOST, CropState.GROWING, value - 97); // Once closed, starts rotting (super compost)
				}
				if (value >= 100 && value <= 114)
				{
					// Giant compost bin[Take,Examine,Dump] 33872..33886
					return new PatchState(Produce.BIG_SUPERCOMPOST, CropState.HARVESTABLE, 15 + value - 100);
				}
				if (value >= 127 && value <= 128)
				{
					// Giant compost bin[Open,Examine,Dump] 33793,33793
					return new PatchState(Produce.BIG_COMPOST, CropState.GROWING, value - 127);
				}
				if (value >= 129 && value <= 143)
				{
					// Giant compost bin[Close,Examine,Dump] 33887..33901
					return new PatchState(Produce.BIG_ROTTEN_TOMATO, CropState.FILLING, value - 129);
				}
				if (value >= 144 && value <= 158)
				{
					// Giant compost bin[Take,Examine,Dump] 33919..33933
					return new PatchState(Produce.BIG_ROTTEN_TOMATO, CropState.HARVESTABLE, value - 144);
				}
				if (value >= 159 && value <= 160)
				{
					// Giant compost bin[Open,Examine,Dump] 33917,33917
					return new PatchState(Produce.BIG_ROTTEN_TOMATO, CropState.GROWING, value - 159);
				}
				if (value >= 161 && value <= 175)
				{
					// Giant compost bin[Examine,Dump] 33840..33854
					return new PatchState(Produce.BIG_SUPERCOMPOST, CropState.FILLING, 15 + value - 161); // 161 means there are 16 items
				}
				if (value >= 176 && value <= 205)
				{
					// Giant compost bin[Take,Examine,Dump] 33957..33986
					return new PatchState(Produce.BIG_ULTRACOMPOST, CropState.HARVESTABLE, value - 176);
				}
				if (value >= 207 && value <= 221)
				{
					// Giant compost bin[Take,Examine,Dump] 33934..33948
					return new PatchState(Produce.BIG_ROTTEN_TOMATO, CropState.HARVESTABLE, 15 + value - 207);
				}
				if (value == 222)
				{
					// Giant compost bin[Open,Examine,Dump] 33918
					return new PatchState(Produce.BIG_ROTTEN_TOMATO, CropState.GROWING, Produce.BIG_ROTTEN_TOMATO.getStages() - 1);
				}
				if (value >= 223 && value <= 237)
				{
					// Giant compost bin[Close,Examine,Dump] 33902..33916
					return new PatchState(Produce.BIG_ROTTEN_TOMATO, CropState.FILLING, 15 + value  - 223);
				}
				return null;
			}
		};

	@Nullable
	abstract PatchState forVarbitValue(int value);

	private final Tab tab;

	private final String name;

	private final boolean healthCheckRequired;
}

// THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT IT MANUALLY. SEE README.

/*
 * Copyright (c) 2018 Abex
 * Copyright (c) 2018, NotFoxtrot <https://github.com/NotFoxtrot>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.homeassistant.runelite.farming;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;
import net.runelite.api.NullItemID;

import javax.annotation.Nullable;

@RequiredArgsConstructor
@Getter
public enum Produce
{
	WEEDS("Weeds", ItemID.WEEDS, 5, 4),
	SCARECROW("Scarecrow", ItemID.SCARECROW, 5, 4),

	// Allotment crops
	POTATO("Potato", "Potatoes", PatchImplementation.ALLOTMENT, ItemID.POTATO, 10, 5, 0, 3),
	ONION("Onion", "Onions", PatchImplementation.ALLOTMENT, ItemID.ONION, 10, 5, 0, 3),
	CABBAGE("Cabbage", "Cabbages", PatchImplementation.ALLOTMENT, ItemID.CABBAGE, 10, 5, 0, 3),
	TOMATO("Tomato", "Tomatoes", PatchImplementation.ALLOTMENT, ItemID.TOMATO, 10, 5, 0, 3),
	SWEETCORN("Sweetcorn", PatchImplementation.ALLOTMENT, ItemID.SWEETCORN, 10, 7, 0, 3),
	STRAWBERRY("Strawberry", "Strawberries", PatchImplementation.ALLOTMENT, ItemID.STRAWBERRY, 10, 7, 0, 3),
	WATERMELON("Watermelon", "Watermelons", PatchImplementation.ALLOTMENT, ItemID.WATERMELON, 10, 9, 0, 3),
	SNAPE_GRASS("Snape grass", PatchImplementation.ALLOTMENT, ItemID.SNAPE_GRASS, 10, 8, 0, 3),

	// Flower crops
	MARIGOLD("Marigold", "Marigolds", PatchImplementation.FLOWER, ItemID.MARIGOLDS, 5, 5),
	ROSEMARY("Rosemary", PatchImplementation.FLOWER, ItemID.ROSEMARY, 5, 5),
	NASTURTIUM("Nasturtium", "Nasturtiums", PatchImplementation.FLOWER, ItemID.NASTURTIUMS, 5, 5),
	WOAD("Woad", PatchImplementation.FLOWER, ItemID.WOAD_LEAF, 5, 5),
	LIMPWURT("Limpwurt", "Limpwurt roots", PatchImplementation.FLOWER, ItemID.LIMPWURT_ROOT, 5, 5),
	WHITE_LILY("White lily", "White lillies", PatchImplementation.FLOWER, ItemID.WHITE_LILY, 5, 5),

	// Bush crops
	REDBERRIES("Redberry", "Redberries", PatchImplementation.BUSH, ItemID.REDBERRIES, 20, 6, 20, 5),
	CADAVABERRIES("Cadavaberry", "Cadava berries", PatchImplementation.BUSH, ItemID.CADAVA_BERRIES, 20, 7, 20, 5),
	DWELLBERRIES("Dwellberry", "Dwellberries", PatchImplementation.BUSH, ItemID.DWELLBERRIES, 20, 8, 20, 5),
	JANGERBERRIES("Jangerberry", "Jangerberries", PatchImplementation.BUSH, ItemID.JANGERBERRIES, 20, 9, 20, 5),
	WHITEBERRIES("Whiteberry", "White berries", PatchImplementation.BUSH, ItemID.WHITE_BERRIES, 20, 9, 20, 5),
	POISON_IVY("Poison ivy", "Poison ivy berries", PatchImplementation.BUSH, ItemID.POISON_IVY_BERRIES, 20, 9, 20, 5),

	// Hop crops
	BARLEY("Barley", PatchImplementation.HOPS, ItemID.BARLEY, 10, 5, 0, 3),
	HAMMERSTONE("Hammerstone", PatchImplementation.HOPS, ItemID.HAMMERSTONE_HOPS, 10, 5, 0, 3),
	ASGARNIAN("Asgarnian", PatchImplementation.HOPS, ItemID.ASGARNIAN_HOPS, 10, 6, 0, 3),
	JUTE("Jute", PatchImplementation.HOPS, ItemID.JUTE_FIBRE, 10, 6, 0, 3),
	YANILLIAN("Yanillian", PatchImplementation.HOPS, ItemID.YANILLIAN_HOPS, 10, 7, 0, 3),
	KRANDORIAN("Krandorian", PatchImplementation.HOPS, ItemID.KRANDORIAN_HOPS, 10, 8, 0, 3),
	WILDBLOOD("Wildblood", PatchImplementation.HOPS, ItemID.WILDBLOOD_HOPS, 10, 9, 0, 3),

	// Herb crops
	GUAM("Guam", PatchImplementation.HERB, ItemID.GUAM_LEAF, 20, 5, 0, 3),
	MARRENTILL("Marrentill", PatchImplementation.HERB, ItemID.MARRENTILL, 20, 5, 0, 3),
	TARROMIN("Tarromin", PatchImplementation.HERB, ItemID.TARROMIN, 20, 5, 0, 3),
	HARRALANDER("Harralander", PatchImplementation.HERB, ItemID.HARRALANDER, 20, 5, 0, 3),
	RANARR("Ranarr", PatchImplementation.HERB, ItemID.RANARR_WEED, 20, 5, 0, 3),
	TOADFLAX("Toadflax", PatchImplementation.HERB, ItemID.TOADFLAX, 20, 5, 0, 3),
	IRIT("Irit", PatchImplementation.HERB, ItemID.IRIT_LEAF, 20, 5, 0, 3),
	AVANTOE("Avantoe", PatchImplementation.HERB, ItemID.AVANTOE, 20, 5, 0, 3),
	KWUARM("Kwuarm", PatchImplementation.HERB, ItemID.KWUARM, 20, 5, 0, 3),
	SNAPDRAGON("Snapdragon", PatchImplementation.HERB, ItemID.SNAPDRAGON, 20, 5, 0, 3),
	CADANTINE("Cadantine", PatchImplementation.HERB, ItemID.CADANTINE, 20, 5, 0, 3),
	LANTADYME("Lantadyme", PatchImplementation.HERB, ItemID.LANTADYME, 20, 5, 0, 3),
	DWARF_WEED("Dwarf weed", PatchImplementation.HERB, ItemID.DWARF_WEED, 20, 5, 0, 3),
	TORSTOL("Torstol", PatchImplementation.HERB, ItemID.TORSTOL, 20, 5, 0, 3),
	GOUTWEED("Goutweed", PatchImplementation.HERB, ItemID.GOUTWEED, 20, 5, 0, 2),
	ANYHERB("Any herb", PatchImplementation.HERB, ItemID.GUAM_LEAF, 20, 5, 0, 3),

	// Tree crops
	OAK("Oak", "Oak tree", PatchImplementation.TREE, ItemID.OAK_LOGS, 40, 5),
	WILLOW("Willow", "Willow tree", PatchImplementation.TREE, ItemID.WILLOW_LOGS, 40, 7),
	MAPLE("Maple", "Maple tree", PatchImplementation.TREE, ItemID.MAPLE_LOGS, 40, 9),
	YEW("Yew", "Yew tree", PatchImplementation.TREE, ItemID.YEW_LOGS, 40, 11),
	MAGIC("Magic", "Magic tree", PatchImplementation.TREE, ItemID.MAGIC_LOGS, 40, 13),

	// Fruit tree crops
	APPLE("Apple", "Apple tree", PatchImplementation.FRUIT_TREE, ItemID.COOKING_APPLE, 160, 7, 45, 7),
	BANANA("Banana", "Banana tree", PatchImplementation.FRUIT_TREE, ItemID.BANANA, 160, 7, 45, 7),
	ORANGE("Orange", "Orange tree", PatchImplementation.FRUIT_TREE, ItemID.ORANGE, 160, 7, 45, 7),
	CURRY("Curry", "Curry tree", PatchImplementation.FRUIT_TREE, ItemID.CURRY_LEAF, 160, 7, 45, 7),
	PINEAPPLE("Pineapple", "Pineapple plant", PatchImplementation.FRUIT_TREE, ItemID.PINEAPPLE, 160, 7, 45, 7),
	PAPAYA("Papaya", "Papaya tree", PatchImplementation.FRUIT_TREE, ItemID.PAPAYA_FRUIT, 160, 7, 45, 7),
	PALM("Palm", "Palm tree", PatchImplementation.FRUIT_TREE, ItemID.COCONUT, 160, 7, 45, 7),
	DRAGONFRUIT("Dragonfruit", "Dragonfruit tree", PatchImplementation.FRUIT_TREE, ItemID.DRAGONFRUIT, 160, 7, 45, 7),

	// Cactus
	CACTUS("Cactus", PatchImplementation.CACTUS, ItemID.CACTUS_SPINE, 80, 8, 20, 4),
	POTATO_CACTUS("Potato cactus", "Potato cacti", PatchImplementation.CACTUS, ItemID.POTATO_CACTUS, 10, 8, 5, 7),

	// Hardwood
	TEAK("Teak", PatchImplementation.HARDWOOD_TREE, ItemID.TEAK_LOGS, 640, 8),
	MAHOGANY("Mahogany", PatchImplementation.HARDWOOD_TREE, ItemID.MAHOGANY_LOGS, 640, 9),

	// Anima
	ATTAS("Attas", PatchImplementation.ANIMA, NullItemID.NULL_22940, 640, 9),
	IASOR("Iasor", PatchImplementation.ANIMA, NullItemID.NULL_22939, 640, 9),
	KRONOS("Kronos", PatchImplementation.ANIMA, NullItemID.NULL_22938, 640, 9),

	// Special crops
	SEAWEED("Seaweed", PatchImplementation.SEAWEED, ItemID.GIANT_SEAWEED, 10, 5, 0, 4),
	GRAPE("Grape", PatchImplementation.GRAPES, ItemID.GRAPES, 5, 8, 0, 5),
	MUSHROOM("Mushroom", PatchImplementation.MUSHROOM, ItemID.MUSHROOM, 40, 7, 0, 7),
	BELLADONNA("Belladonna", PatchImplementation.BELLADONNA, ItemID.CAVE_NIGHTSHADE, 80, 5),
	CALQUAT("Calquat", PatchImplementation.CALQUAT, ItemID.CALQUAT_FRUIT, 160, 9, 0, 7),
	SPIRIT_TREE("Spirit tree", PatchImplementation.SPIRIT_TREE, ItemID.SPIRIT_TREE, 320, 13),
	CELASTRUS("Celastrus", "Celastrus tree", PatchImplementation.CELASTRUS, ItemID.BATTLESTAFF, 160, 6, 0, 4),
	REDWOOD("Redwood", "Redwood tree", PatchImplementation.REDWOOD, ItemID.REDWOOD_LOGS, 640, 11),
	HESPORI("Hespori", PatchImplementation.HESPORI, NullItemID.NULL_23044, 640, 4, 0, 2),
	CRYSTAL_TREE("Crystal tree", PatchImplementation.CRYSTAL_TREE, ItemID.CRYSTAL_SHARDS, 80, 7),

	// Compost bins
	EMPTY_COMPOST_BIN("Compost Bin", PatchImplementation.COMPOST, ItemID.COMPOST_BIN, 0, 1, 0, 0), // Dummy produce for the empty state
	COMPOST("Compost", PatchImplementation.COMPOST, ItemID.COMPOST, 40, 3, 0, 15),
	SUPERCOMPOST("Supercompost", PatchImplementation.COMPOST, ItemID.SUPERCOMPOST, 40, 3, 0, 15),
	ULTRACOMPOST("Ultracompost", PatchImplementation.COMPOST, ItemID.ULTRACOMPOST, 0, 3, 0, 15), // Ultra doesn't compost,
	ROTTEN_TOMATO("Rotten Tomato", PatchImplementation.COMPOST, ItemID.ROTTEN_TOMATO, 40, 3, 0, 15),
	EMPTY_BIG_COMPOST_BIN("Big Compost Bin", PatchImplementation.COMPOST, ItemID.COMPOST_BIN, 0, 1, 0, 0), // Dummy produce for the empty state
	BIG_COMPOST("Compost", PatchImplementation.BIG_COMPOST, ItemID.COMPOST, 40, 3, 0, 30),
	BIG_SUPERCOMPOST("Supercompost", PatchImplementation.BIG_COMPOST, ItemID.SUPERCOMPOST, 40, 3, 0, 30),
	BIG_ULTRACOMPOST("Ultracompost", PatchImplementation.BIG_COMPOST, ItemID.ULTRACOMPOST, 0, 3, 0, 30), // Ultra doesn't compost
	BIG_ROTTEN_TOMATO("Rotten Tomato", PatchImplementation.BIG_COMPOST, ItemID.ROTTEN_TOMATO, 40, 3, 0, 30);

	/**
	 * User-visible name
	 */
	private final String name;
	/**
	 * Farming contract names
	 */
	private final String contractName;
	/**
	 * Patch type for the crop
	 */
	private final PatchImplementation patchImplementation;
	/**
	 * User-visible item icon
	 */
	private final int itemID;
	/**
	 * How many minutes per growth tick
	 */
	private final int tickrate;
	/**
	 * How many states this crop has during growth. Typically tickcount+1
	 */
	private final int stages;
	/**
	 * How many minutes to regrow crops, or zero if it doesn't regrow
	 */
	private final int regrowTickrate;
	/**
	 * How many states this crop has during harvest.
	 * This is often called lives.
	 */
	private final int harvestStages;

	Produce(String name, int itemID, int tickrate, int stages, int regrowTickrate, int harvestStages)
	{
		this(name, name, null, itemID, tickrate, stages, regrowTickrate, harvestStages);
	}

	Produce(String name, PatchImplementation patchImplementation, int itemID, int tickrate, int stages, int regrowTickrate, int harvestStages)
	{
		this(name, name, patchImplementation, itemID, tickrate, stages, regrowTickrate, harvestStages);
	}

	Produce(String name, String contractName, PatchImplementation patchImplementation, int itemID, int tickrate, int stages)
	{
		this(name, contractName, patchImplementation, itemID, tickrate, stages, 0, 1);
	}

	Produce(String name, PatchImplementation patchImplementation, int itemID, int tickrate, int stages)
	{
		this(name, name, patchImplementation, itemID, tickrate, stages, 0, 1);
	}

	Produce(String name, int itemID, int tickrate, int stages)
	{
		this(name, name, null, itemID, tickrate, stages, 0, 1);
	}

	@Nullable
	static Produce getByItemID(int itemId)
	{
		for (Produce produce : Produce.values())
		{
			if (produce.getItemID() == itemId)
			{
				return produce;
			}
		}
		return null;
	}

	@Nullable
	static Produce getByContractName(String contractName)
	{
		for (Produce produce : Produce.values())
		{
			if (produce.getContractName().equalsIgnoreCase(contractName))
			{
				return produce;
			}
		}
		return null;
	}
}

package com.homeassistant;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import com.homeassistant.HomeassistantPlugin;

public class HomeassistantPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(HomeassistantPlugin.class);
		RuneLite.main(args);
	}
}
