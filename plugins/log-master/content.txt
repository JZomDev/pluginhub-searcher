package com.logmaster;

import com.google.inject.Provides;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskPointer;
import com.logmaster.domain.TaskTier;
import com.logmaster.domain.TieredTaskList;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import com.logmaster.ui.InterfaceManager;
import com.logmaster.ui.component.TaskOverlay;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.SoundEffectID;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.menus.WidgetMenuOption;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.io.File;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "Collection Log Master"
)
public class LogMasterPlugin extends Plugin {
	private static final String TASK_CHAT_COMMAND = "!tasker";

    private static final int COLLECTION_LOG_SETUP_SCRIPT_ID = 7797;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private LogMasterConfig config;


	@Inject
	private SpriteManager spriteManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	protected TaskOverlay taskOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ChatCommandManager chatCommandManager;

	@Inject
	private TaskService taskService;

	@Inject
	private SaveDataManager saveDataManager;

	@Inject
	private InterfaceManager interfaceManager;

	@Inject
	private ItemManager itemManager;

	private Map<Integer, Integer> chatSpriteMap = new HashMap<>();

	private File playerFile;

	@Override
	protected void startUp() throws Exception
	{
		mouseManager.registerMouseWheelListener(interfaceManager);
		mouseManager.registerMouseListener(interfaceManager);
		interfaceManager.initialise();
		this.taskOverlay.setResizable(true);
		this.overlayManager.add(this.taskOverlay);
		this.taskService.getTaskList();
		// TODO when task save data can be stored and access externally; populate this with other people's data
//		this.clientThread.invoke(this::populateChatSpriteMap);
//		chatCommandManager.registerCommandAsync(TASK_CHAT_COMMAND, this::getTaskCommandData);
	}

	@Override
	protected void shutDown() throws Exception {
		mouseManager.unregisterMouseWheelListener(interfaceManager);
		mouseManager.unregisterMouseListener(interfaceManager);
		this.overlayManager.remove(this.taskOverlay);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals("log-master")) {
			return;
		}
		interfaceManager.updateAfterConfigChange();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
			saveDataManager.getSaveData();
		} else if(gameStateChanged.getGameState().equals(GameState.LOGIN_SCREEN)) {
			saveDataManager.save();
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded e) {
		if(e.getGroupId() == InterfaceID.COLLECTION_LOG) {
			interfaceManager.handleCollectionLogOpen();
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed e) {
		if(e.getGroupId() == InterfaceID.COLLECTION_LOG) {
			interfaceManager.handleCollectionLogClose();
		}
	}

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP_SCRIPT_ID) {
            interfaceManager.handleCollectionLogScriptRan();
        }
    }

	@Subscribe
	public void onGameTick(GameTick event) {
		interfaceManager.updateTaskListBounds();
	}

	public void generateTask() {
		if(this.saveDataManager.getSaveData().currentTask != null || taskService.getTaskList() == null) {
			interfaceManager.disableGenerateTaskButton();
			return;
		}

		this.client.playSoundEffect(SoundEffectID.UI_BOOP);
		List<Task> uniqueTasks = findAvailableTasks();

		if(uniqueTasks.size() <= 0) {
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "No more tasks left. Looks like you win?", "");
			playFailSound();

			return;
		}

		int index = (int) Math.floor(Math.random()*uniqueTasks.size());


		TaskPointer newTaskPointer = new TaskPointer();
		newTaskPointer.setTask(uniqueTasks.get(index));
		newTaskPointer.setTaskTier(getCurrentTier());
		this.saveDataManager.getSaveData().setActiveTaskPointer(newTaskPointer);
		this.saveDataManager.save();
		interfaceManager.rollTask(this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getDescription(), this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getItemID(), config.rollPastCompleted() ? taskService.getForTier(getCurrentTier()) : uniqueTasks);
		log.debug("Task generated: "+this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getDescription());

		this.saveDataManager.save();
	}

	public void completeTask() {
		completeTask(saveDataManager.getSaveData().getActiveTaskPointer().getTask().getId(), saveDataManager.getSaveData().getActiveTaskPointer().getTaskTier());
	}

	public void completeTask(int taskID, TaskTier tier) {
		this.client.playSoundEffect(SoundEffectID.UI_BOOP);

		if (saveDataManager.getSaveData().getProgress().get(tier).contains(taskID)) {
			saveDataManager.getSaveData().getProgress().get(tier).remove(taskID);
		} else {
			addCompletedTask(taskID, tier);
			if (saveDataManager.getSaveData().getActiveTaskPointer() != null && taskID == saveDataManager.getSaveData().getActiveTaskPointer().getTask().getId()) {
				nullCurrentTask();
			}
		}
		this.saveDataManager.save();
		interfaceManager.completeTask();
	}

	public void nullCurrentTask() {
		this.saveDataManager.getSaveData().setActiveTaskPointer(null);
		this.saveDataManager.save();
		interfaceManager.clearCurrentTask();
	}

	public static int getCenterX(Widget window, int width) {
		return (window.getWidth() / 2) - (width / 2);
	}

	public static int getCenterY(Widget window, int height) {
		return (window.getHeight() / 2) - (height / 2);
	}

	public void addCompletedTask(int taskID, TaskTier tier) {
		this.saveDataManager.getSaveData().getProgress().get(tier).add(taskID);
		this.saveDataManager.save();
	}

	public TaskTier getCurrentTier() {
		TaskTier[] allTiers = TaskTier.values();
		int firstVisibleTier = 0;
		for (int i = 0; i < allTiers.length; i++) {
			if (config.hideBelow() == allTiers[i]) {
				firstVisibleTier = i;
			}
		}

		Map<TaskTier, Integer> tierPercentages = taskService.completionPercentages(saveDataManager.getSaveData());
		for (int i = firstVisibleTier; i < allTiers.length; i++) {
			TaskTier tier = allTiers[i];
			if (tierPercentages.get(tier) < 100) {
				return tier;
			}
		}


		return TaskTier.MASTER;
	}

	public TaskTier getSelectedTier() {
		return this.saveDataManager.getSaveData().getSelectedTier();
	}

	public List<Task> findAvailableTasks() {
		return taskService.getTaskList().getForTier(getCurrentTier()).stream().filter(t -> !this.saveDataManager.getSaveData().getProgress().get(getCurrentTier()).contains(t.getId())).collect(Collectors.toList());
	}

	public void playFailSound() {
		client.playSoundEffect(2277);
	}


	@Provides
	LogMasterConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LogMasterConfig.class);
	}

	public void visitFaq() {
		LinkBrowser.browse("https://docs.google.com/document/d/e/2PACX-1vTHfXHzMQFbt_iYAP-O88uRhhz3wigh1KMiiuomU7ftli-rL_c3bRqfGYmUliE1EHcIr3LfMx2UTf2U/pub");
	}
}

package com.logmaster.util;

import com.google.gson.Gson;

import java.io.InputStream;
import java.io.InputStreamReader;

public class FileUtils {


    /**
     * Loads a definition resource from a JSON file
     *
     * @param classType the class into which the data contained in the JSON file will be read into
     * @param resource  the name of the resource (file name)
     * @param gson      a reference to the GSON object
     * @param <T>       the class type
     * @return the data read from the JSON definition file
     */
    public static <T> T loadDefinitionResource(Class<T> classType, String resource, Gson gson) {
        // Load the resource as a stream and wrap it in a reader
        InputStream resourceStream = classType.getResourceAsStream(resource);
        assert resourceStream != null;
        InputStreamReader definitionReader = new InputStreamReader(resourceStream);

        // Load the objects from the JSON file
        return gson.fromJson(definitionReader, classType);
    }
}

package com.logmaster;


package com.logmaster.chat;

import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.ItemComposition;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Singleton
public class ChatProcessor {

    @Inject
    private TaskService taskService;

    @Inject
    private ItemManager itemManager;

    @Inject
    private Client client;

    @Inject
    private SaveDataManager saveDataManager;

    @Inject
    private LogMasterPlugin plugin;

    private Map<Integer, Integer> chatSpriteMap = new HashMap<>();

    private void populateChatSpriteMap() {
        Set<Integer> itemIdsToLoad = new HashSet<>();
        for (TaskTier tier : TaskTier.values()) {
            itemIdsToLoad.addAll(taskService.getForTier(tier).stream().map(Task::getItemID).collect(Collectors.toList()));
        }
        List<Integer> itemIdsToLoadOrdered = new ArrayList<>(itemIdsToLoad);
        final IndexedSprite[] modIcons = client.getModIcons();

        final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + itemIdsToLoadOrdered.size());
        int modIconIdx = modIcons.length;

        for (int i = 0; i < itemIdsToLoadOrdered.size(); i++)
        {
            final Integer itemId = itemIdsToLoadOrdered.get(i);
            final ItemComposition itemComposition = itemManager.getItemComposition(itemId);
            final BufferedImage image = ImageUtil.resizeImage(itemManager.getImage(itemComposition.getId()), 18, 16);
            final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);
            final int spriteIndex = modIconIdx + i;

            newModIcons[spriteIndex] = sprite;
            chatSpriteMap.put(itemId, spriteIndex);
        }

        client.setModIcons(newModIcons);
    }

    public void getTaskCommandData(ChatMessage chatMessage, String message) {
//		if (!config.taskChatCommand()) {
//			return;
//		}

        Integer percentage = taskService.completionPercentages(saveDataManager.getSaveData()).get(plugin.getCurrentTier());

        ChatMessageBuilder chatMessageBuilder =
                new ChatMessageBuilder()
                        .append(ChatColorType.NORMAL)
                        .append("Progress: ")
                        .append(ChatColorType.HIGHLIGHT)
                        .append(percentage + "% " + plugin.getCurrentTier().displayName);

        if (saveDataManager.getSaveData().getActiveTaskPointer() != null) {
            chatMessageBuilder
                    .append(ChatColorType.NORMAL)
                    .append(" Current task: ")
                    .img(chatSpriteMap.getOrDefault(saveDataManager.getSaveData().getActiveTaskPointer().getTask().getItemID(), Integer.MIN_VALUE))
                    .append(ChatColorType.HIGHLIGHT)
                    .append(saveDataManager.getSaveData().getActiveTaskPointer().getTask().getDescription());
        } else {
            chatMessageBuilder
                    .append(ChatColorType.NORMAL)
                    .append(" No current task.");
        }

        final String response = chatMessageBuilder.build();

        final MessageNode messageNode = chatMessage.getMessageNode();
        messageNode.setRuneLiteFormatMessage(response);
        client.refreshChat();
    }
}

package com.logmaster.persistence;

import com.google.gson.reflect.TypeToken;
import com.logmaster.domain.SaveData;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskPointer;
import com.logmaster.domain.TaskTier;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.RuneLite;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.slayer.SlayerConfig;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.File;
import java.util.HashSet;
import java.util.Scanner;

import static com.logmaster.LogMasterConfig.CONFIG_GROUP;
import static com.logmaster.LogMasterConfig.SAVE_DATA_KEY;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Singleton
@Slf4j
public class SaveDataManager {

    private static final String DATA_FOLDER_NAME = "generate-task";

    @Inject
    private Client client;

    @Inject
    private ConfigManager configManager;

    private SaveData saveData;

    public SaveData getSaveData() {
        saveData = loadRLProfileSaveData();
        if (saveData == null) {
            SaveData localSave = loadLocalPlayerSaveData();
            if (localSave != null) {
                saveData = localSave;
            } else {
                saveData = initialiseSaveData();
            }
        }
        return saveData;
    }

    public void save() {
        String json = GSON.toJson(saveData);
        configManager.setRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY, json);
    }

    public Task currentTask() {
        if (getSaveData().getActiveTaskPointer() == null) {
            return null;
        }
        return getSaveData().getActiveTaskPointer().getTask();
    }

    private SaveData loadRLProfileSaveData() {
        String saveDataJson = configManager.getRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY, String.class);
        if (saveDataJson == null) {
            return null;
        }
        try {
            return GSON.fromJson(saveDataJson, new TypeToken<SaveData>() {}.getType());
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private SaveData loadLocalPlayerSaveData() {
        File playerFolder = new File(RuneLite.RUNELITE_DIR, DATA_FOLDER_NAME);
        if (!playerFolder.exists()) {
            return null;
        }
        File playerFile = new File(playerFolder, client.getAccountHash() + ".txt");
        if (!playerFile.exists()) {
            return null;
        }
        try {
            String json = new Scanner(playerFile).useDelimiter("\\Z").next();
            SaveData loaded = GSON.fromJson(json, new TypeToken<SaveData>() {}.getType());
            for (TaskTier loopTier : TaskTier.values()) {
                if (!loaded.getProgress().containsKey(loopTier)) {
                    loaded.getProgress().put(loopTier, new HashSet<>());
                }
            }
            // Can get rid of this eventually
            if (!loaded.getCompletedTasks().isEmpty()) {
                loaded.getProgress().get(TaskTier.MASTER).addAll(loaded.getCompletedTasks().keySet());
            }
            if (loaded.currentTask != null) {
                TaskPointer taskPointer = new TaskPointer();
                taskPointer.setTask(loaded.currentTask);
                taskPointer.setTaskTier(TaskTier.MASTER);
                loaded.setActiveTaskPointer(taskPointer);
                loaded.currentTask = null;
            }
            return loaded;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    private SaveData initialiseSaveData() {
        SaveData created = new SaveData();
        for (TaskTier loopTier : TaskTier.values()) {
            if (!created.getProgress().containsKey(loopTier)) {
                created.getProgress().put(loopTier, new HashSet<>());
            }
        }
        return created;
    }
}

package com.logmaster.ui.generic;

import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a graphic display component, effectively just a game sprite.
 * @author Antipixel
 */
public class UIGraphic extends UIComponent
{
	/**
	 * Constructs a new graphic component
	 * @param widget the underlying widget
	 */
	public UIGraphic(Widget widget)
	{
		super(widget);
	}

	/**
	 * Sets the sprite to display on the component
	 * @param spriteID the sprite ID
	 */
	public void setSprite(int spriteID)
	{
		this.getWidget().setSpriteId(spriteID);
	}

	/**
	 * Sets the sprite to display on the component
	 * @param itemID the item ID
	 */
	public void setItem(int itemID)
	{
		this.getWidget().setItemId(itemID);
	}
}

package com.logmaster.ui.generic.dropdown;

import com.logmaster.ui.generic.ComponentEventListener;
import com.logmaster.ui.generic.MenuAction;
import com.logmaster.ui.generic.UIComponent;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.FontID;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.*;

@Slf4j
public class UIDropdownOption extends UIComponent {
    private static final int TEXT_COLOR_INACTIVE = 0xFF981F;
    private static final int TEXT_COLOR_HIGHLIGHT = 0xFFFFFF;
    private static final int TEXT_COLOR_ACTIVE = 0xC8C8C8;

    private static final int TEXT_OPACITY_INACTIVE = 0;
    private static final int TEXT_OPACITY_ACTIVE = 128;

    private static final int BG_OPACITY_INACTIVE = 255;
    private static final int BG_OPACITY_ACTIVE = 230;

    private static final String DEFAULT_ACTION_LABEL = "Enable";

    @Getter
    protected final boolean managed;

    @Getter
    private boolean enabled = false;

    @Getter
    protected String text;

    @Getter
    protected String actionText;

    protected final Widget bgWidget;

	protected final Widget labelWidget;

	@Setter
	private ComponentEventListener<UIDropdownOption> enabledListener;

	public UIDropdownOption(Widget layerWidget) {
        super(layerWidget);
        this.managed = true;
        this.bgWidget = this.widget.createChild(WidgetType.RECTANGLE);
        this.labelWidget = this.widget.createChild(WidgetType.TEXT);

        this.setup();
        this.setupManaged();
	}

	public UIDropdownOption(Widget bgWidget, Widget labelWidget) {
        super(labelWidget);
        this.managed = false;
        this.bgWidget = bgWidget;
        this.labelWidget = labelWidget;

        this.setup();
	}

    private void setup() {
        this.setText(this.labelWidget.getText());
        this.setActionText(DEFAULT_ACTION_LABEL);

        // preserve current action label if possible
        String[] originalActions = this.labelWidget.getActions();
        if (originalActions != null && originalActions.length > 0) {
            this.setActionText(originalActions[0]);
        }

        this.enabled = this.bgWidget.getOpacity() < BG_OPACITY_INACTIVE;
        this.updateStatefulStyles();
    }

    private void setupManaged() {
        this.widget.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);

        this.bgWidget.setFilled(true);
        this.bgWidget.setTextColor(0xFFFFFF);
        this.bgWidget.setWidthMode(WidgetSizeMode.MINUS);
        this.bgWidget.setHeightMode(WidgetSizeMode.MINUS);

        this.labelWidget.setTextShadowed(true);
        this.labelWidget.setFontId(FontID.PLAIN_12);
        this.labelWidget.setWidthMode(WidgetSizeMode.MINUS);
        this.labelWidget.setHeightMode(WidgetSizeMode.MINUS);
        this.labelWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
        this.labelWidget.setYTextAlignment(WidgetTextAlignment.CENTER);

        this.setActionText(DEFAULT_ACTION_LABEL);
        this.enabled = false;
        this.updateStatefulStyles();
    }

    @Override
    @Deprecated
    public void addAction(String action, MenuAction callback) {
        throw new RuntimeException("Cannot add actions to this component; use .setActionLabel() to rename single action");
    }

    @Override
    public void setName(String name) {
        this.bgWidget.setName(name + "-bg");
        this.labelWidget.setName(name + "-label");
    }

    public void setText(String text) {
        this.text = text;
        this.labelWidget.setText(text);
    }

    public void setActionText(String actionText) {
        this.actionText = actionText;

        this.actions.clear();
        super.addAction(this.actionText, () -> this.setEnabled(true));
    }

    public void setEnabled(boolean enabled) {
        // prevents raising the events unnecessarily
        if (this.enabled == enabled) return;

        this.enabled = enabled;

        if (this.enabled && this.enabledListener != null) {
            this.enabledListener.onComponentEvent(this);
        }

        this.updateStatefulStyles();
    }

    @Override
    protected void onMouseHover(ScriptEvent e) {
        super.onMouseHover(e);

        if (this.isEnabled()) return;
        this.labelWidget.setTextColor(TEXT_COLOR_HIGHLIGHT);
    }

    @Override
    protected void onMouseLeave(ScriptEvent e) {
        super.onMouseLeave(e);

        if (this.isEnabled()) return;
        this.labelWidget.setTextColor(TEXT_COLOR_INACTIVE);
    }

    private void updateStatefulStyles() {
        if (this.isEnabled()) {
            this.bgWidget.setOpacity(BG_OPACITY_ACTIVE);
            this.labelWidget.setTextColor(TEXT_COLOR_ACTIVE);
            this.labelWidget.setOpacity(TEXT_OPACITY_ACTIVE);
        } else {
            this.bgWidget.setOpacity(BG_OPACITY_INACTIVE);
            this.labelWidget.setTextColor(TEXT_COLOR_INACTIVE);
            this.labelWidget.setOpacity(TEXT_OPACITY_INACTIVE);
        }

        this.revalidate();
    }

    public void revalidate() {
        super.revalidate();
        this.bgWidget.revalidate();
        this.labelWidget.revalidate();
    }
}

package com.logmaster.ui.generic.dropdown;

import com.logmaster.ui.generic.ComponentEventListener;
import com.logmaster.ui.generic.UIComponent;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import java.util.*;

@Slf4j
public class UIDropdown extends UIComponent {
    private static final int BORDER_WIDTH = 6;

    // TODO: find a better way to identify our widgets
    public static final String WIDGET_NAME = "clogmaster";

    private final List<UIDropdownOption> options;

	@Setter
	private ComponentEventListener<UIDropdownOption> optionEnabledListener;

	public UIDropdown(Widget widget) {
		super(widget, Set.of(WidgetType.LAYER));
        this.options = new ArrayList<>();
        this.setup();
	}

    private void setup() {
        Widget[] children = this.widget.getChildren();
        if (children == null) {
            return;
        }

        for (Widget c : children) {
            if (!c.getName().isEmpty()) {
                continue;
            }

            if (c.getType() == WidgetType.RECTANGLE) {
                // we assume every background (rectangle) widget is
                // directly succeeded by the matching text widget
                Widget textWidget = children[c.getIndex() + 1];
                UIDropdownOption option = new UIDropdownOption(c, textWidget);
                option.setEnabledListener(this::onOptionEnabled);
                this.options.add(option);
            }
        }
    }

    public void cleanup() {
        Widget tabContainer = this.widget;
        Widget[] children = tabContainer.getChildren();
        if (children == null || children.length == 0) {
            return;
        }

        for (UIDropdownOption opt : this.options) {
            if (!opt.isManaged()) continue;

            children[opt.getWidget().getIndex()] = null;
        }

        Widget[] newChildren = Arrays.stream(children)
            .filter(Objects::nonNull)
            .toArray(Widget[]::new);

        Widget[] nzNewChildren = Arrays.copyOf(children, newChildren.length);
        System.arraycopy(newChildren, 0, nzNewChildren, 0, newChildren.length);

        tabContainer.setChildren(nzNewChildren);
        tabContainer.revalidate();

        resizeTabsContainer();
    }

    public UIDropdownOption getEnabledOption() {
        for (UIDropdownOption opt : this.options) {
            if (opt.isEnabled()) {
                return opt;
            }
        }

        return null;
    }

    public void setEnabledOption(String text) {
        for (UIDropdownOption opt : this.options) {
            if (opt.getText().equals(text)) {
                opt.setEnabled(true);
            }
        }
    }

    public void addOption(String text, String actionText) {
        Widget tabContainer = this.widget;
        Widget[] children = tabContainer.getChildren();
        if (children == null || children.length == 0) {
            return;
        }

        Widget lastOption = this.options.get(this.options.size() - 1).getWidget();

        UIDropdownOption newOption = new UIDropdownOption(tabContainer.createChild(WidgetType.LAYER));
        newOption.setName(WIDGET_NAME);
        newOption.setSize(lastOption.getOriginalWidth(), lastOption.getOriginalHeight());
        newOption.setPosition(lastOption.getOriginalX(), lastOption.getOriginalY() + lastOption.getOriginalHeight());
        newOption.setText(text);
        newOption.setActionText(actionText);
        newOption.revalidate();
        newOption.setEnabledListener(this::onOptionEnabled);

        this.options.add(newOption);

        resizeTabsContainer();
    }

    void onOptionEnabled(UIDropdownOption src) {
        for (UIDropdownOption ui : this.options) {
            if (ui == src) continue;
            ui.setEnabled(false);
        }

        // close dropdown
        this.widget.setHidden(true)
            .revalidate();

        if (this.optionEnabledListener != null) {
            this.optionEnabledListener.onComponentEvent(src);
        }
    }

    void resizeTabsContainer() {
        Widget tabContainer = this.widget;
        Widget[] children = tabContainer.getChildren();
        if (children == null) {
            return;
        }

        Widget lastOption = this.options.get(this.options.size() - 1).getWidget();

        tabContainer.setOriginalHeight(lastOption.getOriginalY() + lastOption.getOriginalHeight() + BORDER_WIDTH);
        tabContainer.revalidate();

        // recalculates the position and sizes for the border and background widgets
        for (Widget c : children) {
            c.revalidate();
        }
    }
}

package com.logmaster.ui.generic;

import lombok.Getter;

import java.util.ArrayList;
import java.util.List;

/**
 * A group of UIComponents
 * @author Antipixel
 */
public class UIPage
{
	@Getter
	private boolean visible;
	private List<UIComponent> components;

	/**
	 * Constructs a new UI page
	 */
	public UIPage()
	{
		this.components = new ArrayList<>();
	}

	/**
	 * Sets the visibility for all the components in the page
	 * @param visibility true for visible, false for hidden
	 */
	public void setVisibility(boolean visibility)
	{
		this.visible = visibility;
		// Update the visibility for each of the components
		this.components.forEach(c -> c.setVisibility(visibility));
	}

	/**
	 * Adds a UI component to the page
	 * @param component the component to add
	 */
	public void add(UIComponent component)
	{
		this.components.add(component);
	}

	/**
	 * Removes a UI component from the page
	 * @param component the component to remove
	 */
	public void remove(UIComponent component)
	{
		this.components.remove(component);
	}
}

package com.logmaster.ui.generic;

/**
 * A listener interface for receiving UI component events
 * @author Antipixel
 */
public interface ComponentEventListener<T extends UIComponent>
{
	/**
	 * Invoked upon a component event
	 * @param src the source component responsible for the event
	 */
	void onComponentEvent(T src);
}


package com.logmaster.ui.generic;

import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;

import java.awt.*;

/**
 * This class wraps a game widget and gives it the functionality of
 * a text label component, with basic control over text colour and font.
 * @author Antipixel
 */
public class UILabel extends UIComponent
{
	/**
	 * Constructs a new label component
	 * @param labelWidget the underlying widget
	 */
	public UILabel(Widget labelWidget)
	{
		super(labelWidget);

		// Set default font and text colour
		this.setFont(FontID.PLAIN_11);
		this.setColour(Color.WHITE.getRGB());

		// Set the alignment to centre and enable text shadowing
		labelWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setTextShadowed(true);
	}

	/**
	 * Sets the display text of the label
	 * @param text the display text
	 */
	public void setText(String text)
	{

		this.getWidget().setText(text);
	}

	/**
	 * Sets the font of the label
	 * @param fontID the font ID, specified in {@link FontID}
	 */
	public void setFont(int fontID)
	{
		this.getWidget().setFontId(fontID);
	}

	/**
	 * Sets the colour of the label text
	 * @param colour the RGB colour
	 */
	public void setColour(int colour)
	{
		this.getWidget().setTextColor(colour);
	}
}

package com.logmaster.ui.generic;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;

/**
 * Functionally identical to the UI Button, except the opacity
 * of the widget is dimmed when the mouse moves over the component
 * @author Antipixel
 */
public class UIFadeButton extends UIButton
{
	private static final float FADE_OPACITY = 0.75f;
	private static final float DEFAULT_OPACITY = 1.0f;

	public UIFadeButton(Widget widget)
	{
		super(widget);
	}

	@Override
	protected void onMouseHover(ScriptEvent e)
	{
		super.onMouseHover(e);

		// Fade the widget
		this.setOpacity(FADE_OPACITY);
	}

	@Override
	protected void onMouseLeave(ScriptEvent e)
	{
		super.onMouseLeave(e);

		// Set the widget back to full opacity
		this.setOpacity(DEFAULT_OPACITY);
	}
}

package com.logmaster.ui.generic;

/**
 * A listener interface for receiving menu actions
 * @author Antipixel
 */
public interface MenuAction
{
	/**
	 * Invoked upon selection of the menu action that is is bound to
	 */
	void onMenuAction();
}

package com.logmaster.ui.generic;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps two widgets, one a sprite and one text, and gives them the
 * functionality of a checkbox component. A listener can be added to the checkbox
 * which triggers upon the switching of the checkbox state between check and unchecked.
 * @author Antipixel
 */
public class UICheckBox extends UIComponent
{
	private static final int LABEL_COL_DEFAULT = 0xFF981F;
	private static final int LABEL_COL_HOVER = 0xFFFFFF;
	private static final int LABEL_WIDTH = 89;
	private static final int LABEL_HEIGHT = 18;

	private static final int SPRITEID_CHECKBOX_UNCHECKED_STD = 1215;
	private static final int SPRITEID_CHECKBOX_CHECKED_STD = 1217;
	private static final int SPRITEID_CHECKBOX_UNCHECKED_HOV = 1218;
	private static final int SPRITEID_CHECKBOX_CHECKED_HOV = 1220;
	private static final int CHECKBOX_SIZE = 16;

	private static final String OPTION_TOGGLE = "Toggle";

	private UILabel label;
	private UIGraphic checkbox;

	@Getter
	private boolean enabled;
	private boolean hovering;

	@Setter
	private ComponentEventListener<UICheckBox> toggleListener;

	/**
	 * Constructs a new checkbox component
	 * @param boxIcon the checkbox graphic widget
	 * @param labelWidget the checkbox label widget
	 */
	public UICheckBox(Widget boxIcon, Widget labelWidget)
	{
		super(boxIcon);

		this.enabled = false;
		this.hovering = false;

		// Wrap the widget in a label component, set the
		// dimension, colour and attach the listeners
		this.label = new UILabel(labelWidget);
		this.label.setSize(LABEL_WIDTH, LABEL_HEIGHT);
		this.label.setColour(LABEL_COL_DEFAULT);
		this.label.setOnHoverListener(this::onLabelHover);
		this.label.setOnLeaveListener(this::onLabelLeave);
		this.label.addAction(OPTION_TOGGLE, this::onCheckboxToggled);

		this.checkbox = new UIGraphic(boxIcon);
		this.checkbox.addAction(OPTION_TOGGLE, this::onCheckboxToggled);
		this.checkbox.setOnHoverListener(e -> onLabelHover(label));
		this.checkbox.setOnLeaveListener(e -> onLabelLeave(label));

		// Resize and update the sprite for the checkbox widget
		this.updateCheckboxSprite();
		this.setSize(CHECKBOX_SIZE, CHECKBOX_SIZE);
	}

	/**
	 * Called upon the mouse hovering over the label component
	 * @param src the label component
	 */
	private void onLabelHover(UIComponent src)
	{
		// Update the hovering state
		this.hovering = true;

		// Update the label colour
		UILabel label = (UILabel) src;
		label.setColour(LABEL_COL_HOVER);

		// Make sure the checkbox sprite is up to date
		this.updateCheckboxSprite();
	}

	/**
	 * Called upon the mouse leaving the label component
	 * @param src the label component
	 */
	private void onLabelLeave(UIComponent src)
	{
		// Update the hovering state
		this.hovering = false;

		// Update the label colour
		UILabel label = (UILabel) src;
		label.setColour(LABEL_COL_DEFAULT);

		// Make sure the checkbox sprite is up to date
		this.updateCheckboxSprite();
	}

	@Override
	public void setX(int x)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setX(x);
		this.label.setX(x);
	}

	@Override
	public void setY(int y)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setY(y);
		this.label.setY(y);
	}

	@Override
	public void setName(String name)
	{
		// Set the name of the label instead
		this.label.setName(name);
	}

	/**
	 * Called upon the toggle menu action being selected on the checkbox component
	 */
	private void onCheckboxToggled()
	{
		// Switch the checked state
		this.setEnabled(!enabled);

		// If there's a toggle listener registered, call it
		if (this.toggleListener != null)
			this.toggleListener.onComponentEvent(this);
	}

	/**
	 * Updates the sprite for the checkbox, depending on whether the checkbox
	 * is enabled or disabled, or if the mouse is hovering over it
	 */
	private void updateCheckboxSprite()
	{
		// Get both standard and hovering sprites for the current enable state
		int stdSprite = enabled ? SPRITEID_CHECKBOX_CHECKED_STD : SPRITEID_CHECKBOX_UNCHECKED_STD;
		int hovSprite = enabled ? SPRITEID_CHECKBOX_CHECKED_HOV : SPRITEID_CHECKBOX_UNCHECKED_HOV;

		// Apply it to the checkbox widget, depending on whether the mouse is hovering
		this.getWidget().setSpriteId(this.hovering ? hovSprite : stdSprite);
	}

	/**
	 * Sets the state of the checkbox, checked or unchecked
	 * @param enabled true for checked, false for unchecked
	 */
	public void setEnabled(boolean enabled)
	{
		// Set the new state
		this.enabled = enabled;

		// Update the sprite
		this.updateCheckboxSprite();
	}

	/**
	 * Sets the text of the checkbox label
	 * @param text the label text
	 */
	public void setText(String text)
	{
		this.label.setText(text);
	}
}

package com.logmaster.ui.generic;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * UI Component classes allow for complex user interface functionality by
 * wrapping the gaming widget and carefully controlling its behaviour
 * @author Antipixel
 */
public abstract class UIComponent
{
	private static final int MAX_OPACITY = 255;
	private static final String BTN_NAME_FORMAT = "<col=ff9040>%s</col>";

	@Getter
	protected Widget widget;

	/* Actions and events */
	protected List<MenuAction> actions;

	@Setter
	private ComponentEventListener<UIComponent> hoverListener;

	@Setter
	private ComponentEventListener<UIComponent> leaveListener;

	@Setter
	private ComponentEventListener<UIComponent> mousePressListener;

	@Setter
	private ComponentEventListener<UIComponent> mouseDragListener;

	@Setter
	private ComponentEventListener<UIComponent> mouseReleaseListener;

	/**
	 * Constructs a new UIComponent
	 * @param widget the underlying game widget
	 */
	public UIComponent(Widget widget)
	{
		this.widget = widget;

		// Assign the event listeners to the widget
		this.widget.setOnOpListener((JavaScriptCallback) this::onActionSelected);
		this.widget.setOnMouseOverListener((JavaScriptCallback) this::onMouseHover);
		this.widget.setOnMouseLeaveListener((JavaScriptCallback) this::onMouseLeave);
		this.widget.setHasListener(true);

		this.actions = new ArrayList<>();
	}

	public UIComponent(Widget widget, Set<Integer> allowedTypes) {
		this(widget);

		if (!allowedTypes.contains(widget.getType())) {
			String msg = String.format("Incompatible widget's type given; %s given, %d expected", allowedTypes, widget.getType());
			throw new RuntimeException(msg);
		}
	}

	/**
	 * Adds an action option to the component's menu
	 * @param action the action name
 	 * @param callback the callback event, which is trigger upon the
	 *                 selection of this menu option
	 */
	public void addAction(String action, MenuAction callback)
	{
		this.widget.setAction(actions.size(), action);
		this.actions.add(callback);
	}

	/**
	 * Triggered upon the selection of menu option
	 * @param e the script event
	 */
	protected void onActionSelected(ScriptEvent e)
	{
		// If there's no actions specified, ignore
		if (this.actions.isEmpty())
			return;

		// Get the action event object for this menu option
		MenuAction actionEvent = this.actions.get(e.getOp() - 1);

		// Call the action listener for this option
		actionEvent.onMenuAction();
	}

	/**
	 * Triggered upon the mouse entering the component
	 * @param e the script event
	 */
	protected void onMouseHover(ScriptEvent e)
	{
		// If a hover event is specified, trigger it
		if (this.hoverListener != null)
			this.hoverListener.onComponentEvent(this);
	}

	/**
	 * Triggered upon the mouse leaving the component
	 * @param e the script event
	 */
	protected void onMouseLeave(ScriptEvent e)
	{
		// If a leave event is specified, trigger it
		if (this.leaveListener != null)
			this.leaveListener.onComponentEvent(this);
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * hovering over the widget
	 * @param listener the listener
	 */
	public void setOnHoverListener(ComponentEventListener<UIComponent> listener)
	{
		this.hoverListener = listener;
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * exiting from over the widget
	 * @param listener the listener
	 */
	public void setOnLeaveListener(ComponentEventListener<UIComponent> listener)
	{
		this.leaveListener = listener;
	}

	/**
	 * Sets the name of the component widget
	 * @param name the component name
	 */
	public void setName(String name)
	{
		this.widget.setName(String.format(BTN_NAME_FORMAT, name));
	}

	/**
	 * Sets the component size
	 * @param width the component width
	 * @param height the component height
	 */
	public void setSize(int width, int height)
	{
		this.widget.setOriginalWidth(width);
		this.widget.setOriginalHeight(height);
	}

	public void setSizeMode(int widthMode, int heightMode)
	{
		this.widget.setWidthMode(widthMode);
		this.widget.setHeightMode(heightMode);
	}

	/**
	 * Sets the position of the component, relative
	 * to the parent layer widget
	 * @param x the x position
	 * @param y the y position
	 */
	public void setPosition(int x, int y)
	{
		this.setX(x);
		this.setY(y);
	}

	/**
	 * Sets the X position of the component, relative
	 * to the parent layer
	 * @param x the x position
	 */
	public void setX(int x)
	{
		this.widget.setOriginalX(x);
	}

	/**
	 * Sets the Y position of the component, relative
	 * to the parent layer
	 * @param y the x position
	 */
	public void setY(int y)
	{
		this.widget.setOriginalY(y);
	}

	/**
	 * Gets the X position of the component, relative
	 * to the the parent layer
	 * @return the x position
	 */
	public int getX()
	{
		return this.widget.getOriginalX();
	}

	/**
	 * Gets the Y position of the component, relative
	 * to the the parent layer
	 * @return the y position
	 */
	public int getY()
	{
		return this.widget.getOriginalY();
	}


	/**
	 * Sets the visibility of the component
	 * @param visible true for visible, false for hidden
	 */
	public void setVisibility(boolean visible)
	{
		this.widget.setHidden(!visible);
	}

	/**
	 * Sets the opacity of the widget
	 * @param opacity the opacity value. Expects a value
	 *                between 0.0 (transparent) and 1.0 (opaque)
	 */
	public void setOpacity(float opacity)
	{
		// Cap the opacity to 1.0
		if (opacity > 1.0)
			opacity = 1.0f;

		// Invert the percentage
		float percentage = 1.0f - opacity;

		// Convert the percentage value to a 0-255 integer
		this.widget.setOpacity((int)(percentage * MAX_OPACITY));
	}

	/**
	 * Gets the opacity of the widget
	 * @return an opacity value between 0.0 (transparent) and 1.0 (opaque)
	 */
	public float getOpacity()
	{
		// Convert the opacity to a percentage
		float opacity = (float)this.widget.getOpacity() / MAX_OPACITY;

		// Invert the percentage
		return 1.0f - opacity;
	}

	public void clearActions() {
		actions.clear();
	}

	public void revalidate() {
		this.widget.revalidate();
	}
}

package com.logmaster.ui.generic;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a button, with the option of a second sprite shown on hover
 * @author Antipixel
 */
public class UIButton extends UIComponent
{
	private int spriteStandard;
	private int spriteHover;

	/**
	 * Constructs a new button component
	 * @param widget the underlying widget
	 */
	public UIButton(Widget widget)
	{
		super(widget);

		// Blank the sprites
		this.spriteStandard = -1;
		this.spriteHover = -1;
	}

	@Override
	protected void onMouseHover(ScriptEvent e)
	{
		// Call the parent method
		super.onMouseHover(e);

		// Update the sprite
		this.getWidget().setSpriteId(this.spriteHover);
	}

	@Override
	protected void onMouseLeave(ScriptEvent e)
	{
		// Call the parent method
		super.onMouseLeave(e);

		// Update the sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	/**
	 * Sets the button sprite for both standard and hover
	 * @param standard the standard sprite id
	 * @param hover the sprite to display on hover
	 */
	public void setSprites(int standard, int hover)
	{
		this.spriteStandard = standard;
		this.spriteHover = hover;

		// Update the widgets sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	/**
	 * Sets the sprite for the button, for buttons
	 * without a sprite for hovering state
	 * @param standard the button sprite
	 */
	public void setSprites(int standard)
	{
		this.setSprites(standard, standard);
	}
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.ui.InterfaceManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Image;

@Singleton
public class TaskOverlay extends Overlay {

    private static final Dimension EMPTY = new Dimension(0, 0);

    private static final int WIDTH_ADDITION = 51;
    private static final int MIN_HEIGHT = 46;

    private static final float OUTER_COLOR_OFFSET = 0.8f;
    private static final float INNER_COLOR_OFFSET = 1.2f;
    private static final float ALPHA_OFFSET = 1.4f;

    private static final int MAX_BYTE = 255;

    @Inject
    private LogMasterPlugin plugin;

    @Inject
    private LogMasterConfig config;

    @Inject
    private RuneLiteConfig runeLiteConfig;

    @Inject
    private ItemManager itemManager;

    @Inject
    private InterfaceManager interfaceManager;

    @Inject
    private SaveDataManager saveDataManager;

    @Override
    public Dimension render(Graphics2D g) {
        try {
            Task currentTask = saveDataManager.currentTask();
            if (!config.displayCurrentTaskOverlay() || currentTask == null || interfaceManager.isDashboardOpen()) {
                return EMPTY;
            }

            Image icon = itemManager.getImage(currentTask.getItemID());
            String task = currentTask.getDescription();


            FontMetrics fm = g.getFontMetrics();

            int width = fm.stringWidth(task) + WIDTH_ADDITION;
            int height = MIN_HEIGHT;

            Color border = outsideColor(this.runeLiteConfig.overlayBackgroundColor());

            g.setColor(this.runeLiteConfig.overlayBackgroundColor());
            g.fillRect(0, 0, width, height);
            g.setColor(border);
            g.drawRect(0, 0, width, height);

//            int textX = 46;
            int textX = width - fm.stringWidth(task) - 5;
            int textY = 30;

            g.setFont(g.getFont().deriveFont(16f));
            g.setColor(Color.BLACK);
            g.drawString(task, textX + 1, textY + 1);
            g.setColor(Color.WHITE);
            g.drawString(task, textX, textY);

            int iconWidth = icon.getWidth(null);
            int iconHeight = icon.getHeight(null);

            g.drawImage(icon, 5 + 18 - (iconWidth / 2), 5 + 18 - (iconHeight / 2), iconWidth, iconHeight, null);
            return new Dimension(width, height);
        } catch (Throwable t) {
            t.printStackTrace();
            return EMPTY;
        }
    }

    private Color outsideColor(Color base) {
        return new Color(
                Math.round(base.getRed() * OUTER_COLOR_OFFSET),
                Math.round(base.getGreen() * OUTER_COLOR_OFFSET),
                Math.round(base.getBlue() * OUTER_COLOR_OFFSET),
                Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
        );
    }

    private Color innerColor(Color base) {
        return new Color(
                Math.min(MAX_BYTE, Math.round(base.getRed() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getGreen() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getBlue() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
        );
    }
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import com.logmaster.ui.generic.UILabel;
import com.logmaster.ui.generic.UIPage;
import lombok.Getter;
import net.runelite.api.FontID;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.swing.Timer;
import java.awt.Color;

import static com.logmaster.LogMasterPlugin.*;
import static com.logmaster.ui.InterfaceConstants.COLLECTION_LOG_WINDOW_HEIGHT;
import static com.logmaster.ui.InterfaceConstants.COLLECTION_LOG_WINDOW_WIDTH;

public class TaskDashboard extends UIPage {
    private final int DEFAULT_BUTTON_WIDTH = 140;
    private final int DEFAULT_BUTTON_HEIGHT = 30;
    private final int DEFAULT_TASK_DETAILS_WIDTH = 300;
    private final int DEFAULT_TASK_DETAILS_HEIGHT = 75;
    private final int GENERATE_TASK_SPRITE_ID = -20001;
    private final int COMPLETE_TASK_SPRITE_ID = -20000;
    private final int GENERATE_TASK_HOVER_SPRITE_ID = -20003;
    private final int COMPLETE_TASK_HOVER_SPRITE_ID = -20002;
    private final int GENERATE_TASK_DISABLED_SPRITE_ID = -20005;
    private final int COMPLETE_TASK_DISABLED_SPRITE_ID = -20004;
    private final int TASK_BACKGROUND_SPRITE_ID = -20006;
    private final int FAQ_BUTTON_SPRITE_ID = -20027;
    private final int FAQ_BUTTON_HOVER_SPRITE_ID = -20028;

    @Getter
    private Widget window;
    private LogMasterPlugin plugin;

    private LogMasterConfig config;

    private final TaskService taskService;

    private final SaveDataManager saveDataManager;

    private UILabel title;
    private UILabel taskLabel;
    private UILabel percentCompletion;

    private UIGraphic taskImage;
    private UIGraphic taskBg;

    private UIButton completeTaskBtn;
    private UIButton generateTaskBtn;
    private UIButton faqBtn;

    public TaskDashboard(LogMasterPlugin plugin, LogMasterConfig config, Widget window, TaskService taskService, SaveDataManager saveDataManager) {
        this.window = window;
        this.plugin = plugin;
        this.config = config;
        this.taskService = taskService;
        this.saveDataManager = saveDataManager;

        createTaskDetails();

        Widget titleWidget = window.createChild(-1, WidgetType.TEXT);
        this.title = new UILabel(titleWidget);
        this.title.setFont(FontID.QUILL_CAPS_LARGE);
        this.title.setSize(COLLECTION_LOG_WINDOW_WIDTH, DEFAULT_TASK_DETAILS_HEIGHT);
        this.title.setPosition(getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH), 24);
        this.title.setText("Current Task");

        Widget percentWidget = window.createChild(-1, WidgetType.TEXT);
        this.percentCompletion = new UILabel(percentWidget);
        this.percentCompletion.setFont(FontID.BOLD_12);
        this.percentCompletion.setSize(COLLECTION_LOG_WINDOW_WIDTH, 25);
        this.percentCompletion.setPosition(getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH), COLLECTION_LOG_WINDOW_HEIGHT - 91);
        updatePercentages();

        Widget completeTaskWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.completeTaskBtn = new UIButton(completeTaskWidget);
        this.completeTaskBtn.setSize(DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        this.completeTaskBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) + (DEFAULT_BUTTON_WIDTH / 2 + 15), getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62);
        this.completeTaskBtn.setSprites(COMPLETE_TASK_SPRITE_ID, COMPLETE_TASK_HOVER_SPRITE_ID);

        Widget generateTaskWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.generateTaskBtn = new UIButton(generateTaskWidget);
        this.generateTaskBtn.setSize(DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        this.generateTaskBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) - (DEFAULT_BUTTON_WIDTH / 2 + 15), getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62);
        this.generateTaskBtn.setSprites(GENERATE_TASK_SPRITE_ID, GENERATE_TASK_HOVER_SPRITE_ID);

        Widget faqWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.faqBtn = new UIButton(faqWidget);
        this.faqBtn.setSize(DEFAULT_BUTTON_WIDTH/2, DEFAULT_BUTTON_HEIGHT);
        this.faqBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) + 238, getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112);
        this.faqBtn.setSprites(FAQ_BUTTON_SPRITE_ID, FAQ_BUTTON_HOVER_SPRITE_ID);

        this.add(this.title);
        this.add(this.taskBg);
        this.add(this.taskLabel);
        this.add(this.taskImage);
        this.add(this.completeTaskBtn);
        this.add(this.generateTaskBtn);
        this.add(this.percentCompletion);
        this.add(faqBtn);
    }

    private void createTaskDetails() {
        final int POS_X = getCenterX(window, DEFAULT_TASK_DETAILS_WIDTH);
        final int POS_Y = getCenterY(window, DEFAULT_TASK_DETAILS_HEIGHT)-3;

        Widget taskBgWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.taskBg = new UIGraphic(taskBgWidget);
        this.taskBg.setSize(DEFAULT_TASK_DETAILS_WIDTH, DEFAULT_TASK_DETAILS_HEIGHT);
        this.taskBg.setPosition(POS_X, POS_Y);
        this.taskBg.setSprite(TASK_BACKGROUND_SPRITE_ID);

        Widget label = window.createChild(-1, WidgetType.TEXT);
        label.setTextColor(Color.WHITE.getRGB());
        label.setTextShadowed(true);
        label.setName("Task Label");
        this.taskLabel = new UILabel(label);
        this.taskLabel.setFont(496);
        this.taskLabel.setPosition(POS_X+60, POS_Y);
        this.taskLabel.setSize(DEFAULT_TASK_DETAILS_WIDTH-60, DEFAULT_TASK_DETAILS_HEIGHT);

        Widget taskImageWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.taskImage = new UIGraphic(taskImageWidget);
        this.taskImage.setPosition(POS_X+12, POS_Y+21);
        this.taskImage.getWidget().setItemQuantityMode(ItemQuantityMode.NEVER);
        this.taskImage.setSize(42, 36);
        this.taskImage.getWidget().setBorderType(1);
    }

    public void setTask(String desc, int taskItemID, java.util.List<Task> cyclingTasks) {
        if (cyclingTasks != null) {
            for (int i = 0; i < 250; i++) {
                Task displayTask = cyclingTasks.get((int) Math.floor(Math.random() * cyclingTasks.size()));
                // Seems the most natural timing
                double decay = 450.0 / ((double) config.rollTime());
                int delay = (int) ((config.rollTime() * 0.925) * Math.exp(-decay * i));
                Timer fakeTaskTimer = new Timer(delay, ae -> {
                    this.taskLabel.setText(displayTask.getDescription());
                    this.taskImage.setItem(displayTask.getItemID());
                });
                fakeTaskTimer.setRepeats(false);
                fakeTaskTimer.setCoalesce(true);
                fakeTaskTimer.start();
            }
            Timer realTaskTimer = new Timer(config.rollTime(), ae -> {
                this.taskLabel.setText(desc);
                this.taskImage.setItem(taskItemID);
                this.enableCompleteTask();
                this.enableFaqButton();
            });
            realTaskTimer.setRepeats(false);
            realTaskTimer.setCoalesce(true);
            realTaskTimer.start();
        } else {
            this.taskLabel.setText(desc);
            this.taskImage.setItem(taskItemID);
            this.enableCompleteTask();
            this.enableFaqButton();
        }
    }

    public void updatePercentages() {
        if (this.plugin != null && taskService.completionPercentages(saveDataManager.getSaveData()) != null && this.plugin.getCurrentTier() != null) {
            Integer percentage = taskService.completionPercentages(saveDataManager.getSaveData()).get(this.plugin.getCurrentTier());
            if (percentage != null) {
                this.percentCompletion.setText("<col=" + getCompletionColor(percentage) + ">" + percentage + "%</col> " + this.plugin.getCurrentTier().displayName + " Completed");
            }
        }
    }

    private String getCompletionColor(double percent) {
        int max = 255;
        int amount = (int) Math.round(((percent % 50) / 50) * max);

        if(percent == 100) {
            return "00ff00";
        }
        else if(percent > 50) {
            int redValue = max - amount;
            return String.format("%02x", redValue)+"ff00";

        }
        else if(percent == 50) {
            return "ffff00";
        }
        else {
            return "ff"+String.format("%02x", amount)+"00";
        }
    }

    public void disableGenerateTask() {
        disableGenerateTask(true);
    }

    public void disableGenerateTask(boolean enableComplete) {
        this.generateTaskBtn.setSprites(GENERATE_TASK_DISABLED_SPRITE_ID);
        this.generateTaskBtn.clearActions();

        this.generateTaskBtn.addAction("Disabled", plugin::playFailSound);

        if (enableComplete) {
            this.enableCompleteTask();
            this.enableFaqButton();
        }
    }

    public void enableGenerateTask() {
        this.generateTaskBtn.clearActions();
        this.generateTaskBtn.setSprites(GENERATE_TASK_SPRITE_ID, GENERATE_TASK_HOVER_SPRITE_ID);
        this.generateTaskBtn.addAction("Generate task", plugin::generateTask);

        this.disableCompleteTask();
    }

    public void disableCompleteTask() {
        this.completeTaskBtn.setSprites(COMPLETE_TASK_DISABLED_SPRITE_ID);
        this.completeTaskBtn.clearActions();

        this.completeTaskBtn.addAction("Disabled", plugin::playFailSound);
    }

    public void enableCompleteTask() {
        this.completeTaskBtn.clearActions();
        this.completeTaskBtn.setSprites(COMPLETE_TASK_SPRITE_ID, COMPLETE_TASK_HOVER_SPRITE_ID);
        this.completeTaskBtn.addAction("Complete", plugin::completeTask);
    }

    public void enableFaqButton() {
        this.faqBtn.clearActions();
        this.faqBtn.setSprites(FAQ_BUTTON_SPRITE_ID, FAQ_BUTTON_HOVER_SPRITE_ID);
        this.faqBtn.addAction("FAQ", plugin::visitFaq);
    }
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.domain.TieredTaskList;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import com.logmaster.ui.generic.UILabel;
import com.logmaster.ui.generic.UIPage;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;

import java.awt.*;
import java.awt.event.MouseWheelEvent;
import java.util.ArrayList;
import java.util.List;

import static com.logmaster.LogMasterPlugin.getCenterX;
import static com.logmaster.ui.InterfaceConstants.*;

@Slf4j
public class TaskList extends UIPage {
    private final int OFFSET_X = 0;
    private final int OFFSET_Y = 22;
    private final int CANVAS_WIDTH = 480;
    private final int CANVAS_HEIGHT = 252;
    private final int TASK_WIDTH = 300;
    private final int TASK_HEIGHT = 50;
    private final int TASK_ITEM_HEIGHT = 32;
    private final int TASK_ITEM_WIDTH = 36;
    private final int PAGE_UP_ARROW_SPRITE_ID = -20029;
    private final int UP_ARROW_SPRITE_ID = -20014;
    private final int DOWN_ARROW_SPRITE_ID = -20015;
    private final int PAGE_DOWN_ARROW_SPRITE_ID = -20030;
    private final int THUMB_TOP_SPRITE_ID = -20031;
    private final int THUMB_MIDDLE_SPRITE_ID = -20032;
    private final int THUMB_BOTTOM_SPRITE_ID = -20033;
    private final int ARROW_SPRITE_WIDTH = 39;
    private final int ARROW_SPRITE_HEIGHT = 20;
    private final int ARROW_Y_OFFSET = 4;
    private final int SCROLLBAR_WIDTH = 35; // Match arrow width
    private final int SCROLLBAR_THUMB_MIN_HEIGHT = 8;
    
    private int tasksPerPage = 20; // Default value, will be updated based on window size

    private final Widget window;
    private final TaskService taskService;
    private final LogMasterPlugin plugin;
    private final ClientThread clientThread;

    private final SaveDataManager saveDataManager;

    private Rectangle bounds = new Rectangle();

    private List<UIGraphic> taskBackgrounds = new ArrayList<>();
    private List<UILabel> taskLabels = new ArrayList<>();
    private List<UIGraphic> taskImages = new ArrayList<>();
    private Widget scrollbarTrackWidget;
    private Widget scrollbarThumbTopWidget;
    private Widget scrollbarThumbMiddleWidget;
    private Widget scrollbarThumbBottomWidget;
    private UIButton pageUpButton;
    private UIButton upArrowButton;
    private UIButton downArrowButton;
    private UIButton pageDownButton;
    private boolean isDraggingThumb = false;
    private int dragStartY = 0;
    private int dragStartTopIndex = 0;
    private int topTaskIndex = 0;

    public TaskList(Widget window, TaskService taskService, LogMasterPlugin plugin, ClientThread clientThread, SaveDataManager saveDataManager) {
        this.window = window;
        this.taskService = taskService;
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.saveDataManager = saveDataManager;

        updateBounds();
        refreshTasks(0);

        createScrollbarComponents();
        this.add(upArrowButton);
        this.add(pageUpButton);
        this.add(downArrowButton);
        this.add(pageDownButton);
        updateScrollbar();
    }

    private void createScrollbarComponents() {
        Widget pageUpWidget = window.createChild(-1, WidgetType.GRAPHIC);
        pageUpButton = new UIButton(pageUpWidget);
        pageUpButton.setSprites(PAGE_UP_ARROW_SPRITE_ID);
        pageUpButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        pageUpButton.setPosition(CANVAS_WIDTH - (ARROW_SPRITE_WIDTH+5), ARROW_SPRITE_HEIGHT + ARROW_Y_OFFSET);
        pageUpButton.addAction("Page up", () -> refreshTasks(-tasksPerPage));

        Widget upWidget = window.createChild(-1, WidgetType.GRAPHIC);
        upArrowButton = new UIButton(upWidget);
        upArrowButton.setSprites(UP_ARROW_SPRITE_ID);
        upArrowButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        upArrowButton.setPosition(CANVAS_WIDTH - (ARROW_SPRITE_WIDTH+5), ARROW_SPRITE_HEIGHT*2 + ARROW_Y_OFFSET);
        upArrowButton.addAction("Scroll up", () -> refreshTasks(-1));

        scrollbarTrackWidget = window.createChild(-1, WidgetType.RECTANGLE);
        scrollbarTrackWidget.setFilled(true);
        scrollbarTrackWidget.setTextColor(0x665948);
        scrollbarTrackWidget.setSize(SCROLLBAR_WIDTH, 200);
        scrollbarTrackWidget.setPos(CANVAS_WIDTH - (ARROW_SPRITE_WIDTH + 5) + 2, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET);
        
        scrollbarThumbTopWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbTopWidget.setSpriteId(THUMB_TOP_SPRITE_ID);
        scrollbarThumbTopWidget.setSize(SCROLLBAR_WIDTH, 2);
        scrollbarThumbTopWidget.setPos(CANVAS_WIDTH - (ARROW_SPRITE_WIDTH + 5) + 2, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET);

        scrollbarThumbMiddleWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbMiddleWidget.setSpriteId(THUMB_MIDDLE_SPRITE_ID);
        scrollbarThumbMiddleWidget.setSize(SCROLLBAR_WIDTH, SCROLLBAR_THUMB_MIN_HEIGHT - 4);
        scrollbarThumbMiddleWidget.setPos(CANVAS_WIDTH - (ARROW_SPRITE_WIDTH + 5) + 2, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + 2);

        scrollbarThumbBottomWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbBottomWidget.setSpriteId(THUMB_BOTTOM_SPRITE_ID);
        scrollbarThumbBottomWidget.setSize(SCROLLBAR_WIDTH, 2);
        scrollbarThumbBottomWidget.setPos(CANVAS_WIDTH - (ARROW_SPRITE_WIDTH + 5) + 2, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + SCROLLBAR_THUMB_MIN_HEIGHT - 2);

        Widget downWidget = window.createChild(-1, WidgetType.GRAPHIC);
        downArrowButton = new UIButton(downWidget);
        downArrowButton.setSprites(DOWN_ARROW_SPRITE_ID);
        downArrowButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        downArrowButton.addAction("Scroll down", () -> refreshTasks(1));

        Widget pageDownWidget = window.createChild(-1, WidgetType.GRAPHIC);
        pageDownButton = new UIButton(pageDownWidget);
        pageDownButton.setSprites(PAGE_DOWN_ARROW_SPRITE_ID);
        pageDownButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        pageDownButton.addAction("Page down", () -> refreshTasks(tasksPerPage));
    }

    public void refreshTasks(int dir) {
        refreshTasks(dir, false);
    }
    
    public void refreshTasks(int dir, boolean forceRefresh) {
        TaskTier relevantTier = plugin.getSelectedTier();
        if (relevantTier == null) {
            relevantTier = TaskTier.MASTER;
        }
        
        if (!forceRefresh) {
            int newIndex = topTaskIndex + dir;
            // Ensure we don't go past the valid range
            topTaskIndex = Math.min(taskService.getTaskList().getForTier(relevantTier).size() - tasksPerPage, Math.max(0, newIndex));
        }

        final int POS_X = CANVAS_WIDTH / 2 - TASK_WIDTH / 2;

        int i = 0;
        for(Task task : getTasksToShow(relevantTier, topTaskIndex)) {
            final int POS_Y = OFFSET_Y+(i*TASK_HEIGHT);

            UIGraphic taskBg;
            if(taskBackgrounds.size() <= i) {
                taskBg = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                taskBackgrounds.add(taskBg);
                this.add(taskBg);
            }
            else {
                taskBg = taskBackgrounds.get(i);
                taskBg.getWidget().setHidden(false);
            }

            taskBg.clearActions();
            taskBg.setSize(TASK_WIDTH, TASK_HEIGHT);
            taskBg.setPosition(POS_X, POS_Y);
            taskBg.getWidget().setPos(POS_X, POS_Y);
            TaskTier finalRelevantTier = relevantTier;
            taskBg.addAction("Mark", () -> plugin.completeTask(task.getId(), finalRelevantTier));

            if (saveDataManager.getSaveData().getProgress().get(relevantTier).contains(task.getId())) {
                taskBg.setSprite(TASK_COMPLETE_BACKGROUND_SPRITE_ID);
            } else if (saveDataManager.getSaveData().getActiveTaskPointer() != null && saveDataManager.getSaveData().getActiveTaskPointer().getTaskTier() == relevantTier && saveDataManager.getSaveData().getActiveTaskPointer().getTask().getId() == task.getId()) {
                taskBg.setSprite(TASK_CURRENT_BACKGROUND_SPRITE_ID);
            } else {
                taskBg.setSprite(TASK_LIST_BACKGROUND_SPRITE_ID);
            }

            UILabel taskLabel;
            if (taskLabels.size() <= i) {
                taskLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
                this.add(taskLabel);
                taskLabels.add(taskLabel);
            } else {
                taskLabel = taskLabels.get(i);
                taskLabel.getWidget().setHidden(false);
            }

            taskLabel.getWidget().setTextColor(Color.WHITE.getRGB());
            taskLabel.getWidget().setTextShadowed(true);
            taskLabel.getWidget().setName(task.getDescription());
            taskLabel.setFont(496);
            taskLabel.setPosition(POS_X+60, POS_Y);
            taskLabel.setSize(TASK_WIDTH-60, TASK_HEIGHT);
            taskLabel.setText(task.getDescription());

            UIGraphic taskImage;
            if(taskImages.size() <= i) {
                taskImage = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                this.add(taskImage);
                taskImages.add(taskImage);
            }
            else {
                taskImage = taskImages.get(i);
                taskImage.getWidget().setHidden(false);
            }

            taskImage.setPosition(POS_X+12, POS_Y+6);
            taskImage.getWidget().setBorderType(1);
            taskImage.getWidget().setItemQuantityMode(ItemQuantityMode.NEVER);
            taskImage.setSize(TASK_ITEM_WIDTH, TASK_ITEM_HEIGHT);
            taskImage.setItem(task.getItemID());

            i++;
        }
        
        // Hide any remaining task UI elements that are no longer visible
        hideUnusedTaskElements(i);
        updateScrollbar();
    }

    private void hideUnusedTaskElements(int visibleCount) {
        for (int i = visibleCount; i < taskBackgrounds.size(); i++) {
            taskBackgrounds.get(i).getWidget().setHidden(true);
        }
        
        for (int i = visibleCount; i < taskLabels.size(); i++) {
            taskLabels.get(i).getWidget().setHidden(true);
        }
        
        for (int i = visibleCount; i < taskImages.size(); i++) {
            taskImages.get(i).getWidget().setHidden(true);
        }
    }

    public void goToTop() {
        topTaskIndex = 0;
        updateScrollbar();
    }

    private List<Task> getTasksToShow(TaskTier relevantTier, int topTaskIndex) {
        List<Task> tasksToShow = new ArrayList<>();
        List<Task> taskList = taskService.getTaskList().getForTier(relevantTier);
        for (int i = 0; i < tasksPerPage; i++) {
            if (topTaskIndex + i >= taskList.size()) break;
            tasksToShow.add(taskList.get(topTaskIndex + i));
        }
        return tasksToShow;
    }

    public void handleWheel(final MouseWheelEvent event)
    {
        if (!this.isVisible() || !bounds.contains(event.getPoint()))
        {
            return;
        }

        event.consume();

        clientThread.invoke(() -> refreshTasks(event.getWheelRotation()));
    }

    public void updateBounds()
    {
        if (!this.isVisible()) {
            tasksPerPage = 20; // Default value, will be updated based on window size
            return;
        }

        Widget collectionLogWrapper = window.getParent();
        int wrapperX = collectionLogWrapper.getRelativeX();
        int wrapperY = collectionLogWrapper.getRelativeY();
        int windowWidth = window.getWidth();
        int windowHeight = window.getHeight();
        int windowX = window.getRelativeX();
        int windowY = window.getRelativeY();

        // Recalculate how many tasks can be displayed
        int newTasksPerPage = Math.max(1, (windowHeight - OFFSET_Y) / TASK_HEIGHT);
        if (newTasksPerPage != tasksPerPage) {
            tasksPerPage = newTasksPerPage;
            // Ensure topTaskIndex is valid for the new page size
            TaskTier relevantTier = plugin.getSelectedTier();
            if (relevantTier == null) {
                relevantTier = TaskTier.MASTER;
            }
            int maxTopIndex = Math.max(0, taskService.getTaskList().getForTier(relevantTier).size() - tasksPerPage);
            topTaskIndex = Math.min(topTaskIndex, maxTopIndex);
            
            // Update arrow positions immediately when page size changes
            updateArrowPositions();
            
            // Update scrollbar immediately when size changes
            updateScrollbar();
            
            // Force refresh the task display
            refreshTasks(0, true);
        }

        bounds.setLocation(wrapperX + windowX + OFFSET_X, wrapperY + windowY + OFFSET_Y);
        bounds.setSize(windowWidth - OFFSET_X, windowHeight - OFFSET_Y);
    }

    private void updateArrowPositions() {
        int scrollbarTrackHeight = (tasksPerPage * TASK_HEIGHT) - (ARROW_SPRITE_HEIGHT * 4);
        int scrollbarEndY = ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + scrollbarTrackHeight;
        
        forceWidgetPositionUpdate(downArrowButton, CANVAS_WIDTH - (ARROW_SPRITE_WIDTH+5), scrollbarEndY);
        forceWidgetPositionUpdate(pageDownButton, CANVAS_WIDTH - (ARROW_SPRITE_WIDTH+5), scrollbarEndY + ARROW_SPRITE_HEIGHT);
    }

    private void forceWidgetPositionUpdate(UIButton button, int x, int y) {
        button.getWidget().setHidden(true);
        button.setPosition(x, y);
        button.getWidget().setHidden(false);
        button.getWidget().revalidate();
    }

    private void updateScrollbar() {
        if (!this.isVisible()) {
            setScrollbarVisibility(false);
            return;
        }

        TaskTier relevantTier = plugin.getSelectedTier();
        if (relevantTier == null) relevantTier = TaskTier.MASTER;
        
        int totalTasks = taskService.getTaskList().getForTier(relevantTier).size();
        int scrollbarTrackHeight = (tasksPerPage * TASK_HEIGHT) - (ARROW_SPRITE_HEIGHT * 4);
        
        forceWidgetUpdate(scrollbarTrackWidget, SCROLLBAR_WIDTH, scrollbarTrackHeight);
        updateArrowPositions();
        
        if (totalTasks <= tasksPerPage) {
            setScrollbarVisibility(false);
        } else {
            setScrollbarVisibility(true);
            updateScrollbarThumb(totalTasks, scrollbarTrackHeight);
        }
    }

    private void forceWidgetUpdate(Widget widget, int width, int height) {
        widget.setHidden(true);
        widget.setSize(width, height);
        widget.setHidden(false);
        widget.revalidate();
    }

    private void updateScrollbarThumb(int totalTasks, int scrollbarTrackHeight) {
        topTaskIndex = Math.min(topTaskIndex, Math.max(0, totalTasks - tasksPerPage));
        
        int thumbHeight = Math.max(SCROLLBAR_THUMB_MIN_HEIGHT, (int)(scrollbarTrackHeight * ((double)tasksPerPage / totalTasks)));
        int maxScrollPosition = Math.max(1, totalTasks - tasksPerPage);
        int thumbY = maxScrollPosition > 0 ? (int)((scrollbarTrackHeight - thumbHeight) * ((double)topTaskIndex / maxScrollPosition)) : 0;
        
        int thumbX = CANVAS_WIDTH - (ARROW_SPRITE_WIDTH + 5) + 2;
        int thumbStartY = ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + thumbY;
        
        // Update top edge (2px height)
        scrollbarThumbTopWidget.setPos(thumbX, thumbStartY);
        scrollbarThumbTopWidget.setSize(SCROLLBAR_WIDTH, 2);
        
        // Update middle section (variable height)
        int middleHeight = Math.max(0, thumbHeight - 4);
        scrollbarThumbMiddleWidget.setPos(thumbX, thumbStartY + 2);
        scrollbarThumbMiddleWidget.setSize(SCROLLBAR_WIDTH, middleHeight);
        
        // Update bottom edge (2px height)
        scrollbarThumbBottomWidget.setPos(thumbX, thumbStartY + thumbHeight - 2);
        scrollbarThumbBottomWidget.setSize(SCROLLBAR_WIDTH, 2);
        
        // Force redraw all thumb components
        forceThumbWidgetUpdate(scrollbarThumbTopWidget, SCROLLBAR_WIDTH, 2);
        forceThumbWidgetUpdate(scrollbarThumbMiddleWidget, SCROLLBAR_WIDTH, middleHeight);
        forceThumbWidgetUpdate(scrollbarThumbBottomWidget, SCROLLBAR_WIDTH, 2);
    }

    private void forceThumbWidgetUpdate(Widget widget, int width, int height) {
        widget.setHidden(true);
        widget.setSize(width, height);
        widget.setHidden(false);
        widget.revalidate();
    }

    private void setScrollbarVisibility(boolean visible) {
        if (scrollbarTrackWidget != null) scrollbarTrackWidget.setHidden(!visible);
        if (scrollbarThumbTopWidget != null) scrollbarThumbTopWidget.setHidden(!visible);
        if (scrollbarThumbMiddleWidget != null) scrollbarThumbMiddleWidget.setHidden(!visible);
        if (scrollbarThumbBottomWidget != null) scrollbarThumbBottomWidget.setHidden(!visible);
    }

    public void setVisibility(boolean visible) {
        super.setVisibility(visible);
        setScrollbarVisibility(visible && this.isVisible());
        if (visible) updateScrollbar();
    }

    public void handleMousePress(int mouseX, int mouseY) {
        if (!this.isVisible()) return;
        
        clientThread.invoke(() -> {
            if (isPointInScrollThumb(mouseX, mouseY)) {
                isDraggingThumb = true;
                dragStartY = mouseY;
                dragStartTopIndex = topTaskIndex;
            }
        });
    }

    public void handleMouseDrag(int mouseX, int mouseY) {
        if (!isDraggingThumb || !this.isVisible()) return;
        
        clientThread.invoke(() -> {
            TaskTier relevantTier = plugin.getSelectedTier();
            if (relevantTier == null) relevantTier = TaskTier.MASTER;
            
            int totalTasks = taskService.getTaskList().getForTier(relevantTier).size();
            if (totalTasks <= tasksPerPage) return;
            
            int newTopIndex = calculateNewScrollPosition(mouseY, totalTasks);
            if (newTopIndex != topTaskIndex) {
                topTaskIndex = newTopIndex;
                refreshTasks(0, true);
            }
        });
    }

    private boolean isPointInScrollThumb(int mouseX, int mouseY) {
        Widget collectionLogWrapper = window.getParent();
        int baseX = collectionLogWrapper.getRelativeX() + window.getRelativeX();
        int baseY = collectionLogWrapper.getRelativeY() + window.getRelativeY();
        
        // Check if point is in any of the three thumb components
        int thumbX = baseX + scrollbarThumbTopWidget.getRelativeX();
        int thumbTopY = baseY + scrollbarThumbTopWidget.getRelativeY();
        int thumbBottomY = baseY + scrollbarThumbBottomWidget.getRelativeY() + scrollbarThumbBottomWidget.getHeight();
        int thumbWidth = scrollbarThumbTopWidget.getWidth();
        
        return mouseX >= thumbX && mouseX <= thumbX + thumbWidth && 
               mouseY >= thumbTopY && mouseY <= thumbBottomY;
    }

    private int calculateNewScrollPosition(int mouseY, int totalTasks) {
        int scrollbarTrackHeight = (tasksPerPage * TASK_HEIGHT) - (ARROW_SPRITE_HEIGHT * 4);
        int thumbHeight = Math.max(SCROLLBAR_THUMB_MIN_HEIGHT, (int)(scrollbarTrackHeight * ((double)tasksPerPage / totalTasks)));
        int deltaY = mouseY - dragStartY;
        
        double scrollRatio = (scrollbarTrackHeight - thumbHeight) > 0 ? (double)deltaY / (scrollbarTrackHeight - thumbHeight) : 0;
        int newTopIndex = dragStartTopIndex + (int)(scrollRatio * (totalTasks - tasksPerPage));
        
        return Math.min(totalTasks - tasksPerPage, Math.max(newTopIndex, 0));
    }

    public void handleMouseRelease() {
        isDraggingThumb = false;
    }
}

package com.logmaster.ui;

public class InterfaceConstants {

    public static final String DEF_FILE_SPRITES = "SpriteDef.json";

    public static final int TASK_BACKGROUND_SPRITE_ID = -20006;
    public static final int TASK_LIST_BACKGROUND_SPRITE_ID = -20012;
    public static final int TASK_COMPLETE_BACKGROUND_SPRITE_ID = -20013;
    public static final int TASK_CURRENT_BACKGROUND_SPRITE_ID = -20016;

    public static final int COLLECTION_LOG_WINDOW_WIDTH = 500;
    public static final int COLLECTION_LOG_WINDOW_HEIGHT = 314;
    public static final int COLLECTION_LOG_CONTENT_WIDGET_ID = 40697858;

    public static final int DASHBOARD_TAB_SPRITE_ID = -20007;
    public static final int DASHBOARD_TAB_HOVER_SPRITE_ID = -20008;
    public static final int TASKLIST_TAB_SPRITE_ID = -20009;
    public static final int TASKLIST_TAB_HOVER_SPRITE_ID = -20010;
    public static final int DIVIDER_SPRITE_ID = -20011;

    public static final int TASKLIST_EASY_TAB_SPRITE_ID = -20017;
    public static final int TASKLIST_EASY_TAB_HOVER_SPRITE_ID = -20018;
    public static final int TASKLIST_MEDIUM_TAB_SPRITE_ID = -20019;
    public static final int TASKLIST_MEDIUM_TAB_HOVER_SPRITE_ID = -20020;
    public static final int TASKLIST_HARD_TAB_SPRITE_ID = -20021;
    public static final int TASKLIST_HARD_TAB_HOVER_SPRITE_ID = -20022;
    public static final int TASKLIST_ELITE_TAB_SPRITE_ID = -20023;
    public static final int TASKLIST_ELITE_TAB_HOVER_SPRITE_ID = -20024;
    public static final int TASKLIST_MASTER_TAB_SPRITE_ID = -20025;
    public static final int TASKLIST_MASTER_TAB_HOVER_SPRITE_ID = -20026;
}

package com.logmaster.ui;

import lombok.Getter;
import net.runelite.client.game.SpriteOverride;

@Getter
public class SpriteDefinition implements SpriteOverride
{
    private int spriteId;
    private String fileName;
}

package com.logmaster.ui;

import com.google.gson.Gson;
import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import com.logmaster.ui.component.TaskDashboard;
import com.logmaster.ui.component.TaskList;
import com.logmaster.ui.generic.UICheckBox;
import com.logmaster.ui.generic.dropdown.UIDropdown;
import com.logmaster.ui.generic.dropdown.UIDropdownOption;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import com.logmaster.util.FileUtils;
import net.runelite.api.Client;
import net.runelite.api.SoundEffectID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseWheelListener;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static com.logmaster.ui.InterfaceConstants.*;

@Singleton
public class InterfaceManager implements MouseListener, MouseWheelListener {
    private static final int COLLECTION_LOG_TAB_DROPDOWN_WIDGET_ID = 40697929;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private LogMasterConfig config;

    @Inject
    private LogMasterPlugin plugin;

    @Inject
    private TaskService taskService;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private Gson gson;

    @Inject
    private SaveDataManager saveDataManager;


    private SpriteDefinition[] spriteDefinitions;

    private TaskDashboard taskDashboard;
    private TaskList taskList;

    private List<UIButton> tabs;
    private UIButton taskListTab;
    private UIButton taskDashboardTab;
    private UICheckBox taskDashboardCheckbox;
    private UIDropdown dropdown;

    public void initialise() {
        this.spriteDefinitions = FileUtils.loadDefinitionResource(SpriteDefinition[].class, DEF_FILE_SPRITES, gson);
        this.spriteManager.addSpriteOverrides(spriteDefinitions);
    }

    public void updateAfterConfigChange() {
        hideTabs();
        updateTabs();
        if (this.config.hideBelow() == TaskTier.MASTER && this.saveDataManager.getSaveData().getSelectedTier() == TaskTier.MASTER && !this.taskDashboard.isVisible()) {
            this.taskListTab.setSprites(TASKLIST_TAB_HOVER_SPRITE_ID);
        }
        if (this.taskDashboard != null && isTaskDashboardEnabled()) {
            showTabs();
            if (this.saveDataManager.getSaveData().getSelectedTier() != null && Arrays.asList(TaskTier.values()).indexOf(this.saveDataManager.getSaveData().getSelectedTier()) < Arrays.asList(TaskTier.values()).indexOf(this.config.hideBelow())) {
                activateTaskDashboard();
            }
            this.taskDashboard.updatePercentages();
        }
    }

    public void handleCollectionLogOpen() {
        Widget window = client.getWidget(InterfaceID.Collection.CONTENT);
        Widget dashboardTabWidget = window.createChild(-1, WidgetType.GRAPHIC);
        taskDashboardTab = new UIButton(dashboardTabWidget);
        taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
        taskDashboardTab.setSize(95, 21);
        taskDashboardTab.setPosition(10, 0);
        taskDashboardTab.addAction("View <col=ff9040>Dashboard</col>", this::activateTaskDashboard);
        taskDashboardTab.setVisibility(false);

        tabs = new ArrayList<>();

        int currentTabX = 110;

        for (int i = 0; i < 5; i++) {
            Widget tabWiget = window.createChild(-1, WidgetType.GRAPHIC);
            UIButton tab = new UIButton(tabWiget);
            tab.setSize(66, 21);
            tab.setPosition(currentTabX, 0);
            tab.setVisibility(false);
            currentTabX += 71;
            tabs.add(tab);
        }

        Widget tabWiget = window.createChild(-1, WidgetType.GRAPHIC);
        taskListTab = new UIButton(tabWiget);
        taskListTab.setSize(95, 21);
        taskListTab.setPosition(110, 0);
        taskListTab.setSprites(TASKLIST_TAB_SPRITE_ID, TASKLIST_TAB_HOVER_SPRITE_ID);
        taskListTab.setVisibility(false);
        taskListTab.addAction("View <col=ff9040>Task List</col>", () -> {
            taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
            if (this.saveDataManager.getSaveData().getSelectedTier() != TaskTier.MASTER) {
                this.taskList.goToTop();
                this.saveDataManager.getSaveData().setSelectedTier(TaskTier.MASTER);
                this.saveDataManager.save();
            }
            updateTabs();
            taskListTab.setSprites(TASKLIST_TAB_HOVER_SPRITE_ID);
            this.taskDashboard.setVisibility(false);
            this.taskList.refreshTasks(0);
            this.taskList.setVisibility(true);
        });

        Widget dividerWidget = window.createChild(-1, WidgetType.GRAPHIC);
        UIGraphic divider = new UIGraphic(dividerWidget);
        divider.setSprite(DIVIDER_SPRITE_ID);
        divider.setSize(480, 1);
        divider.setPosition(10, 20);

        createTaskDashboard(window);
        createTaskList(window);
        createTaskCheckbox();
        updateTabs();

        this.taskDashboard.setVisibility(false);
    }

    public void handleCollectionLogClose() {
        this.taskDashboard.setVisibility(false);
        this.taskList.setVisibility(false);
        hideTabs();
    }

    public void handleCollectionLogScriptRan() {
        if (this.dropdown != null) {
            this.dropdown.cleanup();
            this.dropdown = null;
        }

        createTaskDropdownOption();
    }

    public boolean isDashboardOpen() {
        return this.taskDashboard != null && this.taskDashboard.isVisible();
    }

    public void updateTaskListBounds() {
        if (this.taskList != null) {
            taskList.updateBounds();
        }
    }

    public void handleMouseWheel(MouseWheelEvent event) {
        if(this.taskList != null) {
            taskList.handleWheel(event);
        }
    }

    public void handleMousePress(int mouseX, int mouseY) {
        if(this.taskList != null && this.taskList.isVisible()) {
            taskList.handleMousePress(mouseX, mouseY);
        }
    }

    public void handleMouseDrag(int mouseX, int mouseY) {
        if(this.taskList != null && this.taskList.isVisible()) {
            taskList.handleMouseDrag(mouseX, mouseY);
        }
    }

    public void handleMouseRelease() {
        if(this.taskList != null) {
            taskList.handleMouseRelease();
        }
    }

    @Override
    public MouseWheelEvent mouseWheelMoved(MouseWheelEvent event) {
        handleMouseWheel(event);
        return event;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent event) {
        handleMousePress(event.getX(), event.getY());
        return event;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent event) {
        handleMouseRelease();
        return event;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent event) {
        handleMouseDrag(event.getX(), event.getY());
        return event;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent event) {
        return event;
    }

    private void createTaskDropdownOption() {
        Widget container = client.getWidget(COLLECTION_LOG_TAB_DROPDOWN_WIDGET_ID);
        if (container == null) {
            return;
        }

        this.dropdown = new UIDropdown(container);
        this.dropdown.addOption("Tasks", "View Tasks Dashboard");
        this.dropdown.setOptionEnabledListener(this::toggleTaskDashboard);
    }

    private void createTaskCheckbox() {
        Widget window = client.getWidget(621, 88);
        if (window != null) {
            // Create the graphic widget for the checkbox
            Widget toggleWidget = window.createChild(-1, WidgetType.GRAPHIC);
            Widget labelWidget = window.createChild(-1, WidgetType.TEXT);

            // Wrap in checkbox, set size, position, etc.
            taskDashboardCheckbox = new UICheckBox(toggleWidget, labelWidget);
            taskDashboardCheckbox.setPosition(360, 10);
            taskDashboardCheckbox.setName("Task Dashboard");
            taskDashboardCheckbox.setEnabled(false);
            taskDashboardCheckbox.setText("Task Dashboard");
            labelWidget.setPos(375, 10);
            taskDashboardCheckbox.setToggleListener((UICheckBox src) -> {
                if (taskDashboardCheckbox.isEnabled()) {
                    this.dropdown.setEnabledOption("Tasks");
                } else {
                    this.dropdown.setEnabledOption("View Log");
                }
            });
        }
    }

    private void updateTabs() {
        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            if (tabIndex > 0 || tier == config.hideBelow()) {
                if (tabs == null) {
                    return;
                }
                if (this.saveDataManager.getSaveData().getSelectedTier() == tier && !this.taskDashboard.isVisible()) {
                    tabs.get(tabIndex).setSprites(tier.tabSpriteHoverId);
                } else {
                    tabs.get(tabIndex).setSprites(tier.tabSpriteId, tier.tabSpriteHoverId);
                }
                int finalTabIndex = tabIndex;
                tabs.get(tabIndex).clearActions();
                tabs.get(tabIndex).setSize(66, 21);
                tabs.get(tabIndex).addAction(String.format("View <col=ff9040>%s Task List</col>", tier.displayName), () -> {
                    taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
                    if (this.saveDataManager.getSaveData().getSelectedTier() != tier) {
                        this.taskList.goToTop();
                        this.saveDataManager.getSaveData().setSelectedTier(tier);
                        this.saveDataManager.save();
                    }
                    updateTabs();
                    tabs.get(finalTabIndex).setSprites(tier.tabSpriteHoverId);
                    this.taskDashboard.setVisibility(false);
                    this.taskList.refreshTasks(0);
                    this.taskList.setVisibility(true);
                    showTabs();
                });
                tabIndex++;
            }
        }
    }

    private void createTaskDashboard(Widget window) {
        this.taskDashboard = new TaskDashboard(plugin, config, window, taskService, saveDataManager);
        this.taskDashboard.setVisibility(false);
    }

    private void createTaskList(Widget window) {
        this.taskList = new TaskList(window, taskService, plugin, clientThread, this.saveDataManager);
        this.taskList.setVisibility(false);
    }

    private void toggleTaskDashboard(UIDropdownOption src) {
        if(this.taskDashboard == null) return;

        if (saveDataManager.getSaveData().getActiveTaskPointer() != null) {
            this.taskDashboard.setTask(this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getDescription(), this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getItemID(), null);
            this.taskDashboard.disableGenerateTask();
        } else {
            plugin.nullCurrentTask();
        }

        boolean enabled = isTaskDashboardEnabled();
        this.taskDashboardCheckbox.setEnabled(enabled);
        for (Widget c : client.getWidget(InterfaceID.Collection.CONTENT).getStaticChildren()) {
            c.setHidden(enabled);
        }
        client.getWidget(InterfaceID.Collection.SEARCH_TITLE).setHidden(enabled);

        if (isTaskDashboardEnabled()) {
            activateTaskDashboard();
        } else {
            this.taskDashboard.setVisibility(false);
            this.taskList.setVisibility(false);

            hideTabs();
        }

        // *Boop*
        this.client.playSoundEffect(SoundEffectID.UI_BOOP);
    }

    private boolean isTaskDashboardEnabled() {
        return this.dropdown != null && this.dropdown.getEnabledOption().getText().equals("Tasks");
    }

    private void hideTabs() {
        if (this.taskDashboardTab != null) {
            this.taskDashboardTab.setVisibility(false);
        }
        if (this.tabs != null) {
            this.tabs.forEach(t -> t.setVisibility(false));
        }
        if (this.taskListTab != null) {
            this.taskListTab.setVisibility(false);
        }
    }

    private void showTabs() {
        if (this.taskDashboardTab != null) {
            this.taskDashboardTab.setVisibility(true);
        }
        if (this.config.hideBelow() == TaskTier.MASTER) {
            this.taskListTab.setVisibility(true);
        } else {
            int tabIndex = 0;
            for (TaskTier tier : TaskTier.values()) {
                if (tabIndex > 0 || tier == config.hideBelow()) {
                    this.tabs.get(tabIndex).setVisibility(true);
                    tabIndex++;
                }
            }
        }
    }

    private void activateTaskDashboard() {
        this.taskDashboardTab.setSprites(DASHBOARD_TAB_HOVER_SPRITE_ID);
        this.taskList.setVisibility(false);
        this.taskDashboard.setVisibility(true);
        this.taskListTab.setSprites(TASKLIST_TAB_SPRITE_ID, TASKLIST_TAB_HOVER_SPRITE_ID);
        updateTabs();
        showTabs();
    }

    public void rollTask(String description, int itemID, List<Task> tasks) {
        this.taskDashboard.setTask(description, itemID, tasks);
        this.taskDashboard.disableGenerateTask(false);
        this.taskDashboard.updatePercentages();
    }

    public void completeTask() {
        boolean wasDashboardVisible = this.taskDashboard.isVisible();
        this.taskDashboard.updatePercentages();
        taskList.refreshTasks(0);
        // Restore previous visibility state
        this.taskDashboard.setVisibility(wasDashboardVisible);
        this.taskList.setVisibility(!wasDashboardVisible);
        showTabs();
    }

    public void clearCurrentTask() {
        this.taskDashboard.setTask("No task.", -1, null);
        this.taskDashboard.enableGenerateTask();
        this.taskDashboard.enableFaqButton();
    }

    public void disableGenerateTaskButton() {
        this.taskDashboard.disableGenerateTask();
    }
}

package com.logmaster.domain;

import lombok.Getter;

@Getter
public class Task {
    private int id;
    private String description;
    private int itemID;
}

package com.logmaster.domain;

import static com.logmaster.ui.InterfaceConstants.*;

public enum TaskTier {
    EASY("Easy", TASKLIST_EASY_TAB_SPRITE_ID, TASKLIST_EASY_TAB_HOVER_SPRITE_ID),
    MEDIUM("Medium", TASKLIST_MEDIUM_TAB_SPRITE_ID, TASKLIST_MEDIUM_TAB_HOVER_SPRITE_ID),
    HARD("Hard", TASKLIST_HARD_TAB_SPRITE_ID, TASKLIST_HARD_TAB_HOVER_SPRITE_ID),
    ELITE("Elite", TASKLIST_ELITE_TAB_SPRITE_ID, TASKLIST_ELITE_TAB_HOVER_SPRITE_ID),
    MASTER("Master", TASKLIST_MASTER_TAB_SPRITE_ID, TASKLIST_MASTER_TAB_HOVER_SPRITE_ID);

    public final String displayName;
    public final int tabSpriteId;
    public final int tabSpriteHoverId;

    TaskTier(String displayName, int tabSpriteId, int tabSpriteHoverId) {
        this.displayName = displayName;
        this.tabSpriteId = tabSpriteId;
        this.tabSpriteHoverId = tabSpriteHoverId;
    }
}

package com.logmaster.domain;

import lombok.Data;

import java.util.Collections;
import java.util.List;

@Data
public class TieredTaskList {

    private List<Task> easy;
    private List<Task> medium;
    private List<Task> hard;
    private List<Task> elite;
    private List<Task> master;

    public List<Task> getForTier(TaskTier tier) {
        if (tier == null) {
            return Collections.emptyList();
        }
        switch (tier) {
            case EASY: return easy;
            case MEDIUM: return medium;
            case HARD: return hard;
            case ELITE: return elite;
            case MASTER: return master;
            default: return Collections.emptyList();
        }
    }
}

package com.logmaster.domain;

import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

@ToString
public class SaveData {
    // We have to leave this here in case someone was running the old version of the plugin
    @Getter
    private HashMap<Integer, Integer> completedTasks = new HashMap<>();

    public Task currentTask;

    // New save data!
    @Getter
    private Map<TaskTier, Set<Integer>> progress = new HashMap<>();

    @Getter
    @Setter
    private TaskPointer activeTaskPointer;
    @Getter
    @Setter
    private TaskTier selectedTier;
}

package com.logmaster.domain;

import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TaskPointer {

    private TaskTier taskTier;
    private Task task;
}

package com.logmaster.task;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.logmaster.LogMasterConfig;
import com.logmaster.domain.SaveData;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.domain.TieredTaskList;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.util.FileUtils;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@Singleton
@Slf4j
public class TaskService {

    private static final String DEF_FILE_TASKS = "default-tasks.json";

    @Inject
    private Gson gson;

    @Inject
    private LogMasterConfig config;

    @Inject
    private TaskListClient taskListClient;

    @Inject
    private ClientThread clientThread;

    @Inject
    private SaveDataManager saveDataManager;

    private TieredTaskList localList;
    private TieredTaskList remoteList;
    private boolean requestedRemoteList = false;

    public TieredTaskList getTaskList() {
        if (localList == null) {
            this.localList = FileUtils.loadDefinitionResource(TieredTaskList.class, DEF_FILE_TASKS, gson);
        }
        if (remoteList == null && !requestedRemoteList && config.loadRemoteTaskList()) {
            loadRemoteTaskList();
        }
        return remoteList != null && config.loadRemoteTaskList() ? remoteList : localList;
    }

    public List<Task> getForTier(TaskTier tier) {
        return getTaskList().getForTier(tier);
    }

    public Map<TaskTier, Integer> completionPercentages(SaveData saveData) {
        Map<TaskTier, Set<Integer>> progressData = saveData.getProgress();
        TieredTaskList taskList = getTaskList();

        Map<TaskTier, Integer> completionPercentages = new HashMap<>();
        for (TaskTier tier : TaskTier.values()) {
            Set<Integer> tierCompletedTasks = new HashSet<>(progressData.get(tier));
            Set<Integer> tierTaskIdList = taskList.getForTier(tier)
                    .stream()
                    .mapToInt(Task::getId)
                    .boxed()
                    .collect(Collectors.toSet());

            tierCompletedTasks.retainAll(tierTaskIdList);

            double tierPercentage = 100d * tierCompletedTasks.size() / tierTaskIdList.size();

            completionPercentages.put(tier, (int) Math.floor(tierPercentage));
        }

        return completionPercentages;
    }

    private void loadRemoteTaskList() {
        requestedRemoteList = true;
        // Load the remote task list
        try {
            taskListClient.getTaskList(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Unable to load remote task list, will defer to the default task list", e);
                    requestedRemoteList = false;
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                    JsonObject tasksJson = taskListClient.processResponse(response);
                    response.close();
                    if (tasksJson == null) {
                        log.error("Loaded null remote task list, will defer to the default task list");
                        return;
                    }
                    log.debug("Loaded remote task list!");
                    remoteList = gson.fromJson(tasksJson, TieredTaskList.class);
                }
            });
        } catch (IOException e) {
            log.error("Unable to load remote task list, will defer to the default task list");
            this.localList = FileUtils.loadDefinitionResource(TieredTaskList.class, DEF_FILE_TASKS, gson);
        }
    }
}

package com.logmaster.task;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;

@Slf4j
@Singleton
public class TaskListClient {

    private static final String TASK_LIST_URL = "raw.githubusercontent.com";
    private static final String TASK_LIST_PATH = "Alex-Banna/generate-task-tasks/main/tasks.json";

    @Inject
    private OkHttpClient okHttpClient;

    public void getTaskList(Callback callback) throws IOException {
        HttpUrl url = new HttpUrl.Builder()
                .scheme("https")
                .host(TASK_LIST_URL)
                .addPathSegments(TASK_LIST_PATH)
                .build();

        getRequest(url, callback);
    }

    private void getRequest(HttpUrl url, Callback callback) {
        Request request = new Request.Builder().url(url).get().build();
        okHttpClient.newCall(request).enqueue(callback);
    }

    public JsonObject processResponse(Response response) throws IOException {
        if (!response.isSuccessful()) {
            return null;
        }

        ResponseBody resBody = response.body();
        if (resBody == null) {
            return null;
        }
        return new JsonParser().parse(resBody.string()).getAsJsonObject();
    }
}

package com.logmaster;

import com.logmaster.domain.TaskTier;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import net.runelite.client.plugins.camera.ControlFunction;

import static com.logmaster.LogMasterConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface LogMasterConfig extends Config
{
    String CONFIG_GROUP = "log-master";

    String SAVE_DATA_KEY = "save-data";

    @Range(
            min = 1000,
            max = 10000
    )
    @Units(Units.MILLISECONDS)
    @ConfigItem(
            keyName = "rollTime",
            name = "Roll Time",
            description = "How long new tasks will take to roll",
            position = 1
    )
    default int rollTime()
    {
        return 5000;
    }

    @ConfigItem(
            keyName = "rollPastCompleted",
            name = "Roll past completed",
            description = "When rolling tasks, include those you've already completed in the roll animation. Helpful when you're getting to the end of a tier!",
            position = 2
    )
    default boolean rollPastCompleted()
    {
        return false;
    }

    @ConfigItem(
            keyName = "hideBelow",
            name = "Hide Tasks Below",
            description = "Disabled the showing up/assigning of tasks at or below the specified tier",
            position = 3
    )
    default TaskTier hideBelow()
    {
        return TaskTier.EASY;
    }

    @ConfigItem(
            keyName = "loadRemoteTaskList",
            name = "Load remote task list",
            description = "Load the latest version of the tasklist, this will be updated more frequently than the default list bundled with the plugin",
            position = 4
    )
    default boolean loadRemoteTaskList()
    {
        return true;
    }

    @ConfigItem(
            keyName = "displayCurrentTaskOverlay",
            name = "Display current task overlay",
            description = "Enable an overlay showing the currently assigned task (when one exists)",
            position = 5
    )
    default boolean displayCurrentTaskOverlay()
    {
        return true;
    }
//
//    @ConfigItem(
//            keyName = "taskChatCommand",
//            name = "Enable !task command",
//            description = "Enable the !task chat command to show your current tier progress and task",
//            position = 6
//    )
//    default boolean taskChatCommand()
//    {
//        return true;
//    }


}

package com.logmaster;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LogMasterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LogMasterPlugin.class);
		RuneLite.main(args);
	}
}
