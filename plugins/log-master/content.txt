package com.logmaster;

import com.google.inject.Provides;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskPointer;
import com.logmaster.domain.TaskTier;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import com.logmaster.ui.InterfaceManager;
import com.logmaster.ui.component.TaskOverlay;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.SoundEffectID;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(name = "Collection Log Master")
public class LogMasterPlugin extends Plugin {
    private static final int COLLECTION_LOG_SETUP_SCRIPT_ID = 7797;

	@Inject
	private Client client;

	@Inject
	private LogMasterConfig config;

	@Inject
	private MouseManager mouseManager;

	@Inject
	protected TaskOverlay taskOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private TaskService taskService;

	@Inject
	private SaveDataManager saveDataManager;

	@Inject
	private InterfaceManager interfaceManager;

	@Override
	protected void startUp()
	{
		mouseManager.registerMouseWheelListener(interfaceManager);
		mouseManager.registerMouseListener(interfaceManager);
		interfaceManager.initialise();
		this.taskOverlay.setResizable(true);
		this.overlayManager.add(this.taskOverlay);
		this.taskService.getTaskList();
	}

	@Override
	protected void shutDown() {
		mouseManager.unregisterMouseWheelListener(interfaceManager);
		mouseManager.unregisterMouseListener(interfaceManager);
		this.overlayManager.remove(this.taskOverlay);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals("log-master")) {
			return;
		}
		interfaceManager.updateAfterConfigChange();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
			saveDataManager.getSaveData();
		} else if(gameStateChanged.getGameState().equals(GameState.LOGIN_SCREEN)) {
			saveDataManager.save();
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded e) {
		if(e.getGroupId() == InterfaceID.COLLECTION) {
			interfaceManager.handleCollectionLogOpen();
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed e) {
		if(e.getGroupId() == InterfaceID.COLLECTION) {
			interfaceManager.handleCollectionLogClose();
		}
	}

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP_SCRIPT_ID) {
            interfaceManager.handleCollectionLogScriptRan();
        }
    }

	@Subscribe
	public void onGameTick(GameTick event) {
		interfaceManager.updateTaskListBounds();
	}

	public void generateTask() {
		TaskPointer pointer =this.saveDataManager.getSaveData().getActiveTaskPointer();
		if ((pointer != null && pointer.getTask() != null) || taskService.getTaskList() == null) {
			interfaceManager.disableGenerateTaskButton();
			return;
		}

		this.client.playSoundEffect(SoundEffectID.UI_BOOP);
		List<Task> uniqueTasks = findAvailableTasks();

		if(uniqueTasks.size() <= 0) {
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "No more tasks left. Looks like you win?", "");
			playFailSound();

			return;
		}

		int index = (int) Math.floor(Math.random()*uniqueTasks.size());


		TaskPointer newTaskPointer = new TaskPointer();
		newTaskPointer.setTask(uniqueTasks.get(index));
		newTaskPointer.setTaskTier(getCurrentTier());
		this.saveDataManager.getSaveData().setActiveTaskPointer(newTaskPointer);
		this.saveDataManager.save();
		interfaceManager.rollTask(this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getName(), this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getDisplayItemId(), config.rollPastCompleted() ? taskService.getForTier(getCurrentTier()) : uniqueTasks);
		log.debug("Task generated: "+this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getName());

		this.saveDataManager.save();
	}

	public void completeTask() {
		completeTask(saveDataManager.getSaveData().getActiveTaskPointer().getTask().getId(), saveDataManager.getSaveData().getActiveTaskPointer().getTaskTier());
	}

	public void completeTask(String taskID, TaskTier tier) {
		this.client.playSoundEffect(SoundEffectID.UI_BOOP);

		if (saveDataManager.getSaveData().getProgress().get(tier).contains(taskID)) {
			saveDataManager.getSaveData().getProgress().get(tier).remove(taskID);
		} else {
			addCompletedTask(taskID, tier);
			if (saveDataManager.getSaveData().getActiveTaskPointer() != null && taskID.equals(saveDataManager.getSaveData().getActiveTaskPointer().getTask().getId())) {
				nullCurrentTask();
			}
		}
		this.saveDataManager.save();
		interfaceManager.completeTask();
	}

	public void nullCurrentTask() {
		this.saveDataManager.getSaveData().setActiveTaskPointer(null);
		this.saveDataManager.save();
		interfaceManager.clearCurrentTask();
	}

	public static int getCenterX(Widget window, int width) {
		return (window.getWidth() / 2) - (width / 2);
	}

	public static int getCenterY(Widget window, int height) {
		return (window.getHeight() / 2) - (height / 2);
	}

	public void addCompletedTask(String taskID, TaskTier tier) {
		this.saveDataManager.getSaveData().getProgress().get(tier).add(taskID);
		this.saveDataManager.save();
	}

	public TaskTier getCurrentTier() {
		TaskTier[] allTiers = TaskTier.values();
		int firstVisibleTier = 0;
		for (int i = 0; i < allTiers.length; i++) {
			if (config.hideBelow() == allTiers[i]) {
				firstVisibleTier = i;
			}
		}

		Map<TaskTier, Integer> tierPercentages = taskService.completionPercentages(saveDataManager.getSaveData());
		for (int i = firstVisibleTier; i < allTiers.length; i++) {
			TaskTier tier = allTiers[i];
			if (tierPercentages.get(tier) < 100) {
				return tier;
			}
		}


		return TaskTier.MASTER;
	}

	public TaskTier getSelectedTier() {
		return this.saveDataManager.getSaveData().getSelectedTier();
	}

	public List<Task> findAvailableTasks() {
		return taskService.getTaskList().getForTier(getCurrentTier()).stream().filter(t -> !this.saveDataManager.getSaveData().getProgress().get(getCurrentTier()).contains(t.getId())).collect(Collectors.toList());
	}

	public void playFailSound() {
		client.playSoundEffect(2277);
	}

	@Provides
	LogMasterConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LogMasterConfig.class);
	}

	public void visitFaq() {
		LinkBrowser.browse("https://docs.google.com/document/d/e/2PACX-1vTHfXHzMQFbt_iYAP-O88uRhhz3wigh1KMiiuomU7ftli-rL_c3bRqfGYmUliE1EHcIr3LfMx2UTf2U/pub");
	}
}

package com.logmaster.util;

import com.google.gson.Gson;

import java.io.InputStream;
import java.io.InputStreamReader;

public class FileUtils {


    /**
     * Loads a definition resource from a JSON file
     *
     * @param classType the class into which the data contained in the JSON file will be read into
     * @param resource  the name of the resource (file name)
     * @param gson      a reference to the GSON object
     * @param <T>       the class type
     * @return the data read from the JSON definition file
     */
    public static <T> T loadDefinitionResource(Class<T> classType, String resource, Gson gson) {
        // Load the resource as a stream and wrap it in a reader
        InputStream resourceStream = classType.getResourceAsStream(resource);
        assert resourceStream != null;
        InputStreamReader definitionReader = new InputStreamReader(resourceStream);

        // Load the objects from the JSON file
        return gson.fromJson(definitionReader, classType);
    }
}

package com.logmaster;


package com.logmaster.persistence;

import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.logmaster.domain.*;
import com.logmaster.domain.old.OldSaveData;
import com.logmaster.domain.old.OldTask;
import com.logmaster.domain.old.OldTaskPointer;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.Set;

import static com.logmaster.LogMasterConfig.*;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Singleton
@Slf4j
public class SaveDataManager {
    @Inject
    private ConfigManager configManager;

    private SaveData saveData;

    public @NonNull SaveData getSaveData() {
        this.saveData = loadSaveData();
        return this.saveData;
    }

    public void save() {
        String json = GSON.toJson(this.saveData);
        this.configManager.setRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY, json);
    }

    public Task currentTask() {
        if (getSaveData().getActiveTaskPointer() == null) {
            return null;
        }
        return getSaveData().getActiveTaskPointer().getTask();
    }

    private SaveData loadSaveData() {
        String json = this.configManager.getRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY);
        if (json == null) {
            return new SaveData();
        }

        try {
            BaseSaveData base = GSON.fromJson(json, BaseSaveData.class);
            if (BaseSaveData.LATEST_VERSION.equals(base.getVersion())) {
                return GSON.fromJson(json, SaveData.class);
            }

            this.saveBackup(json);
            return this.update(json);
        } catch (JsonSyntaxException e) {
            log.error("Unable to parse save data JSON", e);
        }

        return new SaveData();
    }

    @SuppressWarnings("deprecation")
    private SaveData update(String json) {
        SaveData updated = new SaveData();

        OldSaveData old = null;
        try {
            old = GSON.fromJson(json, OldSaveData.class);
        } catch (JsonSyntaxException e) {
            log.error("Unable to parse *old* save data JSON", e);
        }

        if (old == null) {
            return updated;
        }

        Type mapType = new TypeToken<Map<TaskTier, Map<Integer, String>>>() {}.getType();
        Map<TaskTier, Map<Integer, String>> v0MigrationData;
        try (InputStream resourceStream = this.getClass().getResourceAsStream("v0-migration.json")) {
            assert resourceStream != null;
            InputStreamReader definitionReader = new InputStreamReader(resourceStream);
            v0MigrationData = GSON.fromJson(definitionReader, mapType);
        } catch (IOException e) {
            log.error("Unable to parse migration data", e);
            return updated;
        }

        Map<TaskTier, Set<Integer>> oldProgress = old.getProgress();
        Map<TaskTier, Set<String>> newProgress = updated.getProgress();

        for (TaskTier tier : TaskTier.values()) {
            Set<Integer> oldTierData = oldProgress.get(tier);
            Set<String> newTierData = newProgress.get(tier);
            Map<Integer, String> tierMigrationData = v0MigrationData.get(tier);

            for (Integer oldTaskId : oldTierData) {
                if (tierMigrationData.containsKey(oldTaskId)) {
                    newTierData.add(tierMigrationData.get(oldTaskId));
                }
            }
        }

        updated.setSelectedTier(old.getSelectedTier());

        OldTaskPointer oldTaskPointer = old.getActiveTaskPointer();
        if (oldTaskPointer != null) {
            OldTask oldTask = oldTaskPointer.getTask();
            String newTaskId = v0MigrationData.get(oldTaskPointer.getTaskTier()).get(oldTask.getId());
            Task newTask = new Task(newTaskId, oldTask.getDescription(), oldTask.getItemID());
            updated.setActiveTaskPointer(new TaskPointer(oldTaskPointer.getTaskTier(), newTask));
        }

        return updated;
    }

    private void saveBackup(String json) {
        this.configManager.setRSProfileConfiguration(CONFIG_GROUP, BACKUP_SAVE_DATA_KEY, json);
    }
}

package com.logmaster.ui.generic;

import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a graphic display component, effectively just a game sprite.
 * @author Antipixel
 */
public class UIGraphic extends UIComponent
{
	/**
	 * Constructs a new graphic component
	 * @param widget the underlying widget
	 */
	public UIGraphic(Widget widget)
	{
		super(widget);
	}

	/**
	 * Sets the sprite to display on the component
	 * @param spriteID the sprite ID
	 */
	public void setSprite(int spriteID)
	{
		this.getWidget().setSpriteId(spriteID);
	}

	/**
	 * Sets the sprite to display on the component
	 * @param itemID the item ID
	 */
	public void setItem(int itemID)
	{
		this.getWidget().setItemId(itemID);
	}
}

package com.logmaster.ui.generic.dropdown;

import com.logmaster.ui.generic.ComponentEventListener;
import com.logmaster.ui.generic.MenuAction;
import com.logmaster.ui.generic.UIComponent;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.FontID;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.*;

@Slf4j
public class UIDropdownOption extends UIComponent {
    private static final int TEXT_COLOR_INACTIVE = 0xFF981F;
    private static final int TEXT_COLOR_HIGHLIGHT = 0xFFFFFF;
    private static final int TEXT_COLOR_ACTIVE = 0xC8C8C8;

    private static final int TEXT_OPACITY_INACTIVE = 0;
    private static final int TEXT_OPACITY_ACTIVE = 128;

    private static final int BG_OPACITY_INACTIVE = 255;
    private static final int BG_OPACITY_ACTIVE = 230;

    private static final String DEFAULT_ACTION_LABEL = "Enable";

    @Getter
    protected final boolean managed;

    @Getter
    private boolean enabled = false;

    @Getter
    protected String text;

    @Getter
    protected String actionText;

    protected final Widget bgWidget;

	protected final Widget labelWidget;

	@Setter
	private ComponentEventListener<UIDropdownOption> enabledListener;

	public UIDropdownOption(Widget layerWidget) {
        super(layerWidget);
        this.managed = true;
        this.bgWidget = this.widget.createChild(WidgetType.RECTANGLE);
        this.labelWidget = this.widget.createChild(WidgetType.TEXT);

        this.setup();
        this.setupManaged();
	}

	public UIDropdownOption(Widget bgWidget, Widget labelWidget) {
        super(labelWidget);
        this.managed = false;
        this.bgWidget = bgWidget;
        this.labelWidget = labelWidget;

        this.setup();
	}

    private void setup() {
        this.setText(this.labelWidget.getText());
        this.setActionText(DEFAULT_ACTION_LABEL);

        // preserve current action label if possible
        String[] originalActions = this.labelWidget.getActions();
        if (originalActions != null && originalActions.length > 0) {
            this.setActionText(originalActions[0]);
        }

        this.enabled = this.bgWidget.getOpacity() < BG_OPACITY_INACTIVE;
        this.updateStatefulStyles();
    }

    private void setupManaged() {
        this.widget.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);

        this.bgWidget.setFilled(true);
        this.bgWidget.setTextColor(0xFFFFFF);
        this.bgWidget.setWidthMode(WidgetSizeMode.MINUS);
        this.bgWidget.setHeightMode(WidgetSizeMode.MINUS);

        this.labelWidget.setTextShadowed(true);
        this.labelWidget.setFontId(FontID.PLAIN_12);
        this.labelWidget.setWidthMode(WidgetSizeMode.MINUS);
        this.labelWidget.setHeightMode(WidgetSizeMode.MINUS);
        this.labelWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
        this.labelWidget.setYTextAlignment(WidgetTextAlignment.CENTER);

        this.setActionText(DEFAULT_ACTION_LABEL);
        this.enabled = false;
        this.updateStatefulStyles();
    }

    @Override
    @Deprecated
    public void addAction(String action, MenuAction callback) {
        throw new RuntimeException("Cannot add actions to this component; use .setActionLabel() to rename single action");
    }

    @Override
    public void setName(String name) {
        this.bgWidget.setName(name + "-bg");
        this.labelWidget.setName(name + "-label");
    }

    public void setText(String text) {
        this.text = text;
        this.labelWidget.setText(text);
    }

    public void setActionText(String actionText) {
        this.actionText = actionText;

        this.actions.clear();
        super.addAction(this.actionText, () -> this.setEnabled(true));
    }

    public void setEnabled(boolean enabled) {
        // prevents raising the events unnecessarily
        if (this.enabled == enabled) return;

        this.enabled = enabled;

        if (this.enabled && this.enabledListener != null) {
            this.enabledListener.onComponentEvent(this);
        }

        this.updateStatefulStyles();
    }

    @Override
    protected void onMouseHover(ScriptEvent e) {
        super.onMouseHover(e);

        if (this.isEnabled()) return;
        this.labelWidget.setTextColor(TEXT_COLOR_HIGHLIGHT);
    }

    @Override
    protected void onMouseLeave(ScriptEvent e) {
        super.onMouseLeave(e);

        if (this.isEnabled()) return;
        this.labelWidget.setTextColor(TEXT_COLOR_INACTIVE);
    }

    private void updateStatefulStyles() {
        if (this.isEnabled()) {
            this.bgWidget.setOpacity(BG_OPACITY_ACTIVE);
            this.labelWidget.setTextColor(TEXT_COLOR_ACTIVE);
            this.labelWidget.setOpacity(TEXT_OPACITY_ACTIVE);
        } else {
            this.bgWidget.setOpacity(BG_OPACITY_INACTIVE);
            this.labelWidget.setTextColor(TEXT_COLOR_INACTIVE);
            this.labelWidget.setOpacity(TEXT_OPACITY_INACTIVE);
        }

        this.revalidate();
    }

    public void revalidate() {
        super.revalidate();
        this.bgWidget.revalidate();
        this.labelWidget.revalidate();
    }
}

package com.logmaster.ui.generic.dropdown;

import com.logmaster.ui.generic.ComponentEventListener;
import com.logmaster.ui.generic.UIComponent;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import java.util.*;

@Slf4j
public class UIDropdown extends UIComponent {
    private static final int BORDER_WIDTH = 6;

    // TODO: find a better way to identify our widgets
    public static final String WIDGET_NAME = "clogmaster";

    private final List<UIDropdownOption> options;

	@Setter
	private ComponentEventListener<UIDropdownOption> optionEnabledListener;

	public UIDropdown(Widget widget) {
		super(widget, Set.of(WidgetType.LAYER));
        this.options = new ArrayList<>();
        this.setup();
	}

    private void setup() {
        Widget[] children = this.widget.getChildren();
        if (children == null) {
            return;
        }

        for (Widget c : children) {
            if (!c.getName().isEmpty()) {
                continue;
            }

            if (c.getType() == WidgetType.RECTANGLE) {
                // we assume every background (rectangle) widget is
                // directly succeeded by the matching text widget
                Widget textWidget = children[c.getIndex() + 1];
                UIDropdownOption option = new UIDropdownOption(c, textWidget);
                option.setEnabledListener(this::onOptionEnabled);
                this.options.add(option);
            }
        }
    }

    public void cleanup() {
        Widget tabContainer = this.widget;
        Widget[] children = tabContainer.getChildren();
        if (children == null || children.length == 0) {
            return;
        }

        for (UIDropdownOption opt : this.options) {
            if (!opt.isManaged()) continue;

            children[opt.getWidget().getIndex()] = null;
        }

        Widget[] newChildren = Arrays.stream(children)
            .filter(Objects::nonNull)
            .toArray(Widget[]::new);

        Widget[] nzNewChildren = Arrays.copyOf(children, newChildren.length);
        System.arraycopy(newChildren, 0, nzNewChildren, 0, newChildren.length);

        tabContainer.setChildren(nzNewChildren);
        tabContainer.revalidate();

        resizeTabsContainer();
    }

    public UIDropdownOption getEnabledOption() {
        for (UIDropdownOption opt : this.options) {
            if (opt.isEnabled()) {
                return opt;
            }
        }

        return null;
    }

    public void setEnabledOption(String text) {
        for (UIDropdownOption opt : this.options) {
            if (opt.getText().equals(text)) {
                opt.setEnabled(true);
            }
        }
    }

    public void addOption(String text, String actionText) {
        Widget tabContainer = this.widget;
        Widget[] children = tabContainer.getChildren();
        if (children == null || children.length == 0) {
            return;
        }

        Widget lastOption = this.options.get(this.options.size() - 1).getWidget();

        UIDropdownOption newOption = new UIDropdownOption(tabContainer.createChild(WidgetType.LAYER));
        newOption.setName(WIDGET_NAME);
        newOption.setSize(lastOption.getOriginalWidth(), lastOption.getOriginalHeight());
        newOption.setPosition(lastOption.getOriginalX(), lastOption.getOriginalY() + lastOption.getOriginalHeight());
        newOption.setText(text);
        newOption.setActionText(actionText);
        newOption.revalidate();
        newOption.setEnabledListener(this::onOptionEnabled);

        this.options.add(newOption);

        resizeTabsContainer();
    }

    void onOptionEnabled(UIDropdownOption src) {
        for (UIDropdownOption ui : this.options) {
            if (ui == src) continue;
            ui.setEnabled(false);
        }

        // close dropdown
        this.widget.setHidden(true)
            .revalidate();

        if (this.optionEnabledListener != null) {
            this.optionEnabledListener.onComponentEvent(src);
        }
    }

    void resizeTabsContainer() {
        Widget tabContainer = this.widget;
        Widget[] children = tabContainer.getChildren();
        if (children == null) {
            return;
        }

        Widget lastOption = this.options.get(this.options.size() - 1).getWidget();

        tabContainer.setOriginalHeight(lastOption.getOriginalY() + lastOption.getOriginalHeight() + BORDER_WIDTH);
        tabContainer.revalidate();

        // recalculates the position and sizes for the border and background widgets
        for (Widget c : children) {
            c.revalidate();
        }
    }
}

package com.logmaster.ui.generic;

import lombok.Getter;

import java.util.ArrayList;
import java.util.List;

/**
 * A group of UIComponents
 * @author Antipixel
 */
public class UIPage
{
	@Getter
	private boolean visible;
	private List<UIComponent> components;

	/**
	 * Constructs a new UI page
	 */
	public UIPage()
	{
		this.components = new ArrayList<>();
	}

	/**
	 * Sets the visibility for all the components in the page
	 * @param visibility true for visible, false for hidden
	 */
	public void setVisibility(boolean visibility)
	{
		this.visible = visibility;
		// Update the visibility for each of the components
		this.components.forEach(c -> c.setVisibility(visibility));
	}

	/**
	 * Adds a UI component to the page
	 * @param component the component to add
	 */
	public void add(UIComponent component)
	{
		this.components.add(component);
	}

	/**
	 * Removes a UI component from the page
	 * @param component the component to remove
	 */
	public void remove(UIComponent component)
	{
		this.components.remove(component);
	}
}

package com.logmaster.ui.generic;

/**
 * A listener interface for receiving UI component events
 * @author Antipixel
 */
public interface ComponentEventListener<T extends UIComponent>
{
	/**
	 * Invoked upon a component event
	 * @param src the source component responsible for the event
	 */
	void onComponentEvent(T src);
}


package com.logmaster.ui.generic;

import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;

import java.awt.*;

/**
 * This class wraps a game widget and gives it the functionality of
 * a text label component, with basic control over text colour and font.
 * @author Antipixel
 */
public class UILabel extends UIComponent
{
	/**
	 * Constructs a new label component
	 * @param labelWidget the underlying widget
	 */
	public UILabel(Widget labelWidget)
	{
		super(labelWidget);

		// Set default font and text colour
		this.setFont(FontID.PLAIN_11);
		this.setColour(Color.WHITE.getRGB());

		// Set the alignment to centre and enable text shadowing
		labelWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setTextShadowed(true);
	}

	/**
	 * Sets the display text of the label
	 * @param text the display text
	 */
	public void setText(String text)
	{

		this.getWidget().setText(text);
	}

	/**
	 * Sets the font of the label
	 * @param fontID the font ID, specified in {@link FontID}
	 */
	public void setFont(int fontID)
	{
		this.getWidget().setFontId(fontID);
	}

	/**
	 * Sets the colour of the label text
	 * @param colour the RGB colour
	 */
	public void setColour(int colour)
	{
		this.getWidget().setTextColor(colour);
	}
}

package com.logmaster.ui.generic;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;

/**
 * Functionally identical to the UI Button, except the opacity
 * of the widget is dimmed when the mouse moves over the component
 * @author Antipixel
 */
public class UIFadeButton extends UIButton
{
	private static final float FADE_OPACITY = 0.75f;
	private static final float DEFAULT_OPACITY = 1.0f;

	public UIFadeButton(Widget widget)
	{
		super(widget);
	}

	@Override
	protected void onMouseHover(ScriptEvent e)
	{
		super.onMouseHover(e);

		// Fade the widget
		this.setOpacity(FADE_OPACITY);
	}

	@Override
	protected void onMouseLeave(ScriptEvent e)
	{
		super.onMouseLeave(e);

		// Set the widget back to full opacity
		this.setOpacity(DEFAULT_OPACITY);
	}
}

package com.logmaster.ui.generic;

/**
 * A listener interface for receiving menu actions
 * @author Antipixel
 */
public interface MenuAction
{
	/**
	 * Invoked upon selection of the menu action that is is bound to
	 */
	void onMenuAction();
}

package com.logmaster.ui.generic;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps two widgets, one a sprite and one text, and gives them the
 * functionality of a checkbox component. A listener can be added to the checkbox
 * which triggers upon the switching of the checkbox state between check and unchecked.
 * @author Antipixel
 */
public class UICheckBox extends UIComponent
{
	private static final int LABEL_COL_DEFAULT = 0xFF981F;
	private static final int LABEL_COL_HOVER = 0xFFFFFF;
	private static final int LABEL_WIDTH = 89;
	private static final int LABEL_HEIGHT = 18;

	private static final int SPRITEID_CHECKBOX_UNCHECKED_STD = 1215;
	private static final int SPRITEID_CHECKBOX_CHECKED_STD = 1217;
	private static final int SPRITEID_CHECKBOX_UNCHECKED_HOV = 1218;
	private static final int SPRITEID_CHECKBOX_CHECKED_HOV = 1220;
	private static final int CHECKBOX_SIZE = 16;

	private static final String OPTION_TOGGLE = "Toggle";

	private UILabel label;
	private UIGraphic checkbox;

	@Getter
	private boolean enabled;
	private boolean hovering;

	@Setter
	private ComponentEventListener<UICheckBox> toggleListener;

	/**
	 * Constructs a new checkbox component
	 * @param boxIcon the checkbox graphic widget
	 * @param labelWidget the checkbox label widget
	 */
	public UICheckBox(Widget boxIcon, Widget labelWidget)
	{
		super(boxIcon);

		this.enabled = false;
		this.hovering = false;

		// Wrap the widget in a label component, set the
		// dimension, colour and attach the listeners
		this.label = new UILabel(labelWidget);
		this.label.setSize(LABEL_WIDTH, LABEL_HEIGHT);
		this.label.setColour(LABEL_COL_DEFAULT);
		this.label.setOnHoverListener(this::onLabelHover);
		this.label.setOnLeaveListener(this::onLabelLeave);
		this.label.addAction(OPTION_TOGGLE, this::onCheckboxToggled);

		this.checkbox = new UIGraphic(boxIcon);
		this.checkbox.addAction(OPTION_TOGGLE, this::onCheckboxToggled);
		this.checkbox.setOnHoverListener(e -> onLabelHover(label));
		this.checkbox.setOnLeaveListener(e -> onLabelLeave(label));

		// Resize and update the sprite for the checkbox widget
		this.updateCheckboxSprite();
		this.setSize(CHECKBOX_SIZE, CHECKBOX_SIZE);
	}

	/**
	 * Called upon the mouse hovering over the label component
	 * @param src the label component
	 */
	private void onLabelHover(UIComponent src)
	{
		// Update the hovering state
		this.hovering = true;

		// Update the label colour
		UILabel label = (UILabel) src;
		label.setColour(LABEL_COL_HOVER);

		// Make sure the checkbox sprite is up to date
		this.updateCheckboxSprite();
	}

	/**
	 * Called upon the mouse leaving the label component
	 * @param src the label component
	 */
	private void onLabelLeave(UIComponent src)
	{
		// Update the hovering state
		this.hovering = false;

		// Update the label colour
		UILabel label = (UILabel) src;
		label.setColour(LABEL_COL_DEFAULT);

		// Make sure the checkbox sprite is up to date
		this.updateCheckboxSprite();
	}

	@Override
	public void setX(int x)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setX(x);
		this.label.setX(x);
	}

	@Override
	public void setY(int y)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setY(y);
		this.label.setY(y);
	}

	@Override
	public void setName(String name)
	{
		// Set the name of the label instead
		this.label.setName(name);
	}

	/**
	 * Called upon the toggle menu action being selected on the checkbox component
	 */
	private void onCheckboxToggled()
	{
		// Switch the checked state
		this.setEnabled(!enabled);

		// If there's a toggle listener registered, call it
		if (this.toggleListener != null)
			this.toggleListener.onComponentEvent(this);
	}

	/**
	 * Updates the sprite for the checkbox, depending on whether the checkbox
	 * is enabled or disabled, or if the mouse is hovering over it
	 */
	private void updateCheckboxSprite()
	{
		// Get both standard and hovering sprites for the current enable state
		int stdSprite = enabled ? SPRITEID_CHECKBOX_CHECKED_STD : SPRITEID_CHECKBOX_UNCHECKED_STD;
		int hovSprite = enabled ? SPRITEID_CHECKBOX_CHECKED_HOV : SPRITEID_CHECKBOX_UNCHECKED_HOV;

		// Apply it to the checkbox widget, depending on whether the mouse is hovering
		this.getWidget().setSpriteId(this.hovering ? hovSprite : stdSprite);
	}

	/**
	 * Sets the state of the checkbox, checked or unchecked
	 * @param enabled true for checked, false for unchecked
	 */
	public void setEnabled(boolean enabled)
	{
		// Set the new state
		this.enabled = enabled;

		// Update the sprite
		this.updateCheckboxSprite();
	}

	/**
	 * Sets the text of the checkbox label
	 * @param text the label text
	 */
	public void setText(String text)
	{
		this.label.setText(text);
	}

	// Align checkbox to right hand side of the window near the close button
	public void alignToRightEdge(Widget window, int marginFromEdge, int y)
	{
		int windowWidth = window.getWidth();
		int checkboxX = windowWidth - LABEL_WIDTH - CHECKBOX_SIZE - marginFromEdge;
		this.setPosition(checkboxX, y);
		
		// Force widget position updates
		this.getWidget().setPos(checkboxX, y);
		this.label.getWidget().setPos(checkboxX + CHECKBOX_SIZE + 4, y); // 4px spacing between checkbox and label
		
		// Revalidate widgets
		this.getWidget().revalidate();
		this.label.getWidget().revalidate();
	}
}

package com.logmaster.ui.generic;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * UI Component classes allow for complex user interface functionality by
 * wrapping the gaming widget and carefully controlling its behaviour
 * @author Antipixel
 */
public abstract class UIComponent
{
	private static final int MAX_OPACITY = 255;
	private static final String BTN_NAME_FORMAT = "<col=ff9040>%s</col>";

	@Getter
	protected Widget widget;

	/* Actions and events */
	protected List<MenuAction> actions;

	@Setter
	private ComponentEventListener<UIComponent> hoverListener;

	@Setter
	private ComponentEventListener<UIComponent> leaveListener;

	@Setter
	private ComponentEventListener<UIComponent> mousePressListener;

	@Setter
	private ComponentEventListener<UIComponent> mouseDragListener;

	@Setter
	private ComponentEventListener<UIComponent> mouseReleaseListener;

	/**
	 * Constructs a new UIComponent
	 * @param widget the underlying game widget
	 */
	public UIComponent(Widget widget)
	{
		this.widget = widget;

		// Assign the event listeners to the widget
		this.widget.setOnOpListener((JavaScriptCallback) this::onActionSelected);
		this.widget.setOnMouseOverListener((JavaScriptCallback) this::onMouseHover);
		this.widget.setOnMouseLeaveListener((JavaScriptCallback) this::onMouseLeave);
		this.widget.setHasListener(true);

		this.actions = new ArrayList<>();
	}

	public UIComponent(Widget widget, Set<Integer> allowedTypes) {
		this(widget);

		if (!allowedTypes.contains(widget.getType())) {
			String msg = String.format("Incompatible widget's type given; %s given, %d expected", allowedTypes, widget.getType());
			throw new RuntimeException(msg);
		}
	}

	/**
	 * Adds an action option to the component's menu
	 * @param action the action name
 	 * @param callback the callback event, which is trigger upon the
	 *                 selection of this menu option
	 */
	public void addAction(String action, MenuAction callback)
	{
		this.widget.setAction(actions.size(), action);
		this.actions.add(callback);
	}

	/**
	 * Triggered upon the selection of menu option
	 * @param e the script event
	 */
	protected void onActionSelected(ScriptEvent e)
	{
		// If there's no actions specified, ignore
		if (this.actions.isEmpty())
			return;

		// Get the action event object for this menu option
		MenuAction actionEvent = this.actions.get(e.getOp() - 1);

		// Call the action listener for this option
		actionEvent.onMenuAction();
	}

	/**
	 * Triggered upon the mouse entering the component
	 * @param e the script event
	 */
	protected void onMouseHover(ScriptEvent e)
	{
		// If a hover event is specified, trigger it
		if (this.hoverListener != null)
			this.hoverListener.onComponentEvent(this);
	}

	/**
	 * Triggered upon the mouse leaving the component
	 * @param e the script event
	 */
	protected void onMouseLeave(ScriptEvent e)
	{
		// If a leave event is specified, trigger it
		if (this.leaveListener != null)
			this.leaveListener.onComponentEvent(this);
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * hovering over the widget
	 * @param listener the listener
	 */
	public void setOnHoverListener(ComponentEventListener<UIComponent> listener)
	{
		this.hoverListener = listener;
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * exiting from over the widget
	 * @param listener the listener
	 */
	public void setOnLeaveListener(ComponentEventListener<UIComponent> listener)
	{
		this.leaveListener = listener;
	}

	/**
	 * Sets the name of the component widget
	 * @param name the component name
	 */
	public void setName(String name)
	{
		this.widget.setName(String.format(BTN_NAME_FORMAT, name));
	}

	/**
	 * Sets the component size
	 * @param width the component width
	 * @param height the component height
	 */
	public void setSize(int width, int height)
	{
		this.widget.setOriginalWidth(width);
		this.widget.setOriginalHeight(height);
	}

	public void setSizeMode(int widthMode, int heightMode)
	{
		this.widget.setWidthMode(widthMode);
		this.widget.setHeightMode(heightMode);
	}

	/**
	 * Sets the position of the component, relative
	 * to the parent layer widget
	 * @param x the x position
	 * @param y the y position
	 */
	public void setPosition(int x, int y)
	{
		this.setX(x);
		this.setY(y);
	}

	/**
	 * Sets the X position of the component, relative
	 * to the parent layer
	 * @param x the x position
	 */
	public void setX(int x)
	{
		this.widget.setOriginalX(x);
	}

	/**
	 * Sets the Y position of the component, relative
	 * to the parent layer
	 * @param y the x position
	 */
	public void setY(int y)
	{
		this.widget.setOriginalY(y);
	}

	/**
	 * Gets the X position of the component, relative
	 * to the the parent layer
	 * @return the x position
	 */
	public int getX()
	{
		return this.widget.getOriginalX();
	}

	/**
	 * Gets the Y position of the component, relative
	 * to the the parent layer
	 * @return the y position
	 */
	public int getY()
	{
		return this.widget.getOriginalY();
	}


	/**
	 * Sets the visibility of the component
	 * @param visible true for visible, false for hidden
	 */
	public void setVisibility(boolean visible)
	{
		this.widget.setHidden(!visible);
	}

	/**
	 * Sets the opacity of the widget
	 * @param opacity the opacity value. Expects a value
	 *                between 0.0 (transparent) and 1.0 (opaque)
	 */
	public void setOpacity(float opacity)
	{
		// Cap the opacity to 1.0
		if (opacity > 1.0)
			opacity = 1.0f;

		// Invert the percentage
		float percentage = 1.0f - opacity;

		// Convert the percentage value to a 0-255 integer
		this.widget.setOpacity((int)(percentage * MAX_OPACITY));
	}

	/**
	 * Gets the opacity of the widget
	 * @return an opacity value between 0.0 (transparent) and 1.0 (opaque)
	 */
	public float getOpacity()
	{
		// Convert the opacity to a percentage
		float opacity = (float)this.widget.getOpacity() / MAX_OPACITY;

		// Invert the percentage
		return 1.0f - opacity;
	}

	public void clearActions() {
		actions.clear();
	}

	public void revalidate() {
		this.widget.revalidate();
	}
}

package com.logmaster.ui.generic;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a button, with the option of a second sprite shown on hover
 * @author Antipixel
 */
public class UIButton extends UIComponent
{
	private int spriteStandard;
	private int spriteHover;

	/**
	 * Constructs a new button component
	 * @param widget the underlying widget
	 */
	public UIButton(Widget widget)
	{
		super(widget);

		// Blank the sprites
		this.spriteStandard = -1;
		this.spriteHover = -1;
	}

	@Override
	protected void onMouseHover(ScriptEvent e)
	{
		// Call the parent method
		super.onMouseHover(e);

		// Update the sprite
		this.getWidget().setSpriteId(this.spriteHover);
	}

	@Override
	protected void onMouseLeave(ScriptEvent e)
	{
		// Call the parent method
		super.onMouseLeave(e);

		// Update the sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	/**
	 * Sets the button sprite for both standard and hover
	 * @param standard the standard sprite id
	 * @param hover the sprite to display on hover
	 */
	public void setSprites(int standard, int hover)
	{
		this.spriteStandard = standard;
		this.spriteHover = hover;

		// Update the widgets sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	/**
	 * Sets the sprite for the button, for buttons
	 * without a sprite for hovering state
	 * @param standard the button sprite
	 */
	public void setSprites(int standard)
	{
		this.setSprites(standard, standard);
	}
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.ui.InterfaceManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class TaskOverlay extends Overlay {

    private static final Dimension EMPTY = new Dimension(0, 0);

    private static final int WIDTH_ADDITION = 51;
    private static final int MIN_HEIGHT = 46;

    private static final float OUTER_COLOR_OFFSET = 0.8f;
    private static final float INNER_COLOR_OFFSET = 1.2f;
    private static final float ALPHA_OFFSET = 1.4f;

    private static final int MAX_BYTE = 255;

    @Inject
    private LogMasterPlugin plugin;

    @Inject
    private LogMasterConfig config;

    @Inject
    private RuneLiteConfig runeLiteConfig;

    @Inject
    private ItemManager itemManager;

    @Inject
    private InterfaceManager interfaceManager;

    @Inject
    private SaveDataManager saveDataManager;

    @Override
    public Dimension render(Graphics2D g) {
        try {
            Task currentTask = saveDataManager.currentTask();
            if (!config.displayCurrentTaskOverlay() || currentTask == null || interfaceManager.isDashboardOpen()) {
                return EMPTY;
            }

            Image icon = itemManager.getImage(currentTask.getDisplayItemId());
            String task = currentTask.getName();


            FontMetrics fm = g.getFontMetrics();

            int width = fm.stringWidth(task) + WIDTH_ADDITION;
            int height = MIN_HEIGHT;

            Color border = outsideColor(this.runeLiteConfig.overlayBackgroundColor());

            g.setColor(this.runeLiteConfig.overlayBackgroundColor());
            g.fillRect(0, 0, width, height);
            g.setColor(border);
            g.drawRect(0, 0, width, height);

//            int textX = 46;
            int textX = width - fm.stringWidth(task) - 5;
            int textY = 30;

            g.setFont(g.getFont().deriveFont(16f));
            g.setColor(Color.BLACK);
            g.drawString(task, textX + 1, textY + 1);
            g.setColor(Color.WHITE);
            g.drawString(task, textX, textY);

            int iconWidth = icon.getWidth(null);
            int iconHeight = icon.getHeight(null);

            g.drawImage(icon, 5 + 18 - (iconWidth / 2), 5 + 18 - (iconHeight / 2), iconWidth, iconHeight, null);
            return new Dimension(width, height);
        } catch (Throwable t) {
            t.printStackTrace();
            return EMPTY;
        }
    }

    private Color outsideColor(Color base) {
        return new Color(
                Math.round(base.getRed() * OUTER_COLOR_OFFSET),
                Math.round(base.getGreen() * OUTER_COLOR_OFFSET),
                Math.round(base.getBlue() * OUTER_COLOR_OFFSET),
                Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
        );
    }

    private Color innerColor(Color base) {
        return new Color(
                Math.min(MAX_BYTE, Math.round(base.getRed() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getGreen() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getBlue() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
        );
    }
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import com.logmaster.ui.generic.UILabel;
import com.logmaster.ui.generic.UIPage;
import lombok.Getter;
import net.runelite.api.FontID;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.swing.*;
import java.awt.*;
import java.util.List;

import static com.logmaster.LogMasterPlugin.getCenterX;
import static com.logmaster.LogMasterPlugin.getCenterY;
import static com.logmaster.ui.InterfaceConstants.COLLECTION_LOG_WINDOW_HEIGHT;
import static com.logmaster.ui.InterfaceConstants.COLLECTION_LOG_WINDOW_WIDTH;

public class TaskDashboard extends UIPage {
    private final int DEFAULT_BUTTON_WIDTH = 140;
    private final int DEFAULT_BUTTON_HEIGHT = 30;
    private final int DEFAULT_TASK_DETAILS_WIDTH = 300;
    private final int DEFAULT_TASK_DETAILS_HEIGHT = 75;
    private final int GENERATE_TASK_SPRITE_ID = -20001;
    private final int COMPLETE_TASK_SPRITE_ID = -20000;
    private final int GENERATE_TASK_HOVER_SPRITE_ID = -20003;
    private final int COMPLETE_TASK_HOVER_SPRITE_ID = -20002;
    private final int GENERATE_TASK_DISABLED_SPRITE_ID = -20005;
    private final int COMPLETE_TASK_DISABLED_SPRITE_ID = -20004;
    private final int TASK_BACKGROUND_SPRITE_ID = -20006;
    private final int FAQ_BUTTON_SPRITE_ID = -20027;
    private final int FAQ_BUTTON_HOVER_SPRITE_ID = -20028;

    @Getter
    private Widget window;
    private LogMasterPlugin plugin;

    private LogMasterConfig config;

    private final TaskService taskService;

    private final SaveDataManager saveDataManager;

    private UILabel title;
    private UILabel taskLabel;
    private UILabel percentCompletion;

    private UIGraphic taskImage;
    private UIGraphic taskBg;

    private UIButton completeTaskBtn;
    private UIButton generateTaskBtn;
    private UIButton faqBtn;

    public TaskDashboard(LogMasterPlugin plugin, LogMasterConfig config, Widget window, TaskService taskService, SaveDataManager saveDataManager) {
        this.window = window;
        this.plugin = plugin;
        this.config = config;
        this.taskService = taskService;
        this.saveDataManager = saveDataManager;

        createTaskDetails();

        Widget titleWidget = window.createChild(-1, WidgetType.TEXT);
        this.title = new UILabel(titleWidget);
        this.title.setFont(FontID.QUILL_CAPS_LARGE);
        this.title.setSize(COLLECTION_LOG_WINDOW_WIDTH, DEFAULT_TASK_DETAILS_HEIGHT);
        this.title.setPosition(getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH), 24);
        this.title.setText("Current Task");

        Widget percentWidget = window.createChild(-1, WidgetType.TEXT);
        this.percentCompletion = new UILabel(percentWidget);
        this.percentCompletion.setFont(FontID.BOLD_12);
        this.percentCompletion.setSize(COLLECTION_LOG_WINDOW_WIDTH, 25);
        this.percentCompletion.setPosition(getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH), COLLECTION_LOG_WINDOW_HEIGHT - 91);
        updatePercentages();

        Widget completeTaskWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.completeTaskBtn = new UIButton(completeTaskWidget);
        this.completeTaskBtn.setSize(DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        this.completeTaskBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) + (DEFAULT_BUTTON_WIDTH / 2 + 15), getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62);
        this.completeTaskBtn.setSprites(COMPLETE_TASK_SPRITE_ID, COMPLETE_TASK_HOVER_SPRITE_ID);

        Widget generateTaskWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.generateTaskBtn = new UIButton(generateTaskWidget);
        this.generateTaskBtn.setSize(DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        this.generateTaskBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) - (DEFAULT_BUTTON_WIDTH / 2 + 15), getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62);
        this.generateTaskBtn.setSprites(GENERATE_TASK_SPRITE_ID, GENERATE_TASK_HOVER_SPRITE_ID);

        Widget faqWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.faqBtn = new UIButton(faqWidget);
        this.faqBtn.setSize(DEFAULT_BUTTON_WIDTH/2, DEFAULT_BUTTON_HEIGHT);
        this.faqBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) + 238, getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112);
        this.faqBtn.setSprites(FAQ_BUTTON_SPRITE_ID, FAQ_BUTTON_HOVER_SPRITE_ID);

        this.add(this.title);
        this.add(this.taskBg);
        this.add(this.taskLabel);
        this.add(this.taskImage);
        this.add(this.completeTaskBtn);
        this.add(this.generateTaskBtn);
        this.add(this.percentCompletion);
        this.add(faqBtn);
    }

    private void createTaskDetails() {
        final int POS_X = getCenterX(window, DEFAULT_TASK_DETAILS_WIDTH);
        final int POS_Y = getCenterY(window, DEFAULT_TASK_DETAILS_HEIGHT)-3;

        Widget taskBgWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.taskBg = new UIGraphic(taskBgWidget);
        this.taskBg.setSize(DEFAULT_TASK_DETAILS_WIDTH, DEFAULT_TASK_DETAILS_HEIGHT);
        this.taskBg.setPosition(POS_X, POS_Y);
        this.taskBg.setSprite(TASK_BACKGROUND_SPRITE_ID);

        Widget label = window.createChild(-1, WidgetType.TEXT);
        label.setTextColor(Color.WHITE.getRGB());
        label.setTextShadowed(true);
        label.setName("Task Label");
        this.taskLabel = new UILabel(label);
        this.taskLabel.setFont(496);
        this.taskLabel.setPosition(POS_X+60, POS_Y);
        this.taskLabel.setSize(DEFAULT_TASK_DETAILS_WIDTH-60, DEFAULT_TASK_DETAILS_HEIGHT);

        Widget taskImageWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.taskImage = new UIGraphic(taskImageWidget);
        this.taskImage.setPosition(POS_X+12, POS_Y+21);
        this.taskImage.getWidget().setItemQuantityMode(ItemQuantityMode.NEVER);
        this.taskImage.setSize(42, 36);
        this.taskImage.getWidget().setBorderType(1);
    }

    public void setTask(String desc, int taskItemID, List<Task> cyclingTasks) {
        if (cyclingTasks != null) {
            for (int i = 0; i < 250; i++) {
                Task displayTask = cyclingTasks.get((int) Math.floor(Math.random() * cyclingTasks.size()));
                // Seems the most natural timing
                double decay = 450.0 / ((double) config.rollTime());
                int delay = (int) ((config.rollTime() * 0.925) * Math.exp(-decay * i));
                Timer fakeTaskTimer = new Timer(delay, ae -> {
                    this.taskLabel.setText(displayTask.getName());
                    this.taskImage.setItem(displayTask.getDisplayItemId());
                });
                fakeTaskTimer.setRepeats(false);
                fakeTaskTimer.setCoalesce(true);
                fakeTaskTimer.start();
            }
            Timer realTaskTimer = new Timer(config.rollTime(), ae -> {
                this.taskLabel.setText(desc);
                this.taskImage.setItem(taskItemID);
                this.enableCompleteTask();
                this.enableFaqButton();
            });
            realTaskTimer.setRepeats(false);
            realTaskTimer.setCoalesce(true);
            realTaskTimer.start();
        } else {
            this.taskLabel.setText(desc);
            this.taskImage.setItem(taskItemID);
            this.enableCompleteTask();
            this.enableFaqButton();
        }
    }

    public void updatePercentages() {
        if (this.plugin != null && taskService.completionPercentages(saveDataManager.getSaveData()) != null && this.plugin.getCurrentTier() != null) {
            Integer percentage = taskService.completionPercentages(saveDataManager.getSaveData()).get(this.plugin.getCurrentTier());
            if (percentage != null) {
                this.percentCompletion.setText("<col=" + getCompletionColor(percentage) + ">" + percentage + "%</col> " + this.plugin.getCurrentTier().displayName + " Completed");
            }
        }
    }

    private String getCompletionColor(double percent) {
        int max = 255;
        int amount = (int) Math.round(((percent % 50) / 50) * max);

        if(percent == 100) {
            return "00ff00";
        }
        else if(percent > 50) {
            int redValue = max - amount;
            return String.format("%02x", redValue)+"ff00";

        }
        else if(percent == 50) {
            return "ffff00";
        }
        else {
            return "ff"+String.format("%02x", amount)+"00";
        }
    }

    public void disableGenerateTask() {
        disableGenerateTask(true);
    }

    public void disableGenerateTask(boolean enableComplete) {
        this.generateTaskBtn.setSprites(GENERATE_TASK_DISABLED_SPRITE_ID);
        this.generateTaskBtn.clearActions();

        this.generateTaskBtn.addAction("Disabled", plugin::playFailSound);

        if (enableComplete) {
            this.enableCompleteTask();
            this.enableFaqButton();
        }
    }

    public void enableGenerateTask() {
        this.generateTaskBtn.clearActions();
        this.generateTaskBtn.setSprites(GENERATE_TASK_SPRITE_ID, GENERATE_TASK_HOVER_SPRITE_ID);
        this.generateTaskBtn.addAction("Generate task", plugin::generateTask);

        this.disableCompleteTask();
    }

    public void disableCompleteTask() {
        this.completeTaskBtn.setSprites(COMPLETE_TASK_DISABLED_SPRITE_ID);
        this.completeTaskBtn.clearActions();

        this.completeTaskBtn.addAction("Disabled", plugin::playFailSound);
    }

    public void enableCompleteTask() {
        this.completeTaskBtn.clearActions();
        this.completeTaskBtn.setSprites(COMPLETE_TASK_SPRITE_ID, COMPLETE_TASK_HOVER_SPRITE_ID);
        this.completeTaskBtn.addAction("Complete", plugin::completeTask);
    }

    public void enableFaqButton() {
        this.faqBtn.clearActions();
        this.faqBtn.setSprites(FAQ_BUTTON_SPRITE_ID, FAQ_BUTTON_HOVER_SPRITE_ID);
        this.faqBtn.addAction("FAQ", plugin::visitFaq);
    }

    public void updateBounds() {
        if (!this.isVisible()) {
            return;
        }

        int windowWidth = window.getWidth();

        // Update title position - force widget position update
        int titleX = getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH);
        this.title.setPosition(titleX, 24);
        this.title.getWidget().setPos(titleX, 24);

        // Update task details (background, label, image)
        final int taskPosX = getCenterX(window, DEFAULT_TASK_DETAILS_WIDTH);
        final int taskPosY = getCenterY(window, DEFAULT_TASK_DETAILS_HEIGHT) - 3;
        
        this.taskBg.setPosition(taskPosX, taskPosY);
        this.taskBg.getWidget().setPos(taskPosX, taskPosY);
        
        this.taskLabel.setPosition(taskPosX + 60, taskPosY);
        this.taskLabel.getWidget().setPos(taskPosX + 60, taskPosY);
        
        this.taskImage.setPosition(taskPosX + 12, taskPosY + 21);
        this.taskImage.getWidget().setPos(taskPosX + 12, taskPosY + 21);

        // Update button positions - force widget position updates
        int generateBtnX = getCenterX(window, DEFAULT_BUTTON_WIDTH) - (DEFAULT_BUTTON_WIDTH / 2 + 15);
        int generateBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62;
        this.generateTaskBtn.setPosition(generateBtnX, generateBtnY);
        this.generateTaskBtn.getWidget().setPos(generateBtnX, generateBtnY);
        
        int completeBtnX = getCenterX(window, DEFAULT_BUTTON_WIDTH) + (DEFAULT_BUTTON_WIDTH / 2 + 15);
        int completeBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62;
        this.completeTaskBtn.setPosition(completeBtnX, completeBtnY);
        this.completeTaskBtn.getWidget().setPos(completeBtnX, completeBtnY);
        
        // Update FAQ button position with boundary checking
        int faqBtnX = getCenterX(window, DEFAULT_BUTTON_WIDTH) + 238;
        int faqBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112;
        
        // Check if FAQ button would go outside the window and align with edge if needed
        int faqBtnWidth = DEFAULT_BUTTON_WIDTH / 2;
        if (faqBtnX + faqBtnWidth > windowWidth) {
            faqBtnX = windowWidth - faqBtnWidth - 10; // 10px margin from edge
        }
        
        this.faqBtn.setPosition(faqBtnX, faqBtnY);
        this.faqBtn.getWidget().setPos(faqBtnX, faqBtnY);

        // Update percentage completion position - force widget position update
        int percentX = getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH);
        int percentY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112; // Same Y as FAQ button
        this.percentCompletion.setPosition(percentX, percentY);
        this.percentCompletion.getWidget().setPos(percentX, percentY);
        
        // Force revalidation of all widgets
        this.title.getWidget().revalidate();
        this.taskBg.getWidget().revalidate();
        this.taskLabel.getWidget().revalidate();
        this.taskImage.getWidget().revalidate();
        this.generateTaskBtn.getWidget().revalidate();
        this.completeTaskBtn.getWidget().revalidate();
        this.faqBtn.getWidget().revalidate();
        this.percentCompletion.getWidget().revalidate();
    }
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.TaskTier;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import java.util.ArrayList;
import java.util.List;

import static com.logmaster.ui.InterfaceConstants.*;

public class TabManager {
    private final LogMasterConfig config;
    private final SaveDataManager saveDataManager;
    private final Widget window;
    
    private List<UIButton> tabs;
    private UIButton taskDashboardTab;
    
    private TaskDashboard taskDashboard;
    private TaskList taskList;
    private UIGraphic divider;

    public TabManager(Widget window, LogMasterConfig config, SaveDataManager saveDataManager) {
        this.window = window;
        this.config = config;
        this.saveDataManager = saveDataManager;
        
        createTabs();
        createDivider();
    }

    public void setComponents(TaskDashboard taskDashboard, TaskList taskList) {
        this.taskDashboard = taskDashboard;
        this.taskList = taskList;
    }

    private void createTabs() {
        // Remove any existing tabs from the window
        if (tabs != null) {
            for (UIButton tab : tabs) {
                if (tab != null && tab.getWidget() != null) {
                    tab.getWidget().setHidden(true);
                }
            }
        }
        tabs = new ArrayList<>();
        // Remove and recreate dashboard tab
        if (taskDashboardTab != null && taskDashboardTab.getWidget() != null) {
            taskDashboardTab.getWidget().setHidden(true);
        }
        Widget dashboardTabWidget = window.createChild(-1, WidgetType.GRAPHIC);
        taskDashboardTab = new UIButton(dashboardTabWidget);
        taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
        taskDashboardTab.setSize(95, 21);
        taskDashboardTab.setPosition(10, 0);
        taskDashboardTab.addAction("View <col=ff9040>Dashboard</col>", this::activateTaskDashboard);
        taskDashboardTab.setVisibility(false);
        // Always create all tabs for all tiers
        for (TaskTier tier : TaskTier.values()) {
            Widget tabWidget = window.createChild(-1, WidgetType.GRAPHIC);
            UIButton tab = new UIButton(tabWidget);
            tab.setSize(66, 21);
            tab.setVisibility(false);
            tabs.add(tab);
        }
    }

    private void createDivider() {
        Widget dividerWidget = window.createChild(-1, WidgetType.GRAPHIC);
        divider = new UIGraphic(dividerWidget);
        divider.setSprite(DIVIDER_SPRITE_ID);
        divider.setSize(window.getWidth() - 20, 1); // Full width minus margins
        divider.setPosition(10, 20);
    }

    public void updateBounds() {
        // Update divider width to match window width
        int windowWidth = window.getWidth();
        divider.setSize(windowWidth - 20, 1);
        divider.getWidget().setSize(windowWidth - 20, 1);
        divider.getWidget().revalidate();
        
        // Force widget position updates for all tabs
        taskDashboardTab.getWidget().revalidate();
        for (UIButton tab : tabs) {
            tab.getWidget().revalidate();
        }

        // Update tab positions
        updateTabPositions();
    }

    private void updateTabPositions() {
        int windowWidth = window.getWidth();
        int availableWidth = windowWidth - 20; // 10px margin on each side
        int dashboardTabWidth = 95;
        int regularTabWidth = 66;
        int minSpacing = -30; // Allow up to 30px overlap
        // Count only visible tabs
        int visibleTierTabs = 0;
        for (TaskTier tier : TaskTier.values()) {
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                visibleTierTabs++;
            }
        }
        int totalTabsWidth = dashboardTabWidth + (visibleTierTabs * regularTabWidth);
        int spacing = (availableWidth - totalTabsWidth) / (visibleTierTabs + 2);
        // Allow negative spacing for overlap, but not less than minSpacing
        spacing = Math.max(minSpacing, Math.min(10, spacing));
        int dashboardX = 10 + spacing;
        taskDashboardTab.setSize(dashboardTabWidth, 21);
        taskDashboardTab.setPosition(dashboardX, 0);
        taskDashboardTab.getWidget().setSize(dashboardTabWidth, 21);
        taskDashboardTab.getWidget().setPos(dashboardX, 0);
        int currentX = dashboardX + dashboardTabWidth + spacing;
        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                UIButton tab = tabs.get(tabIndex);
                tab.setSize(regularTabWidth, 21);
                tab.setPosition(currentX, 0);
                tab.getWidget().setSize(regularTabWidth, 21);
                tab.getWidget().setPos(currentX, 0);
                currentX += regularTabWidth + spacing;
            }
            tabIndex++;
        }
        // Revalidate all tabs
        for (UIButton tab : tabs) {
            tab.revalidate();
            tab.getWidget().revalidate();
        }
    }

    public void updateTabs() {
        hideTabs();
        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                if (tabs == null) {
                    return;
                }
                if (this.saveDataManager.getSaveData().getSelectedTier() == tier && !this.taskDashboard.isVisible()) {
                    tabs.get(tabIndex).setSprites(tier.tabSpriteHoverId);
                } else {
                    tabs.get(tabIndex).setSprites(tier.tabSpriteId, tier.tabSpriteHoverId);
                }
                int finalTabIndex = tabIndex;
                tabs.get(tabIndex).clearActions();
                tabs.get(tabIndex).setSize(66, 21);
                tabs.get(tabIndex).addAction(String.format("View <col=ff9040>%s Task List</col>", tier.displayName), () -> {
                    activateTaskListForTier(tier, finalTabIndex);
                });
            }
            tabIndex++;
        }
        showTabs();
    }

    private void activateTaskListForTier(TaskTier tier, int tabIndex) {
        taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
        if (this.saveDataManager.getSaveData().getSelectedTier() != tier) {
            this.taskList.goToTop();
            this.saveDataManager.getSaveData().setSelectedTier(tier);
            this.saveDataManager.save();
        }
        updateTabs();
        tabs.get(tabIndex).setSprites(tier.tabSpriteHoverId);
        this.taskDashboard.setVisibility(false);
        this.taskList.refreshTasks(0);
        this.taskList.setVisibility(true);
    }

    public void activateTaskDashboard() {
        this.taskDashboardTab.setSprites(DASHBOARD_TAB_HOVER_SPRITE_ID);
        this.taskList.setVisibility(false);
        this.taskDashboard.setVisibility(true);
        updateTabs();
    }

    public void hideTabs() {
        if (this.taskDashboardTab != null) {
            this.taskDashboardTab.setVisibility(false);
        }
        if (this.tabs != null) {
            this.tabs.forEach(t -> {
                t.setVisibility(false);
            });
        }
    }

    public void showTabs() {
        // Hide tabs if neither list is visible
        if (!this.taskList.isVisible() && !this.taskDashboard.isVisible()) {
            this.hideTabs();
            return;
        }
        if (this.taskDashboardTab != null) {
            this.taskDashboardTab.setVisibility(true);
        }
        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            UIButton tab = this.tabs.get(tabIndex);
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                tab.setVisibility(true);
            } else {
                // Move out of view before hiding
                tab.setPosition(-1000, 0);
                tab.getWidget().setPos(-1000, 0);
                tab.setVisibility(false);
            }
            tabIndex++;
        }
        updateTabPositions();
    }

    public void onConfigChanged() {
        createTabs();
        updateTabs();
    }
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import com.logmaster.ui.generic.UILabel;
import com.logmaster.ui.generic.UIPage;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;

import java.awt.*;
import java.awt.event.MouseWheelEvent;
import java.util.ArrayList;
import java.util.List;

import static com.logmaster.ui.InterfaceConstants.*;

@Slf4j
public class TaskList extends UIPage {
    private final int OFFSET_X = 0;
    private final int OFFSET_Y = 22;
    private final int TASK_WIDTH = 300;
    private final int TASK_HEIGHT = 50;
    private final int COLUMN_SPACING = 24;
    private final int TASK_ITEM_HEIGHT = 32;
    private final int TASK_ITEM_WIDTH = 36;
    private final int PAGE_UP_ARROW_SPRITE_ID = -20029;
    private final int UP_ARROW_SPRITE_ID = -20014;
    private final int DOWN_ARROW_SPRITE_ID = -20015;
    private final int PAGE_DOWN_ARROW_SPRITE_ID = -20030;
    private final int THUMB_TOP_SPRITE_ID = -20031;
    private final int THUMB_MIDDLE_SPRITE_ID = -20032;
    private final int THUMB_BOTTOM_SPRITE_ID = -20033;
    private final int ARROW_SPRITE_WIDTH = 39;
    private final int ARROW_SPRITE_HEIGHT = 20;
    private final int ARROW_Y_OFFSET = 4;
    private final int SCROLLBAR_WIDTH = 35; // Match arrow width
    private final int SCROLLBAR_THUMB_MIN_HEIGHT = 8;
    

    private final Widget window;
    private final TaskService taskService;
    private final LogMasterPlugin plugin;
    private final ClientThread clientThread;

    private final SaveDataManager saveDataManager;

    private Rectangle bounds = new Rectangle();

    private List<UIGraphic> taskBackgrounds = new ArrayList<>();
    private List<UILabel> taskLabels = new ArrayList<>();
    private List<UIGraphic> taskImages = new ArrayList<>();
    private Widget scrollbarTrackWidget;
    private Widget scrollbarThumbTopWidget;
    private Widget scrollbarThumbMiddleWidget;
    private Widget scrollbarThumbBottomWidget;
    private UIButton pageUpButton;
    private UIButton upArrowButton;
    private UIButton downArrowButton;
    private UIButton pageDownButton;
    private boolean isDraggingThumb = false;
    private int dragStartY = 0;
    private int dragStartTopIndex = 0;
    private int topTaskIndex = 0;
    private int totalTasks = 0;
    // default values, will update when bounds change
    private int windowWidth = 480;
    private int windowHeight = 252;
    private int wrapperX = 0;
    private int wrapperY = 0;
    private int wrapperHeight = 230;
    private int windowX = 0;
    private int windowY = 0;
    private int tasksPerPage = 20;
    private int columns = 1;

    public TaskList(Widget window, TaskService taskService, LogMasterPlugin plugin, ClientThread clientThread, SaveDataManager saveDataManager) {
        this.window = window;
        this.taskService = taskService;
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.saveDataManager = saveDataManager;

        updateBounds();

        createScrollbarComponents();
        this.add(upArrowButton);
        this.add(pageUpButton);
        this.add(downArrowButton);
        this.add(pageDownButton);

        // Refresh the tasks list
        refreshTasks(0);
    }

    private void createScrollbarComponents() {
        Widget pageUpWidget = window.createChild(-1, WidgetType.GRAPHIC);
        pageUpButton = new UIButton(pageUpWidget);
        pageUpButton.setSprites(PAGE_UP_ARROW_SPRITE_ID);
        pageUpButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        pageUpButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        pageUpButton.addAction("Page up", () -> refreshTasks(-tasksPerPage));

        Widget upWidget = window.createChild(-1, WidgetType.GRAPHIC);
        upArrowButton = new UIButton(upWidget);
        upArrowButton.setSprites(UP_ARROW_SPRITE_ID);
        upArrowButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        upArrowButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        upArrowButton.addAction("Scroll up", () -> refreshTasks(-1));

        scrollbarTrackWidget = window.createChild(-1, WidgetType.RECTANGLE);
        scrollbarTrackWidget.setFilled(true);
        scrollbarTrackWidget.setTextColor(0x665948);
        scrollbarTrackWidget.setSize(SCROLLBAR_WIDTH, 200);
        scrollbarTrackWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET);
        
        scrollbarThumbTopWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbTopWidget.setSpriteId(THUMB_TOP_SPRITE_ID);
        scrollbarThumbTopWidget.setSize(SCROLLBAR_WIDTH, 2);
        scrollbarThumbTopWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET);

        scrollbarThumbMiddleWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbMiddleWidget.setSpriteId(THUMB_MIDDLE_SPRITE_ID);
        scrollbarThumbMiddleWidget.setSize(SCROLLBAR_WIDTH, SCROLLBAR_THUMB_MIN_HEIGHT - 4);
        scrollbarThumbMiddleWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + 2);

        scrollbarThumbBottomWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbBottomWidget.setSpriteId(THUMB_BOTTOM_SPRITE_ID);
        scrollbarThumbBottomWidget.setSize(SCROLLBAR_WIDTH, 2);
        scrollbarThumbBottomWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + SCROLLBAR_THUMB_MIN_HEIGHT - 2);

        Widget downWidget = window.createChild(-1, WidgetType.GRAPHIC);
        downArrowButton = new UIButton(downWidget);
        downArrowButton.setSprites(DOWN_ARROW_SPRITE_ID);
        downArrowButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        downArrowButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        downArrowButton.addAction("Scroll down", () -> refreshTasks(1));

        Widget pageDownWidget = window.createChild(-1, WidgetType.GRAPHIC);
        pageDownButton = new UIButton(pageDownWidget);
        pageDownButton.setSprites(PAGE_DOWN_ARROW_SPRITE_ID);
        pageDownButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        pageDownButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        pageDownButton.addAction("Page down", () -> refreshTasks(tasksPerPage));
    }
    
    public void refreshTasks(int dir) {
        TaskTier relevantTier = plugin.getSelectedTier();
        if (relevantTier == null) {
            relevantTier = TaskTier.MASTER;
        }
        int tasksToShowCount = tasksPerPage * columns;
        totalTasks = taskService.getTaskList().getForTier(relevantTier).size();
        if (dir != 0) {
            int newIndex = topTaskIndex + (dir * columns);
            topTaskIndex = Math.min(Math.max(0, totalTasks - tasksToShowCount), Math.max(0, newIndex));
        }
        int rows = tasksPerPage;
        int totalTasksHeight = rows * TASK_HEIGHT;
        int verticalMargin = Math.max(0, (wrapperHeight - totalTasksHeight) / (rows - 1));
        int totalHeightWithMargin = totalTasksHeight + (rows > 1 ? (rows - 1) * verticalMargin : 0);
        int startY = OFFSET_Y + Math.max(0, (wrapperHeight - totalHeightWithMargin) / 2);
        int totalWidth = columns * TASK_WIDTH + (columns - 1) * COLUMN_SPACING;
        int startX = (windowWidth - totalWidth - SCROLLBAR_WIDTH - 10) / 2;
        hideUnusedTaskElements(tasksToShowCount);
        List<Task> tasksToShow = getTasksToShow(relevantTier, topTaskIndex, tasksToShowCount);
        int widgetIndex = 0;
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < columns; col++) {
                int i = row * columns + col;
                int taskY = startY + (row * (TASK_HEIGHT + verticalMargin));
                int taskX = startX + col * (TASK_WIDTH + COLUMN_SPACING);
                if (i > tasksToShowCount) break;
                // Create the task background
                UIGraphic taskBg;
                if (taskBackgrounds.size() <= widgetIndex) {
                    taskBg = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                    taskBackgrounds.add(taskBg);
                    this.add(taskBg);
                } else {
                    taskBg = taskBackgrounds.get(widgetIndex);
                }
                taskBg.getWidget().setHidden(false);
                taskBg.clearActions();
                taskBg.setSize(TASK_WIDTH, TASK_HEIGHT);
                taskBg.setPosition(taskX, taskY);
                taskBg.getWidget().setPos(taskX, taskY);
                taskBg.getWidget().revalidate();
                // Figure out which background we should be showing
                if (i < tasksToShow.size()) {
                    Task task = tasksToShow.get(i);
                    TaskTier finalRelevantTier = relevantTier;
                    taskBg.addAction("Mark", () -> plugin.completeTask(task.getId(), finalRelevantTier));
                    if (saveDataManager.getSaveData().getProgress().get(relevantTier).contains(task.getId())) {
                        taskBg.setSprite(TASK_COMPLETE_BACKGROUND_SPRITE_ID);
                    } else if (
                            saveDataManager.getSaveData().getActiveTaskPointer() != null
                                    && saveDataManager.getSaveData().getActiveTaskPointer().getTaskTier() == relevantTier
                                    && saveDataManager.getSaveData().getActiveTaskPointer().getTask().getId().equals(task.getId())
                    ) {
                        taskBg.setSprite(TASK_CURRENT_BACKGROUND_SPRITE_ID);
                    } else {
                        taskBg.setSprite(TASK_LIST_BACKGROUND_SPRITE_ID);
                    }
                } else {
                    taskBg.setSprite(TASK_LIST_BACKGROUND_SPRITE_ID);
                }
                UILabel taskLabel;
                if (taskLabels.size() <= widgetIndex) {
                    taskLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
                    this.add(taskLabel);
                    taskLabels.add(taskLabel);
                } else {
                    taskLabel = taskLabels.get(widgetIndex);
                }
                taskLabel.getWidget().setHidden(false);
                taskLabel.getWidget().setTextColor(Color.WHITE.getRGB());
                taskLabel.getWidget().setTextShadowed(true);
                if (i < tasksToShow.size()) {
                    Task task = tasksToShow.get(i);
                    taskLabel.getWidget().setName(task.getName());
                    taskLabel.setText(task.getName());
                } else {
                    taskLabel.getWidget().setName("");
                    taskLabel.setText("");
                }
                taskLabel.setFont(496);
                taskLabel.setPosition(taskX + 60, taskY);
                taskLabel.setSize(TASK_WIDTH-60, TASK_HEIGHT);
                taskLabel.getWidget().revalidate();
                UIGraphic taskImage;
                if(taskImages.size() <= widgetIndex) {
                    taskImage = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                    this.add(taskImage);
                    taskImages.add(taskImage);
                } else {
                    taskImage = taskImages.get(widgetIndex);
                }
                taskImage.getWidget().setHidden(false);
                taskImage.setPosition(taskX + 12, taskY + 6);
                taskImage.getWidget().setBorderType(1);
                taskImage.getWidget().setItemQuantityMode(ItemQuantityMode.NEVER);
                taskImage.setSize(TASK_ITEM_WIDTH, TASK_ITEM_HEIGHT);
                if (i < tasksToShow.size()) {
                    Task task = tasksToShow.get(i);
                    taskImage.setItem(task.getDisplayItemId());
                } else {
                    taskImage.setItem(-1);
                }
                taskImage.getWidget().revalidate();
                widgetIndex++;
            }
        }
        // Render the extra widget offscreen if needed
        if (widgetIndex == tasksToShowCount) {
            UIGraphic taskBg;
            if (taskBackgrounds.size() <= widgetIndex) {
                taskBg = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                taskBackgrounds.add(taskBg);
                this.add(taskBg);
            } else {
                taskBg = taskBackgrounds.get(widgetIndex);
            }
            taskBg.getWidget().setHidden(false);
            taskBg.setPosition(-1000, 0);
            taskBg.getWidget().setPos(-1000, 0);
            taskBg.getWidget().revalidate();
            UILabel taskLabel;
            if (taskLabels.size() <= widgetIndex) {
                taskLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
                this.add(taskLabel);
                taskLabels.add(taskLabel);
            } else {
                taskLabel = taskLabels.get(widgetIndex);
            }
            taskLabel.getWidget().setHidden(false);
            taskLabel.setPosition(-1000, 0);
            taskLabel.getWidget().setPos(-1000, 0);
            taskLabel.getWidget().revalidate();
            UIGraphic taskImage;
            if(taskImages.size() <= widgetIndex) {
                taskImage = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                this.add(taskImage);
                taskImages.add(taskImage);
            } else {
                taskImage = taskImages.get(widgetIndex);
            }
            taskImage.getWidget().setHidden(false);
            taskImage.setPosition(-1000, 0);
            taskImage.getWidget().setPos(-1000, 0);
            taskImage.getWidget().revalidate();
        }
        updateScrollbar();
    }

    // Overload getTasksToShow to accept a count
    private List<Task> getTasksToShow(TaskTier relevantTier, int topTaskIndex, int count) {
        List<Task> tasksToShow = new ArrayList<>();
        List<Task> taskList = taskService.getTaskList().getForTier(relevantTier);
        for (int i = 0; i < count; i++) {
            if (topTaskIndex + i >= taskList.size()) break;
            tasksToShow.add(taskList.get(topTaskIndex + i));
        }
        return tasksToShow;
    }

    private void hideUnusedTaskElements(int visibleCount) {
        // Only hide widgets beyond visibleCount (which is visibleTasks+1)
        for (int i = visibleCount; i < taskBackgrounds.size(); i++) {
            UIGraphic bg = taskBackgrounds.get(i);
            bg.getWidget().setHidden(true);
            bg.setPosition(-1000, 0);
            bg.getWidget().setPos(-1000, 0);
            bg.setSprite(TRANSPARENT_SPRITE_ID);
        }
        for (int i = visibleCount; i < taskLabels.size(); i++) {
            UILabel label = taskLabels.get(i);
            label.getWidget().setHidden(true);
            label.setPosition(-1000, 0);
            label.getWidget().setPos(-1000, 0);
            label.setText("");
        }
        for (int i = visibleCount; i < taskImages.size(); i++) {
            UIGraphic img = taskImages.get(i);
            img.getWidget().setHidden(true);
            img.setPosition(-1000, 0);
            img.getWidget().setPos(-1000, 0);
            img.setItem(-1);
        }
    }

    public void goToTop() {
        topTaskIndex = 0;
        updateScrollbar();
    }

    public void handleWheel(final MouseWheelEvent event)
    {
        if (!this.isVisible() || !bounds.contains(event.getPoint()))
        {
            return;
        }

        event.consume();

        // Needed otherwise we get laggy updates
        clientThread.invoke(() -> refreshTasks(event.getWheelRotation()));
    }

    public void updateBounds()
    {
        if (!this.isVisible()) {
            return;
        }

        Widget collectionLogWrapper = window.getParent();
        wrapperX = collectionLogWrapper.getRelativeX();
        wrapperY = collectionLogWrapper.getRelativeY();
        wrapperHeight = window.getHeight() - OFFSET_Y;
        windowX = window.getRelativeX();
        windowY = window.getRelativeY();
        windowWidth = window.getWidth();
        windowHeight = window.getHeight();

        // Recalculate how many tasks can be displayed
        int newTasksPerPage = Math.max(1, wrapperHeight / TASK_HEIGHT);
        columns = Math.max(1, (windowWidth - SCROLLBAR_WIDTH - 40) / (TASK_WIDTH + COLUMN_SPACING));
        if (newTasksPerPage != tasksPerPage) {
            tasksPerPage = newTasksPerPage;
            // Ensure topTaskIndex is valid for the new page size
            TaskTier relevantTier = plugin.getSelectedTier();
            if (relevantTier == null) {
                relevantTier = TaskTier.MASTER;
            }
            int maxTopIndex = Math.max(0, taskService.getTaskList().getForTier(relevantTier).size() - tasksPerPage);
            topTaskIndex = Math.min(topTaskIndex, maxTopIndex);
        }
        updateArrowPositions();
        updateScrollbar();
        refreshTasks(0);

        bounds.setLocation(wrapperX + windowX + OFFSET_X, wrapperY + windowY + OFFSET_Y);
        bounds.setSize(windowWidth - OFFSET_X, wrapperHeight);
    }

    private void updateArrowPositions() {
        int scrollbarX = windowWidth - ARROW_SPRITE_WIDTH - 5;
        // Position arrows vertically in order: page up, up, down, page down
        int pageUpY = ARROW_SPRITE_HEIGHT + ARROW_Y_OFFSET;
        int upArrowY = ARROW_SPRITE_HEIGHT * 2 + ARROW_Y_OFFSET;
        int downArrowY = windowHeight - ARROW_SPRITE_HEIGHT * 2;
        int pageDownY = windowHeight - ARROW_SPRITE_HEIGHT;
        forceWidgetPositionUpdate(pageUpButton.getWidget(), scrollbarX, pageUpY);
        forceWidgetPositionUpdate(upArrowButton.getWidget(), scrollbarX, upArrowY);
        forceWidgetPositionUpdate(downArrowButton.getWidget(), scrollbarX, downArrowY);
        forceWidgetPositionUpdate(pageDownButton.getWidget(), scrollbarX, pageDownY);
    }

    private void forceWidgetPositionUpdate(Widget button, int x, int y) {
        button.setPos(x, y);
        button.revalidate();
    }

    private void forceWidgetUpdate(Widget widget, int width, int height) {
        widget.setSize(width, height);
        widget.revalidate();
    }

    private void updateScrollbar() {
        if (!this.isVisible()) {
            setScrollbarVisibility(false);
            return;
        }

        // The track should fill between the up and down arrows
        int trackY = ARROW_SPRITE_HEIGHT * 3 + ARROW_Y_OFFSET;
        int scrollbarTrackHeight = windowHeight - trackY - ARROW_SPRITE_HEIGHT * 2;
        int scrollbarX = windowWidth - SCROLLBAR_WIDTH - 9;
        scrollbarTrackWidget.setPos(scrollbarX + 2, trackY);

        // Update position, arrows and thumbs
        forceWidgetUpdate(scrollbarTrackWidget, SCROLLBAR_WIDTH, scrollbarTrackHeight);
        updateArrowPositions();
        setScrollbarVisibility(true);
        updateScrollbarThumb(scrollbarTrackHeight, scrollbarX);
    }

    private void updateScrollbarThumb(int scrollbarTrackHeight, int scrollbarX) {
        int tasksPerPageActual = (columns > 1) ? tasksPerPage * columns : tasksPerPage;
        topTaskIndex = Math.min(topTaskIndex, Math.max(0, totalTasks - tasksPerPageActual));
        int thumbHeight = Math.max(SCROLLBAR_THUMB_MIN_HEIGHT, (int)(scrollbarTrackHeight * ((double)tasksPerPageActual / totalTasks)));
        int maxScrollPosition = Math.max(1, totalTasks - tasksPerPageActual);
        int thumbY = maxScrollPosition > 0 ? (int)((scrollbarTrackHeight - thumbHeight) * ((double)topTaskIndex / maxScrollPosition)) : 0;
        int thumbStartY = ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + thumbY;
        int thumbX = scrollbarX + 2;
        // Update middle section (variable height)
        int middleHeight = Math.max(0, thumbHeight - 4);
        scrollbarThumbMiddleWidget.setSize(SCROLLBAR_WIDTH, middleHeight);
        // Force redraw all thumb components
        forceWidgetPositionUpdate(scrollbarThumbTopWidget, thumbX, thumbStartY);
        forceWidgetPositionUpdate(scrollbarThumbMiddleWidget, thumbX, thumbStartY + 2);
        forceWidgetPositionUpdate(scrollbarThumbBottomWidget, thumbX, thumbStartY + thumbHeight - 2);
    }

    private int calculateNewScrollPosition(int mouseY, int totalTasks) {
        int tasksPerPageActual = tasksPerPage * columns;
        int scrollbarTrackHeight = wrapperHeight - (ARROW_SPRITE_HEIGHT * 4) - ARROW_Y_OFFSET;
        int thumbHeight = Math.max(SCROLLBAR_THUMB_MIN_HEIGHT, (int)(scrollbarTrackHeight * ((double)tasksPerPageActual / totalTasks)));
        int deltaY = mouseY - dragStartY;
        int maxTopIndex = Math.max(0, totalTasks - tasksPerPageActual);
        double scrollRatio = (scrollbarTrackHeight - thumbHeight) > 0 ? (double)deltaY / (scrollbarTrackHeight - thumbHeight) : 0;
        int newTopIndex = dragStartTopIndex + (int)(scrollRatio * (totalTasks - tasksPerPageActual));
        
        // Round to nearest column boundary
        newTopIndex = (newTopIndex / columns) * columns;
        
        return Math.max(0, Math.min(maxTopIndex, newTopIndex));
    }

    private void setScrollbarVisibility(boolean visible) {
        if (scrollbarTrackWidget != null) scrollbarTrackWidget.setHidden(!visible);
        if (scrollbarThumbTopWidget != null) scrollbarThumbTopWidget.setHidden(!visible);
        if (scrollbarThumbMiddleWidget != null) scrollbarThumbMiddleWidget.setHidden(!visible);
        if (scrollbarThumbBottomWidget != null) scrollbarThumbBottomWidget.setHidden(!visible);
    }

    @Override
    public void setVisibility(boolean visible) {
        super.setVisibility(visible);
        setScrollbarVisibility(visible && this.isVisible());
        if (visible) updateScrollbar();
    }

    public void handleMousePress(int mouseX, int mouseY) {
        if (!this.isVisible()) return;
        
        if (isPointInScrollThumb(mouseX, mouseY)) {
            isDraggingThumb = true;
            dragStartY = mouseY;
            dragStartTopIndex = topTaskIndex;
        }
    }

    public void handleMouseDrag(int mouseX, int mouseY) {
        if (!isDraggingThumb || !this.isVisible()) return;
        
        if (totalTasks <= tasksPerPage) return;
        
        int newTopIndex = calculateNewScrollPosition(mouseY, totalTasks);
        if (newTopIndex != topTaskIndex) {
            topTaskIndex = newTopIndex;
            // Needed otherwise we get laggy updates
            clientThread.invoke(() -> refreshTasks(0));
        }
    }

    private boolean isPointInScrollThumb(int mouseX, int mouseY) {
        int baseX = wrapperX + windowX;
        int baseY = wrapperY + windowY;
        
        // Check if point is in any of the three thumb components
        int thumbX = baseX + scrollbarThumbTopWidget.getRelativeX();
        int thumbTopY = baseY + scrollbarThumbTopWidget.getRelativeY();
        int thumbBottomY = baseY + scrollbarThumbBottomWidget.getRelativeY() + scrollbarThumbBottomWidget.getHeight();
        int thumbWidth = scrollbarThumbTopWidget.getWidth();
        
        return mouseX >= thumbX && mouseX <= thumbX + thumbWidth &&
            mouseY >= thumbTopY && mouseY <= thumbBottomY;
    }

    public void handleMouseRelease() {
        isDraggingThumb = false;
    }
}

package com.logmaster.ui;

public class InterfaceConstants {

    public static final String DEF_FILE_SPRITES = "SpriteDef.json";
    public static final int TRANSPARENT_SPRITE_ID = -20099;

    public static final int TASK_BACKGROUND_SPRITE_ID = -20006;
    public static final int TASK_LIST_BACKGROUND_SPRITE_ID = -20012;
    public static final int TASK_COMPLETE_BACKGROUND_SPRITE_ID = -20013;
    public static final int TASK_CURRENT_BACKGROUND_SPRITE_ID = -20016;

    public static final int COLLECTION_LOG_WINDOW_WIDTH = 500;
    public static final int COLLECTION_LOG_WINDOW_HEIGHT = 314;
    public static final int COLLECTION_LOG_CONTENT_WIDGET_ID = 40697858;

    public static final int DASHBOARD_TAB_SPRITE_ID = -20007;
    public static final int DASHBOARD_TAB_HOVER_SPRITE_ID = -20008;
    public static final int TASKLIST_TAB_SPRITE_ID = -20009;
    public static final int TASKLIST_TAB_HOVER_SPRITE_ID = -20010;
    public static final int DIVIDER_SPRITE_ID = -20011;

    public static final int TASKLIST_EASY_TAB_SPRITE_ID = -20017;
    public static final int TASKLIST_EASY_TAB_HOVER_SPRITE_ID = -20018;
    public static final int TASKLIST_MEDIUM_TAB_SPRITE_ID = -20019;
    public static final int TASKLIST_MEDIUM_TAB_HOVER_SPRITE_ID = -20020;
    public static final int TASKLIST_HARD_TAB_SPRITE_ID = -20021;
    public static final int TASKLIST_HARD_TAB_HOVER_SPRITE_ID = -20022;
    public static final int TASKLIST_ELITE_TAB_SPRITE_ID = -20023;
    public static final int TASKLIST_ELITE_TAB_HOVER_SPRITE_ID = -20024;
    public static final int TASKLIST_MASTER_TAB_SPRITE_ID = -20025;
    public static final int TASKLIST_MASTER_TAB_HOVER_SPRITE_ID = -20026;
}

package com.logmaster.ui;

import lombok.Getter;
import net.runelite.client.game.SpriteOverride;

@Getter
public class SpriteDefinition implements SpriteOverride
{
    private int spriteId;
    private String fileName;
}

package com.logmaster.ui;

import com.google.gson.Gson;
import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.persistence.SaveDataManager;
import com.logmaster.task.TaskService;
import com.logmaster.ui.component.TabManager;
import com.logmaster.ui.component.TaskDashboard;
import com.logmaster.ui.component.TaskList;
import com.logmaster.ui.generic.UICheckBox;
import com.logmaster.ui.generic.dropdown.UIDropdown;
import com.logmaster.ui.generic.dropdown.UIDropdownOption;
import com.logmaster.util.FileUtils;
import net.runelite.api.Client;
import net.runelite.api.SoundEffectID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseWheelListener;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.util.Arrays;
import java.util.List;

import static com.logmaster.ui.InterfaceConstants.DEF_FILE_SPRITES;

@Singleton
public class InterfaceManager implements MouseListener, MouseWheelListener {
    private static final int COLLECTION_LOG_TAB_DROPDOWN_WIDGET_ID = 40697929;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private LogMasterConfig config;

    @Inject
    private LogMasterPlugin plugin;

    @Inject
    private TaskService taskService;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private Gson gson;

    @Inject
    private SaveDataManager saveDataManager;


    private SpriteDefinition[] spriteDefinitions;

    private TaskDashboard taskDashboard;
    private TaskList taskList;
    private TabManager tabManager;

    private UICheckBox taskDashboardCheckbox;
    private UIDropdown dropdown;

    public void initialise() {
        this.spriteDefinitions = FileUtils.loadDefinitionResource(SpriteDefinition[].class, DEF_FILE_SPRITES, gson);
        this.spriteManager.addSpriteOverrides(spriteDefinitions);
    }

    public void updateAfterConfigChange() {
        if (this.taskDashboard != null && isTaskDashboardEnabled()) {
            if (tabManager != null) {
                tabManager.updateTabs();
            }
            if (this.saveDataManager.getSaveData().getSelectedTier() != null && Arrays.asList(TaskTier.values()).indexOf(this.saveDataManager.getSaveData().getSelectedTier()) < Arrays.asList(TaskTier.values()).indexOf(this.config.hideBelow())) {
                if (tabManager != null) {
                    tabManager.activateTaskDashboard();
                }
            }
            this.taskDashboard.updatePercentages();
        }
    }

    public void handleCollectionLogOpen() {
        Widget window = client.getWidget(InterfaceID.Collection.CONTENT);
        
        createTaskDashboard(window);
        createTaskList(window);
        createTabManager(window);
        createTaskCheckbox();

        this.tabManager.updateTabs();
        this.taskDashboard.setVisibility(false);
    }

    public void handleCollectionLogClose() {
        this.taskDashboard.setVisibility(false);
        this.taskList.setVisibility(false);
        tabManager.hideTabs();
    }

    public void handleCollectionLogScriptRan() {
        if (this.dropdown != null) {
            this.dropdown.cleanup();
            this.dropdown = null;
        }

        createTaskDropdownOption();
    }

    public boolean isDashboardOpen() {
        return this.taskDashboard != null && this.taskDashboard.isVisible();
    }

    public void updateTaskListBounds() {
        if (this.taskList != null) {
            taskList.updateBounds();
        }
        if (this.taskDashboard != null) {
            taskDashboard.updateBounds();
        }
        if (this.tabManager != null) {
            tabManager.updateBounds();
        }
        if (this.taskDashboardCheckbox != null) {
            Widget window = client.getWidget(621, 88);
            if (window != null) {
                taskDashboardCheckbox.alignToRightEdge(window, 35, 10);
            }
        }
    }

    public void handleMouseWheel(MouseWheelEvent event) {
        if(this.taskList != null) {
            taskList.handleWheel(event);
        }
    }

    public void handleMousePress(int mouseX, int mouseY) {
        if(this.taskList != null && this.taskList.isVisible()) {
            taskList.handleMousePress(mouseX, mouseY);
        }
    }

    public void handleMouseDrag(int mouseX, int mouseY) {
        if(this.taskList != null && this.taskList.isVisible()) {
            taskList.handleMouseDrag(mouseX, mouseY);
        }
    }

    public void handleMouseRelease() {
        if(this.taskList != null) {
            taskList.handleMouseRelease();
        }
    }

    @Override
    public MouseWheelEvent mouseWheelMoved(MouseWheelEvent event) {
        handleMouseWheel(event);
        return event;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent event) {
        handleMousePress(event.getX(), event.getY());
        return event;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent event) {
        handleMouseRelease();
        return event;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent event) {
        handleMouseDrag(event.getX(), event.getY());
        return event;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent event) {
        return event;
    }

    private void createTaskDropdownOption() {
        Widget container = client.getWidget(COLLECTION_LOG_TAB_DROPDOWN_WIDGET_ID);
        if (container == null) {
            return;
        }

        this.dropdown = new UIDropdown(container);
        this.dropdown.addOption("Tasks", "View Tasks Dashboard");
        this.dropdown.setOptionEnabledListener(this::toggleTaskDashboard);
    }

    private void createTabManager(Widget window) {
        this.tabManager = new TabManager(window, config, saveDataManager);
        this.tabManager.setComponents(taskDashboard, taskList);
    }

    private void createTaskDashboard(Widget window) {
        this.taskDashboard = new TaskDashboard(plugin, config, window, taskService, saveDataManager);
        this.taskDashboard.setVisibility(false);
    }

    private void createTaskList(Widget window) {
        this.taskList = new TaskList(window, taskService, plugin, clientThread, this.saveDataManager);
        this.taskList.setVisibility(false);
    }

    private void createTaskCheckbox() {
        Widget window = client.getWidget(621, 88);
        if (window != null) {
            // Create the graphic widget for the checkbox
            Widget toggleWidget = window.createChild(-1, WidgetType.GRAPHIC);
            Widget labelWidget = window.createChild(-1, WidgetType.TEXT);

            // Wrap in checkbox, set size, position, etc.
            taskDashboardCheckbox = new UICheckBox(toggleWidget, labelWidget);
            taskDashboardCheckbox.setPosition(360, 10);
            taskDashboardCheckbox.setName("Task Dashboard");
            taskDashboardCheckbox.setEnabled(false);
            taskDashboardCheckbox.setText("Task Dashboard");
            labelWidget.setPos(375, 10);
            taskDashboardCheckbox.setToggleListener((UICheckBox src) -> {
                if (taskDashboardCheckbox.isEnabled()) {
                    this.dropdown.setEnabledOption("Tasks");
                } else {
                    this.dropdown.setEnabledOption("View Log");
                }
            });
        }
    }

    private void toggleTaskDashboard(UIDropdownOption src) {
        if(this.taskDashboard == null) return;

        if (saveDataManager.getSaveData().getActiveTaskPointer() != null) {
            this.taskDashboard.setTask(this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getName(), this.saveDataManager.getSaveData().getActiveTaskPointer().getTask().getDisplayItemId(), null);
            this.taskDashboard.disableGenerateTask();
        } else {
            plugin.nullCurrentTask();
        }

        boolean enabled = isTaskDashboardEnabled();
        this.taskDashboardCheckbox.setEnabled(enabled);
        for (Widget c : client.getWidget(InterfaceID.Collection.CONTENT).getStaticChildren()) {
            c.setHidden(enabled);
        }
        client.getWidget(InterfaceID.Collection.SEARCH_TITLE).setHidden(enabled);

        if (isTaskDashboardEnabled()) {
            this.tabManager.activateTaskDashboard();
        } else {
            this.taskDashboard.setVisibility(false);
            this.taskList.setVisibility(false);
            this.tabManager.hideTabs();
        }

        // *Boop*
        this.client.playSoundEffect(SoundEffectID.UI_BOOP);
    }

    private boolean isTaskDashboardEnabled() {
        return this.dropdown != null && this.dropdown.getEnabledOption().getText().equals("Tasks");
    }

    public void rollTask(String description, int itemID, List<Task> tasks) {
        this.taskDashboard.setTask(description, itemID, tasks);
        this.taskDashboard.disableGenerateTask(false);
        this.taskDashboard.updatePercentages();
    }

    public void completeTask() {
        boolean wasDashboardVisible = this.taskDashboard.isVisible();
        this.taskDashboard.updatePercentages();
        taskList.refreshTasks(0);
        // Restore previous visibility state
        this.taskDashboard.setVisibility(wasDashboardVisible);
        this.taskList.setVisibility(!wasDashboardVisible);
        this.tabManager.showTabs();
    }

    public void clearCurrentTask() {
        this.taskDashboard.setTask("No task.", -1, null);
        this.taskDashboard.enableGenerateTask();
        this.taskDashboard.enableFaqButton();
    }

    public void disableGenerateTaskButton() {
        this.taskDashboard.disableGenerateTask();
    }
}

package com.logmaster.domain;

import lombok.Getter;
import lombok.ToString;

import javax.annotation.Nullable;

@ToString
@Getter
public class BaseSaveData {
    public static final Integer LATEST_VERSION = 1;

    protected @Nullable Integer version;
}

package com.logmaster.domain;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class Task {
    private String id;
    private String name;
    private int displayItemId;
}

package com.logmaster.domain;

import static com.logmaster.ui.InterfaceConstants.*;

public enum TaskTier {
    EASY("Easy", TASKLIST_EASY_TAB_SPRITE_ID, TASKLIST_EASY_TAB_HOVER_SPRITE_ID),
    MEDIUM("Medium", TASKLIST_MEDIUM_TAB_SPRITE_ID, TASKLIST_MEDIUM_TAB_HOVER_SPRITE_ID),
    HARD("Hard", TASKLIST_HARD_TAB_SPRITE_ID, TASKLIST_HARD_TAB_HOVER_SPRITE_ID),
    ELITE("Elite", TASKLIST_ELITE_TAB_SPRITE_ID, TASKLIST_ELITE_TAB_HOVER_SPRITE_ID),
    MASTER("Master", TASKLIST_MASTER_TAB_SPRITE_ID, TASKLIST_MASTER_TAB_HOVER_SPRITE_ID);

    public final String displayName;
    public final int tabSpriteId;
    public final int tabSpriteHoverId;

    TaskTier(String displayName, int tabSpriteId, int tabSpriteHoverId) {
        this.displayName = displayName;
        this.tabSpriteId = tabSpriteId;
        this.tabSpriteHoverId = tabSpriteHoverId;
    }
}

package com.logmaster.domain.old;

import lombok.Getter;

@Getter
@Deprecated
public class OldTask {
    private int id;
    private String description;
    private int itemID;
}

package com.logmaster.domain.old;

import com.logmaster.domain.TaskTier;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class OldSaveData {
    public OldSaveData() {
        this.progress = new HashMap<>();

        for (TaskTier tier : TaskTier.values()) {
            this.progress.put(tier, new HashSet<>());
        }
    }

    private final Map<TaskTier, Set<Integer>> progress;

    @Setter
    private OldTaskPointer activeTaskPointer;

    @Setter
    private TaskTier selectedTier;
}

package com.logmaster.domain.old;

import com.logmaster.domain.TaskTier;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Deprecated
public class OldTaskPointer {

    private TaskTier taskTier;
    private OldTask task;
}

package com.logmaster.domain;

import lombok.Data;

import java.util.Collections;
import java.util.List;

@Data
public class TieredTaskList {
    private List<Task> easy;
    private List<Task> medium;
    private List<Task> hard;
    private List<Task> elite;
    private List<Task> master;

    public List<Task> getForTier(TaskTier tier) {
        switch (tier) {
            case EASY: return easy;
            case MEDIUM: return medium;
            case HARD: return hard;
            case ELITE: return elite;
            case MASTER: return master;
            default: return Collections.emptyList();
        }
    }
}

package com.logmaster.domain;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
@ToString
public class SaveData extends BaseSaveData {
    public SaveData() {
        this.version = 1;
        this.progress = new HashMap<>();

        for (TaskTier tier : TaskTier.values()) {
            this.progress.put(tier, new HashSet<>());
        }
    }

    public @Nullable Task currentTask;

    private final Map<TaskTier, Set<String>> progress;

    @Setter
    private @Nullable TaskPointer activeTaskPointer;
    
    @Setter
    private @Nullable TaskTier selectedTier;
}

package com.logmaster.domain;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class TaskPointer {
    private TaskTier taskTier;
    private Task task;
}

package com.logmaster.task;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.logmaster.LogMasterConfig;
import com.logmaster.domain.SaveData;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.domain.TieredTaskList;
import com.logmaster.util.FileUtils;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@Singleton
@Slf4j
public class TaskService {

    private static final String DEF_FILE_TASKS = "task-list.json";

    @Inject
    private Gson gson;

    @Inject
    private LogMasterConfig config;

    @Inject
    private TaskListClient taskListClient;

    private TieredTaskList localList;
    private TieredTaskList remoteList;
    private boolean requestedRemoteList = false;

    public TieredTaskList getTaskList() {
        if (localList == null) {
            this.localList = FileUtils.loadDefinitionResource(TieredTaskList.class, DEF_FILE_TASKS, gson);
        }
        if (remoteList == null && !requestedRemoteList && config.loadRemoteTaskList()) {
            loadRemoteTaskList();
        }
        return remoteList != null && config.loadRemoteTaskList() ? remoteList : localList;
    }

    public List<Task> getForTier(TaskTier tier) {
        return getTaskList().getForTier(tier);
    }

    public Map<TaskTier, Integer> completionPercentages(SaveData saveData) {
        Map<TaskTier, Set<String>> progressData = saveData.getProgress();
        TieredTaskList taskList = getTaskList();

        Map<TaskTier, Integer> completionPercentages = new HashMap<>();
        for (TaskTier tier : TaskTier.values()) {
            Set<String> tierCompletedTasks = new HashSet<>(progressData.get(tier));
            Set<String> tierTaskIdList = taskList.getForTier(tier)
                    .stream()
                    .map(Task::getId)
                    .collect(Collectors.toSet());

            tierCompletedTasks.retainAll(tierTaskIdList);

            double tierPercentage = 100d * tierCompletedTasks.size() / tierTaskIdList.size();

            completionPercentages.put(tier, (int) Math.floor(tierPercentage));
        }

        return completionPercentages;
    }

    private void loadRemoteTaskList() {
        requestedRemoteList = true;
        // Load the remote task list
        try {
            taskListClient.getTaskList(new Callback() {
                @Override
                public void onFailure(@NonNull Call call, @NonNull IOException e) {
                    log.error("Unable to load remote task list, will defer to the default task list", e);
                    requestedRemoteList = false;
                }

                @Override
                public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException {
                    JsonObject tasksJson = taskListClient.processResponse(response);
                    response.close();
                    if (tasksJson == null) {
                        log.error("Loaded null remote task list, will defer to the default task list");
                        return;
                    }
                    log.debug("Loaded remote task list!");
                    remoteList = gson.fromJson(tasksJson, TieredTaskList.class);
                }
            });
        } catch (IOException e) {
            log.error("Unable to load remote task list, will defer to the default task list");
            this.localList = FileUtils.loadDefinitionResource(TieredTaskList.class, DEF_FILE_TASKS, gson);
        }
    }
}

package com.logmaster.task;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;

@Slf4j
@Singleton
public class TaskListClient {

    private static final String TASK_LIST_URL = "https://raw.githubusercontent.com/OSRS-Taskman/task-list/refs/heads/main/lists/tedious.json";

    @Inject
    private OkHttpClient okHttpClient;

    public void getTaskList(Callback callback) throws IOException {
        Request request = new Request.Builder()
                .url(TASK_LIST_URL)
                .get()
                .build();

        okHttpClient.newCall(request).enqueue(callback);
    }

    public JsonObject processResponse(Response response) throws IOException {
        if (!response.isSuccessful()) {
            return null;
        }

        ResponseBody resBody = response.body();
        if (resBody == null) {
            return null;
        }
        return new JsonParser().parse(resBody.string()).getAsJsonObject();
    }
}

package com.logmaster;

import com.logmaster.domain.TaskTier;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import net.runelite.client.plugins.camera.ControlFunction;

import static com.logmaster.LogMasterConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface LogMasterConfig extends Config
{
    String CONFIG_GROUP = "log-master";

    String SAVE_DATA_KEY = "save-data";

    String BACKUP_SAVE_DATA_KEY = "backup-save-data";

    @Range(
            min = 1000,
            max = 10000
    )
    @Units(Units.MILLISECONDS)
    @ConfigItem(
            keyName = "rollTime",
            name = "Roll Time",
            description = "How long new tasks will take to roll",
            position = 1
    )
    default int rollTime()
    {
        return 5000;
    }

    @ConfigItem(
            keyName = "rollPastCompleted",
            name = "Roll past completed",
            description = "When rolling tasks, include those you've already completed in the roll animation. Helpful when you're getting to the end of a tier!",
            position = 2
    )
    default boolean rollPastCompleted()
    {
        return false;
    }

    @ConfigItem(
            keyName = "hideBelow",
            name = "Hide Tasks Below",
            description = "Disabled the showing up/assigning of tasks at or below the specified tier",
            position = 3
    )
    default TaskTier hideBelow()
    {
        return TaskTier.EASY;
    }

    @ConfigItem(
            keyName = "loadRemoteTaskList",
            name = "Load remote task list",
            description = "Load the latest version of the tasklist, this will be updated more frequently than the default list bundled with the plugin",
            position = 4
    )
    default boolean loadRemoteTaskList()
    {
        return true;
    }

    @ConfigItem(
            keyName = "displayCurrentTaskOverlay",
            name = "Display current task overlay",
            description = "Enable an overlay showing the currently assigned task (when one exists)",
            position = 5
    )
    default boolean displayCurrentTaskOverlay()
    {
        return true;
    }
}

package com.logmaster;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LogMasterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LogMasterPlugin.class);
		RuneLite.main(args);
	}
}
