package com.logmaster;

import com.google.inject.Provides;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.synchronization.clog.CollectionLogService;
import com.logmaster.task.TaskService;
import com.logmaster.ui.InterfaceManager;
import com.logmaster.ui.component.TaskOverlay;
import com.logmaster.util.GsonOverride;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SoundEffectID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;

@Slf4j
@PluginDescriptor(name = "Collection Log Master")
public class LogMasterPlugin extends Plugin {
	@Inject
	@SuppressWarnings("unused")
	private GsonOverride gsonOverride;

	@Inject
	private Client client;

	@Inject
	protected TaskOverlay taskOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private InterfaceManager interfaceManager;

	@Inject
	public ItemManager itemManager;

	@Inject
	public CollectionLogService collectionLogService;

	@Inject
	public PluginUpdateNotifier pluginUpdateNotifier;

	@Inject
	public TaskService taskService;

	@Getter
	@Setter
	// TODO: this is UI state, move it somewhere else
	private TaskTier selectedTier;

	@Override
	protected void startUp() {
		taskService.startUp();
		collectionLogService.startUp();
		pluginUpdateNotifier.startUp();
		interfaceManager.startUp();
		this.taskOverlay.setResizable(true);
		this.overlayManager.add(this.taskOverlay);
	}

	@Override
	protected void shutDown() {
		taskService.shutDown();
		collectionLogService.shutDown();
		pluginUpdateNotifier.shutDown();
		interfaceManager.shutDown();
		this.overlayManager.remove(this.taskOverlay);
	}

	@Provides
	LogMasterConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(LogMasterConfig.class);
	}

	public void completeTask() {
		Task activeTask = taskService.getActiveTask();
		completeTask(activeTask.getId());
	}

	public void completeTask(String taskId) {
		completeTask(taskId, true);
	}

	public void completeTask(String taskId, boolean playSound) {
		if (playSound) {
			this.client.playSoundEffect(SoundEffectID.UI_BOOP);
		}

		taskService.toggleComplete(taskId);
		if (taskService.getActiveTask() == null) {
			interfaceManager.clearCurrentTask();
		}

		interfaceManager.completeTask();
	}

	public void visitFaq() {
		LinkBrowser.browse("https://docs.google.com/document/d/e/2PACX-1vTHfXHzMQFbt_iYAP-O88uRhhz3wigh1KMiiuomU7ftli-rL_c3bRqfGYmUliE1EHcIr3LfMx2UTf2U/pub");
	}
}

package com.logmaster.util;

import lombok.NonNull;

public class StringUtils {
    public static @NonNull String kebabCase(@NonNull String snakeCase) {
        return snakeCase.toLowerCase().replace('_', '-');
    }
}

package com.logmaster.util;

import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class EnumUtils {
    public static <T extends Enum<T>> T fromString(@NonNull Class<T> enumClass, String name) {
        for (T e : enumClass.getEnumConstants()) {
            if (EnumUtils.toString(e).equals(name)) {
                return e;
            }
        }

        log.warn("No enum const {} for name '{}'", enumClass.getName(), name);
        return null;
    }

    public static <T extends Enum<T>> @NonNull String toString(T enumValue) {
        return StringUtils.kebabCase(enumValue.name());
    }
}

package com.logmaster.util;

import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;

public abstract class EventBusSubscriber {
    @Inject
    EventBus eventBus = null;

    public void startUp() {
        eventBus.register(this);
    };

    public void shutDown() {
        eventBus.unregister(this);
    }
}

package com.logmaster.util;

import com.logmaster.LogMasterPlugin;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;

import static com.logmaster.util.GsonOverride.GSON;

public class FileUtils {
    /**
     * Loads a definition resource from a JSON file
     *
     * @param classType the class into which the data contained in the JSON file will be read into
     * @param resource  the name of the resource (file name)
     * @param <T>       the class type
     * @return the data read from the JSON definition file
     */
    public static <T> T loadDefinitionResource(Class<T> classType, String resource) {
        // Load the resource as a stream and wrap it in a reader
        InputStream resourceStream = classType.getResourceAsStream(resource);
        assert resourceStream != null;
        InputStreamReader definitionReader = new InputStreamReader(resourceStream);

        // Load the objects from the JSON file
        return GSON.fromJson(definitionReader, classType);
    }

    public static <T> T loadResource(String resourcePath, Type clazz) {
        try (InputStream is = LogMasterPlugin.class.getResourceAsStream(resourcePath)) {
            assert is != null;
            return GSON.fromJson(new InputStreamReader(is), clazz);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

package com.logmaster.util;

import com.google.inject.Inject;

import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class SimpleDebouncer {
    public interface Callback {
        void call();
    }

    Future<?> future;

    @Inject
    private ScheduledExecutorService executorService;

    private final static int MS_DELAY = 500;

    public synchronized void debounce(Callback cb) {
        if (future != null) {
            future.cancel(false);
            future = null;
        }

        future = executorService.schedule(cb::call, MS_DELAY, TimeUnit.MILLISECONDS);
    }
}

package com.logmaster.util;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.logmaster.domain.adapters.EnumAdapter;
import com.logmaster.domain.adapters.VerificationAdapter;
import com.logmaster.domain.verification.Verification;
import com.logmaster.domain.verification.VerificationMethod;
import com.logmaster.domain.verification.diary.DiaryDifficulty;
import com.logmaster.domain.verification.diary.DiaryRegion;
import net.runelite.api.Skill;

import javax.inject.Inject;

public class GsonOverride {
    /**
     * Custom Gson instance capable of parsing additional types.
     */
    public static Gson GSON;

    @Inject
    public GsonOverride(Gson originalGson) {
        GsonBuilder gsonBuilder = originalGson.newBuilder()
                .registerTypeAdapter(Verification.class, new VerificationAdapter())
                .registerTypeAdapter(VerificationMethod.class, new EnumAdapter<>(VerificationMethod.class))
                .registerTypeAdapter(DiaryRegion.class, new EnumAdapter<>(DiaryRegion.class))
                .registerTypeAdapter(DiaryDifficulty.class, new EnumAdapter<>(DiaryDifficulty.class))
                .registerTypeAdapter(Skill.class, new EnumAdapter<>(Skill.class));

        GSON = gsonBuilder.create();
    }
}

package com.logmaster.synchronization.diary;

import com.logmaster.domain.Task;
import com.logmaster.domain.verification.diary.AchievementDiaryVerification;
import com.logmaster.domain.verification.diary.DiaryDifficulty;
import com.logmaster.domain.verification.diary.DiaryRegion;
import com.logmaster.synchronization.Verifier;
import lombok.NonNull;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class AchievementDiaryVerifier implements Verifier {
    @Inject
    private AchievementDiaryService achievementDiaryService;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof AchievementDiaryVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof AchievementDiaryVerification;
        AchievementDiaryVerification verif = (AchievementDiaryVerification) task.getVerification();

        DiaryRegion diary = verif.getRegion();
        DiaryDifficulty difficulty = verif.getDifficulty();

        return achievementDiaryService.isComplete(diary, difficulty);
    }
}

package com.logmaster.synchronization.diary;

import com.logmaster.domain.verification.diary.DiaryDifficulty;
import com.logmaster.domain.verification.diary.DiaryRegion;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class AchievementDiaryService {
    private static final int DIARY_COMPLETION_SCRIPT = 2200;

    @Inject
    private Client client;

    // Code from: RuneProfile
    // Repository: https://github.com/ReinhardtR/runeprofile-plugin
    // License: BSD 2-Clause License
    public boolean isComplete(@NonNull DiaryRegion diary, @NonNull DiaryDifficulty difficulty) {
        // https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cdiary_completion_info%5D.cs2
        client.runScript(DIARY_COMPLETION_SCRIPT, diary.getId());
        int[] stack = client.getIntStack();

        return stack[difficulty.getStackOffset()] == 1;
    }
}

package com.logmaster.synchronization.clog;

import com.logmaster.util.EventBusSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton

// Code from: RuneProfile
// Repository: https://github.com/ReinhardtR/runeprofile-plugin
// License: BSD 2-Clause License
public class CollectionLogWidgetSubscriber extends EventBusSubscriber {
    @Inject
    private Client client;

    @Inject
    private CollectionLogService collectionLogService;

    private int tickCollectionLogScriptFired = -1;

    private boolean isAutoClogRetrieval = false;

    public void reset() {
        isAutoClogRetrieval = false;
        tickCollectionLogScriptFired = -1;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.HOPPING && gameState != GameState.LOGGED_IN) {
            reset();
        }
    }

    // Code from: WikiSync
    // Repository: https://github.com/weirdgloop/WikiSync
    // License: BSD 2-Clause License
    @Subscribe
    public void onGameTick(GameTick gameTick) {
        int tick = client.getTickCount();
        boolean hasClogScriptFired = tickCollectionLogScriptFired != -1;
        boolean hasBufferPassed = tickCollectionLogScriptFired + 2 < tick;
        if (hasClogScriptFired && hasBufferPassed) {
            tickCollectionLogScriptFired = -1;
            log.debug("Clog items script has fired");
            isAutoClogRetrieval = false;
        }
    }

    // Code from: WikiSync
    // Repository: https://github.com/weirdgloop/WikiSync
    // License: BSD 2-Clause License
    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();

            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int quantity = (int) args[2];

            if (quantity > 0) {
                collectionLogService.storeItem(itemId);
            }
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        final int COLLECTION_LOG_SETUP = 7797;
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP) {
            if (isAutoClogRetrieval) {
                return;
            }

            // disallow updating from the adventure log, to avoid players updating their profile
            // while viewing other players collection logs using the POH adventure log.
            if (isOpenedFromAdventureLog()) return;

            isAutoClogRetrieval = true;
            client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
            client.runScript(2240);
        }
    }

    private boolean isOpenedFromAdventureLog() {
        return client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
    }
}

package com.logmaster.synchronization.clog;

import com.logmaster.domain.Task;
import com.logmaster.domain.verification.clog.CollectionLogVerification;
import com.logmaster.synchronization.Verifier;
import lombok.NonNull;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;

@Singleton
public class CollectionLogVerifier implements Verifier {
    @Inject
    private CollectionLogService collectionLogService;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof CollectionLogVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof CollectionLogVerification;
        CollectionLogVerification verif = (CollectionLogVerification) task.getVerification();

        long totalObtained = Arrays.stream(verif.getItemIds())
                .filter(itemId -> this.collectionLogService.isItemObtained(itemId))
                .count();

        return totalObtained >= verif.getCount();
    }
}

package com.logmaster.synchronization.clog;

import com.logmaster.util.EventBusSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@Singleton
public class CollectionLogService extends EventBusSubscriber {
	@Inject
	public CollectionLogWidgetSubscriber collectionLogWidgetSubscriber;

    private final Set<Integer> obtainedItems = new HashSet<>();

    public void startUp() {
        super.startUp();
        collectionLogWidgetSubscriber.startUp();

        reset();
    }

    public void shutDown() {
        super.startUp();
        collectionLogWidgetSubscriber.shutDown();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.LOGGED_IN) {
            reset();
        }
    }

    public boolean isItemObtained(int itemId) {
        return obtainedItems.contains(itemId);
    }

    public void storeItem(int itemId) {
        obtainedItems.add(itemId);
    }

    public void reset() {
        obtainedItems.clear();
    }
}

package com.logmaster.synchronization;

import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.synchronization.clog.CollectionLogVerifier;
import com.logmaster.synchronization.diary.AchievementDiaryVerifier;
import com.logmaster.synchronization.skill.SkillVerifier;
import com.logmaster.task.TaskService;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class SyncService {
    @Inject
    private Client client;

    @Inject
    private LogMasterPlugin plugin;

    @Inject
    private TaskService taskService;

    @Inject
    private SyncService syncService;

    @Inject
    private CollectionLogVerifier collectionLogVerifier;

    @Inject
    private AchievementDiaryVerifier achievementDiaryVerifier;

    @Inject
    private SkillVerifier skillVerifier;

    private @NonNull Verifier[] getVerifiers() {
        return new Verifier[]{
            this.collectionLogVerifier,
            this.achievementDiaryVerifier,
            this.skillVerifier
        };
    }

    private Boolean verify(Task task) {
        for (Verifier verif : this.getVerifiers()) {
            if (verif.supports(task)) {
                return verif.verify(task);
            }
        }

        return null;
    }

    public void sync() {
        int updatedCount = 0;
        for (TaskTier tier : TaskTier.values()) {
            for (Task task : taskService.getTierTasks(tier)) {
                Boolean isVerified = syncService.verify(task);
                if (isVerified == null) {
                    continue;
                }

                boolean taskChanged = isVerified != taskService.isComplete(task.getId());

                if (!taskChanged) {
                    continue;
                }

                plugin.completeTask(task.getId(), false);

                String newStatus = isVerified ? "<col=27ae60>complete</col>" : "<col=c0392b>incomplete</col>";
                String msg = String.format("%s tier task '%s' marked as %s", tier.displayName, task.getName(), newStatus);
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, "");

                updatedCount++;
            }
        }

        String msg = String.format("Task synchronization finalized; %d task updated", updatedCount);
        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null);
    }
}

package com.logmaster.synchronization;

import com.logmaster.domain.Task;
import lombok.NonNull;

public interface Verifier {
    boolean supports(@NonNull Task task);
    boolean verify(@NonNull Task task);
}

package com.logmaster.synchronization.skill;

import com.logmaster.domain.Task;
import com.logmaster.domain.verification.skill.SkillVerification;
import com.logmaster.synchronization.Verifier;
import lombok.NonNull;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class SkillVerifier implements Verifier {
    @Inject
    private Client client;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof SkillVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof SkillVerification;
        SkillVerification verif = (SkillVerification) task.getVerification();

        long totalAchieved = verif.getExperience().entrySet().stream()
                .filter(entry -> entry.getKey() != null)
                .filter(entry -> client.getSkillExperience(entry.getKey()) > entry.getValue())
                .count();

        return totalAchieved >= verif.getCount();
    }
}

package com.logmaster;

import com.logmaster.util.EventBusSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;

import static com.logmaster.LogMasterConfig.CONFIG_GROUP;
import static com.logmaster.LogMasterConfig.PLUGIN_VERSION_KEY;

@Slf4j
@Singleton
public class PluginUpdateNotifier extends EventBusSubscriber {
    private static final String[] UPDATE_MESSAGES = {
            "<colHIGHLIGHT>Collection Log Master updated to v" + getPluginVersion(),
            "<colHIGHLIGHT>- Deprecated checkbox to open the dashboard; use the hamburger menu now",
            "<colHIGHLIGHT>- Major performance improvements",
            "<colHIGHLIGHT>- Fixed conflict with RuneProfile",
    };

    @Inject
    ConfigManager configManager;

    @Inject
    ChatMessageManager chatMessageManager;

    private static String getPluginVersion() {
        try (InputStream is = LogMasterPlugin.class.getResourceAsStream("version")) {
            assert is != null;
            return new String(is.readAllBytes(), StandardCharsets.UTF_8)
                    .replace("-SNAPSHOT", "");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState == GameState.LOGGED_IN) {
            checkUpdate();
        }
    }

    private void checkUpdate() {
        boolean isDebug = false;
        String curVersion = getPluginVersion();
        String lastVersion = configManager.getRSProfileConfiguration(CONFIG_GROUP, PLUGIN_VERSION_KEY);

        //noinspection ConstantValue
        if (isDebug || !curVersion.equals(lastVersion)) {
            configManager.setRSProfileConfiguration(CONFIG_GROUP, PLUGIN_VERSION_KEY, curVersion);
            notifyUpdate();
        }
    }

    private void notifyUpdate() {
        //noinspection ConstantConditions
        if (UPDATE_MESSAGES == null) return;

        String replacedMessage = String.join("<br>", UPDATE_MESSAGES);
        chatMessageManager.queue(
                QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(replacedMessage)
                        .build()
        );
    }
}

package com.logmaster.ui.generic;

import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a graphic display component, effectively just a game sprite.
 * @author Antipixel
 */
public class UIGraphic extends UIComponent
{
	/**
	 * Constructs a new graphic component
	 * @param widget the underlying widget
	 */
	public UIGraphic(Widget widget)
	{
		super(widget);
	}

	/**
	 * Sets the sprite to display on the component
	 * @param spriteID the sprite ID
	 */
	public void setSprite(int spriteID)
	{
		this.getWidget().setSpriteId(spriteID);
	}

	/**
	 * Sets the sprite to display on the component
	 * @param itemID the item ID
	 */
	public void setItem(int itemID)
	{
		this.getWidget().setItemId(itemID);
	}
}

package com.logmaster.ui.generic;

import lombok.Getter;

import java.util.ArrayList;
import java.util.List;

/**
 * A group of UIComponents
 * @author Antipixel
 */
public class UIPage
{
	@Getter
	private boolean visible;
	private List<UIComponent> components;

	/**
	 * Constructs a new UI page
	 */
	public UIPage()
	{
		this.components = new ArrayList<>();
	}

	/**
	 * Sets the visibility for all the components in the page
	 * @param visibility true for visible, false for hidden
	 */
	public void setVisibility(boolean visibility)
	{
		this.visible = visibility;
		// Update the visibility for each of the components
		this.components.forEach(c -> c.setVisibility(visibility));
	}

	/**
	 * Adds a UI component to the page
	 * @param component the component to add
	 */
	public void add(UIComponent component)
	{
		this.components.add(component);
	}

	/**
	 * Removes a UI component from the page
	 * @param component the component to remove
	 */
	public void remove(UIComponent component)
	{
		this.components.remove(component);
	}
}

package com.logmaster.ui.generic;

/**
 * A listener interface for receiving UI component events
 * @author Antipixel
 */
public interface ComponentEventListener<T extends UIComponent>
{
	/**
	 * Invoked upon a component event
	 * @param src the source component responsible for the event
	 */
	void onComponentEvent(T src);
}


package com.logmaster.ui.generic;

import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;

import java.awt.*;

/**
 * This class wraps a game widget and gives it the functionality of
 * a text label component, with basic control over text colour and font.
 * @author Antipixel
 */
public class UILabel extends UIComponent
{
	/**
	 * Constructs a new label component
	 * @param labelWidget the underlying widget
	 */
	public UILabel(Widget labelWidget)
	{
		super(labelWidget);

		// Set default font and text colour
		this.setFont(FontID.PLAIN_11);
		this.setColour(Color.WHITE.getRGB());

		// Set the alignment to centre and enable text shadowing
		labelWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setTextShadowed(true);
	}

	/**
	 * Sets the display text of the label
	 * @param text the display text
	 */
	public void setText(String text)
	{

		this.getWidget().setText(text);
	}

	/**
	 * Sets the font of the label
	 * @param fontID the font ID, specified in {@link FontID}
	 */
	public void setFont(int fontID)
	{
		this.getWidget().setFontId(fontID);
	}

	/**
	 * Sets the colour of the label text
	 * @param colour the RGB colour
	 */
	public void setColour(int colour)
	{
		this.getWidget().setTextColor(colour);
	}
}

package com.logmaster.ui.generic;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;

/**
 * Functionally identical to the UI Button, except the opacity
 * of the widget is dimmed when the mouse moves over the component
 * @author Antipixel
 */
public class UIFadeButton extends UIButton
{
	private static final float FADE_OPACITY = 0.75f;
	private static final float DEFAULT_OPACITY = 1.0f;

	public UIFadeButton(Widget widget)
	{
		super(widget);
	}

	@Override
	protected void onMouseHover(ScriptEvent e)
	{
		super.onMouseHover(e);

		// Fade the widget
		this.setOpacity(FADE_OPACITY);
	}

	@Override
	protected void onMouseLeave(ScriptEvent e)
	{
		super.onMouseLeave(e);

		// Set the widget back to full opacity
		this.setOpacity(DEFAULT_OPACITY);
	}
}

package com.logmaster.ui.generic;

/**
 * A listener interface for receiving menu actions
 * @author Antipixel
 */
public interface MenuAction
{
	/**
	 * Invoked upon selection of the menu action that is is bound to
	 */
	void onMenuAction();
}

package com.logmaster.ui.generic;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps two widgets, one a sprite and one text, and gives them the
 * functionality of a checkbox component. A listener can be added to the checkbox
 * which triggers upon the switching of the checkbox state between check and unchecked.
 * @author Antipixel
 */
public class UICheckBox extends UIComponent
{
	private static final int LABEL_COL_DEFAULT = 0xFF981F;
	private static final int LABEL_COL_HOVER = 0xFFFFFF;
	private static final int LABEL_WIDTH = 89;
	private static final int LABEL_HEIGHT = 18;

	private static final int SPRITEID_CHECKBOX_UNCHECKED_STD = 1215;
	private static final int SPRITEID_CHECKBOX_CHECKED_STD = 1217;
	private static final int SPRITEID_CHECKBOX_UNCHECKED_HOV = 1218;
	private static final int SPRITEID_CHECKBOX_CHECKED_HOV = 1220;
	private static final int CHECKBOX_SIZE = 16;

	private static final String OPTION_TOGGLE = "Toggle";

	private UILabel label;
	private UIGraphic checkbox;

	@Getter
	private boolean enabled;
	private boolean hovering;

	@Setter
	private ComponentEventListener<UICheckBox> toggleListener;

	/**
	 * Constructs a new checkbox component
	 * @param boxIcon the checkbox graphic widget
	 * @param labelWidget the checkbox label widget
	 */
	public UICheckBox(Widget boxIcon, Widget labelWidget)
	{
		super(boxIcon);

		this.enabled = false;
		this.hovering = false;

		// Wrap the widget in a label component, set the
		// dimension, colour and attach the listeners
		this.label = new UILabel(labelWidget);
		this.label.setSize(LABEL_WIDTH, LABEL_HEIGHT);
		this.label.setColour(LABEL_COL_DEFAULT);
		this.label.setOnHoverListener(this::onLabelHover);
		this.label.setOnLeaveListener(this::onLabelLeave);
		this.label.addAction(OPTION_TOGGLE, this::onCheckboxToggled);

		this.checkbox = new UIGraphic(boxIcon);
		this.checkbox.addAction(OPTION_TOGGLE, this::onCheckboxToggled);
		this.checkbox.setOnHoverListener(e -> onLabelHover(label));
		this.checkbox.setOnLeaveListener(e -> onLabelLeave(label));

		// Resize and update the sprite for the checkbox widget
		this.updateCheckboxSprite();
		this.setSize(CHECKBOX_SIZE, CHECKBOX_SIZE);
	}

	/**
	 * Called upon the mouse hovering over the label component
	 * @param src the label component
	 */
	private void onLabelHover(UIComponent src)
	{
		// Update the hovering state
		this.hovering = true;

		// Update the label colour
		UILabel label = (UILabel) src;
		label.setColour(LABEL_COL_HOVER);

		// Make sure the checkbox sprite is up to date
		this.updateCheckboxSprite();
	}

	/**
	 * Called upon the mouse leaving the label component
	 * @param src the label component
	 */
	private void onLabelLeave(UIComponent src)
	{
		// Update the hovering state
		this.hovering = false;

		// Update the label colour
		UILabel label = (UILabel) src;
		label.setColour(LABEL_COL_DEFAULT);

		// Make sure the checkbox sprite is up to date
		this.updateCheckboxSprite();
	}

	@Override
	public void setX(int x)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setX(x);
		this.label.setX(x);
	}

	@Override
	public void setY(int y)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setY(y);
		this.label.setY(y);
	}

	@Override
	public void setName(String name)
	{
		// Set the name of the label instead
		this.label.setName(name);
	}

	/**
	 * Called upon the toggle menu action being selected on the checkbox component
	 */
	private void onCheckboxToggled()
	{
		// Switch the checked state
		this.setEnabled(!enabled);

		// If there's a toggle listener registered, call it
		if (this.toggleListener != null)
			this.toggleListener.onComponentEvent(this);
	}

	/**
	 * Updates the sprite for the checkbox, depending on whether the checkbox
	 * is enabled or disabled, or if the mouse is hovering over it
	 */
	private void updateCheckboxSprite()
	{
		// Get both standard and hovering sprites for the current enable state
		int stdSprite = enabled ? SPRITEID_CHECKBOX_CHECKED_STD : SPRITEID_CHECKBOX_UNCHECKED_STD;
		int hovSprite = enabled ? SPRITEID_CHECKBOX_CHECKED_HOV : SPRITEID_CHECKBOX_UNCHECKED_HOV;

		// Apply it to the checkbox widget, depending on whether the mouse is hovering
		this.getWidget().setSpriteId(this.hovering ? hovSprite : stdSprite);
	}

	/**
	 * Sets the state of the checkbox, checked or unchecked
	 * @param enabled true for checked, false for unchecked
	 */
	public void setEnabled(boolean enabled)
	{
		// Set the new state
		this.enabled = enabled;

		// Update the sprite
		this.updateCheckboxSprite();
	}

	/**
	 * Sets the text of the checkbox label
	 * @param text the label text
	 */
	public void setText(String text)
	{
		this.label.setText(text);
	}

	// Align checkbox to right hand side of the window near the close button
	public void alignToRightEdge(Widget window, int marginFromEdge, int y)
	{
		int windowWidth = window.getWidth();
		int checkboxX = windowWidth - LABEL_WIDTH - CHECKBOX_SIZE - marginFromEdge;
		this.setPosition(checkboxX, y);
		
		// Force widget position updates
		this.getWidget().setPos(checkboxX, y);
		this.label.getWidget().setPos(checkboxX + CHECKBOX_SIZE + 4, y); // 4px spacing between checkbox and label
		
		// Revalidate widgets
		this.getWidget().revalidate();
		this.label.getWidget().revalidate();
	}
}

package com.logmaster.ui.generic;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * UI Component classes allow for complex user interface functionality by
 * wrapping the gaming widget and carefully controlling its behaviour
 * @author Antipixel
 */
public abstract class UIComponent
{
	private static final int MAX_OPACITY = 255;
	private static final String BTN_NAME_FORMAT = "<col=ff9040>%s</col>";

	@Getter
	protected Widget widget;

	/* Actions and events */
	protected List<MenuAction> actions;

	@Setter
	private ComponentEventListener<UIComponent> hoverListener;

	@Setter
	private ComponentEventListener<UIComponent> leaveListener;

	@Setter
	private ComponentEventListener<UIComponent> mousePressListener;

	@Setter
	private ComponentEventListener<UIComponent> mouseDragListener;

	@Setter
	private ComponentEventListener<UIComponent> mouseReleaseListener;

	/**
	 * Constructs a new UIComponent
	 * @param widget the underlying game widget
	 */
	public UIComponent(Widget widget)
	{
		this.widget = widget;

		// Assign the event listeners to the widget
		this.widget.setOnOpListener((JavaScriptCallback) this::onActionSelected);
		this.widget.setOnMouseOverListener((JavaScriptCallback) this::onMouseHover);
		this.widget.setOnMouseLeaveListener((JavaScriptCallback) this::onMouseLeave);
		this.widget.setHasListener(true);

		this.actions = new ArrayList<>();
	}

	public UIComponent(Widget widget, Set<Integer> allowedTypes) {
		this(widget);

		if (!allowedTypes.contains(widget.getType())) {
			String msg = String.format("Incompatible widget's type given; %s given, %d expected", allowedTypes, widget.getType());
			throw new RuntimeException(msg);
		}
	}

	/**
	 * Adds an action option to the component's menu
	 * @param action the action name
 	 * @param callback the callback event, which is trigger upon the
	 *                 selection of this menu option
	 */
	public void addAction(String action, MenuAction callback)
	{
		this.widget.setAction(actions.size(), action);
		this.actions.add(callback);
	}

	/**
	 * Triggered upon the selection of menu option
	 * @param e the script event
	 */
	protected void onActionSelected(ScriptEvent e)
	{
		// If there's no actions specified, ignore
		if (this.actions.isEmpty())
			return;

		// Get the action event object for this menu option
		MenuAction actionEvent = this.actions.get(e.getOp() - 1);

		// Call the action listener for this option
		actionEvent.onMenuAction();
	}

	/**
	 * Triggered upon the mouse entering the component
	 * @param e the script event
	 */
	protected void onMouseHover(ScriptEvent e)
	{
		// If a hover event is specified, trigger it
		if (this.hoverListener != null)
			this.hoverListener.onComponentEvent(this);
	}

	/**
	 * Triggered upon the mouse leaving the component
	 * @param e the script event
	 */
	protected void onMouseLeave(ScriptEvent e)
	{
		// If a leave event is specified, trigger it
		if (this.leaveListener != null)
			this.leaveListener.onComponentEvent(this);
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * hovering over the widget
	 * @param listener the listener
	 */
	public void setOnHoverListener(ComponentEventListener<UIComponent> listener)
	{
		this.hoverListener = listener;
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * exiting from over the widget
	 * @param listener the listener
	 */
	public void setOnLeaveListener(ComponentEventListener<UIComponent> listener)
	{
		this.leaveListener = listener;
	}

	/**
	 * Sets the name of the component widget
	 * @param name the component name
	 */
	public void setName(String name)
	{
		this.widget.setName(String.format(BTN_NAME_FORMAT, name));
	}

	/**
	 * Sets the component size
	 * @param width the component width
	 * @param height the component height
	 */
	public void setSize(int width, int height)
	{
		this.widget.setOriginalWidth(width);
		this.widget.setOriginalHeight(height);
	}

	public void setSizeMode(int widthMode, int heightMode)
	{
		this.widget.setWidthMode(widthMode);
		this.widget.setHeightMode(heightMode);
	}

	/**
	 * Sets the position of the component, relative
	 * to the parent layer widget
	 * @param x the x position
	 * @param y the y position
	 */
	public void setPosition(int x, int y)
	{
		this.setX(x);
		this.setY(y);
	}

	/**
	 * Sets the X position of the component, relative
	 * to the parent layer
	 * @param x the x position
	 */
	public void setX(int x)
	{
		this.widget.setOriginalX(x);
	}

	/**
	 * Sets the Y position of the component, relative
	 * to the parent layer
	 * @param y the x position
	 */
	public void setY(int y)
	{
		this.widget.setOriginalY(y);
	}

	/**
	 * Gets the X position of the component, relative
	 * to the the parent layer
	 * @return the x position
	 */
	public int getX()
	{
		return this.widget.getOriginalX();
	}

	/**
	 * Gets the Y position of the component, relative
	 * to the the parent layer
	 * @return the y position
	 */
	public int getY()
	{
		return this.widget.getOriginalY();
	}


	/**
	 * Sets the visibility of the component
	 * @param visible true for visible, false for hidden
	 */
	public void setVisibility(boolean visible)
	{
		this.widget.setHidden(!visible);
	}

	/**
	 * Sets the opacity of the widget
	 * @param opacity the opacity value. Expects a value
	 *                between 0.0 (transparent) and 1.0 (opaque)
	 */
	public void setOpacity(float opacity)
	{
		// Cap the opacity to 1.0
		if (opacity > 1.0)
			opacity = 1.0f;

		// Invert the percentage
		float percentage = 1.0f - opacity;

		// Convert the percentage value to a 0-255 integer
		this.widget.setOpacity((int)(percentage * MAX_OPACITY));
	}

	/**
	 * Gets the opacity of the widget
	 * @return an opacity value between 0.0 (transparent) and 1.0 (opaque)
	 */
	public float getOpacity()
	{
		// Convert the opacity to a percentage
		float opacity = (float)this.widget.getOpacity() / MAX_OPACITY;

		// Invert the percentage
		return 1.0f - opacity;
	}

	public void clearActions() {
		actions.clear();
	}

	public void revalidate() {
		this.widget.revalidate();
	}
}

package com.logmaster.ui.generic;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a button, with the option of a second sprite shown on hover
 * @author Antipixel
 */
public class UIButton extends UIComponent
{
	private int spriteStandard;
	private int spriteHover;

	/**
	 * Constructs a new button component
	 * @param widget the underlying widget
	 */
	public UIButton(Widget widget)
	{
		super(widget);

		// Blank the sprites
		this.spriteStandard = -1;
		this.spriteHover = -1;
	}

	@Override
	protected void onMouseHover(ScriptEvent e)
	{
		// Call the parent method
		super.onMouseHover(e);

		// Update the sprite
		this.getWidget().setSpriteId(this.spriteHover);
	}

	@Override
	protected void onMouseLeave(ScriptEvent e)
	{
		// Call the parent method
		super.onMouseLeave(e);

		// Update the sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	/**
	 * Sets the button sprite for both standard and hover
	 * @param standard the standard sprite id
	 * @param hover the sprite to display on hover
	 */
	public void setSprites(int standard, int hover)
	{
		this.spriteStandard = standard;
		this.spriteHover = hover;

		// Update the widgets sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	/**
	 * Sets the sprite for the button, for buttons
	 * without a sprite for hovering state
	 * @param standard the button sprite
	 */
	public void setSprites(int standard)
	{
		this.setSprites(standard, standard);
	}
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.domain.Task;
import com.logmaster.task.TaskService;
import com.logmaster.ui.InterfaceManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class TaskOverlay extends Overlay {

    private static final Dimension EMPTY = new Dimension(0, 0);

    private static final int WIDTH_ADDITION = 51;
    private static final int MIN_HEIGHT = 46;

    private static final float OUTER_COLOR_OFFSET = 0.8f;
    private static final float INNER_COLOR_OFFSET = 1.2f;
    private static final float ALPHA_OFFSET = 1.4f;

    private static final int MAX_BYTE = 255;

    @Inject
    private LogMasterConfig config;

    @Inject
    private RuneLiteConfig runeLiteConfig;

    @Inject
    private ItemManager itemManager;

    @Inject
    private InterfaceManager interfaceManager;

    @Inject
    private TaskService taskService;

    @Override
    public Dimension render(Graphics2D g) {
        try {
            Task activeTask = taskService.getActiveTask();
            if (!config.displayCurrentTaskOverlay() || activeTask == null || interfaceManager.isDashboardOpen()) {
                return EMPTY;
            }

            Image icon = itemManager.getImage(activeTask.getDisplayItemId());
            String task = activeTask.getName();


            FontMetrics fm = g.getFontMetrics();

            int width = fm.stringWidth(task) + WIDTH_ADDITION;
            int height = MIN_HEIGHT;

            Color border = outsideColor(this.runeLiteConfig.overlayBackgroundColor());

            g.setColor(this.runeLiteConfig.overlayBackgroundColor());
            g.fillRect(0, 0, width, height);
            g.setColor(border);
            g.drawRect(0, 0, width, height);

//            int textX = 46;
            int textX = width - fm.stringWidth(task) - 5;
            int textY = 30;

            g.setFont(g.getFont().deriveFont(16f));
            g.setColor(Color.BLACK);
            g.drawString(task, textX + 1, textY + 1);
            g.setColor(Color.WHITE);
            g.drawString(task, textX, textY);

            int iconWidth = icon.getWidth(null);
            int iconHeight = icon.getHeight(null);

            g.drawImage(icon, 5 + 18 - (iconWidth / 2), 5 + 18 - (iconHeight / 2), iconWidth, iconHeight, null);
            return new Dimension(width, height);
        } catch (Throwable t) {
            t.printStackTrace();
            return EMPTY;
        }
    }

    private Color outsideColor(Color base) {
        return new Color(
                Math.round(base.getRed() * OUTER_COLOR_OFFSET),
                Math.round(base.getGreen() * OUTER_COLOR_OFFSET),
                Math.round(base.getBlue() * OUTER_COLOR_OFFSET),
                Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
        );
    }

    private Color innerColor(Color base) {
        return new Color(
                Math.min(MAX_BYTE, Math.round(base.getRed() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getGreen() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getBlue() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
        );
    }
}

package com.logmaster.ui.component;

import com.google.inject.Inject;
import com.logmaster.util.EventBusSubscriber;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.eventbus.Subscribe;

import java.util.*;

@Slf4j
public class BurgerMenuManager extends EventBusSubscriber {
    private static final int DRAW_BURGER_MENU_SCRIPT_ID = 7812;
    private static final int COLLECTION_LOG_SETUP_SCRIPT_ID = 7797;
    private static final int COLLECTION_LOG_BURGER_MENU_WIDGET_ID = 40697929;

    private static final int BG_OPACITY = 255;
    private static final int BG_OPACITY_SELECTED = 230;
    private static final int TEXT_OPACITY = 0;
    private static final int TEXT_OPACITY_SELECTED = 200;
    private static final int TEXT_COLOR = 0xFF981F;
    private static final int TEXT_COLOR_SELECTED = 0xC8C8C8;
    private static final int TEXT_COLOR_HOVER = 0xFFFFFF;

    private static final String BUTTON_TEXT = "Tasks";
    private static final String ACTION_TEXT = "View Tasks Dashboard";

    @Inject
    private Client client;

    private Widget menu;
    private Widget ourBackground;
    private Widget ourText;
    private Widget firstBackground;
    private Widget firstText;

    private int baseMenuHeight = -1;

    @Getter
    private boolean selected = false;

    @Setter
    private Runnable onSelectChangedListener = null;

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        int scriptId = event.getScriptId();
        if (scriptId == COLLECTION_LOG_SETUP_SCRIPT_ID) {
            setSelected(false);
            baseMenuHeight = -1;
        }

        if (scriptId != DRAW_BURGER_MENU_SCRIPT_ID) {
            return;
        }

        Object[] args = event.getScriptEvent().getArguments();
        int menuId = (int) args[3];
        if (menuId != COLLECTION_LOG_BURGER_MENU_WIDGET_ID) {
            return;
        }

        try {
            log.debug("Adding task dashboard button to menu with ID: {}", menuId);
            addButton(menuId);
        } catch (Exception e) {
            log.debug("Failed to add task dashboard button to menu: {}", e.getMessage());
        }
    }

    public void setSelected(boolean selected) {
        if (this.selected == selected) return;

        this.selected = selected;
        restyleOptions();

        if (this.onSelectChangedListener != null) {
            this.onSelectChangedListener.run();
        }
    }

    private void restyleOptions() {
        if (ourBackground == null || ourText == null) return;

        Widget selectedBackground = selected ? ourBackground : firstBackground;
        Widget selectedText = selected ? ourText : firstText;
        Widget defaultBackground = selected ? firstBackground : ourBackground;
        Widget defaultText = selected ? firstText : ourText;

        selectedBackground.setOpacity(BG_OPACITY_SELECTED);
        selectedText.setOpacity(TEXT_OPACITY_SELECTED)
            .setTextColor(TEXT_COLOR_SELECTED);

        defaultBackground.setOpacity(BG_OPACITY);
        defaultText.setOpacity(TEXT_OPACITY)
            .setTextColor(TEXT_COLOR);

        selectedBackground.revalidate();
        selectedText.revalidate();
        defaultBackground.revalidate();
        defaultText.revalidate();
    }

    private void addButton(int menuId) throws NullPointerException, NoSuchElementException {
        Widget menu = Objects.requireNonNull(client.getWidget(menuId));
        List<Widget> menuChildren = Arrays.asList(Objects.requireNonNull(menu.getChildren()));
        if (baseMenuHeight == -1) {
            baseMenuHeight = menu.getOriginalHeight();
        }

        setupFirstWidgets(menuChildren);
        List<Widget> reversedMenuChildren = new ArrayList<>(menuChildren);
        Collections.reverse(reversedMenuChildren);
        Widget lastBackground = getFirstWidgetOfType(reversedMenuChildren, WidgetType.RECTANGLE);
        Widget lastText = getFirstWidgetOfType(reversedMenuChildren, WidgetType.TEXT);

        final int buttonHeight = lastBackground.getHeight();
        final int buttonY = lastBackground.getOriginalY() + buttonHeight;

        final boolean existingButton = menuChildren.stream()
                .anyMatch(w -> w.getText().equals(BUTTON_TEXT));

        if (!existingButton) {
            this.menu = menu;

            ourBackground = menu.createChild(WidgetType.RECTANGLE)
                    .setOriginalWidth(lastBackground.getOriginalWidth())
                    .setOriginalHeight(lastBackground.getOriginalHeight())
                    .setOriginalX(lastBackground.getOriginalX())
                    .setOriginalY(buttonY)
                    .setOpacity(lastBackground.getOpacity())
                    .setFilled(lastBackground.isFilled())
                    .setTextColor(lastBackground.getTextColor());
            ourBackground.revalidate();

            ourText = menu.createChild(WidgetType.TEXT)
                    .setText(BUTTON_TEXT)
                    .setTextColor(TEXT_COLOR)
                    .setFontId(lastText.getFontId())
                    .setTextShadowed(lastText.getTextShadowed())
                    .setOriginalWidth(lastText.getOriginalWidth())
                    .setOriginalHeight(lastText.getOriginalHeight())
                    .setOriginalX(lastText.getOriginalX())
                    .setOriginalY(buttonY)
                    .setXTextAlignment(lastText.getXTextAlignment())
                    .setYTextAlignment(lastText.getYTextAlignment());
            ourText.setHasListener(true);
            ourText.setOnMouseOverListener((JavaScriptCallback) ev -> { if (!selected) ourText.setTextColor(TEXT_COLOR_HOVER); });
            ourText.setOnMouseLeaveListener((JavaScriptCallback) ev -> { if (!selected) ourText.setTextColor(TEXT_COLOR); });
            ourText.setAction(0, ACTION_TEXT);
            ourText.setOnOpListener((JavaScriptCallback) ev -> {
                setSelected(true);
                hideMenu();
            });
            ourText.revalidate();
        }

        if (menu.getOriginalHeight() <= baseMenuHeight) {
            menu.setOriginalHeight((menu.getOriginalHeight() + buttonHeight));
        }

        restyleOptions();
        menu.revalidate();
        for (Widget child : menuChildren) {
            child.revalidate();
        }
    }

    private void setupFirstWidgets(List<Widget> menuChildren) {
        firstBackground = getFirstWidgetOfType(menuChildren, WidgetType.RECTANGLE);
        firstText = getFirstWidgetOfType(menuChildren, WidgetType.TEXT);

        firstText.setHasListener(true);
        firstText.setOnMouseOverListener((JavaScriptCallback) ev -> { if (selected) firstText.setTextColor(TEXT_COLOR_HOVER); });
        firstText.setOnMouseLeaveListener((JavaScriptCallback) ev -> { if (selected) firstText.setTextColor(TEXT_COLOR); });
        firstText.setAction(0, firstText.getText());
        firstText.setOnOpListener((JavaScriptCallback) ev -> {
            setSelected(false);
            hideMenu();
        });
    }

    private void hideMenu() {
        if (menu != null) {
            menu.setHidden(true)
                .revalidate();
        }
    }

    private static Widget getFirstWidgetOfType(List<Widget> menuChildren, int widgetType) {
        return menuChildren.stream()
                .filter(w -> w.getType() == widgetType)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("No widget of type" + widgetType + " found in menu"));
    }
}
package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.synchronization.SyncService;
import com.logmaster.task.TaskService;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import com.logmaster.ui.generic.UILabel;
import com.logmaster.ui.generic.UIPage;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.SoundEffectID;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.swing.*;
import java.awt.*;
import java.util.List;
import java.util.Map;

import static com.logmaster.ui.InterfaceConstants.COLLECTION_LOG_WINDOW_HEIGHT;
import static com.logmaster.ui.InterfaceConstants.COLLECTION_LOG_WINDOW_WIDTH;

public class TaskDashboard extends UIPage {
    private final static int DEFAULT_BUTTON_WIDTH = 140;
    private final static int DEFAULT_BUTTON_HEIGHT = 30;
    private final static int SMALL_BUTTON_WIDTH = 68;
    private final static int DEFAULT_TASK_DETAILS_WIDTH = 300;
    private final static int DEFAULT_TASK_DETAILS_HEIGHT = 75;
    private final static int GENERATE_TASK_SPRITE_ID = -20001;
    private final static int COMPLETE_TASK_SPRITE_ID = -20000;
    private final static int GENERATE_TASK_HOVER_SPRITE_ID = -20003;
    private final static int COMPLETE_TASK_HOVER_SPRITE_ID = -20002;
    private final static int GENERATE_TASK_DISABLED_SPRITE_ID = -20005;
    private final static int COMPLETE_TASK_DISABLED_SPRITE_ID = -20004;
    private final static int TASK_BACKGROUND_SPRITE_ID = -20006;
    private final static int FAQ_BUTTON_SPRITE_ID = -20027;
    private final static int FAQ_BUTTON_HOVER_SPRITE_ID = -20028;
    private final static int SYNC_BUTTON_SPRITE_ID = -20034;
    private final static int SYNC_BUTTON_HOVER_SPRITE_ID = -20035;
    private final static int SYNC_BUTTON_DISABLED_SPRITE_ID = -20036;

    @Getter
    private Widget window;
    private LogMasterPlugin plugin;

    private LogMasterConfig config;
    private final SyncService syncService;
    private final TaskService taskService;
    private final Client client;

    private UILabel title;
    private UILabel taskLabel;
    private UILabel percentCompletion;

    private UIGraphic taskImage;
    private UIGraphic taskBg;

    private UIButton completeTaskBtn;
    private UIButton generateTaskBtn;
    private UIButton faqBtn;
    private UIButton syncBtn;

    public TaskDashboard(LogMasterPlugin plugin, LogMasterConfig config, Widget window, SyncService syncService, TaskService taskService, Client client) {
        this.window = window;
        this.plugin = plugin;
        this.config = config;
        this.syncService = syncService;
        this.taskService = taskService;
        this.client = client;

        createTaskDetails();

        Widget titleWidget = window.createChild(-1, WidgetType.TEXT);
        this.title = new UILabel(titleWidget);
        this.title.setFont(FontID.QUILL_CAPS_LARGE);
        this.title.setSize(COLLECTION_LOG_WINDOW_WIDTH, DEFAULT_TASK_DETAILS_HEIGHT);
        this.title.setPosition(getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH), 24);
        this.title.setText("Current Task");

        Widget percentWidget = window.createChild(-1, WidgetType.TEXT);
        this.percentCompletion = new UILabel(percentWidget);
        this.percentCompletion.setFont(FontID.BOLD_12);
        this.percentCompletion.setSize(COLLECTION_LOG_WINDOW_WIDTH, 25);
        this.percentCompletion.setPosition(getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH), COLLECTION_LOG_WINDOW_HEIGHT - 91);
        updatePercentages();

        Widget completeTaskWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.completeTaskBtn = new UIButton(completeTaskWidget);
        this.completeTaskBtn.setSize(DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        this.completeTaskBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) + (DEFAULT_BUTTON_WIDTH / 2 + 15), getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62);
        this.completeTaskBtn.setSprites(COMPLETE_TASK_SPRITE_ID, COMPLETE_TASK_HOVER_SPRITE_ID);

        Widget generateTaskWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.generateTaskBtn = new UIButton(generateTaskWidget);
        this.generateTaskBtn.setSize(DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        this.generateTaskBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) - (DEFAULT_BUTTON_WIDTH / 2 + 15), getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62);
        this.generateTaskBtn.setSprites(GENERATE_TASK_SPRITE_ID, GENERATE_TASK_HOVER_SPRITE_ID);

        Widget faqWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.faqBtn = new UIButton(faqWidget);
        this.faqBtn.setSize(SMALL_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        this.faqBtn.setPosition(getCenterX(window, SMALL_BUTTON_WIDTH) + 190, getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112);
        this.faqBtn.setSprites(FAQ_BUTTON_SPRITE_ID, FAQ_BUTTON_HOVER_SPRITE_ID);

        
        Widget syncWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.syncBtn = new UIButton(syncWidget);
        this.syncBtn.setSize(SMALL_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        this.syncBtn.setPosition(getCenterX(window, SMALL_BUTTON_WIDTH) - 190, getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112);
        this.syncBtn.setSprites(SYNC_BUTTON_SPRITE_ID, SYNC_BUTTON_DISABLED_SPRITE_ID);

        this.add(this.title);
        this.add(this.taskBg);
        this.add(this.taskLabel);
        this.add(this.taskImage);
        this.add(this.completeTaskBtn);
        this.add(this.generateTaskBtn);
        this.add(this.percentCompletion);
        this.add(faqBtn);
        this.add(syncBtn);
    }

    private void createTaskDetails() {
        final int POS_X = getCenterX(window, DEFAULT_TASK_DETAILS_WIDTH);
        final int POS_Y = getCenterY(window, DEFAULT_TASK_DETAILS_HEIGHT)-3;

        Widget taskBgWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.taskBg = new UIGraphic(taskBgWidget);
        this.taskBg.setSize(DEFAULT_TASK_DETAILS_WIDTH, DEFAULT_TASK_DETAILS_HEIGHT);
        this.taskBg.setPosition(POS_X, POS_Y);
        this.taskBg.setSprite(TASK_BACKGROUND_SPRITE_ID);

        Widget label = window.createChild(-1, WidgetType.TEXT);
        label.setTextColor(Color.WHITE.getRGB());
        label.setTextShadowed(true);
        label.setName("Task Label");
        this.taskLabel = new UILabel(label);
        this.taskLabel.setFont(496);
        this.taskLabel.setPosition(POS_X+60, POS_Y);
        this.taskLabel.setSize(DEFAULT_TASK_DETAILS_WIDTH-60, DEFAULT_TASK_DETAILS_HEIGHT);

        Widget taskImageWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.taskImage = new UIGraphic(taskImageWidget);
        this.taskImage.setPosition(POS_X+12, POS_Y+21);
        this.taskImage.getWidget().setItemQuantityMode(ItemQuantityMode.NEVER);
        this.taskImage.setSize(42, 36);
        this.taskImage.getWidget().setBorderType(1);
    }

    public void setTask(String desc, int taskItemID, List<Task> cyclingTasks) {
        if (cyclingTasks != null) {
            for (int i = 0; i < 250; i++) {
                Task displayTask = cyclingTasks.get((int) Math.floor(Math.random() * cyclingTasks.size()));
                // Seems the most natural timing
                double decay = 450.0 / ((double) config.rollTime());
                int delay = (int) ((config.rollTime() * 0.925) * Math.exp(-decay * i));
                Timer fakeTaskTimer = new Timer(delay, ae -> {
                    this.taskLabel.setText(displayTask.getName());
                    this.taskImage.setItem(displayTask.getDisplayItemId());
                });
                fakeTaskTimer.setRepeats(false);
                fakeTaskTimer.setCoalesce(true);
                fakeTaskTimer.start();
            }
            Timer realTaskTimer = new Timer(config.rollTime(), ae -> {
                this.taskLabel.setText(desc);
                this.taskImage.setItem(taskItemID);
                this.enableCompleteTask();
                this.enableFaqButton();
            });
            realTaskTimer.setRepeats(false);
            realTaskTimer.setCoalesce(true);
            realTaskTimer.start();
        } else {
            this.taskLabel.setText(desc);
            this.taskImage.setItem(taskItemID);
            this.enableCompleteTask();
            this.enableFaqButton();
        }
    }

	private void generateTask() {
		client.playSoundEffect(SoundEffectID.UI_BOOP);
		Task generatedTask = taskService.generate();

		List<Task> rollTaskList = config.rollPastCompleted() ? taskService.getTierTasks() : taskService.getIncompleteTierTasks();
		setTask(generatedTask.getName(), generatedTask.getDisplayItemId(), rollTaskList);
        disableGenerateTask(false);
        updatePercentages();
	}

    public void updatePercentages() {
        Map<TaskTier, Float> progress = taskService.getProgress();
        TaskTier currentTier = taskService.getCurrentTier();
        float tierPercentage = progress.get(currentTier);

        String text = String.format(
                "<col=%s>%d%%</col> %s Completed",
                getCompletionColor(tierPercentage),
                (int) tierPercentage,
                currentTier.displayName
        );
        percentCompletion.setText(text);
    }

    private String getCompletionColor(double percent) {
        int max = 255;
        int amount = (int) Math.round(((percent % 50) / 50) * max);

        if(percent == 100) {
            return "00ff00";
        }
        else if(percent > 50) {
            int redValue = max - amount;
            return String.format("%02x", redValue)+"ff00";

        }
        else if(percent == 50) {
            return "ffff00";
        }
        else {
            return "ff"+String.format("%02x", amount)+"00";
        }
    }

    public void disableGenerateTask() {
        disableGenerateTask(true);
    }

    public void disableGenerateTask(boolean enableComplete) {
        this.generateTaskBtn.setSprites(GENERATE_TASK_DISABLED_SPRITE_ID);
        this.generateTaskBtn.clearActions();

        this.generateTaskBtn.addAction("Disabled", this::playFailSound);

        if (enableComplete) {
            this.enableCompleteTask();
            this.enableFaqButton();
        }
    }

    public void enableGenerateTask() {
        this.generateTaskBtn.clearActions();
        this.generateTaskBtn.setSprites(GENERATE_TASK_SPRITE_ID, GENERATE_TASK_HOVER_SPRITE_ID);
        this.generateTaskBtn.addAction("Generate task", this::generateTask);

        this.disableCompleteTask();
    }

    public void disableCompleteTask() {
        this.completeTaskBtn.setSprites(COMPLETE_TASK_DISABLED_SPRITE_ID);
        this.completeTaskBtn.clearActions();
        this.completeTaskBtn.addAction("Disabled", this::playFailSound);
    }

    public void enableCompleteTask() {
        this.completeTaskBtn.clearActions();
        this.completeTaskBtn.setSprites(COMPLETE_TASK_SPRITE_ID, COMPLETE_TASK_HOVER_SPRITE_ID);
        this.completeTaskBtn.addAction("Complete", plugin::completeTask);
    }

    public void enableFaqButton() {
        this.faqBtn.clearActions();
        this.faqBtn.setSprites(FAQ_BUTTON_SPRITE_ID, FAQ_BUTTON_HOVER_SPRITE_ID);
        this.faqBtn.addAction("FAQ", plugin::visitFaq);
        this.enableSyncButton();
    }

    public void enableSyncButton() {
        this.syncBtn.clearActions();
        this.syncBtn.setSprites(SYNC_BUTTON_SPRITE_ID, SYNC_BUTTON_HOVER_SPRITE_ID);
        this.syncBtn.addAction("Auto sync completed tasks", syncService::sync);
    }

    public void updateBounds() {
        if (!this.isVisible()) {
            return;
        }

        int windowWidth = window.getWidth();

        // Update title position - force widget position update
        int titleX = getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH);
        this.title.setPosition(titleX, 24);
        this.title.getWidget().setPos(titleX, 24);

        // Update task details (background, label, image)
        final int taskPosX = getCenterX(window, DEFAULT_TASK_DETAILS_WIDTH);
        final int taskPosY = getCenterY(window, DEFAULT_TASK_DETAILS_HEIGHT) - 3;
        
        this.taskBg.setPosition(taskPosX, taskPosY);
        this.taskBg.getWidget().setPos(taskPosX, taskPosY);
        
        this.taskLabel.setPosition(taskPosX + 60, taskPosY);
        this.taskLabel.getWidget().setPos(taskPosX + 60, taskPosY);
        
        this.taskImage.setPosition(taskPosX + 12, taskPosY + 21);
        this.taskImage.getWidget().setPos(taskPosX + 12, taskPosY + 21);

        // Update button positions - force widget position updates
        int generateBtnX = getCenterX(window, DEFAULT_BUTTON_WIDTH) - (DEFAULT_BUTTON_WIDTH / 2 + 15);
        int generateBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62;
        this.generateTaskBtn.setPosition(generateBtnX, generateBtnY);
        this.generateTaskBtn.getWidget().setPos(generateBtnX, generateBtnY);
        
        int completeBtnX = getCenterX(window, DEFAULT_BUTTON_WIDTH) + (DEFAULT_BUTTON_WIDTH / 2 + 15);
        int completeBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62;
        this.completeTaskBtn.setPosition(completeBtnX, completeBtnY);
        this.completeTaskBtn.getWidget().setPos(completeBtnX, completeBtnY);
        
        // Update FAQ button position with boundary checking
        int faqBtnX = getCenterX(window, SMALL_BUTTON_WIDTH) + 238;
        int faqBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112;
        
        // Check if FAQ button would go outside the window and align with edge if needed
        int faqBtnWidth = SMALL_BUTTON_WIDTH;
        if (faqBtnX + faqBtnWidth + 10 > windowWidth) {
            faqBtnX = windowWidth - faqBtnWidth - 10; // 10px margin from edge
        }
        this.faqBtn.setPosition(faqBtnX, faqBtnY);
        this.faqBtn.getWidget().setPos(faqBtnX, faqBtnY);

        // Update Sync button position with boundary checking
        int syncBtnX = getCenterX(window, SMALL_BUTTON_WIDTH) - 238;
        int syncBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112;
        if (syncBtnX < 10) {
            syncBtnX = 10; // 10px margin from left edge
        }
        this.syncBtn.setPosition(syncBtnX, syncBtnY);
        this.syncBtn.getWidget().setPos(syncBtnX, syncBtnY);
        
        // Update percentage completion position - force widget position update
        int percentX = getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH);
        int percentY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112; // Same Y as FAQ button
        this.percentCompletion.setPosition(percentX, percentY);
        this.percentCompletion.getWidget().setPos(percentX, percentY);
        
        // Force revalidation of all widgets
        this.title.getWidget().revalidate();
        this.taskBg.getWidget().revalidate();
        this.taskLabel.getWidget().revalidate();
        this.taskImage.getWidget().revalidate();
        this.generateTaskBtn.getWidget().revalidate();
        this.completeTaskBtn.getWidget().revalidate();
        this.faqBtn.getWidget().revalidate();
        this.syncBtn.getWidget().revalidate();
        this.percentCompletion.getWidget().revalidate();
    }

	private int getCenterX(Widget window, int width) {
		return (window.getWidth() / 2) - (width / 2);
	}

	private int getCenterY(Widget window, int height) {
		return (window.getHeight() / 2) - (height / 2);
	}

	private void playFailSound() {
		client.playSoundEffect(2277);
	}
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.TaskTier;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import java.util.ArrayList;
import java.util.List;

import static com.logmaster.ui.InterfaceConstants.*;

public class TabManager {
    private final LogMasterConfig config;
    private final Widget window;
    private final LogMasterPlugin plugin;
    
    private List<UIButton> tabs;
    private UIButton taskDashboardTab;
    
    private TaskDashboard taskDashboard;
    private TaskList taskList;
    private UIGraphic divider;

    public TabManager(Widget window, LogMasterConfig config, LogMasterPlugin plugin) {
        this.window = window;
        this.config = config;
        this.plugin = plugin;
        
        createTabs();
        createDivider();
    }

    public void setComponents(TaskDashboard taskDashboard, TaskList taskList) {
        this.taskDashboard = taskDashboard;
        this.taskList = taskList;
    }

    private void createTabs() {
        // Remove any existing tabs from the window
        if (tabs != null) {
            for (UIButton tab : tabs) {
                if (tab != null && tab.getWidget() != null) {
                    tab.getWidget().setHidden(true);
                }
            }
        }
        tabs = new ArrayList<>();
        // Remove and recreate dashboard tab
        if (taskDashboardTab != null && taskDashboardTab.getWidget() != null) {
            taskDashboardTab.getWidget().setHidden(true);
        }
        Widget dashboardTabWidget = window.createChild(-1, WidgetType.GRAPHIC);
        taskDashboardTab = new UIButton(dashboardTabWidget);
        taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
        taskDashboardTab.setSize(95, 21);
        taskDashboardTab.setPosition(10, 0);
        taskDashboardTab.addAction("View <col=ff9040>Dashboard</col>", this::activateTaskDashboard);
        taskDashboardTab.setVisibility(false);
        // Always create all tabs for all tiers
        for (TaskTier tier : TaskTier.values()) {
            Widget tabWidget = window.createChild(-1, WidgetType.GRAPHIC);
            UIButton tab = new UIButton(tabWidget);
            tab.setSize(66, 21);
            tab.setVisibility(false);
            tabs.add(tab);
        }
    }

    private void createDivider() {
        Widget dividerWidget = window.createChild(-1, WidgetType.GRAPHIC);
        divider = new UIGraphic(dividerWidget);
        divider.setSprite(DIVIDER_SPRITE_ID);
        divider.setSize(window.getWidth() - 20, 1); // Full width minus margins
        divider.setPosition(10, 20);
    }

    public void updateBounds() {
        // Update divider width to match window width
        int windowWidth = window.getWidth();
        divider.setSize(windowWidth - 20, 1);
        divider.getWidget().setSize(windowWidth - 20, 1);
        divider.getWidget().revalidate();
        
        // Force widget position updates for all tabs
        taskDashboardTab.getWidget().revalidate();
        for (UIButton tab : tabs) {
            tab.getWidget().revalidate();
        }

        // Update tab positions
        updateTabPositions();
    }

    private void updateTabPositions() {
        int windowWidth = window.getWidth();
        int availableWidth = windowWidth - 20; // 10px margin on each side
        int dashboardTabWidth = 95;
        int regularTabWidth = 66;
        int minSpacing = -30; // Allow up to 30px overlap
        // Count only visible tabs
        int visibleTierTabs = 0;
        for (TaskTier tier : TaskTier.values()) {
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                visibleTierTabs++;
            }
        }
        int totalTabsWidth = dashboardTabWidth + (visibleTierTabs * regularTabWidth);
        int spacing = (availableWidth - totalTabsWidth) / (visibleTierTabs + 2);
        // Allow negative spacing for overlap, but not less than minSpacing
        spacing = Math.max(minSpacing, Math.min(10, spacing));
        int dashboardX = 10 + spacing;
        taskDashboardTab.setSize(dashboardTabWidth, 21);
        taskDashboardTab.setPosition(dashboardX, 0);
        taskDashboardTab.getWidget().setSize(dashboardTabWidth, 21);
        taskDashboardTab.getWidget().setPos(dashboardX, 0);
        int currentX = dashboardX + dashboardTabWidth + spacing;
        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                UIButton tab = tabs.get(tabIndex);
                tab.setSize(regularTabWidth, 21);
                tab.setPosition(currentX, 0);
                tab.getWidget().setSize(regularTabWidth, 21);
                tab.getWidget().setPos(currentX, 0);
                currentX += regularTabWidth + spacing;
            }
            tabIndex++;
        }
        // Revalidate all tabs
        for (UIButton tab : tabs) {
            tab.revalidate();
            tab.getWidget().revalidate();
        }
    }

    public void updateTabs() {
        hideTabs();
        if (tabs == null) return;

        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                UIButton tab = tabs.get(tabIndex);

                if (plugin.getSelectedTier() == tier && !this.taskDashboard.isVisible()) {
                    tab.setSprites(tier.tabSpriteHoverId);
                } else {
                    tab.setSprites(tier.tabSpriteId, tier.tabSpriteHoverId);
                }

                tab.setSize(66, 21);

                int finalTabIndex = tabIndex;
                String actionLabel = String.format("View <col=ff9040>%s Task List</col>", tier.displayName);
                tab.clearActions();
                tab.addAction(actionLabel, () -> activateTaskListForTier(tier, finalTabIndex));
            }

            tabIndex++;
        }

        showTabs();
    }

    private void activateTaskListForTier(TaskTier tier, int tabIndex) {
        taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
        if (plugin.getSelectedTier() != tier) {
            this.taskList.goToTop();
            plugin.setSelectedTier(tier);
        }
        updateTabs();
        tabs.get(tabIndex).setSprites(tier.tabSpriteHoverId);
        this.taskDashboard.setVisibility(false);
        this.taskList.refreshTasks(0);
        this.taskList.setVisibility(true);
    }

    public void activateTaskDashboard() {
        this.taskDashboardTab.setSprites(DASHBOARD_TAB_HOVER_SPRITE_ID);
        this.taskList.setVisibility(false);
        this.taskDashboard.setVisibility(true);
        updateTabs();
    }

    public void hideTabs() {
        if (this.taskDashboardTab != null) {
            this.taskDashboardTab.setVisibility(false);
        }
        if (this.tabs != null) {
            this.tabs.forEach(t -> t.setVisibility(false));
        }
    }

    public void showTabs() {
        // Hide tabs if neither list is visible
        if (!this.taskList.isVisible() && !this.taskDashboard.isVisible()) {
            this.hideTabs();
            return;
        }
        if (this.taskDashboardTab != null) {
            this.taskDashboardTab.setVisibility(true);
        }
        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            UIButton tab = this.tabs.get(tabIndex);
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                tab.setVisibility(true);
            } else {
                // Move out of view before hiding
                tab.setPosition(-1000, 0);
                tab.getWidget().setPos(-1000, 0);
                tab.setVisibility(false);
            }
            tabIndex++;
        }
        updateTabPositions();
    }

    public void onConfigChanged() {
        createTabs();
        updateTabs();
    }
}

package com.logmaster.ui.component;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.DynamicTaskImages;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.domain.verification.clog.CollectionLogVerification;
import com.logmaster.synchronization.clog.CollectionLogService;
import com.logmaster.task.TaskService;
import com.logmaster.ui.generic.UIButton;
import com.logmaster.ui.generic.UIGraphic;
import com.logmaster.ui.generic.UILabel;
import com.logmaster.ui.generic.UIPage;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;

import java.awt.*;
import java.awt.event.MouseWheelEvent;
import java.util.ArrayList;
import java.util.List;

import static com.logmaster.ui.InterfaceConstants.*;

@Slf4j
public class TaskList extends UIPage {
    private final static int OFFSET_X = 0;
    private final static int OFFSET_Y = 21;
    private final static int TASK_WIDTH = 300;
    private final static int TASK_HEIGHT = 50;
    private final static int COLUMN_SPACING = 24;
    private final static int TASK_ITEM_HEIGHT = 32;
    private final static int TASK_ITEM_WIDTH = 36;
    private final static int PAGE_UP_ARROW_SPRITE_ID = -20029;
    private final static int UP_ARROW_SPRITE_ID = -20014;
    private final static int DOWN_ARROW_SPRITE_ID = -20015;
    private final static int PAGE_DOWN_ARROW_SPRITE_ID = -20030;
    private final static int THUMB_TOP_SPRITE_ID = -20031;
    private final static int THUMB_MIDDLE_SPRITE_ID = -20032;
    private final static int THUMB_BOTTOM_SPRITE_ID = -20033;
    private final static int ARROW_SPRITE_WIDTH = 39;
    private final static int ARROW_SPRITE_HEIGHT = 20;
    private final static int ARROW_Y_OFFSET = 4;
    private final static int SCROLLBAR_WIDTH = 35; // Match arrow width
    private final static int SCROLLBAR_THUMB_MIN_HEIGHT = 8;
    

    private final Widget window;
    private final LogMasterPlugin plugin;
    private final ClientThread clientThread;
    private final CollectionLogService collectionLogService;
    private final TaskService taskService;

    private Rectangle bounds = new Rectangle();

    private List<UIGraphic> taskBackgrounds = new ArrayList<>();
    private List<UILabel> taskLabels = new ArrayList<>();
    private List<UIGraphic> taskImages = new ArrayList<>();
    private Widget scrollbarTrackWidget;
    private Widget scrollbarThumbTopWidget;
    private Widget scrollbarThumbMiddleWidget;
    private Widget scrollbarThumbBottomWidget;
    private UIButton pageUpButton;
    private UIButton upArrowButton;
    private UIButton downArrowButton;
    private UIButton pageDownButton;
    private boolean isDraggingThumb = false;
    private int dragStartY = 0;
    private int dragStartTopIndex = 0;
    private int topTaskIndex = 0;
    private int totalTasks = 0;
    // default values, will update when bounds change
    private int windowWidth = 480;
    private int windowHeight = 252;
    private int wrapperX = 0;
    private int wrapperY = 0;
    private int wrapperHeight = 230;
    private int windowX = 0;
    private int windowY = 0;
    private int tasksPerPage = 20;
    private int columns = 1;

    private final LogMasterConfig config;

    public TaskList(Widget window, LogMasterPlugin plugin, ClientThread clientThread, LogMasterConfig config, CollectionLogService collectionLogService, TaskService taskService) {
        this.window = window;
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.config = config;
        this.collectionLogService = collectionLogService;
        this.taskService = taskService;

        updateBounds();

        createScrollbarComponents();
        this.add(upArrowButton);
        this.add(pageUpButton);
        this.add(downArrowButton);
        this.add(pageDownButton);

        // Refresh the tasks list
        refreshTasks(0);
    }

    private void createScrollbarComponents() {
        Widget pageUpWidget = window.createChild(-1, WidgetType.GRAPHIC);
        pageUpButton = new UIButton(pageUpWidget);
        pageUpButton.setSprites(PAGE_UP_ARROW_SPRITE_ID);
        pageUpButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        pageUpButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        pageUpButton.addAction("Page up", () -> refreshTasks(-tasksPerPage));

        Widget upWidget = window.createChild(-1, WidgetType.GRAPHIC);
        upArrowButton = new UIButton(upWidget);
        upArrowButton.setSprites(UP_ARROW_SPRITE_ID);
        upArrowButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        upArrowButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        upArrowButton.addAction("Scroll up", () -> refreshTasks(-1));

        scrollbarTrackWidget = window.createChild(-1, WidgetType.RECTANGLE);
        scrollbarTrackWidget.setFilled(true);
        scrollbarTrackWidget.setTextColor(0x665948);
        scrollbarTrackWidget.setSize(SCROLLBAR_WIDTH, 200);
        scrollbarTrackWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET);
        
        scrollbarThumbTopWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbTopWidget.setSpriteId(THUMB_TOP_SPRITE_ID);
        scrollbarThumbTopWidget.setSize(SCROLLBAR_WIDTH, 2);
        scrollbarThumbTopWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET);

        scrollbarThumbMiddleWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbMiddleWidget.setSpriteId(THUMB_MIDDLE_SPRITE_ID);
        scrollbarThumbMiddleWidget.setSize(SCROLLBAR_WIDTH, SCROLLBAR_THUMB_MIN_HEIGHT - 4);
        scrollbarThumbMiddleWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + 2);

        scrollbarThumbBottomWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbBottomWidget.setSpriteId(THUMB_BOTTOM_SPRITE_ID);
        scrollbarThumbBottomWidget.setSize(SCROLLBAR_WIDTH, 2);
        scrollbarThumbBottomWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + SCROLLBAR_THUMB_MIN_HEIGHT - 2);

        Widget downWidget = window.createChild(-1, WidgetType.GRAPHIC);
        downArrowButton = new UIButton(downWidget);
        downArrowButton.setSprites(DOWN_ARROW_SPRITE_ID);
        downArrowButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        downArrowButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        downArrowButton.addAction("Scroll down", () -> refreshTasks(1));

        Widget pageDownWidget = window.createChild(-1, WidgetType.GRAPHIC);
        pageDownButton = new UIButton(pageDownWidget);
        pageDownButton.setSprites(PAGE_DOWN_ARROW_SPRITE_ID);
        pageDownButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        pageDownButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        pageDownButton.addAction("Page down", () -> refreshTasks(tasksPerPage));
    }
    
    public void refreshTasks(int dir) {
        TaskTier relevantTier = plugin.getSelectedTier();
        if (relevantTier == null) {
            relevantTier = TaskTier.MASTER;
        }
        int tasksToShowCount = tasksPerPage * columns;
        totalTasks = taskService.getTierTasks(relevantTier).size();
        if (dir != 0) {
            int newIndex = topTaskIndex + (dir * columns);
            topTaskIndex = Math.min(Math.max(0, totalTasks - tasksToShowCount), Math.max(0, newIndex));
        }
        int rows = tasksPerPage;
        int totalTasksHeight = rows * TASK_HEIGHT;
        int verticalMargin = Math.max(0, (wrapperHeight - totalTasksHeight) / (rows - 1));
        int totalHeightWithMargin = totalTasksHeight + (rows > 1 ? (rows - 1) * verticalMargin : 0);
        int startY = OFFSET_Y + Math.max(0, (wrapperHeight - totalHeightWithMargin) / 2);
        int totalWidth = columns * TASK_WIDTH + (columns - 1) * COLUMN_SPACING;
        int startX = (windowWidth - totalWidth - SCROLLBAR_WIDTH - 10) / 2;
        hideUnusedTaskElements(tasksToShowCount);
        List<Task> tasksToShow = getTasksToShow(relevantTier, topTaskIndex, tasksToShowCount);
        int widgetIndex = 0;
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < columns; col++) {
                int i = row * columns + col;
                if (i >= tasksToShow.size() || i > tasksToShowCount) {
                    break;
                }

                Task task = tasksToShow.get(i);

                int taskY = startY + (row * (TASK_HEIGHT + verticalMargin));
                int taskX = startX + col * (TASK_WIDTH + COLUMN_SPACING);

                UIGraphic taskBg;
                if (taskBackgrounds.size() <= widgetIndex) {
                    // Create a new background if it doesn't exist yet
                    taskBg = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                    taskBackgrounds.add(taskBg);
                    this.add(taskBg);
                } else {
                    taskBg = taskBackgrounds.get(widgetIndex);
                }
                // Ensure it's visible, clear the actions, set size and position
                taskBg.getWidget().setHidden(false);
                taskBg.clearActions();
                taskBg.getWidget().clearActions();
                taskBg.setSize(TASK_WIDTH, TASK_HEIGHT);
                taskBg.setPosition(taskX, taskY);
                taskBg.getWidget().setPos(taskX, taskY);
                boolean taskCompleted = taskService.isComplete(task.getId());

                Task activeTask = taskService.getActiveTask();
                if (activeTask != null && activeTask.getId().equals(task.getId())) {
                    taskBg.setSprite(TASK_CURRENT_BACKGROUND_SPRITE_ID);
                } else if (taskCompleted) {
                    taskBg.setSprite(TASK_COMPLETE_BACKGROUND_SPRITE_ID);
                } else {
                    taskBg.setSprite(TASK_LIST_BACKGROUND_SPRITE_ID);
                }

                // Create the task label
                UILabel taskLabel;
                if (taskLabels.size() <= widgetIndex) {
                    // Create a new label if it doesn't exist yet
                    taskLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
                    this.add(taskLabel);
                    taskLabels.add(taskLabel);
                } else {
                    taskLabel = taskLabels.get(widgetIndex);
                }
                taskLabel.getWidget().setHidden(false);
                taskLabel.getWidget().setTextColor(Color.WHITE.getRGB());
                taskLabel.getWidget().setTextShadowed(true);
                taskLabel.getWidget().setName(task.getName());
                taskLabel.setText(task.getName());
                taskLabel.setFont(496);
                taskLabel.setPosition(taskX + 60, taskY);
                taskLabel.setSize(TASK_WIDTH-60, TASK_HEIGHT);

                // Create the task image
                UIGraphic taskImage;
                if (taskImages.size() <= widgetIndex) {
                    // Create a new image if it doesn't exist yet
                    taskImage = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                    this.add(taskImage);
                    taskImages.add(taskImage);
                } else {
                    taskImage = taskImages.get(widgetIndex);
                }
                taskImage.getWidget().setHidden(false);
                taskImage.setPosition(taskX + 12, taskY + 6);
                taskImage.getWidget().setBorderType(1);
                taskImage.getWidget().setItemQuantityMode(ItemQuantityMode.NEVER);
                taskImage.setSize(TASK_ITEM_WIDTH, TASK_ITEM_HEIGHT);
                taskImage.setItem(task.getDisplayItemId());

                // Add our right click actions
                taskBg.addAction("Mark as " + (taskCompleted ? "<col=c0392b>incomplete" : "<col=27ae60>completed") + "</col>", () -> plugin.completeTask(task.getId()));

                if (task.getVerification() instanceof CollectionLogVerification) {
                    CollectionLogVerification verif = (CollectionLogVerification) task.getVerification();

                    int[] checkArray = verif.getItemIds();
                    int count = verif.getCount();
                    if (checkArray.length > 0) {
                        taskBg.addAction("==============", () -> {});
                        List<String> lockedItems = new ArrayList<>();
                        List<String> unlockedItems = new ArrayList<>();
                        for (int checkID : checkArray) {
                            String itemName = plugin.itemManager.getItemComposition(checkID).getName();
                            itemName = itemName.replaceFirst("^Pet\\s+", "");
                            itemName = itemName.replaceFirst("^(.)", itemName.substring(0, 1).toUpperCase());
                            if (collectionLogService.isItemObtained(checkID)) {
                                unlockedItems.add(itemName);
                            } else {
                                lockedItems.add(itemName);
                            }
                        }
                        if (checkArray.length > 1) {
                            taskBg.addAction("Items acquired: " + (count <= unlockedItems.size() ? "<col=27ae60>" : "<col=c0392b>") + unlockedItems.size() + "/" + count + "</col>", () -> {});
                            taskBg.addAction("==============", () -> {});
                        }
                        lockedItems.sort(String::compareToIgnoreCase);
                        for (String item : lockedItems) {
                            taskBg.addAction("<col=c0392b>-</col> " + item, () -> {});
                        }
                        unlockedItems.sort(String::compareToIgnoreCase);
                        for (String item : unlockedItems) {
                            taskBg.addAction("<col=27ae60>+</col> " + item, () -> {});
                        }
                    }

                    if (
                        !task.getName().contains("clues")
                        && (config.dynamicTaskImages() == DynamicTaskImages.ALL || (!taskCompleted && config.dynamicTaskImages() == DynamicTaskImages.INCOMPLETE) || (taskCompleted && config.dynamicTaskImages() == DynamicTaskImages.COMPLETE))
                    ) {
                        List<Integer> potentialItems = new ArrayList<>();
                        for (int checkID : checkArray) {
                            if (
                                (taskCompleted && collectionLogService.isItemObtained(checkID)) ||
                                (!taskCompleted && !collectionLogService.isItemObtained(checkID))
                             ) {
                                potentialItems.add(checkID);
                            }
                        }

                        if (!potentialItems.isEmpty()) {
                            taskImage.setItem(potentialItems.get((count - 1) % potentialItems.size()));
                        }
                    }
                }

                taskImage.revalidate();
                taskLabel.revalidate();
                taskBg.revalidate();

                widgetIndex++;
            }
        }
        updateScrollbar();
    }

    // Overload getTasksToShow to accept a count
    private List<Task> getTasksToShow(TaskTier relevantTier, int topTaskIndex, int count) {
        List<Task> tasksToShow = new ArrayList<>();
        List<Task> taskList = taskService.getTierTasks(relevantTier);
        for (int i = 0; i < count; i++) {
            if (topTaskIndex + i >= taskList.size()) break;
            tasksToShow.add(taskList.get(topTaskIndex + i));
        }
        return tasksToShow;
    }

    private void hideUnusedTaskElements(int visibleCount) {
        // Only hide widgets beyond visibleCount (which is visibleTasks+1)
        for (int i = visibleCount; i < taskBackgrounds.size(); i++) {
            UIGraphic bg = taskBackgrounds.get(i);
            bg.getWidget().setHidden(true);
            bg.setPosition(-1000, 0);
            bg.getWidget().setPos(-1000, 0);
            bg.setSprite(TRANSPARENT_SPRITE_ID);
        }
        for (int i = visibleCount; i < taskLabels.size(); i++) {
            UILabel label = taskLabels.get(i);
            label.getWidget().setHidden(true);
            label.setPosition(-1000, 0);
            label.getWidget().setPos(-1000, 0);
            label.setText("");
        }
        for (int i = visibleCount; i < taskImages.size(); i++) {
            UIGraphic img = taskImages.get(i);
            img.getWidget().setHidden(true);
            img.setPosition(-1000, 0);
            img.getWidget().setPos(-1000, 0);
            img.setItem(-1);
        }
    }

    public void goToTop() {
        topTaskIndex = 0;
        updateScrollbar();
    }

    public void handleWheel(final MouseWheelEvent event)
    {
        if (!this.isVisible() || !bounds.contains(event.getPoint()))
        {
            return;
        }

        event.consume();

        // Needed otherwise we get laggy updates
        clientThread.invoke(() -> refreshTasks(event.getWheelRotation()));
    }

    public void updateBounds()
    {
        if (!this.isVisible()) {
            return;
        }

        Widget collectionLogWrapper = window.getParent();
        wrapperX = collectionLogWrapper.getRelativeX();
        wrapperY = collectionLogWrapper.getRelativeY();
        wrapperHeight = window.getHeight() - OFFSET_Y;
        windowX = window.getRelativeX();
        windowY = window.getRelativeY();
        windowWidth = window.getWidth();
        windowHeight = window.getHeight();

        // Recalculate how many tasks can be displayed
        int newTasksPerPage = Math.max(1, wrapperHeight / TASK_HEIGHT);
        columns = Math.max(1, (windowWidth - SCROLLBAR_WIDTH - 40) / (TASK_WIDTH + COLUMN_SPACING));
        if (newTasksPerPage != tasksPerPage) {
            tasksPerPage = newTasksPerPage;
            // Ensure topTaskIndex is valid for the new page size
            TaskTier relevantTier = plugin.getSelectedTier();
            if (relevantTier == null) {
                relevantTier = TaskTier.MASTER;
            }
            int maxTopIndex = Math.max(0, taskService.getTierTasks(relevantTier).size() - tasksPerPage);
            topTaskIndex = Math.min(topTaskIndex, maxTopIndex);
        }
        updateArrowPositions();
        updateScrollbar();
        refreshTasks(0);

        bounds.setLocation(wrapperX + windowX + OFFSET_X, wrapperY + windowY + OFFSET_Y);
        bounds.setSize(windowWidth - OFFSET_X, wrapperHeight);
    }

    private void updateArrowPositions() {
        int scrollbarX = windowWidth - ARROW_SPRITE_WIDTH - 5;
        // Position arrows vertically in order: page up, up, down, page down
        int pageUpY = ARROW_SPRITE_HEIGHT + ARROW_Y_OFFSET;
        int upArrowY = ARROW_SPRITE_HEIGHT * 2 + ARROW_Y_OFFSET;
        int downArrowY = windowHeight - ARROW_SPRITE_HEIGHT * 2;
        int pageDownY = windowHeight - ARROW_SPRITE_HEIGHT;
        forceWidgetPositionUpdate(pageUpButton.getWidget(), scrollbarX, pageUpY);
        forceWidgetPositionUpdate(upArrowButton.getWidget(), scrollbarX, upArrowY);
        forceWidgetPositionUpdate(downArrowButton.getWidget(), scrollbarX, downArrowY);
        forceWidgetPositionUpdate(pageDownButton.getWidget(), scrollbarX, pageDownY);
    }

    private void forceWidgetPositionUpdate(Widget button, int x, int y) {
        button.setPos(x, y);
        button.revalidate();
    }

    private void forceWidgetUpdate(Widget widget, int width, int height) {
        widget.setSize(width, height);
        widget.revalidate();
    }

    private void updateScrollbar() {
        if (!this.isVisible()) {
            setScrollbarVisibility(false);
            return;
        }

        // The track should fill between the up and down arrows
        int trackY = ARROW_SPRITE_HEIGHT * 3 + ARROW_Y_OFFSET;
        int scrollbarTrackHeight = windowHeight - trackY - ARROW_SPRITE_HEIGHT * 2;
        int scrollbarX = windowWidth - SCROLLBAR_WIDTH - 9;
        scrollbarTrackWidget.setPos(scrollbarX + 2, trackY);

        // Update position, arrows and thumbs
        forceWidgetUpdate(scrollbarTrackWidget, SCROLLBAR_WIDTH, scrollbarTrackHeight);
        updateArrowPositions();
        setScrollbarVisibility(true);
        updateScrollbarThumb(scrollbarTrackHeight, scrollbarX);
    }

    private void updateScrollbarThumb(int scrollbarTrackHeight, int scrollbarX) {
        int tasksPerPageActual = (columns > 1) ? tasksPerPage * columns : tasksPerPage;
        topTaskIndex = Math.min(topTaskIndex, Math.max(0, totalTasks - tasksPerPageActual));
        int thumbHeight = Math.max(SCROLLBAR_THUMB_MIN_HEIGHT, (int)(scrollbarTrackHeight * ((double)tasksPerPageActual / totalTasks)));
        int maxScrollPosition = Math.max(1, totalTasks - tasksPerPageActual);
        int thumbY = (int)((scrollbarTrackHeight - thumbHeight) * ((double)topTaskIndex / maxScrollPosition));
        int thumbStartY = ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + thumbY;
        int thumbX = scrollbarX + 2;
        // Update middle section (variable height)
        int middleHeight = Math.max(0, thumbHeight - 4);
        scrollbarThumbMiddleWidget.setSize(SCROLLBAR_WIDTH, middleHeight);
        // Force redraw all thumb components
        forceWidgetPositionUpdate(scrollbarThumbTopWidget, thumbX, thumbStartY);
        forceWidgetPositionUpdate(scrollbarThumbMiddleWidget, thumbX, thumbStartY + 2);
        forceWidgetPositionUpdate(scrollbarThumbBottomWidget, thumbX, thumbStartY + thumbHeight - 2);
    }

    private int calculateNewScrollPosition(int mouseY, int totalTasks) {
        int tasksPerPageActual = tasksPerPage * columns;
        int scrollbarTrackHeight = wrapperHeight - (ARROW_SPRITE_HEIGHT * 4) - ARROW_Y_OFFSET;
        int thumbHeight = Math.max(SCROLLBAR_THUMB_MIN_HEIGHT, (int)(scrollbarTrackHeight * ((double)tasksPerPageActual / totalTasks)));
        int deltaY = mouseY - dragStartY;
        int maxTopIndex = Math.max(0, totalTasks - tasksPerPageActual);
        double scrollRatio = (scrollbarTrackHeight - thumbHeight) > 0 ? (double)deltaY / (scrollbarTrackHeight - thumbHeight) : 0;
        int newTopIndex = dragStartTopIndex + (int)(scrollRatio * (totalTasks - tasksPerPageActual));
        
        // Round to nearest column boundary
        newTopIndex = (newTopIndex / columns) * columns;
        
        return Math.max(0, Math.min(maxTopIndex, newTopIndex));
    }

    private void setScrollbarVisibility(boolean visible) {
        if (scrollbarTrackWidget != null) scrollbarTrackWidget.setHidden(!visible);
        if (scrollbarThumbTopWidget != null) scrollbarThumbTopWidget.setHidden(!visible);
        if (scrollbarThumbMiddleWidget != null) scrollbarThumbMiddleWidget.setHidden(!visible);
        if (scrollbarThumbBottomWidget != null) scrollbarThumbBottomWidget.setHidden(!visible);
    }

    @Override
    public void setVisibility(boolean visible) {
        super.setVisibility(visible);
        setScrollbarVisibility(visible && this.isVisible());
        if (visible) updateScrollbar();
    }

    public void handleMousePress(int mouseX, int mouseY) {
        if (!this.isVisible()) return;
        
        if (isPointInScrollThumb(mouseX, mouseY)) {
            isDraggingThumb = true;
            dragStartY = mouseY;
            dragStartTopIndex = topTaskIndex;
        }
    }

    public void handleMouseDrag(int mouseX, int mouseY) {
        if (!isDraggingThumb || !this.isVisible()) return;
        
        if (totalTasks <= tasksPerPage) return;
        
        int newTopIndex = calculateNewScrollPosition(mouseY, totalTasks);
        if (newTopIndex != topTaskIndex) {
            topTaskIndex = newTopIndex;
            // Needed otherwise we get laggy updates
            clientThread.invoke(() -> refreshTasks(0));
        }
    }

    private boolean isPointInScrollThumb(int mouseX, int mouseY) {
        int baseX = wrapperX + windowX;
        int baseY = wrapperY + windowY;
        
        // Check if point is in any of the three thumb components
        int thumbX = baseX + scrollbarThumbTopWidget.getRelativeX();
        int thumbTopY = baseY + scrollbarThumbTopWidget.getRelativeY();
        int thumbBottomY = baseY + scrollbarThumbBottomWidget.getRelativeY() + scrollbarThumbBottomWidget.getHeight();
        int thumbWidth = scrollbarThumbTopWidget.getWidth();
        
        return mouseX >= thumbX && mouseX <= thumbX + thumbWidth &&
            mouseY >= thumbTopY && mouseY <= thumbBottomY;
    }

    public void handleMouseRelease() {
        isDraggingThumb = false;
    }
}

package com.logmaster.ui;

public class InterfaceConstants {

    public static final String DEF_FILE_SPRITES = "SpriteDef.json";
    public static final int TRANSPARENT_SPRITE_ID = -20099;

    public static final int TASK_BACKGROUND_SPRITE_ID = -20006;
    public static final int TASK_LIST_BACKGROUND_SPRITE_ID = -20012;
    public static final int TASK_COMPLETE_BACKGROUND_SPRITE_ID = -20013;
    public static final int TASK_CURRENT_BACKGROUND_SPRITE_ID = -20016;

    public static final int COLLECTION_LOG_WINDOW_WIDTH = 500;
    public static final int COLLECTION_LOG_WINDOW_HEIGHT = 314;
    public static final int COLLECTION_LOG_CONTENT_WIDGET_ID = 40697858;

    public static final int DASHBOARD_TAB_SPRITE_ID = -20007;
    public static final int DASHBOARD_TAB_HOVER_SPRITE_ID = -20008;
    public static final int TASKLIST_TAB_SPRITE_ID = -20009;
    public static final int TASKLIST_TAB_HOVER_SPRITE_ID = -20010;
    public static final int DIVIDER_SPRITE_ID = -20011;

    public static final int TASKLIST_EASY_TAB_SPRITE_ID = -20017;
    public static final int TASKLIST_EASY_TAB_HOVER_SPRITE_ID = -20018;
    public static final int TASKLIST_MEDIUM_TAB_SPRITE_ID = -20019;
    public static final int TASKLIST_MEDIUM_TAB_HOVER_SPRITE_ID = -20020;
    public static final int TASKLIST_HARD_TAB_SPRITE_ID = -20021;
    public static final int TASKLIST_HARD_TAB_HOVER_SPRITE_ID = -20022;
    public static final int TASKLIST_ELITE_TAB_SPRITE_ID = -20023;
    public static final int TASKLIST_ELITE_TAB_HOVER_SPRITE_ID = -20024;
    public static final int TASKLIST_MASTER_TAB_SPRITE_ID = -20025;
    public static final int TASKLIST_MASTER_TAB_HOVER_SPRITE_ID = -20026;
}

package com.logmaster.ui;

import lombok.Getter;
import net.runelite.client.game.SpriteOverride;

@Getter
public class SpriteDefinition implements SpriteOverride
{
    private int spriteId;
    private String fileName;
}

package com.logmaster.ui;

import com.logmaster.LogMasterConfig;
import com.logmaster.LogMasterPlugin;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.synchronization.SyncService;
import com.logmaster.synchronization.clog.CollectionLogService;
import com.logmaster.task.TaskService;
import com.logmaster.ui.component.BurgerMenuManager;
import com.logmaster.ui.component.TabManager;
import com.logmaster.ui.component.TaskDashboard;
import com.logmaster.ui.component.TaskList;
import com.logmaster.ui.generic.UICheckBox;
import com.logmaster.util.EventBusSubscriber;
import com.logmaster.util.FileUtils;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.SoundEffectID;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.input.MouseWheelListener;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.util.List;

import static com.logmaster.LogMasterConfig.CONFIG_GROUP;
import static com.logmaster.ui.InterfaceConstants.DEF_FILE_SPRITES;

@Singleton
public class InterfaceManager extends EventBusSubscriber implements MouseListener, MouseWheelListener {
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private LogMasterConfig config;

    @Inject
    private LogMasterPlugin plugin;

	@Inject
	private MouseManager mouseManager;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private CollectionLogService collectionLogService;

    @Inject
    private SyncService syncService;

    @Inject
    private TaskService taskService;

    @Inject
    private BurgerMenuManager burgerMenuManager;

    public TaskDashboard taskDashboard;
    private TaskList taskList;
    private TabManager tabManager;
    private UICheckBox taskDashboardCheckbox;

    private boolean checkboxDeprecationWarned = false;

    public void startUp() {
        super.startUp();
        mouseManager.registerMouseListener(this);
        mouseManager.registerMouseWheelListener(this);
        burgerMenuManager.startUp();

        burgerMenuManager.setOnSelectChangedListener(this::toggleTaskDashboard);

        SpriteDefinition[] spriteDefinitions = FileUtils.loadDefinitionResource(SpriteDefinition[].class, DEF_FILE_SPRITES);
        this.spriteManager.addSpriteOverrides(spriteDefinitions);
    }

    public void shutDown() {
        super.shutDown();
        mouseManager.unregisterMouseListener(this);
        mouseManager.unregisterMouseWheelListener(this);
        burgerMenuManager.shutDown();
    }

	@Subscribe
	public void onConfigChanged(ConfigChanged e) {
        if (!e.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

        if (this.taskDashboard == null || !isTaskDashboardEnabled()) {
            return;
        }

        if (tabManager != null) {
            tabManager.updateTabs();

            List<TaskTier> visibleTiers = taskService.getVisibleTiers();
            TaskTier activeTier = plugin.getSelectedTier();
            if (activeTier != null && visibleTiers.contains(activeTier)) {
                tabManager.activateTaskDashboard();
            }
        }

        taskDashboard.updatePercentages();
        tabManager.onConfigChanged();
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded e) {
		if (e.getGroupId() != InterfaceID.COLLECTION) {
			return;
		}

        Widget window = client.getWidget(InterfaceID.Collection.CONTENT);

        createTaskDashboard(window);
        createTaskList(window);
        createTabManager(window);
        createTaskCheckbox();

        this.tabManager.updateTabs();
        this.taskDashboard.setVisibility(false);
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed e) {
		if (e.getGroupId() != InterfaceID.COLLECTION) {
			return;
		}

        this.taskDashboard.setVisibility(false);
        this.taskList.setVisibility(false);
        tabManager.hideTabs();
	}

	@Subscribe
	public void onGameTick(GameTick e) {
        if (this.taskList != null) {
            taskList.updateBounds();
        }
        if (this.taskDashboard != null) {
            taskDashboard.updateBounds();
        }
        if (this.tabManager != null) {
            tabManager.updateBounds();
        }
        if (this.taskDashboardCheckbox != null) {
            Widget window = client.getWidget(621, 88);
            if (window != null) {
                taskDashboardCheckbox.alignToRightEdge(window, 35, 10);
            }
        }
	}

    public boolean isDashboardOpen() {
        return this.taskDashboard != null && this.taskDashboard.isVisible();
    }

    public void handleMouseWheel(MouseWheelEvent event) {
        if (this.taskList != null) {
            taskList.handleWheel(event);
        }
    }

    public void handleMousePress(int mouseX, int mouseY) {
        if (this.taskList != null && this.taskList.isVisible()) {
            taskList.handleMousePress(mouseX, mouseY);
        }
    }

    public void handleMouseDrag(int mouseX, int mouseY) {
        if (this.taskList != null && this.taskList.isVisible()) {
            taskList.handleMouseDrag(mouseX, mouseY);
        }
    }

    public void handleMouseRelease() {
        if (this.taskList != null) {
            taskList.handleMouseRelease();
        }
    }

    @Override
    public MouseWheelEvent mouseWheelMoved(MouseWheelEvent event) {
        handleMouseWheel(event);
        return event;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent event) {
        handleMousePress(event.getX(), event.getY());
        return event;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent event) {
        handleMouseRelease();
        return event;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent event) {
        handleMouseDrag(event.getX(), event.getY());
        return event;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent event) {
        return event;
    }

    private void createTabManager(Widget window) {
        this.tabManager = new TabManager(window, config, plugin);
        this.tabManager.setComponents(taskDashboard, taskList);
    }

    private void createTaskDashboard(Widget window) {
        this.taskDashboard = new TaskDashboard(plugin, config, window, syncService, taskService, client);
        this.taskDashboard.setVisibility(false);
    }

    private void createTaskList(Widget window) {
        this.taskList = new TaskList(window, plugin, clientThread, config, collectionLogService, taskService);
        this.taskList.setVisibility(false);
    }

    private void createTaskCheckbox() {
        Widget window = client.getWidget(621, 88);
        if (window != null) {
            // Create the graphic widget for the checkbox
            Widget toggleWidget = window.createChild(-1, WidgetType.GRAPHIC);
            Widget labelWidget = window.createChild(-1, WidgetType.TEXT);

            // Wrap in checkbox, set size, position, etc.
            taskDashboardCheckbox = new UICheckBox(toggleWidget, labelWidget);
            taskDashboardCheckbox.setPosition(360, 10);
            taskDashboardCheckbox.setName("Task Dashboard");
            taskDashboardCheckbox.setEnabled(false);
            taskDashboardCheckbox.setText("Task Dashboard");
            labelWidget.setPos(375, 10);


            taskDashboardCheckbox.setToggleListener((UICheckBox src) -> {
                if (!checkboxDeprecationWarned) {
                    checkboxDeprecationWarned = true;
                    String msg = "<col=ff392b>Please use the hamburger menu on the top-left corner to open the task dashboard;"
                            + " this checkbox will be removed in the future";
                    client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, "");
                    client.playSoundEffect(2277);
                }

                this.burgerMenuManager.setSelected(taskDashboardCheckbox.isEnabled());
            });
        }
    }

    private void toggleTaskDashboard() {
        if(this.taskDashboard == null) return;

        Task activeTask = taskService.getActiveTask();
        if (activeTask != null) {
            this.taskDashboard.setTask(activeTask.getName(), activeTask.getDisplayItemId(), null);
            this.taskDashboard.disableGenerateTask();
        } else {
            clearCurrentTask();
        }

        boolean enabled = isTaskDashboardEnabled();
        
        
        this.taskDashboardCheckbox.setEnabled(enabled);
        Widget contentWidget = client.getWidget(InterfaceID.Collection.CONTENT);
        if (contentWidget != null) {
            for (Widget c : contentWidget.getStaticChildren()) {
                c.setHidden(enabled);
            }
        }
        Widget searchTitleWidget = client.getWidget(InterfaceID.Collection.SEARCH_TITLE);
        if (searchTitleWidget != null) {
            searchTitleWidget.setHidden(enabled);
        }

        if (enabled) {
            this.tabManager.activateTaskDashboard();
        } else {
            this.taskDashboard.setVisibility(false);
            this.taskList.setVisibility(false);
            this.tabManager.hideTabs();
        }

        // *Boop*
        this.client.playSoundEffect(SoundEffectID.UI_BOOP);
    }

    private boolean isTaskDashboardEnabled() {
        return burgerMenuManager.isSelected();
    }

    public void completeTask() {
        boolean wasDashboardVisible = this.taskDashboard.isVisible();
        this.taskDashboard.updatePercentages();
        taskList.refreshTasks(0);
        // Restore previous visibility state
        this.taskDashboard.setVisibility(wasDashboardVisible);
        this.taskList.setVisibility(!wasDashboardVisible);
        this.tabManager.showTabs();
    }

    public void clearCurrentTask() {
        this.taskDashboard.setTask("No task.", -1, null);
        this.taskDashboard.enableGenerateTask();
        this.taskDashboard.enableFaqButton();
    }
}

package com.logmaster.domain;

public enum DynamicTaskImages {
  NONE,
  INCOMPLETE,
  COMPLETE,
  ALL
}

package com.logmaster.domain;

import com.logmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.annotation.Nullable;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class Task {
    private String id;
    private String name;
    private int displayItemId;
    
    private @Nullable Verification verification;
}

package com.logmaster.domain.verification.diary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum DiaryRegion {
    KARAMJA(0),
    ARDOUGNE(1),
    FALADOR(2),
    FREMENNIK(3),
    KANDARIN(4),
    DESERT(5),
    LUMBRIDGE_AND_DRAYNOR(6),
    MORYTANIA(7),
    VARROCK(8),
    WILDERNESS(9),
    WESTERN_PROVINCES(10),
    KOUREND_AND_KEBOS(11);

    private final int id;
}

package com.logmaster.domain.verification.diary;

import com.logmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class AchievementDiaryVerification extends Verification {
    private @NonNull DiaryRegion region;
    private @NonNull DiaryDifficulty difficulty;
}

package com.logmaster.domain.verification.diary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum DiaryDifficulty {
    EASY(2),
    MEDIUM(5),
    HARD(8),
    ELITE(11);

    private final int stackOffset;
}

package com.logmaster.domain.verification.clog;

import com.logmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class CollectionLogVerification extends Verification {
    private int @NonNull [] itemIds;
    private int count;
}

package com.logmaster.domain.verification;

public enum VerificationMethod {
    COLLECTION_LOG,
    ACHIEVEMENT_DIARY,
    SKILL;
}

package com.logmaster.domain.verification;

import lombok.Getter;

@Getter
public abstract class Verification {
    private VerificationMethod method;
}

package com.logmaster.domain.verification.skill;

import com.logmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import net.runelite.api.Skill;

import java.util.Map;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class SkillVerification extends Verification {
    private @NonNull Map<Skill, Integer> experience;
    private int count;
}

package com.logmaster.domain.savedata;

import lombok.Getter;
import lombok.ToString;

import javax.annotation.Nullable;

@ToString
@Getter
public class BaseSaveData {
    protected @Nullable Integer version = null;
}

package com.logmaster.domain.savedata.v0;

import com.logmaster.domain.TaskTier;
import com.logmaster.domain.savedata.BaseSaveData;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class V0SaveData extends BaseSaveData {
    public final static Integer VERSION = null;

    public V0SaveData() {
        this.progress = new HashMap<>();

        for (TaskTier tier : TaskTier.values()) {
            this.progress.put(tier, new HashSet<>());
        }
    }

    private final Map<TaskTier, Set<Integer>> progress;

    @Setter
    private V0TaskPointer activeTaskPointer;

    @Setter
    private TaskTier selectedTier;
}

package com.logmaster.domain.savedata.v0;

import lombok.Getter;

@Getter
@Deprecated
public class V0Task {
    private int id;
    private String description;
    private int itemID;
}

package com.logmaster.domain.savedata.v0;

import com.logmaster.domain.TaskTier;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Deprecated
public class V0TaskPointer {

    private TaskTier taskTier;
    private V0Task task;
}

package com.logmaster.domain.savedata.v1;

import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@AllArgsConstructor
@NoArgsConstructor
@Deprecated
public class V1TaskPointer {
    private TaskTier taskTier;
    private Task task;
}

package com.logmaster.domain.savedata.v1;

import com.logmaster.domain.TaskTier;
import com.logmaster.domain.savedata.BaseSaveData;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class V1SaveData extends BaseSaveData {
    public final static int VERSION = 1;

    public V1SaveData() {
        this.version = VERSION;
        this.progress = new HashMap<>();

        for (TaskTier tier : TaskTier.values()) {
            this.progress.put(tier, new HashSet<>());
        }
    }

    private final Map<TaskTier, Set<String>> progress;

    @Setter
    private @Nullable V1TaskPointer activeTaskPointer;
}

package com.logmaster.domain.savedata;

import com.logmaster.domain.Task;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashSet;
import java.util.Set;

@Getter
@ToString
public class SaveData extends BaseSaveData {
    public final static int VERSION = 2;

    public SaveData() {
        this.version = VERSION;
    }

    private final Set<String> completedTasks = new HashSet<>();

    @Setter
    private @Nullable Task activeTask = null;
}

package com.logmaster.domain.savedata;

import com.google.gson.reflect.TypeToken;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.domain.savedata.v0.V0SaveData;
import com.logmaster.domain.savedata.v0.V0Task;
import com.logmaster.domain.savedata.v0.V0TaskPointer;
import com.logmaster.domain.savedata.v1.V1SaveData;
import com.logmaster.domain.savedata.v1.V1TaskPointer;
import com.logmaster.task.SaveDataStorage;
import com.logmaster.util.FileUtils;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.logmaster.util.GsonOverride.GSON;

@Singleton
@Slf4j
@SuppressWarnings("deprecation")
public class SaveDataUpdater {
    @Inject
    private SaveDataStorage saveDataStorage;

    public SaveData update(String json) {
        BaseSaveData base = GSON.fromJson(json, BaseSaveData.class);
        if (base == null) {
            return new SaveData();
        }

        if (base.getVersion() == V0SaveData.VERSION) {
            V0SaveData v0Save = GSON.fromJson(json, V0SaveData.class);
            return update(update(v0Save));
        }

        if (base.getVersion() == V1SaveData.VERSION) {
            V1SaveData v1Save = GSON.fromJson(json, V1SaveData.class);
            return update(v1Save);
        }

        return GSON.fromJson(json, SaveData.class);
    }

    private SaveData update(V1SaveData v1Save) {
        saveDataStorage.saveBackup(v1Save);
        SaveData newSave = new SaveData();

        V1TaskPointer v1ActiveTaskPointer = v1Save.getActiveTaskPointer();
        if (v1ActiveTaskPointer != null) {
            newSave.setActiveTask(v1ActiveTaskPointer.getTask());
        }

        Set<String> newCompletedTasks = newSave.getCompletedTasks();
        Set<String> v1CompletedTasks = v1Save.getProgress().entrySet().stream()
                .flatMap(entry -> entry.getValue().stream())
                .collect(Collectors.toSet());

        newCompletedTasks.addAll(v1CompletedTasks);

        return newSave;
    }

    private V1SaveData update(V0SaveData v0Save) {
        saveDataStorage.saveBackup(v0Save);
        V1SaveData newSave = new V1SaveData();

        Type mapType = new TypeToken<Map<TaskTier, Map<Integer, String>>>() {}.getType();
        Map<TaskTier, Map<Integer, String>> v0MigrationData =
                FileUtils.loadResource("domain/savedata/v0-migration.json", mapType);;

        Map<TaskTier, Set<Integer>> v0Progress = v0Save.getProgress();
        Map<TaskTier, Set<String>> newProgress = newSave.getProgress();

        for (TaskTier tier : TaskTier.values()) {
            Set<Integer> v0TierData = v0Progress.get(tier);
            Set<String> newTierData = newProgress.get(tier);
            Map<Integer, String> tierMigrationData = v0MigrationData.get(tier);

            for (Integer v0TaskId : v0TierData) {
                if (tierMigrationData.containsKey(v0TaskId)) {
                    newTierData.add(tierMigrationData.get(v0TaskId));
                }
            }
        }

        V0TaskPointer v0TaskPointer = v0Save.getActiveTaskPointer();
        if (v0TaskPointer != null) {
            V0Task v0Task = v0TaskPointer.getTask();
            String newTaskId = v0MigrationData.get(v0TaskPointer.getTaskTier()).get(v0Task.getId());
            Task newTask = new Task(newTaskId, v0Task.getDescription(), v0Task.getItemID(), null);
            newSave.setActiveTaskPointer(new V1TaskPointer(v0TaskPointer.getTaskTier(), newTask));
        }

        return newSave;
    }
}

package com.logmaster.domain;

import static com.logmaster.ui.InterfaceConstants.*;

public enum TaskTier {
    EASY("Easy", TASKLIST_EASY_TAB_SPRITE_ID, TASKLIST_EASY_TAB_HOVER_SPRITE_ID),
    MEDIUM("Medium", TASKLIST_MEDIUM_TAB_SPRITE_ID, TASKLIST_MEDIUM_TAB_HOVER_SPRITE_ID),
    HARD("Hard", TASKLIST_HARD_TAB_SPRITE_ID, TASKLIST_HARD_TAB_HOVER_SPRITE_ID),
    ELITE("Elite", TASKLIST_ELITE_TAB_SPRITE_ID, TASKLIST_ELITE_TAB_HOVER_SPRITE_ID),
    MASTER("Master", TASKLIST_MASTER_TAB_SPRITE_ID, TASKLIST_MASTER_TAB_HOVER_SPRITE_ID);

    public final String displayName;
    public final int tabSpriteId;
    public final int tabSpriteHoverId;

    TaskTier(String displayName, int tabSpriteId, int tabSpriteHoverId) {
        this.displayName = displayName;
        this.tabSpriteId = tabSpriteId;
        this.tabSpriteHoverId = tabSpriteHoverId;
    }
}

package com.logmaster.domain;

import lombok.Data;

import java.util.Collections;
import java.util.List;

@Data
public class TieredTaskList {
    private List<Task> easy;
    private List<Task> medium;
    private List<Task> hard;
    private List<Task> elite;
    private List<Task> master;

    public List<Task> getForTier(TaskTier tier) {
        switch (tier) {
            case EASY: return easy;
            case MEDIUM: return medium;
            case HARD: return hard;
            case ELITE: return elite;
            case MASTER: return master;
            default: return Collections.emptyList();
        }
    }
}

package com.logmaster.domain.adapters;

import com.google.gson.*;
import com.logmaster.util.EnumUtils;
import com.logmaster.util.StringUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
@RequiredArgsConstructor
public class EnumAdapter<T extends Enum<T>> implements JsonDeserializer<T>, JsonSerializer<T> {
    private final Class<T> clazz;

    @Override
    public T deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context) throws JsonParseException {
        return EnumUtils.fromString(clazz, jsonElement.getAsString());
    }

    @Override
    public JsonElement serialize(T t, Type type, JsonSerializationContext context) {
        return context.serialize(StringUtils.kebabCase(t.name()), String.class);
    }
}

package com.logmaster.domain.adapters;

import com.google.gson.*;
import com.logmaster.domain.verification.Verification;
import com.logmaster.domain.verification.VerificationMethod;
import com.logmaster.domain.verification.clog.CollectionLogVerification;
import com.logmaster.domain.verification.diary.AchievementDiaryVerification;
import com.logmaster.domain.verification.skill.SkillVerification;
import com.logmaster.util.EnumUtils;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
public class VerificationAdapter implements JsonDeserializer<Verification> {
    private static final String DISCRIMINATOR_FIELD = "method";

    @Override
    public Verification deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context) throws JsonParseException {
        JsonObject obj = jsonElement.getAsJsonObject();
        if (!obj.has(DISCRIMINATOR_FIELD)) {
            log.error("Verification object has no required discriminator field '{}'", DISCRIMINATOR_FIELD);
            return null;
        }

        String methodStr = obj.get(DISCRIMINATOR_FIELD).getAsString();
        VerificationMethod method = EnumUtils.fromString(VerificationMethod.class, methodStr);
        if (method == null) {
            log.warn("Verification object has unknown method '{}'", methodStr);
            return null;
        }

        switch (method) {
            case COLLECTION_LOG:
                return context.deserialize(jsonElement, CollectionLogVerification.class);

            case ACHIEVEMENT_DIARY:
                return context.deserialize(jsonElement, AchievementDiaryVerification.class);

            case SKILL:
                return context.deserialize(jsonElement, SkillVerification.class);
        }

        log.error("Unhandled verification method '{}'", method);
        return null;
    }
}

package com.logmaster.task;

import com.logmaster.domain.TieredTaskList;
import com.logmaster.util.FileUtils;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;

import static com.logmaster.util.GsonOverride.GSON;

@Slf4j
@Singleton
public class TaskListStorage {
    private static final String LOCAL_TASK_LIST_FILE = "task-list.json";

    private static final String REMOTE_TASK_LIST_URL = "https://raw.githubusercontent.com/OSRS-Taskman/generate-task/refs/heads/main/src/main/resources/com/logmaster/domain/task-list.json";

    @Inject
    private OkHttpClient client;

    private TieredTaskList taskList;

    @Inject
    public TaskListStorage(OkHttpClient client) {
        this.client = client;

        loadAsync();
    }

    public TieredTaskList get() {
        return taskList;
    }

    private void loadAsync() {
        fetchRemoteAsync()
                .exceptionally(t -> fetchLocal())
                .thenAccept(taskList -> this.taskList = taskList);
    }

    private static TieredTaskList fetchLocal() {
        return FileUtils.loadDefinitionResource(TieredTaskList.class, LOCAL_TASK_LIST_FILE);
    }

    private CompletableFuture<TieredTaskList> fetchRemoteAsync() {
        return requestRemote().thenApply(response -> {
            try (Response res = response) {
                ResponseBody body = res.body();
                if (body == null) {
                    throw new RuntimeException("Response body is null");
                }

                return GSON.fromJson(body.string(), TieredTaskList.class);
            } catch (Exception e) {
                log.error("Error!", e);
                return null;
            }
        });
    }

    private CompletableFuture<Response> requestRemote() {
        Request request = new Request.Builder()
                .url(REMOTE_TASK_LIST_URL)
                .header("Content-Type", "application/json")
                .build();

        CompletableFuture<Response> future = new CompletableFuture<>();
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Failed requesting remote task list", e);
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) {
                future.complete(response);
            }
        });
        return future;
    }
}

package com.logmaster.task;

import com.logmaster.LogMasterConfig;
import com.logmaster.domain.Task;
import com.logmaster.domain.TaskTier;
import com.logmaster.domain.TieredTaskList;
import com.logmaster.domain.savedata.SaveData;
import com.logmaster.domain.verification.clog.CollectionLogVerification;
import com.logmaster.util.EventBusSubscriber;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Singleton
@Slf4j
public class TaskService extends EventBusSubscriber {
    @Inject
    private LogMasterConfig config;

    @Inject
    private SaveDataStorage saveDataStorage;

    @Inject
    private TaskListStorage taskListStorage;

    @Override
    public void startUp() {
        super.startUp();
        saveDataStorage.startUp();
    }

    @Override
    public void shutDown() {
        super.shutDown();
        saveDataStorage.shutDown();
    }

    public Task getActiveTask() {
        return saveDataStorage.get().getActiveTask();
    }

    public @NonNull TaskTier getCurrentTier() {
        Map<TaskTier, Float> progress = getProgress();

        return getVisibleTiers().stream()
                .filter(t -> progress.get(t) < 100)
                .findFirst()
                .orElse(TaskTier.MASTER);
    }

    public List<Task> getTierTasks() {
        return getTierTasks(getCurrentTier());
    }

    public List<Task> getTierTasks(TaskTier tier) {
        return taskListStorage.get().getForTier(tier);
    }

    public List<Task> getIncompleteTierTasks() {
        return getIncompleteTierTasks(getCurrentTier());
    }

    public List<Task> getIncompleteTierTasks(TaskTier tier) {
        TieredTaskList taskList = taskListStorage.get();

        return taskList.getForTier(tier).stream()
                .filter(t -> !isComplete(t.getId()))
                .collect(Collectors.toList());
    }

    public List<TaskTier> getVisibleTiers() {
        TaskTier hideBelow = config.hideBelow();

        return Arrays.stream(TaskTier.values())
                .filter(t -> t.ordinal() >= hideBelow.ordinal())
                .collect(Collectors.toList());
    }

    public @NonNull Map<TaskTier, Float> getProgress() {
        SaveData data = saveDataStorage.get();
        TieredTaskList taskList = taskListStorage.get();
        Set<String> completedTasks = data.getCompletedTasks();

        Map<TaskTier, Float> completionPercentages = new HashMap<>();
        for (TaskTier tier : TaskTier.values()) {
            Set<String> tierTasks = taskList.getForTier(tier).stream()
                    .map(Task::getId)
                    .collect(Collectors.toSet());

            int totalTierTasks = tierTasks.size();
            tierTasks.retainAll(completedTasks);

            float tierPercentage = 100f * tierTasks.size() / totalTierTasks;

            completionPercentages.put(tier, tierPercentage);
        }

        return completionPercentages;
    }

    public Task generate() {
        SaveData data = saveDataStorage.get();

        Task activeTask = data.getActiveTask();
        if (activeTask != null) {
            log.warn("Tried to generate task when previous one wasn't completed yet");
            return null;
        }

        TaskTier currentTier = getCurrentTier();
        List<Task> incompleteTierTasks = getIncompleteTierTasks(currentTier);
        if (incompleteTierTasks.isEmpty()) {
            log.warn("No tasks left");
            return null;
        }

        Task generatedTask = pickRandomTask(incompleteTierTasks);
        log.debug("New task generated: {}", generatedTask);

        data.setActiveTask(generatedTask);
        saveDataStorage.save();

        return generatedTask;
    }

    public void complete() {
        Task activeTask = getActiveTask();
        if (activeTask == null) {
            return;
        }

        complete(activeTask.getId());
    }

    public void complete(String taskId) {
        SaveData data = saveDataStorage.get();
        Set<String> completedTasks = data.getCompletedTasks();
        completedTasks.add(taskId);

        Task activeTask = getActiveTask();
        if (activeTask != null && taskId.equals(activeTask.getId())) {
            data.setActiveTask(null);
        }

        saveDataStorage.save();
    }

    public void uncomplete(String taskId) {
        Set<String> completedTasks = saveDataStorage.get().getCompletedTasks();
        completedTasks.remove(taskId);

        saveDataStorage.save();
    }

    public void toggleComplete(String taskId) {
        if (isComplete(taskId)) {
            uncomplete(taskId);
        } else {
            complete(taskId);
        }
    }

    public boolean isComplete(String taskId) {
        Set<String> completedTasks = saveDataStorage.get().getCompletedTasks();

        return completedTasks.contains(taskId);
    }

    private Task pickRandomTask(List<Task> tasks) {
		int index = (int) Math.floor(Math.random() * tasks.size());
		Task pickedTask = tasks.get(index);

		if (!(pickedTask.getVerification() instanceof CollectionLogVerification)) {
			return pickedTask;
		}

		// get first of similarly named tasks
		String taskName = pickedTask.getName();
		Stream<Task> similarTasks = tasks.stream()
				.filter(t -> taskName.equals(t.getName()))
				.filter(t -> t.getVerification() instanceof CollectionLogVerification);

        //noinspection DataFlowIssue
        return similarTasks.min(Comparator.comparingInt(
			t -> ((CollectionLogVerification) t.getVerification()).getCount()
		)).orElse(pickedTask);
	}

}

package com.logmaster.task;

import com.google.gson.JsonSyntaxException;
import com.logmaster.domain.savedata.BaseSaveData;
import com.logmaster.domain.savedata.SaveData;
import com.logmaster.domain.savedata.SaveDataUpdater;
import com.logmaster.util.EventBusSubscriber;
import com.logmaster.util.SimpleDebouncer;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;

import static com.logmaster.LogMasterConfig.CONFIG_GROUP;
import static com.logmaster.util.GsonOverride.GSON;

@Singleton
@Slf4j
public class SaveDataStorage extends EventBusSubscriber {
    public static final String SAVE_DATA_KEY = "save-data";

    public static final String SAVE_DATA_BACKUP_KEY_BASE = "save-data-bk";

    @Inject
    private ConfigManager configManager;

    @Inject
    private SaveDataUpdater saveDataUpdater;

    @Inject
    private SimpleDebouncer saveDebouncer;

    private SaveData data;

    @Override
    public void startUp() {
        super.startUp();
        load();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged e) {
        GameState state = e.getGameState();
        switch (state) {
            case LOGGED_IN:
                load();
                break;

            case LOGIN_SCREEN:
                saveImmediately();
                break;
        }
    }

    public SaveData get() {
        return data;
    }

    public void save() {
        log.debug("Scheduling save; {}", Instant.now());
        saveDebouncer.debounce(this::saveImmediately);
    }

    public void saveImmediately() {
        log.debug("Saving; {}", Instant.now());
        String json = GSON.toJson(data);
        configManager.setRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY, json);
    }

    public void saveBackup(BaseSaveData data) {
        String json = GSON.toJson(data);
        configManager.setRSProfileConfiguration(
                CONFIG_GROUP,
                SAVE_DATA_BACKUP_KEY_BASE + data.getVersion(),
                json
        );
    }

    private void load() {
        data = read();
    }

    private @NonNull SaveData read() {
        String json = configManager.getRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY);
        if (json == null) {
            return new SaveData();
        }

        try {
            return saveDataUpdater.update(json);
        } catch (JsonSyntaxException e) {
            log.error("Unable to parse save data JSON", e);
        }

        return new SaveData();
    }
}

package com.logmaster;

import com.logmaster.domain.DynamicTaskImages;
import com.logmaster.domain.TaskTier;
import net.runelite.client.config.*;

import static com.logmaster.LogMasterConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface LogMasterConfig extends Config
{
    String CONFIG_GROUP = "log-master";

    String PLUGIN_VERSION_KEY = "plugin-version";

    @Range(
            min = 1000,
            max = 10000
    )
    @Units(Units.MILLISECONDS)
    @ConfigItem(
            keyName = "rollTime",
            name = "Roll Time",
            description = "How long new tasks will take to roll",
            position = 1
    )
    default int rollTime()
    {
        return 5000;
    }

    @ConfigItem(
            keyName = "rollPastCompleted",
            name = "Roll past completed",
            description = "When rolling tasks, include those you've already completed in the roll animation. Helpful when you're getting to the end of a tier!",
            position = 2
    )
    default boolean rollPastCompleted()
    {
        return false;
    }

    @ConfigItem(
            keyName = "hideBelow",
            name = "Hide Tasks Below",
            description = "Disabled the showing up/assigning of tasks at or below the specified tier",
            position = 3
    )
    default TaskTier hideBelow()
    {
        return TaskTier.EASY;
    }

    @ConfigItem(
            keyName = "loadRemoteTaskList",
            name = "Load remote task list",
            description = "Load the latest version of the tasklist, this will be updated more frequently than the default list bundled with the plugin",
            position = 4
    )
    default boolean loadRemoteTaskList()
    {
        return true;
    }

    @ConfigItem(
            keyName = "displayCurrentTaskOverlay",
            name = "Display current task overlay",
            description = "Enable an overlay showing the currently assigned task (when one exists)",
            position = 5
    )
    default boolean displayCurrentTaskOverlay()
    {
        return true;
    }

    @ConfigItem(
            keyName = "dynamicTaskImages",
            name = "Dynamic task images",
            description = "Display dynamic task images based on required/acquired items",
            position = 6
    )
    default DynamicTaskImages dynamicTaskImages()
    {
        return DynamicTaskImages.NONE;
    }
}

package com.logmaster;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LogMasterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LogMasterPlugin.class);
		RuneLite.main(args);
	}
}
