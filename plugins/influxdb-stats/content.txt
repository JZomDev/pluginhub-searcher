package net.machpi.runelite.influxdb;

import net.runelite.api.Client;

// Derived starting from https://github.com/RuneStar/cs2-scripts/blob/9a49f4b47b96c15a05f333d61cdfd469f7a197df/scripts/%5Bproc%2Csummary_sidepanel_draw%5D.cs2
public enum AchievementDiary {
    KARAMJA(2423, 6288, 6289, 6290),
    ARDOUGNE(6291, 6292, 6293, 6294),
    FALADOR(6299, 6300, 6301, 6302),
    FREMENNIK(6303, 6304, 6305, 6306),
    KANDARIN(6307, 6308, 6309, 6310),
    DESERT(6295, 6296, 6297, 6298),
    LUMBRIDGE(6311, 6312, 6313, 6314),
    MORYTANIA(6315, 6316, 6317, 6318),
    VARROCK(6319, 6320, 6321, 6322),
    WILDERNESS(6323, 6324, 6325, 6326),
    WESTERN(6327, 6328, 6329, 6330),
    KOUREND(7933, 7934, 7935, 7936);

    private final int varbitEasy;
    private final int varbitMedium;
    private final int varbitHard;
    private final int varbitElite;

    AchievementDiary(int varbitEasy, int varbitMedium, int varbitHard, int varbitElite) {
        this.varbitEasy = varbitEasy;
        this.varbitMedium = varbitMedium;
        this.varbitHard = varbitHard;
        this.varbitElite = varbitElite;
    }

    public int getEasy(Client client) {
        return client.getVarbitValue(varbitEasy);
    }

    public int getMedium(Client client) {
        return client.getVarbitValue(varbitMedium);
    }

    public int getHard(Client client) {
        return client.getVarbitValue(varbitHard);
    }

    public int getElite(Client client) {
        return client.getVarbitValue(varbitElite);
    }

    public int getTotal(Client client) {
        return getEasy(client) + getMedium(client) + getHard(client) + getElite(client);
    }
}

package net.machpi.runelite.influxdb.activity;

import com.google.common.collect.ComparisonChain;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.machpi.runelite.influxdb.InfluxDbConfig;
import net.machpi.runelite.influxdb.MeasurementCreator;
import net.machpi.runelite.influxdb.write.Measurement;

import javax.inject.Inject;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumMap;
import java.util.Objects;
import java.util.Optional;
import java.util.TreeSet;

@Slf4j
public class ActivityState {

    @Data
    private static class EventWithTime {
        private final GameEvent type;
        private final Instant start;
        private Instant updated;
    }

    @Data
    public static class State {
        private final String skill;
        private final String location;
        private final String locationType;
    }

    private final InfluxDbConfig config;
    private final MeasurementCreator measurer;

    private final EnumMap<GameEvent, EventWithTime> latestEvents = new EnumMap<>(GameEvent.class);
    private final TreeSet<EventWithTime> events;


    @Inject
    public ActivityState(final InfluxDbConfig config, final MeasurementCreator measurer) {
        this.config = config;
        this.measurer = measurer;
        this.events = new TreeSet<>((a, b) -> ComparisonChain.start()
                .compare(b.getType().getPriority(), a.getType().getPriority())
                .compare(b.getUpdated(), a.getUpdated())
                .result()
        );
    }

    /**
     * Reset state.
     */
    public void reset() {
        events.clear();
        latestEvents.clear();
    }

    /**
     * Trigger new state update.
     *
     * @param eventType event type
     */
    public void triggerEvent(final GameEvent eventType) {
        if (!config.writeActivity()) return;

        EventWithTime event = latestEvents.get(eventType);
        if (event == null) {
            event = new EventWithTime(eventType, Instant.now());
            latestEvents.put(eventType, event);
        } else {
            events.remove(event);
        }
        event.setUpdated(Instant.now());
        events.add(event);

        if (event.getType().isShouldClear()) {
            events.removeIf(e -> {
                boolean remove = e.getType() != eventType && e.getType().isShouldClear();
                if (remove) latestEvents.remove(e.getType());
                return remove;
            });
        }
    }

    public State getState() {
        if (events.isEmpty() || !config.writeActivity()) return null;

        final Duration activityTimeout = Duration.ofMinutes(config.activityTimeout());
        final Instant now = Instant.now();
        final EventWithTime eventWithTime = events.first();

        // if we've been in the menu for more than the timeout, stop sending updates.
        if (Objects.equals(GameEvent.IN_MENU.getLocation(), eventWithTime.getType().getLocation()) && now.isAfter(eventWithTime.getStart().plus(activityTimeout))) {
            return null;
        }

        String location = null;
        String skill = null;
        String locationType = null;

        for (EventWithTime e : events) {
            // get the highest priority skill from our event list
            if (skill == null && e.getType().getSkill() != null) {
                skill = e.getType().getSkill().name();
            }

            // get the highest priority or latest area from our event list
            if (location == null) {
                location = e.getType().getLocation();
            }

            if (locationType == null && e.getType().getLocationType() != null) {
                locationType = e.getType().getLocationType().name();
            }

            if (skill != null && location != null && locationType != null) {
                break;
            }
        }

        return new State(skill, location, locationType);
    }

    /**
     * Check for current state timeout and act upon it.
     */
    public void checkForTimeout() {
        if (events.isEmpty() || !config.writeActivity()) {
            return;
        }

        final Duration activityTimeout = Duration.ofMinutes(config.activityTimeout());
        final Instant now = Instant.now();

        events.removeIf(event -> {
            boolean remove = event.getType().isShouldTimeout() && now.isAfter(event.getUpdated().plus(activityTimeout));
            if (remove) latestEvents.remove(event.getType());
            return remove;
        });
    }

    public Optional<Measurement> measure() {
        if (!config.writeActivity()) return Optional.empty();

        State state = getState();
        if (state == null)
            return Optional.empty();

        return measurer.createActivityMeasurement(state);
    }
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2018, PandahRS <https://github.com/PandahRS>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.machpi.runelite.influxdb.activity;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.Varbits;

import javax.annotation.Nullable;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;


enum LocationType {
    BOSSES,
    CITIES,
    DUNGEONS,
    MINIGAMES,
    RAIDS,
    POI,
    ;
}

@AllArgsConstructor
@Getter
public enum GameEvent {
    IN_GAME("In Game", -3),
    IN_MENU("In Menu", -3),
    PLAYING_DEADMAN("Playing Deadman Mode", -3),
    PLAYING_PVP("Playing in a PVP world", -3),
    WILDERNESS("Wilderness", -2),

    TRAINING_ATTACK(Skill.ATTACK),
    TRAINING_DEFENCE(Skill.DEFENCE),
    TRAINING_STRENGTH(Skill.STRENGTH),
    TRAINING_HITPOINTS(Skill.HITPOINTS, -1),
    TRAINING_SLAYER(Skill.SLAYER, 1),
    TRAINING_RANGED(Skill.RANGED),
    TRAINING_MAGIC(Skill.MAGIC),
    TRAINING_PRAYER(Skill.PRAYER),
    TRAINING_COOKING(Skill.COOKING),
    TRAINING_WOODCUTTING(Skill.WOODCUTTING),
    TRAINING_FLETCHING(Skill.FLETCHING),
    TRAINING_FISHING(Skill.FISHING, 1),
    TRAINING_FIREMAKING(Skill.FIREMAKING),
    TRAINING_CRAFTING(Skill.CRAFTING),
    TRAINING_SMITHING(Skill.SMITHING),
    TRAINING_MINING(Skill.MINING),
    TRAINING_HERBLORE(Skill.HERBLORE),
    TRAINING_AGILITY(Skill.AGILITY),
    TRAINING_THIEVING(Skill.THIEVING),
    TRAINING_FARMING(Skill.FARMING),
    TRAINING_RUNECRAFT(Skill.RUNECRAFT),
    TRAINING_HUNTER(Skill.HUNTER),
    TRAINING_CONSTRUCTION(Skill.CONSTRUCTION),

    // Bosses
    BOSS_ABYSSAL_SIRE("Abyssal Sire", LocationType.BOSSES, 11851, 11850, 12363, 12362),
    BOSS_CERBERUS("Cerberus", LocationType.BOSSES, 4883, 5140, 5395),
    BOSS_COMMANDER_ZILYANA("Commander Zilyana", LocationType.BOSSES, 11602),
    BOSS_DKS("Dagannoth Kings", LocationType.BOSSES, 11588, 11589),
    BOSS_GENERAL_GRAARDOR("General Graardor", LocationType.BOSSES, 11347),
    BOSS_GIANT_MOLE("Giant Mole", LocationType.BOSSES, 6993, 6992),
    BOSS_GROTESQUE_GUARDIANS("Grotesque Guardians", LocationType.BOSSES, 6727),
    BOSS_HYDRA("Alchemical Hydra", LocationType.BOSSES, 5536),
    BOSS_KING_BLACK_DRAGON("King Black Dragon", LocationType.BOSSES), // no region id.. custom logic for kbd/nmz
    BOSS_KQ("Kalphite Queen", LocationType.BOSSES, 13972),
    BOSS_KRAKEN("Kraken", LocationType.BOSSES, 9116),
    BOSS_KREEARRA("Kree'arra", LocationType.BOSSES, 11346),
    BOSS_KRIL_TSUTSAROTH("K'ril Tsutsaroth", LocationType.BOSSES, 11603),
    BOSS_SKOTIZO("Skotizo", LocationType.BOSSES, 6810),
    BOSS_SMOKE_DEVIL("Thermonuclear smoke devil", LocationType.BOSSES, 9363, 9619),
    BOSS_VORKATH("Vorkath", LocationType.BOSSES, 9023),
    BOSS_WINTERTODT("Wintertodt", LocationType.BOSSES, 6462),
    BOSS_ZALCANO("Zalcano", LocationType.BOSSES, 13250),
    BOSS_ZULRAH("Zulrah", LocationType.BOSSES, 9007, 9008),
    BOSS_NIGHTMARE("Nightmare of Ashihama", LocationType.BOSSES, 15515),

    // Cities
    CITY_AL_KHARID("Al Kharid", LocationType.CITIES, 13105, 13106),
    CITY_APE_ATOLL("Ape Atoll", LocationType.CITIES, 10795, 11051, 10974, 11050),
    CITY_ARCEUUS_HOUSE("Arceuus", LocationType.CITIES, 6459, 6715, 6458, 6714),
    CITY_ARDOUGNE("Ardougne", LocationType.CITIES, 10548, 10547, 10292, 10291, 10036, 10035, 9780, 9779),
    CITY_BARBARIAN_VILLAGE("Barbarian Village", LocationType.CITIES, 12341),
    CITY_BANDIT_CAMP("Bandit Camp", LocationType.CITIES, 12591),
    CITY_BEDABIN_CAMP("Bedabin Camp", LocationType.CITIES, 12590),
    CITY_BRIMHAVEN("Brimhaven", LocationType.CITIES, 11057, 11058),
    CITY_BURGH_DE_ROTT("Burgh de Rott", LocationType.CITIES, 13874, 13873, 14130, 14129),
    CITY_BURTHORPE("Burthorpe", LocationType.CITIES, 11319, 11575),
    CITY_CANIFIS("Canifis", LocationType.CITIES, 13878),
    CITY_CATHERBY("Catherby", LocationType.CITIES, 11317, 11318, 11061),
    CITY_CORSAIR_CAVE("Corsair Cove", LocationType.CITIES, 10028, 10284),
    CITY_DARKMEYER("Darkmeyer", LocationType.CITIES, 14388),
    CITY_DORGESH_KAAN("Dorgesh-Kaan", LocationType.CITIES, 10835, 10834),
    CITY_DRAYNOR("Draynor", LocationType.CITIES, 12338),
    CITY_EDGEVILLE("Edgeville", LocationType.CITIES, 12342),
    CITY_ENTRANA("Entrana", LocationType.CITIES, 11060, 11316),
    CITY_FALADOR("Falador", LocationType.CITIES, 11828, 11572, 11571, 11827, 12084),
    CITY_GOBLIN_VILLAGE("Goblin Village", LocationType.CITIES, 11830),
    CITY_GUTANOTH("Gu'Tanoth", LocationType.CITIES, 10031),
    CITY_GWENITH("Gwenith", LocationType.CITIES, 8501, 8757, 9013),
    CITY_HOSIDIUS_HOUSE("Hosidius", LocationType.CITIES, 6713, 6712, 6455, 6711, 6710, 6965, 6966, 7222, 7223, 6967),
    CITY_JATISZO("Jatizso", LocationType.CITIES, 9531),
    CITY_JIGGIG("Jiggig", LocationType.CITIES, 9775),
    CITY_KARAMJA("Karamja", LocationType.CITIES, 11569, 11568, 11567, 11566, 11313, 11312, 11311),
    CITY_KELDAGRIM("Keldagrim", LocationType.CITIES, 11423, 11422, 11679, 11678),
    CITY_LLETYA("Lletya", LocationType.CITIES, 9265),
    CITY_LOVAKENGJ_HOUSE("Lovakengj", LocationType.CITIES, 5692, 5948, 5691, 5947, 6203, 6202, 5690, 5946),
    CITY_LUMBRIDGE("Lumbridge", LocationType.CITIES, 12850),
    CITY_LUNAR_ISLE("Lunar Isle", LocationType.CITIES, 8253, 8252, 8509, 8508),
    CITY_MEIYERDITCH("Meiyerditch", LocationType.CITIES, 14132, 14387, 14386, 14385),
    CITY_MISCELLANIA("Miscellania", LocationType.CITIES, 10044, 10300),
    CITY_MOS_LE_HARMLESS("Mos Le'Harmless", LocationType.CITIES, 14638),
    CITY_MORTTON("Mort'ton", LocationType.CITIES, 13875),
    CITY_MOR_UI_REK("Mor UI Rek", LocationType.CITIES, 9808, 9807, 10064, 10063),
    CITY_MOUNT_KARUULM("Mount Karuulm", LocationType.CITIES, 5179, 4923, 5180),
    CITY_MOUNT_QUIDAMORTEM("Mount Quidamortem", LocationType.CITIES, 4919),
    CITY_NARDAH("Nardah", LocationType.CITIES, 13613),
    CITY_NEITIZNOT("Neitiznot", LocationType.CITIES, 9275),
    CITY_PISCATORIS("Piscatoris", LocationType.CITIES, 9273),
    CITY_POLLNIVNEACH("Pollnivneach", LocationType.CITIES, 13358),
    CITY_PORT_KHAZARD("Port Khazard", LocationType.CITIES, 10545),
    CITY_PORT_PHASMATYS("Port Phasmatys", LocationType.CITIES, 14646),
    CITY_PORT_SARIM("Port Sarim", LocationType.CITIES, 12082),
    CITY_PISCARILIUS_HOUSE("Port Piscarilius", LocationType.CITIES, 6971, 7227, 6970, 7226),
    CITY_PRIFDDINAS("Prifddinas", LocationType.CITIES, 12894, 12895, 13150, 13151),
    CITY_RELLEKKA("Rellekka", LocationType.CITIES, 10553),
    CITY_RIMMINGTON("Rimmington", LocationType.CITIES, 11826, 11570),
    CITY_SEERS_VILLAGE("Seers' Village", LocationType.CITIES, 10806),
    CITY_SHAYZIEN_HOUSE("Shayzien", LocationType.CITIES, 5944, 5943, 6200, 6199, 5688),
    CITY_SHILO_VILLAGE("Shilo Village", LocationType.CITIES, 11310),
    CITY_SOPHANEM("Sophanem", LocationType.CITIES, 13099),
    CITY_TAI_BWO_WANNAI("Tai Bwo Wannai", LocationType.CITIES, 11056, 11055),
    CITY_TAVERLEY("Taverley", LocationType.CITIES, 11574, 11573),
    CITY_TREE_GNOME_STRONGHOLD("Tree Gnome Stronghold", LocationType.CITIES, 9782, 9781),
    CITY_TREE_GNOME_VILLAGE("Tree Gnome Village", LocationType.CITIES, 10033),
    CITY_TROLL_STRONGHOLD("Troll Stronghold", LocationType.CITIES, 11321),
    CITY_TYRAS_CAMP("Tyras Camp", LocationType.CITIES, 8753, 8752),
    CITY_UZER("Uzer", LocationType.CITIES, 13872),
    CITY_VARROCK("Varrock", LocationType.CITIES, 12596, 12597, 12598, 12852, 12853, 12854, 13108, 13109, 13110),
    CITY_WITCHHAVEN("Witchaven", LocationType.CITIES, 10803),
    CITY_WOODCUTTING_GUILD("Woodcutting Guild", LocationType.CITIES, 6454, 6198, 6298),
    CITY_YANILLE("Yanille", LocationType.CITIES, 10288, 10032),
    CITY_ZANARIS("Zanaris", LocationType.CITIES, 9285, 9541, 9540, 9797),
    CITY_ZULANDRA("Zul-Andra", LocationType.CITIES, 8751),

    // Dungeons
    DUNGEON_ABANDONED_MINE("Abandoned Mine", LocationType.DUNGEONS, 13718, 11079, 11078, 11077, 10823, 10822, 10821),
    DUNGEON_AH_ZA_RHOON("Ah Za Rhoon", LocationType.DUNGEONS, 11666),
    DUNGEON_ANCIENT_CAVERN("Ancient Cavern", LocationType.DUNGEONS, 6483, 6995),
    DUNGEON_APE_ATOLL("Ape Atoll Dungeon", LocationType.DUNGEONS, 11150, 10894),
    DUNGEON_ARDY_SEWERS("Ardougne Sewers", LocationType.DUNGEONS, 10136),
    DUNGEON_ASGARNIAN_ICE_CAVES("Asgarnian Ice Caves", LocationType.DUNGEONS, 12181),
    DUNGEON_BRIMHAVEN("Brimhaven Dungeon", LocationType.DUNGEONS, 10901, 10900, 10899, 10645, 10644, 10643),
    DUNGEON_BRINE_RAT_CAVERN("Brine Rat Cavern", LocationType.DUNGEONS, 10910),
    DUNGEON_CATACOMBS_OF_KOUREND("Catacombs of Kourend", LocationType.DUNGEONS, 6557, 6556, 6813, 6812),
    DUNGEON_CHASM_OF_FIRE("Chasm of Fire", LocationType.DUNGEONS, 5789),
    DUNGEON_CLOCK_TOWER("Clock Tower Basement", LocationType.DUNGEONS, 10390),
    DUNGEON_CORSAIR_COVE("Corsair Cove Dungeon", LocationType.DUNGEONS, 8076, 8332),
    DUNGEON_CRABCLAW_CAVES("Crabclaw Caves", LocationType.DUNGEONS, 6553, 6809),
    DUNGEON_DIGSITE("Digsite Dungeon", LocationType.DUNGEONS, 13465),
    DUNGEON_DORGESHKAAN("Dorgesh-Kaan South Dungeon", LocationType.DUNGEONS, 10833),
    DUNGEON_DORGESHUUN_MINES("Dorgeshuun Mines", LocationType.DUNGEONS, 12950, 13206),
    DUNGEON_DRAYNOR_SEWERS("Draynor Sewers", LocationType.DUNGEONS, 12439, 12438),
    DUNGEON_DWARVEN_MINES("Dwarven Mines", LocationType.DUNGEONS, 12185, 12184, 12183),
    DUNGEON_EAGLES_PEAK("Eagles' Peak Dungeon", LocationType.DUNGEONS, 8013),
    DUNGEON_EDGEVILLE("Edgeville Dungeon", LocationType.DUNGEONS, 12441, 12442, 12443, 12698),
    DUNGEON_ELEMENTAL_WORKSHOP("Elemental Workshop", LocationType.DUNGEONS, 10906, 7760),
    DUNGEON_ENAKHRAS_TEMPLE("Enakhra's Temple", LocationType.DUNGEONS, 12423),
    DUNGEON_ENTRANA("Entrana Dungeon", LocationType.DUNGEONS, 11416),
    DUNGEON_EVIL_CHICKENS_LAIR("Evil Chicken's Lair", LocationType.DUNGEONS, 9796),
    DUNGEON_EXPERIMENT_CAVE("Experiment Cave", LocationType.DUNGEONS, 14235, 13979),
    DUNGEON_FREMENNIK_SLAYER("Fremennik Slayer Dungeon", LocationType.DUNGEONS, 10908, 11164),
    DUNGEON_GOBLIN_CAVE("Goblin Cave", LocationType.DUNGEONS, 10393),
    DUNGEON_GRAND_TREE_TUNNELS("Grand Tree Tunnels", LocationType.DUNGEONS, 9882),
    DUNGEON_HAM("H.A.M Dungeon", LocationType.DUNGEONS, 12694, 10321),
    DUNGEON_IORWERTH("Iorwerth Dungeon", LocationType.DUNGEONS, 12737, 12738, 12993, 12994),
    DUNGEON_JATIZSO_MINES("Jatizso Mines", LocationType.DUNGEONS, 9631),
    DUNGEON_JIGGIG_BURIAL_TOMB("Jiggig Burial Tomb", LocationType.DUNGEONS, 9875, 9874),
    DUNGEON_JOGRE("Jogre Dungeon", LocationType.DUNGEONS, 11412),
    DUNGEON_KARAMJA_VOLCANO("Karamja Volcano", LocationType.DUNGEONS, 11413, 11414),
    DUNGEON_KARUULM("Karuulm Slayer Dungeon", LocationType.DUNGEONS, 5280, 5279, 5023, 5535, 5022, 4766, 4510, 4511, 4767, 4768, 4512),
    DUNGEON_KHARAZI("Khazari Dungeon", LocationType.DUNGEONS, 11153),
    DUNGEON_LIGHTHOUSE("Lighthouse", LocationType.DUNGEONS, 10140),
    DUNGEON_LIZARDMAN_CAVES("Lizardman Caves", LocationType.DUNGEONS, 5275),
    DUNGEON_LUMBRIDGE_SWAMP_CAVES("Lumbridge Swamp Caves", LocationType.DUNGEONS, 12693, 12949),
    DUNGEON_LUNAR_ISLE_MINE("Lunar Isle Mine", LocationType.DUNGEONS, 9377),
    DUNGEON_MISCELLANIA("Miscellania Dungeon", LocationType.DUNGEONS, 10144, 10400),
    DUNGEON_MOGRE_CAMP("Mogre Camp", LocationType.DUNGEONS, 11924),
    DUNGEON_MOS_LE_HARMLESS_CAVES("Mos Le'Harmless Caves", LocationType.DUNGEONS, 14994, 14995, 15251),
    DUNGEON_MOUSE_HOLE("Mouse Hole", LocationType.DUNGEONS, 9046),
    DUNGEON_OBSERVATORY("Observatory Dungeon", LocationType.DUNGEONS, 9362),
    DUNGEON_OGRE_ENCLAVE("Ogre Enclave", LocationType.DUNGEONS, 10387),
    DUNGEON_QUIDAMORTEM_CAVE("Quidamortem Cave", LocationType.DUNGEONS, 4763),
    DUNGEON_RASHILIYIAS_TOMB("Rashiliyta's Tomb", LocationType.DUNGEONS, 11668),
    DUNGEON_SARADOMINSHRINE("Saradomin Shrine (Paterdomus)", LocationType.DUNGEONS, 13722),
    DUNGEON_SHADE_CATACOMBS("Shade Catacombs", LocationType.DUNGEONS, 13975),
    DUNGEON_SHAYZIEN_CRYPTS("Shayzien Crypts", LocationType.DUNGEONS, 6043),
    DUNGEON_SMOKE("Smoke Dungeon", LocationType.DUNGEONS, 12946, 13202),
    DUNGEON_SOPHANEM("Sophanem Dungeon", LocationType.DUNGEONS, 13200),
    DUNGEON_STRONGHOLD_SECURITY("Stronghold of Security", LocationType.DUNGEONS, 7505, 8017, 8530, 9297),
    DUNGEON_TARNS_LAIR("Tarn's Lair", LocationType.DUNGEONS, 12616, 12615),
    DUNGEON_TAVERLEY("Taverley Dungeon", LocationType.DUNGEONS, 11673, 11672, 11929, 11928, 11417),
    DUNGEON_TEMPLE_OF_IKOV("Temple of Ikov", LocationType.DUNGEONS, 10649, 10905, 10650),
    DUNGEON_TEMPLE_OF_MARIMBO("Temple of Marimbo", LocationType.DUNGEONS, 11151),
    DUNGEON_THE_WARRENS("The Warrens", LocationType.DUNGEONS, 7070, 7326),
    DUNGEON_TOLNA("Dungeon of Tolna", LocationType.DUNGEONS, 13209),
    DUNGEON_TOWER_OF_LIFE("Tower of Life Basement", LocationType.DUNGEONS, 12100),
    DUNGEON_TRAHAEARN_MINE("Trahaearn Mine", LocationType.DUNGEONS, 13249),
    DUNGEON_TUNNEL_OF_CHAOS("Tunnel of Chaos", LocationType.DUNGEONS, 12625),
    DUNGEON_UNDERGROUND_PASS("Underground Pass", LocationType.DUNGEONS, 9369, 9370),
    DUNGEON_VARROCKSEWERS("Varrock Sewers", LocationType.DUNGEONS, 12954, 13210),
    DUNGEON_WATER_RAVINE("Water Ravine", LocationType.DUNGEONS, 13461),
    DUNGEON_WATERBIRTH("Waterbirth Dungeon", LocationType.DUNGEONS, 9886, 10142, 7492, 7748),
    DUNGEON_WATERFALL("Waterfall Dungeon", LocationType.DUNGEONS, 10394),
    DUNGEON_WHITE_WOLF_MOUNTAIN_CAVES("White Wolf Mountain Caves", LocationType.DUNGEONS, 11418, 11419, 11675),
    DUNGEON_WITCHAVEN_SHRINE("Witchhaven Shrine Dungeon", LocationType.DUNGEONS, 10903),
    DUNGEON_YANILLE_AGILITY("Yanille Agility Dungeon", LocationType.DUNGEONS, 10388),
    DUNGEON_MOTHERLODE_MINE("Motherlode Mine", LocationType.DUNGEONS, 14679, 14680, 14681, 14935, 14936, 14937, 15191, 15192, 15193),
    DUNGEON_NIGHTMARE("Nightmare Dungeon", LocationType.DUNGEONS, 14999, 15000, 15001, 15255, 15256, 15257, 15511, 15512, 15513),

    // Minigames
    MG_BARBARIAN_ASSAULT("Barbarian Assault", LocationType.MINIGAMES, 10332),
    MG_BARROWS("Barrows", LocationType.MINIGAMES, 14131, 14231),
    MG_BLAST_FURNACE("Blast Furnace", LocationType.MINIGAMES, 7757),
    MG_BRIMHAVEN_AGILITY_ARENA("Brimhaven Agility Arena", LocationType.MINIGAMES, 11157),
    MG_BURTHORPE_GAMES_ROOM("Burthorpe Games Room", LocationType.MINIGAMES, 8781),
    MG_CASTLE_WARS("Castle Wars", LocationType.MINIGAMES, 9520),
    MG_CLAN_WARS("Clan Wars", LocationType.MINIGAMES, 13135, 13134, 13133, 13131, 13130, 13387, 13386),
    MG_DUEL_ARENA("Duel Arena", LocationType.MINIGAMES, 13362),
    MG_FISHING_TRAWLER("Fishing Trawler", LocationType.MINIGAMES, 7499),
    MG_GAUNTLET("Gauntlet", LocationType.MINIGAMES, 12995),
    MG_INFERNO("The Inferno", LocationType.MINIGAMES, 9043),
    MG_LAST_MAN_STANDING("Last Man Standing", LocationType.MINIGAMES, 13660, 13659, 13658, 13916, 13915, 13914),
    MG_HALLOWED_SEPULCHRE("Hallowed Sepulchre", LocationType.MINIGAMES, 8797, 9051, 9052, 9053, 9054, 9309, 9563, 9565, 9821, 10074, 10075, 10077),
    MG_MAGE_TRAINING_ARENA("Mage Training Arena", LocationType.MINIGAMES, 13462, 13463),
    MG_NIGHTMARE_ZONE("Nightmare Zone", LocationType.MINIGAMES, 9033),
    MG_PEST_CONTROL("Pest Control", LocationType.MINIGAMES, 10536),
    MG_PYRAMID_PLUNDER("Pyramid Plunder", LocationType.MINIGAMES, 7749),
    MG_ROGUES_DEN("Rogues' Den", LocationType.MINIGAMES, 11855, 11854, 12111, 12110),
    MG_SORCERESS_GARDEN("Sorceress's Garden", LocationType.MINIGAMES, 11605),
    MG_TEMPLE_TREKKING("Temple Trekking", LocationType.MINIGAMES, 8014, 8270, 8256, 8782, 9038, 9294, 9550, 9806),
    MG_TITHE_FARM("Tithe Farm", LocationType.MINIGAMES, 6968),
    MG_TROUBLE_BREWING("Trouble Brewing", LocationType.MINIGAMES, 15150),
    MG_TZHAAR_FIGHT_CAVES("Tzhaar Fight Caves", LocationType.MINIGAMES, 9551),
    MG_TZHAAR_FIGHT_PITS("Tzhaar Fight Pits", LocationType.MINIGAMES, 9552),
    MG_VOLCANIC_MINE("Volcanic Mine", LocationType.MINIGAMES, 15263, 15262),

    // Raids
    RAIDS_CHAMBERS_OF_XERIC("Chambers of Xeric", LocationType.RAIDS, true, Varbits.IN_RAID),
    RAIDS_THEATRE_OF_BLOOD("Theatre of Blood", LocationType.RAIDS, true, Varbits.THEATRE_OF_BLOOD),

    POI_FISHING_GUILD("Fishing Guild", LocationType.POI, 10293),
    POI_OTTOS_GROTTO("Otto's Grotto", LocationType.POI, 10038),
    POI_PLAYER_OWNED_HOUSE("Player Owned House", LocationType.POI, 7769),
    ;

    private static final Map<Integer, GameEvent> FROM_REGION;
    private static final List<GameEvent> FROM_VARBITS;
    private static final EnumMap<Skill, GameEvent> FROM_SKILL = new EnumMap<Skill, GameEvent>(Skill.class);

    static {
        ImmutableMap.Builder<Integer, GameEvent> regionMapBuilder = new ImmutableMap.Builder<>();
        ImmutableList.Builder<GameEvent> fromVarbitsBuilder = ImmutableList.builder();
        for (GameEvent gameEvent : GameEvent.values()) {
            if (gameEvent.getVarbit() != null) {
                fromVarbitsBuilder.add(gameEvent);
                continue;
            }

            if (gameEvent.getSkill() != null) {
                FROM_SKILL.put(gameEvent.getSkill(), gameEvent);
                continue;
            }

            if (gameEvent.getRegionIds() == null) {
                continue;
            }


            for (int region : gameEvent.getRegionIds()) {
                regionMapBuilder.put(region, gameEvent);
            }
        }
        FROM_REGION = regionMapBuilder.build();
        FROM_VARBITS = fromVarbitsBuilder.build();
    }

    @Nullable
    private String location;

    @Nullable
    private Skill skill;

    private final int priority;
    private boolean shouldClear;
    private boolean shouldTimeout;

    @Nullable
    private LocationType locationType;

    @Nullable
    private Integer varbit;

    @Nullable
    private int[] regionIds;

    GameEvent(Skill skill) {
        this(skill, 0);
    }

    GameEvent(Skill skill, int priority) {
        this.skill = skill;
        this.priority = priority;
        this.shouldTimeout = true;
    }

    GameEvent(String areaName, LocationType locationType, int... regionIds) {
        this.location = areaName;
        this.priority = -2;
        this.locationType = locationType;
        this.regionIds = regionIds;
        this.shouldClear = true;
    }

    GameEvent(String state, int priority) {
        this.location = state;
        this.priority = priority;
        this.shouldClear = true;
    }

    GameEvent(String areaName, LocationType locationType, boolean usingVarbits, int varbit) {
        this.location = areaName;
        this.priority = -2;
        this.locationType = locationType;
        this.varbit = varbit;
        this.shouldClear = true;
    }

    public static GameEvent fromSkill(final Skill skill) {
        return FROM_SKILL.get(skill);
    }

    public static GameEvent fromRegion(final int regionId) {
        return FROM_REGION.get(regionId);
    }

    public static GameEvent fromVarbit(final Client client) {
        for (GameEvent fromVarbit : FROM_VARBITS) {
            if (client.getVarbitValue(fromVarbit.getVarbit()) != 0) {
                return fromVarbit;
            }
        }

        return null;
    }
}

package net.machpi.runelite.influxdb;

import net.runelite.api.Client;

import java.util.Locale;

// Derived starting from https://github.com/RuneStar/cs2-scripts/blob/9a49f4b47b96c15a05f333d61cdfd469f7a197df/scripts/%5Bproc%2Csummary_sidepanel_draw%5D.cs2
public enum CombatAchievement {
    EASY(12885, 3981),
    MEDIUM(12886, 3982),
    HARD(12887, 3983),
    ELITE(12888, 3984),
    MASTER(12889, 3985),
    GRANDMASTER(12890, 3986);
    private final int varbitId;
    private final int enumId;

    CombatAchievement(int varbitId, int enumId) {
        this.varbitId = varbitId;
        this.enumId = enumId;
    }

    public int getCompleted(Client client) {
        return client.getVarbitValue(varbitId);
    }

    public int getTotal(Client client) {
        return client.getEnum(enumId).size();
    }
}

package net.machpi.runelite.influxdb;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(InfluxDbConfig.GROUP)
public interface InfluxDbConfig extends Config {
    String GROUP = "influxdb";
    String WRITE_INTERVAL = "writeInterval";

    @ConfigItem(
            keyName = "serverUrl",
            name = "Server URL",
            description = "URL of the influx DB api to write to",
            position = 0
    )
    String getServerUrl();

    @ConfigItem(
            keyName = "serverDatabase",
            name = "Database",
            description = "Database to write to",
            position = 1
    )
    String getDatabase();

    @ConfigItem(
            keyName = "serverUsername",
            name = "Server Username",
            description = "Username to use for authentication",
            position = 2
    )
    default String getServerUsername() {
        return "";
    }

    @ConfigItem(
            keyName = "serverPassword",
            name = "Server Password",
            description = "Password to use for authentication",
            position = 3,
            secret = true
    )
    default String getServerPassword() {
        return "";
    }

    @ConfigItem(
            keyName = "serverRetentionPolicy",
            name = "Server Retention Policy",
            description = "Retention policy to use for storing data",
            position = 4
    )
    default String getServerRetentionPolicy() {
        return "autogen";
    }

    @ConfigItem(
            keyName = "writeXp",
            name = "Submit Experience",
            description = "Submit experience amount",
            position = 5
    )
    default boolean writeXp() {
        return true;
    }

    @ConfigItem(
            keyName = "writeBankValue",
            name = "Submit Bank Value",
            description = "Submit bank and seed vault items",
            position = 6
    )
    default boolean writeBankValue() {
        return true;
    }

    @ConfigItem(
            keyName = "writeSelfLoc",
            name = "Submit Player Location",
            description = "Submit player location",
            position = 7
    )
    default boolean writeSelfLoc() {
        return false;
    }

    @ConfigItem(
            keyName = "writeSelfMeta",
            name = "Submit Player Metadata",
            description = "Submit player combat level, quest points, and other minor stats",
            position = 8
    )
    default boolean writeSelfMeta() {
        return true;
    }

    @ConfigItem(
            keyName = "writeKillCount",
            name = "Submit Kill Count",
            description = "Submits boss kill counts (requires Chat Commands plugin)",
            position = 9
    )
    default boolean writeKillCount() {
        return true;
    }

    @ConfigItem(
            keyName = "writeActivity",
            name = "Submit Activity",
            description = "Submit player activity such as location names, skill training, minigame, raid, or boss",
            position = 10
    )
    default boolean writeActivity() {
        return true;
    }

    @ConfigItem(
            keyName = "writeLoot",
            name = "Submit Loot",
            description = "Submit loot events provided by the Loot Tracker plugin",
            position = 11
    )
    default boolean writeLoot() {
        return false;
    }

    @ConfigItem(
            keyName = "writeSkillingItems",
            name = "Submit Skilling Items",
            description = "Submit skilling xp and item pairs",
            position = 12
    )
    default boolean writeSkillingItems() {
        return false;
    }

    @ConfigItem(
            keyName = WRITE_INTERVAL,
            name = "Recording interval",
            description = "Minimum interval between measurements",
            position = 13
    )
    @Units(Units.SECONDS)
    @Range(min = 5, max = 5 * 60)
    default int writeIntervalSeconds() {
        return 15;
    }

    @ConfigItem(
            keyName = "activityTimeout",
            name = "Activity timeout",
            description = "Configures after how long of not updating activity will be reset (in minutes)",
            position = 14
    )
    @Units(Units.MINUTES)
    default int activityTimeout() {
        return 5;
    }
}

package net.machpi.runelite.influxdb;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.machpi.runelite.influxdb.activity.ActivityState;
import net.machpi.runelite.influxdb.activity.GameEvent;
import net.machpi.runelite.influxdb.write.InfluxWriter;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.task.Schedule;
import net.runelite.client.util.ExecutorServiceExceptionLogger;

import javax.inject.Inject;
import java.time.temporal.ChronoUnit;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Objects;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

@PluginDescriptor(
        name = "InfluxDB",
        description = "Saves statistics to InfluxDB",
        tags = {"experience", "levels", "stats", "activity", "tracker"}
)
@Slf4j
public class InfluxDbPlugin extends Plugin {
    private ScheduledFuture<?> flushTask;

    @Provides
    InfluxDbConfig getConfig(ConfigManager configManager) {
        return configManager.getConfig(InfluxDbConfig.class);
    }

    @Inject
    private ConfigManager configManager;

    @Inject
    private InfluxWriter writer;

    @Inject
    private InfluxDbConfig config;

    @Inject
    private Client client;

    @Inject
    private MeasurementCreator measurer;

    @Inject
    private ActivityState activityState;

    @Inject
    private SkillingItemTracker skillingItemTracker;



    /**
     * Don't use a shared executor because we don't want to block any game threads.
     */
    private final ScheduledExecutorService executor = new ExecutorServiceExceptionLogger(Executors.newSingleThreadScheduledExecutor());
    private final EnumMap<Skill, Integer> previousStatXp = new EnumMap<>(Skill.class);
    private GameState prevGameState;
    private boolean varPlayerChanged;

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        if (measurer.isInLastManStanding())
            return;
        if (statChanged.getXp() == 0 || client.getGameState() != GameState.LOGGED_IN)
            return;
        final Integer previous = previousStatXp.put(statChanged.getSkill(), statChanged.getXp());
        if (previous == null || previous == statChanged.getXp())
            return;
        previousStatXp.put(statChanged.getSkill(), statChanged.getXp());

        if (config.writeSkillingItems()) {
            skillingItemTracker.onXpGained(statChanged.getSkill(), statChanged.getXp() - previous);
        }

        if (config.writeXp()) {
            measurer.createXpMeasurement(statChanged.getSkill()).ifPresent(writer::submit);
            measurer.createOverallXpMeasurement().ifPresent(writer::submit);
        }

        if (config.writeActivity()) {
            final GameEvent gameEvent = GameEvent.fromSkill(statChanged.getSkill());
            if (gameEvent != null) {
                activityState.triggerEvent(gameEvent);
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        GameState prev = prevGameState;
        prevGameState = event.getGameState();

        switch (event.getGameState()) {
            case LOGIN_SCREEN:
                checkForGameStateUpdate();
                break;
            case LOGGING_IN:
                previousStatXp.clear();
                break;
            case LOGGED_IN:
                if (prev == GameState.LOGGING_IN) {
                    checkForGameStateUpdate();
                }
                break;
        }

        checkForAreaUpdate();
    }

    private String lastMeasuredProfile;

    private void maybeMeasureInitialState() {
        String profile = configManager.getRSProfileKey();
        if (profile == null || Objects.equals(profile, lastMeasuredProfile)) {
            return;
        }
        lastMeasuredProfile = profile;
        if (config.writeXp() && !measurer.isInLastManStanding()) {
            for (Skill s : Skill.values()) {
                measurer.createXpMeasurement(s).ifPresent(writer::submit);
            }
            measurer.createOverallXpMeasurement().ifPresent(writer::submit);
        }
        if (config.writeKillCount()) {
            String prefix = MeasurementCreator.KILL_COUNT_CFG_GROUP + "." + profile + ".";
            for (String groupAndKey : configManager.getConfigurationKeys(prefix)) {
                String boss = groupAndKey.substring(prefix.length());
                measurer.createKillCountMeasurement(boss).ifPresent(writer::submit);
            }
        }
        if (config.writeSelfMeta()) {
            measurer.createAchievementMeasurements(writer::submit);
        }
        checkForGameStateUpdate();
        checkForAreaUpdate();
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        ItemContainer container = event.getItemContainer();
        if (container == null)
            return;
        InventoryID2 id = null;
        for (InventoryID2 val : InventoryID2.values()) {
            if (val.getId() == event.getContainerId()) {
                id = val;
                break;
            }
        }
        if (id == InventoryID2.INVENTORY && config.writeSkillingItems()) {
            skillingItemTracker.onInventoryChanges(container);
        }
        if (config.writeBankValue()) {
            if (id != InventoryID2.BANK && id != InventoryID2.SEED_VAULT && id != InventoryID2.COLLECTION_LOG)
                return;
            if (writer.isBlocked(measurer.createItemSeries(id, MeasurementCreator.InvValueType.HA)))
                return;
            Item[] items = container.getItems();
            measurer.createItemMeasurements(id, items).forEach(writer::submit);
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        maybeMeasureInitialState();
        skillingItemTracker.flushIfNeeded();
        if (config.writeSelfLoc())
            writer.submit(measurer.createSelfLocMeasurement());
        if (config.writeSelfMeta()) {
            writer.submit(measurer.createSelfMeasurement());
        }
        if (varPlayerChanged) {
            if (config.writeSelfMeta()) {
                measurer.createAchievementMeasurements(writer::submit);
            }
            varPlayerChanged = false;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged changed) {
        if (InfluxDbConfig.GROUP.equals(changed.getGroup())) {
            failureBackoff = 0;
            if (InfluxDbConfig.WRITE_INTERVAL.equals(changed.getKey())) {
                rescheduleFlush();
            }
        }
        observeKillCountConfig(changed.getGroup(), changed.getKey());
    }

    private void observeKillCountConfig(String group, String key) {
        // Piggyback on the chat commands plugin to record kill count to avoid
        // duplicating the complex logic to keep up to date on kill counts
        if (!config.writeKillCount())
            return;
        if (!group.equals(MeasurementCreator.KILL_COUNT_CFG_GROUP)
                && !group.equals(MeasurementCreator.PERSONAL_BEST_CFG_GROUP))
            return;
        measurer.createKillCountMeasurement(key).ifPresent(writer::submit);
    }

    private int failures = 0;
    private int failureBackoff = 0;

    public void flush() {
        if (failureBackoff > 0) {
            failureBackoff--;
            return;
        }
        try {
            writer.flush();
            failures = 0;
        } catch (RuntimeException ex) {
            failures++;
            log.error("Failed to write to influxDB " + failures + " times", ex);
            failureBackoff = Math.min(32, failures * failures);
        }
    }

    private synchronized void rescheduleFlush() {
        unscheduleFlush();
        this.flushTask = executor.scheduleWithFixedDelay(this::flush, config.writeIntervalSeconds(), config.writeIntervalSeconds(), TimeUnit.SECONDS);
    }

    private synchronized void unscheduleFlush() {
        if (flushTask != null) {
            flushTask.cancel(false);
            flushTask = null;
        }
    }

    @Subscribe
    public void onLootReceived(LootReceived event) {
        if (config.writeLoot()) {
            measurer.createLootMeasurement(event).ifPresent(writer::submit);
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        varPlayerChanged = true;
        final GameEvent gameEvent = GameEvent.fromVarbit(client);
        if (gameEvent != null) {
            activityState.triggerEvent(gameEvent);
        }
    }

    private void checkForAreaUpdate() {
        if (client.getLocalPlayer() == null) {
            return;
        }

        Player localPlayer = client.getLocalPlayer();
        final int regionId = WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation()).getRegionID();
        if (regionId == 0) {
            return;
        }

        final EnumSet<WorldType> worldType = client.getWorldType();
        GameEvent gameEvent = GameEvent.fromRegion(regionId);

        Widget wildyWidget = client.getWidget(ComponentID.PVP_WILDERNESS_LEVEL);
        if (GameEvent.MG_NIGHTMARE_ZONE == gameEvent && localPlayer.getWorldLocation().getPlane() == 0) {
            // NMZ uses the same region ID as KBD. KBD is always on plane 0 and NMZ is always above plane 0
            gameEvent = GameEvent.BOSS_KING_BLACK_DRAGON;
        } else if (wildyWidget != null && !wildyWidget.isHidden() && !"".equals(wildyWidget.getText())) {
            gameEvent = GameEvent.WILDERNESS;
        } else if (worldType.contains(WorldType.DEADMAN)) {
            gameEvent = GameEvent.PLAYING_DEADMAN;
        } else if (WorldType.isPvpWorld(worldType)) {
            gameEvent = GameEvent.PLAYING_PVP;
        } else if (gameEvent == null) {
            gameEvent = GameEvent.IN_GAME;
        }

        activityState.triggerEvent(gameEvent);
    }

    private void checkForGameStateUpdate() {
        // Game state update does also full reset of state
        activityState.reset();
        activityState.triggerEvent(client.getGameState() == GameState.LOGGED_IN
                ? GameEvent.IN_GAME
                : GameEvent.IN_MENU);
    }

    /**
     * send an activity heartbeat once every 50 seconds.
     */
    @Schedule(period = 50, unit = ChronoUnit.SECONDS)
    public void updateActivity() {
        activityState.checkForTimeout();
        activityState.measure().ifPresent(writer::submit);
    }

    @Override
    protected void startUp() {
        rescheduleFlush();
    }

    @Override
    protected void shutDown() {
        updateActivity(); // get the final activity before shutting down
        flush();
        unscheduleFlush();
    }
}

package net.machpi.runelite.influxdb;

public enum InventoryID2 {
    /**
     * Reward from fishing trawler
     */
    FISHING_TRAWLER_REWARD(0),
    /**
     * The trade inventory.
     */
    TRADE(90),
    /**
     * The other trade inventory.
     */
    TRADEOTHER(90 | 0x8000),
    /**
     * Standard player inventory.
     */
    INVENTORY(93),
    /**
     * Equipment inventory.
     */
    EQUIPMENT(94),
    /**
     * Bank inventory.
     */
    BANK(95),
    /**
     * A puzzle box inventory.
     */
    PUZZLE_BOX(140),
    /**
     * Barrows reward chest inventory.
     */
    BARROWS_REWARD(141),
    /**
     * Monkey madness puzzle box inventory.
     */
    MONKEY_MADNESS_PUZZLE_BOX(221),
    /**
     * Drift net fishing reward
     */
    DRIFT_NET_FISHING_REWARD(307),
    /**
     * Kingdom Of Miscellania reward inventory.
     */
    KINGDOM_OF_MISCELLANIA(390),
    /**
     * Chambers of Xeric chest inventory.
     */
    CHAMBERS_OF_XERIC_CHEST(581),
    /**
     * Theater of Blood reward chest inventory (Raids 2)
     */
    THEATRE_OF_BLOOD_CHEST(612),
    /**
     * Inventory representing contents of the collection log
     */
    COLLECTION_LOG(620),
    /**
     * Seed vault located inside the Farming Guild
     */
    SEED_VAULT(626),
    ;

    private final int id;

    InventoryID2(int id) {
        this.id = id;
    }

    /**
     * Gets the raw inventory type ID.
     *
     * @return inventory type
     */
    public int getId() {
        return id;
    }
}

package net.machpi.runelite.influxdb;

import com.google.common.base.MoreObjects;
import com.google.common.base.Strings;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multiset;
import com.google.inject.Inject;
import net.machpi.runelite.influxdb.activity.ActivityState;
import net.machpi.runelite.influxdb.activity.GameEvent;
import net.machpi.runelite.influxdb.write.Measurement;
import net.machpi.runelite.influxdb.write.Series;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Experience;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.WorldType;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.inject.Singleton;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

@Singleton
public class MeasurementCreator {
    public static final String SERIES_INVENTORY = "rs_inventory";
    public static final String SERIES_SKILL = "rs_skill";
    public static final String SERIES_SELF = "rs_self";
    public static final String SERIES_ACHIEVEMENTS = "rs_achievements";
    public static final String SERIES_KILL_COUNT = "rs_killcount";
    public static final String SERIES_SELF_LOC = "rs_self_loc";
    public static final String SERIES_ACTIVITY = "rs_activity";
    public static final String SERIES_LOOT = "rs_loot";
    public static final String SERIES_SKILLING_ITEMS = "rs_skilling_items";
    public static final String SELF_KEY_X = "locX";
    public static final String SELF_KEY_Y = "locY";
    public static final Set<String> SELF_POS_KEYS = ImmutableSet.of(SELF_KEY_X, SELF_KEY_Y);

    private final Client client;
    private final ItemManager itemManager;
    private final ConfigManager configManager;

    @Inject
    public MeasurementCreator(Client client, ItemManager itemManager, ConfigManager configManager) {
        this.client = client;
        this.itemManager = itemManager;
        this.configManager = configManager;
    }

    public boolean isInLastManStanding() {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null) {
            return false;
        }
        final int regionId = WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation()).getRegionID();
        return GameEvent.MG_LAST_MAN_STANDING.equals(GameEvent.fromRegion(regionId));
    }

    private Series.SeriesBuilder createSeries() {
        Series.SeriesBuilder builder = Series.builder();
        builder.tag("account", Long.toString(client.getAccountHash()));
        Player player = client.getLocalPlayer();
        String playerName = player != null ? player.getName() : null;
        if (!Strings.isNullOrEmpty(playerName)) {
            builder.tag("player", playerName);
        }
        String userName = client.getUsername();
        if (!Strings.isNullOrEmpty(userName)) {
            builder.tag("user", userName);
        }
        builder.tags(WorldTags.tagsForWorld(client.getWorldType()));
        builder.tag("profile", configManager.getRSProfileKey());
        builder.tag("worldType", RuneScapeProfileType.getCurrent(client).name());
        return builder;
    }

    public Series createXpSeries(String skill) {
        return createSeries().measurement(SERIES_SKILL).tag("skill", skill).build();
    }

    public Optional<Measurement> createOverallXpMeasurement() {
        long xp = client.getOverallExperience();
        if (xp == 0) {
            return Optional.empty();
        }
        int virtualLevel = Arrays.stream(Skill.values())
                .mapToInt(x -> Experience.getLevelForXp(client.getSkillExperience(x)))
                .sum();
        int realLevel = client.getTotalLevel();
        return Optional.of(Measurement.builder()
                .series(createXpSeries("OVERALL"))
                .numericValue("xp", xp)
                .numericValue("realLevel", realLevel)
                .numericValue("virtualLevel", virtualLevel)
                .build());
    }

    public Optional<Measurement> createXpMeasurement(Skill skill) {
        long xp = client.getSkillExperience(skill);
        if (xp == 0) {
            return Optional.empty();
        }
        int virtualLevel = Experience.getLevelForXp((int) xp);
        int realLevel = client.getRealSkillLevel(skill);
        return Optional.of(Measurement.builder()
                .series(createXpSeries(skill.name()))
                .numericValue("xp", xp)
                .numericValue("realLevel", realLevel)
                .numericValue("virtualLevel", virtualLevel)
                .build());
    }

    public Series createItemSeries(InventoryID2 inventory, InvValueType type) {
        return createSeries().measurement(SERIES_INVENTORY)
                .tag("inventory", inventory.name())
                .tag("type", type.name())
                .build();
    }

    private static String itemToKey(ItemComposition composition) {
        return composition.getName() + "@" + composition.getId();
    }

    private static void addToMap(Map<String, Long> map, String key, long value) {
        map.compute(key, (_key, oldValue) -> (oldValue != null ? oldValue : 0) + value);
    }

    public Stream<Measurement> createItemMeasurements(InventoryID2 inventoryID, Item[] items) {
        Map<String, Long> gePrice = new HashMap<>(items.length / 2);
        Map<String, Long> haPrice = new HashMap<>(items.length / 2);
        Map<String, Long> count = new HashMap<>(items.length / 2);

        long totalGe = 0, totalAlch = 0;
        long otherGe = 0, otherAlch = 0;
        for (Item item : items) {
            long ge, alch;
            if (item.getId() < 0 || item.getQuantity() <= 0 || item.getId() == ItemID.BANK_FILLER)
                continue;
            int canonId = itemManager.canonicalize(item.getId());
            ItemComposition data = itemManager.getItemComposition(canonId);
            switch (canonId) {
                case ItemID.COINS_995:
                    ge = item.getQuantity();
                    alch = item.getQuantity();
                    break;
                case ItemID.PLATINUM_TOKEN:
                    ge = item.getQuantity() * 1000L;
                    alch = item.getQuantity() * 1000L;
                    break;
                default:
                    final long storePrice = data.getPrice();
                    final long alchPrice = (long) (storePrice * Constants.HIGH_ALCHEMY_MULTIPLIER);
                    alch = alchPrice * item.getQuantity();
                    ge = (long) itemManager.getItemPrice(canonId) * item.getQuantity();
                    break;
            }
            totalGe += ge;
            totalAlch += alch;
            boolean highValue = ge > THRESHOLD || alch > THRESHOLD;
            if (highValue) {
                String key = itemToKey(data);
                addToMap(gePrice, key, ge);
                addToMap(haPrice, key, alch);
                addToMap(count, key, item.getQuantity());
            } else {
                otherGe += ge;
                otherAlch += alch;
            }
        }


        return Stream.of(Measurement.builder().series(createItemSeries(inventoryID, InvValueType.GE))
                        .numericValues(gePrice)
                        .numericValue("total", totalGe)
                        .numericValue("other", otherGe)
                        .build(),
                Measurement.builder().series(createItemSeries(inventoryID, InvValueType.HA))
                        .numericValues(haPrice)
                        .numericValue("total", totalAlch)
                        .numericValue("other", otherAlch)
                        .build(),
                Measurement.builder().series(createItemSeries(inventoryID, InvValueType.COUNT))
                        .numericValues(count)
                        .build());
    }

    public Series createSelfLocSeries() {
        return createSeries().measurement(SERIES_SELF_LOC).build();
    }

    public Measurement createSelfLocMeasurement() {
        Player local = client.getLocalPlayer();
        WorldPoint location = WorldPoint.fromLocalInstance(client, local.getLocalLocation());
        return Measurement.builder()
                .series(createSelfLocSeries())
                .numericValue(SELF_KEY_X, location.getX())
                .numericValue(SELF_KEY_Y, location.getY())
                .numericValue("plane", location.getPlane())
                .numericValue("instance", client.isInInstancedRegion() ? 1 : 0)
                .build();
    }

    public Series createSelfSeries() {
        return createSeries().measurement(SERIES_SELF).build();
    }

    private static final int VARBIT_LEAGUE_TASKS = 10046;
    private static final int VARP_LEAGUE_POINTS = 2614;
    private static final int VARP_COLLECTION_LOG_ACHIEVED = 2943;
    private static final int VARP_COLLECTION_LOG_TOTAL = 2944;

    public Measurement createSelfMeasurement() {
        Player local = client.getLocalPlayer();
        Measurement.MeasurementBuilder builder = Measurement.builder()
                .series(createSelfSeries())
                .numericValue("combat", Experience.getCombatLevelPrecise(
                        client.getRealSkillLevel(Skill.ATTACK),
                        client.getRealSkillLevel(Skill.STRENGTH),
                        client.getRealSkillLevel(Skill.DEFENCE),
                        client.getRealSkillLevel(Skill.HITPOINTS),
                        client.getRealSkillLevel(Skill.MAGIC),
                        client.getRealSkillLevel(Skill.RANGED),
                        client.getRealSkillLevel(Skill.PRAYER)
                ))
                .numericValue("questPoints", client.getVarpValue(VarPlayer.QUEST_POINTS))
                .numericValue("skulled", local.getSkullIcon() != -1 ? 1 : 0)
                .stringValue("name", MoreObjects.firstNonNull(local.getName(), "none"))
                .stringValue("overhead", local.getOverheadIcon() != null ? local.getOverheadIcon().name() : "NONE");
        if (client.getWorldType().contains(WorldType.SEASONAL) && WorldTags.League.findCurrentLeague() != null) {
            int tasksComplete = client.getVarbitValue(VARBIT_LEAGUE_TASKS);
            int leaguePoints = client.getVarpValue(VARP_LEAGUE_POINTS);
            builder.numericValue("leagueTasksComplete", tasksComplete)
                    .numericValue("leaguePoints", leaguePoints);
        }
        loadProfileConfig("slayer", "initialAmount", Integer::parseInt)
                .ifPresent(amount -> builder.numericValue("slayerTaskAmount", amount));
        loadProfileConfig("slayer", "amount", Integer::parseInt)
                .ifPresent(amount -> builder.numericValue("slayerTaskRemaining", amount));
        loadProfileConfig("slayer", "taskName", MeasurementCreator::toTitleCase)
                .ifPresent(taskName -> {
                    String taskLoc = loadProfileConfig("slayer", "taskLocation", MeasurementCreator::toTitleCase)
                            .orElse("Any Location");
                    builder.stringValue("slayerTaskName", taskName)
                            .stringValue("slayerTaskLoc", taskLoc);
                });
        loadProfileConfig("slayer", "points", Integer::parseInt)
                .ifPresent(amount -> builder.numericValue("slayerPoints", amount));
        loadProfileConfig("slayer", "streak", Integer::parseInt)
                .ifPresent(streak -> builder.numericValue("slayerTaskStreak", streak));
        int collectionLogAchieved = client.getVarpValue(VARP_COLLECTION_LOG_ACHIEVED);

        // Don't record if these are zero -- the varbits may not be initialized
        if (collectionLogAchieved > 0) {
            builder.numericValue("collectionLogAchieved", collectionLogAchieved);
        }
        int achievementDiaryAchieved = Arrays.stream(AchievementDiary.values())
                .mapToInt(d -> d.getTotal(client))
                .sum();
        if (achievementDiaryAchieved > 0) {
            builder.numericValue("achievementDiaryAchieved", achievementDiaryAchieved);
        }
        int combatAchievementsAchieved = Arrays.stream(CombatAchievement.values())
                .mapToInt(d -> d.getCompleted(client))
                .sum();
        if (combatAchievementsAchieved > 0) {
            builder.numericValue("combatAchievementsAchieved", combatAchievementsAchieved);
        }
        return builder.build();
    }

    public Series createAchievementSeries(String achievementGroup, String achievementTier) {
        return createSeries()
                .measurement(SERIES_ACHIEVEMENTS)
                .tag("group", achievementGroup)
                .tag("tier", achievementTier)
                .build();
    }

    private Optional<Measurement> createAchievementMeasurementInternal(String group, String tier, int count, int total) {
        if (count == 0 || total == 0) {
            return Optional.empty();
        }
        Measurement.MeasurementBuilder builder = Measurement.builder()
                .series(createAchievementSeries(group, tier))
                .numericValue("count", count);
        if (total > 0) {
            builder.numericValue("total", total);
        }
        return Optional.of(builder.build());
    }

    public void createAchievementMeasurements(Consumer<Measurement> target) {
        for (AchievementDiary diary : AchievementDiary.values()) {
            createAchievementMeasurementInternal(diary.name(), "EASY", diary.getEasy(client), -1)
                    .ifPresent(target);
            createAchievementMeasurementInternal(diary.name(), "MEDIUM", diary.getMedium(client), -1)
                    .ifPresent(target);
            createAchievementMeasurementInternal(diary.name(), "HARD", diary.getHard(client), -1)
                    .ifPresent(target);
            createAchievementMeasurementInternal(diary.name(), "ELITE", diary.getElite(client), -1)
                    .ifPresent(target);
        }
        for (CombatAchievement tier : CombatAchievement.values()) {
            createAchievementMeasurementInternal("COMBAT", tier.name(), tier.getCompleted(client), tier.getTotal(client))
                    .ifPresent(target);
        }
    }

    private static final Pattern SENTENCE_CASE_PATTERN = Pattern.compile("( |^)([a-z])");

    private static String toTitleCase(String str) {
        Matcher matcher = SENTENCE_CASE_PATTERN.matcher(str);
        if (!matcher.find()) {
            return str;
        }
        StringBuilder dest = new StringBuilder(str.length());
        do {
            matcher.appendReplacement(dest, matcher.group(1) + matcher.group(2).toUpperCase());
        } while (matcher.find());
        matcher.appendTail(dest);
        return dest.toString();
    }

    private <T> Optional<T> loadProfileConfig(String group, String key, Function<String, T> parser) {
        String value = configManager.getRSProfileConfiguration(group, key);
        if (Strings.isNullOrEmpty(value)) {
            return Optional.empty();
        }
        try {
            return Optional.of(parser.apply(value));
        } catch (RuntimeException err) {
            return Optional.empty();
        }
    }

    public Series createKillCountSeries(String boss) {
        return createSeries().measurement(SERIES_KILL_COUNT)
                .tag("boss", boss).build();
    }

    static final String KILL_COUNT_CFG_GROUP = "killcount";
    static final String PERSONAL_BEST_CFG_GROUP = "personalbest";

    public Optional<Measurement> createKillCountMeasurement(String bossMixed) {
        // Piggyback off of chat commands plugin
        String boss = bossMixed.toLowerCase();
        Integer killCount = configManager.getRSProfileConfiguration(KILL_COUNT_CFG_GROUP, boss, int.class);
        if (killCount == null)
            return Optional.empty();
        Double personalBest = configManager.getRSProfileConfiguration(PERSONAL_BEST_CFG_GROUP, boss, double.class);
        Measurement.MeasurementBuilder measurement = Measurement.builder()
                .series(createKillCountSeries(boss))
                .numericValue("kc", killCount);
        if (personalBest != null) {
            measurement.numericValue("pb", personalBest.intValue());
            measurement.numericValue("pb_float", personalBest.floatValue());
        }
        return Optional.of(measurement.build());
    }

    public enum InvValueType {
        GE,
        HA,
        COUNT
    }

    private static final int THRESHOLD = 50_000;

    public Series createActivitySeries() {
        return createSeries().measurement(SERIES_ACTIVITY).build();
    }

    public Optional<Measurement> createActivityMeasurement(ActivityState.State lastState) {
        Measurement.MeasurementBuilder mb = Measurement.builder().series(createActivitySeries());
        if (!Strings.isNullOrEmpty(lastState.getSkill())) {
            mb.stringValue("skill", lastState.getSkill());
        }
        if (!Strings.isNullOrEmpty(lastState.getLocationType())) {
            mb.stringValue("type", lastState.getLocationType());
        }
        if (!Strings.isNullOrEmpty(lastState.getLocation())) {
            mb.stringValue("location", lastState.getLocation());
        }
        Measurement measure = mb.build();
        if (measure.getStringValues().isEmpty()) {
            return Optional.empty();
        }
        return Optional.of(measure);
    }

    public Series createLootSeries(LootRecordType type, String source, int combatLevel) {
        return createSeries()
                .measurement(SERIES_LOOT)
                .tag("type", type.name())
                .tag("source", source)
                .tag("combat", Integer.toString(combatLevel))
                .build();
    }

    public Optional<Measurement> createLootMeasurement(LootReceived event) {
        Player local = client.getLocalPlayer();
        WorldPoint location = WorldPoint.fromLocalInstance(client, local.getLocalLocation());
        Measurement.MeasurementBuilder measurement = Measurement.builder().series(createLootSeries(event.getType(), event.getName(), event.getCombatLevel()))
                .numericValue(SELF_KEY_X, location.getX())
                .numericValue(SELF_KEY_Y, location.getY())
                .numericValue("plane", location.getPlane())
                .numericValue("killcount", 1);

        Multiset<String> counts = HashMultiset.create(event.getItems().size());
        for (ItemStack stack : event.getItems()) {
            if (stack.getQuantity() <= 0) {
                continue;
            }
            int canonId = itemManager.canonicalize(stack.getId());
            ItemComposition data = itemManager.getItemComposition(canonId);
            counts.add(itemToKey(data), stack.getQuantity());
        }
        if (counts.isEmpty()) {
            return Optional.empty();
        }
        for (Multiset.Entry<String> count : counts.entrySet()) {
            measurement.numericValue(count.getElement(), count.getCount());
        }
        return Optional.of(measurement.build());
    }

    public Series createSkillingItemSeries(Skill skill, ItemComposition item) {
        return createSeries()
                .measurement(SERIES_SKILLING_ITEMS)
                .tag("skill", skill.name())
                .tag("item", itemToKey(item))
                .build();
    }

    public Measurement createSkillingItemMeasurement(Skill skill, int xp,
                                                     float weightedXp,
                                                     ItemComposition item,
                                                     long count) {
        return Measurement.builder().series(createSkillingItemSeries(skill, item))
                .numericValue("xp", xp)
                .numericValue("weightedXp", weightedXp)
                .numericValue("itemCount", count)
                .numericValue("actionCount", 1)
                .build();
    }
}

package net.machpi.runelite.influxdb;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Multiset;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.machpi.runelite.influxdb.write.InfluxWriter;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.game.ItemManager;

import java.util.Set;

@Slf4j
@Singleton
public final class SkillingItemTracker {
    private static final Set<Integer> IGNORED_ITEMS = ImmutableSet.of(ItemID.COINS_995,
            // ignore waterskins since they can be used on the same tick when doing activities in the desert
            ItemID.WATERSKIN0, ItemID.WATERSKIN1, ItemID.WATERSKIN2, ItemID.WATERSKIN3, ItemID.WATERSKIN4,
            // ignore cooking utensils
            ItemID.PIE_DISH, ItemID.CAKE_TIN, ItemID.POT, ItemID.BOWL, ItemID.SERVERY_DISH,
            // ignore not-interesting items received while doing birdhouse runs
            ItemID.CLOCKWORK, ItemID.FEATHER);
    private static final Set<Skill> VALID_SKILLS = ImmutableSet.of(Skill.RUNECRAFT, Skill.CRAFTING, Skill.MINING,
            Skill.SMITHING, Skill.FIREMAKING, Skill.COOKING, Skill.WOODCUTTING, Skill.HERBLORE, Skill.HUNTER,
            Skill.FLETCHING, Skill.FARMING, Skill.FISHING);

    private final Client client;
    private final ItemManager itemManager;
    private final MeasurementCreator measurementCreator;
    private final InfluxWriter writer;

    private Multiset<Integer> prevInventoryItems = HashMultiset.create();
    private Multiset<Integer> currInventoryItems = HashMultiset.create();

    private int trackingDataForTick = -1;
    private final Multiset<Integer> currTickAddedItems = HashMultiset.create();
    private final Multiset<Skill> currTickXp = HashMultiset.create();

    @Inject
    public SkillingItemTracker(Client client, ItemManager itemManager, MeasurementCreator measurementCreator,
                               InfluxWriter writer) {
        this.client = client;
        this.itemManager = itemManager;
        this.measurementCreator = measurementCreator;
        this.writer = writer;
    }

    public void onInventoryChanges(ItemContainer container) {
        for (int i = 0; i < container.size(); i++) {
            Item curr = container.getItem(i);
            if (curr == null) {
                continue;
            }
            int id = itemManager.canonicalize(curr.getId());
            if (IGNORED_ITEMS.contains(id)) {
                continue;
            }
            currInventoryItems.add(id, curr.getQuantity());
        }

        // Figure out what was added:
        for (Multiset.Entry<Integer> curr : currInventoryItems.entrySet()) {
            int prevCount = prevInventoryItems.count(curr.getElement());
            int newItems = curr.getCount() - prevCount;
            if (newItems > 0) {
                onItemAdded(curr.getElement(), newItems);
            }
        }

        Multiset<Integer> tmp = prevInventoryItems;
        prevInventoryItems = currInventoryItems;
        currInventoryItems = tmp;
        tmp.clear();
    }

    public void onXpGained(Skill skill, int xp) {
        if (VALID_SKILLS.contains(skill)) {
            flushIfNeeded();
            currTickXp.add(skill, xp);
        }
    }

    private void onItemAdded(int id, int count) {
        flushIfNeeded();
        currTickAddedItems.add(id, count);
    }

    public void flushIfNeeded() {
        int tick = client.getTickCount();
        if (trackingDataForTick == tick) {
            return;
        }
        if (currTickXp.entrySet().size() == 1) {
            Multiset.Entry<Skill> skill = Iterables.getOnlyElement(currTickXp.entrySet());
            float weightedXp = skill.getCount() / (float) currTickAddedItems.size();
            for (Multiset.Entry<Integer> item : currTickAddedItems.entrySet()) {
                ItemComposition composition = itemManager.getItemComposition(item.getElement());
                writer.submit(measurementCreator.createSkillingItemMeasurement(
                        skill.getElement(), skill.getCount(), weightedXp, composition, item.getCount()));
            }
        }
        currTickAddedItems.clear();
        currTickXp.clear();
        trackingDataForTick = tick;
    }
}

package net.machpi.runelite.influxdb;

import net.runelite.api.WorldType;

import java.time.Instant;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;

public final class WorldTags {
    private WorldTags() {
    }

    private static final String TAG_VARIANT = "variant";
    private static final String TAG_LEAGUE = "league";

    public static Map<String, String> tagsForWorld(EnumSet<WorldType> worldTypeData) {
        Variant variant = null;
        League league = null;
        if (worldTypeData.contains(WorldType.DEADMAN)) {
            variant = Variant.DEADMAN;
        } else if (worldTypeData.contains(WorldType.TOURNAMENT_WORLD)) {
            variant = Variant.TOURNAMENT;
        } else if (worldTypeData.contains(WorldType.LAST_MAN_STANDING)) {
            variant = Variant.LAST_MAN_STANDING;
        } else if (worldTypeData.contains(WorldType.SEASONAL)) {
            league = League.findCurrentLeague();
            variant = league != null ? Variant.LEAGUES : Variant.UNKNOWN_SEASONAL;
        }
        Map<String, String> results = new HashMap<>();
        if (variant != null)
            results.put(TAG_VARIANT, variant.name().toLowerCase());
        if (league != null)
            results.put(TAG_LEAGUE, league.name().toLowerCase());
        return results;
    }

    public enum League {
        TRAILBLAZER(Instant.parse("2020-10-28T00:00:00.00Z"), Instant.parse("2021-01-07T00:00:00.00Z"));

        private final Instant start;
        private final Instant end;

        League(Instant start, Instant end) {
            this.start = start;
            this.end = end;
        }

        public static League findCurrentLeague() {
            Instant now = Instant.now();
            for (League league : League.values()) {
                if ((league.start == null || league.start.isBefore(now)) && (league.end == null || league.end.isAfter(now))) {
                    return league;
                }
            }
            return null;
        }
    }

    public enum Variant {
        LEAGUES,
        DEADMAN,
        TOURNAMENT,
        LAST_MAN_STANDING,
        UNKNOWN_SEASONAL;
    }
}

package net.machpi.runelite.influxdb.write;

import com.google.common.base.Preconditions;
import com.google.common.collect.Maps;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.machpi.runelite.influxdb.InfluxDbConfig;
import net.machpi.runelite.influxdb.MeasurementCreator;
import org.apache.commons.lang3.StringUtils;
import org.influxdb.InfluxDB;
import org.influxdb.InfluxDBFactory;
import org.influxdb.dto.BatchPoints;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
@Singleton
public class InfluxWriter {
    private final InfluxDbConfig config;
    private final ConcurrentMap<Series, Writer> writers = new ConcurrentHashMap<>();

    @Inject
    public InfluxWriter(InfluxDbConfig config) {
        this.config = config;
    }

    public void submit(Measurement m) {
        writer(m.getSeries()).submit(m);
    }

    public boolean isBlocked(Series s) {
        return writer(s).isBlocked();
    }

    private InfluxDB cachedServer = null;
    private String serverUrl, serverUser, serverPass;

    private synchronized Optional<InfluxDB> getInflux() {
        if (StringUtils.isEmpty(config.getDatabase())) {
            return Optional.empty();
        }

        String newServerUrl = config.getServerUrl();
        String newServerUser = config.getServerUsername();
        String newServerPass = config.getServerPassword();

        if (!Objects.equals(newServerUrl, serverUrl)
                || !Objects.equals(newServerUser, serverUser)
                || !Objects.equals(newServerPass, serverPass)
                || cachedServer == null) {
            if (cachedServer != null) {
                cachedServer.close();
                cachedServer = null;
                serverUrl = null;
                serverUser = null;
                serverPass = null;
            }

            if (!StringUtils.isEmpty(serverUrl)) {
                if (StringUtils.isEmpty(serverPass) || StringUtils.isEmpty(serverUser)) {
                    cachedServer = InfluxDBFactory.connect(serverUrl);
                } else {
                    cachedServer = InfluxDBFactory.connect(serverUrl, serverUser, serverPass);
                }
            }
            serverUrl = newServerUrl;
            serverUser = newServerUser;
            serverPass = newServerPass;
        }
        return Optional.ofNullable(cachedServer);
    }

    private Writer writer(Series s) {
        return writers.computeIfAbsent(s, series -> {
            switch (series.getMeasurement()) {
                case MeasurementCreator.SERIES_SELF_LOC:
                    return new Writer(new ThrottledWriter(), SELF_DEDUPE);
                case MeasurementCreator.SERIES_ACTIVITY:
                case MeasurementCreator.SERIES_LOOT:
                    return new Writer(new AlwaysWriter(), (a, b) -> true);
                case MeasurementCreator.SERIES_SKILLING_ITEMS:
                    return new Writer(new SummingWriter(false), (a, b) -> true);
            }
            return new Writer(new ThrottledWriter(), FULL_DEDUPE);
        });
    }

    public synchronized void flush() {
        Optional<InfluxDB> influx = getInflux();
        if (influx.isEmpty()) {
            return;
        }
        BatchPoints.Builder batch = BatchPoints.database(config.getDatabase())
                .retentionPolicy(config.getServerRetentionPolicy())
                .consistency(InfluxDB.ConsistencyLevel.ONE);
        writers.forEach((k, v) -> v.flush(batch));

        influx.ifPresent(influxDB -> {
            BatchPoints built = batch.build();
            if (!built.getPoints().isEmpty()) {
                influxDB.write(built);
                if (log.isDebugEnabled()) {
                    log.debug("Writing {}", built.lineProtocol());
                }
            }
        });
    }

    private static class Writer {
        private final TerminalOp terminal;
        private final FilterOp[] filters;

        private Writer(TerminalOp terminal, FilterOp... filters) {
            this.terminal = terminal;
            this.filters = filters;
        }

        boolean isBlocked() {
            return terminal.isBlocked();
        }

        synchronized void submit(Measurement m) {
            Measurement prev = terminal.getLastWritten();
            for (FilterOp e : filters) {
                if (!e.shouldWrite(prev, m)) {
                    return;
                }
            }
            terminal.submit(m);
        }

        synchronized void flush(BatchPoints.Builder output) {
            terminal.flush(output);
        }
    }

    private interface TerminalOp {
        Measurement getLastWritten();

        boolean isBlocked();

        void submit(Measurement m);

        void flush(BatchPoints.Builder output);
    }

    private interface FilterOp {
        boolean shouldWrite(Measurement lastWritten, Measurement measurement);
    }

    private static class ThrottledWriter implements TerminalOp {
        @Getter
        private volatile Measurement lastWritten;
        private final AtomicReference<Measurement> waitingForWrite = new AtomicReference<>();

        @Override
        public boolean isBlocked() {
            return waitingForWrite.get() != null;
        }

        @Override
        public void submit(Measurement m) {
            waitingForWrite.set(m);
        }

        @Override
        public void flush(BatchPoints.Builder output) {
            Measurement flush = waitingForWrite.getAndSet(null);
            lastWritten = flush;
            if (flush != null)
                flush.toInflux().ifPresent(output::point);
        }
    }

    private static class AlwaysWriter implements TerminalOp {
        private final ArrayDeque<Measurement> queued = new ArrayDeque<>();

        @Override
        public synchronized Measurement getLastWritten() {
            return queued.isEmpty() ? null : queued.peekLast();
        }

        @Override
        public boolean isBlocked() {
            return false;
        }

        @Override
        public synchronized void submit(Measurement m) {
            queued.add(m);
        }

        @Override
        public synchronized void flush(BatchPoints.Builder output) {
            while (!queued.isEmpty()) {
                queued.removeFirst().toInflux().ifPresent(output::point);
            }
        }
    }

    private static final class SummingWriter implements TerminalOp {
        private final boolean floatingPoint;
        private Series series;
        private final Map<String, Number> values = new HashMap<>();

        public SummingWriter(boolean floatingPoint) {
            this.floatingPoint = floatingPoint;
        }

        @Override
        public Measurement getLastWritten() {
            return null;
        }

        @Override
        public boolean isBlocked() {
            return false;
        }

        @Override
        public synchronized void submit(Measurement m) {
            if (series == null) {
                series = m.getSeries();
            }
            Preconditions.checkArgument(m.getStringValues().isEmpty(), "Summing writer doesn't support string values");
            for (Map.Entry<String, Number> entry : m.getNumericValues().entrySet()) {
                Number existing = values.get(entry.getKey());
                Number output;
                if (floatingPoint) {
                    output = (existing != null ? existing.doubleValue() : 0) + entry.getValue().doubleValue();
                } else {
                    output = (existing != null ? existing.longValue() : 0) + entry.getValue().longValue();
                }
                values.put(entry.getKey(), output);
            }
        }

        @Override
        public synchronized void flush(BatchPoints.Builder output) {
            if (values.isEmpty()) {
                return;
            }
            Measurement.builder().series(series).numericValues(values).build().toInflux().ifPresent(output::point);
            values.clear();
        }
    }

    private static final FilterOp FULL_DEDUPE = (prev, b) -> prev == null || !prev.getNumericValues().equals(b.getNumericValues())
            || !prev.getStringValues().equals(b.getStringValues());

    private static final FilterOp SELF_DEDUPE = (prev, curr) -> {
        if (prev == null)
            return true;
        if (!prev.getStringValues().equals(curr.getStringValues()))
            return true;
        for (String posKey : MeasurementCreator.SELF_POS_KEYS) {
            Number p = prev.getNumericValues().get(posKey);
            Number c = curr.getNumericValues().get(posKey);
            if (p == null || c == null)
                return true;
            if (Math.abs(p.doubleValue() - c.doubleValue()) > 5)
                return true;
        }
        return !Objects.equals(
                Maps.filterKeys(prev.getNumericValues(), x -> !MeasurementCreator.SELF_POS_KEYS.contains(x)),
                Maps.filterKeys(curr.getNumericValues(), x -> !MeasurementCreator.SELF_POS_KEYS.contains(x)));
    };
}

package net.machpi.runelite.influxdb.write;

import lombok.Builder;
import lombok.NonNull;
import lombok.Singular;
import lombok.Value;
import org.influxdb.dto.Point;

import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;

@Value
@Builder
public class Measurement {
    Series series;

    @Builder.Default
    long time = System.currentTimeMillis();

    @Singular
    Map<@NonNull String, @NonNull String> stringValues;

    @Singular
    Map<@NonNull String, @NonNull Number> numericValues;

    // influx accepts Map<String, Object>, where object is String | Number
    @SuppressWarnings("unchecked")
    Optional<Point> toInflux() {
        if (getStringValues().isEmpty() && getNumericValues().isEmpty()) {
            return Optional.empty();
        }
        return Optional.of(Point.measurement(series.getMeasurement())
                .tag(series.getTags())
                .time(time, TimeUnit.MILLISECONDS)
                .fields((Map) getStringValues())
                .fields((Map) getNumericValues())
                .build());
    }
}

package net.machpi.runelite.influxdb.write;

import lombok.Builder;
import lombok.NonNull;
import lombok.Singular;
import lombok.Value;

import java.util.Map;

@Value
@Builder
public class Series {
    String measurement;

    @Singular
    Map<@NonNull String, @NonNull String> tags;
}

package net.machpi.runelite.influxdb.write;

import net.machpi.runelite.influxdb.InfluxDbPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class InfluxDbPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(InfluxDbPlugin.class);
		RuneLite.main(args);
	}
}
