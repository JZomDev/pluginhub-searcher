/*
	BSD 2-Clause License

	Copyright (c) 2024, denaelc

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	1. Redistributions of source code must retain the above copyright notice, this
	   list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright notice,
	   this list of conditions and the following disclaimer in the documentation
	   and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
	FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// A lot of code used from the gauntlet recolor plugin.
// This is an adaptation(abomination) of the previously created modelprocessor.
// The name was changed specifically because the it was easier for me to keep track of things as I went along.

package com.VMRecolor;

import static com.VMRecolor.VMRecolorPlugin.GRAPHICS_OBJECTS;
import static com.VMRecolor.VMRecolorPlugin.LAVA;
import static com.VMRecolor.VMRecolorPlugin.LAVA_BEAST;
import static com.VMRecolor.VMRecolorPlugin.LOWER_LEVEL_FLOOR;
import static com.VMRecolor.VMRecolorPlugin.LOWER_LEVEL_INTERACTABLES;
import static com.VMRecolor.VMRecolorPlugin.PLATFORMS;
import static com.VMRecolor.VMRecolorPlugin.UPPER_LEVEL_FLOOR;
import static com.VMRecolor.VMRecolorPlugin.WALL_OBJECTS;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Model;
import net.runelite.client.config.ConfigManager;

@Slf4j
public class ModelRecolorer
{

	@Inject
	private VMRecolorConfig config;

	@Inject
	private ConfigManager configManager;

	private Map<String, Map<Integer, int[][]>> originalColorData = new HashMap<>();
	private Map<String, Map<Integer, int[][]>> recoloredColorData = new HashMap<>();

	static final int DARK_PURPLE = 48;
	static final int PURPLE = 49;
	static final int YELLOW = 8;
	static final int ORANGE = 5;
	static final int GREEN = 28;

	// creates a hashmap with all the facecolors, IDs and types (gameObject, Groundobject etc.)
	// could be simplified if the .txt gets simplified
	public void cacheData(String filePath) throws IOException
	{
		try (InputStream inputStream = getClass().getResourceAsStream(filePath))
		{
			if (inputStream == null)
			{
				throw new FileNotFoundException("Resource not found: " + filePath);
			}
			try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)))
			{
				String line;
				String currentType = null;
				int currentId = -1;
				int[][] colors = new int[3][];

				while ((line = reader.readLine()) != null)
				{
					if (line.trim().isEmpty())
					{
						continue;
					}
					if (line.contains(" ID: "))
					{
						if (currentType != null && currentId != -1)
						{
							originalColorData.computeIfAbsent(currentType, k -> new HashMap<>()).put(currentId, colors);
						}
						currentType = line.split(" ")[0];
						currentId = Integer.parseInt(line.split(": ")[1].split(" ")[0]);
						colors = new int[3][];
					}
					else if (line.startsWith("FaceColors"))
					{
						int index = Integer.parseInt(line.substring(10, 11)) - 1;
						colors[index] = Arrays.stream(line.split(": ")[1].replace("[", "").replace("]", "").split(",")).mapToInt(Integer::parseInt).toArray();
					}
				}
				if (currentType != null && currentId != -1)
				{
					originalColorData.computeIfAbsent(currentType, k -> new HashMap<>()).put(currentId, colors);
				}
			}
		}
	}

	// This is great and all but it's not super convenient for replacing individual IDs which is this plugin's need
	// creates a second hashmap with the recolored values, based of the vanilla hashmap
	public void recolorData()
	{
		recoloredColorData.clear();
		originalColorData.forEach((type, models) -> {
			Map<Integer, int[][]> recoloredMap = new HashMap<>();
			models.forEach((id, colors) -> {
				int[][] recoloredColors = new int[colors.length][];
				for (int i = 0; i < colors.length; i++)
				{
					recoloredColors[i] = recolor(colors[i], id);
				}
				recoloredMap.put(id, recoloredColors);
			});
			recoloredColorData.put(type, recoloredMap);
		});
	}

	private boolean isBoulder(int id)
	{
		return VMRecolorPlugin.THE_BOULDER.contains(id) || VMRecolorPlugin.THE_BOULDER_NPCS.contains(id);
	}

	// recolors a single array of colors (e.g. facecolors1 of a single model)
	private int[] recolor(int[] originalColors, int id)
	{
		int[] newColors = new int[originalColors.length];
		for (int i = 0; i < originalColors.length; i++)
		{
			if (id == 0 || WALL_OBJECTS.contains(id))
			{
				newColors[i] = newColorHsbEnumHandler(originalColors[i], config.wallColor(), id, config.wall());
			}
			else if (isBoulder(id))
			{
				newColors[i] = newBoulderColorHsb(originalColors[i], config.boulderColor(), id, config.boulder());
			}
			else if (LOWER_LEVEL_FLOOR.contains(id) || GRAPHICS_OBJECTS.contains(id) || (config.lava() == VMRecolorConfig.LavaOptions.Hidden && (id == 660 || id == 659))) // lava projectiles and splats
			{
				newColors[i] = newColorHsbEnumHandler(originalColors[i], config.lowerLevelFloorColor(), id, config.lowerLevelFloor());
			}
			else if (UPPER_LEVEL_FLOOR.contains(id))
			{
				newColors[i] = newColorHsbEnumHandler(originalColors[i], config.upperLevelFloorColor(), id, config.upperLevelFloor());
			}
			else if (PLATFORMS.contains(id))
			{
				newColors[i] = newColorPlatformHandler(originalColors[i], config.platformColor(), id, config.platform());
			}
			else if (id == LAVA_BEAST || id == 1403)
			{
				newColors[i] = newColorHsbEnumHandler(originalColors[i], config.lavaBeastColor(), id, config.lavaBeast());
			}
			else if (LAVA.contains(id))
			{
				newColors[i] = newLavaColorHsb(originalColors[i], id);
			}
			else
			{
				newColors[i] = originalColors[i];
			}
		}
		return newColors;
	}

	public int newBoulderColorHsb(int faceColor, Color newColor, int id, VMRecolorConfig.BoulderTypes boulderType)
	{
		if (faceColor <= 0)
		{
			return faceColor; // Returning -2 for -1 faces removes a large portion of the boulder
		}

		switch (boulderType)
		{
			case Brightness:
			{
				int hueFace = extractHsbValues(faceColor, 6, 11);
				int saturationFace = extractHsbValues(faceColor, 3, 8);
				int brightnessFace = extractHsbValues(faceColor, 7, 1);

				// Apply the brightness multiplier
				int newBrightness = (int) (brightnessFace * (config.brightness() / 100.0));
				// Ensure the brightness stays within the valid range (0-127)
				newBrightness = Math.max(1, Math.min(127, newBrightness));
				return (hueFace << 10) + (saturationFace << 7) + newBrightness;
			}

			case HueShift:
			{
				return hueShift(faceColor, config.boulderColor());
			}
			// I like the way stars look but hate mining them
			case Star:
				// No good way to recolor each stage of the boulder. It would involve going through the arrays individually and creating entirely new palletes.
				// If there's a way to edit rsmodels with their natural hsbs I would love to do this and just export as needed, but currently is not viable.
				// When it breaks, it reveals the model of the next boulder but without the
				// custom colors applied
				// Would have to subscribe to animation changed event or something similar to that to
				// recolor the animation appropriately. Very annoying
			{
				int hue = getHue(faceColor);
				if (hue == YELLOW)
				{
					return hsbTors2(PURPLE, 1, 30);
				}
				if (hue == ORANGE)
				{
					if (getBrightness(faceColor) > 25)
					{
						return hsbTors2(DARK_PURPLE, 1, 20);
					}
					else
					{
						return hsbTors2(GREEN, getSaturation(faceColor), getBrightness(faceColor) / 3);
					}
				}
				// Reds
				if (hue == 1)
				{
					return hsbTors2(GREEN + 1, getSaturation(faceColor), getBrightness(faceColor) / 3);
				}
				if (hue == 2)
				{
					return hsbTors2(GREEN, getSaturation(faceColor), getBrightness(faceColor) / 3);
				}
				if (hue == 3)
				{
					return hsbTors2(GREEN - 1, getSaturation(faceColor), getBrightness(faceColor) / 3);
				}
				return faceColor;
			}
			default:
				return faceColor;
		}
	}

	private int hsbTors2(int h, int s, int b)
	{
		return (h << 10) + (s << 7) + b;
	}

	public int newLavaColorHsb(int faceColor, int id)
	{
		if (faceColor == 2)
		{
			return faceColor;
		}
		switch (config.lava())
		{
			case Default:
				return faceColor;

			case Brightness:
			{
				int hueFace = extractHsbValues(faceColor, 6, 11);
				int saturationFace = extractHsbValues(faceColor, 3, 8);
				int brightnessFace = extractHsbValues(faceColor, 7, 1);

				// Apply the brightness multiplier
				int newBrightness = (int) (brightnessFace * (config.brightness() / 100.0));
				// Ensure the brightness stays within the valid range (0-127)
				newBrightness = Math.max(1, Math.min(127, newBrightness));
				return (hueFace << 10) + (saturationFace << 7) + newBrightness;
			}

			case HueShift:
			{
				return lavaHueShift(faceColor, config.lavaColor(), faceColor, 1);
			}

			case Hidden:
			{
				if (id == VMRecolorPlugin.LAVA_BEAST)
				{
					return faceColor;
				}
				if (id == 31039)
				{
					return -2;
				}
				// Not even going to try dynamically finding them
				if ((faceColor > 5900 && faceColor < 6000) || faceColor > 9000 || isWhite(faceColor))
				{
					return -2;
				}
				return faceColor;
			}

			default:
				return 0; //how
		}
	}

	public int newColorPlatformHandler(int faceColor, Color newColor, int id, VMRecolorConfig.PlatformOptions globalColor)
	{
		if (faceColor == 2)
		{
			return faceColor;
		}
		switch (globalColor)
		{
			case Default:
				return faceColor;

			case Brightness:
			{
				int hueFace = extractHsbValues(faceColor, 6, 11);
				int saturationFace = extractHsbValues(faceColor, 3, 8);
				int brightnessFace = extractHsbValues(faceColor, 7, 1);

				// Apply the brightness multiplier
				int newBrightness = (int) (brightnessFace * (config.brightness() / 100.0));
				// Ensure the brightness stays within the valid range (0-127)
				newBrightness = Math.max(1, Math.min(127, newBrightness));
				return (hueFace << 10) + (saturationFace << 7) + newBrightness;
			}

			case HueShift:
			{
				return hueShift(faceColor, newColor);
			}

			case MatchLava:
			{
				if (config.lava() == VMRecolorConfig.LavaOptions.Hidden)
				{
					return faceColor;
				}
				return newLavaColorHsb(faceColor, id);
			}
			default:
				return -1; //how
		}
	}

	public int newColorHsbEnumHandler(int faceColor, Color newColor, int id, VMRecolorConfig.GlobalColor globalColor)
	{
		if (faceColor == 2)
		{
			return faceColor;
		}
		// Ignore lava beast projectiles, don't make anything on lava beasts invisible, and don't hide gas hole animations
		if ((faceColor > 9000 || isWhite(faceColor))
			&& !(id == 1403 || ((config.lava() == VMRecolorConfig.LavaOptions.Hidden) && id == LAVA_BEAST) || LOWER_LEVEL_INTERACTABLES.contains(id) || id == 1407))
		{
			return newLavaColorHsb(faceColor, id);
		}
		switch (globalColor)
		{
			case Default:
				return faceColor;

			case Brightness:
			{
				int hueFace = extractHsbValues(faceColor, 6, 11);
				int saturationFace = extractHsbValues(faceColor, 3, 8);
				int brightnessFace = extractHsbValues(faceColor, 7, 1);

				// Apply the brightness multiplier
				int newBrightness = (int) (brightnessFace * (config.brightness() / 100.0));
				// Ensure the brightness stays within the valid range (0-127)
				newBrightness = Math.max(1, Math.min(127, newBrightness));
				return (hueFace << 10) + (saturationFace << 7) + newBrightness;
			}

			case HueShift:
			{
				return hueShift(faceColor, newColor);
			}

			default:
				return -1; //how
		}
	}

	private boolean isWhite(int faceColor)
	{
		int faceHue = extractHsbValues(faceColor, 6, 11);
		int faceSat = extractHsbValues(faceColor, 3, 8);
		return faceHue == 0 && faceSat == 0;
	}

	public int lavaHueShift(int faceColor, Color newColor, int referenceColor, double aggression)
	{
		int newColorHsb = colorToRs2hsb(newColor);

		// values of the facecolor
		int saturationFace = extractHsbValues(faceColor, 3, 8);
		int brightnessFace = extractHsbValues(faceColor, 7, 1);
		// value of the new reference color
		int hueRef = extractHsbValues(newColorHsb, 6, 11);

		// This is a WIP
		int newBrightness;

		newBrightness = (int) (brightnessFace * ((config.brightness() / 100.0) / aggression));
		newBrightness = Math.max(1, Math.min(127, newBrightness));

		if (isWhite(faceColor))
		{
			if (config.whiteBrightness() != -1)
			{
				return (hueRef << 10) + (7 << 7) + config.whiteBrightness();
			}
			return -1;
		}

		return (hueRef << 10) + (saturationFace << 7) + newBrightness;
	}

	// applies the colors to a model
	public void applyColor(Model model, int[] f1, int[] f2, int[] f3)
	{
		int[] faceColors, faceColors2, faceColors3;
		try
		{
			faceColors = model.getFaceColors1();
			faceColors2 = model.getFaceColors2();
			faceColors3 = model.getFaceColors3();
		}
		catch (NullPointerException e)
		{
			return;
		}

		if (f1.length <= faceColors.length && f2.length <= faceColors2.length && f3.length <= faceColors3.length)
		{
			System.arraycopy(f1, 0, faceColors, 0, f1.length);
			System.arraycopy(f2, 0, faceColors2, 0, f2.length);
			System.arraycopy(f3, 0, faceColors3, 0, f3.length);
		}
		else
		{
			log.info("FaceColor has the wrong length.");
		}
	}

	// same concept as brightColors, but only shifts Hue
	public int hueShift(int faceColor, Color newColor)
	{
		int newColorHsb = colorToRs2hsb(newColor);

		// values of the facecolor
		int hueFace = extractHsbValues(faceColor, 6, 11);
		int saturationFace = extractHsbValues(faceColor, 3, 8);
		int brightnessFace = extractHsbValues(faceColor, 7, 1);
		// value of the new reference color
		int hueRef = extractHsbValues(newColorHsb, 6, 11);
		// value for the current reference color

		//int referenceHue = extractHsbValues(referenceColor, 6, 11);

		//int hueDiff = referenceHue - hueFace;

		//int newHue = hueRef - hueDiff;

		// newHue = (newHue % 64 + 64) % 64;

		return (hueRef << 10) + (saturationFace << 7) + brightnessFace;
	}


	static int getBrightness(int faceColor)
	{
		return (((1 << 7) - 1) & (faceColor));
	}

	static int getSaturation(int faceColor)
	{
		return (((1 << 3) - 1) & (faceColor >> (8 - 1)));
	}

	static int getHue(int faceColor)
	{
		return (((1 << 6) - 1) & (faceColor >> (11 - 1)));
	}

	// Returns the hsb values
	static int extractHsbValues(int hsbColor, int k, int p)
	{
		return (((1 << k) - 1) & (hsbColor >> (p - 1)));
	}

	// not my method, I don't know who to give credit for it, but I took it from AnkouOSRS, https://github.com/AnkouOSRS/cox-light-colors/blob/master/src/main/java/com/coxlightcolors/CoxLightColorsPlugin.java
	private int colorToRs2hsb(Color color)
	{
		float[] hsbVals = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);
		// "Correct" the brightness level to avoid going to white at full saturation, or having a low brightness at
		// low saturation
		hsbVals[2] -= Math.min(hsbVals[1], hsbVals[2] / 2);
		int encode_hue = (int) (hsbVals[0] * 63);
		int encode_saturation = (int) (hsbVals[1] * 7);
		int encode_brightness = (int) (hsbVals[2] * 127);
		return (encode_hue << 10) + (encode_saturation << 7) + (encode_brightness);
	}

	// applies either the vanilla or the recolored hashmap data to a given model
	public void applyColors(int objectId, String type, Model model, boolean useRecolored)
	{
		Map<Integer, int[][]> data = useRecolored ? recoloredColorData.getOrDefault(type, Collections.emptyMap()) : originalColorData.getOrDefault(type, Collections.emptyMap());
		int[][] colors = data.get(objectId);
		if (colors != null && colors[0] != null && colors[1] != null && colors[2] != null)
		{
			applyColor(model, colors[0], colors[1], colors[2]);
		}
	}

	// Calls to this method are so computationally heavy they result in significant client hitching
	// this is alleviated by not calling them synchronously (should only be a problem if a user changes config
	// when rendering?) This is noteable when crossing any loading line (if called synchronously).
	public void applyColorsDirectly(Model model, int id)
	{
		int[] f1 = model.getFaceColors1();
		int[] f2 = model.getFaceColors2();
		int[] f3 = model.getFaceColors3();
		if (f1 != null && f2 != null && f3 != null)
		{
			applyColor(model, recolor(f1, id), recolor(f2, id), recolor(f3, id));
		}
	}

	// deletes the hashmaps
	public void cleanUp()
	{
		originalColorData.clear();
		recoloredColorData.clear();
	}
}
package com.VMRecolor;

import static com.VMRecolor.VMRecolorPlugin.CONFIG_GROUP;
import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup(CONFIG_GROUP)
public interface VMRecolorConfig extends Config
{
	enum BoulderTypes
	{
		Default,
		Brightness,
		HueShift,
		Star
	}

	enum GlobalColor
	{
		Default,
		Brightness,
		HueShift
	}

	enum LavaOptions
	{
		Default,
		Brightness,
		HueShift,
		Hidden
	}

	enum PlatformOptions
	{
		Default,
		Brightness,
		HueShift,
		MatchLava
	}

	@ConfigSection(
		name = "Global",
		description = "Global color settings",
		position = 0,
		closedByDefault = false
	)
	String globalOpt = "globalOpt";

	@ConfigSection(
		name = "Options",
		description = "All the options for coloring",
		position = 1,
		closedByDefault = false
	)
	String options = "options";

	@ConfigSection(
		name = "Custom colors",
		description = "Global color settings",
		position = 2,
		closedByDefault = false
	)
	String color = "color";

	@ConfigItem(
		keyName = "syncColors",
		name = "Sync colors",
		description = "Sync custom colors when changing -- takes effect on your next color change. Reopen settings to see synced colors.",
		section = globalOpt
	)
	default boolean syncColors()
	{
		return false;
	}

	@ConfigItem(
		keyName = "ignoreThis",
		name = "HD ground textures",
		description = "",
		section = globalOpt
	)
	default String ignore()
	{
		return "117 HD ground textures do not blend with the models in VM currently. \nIf you toggle Ground Textures setting off in that plugin it should alleviate the harsh edges.";
	}

	@ConfigItem(
		keyName = "Boulder",
		name = "Boulder",
		description = "Recolor the boulder",
		section = options
	)
	default BoulderTypes boulder()
	{
		return BoulderTypes.Default;
	}

	@ConfigItem(
		keyName = "lavaBeast",
		name = "Lava Beast",
		description = "Recolor lava beast",
		section = options
	)
	default GlobalColor lavaBeast()
	{
		return GlobalColor.Default;
	}

	@ConfigItem(
		keyName = "lava",
		name = "Lava",
		description = "Removes all objects with visible lava",
		section = options
	)
	default LavaOptions lava()
	{
		return LavaOptions.Default;
	}

	// Unsure. Think this needs to be in config per item as well.
	@ConfigItem(
		keyName = "Brightness",
		name = "Brightness",
		description = "The brightness percentage applied to lava facing visuals",
		section = globalOpt
	)
	@Range(
		max = 10000,
		min = 1
	)
	default int brightness()
	{
		return 100;
	}

	// Still kind of necessary? Maybe enum to match chosen color, recolor to match lava
	@ConfigItem(
		keyName = "whiteBrightness",
		name = "White brightness",
		description = "Change the brightness of white colors (-1 hides it completely)",
		section = globalOpt
	)
	@Range(
		max = 127,
		min = -1
	)
	default int whiteBrightness()
	{
		return 100;
	}

	@ConfigItem(
		keyName = "wall",
		name = "Walls",
		description = "Wall colors",
		section = options
	)
	default GlobalColor wall()
	{
		return GlobalColor.Default;
	}

	@ConfigItem(
		keyName = "lowerLevelFloor",
		name = "Lower Floor",
		description = "Lower level floor option",
		section = options
	)
	default GlobalColor lowerLevelFloor()
	{
		return GlobalColor.Default;
	}

	@ConfigItem(
		keyName = "upperLevelFloor",
		name = "Upper Floor",
		description = "Upper level floor option",
		section = options
	)
	default GlobalColor upperLevelFloor()
	{
		return GlobalColor.Default;
	}

	@ConfigItem(
		keyName = "platform",
		name = "Platforms",
		description = "Platform option",
		section = options
	)
	default PlatformOptions platform()
	{
		return PlatformOptions.Default;
	}

	@ConfigItem(
		keyName = "wallCustomColor",
		name = "Walls",
		description = "Walls color",
		section = color
	)
	default Color wallColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "lowerLevelFloorCustomColor",
		name = "Lower Floor",
		description = "Lower level floor color",
		section = color
	)
	default Color lowerLevelFloorColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "upperLevelFloorCustomColor",
		name = "Upper Floor",
		description = "Upper level floor color",
		section = color
	)
	default Color upperLevelFloorColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "platformCustomColor",
		name = "Platforms",
		description = "Color for the platforms",
		section = color
	)
	default Color platformColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "BoulderCustomColor",
		name = "Boulder",
		description = "Color for the boulder",
		section = color
	)
	default Color boulderColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "lavaBeastCustomColor",
		name = "Lava Beast",
		description = "Color for the Lava Beast",
		section = color
	)
	default Color lavaBeastColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "lavaColor",
		name = "Lava",
		description = "Color for the lava",
		section = color
	)
	default Color lavaColor()
	{
		return Color.RED;
	}
}

/*
	BSD 2-Clause License
	Copyright (c) 2018, Adam <Adam@sigterm.info>
	Copyright (c) 2018, James Swindle <wilingua@gmail.com>
	Copyright (c) 2024, denaelc

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	1. Redistributions of source code must retain the above copyright notice, this
	   list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright notice,
	   this list of conditions and the following disclaimer in the documentation
	   and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
	FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// A lot of code used from the gauntlet recolor plugin.
// Menus were derived from Adam's in core RuneLite.

package com.VMRecolor;

import com.VMRecolor.VMRecolorConfig.BoulderTypes;
import com.VMRecolor.VMRecolorConfig.GlobalColor;
import com.VMRecolor.VMRecolorConfig.LavaOptions;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import java.applet.Applet;
import java.awt.Color;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;

@Slf4j
@PluginDescriptor(
		name = "VM Recolor",
		description="Make Volcanic Mine not look like cheese",
		tags= {"volcanic","mine","ultimate","vm","color","vent","recolor","boulder"}
)
public class VMRecolorPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "VMRecolor";
	@Inject
	private Client client;

	@Inject
	private VMRecolorConfig config;

	@Inject
	private ModelRecolorer modelRecolorer;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ColorPickerManager colorPickerManager;

	@Inject
	private ConfigManager configManager;

	private final ArrayList<GameObject> recordedGameObjects = new ArrayList<>();
	private final ArrayList<GroundObject> recordedGroundObjects = new ArrayList<>();
	private final ArrayList<Model> recordedModels = new ArrayList<>();
	private final ArrayList<NPC> recordedNpcs = new ArrayList<>();
	private final ArrayList<Projectile> recordedProjectiles = new ArrayList<>();
	private final ArrayList<GraphicsObject> recordedGraphicsObjects = new ArrayList<>();
	private final ArrayList<Integer> sceneIDs = new ArrayList<>();
	private final Set<Integer> VMRegionIDs = ImmutableSet.of(15263, 15262, 15519, 15518, 15775, 15774);

	private static final Set<String> COLOR_CONFIG_KEYS = ImmutableSet.of("BoulderCustomColor", "wallCustomColor", "lavaBeastCustomColor", "upperLevelFloorCustomColor", "lowerLevelFloorCustomColor", "platformCustomColor", "lavaColor");
	public static final Set<Integer> THE_BOULDER = ImmutableSet.of(31034, 31035, 31036, 31037, 31038);
	public static final Set<Integer> THE_BOULDER_NPCS = ImmutableSet.of(7807, 7808, 7809, 7810, 7811, 7812, 7813, 7814, 7815, 7816);

	public static final Set<Integer> LAVA = ImmutableSet.of(31001, 31002, 31039);
	private static final Set<Integer> GAME_OBJECTS = ImmutableSet.of(30998, 30999, 31000, 31002, 31003, 31004, 31005, 31006, 31007, 31008, 31009, 31010, 31011, 31012, 31013, 30996, 30995, 30994, 30993, 30992, 30991, 30990, 31039, 31014, 31015, 31016, 31017, 31018, 31019, 31020, 31021, 31022, 31023, 31024, 31025, 31026, 31027, 31028, 31029, 31030, 31042, 31043, 31044, 31045, 31046, 31047, 31048, 31049, 31050, 31051, 31052);
	public static final Set<Integer> LOWER_LEVEL_FLOOR = ImmutableSet.of(31003, 31004, 31005, 31006, 31007, 31008, 31009, 31010, 31011, 31012, 31013, 31026, 31028, 31030, 31033, 31042, 31043, 31044, 31045, 31046, 31047, 31048, 31049, 31050, 31051, 31052);
	public static final Set<Integer> LOWER_LEVEL_INTERACTABLES = ImmutableSet.of(31042, 31043, 31044, 31045, 31046, 31047, 31048, 31049, 31050, 31051, 31052);
	public static final Set<Integer> UPPER_LEVEL_FLOOR = ImmutableSet.of(31014, 31015, 31016, 31017, 31018, 31019, 31020, 31021, 31022, 31023, 31024, 31025, 31027);
	public static final Set<Integer> PLATFORMS = ImmutableSet.of(30998, 30999, 31000);
	public static final Set<Integer> WALL_OBJECTS = ImmutableSet.of(30996, 30995, 30994, 30993, 30992, 30991, 30990);
	public static final Set<Integer> GRAPHICS_OBJECTS = ImmutableSet.of(1406, 1407);

	public static final int LAVA_BEAST = 7817;
	private boolean syncingColors = false;

	private int regionId;
	private boolean counting;
	private int ticksSinceInVM;

	@Override
	protected void startUp() throws Exception
	{
		modelRecolorer.cacheData("/model_facecolors.txt");
		modelRecolorer.recolorData();
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			regionId = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID();
			if (VMRegionIDs.contains(regionId) && client.getGameState() == GameState.LOGGED_IN)
			{
				clientThread.invokeLater(() -> client.setGameState(GameState.LOADING));
			}
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientThread.invokeLater(() -> {
			clearAll();

			synchronized (modelRecolorer)
			{
				modelRecolorer.cleanUp();
			}
		});
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invokeLater(() -> {
				client.setGameState(GameState.LOADING);
			});
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!inVMRegion() || !client.isKeyPressed(KeyCode.KC_SHIFT) || (event.getType() != MenuAction.EXAMINE_OBJECT.getId() && event.getMenuEntry().getType() != MenuAction.EXAMINE_NPC))
		{
			return;
		}
		NPC npc = null;
		if (event.getMenuEntry().getType() != MenuAction.EXAMINE_NPC)
		{
			npc = event.getMenuEntry().getNpc();
		}
		TileObject tileObject = null;
		if (event.getType() == MenuAction.EXAMINE_OBJECT.getId())
		{
			tileObject = findTileObject(client.getPlane(), event.getActionParam0(), event.getActionParam1(), event.getIdentifier());
			if (tileObject == null && npc == null)
			{
				return;
			}
		}


		int idx = -1;
		if (tileObject != null && (THE_BOULDER.contains(tileObject.getId()) || GAME_OBJECTS.contains(tileObject.getId())))
		{
			idx = createColorMenu(idx, event.getTarget(), tileObject.getId());
		}
		if (npc != null && (npc.getId() == LAVA_BEAST || THE_BOULDER_NPCS.contains(npc.getId())))
		{
			idx = createColorMenu(idx, event.getTarget(), npc.getId());
		}

	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(CONFIG_GROUP) || syncingColors) // Can create loop of death if changing colors without this
		{
			return;
		}
		if (config.syncColors() && COLOR_CONFIG_KEYS.contains(event.getKey()))
		{
			syncingColors = true;
			log.debug("Attmepting to sync color change: {}", event.getKey());
			Color newColor = Color.WHITE;
			switch (event.getKey())
			{

				case "BoulderCustomColor":
				{
					newColor = config.boulderColor();
					break;
				}
				case "wallCustomColor":
				{
					newColor = config.wallColor();
					break;
				}
				case "lavaBeastCustomColor":
				{
					newColor = config.lavaBeastColor();
					break;
				}
				case "upperLevelFloorCustomColor":
				{
					newColor = config.upperLevelFloorColor();
					break;
				}
				case "lowerLevelFloorCustomColor":
				{
					newColor = config.lowerLevelFloorColor();
					break;
				}
				case "platformCustomColor":
				{
					newColor = config.platformColor();
					break;
				}
				case "lavaColor":
				{
					newColor = config.lavaColor();
					break;
				}
			}
			for (String key : COLOR_CONFIG_KEYS)
			{
				log.debug("Syncing color change: {}", key);
				configManager.setConfiguration(CONFIG_GROUP, key, newColor);
			}
			syncingColors = false;

			synchronized (modelRecolorer)
			{
				modelRecolorer.recolorData();
			}

			if (inVMRegion())
			{
				recolorAllNPCs();
				forceReload();
			}
			return;
		}

		switch (event.getKey())
		{
			case "Boulder":
			case "BoulderCustomColor":
			case "lava":
			case "lavaColor":
			case "wall":
			case "wallCustomColor":
			case "platform":
			case "upperLevelFloor":
			case "lowerLevelFloor":
			case "platformCustomColor":
			case "upperLevelFloorCustomColor":
			case "lowerLevelFloorCustomColor":
			{
				synchronized (modelRecolorer)
				{
					modelRecolorer.recolorData();
				}
				if (inVMRegion())
				{
					forceReload();
				}
				break;
				// TODO: Figure out how to recolor walls without forcing scene reload
				// Don't think it can be done simply.
				// Currently all methods of recoloring walls are unsuccessful because other methods apply colors to
				//  *default* models. Because walls have two renderables and there's no way to identify the second renderable
				// they currently have their colors applied directly to the model with no way to recover the initial colors.
				// Potential workaround to forcing client reload is *undo* color applications to the model and reapply?
				// Furthermore, several models used as walls are also used as decorations, as seen on the first floor by the west staircase
				// as well as the platform just under the west stairs.
			}
			case "lavaBeast":
			case "lavaBeastCustomColor":
			{
				synchronized (modelRecolorer)
				{
					modelRecolorer.recolorData();
				}
				recolorAllNPCs();
				break;
			}
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		if (!inVMRegion())
		{
			return;
		}

		int ID = event.getGameObject().getId();
		if (GAME_OBJECTS.contains(ID) || THE_BOULDER.contains(ID) || WALL_OBJECTS.contains(ID) || LAVA.contains(ID))
		{
			recordedGameObjects.add(event.getGameObject());
			recolorGameObject(event.getGameObject());
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		// Running clearAll on varbit changed is tricky because it
		// crashes the client without waiting a tick after.
		// The vm varbit changes before the player loads the environment outside VM
		if(event.getNpc().getId()==7776 && !recordedGameObjects.isEmpty())
		{
			clientThread.invokeLater(this::clearAll);
			return;
		}
		if (!inVMRegion())
		{
			return;
		}
		if (LAVA_BEAST == event.getNpc().getId())
		{
			recordedNpcs.add(event.getNpc());
			if (config.lavaBeast() == GlobalColor.Default)
			{
				return;
			}
			recolorNPC(event.getNpc());
		}
		if (THE_BOULDER_NPCS.contains(event.getNpc().getId()) && config.boulder() != BoulderTypes.Default)
		{
			recolorNPC(event.getNpc());
		}
	}

	@Subscribe
	public void onNpcChanged(NpcChanged event)
	{
		if (!inVMRegion())
		{
			return;
		}
		if (LAVA_BEAST == event.getNpc().getId())
		{
			recordedNpcs.add(event.getNpc());
			if (config.lavaBeast() == GlobalColor.Default)
			{
				return;
			}
			recolorNPC(event.getNpc());
		}
		if (THE_BOULDER_NPCS.contains(event.getNpc().getId()) && config.boulder() != BoulderTypes.Default)
		{
			recolorNPC(event.getNpc());
		}
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned event)
	{
		if (!inVMRegion())
		{
			return;
		}
		if (config.lava() == LavaOptions.Default && config.brightness() == 100)
		{
			return;
		}
		int ID = event.getGroundObject().getId();
		if (LAVA.contains(ID) || ID == 659) // 659 is lava projectile splat effect
		{
			recordedGroundObjects.add(event.getGroundObject());
			recolorGroundObject(event.getGroundObject());
		}
	}

	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated event)
	{
		if (!inVMRegion())
		{
			return;
		}
		int ID = event.getGraphicsObject().getId();

		if (ID == 659 || GRAPHICS_OBJECTS.contains(ID))
		{
			recordedGraphicsObjects.add(event.getGraphicsObject());
			recolorGraphicsObject(event.getGraphicsObject());
		}
	}

	@Subscribe
	void onWallObjectSpawned(WallObjectSpawned event)
	{
		if (!inVMRegion())
		{
			return;
		}
		if (WALL_OBJECTS.contains(event.getWallObject().getId()))
		{
			recolorWallObject(event.getWallObject());
		}
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved)
	{
		if (!inVMRegion())
		{
			return;
		}
		if (config.lava() != LavaOptions.Default)
		{

			if (projectileMoved.getProjectile().getId() == 660)
			{
				recordedProjectiles.add(projectileMoved.getProjectile());
				recolorProjectile(projectileMoved.getProjectile());
				return;
			}
		}
		if (projectileMoved.getProjectile().getId() == 1403 && config.lavaBeast() != GlobalColor.Default)
		{
			recordedProjectiles.add(projectileMoved.getProjectile());
			recolorProjectile(projectileMoved.getProjectile());
		}
	}

	private boolean inVMRegion()
	{
		regionId = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID();
		return VMRegionIDs.contains(regionId);
	}

	public void recolorGraphicsObject(GraphicsObject graphicsObject)
	{

		Model model = graphicsObject.getModel();
		if (model == null)
		{
			log.debug("recolorProjectile returned null!");
			return;
		}
		modelRecolorer.applyColors(graphicsObject.getId(), "GraphicsObject", model, config.lava() != LavaOptions.Default);
	}

	public void recolorProjectile(Projectile projectile)
	{
		Model model = projectile.getModel();
		if (model == null)
		{
			log.debug("recolorProjectile returned null!");
			return;
		}
		modelRecolorer.applyColors(projectile.getId(), "Projectile", model, true);
	}

	private void forceReload()
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invokeLater(() -> client.setGameState(GameState.LOADING));
		}
	}

	public void recolorGameObject(GameObject gameObject)
	{
		Renderable renderable = gameObject.getRenderable();
		Model model = verifyModel(renderable);
		if (model == null)
		{
			log.debug("recolorGameObject returned null!");
			return;
		}
		recordedModels.add(model);
		sceneIDs.add(model.getSceneId());
		if (THE_BOULDER.contains(gameObject.getId()))
		{
			modelRecolorer.applyColors(gameObject.getId(), "GameObject", model, config.boulder() != BoulderTypes.Default);
		}
		// Some objects have many different sets of colors on their faces.
		// This makes it non-viable to store *all* variants of their facecolors in a file.
		// Walls and upper level floors in particular have this problem.
		// This circumvents finding colors in a cache and instead applies them directly to the model.
		// As a result, this requires forcing the client into the loading state to restore the original values.
		else if ((gameObject.getId() <= 30992 && gameObject.getId() >= 30990))
		{
			modelRecolorer.applyColorsDirectly(model, 0);
		}
		else if (UPPER_LEVEL_FLOOR.contains(gameObject.getId()))
		{
			modelRecolorer.applyColorsDirectly(model, gameObject.getId());
		}
		else
		{
			modelRecolorer.applyColors(gameObject.getId(), "GameObject", model, true);
		}
		recordedModels.add(model);
		sceneIDs.add(model.getSceneId());
		model.setSceneId(0);
	}

	public void recolorGroundObject(GroundObject groundObject)
	{
		Renderable renderable = groundObject.getRenderable();
		Model model = verifyModel(renderable);
		if (model == null)
		{
			log.debug("recolorGroundObject returned null!");
			return;
		}

		modelRecolorer.applyColors(groundObject.getId(), "GroundObject", model, true);
		addToLists(model);
		model.setSceneId(0);

	}

	public void recolorWallObject(WallObject wallObject)
	{
		Renderable renderable = wallObject.getRenderable1();
		Model model = verifyModel(renderable);
		Renderable renderable2 = null;
		Model model2 = null;
		// wallObjects can have 2 renderable models, not distinguishable and no good way to find them
		try
		{
			renderable2 = wallObject.getRenderable2();
			model2 = verifyModel(renderable2);
		}
		catch (NullPointerException ignore)
		{
		}
		if (model2 != null)
		{

			modelRecolorer.applyColorsDirectly(model2, 0);
			recordedModels.add(model2);
			sceneIDs.add(model2.getSceneId());
			model2.setSceneId(0);
		}
		if (model == null)
		{
			return;
		}
		modelRecolorer.applyColorsDirectly(model, 0);
		recordedModels.add(model);
		sceneIDs.add(model.getSceneId());
		model.setSceneId(0);
	}

	public void recolorNPC(NPC npc)
	{
		if (npc.getModel() == null)
		{
			log.debug("recolorNPC returned null! - NPC");
			return;
		}
		if (npc.getId() == LAVA_BEAST)
		{
			modelRecolorer.applyColors(npc.getId(), "NPC", npc.getModel(), config.lavaBeast() != GlobalColor.Default);
		}
		else
		{
			modelRecolorer.applyColors(npc.getId(), "NPC", npc.getModel(), config.boulder() != BoulderTypes.Default);
		}
		addToLists(npc.getModel());
		npc.getModel().setSceneId(0);
	}

	private void resetSceneIDs()
	{
		int size = sceneIDs.size();
		for (int i = 0; i < size; i++)
		{
			recordedModels.get(i).setSceneId(sceneIDs.get(i));
		}
		recordedModels.clear();
		sceneIDs.clear();
	}

	private Model verifyModel(Renderable renderable)
	{
		if (renderable instanceof Model)
		{
			return (Model) renderable;
		}
		else
		{
			try
			{
				Model model = renderable.getModel();
				if (model == null)
				{
					log.debug("verifyModel returned null!");
					return null;
				}
				return model;
			}
			catch (NullPointerException e)
			{
				return null;
			}
		}
	}

	private void recolorAllNPCs()
	{
		for (NPC npc : recordedNpcs)
		{
			recolorNPC(npc);
		}
	}

	public void clearAll()
	{
		for (GameObject g : recordedGameObjects)
		{
			Renderable renderable = g.getRenderable();
			Model model = verifyModel(renderable);
			if (model == null)
			{
				log.debug("clearAll returned null! - GameObject");
			}
			modelRecolorer.applyColors(g.getId(), "GameObject", model, false);
		}

		for (NPC n : recordedNpcs)
		{
			Renderable renderable = n.getModel();
			Model model = verifyModel(renderable);
			if (model == null)
			{
				log.debug("clearAll returned null! - NPC");
			}

			modelRecolorer.applyColors(n.getId(), "NPC", model, false);
		}

		for (GroundObject g : recordedGroundObjects)
		{
			Renderable renderable = g.getRenderable();
			Model model = verifyModel(renderable);
			if (model == null)
			{
				log.debug("clearAll returned null! - GroundObject");
			}

			modelRecolorer.applyColors(g.getId(), "GroundObject", model, false);
		}

		for (Projectile g : recordedProjectiles)
		{

			modelRecolorer.applyColors(g.getId(), "Projectile", g.getModel(), false);
		}

		for (GraphicsObject g : recordedGraphicsObjects)
		{

			modelRecolorer.applyColors(g.getId(), "GraphicsObject", g.getModel(), false);
		}

		resetSceneIDs();

		//freeing the stored data.
		recordedGameObjects.clear();
		recordedGroundObjects.clear();
		recordedNpcs.clear();
		recordedProjectiles.clear();
		recordedGraphicsObjects.clear();
	}

	// recolors all GameObjects, GroundObjects, NPCs (including Hunllef) and Projectiles to their desired colors, if they are stored in the corresponding list.
	// differentiating between NPCs and tornados, even though tornados are technically a NPC
	// Can't really use this one for VM because of the way walls are handled :(
	// public void recolorAll()

	private void addToLists(Model model)
	{
		if (!recordedModels.contains(model))
		{
			recordedModels.add(model);
		}

		if (!sceneIDs.contains(model.getSceneId()))
		{
			sceneIDs.add(model.getSceneId());
		}
	}

	private TileObject findTileObject(int z, int x, int y, int id)
	{
		Scene scene = client.getScene();
		Tile[][][] tiles = scene.getTiles();
		final Tile tile = tiles[z][x][y];
		if (tile == null)
		{
			return null;
		}

		final GameObject[] tileGameObjects = tile.getGameObjects();

		for (GameObject object : tileGameObjects)
		{
			if (object.getId() == id)
			{
				return object;
			}
		}

		return null;
	}

	private int createColorMenu(int idx, String target, int id)
	{
		String name = "null";
		if (id == LAVA_BEAST)
		{
			name = "Lava Beast";
		}
		if (THE_BOULDER.contains(id) || THE_BOULDER_NPCS.contains(id))
		{
			name = "Boulder";
		}
		if (WALL_OBJECTS.contains(id))
		{
			name = "walls";
		}
		if (LOWER_LEVEL_FLOOR.contains(id) || UPPER_LEVEL_FLOOR.contains(id))
		{
			name = "Stuff";
		}
		List<Color> colors = List.of(config.boulderColor(), config.wallColor(), config.lavaColor(), config.platformColor(), config.lowerLevelFloorColor(), config.upperLevelFloorColor(), config.lavaBeastColor());
		//Dirty remove dupes
		colors = new ArrayList<>(new HashSet<>(colors));
		// add a few default colors
		for (Color default_ : new Color[]{Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.MAGENTA})
		{
			if (colors.size() < 5 && !colors.contains(default_))
			{
				colors.add(default_);
			}
		}

		MenuEntry parent = client.createMenuEntry(idx--)
			.setOption("Recolor")
			.setTarget(target)
			.setType(MenuAction.RUNELITE);
		Menu submenu = parent.createSubMenu();
		int yeet = 0;
		for (final Color c : colors)
		{
			submenu.createMenuEntry(yeet)
					.setOption(ColorUtil.prependColorTag("Set color", c))
					.setType(MenuAction.RUNELITE)
					.onClick(e -> updateConfig(id, c));
			yeet++;
		}
		submenu.createMenuEntry(yeet)
			.setOption("Pick color")
			.setType(MenuAction.RUNELITE)
			.onClick(e -> SwingUtilities.invokeLater(() ->
			{
				RuneliteColorPicker colorPicker = colorPickerManager.create(SwingUtilities.windowForComponent((Applet) client),
					getObjectCurrentColor(id), "Recolor", true);
				colorPicker.setOnClose(c ->
					clientThread.invokeLater(() ->
						updateConfig(id, c)));
				colorPicker.setVisible(true);
			}));

		return idx;
	}

	private Color getObjectCurrentColor(int id)
	{
		if (WALL_OBJECTS.contains(id))
		{
			return config.wallColor();
		}
		else if (THE_BOULDER.contains(id) || THE_BOULDER_NPCS.contains(id))
		{
			return config.boulderColor();
		}
		else if (id == LAVA_BEAST)
		{
			return config.lavaBeastColor();
		}
		else
		{
			return Color.RED;
		}
	}

	private void updateConfig(int id, Color c)
	{
		if (WALL_OBJECTS.contains(id))
		{
			configManager.setConfiguration(CONFIG_GROUP, "wallCustomColor", c);
		}
		else if (THE_BOULDER.contains(id) || THE_BOULDER_NPCS.contains(id))
		{
			configManager.setConfiguration(CONFIG_GROUP, "BoulderCustomColor", c);
		}
		else if (id == LAVA_BEAST)
		{
			configManager.setConfiguration(CONFIG_GROUP, "lavaBeastCustomColor", c);
		}
	}

	@Provides
	VMRecolorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(VMRecolorConfig.class);
	}
}

package com.VMRecolor;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(VMRecolorPlugin.class);
		RuneLite.main(args);
	}
}
