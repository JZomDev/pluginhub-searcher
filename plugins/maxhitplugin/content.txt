package com.maxhit;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MaxHitPlugin.class);
		RuneLite.main(args);
	}
}
package com.maxhit;


import com.google.inject.Provides;
import com.maxhit.sets.DharokSet;
import com.maxhit.sets.EliteVoidSet;
import com.maxhit.sets.ObsidianSet;
import com.maxhit.sets.VoidSet;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.http.api.item.ItemStats;
import net.runelite.http.api.item.ItemEquipmentStats;

import javax.inject.Inject;
import java.util.HashMap;

import static com.maxhit.AttackStyle.*;

@Slf4j
@PluginDescriptor(
		name = "Max Hit",
		description = "Displays current max hit",
		enabledByDefault = true,
		tags = {"max, hit, spec, pvp, magic, spell, combat"}
)


public class MaxHitPlugin extends Plugin
{
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ItemManager itemManager;
	@Inject
	private MaxHitOverlay myOverlay;
	@Inject
	private MaxHitConfig config;

	@Provides
	MaxHitConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(MaxHitConfig.class);
	}

	public static int booleanToInt(boolean value) { return value ? 1 : 0;}
	final int MELEE = 0;
	final int RANGED = 1;
	final int MAGE = 2;
	final int TRIDENT = 3;
	public ItemContainer equippedItems;
	public Item[] inventoryItems;
	private final VoidSet voidSetChecker = new VoidSet();
	private final EliteVoidSet eliteVoidSetChecker = new EliteVoidSet();
	private final DharokSet dharokSetChecker = new DharokSet();
	private final ObsidianSet obsidianSetChecker = new ObsidianSet();
	private final HashMap<String, Integer> equippedItemIds = new HashMap<String, Integer>();
	private final HashMap<String, InventoryWeapon> inventoryWeaponsHashMap = new HashMap<>();
	private final HashMap<String, EquipmentInventorySlot> slotNametoIdMap = new HashMap<String, EquipmentInventorySlot>() {{
		put("head", EquipmentInventorySlot.HEAD);
		put("cape", EquipmentInventorySlot.CAPE);
		put("amulet", EquipmentInventorySlot.AMULET);
		put("weapon", EquipmentInventorySlot.WEAPON);
		put("body", EquipmentInventorySlot.BODY);
		put("shield", EquipmentInventorySlot.SHIELD);
		put("legs", EquipmentInventorySlot.LEGS);
		put("gloves", EquipmentInventorySlot.GLOVES);
		put("boots", EquipmentInventorySlot.BOOTS);
		put("ring", EquipmentInventorySlot.RING);
		put("ammo", EquipmentInventorySlot.AMMO);
	}};
	public HashMap<String, InventoryWeapon> map;

	public double equipedWeaponMaxHit = 0.0;

    @Override
	public void startUp() throws Exception {
		overlayManager.add(myOverlay);

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invoke(this::start);
		}

	}
	private void start() {
		calculateEquippedWeaponMaxHit();
	}

	@Override
	public void shutDown() throws Exception {
		overlayManager.remove(myOverlay);
		equippedItems = null;
		inventoryItems = null;
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged event) {
		final ItemContainer itemContainer = event.getItemContainer();
		//If equipment is changed, recalculate
		if (event.getContainerId() == InventoryID.EQUIPMENT.getId()) {
			calculateEquippedWeaponMaxHit();
			return;
		}
		if (event.getContainerId() != InventoryID.INVENTORY.getId()) {
			return;
		}
		inventoryItems = itemContainer.getItems();
		map = equipableItems();
	}

	//Update on stat change
	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		Skill[] skills = {
				Skill.STRENGTH, Skill.RANGED, Skill.MAGIC, Skill.HITPOINTS
		};
		for (Skill skill: skills)
		{
			if(event.getSkill() != skill) {
				continue;
			}
			calculateEquippedWeaponMaxHit();
			return;
		}

	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarpId() == VarPlayer.ATTACK_STYLE
				|| event.getVarbitId() == Varbits.EQUIPPED_WEAPON_TYPE
				|| event.getVarbitId() == Varbits.DEFENSIVE_CASTING_MODE)
		{
			final int currentAttackStyleVarbit = client.getVarpValue(VarPlayer.ATTACK_STYLE);
			final int currentEquippedWeaponTypeVarbit = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
			final int currentCastingModeVarbit = client.getVarbitValue(Varbits.DEFENSIVE_CASTING_MODE);

            updateAttackStyle(currentEquippedWeaponTypeVarbit, currentAttackStyleVarbit,
					currentCastingModeVarbit);
		}
	}

	public void getEquippedItems()
	{
		final ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);
		if (equipment != null)
		{
			equippedItems = equipment;
			map = equipableItems();
		}
	}

	public void getEquippedItemsIds() {
		if (equippedItems == null)
			return;
		for (String name: slotNametoIdMap.keySet())
		{
			Item item = equippedItems.getItem(slotNametoIdMap.get(name).getSlotIdx());
			if (item == null)
			{
				equippedItemIds.put(name, -1);
				continue;
			}
			equippedItemIds.put(name, item.getId());
		}
	}

	//Info for all styles:
	//Item set bonus, combat type, prayer bonus, weapon, attack style
	private AttackStyle attackStyle;

	private double getEffectiveStrength(int strengthLevel, double prayerBonus, int styleBonus, int combatType) {
		return Math.floor((Math.floor(strengthLevel * prayerBonus) + styleBonus + 8) * voidBonus(combatType));
	}

	private double getBaseDamage(double effectiveStrength, int strengthBonus) {
		return Math.floor(0.5 + (effectiveStrength * (strengthBonus + 64) / 640));
	}
	private double getBonusDamage(int baseDamage, double specialBonus) {
		return Math.floor(baseDamage * specialBonus);
	}
	private int getWeaponType(String name) {
		if (name.contains("bow") ||
				name.contains("knif") ||
				name.contains("dart") ||
				name.contains("throw") ||
				name.contains("xil-ul") ||
				name.contains("chompa") ||
				name.contains("blowpipe") ||
				name.contains("ballista")) {
			return RANGED;
		}
		if (name.contains("rident")) {
			return TRIDENT;
		}
		return MELEE;
	}

	//Combat type of equipped weapon (Melee, ranged, magic, other)
	public int combatType() {

		if (attackStyle == ACCURATE || attackStyle == AGGRESSIVE ||
				attackStyle == CONTROLLED || attackStyle == DEFENSIVE) {
			return MELEE;
		}
		if (attackStyle.getName().contains("ang")) {
			return RANGED;
		}
		if (attackStyle.getName().contains("Casting")) {
			return MAGE;
		}
		return -1;
	}

	//Prayer Bonus
	public double getMeleePrayerBonus() {
		//Melee prayers
		if (client.isPrayerActive(Prayer.BURST_OF_STRENGTH)) {
			return 1.05;
		}
		if (client.isPrayerActive(Prayer.SUPERHUMAN_STRENGTH)) {
			return 1.10;
		}
		if (client.isPrayerActive(Prayer.ULTIMATE_STRENGTH)) {
			return 1.15;
		}
		if (client.isPrayerActive(Prayer.CHIVALRY)) {
			return 1.18;
		}
		if (client.isPrayerActive(Prayer.PIETY)) {
			return 1.23;
		}
		return 1.0;
	}

	public double getRangedPrayerBonus() {
		//Ranged prayers
		if (client.isPrayerActive(Prayer.SHARP_EYE)) { return 1.05; }
		if (client.isPrayerActive(Prayer.HAWK_EYE)) { return 1.1; }
		if (client.isPrayerActive(Prayer.EAGLE_EYE)) { return 1.15; }
		if (client.isPrayerActive(Prayer.RIGOUR)) { return 1.23; }
		return 1;
	}

	//Attack style (Aggressive, Defensive, etc..) Doesn't differentiate
	//between accurate and rapid for ranged, so use isRangingAccurate() for that

	private void updateAttackStyle(int equippedWeaponType, int attackStyleIndex, int castingMode)
	{
		AttackStyle[] attackStyles = WeaponType.getWeaponType(equippedWeaponType).getAttackStyles();
		if (attackStyleIndex < attackStyles.length)
		{
			attackStyle = attackStyles[attackStyleIndex];
			if (attackStyle == null)
			{
				attackStyle = OTHER;
			}
			else if ((attackStyle == CASTING) && (castingMode == 1))
			{
				attackStyle = DEFENSIVE_CASTING;
			}
		}
	}

	//Using accurate ranging style, gives +3 boost to style bonus
	public boolean isRangingAccurate() {

		//if 0 for ranged weapons, style is accurate
		int styleNum = client.getVarpValue(VarPlayer.ATTACK_STYLE);
		return (attackStyle.name().contains("ang") && styleNum == 0);
	}

	public int getStyleBonus() {

		if (attackStyle.name().equalsIgnoreCase("Aggressive")) { return 3; }
		if (attackStyle.name().equalsIgnoreCase("Controlled")) { return 1; }
		if (isRangingAccurate()) { return 3; }
		if (attackStyle.name().equalsIgnoreCase("Longrange")) { return 1; }
		return 0;
	}
	//MELEE FACTORS -- Get all factors that specifically affect melee max hit:
	//Boosted strength level, equipment bonus, attack style bonus from all styles section

	public int getEquipmentBonus(int style) {
		int bonus = 0;
		//get str bonus of worn equipment
		for (int id : equippedItemIds.values()) {
			final ItemStats stats = itemManager.getItemStats(id, false);
			if (stats == null) {
				continue;
			}
			final ItemEquipmentStats currentEquipment = stats.getEquipment();
			switch (style) {
				case MELEE:
					bonus += currentEquipment.getStr();
					break;
				case RANGED:
					bonus += currentEquipment.getRstr();
					break;
			}
		}
		return bonus;
	}

	public int getMeleeStrengthBonus() {
		return getEquipmentBonus(MELEE);
	}

	public int getRangedStrengthBonus() {
		if (itemManager.getItemComposition(equippedItemIds.get("weapon")).isStackable()) {
			return getEquipmentBonus(RANGED) - itemManager.getItemStats(equippedItemIds.get("ammo"), false).getEquipment().getRstr();
		}
		return getEquipmentBonus(RANGED);
	}


	public void calculateEquippedWeaponMaxHit() {
		getEquippedItems();
		getEquippedItemsIds();
		equipedWeaponMaxHit = maxHitBase(combatType());
	}

	private double getMaxMeleePrayerBonus(int prayerLevel, int defenseLevel) {
		if (prayerLevel < 13) {
			return 1.05; // Burst of Strength
		} else if (prayerLevel < 31) {
			return 1.1; // Superhuman Strength
		} else if (prayerLevel < 60) {
			return 1.15; // Ultimate Strength
		} else if (prayerLevel < 70 && defenseLevel >= 65) {
			return 1.18; // Chivalry
		} else if (prayerLevel >= 70 && defenseLevel >= 70) {
			return 1.23; // Piety
		}
		return 1;
	}

	private double getMaxRangedPrayerBonus(int prayerLevel, int defenseLevel) {
		if (prayerLevel < 8) {
			return 1.05; // Sharp Eye
		} else if (prayerLevel < 26) {
			return 1.1; // Hawk Eye
		} else if (prayerLevel < 74) {
			return 1.15; // Eagle Eye
		} else if (defenseLevel >= 70) {
			return 1.23; // Rigour
		}
		return 1;
	}

	public HashMap equipableItems() {
		inventoryWeaponsHashMap.clear();
		if (inventoryItems == null) {
			return null;
		}
		if (inventoryItems.length == 0) {
			return null;
		}

		if (equippedItemIds.size() == 0)
			return null;

		//MAX HIT FACTORS
		int style = 3; //have to assume, we can't actually get this value
		double prayerBonus = 1;
		int strengthBonus = 0;
		int strengthOrRangedLevel = 0;
		int defenseLevel = client.getRealSkillLevel(Skill.DEFENCE);
		int prayerLevel = client.getRealSkillLevel(Skill.PRAYER);
		double effectiveStrength = 0.0;
		int equippedWeaponStr = 0;
		int equippedWeaponRstr = 0;
		int equippedShieldStr = 0;
		int equippedShieldRstr = 0;
		int equippedAmmoRstr = 0;
		for (Item item : inventoryItems) {
			int ID = item.getId();
			if (ID == -1) {
				continue;
			}
			ItemStats itemStats = itemManager.getItemStats(ID, false);
			if (itemStats == null) {
				continue;
			}
			if (!itemStats.isEquipable()) {
				continue;
			}
			ItemEquipmentStats itemEquipmentStats = itemStats.getEquipment();
			if (itemEquipmentStats.getSlot() != 3) {
				continue;
			}

			boolean isWeaponEquipped = equippedItemIds.get("weapon") != -1;
			boolean isShieldEquipped = equippedItemIds.get("shield") != -1;
			boolean isAmmoEquipped = equippedItemIds.get("ammo") != -1;
			if (isWeaponEquipped) {
				equippedWeaponStr = itemManager.getItemStats(equippedItemIds.get("weapon"), false).getEquipment().getStr();
				equippedWeaponRstr = itemManager.getItemStats(equippedItemIds.get("weapon"), false).getEquipment().getRstr();
			}
			if (isShieldEquipped) {
				equippedShieldStr = itemManager.getItemStats(equippedItemIds.get("shield"), false).getEquipment().getStr();
				equippedShieldRstr = itemManager.getItemStats(equippedItemIds.get("shield"), false).getEquipment().getRstr();
			}
			if (isAmmoEquipped) {
				equippedAmmoRstr = itemManager.getItemStats(equippedItemIds.get("ammo"), false).getEquipment().getRstr();
			}
			String name = client.getItemDefinition(ID).getName();
			boolean twoHanded = itemEquipmentStats.isTwoHanded();
			int weaponType = getWeaponType(name);
			inventoryWeaponsHashMap.put(name, new InventoryWeapon());
			inventoryWeaponsHashMap.get(name).ID = ID;
			inventoryWeaponsHashMap.get(name).name = name;
			inventoryWeaponsHashMap.get(name).isTwoHanded = twoHanded;
			inventoryWeaponsHashMap.get(name).weaponType = weaponType;
			//Invent weapon is melee
			switch (weaponType) {
				case MELEE:
					inventoryWeaponsHashMap.get(name).strBonus = itemManager.getItemStats(ID, false).getEquipment().getStr();
					strengthOrRangedLevel = strengthLevel();
					strengthBonus += getMeleeStrengthBonus();
					prayerBonus = getMaxMeleePrayerBonus(prayerLevel, defenseLevel);
					//invent weapon is 2 handed, take away shield bonus
					if (twoHanded) {
						strengthBonus -= equippedShieldStr * booleanToInt(isShieldEquipped);
					}
					strengthBonus -= equippedWeaponStr * booleanToInt(isWeaponEquipped);
					strengthBonus += inventoryWeaponsHashMap.get(name).strBonus;
					break;
				//Invent weapon is ranged
				case RANGED:
					inventoryWeaponsHashMap.get(name).strBonus = itemManager.getItemStats(ID, false).getEquipment().getRstr();
					strengthOrRangedLevel = rangedLevel();
					strengthBonus += getRangedStrengthBonus();
					prayerBonus = getMaxRangedPrayerBonus(prayerLevel, defenseLevel);
					//If inventory weapon is stackable (throwable)
					if (itemManager.getItemComposition(ID).isStackable()) {
						strengthBonus -= equippedAmmoRstr * booleanToInt(isAmmoEquipped);
					}
					if(twoHanded) {
						strengthBonus -= equippedShieldRstr * booleanToInt(isShieldEquipped);
					}
					strengthBonus -= equippedWeaponRstr * booleanToInt(isWeaponEquipped);
					strengthBonus += inventoryWeaponsHashMap.get(name).strBonus;
					// get ranged prayer bonus
					prayerBonus = getMaxRangedPrayerBonus(prayerLevel, defenseLevel);
					inventoryWeaponsHashMap.get(name).strBonus = itemEquipmentStats.getRstr();
					break;

				//Special case: Trident
				case TRIDENT:
					double maxTrident;
					double magicLevel = magicLevel();
					if (name.contains("swamp")) {
						maxTrident = Math.floor(magicLevel / 3) - 2;
						inventoryWeaponsHashMap.get(name).maxHitBase = Math.floor(maxTrident * magicBonus());
						continue;
					}
					if (name.contains("seas")) {
						maxTrident = Math.floor(magicLevel / 3) - 5;
						inventoryWeaponsHashMap.get(name).maxHitBase = Math.floor(maxTrident * magicBonus());
						continue;
					}
					break;
			}

			// have to assume using the best prayer for level
			effectiveStrength = getEffectiveStrength(strengthOrRangedLevel, prayerBonus, style, weaponType);
			double baseMax = getBaseDamage(effectiveStrength, strengthBonus);
			inventoryWeaponsHashMap.get(name).maxHitBase = baseMax * setBonus(combatType());
			inventoryWeaponsHashMap.get(name).maxHitSpec = maxHitSpec(name, baseMax);
		}
		return inventoryWeaponsHashMap;
	}

	public double voidBonus(int combatType) {
		switch(combatType) {
			case MELEE:
				if (voidSetChecker.isWearingVoid(MELEE)) {
					return 1.1;
				}
				if (eliteVoidSetChecker.isWearingEliteVoid(MELEE)) {
					return 1.1;
				}
				break;
			case RANGED:
				//Ranged sets
				if (voidSetChecker.isWearingVoid((RANGED))) {
					return 1.1;
				}
				if (eliteVoidSetChecker.isWearingEliteVoid(RANGED)) {
					return 1.125;
				}
				break;
			case MAGE:
				if (voidSetChecker.isWearingVoid(MAGE)) {
					return 1.0;
				}
				if (eliteVoidSetChecker.isWearingEliteVoid(MAGE)) {
					return 1.025;
				}
				break;
			default:
				return 1;
		}
		return 1;
	}
	public double setBonus(int combatType) {
		//Melee sets
		if (combatType == MELEE) {
			if (dharokSetChecker.isWearingSet()) {
				double baseHitpoints = client.getRealSkillLevel(Skill.HITPOINTS);
				double currentHitpoints = client.getBoostedSkillLevel(Skill.HITPOINTS);
				return 1 + (((baseHitpoints - currentHitpoints)/100) * baseHitpoints/100);
			}

			if (obsidianSetChecker.isWearingMaxSet()) {
				return 1.32;
			}
			if (obsidianSetChecker.isWearingWeaponAndNecklace()) {
				return 1.2;
			}
			if (obsidianSetChecker.isWearingSet()) {
				return 1.1;
			}
		}
		//Magic sets applied directly in max hit calculation
		return 1;
	}
	//Weapon name
	public String weaponName() {

		final ItemContainer container = client.getItemContainer(InventoryID.EQUIPMENT);
		if (container == null) {
			return "No weapon or items";
		}
		Item[] items = container.getItems();
		if (items.length >= EquipmentInventorySlot.WEAPON.getSlotIdx()) {
			final Item weapon = items[EquipmentInventorySlot.WEAPON.getSlotIdx()];
			if (weapon.getId() > 512) {
				int weaponID = weapon.getId();
				return client.getItemDefinition(weaponID).getName();
			}
		}
		return "no weapon";
	}
	//MAGIC FACTORS -- An option in config menu, not based on equipped weapon
	//Get all factors that specifically affect magic max hit:
	//Boosted magic level (for trident), spell, equipment bonus

	//Visible levels
	public int strengthLevel() {return client.getBoostedSkillLevel(Skill.STRENGTH);}
	public int magicLevel() { return client.getBoostedSkillLevel(Skill.MAGIC); }
	public int rangedLevel() { return client.getBoostedSkillLevel(Skill.RANGED); }


	public int spellDamage() {
		MagicSpell spell = config.spellChoice();
		if (spell.element == Element.GOD && config.applyCharge()) {
			return 30;
		}
		return spell.damage;
	}
	public boolean tomeOfFireEquipped() {
		return equippedItemIds.get("shield") == ItemID.TOME_OF_FIRE;
	}

	//Magic equipment damage bonus, includes void bonus
	//returns % damage increase
	public double magicBonus() {
		double magicEquipmentBonus = 0;

		int[] ids = client.getLocalPlayer().getPlayerComposition().getEquipmentIds();
		for (int x : ids) {
			if (x > 512) {
				int id = x - 512;
				final ItemStats stats = itemManager.getItemStats(id, false);
				final ItemEquipmentStats currentEquipment = stats.getEquipment();
				magicEquipmentBonus += currentEquipment.getMdmg();

			}
		}
		if (eliteVoidSetChecker.isWearingEliteVoid(MAGE)) {
			magicEquipmentBonus += 2.5;
		}
		if (weaponName().contains("moke battle") && config.spellChoice().spellbook == Spellbook.NORMAL) {
			magicEquipmentBonus += 10;
		}
		return 1 + (magicEquipmentBonus/100);
	}

	//RANGED FACTORS -- Get all factors that specifically affect ranged max hit:
	//Boosted ranged level, equipment bonus, attack style bonus from all styles section

	//Visible ranged level

	public String ammoName() {
		Item[] items = client.getItemContainer(InventoryID.EQUIPMENT).getItems();
		if (items.length == 14) {
			final Item ammo = items[EquipmentInventorySlot.AMMO.getSlotIdx()];
			int ammoID = ammo.getId();
			if (ammoID != -1) {
				return client.getItemDefinition(ammoID).getName();
			}
		}
		return "None";
	}
	//MAX HIT CALCULATIONS -- including special attack
	//Does not account for special cases such as
	//slayer, twisted bow, wilderness weapons, etc.

	//Max hit base for melee and ranged, as well as tridents
	//Displayed by "Max Hit:" overlay

	public double maxHitBase(int combatType) {
		int style = getStyleBonus();
		double pray = 0.0;
		double setBonus = setBonus(combatType());
		int equipment = 0;
		int strengthOrRangedLevel = 0;
		switch(combatType) {
			case MELEE:
				strengthOrRangedLevel = strengthLevel();
				pray = getMeleePrayerBonus();
				equipment = getMeleeStrengthBonus();
				break;
			case RANGED:
				strengthOrRangedLevel = rangedLevel();
				pray = getRangedPrayerBonus();
				equipment = getRangedStrengthBonus();
				break;
			//Special case: Trident
			case TRIDENT:
				double maxTrident;
				double magicLevel = magicLevel();
				if (weaponName().contains("swamp")) {
					maxTrident = Math.floor(magicLevel / 3) - 2;
					return Math.floor(maxTrident * magicBonus());
				}
				if (weaponName().contains("seas")) {
					maxTrident = Math.floor(magicLevel / 3) - 5;
					return Math.floor(maxTrident * magicBonus());
				}
				break;
		}
		//Actual calculation for base damage (base damage refers to hit without special attack
		double effectiveStrengthLevel = getEffectiveStrength(strengthOrRangedLevel, pray, style, combatType());
		double baseMax = Math.floor((effectiveStrengthLevel * (equipment + 64) / 640) + 0.5);
		return Math.floor(baseMax * setBonus);
	}

	//Max hit calculation for magic
	//Displayed by "Max Magic Hit:" overlay
	public double maxMagicHitBase() {
		if (config.showMagic()) {
			int spellDamage = spellDamage();
			double magicEquipment = magicBonus();

			double base = spellDamage * magicEquipment;
			if (config.spellChoice().element == Element.FIRE && tomeOfFireEquipped()) {
				base = Math.floor(base) * 1.5;
			}
			return base;
		}
		return 0;
	}

	/**still need to add mage spec (nightmare staff). need to find documentation on formula**/
	//Returns -1 if special attack does not affect max hit
	//Displayed by "Max Special:" overlay
	public double maxHitSpec(String weaponName, double maxHitBase) {

		if (weaponName.contains("rossbo") && ammoName().contains("(e)")) {
			if (ammoName().contains("iamond")) {
				return Math.floor(maxHitBase) * 1.15;
			}
			if (ammoName().contains("nyx")) {
				return Math.floor(maxHitBase) * 1.2;
			}
			if (ammoName().contains("ragonstone")) {
				return Math.floor(maxHitBase) + Math.floor(rangedLevel() * .2);
			}
			if (ammoName().contains("pal")) {
				return Math.floor(maxHitBase) + Math.floor(rangedLevel() * .1);
			}
			if (ammoName().contains("earl")) {
				return Math.floor(maxHitBase) + Math.floor(rangedLevel() * .05);
			}
		}

		if (weaponName.equalsIgnoreCase("Saradomin sword")) {
			return 16 + (Math.floor(maxHitBase) * specialAttackDamageMultiplier(weaponName));
		}
		if (weaponName.equalsIgnoreCase("Granite hammer")) {
			return Math.floor(maxHitBase) + 5;
		}
		if (specialAttackDamageMultiplier(weaponName) != 1) {
			if (weaponName.contains("dagger") || weaponName.equalsIgnoreCase("Dark bow")) {
				return Math.floor(Math.floor(maxHitBase) * specialAttackDamageMultiplier(weaponName)) * 2;
			}
			return Math.floor(maxHitBase) * specialAttackDamageMultiplier(weaponName);
		}


		return -1;
	}

	public double specialAttackDamageMultiplier(String weaponName) {

		if (weaponName.contains("Abyssal dagger")) {
			return .85;
		}
		if (weaponName.equalsIgnoreCase("Dragon claws")) {
			return 1.98;
		}
		if (weaponName.contains("Dragon dagger")) {
			return 1.15;
		}
		if (weaponName.equalsIgnoreCase("Dragon halberd")) {
			return 1.1;
		}
		if (weaponName.equalsIgnoreCase("Dragon longsword")) {
			return 1.25;
		}
		if (weaponName.equalsIgnoreCase("Dragon mace")) {
			return 1.5;
		}
		if (weaponName.equalsIgnoreCase("Dragon sword")) {
			return 1.25;
		}
		if (weaponName.equalsIgnoreCase("Dragon warhammer")) {
			return 1.5;
		}
		if (weaponName.equalsIgnoreCase("Armadyl godsword")) {
			return 1.375;
		}
		if (weaponName.equalsIgnoreCase("Bandos godsword")) {
			return 1.21;
		}
		if (weaponName.equalsIgnoreCase("Saradomin godsword")) {
			return 1.1;
		}
		if (weaponName.equalsIgnoreCase("Saradomin sword")) {
			return 1.1; //also add + 16 for magic damage
		}
		if (weaponName.equalsIgnoreCase("Saradomin's blessed sword")) {
			return 1.25;
		}
		if (weaponName.equalsIgnoreCase("Zamorak Godsword")) {
			return 1.1;
		}
		if (weaponName.equalsIgnoreCase("Granite hammer")) {
			return 1; // add extra 5 damage
		}
		if (weaponName.equalsIgnoreCase("Barrelchest anchor")) {
			return 1.1;
		}
		if (weaponName.equalsIgnoreCase("Crystal halberd")) {
			return 1.1;
		}
		if (weaponName.contains("ballista")) {
			return 1.25;
		}
		if (weaponName.equalsIgnoreCase("Dragon crossbow")) {
			return 1.2;
		}
		if (weaponName.equalsIgnoreCase("Dark bow")) {
			if (ammoName().contains("Dragon arr")) {
				return 1.5;
			}
			return 1.3;
		}
		if (weaponName.equalsIgnoreCase("Toxic blowpipe")) {
			return 1.5;
		}
		return 1;
	}

	public NextMaxHit nextMaxHit() {
		NextMaxHit nextMaxHit = new NextMaxHit();
		if (combatType() == MELEE || combatType() == RANGED || weaponName().contains("rident")) {
			nextMaxHit = nextMaxHitBase();
		}
		else if (combatType() == MAGE) {
			nextMaxHit = nextMagicMaxHitBase();
		}
		return nextMaxHit;
	}

	private NextMaxHit nextMaxHitBase() {
		double baseMax = maxHitBase(combatType()) + 1;
		NextMaxHit reqs = new NextMaxHit();

		int style = getStyleBonus();
		double prayerBonus = 1.0;
		double setBonus = setBonus(combatType());
		int equipment = 0;
		int strengthOrRangedLevel = 0;

		switch(combatType()) {
			case MELEE:
				strengthOrRangedLevel = client.getRealSkillLevel(Skill.STRENGTH);
				equipment = getMeleeStrengthBonus();
				prayerBonus = getMeleePrayerBonus();
				break;
			case RANGED:
				strengthOrRangedLevel = rangedLevel();
				equipment = getRangedStrengthBonus();
				prayerBonus = getRangedPrayerBonus();
				break;
			case TRIDENT:
				final double magicLevel = magicLevel();
				double magicLevelNew = magicLevel;
				if (weaponName().contains("swamp")) {
					magicLevelNew = (Math.ceil(baseMax / magicBonus()) + 2) * 3;
				}
				if (weaponName().contains("seas")) {
					magicLevelNew = (Math.ceil(baseMax / magicBonus()) + 5) * 3;
				}

				final double magicDiff = magicLevelNew - magicLevel;

				reqs.magicLevels = (int) magicDiff;
				return reqs;
		}

		// Calculate effective strength level
		//double effectiveStrengthLevel = Math.floor((Math.floor(level * pray) + style + 8));
		double effectiveStrengthLevel = getEffectiveStrength(strengthOrRangedLevel, prayerBonus, style, combatType());

		// Remove non-void set effects
		if (!(voidSetChecker.isWearingVoid() || eliteVoidSetChecker.isWearingEliteVoid())) {
			baseMax /= setBonus;
		}

		final double equipmentNew = Math.ceil(((baseMax - 0.5) * 640 / effectiveStrengthLevel) - 64);
		final double equipmentDiff = equipmentNew - equipment;

		double reverseEffectiveStrengthLevel = Math.ceil((baseMax - 0.5) * 640 / (equipment + 64) - 8 - style);
		// Remove void set effects
		if (voidSetChecker.isWearingVoid() || eliteVoidSetChecker.isWearingEliteVoid()) {
			reverseEffectiveStrengthLevel /= setBonus;
		}

		final double levelNew = Math.ceil(reverseEffectiveStrengthLevel / prayerBonus);
		final double levelDiff = levelNew - strengthOrRangedLevel;

		final double prayerNew = reverseEffectiveStrengthLevel / strengthOrRangedLevel;
		final double prayerDiff = Math.ceil((prayerNew - prayerBonus) * 100);

		if (combatType() == MELEE) {
			reqs.strengthBonus = (int) equipmentDiff;
			reqs.strengthLevels = (int) levelDiff;
		}
		else if (combatType() == RANGED) {
			reqs.rangedBonus = (int) equipmentDiff;
			reqs.rangedLevels = (int) levelDiff;
		}
		reqs.prayerBoost = (int) prayerDiff;

		return reqs;
	}

	private NextMaxHit nextMagicMaxHitBase() {
		NextMaxHit nextMaxHit = new NextMaxHit();

		double base = maxMagicHitBase() + 1;
		if (config.spellChoice().element == Element.FIRE && tomeOfFireEquipped()) {
			base = Math.ceil(base / 1.5);
		}
		final double equipmentNew = base / spellDamage();
		final double equipmentDiff = Math.ceil((equipmentNew - magicBonus()) * 100);

		nextMaxHit.magicBonus = (int) equipmentDiff;

		return nextMaxHit;
	}
}
package com.maxhit;

import net.runelite.client.plugins.Plugin;

public class InventoryWeapon extends Plugin {
    String name;
    int weaponType;
    boolean isTwoHanded = false;
    int ID = -1;
    int strBonus = 0;
    double maxHitBase;
    double maxHitSpec;
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhit;

public enum AttackStyle
{
    ACCURATE("Accurate"),
    AGGRESSIVE("Aggressive"),
    DEFENSIVE("Defensive"),
    CONTROLLED("Controlled"),
    RANGING("Ranging"),
    LONGRANGE("Longrange"),
    CASTING("Casting"),
    DEFENSIVE_CASTING("Defensive Casting"),
    OTHER("Other");

    private final String name;

    AttackStyle(String name)
    {
        this.name = name;
    }

    public String getName()
    {
        return name;
    }
}


package com.maxhit;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("maxhit")
public interface MaxHitConfig extends Config {

	@ConfigItem(
			keyName = "maxhit",
			name = "Max Hit",
			description = "Display max hit in current setup",
			position = 1
	)
	default boolean maxHit() { return true; }

	@ConfigItem(
			keyName = "showNextMaxHit",
			name = "Calculate next max hit",
			description = "Mouse over the max hit to show the options to reach the next max hit " +
					"like strength/ranged levels, bonus or prayer boosts",
			position = 2
	)
	default boolean showNextMaxHit() { return true; }

	@ConfigItem(
			keyName = "showSpec",
			name = "Show Max Spec",
			description = "Show max spec in current setup",
			position = 3
	)
	default boolean showSpec() { return true; }

	@ConfigItem(
			keyName = "showMagic",
			name = "Show Magic",
			description = "Show max hit in current setup with selected spell",
			position = 4
	)
	default boolean showMagic() { return false; }


	@ConfigItem(
			keyName = "spellChoice",
			name = "Spell",
			description = "Choose spell to calculate max",
			position = 5
	)
	default MagicSpell spellChoice() { return MagicSpell.ICE_BARRAGE; }

	@ConfigItem(
			keyName = "applyCharge",
			name = "Apply Charge Spell",
			description = "Calculate max hit of spell using charge (god spells)",
			position = 6
	)
	default boolean applyCharge() { return false; }

	@ConfigItem(
			keyName = "inventoryWeapons",
			name = "Inventory Weapons' Max Hits",
			description = "Shows max hit of weapons in inventory. Assumes highest level prayer is used",
			position = 7
	)
	default boolean inventoryWeapons() { return false; }

	@ConfigItem(
			keyName = "inventoryWeaponsSpecial",
			name = "Inventory Weapons' Max Specs",
			description = "Shows max spec of weapons in inventory",
			position = 8
	)
	default boolean inventoryWeaponsSpecial() { return false; }

	@ConfigItem(
			keyName = "inventorySelectiveSpecial",
			name = "Inventory Selective Spec",
			description = "Shows spec max if weapon has spec, otherwise shows normal max. " +
					"Do not use with previous two options",
			position = 9
	)
	default boolean inventorySelectiveSpecial() { return false; }
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhit;
import com.google.common.collect.ImmutableMap;

import java.util.Map;

import static com.maxhit.AttackStyle.*;

enum WeaponType {
    TYPE_0(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
    TYPE_1(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
    TYPE_2(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
    TYPE_3(RANGING, RANGING, null, LONGRANGE),
    TYPE_4(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
    TYPE_5(RANGING, RANGING, null, LONGRANGE),
    TYPE_6(AGGRESSIVE, RANGING, CASTING, null),
    TYPE_7(RANGING, RANGING, null, LONGRANGE),
    TYPE_8(OTHER, AGGRESSIVE, null, null),
    TYPE_9(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
    TYPE_10(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
    TYPE_11(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
    TYPE_12(CONTROLLED, AGGRESSIVE, null, DEFENSIVE),
    TYPE_13(ACCURATE, AGGRESSIVE, null, DEFENSIVE),
    TYPE_14(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
    TYPE_15(CONTROLLED, CONTROLLED, CONTROLLED, DEFENSIVE),
    TYPE_16(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
    TYPE_17(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
    TYPE_18(ACCURATE, AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING),
    TYPE_19(RANGING, RANGING, null, LONGRANGE),
    TYPE_20(ACCURATE, CONTROLLED, null, DEFENSIVE),
    TYPE_21(ACCURATE, AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING),
    TYPE_22(ACCURATE, AGGRESSIVE, AGGRESSIVE, DEFENSIVE),
    TYPE_23(CASTING, CASTING, null, DEFENSIVE_CASTING),
    TYPE_24(ACCURATE, AGGRESSIVE, CONTROLLED, DEFENSIVE),
    TYPE_25(CONTROLLED, AGGRESSIVE, null, DEFENSIVE),
    TYPE_26(AGGRESSIVE, AGGRESSIVE, null, AGGRESSIVE),
    TYPE_27(ACCURATE, null, null, OTHER);

    private final AttackStyle[] attackStyles;

    private static final Map<Integer, WeaponType> weaponTypes;

    static {
        ImmutableMap.Builder<Integer, WeaponType> builder = new ImmutableMap.Builder<>();

        for (WeaponType weaponType : values()) {
            builder.put(weaponType.ordinal(), weaponType);
        }

        weaponTypes = builder.build();
    }

    WeaponType(AttackStyle... attackStyles) {
        this.attackStyles = attackStyles;
    }

    public AttackStyle[] getAttackStyles() {
        return attackStyles;
    }

    public static WeaponType getWeaponType(int id) {
        return weaponTypes.get(id);
    }
}

package com.maxhit;

import java.util.HashMap;
import java.util.Map;

enum Spellbook {
    NORMAL,
    ANCIENT,
}

enum Element {
    AIR,
    WATER,
    EARTH,
    FIRE,
    OTHER,
    GOD,
    SMOKE,
    SHADOW,
    BLOOD,
    ICE
}

public enum MagicSpell {
    //Most common spells
    ICE_BARRAGE(Spellbook.ANCIENT, Element.ICE, 30),
    BLOOD_BARRAGE(Spellbook.ANCIENT, Element.BLOOD, 29),
    FIRE_SURGE(Spellbook.NORMAL, Element.FIRE, 24),
    FLAMES_OF_ZAMORAK(Spellbook.NORMAL, Element.GOD, 20),
    CLAWS_OF_GUTHIX(Spellbook.NORMAL, Element.GOD, 20),
    SARADOMIN_STRIKE(Spellbook.NORMAL, Element.GOD, 20),
    IBAN_BLAST(Spellbook.NORMAL, Element.OTHER, 25),
    //Normal spells
    EARTH_SURGE(Spellbook.NORMAL, Element.EARTH, 23),
    WATER_SURGE(Spellbook.NORMAL, Element.WATER, 22),
    WIND_SURGE(Spellbook.NORMAL, Element.AIR, 21),
    FIRE_WAVE(Spellbook.NORMAL, Element.FIRE, 20),
    EARTH_WAVE(Spellbook.NORMAL, Element.EARTH, 19),
    WATER_WAVE(Spellbook.NORMAL, Element.WATER, 18),
    WIND_WAVE(Spellbook.NORMAL, Element.AIR, 17),
    FIRE_BLAST(Spellbook.NORMAL, Element.FIRE, 16),
    EARTH_BLAST(Spellbook.NORMAL, Element.EARTH, 15),
    WATER_BLAST(Spellbook.NORMAL, Element.WATER, 14),
    WIND_BLAST(Spellbook.NORMAL, Element.AIR, 13),
    FIRE_BOLT(Spellbook.NORMAL, Element.FIRE, 12),
    EARTH_BOLT(Spellbook.NORMAL, Element.EARTH, 11),
    WATER_BOLT(Spellbook.NORMAL, Element.WATER, 10),
    WIND_BOLT(Spellbook.NORMAL, Element.AIR, 9),
    FIRE_STRIKE(Spellbook.NORMAL, Element.FIRE, 8),
    EARTH_STRIKE(Spellbook.NORMAL, Element.EARTH, 6),
    WATER_STRIKE(Spellbook.NORMAL, Element.WATER, 4),
    WIND_STRIKE(Spellbook.NORMAL, Element.AIR, 2),
    //Ancient spells
    SHADOW_BARRAGE(Spellbook.ANCIENT, Element.SHADOW, 28),
    SMOKE_BARRAGE(Spellbook.ANCIENT, Element.SMOKE, 27),
    ICE_BLITZ(Spellbook.ANCIENT, Element.ICE, 26),
    BLOOD_BLITZ(Spellbook.ANCIENT, Element.BLOOD, 25),
    SHADOW_BLITZ(Spellbook.ANCIENT, Element.SHADOW, 24),
    SMOKE_BLITZ(Spellbook.ANCIENT, Element.SMOKE, 23),
    ICE_BURST(Spellbook.ANCIENT, Element.ICE, 22),
    BLOOD_BURST(Spellbook.ANCIENT, Element.BLOOD, 21),
    SHADOW_BURST(Spellbook.ANCIENT, Element.SHADOW, 19),
    SMOKE_BURST(Spellbook.ANCIENT, Element.SMOKE, 18),
    ICE_RUSH(Spellbook.ANCIENT, Element.ICE, 17),
    BLOOD_RUSH(Spellbook.ANCIENT, Element.BLOOD, 16),
    SHADOW_RUSH(Spellbook.ANCIENT, Element.SHADOW, 15),
    SMOKE_RUSH(Spellbook.ANCIENT, Element.SMOKE, 14),
    ;

    private static final Map<Spellbook, MagicSpell> SPELLBOOK = new HashMap<>();
    private static final Map<Element, MagicSpell> ELEMENT = new HashMap<>();
    private static final Map<Integer, MagicSpell> DAMAGE = new HashMap<>();

    static {
        for (MagicSpell m : values()) {
            SPELLBOOK.put(m.spellbook, m);
            ELEMENT.put(m.element, m);
            DAMAGE.put(m.damage, m);
        }
    }

    public final Spellbook spellbook;
    public final Element element;
    public final int damage;

    private MagicSpell(Spellbook spellbook, Element element, int damage) {
        this.spellbook = spellbook;
        this.element = element;
        this.damage = damage;
    }
}
package com.maxhit.sets;

import static net.runelite.api.ItemID.*;

public class VoidSet extends EquipmentSet {

    public VoidSet() {
        this.bodies = new int[]{
                VOID_KNIGHT_TOP_LOR,
                VOID_KNIGHT_TOP_L,
                VOID_KNIGHT_TOP_OR,
                VOID_KNIGHT_TOP
        };
        this.legs = new int[]{
                VOID_KNIGHT_ROBE_LOR,
                VOID_KNIGHT_ROBE_L,
                VOID_KNIGHT_ROBE_OR,
                VOID_KNIGHT_ROBE
        };
        this.gloves = new int[]{
                VOID_MELEE_HELM_LOR,
                VOID_MELEE_HELM_L,
                VOID_MELEE_HELM_OR,
                VOID_MELEE_HELM
        };
    }

    public boolean isWearingVoid() {
        this.heads = new int [] {
                VOID_MELEE_HELM_LOR,
                VOID_MELEE_HELM_L,
                VOID_MELEE_HELM_OR,
                VOID_MELEE_HELM,
                VOID_RANGER_HELM_LOR,
                VOID_RANGER_HELM_L,
                VOID_RANGER_HELM_OR,
                VOID_RANGER_HELM,
                VOID_MAGE_HELM_LOR,
                VOID_MAGE_HELM_L,
                VOID_MAGE_HELM_OR,
                VOID_MAGE_HELM
        };
        return isWearingSet();
    }
    public boolean isWearingVoid(int style) {
        final int[] meleeHeads = {
                VOID_MELEE_HELM_LOR,
                VOID_MELEE_HELM_L,
                VOID_MELEE_HELM_OR,
                VOID_MELEE_HELM
        };
        final int[] rangedHeads = {
                VOID_RANGER_HELM_LOR,
                VOID_RANGER_HELM_L,
                VOID_RANGER_HELM_OR,
                VOID_RANGER_HELM
        };
        final int[] mageHeads = {
                VOID_MAGE_HELM_LOR,
                VOID_MAGE_HELM_L,
                VOID_MAGE_HELM_OR,
                VOID_MAGE_HELM
        };
        if (style == 0) {
            this.heads = meleeHeads;
        } else if (style == 1) {
            this.heads = rangedHeads;
        } else {
            this.heads = mageHeads;
        }
        return isWearingSet();
    }
}

package com.maxhit.sets;

import static net.runelite.api.ItemID.*;

public class EliteVoidSet extends VoidSet {
    public EliteVoidSet() {
        this.bodies = new int[]{
                ELITE_VOID_TOP_LOR,
                ELITE_VOID_TOP_L,
                ELITE_VOID_TOP_OR,
                ELITE_VOID_TOP
        };
        this.legs = new int[]{
                ELITE_VOID_ROBE_LOR,
                ELITE_VOID_ROBE_L,
                ELITE_VOID_ROBE_OR,
                ELITE_VOID_ROBE
        };
    }

    public boolean isWearingEliteVoid() {
        return super.isWearingVoid();
    }
    public boolean isWearingEliteVoid(int style) {
        return super.isWearingVoid(style);
    }
}

package com.maxhit.sets;

import net.runelite.api.EquipmentInventorySlot;

import static net.runelite.api.ItemID.*;

public class ObsidianSet extends EquipmentSet {

    private int[] amulets = {
            BERSERKER_NECKLACE,
            BERSERKER_NECKLACE_OR
    };
    // This does not include the amulet
    public ObsidianSet() {
        this.heads = new int[] {
                OBSIDIAN_HELMET
        };
        this.bodies = new int[]{
                OBSIDIAN_PLATEBODY
        };

        this.legs = new int[] {
                OBSIDIAN_PLATELEGS
        };
        this.weapons = new int[] {
                TOKTZXILEK,
                TOKTZXILAK,
                TZHAARKETEM,
                TZHAARKETOM,
                TZHAARKETOM_T,
                TOKTZMEJTAL
        };
    }

    private boolean hasAmulet() {
        return hasItem(amulets, EquipmentInventorySlot.AMULET);
    }

    public boolean isWearingWeaponAndNecklace() {
        return hasWeapon() && hasAmulet();
    }

    public boolean isWearingMaxSet() {
        return isWearingSet() && hasAmulet();
    }

}

package com.maxhit.sets;

import static net.runelite.api.ItemID.*;

public class DharokSet extends EquipmentSet {
    public DharokSet() {
        this.heads = new int[] {
                DHAROKS_HELM,
                DHAROKS_HELM_100,
                DHAROKS_HELM_75,
                DHAROKS_HELM_50,
                DHAROKS_HELM_25,
        };
        this.bodies = new int[] {
                DHAROKS_PLATEBODY,
                DHAROKS_PLATEBODY_100,
                DHAROKS_PLATEBODY_75,
                DHAROKS_PLATEBODY_50,
                DHAROKS_PLATEBODY_25,
        };
        this.legs = new int[] {
                DHAROKS_PLATELEGS,
                DHAROKS_PLATELEGS_100,
                DHAROKS_PLATELEGS_75,
                DHAROKS_PLATELEGS_50,
                DHAROKS_PLATELEGS_25,
        };
        this.weapons = new int[] {
                DHAROKS_GREATAXE,
                DHAROKS_GREATAXE_100,
                DHAROKS_GREATAXE_75,
                DHAROKS_GREATAXE_50,
                DHAROKS_GREATAXE_25,
        };
    }
}

package com.maxhit.sets;

//Used for determining if the user is wearing a set

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;

import javax.inject.Inject;

public class EquipmentSet {
    @Inject
    private Client client;
    protected int[] heads = null;
    protected int[] bodies = null;
    protected int[] legs = null;
    protected int[] gloves = null;
    protected int[] weapons = null;

    protected boolean hasItem(int[] items, EquipmentInventorySlot slot) {
        try {
            Item[] equippedItems = client.getItemContainer(InventoryID.EQUIPMENT).getItems();
            if (items == null) {
                return true;
            }
            for (int item : items) {
                if (equippedItems[slot.getSlotIdx()].getId() == item) {
                    return true;
                }
            }
            return false;
        } catch (NullPointerException e) {
            return false;
        }
    }

    private boolean hasHead() {
        return hasItem(heads, EquipmentInventorySlot.HEAD);
    }
    private boolean hasBody() {
        return hasItem(bodies, EquipmentInventorySlot.BODY);
    }
    private boolean hasLegs() {
        return hasItem(legs, EquipmentInventorySlot.LEGS);
    }
    private boolean hasGloves() {
        return hasItem(gloves, EquipmentInventorySlot.GLOVES);
    }
    protected boolean hasWeapon() {
        return hasItem(weapons, EquipmentInventorySlot.WEAPON);
    }

    public boolean isWearingSet() {
        return hasHead() && hasBody() && hasLegs() && hasGloves() && hasWeapon();
    }

}

package com.maxhit;

import net.runelite.client.plugins.Plugin;

public class InventoryWeapons extends Plugin {
    String name;
    String weaponType;
    boolean isTwoHanded = false;
    int ID = -1;
    int strBonus = 0;
    double maxHitBase;
    double maxHitSpec;
}

package com.maxhit;

public class NextMaxHit {
    public int strengthLevels;
    public int rangedLevels;
    public int magicLevels;
    public int strengthBonus;
    public int rangedBonus;
    public int magicBonus;
    public int prayerBoost;
}

package com.maxhit;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class MaxHitOverlay extends Overlay {

    private static final Color COMBAT_LEVEL_COLOUR = new Color(0xff981f);
    private final MaxHitPlugin plugin;
    private final MaxHitConfig config;
    private final Client client;
    private final TooltipManager tooltipManager;
    private final PanelComponent panelComponent = new PanelComponent();


    @Inject
    public MaxHitOverlay(MaxHitPlugin plugin, MaxHitConfig config, Client client, TooltipManager tooltipManager) {
        super(plugin);
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.plugin = plugin;  //set plugin field to plugin object given as input
        this.config = config;
        this.client = client;
        this.tooltipManager = tooltipManager;
        getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Max hit overlay"));
    }

    //render method
    @Override
    public Dimension render(Graphics2D graphics) {

        if(client.getGameState() != GameState.LOGGED_IN) {
            return null;
        }

        panelComponent.getChildren().clear();

        if (config.maxHit()) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Hit:")
                    .right(Double.toString(plugin.equipedWeaponMaxHit))
                    .build());
        }

        if (config.showSpec() && plugin.maxHitSpec(plugin.weaponName(), plugin.equipedWeaponMaxHit) != -1) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Special:")
                    .right(Double.toString(Math.floor(plugin.maxHitSpec(plugin.weaponName(), plugin.equipedWeaponMaxHit))))
                    .build());
        }

        if (config.showMagic()) {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Magic Max Hit:")
                    .right(Double.toString(Math.floor(plugin.maxMagicHitBase())))
                    .build());
        }

        //If showNextMaxHit is selected and mouse is inside the overlay show the next max hit tooltip
        if (config.showNextMaxHit() && this.getBounds().contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY())) {
            tooltipManager.add(new Tooltip(getNextMaxHitTooltip()));
        }

        if (plugin.map == null) {
            return panelComponent.render(graphics);
        }

        for (Object weapon : plugin.map.keySet()) {
            String wep = weapon.toString();
            if (config.inventoryWeapons()) {
                panelComponent.getChildren().add(LineComponent.builder()
                        .left(plugin.map.get(wep).name)
                        .right(Double.toString(Math.floor(plugin.map.get(wep).maxHitBase)))
                        .build());
            }
            if (plugin.map.get(wep).maxHitSpec > 0 && config.inventoryWeaponsSpecial()) {
                panelComponent.getChildren().add(LineComponent.builder()
                        .left(plugin.map.get(wep).name + " Spec")
                        .right(Double.toString(Math.floor(plugin.map.get(wep).maxHitSpec)))
                        .build());
            }
            if (config.inventorySelectiveSpecial() &&
                    !config.inventoryWeapons() &&
                    !config.inventoryWeaponsSpecial()) {

                if (plugin.map.get(wep).maxHitSpec <= 0) {
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left(plugin.map.get(wep).name)
                            .right(Double.toString(Math.floor(plugin.map.get(wep).maxHitBase)))
                            .build());
                }
                else {
                    panelComponent.getChildren().add(LineComponent.builder()
                            .left(plugin.map.get(wep).name + " Spec")
                            .right(Double.toString(Math.floor(plugin.map.get(wep).maxHitSpec)))
                            .build());
                }
            }
        }

        return panelComponent.render(graphics);
    }

    private String getNextMaxHitTooltip() {
        NextMaxHit nextMaxHit = plugin.nextMaxHit();

        StringBuilder sb = new StringBuilder();
        sb.append(ColorUtil.wrapWithColorTag("Next max hit:", COMBAT_LEVEL_COLOUR));

        if (nextMaxHit.strengthLevels > 0) {
            sb.append("</br>").append(nextMaxHit.strengthLevels).append(" Strength levels");
        }
        else if (nextMaxHit.rangedLevels > 0) {
            sb.append("</br>").append(nextMaxHit.rangedLevels).append(" Ranged levels");
        }
        else if (nextMaxHit.magicLevels > 0) {
            sb.append("</br>").append(nextMaxHit.magicLevels).append(" Magic levels");
        }

        if (nextMaxHit.strengthBonus > 0) {
            sb.append("</br>").append(nextMaxHit.strengthBonus).append(" Strength bonus");
        }
        else if (nextMaxHit.rangedBonus > 0) {
            sb.append("</br>").append(nextMaxHit.rangedBonus).append(" Ranged bonus");
        }
        else if (nextMaxHit.magicBonus > 0) {
            sb.append("</br>").append(nextMaxHit.magicBonus).append(" % Magic damage");
        }

        if (nextMaxHit.prayerBoost > 0) {
            sb.append("</br>").append(nextMaxHit.prayerBoost).append(" % Prayer boost");
        }

        return sb.toString();
    }
}
