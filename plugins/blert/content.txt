/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

public class ChallengeEndRequest {
    public int overallTimeTicks;
    public int challengeTimeTicks;
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import java.util.List;

/**
 * JSON representation of an attack definition received from the server.
 */
public class AttackDefinition {
    public int protoId;
    public String name;
    public List<Integer> weaponIds;
    public List<Integer> animationIds;
    public int cooldown;
    public Projectile projectile;
    public List<Projectile> weaponProjectiles;
    public boolean continuousAnimation;
    public String category;

    public static class Projectile {
        public int id;
        public int startCycleOffset;
        public Integer weaponId;
    }

    public io.blert.core.AttackDefinition toCore() {
        java.util.List<io.blert.core.AttackDefinition.Projectile> projectileList;

        if (weaponProjectiles != null && !weaponProjectiles.isEmpty()) {
            projectileList = new java.util.ArrayList<>();
            for (Projectile jp : weaponProjectiles) {
                int wid = jp.weaponId != null ? jp.weaponId : -1;
                projectileList.add(new io.blert.core.AttackDefinition.Projectile(jp.id, jp.startCycleOffset, wid));
            }
        } else if (projectile != null) {
            projectileList = java.util.Collections.singletonList(
                    new io.blert.core.AttackDefinition.Projectile(projectile.id, projectile.startCycleOffset));
        } else {
            projectileList = java.util.Collections.emptyList();
        }

        io.blert.core.AttackDefinition.Category cat = io.blert.core.AttackDefinition.Category.MELEE;
        if (category != null) {
            try {
                cat = io.blert.core.AttackDefinition.Category.valueOf(category);
            } catch (IllegalArgumentException ignored) {
            }
        }

        return new io.blert.core.AttackDefinition(
                protoId,
                name,
                weaponIds != null ? weaponIds.stream().mapToInt(Integer::intValue).toArray() : new int[0],
                animationIds != null ? animationIds.stream().mapToInt(Integer::intValue).toArray() : new int[0],
                cooldown,
                projectileList,
                continuousAnimation,
                cat
        );
    }
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import java.util.List;

public class PastChallenge {
    public static final int STATUS_IN_PROGRESS = 0;
    public static final int STATUS_COMPLETED = 1;
    public static final int STATUS_RESET = 2;
    public static final int STATUS_WIPED = 3;
    public static final int STATUS_ABANDONED = 4;

    public String id;
    public int status;
    public int stage;
    public int mode;
    public List<String> party;
    public int challenge;
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import io.blert.challenges.colosseum.Handicap;
import io.blert.challenges.tob.rooms.maiden.MaidenCrab;
import io.blert.challenges.tob.rooms.nylocas.Nylo;
import io.blert.challenges.tob.rooms.sotetseg.Maze;
import io.blert.challenges.tob.rooms.verzik.VerzikCrab;
import io.blert.core.EquipmentSlot;
import io.blert.core.ItemDelta;
import io.blert.core.Stage;
import io.blert.core.TrackedNpc;
import io.blert.events.*;
import io.blert.events.colosseum.HandicapChoiceEvent;
import io.blert.events.tob.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
public class JsonEventTranslator {
    public static Event toJson(io.blert.events.Event event, @Nullable String challengeId) {
        Event json = new Event();
        json.type = event.getType().getId();
        json.tick = event.getTick();
        json.xCoord = event.getXCoord();
        json.yCoord = event.getYCoord();

        event.getStage().map(Stage::getId).ifPresent(s -> json.stage = s);

        if (challengeId != null) {
            json.challengeId = challengeId;
        }

        switch (event.getType()) {
            case CHALLENGE_START:
            case CHALLENGE_END:
            case CHALLENGE_UPDATE:
            case STAGE_UPDATE:
                throw new AssertionError(String.format("Event type %s has no JSON representation", event.getType()));

            case PLAYER_UPDATE: {
                PlayerUpdateEvent playerUpdateEvent = (PlayerUpdateEvent) event;

                int dataSource = playerUpdateEvent.getSource() == PlayerUpdateEvent.Source.PRIMARY
                        ? Event.Player.DATA_SOURCE_PRIMARY
                        : Event.Player.DATA_SOURCE_SECONDARY;

                Event.Player player = new Event.Player();
                player.dataSource = dataSource;
                player.name = playerUpdateEvent.getUsername();
                player.offCooldownTick = playerUpdateEvent.getOffCooldownTick();

                playerUpdateEvent.getHitpoints().ifPresent(sl -> player.hitpoints = sl.getValue());
                playerUpdateEvent.getPrayer().ifPresent(sl -> player.prayer = sl.getValue());
                playerUpdateEvent.getAttack().ifPresent(sl -> player.attack = sl.getValue());
                playerUpdateEvent.getStrength().ifPresent(sl -> player.strength = sl.getValue());
                playerUpdateEvent.getDefence().ifPresent(sl -> player.defence = sl.getValue());
                playerUpdateEvent.getRanged().ifPresent(sl -> player.ranged = sl.getValue());
                playerUpdateEvent.getMagic().ifPresent(sl -> player.magic = sl.getValue());

                playerUpdateEvent.getActivePrayers().ifPresent(prayers -> player.activePrayers = prayers.getValue());

                if (!playerUpdateEvent.getEquipmentChangesThisTick().isEmpty()) {
                    player.equipmentDeltas = playerUpdateEvent.getEquipmentChangesThisTick().stream()
                            .map(ItemDelta::getValue)
                            .collect(Collectors.toList());
                }

                json.player = player;
                break;
            }

            case PLAYER_ATTACK: {
                PlayerAttackEvent playerAttackEvent = (PlayerAttackEvent) event;
                Event.Attack attack = new Event.Attack();
                attack.type = playerAttackEvent.getAttack().getProtoId();
                attack.distanceToTarget = playerAttackEvent.getDistanceToTarget();

                playerAttackEvent.getWeapon().ifPresent(item -> {
                    attack.weapon = new Event.Player.EquippedItem();
                    attack.weapon.slot = EquipmentSlot.WEAPON.getId();
                    attack.weapon.id = item.getId();
                    attack.weapon.quantity = item.getQuantity();
                });

                if (playerAttackEvent.getTargetNpcId() != -1) {
                    attack.target = new Event.Npc();
                    attack.target.id = playerAttackEvent.getTargetNpcId();
                    attack.target.roomId = playerAttackEvent.getTargetRoomId();
                }

                json.playerAttack = attack;
                json.player = new Event.Player();
                json.player.name = playerAttackEvent.getUsername();
                break;
            }

            case PLAYER_SPELL: {
                PlayerSpellEvent playerSpellEvent = (PlayerSpellEvent) event;
                Event.Spell spell = new Event.Spell();
                spell.type = playerSpellEvent.getSpell().getId();

                if (playerSpellEvent.getTargetPlayer() != null) {
                    spell.targetPlayer = playerSpellEvent.getTargetPlayer();
                } else if (playerSpellEvent.hasNpcTarget()) {
                    spell.targetNpc = new Event.Npc();
                    spell.targetNpc.id = playerSpellEvent.getTargetNpcId();
                    spell.targetNpc.roomId = playerSpellEvent.getTargetNpcRoomId();
                }

                json.playerSpell = spell;
                json.player = new Event.Player();
                json.player.name = playerSpellEvent.getUsername();
                break;
            }

            case PLAYER_DEATH: {
                PlayerDeathEvent playerDeathEvent = (PlayerDeathEvent) event;
                json.player = new Event.Player();
                json.player.name = playerDeathEvent.getUsername();
                break;
            }

            case NPC_SPAWN:
            case NPC_UPDATE:
            case NPC_DEATH:
            case MAIDEN_CRAB_LEAK: {
                NpcEvent npcEvent = (NpcEvent) event;
                Event.Npc npc = new Event.Npc();
                npc.id = npcEvent.getNpcId();
                npc.roomId = npcEvent.getRoomId();
                npc.hitpoints = npcEvent.getHitpoints().getValue();

                if (npcEvent.propertiesChanged()) {
                    addTranslatedNpcProperties(npc, npcEvent);
                }

                json.npc = npc;
                break;
            }

            case NPC_ATTACK: {
                NpcAttackEvent npcAttackEvent = (NpcAttackEvent) event;
                json.npc = new Event.Npc();
                json.npc.id = npcAttackEvent.getNpcId();
                json.npc.roomId = npcAttackEvent.getRoomId();

                Event.NpcAttack npcAttack = new Event.NpcAttack();
                npcAttack.attack = npcAttackEvent.getAttack().getId();
                if (npcAttackEvent.getTarget() != null) {
                    npcAttack.target = npcAttackEvent.getTarget();
                }
                json.npcAttack = npcAttack;
                break;
            }

            case MAIDEN_BLOOD_SPLATS: {
                MaidenBloodSplatsEvent bloodSplatsEvent = (MaidenBloodSplatsEvent) event;
                json.maidenBloodSplats = toCoordsList(bloodSplatsEvent.getBloodSplats());
                break;
            }

            case BLOAT_DOWN: {
                BloatDownEvent bloatDownEvent = (BloatDownEvent) event;
                json.bloatDown = new Event.BloatDown();
                json.bloatDown.downNumber = bloatDownEvent.getDownNumber();
                json.bloatDown.walkTime = bloatDownEvent.getUptime();
                break;
            }

            case NYLO_WAVE_SPAWN:
            case NYLO_WAVE_STALL: {
                NyloWaveEvent nyloWaveEvent = (NyloWaveEvent) event;
                json.nyloWave = new Event.NyloWave();
                json.nyloWave.wave = nyloWaveEvent.getWave();
                json.nyloWave.nylosAlive = nyloWaveEvent.getNyloCount();
                json.nyloWave.roomCap = nyloWaveEvent.getNyloCap();
                break;
            }

            case SOTE_MAZE_PROC:
            case SOTE_MAZE_END: {
                SoteMazeEvent mazeEvent = (SoteMazeEvent) event;
                int maze = mazeEvent.getMaze() == Maze.MAZE_66
                        ? Event.SoteMaze.MAZE_66
                        : Event.SoteMaze.MAZE_33;
                json.soteMaze = new Event.SoteMaze();
                json.soteMaze.maze = maze;
                break;
            }

            case SOTE_MAZE_PATH: {
                SoteMazePathEvent mazePathEvent = (SoteMazePathEvent) event;
                int maze = mazePathEvent.getMaze() == Maze.MAZE_66
                        ? Event.SoteMaze.MAZE_66
                        : Event.SoteMaze.MAZE_33;
                var coords = mazePathEvent.mazeRelativePoints()
                        .map(JsonEventTranslator::worldPointToCoords)
                        .collect(Collectors.toList());

                json.soteMaze = new Event.SoteMaze();
                json.soteMaze.maze = maze;

                switch (mazePathEvent.getTileType()) {
                    case OVERWORLD_TILES:
                        json.soteMaze.overworldTiles = coords;
                        break;
                    case UNDERWORLD_PIVOTS:
                        json.soteMaze.underworldPivots = coords;
                        break;
                    case OVERWORLD_PIVOTS:
                        json.soteMaze.overworldPivots = coords;
                        break;
                }
                break;
            }

            case XARPUS_PHASE: {
                XarpusPhaseEvent xarpusPhaseEvent = (XarpusPhaseEvent) event;
                json.xarpusPhase = xarpusPhaseEvent.getPhase().ordinal();
                break;
            }

            case VERZIK_PHASE: {
                VerzikPhaseEvent verzikPhaseEvent = (VerzikPhaseEvent) event;
                json.verzikPhase = verzikPhaseEvent.getPhase().ordinal();
                break;
            }

            case VERZIK_ATTACK_STYLE: {
                VerzikAttackStyleEvent verzikAttackStyleEvent = (VerzikAttackStyleEvent) event;
                json.verzikAttackStyle = new Event.AttackStyle();
                json.verzikAttackStyle.style = verzikAttackStyleEvent.getStyle().ordinal();
                json.verzikAttackStyle.npcAttackTick = verzikAttackStyleEvent.getAttackTick();
                break;
            }

            case COLOSSEUM_HANDICAP_CHOICE: {
                HandicapChoiceEvent handicapChoiceEvent = (HandicapChoiceEvent) event;
                json.handicap = handicapChoiceEvent.getHandicap().getId();
                json.handicapOptions =
                        Arrays.stream(handicapChoiceEvent.getHandicapOptions())
                                .map(Handicap::getId)
                                .collect(Collectors.toList());
                break;
            }

            default:
                break;
        }

        return json;
    }

    private static List<Coords> toCoordsList(List<WorldPoint> points) {
        return points.stream()
                .map(JsonEventTranslator::worldPointToCoords)
                .collect(Collectors.toList());
    }

    private static Coords worldPointToCoords(WorldPoint point) {
        return new Coords(point.getX(), point.getY());
    }

    /**
     * Adds tracked NPC-specific properties to the given {@link Event.Npc} based
     * on the {@link NpcEvent}.
     *
     * @param npc   Npc to which the properties should be added.
     * @param event Event describing the NPC.
     */
    private static void addTranslatedNpcProperties(Event.Npc npc, NpcEvent event) {
        TrackedNpc.Properties properties = event.getProperties();

        if (properties instanceof MaidenCrab.Properties) {
            var crab = (MaidenCrab.Properties) properties;
            npc.maidenCrab = new Event.MaidenCrab();
            npc.maidenCrab.spawn = crab.getSpawn().ordinal();
            npc.maidenCrab.position = crab.getPosition().ordinal();
            npc.maidenCrab.scuffed = crab.isScuffed();
            return;
        }

        if (properties instanceof Nylo.Properties) {
            var nylo = (Nylo.Properties) properties;
            npc.nylo = new Event.Nylo();
            npc.nylo.wave = nylo.getWave();
            npc.nylo.parentRoomId = nylo.getParentRoomId();
            npc.nylo.big = nylo.isBig();
            npc.nylo.style = nylo.getStyle().ordinal();
            npc.nylo.spawnType = nylo.getSpawnType().ordinal();
            return;
        }

        if (properties instanceof VerzikCrab.Properties) {
            var crab = (VerzikCrab.Properties) properties;
            npc.verzikCrab = new Event.VerzikCrab();
            npc.verzikCrab.phase = crab.getPhase().ordinal();
            npc.verzikCrab.spawn = crab.getSpawn().ordinal();
        }
    }
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import java.util.List;

public class ServerMessage {
    public static final int TYPE_PING = 0;
    public static final int TYPE_PONG = 1;
    public static final int TYPE_ERROR = 2;
    public static final int TYPE_CONNECTION_RESPONSE = 3;
    public static final int TYPE_HISTORY_REQUEST = 4;
    public static final int TYPE_HISTORY_RESPONSE = 5;
    public static final int TYPE_EVENT_STREAM = 6;
    public static final int TYPE_SERVER_STATUS = 8;
    public static final int TYPE_GAME_STATE = 10;
    public static final int TYPE_PLAYER_STATE = 11;
    public static final int TYPE_CHALLENGE_STATE_CONFIRMATION = 12;
    public static final int TYPE_CHALLENGE_START_REQUEST = 13;
    public static final int TYPE_CHALLENGE_START_RESPONSE = 14;
    public static final int TYPE_CHALLENGE_END_REQUEST = 15;
    public static final int TYPE_CHALLENGE_END_RESPONSE = 16;
    public static final int TYPE_CHALLENGE_UPDATE = 17;
    public static final int TYPE_GAME_STATE_REQUEST = 18;
    public static final int TYPE_ATTACK_DEFINITIONS = 19;
    public static final int TYPE_SPELL_DEFINITIONS = 20;

    public int type;
    public User user;
    public ErrorData error;
    public String activeChallengeId;
    public List<PastChallenge> recentRecordings;
    public List<Event> challengeEvents;
    public ServerStatus serverStatus;
    public GameState gameState;
    public List<PlayerState> playerState;
    public ChallengeStateConfirmation challengeStateConfirmation;
    public ChallengeStartRequest challengeStartRequest;
    public ChallengeEndRequest challengeEndRequest;
    public ChallengeUpdate challengeUpdate;
    public List<AttackDefinition> attackDefinitions;
    public List<SpellDefinition> spellDefinitions;
    public Integer requestId;
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class SpellDefinition {
    public int id;
    public String name;
    public List<Integer> animationIds;
    public List<Graphic> graphics;
    public List<Graphic> targetGraphics;
    public int stallTicks;

    public static class Graphic {
        public int id;
        public int durationTicks;
        public int maxFrame;
    }

    public io.blert.core.SpellDefinition toCore() {
        List<io.blert.core.SpellDefinition.Graphic> graphicList = graphics != null
                ? graphics.stream()
                    .map(g -> new io.blert.core.SpellDefinition.Graphic(g.id, g.durationTicks, g.maxFrame))
                    .collect(Collectors.toList())
                : Collections.emptyList();

        List<io.blert.core.SpellDefinition.Graphic> targetGraphicList = targetGraphics != null
                ? targetGraphics.stream()
                    .map(g -> new io.blert.core.SpellDefinition.Graphic(g.id, g.durationTicks, g.maxFrame))
                    .collect(Collectors.toList())
                : Collections.emptyList();

        return new io.blert.core.SpellDefinition(
                id,
                name,
                animationIds != null ? animationIds.stream().mapToInt(Integer::intValue).toArray() : new int[0],
                graphicList,
                targetGraphicList,
                stallTicks
        );
    }
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

public class Coords {
    public int x;
    public int y;

    public Coords(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import java.util.List;

public class ChallengeStateConfirmation {
    public boolean isValid;
    public String username;
    public int challenge;
    public int mode;
    public int stage;
    public List<String> party;
    public boolean spectator;
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import io.blert.events.EventHandler;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nullable;
import java.util.*;

/**
 * An event handler which converts events to their corresponding JSON representation.
 * <p>
 * Events posted to `HandleEvent` are stored, without any output being produced.
 * Users must call a flush method to consume the events.
 */
@Slf4j
public class EventBuffer implements EventHandler {
    private final Map<Integer, List<Event>> eventsByTick = new HashMap<>();
    private int earliestTickStored = 0;

    private @Nullable String challengeId = null;

    @Override
    public synchronized void handleEvent(int clientTick, io.blert.events.Event event) {
        eventsByTick.putIfAbsent(clientTick, new ArrayList<>());
        eventsByTick.get(clientTick).add(JsonEventTranslator.toJson(event, challengeId));
    }

    /**
     * Sets a challenge ID to be applied to received events.
     * <p>
     * If the challenge ID is null, events will not have a challenge ID set.
     * Otherwise, if any events are already stored without a challenge ID, they
     * will be updated to have the new challenge ID.
     *
     * @param challengeId The challenge ID to set.
     */
    public synchronized void setChallengeId(@Nullable String challengeId) {
        this.challengeId = challengeId;
        if (challengeId == null) {
            return;
        }

        eventsByTick.values().forEach(events -> {
            for (Event event : events) {
                if (Strings.isNullOrEmpty(event.challengeId)) {
                    event.challengeId = challengeId;
                }
            }
        });
    }

    public boolean hasEvents() {
        return !eventsByTick.isEmpty();
    }

    public List<Event> flushEventsUpTo(int tick) {
        List<Event> events = new ArrayList<>();
        for (int i = earliestTickStored; i <= tick; i++) {
            if (eventsByTick.containsKey(i)) {
                events.addAll(eventsByTick.get(i));
                eventsByTick.remove(i);
            }
        }
        earliestTickStored = tick;
        return events;
    }
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

public class PlayerState {
    public String username;
    public String challengeId;
    public int challenge;
    public int mode;
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

public class ServerStatus {
    public static final int STATUS_RUNNING = 0;
    public static final int STATUS_SHUTDOWN_PENDING = 1;
    public static final int STATUS_SHUTDOWN_CANCELED = 2;
    public static final int STATUS_SHUTDOWN_IMMINENT = 3;

    public int status;
    public Timestamp shutdownTime;

    public static class Timestamp {
        public long seconds;
        public int nanos;
    }
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

public class User {
    public int id;
    public String name;
}

/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import java.util.List;

public class ChallengeUpdate {
    public int mode;
    public List<String> party;
    public StageUpdate stageUpdate;

    public static class StageUpdate {
        public static final int STATUS_ENTERED = 0;
        public static final int STATUS_STARTED = 1;
        public static final int STATUS_COMPLETED = 2;
        public static final int STATUS_WIPED = 3;

        public int stage;
        public int status;
        public boolean accurate;
        public int recordedTicks;
        public Integer gameServerTicks;
        public boolean gameTicksPrecise;
    }
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

public class ErrorData {
    public static final int TYPE_UNKNOWN = 0;
    public static final int TYPE_UNIMPLEMENTED = 1;
    public static final int TYPE_BAD_REQUEST = 2;
    public static final int TYPE_UNAUTHENTICATED = 3;
    public static final int TYPE_USERNAME_MISMATCH = 4;
    public static final int TYPE_CHALLENGE_RECORDING_ENDED = 5;

    public int type;
    public String username;
    public String message;
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import java.util.List;

/**
 * JSON representation of a game event sent to/from the server.
 */
public class Event {
    // General fields shared by all events
    public int type;
    public String challengeId;
    public Integer stage;
    public int tick;
    public int xCoord;
    public int yCoord;

    // Event-specific fields
    public Player player;
    public Attack playerAttack;
    public Npc npc;
    public NpcAttack npcAttack;
    public Spell playerSpell;

    // ToB event-specific fields
    public List<Coords> maidenBloodSplats;
    public BloatDown bloatDown;
    public NyloWave nyloWave;
    public SoteMaze soteMaze;
    public Integer xarpusPhase;
    public Integer verzikPhase;
    public AttackStyle verzikAttackStyle;

    // Colosseum event-specific fields
    public Integer handicap;
    public List<Integer> handicapOptions;

    public static class Player {
        public static final int DATA_SOURCE_PRIMARY = 0;
        public static final int DATA_SOURCE_SECONDARY = 1;

        public String name;
        public int offCooldownTick;
        public Integer hitpoints;
        public Integer prayer;
        public Integer attack;
        public Integer strength;
        public Integer defence;
        public Integer ranged;
        public Integer magic;
        public List<Long> equipmentDeltas;
        public Long activePrayers;
        public int dataSource;

        public static class EquippedItem {
            public int slot;
            public int id;
            public int quantity;
        }
    }

    public static class Npc {
        public int id;
        public long roomId;
        public Integer hitpoints;

        public MaidenCrab maidenCrab;
        public Nylo nylo;
        public VerzikCrab verzikCrab;
    }

    public static class MaidenCrab {
        public int spawn;
        public int position;
        public boolean scuffed;
    }

    public static class Nylo {
        public int wave;
        public long parentRoomId;
        public boolean big;
        public int style;
        public int spawnType;
    }

    public static class VerzikCrab {
        public int phase;
        public int spawn;
    }

    public static class Attack {
        public int type;
        public Player.EquippedItem weapon;
        public Npc target;
        public int distanceToTarget;
    }

    public static class Spell {
        public int type;
        public String targetPlayer;
        public Npc targetNpc;
    }

    public static class NpcAttack {
        public int attack;
        public String target;
    }

    public static class BloatDown {
        public int downNumber;
        public int walkTime;
    }

    public static class NyloWave {
        public int wave;
        public int nylosAlive;
        public int roomCap;
    }

    public static class SoteMaze {
        public static final int MAZE_66 = 0;
        public static final int MAZE_33 = 1;

        public int maze;
        public List<Coords> overworldTiles;
        public List<Coords> overworldPivots;
        public List<Coords> underworldPivots;
    }

    public static class AttackStyle {
        public static final int STYLE_MELEE = 0;
        public static final int STYLE_RANGE = 1;
        public static final int STYLE_MAGE = 2;

        public int style;
        public int npcAttackTick;
    }
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

public class GameState {
    public static final int STATE_LOGGED_OUT = 0;
    public static final int STATE_LOGGED_IN = 1;

    public int state;
    public PlayerInfo playerInfo;

    public static class PlayerInfo {
        public String username;
        public long overallExperience;
        public int attackExperience;
        public int strengthExperience;
        public int defenceExperience;
        public int hitpointsExperience;
        public int rangedExperience;
        public int prayerExperience;
        public int magicExperience;
        public String accountHash;
    }
}
/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.json;

import java.util.List;

public class ChallengeStartRequest {
    public int challenge;
    public int mode;
    public Integer stage;
    public List<String> party;
    public boolean spectator;
}
/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.util;

import org.apache.commons.lang3.tuple.Pair;

import java.util.Optional;

public class Tick {
    public static final int MILLISECONDS_PER_TICK = 600;
    public static final String TIME_STRING_REGEX =
            "(\\d+:)?\\d{1,2}:\\d{2}(\\.\\d{2})?";

    /**
     * Convert a number of ticks to a human-readable time string.
     *
     * @param ticks The number of ticks.
     * @return Formatted time string.
     */
    public static String asTimeString(int ticks) {
        if (ticks < 0) {
            throw new IllegalArgumentException("ticks must be non-negative");
        }

        int hours = 0;
        if (ticks >= 6000) {
            hours = ticks / 6000;
            ticks = ticks % 6000;
        }

        int milliseconds = ticks * MILLISECONDS_PER_TICK;
        int seconds = (milliseconds / 1000) % 60;
        int minutes = milliseconds / 1000 / 60;
        int centiseconds = (milliseconds % 1000) / 10;

        if (hours > 0) {
            return String.format("%d:%02d:%02d.%02d", hours, minutes, seconds, centiseconds);
        }

        return String.format("%d:%02d.%02d", minutes, seconds, centiseconds);
    }

    /**
     * Convert a human-readable time string to a number of ticks. The string may either be a "precise" in-game time
     * string (e.g. "2:19.20") or an imprecise time string (e.g. "2:19"). In the latter case, the time will be rounded
     * up to the nearest tick.
     *
     * @param timeString The time string.
     * @return The number of ticks.
     */
    public static Optional<Pair<Integer, Boolean>> fromTimeString(String timeString) {
        if (timeString.isEmpty()) {
            return Optional.empty();
        }

        if (!timeString.matches(TIME_STRING_REGEX)) {
            throw new IllegalArgumentException("Invalid time string: " + timeString);
        }

        String[] parts = timeString.split(":");

        int hours = 0;
        int minutes;
        String[] secondsAndCentiseconds;
        if (parts.length == 3) {
            hours = Integer.parseInt(parts[0]);
            minutes = Integer.parseInt(parts[1]);
            secondsAndCentiseconds = parts[2].split("\\.");
        } else {
            minutes = Integer.parseInt(parts[0]);
            secondsAndCentiseconds = parts[1].split("\\.");
        }

        int seconds = Integer.parseInt(secondsAndCentiseconds[0]);

        boolean precise = true;

        int milliseconds =
                hours * 60 * 60 * 1000 + minutes * 60 * 1000 + seconds * 1000;
        if (secondsAndCentiseconds.length == 2) {
            int centiseconds = Integer.parseInt(secondsAndCentiseconds[1]);
            milliseconds += centiseconds * 10;
        } else {
            precise = false;
            int remainder = milliseconds % MILLISECONDS_PER_TICK;
            if (remainder != 0) {
                // Round up to the next tick.
                milliseconds += MILLISECONDS_PER_TICK - remainder;
            }
        }

        return Optional.of(Pair.of(milliseconds / MILLISECONDS_PER_TICK, precise));
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.util;

import lombok.NonNull;

/**
 * Delays execution of a task by a specified number of ticks.
 * <p>
 * Progression towards execution is made by calling the {@link DeferredTask#tick()} method,
 * typically from some {@code onTick} handler.
 */
public class DeferredTask {
    private final @NonNull Runnable task;
    private int ticks;

    public DeferredTask(@NonNull Runnable task, int ticks) {
        this.task = task;
        this.ticks = ticks;
    }

    /**
     * Decrements the number of ticks remaining before the task is executed.
     */
    public void tick() {
        ticks = Math.max(-1, ticks - 1);

        if (ticks == 0) {
            task.run();
            ticks = -1;
        }
    }

    /**
     * Cancels the task, preventing it from being executed.
     */
    public void cancel() {
        ticks = -1;
    }

    /**
     * Resets the number of ticks remaining before the task is executed.
     *
     * @param ticks Updated number of ticks.
     */
    public void reset(int ticks) {
        this.ticks = Math.max(-1, ticks);
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.util;

import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;

public class Location {
    @Nullable
    public static WorldPoint getWorldLocation(Client client, WorldPoint instanceUnawareWorldPoint) {
        LocalPoint local = LocalPoint.fromWorld(client, instanceUnawareWorldPoint);
        return local != null ? WorldPoint.fromLocalInstance(client, local) : null;
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob;

import io.blert.challenges.tob.rooms.RoomDataTracker;
import io.blert.challenges.tob.rooms.bloat.BloatDataTracker;
import io.blert.challenges.tob.rooms.maiden.MaidenDataTracker;
import io.blert.challenges.tob.rooms.nylocas.NylocasDataTracker;
import io.blert.challenges.tob.rooms.sotetseg.SotetsegDataTracker;
import io.blert.challenges.tob.rooms.verzik.VerzikDataTracker;
import io.blert.challenges.tob.rooms.xarpus.XarpusDataTracker;
import io.blert.core.*;
import io.blert.events.ChallengeEndEvent;
import io.blert.events.ChallengeStartEvent;
import io.blert.events.StageUpdateEvent;
import io.blert.util.DeferredTask;
import io.blert.util.Tick;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.tuple.Pair;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j

public class TheatreChallenge extends RecordableChallenge {
    private static final int TOB_ROOM_STATUS_VARBIT = 6447;
    private static final int TOB_PARTY_LIST_COMPONENT_ID = 1835020;

    private static final Pattern RAID_ENTRY_REGEX_1P =
            Pattern.compile("You enter the Theatre of Blood \\((\\w+) Mode\\)\\.\\.\\.");
    private static final Pattern RAID_ENTRY_REGEX_3P =
            Pattern.compile("(.+) has entered the Theatre of Blood \\((\\w+) Mode\\). Step inside to join (her|him|them)\\.\\.\\.");
    private static final Pattern RAID_COMPLETION_CHALLENGE_REGEX =
            Pattern.compile("^.+Theatre of Blood completion time: (" + Tick.TIME_STRING_REGEX + ").*");
    private static final Pattern RAID_COMPLETION_OVERALL_REGEX =
            Pattern.compile("Theatre of Blood total completion time: (" + Tick.TIME_STRING_REGEX + ").*");

    private Location location = Location.ELSEWHERE;
    private boolean locationChangedThisTick = false;

    private RoomState roomState = RoomState.INACTIVE;
    @Nullable
    RoomDataTracker roomDataTracker = null;

    private int reportedChallengeTime = -1;

    private @Nullable DeferredTask deferredTask = null;

    public TheatreChallenge(Client client, ClientThread clientThread) {
        super(Challenge.TOB, client, clientThread);
    }

    @Nullable
    @Override
    protected DataTracker getActiveTracker() {
        return roomDataTracker;
    }

    @Override
    public boolean containsLocation(WorldPoint worldPoint) {
        return Location.fromWorldPoint(worldPoint) != Location.ELSEWHERE;
    }

    @Override
    protected void onInitialize() {
        reportedChallengeTime = -1;
    }

    @Override
    protected void onTerminate() {
        clearRoomDataTracker();
        resetParty();
        reportedChallengeTime = -1;
    }

    @Override
    protected void onTick() {
        updateLocation();

        if (location == Location.LOBBY && client.getVarbitValue(Varbits.THEATRE_OF_BLOOD) == 1) {
            // If the player is in a party in the raid lobby, grab the party information from the party widget.
            initializePartyFromLobby();
        }

        if (deferredTask != null) {
            deferredTask.tick();
        }

        if (getState().isInactive() && location.inRaid()) {
            queueRaidStart(ChallengeMode.NO_MODE, true);
        } else if (getState() == ChallengeState.STARTING && location.inRaid()) {
            setState(ChallengeState.ACTIVE);
        } else if (!getState().isInactive() && !location.inRaid()) {
            // The player has left the raid.
            switch (getState()) {
                case COMPLETE:
                    setState(ChallengeState.INACTIVE);
                    break;
                case ACTIVE:
                    queueRaidEnd(ChallengeState.INACTIVE);
                    break;
                case STARTING:
                case PREPARING:
                    if (locationChangedThisTick) {
                        // If the player leaves the raid before it starts, cancel the start.
                        queueRaidEnd(ChallengeState.INACTIVE);
                    }
                    break;
                case ENDING:
                case INACTIVE:
                    // Do nothing.
                    break;
            }
        }

        locationChangedThisTick = false;
        if (!inChallenge()) {
            return;
        }

        updatePartyInformation();

        if (roomDataTracker != null) {
            roomDataTracker.checkEntry();

            if (roomDataTracker.notStarted() && roomState.isActive() && roomDataTracker.playersAreInRoom()) {
                // The room may already be active when entered (e.g. as a spectator); start its tracker.
                if (getState() == ChallengeState.PREPARING) {
                    startRaid();
                }

                roomDataTracker.startRoomInaccurate();
                log.debug("Room {} started via activity check", roomDataTracker.getRoom());
            }

            roomDataTracker.tick();
        }
    }

    @Nullable
    @Override
    protected Stage getStage() {
        return roomDataTracker != null ? roomDataTracker.getStage() : null;
    }

    /**
     * Invokes a callback for each username displayed in the ToB orb list.
     *
     * @param callback Function to run on each user.
     */
    public void forEachOrb(BiConsumer<Integer, String> callback) {
        // ID of the client string containing the username of the first member in a ToB party. Subsequent party members'
        // usernames (if present) occupy the following four IDs.
        final int TOB_P1_VARCSTR_ID = 330;
        for (int player = 0; player < 5; player++) {
            String username = client.getVarcStrValue(TOB_P1_VARCSTR_ID + player);
            if (!Strings.isNullOrEmpty(username)) {
                callback.accept(player, Text.sanitize(username));
            }
        }
    }

    private void queueRaidStart(ChallengeMode mode, boolean reinitializeParty) {
        log.info("Starting new raid");
        updateMode(mode);
        setState(ChallengeState.PREPARING);
        reportedChallengeTime = -1;

        if (reinitializeParty) {
            // When players join the raid, the orb list does not immediately update, nor does it update all at once.
            // (Some players may take longer to load in, thanks Jagex!) Therefore, wait a few ticks before starting.
            // This value is arbitrary and may need to be adjusted.
            final int TICKS_TO_DELAY_ORB_CHECK = 5;
            deferredTask = new DeferredTask(() -> {
                initializePartyFromOrbs();
                startRaid();
            }, TICKS_TO_DELAY_ORB_CHECK);
        } else {
            deferredTask = new DeferredTask(this::startRaid, 1);
        }
    }

    private void startRaid() {
        deferredTask = null;

        updateLocation();
        setState(location.inRaid() ? ChallengeState.ACTIVE : ChallengeState.STARTING);

        boolean spectator = !playerIsInChallenge(client.getLocalPlayer().getName());

        List<String> names = getParty().stream().map(Raider::getUsername).collect(Collectors.toList());
        Stage stage = null;

        if (this.roomDataTracker != null) {
            // Raid scale information is not immediately available when the raid starts, so if any NPCs have already
            // spawned, their hitpoints must be corrected after the scale is known.
            this.roomDataTracker.correctNpcHitpointsForScale(getScale());
            stage = this.roomDataTracker.getStage();
        }

        dispatchEvent(new ChallengeStartEvent(getChallenge(), getChallengeMode(), stage, names, spectator));

        // Dispatch any events that were queued before the raid started.
        dispatchPendingEvents();
    }

    private void queueRaidEnd(ChallengeState state) {
        queueRaidEnd(state, -1);
    }

    private void queueRaidEnd(ChallengeState state, int overallTime) {
        if (getState() == ChallengeState.PREPARING) {
            // If a raid start is pending, cancel it.
            setState(ChallengeState.INACTIVE);
            updateMode(ChallengeMode.NO_MODE);
            clearPendingEvents();
            resetParty();
            deferredTask = null;
            log.info("Raid ended before it started");
            return;
        }

        setState(ChallengeState.ENDING);
        deferredTask = new DeferredTask(() -> endRaid(state, overallTime), 3);
    }

    private void endRaid(ChallengeState state, int overallTime) {
        final int challengeTime = reportedChallengeTime;
        log.info("Raid completed; challenge {}, overall {}",
                challengeTime == -1 ? "unknown" : Tick.asTimeString(reportedChallengeTime),
                overallTime == -1 ? "unknown" : Tick.asTimeString(overallTime));

        clearRoomDataTracker();
        setState(state);
        updateMode(ChallengeMode.NO_MODE);
        resetParty();

        getClientThread().invokeAtTickEnd(() -> dispatchEvent(new ChallengeEndEvent(challengeTime, overallTime)));

        reportedChallengeTime = -1;
    }

    /**
     * Checks the location of the logged-in player, initializing the appropriate {@link RoomDataTracker} if a new room
     * has been entered.
     */
    private void updateLocation() {
        Player player = client.getLocalPlayer();
        if (player == null) {
            return;
        }

        Location loc = Location.fromWorldPoint(WorldPoint.fromLocalInstance(client, player.getLocalLocation()));
        if (location == loc) {
            return;
        }

        log.debug("Location changed to {}", loc);
        location = loc;

        if (roomDataTracker == null || !location.inRoomInstance(roomDataTracker.getRoom())) {
            // When entering a new instance for the first time, its room data tracker must be initialized.
            initializeRoomDataTracker();
        }

        locationChangedThisTick = true;
    }

    @Override
    public void onNpcSpawned(NpcSpawned npcSpawned) {
        updateLocation();
        super.onNpcSpawned(npcSpawned);
    }

    @Override
    public void onVarbitChanged(VarbitChanged varbit) {
        if (varbit.getVarbitId() == Varbits.THEATRE_OF_BLOOD) {
            if (getState().isInactive() && varbit.getValue() == 2) {
                // A raid start due to a varbit change usually means that the player is joining late, rejoining, or
                // spectating. Party and mode information is not immediately available.
                log.debug("Raid started via varbit change");
                queueRaidStart(ChallengeMode.NO_MODE, true);
            } else if (getState().inChallenge() && varbit.getValue() < 2) {
                if (getState() == ChallengeState.COMPLETE) {
                    setState(ChallengeState.INACTIVE);
                }
            }
        }

        int roomStatus = client.getVarbitValue(TOB_ROOM_STATUS_VARBIT);
        var state = RoomState.fromVarbit(roomStatus);
        if (state.isEmpty()) {
            log.error("Unknown value for room status varbit: " + varbit.getValue());
            return;
        }

        RoomState previousState = roomState;
        roomState = state.get();
        if (previousState != roomState) {
            log.debug("Room status changed from " + previousState + " to " + roomState);
        }

        super.onVarbitChanged(varbit);
    }

    @Override
    public void onChatMessage(ChatMessage message) {
        updateLocation();

        if (message.getType() == ChatMessageType.GAMEMESSAGE) {
            String stripped = Text.removeTags(message.getMessage());

            if (getState().isInactive()) {
                // Listen for a chat message indicating the start of a raid, and queue the start action immediately
                // instead of waiting to enter.
                Matcher matcher = RAID_ENTRY_REGEX_1P.matcher(stripped);
                if (matcher.matches()) {
                    log.debug("Raid started via 1p chat message (mode: {})", matcher.group(1));
                    queueRaidStart(ChallengeMode.parseTob(matcher.group(1)).orElse(ChallengeMode.NO_MODE),
                            getParty().isEmpty());
                    super.onChatMessage(message);
                    return;
                }

                matcher = RAID_ENTRY_REGEX_3P.matcher(stripped);
                if (matcher.matches()) {
                    log.debug("Raid started via 3p chat message (leader: {} mode: {})", matcher.group(1), matcher.group(2));
                    queueRaidStart(ChallengeMode.parseTob(matcher.group(2)).orElse(ChallengeMode.NO_MODE),
                            getParty().isEmpty());
                }
                super.onChatMessage(message);
                return;
            }

            Matcher matcher = RAID_COMPLETION_CHALLENGE_REGEX.matcher(stripped);
            if (matcher.matches()) {
                reportedChallengeTime = Tick.fromTimeString(matcher.group(1)).map(Pair::getLeft).orElse(-1);
            }

            matcher = RAID_COMPLETION_OVERALL_REGEX.matcher(stripped);
            if (matcher.matches()) {
                int overallTime = Tick.fromTimeString(matcher.group(1)).map(Pair::getLeft).orElse(-1);
                queueRaidEnd(ChallengeState.COMPLETE, overallTime);
            }
        }

        super.onChatMessage(message);
    }

    /**
     * Collects party members' names from the lobby party widget.
     */
    private void initializePartyFromLobby() {
        var tobPartyWidget = client.getWidget(TOB_PARTY_LIST_COMPONENT_ID);
        if (tobPartyWidget == null) {
            return;
        }

        resetParty();

        Arrays.stream(tobPartyWidget.getText().split("<br>"))
                .filter(s -> !s.equals("-"))
                .map((name) -> Text.sanitize(name).replace(" (R)", ""))
                .forEach(s -> addRaider(new Raider(s, s.equals(client.getLocalPlayer().getName()))));
    }

    private void initializePartyFromOrbs() {
        resetParty();
        String localPlayer = client.getLocalPlayer().getName();
        forEachOrb((orb, username) -> addRaider(new Raider(username, username.equals(localPlayer))));
    }

    private void updatePartyInformation() {
        // Toggle the players who are currently connected to the raid.
        getParty().forEach(r -> r.setActive(false));
        forEachOrb((orb, username) -> {
            Raider raider = getRaider(Text.standardize(username));
            if (raider != null) {
                raider.setActive(true);
            }
        });
    }

    private void clearRoomDataTracker() {
        if (roomDataTracker != null) {
            roomDataTracker.terminate();
            roomDataTracker = null;
        }
    }

    private void initializeRoomDataTracker() {
        clearRoomDataTracker();

        if (location.inMaidenInstance()) {
            roomDataTracker = new MaidenDataTracker(this, client);
        } else if (location.inBloatInstance()) {
            roomDataTracker = new BloatDataTracker(this, client);
        } else if (location.inNylocasInstance()) {
            roomDataTracker = new NylocasDataTracker(this, client);
        } else if (location.inSotetsegInstance()) {
            roomDataTracker = new SotetsegDataTracker(this, client);
        } else if (location.inXarpusInstance()) {
            roomDataTracker = new XarpusDataTracker(this, client);
        } else if (location.inVerzikInstance()) {
            roomDataTracker = new VerzikDataTracker(this, client);
        }

        if (roomDataTracker != null) {
            log.info("Initialized room data tracker for {} from {}", roomDataTracker.getRoom(), location);
            dispatchEvent(new StageUpdateEvent(roomDataTracker.getStage(), 0, StageUpdateEvent.Status.ENTERED));
            getParty().forEach(Raider::resetForNewRoom);
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob;

import java.util.Optional;

public enum Mode {
    ENTRY,
    REGULAR,
    HARD;

    public static Optional<Mode> parse(String string) {
        switch (string.toLowerCase()) {
            case "entry":
            case "story":
                return Optional.of(ENTRY);
            case "normal":
            case "regular":
                return Optional.of(REGULAR);
            case "hard":
                return Optional.of(HARD);
            default:
                return Optional.empty();
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob;

import com.google.common.collect.ImmutableMap;
import io.blert.core.ChallengeMode;
import lombok.Getter;
import net.runelite.api.gameval.NpcID;

import java.util.Arrays;
import java.util.Optional;

/**
 * All known NPCs within the Theatre of Blood.
 */
public enum TobNpc {
    // Maiden boss.
    MAIDEN_ENTRY(10814, 6, ChallengeMode.TOB_ENTRY, 500),
    MAIDEN_REGULAR(8360, 6, ChallengeMode.TOB_REGULAR, new int[]{2625, 3062, 3500}),
    MAIDEN_HARD(10822, 6, ChallengeMode.TOB_HARD, new int[]{2625, 3062, 3500}),

    // Maiden red crab.
    MAIDEN_MATOMENOS_ENTRY(10820, 1, ChallengeMode.TOB_ENTRY, 16),
    MAIDEN_MATOMENOS_REGULAR(8366, 1, ChallengeMode.TOB_REGULAR, new int[]{75, 87, 100}),
    MAIDEN_MATOMENOS_HARD(10828, 1, ChallengeMode.TOB_HARD, new int[]{75, 87, 100}),

    // Maiden heat-seeking blood spawn.
    MAIDEN_BLOOD_SPAWN_ENTRY(10821, 1, ChallengeMode.TOB_ENTRY, 0),
    MAIDEN_BLOOD_SPAWN_REGULAR(8367, 1, ChallengeMode.TOB_REGULAR, new int[]{90, 105, 120}),
    MAIDEN_BLOOD_SPAWN_HARD(10829, 1, ChallengeMode.TOB_HARD, new int[]{90, 105, 120}),

    // Bloat.
    BLOAT_ENTRY(10812, 1, ChallengeMode.TOB_ENTRY, 320),
    BLOAT_REGULAR(8359, 1, ChallengeMode.TOB_REGULAR, new int[]{1500, 1750, 2000}),
    BLOAT_HARD(10813, 1, ChallengeMode.TOB_HARD, new int[]{1800, 2100, 2400}),

    // Melee small nylos.
    NYLOCAS_ISCHYROS_SMALL_ENTRY(10774, 1, ChallengeMode.TOB_ENTRY, 2),
    NYLOCAS_ISCHYROS_SMALL_REGULAR(8342, 1, ChallengeMode.TOB_REGULAR, new int[]{8, 9, 11}),
    NYLOCAS_ISCHYROS_SMALL_HARD(10791, 1, ChallengeMode.TOB_HARD, new int[]{8, 9, 11}),
    NYLOCAS_ISCHYROS_SMALL_AGGRO_ENTRY(10780, 1, ChallengeMode.TOB_ENTRY, 2),
    NYLOCAS_ISCHYROS_SMALL_AGRRO_REGULAR(8348, 1, ChallengeMode.TOB_REGULAR, new int[]{8, 9, 11}),
    NYLOCAS_ISCHYROS_SMALL_AGGRO_HARD(10797, 1, ChallengeMode.TOB_HARD, new int[]{8, 9, 11}),

    // Melee big nylos.
    NYLOCAS_ISCHYROS_BIG_ENTRY(10777, 1, ChallengeMode.TOB_ENTRY, 3),
    NYLOCAS_ISCHYROS_BIG_REGULAR(8345, 1, ChallengeMode.TOB_REGULAR, new int[]{16, 19, 22}),
    NYLOCAS_ISCHYROS_BIG_HARD(10794, 1, ChallengeMode.TOB_HARD, new int[]{16, 19, 22}),
    NYLOCAS_ISCHYROS_BIG_AGGRO_ENTRY(10783, 1, ChallengeMode.TOB_ENTRY, 3),
    NYLOCAS_ISCHYROS_BIG_AGGRO_REGULAR(8351, 1, ChallengeMode.TOB_REGULAR, new int[]{16, 19, 22}),
    NYLOCAS_ISCHYROS_BIG_AGGRO_HARD(10800, 1, ChallengeMode.TOB_HARD, new int[]{16, 19, 22}),

    // Range small nylos.
    NYLOCAS_TOXOBOLOS_SMALL_ENTRY(10775, 1, ChallengeMode.TOB_ENTRY, 2),
    NYLOCAS_TOXOBOLOS_SMALL_REGULAR(8343, 1, ChallengeMode.TOB_REGULAR, new int[]{8, 9, 11}),
    NYLOCAS_TOXOBOLOS_SMALL_HARD(10792, 1, ChallengeMode.TOB_HARD, new int[]{8, 9, 11}),
    NYLOCAS_TOXOBOLOS_SMALL_AGGRO_ENTRY(10781, 1, ChallengeMode.TOB_ENTRY, 2),
    NYLOCAS_TOXOBOLOS_SMALL_AGRRO_REGULAR(8349, 1, ChallengeMode.TOB_REGULAR, new int[]{8, 9, 11}),
    NYLOCAS_TOXOBOLOS_SMALL_AGGRO_HARD(10798, 1, ChallengeMode.TOB_HARD, new int[]{8, 9, 11}),

    // Range big nylos.
    NYLOCAS_TOXOBOLOS_BIG_ENTRY(10778, 1, ChallengeMode.TOB_ENTRY, 3),
    NYLOCAS_TOXOBOLOS_BIG_REGULAR(8346, 1, ChallengeMode.TOB_REGULAR, new int[]{16, 19, 22}),
    NYLOCAS_TOXOBOLOS_BIG_HARD(10795, 1, ChallengeMode.TOB_HARD, new int[]{16, 19, 22}),
    NYLOCAS_TOXOBOLOS_BIG_AGGRO_ENTRY(10784, 1, ChallengeMode.TOB_ENTRY, 3),
    NYLOCAS_TOXOBOLOS_BIG_AGGRO_REGULAR(8352, 1, ChallengeMode.TOB_REGULAR, new int[]{16, 19, 22}),
    NYLOCAS_TOXOBOLOS_BIG_AGGRO_HARD(10801, 1, ChallengeMode.TOB_HARD, new int[]{16, 19, 22}),

    // Mage small nylos.
    NYLOCAS_HAGIOS_SMALL_ENTRY(10776, 1, ChallengeMode.TOB_ENTRY, 2),
    NYLOCAS_HAGIOS_SMALL_REGULAR(8344, 1, ChallengeMode.TOB_REGULAR, new int[]{8, 9, 11}),
    NYLOCAS_HAGIOS_SMALL_HARD(10793, 1, ChallengeMode.TOB_HARD, new int[]{8, 9, 11}),
    NYLOCAS_HAGIOS_SMALL_AGGRO_ENTRY(10782, 1, ChallengeMode.TOB_ENTRY, 2),
    NYLOCAS_HAGIOS_SMALL_AGRRO_REGULAR(8350, 1, ChallengeMode.TOB_REGULAR, new int[]{8, 9, 11}),
    NYLOCAS_HAGIOS_SMALL_AGGRO_HARD(10799, 1, ChallengeMode.TOB_HARD, new int[]{8, 9, 11}),

    // Mage big nylos.
    NYLOCAS_HAGIOS_BIG_ENTRY(10779, 1, ChallengeMode.TOB_ENTRY, 3),
    NYLOCAS_HAGIOS_BIG_REGULAR(8347, 1, ChallengeMode.TOB_REGULAR, new int[]{16, 19, 22}),
    NYLOCAS_HAGIOS_BIG_HARD(10796, 1, ChallengeMode.TOB_HARD, new int[]{16, 19, 22}),
    NYLOCAS_HAGIOS_BIG_AGGRO_ENTRY(10785, 1, ChallengeMode.TOB_ENTRY, 3),
    NYLOCAS_HAGIOS_BIG_AGGRO_REGULAR(8353, 1, ChallengeMode.TOB_REGULAR, new int[]{16, 19, 22}),
    NYLOCAS_HAGIOS_BIG_AGGRO_HARD(10802, 1, ChallengeMode.TOB_HARD, new int[]{16, 19, 22}),

    // HMT nylo prince.
    NYLOCAS_PRINKIPAS(10803, 4, ChallengeMode.TOB_HARD, new int[]{300, 350, 400}),

    // Nylo king.
    NYLOCAS_VASILIAS_ENTRY(10787, 4, ChallengeMode.TOB_ENTRY, 360),
    NYLOCAS_VASILIAS_REGULAR(8354, 4, ChallengeMode.TOB_REGULAR, new int[]{1875, 2187, 2500}),
    NYLOCAS_VASILIAS_HARD(10807, 4, ChallengeMode.TOB_HARD, new int[]{1875, 2187, 2500}),

    // Inactive Sotetseg (prior to room entry or during maze).
    SOTETSEG_IDLE_ENTRY(10864, 1, ChallengeMode.TOB_ENTRY, 560),
    SOTETSEG_IDLE_REGULAR(8387, 1, ChallengeMode.TOB_REGULAR, new int[]{3000, 3500, 4000}),
    SOTETSEG_IDLE_HARD(10867, 1, ChallengeMode.TOB_HARD, new int[]{3000, 3500, 4000}),

    // Main Sotetseg boss.
    SOTETSEG_ENTRY(10865, 1, ChallengeMode.TOB_ENTRY, 560),
    SOTETSEG_REGULAR(8388, 1, ChallengeMode.TOB_REGULAR, new int[]{3000, 3500, 4000}),
    SOTETSEG_HARD(10868, 1, ChallengeMode.TOB_HARD, new int[]{3000, 3500, 4000}),

    // Inactive Xarpus prior to room entry.
    XARPUS_IDLE_ENTRY(10766, 1, ChallengeMode.TOB_ENTRY, 680),
    XARPUS_IDLE_REGULAR(8338, 1, ChallengeMode.TOB_REGULAR, new int[]{3810, 4445, 5080}),
    XARPUS_IDLE_HARD(10770, 1, ChallengeMode.TOB_HARD, new int[]{4500, 5250, 6000}),

    // Xarpus healing during P1 exhumes.
    XARPUS_P1_ENTRY(10767, 1, ChallengeMode.TOB_ENTRY, 680),
    XARPUS_P1_REGULAR(8339, 1, ChallengeMode.TOB_REGULAR, new int[]{3810, 4445, 5080}),
    XARPUS_P1_HARD(10771, 1, ChallengeMode.TOB_HARD, new int[]{4500, 5250, 6000}),

    // Xarpus main phase and post-screech.
    XARPUS_ENTRY(10768, 1, ChallengeMode.TOB_ENTRY, 680),
    XARPUS_REGULAR(8340, 1, ChallengeMode.TOB_REGULAR, new int[]{3810, 4445, 5080}),
    XARPUS_HARD(10772, 1, ChallengeMode.TOB_HARD, new int[]{4500, 5250, 6000}),

    // Verzik sitting at her throne prior to combat.
    VERZIK_IDLE_ENTRY(NpcID.VERZIK_INITIAL_STORY, 1, ChallengeMode.TOB_ENTRY, 240),
    VERZIK_IDLE_REGULAR(NpcID.VERZIK_INITIAL, 1, ChallengeMode.TOB_REGULAR, new int[]{1500, 1750, 2000}),
    VERZIK_IDLE_REGULAR_QS(NpcID.VERZIK_INITIAL_QUICKSTART, 1, ChallengeMode.TOB_REGULAR, new int[]{1500, 1750, 2000}),
    VERZIK_IDLE_HARD(NpcID.VERZIK_INITIAL_HARD, 1, ChallengeMode.TOB_HARD, new int[]{1500, 1750, 2000}),
    VERZIK_IDLE_HARD_QS(NpcID.VERZIK_INITIAL_HARD_QUICKSTART, 1, ChallengeMode.TOB_HARD, new int[]{1500, 1750, 2000}),

    // Verzik P1.
    VERZIK_P1_ENTRY(NpcID.VERZIK_PHASE1_STORY, 1, ChallengeMode.TOB_ENTRY, 240),
    VERZIK_P1_REGULAR(NpcID.VERZIK_PHASE1, 1, ChallengeMode.TOB_REGULAR, new int[]{1500, 1750, 2000}),
    VERZIK_P1_HARD(NpcID.VERZIK_PHASE1_HARD, 1, ChallengeMode.TOB_HARD, new int[]{1500, 1750, 2000}),

    VERZIK_P1_TRANSITION_ENTRY(NpcID.VERZIK_PHASE1_TO2_TRANSITION_STORY, 1, ChallengeMode.TOB_ENTRY, 0),
    VERZIK_P1_TRANSITION_REGULAR(NpcID.VERZIK_PHASE1_TO2_TRANSITION, 1, ChallengeMode.TOB_REGULAR, 0),
    VERZIK_P1_TRANSITION_HARD(NpcID.VERZIK_PHASE1_TO2_TRANSITION_HARD, 1, ChallengeMode.TOB_HARD, 0),

    // Verzik P2, including the transition to P3.
    VERZIK_P2_ENTRY(NpcID.VERZIK_PHASE2_STORY, 2, ChallengeMode.TOB_ENTRY, 320),
    VERZIK_P2_REGULAR(NpcID.VERZIK_PHASE2, 2, ChallengeMode.TOB_REGULAR, new int[]{2437, 2843, 3250}),
    VERZIK_P2_HARD(NpcID.VERZIK_PHASE2_HARD, 2, ChallengeMode.TOB_HARD, new int[]{2437, 2843, 3250}),

    // Verzik P3, including death animation.
    VERZIK_P3_ENTRY(NpcID.VERZIK_PHASE3_STORY, 2, ChallengeMode.TOB_ENTRY, 320),
    VERZIK_P3_REGULAR(NpcID.VERZIK_PHASE3, 2, ChallengeMode.TOB_REGULAR, new int[]{2437, 2843, 3250}),
    VERZIK_P3_HARD(NpcID.VERZIK_PHASE3_HARD, 2, ChallengeMode.TOB_HARD, new int[]{2437, 2843, 3250}),

    // Pillars at Verzik.
    VERZIK_PILLAR(NpcID.VERZIK_PILLAR_NPC, 1, ChallengeMode.NO_MODE, 0),

    // Nylos at Verzik.
    // TODO(frolv): Correct HP values.
    VERZIK_NYLOCAS_ISCHYROS_ENTRY(10841, 1, ChallengeMode.TOB_ENTRY, 11),
    VERZIK_NYLOCAS_ISCHYROS_REGULAR(8381, 1, ChallengeMode.TOB_REGULAR, 11),
    VERZIK_NYLOCAS_ISCHYROS_HARD(10858, 1, ChallengeMode.TOB_HARD, 11),
    VERZIK_NYLOCAS_TOXOBOLOS_ENTRY(10842, 1, ChallengeMode.TOB_ENTRY, 11),
    VERZIK_NYLOCAS_TOXOBOLOS_REGULAR(8382, 1, ChallengeMode.TOB_REGULAR, 11),
    VERZIK_NYLOCAS_TOXOBOLOS_HARD(10859, 1, ChallengeMode.TOB_HARD, 11),
    VERZIK_NYLOCAS_HAGIOS_ENTRY(10843, 1, ChallengeMode.TOB_ENTRY, 11),
    VERZIK_NYLOCAS_HAGIOS_REGULAR(8383, 1, ChallengeMode.TOB_REGULAR, 11),
    VERZIK_NYLOCAS_HAGIOS_HARD(10860, 1, ChallengeMode.TOB_HARD, 11),

    // Purple crab at Verzik.
    VERZIK_ATHANATOS_ENTRY(10844, 1, ChallengeMode.TOB_ENTRY, 0),
    VERZIK_ATHANATOS_REGULAR(8384, 1, ChallengeMode.TOB_REGULAR, 0),
    VERZIK_ATHANATOS_HARD(10861, 1, ChallengeMode.TOB_HARD, 0),

    // Red crabs at Verzik.
    VERZIK_MATOMENOS_ENTRY(10845, 1, ChallengeMode.TOB_ENTRY, 0),
    VERZIK_MATOMENOS_REGULAR(8385, 1, ChallengeMode.TOB_REGULAR, new int[]{150, 175, 200}),
    VERZIK_MATOMENOS_HARD(10862, 1, ChallengeMode.TOB_HARD, new int[]{150, 175, 200}),

    ;

    @Getter
    private final int id;
    private final int idRange;
    @Getter
    private final ChallengeMode mode;
    private final int[] hitpointsByScale;

    private static final ImmutableMap<Integer, TobNpc> npcsById;

    static {
        ImmutableMap.Builder<Integer, TobNpc> builder = ImmutableMap.builder();

        for (TobNpc npc : TobNpc.values()) {
            for (int i = 0; i < npc.idRange; i++) {
                builder.put(npc.id + i, npc);
            }
        }

        npcsById = builder.build();
    }

    public static Optional<TobNpc> withId(int id) {
        return Optional.ofNullable(npcsById.get(id));
    }

    TobNpc(int id, int idRange, ChallengeMode mode, int[] hitpoints) {
        this.id = id;
        this.idRange = idRange;
        this.mode = mode;
        this.hitpointsByScale = hitpoints;
    }

    TobNpc(int id, int idRange, ChallengeMode mode, int hitpoints) {
        this.id = id;
        this.idRange = idRange;
        this.mode = mode;
        this.hitpointsByScale = new int[]{hitpoints, hitpoints, hitpoints};
    }

    TobNpc(int id, ChallengeMode mode) {
        this(id, 1, mode, new int[]{0, 0, 0});
    }

    public boolean hasId(int id) {
        return id >= this.id && id < this.id + this.idRange;
    }

    private static boolean idMatches(int id, TobNpc... npcs) {
        return Arrays.stream(npcs).anyMatch(npc -> npc.hasId(id));
    }

    public static boolean isMaiden(int id) {
        return idMatches(id, MAIDEN_ENTRY, MAIDEN_REGULAR, MAIDEN_HARD);
    }

    public static boolean isMaidenMatomenos(int id) {
        return idMatches(id, MAIDEN_MATOMENOS_ENTRY, MAIDEN_MATOMENOS_REGULAR, MAIDEN_MATOMENOS_HARD);
    }

    public static boolean isMaidenBloodSpawn(int id) {
        return idMatches(id, MAIDEN_BLOOD_SPAWN_ENTRY, MAIDEN_BLOOD_SPAWN_REGULAR, MAIDEN_BLOOD_SPAWN_HARD);
    }

    public static boolean isBloat(int id) {
        return idMatches(id, BLOAT_ENTRY, BLOAT_REGULAR, BLOAT_HARD);
    }

    public static boolean isNylocasIschyrosSmall(int id) {
        return idMatches(id, NYLOCAS_ISCHYROS_SMALL_ENTRY, NYLOCAS_ISCHYROS_SMALL_REGULAR, NYLOCAS_ISCHYROS_SMALL_HARD)
                || idMatches(id, NYLOCAS_ISCHYROS_SMALL_AGGRO_ENTRY, NYLOCAS_ISCHYROS_SMALL_AGRRO_REGULAR, NYLOCAS_ISCHYROS_SMALL_AGGRO_HARD);
    }

    public static boolean isNylocasIschyrosBig(int id) {
        return idMatches(id, NYLOCAS_ISCHYROS_BIG_ENTRY, NYLOCAS_ISCHYROS_BIG_REGULAR, NYLOCAS_ISCHYROS_BIG_HARD)
                || idMatches(id, NYLOCAS_ISCHYROS_BIG_AGGRO_ENTRY, NYLOCAS_ISCHYROS_BIG_AGGRO_REGULAR, NYLOCAS_ISCHYROS_BIG_AGGRO_HARD);
    }

    public static boolean isNylocasIschyros(int id) {
        return isNylocasIschyrosSmall(id) || isNylocasIschyrosBig(id);
    }

    public static boolean isNylocasToxobolosSmall(int id) {
        return idMatches(id, NYLOCAS_TOXOBOLOS_SMALL_ENTRY, NYLOCAS_TOXOBOLOS_SMALL_REGULAR, NYLOCAS_TOXOBOLOS_SMALL_HARD)
                || idMatches(id, NYLOCAS_TOXOBOLOS_SMALL_AGGRO_ENTRY, NYLOCAS_TOXOBOLOS_SMALL_AGRRO_REGULAR, NYLOCAS_TOXOBOLOS_SMALL_AGGRO_HARD);
    }

    public static boolean isNylocasToxobolosBig(int id) {
        return idMatches(id, NYLOCAS_TOXOBOLOS_BIG_ENTRY, NYLOCAS_TOXOBOLOS_BIG_REGULAR, NYLOCAS_TOXOBOLOS_BIG_HARD)
                || idMatches(id, NYLOCAS_TOXOBOLOS_BIG_AGGRO_ENTRY, NYLOCAS_TOXOBOLOS_BIG_AGGRO_REGULAR, NYLOCAS_TOXOBOLOS_BIG_AGGRO_HARD);
    }

    public static boolean isNylocasToxobolos(int id) {
        return isNylocasToxobolosSmall(id) || isNylocasToxobolosBig(id);
    }

    public static boolean isNylocasHagiosSmall(int id) {
        return idMatches(id, NYLOCAS_HAGIOS_SMALL_ENTRY, NYLOCAS_HAGIOS_SMALL_REGULAR, NYLOCAS_HAGIOS_SMALL_HARD)
                || idMatches(id, NYLOCAS_HAGIOS_SMALL_AGGRO_ENTRY, NYLOCAS_HAGIOS_SMALL_AGRRO_REGULAR, NYLOCAS_HAGIOS_SMALL_AGGRO_HARD);
    }

    public static boolean isNylocasHagiosBig(int id) {
        return idMatches(id, NYLOCAS_HAGIOS_BIG_ENTRY, NYLOCAS_HAGIOS_BIG_REGULAR, NYLOCAS_HAGIOS_BIG_HARD)
                || idMatches(id, NYLOCAS_HAGIOS_BIG_AGGRO_ENTRY, NYLOCAS_HAGIOS_BIG_AGGRO_REGULAR, NYLOCAS_HAGIOS_BIG_AGGRO_HARD);
    }

    public static boolean isNylocasHagios(int id) {
        return isNylocasHagiosSmall(id) || isNylocasHagiosBig(id);
    }

    public static boolean isNylocas(int id) {
        return isNylocasIschyros(id) || isNylocasToxobolos(id) || isNylocasHagios(id);
    }

    public static boolean isNylocasPrinkipas(int id) {
        return NYLOCAS_PRINKIPAS.hasId(id);
    }

    public static boolean isNylocasVasilias(int id) {
        return idMatches(id, NYLOCAS_VASILIAS_ENTRY, NYLOCAS_VASILIAS_REGULAR, NYLOCAS_VASILIAS_HARD);
    }

    public static boolean isDroppingNyloBoss(int id) {
        // The base ID of each Nylo boss is the NPC ID of it dropping from the ceiling, so do a strict check agsinst
        // those, ignoring the ID range.
        return id == NYLOCAS_PRINKIPAS.id || id == NYLOCAS_VASILIAS_ENTRY.id
                || id == NYLOCAS_VASILIAS_REGULAR.id || id == NYLOCAS_VASILIAS_HARD.id;
    }

    public static boolean isSotetsegIdle(int id) {
        return idMatches(id, SOTETSEG_IDLE_ENTRY, SOTETSEG_IDLE_REGULAR, SOTETSEG_IDLE_HARD);
    }

    public static boolean isSotetseg(int id) {
        return idMatches(id, SOTETSEG_ENTRY, SOTETSEG_REGULAR, SOTETSEG_HARD);
    }

    public static boolean isAnySotetseg(int id) {
        return isSotetsegIdle(id) || isSotetseg(id);
    }

    public static boolean isXarpusIdle(int id) {
        return idMatches(id, XARPUS_IDLE_ENTRY, XARPUS_IDLE_REGULAR, XARPUS_IDLE_HARD);
    }

    public boolean isXarpusIdle() {
        return isXarpusIdle(this.id);
    }

    public static boolean isXarpusP1(int id) {
        return idMatches(id, XARPUS_P1_ENTRY, XARPUS_P1_REGULAR, XARPUS_P1_HARD);
    }

    public boolean isXarpusP1() {
        return isXarpusP1(this.id);
    }

    public static boolean isXarpus(int id) {
        return idMatches(id, XARPUS_ENTRY, XARPUS_REGULAR, XARPUS_HARD);
    }

    public boolean isXarpus() {
        return isXarpus(this.id);
    }

    public static boolean isAnyXarpus(int id) {
        return isXarpusIdle(id) || isXarpusP1(id) || isXarpus(id);
    }

    public boolean isAnyXarpus() {
        return isXarpusIdle() || isXarpusP1() || isXarpus();
    }

    public static boolean isVerzikIdle(int id) {
        return idMatches(id, VERZIK_IDLE_ENTRY, VERZIK_IDLE_REGULAR, VERZIK_IDLE_REGULAR_QS, VERZIK_IDLE_HARD, VERZIK_IDLE_HARD_QS);
    }

    public boolean isVerzikIdle() {
        return isVerzikIdle(this.id);
    }

    public static boolean isVerzikP1(int id) {
        return idMatches(id, VERZIK_P1_ENTRY, VERZIK_P1_REGULAR, VERZIK_P1_HARD);
    }

    public boolean isVerzikP1() {
        return isVerzikP1(this.id);
    }

    public static boolean isVerzikP1Transition(int id) {
        return idMatches(id, VERZIK_P1_TRANSITION_ENTRY, VERZIK_P1_TRANSITION_REGULAR, VERZIK_P1_TRANSITION_HARD);
    }

    public boolean isVerzikP1Transition() {
        return isVerzikP1Transition(this.id);
    }

    public static boolean isVerzikP2(int id) {
        return idMatches(id, VERZIK_P2_ENTRY, VERZIK_P2_REGULAR, VERZIK_P2_HARD);
    }

    public boolean isVerzikP2() {
        return isVerzikP2(this.id);
    }

    public static boolean isVerzikP3(int id) {
        return idMatches(id, VERZIK_P3_ENTRY, VERZIK_P3_REGULAR, VERZIK_P3_HARD);
    }

    public boolean isVerzikP3() {
        return isVerzikP3(this.id);
    }

    public static boolean isAnyVerzik(int id) {
        return isVerzikIdle(id) || isVerzikP1(id) || isVerzikP1Transition(id) || isVerzikP2(id) || isVerzikP3(id);
    }

    public boolean isAnyVerzik() {
        return isAnyVerzik(this.id);
    }

    public static boolean isVerzikIschyros(int id) {
        return idMatches(
                id, VERZIK_NYLOCAS_ISCHYROS_ENTRY, VERZIK_NYLOCAS_ISCHYROS_REGULAR, VERZIK_NYLOCAS_ISCHYROS_HARD);
    }

    public static boolean isVerzikToxobolos(int id) {
        return idMatches(
                id, VERZIK_NYLOCAS_TOXOBOLOS_ENTRY, VERZIK_NYLOCAS_TOXOBOLOS_REGULAR, VERZIK_NYLOCAS_TOXOBOLOS_HARD);
    }

    public static boolean isVerzikHagios(int id) {
        return idMatches(id, VERZIK_NYLOCAS_HAGIOS_ENTRY, VERZIK_NYLOCAS_HAGIOS_REGULAR, VERZIK_NYLOCAS_HAGIOS_HARD);
    }

    public static boolean isVerzikCrab(int id) {
        return isVerzikIschyros(id) || isVerzikToxobolos(id) || isVerzikHagios(id);
    }

    public boolean isVerzikCrab() {
        return isVerzikCrab(this.id);
    }

    public static boolean isVerzikAthanatos(int id) {
        return idMatches(id, VERZIK_ATHANATOS_ENTRY, VERZIK_ATHANATOS_REGULAR, VERZIK_ATHANATOS_HARD);
    }

    public boolean isVerzikAthanatos() {
        return isVerzikAthanatos(this.id);
    }

    public static boolean isVerzikMatomenos(int id) {
        return idMatches(id, VERZIK_MATOMENOS_ENTRY, VERZIK_MATOMENOS_REGULAR, VERZIK_MATOMENOS_HARD);
    }

    public boolean isVerzikMatomenos() {
        return isVerzikMatomenos(this.id);
    }

    public int getBaseHitpoints(int scale) {
        if (scale < 1 || scale > 5) {
            return -1;
        }

        if (mode == ChallengeMode.TOB_ENTRY) {
            if (isNylocas(this.id)) {
                return hitpointsByScale[0];
            }
            // Entry mode scales hitpoints linearly with party size.
            return hitpointsByScale[0] * scale;
        }

        switch (scale) {
            case 5:
                return hitpointsByScale[2];
            case 4:
                return hitpointsByScale[1];
            default:
                return hitpointsByScale[0];
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob;

import io.blert.core.BasicTrackedNpc;
import io.blert.core.Hitpoints;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.api.NPC;

/**
 * A tracked NPC whose hitpoints are periodically updated from a varbit.
 */
@Getter
@Setter
public class HpVarbitTrackedNpc extends BasicTrackedNpc {
    boolean disableVarbitUpdates;

    public HpVarbitTrackedNpc(@NonNull NPC npc, TobNpc tobNpc, long roomId, Hitpoints hitpoints) {
        super(npc, tobNpc, roomId, hitpoints);
        this.disableVarbitUpdates = false;
    }

    public void updateHitpointsFromVarbit(int varbitValue) {
        if (disableVarbitUpdates) {
            return;
        }

        // The varbit stores a value from 0 to 1000, representing the percentage of hitpoints remaining
        // to a tenth of a percent.
        double ratio = varbitValue / 1000.0;
        int updatedHitpoints = (int) (getHitpoints().getBase() * ratio);
        int currentHitpoints = getHitpoints().getCurrent();

        // As bosses can have several thousands of hitpoints, the calculated value is not entirely precise.
        // If the current value is within a few hitpoints of the calculated value, assume that it is correct.
        if (Math.abs(currentHitpoints - updatedHitpoints) > 5) {
            Hitpoints newHitpoints = getHitpoints().update(updatedHitpoints);
            setHitpoints(newHitpoints);
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob;

import io.blert.challenges.tob.rooms.Room;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

public enum Location {
    ELSEWHERE,  // Anywhere but TOB (why?)
    LOBBY,
    MAIDEN_INSTANCE,
    MAIDEN_ROOM,
    BLOAT_INSTANCE,
    BLOAT_ROOM,
    NYLOCAS_INSTANCE,
    NYLOCAS_ROOM,
    SOTETSEG_INSTANCE,
    SOTETSEG_ROOM,
    SOTETSEG_MAZE,
    XARPUS_INSTANCE,
    XARPUS_ROOM,
    VERZIK_INSTANCE,
    VERZIK_ROOM,
    LOOT_ROOM;

    private static final int LOBBY_REGION_ID = 14642;

    // The corridor leading up to Maiden.
    private static final int CORRIDOR_REGION_ID = 12869;
    private static final int MAIDEN_REGION_ID = 12613;

    private static final int BLOAT_REGION_ID = 13125;
    private static final int NYLOCAS_REGION_ID = 13122;
    private static final int SOTETSEG_REGION_ID = 13123;
    private static final int SOTETSEG_MAZE_REGION_ID = 13379;
    private static final int XARPUS_REGION_ID = 12612;
    private static final int VERZIK_REGION_ID = 12611;

    private static final int LOOT_ROOM_REGION_ID = 12867;

    private static final WorldArea MAIDEN_ROOM_AREA = new WorldArea(3159, 4434, 29, 25, 0);
    private static final WorldArea MAIDEN_STAIRCASE_AREA = new WorldArea(3185, 4444, 3, 6, 0);
    private static final WorldArea BLOAT_ROOM_AREA = new WorldArea(3287, 4439, 18, 17, 0);
    private static final WorldArea NYLOCAS_ROOM_AREA = new WorldArea(3276, 4228, 38, 27, 0);
    private static final WorldArea SOTETSEG_ROOM_AREA = new WorldArea(3271, 4304, 17, 30, 0);
    private static final WorldArea SOTETSEG_STAIRCASE_AREA = new WorldArea(3277, 4304, 6, 3, 0);
    private static final WorldArea XARPUS_ROOM_AREA = new WorldArea(3162, 4379, 17, 17, 0);
    private static final WorldArea VERZIK_ROOM_AREA = new WorldArea(3154, 4302, 28, 21, 0);

    public static Location fromWorldPoint(WorldPoint worldPoint) {
        switch (worldPoint.getRegionID()) {
            case LOBBY_REGION_ID:
                return LOBBY;
            case CORRIDOR_REGION_ID:
            case MAIDEN_REGION_ID:
                if (MAIDEN_ROOM_AREA.contains2D(worldPoint) && !MAIDEN_STAIRCASE_AREA.contains2D(worldPoint)) {
                    return MAIDEN_ROOM;
                }
                return MAIDEN_INSTANCE;
            case BLOAT_REGION_ID:
                return BLOAT_ROOM_AREA.contains2D(worldPoint) ? BLOAT_ROOM : BLOAT_INSTANCE;
            case NYLOCAS_REGION_ID:
                return NYLOCAS_ROOM_AREA.contains2D(worldPoint) ? NYLOCAS_ROOM : NYLOCAS_INSTANCE;
            case SOTETSEG_REGION_ID:
                if (SOTETSEG_ROOM_AREA.contains2D(worldPoint) && !SOTETSEG_STAIRCASE_AREA.contains2D(worldPoint)) {
                    return SOTETSEG_ROOM;
                }
                return SOTETSEG_INSTANCE;
            case SOTETSEG_MAZE_REGION_ID:
                return SOTETSEG_MAZE;
            case XARPUS_REGION_ID:
                return XARPUS_ROOM_AREA.contains2D(worldPoint) ? XARPUS_ROOM : XARPUS_INSTANCE;
            case VERZIK_REGION_ID:
                return VERZIK_ROOM_AREA.contains2D(worldPoint) ? VERZIK_ROOM : VERZIK_INSTANCE;
            case LOOT_ROOM_REGION_ID:
                return LOOT_ROOM;
            default:
                return ELSEWHERE;
        }
    }

    public boolean inRoom(Room room) {
        switch (room) {
            case MAIDEN:
                return inMaiden();
            case BLOAT:
                return inBloat();
            case NYLOCAS:
                return inNylocas();
            case SOTETSEG:
                return inSotetseg();
            case XARPUS:
                return inXarpus();
            case VERZIK:
                return inVerzik();
            default:
                return false;
        }
    }

    public boolean inRoomInstance(Room room) {
        switch (room) {
            case MAIDEN:
                return inMaidenInstance();
            case BLOAT:
                return inBloatInstance();
            case NYLOCAS:
                return inNylocasInstance();
            case SOTETSEG:
                return inSotetsegInstance();
            case XARPUS:
                return inXarpusInstance();
            case VERZIK:
                return inVerzikInstance();
            default:
                return false;
        }
    }

    public boolean inRaid() {
        return this != ELSEWHERE && this != LOBBY;
    }

    public boolean inMaidenInstance() {
        return this == MAIDEN_INSTANCE || inMaiden();
    }

    public boolean inMaiden() {
        return this == MAIDEN_ROOM;
    }

    public boolean inBloatInstance() {
        return this == BLOAT_INSTANCE || inBloat();
    }

    public boolean inBloat() {
        return this == BLOAT_ROOM;
    }

    public boolean inNylocasInstance() {
        return this == NYLOCAS_INSTANCE || inNylocas();
    }

    public boolean inNylocas() {
        return this == NYLOCAS_ROOM;
    }

    public boolean inSotetsegInstance() {
        return this == SOTETSEG_INSTANCE || inSotetseg();
    }

    public boolean inSotetseg() {
        return this == SOTETSEG_ROOM || this == SOTETSEG_MAZE;
    }

    public boolean inSotetsegOverworld() {
        return this == SOTETSEG_INSTANCE || this == SOTETSEG_ROOM;
    }

    public boolean inSotetsegUnderworld() {
        return this == SOTETSEG_MAZE;
    }

    public boolean inXarpusInstance() {
        return this == XARPUS_INSTANCE || inXarpus();
    }

    public boolean inXarpus() {
        return this == XARPUS_ROOM;
    }

    public boolean inVerzikInstance() {
        return this == VERZIK_INSTANCE || inVerzik();
    }

    public boolean inVerzik() {
        return this == VERZIK_ROOM;
    }

    public boolean isInstance() {
        return this == MAIDEN_INSTANCE || this == BLOAT_INSTANCE || this == NYLOCAS_INSTANCE
                || this == SOTETSEG_INSTANCE || this == XARPUS_INSTANCE || this == VERZIK_INSTANCE;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob;

import java.util.Optional;

/**
 * State of rooms in a ToB raid.
 * The ordinal values of this enum correspond to values of the TOB_ROOM_STATUS client varbit.
 */
public enum RoomState {
    INACTIVE,
    // The actual boss fight.
    BOSS,
    // A special phase in a boss fight (Sote maze, Xarpus exhumes).
    SPECIAL,
    // P1 has its own status value for some reason (thanks Jagex).
    VERZIK_P1;

    public static Optional<RoomState> fromVarbit(int varbit) {
        switch (varbit) {
            case 0:
                return Optional.of(INACTIVE);
            case 1:
                return Optional.of(BOSS);
            case 2:
                return Optional.of(SPECIAL);
            case 3:
                return Optional.of(VERZIK_P1);
            default:
                return Optional.empty();
        }
    }

    public boolean isActive() {
        return this != INACTIVE;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.verzik;

public enum VerzikSpecial {
    CRABS,
    WEBS,
    YELLOWS,
    BALL;

    public VerzikSpecial next() {
        switch (this) {
            case CRABS:
                return WEBS;
            case WEBS:
                return YELLOWS;
            case YELLOWS:
                return BALL;
            default:
                return CRABS;
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.verzik;

import com.google.common.collect.ImmutableSet;
import io.blert.challenges.tob.HpVarbitTrackedNpc;
import io.blert.challenges.tob.TheatreChallenge;
import io.blert.challenges.tob.TobNpc;
import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.RoomDataTracker;
import io.blert.core.*;
import io.blert.events.NpcAttackEvent;
import io.blert.events.tob.VerzikAttackStyleEvent;
import io.blert.events.tob.VerzikPhaseEvent;
import io.blert.events.tob.VerzikRedsSpawnEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.*;

@Slf4j
public class VerzikDataTracker extends RoomDataTracker {
    private static final int P1_AUTO_ANIMATION = 8109;
    private static final int P2_AUTO_ANIMATION = 8114;
    private static final int P2_BOUNCE_ANIMATION = 8116;
    private static final int P3_TRANSITION_ANIMATION = 8118;

    private static final int P2_CABBAGE_PROJECTILE = 1583;
    private static final int P2_ZAP_PROJECTILE = 1585;
    private static final int P2_PURPLE_PROJECTILE = 1586;
    private static final int P2_MAGE_PROJECTILE = 1591;
    private static final int P3_RANGE_PROJECTILE = 1593;
    private static final int P3_MAGE_PROJECTILE = 1594;

    private static final int P1_ATTACK_SPEED = 14;
    private static final int P2_ATTACK_SPEED = 4;
    private static final int P2_TICKS_BEFORE_FIRST_ATTACK_AFTER_SPAWN = 3;
    private static final int P2_TICKS_BEFORE_FIRST_ATTACK_AFTER_REDS = 12;
    private static final int P2_ATTACKS_PER_REDS = 7;
    private static final int P3_ATTACK_SPEED = 7;
    private static final int P3_ENRAGED_ATTACK_SPEED = 5;
    private static final int P3_TICKS_BEFORE_FIRST_ATTACK = 12;
    private static final int P3_GREEN_BALL_TICK_DELAY = 12;
    private static final int P3_ATTACKS_BEFORE_SPECIAL = 4;

    private static final ImmutableSet<Integer> VERZIK_WEB_IDS = ImmutableSet.of(8376, 10837, 10854);
    private static final int VERZIK_YELLOW_OBJECT_ID = 1595;

    private HpVarbitTrackedNpc verzik;

    private VerzikPhase phase;
    int phaseStartTick;

    private int unidentifiedVerzikAttackTick;
    private int nextVerzikAttackTick;
    private final Set<Number> p3MeleeChanceTicks = new HashSet<>();
    private int firstP3AttackTick;
    private @Nullable NpcAttack nextVerzikAttack;
    private int verzikAttacksUntilSpecial;
    private final P2AttackTracker p2AttackTracker = new P2AttackTracker();
    private @Nullable VerzikSpecial activeSpecial;
    private VerzikSpecial nextSpecial;
    boolean enraged;

    private int redCrabsTick;
    private int redCrabSpawnCount;
    private final List<BasicTrackedNpc> pillars = new ArrayList<>();
    private final Set<VerzikCrab> explodingCrabs = new HashSet<>();
    private final Set<BasicTrackedNpc> specialCrabs = new HashSet<>();
    private final List<WorldPoint> yellowPools = new ArrayList<>();

    private static class P2AttackTracker {
        private static final int MIN_ATTACKS_BEFORE_ZAP = 4;
        // This isn't the actual minimum, it's just large enough to avoid false
        // positives, even when accounting for client lag.
        private static final int MIN_ATTACKS_BEFORE_PURPLE = 16;

        private int untilZap;
        private int untilPurple;
        private boolean foundAttack;

        P2AttackTracker() {
            this.untilZap = 0;
            this.untilPurple = 0;
            this.foundAttack = false;
        }

        NpcAttack checkProjectile(Projectile projectile) {
            if (foundAttack) {
                return null;
            }

            NpcAttack attack = null;

            switch (projectile.getId()) {
                case P2_CABBAGE_PROJECTILE:
                    attack = NpcAttack.TOB_VERZIK_P2_CABBAGE;
                    break;
                case P2_ZAP_PROJECTILE:
                    if (untilZap <= 0) {
                        attack = NpcAttack.TOB_VERZIK_P2_ZAP;
                    }
                    break;
                case P2_PURPLE_PROJECTILE:
                    if (untilPurple <= 0) {
                        attack = NpcAttack.TOB_VERZIK_P2_PURPLE;
                    }
                    break;
                case P2_MAGE_PROJECTILE:
                    attack = NpcAttack.TOB_VERZIK_P2_MAGE;
                    break;
            }

            if (attack != null) {
                foundAttack = true;
            }

            return attack;
        }

        void trackAttack(@Nonnull NpcAttack attack) {
            foundAttack = false;

            if (attack == NpcAttack.TOB_VERZIK_P2_PURPLE) {
                untilPurple = MIN_ATTACKS_BEFORE_PURPLE;
            } else {
                untilPurple--;
            }

            if (attack == NpcAttack.TOB_VERZIK_P2_ZAP) {
                untilZap = MIN_ATTACKS_BEFORE_ZAP;
            } else {
                untilZap--;
            }
        }

        void reset() {
            untilZap = 0;
            untilPurple = 0;
            foundAttack = false;
        }
    }

    public VerzikDataTracker(TheatreChallenge manager, Client client) {
        super(manager, client, Room.VERZIK);
        this.phase = VerzikPhase.IDLE;
        this.unidentifiedVerzikAttackTick = -1;
        this.nextVerzikAttackTick = -1;
        this.firstP3AttackTick = -1;
        this.nextVerzikAttack = null;
        this.verzikAttacksUntilSpecial = -1;
        this.redCrabsTick = -1;
        this.redCrabSpawnCount = 0;
        this.enraged = false;
        this.activeSpecial = null;
    }

    @Override
    protected void onRoomStart() {
        client.getTopLevelWorldView().npcs().stream().filter(npc -> TobNpc.isAnyVerzik(npc.getId())).findFirst().ifPresent(npc -> {
            TobNpc tobNpc = TobNpc.withId(npc.getId()).orElseThrow();

            if (verzik == null) {
                verzik = new HpVarbitTrackedNpc(npc, tobNpc, generateRoomId(npc),
                        new Hitpoints(tobNpc, theatreChallenge.getScale()));
                addTrackedNpc(verzik);
            }

            if (tobNpc.isVerzikP1()) {
                startVerzikPhase(VerzikPhase.P1, getTick(), true);
            } else if (tobNpc.isVerzikP2()) {
                startVerzikPhase(VerzikPhase.P2, getTick(), true);
            } else if (tobNpc.isVerzikP3()) {
                startVerzikPhase(VerzikPhase.P3, getTick(), true);
            }
        });
        phaseStartTick = 0;
    }

    @Override
    protected void onTick() {
        super.onTick();
        final int tick = getTick();

        if (tick == redCrabsTick) {
            if (redCrabSpawnCount == 1) {
                log.debug("Reds: {} ({})", tick, formattedRoomTime());
            }

            // TODO(frolv): Remove this in favor of the generic NPC spawn event.
            dispatchEvent(new VerzikRedsSpawnEvent(tick));
        }

        if (phase == VerzikPhase.P3 && tick == nextVerzikAttackTick - 1) {
            checkForMeleeChance();
        }

        if (tick == nextVerzikAttackTick) {
            handleVerzikAttack(tick);
        }

        if (phase == VerzikPhase.P3) {
            checkForEnrage(tick);
        }

        if (activeSpecial != null && verzik.getNpc().getInteracting() != null) {
            // Once Verzik targets a player, her special attack has ended.
            if (activeSpecial == VerzikSpecial.YELLOWS) {
                nextVerzikAttackTick = tick + 7;
            } else {
                nextVerzikAttackTick = tick + 10;
            }

            activeSpecial = null;
            yellowPools.clear();
        }

        if (tick > phaseStartTick + 5 && verzik != null) {
            // After the phase has been active for several ticks, re-enable varbit updates.
            verzik.setDisableVarbitUpdates(false);
        }
    }

    @Override
    protected Optional<? extends TrackedNpc> onNpcSpawn(NpcSpawned event) {
        NPC npc = event.getNpc();
        final int tick = getTick();

        if (activeSpecial == null && VERZIK_WEB_IDS.contains(npc.getId())) {
            activeSpecial = VerzikSpecial.WEBS;
            return Optional.empty();
        }

        if (npc.getId() == NpcID.SUPPORTING_PILLAR) {
            BasicTrackedNpc pillar = new BasicTrackedNpc(npc, TobNpc.VERZIK_PILLAR, generateRoomId(npc), new Hitpoints(0));
            pillars.add(pillar);
            return Optional.of(pillar);
        }

        if (npc.getId() == NpcID.COLLAPSING_PILLAR) {
            // Find the pillar that collapsed and despawn it.
            pillars.stream()
                    .filter(pillar -> npc.getWorldArea().contains2D(pillar.getNpc().getWorldLocation()))
                    .findFirst()
                    .ifPresent(collapsed -> {
                        pillars.remove(collapsed);
                        despawnTrackedNpc(collapsed);
                    });
            return Optional.empty();
        }

        var maybeNpc = TobNpc.withId(npc.getId());
        if (maybeNpc.isEmpty()) {
            return Optional.empty();
        }
        TobNpc tobNpc = maybeNpc.get();

        if (tobNpc.isAnyVerzik()) {
            long roomId = verzik != null ? verzik.getRoomId() : generateRoomId(npc);
            verzik = new HpVarbitTrackedNpc(npc, tobNpc, roomId, new Hitpoints(tobNpc, theatreChallenge.getScale()));
            return Optional.of(verzik);
        }

        if (tobNpc.isVerzikCrab()) {
            WorldPoint point = getWorldLocation(npc);
            long roomId = generateRoomId(npc);
            VerzikCrab crab = VerzikCrab.fromSpawnedNpc(npc, tobNpc, roomId, point, theatreChallenge.getScale(), phase);

            explodingCrabs.add(crab);
            return Optional.of(crab);
        }

        if (tobNpc.isVerzikAthanatos()) {
            BasicTrackedNpc purpleCrab = new BasicTrackedNpc(npc, tobNpc, generateRoomId(npc),
                    new Hitpoints(tobNpc, theatreChallenge.getScale()));
            specialCrabs.add(purpleCrab);
            return Optional.of(purpleCrab);
        }

        if (tobNpc.isVerzikMatomenos()) {
            if (tick != redCrabsTick) {
                startNewRedsPhase(tick);
            }

            BasicTrackedNpc crab = new BasicTrackedNpc(npc, tobNpc, generateRoomId(npc),
                    new Hitpoints(tobNpc, theatreChallenge.getScale()));
            specialCrabs.add(crab);
            return Optional.of(crab);
        }

        return Optional.empty();
    }

    @Override
    protected boolean onNpcDespawn(NpcDespawned event, TrackedNpc trackedNpc) {
        NPC npc = event.getNpc();

        if (TobNpc.isVerzikMatomenos(npc.getId()) || TobNpc.isVerzikAthanatos(npc.getId())) {
            return trackedNpc instanceof BasicTrackedNpc && specialCrabs.remove(trackedNpc);
        }

        if (TobNpc.isVerzikCrab(npc.getId())) {
            return trackedNpc instanceof VerzikCrab && explodingCrabs.remove(trackedNpc);
        }

        if (TobNpc.isVerzikP1(npc.getId())) {
            final int tick = getTick();
            log.debug("P1: {} ({})", tick, formattedRoomTime());
            dispatchEvent(new VerzikPhaseEvent(tick, VerzikPhase.P2));
        }

        // Verzik despawns between phases, but it should not be counted as a final despawn until the end of the fight.
        return trackedNpc == verzik && phase == VerzikPhase.P3;
    }

    @Override
    protected void onNpcChange(NpcChanged changed) {
        NPC npc = changed.getNpc();
        int beforeId = changed.getOld().getId();

        final int tick = getTick();

        var maybeVerzik = TobNpc.withId(npc.getId());
        if (maybeVerzik.isEmpty()) {
            return;
        }
        TobNpc tobNpc = maybeVerzik.get();

        if (TobNpc.isVerzikIdle(beforeId) && tobNpc.isVerzikP1()) {
            startRoom();
            return;
        }

        if (TobNpc.isVerzikP1Transition(beforeId) && tobNpc.isVerzikP2()) {
            startVerzikPhase(VerzikPhase.P2, tick, false);

            // A transition from P1 to P2 does not spawn a new NPC. Simply reset Verzik's HP to its P2 value.
            verzik.setHitpoints(new Hitpoints(tobNpc, theatreChallenge.getScale()));
        }
    }

    @Override
    protected void onAnimation(AnimationChanged event) {
        Actor actor = event.getActor();
        if (!(actor instanceof NPC)) {
            return;
        }

        final int npcId = ((NPC) actor).getId();
        final int animationId = actor.getAnimation();
        final int tick = getTick();

        if (phase == VerzikPhase.P2 && TobNpc.isVerzikP2(npcId) && animationId == P3_TRANSITION_ANIMATION) {
            startVerzikPhase(VerzikPhase.P3, tick, true);
            firstP3AttackTick = nextVerzikAttackTick;
            log.debug("P2: {} ({})", tick, formattedRoomTime());
            return;
        }

        if (verzik != null && actor == verzik.getNpc()) {
            if (animationId == P1_AUTO_ANIMATION && phase == VerzikPhase.P1) {
                nextVerzikAttackTick = tick + 1;
                nextVerzikAttack = NpcAttack.TOB_VERZIK_P1_AUTO;
                return;
            }

            if (animationId == P2_AUTO_ANIMATION && phase == VerzikPhase.P2) {
                nextVerzikAttackTick = tick;
                return;
            }

            if (animationId == P2_BOUNCE_ANIMATION && phase == VerzikPhase.P2) {
                nextVerzikAttack = NpcAttack.TOB_VERZIK_P2_BOUNCE;
            }
        }
    }

    @Override
    protected void onProjectile(ProjectileMoved event) {
        final int tick = getTick();
        Projectile projectile = event.getProjectile();

        if (phase == VerzikPhase.P2 && tick == nextVerzikAttackTick && nextVerzikAttack == null) {
            if (tick != redCrabsTick) {
                nextVerzikAttack = p2AttackTracker.checkProjectile(projectile);
            }
        }

        if (phase == VerzikPhase.P3) {
            int totalCycles = projectile.getEndCycle() - projectile.getStartCycle();
            if (projectile.getRemainingCycles() != totalCycles) {
                return;
            }

            VerzikAttackStyleEvent.Style style;
            switch (event.getProjectile().getId()) {
                case P3_RANGE_PROJECTILE:
                    style = VerzikAttackStyleEvent.Style.RANGE;
                    break;
                case P3_MAGE_PROJECTILE:
                    style = VerzikAttackStyleEvent.Style.MAGE;
                    break;
                default:
                    return;
            }

            if (unidentifiedVerzikAttackTick != -1) {
                dispatchEvent(new VerzikAttackStyleEvent(tick, style, unidentifiedVerzikAttackTick));
                unidentifiedVerzikAttackTick = -1;
            }
        }
    }

    @Override
    protected void onGraphicsObjectCreation(GraphicsObjectCreated event) {
        GraphicsObject obj = event.getGraphicsObject();
        if (obj.getId() != VERZIK_YELLOW_OBJECT_ID) {
            return;
        }

        long totalYellows = theatreChallenge.getParty().stream().filter(Raider::isAlive).count();
        if (theatreChallenge.getChallengeMode() == ChallengeMode.TOB_HARD) {
            totalYellows *= 3;
        }

        if (yellowPools.isEmpty()) {
            activeSpecial = VerzikSpecial.YELLOWS;
        }

        if (yellowPools.size() <= totalYellows) {
            yellowPools.add(WorldPoint.fromLocalInstance(client, obj.getLocation()));
        }
    }

    private void checkForMeleeChance() {
        if (nextVerzikAttackTick == firstP3AttackTick) {
            // First P3 attack can't be melee.
            return;
        }

        Actor tank = verzik.getNpc().getInteracting();
        if (!(tank instanceof Player)) {
            return;
        }

        WorldArea verzikArea = verzik.getNpc().getWorldArea();
        boolean isMeleeDistance = verzikArea.isInMeleeDistance(tank.getWorldLocation());
        boolean isUnderVerzik = verzikArea.contains(tank.getWorldLocation());
        if (isMeleeDistance && !isUnderVerzik) {
            log.debug("Player {} chanced a melee on tick {} ({})",
                    tank.getName(), getTick(), formattedRoomTime());
            p3MeleeChanceTicks.add(nextVerzikAttackTick);
        }
    }

    private void handleVerzikAttack(int tick) {
        switch (phase) {
            case P1:
                // No special handling required.
                break;

            case P2:
                if (nextVerzikAttack == null && tick != redCrabsTick) {
                    for (Projectile projectile : client.getProjectiles()) {
                        NpcAttack maybeAttack =
                                p2AttackTracker.checkProjectile(projectile);
                        if (maybeAttack != null) {
                            nextVerzikAttack = maybeAttack;
                            break;
                        }
                    }
                }

                if (nextVerzikAttack != null) {
                    p2AttackTracker.trackAttack(nextVerzikAttack);
                }

                if (verzikAttacksUntilSpecial > 0) {
                    verzikAttacksUntilSpecial--;
                }
                if (redCrabSpawnCount > 0 && verzikAttacksUntilSpecial == 0) {
                    // Last auto before the next reds phase.
                    nextVerzikAttackTick = -1;
                }
                break;

            case P3:
                if (unidentifiedVerzikAttackTick != -1) {
                    // No projectiles were recorded since the last Verzik
                    // attack. Check if it could have been a melee attack.
                    if (p3MeleeChanceTicks.contains(unidentifiedVerzikAttackTick)) {
                        dispatchEvent(new VerzikAttackStyleEvent(
                                tick, VerzikAttackStyleEvent.Style.MELEE, unidentifiedVerzikAttackTick));
                    }
                    unidentifiedVerzikAttackTick = -1;
                }

                if (verzikAttacksUntilSpecial == 0) {
                    verzikAttacksUntilSpecial = P3_ATTACKS_BEFORE_SPECIAL;
                    WorldPoint point = getWorldLocation(verzik);

                    switch (nextSpecial) {
                        case BALL:
                            // Green ball occurs alongside a regular Verzik attack, and delays her next attack by 12
                            // ticks total.
                            // TODO(frolv): `unidentifiedVerzikAttackTick` is deliberately not set here, as the green
                            // ball projectile seems to hide the regular attack projectiles. Investigate this further.
                            dispatchEvent(new NpcAttackEvent(getStage(), tick, point, NpcAttack.TOB_VERZIK_P3_BALL, verzik));
                            nextSpecial = nextSpecial.next();
                            verzikAttacksUntilSpecial += 1;
                            nextVerzikAttackTick += P3_GREEN_BALL_TICK_DELAY - attackSpeed();
                            break;

                        case CRABS:
                            // Crabs occur alongside a regular Verzik attack whose projectile is identifiable.
                            nextSpecial = nextSpecial.next();
                            verzikAttacksUntilSpecial += 1;
                            unidentifiedVerzikAttackTick = tick;
                            break;

                        case WEBS:
                        case YELLOWS:
                            NpcAttack attack = nextSpecial == VerzikSpecial.WEBS
                                    ? NpcAttack.TOB_VERZIK_P3_WEBS
                                    : NpcAttack.TOB_VERZIK_P3_YELLOWS;
                            dispatchEvent(new NpcAttackEvent(getStage(), tick, point, attack, verzik));

                            // Other specials pause the attack cycle until they are completed.
                            p3MeleeChanceTicks.remove(tick);
                            nextSpecial = nextSpecial.next();
                            nextVerzikAttackTick = -1;
                            nextVerzikAttack = null;
                            return;
                    }
                } else {
                    // Verzik is performing a regular attack on this tick, without a stacked special.
                    // Mark the attack as unidentified.
                    unidentifiedVerzikAttackTick = tick;
                }

                nextVerzikAttack = NpcAttack.TOB_VERZIK_P3_AUTO;
                verzikAttacksUntilSpecial--;
                break;

            default:
                nextVerzikAttack = null;
                nextVerzikAttackTick = -1;
                return;
        }

        if (nextVerzikAttack != null && verzik != null) {
            dispatchEvent(new NpcAttackEvent(getStage(), tick, getWorldLocation(verzik), nextVerzikAttack, verzik));
        }

        nextVerzikAttackTick += attackSpeed();
        nextVerzikAttack = null;
    }

    private void checkForEnrage(int tick) {
        if (enraged) {
            return;
        }

        if (verzik.getHitpoints().percentage() < 25.0 && verzik.getNpc().getOverheadText() != null) {
            enraged = true;
            if (activeSpecial != VerzikSpecial.WEBS) {
                nextVerzikAttackTick = tick + P3_ENRAGED_ATTACK_SPEED;
            }
        }
    }

    private void startVerzikPhase(VerzikPhase phase, int tick, boolean dispatchPhaseEvent) {
        this.phase = phase;
        phaseStartTick = tick;
        nextVerzikAttack = null;
        unidentifiedVerzikAttackTick = -1;

        if (phase == VerzikPhase.P2) {
            nextVerzikAttackTick = tick + P2_TICKS_BEFORE_FIRST_ATTACK_AFTER_SPAWN;
            p2AttackTracker.reset();
        } else if (phase == VerzikPhase.P3) {
            nextVerzikAttackTick = tick + P3_TICKS_BEFORE_FIRST_ATTACK;
            p3MeleeChanceTicks.clear();
            verzikAttacksUntilSpecial = P3_ATTACKS_BEFORE_SPECIAL;
            nextSpecial = VerzikSpecial.CRABS;
            activeSpecial = null;
            enraged = false;
        } else {
            nextVerzikAttackTick = -1;
        }

        if (verzik != null) {
            // Temporarily disable varbit updates at the start of a phase as the varbit lags behind, so it may reset
            // the HP to 0 from the previous phase.
            verzik.setDisableVarbitUpdates(true);
        }

        if (dispatchPhaseEvent && phase != VerzikPhase.P1) {
            dispatchEvent(new VerzikPhaseEvent(tick, phase));
        }
    }

    private void startNewRedsPhase(int tick) {
        redCrabsTick = tick;
        redCrabSpawnCount++;
        verzikAttacksUntilSpecial = P2_ATTACKS_PER_REDS;
        nextVerzikAttack = null;
        nextVerzikAttackTick = tick + P2_TICKS_BEFORE_FIRST_ATTACK_AFTER_REDS;
    }

    private int attackSpeed() {
        switch (phase) {
            case P1:
                return P1_ATTACK_SPEED;
            case P2:
                return P2_ATTACK_SPEED;
            case P3:
                return enraged ? P3_ENRAGED_ATTACK_SPEED : P3_ATTACK_SPEED;
            default:
                return -1;
        }
    }
}
/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.verzik;

public enum VerzikPhase {
    IDLE,
    P1,
    P2,
    P3,
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.verzik;

import io.blert.challenges.tob.TobNpc;
import io.blert.core.Hitpoints;
import io.blert.core.TrackedNpc;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;

public class VerzikCrab extends TrackedNpc {
    public enum Spawn {
        NORTH,
        NORTHEAST,
        NORTHWEST,
        EAST,
        SOUTH,
        SOUTHEAST,
        SOUTHWEST,
        WEST,
        UNKNOWN,
        SOUTH_FAR,
        CENTER,  // If Verzik is dragged.
    }

    @AllArgsConstructor
    @Getter
    public static class Properties extends TrackedNpc.Properties {
        private final VerzikPhase phase;
        private final Spawn spawn;
    }

    private final Properties properties;

    @Override
    public @NonNull TrackedNpc.Properties getProperties() {
        return properties;
    }

    static VerzikCrab fromSpawnedNpc(@NonNull NPC npc, @NonNull TobNpc tobNpc, long roomId,
                                     WorldPoint spawnPoint, int raidScale, VerzikPhase phase) {
        Spawn spawn;

        if (spawnPoint.equals(NORTH_SPAWN)) {
            spawn = Spawn.NORTH;
        } else if (spawnPoint.equals(NORTHEAST_SPAWN)) {
            spawn = Spawn.NORTHEAST;
        } else if (spawnPoint.equals(NORTHWEST_SPAWN)) {
            spawn = Spawn.NORTHWEST;
        } else if (spawnPoint.equals(EAST_SPAWN)) {
            spawn = Spawn.EAST;
        } else if (spawnPoint.equals(SOUTH_SPAWN)) {
            spawn = Spawn.SOUTH;
        } else if (spawnPoint.equals(SOUTH_FAR_SPAWN)) {
            spawn = Spawn.SOUTH_FAR;
        } else if (spawnPoint.equals(SOUTHEAST_SPAWN)) {
            spawn = Spawn.SOUTHEAST;
        } else if (spawnPoint.equals(SOUTHWEST_SPAWN)) {
            spawn = Spawn.SOUTHWEST;
        } else if (spawnPoint.equals(WEST_SPAWN)) {
            spawn = Spawn.WEST;
        } else if (spawnPoint.equals(CENTER_SPAWN)) {
            spawn = Spawn.CENTER;
        } else {
            spawn = Spawn.UNKNOWN;
        }

        return new VerzikCrab(npc, tobNpc, roomId, new Hitpoints(tobNpc, raidScale), phase, spawn);
    }

    private VerzikCrab(@NonNull NPC npc, @NonNull TobNpc tobNpc,
                       long roomId, Hitpoints hitpoints, VerzikPhase phase, Spawn spawn) {
        super(npc, tobNpc, roomId, hitpoints);
        this.properties = new Properties(phase, spawn);
    }

    private static final WorldPoint NORTH_SPAWN = new WorldPoint(3167, 4320, 0);
    private static final WorldPoint NORTHEAST_SPAWN = new WorldPoint(3177, 4319, 0);
    private static final WorldPoint NORTHWEST_SPAWN = new WorldPoint(3157, 4320, 0);
    private static final WorldPoint EAST_SPAWN = new WorldPoint(3176, 4315, 0);
    private static final WorldPoint SOUTH_SPAWN = new WorldPoint(3166, 4308, 0);
    private static final WorldPoint SOUTH_FAR_SPAWN = new WorldPoint(3171, 4303, 0);
    private static final WorldPoint SOUTHEAST_SPAWN = new WorldPoint(3179, 4310, 0);
    private static final WorldPoint SOUTHWEST_SPAWN = new WorldPoint(3157, 4311, 0);
    private static final WorldPoint WEST_SPAWN = new WorldPoint(3157, 4315, 0);
    private static final WorldPoint CENTER_SPAWN = new WorldPoint(3168, 4315, 0);
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.sotetseg;

import net.runelite.api.coords.WorldPoint;

public enum Maze {
    MAZE_66,
    MAZE_33;

    public static final WorldPoint OVERWORLD_MAZE_START = new WorldPoint(3273, 4310, 0);
    public static final WorldPoint UNDERWORLD_MAZE_START = new WorldPoint(3354, 4311, 3);
    public static final int WIDTH = 14;
    public static final int HEIGHT = 15;
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.sotetseg;

import com.google.common.collect.ImmutableList;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.tuple.Pair;

import java.util.*;

@Getter
@Slf4j
public class MazeTracker {
    /**
     * An infill path is an assumed path between two points in a Sotetseg maze.
     * <p>
     * Players can move diagonally and up to two tiles at a time, but the maze only runs in cardinal directions and
     * includes every tile. Therefore, the infill path is a series of steps that a player would take to move between
     * two points if they were constrained to the maze's grid.
     * <p>
     * An infill path is defined by the following three properties:
     * <ul>
     *     <li>{@code dx}: The horizontal distance between the start and end point, in the range {@code [-2, 2]}.</li>
     *     <li>{@code dy}: The vertical distance between the start and end point, in the range {@code [0, 2]}.
     *     (The maze only moves upwards.)</li>
     *     <li>{@code path}: A list of coordinates defining the path between the start and end points. The first
     *     coordinate is always {@code (0, 0)}, and the last coordinate is always {@code (dx, dy)}.</li>
     * </ul>
     */
    private static class InfillPath {
        private class PathIterator implements Iterator<WorldPoint> {
            private final WorldPoint origin;
            private int index = 0;

            PathIterator(WorldPoint origin) {
                this.origin = origin;
            }

            public boolean hasNext() {
                return index < path.length;
            }

            public WorldPoint next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }

                final Pair<Integer, Integer> step = path[index++];
                return new WorldPoint(origin.getX() + step.getLeft(), origin.getY() + step.getRight(), origin.getPlane());
            }
        }

        private final int dx;
        private final int dy;
        private final Pair<Integer, Integer>[] path;

        @SafeVarargs
        InfillPath(int dx, int dy, Pair<Integer, Integer>... path) {
            this.dx = dx;
            this.dy = dy;
            this.path = path;
        }

        public Iterator<WorldPoint> pathFrom(WorldPoint origin) {
            return new PathIterator(origin);
        }
    }

    // Infill paths starting from points on non-pivot rows.
    private static final ImmutableList<InfillPath> NON_PIVOT_INFILLS = ImmutableList.of(
            // Two steps left on a non-pivot row.
            //   o o o
            //   o o o
            //   E x S
            new InfillPath(-2, 0, Pair.of(0, 0), Pair.of(-1, 0), Pair.of(-2, 0)),
            // Single step left on a non-pivot row.
            //   o o o
            //   o o o
            //   o E S
            new InfillPath(-1, 0, Pair.of(0, 0), Pair.of(-1, 0)),
            // Single step right on a non-pivot row.
            //   o o o
            //   o o o
            //   S E o
            new InfillPath(1, 0, Pair.of(0, 0), Pair.of(1, 0)),
            // Two steps right on a non-pivot row.
            //   o o o
            //   o o o
            //   S x E
            new InfillPath(2, 0, Pair.of(0, 0), Pair.of(1, 0), Pair.of(2, 0)),
            // Two steps left and one step up on a non-pivot row (L-shape).
            //   o o o
            //   E o o
            //   x x S
            new InfillPath(-2, 1, Pair.of(0, 0), Pair.of(-1, 0), Pair.of(-2, 0), Pair.of(-2, 1)),
            // One step left and one step up on a non-pivot row (diagonal).
            //   o o o
            //   o E o
            //   o x S
            new InfillPath(-1, 1, Pair.of(0, 0), Pair.of(-1, 0), Pair.of(-1, 1)),
            // One step up on a non-pivot row.
            //   o o o
            //   o E o
            //   o S o
            new InfillPath(0, 1, Pair.of(0, 0), Pair.of(0, 1)),
            // One step right and one step up on a non-pivot row (diagonal).
            //   o o o
            //   o E o
            //   S x o
            new InfillPath(1, 1, Pair.of(0, 0), Pair.of(1, 0), Pair.of(1, 1)),
            // Two steps right and one step up on a non-pivot row (L-shape).
            //   o o o
            //   o o E
            //   S x x
            new InfillPath(2, 1, Pair.of(0, 0), Pair.of(1, 0), Pair.of(2, 0), Pair.of(2, 1)),
            // Two steps left and two steps up on a non-pivot row (diagonal).
            //   E x o
            //   o x o
            //   o x S
            new InfillPath(-2, 2, Pair.of(0, 0), Pair.of(-1, 0), Pair.of(-1, 1), Pair.of(-1, 2), Pair.of(-2, 2)),
            // One step left and two steps up on a non-pivot row (L-shape).
            //   E x o
            //   o x o
            //   o S o
            new InfillPath(-1, 2, Pair.of(0, 0), Pair.of(0, 1), Pair.of(0, 2), Pair.of(-1, 2)),
            // Two steps up on a non-pivot row.
            //   o E o
            //   o x o
            //   o S o
            new InfillPath(0, 2, Pair.of(0, 0), Pair.of(0, 1), Pair.of(0, 2)),
            // One step right and two steps up on a non-pivot row (L-shape).
            //   o x E
            //   o x o
            //   o S o
            new InfillPath(1, 2, Pair.of(0, 0), Pair.of(0, 1), Pair.of(0, 2), Pair.of(1, 2)),
            // Two steps right and two steps up on a non-pivot row (diagonal).
            //   o x E
            //   o x o
            //   S x o
            new InfillPath(2, 2, Pair.of(0, 0), Pair.of(1, 0), Pair.of(1, 1), Pair.of(1, 2), Pair.of(2, 2))
    );

    // Infill paths starting from points on pivot rows. Pivot rows only contain a single point, so the infill paths
    // cannot move horizontally on rows 0 or 2.
    private static final ImmutableList<InfillPath> PIVOT_INFILLS = ImmutableList.of(
            // Two steps left and one step up on a pivot row (incorrect L-shape).
            //   o o o
            //   E x x
            //   o o S
            new InfillPath(-2, 1, Pair.of(0, 0), Pair.of(0, 1), Pair.of(-1, 1), Pair.of(-2, 1)),
            // One step left and one step up on a pivot row (diagonal).
            //   o o o
            //   o E x
            //   o o S
            new InfillPath(-1, 1, Pair.of(0, 0), Pair.of(0, 1), Pair.of(-1, 1)),
            // One step up on a pivot row.
            //   o o o
            //   o E o
            //   o S o
            new InfillPath(0, 1, Pair.of(0, 0), Pair.of(0, 1)),
            // One step right and one step up on a pivot row (diagonal).
            //   o o o
            //   x E o
            //   S o o
            new InfillPath(1, 1, Pair.of(0, 0), Pair.of(0, 1), Pair.of(1, 1)),
            // Two steps right and one step up on a pivot row (incorrect L-shape).
            //   o o o
            //   x x E
            //   S o o
            new InfillPath(2, 1, Pair.of(0, 0), Pair.of(0, 1), Pair.of(1, 1), Pair.of(2, 1)),
            // Two steps left and two steps up on a pivot row (diagonal).
            //   E o o
            //   x x x
            //   o o S
            new InfillPath(-2, 2, Pair.of(0, 0), Pair.of(0, 1), Pair.of(-1, 1), Pair.of(-2, 1), Pair.of(-2, 2)),
            // One step left and two steps up on a pivot row (L-shape).
            //   o E o
            //   o x x
            //   o o S
            new InfillPath(-1, 2, Pair.of(0, 0), Pair.of(0, 1), Pair.of(-1, 1), Pair.of(-1, 2)),
            // Two steps up on a pivot row.
            //   o E o
            //   o x o
            //   o S o
            new InfillPath(0, 2, Pair.of(0, 0), Pair.of(0, 1), Pair.of(0, 2)),
            // One step right and two steps up on a pivot row (L-shape).
            //   o E o
            //   x x o
            //   S o o
            new InfillPath(1, 2, Pair.of(0, 0), Pair.of(0, 1), Pair.of(1, 1), Pair.of(1, 2)),
            // Two steps right and two steps up on a pivot row (diagonal).
            //   o o E
            //   x x x
            //   S o o
            new InfillPath(2, 2, Pair.of(0, 0), Pair.of(0, 1), Pair.of(1, 1), Pair.of(2, 1), Pair.of(2, 2))
    );

    private final List<WorldPoint> overworldPoints = new ArrayList<>();
    private final List<WorldPoint> underworldPivots = new ArrayList<>();
    private final Set<WorldPoint> raggedPoints = new HashSet<>();

    public MazeTracker() {
    }

    public void addPotentialOverworldPoint(WorldPoint point) {
        if (overworldPoints.contains(point)) {
            return;
        }

        if (overworldPoints.isEmpty()) {
            overworldPoints.add(point);
            return;
        }

        WorldPoint lastPoint = overworldPoints.get(overworldPoints.size() - 1);
        int dx = point.getX() - lastPoint.getX();
        int dy = point.getY() - lastPoint.getY();
        boolean isPivot = (lastPoint.getY() - Maze.OVERWORLD_MAZE_START.getY()) % 2 == 0;

        InfillPath infillPath = null;
        if (isPivot) {
            for (InfillPath infill : PIVOT_INFILLS) {
                if (infill.dx == dx && infill.dy == dy) {
                    infillPath = infill;
                    break;
                }
            }
        } else {
            for (InfillPath infill : NON_PIVOT_INFILLS) {
                if (infill.dx == dx && infill.dy == dy) {
                    infillPath = infill;
                    break;
                }
            }
        }

        if (infillPath == null) {
            log.error("No infill path for ({}, {}) pivot={}", dx, dy, isPivot);
            return;
        }

        for (Iterator<WorldPoint> it = infillPath.pathFrom(lastPoint); it.hasNext(); ) {
            WorldPoint nextPoint = it.next();
            if (!overworldPoints.contains(nextPoint) && !raggedPoints.contains(nextPoint)) {
                overworldPoints.add(nextPoint);
            }
        }
    }

    public void removeOverworldPoint(WorldPoint point) {
        raggedPoints.add(point);
    }

    public void finishMaze() {
        // If the last recorded point is on the penultimate row, assume the final pivot has the same x coordinate.
        if (!overworldPoints.isEmpty()) {
            final WorldPoint lastPoint = overworldPoints.get(overworldPoints.size() - 1);
            final int penultimateRow = Maze.OVERWORLD_MAZE_START.getY() + Maze.HEIGHT - 2;
            if (lastPoint.getY() == penultimateRow) {
                overworldPoints.add(new WorldPoint(lastPoint.getX(), penultimateRow + 1, lastPoint.getPlane()));
            }
        }

        overworldPoints.removeAll(raggedPoints);
        overworldPoints.removeIf(point -> (point.getY() - Maze.OVERWORLD_MAZE_START.getY()) % 2 == 1);
    }

    public void addUnderworldPoint(WorldPoint point) {
        int y = point.getY() - Maze.UNDERWORLD_MAZE_START.getY();
        if (y % 2 == 1) {
            // Only even rows are pivots.
            return;
        }

        if (!underworldPivots.contains(point)) {
            underworldPivots.add(point);
        }
    }

    public boolean hasOverworldMaze() {
        if (overworldPoints.size() != 8) {
            return false;
        }

        for (int i = 0; i < 8; i++) {
            final int expectedY = Maze.OVERWORLD_MAZE_START.getY() + i * 2;
            if (overworldPoints.get(i).getY() != expectedY) {
                return false;
            }
        }

        return true;
    }

    public void debugPrintMaze() {
        Set<WorldPoint> points = new HashSet<>(overworldPoints);
        for (int y = Maze.OVERWORLD_MAZE_START.getY() + Maze.HEIGHT - 1; y >= Maze.OVERWORLD_MAZE_START.getY(); y--) {
            StringBuilder sb = new StringBuilder();
            for (int x = Maze.OVERWORLD_MAZE_START.getX(); x < Maze.OVERWORLD_MAZE_START.getX() + Maze.WIDTH; x++) {
                sb.append(points.contains(new WorldPoint(x, y, 0)) ? "X " : "o ");
            }
            log.info(sb.toString());
        }
    }

    public boolean hasOverworldPivots() {
        return !overworldPoints.isEmpty();
    }

    public boolean hasUnderworldPivots() {
        return !underworldPivots.isEmpty();
    }

    public int[] getPivots() {
        List<WorldPoint> pivots = hasUnderworldPivots() ? underworldPivots : overworldPoints;
        return pivots.stream().mapToInt(WorldPoint::getX).toArray();
    }

    public void reset() {
        overworldPoints.clear();
        underworldPivots.clear();
        raggedPoints.clear();
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.sotetseg;

import io.blert.challenges.tob.HpVarbitTrackedNpc;
import io.blert.challenges.tob.Location;
import io.blert.challenges.tob.TheatreChallenge;
import io.blert.challenges.tob.TobNpc;
import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.RoomDataTracker;
import io.blert.core.Hitpoints;
import io.blert.core.NpcAttack;
import io.blert.core.TrackedNpc;
import io.blert.events.NpcAttackEvent;
import io.blert.events.tob.SoteMazeEvent;
import io.blert.events.tob.SoteMazePathEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;

import javax.annotation.Nullable;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Slf4j
public class SotetsegDataTracker extends RoomDataTracker {
    private static final int MAZE_TELEPORT_ANIMATION = 1816;
    private static final int SOTE_MELEE_ANIMATION = 8138;
    private static final int SOTE_BALL_ANIMATION = 8139;
    private static final int SOTE_DEATH_BALL_PROJECTILE = 1604;
    private static final int MAZE_DISABLED_TILE_GROUND_OBJECT = 33033;
    private static final int MAZE_INACTIVE_TILE_GROUND_OBJECT = 33034;
    private static final int MAZE_ACTIVE_TILE_GROUND_OBJECT = 33035;
    private static final int MAZE_RAG_GRAPHICS_OBJECT = 505;
    private static final int SOTE_ATTACK_SPEED = 5;

    private final int[] mazeTicks = new int[]{-1, -1};
    private Maze maze = Maze.MAZE_66;
    private @Nullable NpcAttack attackThisTick = null;
    private int lastAttackTick = -1;
    private int deathBallSpawnTick = -1;
    private @Nullable HpVarbitTrackedNpc sotetseg = null;
    private final MazeTracker mazeTracker = new MazeTracker();
    boolean inMaze = false;
    boolean chosen = false;
    private final Set<GroundObject> activeMazeTiles = new HashSet<>();

    public SotetsegDataTracker(TheatreChallenge manager, Client client) {
        super(manager, client, Room.SOTETSEG);
    }

    @Override
    protected void onRoomStart() {
        if (sotetseg == null) {
            client.getTopLevelWorldView().npcs().stream().filter(npc -> TobNpc.isSotetseg(npc.getId())).findFirst().ifPresent(npc -> {
                TobNpc tobNpc = TobNpc.withId(npc.getId()).orElseThrow();
                sotetseg = new HpVarbitTrackedNpc(npc, tobNpc, generateRoomId(npc),
                        new Hitpoints(tobNpc, theatreChallenge.getScale()));
                addTrackedNpc(sotetseg);
            });
        }

        inMaze = false;
    }

    @Override
    protected void onTick() {
        super.onTick();
        final int tick = getTick();

        Player deathBallTarget = checkForDeathBall();

        if (attackThisTick != null && sotetseg != null) {
            WorldPoint point = getWorldLocation(sotetseg);
            if (deathBallSpawnTick == tick) {
                // A regular attack animation may have occurred at the same time as the death ball; the death ball
                // should take priority.
                String target = deathBallTarget != null
                        ? deathBallTarget.getName()
                        : null;
                dispatchEvent(new NpcAttackEvent(getStage(), tick, point,
                        NpcAttack.TOB_SOTE_DEATH_BALL, sotetseg, target));
            } else {
                dispatchEvent(new NpcAttackEvent(getStage(), tick, point,
                        attackThisTick, sotetseg));
            }
            lastAttackTick = tick;
            attackThisTick = null;
        }

        if (inMaze) {
            Location playerLocation = Location.fromWorldPoint(getWorldLocation(client.getLocalPlayer()));
            if (playerLocation.inSotetsegOverworld() && !activeMazeTiles.isEmpty()) {
                var activeTilePoints = activeMazeTiles.stream()
                        .map(this::getWorldLocation)
                        .collect(Collectors.toList());
                dispatchEvent(SoteMazePathEvent.overworldTiles(tick, maze, activeTilePoints));
            }

            if (playerLocation.inSotetsegUnderworld()) {
                chosen = true;
            }

            if (chosen && playerLocation.inSotetsegOverworld()) {
                finishMaze(tick);
            }
        }
    }

    @Override
    protected Optional<? extends TrackedNpc> onNpcSpawn(NpcSpawned event) {
        NPC npc = event.getNpc();

        return TobNpc.withId(npc.getId())
                .filter(tobNpc -> TobNpc.isAnySotetseg(tobNpc.getId()))
                .map(tobNpc -> {
                    if (sotetseg != null) {
                        sotetseg = new HpVarbitTrackedNpc(npc, tobNpc, sotetseg.getRoomId(), sotetseg.getHitpoints());
                    } else {
                        sotetseg = new HpVarbitTrackedNpc(npc, tobNpc, generateRoomId(npc),
                                new Hitpoints(tobNpc, theatreChallenge.getScale()));
                    }
                    return sotetseg;
                });
    }

    @Override
    protected boolean onNpcDespawn(NpcDespawned event, TrackedNpc trackedNpc) {
        if (sotetseg != null && trackedNpc == sotetseg) {
            if (sotetseg.getNpc().isDead()) {
                sotetseg = null;
            }
            return true;
        }
        return false;
    }

    @Override
    protected void onNpcChange(NpcChanged changed) {
        if (TobNpc.isSotetsegIdle(changed.getOld().getId()) && TobNpc.isSotetseg(changed.getNpc().getId())) {
            if (getState() == State.NOT_STARTED) {
                startRoom();
            } else {
                finishMaze(getTick());
            }
        }
    }

    @Override
    protected void onAnimation(AnimationChanged event) {
        Actor actor = event.getActor();
        int animationId = actor.getAnimation();
        final int tick = getTick();

        if (actor instanceof NPC) {
            if (sotetseg == null || actor != sotetseg.getNpc()) {
                return;
            }

            if (lastAttackTick != -1 && tick - lastAttackTick < SOTE_ATTACK_SPEED) {
                return;
            }

            if (animationId == SOTE_MELEE_ANIMATION) {
                attackThisTick = NpcAttack.TOB_SOTE_MELEE;
            } else if (animationId == SOTE_BALL_ANIMATION) {
                attackThisTick = NpcAttack.TOB_SOTE_BALL;
            }
            return;
        }

        if (!(actor instanceof Player) || animationId != MAZE_TELEPORT_ANIMATION) {
            return;
        }

        if (mazeTicks[maze.ordinal()] == -1) {
            mazeTicks[maze.ordinal()] = tick;
            startMaze(tick);
        }
    }

    private Player checkForDeathBall() {
        final int tick = getTick();
        if (deathBallSpawnTick != -1) {
            if (tick >= deathBallSpawnTick + 20) {
                // The ball takes 15 ticks to land, but add in a safety buffer.
                deathBallSpawnTick = -1;
            } else {
                return null;
            }
        }

        for (Projectile projectile : client.getProjectiles()) {
            if (projectile.getId() == SOTE_DEATH_BALL_PROJECTILE) {
                deathBallSpawnTick = tick;
                attackThisTick = NpcAttack.TOB_SOTE_DEATH_BALL;
                Actor target = projectile.getTargetActor();
                return target instanceof Player ? (Player) target : null;
            }
        }

        return null;
    }

    @Override
    protected void onGroundObjectSpawn(GroundObjectSpawned event) {
        GroundObject groundObject = event.getGroundObject();
        if (groundObject.getId() == MAZE_ACTIVE_TILE_GROUND_OBJECT) {
            Location playerLocation = Location.fromWorldPoint(getWorldLocation(client.getLocalPlayer()));
            if (playerLocation.inSotetsegUnderworld()) {
                mazeTracker.addUnderworldPoint(getWorldLocation(groundObject));
            } else {
                mazeTracker.addPotentialOverworldPoint(getWorldLocation(groundObject));
                activeMazeTiles.add(groundObject);
            }
        }
    }

    @Override
    protected void onGroundObjectDespawn(GroundObjectDespawned event) {
        GroundObject groundObject = event.getGroundObject();
        if (groundObject.getId() == MAZE_ACTIVE_TILE_GROUND_OBJECT) {
            activeMazeTiles.remove(groundObject);
        }
    }

    @Override
    protected void onGraphicsObjectCreation(GraphicsObjectCreated event) {
        GraphicsObject graphicsObject = event.getGraphicsObject();
        if (graphicsObject.getId() == MAZE_RAG_GRAPHICS_OBJECT) {
            WorldPoint point = WorldPoint.fromLocalInstance(client, graphicsObject.getLocation());
            mazeTracker.removeOverworldPoint(point);
        }
    }

    private void startMaze(int tick) {
        log.debug("Sotetseg {} started on tick {} {}", maze, tick, formattedRoomTime());
        mazeTracker.reset();
        activeMazeTiles.clear();
        inMaze = true;
        chosen = false;

        dispatchEvent(SoteMazeEvent.mazeProc(tick, maze));

        if (sotetseg != null) {
            sotetseg.setDisableVarbitUpdates(true);
        }
    }

    private void finishMaze(int tick) {
        inMaze = false;
        chosen = false;
        mazeTracker.finishMaze();
        log.debug("{} finished; pivots: {}", maze, mazeTracker.getPivots());

        if (mazeTracker.hasUnderworldPivots()) {
            dispatchEvent(SoteMazePathEvent.underworldPivots(getTick(), maze, mazeTracker.getUnderworldPivots()));
        }

        if (mazeTracker.hasOverworldPivots()) {
            dispatchEvent(SoteMazePathEvent.overworldPivots(getTick(), maze, mazeTracker.getOverworldPoints()));
        }

        dispatchEvent(SoteMazeEvent.mazeEnd(tick, maze));

        // Advance to the next maze.
        maze = Maze.MAZE_33;
        mazeTracker.reset();

        if (sotetseg != null) {
            sotetseg.setDisableVarbitUpdates(false);
        }
    }
}
/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms;

import io.blert.core.Stage;

/**
 * Rooms in the Theatre of Blood.
 */
public enum Room {
    MAIDEN,
    BLOAT,
    NYLOCAS,
    SOTETSEG,
    XARPUS,
    VERZIK;

    /**
     * Returns the name of the room as written in the in-game "wave" message.
     */
    public String waveName() {
        switch (this) {
            case MAIDEN:
                return "The Maiden of Sugadinti";
            case BLOAT:
                return "The Pestilent Bloat";
            case NYLOCAS:
                return "The Nylocas";
            case SOTETSEG:
                return "Sotetseg";
            case XARPUS:
                return "Xarpus";
            case VERZIK:
                return "The Final Challenge";
            default:
                return "";
        }
    }

    public Stage toStage() {
        switch (this) {
            case MAIDEN:
                return Stage.TOB_MAIDEN;
            case BLOAT:
                return Stage.TOB_BLOAT;
            case NYLOCAS:
                return Stage.TOB_NYLOCAS;
            case SOTETSEG:
                return Stage.TOB_SOTETSEG;
            case XARPUS:
                return Stage.TOB_XARPUS;
            case VERZIK:
                return Stage.TOB_VERZIK;
        }

        return null;
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.maiden;

import io.blert.challenges.tob.TobNpc;
import io.blert.core.Hitpoints;
import io.blert.core.TrackedNpc;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;

import java.util.Optional;

public class MaidenCrab extends TrackedNpc {
    @AllArgsConstructor
    @Getter
    public static class Properties extends TrackedNpc.Properties {
        private final CrabSpawn spawn;
        private final Position position;
        private final boolean scuffed;
    }

    private final Properties properties;

    public enum Position {
        S1,
        N1,
        S2,
        N2,
        S3,
        N3,
        S4_INNER,
        S4_OUTER,
        N4_INNER,
        N4_OUTER,
    }

    /**
     * Returns the crab that spawns at a specified location.
     *
     * @param location Spawn location corresponding to the southwest tile of the crab.
     * @return The type of crab which spawns at that location, if one exists.
     */
    public static Optional<MaidenCrab> fromSpawnLocation(int scale, NPC npc, long roomId,
                                                         CrabSpawn spawn, WorldPoint location) {
        Position position;
        boolean scuffed;

        if (location.equals(N1_SPAWN)) {
            position = Position.N1;
            scuffed = false;
        } else if (location.equals(N1_SCUFFED_SPAWN)) {
            position = Position.N1;
            scuffed = true;
        } else if (location.equals(N2_SPAWN)) {
            position = Position.N2;
            scuffed = false;
        } else if (location.equals(N2_SCUFFED_SPAWN)) {
            position = Position.N2;
            scuffed = true;
        } else if (location.equals(N3_SPAWN)) {
            position = Position.N3;
            scuffed = false;
        } else if (location.equals(N3_SCUFFED_SPAWN)) {
            position = Position.N3;
            scuffed = true;
        } else if (location.equals(N4_INNER_SPAWN)) {
            position = Position.N4_INNER;
            scuffed = false;
        } else if (location.equals(N4_INNER_SCUFFED_SPAWN)) {
            position = Position.N4_INNER;
            scuffed = true;
        } else if (location.equals(N4_OUTER_SPAWN)) {
            position = Position.N4_OUTER;
            scuffed = false;
        } else if (location.equals(N4_OUTER_SCUFFED_SPAWN)) {
            position = Position.N4_OUTER;
            scuffed = true;
        } else if (location.equals(S1_SPAWN)) {
            position = Position.S1;
            scuffed = false;
        } else if (location.equals(S1_SCUFFED_SPAWN)) {
            position = Position.S1;
            scuffed = true;
        } else if (location.equals(S2_SPAWN)) {
            position = Position.S2;
            scuffed = false;
        } else if (location.equals(S2_SCUFFED_SPAWN)) {
            position = Position.S2;
            scuffed = true;
        } else if (location.equals(S3_SPAWN)) {
            position = Position.S3;
            scuffed = false;
        } else if (location.equals(S3_SCUFFED_SPAWN)) {
            position = Position.S3;
            scuffed = true;
        } else if (location.equals(S4_INNER_SPAWN)) {
            position = Position.S4_INNER;
            scuffed = false;
        } else if (location.equals(S4_INNER_SCUFFED_SPAWN)) {
            position = Position.S4_INNER;
            scuffed = true;
        } else if (location.equals(S4_OUTER_SPAWN)) {
            position = Position.S4_OUTER;
            scuffed = false;
        } else if (location.equals(S4_OUTER_SCUFFED_SPAWN)) {
            position = Position.S4_OUTER;
            scuffed = true;
        } else {
            return Optional.empty();
        }

        return TobNpc.withId(npc.getId()).map(tobNpc ->
                new MaidenCrab(npc, tobNpc, roomId, spawn, position,
                        scuffed, new Hitpoints(tobNpc.getBaseHitpoints(scale))));
    }

    private MaidenCrab(@NonNull NPC npc, TobNpc tobNpc, long roomId, CrabSpawn spawn,
                       Position position, boolean scuffed, Hitpoints hitpoints) {
        super(npc, tobNpc, roomId, hitpoints);
        this.properties = new Properties(spawn, position, scuffed);
    }

    @Override
    public @NonNull TrackedNpc.Properties getProperties() {
        return properties;
    }

    public CrabSpawn getSpawn() {
        return properties.getSpawn();
    }

    public Position getPosition() {
        return properties.getPosition();
    }

    public boolean isScuffed() {
        return properties.isScuffed();
    }

    /**
     * Returns the location at which this crab spawns.
     */
    public WorldPoint getSpawnPoint() {
        switch (properties.getPosition()) {
            case S1:
                return properties.isScuffed() ? S1_SCUFFED_SPAWN : S1_SPAWN;
            case N1:
                return properties.isScuffed() ? N1_SCUFFED_SPAWN : N1_SPAWN;
            case S2:
                return properties.isScuffed() ? S2_SCUFFED_SPAWN : S2_SPAWN;
            case N2:
                return properties.isScuffed() ? N2_SCUFFED_SPAWN : N2_SPAWN;
            case S3:
                return properties.isScuffed() ? S3_SCUFFED_SPAWN : S3_SPAWN;
            case N3:
                return properties.isScuffed() ? N3_SCUFFED_SPAWN : N3_SPAWN;
            case S4_INNER:
                return properties.isScuffed() ? S4_INNER_SCUFFED_SPAWN : S4_INNER_SPAWN;
            case S4_OUTER:
                return properties.isScuffed() ? S4_OUTER_SCUFFED_SPAWN : S4_OUTER_SPAWN;
            case N4_INNER:
                return properties.isScuffed() ? N4_INNER_SCUFFED_SPAWN : N4_INNER_SPAWN;
            case N4_OUTER:
                return properties.isScuffed() ? N4_OUTER_SCUFFED_SPAWN : N4_OUTER_SPAWN;
        }

        return null;
    }

    private static final WorldPoint N1_SPAWN = new WorldPoint(3173, 4456, 0);
    private static final WorldPoint N1_SCUFFED_SPAWN = new WorldPoint(3174, 4457, 0);
    private static final WorldPoint N2_SPAWN = new WorldPoint(3177, 4456, 0);
    private static final WorldPoint N2_SCUFFED_SPAWN = new WorldPoint(3178, 4457, 0);
    private static final WorldPoint N3_SPAWN = new WorldPoint(3181, 4456, 0);
    private static final WorldPoint N3_SCUFFED_SPAWN = new WorldPoint(3182, 4457, 0);
    private static final WorldPoint N4_INNER_SPAWN = new WorldPoint(3185, 4454, 0);
    private static final WorldPoint N4_INNER_SCUFFED_SPAWN = new WorldPoint(3186, 4455, 0);
    private static final WorldPoint N4_OUTER_SPAWN = new WorldPoint(3185, 4456, 0);
    private static final WorldPoint N4_OUTER_SCUFFED_SPAWN = new WorldPoint(3186, 4457, 0);

    private static final WorldPoint S1_SPAWN = new WorldPoint(3173, 4436, 0);
    private static final WorldPoint S1_SCUFFED_SPAWN = new WorldPoint(3174, 4435, 0);
    private static final WorldPoint S2_SPAWN = new WorldPoint(3177, 4436, 0);
    private static final WorldPoint S2_SCUFFED_SPAWN = new WorldPoint(3178, 4435, 0);
    private static final WorldPoint S3_SPAWN = new WorldPoint(3181, 4436, 0);
    private static final WorldPoint S3_SCUFFED_SPAWN = new WorldPoint(3182, 4435, 0);
    private static final WorldPoint S4_INNER_SPAWN = new WorldPoint(3185, 4438, 0);
    private static final WorldPoint S4_INNER_SCUFFED_SPAWN = new WorldPoint(3186, 4437, 0);
    private static final WorldPoint S4_OUTER_SPAWN = new WorldPoint(3185, 4436, 0);
    private static final WorldPoint S4_OUTER_SCUFFED_SPAWN = new WorldPoint(3186, 4435, 0);
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.maiden;

public enum CrabSpawn {
    SEVENTIES,
    FIFTIES,
    THIRTIES;

    public CrabSpawn next() {
        if (this == SEVENTIES) {
            return FIFTIES;
        }
        return THIRTIES;
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.maiden;

import io.blert.challenges.tob.HpVarbitTrackedNpc;
import io.blert.challenges.tob.Location;
import io.blert.challenges.tob.TheatreChallenge;
import io.blert.challenges.tob.TobNpc;
import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.RoomDataTracker;
import io.blert.core.BasicTrackedNpc;
import io.blert.core.Hitpoints;
import io.blert.core.NpcAttack;
import io.blert.core.TrackedNpc;
import io.blert.events.NpcAttackEvent;
import io.blert.events.tob.MaidenBloodSplatsEvent;
import io.blert.events.tob.MaidenCrabLeakEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;

import javax.annotation.Nullable;
import java.util.*;

@Slf4j

public class MaidenDataTracker extends RoomDataTracker {
    private final static int MAIDEN_BLOODSPLAT_GRAPHIC_ID = 1579;
    private final static int MAIDEN_BLOOD_TRAIL_OBJECT_ID = 32984;

    private final static int MAIDEN_BLOOD_THROW_ANIMATION = 8091;
    private final static int MAIDEN_AUTO_ANIMATION = 8092;

    private CrabSpawn currentSpawn = CrabSpawn.SEVENTIES;
    private final int[] spawnTicks = new int[3];
    private boolean crabsSpawnedThisTick = false;

    private @Nullable HpVarbitTrackedNpc maiden;
    private @Nullable NpcAttack attackThisTick = null;

    private final Set<GameObject> bloodTrails = new HashSet<>();
    private final Map<Integer, MaidenCrab> crabs = new HashMap<>();

    public MaidenDataTracker(TheatreChallenge manager, Client client) {
        super(manager, client, Room.MAIDEN, true);
    }

    @Override
    protected void onRoomStart() {
        if (maiden != null) {
            theatreChallenge.updateMode(maiden.getMode());
        }
    }

    @Override
    protected void onTick() {
        super.onTick();

        List<WorldPoint> bloodSplats = new ArrayList<>();

        // Search for active blood splats thrown by Maiden, and report them if they exist.
        for (GraphicsObject object : client.getTopLevelWorldView().getGraphicsObjects()) {
            WorldPoint point = WorldPoint.fromLocalInstance(client, object.getLocation());
            if (Location.fromWorldPoint(point).inMaiden() && object.getId() == MAIDEN_BLOODSPLAT_GRAPHIC_ID) {
                bloodSplats.add(point);
            }
        }

        // Add any blood trails left by blood spawns to the list. In the future, this may be a separate event.
        for (GameObject trail : bloodTrails) {
            bloodSplats.add(getWorldLocation(trail));
        }

        final int tick = getTick();

        if (!bloodSplats.isEmpty()) {
            dispatchEvent(new MaidenBloodSplatsEvent(tick, bloodSplats));
        }

        if (maiden == null) {
            return;
        }

        for (MaidenCrab crab : crabs.values()) {
            NPC crabNpc = crab.getNpc();

            if (!crabNpc.isDead() && crabNpc.getWorldArea().distanceTo2D(maiden.getNpc().getWorldArea()) <= 1) {
                dispatchEvent(new MaidenCrabLeakEvent(tick, getWorldLocation(crabNpc), crab));
            }
        }

        if (attackThisTick != null) {
            dispatchEvent(new NpcAttackEvent(getStage(), tick, getWorldLocation(maiden.getNpc()), attackThisTick, maiden));
        }

        crabsSpawnedThisTick = false;
        attackThisTick = null;
    }

    @Override
    protected void onGameObjectSpawn(GameObjectSpawned spawned) {
        // The blood trails left by blood spawns are game objects with stable hash codes, so store them in a set when
        // they spawn and remove them on de-spawn. The `onTick` handler will dispatch events with the active set of
        // blood trails.
        GameObject object = spawned.getGameObject();
        if (object.getId() != MAIDEN_BLOOD_TRAIL_OBJECT_ID) {
            return;
        }

        if (Location.fromWorldPoint(getWorldLocation(object)).inMaiden()) {
            bloodTrails.add(object);
        }
    }

    @Override
    protected void onGameObjectDespawn(GameObjectDespawned despawned) {
        GameObject object = despawned.getGameObject();
        if (object.getId() == MAIDEN_BLOOD_TRAIL_OBJECT_ID) {
            bloodTrails.remove(object);
        }
    }

    @Override
    protected Optional<? extends TrackedNpc> onNpcSpawn(NpcSpawned spawned) {
        NPC npc = spawned.getNpc();
        return TobNpc.withId(npc.getId()).flatMap(tobNpc -> {
            if (TobNpc.isMaiden(tobNpc.getId())) {
                if (maiden == null) {
                    startRoom();
                    maiden = new HpVarbitTrackedNpc(npc, tobNpc, generateRoomId(npc),
                            new Hitpoints(tobNpc.getBaseHitpoints(theatreChallenge.getScale())));
                }
                return Optional.of(maiden);
            }

            if (TobNpc.isMaidenMatomenos(tobNpc.getId())) {
                return handleMaidenCrabSpawn(npc);
            }

            if (TobNpc.isMaidenBloodSpawn(tobNpc.getId())) {
                return handleMaidenBloodSpawnSpawn(npc);
            }

            return Optional.empty();
        });
    }

    @Override
    protected boolean onNpcDespawn(NpcDespawned despawned, TrackedNpc trackedNpc) {
        NPC npc = despawned.getNpc();
        crabs.remove(npc.hashCode());
        // Every maiden NPC despawn is final.
        return true;
    }

    @Override
    protected void onAnimation(AnimationChanged event) {
        Actor actor = event.getActor();
        if (maiden == null || actor != maiden.getNpc()) {
            return;
        }

        switch (actor.getAnimation()) {
            case MAIDEN_BLOOD_THROW_ANIMATION:
                attackThisTick = NpcAttack.TOB_MAIDEN_BLOOD_THROW;
                break;
            case MAIDEN_AUTO_ANIMATION:
                attackThisTick = NpcAttack.TOB_MAIDEN_AUTO;
                break;
            default:
        }
    }

    private Optional<TrackedNpc> handleMaidenBloodSpawnSpawn(NPC npc) {
        return TobNpc.withId(npc.getId()).map(tobNpc ->
                new BasicTrackedNpc(npc, tobNpc, generateRoomId(npc),
                        new Hitpoints(tobNpc.getBaseHitpoints(theatreChallenge.getScale()))));
    }

    private Optional<MaidenCrab> handleMaidenCrabSpawn(NPC npc) {
        if (!crabsSpawnedThisTick) {
            markNewSpawn();
            crabsSpawnedThisTick = true;
        }

        WorldPoint spawnLocation = getWorldLocation(npc);

        Optional<MaidenCrab> maybeCrab = MaidenCrab.fromSpawnLocation(
                theatreChallenge.getScale(), npc, generateRoomId(npc), currentSpawn, spawnLocation);
        if (maybeCrab.isPresent()) {
            MaidenCrab maidenCrab = maybeCrab.get();
            log.debug("Crab position: {} scuffed: {}", maidenCrab.getPosition(), maidenCrab.isScuffed());
            crabs.put(npc.hashCode(), maidenCrab);
        }

        return maybeCrab;
    }

    private void markNewSpawn() {
        if (maiden != null) {
            // Correct the crab spawn based on Maiden's current hitpoints in case the room was started late.
            // The percentage thresholds are set higher than the spawn in case Maiden has already healed when
            // joining the room, but not high enough to be falsely triggered by a deep proc.
            double hp = maiden.getHitpoints().percentage();
            if (hp < 39.0) {
                currentSpawn = CrabSpawn.THIRTIES;
            } else if (hp < 59.0) {
                currentSpawn = CrabSpawn.FIFTIES;
            } else {
                currentSpawn = CrabSpawn.SEVENTIES;
            }
        }

        spawnTicks[currentSpawn.ordinal()] = getTick();
        log.debug("Maiden {} spawned on tick {} ({})", currentSpawn, getTick(), formattedRoomTime());
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms;

import io.blert.challenges.tob.HpVarbitTrackedNpc;
import io.blert.challenges.tob.Location;
import io.blert.challenges.tob.TheatreChallenge;
import io.blert.challenges.tob.TobNpc;
import io.blert.core.DataTracker;
import io.blert.core.Hitpoints;
import io.blert.core.Raider;
import io.blert.events.PlayerDeathEvent;
import io.blert.util.Tick;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.util.Text;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public abstract class RoomDataTracker extends DataTracker {
    private static int TOB_HITPOINTS_VARBIT = 6448;

    protected final TheatreChallenge theatreChallenge;

    @Getter
    private final Room room;
    private final Pattern waveEndRegex;

    private final boolean startOnEntry;
    private boolean startingTickAccurate;
    private boolean shouldUpdateHitpoints;
    private int healTick = -1;

    protected RoomDataTracker(TheatreChallenge theatreChallenge, Client client, Room room, boolean startOnEntry) {
        super(theatreChallenge, client, room.toStage());
        this.theatreChallenge = theatreChallenge;
        this.room = room;
        this.waveEndRegex = Pattern.compile(
                "Wave '" + room.waveName() + "' \\(\\w+ Mode\\) " +
                        "complete!Duration: (" + Tick.TIME_STRING_REGEX + ")"
        );
        this.startOnEntry = startOnEntry;
    }

    protected RoomDataTracker(TheatreChallenge theatreChallenge, Client client, Room room) {
        this(theatreChallenge, client, room, false);
    }

    /**
     * Begins tracking data for the room.
     */
    public void startRoom() {
        startRoom(0, true);
    }

    /**
     * Begins tracking data for the room, assuming that the starting tick is not correct (possibly because the room was
     * already in progress).
     */
    public void startRoomInaccurate() {
        startRoom(0, false);
    }

    private void startRoom(int tickOffset, boolean accurate) {
        if (getState() != State.NOT_STARTED) {
            return;
        }

        super.start();

        startingTickAccurate = accurate;
        onRoomStart();
    }

    /**
     * Checks whether players are in the room and starts the room if they are.
     */
    public void checkEntry() {
        if (getState() == State.NOT_STARTED && this.startOnEntry) {
            if (playersAreInRoom()) {
                log.debug("Room {} started because player entered", room);
                startRoom();
            }
        }
    }

    @Override
    protected void onTick() {
        int tick = getTick();

        checkForDeaths();

        // The hitpoints varbit is delayed by up to 3 ticks, so don't update immediately following a heal as it may
        // undo the hitpoints added by the heal.
        if (shouldUpdateHitpoints && (healTick == -1 || tick - healTick > 3)) {
            getTrackedNpcs().stream().filter(npc -> npc instanceof HpVarbitTrackedNpc)
                    .map(npc -> (HpVarbitTrackedNpc) npc)
                    .findFirst()
                    .ifPresent(npc -> npc.updateHitpointsFromVarbit(client.getVarbitValue(TOB_HITPOINTS_VARBIT)));
            shouldUpdateHitpoints = false;
        }
    }

    /**
     * Checks if any players are located within the boundaries of the boss room.
     *
     * @return True if there is at least one player within the room.
     */
    public boolean playersAreInRoom() {
        return client.getTopLevelWorldView().players().stream()
                .filter(player -> theatreChallenge.playerIsInChallenge(player.getName()))
                .anyMatch(player -> Location.fromWorldPoint(getWorldLocation(player)).inRoom(room));
    }

    /**
     * Updates the base and current hitpoints of all NPCs in the room to match the given raid scale.
     *
     * @param scale The raid scale.
     */
    public void correctNpcHitpointsForScale(int scale) {
        getTrackedNpcs().forEach(trackedNpc -> {
            NPC npc = trackedNpc.getNpc();
            int healthRatio = npc.getHealthRatio();
            int healthScale = npc.getHealthScale();

            if (healthScale > 0 && healthRatio != -1) {
                double percent = healthRatio / (double) healthScale;
                TobNpc tobNpc = TobNpc.withId(npc.getId()).orElseThrow();
                trackedNpc.setHitpoints(Hitpoints.fromRatio(percent, tobNpc.getBaseHitpoints(scale)));
            }
        });

    }

    /**
     * Initialization method invoked when the room is first started.
     */
    protected abstract void onRoomStart();

    @Override
    protected void onGameState(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGIN_SCREEN && inProgress()) {
            Player localPlayer = client.getLocalPlayer();
            if (localPlayer == null) {
                return;
            }
            Raider raider = theatreChallenge.getRaider(localPlayer.getName());
            if (raider != null && raider.isAlive()) {
                // Logging out during a ToB room is considered a death.
                int tick = getTick();
                raider.setDead(tick);
                WorldPoint deathPoint = getWorldLocation(localPlayer);
                dispatchEvent(new PlayerDeathEvent(getStage(), tick, deathPoint, raider.getUsername()));
            }
        }
    }

    @Override
    protected final void onMessage(ChatMessage chatMessage) {
        String stripped = Text.removeTags(chatMessage.getMessage());
        Matcher matcher = waveEndRegex.matcher(stripped);
        if (matcher.find()) {
            try {
                String inGameTime = matcher.group(1);
                finish(inGameTime);
            } catch (IndexOutOfBoundsException e) {
                log.warn("Could not parse timestamp from wave end message: {}", stripped);
                finish(true);
            }
        }
    }

    @Override
    protected void onHitsplat(HitsplatApplied event) {
        if (event.getActor() instanceof NPC && event.getHitsplat().getHitsplatType() == HitsplatID.HEAL) {
            getTrackedNpcs().getByNpc((NPC) event.getActor()).ifPresent(npc -> {
                if (npc instanceof HpVarbitTrackedNpc) {
                    healTick = getTick();
                }
            });
        }
    }

    @Override
    protected void onVarbit(VarbitChanged event) {
        if (event.getVarbitId() == TOB_HITPOINTS_VARBIT) {
            shouldUpdateHitpoints = true;
        }
    }

    protected String formattedRoomTime() {
        return Tick.asTimeString(getTick());
    }

    private void checkForDeaths() {
        final int tick = getTick();

        getChallenge().getParty().forEach(raider -> {
            if (!raider.isActive() && raider.isAlive()) {
                // Disconnecting during a ToB room is considered a death.
                raider.setDead(tick);
                WorldPoint deathPoint = raider.getPlayer() != null ? getWorldLocation(raider.getPlayer()) : null;
                dispatchEvent(new PlayerDeathEvent(getStage(), tick, deathPoint, raider.getUsername()));
            }
        });

        // Check party orb health for dead players to catch any deaths that occurred before the client joined as a
        // spectator or while the client was disconnected.
        theatreChallenge.forEachOrb((orb, username) -> {
            Raider raider = theatreChallenge.getRaider(Text.standardize(username));
            if (raider == null) {
                log.warn("Player {} is in orb list but not in party", username);
                return;
            }

            // ToB orb health. 0 = hide, 1-27 = health percentage (0-100%), 30 = dead.
            int orbHealth = client.getVarbitValue(Varbits.THEATRE_OF_BLOOD_ORB1 + orb);
            if (orbHealth == 30) {
                if (raider.isDead()) {
                    return;
                }

                raider.setDead(tick);
                if (raider.getPlayer() != null) {
                    dispatchEvent(new PlayerDeathEvent(getStage(), tick, null, raider.getUsername()));
                }
            }
        });
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.nylocas;

import net.runelite.api.coords.WorldPoint;

public enum SpawnType {
    SPLIT,
    WEST,
    SOUTH,
    EAST;

    private static final WorldPoint EAST_LANE_NORTH = new WorldPoint(3310, 4249, 0);
    private static final WorldPoint EAST_LANE_SOUTH = new WorldPoint(3310, 4248, 0);
    private static final WorldPoint EAST_LANE_SOUTHWEST = new WorldPoint(3309, 4248, 0);  // east bigs
    private static final WorldPoint WEST_LANE_NORTH = new WorldPoint(3281, 4249, 0);
    private static final WorldPoint WEST_LANE_SOUTH = new WorldPoint(3281, 4248, 0);
    private static final WorldPoint SOUTH_LANE_WEST = new WorldPoint(3295, 4233, 0);
    private static final WorldPoint SOUTH_LANE_EAST = new WorldPoint(3296, 4233, 0);

    public static SpawnType fromWorldPoint(WorldPoint point) {
        if (point.equals(EAST_LANE_NORTH) || point.equals(EAST_LANE_SOUTH) || point.equals(EAST_LANE_SOUTHWEST)) {
            return EAST;
        }
        if (point.equals(WEST_LANE_NORTH) || point.equals(WEST_LANE_SOUTH)) {
            return WEST;
        }
        if (point.equals(SOUTH_LANE_WEST) || point.equals(SOUTH_LANE_EAST)) {
            return SOUTH;
        }

        return SPLIT;
    }

    public boolean isSplit() {
        return this == SPLIT;
    }

    public boolean isLaneSpawn() {
        return !isSplit();
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.nylocas;

import com.google.common.collect.ImmutableSet;
import io.blert.challenges.tob.TheatreChallenge;
import io.blert.challenges.tob.TobNpc;
import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.RoomDataTracker;
import io.blert.core.ChallengeMode;
import io.blert.core.Hitpoints;
import io.blert.core.NpcAttack;
import io.blert.core.TrackedNpc;
import io.blert.events.NpcAttackEvent;
import io.blert.events.tob.NyloBossSpawnEvent;
import io.blert.events.tob.NyloCleanupEndEvent;
import io.blert.events.tob.NyloWaveEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NullNpcID;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;

import javax.annotation.Nullable;
import java.util.*;

@Slf4j

public class NylocasDataTracker extends RoomDataTracker {
    private static final int CAP_INCREASE_WAVE = 20;
    private static final int LAST_NYLO_WAVE = 31;
    private static final int WAVE_TICK_CYCLE = 4;
    private static final int[] NATURAL_STALLS = new int[]{
            0, 4, 4, 4, 4, 16, 4, 12, 4, 12, 8, 8, 8, 8, 8, 8, 4, 12, 8, 12, 16, 8, 12, 8, 8, 8, 4, 8, 4, 4, 4,
    };

    private static final int NYLO_BOSS_MAGE_ANIMATION = 7989;
    private static final int NYLO_BOSS_RANGE_ANIMATION = 7999;
    private static final int NYLO_BOSS_MELEE_ANIMATION = 8004;

    private int currentWave;
    private int nextWaveSpawnCheckTick;
    private final int[] waveSpawnTicks = new int[LAST_NYLO_WAVE + 1];
    private int bossSpawnTick;

    private final Map<Integer, Nylo> nylosInRoom = new HashMap<>();
    private @Nullable NyloBoss nyloBoss = null;
    private final List<Nylo> bigDeathsThisTick = new ArrayList<>();

    private static final ImmutableSet<Integer> NYLOCAS_PILLAR_NPC_IDS = ImmutableSet.of(
            NullNpcID.NULL_10790,
            NullNpcID.NULL_8358,
            NullNpcID.NULL_10811);

    public NylocasDataTracker(TheatreChallenge manager, Client client) {
        super(manager, client, Room.NYLOCAS);
        currentWave = 0;
        nextWaveSpawnCheckTick = -1;
        bossSpawnTick = -1;
    }

    private int roomNyloCount() {
        return nylosInRoom.size() + ((nyloBoss != null && nyloBoss.isPrince()) ? 3 : 0);
    }

    private int waveCap() {
        if (theatreChallenge.getChallengeMode() == ChallengeMode.TOB_HARD) {
            return currentWave < CAP_INCREASE_WAVE ? 15 : 24;
        }
        return currentWave < CAP_INCREASE_WAVE ? 12 : 24;
    }

    private boolean isPrinceWave() {
        return theatreChallenge.getChallengeMode() == ChallengeMode.TOB_HARD
                && (currentWave == 10 || currentWave == 20 || currentWave == 30);
    }

    @Override
    protected void onRoomStart() {
    }

    @Override
    protected void onTick() {
        super.onTick();
        final int tick = getTick();

        if (waveSpawnTicks[currentWave] == tick) {
            dispatchEvent(NyloWaveEvent.spawn(tick, currentWave, roomNyloCount(), waveCap()));
        }

        if (currentWave < LAST_NYLO_WAVE && tick == nextWaveSpawnCheckTick) {
            // The spawn event handler runs before the on tick handler, so if `nextWaveSpawnCheckTick` is ever reached,
            // it means that the next wave did not spawn when expected, i.e. a stall occurred.
            nextWaveSpawnCheckTick += WAVE_TICK_CYCLE;

            log.debug("Stalled wave {} ({}/{})", currentWave, roomNyloCount(), waveCap());
            dispatchEvent(NyloWaveEvent.stall(tick, currentWave, roomNyloCount(), waveCap()));
        }

        assignParentsToSplits();
        bigDeathsThisTick.clear();
    }

    @Override
    protected Optional<? extends TrackedNpc> onNpcSpawn(NpcSpawned spawned) {
        NPC npc = spawned.getNpc();

        if (NYLOCAS_PILLAR_NPC_IDS.contains(npc.getId())) {
            startRoom();
            return Optional.empty();
        }

        if (TobNpc.isNylocas(npc.getId())) {
            return handleNylocasSpawn(npc);
        }

        Optional<TobNpc> maybeNpc = TobNpc.withId(npc.getId());
        if (maybeNpc.isEmpty()) {
            return Optional.empty();
        }
        TobNpc tobNpc = maybeNpc.get();

        if (TobNpc.isNylocasPrinkipas(tobNpc.getId())) {
            if (nyloBoss != null && nyloBoss.getNpc().isDead()) {
                despawnTrackedNpc(nyloBoss);
            }
            long roomId = generateRoomId(npc);
            nyloBoss = new NyloBoss(npc, tobNpc, roomId, new Hitpoints(tobNpc, theatreChallenge.getScale()));
            return Optional.of(nyloBoss);
        }

        if (TobNpc.isNylocasVasilias(tobNpc.getId())) {
            if (nyloBoss != null && nyloBoss.isPrince() && nyloBoss.getNpc().isDead()) {
                despawnTrackedNpc(nyloBoss);
            }

            // Two spawn events are sent out for the Nylo king: one when it first drops down, and one when the fight
            // actually starts. Only generate a new room ID for the former.
            boolean bossAlreadySpawned = nyloBoss != null && !nyloBoss.isPrince();

            long roomId;
            if (bossAlreadySpawned) {
                roomId = nyloBoss.getRoomId();
            } else {
                handleBossSpawn(npc);
                roomId = generateRoomId(npc);
            }

            nyloBoss = new NyloBoss(npc, tobNpc, roomId, new Hitpoints(tobNpc, theatreChallenge.getScale()));
            return Optional.of(nyloBoss);
        }

        return Optional.empty();
    }

    @Override
    protected boolean onNpcDespawn(NpcDespawned despawned, TrackedNpc trackedNpc) {
        NPC npc = despawned.getNpc();

        if (TobNpc.isDroppingNyloBoss(npc.getId())) {
            // A dropping boss despawning is not a true despawn; it will be replaced by the actual boss.
            return false;
        }

        if (TobNpc.isNylocasPrinkipas(npc.getId())) {
            nyloBoss = null;
            checkCleanupComplete();
            return true;
        }

        if (trackedNpc == nyloBoss) {
            nyloBoss = null;
            return true;
        }

        if (!TobNpc.isNylocas(npc.getId())) {
            return false;
        }

        Nylo nylo = nylosInRoom.remove(npc.hashCode());
        if (nylo == null) {
            return false;
        }
        assert nylo == trackedNpc;

        final int tick = getTick();

        nylo.recordDeath(tick, getWorldLocation(npc));
        if (nylo.isBig()) {
            bigDeathsThisTick.add(nylo);
        } else {
            // Only check to see if the room is empty when a small dies.
            checkCleanupComplete();
        }

        return true;
    }

    @Override
    protected void onNpcChange(NpcChanged event) {
        NPC npc = event.getNpc();
        Nylo nylo = nylosInRoom.get(npc.hashCode());
        if (nylo != null) {
            nylo.setStyle(Nylo.Style.fromNpcId(npc.getId()));
        }
    }

    @Override
    protected void onAnimation(AnimationChanged event) {
        Actor actor = event.getActor();
        if (nyloBoss == null || actor != nyloBoss.getNpc()) {
            return;
        }

        final int tick = getTick();

        NpcAttack attack;
        switch (actor.getAnimation()) {
            case NYLO_BOSS_MAGE_ANIMATION:
                attack = NpcAttack.TOB_NYLO_BOSS_MAGE;
                break;
            case NYLO_BOSS_RANGE_ANIMATION:
                attack = NpcAttack.TOB_NYLO_BOSS_RANGE;
                break;
            case NYLO_BOSS_MELEE_ANIMATION:
                attack = NpcAttack.TOB_NYLO_BOSS_MELEE;
                break;
            default:
                return;
        }

        dispatchEvent(new NpcAttackEvent(getStage(), tick, getWorldLocation(actor), attack, nyloBoss));
    }

    private Optional<Nylo> handleNylocasSpawn(NPC npc) {
        Optional<TobNpc> tobNpc = TobNpc.withId(npc.getId());
        if (tobNpc.isEmpty()) {
            return Optional.empty();
        }

        final int tick = getTick();

        WorldPoint point = getWorldLocation(npc);
        if (SpawnType.fromWorldPoint(point).isLaneSpawn()) {
            if (waveSpawnTicks[currentWave] != tick) {
                handleWaveSpawn(tick);
            }
        }

        Nylo nylo = new Nylo(npc, tobNpc.get(), generateRoomId(npc), point, tick,
                currentWave, tobNpc.get().getBaseHitpoints(theatreChallenge.getScale()));
        nylosInRoom.put(npc.hashCode(), nylo);
        return Optional.of(nylo);
    }

    private void handleWaveSpawn(int tick) {
        currentWave++;
        waveSpawnTicks[currentWave] = tick;
        if (currentWave < LAST_NYLO_WAVE) {
            if (isPrinceWave()) {
                nextWaveSpawnCheckTick = tick + 4 * WAVE_TICK_CYCLE;
            } else {
                nextWaveSpawnCheckTick = tick + NATURAL_STALLS[currentWave];
            }
        }

        if (currentWave == CAP_INCREASE_WAVE) {
            log.debug("Cap increase: {} ({})", tick, formattedRoomTime());
        } else if (currentWave == LAST_NYLO_WAVE) {
            log.debug("Waves: {} ({})", tick, formattedRoomTime());
        }
    }

    private void handleBossSpawn(NPC npc) {
        final int tick = getTick();

        if (bossSpawnTick == -1) {
            bossSpawnTick = tick;
            dispatchEvent(new NyloBossSpawnEvent(tick, getWorldLocation(npc)));
            log.debug("Boss: {} ({})", tick, formattedRoomTime());
        }
    }

    private void assignParentsToSplits() {
        // TODO(frolv): This could be made smarter in the case of overlapping big deaths by limiting each big to two
        // splits and attempting a best fit algorithm.
        final int tick = getTick();
        nylosInRoom.values().stream()
                .filter(nylo -> nylo.getSpawnTick() == tick && nylo.isSplit())
                .forEach(nylo -> bigDeathsThisTick.stream()
                        .filter(big -> big.isPossibleParentOf(nylo))
                        .findFirst()
                        .ifPresent(nylo::setParent));
    }

    private void checkCleanupComplete() {
        boolean princeAlive = nyloBoss != null && nyloBoss.isPrince() && !nyloBoss.getNpc().isDead();
        if (currentWave == LAST_NYLO_WAVE && nylosInRoom.isEmpty() && !princeAlive) {
            dispatchEvent(new NyloCleanupEndEvent(getTick()));
            log.debug("Cleanup: {} ({})", getTick(), formattedRoomTime());
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.nylocas;

import io.blert.challenges.tob.HpVarbitTrackedNpc;
import io.blert.challenges.tob.TobNpc;
import io.blert.core.Hitpoints;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.NPC;

@Getter
public class NyloBoss extends HpVarbitTrackedNpc {
    private final boolean prince;

    protected NyloBoss(@NonNull NPC npc, @NonNull TobNpc tobNpc, long roomId, Hitpoints hitpoints) {
        super(npc, tobNpc, roomId, hitpoints);
        this.prince = TobNpc.isNylocasPrinkipas(tobNpc.getId());
        if (this.prince) {
            setDisableVarbitUpdates(true);
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.nylocas;

import io.blert.challenges.tob.TobNpc;
import io.blert.core.Hitpoints;
import io.blert.core.TrackedNpc;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.util.Optional;

@Slf4j
public class Nylo extends TrackedNpc {
    @AllArgsConstructor
    @Getter
    public static class Properties extends TrackedNpc.Properties {
        private long roomId;
        private long parentRoomId;
        private int wave;
        private boolean big;
        private SpawnType spawnType;
        private Style style;
    }

    public enum Style {
        MELEE,
        RANGE,
        MAGE;

        static Style fromNpcId(int id) {
            if (TobNpc.isNylocasIschyros(id)) {
                return MELEE;
            }
            if (TobNpc.isNylocasToxobolos(id)) {
                return RANGE;
            }
            return MAGE;
        }
    }

    @Setter
    private @Nullable Nylo parent;
    @Getter
    private final SpawnType spawnType;
    @Getter
    private final WorldPoint spawnPoint;
    @Getter
    private final int spawnTick;
    @Getter
    private Style style;
    @Getter
    private final int wave;
    @Getter
    private final boolean big;

    @Getter
    private WorldPoint deathPoint;
    private int deathTick;

    public Nylo(@NonNull NPC npc, TobNpc tobNpc, long roomId, WorldPoint spawnPoint,
                int spawnTick, int wave, int baseHitpoints) {
        super(npc, tobNpc, roomId, new Hitpoints(baseHitpoints));
        this.parent = null;
        this.spawnType = SpawnType.fromWorldPoint(spawnPoint);
        this.spawnPoint = spawnPoint;
        this.spawnTick = spawnTick;
        this.style = Style.fromNpcId(npc.getId());
        this.wave = wave;
        this.big = npc.getComposition().getSize() > 1;
        this.deathTick = -1;
    }

    @Override
    public @NonNull TrackedNpc.Properties getProperties() {
        long parentRoomId = parent != null ? parent.getRoomId() : 0;
        return new Properties(getRoomId(), parentRoomId, wave, big, spawnType, style);
    }

    public void setStyle(Style style) {
        setUpdatedProperties(true);
        this.style = style;
    }

    public boolean isSplit() {
        return spawnType == SpawnType.SPLIT;
    }

    public Optional<Nylo> getParent() {
        return Optional.ofNullable(parent);
    }

    /**
     * Marks this nylo as having died.
     *
     * @param tick     Room tick on which the nylo died.
     * @param location Point at which the nylo died.
     */
    public void recordDeath(int tick, WorldPoint location) {
        deathTick = tick;
        deathPoint = location;
    }

    /**
     * Checks if this nylo may be a parent of {@code other}. Only possible after calling {@link #recordDeath} and if
     * this nylo is a big and {@code other} is a split.
     *
     * @param other Potential child to check.
     * @return {@code true} if this could be a parent of {@code other}.
     */
    public boolean isPossibleParentOf(Nylo other) {
        if (!big || !other.isSplit() || deathTick != other.spawnTick) {
            return false;
        }

        // Splits appear to spawn within a box of -1 to +2 tiles (inclusive) in both x and y directions around the
        // southwest tile of their parent.
        WorldArea areaToConsider = new WorldArea(deathPoint.getX() - 1, deathPoint.getY() - 1, 4, 4, 0);
        return areaToConsider.contains(other.spawnPoint);
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.xarpus;

import io.blert.challenges.tob.HpVarbitTrackedNpc;
import io.blert.challenges.tob.TheatreChallenge;
import io.blert.challenges.tob.TobNpc;
import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.RoomDataTracker;
import io.blert.core.ChallengeMode;
import io.blert.core.Hitpoints;
import io.blert.core.NpcAttack;
import io.blert.core.TrackedNpc;
import io.blert.events.NpcAttackEvent;
import io.blert.events.tob.XarpusPhaseEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;

import javax.annotation.Nullable;
import java.util.Optional;

@Slf4j
public class XarpusDataTracker extends RoomDataTracker {
    private static final int FIRST_P2_TURN_TICK = 7;
    private static final int TICKS_PER_TURN_P2 = 4;
    private static final int TICKS_PER_TURN_P3 = 8;

    private XarpusPhase phase;
    private @Nullable HpVarbitTrackedNpc xarpus = null;

    private int nextTurnTick = -1;

    public XarpusDataTracker(TheatreChallenge manager, Client client) {
        super(manager, client, Room.XARPUS);
    }

    @Override
    protected void onRoomStart() {
        if (xarpus == null) {
            client.getTopLevelWorldView().npcs().stream().filter(npc -> TobNpc.isAnyXarpus(npc.getId())).findFirst().ifPresent(npc -> {
                TobNpc tobNpc = TobNpc.withId(npc.getId()).orElseThrow();
                xarpus = new HpVarbitTrackedNpc(npc, tobNpc, generateRoomId(npc),
                        new Hitpoints(tobNpc, theatreChallenge.getScale()));
                addTrackedNpc(xarpus);
            });
        }

        phase = XarpusPhase.P1;
    }

    @Override
    protected void onTick() {
        super.onTick();
        final int tick = getTick();

        if (xarpus != null && xarpus.getNpc().getOverheadText() != null && phase != XarpusPhase.P3) {
            phase = XarpusPhase.P3;
            nextTurnTick = tick + TICKS_PER_TURN_P3;
            dispatchEvent(new XarpusPhaseEvent(tick, getWorldLocation(xarpus.getNpc()), phase));
            log.debug("Screech: {} ({})", tick, formattedRoomTime());
        }

        if (tick == nextTurnTick && xarpus != null) {
            WorldPoint point = getWorldLocation(xarpus);
            if (phase == XarpusPhase.P2) {
                nextTurnTick += TICKS_PER_TURN_P2;
                dispatchEvent(new NpcAttackEvent(getStage(), tick, point, NpcAttack.TOB_XARPUS_SPIT, xarpus));
            } else if (phase == XarpusPhase.P3) {
                if (theatreChallenge.getChallengeMode() != ChallengeMode.TOB_HARD) {
                    nextTurnTick += TICKS_PER_TURN_P3;
                    dispatchEvent(new NpcAttackEvent(getStage(), tick, point, NpcAttack.TOB_XARPUS_TURN, xarpus));
                }
            }
        }
    }

    @Override
    protected Optional<? extends TrackedNpc> onNpcSpawn(NpcSpawned event) {
        NPC npc = event.getNpc();

        Optional<TobNpc> maybeXarpus = TobNpc.withId(npc.getId()).filter(TobNpc::isAnyXarpus);
        if (maybeXarpus.isPresent()) {
            if (xarpus == null) {
                xarpus = new HpVarbitTrackedNpc(npc, maybeXarpus.get(), generateRoomId(npc),
                        new Hitpoints(maybeXarpus.get(), theatreChallenge.getScale()));
            }
            return Optional.of(xarpus);
        }

        return Optional.empty();
    }

    @Override
    protected boolean onNpcDespawn(NpcDespawned event, TrackedNpc trackedNpc) {
        if (trackedNpc == xarpus) {
            nextTurnTick = -1;
            return true;
        }
        return false;
    }

    @Override
    protected void onNpcChange(NpcChanged changed) {
        int idBefore = changed.getOld().getId();
        int idAfter = changed.getNpc().getId();

        if (TobNpc.isXarpusIdle(idBefore) && TobNpc.isXarpusP1(idAfter)) {
            startRoom();
            return;
        }

        final int tick = getTick();

        if (TobNpc.isXarpusP1(idBefore) && TobNpc.isXarpus(idAfter)) {
            phase = XarpusPhase.P2;
            nextTurnTick = tick + FIRST_P2_TURN_TICK;
            dispatchEvent(new XarpusPhaseEvent(tick, getWorldLocation(changed.getNpc()), phase));
            log.debug("Exhumes: {} ({})", tick, formattedRoomTime());
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.xarpus;

public enum XarpusPhase {
    P1,
    P2,
    P3,
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.tob.rooms.bloat;

import io.blert.challenges.tob.HpVarbitTrackedNpc;
import io.blert.challenges.tob.TheatreChallenge;
import io.blert.challenges.tob.TobNpc;
import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.RoomDataTracker;
import io.blert.core.Hitpoints;
import io.blert.core.NpcAttack;
import io.blert.core.TrackedNpc;
import io.blert.events.NpcAttackEvent;
import io.blert.events.tob.BloatDownEvent;
import io.blert.events.tob.BloatUpEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;

import java.util.Optional;

@Slf4j

public class BloatDataTracker extends RoomDataTracker {
    private static final int BLOAT_DOWN_ANIMATION = 8082;
    private static final int BLOAT_DOWN_CYCLE_TICKS = 32;
    private static final int BLOAT_STOMP_TICK = 3;

    private enum State {
        WALKING,
        DOWN,
    }

    private State state;
    private HpVarbitTrackedNpc bloat;

    private int currentDown;
    private int currentDownTick;
    private int lastDownTick;
    private int lastUpTick;
    private int nextUpTick;

    public BloatDataTracker(TheatreChallenge manager, Client client) {
        super(manager, client, Room.BLOAT, true);
        state = State.WALKING;
        currentDown = 0;
        lastDownTick = -1;
        lastUpTick = -1;
        nextUpTick = -1;
        bloat = null;
    }

    @Override
    protected void onRoomStart() {
        if (bloat == null) {
            client.getTopLevelWorldView().npcs().stream().filter(npc -> TobNpc.isBloat(npc.getId())).findFirst().ifPresent(npc -> {
                TobNpc tobNpc = TobNpc.withId(npc.getId()).orElseThrow();
                bloat = new HpVarbitTrackedNpc(npc, tobNpc, generateRoomId(npc),
                        new Hitpoints(tobNpc, theatreChallenge.getScale()));
                addTrackedNpc(bloat);
            });
        }

        if (bloat != null && bloat.getNpc().getAnimation() == BLOAT_DOWN_ANIMATION) {
            state = State.DOWN;
        } else {
            state = State.WALKING;
        }
    }

    @Override
    protected void onTick() {
        super.onTick();
        final int tick = getTick();

        if (state == State.DOWN) {
            if (lastDownTick == tick) {
                currentDownTick = BLOAT_DOWN_CYCLE_TICKS;
            } else {
                currentDownTick--;
            }

            if (tick == nextUpTick) {
                handleBloatUp(bloat.getNpc(), tick);
            } else if (currentDownTick == BLOAT_STOMP_TICK && bloat != null) {
                WorldPoint point = getWorldLocation(bloat);
                dispatchEvent(new NpcAttackEvent(getStage(), tick, point, NpcAttack.TOB_BLOAT_STOMP, bloat));
            }
        }
    }

    @Override
    protected Optional<? extends TrackedNpc> onNpcSpawn(NpcSpawned event) {
        NPC npc = event.getNpc();

        return TobNpc.withId(npc.getId())
                .filter(tobNpc -> TobNpc.isBloat(tobNpc.getId()))
                .map(tobNpc -> {
                    if (bloat == null) {
                        bloat = new HpVarbitTrackedNpc(npc, tobNpc, generateRoomId(npc),
                                new Hitpoints(tobNpc, theatreChallenge.getScale()));
                    }
                    return bloat;
                });
    }

    @Override
    protected boolean onNpcDespawn(NpcDespawned event, TrackedNpc trackedNpc) {
        return trackedNpc == bloat;
    }

    @Override
    protected void onAnimation(AnimationChanged event) {
        Actor actor = event.getActor();
        if (!(actor instanceof NPC)) {
            return;
        }

        NPC npc = (NPC) actor;
        if (!TobNpc.isBloat(npc.getId())) {
            return;
        }

        final int tick = getTick();
        if (npc.getAnimation() == BLOAT_DOWN_ANIMATION) {
            handleBloatDown(npc, tick);
        } else if (state == State.DOWN && npc.getAnimation() == -1) {
            handleBloatUp(npc, tick);
        }
    }

    private void handleBloatDown(NPC bloat, int tick) {
        currentDown++;
        state = State.DOWN;
        lastDownTick = tick;
        nextUpTick = tick + BLOAT_DOWN_CYCLE_TICKS + 1;
        log.debug("Bloat down {} tick {}", currentDown, lastDownTick);

        dispatchEvent(new BloatDownEvent(tick, getWorldLocation(bloat), currentDown, tick - lastUpTick));
    }

    private void handleBloatUp(NPC bloat, int tick) {
        lastUpTick = tick;
        nextUpTick = -1;
        state = State.WALKING;
        log.debug("Bloat up {} tick {}", currentDown, lastUpTick);

        dispatchEvent(new BloatUpEvent(tick, getWorldLocation(bloat)));
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.colosseum;

import io.blert.core.*;
import io.blert.events.ChallengeEndEvent;
import io.blert.events.ChallengeStartEvent;
import io.blert.util.DeferredTask;
import io.blert.util.Location;
import io.blert.util.Tick;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.tuple.Pair;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
public final class ColosseumChallenge extends RecordableChallenge {
    final static Pattern COLOSSEUM_END_REGEX = Pattern.compile(
            "Colosseum duration: (" + Tick.TIME_STRING_REGEX + ")");

    private static final int COLOSSEUM_REGION_ID = 7216;
    private static final int COLOSSEUM_LOBBY_REGION_ID = 7316;
    private static final WorldArea COLOSSEUM_AREA = new WorldArea(1806, 3088, 38, 38, 0);

    private static final int MINIMUS_NPC_ID = 12808;
    private static final int REWARD_CHEST_OBJECT_ID = 50741;

    private static final int HANDICAP_SELECTION_SCRIPT_ID = 4931;
    private static final int HANDICAP_SELECTION_VARBIT_ID = 9788;

    private int currentWave;
    private WaveDataTracker waveDataTracker;
    private int recordedChallengeTicks;
    private int reportedChallengeTicks;

    private final List<Handicap> waveHandicapOptions = new ArrayList<>(3);

    private @Nullable DeferredTask deferredTask = null;
    private boolean stateChangeCooldown;

    public ColosseumChallenge(Client client, ClientThread clientThread) {
        super(Challenge.COLOSSEUM, client, clientThread);
    }

    @Nullable
    @Override
    protected DataTracker getActiveTracker() {
        return waveDataTracker;
    }

    @Override
    public boolean containsLocation(WorldPoint worldPoint) {
        return worldPoint.getRegionID() == COLOSSEUM_REGION_ID || worldPoint.getRegionID() == COLOSSEUM_LOBBY_REGION_ID;
    }

    @Override
    protected void onInitialize() {
        reset();
        addRaider(new Raider(client.getLocalPlayer(), true));
    }

    @Override
    protected void onTerminate() {
        if (getState().inChallenge()) {
            log.warn("Terminating Colosseum challenge while still active");
            finishColosseum(ChallengeState.INACTIVE);
        }
        cleanup();
    }

    @Override
    protected void onTick() {
        if (!stateChangeCooldown) {
            checkColosseumState();
        }

        if (getState().inChallenge()) {
            if (waveDataTracker != null) {
                waveDataTracker.tick();
            }
        }

        if (deferredTask != null) {
            deferredTask.tick();
        }
    }

    @Nullable
    @Override
    protected Stage getStage() {
        return waveDataTracker != null ? waveDataTracker.getStage() : null;
    }

    @Override
    public void onNpcSpawned(NpcSpawned event) {
        if (!stateChangeCooldown && event.getNpc().getId() == MINIMUS_NPC_ID) {
            prepareNextWave();
        }
        super.onNpcSpawned(event);
    }

    @Override
    public void onNpcDespawned(NpcDespawned event) {
        if (event.getNpc().getId() == MINIMUS_NPC_ID) {
            if (getState() == ChallengeState.STARTING) {
                setState(ChallengeState.ACTIVE);
            }

            if (getState() == ChallengeState.ACTIVE) {
                stateChangeCooldown = true;
                deferredTask = new DeferredTask(() -> {
                    stateChangeCooldown = false;

                    if (!waveHandicapOptions.isEmpty()) {
                        // The debuff selection varbit stores the index of the selected debuff option, starting from 1.
                        int selectedDebuffIndex = client.getVarbitValue(HANDICAP_SELECTION_VARBIT_ID) - 1;
                        Handicap selectedHandicap = waveHandicapOptions.get(selectedDebuffIndex);
                        if (waveDataTracker != null) {
                            waveDataTracker.setHandicapOptions(waveHandicapOptions.toArray(new Handicap[3]));
                            waveDataTracker.setHandicap(selectedHandicap);
                        }
                    }
                }, 3);
            }
        }
        super.onNpcDespawned(event);
    }

    @Override
    public void onGameObjectSpawned(GameObjectSpawned event) {
        if (event.getGameObject().getId() == REWARD_CHEST_OBJECT_ID) {
            if (deferredTask != null) {
                deferredTask.cancel();
            }
            queueFinishColosseum(ChallengeState.COMPLETE);
        }
        super.onGameObjectSpawned(event);
    }

    @Override
    public void onChatMessage(ChatMessage event) {
        if (!getState().isInactive()) {
            Matcher matcher = ColosseumChallenge.COLOSSEUM_END_REGEX.matcher(Text.removeTags(event.getMessage()));
            if (matcher.find()) {
                try {
                    reportedChallengeTicks = Tick.fromTimeString(matcher.group(1)).map(Pair::getLeft).orElse(-1);
                } catch (Exception e) {
                    reportedChallengeTicks = -1;
                }
            }
        }
        super.onChatMessage(event);
    }

    @Override
    public void onScriptPreFired(ScriptPreFired event) {
        if (!getState().isInactive() && event.getScriptId() == HANDICAP_SELECTION_SCRIPT_ID) {
            waveHandicapOptions.clear();
            Object[] scriptArgs = event.getScriptEvent().getArguments();
            waveHandicapOptions.add(Handicap.withId((int) scriptArgs[2]));
            waveHandicapOptions.add(Handicap.withId((int) scriptArgs[3]));
            waveHandicapOptions.add(Handicap.withId((int) scriptArgs[4]));
        }

        super.onScriptPreFired(event);
    }

    private void checkColosseumState() {
        WorldPoint playerLocation = Location.getWorldLocation(client, client.getLocalPlayer().getWorldLocation());
        if (playerLocation == null) {
            return;
        }

        if (getState().isInactive()) {
            if (COLOSSEUM_AREA.contains(playerLocation)) {
                startColosseum();
            }
        } else if (playerLocation.getRegionID() != COLOSSEUM_REGION_ID) {
            clearWaveDataTracker();
            if (getState() == ChallengeState.COMPLETE) {
                setState(ChallengeState.INACTIVE);
            } else {
                queueFinishColosseum(ChallengeState.INACTIVE);
            }
        }
    }

    private void startColosseum() {
        // TODO(frolv): Check for late starts (e.g. plugin being turned on mid-challenge).
        log.debug("Starting Colosseum challenge");
        setState(ChallengeState.STARTING);
        reportedChallengeTicks = -1;

        List<String> usernames = getParty().stream().map(Raider::getUsername).collect(Collectors.toList());
        dispatchEvent(new ChallengeStartEvent(
                getChallenge(), ChallengeMode.NO_MODE, Stage.COLOSSEUM_WAVE_1, usernames, false));
    }

    private void queueFinishColosseum(ChallengeState state) {
        stateChangeCooldown = true;
        deferredTask = new DeferredTask(() -> finishColosseum(state), 3);
    }

    private void finishColosseum(ChallengeState state) {
        log.debug("Ending Colosseum challenge: {}", state);
        stateChangeCooldown = false;

        cleanup();
        dispatchEvent(new ChallengeEndEvent(reportedChallengeTicks, -1));

        setState(state);
    }

    private void prepareNextWave() {
        if (waveDataTracker != null) {
            clearWaveDataTracker();
        }

        currentWave++;
        if (currentWave < 13) {
            waveDataTracker = new WaveDataTracker(this, client, currentWave, recordedChallengeTicks);
        }
    }

    private void clearWaveDataTracker() {
        if (waveDataTracker != null) {
            recordedChallengeTicks += waveDataTracker.getTotalTicks();
            waveDataTracker.terminate();
            waveDataTracker = null;
        }
    }

    private void cleanup() {
        clearWaveDataTracker();
        reset();
    }

    private void reset() {
        currentWave = 0;
        recordedChallengeTicks = 0;
        reportedChallengeTicks = -1;
        stateChangeCooldown = false;
        waveHandicapOptions.clear();
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.colosseum;

import io.blert.core.BasicTrackedNpc;
import io.blert.core.Hitpoints;
import io.blert.core.NpcAttack;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.NPC;

import javax.annotation.Nullable;

public class Manticore extends BasicTrackedNpc {
    public final static int LOADING_ANIMATION = 10868;
    public final static int ATTACK_ANIMATION = 10869;

    private final static int MAGE_PROJECTILE = 2681;
    private final static int RANGE_PROJECTILE = 2683;
    private final static int MELEE_PROJECTILE = 2685;

    enum Style {
        MAGE,
        RANGE,
        MELEE,
    }

    @Getter
    private @Nullable Style style = null;

    private int attacksRemaining = 0;

    public Manticore(@NonNull NPC npc, long roomId, Hitpoints hitpoints) {
        super(npc, roomId, hitpoints);
    }

    public void updateStyle() {
        if (style != null) {
            return;
        }

        NPC npc = getNpc();
        if (npc.getAnimation() == LOADING_ANIMATION || npc.getAnimation() == ATTACK_ANIMATION) {
            // Manticores can have multiple style graphics; the first one is its next attack.
            for (var spotAnim : npc.getSpotAnims()) {
                if (spotAnim.getId() == MAGE_PROJECTILE) {
                    style = Style.MAGE;
                    break;
                }
                if (spotAnim.getId() == RANGE_PROJECTILE) {
                    style = Style.RANGE;
                    break;
                }
                if (spotAnim.getId() == MELEE_PROJECTILE) {
                    style = Style.MELEE;
                    break;
                }
            }
        } else {
            style = null;
        }
    }

    public void startAttack() {
        attacksRemaining = 3;
    }

    public @Nullable NpcAttack continueAttack() {
        if (attacksRemaining == 0 || getNpc().isDead()) {
            return null;
        }

        attacksRemaining--;
        NpcAttack attack = attackForStyle();
        style = null;
        return attack;
    }

    private @Nullable NpcAttack attackForStyle() {
        if (style == null) {
            return null;
        }
        switch (style) {
            case MAGE:
                return NpcAttack.COLOSSEUM_MANTICORE_MAGE;
            case RANGE:
                return NpcAttack.COLOSSEUM_MANTICORE_RANGE;
            default:
                return NpcAttack.COLOSSEUM_MANTICORE_MELEE;
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.colosseum;

import io.blert.core.*;
import io.blert.events.NpcAttackEvent;
import io.blert.events.colosseum.HandicapChoiceEvent;
import io.blert.util.Tick;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.util.Text;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class WaveDataTracker extends DataTracker {
    private final static String bossStartMessage = "Sol Heredit jumps down from his seat...";
    private final String waveStartMessage;
    private final Pattern waveEndRegex;

    private final int ticksOnEntry;
    @Setter
    private Handicap handicap;
    @Setter
    private Handicap[] handicapOptions;

    public static Stage waveToStage(int wave) {
        return Stage.values()[Stage.COLOSSEUM_WAVE_1.ordinal() + wave - 1];
    }

    public WaveDataTracker(RecordableChallenge challenge, Client client, int wave, int ticksOnEntry) {
        super(challenge, client, waveToStage(wave));

        this.waveStartMessage = "Wave: " + wave;
        this.waveEndRegex = Pattern.compile("Wave " + wave + " completed! " +
                "Wave duration: (" + Tick.TIME_STRING_REGEX + ")");
        this.ticksOnEntry = ticksOnEntry;
    }

    @Override
    protected Optional<? extends TrackedNpc> onNpcSpawn(NpcSpawned event) {
        return ColosseumNpc.withId(event.getNpc().getId()).map(colosseumNpc -> {
            NPC npc = event.getNpc();
            if (colosseumNpc.isManticore()) {
                return new Manticore(npc, generateRoomId(npc), new Hitpoints(colosseumNpc.getHitpoints()));
            }
            return new BasicTrackedNpc(npc, generateRoomId(npc), new Hitpoints(colosseumNpc.getHitpoints()));
        });
    }

    @Override
    protected boolean onNpcDespawn(NpcDespawned event, @Nullable TrackedNpc trackedNpc) {
        return ColosseumNpc.withId(event.getNpc().getId()).isPresent();
    }

    @Override
    protected void onAnimation(AnimationChanged event) {
        if (!(event.getActor() instanceof NPC)) {
            return;
        }

        NPC npc = (NPC) event.getActor();
        Optional<ColosseumNpc> maybeNpc = ColosseumNpc.withId(npc.getId());
        Optional<TrackedNpc> maybeTrackedNpc = getTrackedNpcs().getByNpc(npc);
        if (maybeNpc.isEmpty() || maybeTrackedNpc.isEmpty() || npc.getAnimation() == -1) {
            return;
        }

        ColosseumNpc colosseumNpc = maybeNpc.get();
        TrackedNpc trackedNpc = maybeTrackedNpc.get();

        if (colosseumNpc.isManticore()) {
            Manticore manticore = (Manticore) trackedNpc;
            if (npc.getAnimation() == Manticore.ATTACK_ANIMATION) {
                manticore.startAttack();
            }
            return;
        }

        colosseumNpc.getAttack(npc.getAnimation()).ifPresent(attack -> {
            WorldPoint location = getWorldLocation(npc);
            dispatchEvent(new NpcAttackEvent(getStage(), getTick(), location, attack, trackedNpc));
        });
    }

    @Override
    protected void onTick() {
        if (notStarted()) {
            return;
        }

        getTrackedNpcs().stream()
                .filter(trackedNpc -> trackedNpc instanceof Manticore)
                .forEach(trackedNpc -> {
                    Manticore manticore = (Manticore) trackedNpc;
                    // Check for an attack using the previous tick's style before updating.
                    NpcAttack attack = manticore.continueAttack();
                    if (attack != null) {
                        WorldPoint location = getWorldLocation(manticore.getNpc());
                        dispatchEvent(new NpcAttackEvent(getStage(), getTick(), location, attack, manticore));
                    }
                    manticore.updateStyle();
                });
    }

    @Override
    protected void onMessage(ChatMessage event) {
        String stripped = Text.removeTags(event.getMessage());

        if (stripped.equals(waveStartMessage)) {
            startWave(0);
            return;
        }
        if (stripped.equals(bossStartMessage)) {
            startWave(-1);
            return;
        }

        if (getStage() == Stage.COLOSSEUM_WAVE_12) {
            Matcher matcher = ColosseumChallenge.COLOSSEUM_END_REGEX.matcher(stripped);
            if (matcher.find()) {
                try {
                    var ticks = Tick.fromTimeString(matcher.group(1));
                    if (ticks.isPresent()) {
                        int challengeTicks = ticks.get().getLeft();
                        int bossTicks = challengeTicks - ticksOnEntry;
                        finish(true, bossTicks, ticks.get().getRight());
                    } else {
                        finish(true);
                    }
                } catch (Exception e) {
                    log.warn("Could not parse timestamp from colosseum end message: {}", stripped);
                    finish(true);
                }
            }
        } else {
            Matcher matcher = waveEndRegex.matcher(stripped);
            if (matcher.find()) {
                try {
                    String inGameTime = matcher.group(1);
                    finish(inGameTime);
                } catch (Exception e) {
                    log.warn("Could not parse timestamp from wave end message: {}", stripped);
                    finish(true);
                }
            }
        }
    }

    private void startWave(int tickOffset) {
        if (getState() == State.NOT_STARTED) {
            super.start(tickOffset);
            dispatchEvent(new HandicapChoiceEvent(
                    getStage(), handicap, Arrays.copyOf(handicapOptions, handicapOptions.length)));
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.colosseum;

import lombok.Getter;

@Getter
public enum Handicap {
    MANTIMAYHEM(0),
    REENTRY(1),
    BEES(2),
    VOLATILITY(3),
    BLASPHEMY(4),
    RELENTLESS(5),
    QUARTET(6),
    TOTEMIC(7),
    DOOM(8),
    DYNAMIC_DUO(9),
    SOLARFLARE(10),
    MYOPIA(11),
    FRAILTY(12),
    RED_FLAG(13),
    ;

    private final int id;

    Handicap(int id) {
        this.id = id;
    }

    public static Handicap withId(int id) {
        for (Handicap handicap : values()) {
            if (handicap.id == id) {
                return handicap;
            }
        }
        return null;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.challenges.colosseum;

import io.blert.core.NpcAttack;
import lombok.Getter;
import org.apache.commons.lang3.tuple.Pair;

import java.util.Optional;

public enum ColosseumNpc {
    JAGUAR_WARRIOR(12810, 125, Pair.of(10847, NpcAttack.COLOSSEUM_JAGUAR_AUTO)),
    SERPENT_SHAMAN(12811, 125, Pair.of(10859, NpcAttack.COLOSSEUM_SHAMAN_AUTO)),
    MINOTAUR(12812, 225, Pair.of(10843, NpcAttack.COLOSSEUM_MINOTAUR_AUTO)),
    FREMENNIK_ARCHER(12814, 50, Pair.of(10850, NpcAttack.COLOSSEUM_ARCHER_AUTO)),
    FREMENNIK_SEER(12815, 50, Pair.of(10853, NpcAttack.COLOSSEUM_SEER_AUTO)),
    FREMENNIK_BERSERKER(12816, 50, Pair.of(10856, NpcAttack.COLOSSEUM_BERSERKER_AUTO)),
    JAVELIN_COLOSSUS(
            12817,
            220,
            Pair.of(10892, NpcAttack.COLOSSEUM_JAVELIN_AUTO),
            Pair.of(10893, NpcAttack.COLOSSEUM_JAVELIN_TOSS)
    ),
    MANTICORE(12818, 250),
    SHOCKWAVE_COLOSSUS(12819, 125, Pair.of(10903, NpcAttack.COLOSSEUM_SHOCKWAVE_AUTO)),
    SOL_HEREDIT(
            12821,
            1500,
            Pair.of(10883, NpcAttack.COLOSSEUM_HEREDIT_THRUST),
            Pair.of(10884, NpcAttack.COLOSSEUM_HEREDIT_BREAK),
            Pair.of(10885, NpcAttack.COLOSSEUM_HEREDIT_SLAM),
            Pair.of(10887, NpcAttack.COLOSSEUM_HEREDIT_COMBO)
    ),
    SOLARFLARE(12826, 0),
    ;

    @Getter
    private final int id;
    @Getter
    private final int hitpoints;
    private final Pair<Integer, NpcAttack>[] attacks;

    public static Optional<ColosseumNpc> withId(int id) {
        for (ColosseumNpc npc : values()) {
            if (npc.id == id) {
                return Optional.of(npc);
            }
        }
        return Optional.empty();
    }

    Optional<NpcAttack> getAttack(int animationId) {
        for (Pair<Integer, NpcAttack> attack : attacks) {
            if (attack.getLeft() == animationId) {
                return Optional.of(attack.getRight());
            }
        }
        return Optional.empty();
    }

    public boolean isManticore() {
        return this == MANTICORE;
    }

    @SafeVarargs
    ColosseumNpc(int id, int hitpoints, Pair<Integer, NpcAttack>... attacks) {
        this.id = id;
        this.hitpoints = hitpoints;
        this.attacks = attacks;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert;

import com.google.gson.Gson;
import com.google.inject.Provides;
import io.blert.challenges.colosseum.ColosseumChallenge;
import io.blert.challenges.tob.TheatreChallenge;
import io.blert.client.WebSocketManager;
import io.blert.core.AttackRegistry;
import io.blert.core.RecordableChallenge;
import io.blert.core.SpellRegistry;
import io.blert.util.DeferredTask;
import io.blert.util.Location;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.WorldType;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

@Slf4j
@PluginDescriptor(
        name = "Blert"
)
public class BlertPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private EventBus eventBus;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private BlertConfig config;

    @Inject
    private WebSocketManager websocketManager;

    @Inject
    @Getter
    private Gson gson;

    @Getter
    private BlertPluginPanel sidePanel;
    private NavigationButton sidePanelButton;

    @Getter
    private final AttackRegistry attackRegistry = new AttackRegistry();

    @Getter
    private final SpellRegistry spellRegistry = new SpellRegistry();

    private final List<RecordableChallenge> challenges = new ArrayList<>();
    @Getter
    private @Nullable RecordableChallenge activeChallenge = null;

    private enum LoginState {
        LOGGED_IN,
        JUST_LOGGED_IN,
        LOGGED_OUT;

        LoginState logIn() {
            if (this == LOGGED_OUT) {
                log.info("LOGGED_OUT -> JUST_LOGGED_IN");
                return JUST_LOGGED_IN;
            }
            return LOGGED_IN;
        }

        LoginState update() {
            if (this == JUST_LOGGED_IN) {
                log.info("state JUST_LOGGED_IN -> LOGGED_IN");
                return LOGGED_IN;
            }
            return this;
        }

        boolean isLoggedIn() {
            return this != LOGGED_OUT;
        }
    }

    private GameState previousGameState = null;
    private LoginState loginState = LoginState.LOGGED_OUT;
    private boolean enabled = true;

    private DeferredTask deferredTask;

    @Override
    protected void startUp() throws Exception {
        attackRegistry.setGson(gson);
        spellRegistry.setGson(gson);
        attackRegistry.loadDefaults();
        spellRegistry.loadDefaults();

        websocketManager.open();

        sidePanel = new BlertPluginPanel(config, websocketManager);
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/blert.png");
        sidePanelButton = NavigationButton.builder().tooltip("Blert").priority(6).icon(icon).panel(sidePanel).build();
        clientToolbar.addNavigation(sidePanelButton);
        sidePanel.startPanel();

        challenges.add(new TheatreChallenge(client, clientThread));
        challenges.add(new ColosseumChallenge(client, clientThread));

        previousGameState = client.getGameState();
        loginState = previousGameState == GameState.LOGGED_IN ? LoginState.LOGGED_IN : LoginState.LOGGED_OUT;

        if (loginState.isLoggedIn()) {
            checkWorldType();
        }
    }

    @Override
    protected void shutDown() throws Exception {
        websocketManager.close();

        clientToolbar.removeNavigation(sidePanelButton);
        sidePanel.stopPanel();
        sidePanel = null;

        if (activeChallenge != null) {
            activeChallenge.terminate();
            activeChallenge = null;
        }

        challenges.clear();
    }

    @Subscribe(priority = 10)
    public void onGameTick(GameTick gameTick) {
        if (deferredTask != null) {
            deferredTask.tick();
        }

        if (loginState != LoginState.JUST_LOGGED_IN) {
            updateActiveChallenge();

            if (activeChallenge != null) {
                activeChallenge.tick();
            }
        }

        loginState = loginState.update();
    }

    @Subscribe
    private void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState == previousGameState) {
            return;
        }

        if (gameState == GameState.LOGGED_IN) {
            if (config.apiKey() != null && websocketManager.shouldTryToConnect()) {
                websocketManager.open();
            }

            checkWorldType();

            // If the player was not already logged in, notify the server that they have.
            if (!loginState.isLoggedIn()) {
                deferredTask = new DeferredTask(() -> {
                    if (websocketManager.getEventHandler() != null) {
                        websocketManager.getEventHandler().updateGameState(GameState.LOGGED_IN);
                    }
                }, 3);
            }

            loginState = loginState.logIn();
        } else if (gameState == GameState.LOGIN_SCREEN) {
            if (loginState.isLoggedIn() && websocketManager.getEventHandler() != null) {
                websocketManager.getEventHandler().updateGameState(GameState.LOGIN_SCREEN);
            }

            loginState = LoginState.LOGGED_OUT;
        }

        previousGameState = gameState;

        if (activeChallenge != null) {
            activeChallenge.onGameStateChanged(gameStateChanged);
        }
    }

    @Provides
    BlertConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(BlertConfig.class);
    }

    /**
     * Updates the active challenge based on the player's game location.
     */
    private void updateActiveChallenge() {
        WorldPoint playerLocation = Location.getWorldLocation(client, client.getLocalPlayer().getWorldLocation());

        var maybeChallenge = challenges.stream().filter(c -> c.containsLocation(playerLocation)).findFirst();
        if (enabled && maybeChallenge.isPresent()) {
            RecordableChallenge challenge = maybeChallenge.get();
            if (activeChallenge == challenge) {
                return;
            }

            if (activeChallenge != null) {
                activeChallenge.terminate();
            }

            activeChallenge = challenge;
            activeChallenge.initialize(websocketManager.getEventHandler(), attackRegistry, spellRegistry);

            log.info("Entered challenge \"{}\"", activeChallenge.getName());
        } else if (activeChallenge != null) {
            log.info("Exited challenge \"{}\"", activeChallenge.getName());

            activeChallenge.terminate();
            activeChallenge = null;
        }
    }

    private void checkWorldType() {
        var worldTypes = client.getWorldType();
        enabled = !worldTypes.contains(WorldType.BETA_WORLD)
                && !worldTypes.contains(WorldType.DEADMAN)
                && !worldTypes.contains(WorldType.QUEST_SPEEDRUNNING)
                && !worldTypes.contains(WorldType.SEASONAL);
        if (!enabled) {
            log.info("Plugin is disabled due to world type: {}", worldTypes);
        }
    }

    @Subscribe
    private void onConfigChanged(ConfigChanged event) {
        websocketManager.onConfigChanged(event);
    }

    @Subscribe(priority = 10)
    private void onNpcSpawned(NpcSpawned event) {
        if (activeChallenge != null) {
            activeChallenge.onNpcSpawned(event);
        }
    }

    @Subscribe
    private void onNpcDespawned(NpcDespawned event) {
        if (activeChallenge != null) {
            activeChallenge.onNpcDespawned(event);
        }
    }

    @Subscribe
    private void onNpcChanged(NpcChanged event) {
        if (activeChallenge != null) {
            activeChallenge.onNpcChanged(event);
        }
    }

    @Subscribe
    private void onAnimationChanged(AnimationChanged event) {
        if (activeChallenge != null) {
            activeChallenge.onAnimationChanged(event);
        }
    }

    @Subscribe
    private void onProjectileMoved(ProjectileMoved event) {
        if (activeChallenge != null) {
            activeChallenge.onProjectileMoved(event);
        }
    }

    @Subscribe(priority = 5)
    private void onChatMessage(ChatMessage event) {
        if (activeChallenge != null) {
            activeChallenge.onChatMessage(event);
        }
    }

    @Subscribe
    private void onHitsplatApplied(HitsplatApplied event) {
        if (activeChallenge != null) {
            activeChallenge.onHitsplatApplied(event);
        }
    }

    @Subscribe
    private void onGameObjectSpawned(GameObjectSpawned event) {
        if (activeChallenge != null) {
            activeChallenge.onGameObjectSpawned(event);
        }
    }

    @Subscribe
    private void onGameObjectDespawned(GameObjectDespawned event) {
        if (activeChallenge != null) {
            activeChallenge.onGameObjectDespawned(event);
        }
    }

    @Subscribe
    private void onGroundObjectSpawned(GroundObjectSpawned event) {
        if (activeChallenge != null) {
            activeChallenge.onGroundObjectSpawned(event);
        }
    }

    @Subscribe
    private void onGroundObjectDespawned(GroundObjectDespawned event) {
        if (activeChallenge != null) {
            activeChallenge.onGroundObjectDespawned(event);
        }
    }

    @Subscribe
    private void onGraphicChanged(GraphicChanged event) {
        if (activeChallenge != null) {
            activeChallenge.onGraphicChanged(event);
        }
    }

    @Subscribe
    private void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        if (activeChallenge != null) {
            activeChallenge.onGraphicsObjectCreated(event);
        }
    }

    @Subscribe
    private void onActorDeath(ActorDeath event) {
        if (activeChallenge != null) {
            activeChallenge.onActorDeath(event);
        }
    }

    @Subscribe(priority = 10)
    private void onVarbitChanged(VarbitChanged event) {
        if (activeChallenge != null) {
            activeChallenge.onVarbitChanged(event);
        }
    }

    @Subscribe
    private void onScriptPreFired(ScriptPreFired event) {
        if (activeChallenge != null) {
            activeChallenge.onScriptPreFired(event);
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.client;

import io.blert.BuildProperties;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import okhttp3.internal.annotations.EverythingIsNonNull;

import javax.annotation.Nullable;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;
import java.util.function.Consumer;

@Slf4j
public class WebSocketClient extends WebSocketListener {
    public enum State {
        CLOSED,
        OPEN,
        CONNECTING,
        CLOSING,
        REJECTED,
    }

    public enum DisconnectReason {
        CLOSED_SUCCESSFULLY,
        UNSUPPORTED_VERSION,
        ERROR,
    }

    @NonNull
    private final String hostname;
    private final byte[] apiKey;
    private final String runeliteVersion;
    private final OkHttpClient client;
    private WebSocket socket;
    private State state = State.CLOSED;

    private final List<CompletableFuture<Boolean>> openFutures = new ArrayList<>();
    private final List<CompletableFuture<Void>> closeFutures = new ArrayList<>();

    @Setter
    private @Nullable Consumer<byte[]> binaryMessageCallback = null;

    @Setter
    private @Nullable Consumer<String> textMessageCallback = null;

    @Setter
    private @Nullable Consumer<DisconnectReason> disconnectCallback = null;

    public WebSocketClient(@NonNull String hostname, @NonNull String apiKey,
                           @NonNull String runeliteVersion, OkHttpClient client) {
        this.apiKey = apiKey.getBytes(StandardCharsets.UTF_8);
        this.hostname = hostname;
        this.runeliteVersion = runeliteVersion;
        this.client = client;
    }

    /**
     * Checks if the socket is connected.
     *
     * @return True if the websocket is connected and messages can be sent or received.
     */
    public synchronized boolean isOpen() {
        return state == State.OPEN;
    }

    /**
     * Gets the current state of the websocket connection.
     *
     * @return Connection state.
     */
    public synchronized State getState() {
        return state;
    }

    /**
     * Opens the websocket connection to the configured server.
     *
     * @return A future that resolves to true if the connection was successful, or false if not.
     */
    public Future<Boolean> open() {
        if (state == State.REJECTED) {
            // The WebSocketClient is tied to a client/API key configuration, so if the connection was rejected,
            // all subsequent attempts will also be rejected.
            log.warn("Ignoring websocket reconnection attempt after rejection");
            return CompletableFuture.completedFuture(false);
        }

        Request.Builder request = new Request.Builder()
                .url(hostname)
                .header("Authorization", "Basic " + Base64.getEncoder().encodeToString(apiKey))
                .header("Sec-WebSocket-Protocol", "blert-json")
                .header("Blert-Revision", BuildProperties.REVISION)
                .header("Blert-Version", BuildProperties.VERSION)
                .header("Blert-Runelite-Version", runeliteVersion);

        for (String header : BuildProperties.CUSTOM_HEADERS) {
            String[] parts = header.split("=", 2);
            if (parts.length == 2) {
                request.header(parts[0], parts[1]);
            }
        }

        CompletableFuture<Boolean> future = new CompletableFuture<>();

        synchronized (this) {
            openFutures.add(future);
            socket = client.newWebSocket(request.build(), this);
            state = State.CONNECTING;
        }

        return future;
    }

    /**
     * Sends a text message through the open websocket.
     *
     * @param message The text to send.
     */
    public void sendTextMessage(String message) {
        if (isOpen()) {
            socket.send(message);
        }
    }

    /**
     * Sends a binary message through the open websocket.
     *
     * @param message The binary message to send.
     */
    public void sendMessage(byte[] message) {
        if (isOpen()) {
            socket.send(okio.ByteString.of(message));
        }
    }

    @Override
    @EverythingIsNonNull
    public synchronized void onOpen(WebSocket webSocket, Response response) {
        log.info("Blert websocket {} opened", webSocket);
        state = State.OPEN;
        openFutures.forEach(future -> future.complete(true));
        openFutures.clear();
    }

    @Override
    @EverythingIsNonNull
    public void onMessage(WebSocket webSocket, okio.ByteString bytes) {
        if (!isOpen()) {
            return;
        }
        if (this.binaryMessageCallback != null) {
            this.binaryMessageCallback.accept(bytes.toByteArray());
        }
    }

    @Override
    @EverythingIsNonNull
    public void onMessage(WebSocket webSocket, String text) {
        if (!isOpen()) {
            return;
        }
        log.debug("Blert websocket {} received message {}", webSocket, text);
        if (this.textMessageCallback != null) {
            this.textMessageCallback.accept(text);
        }
    }

    @Override
    @EverythingIsNonNull
    public synchronized void onClosed(WebSocket webSocket, int status, String reason) {
        log.info("Blert websocket {} closed: {} ({})", webSocket, status, reason);
        state = State.CLOSED;
        socket = null;
        closeFutures.forEach(future -> future.complete(null));
        closeFutures.clear();
        onDisconnect(DisconnectReason.CLOSED_SUCCESSFULLY);
    }

    @Override
    public synchronized void onFailure(@NonNull WebSocket webSocket, @NonNull Throwable t, Response response) {
        // Capture previous state before modifying to properly notify listeners.
        State previousState = state;

        if (state == State.CONNECTING) {
            openFutures.forEach(future -> future.complete(false));
            openFutures.clear();
        }

        state = State.CLOSED;
        socket = null;

        if (response != null) {
            switch (response.code()) {
                case 403:
                    state = State.REJECTED;
                    log.warn("Blert websocket {} rejected: unsupported version", webSocket);
                    onDisconnect(DisconnectReason.UNSUPPORTED_VERSION);
                    break;
                case 401:
                    state = State.REJECTED;
                    log.warn("Blert websocket {} rejected: (unauthorized)", webSocket);
                    onDisconnect(DisconnectReason.ERROR);
                    break;
                default:
                    log.error("Blert websocket {} failed: {}", webSocket, response, t);
                    if (previousState == State.OPEN || previousState == State.CONNECTING) {
                        onDisconnect(DisconnectReason.ERROR);
                    }
                    break;
            }
        } else {
            log.error("Blert websocket {} failed", webSocket, t);
            if (previousState == State.OPEN || previousState == State.CONNECTING) {
                onDisconnect(DisconnectReason.ERROR);
            }
        }
    }

    public Future<Void> close() {
        if (socket != null) {
            CompletableFuture<Void> future = new CompletableFuture<>();
            closeFutures.add(future);
            socket.close(1000, null);
            state = State.CLOSING;
            return future;
        }

        return CompletableFuture.completedFuture(null);
    }

    private void onDisconnect(DisconnectReason reason) {
        if (this.disconnectCallback != null) {
            this.disconnectCallback.accept(reason);
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.client;

import io.blert.BlertPlugin;
import io.blert.BlertPluginPanel;
import io.blert.core.Challenge;
import io.blert.core.ChallengeMode;
import io.blert.core.RecordableChallenge;
import io.blert.core.Stage;
import io.blert.events.*;
import io.blert.events.Event;
import io.blert.json.*;
import joptsimple.internal.Strings;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.GameState;
import net.runelite.client.callback.ClientThread;
import org.apache.commons.lang3.NotImplementedException;
import org.apache.commons.lang3.time.DurationFormatUtils;

import javax.annotation.Nullable;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

/**
 * An {@code EventHandler} implementation that transmits received events to a Blert server through a websocket.
 */
@Slf4j
public class WebSocketEventHandler implements EventHandler {
    public enum Status {
        IDLE,
        CHALLENGE_STARTING,
        CHALLENGE_ACTIVE,
        CHALLENGE_ENDING,
    }

    /**
     * Tracks the state of a challenge start request, including any events that need to be queued
     * until the server responds with a challenge ID.
     */
    @AllArgsConstructor(access = lombok.AccessLevel.PRIVATE)
    private static class ChallengeStartAttempt {
        private static final int INITIAL_RETRIES = 3;

        final int currentRequestId;
        final ChallengeStartRequest request;
        final Challenge challenge;
        final int remainingRetries;

        // Queue of events received during CHALLENGE_STARTING, before the challenge ID is known.
        final List<QueuedEvent> queuedEvents;

        // If the challenge ends before the start response arrives, store the end event here.
        @Nullable
        ChallengeEndEvent pendingEndEvent;

        ChallengeStartAttempt(int requestId, ChallengeStartRequest request, Challenge challenge) {
            this(requestId, request, challenge, INITIAL_RETRIES, new ArrayList<>(), null);
        }

        /**
         * Creates a new retry attempt with the same request and queued events but a new request ID
         * and decremented retry count.
         */
        ChallengeStartAttempt retry(int newRequestId) {
            return new ChallengeStartAttempt(
                    newRequestId,
                    request,
                    challenge,
                    remainingRetries - 1,
                    queuedEvents,
                    pendingEndEvent
            );
        }

        boolean canRetry() {
            return remainingRetries > 0;
        }

        /**
         * Returns the timeout duration for this attempt, using linear backoff.
         * Initial attempt: 5s, then 10s, 15s for subsequent retries.
         */
        int getTimeoutMs() {
            return (INITIAL_RETRIES - remainingRetries + 1) * DEFAULT_REQUEST_TIMEOUT_MS;
        }
    }

    /**
     * An event that was received during CHALLENGE_STARTING and needs to be processed once the
     * challenge ID is known.
     */
    @AllArgsConstructor
    private static class QueuedEvent {
        final int clientTick;
        final Event event;
    }

    private static final int DEFAULT_REQUEST_TIMEOUT_MS = 5000;

    private final BlertPlugin plugin;
    private final WebSocketClient webSocketClient;
    private final EventBuffer eventBuffer;
    private final Client runeliteClient;
    private final ClientThread runeliteThread;

    private int nextRequestId = 1;
    private int lastRequestId = -1;
    private final Timer requestTimeout = new Timer();
    private Status status = Status.IDLE;

    private Challenge currentChallenge = null;
    private @Nullable String challengeId = null;
    private @Nullable ChallengeStartAttempt currentStartAttempt = null;
    private Instant serverShutdownTime = null;
    private boolean apiKeyUsernameMismatch = false;

    private int currentTick = 0;

    /**
     * Constructs an event handler which will send and receive events over the provided websocket client.
     *
     * @param webSocketClient Websocket client connected and authenticated to the Blert server.
     */
    public WebSocketEventHandler(BlertPlugin plugin, WebSocketClient webSocketClient,
                                 Client client, ClientThread runeliteThread) {
        this.plugin = plugin;
        this.webSocketClient = webSocketClient;
        this.webSocketClient.setTextMessageCallback(this::handleJsonMessage);
        this.webSocketClient.setDisconnectCallback(this::handleDisconnect);
        this.eventBuffer = new EventBuffer();
        this.runeliteClient = client;
        this.runeliteThread = runeliteThread;
    }

    @Override
    public void handleEvent(int clientTick, Event event) {
        switch (event.getType()) {
            case CHALLENGE_START:
                // Starting a new challenge. Discard any buffered events and abandon any
                // pending start attempt.
                eventBuffer.flushEventsUpTo(clientTick);
                if (currentStartAttempt != null) {
                    log.warn("Abandoning previous challenge start attempt due to new challenge");
                    abandonChallengeStart();
                }
                startChallenge((ChallengeStartEvent) event);
                break;

            case CHALLENGE_END:
                // If we're still waiting for a challenge start response, queue the end event.
                if (currentStartAttempt != null) {
                    log.debug("Queueing challenge end event until start response is received");
                    currentStartAttempt.pendingEndEvent = (ChallengeEndEvent) event;
                    break;
                }

                // Flush any pending events, then indicate that the challenge has ended.
                if (eventBuffer.hasEvents()) {
                    sendEvents(eventBuffer.flushEventsUpTo(clientTick));
                }
                endChallenge((ChallengeEndEvent) event);
                break;

            case CHALLENGE_UPDATE:
                // Queue if waiting for challenge start response.
                if (currentStartAttempt != null) {
                    currentStartAttempt.queuedEvents.add(new QueuedEvent(clientTick, event));
                    break;
                }
                updateChallenge((ChallengeUpdateEvent) event, null);
                break;

            case STAGE_UPDATE:
                // Queue if waiting for challenge start response.
                if (currentStartAttempt != null) {
                    currentStartAttempt.queuedEvents.add(new QueuedEvent(clientTick, event));
                    break;
                }

                // Flush any pending events prior to updating the stage.
                if (eventBuffer.hasEvents()) {
                    sendEvents(eventBuffer.flushEventsUpTo(clientTick));
                }
                updateChallenge(null, (StageUpdateEvent) event);
                break;

            default:
                // Forward other events to the event buffer to be serialized and sent to the server.
                eventBuffer.handleEvent(clientTick, event);

                // Only send events if we have an active challenge ID.
                // During CHALLENGE_STARTING, events are buffered until the ID is received.
                if (status == Status.CHALLENGE_ACTIVE && currentStartAttempt == null) {
                    if (currentTick != clientTick) {
                        // Events are collected and sent in a single batch at the end of a tick.
                        sendEvents(eventBuffer.flushEventsUpTo(clientTick));
                    }
                }

                break;
        }

        currentTick = clientTick;
    }

    private void startChallenge(ChallengeStartEvent event) {
        if (pendingServerShutdown()) {
            sendGameMessage(
                    "<col=ef1020>This challenge will not be recorded due to scheduled Blert maintenance.</col>"
            );
            return;
        }

        if (apiKeyUsernameMismatch) {
            sendGameMessage(
                    "<col=ef1020>This challenge will not be recorded as this API key is linked to a different OSRS account. " +
                            "If you changed your display name, please update it on the Blert website.</col>"
            );
            return;
        }

        if (event.getMode() == ChallengeMode.TOB_ENTRY) {
            log.warn("Recording of Theatre of Blood entry raids is disabled");
            return;
        }

        if (!webSocketClient.isOpen()) {
            return;
        }

        ChallengeStartRequest challengeStartRequest = new ChallengeStartRequest();
        challengeStartRequest.challenge = event.getChallenge().getId();
        challengeStartRequest.mode = event.getMode().getId();
        challengeStartRequest.party = new ArrayList<>(event.getParty());
        challengeStartRequest.spectator = event.isSpectator();
        event.getStage().map(Stage::getId).ifPresent(s -> challengeStartRequest.stage = s);

        // Create a new attempt to track the challenge start request and queued events.
        currentStartAttempt = new ChallengeStartAttempt(
                getRequestId(), challengeStartRequest, event.getChallenge());
        this.currentChallenge = event.getChallenge();

        setStatus(Status.CHALLENGE_STARTING);
        sendChallengeStartRequest(currentStartAttempt);
    }

    /**
     * Sends a challenge start request to the server and schedules a timeout for retry.
     */
    private void sendChallengeStartRequest(ChallengeStartAttempt attempt) {
        ServerMessage message = new ServerMessage();
        message.type = ServerMessage.TYPE_CHALLENGE_START_REQUEST;
        message.requestId = attempt.currentRequestId;
        message.challengeStartRequest = attempt.request;

        lastRequestId = attempt.currentRequestId;
        webSocketClient.sendTextMessage(plugin.getGson().toJson(message));

        // Schedule timeout with linear backoff.
        requestTimeout.schedule(new TimerTask() {
            @Override
            public void run() {
                handleChallengeStartTimeout(attempt);
            }
        }, attempt.getTimeoutMs());
    }

    /**
     * Handles a timeout for a challenge start request. Retries if possible, otherwise abandons.
     */
    private void handleChallengeStartTimeout(ChallengeStartAttempt attempt) {
        // Verify this is still the current attempt and we're still waiting for a response.
        if (currentStartAttempt != attempt || status != Status.CHALLENGE_STARTING) {
            return;
        }

        if (attempt.canRetry()) {
            ChallengeStartAttempt retryAttempt = attempt.retry(getRequestId());
            currentStartAttempt = retryAttempt;
            log.warn("Challenge start request timed out; retrying ({} retries remaining)",
                    retryAttempt.remainingRetries);
            sendChallengeStartRequest(retryAttempt);
        } else {
            log.error("Challenge start request failed after all retries");
            abandonChallengeStart();
        }
    }

    /**
     * Abandons any pending challenge start attempt, clearing state and returning to IDLE.
     */
    private void abandonChallengeStart() {
        currentStartAttempt = null;
        currentChallenge = null;
        setStatus(Status.IDLE);
    }

    void endChallenge(ChallengeEndEvent event) {
        if (challengeId == null) {
            log.warn("Attempted to end challenge without an active challenge ID");
            return;
        }

        int requestId = getRequestId();

        ServerMessage message = new ServerMessage();
        message.type = ServerMessage.TYPE_CHALLENGE_END_REQUEST;
        message.requestId = requestId;
        message.activeChallengeId = challengeId;
        message.challengeEndRequest = new io.blert.json.ChallengeEndRequest();
        message.challengeEndRequest.challengeTimeTicks = event.getChallengeTime();
        message.challengeEndRequest.overallTimeTicks = event.getOverallTime();

        lastRequestId = requestId;

        setStatus(Status.CHALLENGE_ENDING);
        webSocketClient.sendTextMessage(plugin.getGson().toJson(message));

        requestTimeout.schedule(new TimerTask() {
            @Override
            public void run() {
                if (status == Status.CHALLENGE_ENDING && lastRequestId == requestId) {
                    resetChallenge();
                }
            }
        }, DEFAULT_REQUEST_TIMEOUT_MS);
    }

    void updateChallenge(@Nullable ChallengeUpdateEvent challenge, @Nullable StageUpdateEvent stage) {
        if (challengeId == null) {
            log.warn("Attempted to update challenge without an active challenge ID");
            return;
        }

        ChallengeUpdate challengeUpdate = new ChallengeUpdate();

        if (challenge != null) {
            challengeUpdate.mode = challenge.getMode().getId();
        }

        if (stage != null) {
            if (stage.getStage().isEmpty()) {
                log.error("Attempted to update stage without a stage value set");
                return;
            }

            ChallengeUpdate.StageUpdate stageUpdate = new ChallengeUpdate.StageUpdate();
            stageUpdate.stage = stage.getStage().get().getId();
            stageUpdate.status = translateStageStatus(stage.getStatus());
            stageUpdate.accurate = stage.isAccurate();
            stageUpdate.recordedTicks = stage.getTick();
            stageUpdate.gameTicksPrecise = stage.isGameTicksPrecise();
            stage.getInGameTicks().ifPresent(t -> stageUpdate.gameServerTicks = t);
            challengeUpdate.stageUpdate = stageUpdate;
        }

        ServerMessage message = new ServerMessage();
        message.activeChallengeId = challengeId;
        message.type = ServerMessage.TYPE_CHALLENGE_UPDATE;
        message.challengeUpdate = challengeUpdate;

        webSocketClient.sendTextMessage(plugin.getGson().toJson(message));
    }

    public void updateGameState(GameState gameState) {
        int state;
        if (gameState == GameState.LOGGED_IN) {
            state = io.blert.json.GameState.STATE_LOGGED_IN;
        } else if (gameState == GameState.LOGIN_SCREEN) {
            state = io.blert.json.GameState.STATE_LOGGED_OUT;
        } else {
            return;
        }

        io.blert.json.GameState gameStateJson = new io.blert.json.GameState();
        gameStateJson.state = state;

        if (gameState == GameState.LOGGED_IN) {
            Player localPlayer = runeliteClient.getLocalPlayer();
            if (localPlayer == null || localPlayer.getName() == null) {
                return;
            }

            io.blert.json.GameState.PlayerInfo playerInfo = new io.blert.json.GameState.PlayerInfo();
            playerInfo.username = localPlayer.getName();
            playerInfo.accountHash = Long.toString(runeliteClient.getAccountHash());
            playerInfo.overallExperience = runeliteClient.getOverallExperience();
            playerInfo.attackExperience = runeliteClient.getSkillExperience(Skill.ATTACK);
            playerInfo.defenceExperience = runeliteClient.getSkillExperience(Skill.DEFENCE);
            playerInfo.strengthExperience = runeliteClient.getSkillExperience(Skill.STRENGTH);
            playerInfo.hitpointsExperience = runeliteClient.getSkillExperience(Skill.HITPOINTS);
            playerInfo.rangedExperience = runeliteClient.getSkillExperience(Skill.RANGED);
            playerInfo.prayerExperience = runeliteClient.getSkillExperience(Skill.PRAYER);
            playerInfo.magicExperience = runeliteClient.getSkillExperience(Skill.MAGIC);
            gameStateJson.playerInfo = playerInfo;
        }

        ServerMessage message = new ServerMessage();
        message.type = ServerMessage.TYPE_GAME_STATE;
        message.gameState = gameStateJson;
        webSocketClient.sendTextMessage(plugin.getGson().toJson(message));

        apiKeyUsernameMismatch = false;
    }

    private void handleJsonMessage(String messageText) {
        ServerMessage serverMessage;
        try {
            serverMessage = plugin.getGson().fromJson(messageText, ServerMessage.class);
        } catch (Exception e) {
            log.error("Failed to parse JSON message", e);
            return;
        }

        switch (serverMessage.type) {
            case ServerMessage.TYPE_PING:
                sendPong();
                log.debug("Received heartbeat ping from server; responding with pong");
                break;

            case ServerMessage.TYPE_ERROR:
                handleServerError(serverMessage);
                break;

            case ServerMessage.TYPE_CONNECTION_RESPONSE:
                serverShutdownTime = null;
                plugin.getSidePanel().setShutdownTime(null);

                if (serverMessage.user != null) {
                    plugin.getSidePanel().updateConnectionState(
                            BlertPluginPanel.ConnectionState.CONNECTED,
                            serverMessage.user.name
                    );
                    sendRaidHistoryRequest();
                } else {
                    log.warn("Received invalid connection response from server");
                    closeWebsocketClient();
                }
                break;

            case ServerMessage.TYPE_HISTORY_RESPONSE:
                plugin.getSidePanel().setRecentRecordings(serverMessage.recentRecordings);
                break;

            case ServerMessage.TYPE_CHALLENGE_START_RESPONSE:
                handleChallengeStartResponse(serverMessage);
                break;

            case ServerMessage.TYPE_CHALLENGE_END_RESPONSE:
                if (status != Status.CHALLENGE_ENDING || serverMessage.requestId == null ||
                        serverMessage.requestId != lastRequestId) {
                    log.warn("Received unexpected CHALLENGE_END_RESPONSE from server");
                    return;
                }
                resetChallenge();
                // TODO Make proper fix https://github.com/blert-io/plugin/issues/9
                // delaying raid history request to allow backend update last challenge
                requestTimeout.schedule(new TimerTask() {
                    @Override
                    public void run() {
                        sendRaidHistoryRequest();
                    }
                }, DEFAULT_REQUEST_TIMEOUT_MS);

                break;

            case ServerMessage.TYPE_SERVER_STATUS: {
                var serverStatus = serverMessage.serverStatus;
                if (serverStatus != null) {
                    handleServerStatus(serverStatus);
                }
                break;
            }

            case ServerMessage.TYPE_PLAYER_STATE:
                break;

            case ServerMessage.TYPE_GAME_STATE_REQUEST:
                updateGameState(runeliteClient.getGameState());
                break;

            case ServerMessage.TYPE_ATTACK_DEFINITIONS:
                if (serverMessage.attackDefinitions != null) {
                    plugin.getAttackRegistry().updateFromServer(
                            serverMessage.attackDefinitions.stream()
                                    .map(io.blert.json.AttackDefinition::toCore)
                                    .collect(Collectors.toList())
                    );
                }
                break;

            case ServerMessage.TYPE_SPELL_DEFINITIONS:
                if (serverMessage.spellDefinitions != null) {
                    plugin.getSpellRegistry().updateFromServer(
                            serverMessage.spellDefinitions.stream()
                                    .map(io.blert.json.SpellDefinition::toCore)
                                    .collect(Collectors.toList())
                    );
                }
                break;

            case ServerMessage.TYPE_CHALLENGE_STATE_CONFIRMATION:
                handleChallengeStateConfirmation(serverMessage);
                break;

            case ServerMessage.TYPE_PONG:
            case ServerMessage.TYPE_HISTORY_REQUEST:
            case ServerMessage.TYPE_EVENT_STREAM:
            case ServerMessage.TYPE_GAME_STATE:
                log.warn("Received unexpected message from server: type={}", serverMessage.type);
                break;

            default:
                log.warn("Received unrecognized message from server: type={}", serverMessage.type);
                break;
        }
    }

    private synchronized void handleServerError(ServerMessage message) {
        ErrorData error = message.error;
        if (error == null) {
            return;
        }

        switch (error.type) {
            case ErrorData.TYPE_BAD_REQUEST:
                // TODO(frolv): Implement.
                break;

            case ErrorData.TYPE_UNIMPLEMENTED:
                // TODO(frolv): Implement.
                break;

            case ErrorData.TYPE_USERNAME_MISMATCH:
                sendGameMessage(
                        ChatMessageType.GAMEMESSAGE,
                        "<col=ef1020>This Blert API key is linked to the OSRS account " + error.username +
                                ". If you changed your display name, please go update it on the Blert website.</col>");
                apiKeyUsernameMismatch = true;
                // Abandon any pending challenge start since this account can't record.
                if (currentStartAttempt != null) {
                    abandonChallengeStart();
                }
                break;

            case ErrorData.TYPE_UNAUTHENTICATED:
                log.info("Disconnected from server due to authentication failure");
                closeWebsocketClient();
                break;

            case ErrorData.TYPE_CHALLENGE_RECORDING_ENDED:
                if (challengeId == null || !challengeId.equals(message.activeChallengeId)) {
                    break;
                }

                if (status == Status.CHALLENGE_STARTING || status == Status.CHALLENGE_ACTIVE) {
                    log.error("Server ended recording for challenge {}", challengeId);
                    resetChallenge();
                }
                break;

            case ErrorData.TYPE_UNKNOWN:
            default:
                log.error("Received unrecognized server error type={}", error.type);
                break;
        }
    }

    private void handleChallengeStartResponse(ServerMessage serverMessage) {
        if (status != Status.CHALLENGE_STARTING ||
                serverMessage.requestId == null ||
                serverMessage.requestId != lastRequestId) {
            log.warn("Received unexpected CHALLENGE_START_RESPONSE from server");
            return;
        }

        if (Strings.isNullOrEmpty(serverMessage.activeChallengeId)) {
            log.error("Failed to start challenge");
            eventBuffer.setChallengeId(null);
            currentChallenge = null;
            challengeId = null;
            currentStartAttempt = null;
            setStatus(Status.IDLE);

            if (serverMessage.error != null && serverMessage.error.message != null) {
                sendGameMessage(ChatMessageType.GAMEMESSAGE, "<col=ef1020>[Blert] " + serverMessage.error.message + "</col>");
            }
            return;
        }

        challengeId = serverMessage.activeChallengeId;

        // Stamp all buffered events with the challenge ID.
        eventBuffer.setChallengeId(challengeId);

        // Capture and clear the start attempt before processing queued events.
        ChallengeStartAttempt attempt = currentStartAttempt;
        currentStartAttempt = null;

        setStatus(Status.CHALLENGE_ACTIVE);

        // Flush any buffered events (now that they have the challenge ID).
        if (eventBuffer.hasEvents()) {
            sendEvents(eventBuffer.flushEventsUpTo(currentTick));
        }

        // Process any queued STAGE_UPDATE and CHALLENGE_UPDATE events.
        if (attempt != null) {
            for (QueuedEvent qe : attempt.queuedEvents) {
                switch (qe.event.getType()) {
                    case STAGE_UPDATE:
                        updateChallenge(null, (StageUpdateEvent) qe.event);
                        break;
                    case CHALLENGE_UPDATE:
                        updateChallenge((ChallengeUpdateEvent) qe.event, null);
                        break;
                    default:
                        // Other event types were already buffered in eventBuffer.
                        break;
                }
            }

            // If the challenge ended while waiting for the start response, process it now.
            if (attempt.pendingEndEvent != null) {
                log.debug("Processing queued challenge end event");
                if (eventBuffer.hasEvents()) {
                    sendEvents(eventBuffer.flushEventsUpTo(currentTick));
                }
                endChallenge(attempt.pendingEndEvent);
            }
        }
    }

    private void handleServerStatus(@NonNull ServerStatus serverStatus) {
        switch (serverStatus.status) {
            case ServerStatus.STATUS_SHUTDOWN_PENDING: {
                if (serverStatus.shutdownTime != null) {
                    serverShutdownTime = Instant.ofEpochSecond(
                            serverStatus.shutdownTime.seconds,
                            serverStatus.shutdownTime.nanos
                    );
                    Duration timeUntilShutdown = Duration.between(Instant.now(), serverShutdownTime);
                    plugin.getSidePanel().setShutdownTime(serverShutdownTime);

                    String shutdownMessage = String.format(
                            "Blert's servers will go offline for maintenance in %s." +
                                    "<br>Visit Blert's Discord server for status updates.",
                            DurationFormatUtils.formatDuration(timeUntilShutdown.toMillis(), "HH:mm:ss")
                    );

                    sendGameMessage(ChatMessageType.BROADCAST, shutdownMessage);
                }
                break;
            }

            case ServerStatus.STATUS_SHUTDOWN_IMMINENT: {
                reset();
                eventBuffer.flushEventsUpTo(currentTick);
                closeWebsocketClient();
                break;
            }

            case ServerStatus.STATUS_SHUTDOWN_CANCELED: {
                serverShutdownTime = null;
                plugin.getSidePanel().setShutdownTime(null);
                sendGameMessage(
                        ChatMessageType.BROADCAST,
                        "The scheduled Blert maintenance has been canceled. You may continue to record PvM challenges!"
                );
                break;
            }

            default:
                break;
        }
    }

    private void handleDisconnect(WebSocketClient.DisconnectReason reason) {
        resetChallenge();

        BlertPluginPanel.ConnectionState connectionState;
        switch (reason) {
            case UNSUPPORTED_VERSION:
                connectionState = BlertPluginPanel.ConnectionState.UNSUPPORTED_VERSION;
                break;
            case ERROR:
                if (webSocketClient.getState() == WebSocketClient.State.REJECTED) {
                    connectionState = BlertPluginPanel.ConnectionState.REJECTED;
                } else {
                    connectionState = BlertPluginPanel.ConnectionState.DISCONNECTED;
                }
                break;
            case CLOSED_SUCCESSFULLY:
            default:
                connectionState = BlertPluginPanel.ConnectionState.DISCONNECTED;
                break;
        }

        plugin.getSidePanel().updateConnectionState(connectionState, null);
        plugin.getSidePanel().setRecentRecordings(null);
    }

    private void sendEvents(List<io.blert.json.Event> events) {
        if (!webSocketClient.isOpen() || events.isEmpty()) {
            return;
        }

        ServerMessage message = new ServerMessage();
        message.type = ServerMessage.TYPE_EVENT_STREAM;
        message.activeChallengeId = events.get(0).challengeId;
        message.challengeEvents = new ArrayList<>();

        int ignoredEvents = 0;

        for (io.blert.json.Event event : events) {
            if (Strings.isNullOrEmpty(event.challengeId)) {
                ignoredEvents++;
                continue;
            }

            if (!event.challengeId.equals(message.activeChallengeId)) {
                if (!message.challengeEvents.isEmpty()) {
                    webSocketClient.sendTextMessage(plugin.getGson().toJson(message));
                }

                message = new ServerMessage();
                message.type = ServerMessage.TYPE_EVENT_STREAM;
                message.activeChallengeId = event.challengeId;
                message.challengeEvents = new ArrayList<>();
            }

            // Clear the challengeId from individual events since it's set at the message level.
            event.challengeId = null;
            message.challengeEvents.add(event);
        }

        if (!message.challengeEvents.isEmpty()) {
            webSocketClient.sendTextMessage(plugin.getGson().toJson(message));
        }

        if (ignoredEvents > 0) {
            log.debug("Ignored {} events without a challenge ID", ignoredEvents);
        }
    }

    private void sendPong() {
        ServerMessage message = new ServerMessage();
        message.type = ServerMessage.TYPE_PONG;
        webSocketClient.sendTextMessage(plugin.getGson().toJson(message));
    }

    private void sendRaidHistoryRequest() {
        if (webSocketClient.isOpen()) {
            ServerMessage message = new ServerMessage();
            message.type = ServerMessage.TYPE_HISTORY_REQUEST;
            webSocketClient.sendTextMessage(plugin.getGson().toJson(message));
        }
    }

    private void resetChallenge() {
        currentChallenge = null;
        challengeId = null;
        currentStartAttempt = null;
        eventBuffer.setChallengeId(null);
        setStatus(Status.IDLE);
    }

    private void reset() {
        resetChallenge();
        plugin.getSidePanel().updateConnectionState(BlertPluginPanel.ConnectionState.DISCONNECTED, null);
        plugin.getSidePanel().setRecentRecordings(null);
    }

    public void shutdown() {
        requestTimeout.cancel();
    }

    private void setStatus(Status status) {
        this.status = status;
        plugin.getSidePanel().updateChallengeStatus(status, currentChallenge, challengeId);
    }

    private boolean pendingServerShutdown() {
        return serverShutdownTime != null;
    }

    private void sendGameMessage(String message) {
        sendGameMessage(ChatMessageType.GAMEMESSAGE, message);
    }

    private void sendGameMessage(ChatMessageType type, String message) {
        runeliteThread.invoke(() -> {
            if (runeliteClient.getGameState() == GameState.LOGGED_IN) {
                runeliteClient.addChatMessage(type, "", message, null);
            }
        });
    }

    private void closeWebsocketClient() {
        plugin.getSidePanel().setShutdownTime(null);
        webSocketClient.close();
    }

    private void handleChallengeStateConfirmation(ServerMessage message) {
        ChallengeStateConfirmation stateToConfirm = message.challengeStateConfirmation;
        if (stateToConfirm == null) {
            return;
        }

        Player player = runeliteClient.getLocalPlayer();
        if (player == null) {
            return;
        }

        if (Strings.isNullOrEmpty(message.activeChallengeId)) {
            log.warn("Received confirmation request with empty challenge ID");
            return;
        }

        String username = player.getName() != null ? player.getName().toLowerCase() : null;
        if (!Objects.equals(stateToConfirm.username, username)) {
            log.warn("Received confirmation request for {} but current player is {}",
                    stateToConfirm.username, username);
            return;
        }

        if (plugin.getActiveChallenge() == null) {
            ServerMessage response = new ServerMessage();
            response.type = ServerMessage.TYPE_CHALLENGE_STATE_CONFIRMATION;
            response.activeChallengeId = message.activeChallengeId;
            response.challengeStateConfirmation = new ChallengeStateConfirmation();
            response.challengeStateConfirmation.isValid = false;
            webSocketClient.sendTextMessage(plugin.getGson().toJson(response));
            return;
        }

        final WebSocketEventHandler self = this;

        // Getting the challenge status is a blocking operation, so run it in a separate thread.
        new Thread(() -> {
            ServerMessage response = new ServerMessage();
            response.type = ServerMessage.TYPE_CHALLENGE_STATE_CONFIRMATION;
            response.activeChallengeId = message.activeChallengeId;

            RecordableChallenge activeChallenge = plugin.getActiveChallenge();
            if (activeChallenge == null) {
                response.challengeStateConfirmation = new ChallengeStateConfirmation();
                response.challengeStateConfirmation.isValid = false;
                webSocketClient.sendTextMessage(plugin.getGson().toJson(response));
                return;
            }

            RecordableChallenge.Status status = null;

            try {
                status = activeChallenge.getStatus().get();
            } catch (InterruptedException | ExecutionException e) {
                log.error("Failed to get challenge status", e);
            }

            ChallengeStateConfirmation confirmationBuilder = new ChallengeStateConfirmation();
            confirmationBuilder.username = username;

            boolean isValid = false;

            if (status != null) {
                Set<String> party = status.getParty().stream().map(String::toLowerCase).collect(Collectors.toSet());
                Set<String> partyToConfirm = stateToConfirm.party != null
                        ? stateToConfirm.party.stream().map(String::toLowerCase).collect(Collectors.toSet())
                        : Collections.emptySet();

                isValid = status.getChallenge().getId() == stateToConfirm.challenge &&
                        status.getStage() != null &&
                        status.getStage().getId() >= stateToConfirm.stage &&
                        party.equals(partyToConfirm);

                if (!party.contains(username)) {
                    confirmationBuilder.spectator = true;
                }
            }

            confirmationBuilder.isValid = isValid;
            response.challengeStateConfirmation = confirmationBuilder;

            synchronized (self) {
                self.webSocketClient.sendTextMessage(plugin.getGson().toJson(response));

                if (isValid) {
                    self.challengeId = message.activeChallengeId;
                    self.eventBuffer.setChallengeId(self.challengeId);
                    self.setStatus(Status.CHALLENGE_ACTIVE);
                    log.debug("Confirmed challenge state; rejoining challenge {}", self.challengeId);
                }

            }
        }).start();
    }

    private int getRequestId() {
        int id = nextRequestId;
        if (nextRequestId == Integer.MAX_VALUE) {
            nextRequestId = 1;
        } else {
            nextRequestId++;
        }
        return id;
    }

    private static int translateStageStatus(StageUpdateEvent.Status status) {
        switch (status) {
            case ENTERED:
                return ChallengeUpdate.StageUpdate.STATUS_ENTERED;
            case STARTED:
                return ChallengeUpdate.StageUpdate.STATUS_STARTED;
            case COMPLETED:
                return ChallengeUpdate.StageUpdate.STATUS_COMPLETED;
            case WIPED:
                return ChallengeUpdate.StageUpdate.STATUS_WIPED;
            default:
                throw new NotImplementedException("Stage status translation not implemented for " + status);
        }
    }
}
/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.client;

import io.blert.BlertConfig;
import io.blert.BlertPlugin;
import io.blert.BlertPluginPanel;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.events.ConfigChanged;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Named;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;

@Slf4j
public class WebSocketManager {
    public static final String DEFAULT_BLERT_HOST = "https://blert.io";
    public static final String DEFAULT_SERVER_HOST = "wss://wave32.blert.io";

    @Inject
    private BlertPlugin plugin;

    @Inject
    private BlertConfig config;

    @Inject
    private OkHttpClient httpClient;

    @Inject
    private Client runeliteClient;

    @Inject
    private ClientThread runeLiteClientThread;

    @Inject
    @Named("developerMode")
    boolean developerMode;

    @Getter(AccessLevel.MODULE)
    private WebSocketClient wsClient;
    @Getter
    private WebSocketEventHandler eventHandler;

    public Future<Boolean> open() {
        if (config.apiKey() == null) {
            return CompletableFuture.completedFuture(false);
        }

        initializeWebSocketClient();
        return wsClient.open();
    }

    public boolean shouldTryToConnect() {
        if (wsClient == null) {
            return true;
        }

        return wsClient.getState() == WebSocketClient.State.CLOSED;
    }

    public Future<Void> close() {
        if (eventHandler != null) {
            eventHandler.shutdown();
        }

        if (wsClient != null && wsClient.isOpen()) {
            var result = wsClient.close();
            wsClient = null;
            return result;
        }

        return CompletableFuture.completedFuture(null);
    }

    private void initializeWebSocketClient() {
        if (eventHandler != null) {
            eventHandler.shutdown();
        }

        if (wsClient != null) {
            if (plugin != null && plugin.getSidePanel() != null) {
                plugin.getSidePanel().updateConnectionState(BlertPluginPanel.ConnectionState.DISCONNECTED, null);
            }

            if (wsClient.isOpen()) {
                wsClient.close();
            }

            wsClient = null;
        }

        if (config.apiKey() == null) {
            return;
        }

        String runeliteVersion = String.format(
                "runelite-%s%s", RuneLiteProperties.getVersion(), developerMode ? "-dev" : "");
        wsClient = new WebSocketClient(DEFAULT_SERVER_HOST, config.apiKey(), runeliteVersion, httpClient);
        eventHandler = new WebSocketEventHandler(plugin, wsClient, runeliteClient, runeLiteClientThread);

        if (plugin.getActiveChallenge() != null) {
            plugin.getActiveChallenge().setEventHandler(eventHandler);
        }
    }

    public void onConfigChanged(ConfigChanged changed) {
        if (!changed.getGroup().equals("blert")) {
            return;
        }

        String key = changed.getKey();
        if (key.equals("apiKey")) {
            new Thread(() -> {
                plugin.getSidePanel().updateConnectionState(BlertPluginPanel.ConnectionState.DISCONNECTED, null);
                try {
                    open().get(10, java.util.concurrent.TimeUnit.SECONDS);
                } catch (Exception e) {
                    log.error("Failed to open WebSocket connection after API key change", e);
                }
            }).start();
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert;

import io.blert.client.WebSocketEventHandler;
import io.blert.client.WebSocketManager;
import io.blert.core.Challenge;
import io.blert.core.ChallengeMode;
import io.blert.core.Stage;
import io.blert.json.PastChallenge;
import joptsimple.internal.Strings;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;
import org.apache.commons.lang3.time.DurationFormatUtils;
import org.apache.commons.lang3.tuple.Pair;

import javax.annotation.Nullable;
import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.datatransfer.StringSelection;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class BlertPluginPanel extends PluginPanel {
    /**
     * Tracks the websocket connection state for UI display purposes.
     */
    public enum ConnectionState {
        /**
         * Not connected to the server.
         */
        DISCONNECTED,
        /**
         * Currently attempting to connect.
         */
        CONNECTING,
        /**
         * Successfully connected and authenticated.
         */
        CONNECTED,
        /**
         * Connection was rejected (invalid API key).
         */
        REJECTED,
        /**
         * Connection was rejected due to outdated plugin version.
         */
        UNSUPPORTED_VERSION,
    }

    private final BlertConfig config;
    private final WebSocketManager websocketManager;

    private JPanel userPanel;
    private JPanel challengeStatusPanel;
    private JPanel recentRecordingsPanel;
    private JPanel recentRecordingsContainer;

    private final JLabel activeChallengeLabel = new JLabel();
    private final JLabel serverStatusLabel = new JLabel();
    private final JLabel connectionStatusLabel = new JLabel();
    private final Timer shutdownLabelTimer;

    private final List<PastChallenge> recentRecordings = new ArrayList<>();

    private WebSocketEventHandler.Status challengeStatus = WebSocketEventHandler.Status.IDLE;
    private ConnectionState connectionState = ConnectionState.DISCONNECTED;
    private @Nullable String connectedUsername = null;
    private Instant shutdownTime = null;

    public BlertPluginPanel(BlertConfig config, WebSocketManager websocketManager) {
        this.config = config;
        this.websocketManager = websocketManager;

        shutdownLabelTimer = new Timer(1000, e -> {
            if (shutdownTime == null) {
                serverStatusLabel.setForeground(Color.GREEN);
                serverStatusLabel.setText("Blert server is online.");
                return;
            }

            Duration timeUntilShutdown = Duration.between(Instant.now(), shutdownTime);
            if (timeUntilShutdown.isNegative()) {
                serverStatusLabel.setText("Server shutting down...");
                serverStatusLabel.setForeground(Color.RED);
            } else {
                String time = DurationFormatUtils.formatDuration(timeUntilShutdown.toMillis(), "HH:mm:ss");
                serverStatusLabel.setForeground(Color.YELLOW);
                serverStatusLabel.setText("Server shutting down in " + time + ".");
            }
        });

        activeChallengeLabel.setHorizontalAlignment(SwingConstants.CENTER);
        serverStatusLabel.setHorizontalAlignment(SwingConstants.CENTER);
        serverStatusLabel.setBorder(new EmptyBorder(0, 0, 5, 0));
        connectionStatusLabel.setHorizontalAlignment(SwingConstants.CENTER);
    }

    public void startPanel() {
        setBorder(new EmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());
        setFocusable(false);

        rebuildUserPanel();
        createChallengeStatusPanel(this, null, null);
        createRecentRecordingsPanel(this);
        populateRecentRecordingsPanel();

        shutdownLabelTimer.start();
    }

    public void stopPanel() {
        shutdownLabelTimer.stop();
    }

    /**
     * Updates the connection state displayed in the panel.
     *
     * @param state    The new connection state.
     * @param username The username if connected, or null otherwise.
     */
    public void updateConnectionState(ConnectionState state, @Nullable String username) {
        SwingUtilities.invokeLater(() -> {
            synchronized (this) {
                this.connectionState = state;
                this.connectedUsername = username;
                rebuildUserPanel();
                revalidate();
                repaint();
            }
        });
    }

    public void updateChallengeStatus(
            WebSocketEventHandler.Status status,
            @Nullable Challenge challenge,
            @Nullable String challengeId
    ) {
        SwingUtilities.invokeLater(() -> {
            synchronized (this) {
                this.challengeStatus = status;
                createChallengeStatusPanel(this, challenge, challengeId);
                revalidate();
                repaint();
            }
        });
    }

    public void setRecentRecordings(@Nullable List<PastChallenge> recentRecordings) {
        SwingUtilities.invokeLater(() -> {
            synchronized (this) {
                this.recentRecordings.clear();
                if (recentRecordings != null) {
                    this.recentRecordings.addAll(recentRecordings);
                }
                populateRecentRecordingsPanel();
                revalidate();
                repaint();
            }
        });
    }

    public void setShutdownTime(@Nullable Instant shutdownTime) {
        SwingUtilities.invokeLater(() -> {
            synchronized (this) {
                this.shutdownTime = shutdownTime;
                if (challengeStatus == WebSocketEventHandler.Status.IDLE) {
                    setIdleActiveChallengeLabelText();
                }
            }
        });
    }

    /**
     * Rebuilds the user panel based on the current connection state.
     */
    private void rebuildUserPanel() {
        if (userPanel != null) {
            remove(userPanel);
        }

        userPanel = new JPanel();
        userPanel.setLayout(new BorderLayout());
        userPanel.setBorder(createSectionBorder());

        userPanel.add(createHeading("Server Status"), BorderLayout.NORTH);

        switch (connectionState) {
            case CONNECTED:
                connectionStatusLabel.setText(wrapHtml(
                        statusIndicator("green") + " Connected as: <b style=\"color: white\">" + connectedUsername + "</b>"));
                connectionStatusLabel.setForeground(Color.GREEN);
                userPanel.add(serverStatusLabel, BorderLayout.CENTER);
                userPanel.add(connectionStatusLabel, BorderLayout.SOUTH);
                break;

            case CONNECTING:
                connectionStatusLabel.setText(wrapHtml(statusIndicator("yellow") + " Connecting..."));
                connectionStatusLabel.setForeground(Color.YELLOW);
                userPanel.add(connectionStatusLabel, BorderLayout.CENTER);
                break;

            case REJECTED:
                connectionStatusLabel.setText(wrapHtml(
                        "<p style=\"text-align: center\">" + statusIndicator("red") + " Connection rejected.<br>" +
                                "Please check your API key in the plugin settings.</p>"));
                connectionStatusLabel.setForeground(Color.RED);
                userPanel.add(connectionStatusLabel, BorderLayout.CENTER);
                userPanel.add(createConnectButtonPanel(), BorderLayout.SOUTH);
                break;

            case UNSUPPORTED_VERSION:
                connectionStatusLabel.setText(wrapHtml(
                        "<p style=\"text-align: center\">" + statusIndicator("red") + " Connection rejected.<br>" +
                                "You are running an outdated version of Blert. " +
                                "Please restart RuneLite to update your plugin.</p>"));
                connectionStatusLabel.setForeground(Color.RED);
                userPanel.add(connectionStatusLabel, BorderLayout.CENTER);
                break;

            case DISCONNECTED:
            default:
                connectionStatusLabel.setText(wrapHtml(statusIndicator("red") + " Not connected."));
                connectionStatusLabel.setForeground(Color.RED);
                userPanel.add(connectionStatusLabel, BorderLayout.CENTER);

                if (Strings.isNullOrEmpty(config.apiKey())) {
                    JLabel apiKeyLabel = new JLabel(wrapHtml(
                            "<p style=\"text-align: center\">Enter your Blert API key in the plugin settings.</p>"));
                    apiKeyLabel.setForeground(Color.WHITE);
                    apiKeyLabel.setHorizontalAlignment(SwingConstants.CENTER);
                    userPanel.add(apiKeyLabel, BorderLayout.SOUTH);
                } else {
                    userPanel.add(createConnectButtonPanel(), BorderLayout.SOUTH);
                }
                break;
        }

        add(userPanel, BorderLayout.NORTH);
    }

    private @NonNull JPanel createConnectButtonPanel() {
        JPanel connectButtonPanel = new JPanel();
        connectButtonPanel.setLayout(new BorderLayout());
        connectButtonPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        JButton connectButton = new JButton("Connect");
        connectButton.addActionListener(e -> {
            // Update state to show connecting status
            updateConnectionState(ConnectionState.CONNECTING, null);

            SwingWorker<Boolean, Void> worker = new SwingWorker<>() {
                @Override
                protected Boolean doInBackground() {
                    try {
                        return websocketManager.open().get();
                    } catch (Exception e) {
                        log.error("Error connecting to Blert server", e);
                        return false;
                    }
                }

                @Override
                protected void done() {
                    try {
                        boolean success = get();
                        if (!success && connectionState == ConnectionState.CONNECTING) {
                            // Connection failed and no other state update came through.
                            updateConnectionState(ConnectionState.DISCONNECTED, null);
                        }
                    } catch (Exception e) {
                        log.error("Error getting connection result", e);
                        updateConnectionState(ConnectionState.DISCONNECTED, null);
                    }
                }
            };
            worker.execute();
        });
        connectButtonPanel.add(connectButton, BorderLayout.CENTER);
        return connectButtonPanel;
    }

    private void createChallengeStatusPanel(
            JPanel parent,
            @Nullable Challenge challenge,
            @Nullable String challengeId
    ) {
        if (challengeStatusPanel != null) {
            parent.remove(challengeStatusPanel);
        }

        challengeStatusPanel = new JPanel();
        challengeStatusPanel.setLayout(new BorderLayout());
        challengeStatusPanel.setBorder(createSectionBorder());

        JPanel currentStatePanel = createCurrentChallengeStatePanel();

        if (challengeStatus == WebSocketEventHandler.Status.CHALLENGE_ACTIVE && challenge != null) {
            JPanel actionsPanel = createChallengeActionsPanel(challenge, challengeId);
            challengeStatusPanel.add(actionsPanel, BorderLayout.SOUTH);
        }

        challengeStatusPanel.add(currentStatePanel, BorderLayout.CENTER);
        parent.add(challengeStatusPanel, BorderLayout.CENTER);
    }

    private void createRecentRecordingsPanel(JPanel parent) {
        if (recentRecordingsPanel != null) {
            parent.remove(recentRecordingsPanel);
        }

        recentRecordingsPanel = new JPanel();
        recentRecordingsPanel.setLayout(new BorderLayout());
        recentRecordingsPanel.setBorder(new EmptyBorder(10, 0, 10, 0));

        recentRecordingsPanel.add(createHeading("Previous Recordings"), BorderLayout.NORTH);

        recentRecordingsContainer = new JPanel();
        recentRecordingsContainer.setLayout(new BorderLayout());
        recentRecordingsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JScrollPane scrollPane = new JScrollPane(recentRecordingsContainer,
                JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
                JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setPreferredSize(new Dimension(0, 600));
        scrollPane.setBorder(new LineBorder(ColorScheme.BORDER_COLOR));
        recentRecordingsPanel.add(scrollPane, BorderLayout.CENTER);

        parent.add(recentRecordingsPanel, BorderLayout.SOUTH);
    }

    private void populateRecentRecordingsPanel() {
        if (recentRecordingsContainer == null) {
            return;
        }

        recentRecordingsContainer.removeAll();

        if (recentRecordings.isEmpty()) {
            JLabel noRecordingsLabel = new JLabel("No past recordings.");
            noRecordingsLabel.setBorder(new EmptyBorder(10, 0, 0, 0));
            noRecordingsLabel.setForeground(Color.GRAY);
            noRecordingsLabel.setHorizontalAlignment(SwingConstants.CENTER);
            recentRecordingsContainer.add(noRecordingsLabel, BorderLayout.NORTH);
        } else {
            JPanel recentRecordingsList = new JPanel();
            recentRecordingsList.setLayout(new GridBagLayout());
            recentRecordingsList.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            int index = 0;
            for (PastChallenge challenge : recentRecordings) {
                GridBagConstraints constraints = new GridBagConstraints();
                constraints.anchor = GridBagConstraints.FIRST_LINE_START;
                constraints.gridy = index;
                constraints.fill = GridBagConstraints.HORIZONTAL;
                constraints.weightx = 1.0;
                constraints.insets = new Insets(0, 0, 0, 6);
                recentRecordingsList.add(createPastChallengeEntry(challenge, index), constraints);
                index++;
            }

            recentRecordingsContainer.add(recentRecordingsList, BorderLayout.NORTH);
        }
    }

    @NonNull
    private JPanel createCurrentChallengeStatePanel() {
        JPanel currentStatePanel = new JPanel();
        currentStatePanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        currentStatePanel.setLayout(new BorderLayout());

        if (connectionState != ConnectionState.CONNECTED) {
            activeChallengeLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            activeChallengeLabel.setText(wrapHtml(
                    "<p style=\"text-align:center\">Connect to server to record challenges.</p>"));
        } else {
            switch (challengeStatus) {
                case IDLE:
                    setIdleActiveChallengeLabelText();
                    break;
                case CHALLENGE_STARTING:
                    activeChallengeLabel.setText("Starting...");
                    activeChallengeLabel.setForeground(Color.YELLOW);
                    break;
                case CHALLENGE_ENDING:
                    activeChallengeLabel.setText("Ending...");
                    activeChallengeLabel.setForeground(Color.YELLOW);
                    break;
                case CHALLENGE_ACTIVE:
                    activeChallengeLabel.setText("Streaming challenge data!");
                    activeChallengeLabel.setForeground(Color.GREEN);
                    break;
            }
        }

        currentStatePanel.add(createHeading("Current Challenge"), BorderLayout.NORTH);
        currentStatePanel.add(activeChallengeLabel, BorderLayout.CENTER);
        return currentStatePanel;
    }

    @NonNull
    private JPanel createChallengeActionsPanel(Challenge challenge, @Nullable String challengeId) {
        JPanel actionsPanel = new JPanel();
        actionsPanel.setLayout(new GridLayout(1, 0, 5, 0));

        JButton linkButton = new JButton("View Raid");
        linkButton.addActionListener(e -> LinkBrowser.browse(challengeUrl(challenge, challengeId)));
        actionsPanel.add(linkButton);

        JButton copyLinkButton = new JButton("Copy Link");
        copyLinkButton.addActionListener(e ->
                Toolkit.getDefaultToolkit()
                        .getSystemClipboard()
                        .setContents(new StringSelection(challengeUrl(challenge, challengeId)), null));
        actionsPanel.add(copyLinkButton);
        return actionsPanel;
    }

    private static JPanel createHeading(String title) {
        JPanel headingPanel = new JPanel();
        headingPanel.setLayout(new BorderLayout());
        headingPanel.setBorder(new EmptyBorder(0, 0, 5, 0));

        JLabel heading = new JLabel(String.format("— %s —", title));
        heading.setForeground(Color.WHITE);
        heading.setHorizontalAlignment(SwingConstants.CENTER);
        heading.setFont(heading.getFont().deriveFont(Font.BOLD));
        headingPanel.add(heading, BorderLayout.NORTH);
        return headingPanel;
    }

    private Pair<String, Color> getChallengeStatusInfo(int status, int stageId) {
        if (status == PastChallenge.STATUS_IN_PROGRESS) {
            return Pair.of("In Progress", Color.WHITE);
        }
        if (status == PastChallenge.STATUS_COMPLETED) {
            return Pair.of("Completed", Color.GREEN);
        }
        if (status == PastChallenge.STATUS_ABANDONED) {
            return Pair.of("Abandoned", Color.GRAY);
        }

        String boss = "Unknown";
        Stage stage = Stage.fromId(stageId);
        if (stage != null) {
            switch (stage) {
                case TOB_MAIDEN:
                    boss = "Maiden";
                    break;
                case TOB_BLOAT:
                    boss = "Bloat";
                    break;
                case TOB_NYLOCAS:
                    boss = "Nylocas";
                    break;
                case TOB_SOTETSEG:
                    boss = "Sotetseg";
                    break;
                case TOB_XARPUS:
                    boss = "Xarpus";
                    break;
                case TOB_VERZIK:
                    boss = "Verzik";
                    break;

                case COLOSSEUM_WAVE_1:
                    boss = "Wave 1";
                    break;
                case COLOSSEUM_WAVE_2:
                    boss = "Wave 2";
                    break;
                case COLOSSEUM_WAVE_3:
                    boss = "Wave 3";
                    break;
                case COLOSSEUM_WAVE_4:
                    boss = "Wave 4";
                    break;
                case COLOSSEUM_WAVE_5:
                    boss = "Wave 5";
                    break;
                case COLOSSEUM_WAVE_6:
                    boss = "Wave 6";
                    break;
                case COLOSSEUM_WAVE_7:
                    boss = "Wave 7";
                    break;
                case COLOSSEUM_WAVE_8:
                    boss = "Wave 8";
                    break;
                case COLOSSEUM_WAVE_9:
                    boss = "Wave 9";
                    break;
                case COLOSSEUM_WAVE_10:
                    boss = "Wave 10";
                    break;
                case COLOSSEUM_WAVE_11:
                    boss = "Wave 11";
                    break;
                case COLOSSEUM_WAVE_12:
                    boss = "Sol Heredit";
                    break;
            }
        }

        if (status == PastChallenge.STATUS_WIPED) {
            return Pair.of(boss + " Wipe", Color.RED);
        }
        return Pair.of(boss + " Reset", Color.GRAY);
    }

    private String challengeModeToString(int challengeId, int modeId) {
        if (challengeId == Challenge.COLOSSEUM.getId()) {
            return "Colosseum";
        }
        if (challengeId == Challenge.INFERNO.getId()) {
            return "Inferno";
        }

        if (modeId == ChallengeMode.TOB_ENTRY.getId()) {
            return "Entry Mode";
        }
        if (modeId == ChallengeMode.TOB_REGULAR.getId()) {
            return "Regular Mode";
        }
        if (modeId == ChallengeMode.TOB_HARD.getId()) {
            return "Hard Mode";
        }

        if (modeId == ChallengeMode.COX_REGULAR.getId()) {
            return "Cox Regular";
        }
        if (modeId == ChallengeMode.COX_CHALLENGE.getId()) {
            return "CoX CM";
        }

        if (modeId == ChallengeMode.TOA_ENTRY.getId()) {
            return "TOA Entry";
        }
        if (modeId == ChallengeMode.TOA_NORMAL.getId()) {
            return "TOA Normal";
        }
        if (modeId == ChallengeMode.TOA_EXPERT.getId()) {
            return "TOA Expert";
        }

        return "Unknown";
    }

    private JPanel createPastChallengeEntry(PastChallenge challenge, int index) {
        JPanel challengePanel = new JPanel();
        challengePanel.setLayout(new BorderLayout());
        challengePanel.setBorder(new EmptyBorder(8, 8, 8, 8));

        Color bgColor = (index % 2 == 0)
                ? ColorScheme.DARKER_GRAY_COLOR
                : ColorScheme.DARK_GRAY_COLOR;
        challengePanel.setBackground(bgColor);
        challengePanel.setOpaque(true);

        JPanel statusPanel = new JPanel();
        statusPanel.setLayout(new GridLayout(1, 0, 5, 0));
        statusPanel.setOpaque(false);

        Pair<String, Color> statusInfo = getChallengeStatusInfo(challenge.status, challenge.stage);
        JLabel statusLabel = new JLabel();
        statusLabel.setForeground(statusInfo.getRight());
        statusLabel.setText(statusInfo.getLeft());
        statusPanel.add(statusLabel);

        JLabel modeLabel = new JLabel();
        modeLabel.setForeground(Color.WHITE);
        modeLabel.setFont(modeLabel.getFont().deriveFont(Font.ITALIC));
        modeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        modeLabel.setText(challengeModeToString(challenge.challenge, challenge.mode));
        statusPanel.add(modeLabel);

        challengePanel.add(statusPanel, BorderLayout.NORTH);

        JPanel partyPanel = new JPanel();
        partyPanel.setLayout(new BorderLayout());
        partyPanel.setBorder(new EmptyBorder(8, 0, 8, 0));
        partyPanel.setOpaque(false);
        int partyCount = challenge.party != null ? challenge.party.size() : 0;
        JLabel partyHeading = new JLabel("Party (" + partyCount + "):");
        partyHeading.setFont(partyHeading.getFont().deriveFont(Font.BOLD));
        partyHeading.setForeground(Color.WHITE);
        partyPanel.add(partyHeading, BorderLayout.NORTH);

        JLabel partyLabel = new JLabel();
        partyLabel.setForeground(Color.WHITE);
        String party = challenge.party != null ? String.join(", ", challenge.party) : "";
        partyLabel.setText(wrapHtml("<p style=\"width: 150px\">" + party + "</p>"));
        partyPanel.add(partyLabel, BorderLayout.CENTER);
        challengePanel.add(partyPanel, BorderLayout.CENTER);

        Challenge c = Challenge.fromId(challenge.challenge);
        if (c != null) {
            challengePanel.add(createChallengeActionsPanel(c, challenge.id), BorderLayout.SOUTH);
        }

        return challengePanel;
    }

    void setIdleActiveChallengeLabelText() {
        if (this.shutdownTime != null) {
            activeChallengeLabel.setForeground(Color.RED);
            activeChallengeLabel.setText(
                    wrapHtml("<p style=\"text-align:center\">New challenges cannot be started at this time.</p>"));
        } else {
            activeChallengeLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            activeChallengeLabel.setText(wrapHtml(
                    "<p style=\"text-align:center\">Begin a challenge to start recording.</p>"));
        }
    }

    private String challengeUrl(Challenge challenge, String challengeId) {
        String hostname = WebSocketManager.DEFAULT_BLERT_HOST;

        switch (challenge) {
            case TOB:
                return String.format("%s/raids/tob/%s/overview", hostname, challengeId);
            case COX:
                return String.format("%s/raids/cox/%s/overview", hostname, challengeId);
            case TOA:
                return String.format("%s/raids/toa/%s/overview", hostname, challengeId);
            case COLOSSEUM:
                return String.format("%s/challenges/colosseum/%s/overview", hostname, challengeId);
            case INFERNO:
                return String.format("%s/challenges/inferno/%s/overview", hostname, challengeId);
        }

        return hostname;
    }

    /**
     * Creates a border for a section panel with a bottom separator line.
     */
    private static Border createSectionBorder() {
        Border padding = new EmptyBorder(5, 5, 10, 5);
        Border separator = new MatteBorder(0, 0, 1, 0, ColorScheme.LIGHT_GRAY_COLOR);
        return new CompoundBorder(separator, padding);
    }

    /**
     * Returns an HTML colored circle indicator.
     */
    private static String statusIndicator(String color) {
        return "<span style=\"color: " + color + "\">●</span>";
    }

    static String wrapHtml(String content) {
        return "<html><body>" + content + "</body></html>";
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import javax.annotation.Nullable;

@ConfigGroup("blert")
public interface BlertConfig extends Config {
    @ConfigSection(
            name = "General",
            description = "Blert plugin settings",
            position = 1
    )
    String GENERAL_SECTION = "general";


    @ConfigItem(
            keyName = "apiKey",
            name = "Blert API key",
            description = "Token to access the blert API",
            position = 1,
            section = GENERAL_SECTION
    )
    default @Nullable String apiKey() {
        return null;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.Hitpoints;
import io.blert.core.Stage;
import io.blert.core.TrackedNpc;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

public class NpcEvent extends Event {
    @Getter
    private final long roomId;
    @Getter
    private final int npcId;
    @Getter
    private final Hitpoints hitpoints;
    @Getter
    private final TrackedNpc.Properties properties;
    private final boolean propertiesChanged;

    public static NpcEvent spawn(Stage stage, int tick, WorldPoint point, TrackedNpc trackedNpc) {
        return new NpcEvent(EventType.NPC_SPAWN, stage, tick, point, trackedNpc);
    }

    public static NpcEvent update(Stage stage, int tick, WorldPoint point, TrackedNpc trackedNpc) {
        return new NpcEvent(EventType.NPC_UPDATE, stage, tick, point, trackedNpc);
    }

    public static NpcEvent death(Stage stage, int tick, WorldPoint point, TrackedNpc trackedNpc) {
        return new NpcEvent(EventType.NPC_DEATH, stage, tick, point, trackedNpc);
    }

    protected NpcEvent(EventType type, Stage stage, int tick, WorldPoint point, TrackedNpc trackedNpc) {
        super(type, stage, tick, point);
        this.roomId = trackedNpc.getRoomId();
        this.npcId = trackedNpc.getNpcId();
        this.hitpoints = trackedNpc.getHitpoints();
        this.properties = trackedNpc.getProperties();
        this.propertiesChanged = trackedNpc.hasUpdatedProperties();
    }

    public boolean propertiesChanged() {
        return propertiesChanged;
    }

    @Override
    protected String eventDataString() {
        return "npc=(npcId=" + npcId + ", roomId=" + roomId + ", hitpoints=" + hitpoints + ")";
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.xarpus.XarpusPhase;
import io.blert.events.EventType;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class XarpusPhaseEvent extends TobEvent {
    private final XarpusPhase phase;

    public XarpusPhaseEvent(int tick, WorldPoint point, XarpusPhase phase) {
        super(EventType.XARPUS_PHASE, Room.XARPUS, tick, point);
        this.phase = phase;
    }

    @Override
    protected String eventDataString() {
        return "phase=" + phase;
    }
}
/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.events.EventType;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import java.util.List;
import java.util.stream.Collectors;

@Getter
public class MaidenBloodSplatsEvent extends TobEvent {
    private final List<WorldPoint> bloodSplats;

    public MaidenBloodSplatsEvent(int tick, List<WorldPoint> bloodSplats) {
        super(EventType.MAIDEN_BLOOD_SPLATS, Room.MAIDEN, tick, null);
        this.bloodSplats = bloodSplats;
    }

    @Override
    protected String eventDataString() {
        String splats = bloodSplats
                .stream()
                .map(wp -> "(" + wp.getX() + "," + wp.getY() + ")")
                .collect(Collectors.joining(","));
        return "blood_splats=[" + splats + ']';
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.sotetseg.Maze;
import io.blert.events.EventType;
import lombok.Getter;

@Getter
public class SoteMazeEvent extends TobEvent {
    private final Maze maze;

    public static SoteMazeEvent mazeProc(int tick, Maze maze) {
        return new SoteMazeEvent(EventType.SOTE_MAZE_PROC, tick, maze);
    }

    public static SoteMazeEvent mazeEnd(int tick, Maze maze) {
        return new SoteMazeEvent(EventType.SOTE_MAZE_END, tick, maze);
    }

    private SoteMazeEvent(EventType type, int tick, Maze maze) {
        super(type, Room.SOTETSEG, tick, null);
        this.maze = maze;
    }

    @Override
    protected String eventDataString() {
        return null;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.maiden.CrabSpawn;
import io.blert.challenges.tob.rooms.maiden.MaidenCrab;
import io.blert.core.Stage;
import io.blert.events.EventType;
import io.blert.events.NpcEvent;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class MaidenCrabLeakEvent extends NpcEvent {
    public MaidenCrabLeakEvent(int tick, WorldPoint point, MaidenCrab crab) {
        super(EventType.MAIDEN_CRAB_LEAK, Stage.TOB_MAIDEN, tick, point, crab);
    }

    @Override
    public MaidenCrab.Properties getProperties() {
        return (MaidenCrab.Properties) super.getProperties();
    }

    public CrabSpawn getSpawn() {
        return getProperties().getSpawn();
    }

    public MaidenCrab.Position getPosition() {
        return getProperties().getPosition();
    }

    @Override
    protected String eventDataString() {
        return "crab_leak=(crab=" + getSpawn() + ' ' + getPosition() + ", hp=" + getHitpoints().getCurrent() + ')';
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.events.EventType;
import net.runelite.api.coords.WorldPoint;

public class BloatUpEvent extends TobEvent {
    public BloatUpEvent(int tick, WorldPoint point) {
        super(EventType.BLOAT_UP, Room.BLOAT, tick, point);
    }

    @Override
    protected String eventDataString() {
        return null;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.events.EventType;
import lombok.Getter;

@Getter
public class VerzikAttackStyleEvent extends TobEvent {
    public enum Style {
        MELEE,
        RANGE,
        MAGE,
    }

    private final Style style;
    private final int attackTick;

    public VerzikAttackStyleEvent(int tick, Style style, int attackTick) {
        super(EventType.VERZIK_ATTACK_STYLE, Room.VERZIK, tick, null);
        this.style = style;
        this.attackTick = attackTick;
    }

    @Override
    protected String eventDataString() {
        return "verzik_attack=(style=" + style + ", tick=" + attackTick + ")";
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.events.Event;
import io.blert.events.EventType;
import lombok.NonNull;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;

public abstract class TobEvent extends Event {
    protected TobEvent(EventType type, @NonNull Room room, int tick, @Nullable WorldPoint point) {
        super(type, room.toStage(), tick, point);
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.events.EventType;

public class NyloCleanupEndEvent extends TobEvent {
    public NyloCleanupEndEvent(int tick) {
        super(EventType.NYLO_CLEANUP_END, Room.NYLOCAS, tick, null);
    }

    @Override
    protected String eventDataString() {
        return null;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.verzik.VerzikPhase;
import io.blert.events.EventType;
import lombok.Getter;

@Getter
public class VerzikPhaseEvent extends TobEvent {
    private final VerzikPhase phase;

    public VerzikPhaseEvent(int tick, VerzikPhase phase) {
        super(EventType.VERZIK_PHASE, Room.VERZIK, tick, null);
        this.phase = phase;
    }

    @Override
    protected String eventDataString() {
        return "phase=" + phase;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.sotetseg.Maze;
import io.blert.core.Stage;
import io.blert.events.Event;
import io.blert.events.EventType;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

@Getter
public class SoteMazePathEvent extends Event {
    public enum TileType {
        OVERWORLD_TILES,
        UNDERWORLD_PIVOTS,
        OVERWORLD_PIVOTS,
    }

    private final Maze maze;
    private final TileType tileType;
    private final List<WorldPoint> mazeTiles;

    public static SoteMazePathEvent overworldTiles(int tick, Maze maze, List<WorldPoint> mazeTiles) {
        return new SoteMazePathEvent(tick, maze, TileType.OVERWORLD_TILES, mazeTiles);
    }

    public static SoteMazePathEvent underworldPivots(int tick, Maze maze, List<WorldPoint> mazeTiles) {
        return new SoteMazePathEvent(tick, maze, TileType.UNDERWORLD_PIVOTS, mazeTiles);
    }

    public static SoteMazePathEvent overworldPivots(int tick, Maze maze, List<WorldPoint> mazeTiles) {
        return new SoteMazePathEvent(tick, maze, TileType.OVERWORLD_PIVOTS, mazeTiles);
    }

    public Stream<WorldPoint> mazeRelativePoints() {
        return mazeTiles.stream().map(pt -> toMazeRelativePoint(tileType, pt));
    }

    private SoteMazePathEvent(int tick, Maze maze, TileType tileType, List<WorldPoint> mazeTiles) {
        super(EventType.SOTE_MAZE_PATH, Stage.TOB_SOTETSEG, tick, null);
        this.maze = maze;
        this.tileType = tileType;
        this.mazeTiles = mazeTiles;
    }

    @Override
    protected String eventDataString() {
        return "maze=" + maze + ", mazeTiles=" + Arrays.toString(mazeRelativePoints().toArray());
    }

    private static WorldPoint toMazeRelativePoint(TileType tileType, WorldPoint point) {
        WorldPoint start = tileType == TileType.UNDERWORLD_PIVOTS ? Maze.UNDERWORLD_MAZE_START : Maze.OVERWORLD_MAZE_START;
        return new WorldPoint(point.getX() - start.getX(), point.getY() - start.getY(), point.getPlane());
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.events.EventType;
import lombok.Getter;

@Getter
public class NyloWaveEvent extends TobEvent {
    private final int wave;
    private final int nyloCount;
    private final int nyloCap;

    public static NyloWaveEvent spawn(int tick, int wave, int nyloCount, int nyloCap) {
        return new NyloWaveEvent(EventType.NYLO_WAVE_SPAWN, tick, wave, nyloCount, nyloCap);
    }

    public static NyloWaveEvent stall(int tick, int wave, int nyloCount, int nyloCap) {
        return new NyloWaveEvent(EventType.NYLO_WAVE_STALL, tick, wave, nyloCount, nyloCap);
    }

    private NyloWaveEvent(EventType type, int tick, int wave, int nyloCount, int nyloCap) {
        super(type, Room.NYLOCAS, tick, null);
        this.wave = wave;
        this.nyloCount = nyloCount;
        this.nyloCap = nyloCap;
    }

    @Override
    protected String eventDataString() {
        return "wave=" + wave + ", nylos_alive=" + nyloCount;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.events.EventType;
import net.runelite.api.coords.WorldPoint;

public class NyloBossSpawnEvent extends TobEvent {
    public NyloBossSpawnEvent(int tick, WorldPoint spawnPoint) {
        super(EventType.NYLO_BOSS_SPAWN, Room.NYLOCAS, tick, spawnPoint);
    }

    @Override
    protected String eventDataString() {
        return null;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.verzik.VerzikPhase;
import io.blert.events.EventType;

public class VerzikRedsSpawnEvent extends TobEvent {
    public VerzikRedsSpawnEvent(int tick) {
        super(EventType.VERZIK_REDS_SPAWN, Room.VERZIK, tick, null);
    }

    @Override
    protected String eventDataString() {
        return null;
    }

    public VerzikPhase getPhase() {
        // Reds only spawn during P2.
        return VerzikPhase.P2;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.events.EventType;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class BloatDownEvent extends TobEvent {
    final int downNumber;
    final int uptime;

    public BloatDownEvent(int tick, WorldPoint point, int downNumber, int uptime) {
        super(EventType.BLOAT_DOWN, Room.BLOAT, tick, point);
        this.downNumber = downNumber;
        this.uptime = uptime;
    }

    @Override
    protected String eventDataString() {
        return "uptime=" + uptime;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.tob;

import io.blert.challenges.tob.rooms.Room;
import io.blert.challenges.tob.rooms.nylocas.Nylo;
import io.blert.challenges.tob.rooms.nylocas.SpawnType;
import io.blert.events.EventType;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

/**
 * Base class for events containing information about a {@link Nylo}.
 */
@Getter
public abstract class NyloEvent extends TobEvent {
    protected final long roomId;
    protected final long parentRoomId;
    protected final int wave;
    protected final Nylo.Style style;
    protected final SpawnType spawnType;
    protected final boolean big;

    protected NyloEvent(EventType type, int tick, WorldPoint point, Nylo nylo) {
        super(type, Room.NYLOCAS, tick, point);
        this.roomId = nylo.getRoomId();
        this.parentRoomId = nylo.getParent().map(Nylo::getRoomId).orElse(0L);
        this.wave = nylo.getWave();
        this.style = nylo.getStyle();
        this.spawnType = nylo.getSpawnType();
        this.big = nylo.isBig();
    }

    @Override
    protected String eventDataString() {
        StringBuilder sb = new StringBuilder();
        sb.append("roomId=").append(roomId);
        if (parentRoomId != 0) {
            sb.append(", parentRoomId=").append(parentRoomId);
        }
        sb.append(", wave=").append(wave);
        sb.append(", style=").append(style);
        sb.append(", spawnType=").append(spawnType);
        sb.append(", big=").append(big);
        return sb.toString();
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import lombok.Getter;

public enum EventType {
    // These events are sent via server messages, so they do not have IDs.
    CHALLENGE_START(-1),
    CHALLENGE_END(-1),
    CHALLENGE_UPDATE(-1),
    STAGE_UPDATE(-1),

    PLAYER_UPDATE(4),
    PLAYER_ATTACK(5),
    PLAYER_DEATH(6),
    NPC_SPAWN(7),
    NPC_UPDATE(8),
    NPC_DEATH(9),
    NPC_ATTACK(10),
    PLAYER_SPELL(11),

    MAIDEN_CRAB_LEAK(100),
    MAIDEN_BLOOD_SPLATS(101),

    BLOAT_DOWN(110),
    BLOAT_UP(111),

    NYLO_WAVE_SPAWN(120),
    NYLO_WAVE_STALL(121),
    NYLO_CLEANUP_END(122),
    NYLO_BOSS_SPAWN(123),

    SOTE_MAZE_PROC(130),
    SOTE_MAZE_PATH(131),
    SOTE_MAZE_END(132),

    XARPUS_PHASE(140),

    VERZIK_PHASE(150),
    VERZIK_REDS_SPAWN(151),
    VERZIK_ATTACK_STYLE(152),

    COLOSSEUM_HANDICAP_CHOICE(200),
    ;

    @Getter
    private final int id;

    EventType(int id) {
        this.id = id;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

public interface EventHandler {
    /**
     * Processes an event occurring in a raid.
     *
     * @param clientTick Local monotonically increasing tick at which this event was sent. May be used to batch events.
     * @param event      The event that occurred.
     */
    void handleEvent(int clientTick, Event event);
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events.colosseum;

import io.blert.challenges.colosseum.Handicap;
import io.blert.core.Stage;
import io.blert.events.Event;
import io.blert.events.EventType;
import lombok.Getter;

@Getter
public class HandicapChoiceEvent extends Event {
    private final Handicap handicap;
    private final Handicap[] handicapOptions;

    public HandicapChoiceEvent(Stage stage, Handicap handicap, Handicap[] handicapOptions) {
        super(EventType.COLOSSEUM_HANDICAP_CHOICE, stage, 0, null);
        this.handicap = handicap;
        this.handicapOptions = handicapOptions;
    }

    @Override
    protected String eventDataString() {
        return "handicap=" + handicap;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.Challenge;
import io.blert.core.ChallengeMode;
import io.blert.core.Stage;
import lombok.Getter;

import javax.annotation.Nullable;
import java.util.List;

@Getter
public class ChallengeStartEvent extends Event {
    private final Challenge challenge;
    private final ChallengeMode mode;
    private final List<String> party;
    private final boolean isSpectator;

    public ChallengeStartEvent(Challenge challenge, ChallengeMode mode, @Nullable Stage stage,
                               List<String> party, boolean isSpectator) {
        super(EventType.CHALLENGE_START, stage, 0, null);
        this.challenge = challenge;
        this.mode = mode;
        this.party = party;
        this.isSpectator = isSpectator;
    }

    @Override
    protected String eventDataString() {
        return "party=" + party.toString() + ", mode=" + mode;
    }
}
/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.*;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.util.List;
import java.util.Optional;

@Getter
public class PlayerUpdateEvent extends Event {
    /**
     * Type of source for the player update data, indicating the level of confidence about its completeness and
     * accuracy.
     */
    public enum Source {
        /**
         * Data originates directly from the client the player is logged into. Fully accurate.
         */
        PRIMARY,

        /**
         * Data originates from a separate client. Some information may be missing or inaccurate.
         */
        SECONDARY,
    }

    @Getter
    private final Source source;

    @Getter
    private final String username;

    private @Nullable Hitpoints hitpoints = null;
    private @Nullable SkillLevel prayer = null;
    private @Nullable SkillLevel attack = null;
    private @Nullable SkillLevel strength = null;
    private @Nullable SkillLevel defence = null;
    private @Nullable SkillLevel ranged = null;
    private @Nullable SkillLevel magic = null;

    private @Nullable PrayerSet activePrayers = null;

    @Getter
    private List<ItemDelta> equipmentChangesThisTick;
    @Getter
    private int offCooldownTick = 0;

    /**
     * Returns a PlayerUpdateEvent populated with information about a player in the raid.
     *
     * @param stage  Stage during which the event occurred.
     * @param tick   Room tick at which the event occurred.
     * @param client Local client instance.
     * @param raider The player in question.
     * @return Event containing information about the queried player.
     */
    public static PlayerUpdateEvent fromRaider(Stage stage, int tick, WorldPoint point, Client client, Raider raider) {
        Source source = raider.isLocalPlayer() ? Source.PRIMARY : Source.SECONDARY;

        PlayerUpdateEvent evt = new PlayerUpdateEvent(stage, tick, point, source, raider.getUsername());
        evt.equipmentChangesThisTick = raider.getEquipmentChangesThisTick();
        evt.offCooldownTick = raider.getOffCooldownTick();

        if (raider.isLocalPlayer()) {
            evt.hitpoints = new Hitpoints(
                    client.getBoostedSkillLevel(net.runelite.api.Skill.HITPOINTS),
                    client.getRealSkillLevel(net.runelite.api.Skill.HITPOINTS));
            evt.prayer = new SkillLevel(
                    client.getBoostedSkillLevel(net.runelite.api.Skill.PRAYER),
                    client.getRealSkillLevel(net.runelite.api.Skill.PRAYER));
            evt.attack = new SkillLevel(
                    client.getBoostedSkillLevel(net.runelite.api.Skill.ATTACK),
                    client.getRealSkillLevel(net.runelite.api.Skill.ATTACK));
            evt.strength = new SkillLevel(
                    client.getBoostedSkillLevel(net.runelite.api.Skill.STRENGTH),
                    client.getRealSkillLevel(net.runelite.api.Skill.STRENGTH));
            evt.defence = new SkillLevel(
                    client.getBoostedSkillLevel(net.runelite.api.Skill.DEFENCE),
                    client.getRealSkillLevel(net.runelite.api.Skill.DEFENCE));
            evt.ranged = new SkillLevel(
                    client.getBoostedSkillLevel(net.runelite.api.Skill.RANGED),
                    client.getRealSkillLevel(net.runelite.api.Skill.RANGED));
            evt.magic = new SkillLevel(
                    client.getBoostedSkillLevel(net.runelite.api.Skill.MAGIC),
                    client.getRealSkillLevel(net.runelite.api.Skill.MAGIC));

            evt.activePrayers = getPrayersFromClient(client);
        } else {
            if (raider.getOverheadPrayer() != null) {
                PrayerSet prayers = new PrayerSet(Prayer.PRAYER_BOOK_NORMAL);
                prayers.add(raider.getOverheadPrayer());
                evt.activePrayers = prayers;
            }
        }

        return evt;
    }


    private PlayerUpdateEvent(Stage stage, int tick, WorldPoint point, Source source, String username) {
        super(EventType.PLAYER_UPDATE, stage, tick, point);
        this.source = source;
        this.username = username;
    }

    /**
     * Returns the player's hitpoints, if available.
     */
    public Optional<Hitpoints> getHitpoints() {
        return Optional.ofNullable(hitpoints);
    }

    public Optional<SkillLevel> getPrayer() {
        return Optional.ofNullable(prayer);
    }

    public Optional<SkillLevel> getAttack() {
        return Optional.ofNullable(attack);
    }

    public Optional<SkillLevel> getStrength() {
        return Optional.ofNullable(strength);
    }

    public Optional<SkillLevel> getDefence() {
        return Optional.ofNullable(defence);
    }

    public Optional<SkillLevel> getRanged() {
        return Optional.ofNullable(ranged);
    }

    public Optional<SkillLevel> getMagic() {
        return Optional.ofNullable(magic);
    }

    public Optional<PrayerSet> getActivePrayers() {
        return Optional.ofNullable(activePrayers);
    }

    @Override
    protected String eventDataString() {
        StringBuilder string = new StringBuilder("player=(");
        string.append("name=").append(getUsername());

        getHitpoints().ifPresent(hp -> string.append(", hp=").append(hp));

        string.append(')');
        return string.toString();
    }

    private static PrayerSet getPrayersFromClient(Client client) {
        PrayerSet set = new PrayerSet(Prayer.PRAYER_BOOK_NORMAL);

        for (Prayer prayer : Prayer.values()) {
            if (client.isPrayerActive(prayer.getRunelitePrayer())) {
                set.add(prayer);
            }
        }

        return set;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import lombok.extern.slf4j.Slf4j;

@Slf4j

public class LoggingEventHandler implements EventHandler {
    @Override
    public void handleEvent(int clientTick, Event event) {
        log.info(event.toString());
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.ChallengeMode;
import lombok.Getter;

@Getter
public class ChallengeUpdateEvent extends Event {
    private final ChallengeMode mode;

    public ChallengeUpdateEvent(ChallengeMode mode) {
        super(EventType.CHALLENGE_UPDATE);
        this.mode = mode;
    }

    @Override
    protected String eventDataString() {
        return "mode=" + mode;
    }
}

/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.Raider;
import io.blert.core.SpellDefinition;
import io.blert.core.Stage;
import io.blert.core.TrackedNpc;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;

@Getter
public class PlayerSpellEvent extends Event {
    private final SpellDefinition spell;
    private final String username;

    private final @Nullable String targetPlayer;
    private final int targetNpcId;
    private final long targetNpcRoomId;

    private PlayerSpellEvent(Stage stage, int tick, WorldPoint playerPoint, SpellDefinition spell,
                             Raider raider, @Nullable String targetPlayer, int targetNpcId, long targetNpcRoomId) {
        super(EventType.PLAYER_SPELL, stage, tick, playerPoint);
        this.spell = spell;
        this.username = raider.getUsername();
        this.targetPlayer = targetPlayer;
        this.targetNpcId = targetNpcId;
        this.targetNpcRoomId = targetNpcRoomId;
    }

    public static PlayerSpellEvent withNoTarget(Stage stage, int tick, WorldPoint playerPoint,
                                                SpellDefinition spell, Raider raider) {
        return new PlayerSpellEvent(stage, tick, playerPoint, spell, raider, null, -1, 0);
    }

    public static PlayerSpellEvent withPlayerTarget(Stage stage, int tick, WorldPoint playerPoint,
                                                    SpellDefinition spell, Raider raider, String targetPlayer) {
        return new PlayerSpellEvent(stage, tick, playerPoint, spell, raider, targetPlayer, -1, 0);
    }

    public static PlayerSpellEvent withNpcTarget(Stage stage, int tick, WorldPoint playerPoint,
                                                 SpellDefinition spell, Raider raider, TrackedNpc targetNpc) {
        return new PlayerSpellEvent(stage, tick, playerPoint, spell, raider, null,
                targetNpc.getNpcId(), targetNpc.getRoomId());
    }

    public boolean hasNpcTarget() {
        return targetNpcId != -1;
    }

    @Override
    protected String eventDataString() {
        StringBuilder sb = new StringBuilder("spell=").append(spell.getName());
        sb.append(", player=").append(username);
        if (targetPlayer != null) {
            sb.append(", targetPlayer=").append(targetPlayer);
        }
        if (targetNpcId != -1) {
            sb.append(", targetNpc=").append(targetNpcId);
        }
        return sb.toString();
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.*;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.util.Optional;

@Getter
public class PlayerAttackEvent extends Event {
    private final AttackDefinition attack;
    private final @Nullable Item weapon;
    private final String username;
    private final int targetNpcId;
    private final long targetRoomId;
    private final int distanceToTarget;

    public PlayerAttackEvent(Stage stage, int tick, WorldPoint playerPoint, AttackDefinition attack,
                             @Nullable Item weapon, Raider raider, @Nullable TrackedNpc trackedNpc, int distanceToNpc) {
        super(EventType.PLAYER_ATTACK, stage, tick, playerPoint);
        this.attack = attack;
        this.weapon = weapon;
        this.username = raider.getUsername();
        this.distanceToTarget = distanceToNpc;

        if (trackedNpc != null) {
            this.targetNpcId = trackedNpc.getNpcId();
            this.targetRoomId = trackedNpc.getRoomId();
        } else {
            this.targetNpcId = 0;
            this.targetRoomId = 0;
        }
    }

    public Optional<Item> getWeapon() {
        return Optional.ofNullable(weapon);
    }

    @Override
    protected String eventDataString() {
        StringBuilder sb = new StringBuilder("type=").append(attack.getName());
        sb.append(", player=").append(username);
        if (attack.isUnknown()) {
            sb.append(", weapon=").append(weapon != null ? weapon.getId() : "null");
        }
        return sb.toString();
    }
}


/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.Stage;
import joptsimple.internal.Strings;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.util.Optional;

public abstract class Event {
    private final @Getter EventType type;
    private final @Nullable Stage stage;
    private final @Getter int tick;
    private final @Nullable WorldPoint coords;

    protected Event(EventType type) {
        this(type, null, 0, null);
    }

    protected Event(EventType type, @Nullable Stage stage, int tick, @Nullable WorldPoint point) {
        this.type = type;
        this.stage = stage;
        this.tick = tick;
        this.coords = point;
    }

    public Optional<Stage> getStage() {
        return Optional.ofNullable(stage);
    }

    public int getXCoord() {
        return coords != null ? coords.getX() : 0;
    }

    public int getYCoord() {
        return coords != null ? coords.getY() : 0;
    }

    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("Event(");
        string.append("type=").append(type);
        string.append(", tick=").append(tick);
        string.append(", coords=");
        if (coords != null) {
            string.append('(').append(coords.getX()).append(',').append(coords.getY()).append(')');
        } else {
            string.append("null");
        }
        string.append(", stage=").append(stage);

        String eventData = eventDataString();
        if (!Strings.isNullOrEmpty(eventData)) {
            string.append(", ").append(eventData);
        }

        string.append(")");
        return string.toString();
    }

    /**
     * Returns a string representation of the data tracked by the event. A null or empty string indicates no data.
     */
    protected abstract String eventDataString();
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.NpcAttack;
import io.blert.core.Stage;
import io.blert.core.TrackedNpc;
import lombok.Getter;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;

@Getter
public class NpcAttackEvent extends Event {
    private final NpcAttack attack;
    private final int npcId;
    private final long roomId;
    private final @Nullable String target;

    public NpcAttackEvent(Stage stage, int tick, @Nullable WorldPoint point,
                          NpcAttack attack, TrackedNpc npc, @Nullable String target) {
        super(EventType.NPC_ATTACK, stage, tick, point);
        this.attack = attack;
        this.npcId = npc.getNpcId();
        this.roomId = npc.getRoomId();
        this.target = target;
    }

    public NpcAttackEvent(Stage stage, int tick, @Nullable WorldPoint point, NpcAttack attack, TrackedNpc npc) {
        this(stage, tick, point, attack, npc,
                npc.getNpc().getInteracting() instanceof Player ?
                        npc.getNpc().getInteracting().getName() : null);
    }

    @Override
    protected String eventDataString() {
        return "npc_attack=(attack=" + attack + ", target=" + (target != null ? target : "none") + ")";
    }
}
/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import lombok.Getter;

@Getter
public class ChallengeEndEvent extends Event {
    private final int challengeTime;
    private final int overallTime;

    public ChallengeEndEvent(int challengeTime, int overallTime) {
        super(EventType.CHALLENGE_END);
        this.challengeTime = challengeTime;
        this.overallTime = overallTime;
    }

    @Override
    protected String eventDataString() {
        return null;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.Stage;
import lombok.Getter;

import java.util.Optional;

@Getter
public class StageUpdateEvent extends Event {
    public enum Status {
        ENTERED,
        STARTED,
        COMPLETED,
        WIPED,
    }

    private final Status status;
    private final boolean accurate;
    private final Optional<Integer> inGameTicks;
    private final boolean gameTicksPrecise;

    public StageUpdateEvent(Stage stage, int tick, Status status) {
        this(stage, tick, status, false, Optional.empty(), false);
    }

    public StageUpdateEvent(Stage stage, int tick, Status status, boolean accurate,
                            Optional<Integer> inGameTicks, boolean gameTicksPrecise) {
        super(EventType.STAGE_UPDATE, stage, tick, null);
        this.status = status;
        this.accurate = accurate;
        this.inGameTicks = inGameTicks;
        this.gameTicksPrecise = gameTicksPrecise;
    }

    @Override
    protected String eventDataString() {
        return "status=" + status;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.events;

import io.blert.core.Stage;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class PlayerDeathEvent extends Event {
    final String username;

    public PlayerDeathEvent(Stage stage, int tick, WorldPoint point, String username) {
        super(EventType.PLAYER_DEATH, stage, tick, point);
        this.username = username;
    }

    @Override
    protected String eventDataString() {
        return "player=" + username;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

public enum ChallengeState {
    /**
     * Not in a challenge.
     */
    INACTIVE,
    /**
     * A challenge start has been triggered, but is delayed pending some challenge-specific initialization.
     * Not used in all challenges.
     */
    PREPARING,
    /**
     * A challenge has been initialized but the player has not yet entered.
     */
    STARTING,
    /**
     * The player is in the challenge.
     */
    ACTIVE,
    /**
     * The challenge has ended and is in the process of cleaning up.
     */
    ENDING,
    /**
     * The challenge has ended and all cleanup has been completed, but the player has not yet left.
     */
    COMPLETE;

    public boolean isInactive() {
        return this == INACTIVE;
    }

    public boolean hasStarted() {
        return this == ACTIVE || this == ENDING || this == COMPLETE;
    }

    public boolean inChallenge() {
        return !isInactive();
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.Getter;

public enum NpcAttack {
    TOB_MAIDEN_AUTO(1),
    TOB_MAIDEN_BLOOD_THROW(2),
    TOB_BLOAT_STOMP(3),
    TOB_NYLO_BOSS_MELEE(4),
    TOB_NYLO_BOSS_RANGE(5),
    TOB_NYLO_BOSS_MAGE(6),
    TOB_SOTE_MELEE(7),
    TOB_SOTE_BALL(8),
    TOB_SOTE_DEATH_BALL(9),
    TOB_XARPUS_SPIT(10),
    TOB_XARPUS_TURN(11),
    TOB_VERZIK_P1_AUTO(12),
    TOB_VERZIK_P2_BOUNCE(13),
    TOB_VERZIK_P2_CABBAGE(14),
    TOB_VERZIK_P2_ZAP(15),
    TOB_VERZIK_P2_PURPLE(16),
    TOB_VERZIK_P2_MAGE(17),
    TOB_VERZIK_P3_AUTO(18),
    TOB_VERZIK_P3_WEBS(22),
    TOB_VERZIK_P3_YELLOWS(23),
    TOB_VERZIK_P3_BALL(24),

    COLOSSEUM_BERSERKER_AUTO(100),
    COLOSSEUM_SEER_AUTO(101),
    COLOSSEUM_ARCHER_AUTO(102),
    COLOSSEUM_SHAMAN_AUTO(103),
    COLOSSEUM_JAGUAR_AUTO(104),
    COLOSSEUM_JAVELIN_AUTO(105),
    COLOSSEUM_JAVELIN_TOSS(106),
    COLOSSEUM_MANTICORE_MAGE(107),
    COLOSSEUM_MANTICORE_RANGE(114),
    COLOSSEUM_MANTICORE_MELEE(115),
    COLOSSEUM_SHOCKWAVE_AUTO(108),
    COLOSSEUM_MINOTAUR_AUTO(109),
    COLOSSEUM_HEREDIT_THRUST(110),
    COLOSSEUM_HEREDIT_SLAM(111),
    COLOSSEUM_HEREDIT_BREAK(112),
    COLOSSEUM_HEREDIT_COMBO(113),
    ;

    @Getter
    private final int id;

    NpcAttack(int id) {
        this.id = id;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.Getter;

import javax.annotation.Nullable;

public enum Challenge {
    TOB("Theatre of Blood", 1),
    COX("Chambers of Xeric", 2),
    TOA("Tombs of Amascut", 3),
    COLOSSEUM("Colosseum", 4),
    INFERNO("Inferno", 5),
    ;

    @Getter
    private final String name;

    @Getter
    private final int id;

    Challenge(String name, int id) {
        this.name = name;
        this.id = id;
    }

    @Nullable
    public static Challenge fromId(int id) {
        for (Challenge challenge : values()) {
            if (challenge.getId() == id) {
                return challenge;
            }
        }
        return null;
    }
}

/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import com.google.gson.Gson;
import lombok.AllArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nullable;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
public class SpellRegistry {
    private static final String BUNDLED_SPELLS_RESOURCE = "/spells.json";

    @AllArgsConstructor
    private static class State {
        private final Map<Integer, SpellDefinition> byAnimationId;
        private final Map<Integer, SpellDefinition> byGraphicId;
        private final Map<Integer, List<SpellDefinition>> targetedByAnimationId;
    }

    @Setter
    private Gson gson;

    private volatile State state = new State(Map.of(), Map.of(), Map.of());

    /**
     * Loads default spell definitions from the bundled JSON resource.
     */
    public void loadDefaults() {
        InputStream stream = getClass().getResourceAsStream(BUNDLED_SPELLS_RESOURCE);
        if (stream == null) {
            log.warn("Bundled spells.json not found; initializing empty spell registry");
            return;
        }

        try {
            List<SpellDefinition> loaded =
                    SpellDefinition.loadFromJson(gson, stream);
            updateDefinitions(loaded);
            log.info("Loaded {} bundled spell definitions", loaded.size());
        } catch (Exception e) {
            log.error("Failed to load bundled spell definitions", e);
        }
    }

    /**
     * Updates the registry with new spell definitions from the server,
     * replacing existing ones.
     *
     * @param definitions The new definitions.
     */
    public void updateFromServer(List<SpellDefinition> definitions) {
        updateDefinitions(definitions);
        log.info("Updated spell registry with {} definitions from server",
                definitions.size());
    }

    /**
     * Replaces all spell definitions with the provided list.
     */
    public void updateDefinitions(List<SpellDefinition> newDefinitions) {
        Map<Integer, SpellDefinition> newByAnimation = new HashMap<>();
        Map<Integer, SpellDefinition> newByGraphic = new HashMap<>();
        Map<Integer, List<SpellDefinition>> newTargetedByAnimation = new HashMap<>();

        for (SpellDefinition spell : newDefinitions) {
            for (int animId : spell.getAnimationIds()) {
                if (spell.isTargeted()) {
                    newTargetedByAnimation.computeIfAbsent(animId, k -> new ArrayList<>()).add(spell);
                } else {
                    newByAnimation.put(animId, spell);
                }
            }
            for (SpellDefinition.Graphic g : spell.getGraphics()) {
                newByGraphic.put(g.getId(), spell);
            }
        }

        this.state = new State(
                newByAnimation,
                newByGraphic,
                newTargetedByAnimation
        );
    }

    /**
     * Finds a spell by animation ID (for spells with unique animations).
     *
     * @param animationId The animation ID.
     * @return The spell definition, or null if not found.
     */
    @Nullable
    public SpellDefinition findByAnimation(int animationId) {
        return state.byAnimationId.get(animationId);
    }

    /**
     * Finds a spell by caster graphic ID.
     *
     * @param graphicId The graphic ID on the caster.
     * @return The spell definition, or null if not found.
     */
    @Nullable
    public SpellDefinition findByGraphic(int graphicId) {
        return state.byGraphicId.get(graphicId);
    }

    /**
     * Gets all targeted spells that use the given caster animation.
     * Used for disambiguating spells that share an animation but have different
     * target graphics.
     *
     * @param animationId The caster animation ID.
     * @return List of targeted spell candidates, or empty list if none found.
     */
    public List<SpellDefinition> getTargetedSpellsByAnimation(int animationId) {
        List<SpellDefinition> result = state.targetedByAnimationId.get(animationId);
        return result != null ? result : List.of();
    }
}

/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nullable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Getter
@Slf4j
public class AttackDefinition {
    @Getter
    public static class Projectile {
        private final int id;
        private final int startCycleOffset;
        /**
         * Optional weapon ID this projectile is specific to.
         * If <= 0, the projectile applies to all weapons for its attack.
         */
        private final int weaponId;

        public Projectile(int id, int startCycleOffset) {
            this(id, startCycleOffset, -1);
        }

        public Projectile(int id, int startCycleOffset, int weaponId) {
            this.id = id;
            this.startCycleOffset = startCycleOffset;
            this.weaponId = weaponId;
        }

        public boolean isWeaponSpecific() {
            return weaponId > 0;
        }
    }

    public enum Category {
        MELEE,
        RANGED,
        MAGIC;
    }

    /**
     * Unique identifier for this attack: the raw proto PlayerAttack enum value.
     */
    private final int protoId;

    /**
     * Human-readable name for logging/debugging.
     */
    private final String name;

    /**
     * Item IDs that can perform this attack.
     */
    private final int[] weaponIds;

    /**
     * Animation IDs that trigger this attack.
     */
    private final int[] animationIds;

    /**
     * Attack cooldown in game ticks.
     */
    private final int cooldown;

    /**
     * Projectile info. May contain multiple entries for weapon-specific projectiles.
     */
    private final List<Projectile> projectiles;

    /**
     * Whether this attack uses a continuous animation (e.g. blowpipe).
     */
    private final boolean continuousAnimation;

    /**
     * Category of attack.
     */
    private final Category category;

    /**
     * Whether this attack is an "unknown" type.
     */
    private final boolean unknown;

    public AttackDefinition(int protoId, String name, int[] weaponIds, int[] animationIds,
                            int cooldown, List<Projectile> projectiles,
                            boolean continuousAnimation, Category category) {
        this.protoId = protoId;
        this.name = name;
        this.weaponIds = weaponIds;
        this.animationIds = animationIds;
        this.cooldown = cooldown;
        this.projectiles = projectiles != null ? projectiles : Collections.emptyList();
        this.continuousAnimation = continuousAnimation;
        this.category = category;
        this.unknown = protoId == 0 || (name != null && name.startsWith("UNKNOWN"));
    }

    /**
     * Returns whether this attack matches the given attack ID.
     *
     * @param attackId Attack ID.
     * @return True if the attack matches, false otherwise.
     */
    public boolean is(int attackId) {
        return this.protoId == attackId;
    }

    /**
     * Returns whether this attack can be performed with the given weapon.
     */
    public boolean hasWeapon(int weaponId) {
        for (int wid : weaponIds) {
            if (wid == weaponId) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns whether this attack has any associated projectiles.
     */
    public boolean hasProjectile() {
        return !projectiles.isEmpty();
    }

    /**
     * Returns the projectile for the given weapon ID.
     * First checks for a weapon-specific projectile, then falls back to any
     * generic projectile.
     *
     * @param weaponId The weapon ID to look up.
     * @return The projectile for the weapon, or null if none.
     */
    @Nullable
    public Projectile getProjectileForWeapon(int weaponId) {
        if (projectiles.isEmpty()) {
            return null;
        }

        Projectile generic = null;

        for (Projectile p : projectiles) {
            if (p.getWeaponId() == weaponId) {
                return p;
            }
            if (!p.isWeaponSpecific() && generic == null) {
                generic = p;
            }
        }

        return generic;
    }

    /**
     * Loads attack definitions from a JSON input stream.
     */
    public static List<AttackDefinition> loadFromJson(Gson gson, InputStream inputStream) throws IOException {
        try (Reader r = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {
            List<io.blert.json.AttackDefinition> jsonDefs = gson.fromJson(
                    r,
                    new TypeToken<List<io.blert.json.AttackDefinition>>() {
                    }.getType()
            );
            return jsonDefs.stream().map(io.blert.json.AttackDefinition::toCore).collect(Collectors.toList());
        }
    }
}
/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.Getter;

/**
 * An item delta represents a change to an item in a container, such as the player's inventory or equipment.
 */
@Getter
public class ItemDelta {
    // An item delta is a 53-bit integer value (fully representable within an IEEE 754 double for Javascript
    // compatibility), with the following layout:
    //
    //   Bits 0-30:  Absolute quantity of item added or removed.
    //   Bit 31:     Added bit (1 if the item was added, 0 if it was removed).
    //   Bits 32-47: In-game item ID.
    //   Bits 48-52: ID of the "slot" the item was added to or removed from. The meaning of slot is context-dependent.
    //
    private static final long QUANTITY_MASK = 0x7FFFFFFF;
    private static final long ADDED_BIT = 1L << 31;
    private static final long ID_SHIFT = 32;
    private static final long ID_MASK = 0xFFFF;
    private static final long SLOT_SHIFT = 48;
    private static final long SLOT_MASK = 0x1F;

    private long value;

    public ItemDelta(int id, int quantity, int slot, boolean added) {
        if (quantity < 0) {
            throw new IllegalArgumentException("Quantity must be non-negative");
        }
        if (id < 0 || id > ID_MASK) {
            throw new IllegalArgumentException("ID must be between 0 and " + ID_MASK);
        }
        if (slot < 0 || slot > SLOT_MASK) {
            throw new IllegalArgumentException("Slot must be between 0 and " + SLOT_MASK);
        }

        value = quantity & QUANTITY_MASK;
        if (added) {
            value |= ADDED_BIT;
        }
        value |= (id & ID_MASK) << ID_SHIFT;
        value |= (slot & SLOT_MASK) << SLOT_SHIFT;
    }

    public int getQuantity() {
        return (int) (value & QUANTITY_MASK);
    }

    public boolean isAdded() {
        return (value & ADDED_BIT) != 0;
    }

    public int getId() {
        return (int) ((value >> ID_SHIFT) & ID_MASK);
    }

    public int getSlot() {
        return (int) ((value >> SLOT_SHIFT) & SLOT_MASK);
    }

    public String toString() {
        return "ItemDelta{id=" + getId() + ", quantity=" + getQuantity() + ", slot=" + getSlot() + ", added=" + isAdded() + "}";
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.Getter;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;

public enum Stage {
    TOB_MAIDEN(10),
    TOB_BLOAT(11),
    TOB_NYLOCAS(12),
    TOB_SOTETSEG(13),
    TOB_XARPUS(14),
    TOB_VERZIK(15),

    COX_TEKTON(20),
    COX_CRABS(21),
    COX_ICE_DEMON(22),
    COX_SHAMANS(23),
    COX_VANGUARDS(24),
    COX_THIEVING(25),
    COX_VESPULA(26),
    COX_TIGHTROPE(27),
    COX_GUARDIANS(28),
    COX_VASA(29),
    COX_MYSTICS(30),
    COX_MUTTADILE(31),
    COX_OLM(32),

    TOA_APMEKEN(40),
    TOA_BABA(41),
    TOA_SCABARAS(42),
    TOA_KEPHRI(43),
    TOA_HET(44),
    TOA_AKKHA(45),
    TOA_CRONDIS(46),
    TOA_ZEBAK(47),
    TOA_WARDENS(48),

    COLOSSEUM_WAVE_1(100),
    COLOSSEUM_WAVE_2(101),
    COLOSSEUM_WAVE_3(102),
    COLOSSEUM_WAVE_4(103),
    COLOSSEUM_WAVE_5(104),
    COLOSSEUM_WAVE_6(105),
    COLOSSEUM_WAVE_7(106),
    COLOSSEUM_WAVE_8(107),
    COLOSSEUM_WAVE_9(108),
    COLOSSEUM_WAVE_10(109),
    COLOSSEUM_WAVE_11(110),
    COLOSSEUM_WAVE_12(111),
    ;

    @Getter
    private final int id;

    private static final Map<Integer, Stage> ID_MAP = new HashMap<>();

    static {
        for (Stage stage : values()) {
            ID_MAP.put(stage.id, stage);
        }
    }

    Stage(int id) {
        this.id = id;
    }

    /**
     * Retrieves the Stage enum constant associated with a specific ID.
     *
     * @param stageId The integer ID to look up.
     * @return The matching Stage, or null if no match is found.
     */
    @Nullable
    public static Stage fromId(int stageId) {
        return ID_MAP.get(stageId);
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import io.blert.challenges.tob.TobNpc;

/**
 * Represents a game entity's current and maximum hitpoints.
 */
public class Hitpoints extends SkillLevel {
    public static Hitpoints fromRatio(double ratio, int baseHp) {
        return new Hitpoints((int) (baseHp * ratio), baseHp);
    }

    public Hitpoints(int base) {
        super(base, base);
    }

    public Hitpoints(int current, int base) {
        super(current, base);
    }

    public Hitpoints(Hitpoints other) {
        super(other.current, other.base);
    }

    public Hitpoints(TobNpc tobNpc, int scale) {
        this(tobNpc.getBaseHitpoints(scale));
    }

    public Hitpoints update(int current) {
        return new Hitpoints(current, base);
    }

    public double percentage() {
        if (base == 0) {
            return Double.NaN;
        }
        return current / (double) base * 100.0;
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.Getter;

/**
 * Represents a game skill, with a base level and boosted/drained current level.
 */
@Getter
public class SkillLevel {
    int current;
    int base;

    public SkillLevel(int current, int base) {
        this.current = Math.max(current, 0);
        this.base = Math.max(base, 0);
    }

    public void boost(int amount) {
        current += amount;
    }

    public void drain(int amount) {
        current = Math.max(current - amount, 0);
    }

    public int getValue() {
        return (current << 16) | (base & 0xffff);
    }

    public String toString() {
        return current + "/" + base;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import io.blert.challenges.tob.TobNpc;
import lombok.NonNull;
import net.runelite.api.NPC;

/**
 * A tracked NPC without any special properties, existing as a simple wrapper around a Runelite NPC.
 */
public class BasicTrackedNpc extends TrackedNpc {
    public static class EmptyProperties extends TrackedNpc.Properties {
    }

    public BasicTrackedNpc(@NonNull NPC npc, long roomId, Hitpoints hitpoints) {
        super(npc, roomId, hitpoints);
    }

    public BasicTrackedNpc(@NonNull NPC npc, TobNpc tobNpc, long roomId, Hitpoints hitpoints) {
        super(npc, tobNpc, roomId, hitpoints);
    }

    @Override
    public @NonNull Properties getProperties() {
        return new EmptyProperties();
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

public enum Skill {
    HITPOINTS,
    ATTACK,
    STRENGTH,
    DEFENCE,
    RANGED,
    MAGIC,
    PRAYER,
}

/*
 * Copyright (c) 2026 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import net.runelite.api.events.*;

/**
 * Interface for components that receive RuneLite events routed from the central plugin.
 */
public interface RuneliteEventHandler {
    default void onGameStateChanged(GameStateChanged event) {}
    default void onNpcSpawned(NpcSpawned event) {}
    default void onNpcDespawned(NpcDespawned event) {}
    default void onNpcChanged(NpcChanged event) {}
    default void onAnimationChanged(AnimationChanged event) {}
    default void onProjectileMoved(ProjectileMoved event) {}
    default void onChatMessage(ChatMessage event) {}
    default void onHitsplatApplied(HitsplatApplied event) {}
    default void onGameObjectSpawned(GameObjectSpawned event) {}
    default void onGameObjectDespawned(GameObjectDespawned event) {}
    default void onGroundObjectSpawned(GroundObjectSpawned event) {}
    default void onGroundObjectDespawned(GroundObjectDespawned event) {}
    default void onGraphicChanged(GraphicChanged event) {}
    default void onGraphicsObjectCreated(GraphicsObjectCreated event) {}
    default void onActorDeath(ActorDeath event) {}
    default void onVarbitChanged(VarbitChanged event) {}
    default void onScriptPreFired(ScriptPreFired event) {}
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import com.google.common.collect.ImmutableSet;
import io.blert.challenges.tob.TobNpc;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Hitsplat;
import net.runelite.api.Item;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;

import java.util.function.Consumer;

@Slf4j

public class SpecialAttackTracker {
    NPC specTarget = null;
    Item specWeapon = null;
    Hitsplat specHitsplat = null;
    int expectedHitsplatTick;
    int specialPercent = -1;

    @Getter
    @AllArgsConstructor
    public static class SpecialAttack {
        NPC target;
        Item weapon;
        int damage;
    }

    final Consumer<SpecialAttack> specCallback;

    static final ImmutableSet<Integer> TRACKED_SPECIAL_WEAPONS = ImmutableSet.of(
            ItemID.DRAGON_WARHAMMER,
            ItemID.DRAGON_WARHAMMER_CR,
            ItemID.BANDOS_GODSWORD,
            ItemID.BANDOS_GODSWORD_OR);

    public SpecialAttackTracker(Consumer<SpecialAttack> specCallback) {
        this.specCallback = specCallback;
    }

    /**
     * Sets the special attack percentage to the specified value.
     *
     * @param percent The new special attack percentage.
     * @return The old percentage before the update.
     */
    public int updateSpecialPercent(int percent) {
        int old = specialPercent;
        specialPercent = percent;
        return old;
    }

    public void recordSpecialUsed(NPC target, Item weapon, int specTick) {
        if (!TRACKED_SPECIAL_WEAPONS.contains(weapon.getId())) {
            return;
        }

        specTarget = TobNpc.withId(target.getId()).isPresent() ? target : null;
        if (specTarget != null) {
            expectedHitsplatTick = specTick + hitDelay();
            specWeapon = weapon;
        }
    }

    public void recordHitsplat(NPC target, Hitsplat hitsplat, int hitsplatTick) {
        if (specTarget == null || target != specTarget) {
            return;
        }

        if (TobNpc.withId(target.getId()).isEmpty()) {
            return;
        }

        if (hitsplatTick == expectedHitsplatTick) {
            specHitsplat = hitsplat;
        }
    }

    public void processPendingSpecial() {
        if (specTarget == null || specHitsplat == null) {
            return;
        }

        specCallback.accept(new SpecialAttack(specTarget, specWeapon, specHitsplat.getAmount()));

        specTarget = null;
        specWeapon = null;
        specHitsplat = null;
        expectedHitsplatTick = 0;
    }

    private int hitDelay() {
        // TODO(frolv): This should be set per weapon, but only melee weapons are tracked right now.
        return 1;
    }
}

/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Getter;

import javax.annotation.Nullable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Definition of a player spell (utility spells, not combat).
 */
@Getter
public class SpellDefinition {
    @Getter
    public static class Graphic {
        private final int id;
        private final int durationTicks;
        private final int maxFrame;

        public Graphic(int id, int durationTicks, int maxFrame) {
            this.id = id;
            this.durationTicks = durationTicks;
            this.maxFrame = maxFrame;
        }
    }

    private final int id;
    private final String name;
    private final int[] animationIds;
    private final List<Graphic> graphics;
    private final List<Graphic> targetGraphics;
    private final int stallTicks;

    private final int defaultCooldown;

    public SpellDefinition(int id, String name, int[] animationIds, List<Graphic> graphics,
                           List<Graphic> targetGraphics, int stallTicks) {
        this.id = id;
        this.name = name;
        this.animationIds = animationIds != null ? animationIds : new int[0];
        this.graphics = graphics != null ? graphics : Collections.emptyList();
        this.targetGraphics = targetGraphics != null ? targetGraphics : Collections.emptyList();
        this.stallTicks = stallTicks;

        int maxCasterCooldown = this.graphics.stream()
                .mapToInt(Graphic::getDurationTicks)
                .max()
                .orElse(0);
        int maxTargetCooldown = this.targetGraphics.stream()
                .mapToInt(Graphic::getDurationTicks)
                .max()
                .orElse(0);
        this.defaultCooldown = Math.max(Math.max(maxCasterCooldown, maxTargetCooldown), 1);
    }

    public boolean isTargeted() {
        return !targetGraphics.isEmpty();
    }

    public boolean isStall() {
        return stallTicks > 0;
    }

    public boolean hasAnimation(int animationId) {
        for (int aid : animationIds) {
            if (aid == animationId) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the caster graphic definition for the given graphic ID, if any.
     */
    @Nullable
    public Graphic getGraphic(int graphicId) {
        for (Graphic g : graphics) {
            if (g.getId() == graphicId) {
                return g;
            }
        }
        return null;
    }

    /**
     * Returns the cooldown (deduplication interval) for the spell.
     * Optionally, if the graphicId is provided, returns the cooldown for that specific graphic.
     *
     * @param graphicId The graphic ID to get the cooldown for, or null for the default.
     * @return The cooldown in ticks.
     */
    public int getCooldown(@Nullable Integer graphicId) {
        if (graphicId == null) {
            return defaultCooldown;
        }
        Graphic g = getGraphic(graphicId);
        return g != null ? g.getDurationTicks() : defaultCooldown;
    }

    /**
     * Loads spell definitions from a JSON input stream.
     */
    public static List<SpellDefinition> loadFromJson(Gson gson,
                                                     InputStream inputStream) throws IOException {
        try (Reader r = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {
            List<io.blert.json.SpellDefinition> jsonDefs = gson.fromJson(
                    r,
                    new TypeToken<List<io.blert.json.SpellDefinition>>() {
                    }.getType()
            );
            return jsonDefs.stream().map(io.blert.json.SpellDefinition::toCore).collect(Collectors.toList());
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.Getter;

import java.util.Optional;

public enum ChallengeMode {
    NO_MODE(0),

    TOB_ENTRY(10),
    TOB_REGULAR(11),
    TOB_HARD(12),

    COX_REGULAR(20),
    COX_CHALLENGE(21),

    TOA_ENTRY(30),
    TOA_NORMAL(31),
    TOA_EXPERT(32),

    ;

    @Getter
    private final int id;

    ChallengeMode(int id) {
        this.id = id;
    }

    public static Optional<ChallengeMode> parseTob(String string) {
        switch (string.toLowerCase()) {
            case "entry":
            case "story":
                return Optional.of(TOB_ENTRY);
            case "normal":
            case "regular":
                return Optional.of(TOB_REGULAR);
            case "hard":
                return Optional.of(TOB_HARD);
            default:
                return Optional.empty();
        }
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.Getter;
import lombok.NonNull;

import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

/**
 * Represents a set of prayers that can be activated.
 */
@Getter
public class PrayerSet implements Set<Prayer> {
    /**
     * Prayers are stored within a 53-bit integer (Javascript limit), with the highest 3 bits representing the prayer
     * book and the remaining 50 bits representing the prayers that are activated.
     */
    private long value;

    private static final long PRAYER_MASK = 0x1FFFFFFFFFFFFFL;

    public PrayerSet(int prayerBook) {
        this.value = ((long) prayerBook & 0x7) << Prayer.MAX_PRAYERS_PER_BOOK;
    }

    @Override
    public int size() {
        return Long.bitCount(value);
    }

    @Override
    public boolean isEmpty() {
        return (value & PRAYER_MASK) == 0;
    }

    @Override
    public boolean contains(Object o) {
        if (o instanceof Prayer) {
            Prayer prayer = (Prayer) o;
            return (value & (1L << prayer.getId())) != 0;
        }
        return false;
    }

    @NonNull
    @Override
    public Iterator<Prayer> iterator() {
        return new PrayerIterator(value);
    }

    @NonNull
    @Override
    public Prayer @NonNull [] toArray() {
        Prayer[] prayers = new Prayer[size()];
        int i = 0;
        for (Prayer prayer : this) {
            prayers[i++] = prayer;
        }
        return prayers;
    }

    @NonNull
    @Override
    public <T> T @NonNull [] toArray(@NonNull T @NonNull [] ts) {
        if (ts.length < size()) {
            throw new ArrayIndexOutOfBoundsException("Array is too small to store all prayers");
        }
        int i = 0;
        for (Prayer prayer : this) {
            ts[i++] = (T) prayer;
        }
        return ts;
    }

    @Override
    public boolean add(Prayer prayer) {
        if (prayer.getPrayerBook() == getPrayerBook()) {
            value |= 1L << prayer.getId();
            return true;
        }
        return false;
    }

    @Override
    public boolean remove(Object o) {
        if (o instanceof Prayer) {
            Prayer prayer = (Prayer) o;
            if (prayer.getPrayerBook() == getPrayerBook()) {
                value &= ~(1L << prayer.getId());
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean containsAll(@NonNull Collection<?> collection) {
        return collection.stream().anyMatch(this::contains);
    }

    @Override
    public boolean addAll(@NonNull Collection<? extends Prayer> collection) {
        boolean changed = false;
        for (Prayer prayer : collection) {
            changed |= add(prayer);
        }
        return changed;
    }

    @Override
    public boolean retainAll(@NonNull Collection<?> collection) {
        return false;
    }

    @Override
    public boolean removeAll(@NonNull Collection<?> collection) {
        return false;
    }

    @Override
    public void clear() {
        value &= ~PRAYER_MASK;
    }

    public static class PrayerIterator implements Iterator<Prayer> {
        private long remaining;

        private PrayerIterator(long value) {
            remaining = value & PRAYER_MASK;
        }

        @Override
        public boolean hasNext() {
            return remaining != 0;
        }

        @Override
        public Prayer next() {
            long id = Long.numberOfTrailingZeros(remaining);
            remaining &= ~(1L << id);
            return Prayer.withId((int) id);
        }
    }

    public int getPrayerBook() {
        return (int) (value >> Prayer.MAX_PRAYERS_PER_BOOK) & 0x7;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import io.blert.events.ChallengeUpdateEvent;
import io.blert.events.Event;
import io.blert.events.EventHandler;
import io.blert.events.EventType;
import lombok.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.Text;

import javax.annotation.Nullable;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;

@Slf4j
public abstract class RecordableChallenge implements RuneliteEventHandler {
    @Getter
    private final Challenge challenge;
    @Getter
    private @NonNull ChallengeMode challengeMode;

    protected final Client client;

    @Getter
    private final ClientThread clientThread;

    @Setter
    private EventHandler eventHandler;

    @Getter
    private AttackRegistry attackRegistry;

    @Getter
    private SpellRegistry spellRegistry;

    List<Event> pendingEvents = new ArrayList<>();

    @Getter(AccessLevel.PROTECTED)
    private ChallengeState state = ChallengeState.INACTIVE;

    private List<CompletableFuture<Status>> statusUpdateFutures = new ArrayList<>();

    @Getter
    @AllArgsConstructor(access = AccessLevel.PROTECTED)
    public static class Status {
        private final Challenge challenge;
        private final ChallengeMode mode;
        private final Stage stage;
        private final List<String> party;

        @Override
        public String toString() {
            return "Status(" +
                    "challenge=" + challenge +
                    ", mode=" + mode +
                    ", stage=" + stage +
                    ", party=" + party +
                    ')';
        }
    }

    /**
     * Players in the challenge party.
     */
    private final Map<String, Raider> party = new LinkedHashMap<>();

    protected RecordableChallenge(Challenge challenge, Client client, ClientThread clientThread) {
        this.challenge = challenge;
        this.challengeMode = ChallengeMode.NO_MODE;
        this.client = client;
        this.clientThread = clientThread;
    }

    /**
     * Checks if the given world point is within the location of the challenge.
     *
     * @param worldPoint The world point to check.
     * @return True if the world point is within the location of the challenge, false otherwise.
     */
    public abstract boolean containsLocation(WorldPoint worldPoint);

    /**
     * Implementation-specific initialization handler.
     */
    protected abstract void onInitialize();

    /**
     * Implementation-specific termination handler.
     */
    protected abstract void onTerminate();

    /**
     * Implementation-specific game tick handler.
     */
    protected abstract void onTick();

    protected abstract @Nullable Stage getStage();

    public String getName() {
        return challenge.getName();
    }

    public int getScale() {
        return inChallenge() ? party.size() : 0;
    }

    public Collection<Raider> getParty() {
        return party.values();
    }

    public boolean playerIsInChallenge(@Nullable String username) {
        return username != null && party.containsKey(Text.standardize(username));
    }

    public @Nullable Raider getRaider(@Nullable String username) {
        return username != null ? party.get(Text.standardize(username)) : null;
    }

    /**
     * Updates the challenge mode. If the challenge is active and the mode has changed, an update event is dispatched.
     * Updates to {@link ChallengeMode#NO_MODE} are ignored.
     *
     * @param mode The new challenge mode.
     */
    public void updateMode(ChallengeMode mode) {
        if (mode == ChallengeMode.NO_MODE) {
            return;
        }

        if (challengeMode != mode) {
            log.debug("Raid mode set to {}", mode);
            challengeMode = mode;

            if (state == ChallengeState.STARTING || state == ChallengeState.ACTIVE) {
                dispatchEvent(new ChallengeUpdateEvent(mode));
            }
        }
    }

    protected void setState(ChallengeState state) {
        if (this.state == ChallengeState.PREPARING && state != ChallengeState.PREPARING) {
            Status status = currentStatus();
            statusUpdateFutures.forEach(future -> future.complete(status));
            statusUpdateFutures.clear();
        }

        this.state = state;
    }

    protected void addRaider(Raider raider) {
        party.put(Text.standardize(raider.getUsername()), raider);
    }

    protected void resetParty() {
        party.clear();
    }

    public void initialize(EventHandler handler, AttackRegistry attackRegistry, SpellRegistry spellRegistry) {
        this.attackRegistry = attackRegistry;
        this.spellRegistry = spellRegistry;
        onInitialize();
        this.eventHandler = handler;
    }

    public void terminate() {
        onTerminate();

        this.eventHandler = null;
        state = ChallengeState.INACTIVE;
        party.clear();
    }

    public void tick() {
        onTick();
    }

    public boolean inChallenge() {
        return state.inChallenge();
    }

    public Future<Status> getStatus() {
        if (state == ChallengeState.INACTIVE) {
            return CompletableFuture.completedFuture(null);
        }

        if (state == ChallengeState.PREPARING) {
            CompletableFuture<Status> future = new CompletableFuture<>();
            statusUpdateFutures.add(future);
            return future;
        }

        return CompletableFuture.completedFuture(currentStatus());
    }

    public void dispatchEvent(Event event) {
        if (state == ChallengeState.INACTIVE || state == ChallengeState.PREPARING) {
            if (event.getType() != EventType.CHALLENGE_START && event.getType() != EventType.CHALLENGE_END) {
                pendingEvents.add(event);
                return;
            }
        }

        if (eventHandler != null) {
            eventHandler.handleEvent(client.getTickCount(), event);
        }
    }

    protected void dispatchPendingEvents() {
        pendingEvents.forEach(this::dispatchEvent);
        pendingEvents.clear();
    }

    protected void clearPendingEvents() {
        pendingEvents.clear();
    }

    private Status currentStatus() {
        return new Status(challenge, challengeMode, getStage(), new ArrayList<>(party.keySet()));
    }

    /**
     * Returns the currently active data tracker for this challenge, if any.
     */
    @Nullable
    protected abstract DataTracker getActiveTracker();

    @Override
    public void onGameStateChanged(GameStateChanged event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onGameStateChanged(event);
        }
    }

    @Override
    public void onNpcSpawned(NpcSpawned event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onNpcSpawned(event);
        }
    }

    @Override
    public void onNpcDespawned(NpcDespawned event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onNpcDespawned(event);
        }
    }

    @Override
    public void onNpcChanged(NpcChanged event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onNpcChanged(event);
        }
    }

    @Override
    public void onAnimationChanged(AnimationChanged event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onAnimationChanged(event);
        }
    }

    @Override
    public void onProjectileMoved(ProjectileMoved event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onProjectileMoved(event);
        }
    }

    @Override
    public void onChatMessage(ChatMessage event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onChatMessage(event);
        }
    }

    @Override
    public void onHitsplatApplied(HitsplatApplied event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onHitsplatApplied(event);
        }
    }

    @Override
    public void onGameObjectSpawned(GameObjectSpawned event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onGameObjectSpawned(event);
        }
    }

    @Override
    public void onGameObjectDespawned(GameObjectDespawned event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onGameObjectDespawned(event);
        }
    }

    @Override
    public void onGroundObjectSpawned(GroundObjectSpawned event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onGroundObjectSpawned(event);
        }
    }

    @Override
    public void onGroundObjectDespawned(GroundObjectDespawned event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onGroundObjectDespawned(event);
        }
    }

    @Override
    public void onGraphicChanged(GraphicChanged event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onGraphicChanged(event);
        }
    }

    @Override
    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onGraphicsObjectCreated(event);
        }
    }

    @Override
    public void onActorDeath(ActorDeath event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onActorDeath(event);
        }
    }

    @Override
    public void onVarbitChanged(VarbitChanged event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onVarbitChanged(event);
        }
    }

    @Override
    public void onScriptPreFired(ScriptPreFired event) {
        DataTracker tracker = getActiveTracker();
        if (tracker != null) {
            tracker.onScriptPreFired(event);
        }
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.Getter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.kit.KitType;

import javax.annotation.Nullable;

public enum EquipmentSlot {
    // KitType represents an item slot that is visibly rendered on players, so they do not map 1:1 to equipment slots.
    HEAD(EquipmentInventorySlot.HEAD, KitType.HEAD, 0),
    CAPE(EquipmentInventorySlot.CAPE, KitType.CAPE, 1),
    AMULET(EquipmentInventorySlot.AMULET, KitType.AMULET, 2),
    AMMO(EquipmentInventorySlot.AMMO, null, 3),
    WEAPON(EquipmentInventorySlot.WEAPON, KitType.WEAPON, 4),
    TORSO(EquipmentInventorySlot.BODY, KitType.TORSO, 5),
    SHIELD(EquipmentInventorySlot.SHIELD, KitType.SHIELD, 6),
    LEGS(EquipmentInventorySlot.LEGS, KitType.LEGS, 7),
    GLOVES(EquipmentInventorySlot.GLOVES, KitType.HANDS, 8),
    BOOTS(EquipmentInventorySlot.BOOTS, KitType.BOOTS, 9),
    RING(EquipmentInventorySlot.RING, null, 10),
    QUIVER(EquipmentInventorySlot.AMMO, null, 11),
    ;

    @Getter
    private final int inventorySlotIndex;
    @Getter
    private final @Nullable KitType kitType;
    @Getter
    private final int id;

    EquipmentSlot(EquipmentInventorySlot runeliteSlot,
                  @Nullable KitType kitType,
                  int id) {
        this.inventorySlotIndex = runeliteSlot.getSlotIdx();
        this.kitType = kitType;
        this.id = id;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.AccessLevel;
import lombok.Getter;

public enum Prayer {
    THICK_SKIN(0, 0, net.runelite.api.Prayer.THICK_SKIN),
    BURST_OF_STRENGTH(0, 1, net.runelite.api.Prayer.BURST_OF_STRENGTH),
    CLARITY_OF_THOUGHT(0, 2, net.runelite.api.Prayer.CLARITY_OF_THOUGHT),
    SHARP_EYE(0, 3, net.runelite.api.Prayer.SHARP_EYE),
    MYSTIC_WILL(0, 4, net.runelite.api.Prayer.MYSTIC_WILL),
    ROCK_SKIN(0, 5, net.runelite.api.Prayer.ROCK_SKIN),
    SUPERHUMAN_STRENGTH(0, 6, net.runelite.api.Prayer.SUPERHUMAN_STRENGTH),
    IMPROVED_REFLEXES(0, 7, net.runelite.api.Prayer.IMPROVED_REFLEXES),
    RAPID_RESTORE(0, 8, net.runelite.api.Prayer.RAPID_RESTORE),
    RAPID_HEAL(0, 9, net.runelite.api.Prayer.RAPID_HEAL),
    PROTECT_ITEM(0, 10, net.runelite.api.Prayer.PROTECT_ITEM),
    HAWK_EYE(0, 11, net.runelite.api.Prayer.HAWK_EYE),
    MYSTIC_LORE(0, 12, net.runelite.api.Prayer.MYSTIC_LORE),
    STEEL_SKIN(0, 13, net.runelite.api.Prayer.STEEL_SKIN),
    ULTIMATE_STRENGTH(0, 14, net.runelite.api.Prayer.ULTIMATE_STRENGTH),
    INCREDIBLE_REFLEXES(0, 15, net.runelite.api.Prayer.INCREDIBLE_REFLEXES),
    PROTECT_FROM_MAGIC(0, 16, net.runelite.api.Prayer.PROTECT_FROM_MAGIC),
    PROTECT_FROM_MISSILES(0, 17, net.runelite.api.Prayer.PROTECT_FROM_MISSILES),
    PROTECT_FROM_MELEE(0, 18, net.runelite.api.Prayer.PROTECT_FROM_MELEE),
    EAGLE_EYE(0, 19, net.runelite.api.Prayer.EAGLE_EYE),
    MYSTIC_MIGHT(0, 20, net.runelite.api.Prayer.MYSTIC_MIGHT),
    RETRIBUTION(0, 21, net.runelite.api.Prayer.RETRIBUTION),
    REDEMPTION(0, 22, net.runelite.api.Prayer.REDEMPTION),
    SMITE(0, 23, net.runelite.api.Prayer.SMITE),
    PRESERVE(0, 24, net.runelite.api.Prayer.PRESERVE),
    CHIVALRY(0, 25, net.runelite.api.Prayer.CHIVALRY),
    PIETY(0, 26, net.runelite.api.Prayer.PIETY),
    RIGOUR(0, 27, net.runelite.api.Prayer.RIGOUR),
    AUGURY(0, 28, net.runelite.api.Prayer.AUGURY),
    ;

    public static final int PRAYER_BOOK_NORMAL = 0;
    public static final int MAX_PRAYERS_PER_BOOK = 50;

    @Getter(AccessLevel.MODULE)
    private final int prayerBook;
    @Getter(AccessLevel.MODULE)
    private final int id;
    @Getter
    private final net.runelite.api.Prayer runelitePrayer;

    Prayer(int prayerBook, int id, net.runelite.api.Prayer runelitePrayer) {
        this.prayerBook = prayerBook;
        this.id = id;
        this.runelitePrayer = runelitePrayer;
    }

    public static Prayer withId(int id) {
        for (Prayer prayer : values()) {
            if (prayer.id == id) {
                return prayer;
            }
        }
        return null;
    }
}

/*
 * Copyright (c) 2023-2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class Item {
    private int id;
    private int quantity;
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import io.blert.challenges.tob.TobNpc;
import io.blert.events.NpcEvent;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import net.runelite.api.NPC;

/**
 * A {@code TrackedNpc} is an NPC within a PVM challenge room whose data is trackable and reported via
 * {@link NpcEvent}s. The {@code TrackedNpc} wraps an existing Runelite {@link NPC} with additional Blert-specific
 * data fields. Each {@code TrackedNpc} also has an ID which uniquely identifies it among all NPCs within its
 * environment.
 */
public abstract class TrackedNpc {
    /**
     * Properties are an immutable copy of NPC-specific data fields for a {@link TrackedNpc}.
     * <p>
     * Properties are assumed to be immutable by default. If a {@link TrackedNpc}'s state can change over time,
     * the implementation should call {@link TrackedNpc#setUpdatedProperties(boolean)} to indicate when the properties
     * have been changed.
     */
    public abstract static class Properties {
    }

    @Getter
    private final long roomId;

    @Getter
    @Setter
    private @NonNull NPC npc;

    @Getter
    private final @NonNull ChallengeMode mode;

    @Getter
    @Setter
    private Hitpoints hitpoints;

    @Getter
    @Setter
    private int spawnTick;

    @Setter
    private boolean updatedProperties;

    protected TrackedNpc(@NonNull NPC npc, long roomId, Hitpoints hitpoints) {
        this.npc = npc;
        this.mode = ChallengeMode.NO_MODE;
        this.roomId = roomId;
        this.hitpoints = hitpoints;
        this.spawnTick = -1;
        this.updatedProperties = true;
    }

    protected TrackedNpc(@NonNull NPC npc, @NonNull TobNpc tobNpc, long roomId, Hitpoints hitpoints) {
        this.npc = npc;
        this.mode = tobNpc.getMode();
        this.roomId = roomId;
        this.hitpoints = hitpoints;
        this.spawnTick = -1;
        this.updatedProperties = true;
    }

    public boolean hasUpdatedProperties() {
        return updatedProperties;
    }

    /**
     * Returns a snapshot of NPC-specific properties for the NPC at a point in time.
     *
     * @return Copy of the current state of the NPC.
     */
    public abstract @NonNull Properties getProperties();

    public int getNpcId() {
        return npc.getId();
    }

    public String getName() {
        return npc.getName();
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.game.ItemVariationMapping;
import org.apache.commons.lang3.tuple.Pair;

import javax.annotation.Nullable;
import java.util.*;

/**
 * A player in a PvM challenge.
 */
@Slf4j
public class Raider {
    private static final Set<Integer> DIZANAS_QUIVER_IDS = ImmutableSet.<Integer>builder()
            .addAll(ItemVariationMapping.getVariations(ItemVariationMapping.map(ItemID.DIZANAS_QUIVER)))
            .addAll(ItemVariationMapping.getVariations(ItemVariationMapping.map(ItemID.BLESSED_DIZANAS_QUIVER)))
            .addAll(ItemVariationMapping.getVariations(ItemVariationMapping.map(ItemID.DIZANAS_MAX_CAPE)))
            .build();

    // Whether the player is using a continuous animation weapon such as a toxic blowpipe.
    private enum BlowpipeState {
        NOT_PIPING,
        PIPING,
        STOPPED_PIPING,
    }

    @Getter
    private final String username;

    @Getter
    @Setter
    private @Nullable Player player;
    @Getter
    private final boolean localPlayer;

    @Getter
    @Setter
    private boolean active;

    @Getter
    private boolean dead;
    @Getter
    private int deathTick;

    private BlowpipeState blowpiping;

    private Item[] equipment = new Item[EquipmentSlot.values().length];
    @Getter
    private final List<ItemDelta> equipmentChangesThisTick = new ArrayList<>();

    @Getter
    private int animationId;
    @Getter
    private int animationTick;

    private final Map<Integer, ActorSpotAnim> graphicsIds = new HashMap<>();

    @Getter
    private @Nullable AttackDefinition lastAttack;
    @Getter
    private int offCooldownTick;

    /**
     * Map of spell ID to the "off cooldown" tick for that spell.
     * Unlike attacks, these are not real cooldowns, just a minimum interval to
     * distinguish a repeated use.
     */
    private final Map<Integer, Integer> activeSpells = new HashMap<>();
    private @Nullable Pair<Integer, SpellDefinition> activeStall;

    @Getter
    private @Nullable Prayer overheadPrayer;

    public Raider(@NonNull String username, boolean localPlayer) {
        this.username = username;
        this.localPlayer = localPlayer;
        this.active = true;
        this.overheadPrayer = null;
    }

    public Raider(@NonNull Player player, boolean localPlayer) {
        this(Objects.requireNonNull(player.getName()), localPlayer);
        this.player = player;
    }

    public boolean isAlive() {
        return !dead;
    }

    public void setDead(int tick) {
        this.dead = true;
        this.deathTick = tick;
    }

    public boolean isOffCooldownOn(int tick) {
        return offCooldownTick <= tick;
    }

    /**
     * Resets the player's state to what it should be on entry to a new room in the raid.
     */
    public void resetForNewRoom() {
        dead = false;
        deathTick = -1;
        blowpiping = BlowpipeState.NOT_PIPING;
        equipment = new Item[EquipmentSlot.values().length];
        equipmentChangesThisTick.clear();
        animationId = -1;
        animationTick = 0;
        graphicsIds.clear();
        lastAttack = null;
        offCooldownTick = 0;
        activeSpells.clear();
        activeStall = null;
        overheadPrayer = null;
    }

    public boolean isBlowpiping() {
        return blowpiping == BlowpipeState.PIPING;
    }

    /**
     * Returns true if the player was previously blowpiping but switched to a different weapon when they came off
     * cooldown.
     *
     * @return True if the player is no longer blowpiping.
     */
    public boolean stoppedBlowpiping() {
        return blowpiping == BlowpipeState.STOPPED_PIPING;
    }

    public Optional<io.blert.core.Item> getEquippedItem(EquipmentSlot slot) {
        return Optional.ofNullable(equipment[slot.ordinal()]);
    }

    public boolean hasGraphic(int graphicId) {
        return graphicsIds.containsKey(graphicId);
    }

    public Set<Integer> getGraphicIds() {
        return graphicsIds.keySet();
    }

    /**
     * Returns the NPC the player is targeting, if any.
     *
     * @return NPC with which the player is interacting, or empty if the player is either not interacting or
     * interacting with something other than an NPC.
     */
    public Optional<NPC> getTarget() {
        if (player == null) {
            return Optional.empty();
        }

        Actor actor = player.getInteracting();
        return actor instanceof NPC ? Optional.of((NPC) actor) : Optional.empty();
    }

    public void updateState(Client client, Player player, int tick) {
        this.player = player;

        if (blowpiping == BlowpipeState.STOPPED_PIPING) {
            blowpiping = BlowpipeState.NOT_PIPING;
        }

        updateOverheadPrayer();

        graphicsIds.clear();
        for (var spotAnim : player.getSpotAnims()) {
            graphicsIds.put(spotAnim.getId(), spotAnim);
        }

        equipmentChangesThisTick.clear();

        if (localPlayer) {
            updateEquipmentFromLocalPlayer(client);
        } else {
            updateEquipmentFromVisibleItems(client);
        }

        Item newWeapon = equipment[EquipmentSlot.WEAPON.ordinal()];

        if (isBlowpiping() && isOffCooldownOn(tick)) {
            // Some weapon animations are continuous and can't be relied on to
            // determine when a player stops attacking. When a blowpiping player
            // comes off cooldown, infer whether they are continuing to attack or
            // have stopped.
            boolean hasTarget = getTarget().isPresent();
            int newWeaponId = newWeapon != null ? newWeapon.getId() : -1;

            boolean isContinuing = lastAttack != null && lastAttack.hasWeapon(newWeaponId) && hasTarget;

            if (isContinuing) {
                blowpiping = BlowpipeState.PIPING;
            } else if (animationTick != tick) {
                blowpiping = BlowpipeState.STOPPED_PIPING;
            }
        }
    }

    public void recordAttack(int tick, @NonNull AttackDefinition attack) {
        lastAttack = attack;
        offCooldownTick = tick + attack.getCooldown();

        if (attack.isContinuousAnimation()) {
            blowpiping = BlowpipeState.PIPING;
        } else {
            blowpiping = BlowpipeState.NOT_PIPING;
        }

        // A player performing an attack indicates they are no longer stalled.
        if (activeStall != null && activeStall.getLeft() != tick) {
            clearActiveStall();
        }
    }

    /**
     * Attempts to record a spell cast by this player.
     *
     * @param tick             The current tick.
     * @param spell            The spell that was potentially cast.
     * @param matchedGraphicId The graphic ID that matched, or null if matched via animation.
     * @return The spell if it was recorded, or null if it was filtered out (e.g., stale graphic).
     */
    public @Nullable SpellDefinition tryRecordSpell(int tick, @NonNull SpellDefinition spell,
                                                    @Nullable Integer matchedGraphicId) {
        boolean viaAnimation = matchedGraphicId == null && spell.hasAnimation(animationId) && animationTick == tick;

        // A new animation is a reliable indicator for a new spell, so ignore the graphic cooldown.
        if (!viaAnimation) {
            if (matchedGraphicId == null) {
                return null;
            }

            Integer spellOffCooldownTick = activeSpells.get(spell.getId());
            if (spellOffCooldownTick != null && spellOffCooldownTick > tick) {
                return null;
            }

            SpellDefinition.Graphic graphic = spell.getGraphic(matchedGraphicId);
            if (graphic != null) {
                ActorSpotAnim spotAnim = graphicsIds.get(matchedGraphicId);
                if (spotAnim != null && spotAnim.getFrame() > graphic.getMaxFrame()) {
                    return null;
                }
            }
        }

        clearActiveStall();

        if (spell.isStall()) {
            activeStall = Pair.of(tick, spell);
        }

        activeSpells.put(spell.getId(), tick + spell.getCooldown(matchedGraphicId));

        return spell;
    }

    public void setAnimation(int tick, int animationId, boolean isContinuousAnimation) {
        animationTick = tick;
        this.animationId = animationId;

        if (isContinuousAnimation) {
            blowpiping = BlowpipeState.PIPING;
        } else {
            blowpiping = BlowpipeState.NOT_PIPING;
        }
    }

    private void updateEquipmentFromLocalPlayer(Client client) {
        var equippedItems = client.getItemContainer(InventoryID.EQUIPMENT);
        if (equippedItems == null) {
            updateEquipmentFromVisibleItems(client);
            return;
        }

        for (EquipmentSlot slot : EquipmentSlot.values()) {
            net.runelite.api.Item item;

            if (slot == EquipmentSlot.QUIVER) {
                if (!hasQuiver(client)) {
                    continue;
                }
                final int quiverAmmoId = client.getVarpValue(VarPlayer.DIZANAS_QUIVER_ITEM_ID);
                if (quiverAmmoId <= 0) {
                    continue;
                }
                item = new net.runelite.api.Item(quiverAmmoId, client.getVarpValue(VarPlayer.DIZANAS_QUIVER_ITEM_COUNT));
            } else {
                item = equippedItems.getItem(slot.getInventorySlotIndex());
            }

            Item previous = this.equipment[slot.ordinal()];

            if (item != null) {
                if (previous == null || previous.getId() != item.getId()) {
                    equipmentChangesThisTick.add(new ItemDelta(item.getId(), item.getQuantity(), slot.ordinal(), true));
                } else {
                    int delta = item.getQuantity() - previous.getQuantity();
                    if (delta != 0) {
                        equipmentChangesThisTick.add(
                                new ItemDelta(item.getId(), Math.abs(delta), slot.ordinal(), delta > 0));
                    }
                }
                equipment[slot.ordinal()] = new Item(item.getId(), item.getQuantity());
            } else if (previous != null) {
                equipmentChangesThisTick.add(new ItemDelta(previous.getId(), previous.getQuantity(), slot.ordinal(), false));
                equipment[slot.ordinal()] = null;
            }
        }
    }

    private void updateEquipmentFromVisibleItems(Client client) {
        Arrays.stream(EquipmentSlot.values()).filter(slot -> slot.getKitType() != null).forEach(slot -> {
            Item previous = equipment[slot.ordinal()];

            int id = Objects.requireNonNull(player).getPlayerComposition().getEquipmentId(slot.getKitType());
            if (id != -1) {
                var comp = client.getItemDefinition(id);

                if (previous == null || previous.getId() != comp.getId()) {
                    equipmentChangesThisTick.add(new ItemDelta(comp.getId(), 1, slot.ordinal(), true));
                    equipment[slot.ordinal()] = new Item(comp.getId(), 1);
                }
            } else if (previous != null) {
                equipmentChangesThisTick.add(new ItemDelta(previous.getId(), previous.getQuantity(), slot.ordinal(), false));
                equipment[slot.ordinal()] = null;
            }
        });
    }

    private void clearActiveStall() {
        if (activeStall != null) {
            activeSpells.remove(activeStall.getRight().getId());
            activeStall = null;
        }
    }

    private void updateOverheadPrayer() {
        if (player == null) {
            overheadPrayer = null;
            return;
        }

        HeadIcon overheadIcon = player.getOverheadIcon();
        if (overheadIcon == null) {
            overheadPrayer = null;
            return;
        }

        switch (overheadIcon) {
            case MAGIC:
                overheadPrayer = Prayer.PROTECT_FROM_MAGIC;
                break;
            case MELEE:
                overheadPrayer = Prayer.PROTECT_FROM_MELEE;
                break;
            case RANGED:
                overheadPrayer = Prayer.PROTECT_FROM_MISSILES;
                break;
            case REDEMPTION:
                overheadPrayer = Prayer.REDEMPTION;
                break;
            case RETRIBUTION:
                overheadPrayer = Prayer.RETRIBUTION;
                break;
            case SMITE:
                overheadPrayer = Prayer.SMITE;
                break;
            default:
                overheadPrayer = null;
                break;
        }
    }

    private boolean hasQuiver(Client client) {
        var equippedItems = client.getItemContainer(InventoryID.EQUIPMENT);
        if (equippedItems != null) {
            var cape = equippedItems.getItem(EquipmentInventorySlot.CAPE.getSlotIdx());
            if (cape != null && DIZANAS_QUIVER_IDS.contains(cape.getId())) {
                return true;
            }
        }

        var inventoryItems = client.getItemContainer(InventoryID.INVENTORY);
        if (inventoryItems != null) {
            for (var item : inventoryItems.getItems()) {
                if (DIZANAS_QUIVER_IDS.contains(item.getId())) {
                    return true;
                }
            }
        }

        return false;
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import lombok.NonNull;
import net.runelite.api.NPC;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Optional;

public class TrackedNpcCollection implements Collection<TrackedNpc> {
    private final HashMap<Long, TrackedNpc> byRoomId = new HashMap<>();
    private final HashMap<Integer, TrackedNpc> byNpc = new HashMap<>();

    public TrackedNpcCollection() {
    }

    public Optional<TrackedNpc> getByRoomId(long roomId) {
        return Optional.ofNullable(byRoomId.get(roomId));
    }

    public Optional<TrackedNpc> getByNpc(NPC npc) {
        return Optional.ofNullable(byNpc.get(npc.hashCode()));
    }

    @Override
    public int size() {
        return byRoomId.size();
    }

    @Override
    public boolean isEmpty() {
        return byRoomId.isEmpty();
    }

    @Override
    public boolean contains(Object o) {
        if (!(o instanceof TrackedNpc)) {
            return false;
        }

        TrackedNpc trackedNpc = (TrackedNpc) o;
        return byRoomId.containsKey(trackedNpc.getRoomId());
    }

    @NonNull
    @Override
    public Iterator<TrackedNpc> iterator() {
        return byRoomId.values().iterator();
    }

    @NonNull
    @Override
    public TrackedNpc @NonNull [] toArray() {
        return byRoomId.values().toArray(new TrackedNpc[0]);
    }

    @NonNull
    @Override
    public <T> T @NonNull [] toArray(@NonNull T @NonNull [] ts) {
        return byRoomId.values().toArray(ts);
    }

    @Override
    public boolean add(TrackedNpc trackedNpc) {
        byRoomId.put(trackedNpc.getRoomId(), trackedNpc);
        byNpc.put(trackedNpc.getNpc().hashCode(), trackedNpc);
        return true;
    }

    @Override
    public boolean remove(Object o) {
        if (!(o instanceof TrackedNpc)) {
            return false;
        }

        TrackedNpc trackedNpc = (TrackedNpc) o;
        byNpc.remove(trackedNpc.getNpc().hashCode());
        return byRoomId.remove(trackedNpc.getRoomId()) != null;
    }

    @Override
    public boolean containsAll(@NonNull Collection<?> collection) {
        return collection.stream().allMatch(this::contains);
    }

    @Override
    public boolean addAll(@NonNull Collection<? extends TrackedNpc> collection) {
        int sizeBefore = byRoomId.size();
        collection.forEach(this::add);
        return byRoomId.size() != sizeBefore;
    }

    @Override
    public boolean removeAll(@NonNull Collection<?> collection) {
        int sizeBefore = byRoomId.size();
        collection.forEach(this::remove);
        return byRoomId.size() != sizeBefore;
    }

    @Override
    public boolean retainAll(@NonNull Collection<?> collection) {
        int sizeBefore = byRoomId.size();
        byRoomId.values().retainAll(collection);
        byNpc.values().retainAll(collection);
        return byRoomId.size() != sizeBefore;
    }

    @Override
    public void clear() {
        byRoomId.clear();
        byNpc.clear();
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import io.blert.events.*;
import io.blert.util.Location;
import io.blert.util.Tick;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;

import javax.annotation.Nullable;
import java.util.List;
import java.util.Optional;

@Slf4j
public abstract class DataTracker implements RuneliteEventHandler {
    protected enum State {
        NOT_STARTED,
        IN_PROGRESS,
        COMPLETED,
        TERMINATING,
    }

    @Getter(AccessLevel.PROTECTED)
    private final RecordableChallenge challenge;

    protected final Client client;
    protected final ClientThread clientThread;

    @Getter
    private final Stage stage;

    @Getter(AccessLevel.PROTECTED)
    @Setter(AccessLevel.PROTECTED)
    private State state;

    private final SpecialAttackTracker specialAttackTracker = new SpecialAttackTracker(this::onSpecialAttack);

    private int startClientTick;
    @Getter
    private int totalTicks;

    @Getter(AccessLevel.PROTECTED)
    private final TrackedNpcCollection trackedNpcs = new TrackedNpcCollection();

    public DataTracker(RecordableChallenge challenge, Client client, Stage stage) {
        this.challenge = challenge;
        this.client = client;
        this.clientThread = challenge.getClientThread();
        this.state = State.NOT_STARTED;
        this.stage = stage;
    }

    public boolean notStarted() {
        return state == State.NOT_STARTED;
    }

    public boolean inProgress() {
        return state == State.IN_PROGRESS;
    }

    public boolean completed() {
        return state == State.COMPLETED;
    }

    public boolean terminating() {
        return state == State.TERMINATING;
    }

    /**
     * Prepares the tracker for cleanup, preventing any further events from being processed.
     */
    public void terminate() {
        if (getState() == State.IN_PROGRESS) {
            state = State.TERMINATING;
            finish(false);
        } else {
            state = State.TERMINATING;
        }
    }

    public void tick() {
        if (state != State.IN_PROGRESS) {
            return;
        }

        updatePlayers();
        specialAttackTracker.processPendingSpecial();

        challenge.getParty().forEach(this::checkForPlayerActions);

        // Run implementation-specific behavior.
        try {
            onTick();
        } catch (Exception e) {
            log.error("Error during onTick for stage {}", stage, e);
        }

        // Send out an update for every tracked NPC. This must be done after `onTick` to ensure any
        // implementation-specific changes to the NPC are complete.
        trackedNpcs.forEach(this::sendNpcUpdate);
    }

    /**
     * Returns number of ticks the tracker has been active.
     *
     * @return The current tick.
     */
    public int getTick() {
        if (notStarted()) {
            return 0;
        }
        return client.getTickCount() - this.startClientTick;
    }

    /**
     * Gathers information about the stage and dispatches appropriate events. Invoked every tick while the challenge
     * is in progress.
     */
    protected abstract void onTick();

    /**
     * Implementation-specific equivalent of the {@code onGameStateChanged} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onGameState(GameStateChanged event) {
    }

    /**
     * Event handler invoked when a new NPC spawns. If the spawned NPC should be tracked and have its data reported,
     * returns a {@link TrackedNpc} describing it. Otherwise, returns {@link Optional#empty()}, performing any desired
     * actions to handle the spawn.
     *
     * @param event The Runelite NPC spawn event.
     * @return The tracked NPC to track if desired.
     */
    protected abstract Optional<? extends TrackedNpc> onNpcSpawn(NpcSpawned event);

    /**
     * Event handler invoked when an NPC in the room despawns. If the NPC was being tracked, and is now completely
     * dead or otherwise inactive, returns {@code true} to indicate that it should be removed from tracking.
     *
     * @param event      The event.
     * @param trackedNpc The tracked NPC corresponding to the despawned NPC, if it is tracked.
     * @return {@code true} if the NPC should no longer be tracked, {@code false} if it should not (e.g. this despawn
     * indicates a phase change).
     */
    protected abstract boolean onNpcDespawn(NpcDespawned event, @Nullable TrackedNpc trackedNpc);

    /**
     * Implementation-specific equivalent of the {@code onNpcChanged} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onNpcChange(NpcChanged event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onAnimationChanged} Runelite event handler.
     * Should be overriden by implementations which require special animation tracking.
     *
     * @param event The animation event.
     */
    protected void onAnimation(AnimationChanged event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onProjectileMoved} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onProjectile(ProjectileMoved event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onChatMessage} Runelite event handler.
     * Should be overriden by implementations which require special animation tracking.
     *
     * @param event The event.
     */
    protected void onMessage(ChatMessage event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onHitsplatApplied} Runelite event handler.
     * Should be overriden by implementations which require special hitsplat tracking.
     *
     * @param hitsplatApplied The hitsplat event.
     */
    protected void onHitsplat(HitsplatApplied hitsplatApplied) {
    }

    /**
     * Implementation-specific equivalent of the {@code onGameObjectSpawned} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onGameObjectSpawn(GameObjectSpawned event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onGameObjectDespawned} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onGameObjectDespawn(GameObjectDespawned event) {
    }


    /**
     * Implementation-specific equivalent of the {@code onGroundObjectSpawned} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onGroundObjectSpawn(GroundObjectSpawned event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onGroundObjectDespawned} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onGroundObjectDespawn(GroundObjectDespawned event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onGraphicChanged}
     * Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onGraphicChange(GraphicChanged event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onGraphicsObjectCreated} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onGraphicsObjectCreation(GraphicsObjectCreated event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onActorDeath} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onDeath(ActorDeath event) {
    }

    /**
     * Implementation-specific equivalent of the {@code onVarbitChanged} Runelite event handler.
     * Should be overriden by implementations which require special handling.
     *
     * @param event The event.
     */
    protected void onVarbit(VarbitChanged event) {
    }

    protected WorldPoint getWorldLocation(@NonNull Actor actor) {
        return Location.getWorldLocation(client, actor.getWorldLocation());
    }

    protected WorldPoint getWorldLocation(@NonNull TrackedNpc trackedNpc) {
        return getWorldLocation(trackedNpc.getNpc());
    }

    protected WorldPoint getWorldLocation(@NonNull GameObject object) {
        return Location.getWorldLocation(client, object.getWorldLocation());
    }

    protected WorldPoint getWorldLocation(@NonNull GroundObject object) {
        return Location.getWorldLocation(client, object.getWorldLocation());
    }

    /**
     * Sends an event to the registered event handler, if any.
     */
    protected void dispatchEvent(Event event) {
        challenge.dispatchEvent(event);
    }

    protected void start(int tickOffset) {
        this.startClientTick = client.getTickCount() + tickOffset;
        setState(State.IN_PROGRESS);

        client.getTopLevelWorldView().players().forEach(player -> {
            Raider raider = challenge.getRaider(player.getName());
            if (raider != null) {
                raider.setPlayer(player);
                raider.resetForNewRoom();
            }
        });

        dispatchEvent(new StageUpdateEvent(getStage(), 0, StageUpdateEvent.Status.STARTED));
    }

    /**
     * Starts the tracker.
     */
    protected void start() {
        start(0);
    }

    protected void finish(boolean completion) {
        finish(completion, -1, false);
    }

    protected void finish(String inGameTime) {
        var ticks = Tick.fromTimeString(inGameTime);
        if (ticks.isPresent()) {
            finish(true, ticks.get().getLeft(), ticks.get().getRight());
        } else {
            finish(true);
        }
    }

    /**
     * Finishes tracking data for the stage and performs any necessary cleanup.
     *
     * @param completion       Whether the stage was completed successfully.
     * @param inGameStageTicks The number of in-game ticks the stage took to complete, or -1 if the in-game timer is not
     *                         available. If provided, it is used to verify the accuracy of the recorded stage time.
     * @param gameTicksPrecise Whether the in-game tick timer is precise or rounded.
     */
    protected void finish(boolean completion, int inGameStageTicks, boolean gameTicksPrecise) {
        boolean waitToDispatch = true;

        switch (state) {
            case TERMINATING:
                log.debug("Forcefully terminating stage {}", stage);
                waitToDispatch = false;
                break;
            case IN_PROGRESS:
                setState(State.COMPLETED);
                break;
            default:
                return;
        }

        final int lastRecordedRoomTick = getTick();
        boolean accurate;

        totalTicks = lastRecordedRoomTick;

        if (inGameStageTicks != -1) {
            if (inGameStageTicks != lastRecordedRoomTick) {
                log.warn("Stage {} completion time mismatch: in-game room ticks = {}, recorded ticks = {}",
                        stage, inGameStageTicks, lastRecordedRoomTick);
                accurate = false;
                totalTicks = inGameStageTicks;
            } else {
                accurate = true;
            }
        } else {
            log.debug("Stage {} finished in {} unconfirmed ticks ({})",
                    stage, lastRecordedRoomTick, Tick.asTimeString(lastRecordedRoomTick));
            accurate = false;
        }

        boolean spectator = !challenge.playerIsInChallenge(client.getLocalPlayer().getName());
        boolean isWipe = challenge.getParty().stream().allMatch(Raider::isDead);

        if (spectator && !completion && !isWipe) {
            log.info("Spectator left challenge at stage {}", stage);
        } else {
            var status = completion ? StageUpdateEvent.Status.COMPLETED : StageUpdateEvent.Status.WIPED;
            log.info("Stage {} finished, status: {}", stage, status);

            Optional<Integer> gameTicks = inGameStageTicks == -1 ? Optional.empty() : Optional.of(inGameStageTicks);
            Runnable dispatch = () -> challenge.dispatchEvent(
                    new StageUpdateEvent(getStage(), lastRecordedRoomTick, status, accurate, gameTicks, gameTicksPrecise));

            if (waitToDispatch) {
                // Don't send the final room status immediately; allow other pending subscribers to run and dispatch their
                // own events first.
                clientThread.invokeLater(dispatch);
            } else {
                dispatch.run();
            }
        }
    }

    private void updatePlayers() {
        int tick = getTick();

        client.getTopLevelWorldView().players().forEach(player -> {
            Raider raider = challenge.getRaider(player.getName());
            if (raider == null || raider.isDead()) {
                return;
            }

            raider.updateState(client, player, tick);

            dispatchEvent(PlayerUpdateEvent.fromRaider(getStage(), tick, getWorldLocation(player), client, raider));
        });
    }

    private void checkForPlayerActions(@NonNull Raider raider) {
        if (raider.isDead() && raider.getDeathTick() != getTick()) {
            return;
        }

        Player player = raider.getPlayer();
        if (player == null) {
            return;
        }

        checkForPlayerAttack(raider, player);
        checkForPlayerSpell(raider, player);
    }

    private void checkForPlayerSpell(@NonNull Raider raider, @NonNull Player player) {
        final int tick = getTick();
        SpellRegistry spellRegistry = challenge.getSpellRegistry();
        SpellDefinition spell = null;

        if (raider.getAnimationId() != -1) {
            SpellDefinition candidate = spellRegistry.findByAnimation(raider.getAnimationId());
            if (candidate != null) {
                spell = raider.tryRecordSpell(tick, candidate, null);
            } else {
                spell = checkForTargetedPlayerSpell(spellRegistry, raider, player);
            }
        }

        // If no animation match, try to match a non-targeted spell by graphic on the caster.
        // Targeted spells generally apply their graphics on the target.
        if (spell == null) {
            for (int graphicId : raider.getGraphicIds()) {
                SpellDefinition candidate = spellRegistry.findByGraphic(graphicId);
                if (candidate != null && !candidate.isTargeted()) {
                    spell = raider.tryRecordSpell(tick, candidate, graphicId);
                    if (spell != null) {
                        break;
                    }
                }
            }
        }

        if (spell == null) {
            return;
        }

        if (spell.isTargeted()) {
            Actor interacting = player.getInteracting();
            if (interacting == null) {
                dispatchEvent(PlayerSpellEvent.withNoTarget(getStage(), tick, getWorldLocation(player), spell, raider));
                return;
            }

            if (interacting instanceof Player) {
                Player targetPlayer = (Player) interacting;
                dispatchEvent(PlayerSpellEvent.withPlayerTarget(
                        getStage(), tick, getWorldLocation(player), spell, raider, targetPlayer.getName()));
            } else if (interacting instanceof NPC) {
                NPC targetNpc = (NPC) interacting;
                SpellDefinition finalSpell = spell;
                trackedNpcs
                        .getByNpc(targetNpc)
                        .ifPresent(trackedNpc -> dispatchEvent(PlayerSpellEvent.withNpcTarget(
                                getStage(), tick, getWorldLocation(player), finalSpell, raider, trackedNpc)));
            } else {
                dispatchEvent(PlayerSpellEvent.withNoTarget(getStage(), tick, getWorldLocation(player), spell, raider));
            }
        } else {
            dispatchEvent(PlayerSpellEvent.withNoTarget(getStage(), tick, getWorldLocation(player), spell, raider));
        }
    }

    private SpellDefinition checkForTargetedPlayerSpell(
            SpellRegistry spellRegistry, @NonNull Raider raider, @NonNull Player player) {
        Actor interacting = player.getInteracting();
        if (interacting == null) {
            return null;
        }

        List<SpellDefinition> candidates = spellRegistry.getTargetedSpellsByAnimation(raider.getAnimationId());
        for (SpellDefinition targetedCandidate : candidates) {
            boolean interactingHasGraphic = targetedCandidate
                    .getTargetGraphics()
                    .stream()
                    .anyMatch(g -> {
                        for (var spotAnim : interacting.getSpotAnims()) {
                            if (spotAnim.getId() == g.getId() && spotAnim.getFrame() <= g.getMaxFrame()) {
                                return true;
                            }
                        }
                        return false;
                    });
            if (interactingHasGraphic) {
                SpellDefinition spell = raider.tryRecordSpell(getTick(), targetedCandidate, null);
                if (spell != null) {
                    return spell;
                }
            }
        }

        return null;
    }

    private void checkForPlayerAttack(@NonNull Raider raider, @NonNull Player player) {
        int animationId = raider.getAnimationId();
        if (animationId == -1) {
            return;
        }

        final int tick = getTick();

        boolean mayHaveAttacked = raider.isOffCooldownOn(tick) &&
                (raider.getAnimationTick() == tick || raider.isBlowpiping() || raider.stoppedBlowpiping());
        if (!mayHaveAttacked) {
            return;
        }

        WorldPoint point = getWorldLocation(player);

        Optional<NPC> target = raider.getTarget();

        AttackRegistry registry = challenge.getAttackRegistry();
        Optional<AttackDefinition> maybeAttack;
        Optional<Item> weapon = raider.getEquippedItem(EquipmentSlot.WEAPON);
        int weaponId = weapon.map(Item::getId).orElse(-1);

        if (raider.stoppedBlowpiping()) {
            // In some instances, a continuous animation ("blowpiping") overrides
            // another weapon's attack animation when the player attacks right
            // off cooldown. If the player is still using the same animation but
            // has just stopped blowpiping and targeted another NPC, assume that
            // they attacked it with the weapon they're holding.
            if (!registry.isContinuousAnimation(animationId) || target.isEmpty()) {
                return;
            }
            maybeAttack = registry.findSuppressedAttack(weaponId);
        } else {
            maybeAttack = registry.find(weaponId, animationId);
        }

        maybeAttack.ifPresent(attack -> {
            try {
                AttackDefinition finalAttack = attack;
                if (attack.hasProjectile()) {
                    finalAttack = adjustForProjectile(registry, attack, player, weaponId);
                }

                raider.recordAttack(tick, finalAttack);

                TrackedNpc roomTarget = target.flatMap(trackedNpcs::getByNpc).orElse(null);
                int distanceToNpc = target.map(npc -> npc.getWorldArea().distanceTo2D(player.getWorldArea())).orElse(-1);
                dispatchEvent(new PlayerAttackEvent(getStage(), tick, point, finalAttack, weapon.orElse(null),
                        raider, roomTarget, distanceToNpc));
            } catch (Exception e) {
                log.error("Error processing attack {} for {} on tick {}", attack, raider.getUsername(), tick, e);
            }
        });
    }

    /**
     * Adjusts the given attack definition based on any projectiles currently
     * in-flight from the player.
     *
     * @param registry The attack registry.
     * @param attack   Initial attack determined by weapon and animation.
     * @param player   The player performing the attack.
     * @param weaponId The ID of the weapon the player is holding.
     * @return A modified attack definition if a distinguishing projectile is
     * found, or the original attack definition otherwise.
     */
    private AttackDefinition adjustForProjectile(AttackRegistry registry,
                                                 AttackDefinition attack,
                                                 Player player,
                                                 int weaponId) {
        List<AttackDefinition> possibleAttacks =
                registry.allWithAnimations(attack.getAnimationIds());

        for (Projectile p : client.getProjectiles()) {
            for (AttackDefinition candidate : possibleAttacks) {
                AttackDefinition.Projectile expectedProjectile = candidate.getProjectileForWeapon(weaponId);
                if (expectedProjectile != null &&
                        projectileMatches(p, expectedProjectile, player)) {
                    return candidate;
                }
            }
        }

        return attack;
    }

    private boolean projectileMatches(Projectile p,
                                      AttackDefinition.Projectile projectile,
                                      Player player) {
        if (p.getId() != projectile.getId()) {
            return false;
        }

        WorldPoint origin = Location.getWorldLocation(client, p.getSourcePoint());
        boolean originatesFromPlayer =
                origin == null || origin.distanceTo2D(getWorldLocation(player)) == 0;
        boolean startCycleMatches = p.getStartCycle() - client.getGameCycle() == projectile.getStartCycleOffset();

        return originatesFromPlayer && startCycleMatches;
    }

    /**
     * Sends an {@link NpcEvent} about an NPC in the room.
     */
    protected void sendNpcUpdate(TrackedNpc trackedNpc) {
        if (trackedNpc.getNpc().getId() == -1) {
            return;
        }

        final int tick = getTick();
        WorldPoint point = getWorldLocation(trackedNpc);

        if (trackedNpc.getSpawnTick() == tick) {
            dispatchEvent(NpcEvent.spawn(getStage(), tick, point, trackedNpc));
        } else {
            dispatchEvent(NpcEvent.update(getStage(), tick, point, trackedNpc));
        }

        trackedNpc.setUpdatedProperties(false);
    }

    protected void addTrackedNpc(TrackedNpc trackedNpc) {
        boolean existing = trackedNpcs.remove(trackedNpc);
        if (!existing) {
            trackedNpc.setSpawnTick(getTick());
        }
        trackedNpcs.add(trackedNpc);

        if (notStarted()) {
            // NPCs which spawn before the room begins must be reported immediately as the `onTick` handler
            // is not yet active.
            dispatchEvent(NpcEvent.spawn(getStage(), 0, getWorldLocation(trackedNpc), trackedNpc));
        }

        challenge.updateMode(trackedNpc.getMode());
    }

    protected void despawnTrackedNpc(TrackedNpc trackedNpc) {
        if (trackedNpcs.remove(trackedNpc)) {
            dispatchEvent(NpcEvent.death(getStage(), getTick(), getWorldLocation(trackedNpc), trackedNpc));
        }
    }

    protected long generateRoomId(@NonNull NPC npc) {
        return npc.getIndex();
    }

    private void onSpecialAttack(SpecialAttackTracker.SpecialAttack spec) {
        var weapon = client.getItemDefinition(spec.getWeapon().getId());
        log.debug("Hit a {} with {} on {}", spec.getDamage(), weapon.getName(), spec.getTarget().getName());
    }

    public final void onGameStateChanged(GameStateChanged event) {
        if (terminating()) {
            return;
        }

        onGameState(event);
    }

    public final void onNpcSpawned(NpcSpawned event) {
        if (terminating()) {
            return;
        }

        onNpcSpawn(event).ifPresent(this::addTrackedNpc);
    }

    @Override
    public final void onNpcDespawned(NpcDespawned event) {
        if (terminating()) {
            return;
        }

        Optional<TrackedNpc> maybeTrackedNpc = trackedNpcs.getByNpc(event.getNpc());
        if (onNpcDespawn(event, maybeTrackedNpc.orElse(null))) {
            maybeTrackedNpc.ifPresent(this::despawnTrackedNpc);
        }
    }

    @Override
    public final void onNpcChanged(NpcChanged event) {
        if (!terminating()) {
            onNpcChange(event);
        }
    }

    @Override
    public final void onAnimationChanged(AnimationChanged event) {
        if (getState() != State.IN_PROGRESS) {
            return;
        }

        Actor actor = event.getActor();
        if (actor instanceof Player) {
            Raider raider = challenge.getRaider(actor.getName());
            if (raider != null) {
                int animationId = actor.getAnimation();
                boolean isContinuous = challenge.getAttackRegistry().isContinuousAnimation(animationId);
                raider.setAnimation(getTick(), animationId, isContinuous);
            }
        }

        onAnimation(event);
    }

    @Override
    public final void onProjectileMoved(ProjectileMoved event) {
        if (!terminating()) {
            onProjectile(event);
        }
    }

    @Override
    public final void onChatMessage(ChatMessage event) {
        if (state == State.IN_PROGRESS || event.getType() == ChatMessageType.GAMEMESSAGE) {
            onMessage(event);
        }
    }

    @Override
    public final void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        if (getState() != State.IN_PROGRESS) {
            return;
        }

        Actor target = hitsplatApplied.getActor();
        Hitsplat hitsplat = hitsplatApplied.getHitsplat();
        if (hitsplat.isMine() && target != client.getLocalPlayer()) {
            specialAttackTracker.recordHitsplat((NPC) target, hitsplat, client.getTickCount());
        }

        if (target instanceof NPC) {
            trackedNpcs.getByNpc((NPC) target).ifPresent(trackedNpc -> {
                if (hitsplat.getHitsplatType() == HitsplatID.HEAL) {
                    trackedNpc.getHitpoints().boost(hitsplat.getAmount());
                } else {
                    trackedNpc.getHitpoints().drain(hitsplat.getAmount());
                }
            });
        }

        onHitsplat(hitsplatApplied);
    }

    @Override
    public final void onGameObjectSpawned(GameObjectSpawned event) {
        if (!terminating()) {
            onGameObjectSpawn(event);
        }
    }

    @Override
    public final void onGameObjectDespawned(GameObjectDespawned event) {
        if (!terminating()) {
            onGameObjectDespawn(event);
        }
    }

    @Override
    public final void onGroundObjectSpawned(GroundObjectSpawned event) {
        if (!terminating()) {
            onGroundObjectSpawn(event);
        }
    }

    @Override
    public final void onGroundObjectDespawned(GroundObjectDespawned event) {
        if (!terminating()) {
            onGroundObjectDespawn(event);
        }
    }

    @Override
    public final void onGraphicChanged(GraphicChanged event) {
        if (!terminating()) {
            onGraphicChange(event);
        }
    }

    @Override
    public final void onGraphicsObjectCreated(GraphicsObjectCreated event) {
        if (!terminating()) {
            onGraphicsObjectCreation(event);
        }
    }

    @Override
    public final void onActorDeath(ActorDeath event) {
        if (terminating()) {
            return;
        }

        if (event.getActor() instanceof Player) {
            Raider raider = challenge.getRaider(event.getActor().getName());
            if (raider != null) {
                int tick = getTick();
                raider.setDead(tick);
                dispatchEvent(new PlayerDeathEvent(
                        getStage(), tick, getWorldLocation(event.getActor()), raider.getUsername()));
            }
        }

        onDeath(event);
    }

    @Override
    public final void onVarbitChanged(VarbitChanged varbitChanged) {
        if (getState() != State.IN_PROGRESS) {
            return;
        }

        if (varbitChanged.getVarpId() == VarPlayer.SPECIAL_ATTACK_PERCENT) {
            int percent = varbitChanged.getValue();
            int oldPercent = specialAttackTracker.updateSpecialPercent(percent);
            if (oldPercent != -1 && percent >= oldPercent) {
                // This is a special attack regen, not drain. Ignore it.
                return;
            }

            int specTick = client.getTickCount();
            clientThread.invokeLater(() -> {
                Actor target = client.getLocalPlayer().getInteracting();
                if (target instanceof NPC) {
                    var equipment = client.getItemContainer(InventoryID.EQUIPMENT);
                    if (equipment == null) {
                        return;
                    }

                    net.runelite.api.Item weapon = equipment.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
                    if (weapon != null) {
                        specialAttackTracker.recordSpecialUsed((NPC) target, weapon, specTick);
                    }
                }
            });
        }

        onVarbit(varbitChanged);
    }
}

/*
 * Copyright (c) 2025 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.core;

import com.google.gson.Gson;
import lombok.AllArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.io.InputStream;
import java.util.*;

@Slf4j
public class AttackRegistry {
    private static final String BUNDLED_ATTACKS_RESOURCE = "/attacks.json";

    private static final int UNKNOWN_PROTO_ID = 0;

    @AllArgsConstructor
    private static class State {
        private volatile Map<Integer, List<AttackDefinition>> byAnimationId;

        private volatile Set<Integer> continuousAnimationIds;

        /**
         * Attacks that can be suppressed by continuous animations.
         */
        private volatile List<AttackDefinition> suppressableAttacks;
    }

    @Setter
    private Gson gson;

    private volatile State state = new State(Map.of(), Set.of(), List.of());

    /**
     * The UNKNOWN attack definition.
     */
    private AttackDefinition unknownAttack;

    public AttackRegistry() {
        // Initialize with a default UNKNOWN attack.
        unknownAttack = new AttackDefinition(
                UNKNOWN_PROTO_ID,
                "UNKNOWN",
                new int[]{-1},
                new int[]{-1},
                0,
                null,
                false,
                AttackDefinition.Category.MELEE
        );
    }

    /**
     * Loads bundled attack definitions from the JAR resources.
     */
    public void loadDefaults() {
        InputStream inputStream = getClass().getResourceAsStream(BUNDLED_ATTACKS_RESOURCE);
        if (inputStream == null) {
            log.warn("Bundled attacks.json not found; initializing empty attack registry");
            return;
        }

        try {
            List<AttackDefinition> definitions = AttackDefinition.loadFromJson(gson, inputStream);
            updateDefinitions(definitions);
            log.info("Loaded {} bundled attack definitions", definitions.size());
        } catch (Exception e) {
            log.error("Failed to load bundled attack definitions", e);
        }
    }

    /**
     * Updates the registry with new attack definitions from the server, replacing existing ones.
     *
     * @param definitions The new definitions.
     */
    public void updateFromServer(List<AttackDefinition> definitions) {
        updateDefinitions(definitions);
        log.info("Updated attack registry with {} definitions from server", definitions.size());
    }

    private void updateDefinitions(List<AttackDefinition> definitions) {
        Map<Integer, List<AttackDefinition>> newByAnimationId = new HashMap<>();
        Set<Integer> newContinuousAnimationIds = new HashSet<>();
        List<AttackDefinition> newSuppressableAttacks = new ArrayList<>();

        for (AttackDefinition def : definitions) {
            for (int animationId : def.getAnimationIds()) {
                newByAnimationId.computeIfAbsent(animationId, k -> new ArrayList<>()).add(def);
            }

            if (def.isContinuousAnimation()) {
                for (int animationId : def.getAnimationIds()) {
                    newContinuousAnimationIds.add(animationId);
                }
            }

            // Throwing chins can be suppressed by continuous animations.
            // TODO(frolv): Barrages can also be suppressed, but it requires
            //   checking for applied graphics.
            if (def.getName() != null && def.getName().startsWith("CHIN_")) {
                newSuppressableAttacks.add(def);
            }

            if (def.getProtoId() == UNKNOWN_PROTO_ID) {
                unknownAttack = def;
            }
        }

        this.state = new State(newByAnimationId, newContinuousAnimationIds, newSuppressableAttacks);
    }

    /**
     * Finds a player attack based on a weapon and animation.
     *
     * @param weaponId    ID of the weapon used.
     * @param animationId ID of the animation played with the attack.
     * @return If the animation ID does not map to any known attack, returns {@code Optional.empty()}.
     * Otherwise, returns the attack if the weapon ID is consistent with the animation,
     * or the UNKNOWN attack if not.
     */
    public Optional<AttackDefinition> find(int weaponId, int animationId) {
        List<AttackDefinition> candidates = state.byAnimationId.get(animationId);
        if (candidates == null) {
            return Optional.empty();
        }

        for (AttackDefinition attack : candidates) {
            if (attack.hasWeapon(weaponId)) {
                return Optional.of(attack);
            }
        }

        for (AttackDefinition attack : candidates) {
            if (attack.isUnknown()) {
                return Optional.of(attack);
            }
        }

        return Optional.of(unknownAttack);
    }

    /**
     * Finds an attack that may be hidden after a continuous animation.
     *
     * @param weaponId ID of the weapon used.
     * @return A player attack matching the weapon that can be suppressed, or
     * empty if none.
     */
    public Optional<AttackDefinition> findSuppressedAttack(int weaponId) {
        for (AttackDefinition attack : state.suppressableAttacks) {
            if (attack.hasWeapon(weaponId)) {
                return Optional.of(attack);
            }
        }
        return Optional.empty();
    }

    /**
     * Returns whether the given animation ID is continuous.
     *
     * @param animationId ID of the animation to check.
     * @return true if the animation is a continuous animation, false otherwise.
     */
    public boolean isContinuousAnimation(int animationId) {
        return state.continuousAnimationIds.contains(animationId);
    }

    /**
     * Returns all attacks that share any of the given animation IDs.
     *
     * @param animationIds Animation IDs to include.
     * @return All matching attack definitions.
     */
    public List<AttackDefinition> allWithAnimations(int[] animationIds) {
        Set<AttackDefinition> result = new LinkedHashSet<>();
        for (int animationId : animationIds) {
            List<AttackDefinition> candidates = state.byAnimationId.get(animationId);
            if (candidates != null) {
                result.addAll(candidates);
            }
        }
        return new ArrayList<>(result);
    }
}
/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.util;

import junit.framework.TestCase;
import org.apache.commons.lang3.tuple.Pair;

public class TickTest extends TestCase {
    public void testAsTimeString() {
        assertEquals("0:00.00", Tick.asTimeString(0));
        assertEquals("0:00.60", Tick.asTimeString(1));
        assertEquals("0:06.00", Tick.asTimeString(10));
        assertEquals("1:00.00", Tick.asTimeString(100));
        assertEquals("1:00.60", Tick.asTimeString(101));
        assertEquals("2:57.60", Tick.asTimeString(296));
        assertEquals("9:59.40", Tick.asTimeString(999));
        assertEquals("10:00.00", Tick.asTimeString(1000));
        assertEquals("1:00:00.00", Tick.asTimeString(6000));
        assertEquals("5:59:59.40", Tick.asTimeString(35999));
        assertEquals("16:39:59.40", Tick.asTimeString(99999));
    }

    public void testFromTimeString() {
        assertTrue(Tick.fromTimeString("").isEmpty());

        assertEquals(Pair.of(0, true), Tick.fromTimeString("0:00.00").orElseThrow());
        assertEquals(Pair.of(1, true), Tick.fromTimeString("0:00.60").orElseThrow());
        assertEquals(Pair.of(10, true), Tick.fromTimeString("0:06.00").orElseThrow());
        assertEquals(Pair.of(100, true), Tick.fromTimeString("1:00.00").orElseThrow());
        assertEquals(Pair.of(101, true), Tick.fromTimeString("1:00.60").orElseThrow());
        assertEquals(Pair.of(296, true), Tick.fromTimeString("2:57.60").orElseThrow());
        assertEquals(Pair.of(999, true), Tick.fromTimeString("9:59.40").orElseThrow());
        assertEquals(Pair.of(1000, true), Tick.fromTimeString("10:00.00").orElseThrow());
        assertEquals(Pair.of(6000, true), Tick.fromTimeString("1:00:00.00").orElseThrow());
        assertEquals(Pair.of(35999, true), Tick.fromTimeString("5:59:59.40").orElseThrow());
        assertEquals(Pair.of(99999, true), Tick.fromTimeString("16:39:59.40").orElseThrow());

        // Non-precise time strings without centiseconds.
        assertEquals(Pair.of(0, false), Tick.fromTimeString("0:00").orElseThrow());
        assertEquals(Pair.of(2, false), Tick.fromTimeString("0:01").orElseThrow());
        assertEquals(Pair.of(4, false), Tick.fromTimeString("0:02").orElseThrow());
        assertEquals(Pair.of(10, false), Tick.fromTimeString("0:06").orElseThrow());
        assertEquals(Pair.of(99, false), Tick.fromTimeString("0:59").orElseThrow());
        assertEquals(Pair.of(100, false), Tick.fromTimeString("1:00").orElseThrow());
        assertEquals(Pair.of(295, false), Tick.fromTimeString("2:57").orElseThrow());
        assertEquals(Pair.of(297, false), Tick.fromTimeString("2:58").orElseThrow());
        assertEquals(Pair.of(999, false), Tick.fromTimeString("9:59").orElseThrow());
        assertEquals(Pair.of(1000, false), Tick.fromTimeString("10:00").orElseThrow());
        assertEquals(Pair.of(6000, false), Tick.fromTimeString("1:00:00").orElseThrow());
        assertEquals(Pair.of(35997, false), Tick.fromTimeString("5:59:58").orElseThrow());
        assertEquals(Pair.of(99999, false), Tick.fromTimeString("16:39:59").orElseThrow());
    }
}

/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert.util;

import junit.framework.TestCase;

import java.util.concurrent.atomic.AtomicBoolean;

public class DeferredTaskTest extends TestCase {

    public void testTick() {
        AtomicBoolean complete = new AtomicBoolean(false);
        DeferredTask task = new DeferredTask(() -> complete.set(true), 5);
        for (int i = 0; i < 5; i++) {
            assertFalse(complete.get());
            task.tick();
        }
        assertTrue(complete.get());
    }

    public void testCancel() {
        AtomicBoolean complete = new AtomicBoolean(false);
        DeferredTask task = new DeferredTask(() -> complete.set(true), 5);
        task.tick();  // 4
        assertFalse(complete.get());
        task.tick();  // 3
        assertFalse(complete.get());
        task.tick();  // 2
        assertFalse(complete.get());
        task.tick();  // 1
        assertFalse(complete.get());
        task.cancel();
        task.tick();  // 0
        assertFalse(complete.get());
    }

    public void testReset() {
        AtomicBoolean complete = new AtomicBoolean(false);
        DeferredTask task = new DeferredTask(() -> complete.set(true), 3);

        task.tick();  // 2
        assertFalse(complete.get());
        task.tick();  // 1
        assertFalse(complete.get());

        task.reset(3);
        task.tick();  // 2
        assertFalse(complete.get());
        task.tick();  // 1
        assertFalse(complete.get());
        task.tick();  // 0
        assertTrue(complete.get());

        complete.set(false);
        task.reset(1);
        task.tick();  // 0
        assertTrue(complete.get());
    }
}
/*
 * Copyright (c) 2024 Alexei Frolov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the “Software”), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package io.blert;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

import java.util.Arrays;

public class BlertPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(BlertPlugin.class);
        String[] debugArgs = Arrays.copyOf(args, args.length + 1);
        debugArgs[args.length] = "--developer-mode";
        RuneLite.main(debugArgs);
    }
}
