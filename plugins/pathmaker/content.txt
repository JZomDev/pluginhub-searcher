/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.function.Consumer;
import java.util.function.Function;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

public class PanelBuildUtils
{
	private static final ImageIcon EXPORT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "export.png"));
	private static final BufferedImage BRUSH_IMAGE = ImageUtil.loadImageResource(PathmakerPlugin.class, "brush.png");
	private static final ImageIcon EXPAND_ICON;
	private static final ImageIcon COLLAPSE_ICON;
	//	private static final ImageIcon LOOP_ON_ICON;
//	private static final ImageIcon LOOP_OFF_ICON;
	private static final ImageIcon EYE_OPEN_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "eye_open.png"));
	private static final ImageIcon EYE_CLOSED_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "eye_closed.png"));
	private static final BufferedImage crossImage = ImageUtil.loadImageResource(PathmakerPlugin.class, "cross.png");
//	private static final ImageIcon OFFSET_LEFT_ICON;
//	private static final ImageIcon OFFSET_MIDDLE_ICON;
//	private static final ImageIcon OFFSET_RIGHT_ICON;
//	private static final ImageIcon PERSON_ICON;
//	private static final ImageIcon PERSON_GREEN_ICON;
//	private static final ImageIcon PERSON_GREEN_LINES_ICON;

	static final int PANEL_WIDTH = 225; // Client.PANEL_WIDTH = 225
	static final int ICON_SIZE = 18;

	static
	{
		BufferedImage upArrowImage = ImageUtil.loadImageResource(PathmakerPlugin.class, "up_arrow.png");
		COLLAPSE_ICON = new ImageIcon(upArrowImage);
		EXPAND_ICON = new ImageIcon(ImageUtil.flipImage(upArrowImage, false, true));
	}

	// EXPAND

	static JButton createExpandToggleButton(boolean expanded, int width, int height, String panelTypeText)
	{
		width = width < 0 ? ICON_SIZE : width;
		height = height < 0 ? ICON_SIZE : height;

		JButton expandToggle = new JButton(expanded ? COLLAPSE_ICON : EXPAND_ICON);
		expandToggle.setPreferredSize(new Dimension(width, height));
		expandToggle.setToolTipText((expanded ? "Collapse" : "Expand") + " " + panelTypeText);

		return expandToggle;
	}

	static void getExpandToggleAction(JPanel panel, JButton expandToggleButton, boolean expanded, String panelTypeText)
	{
		for (int i = 0; i < panel.getComponentCount(); i++)
		{
			panel.getComponent(i).setVisible(expanded);
		}

		expandToggleButton.setIcon(expanded ? COLLAPSE_ICON : EXPAND_ICON);
		expandToggleButton.setToolTipText((expanded ? "Collapse" : "Expand") + " " + panelTypeText);
	}

	static void toggleExpandPath(PathmakerPath path, JPanel pathContainer, JButton expandToggle)
	{
		path.panelExpanded = !path.panelExpanded;
		getExpandToggleAction(pathContainer, expandToggle, path.panelExpanded, "path");
	}

	// VISIBILITY

	static JButton createVisibilityToggleButton(boolean hidden, int width, int height, String panelTypeText)
	{
		width = width < 0 ? ICON_SIZE : width;
		height = height < 0 ? ICON_SIZE : height;

		JButton visibilityToggle = new JButton(hidden ? EYE_CLOSED_ICON : EYE_OPEN_ICON);
		visibilityToggle.setPreferredSize(new Dimension(width, height));
		visibilityToggle.setToolTipText((hidden ? "Show" : "Hide") + " " + panelTypeText);
//		visibilityToggle.addActionListener(actionEvent ->
//		{
//			//path.hidden = !path.hidden;
//			getVisibilityAction(visibilityToggle, hidden, panelTypeText);
//		});
		return visibilityToggle;
	}

	static void toggleVisibilityPath(PathmakerPath path, JButton visibilityToggle)
	{
		path.hidden = !path.hidden;
		getVisibilityAction(visibilityToggle, path.hidden, "path");
	}

	static void getVisibilityAction(JButton visibilityToggle, boolean hidden, String panelTypeText)
	{
		visibilityToggle.setIcon(hidden ? EYE_CLOSED_ICON : EYE_OPEN_ICON);
		visibilityToggle.setToolTipText((hidden ? "Show" : "Hide") + " " + panelTypeText);
	}

	// COLOR PICKER

	static JButton createColorPickerButton(int width, int height, Color currentColor, String panelTypeText)
	{
		width = width < 0 ? ICON_SIZE : width;
		height = height < 0 ? ICON_SIZE : height;

		JButton colorPickerButton = new JButton();
		colorPickerButton.setPreferredSize(new Dimension(width, height));
		colorPickerButton.setIcon(new ImageIcon(ImageUtil.recolorImage(BRUSH_IMAGE, currentColor)));
		colorPickerButton.setToolTipText("Choose " + panelTypeText + " color");
		return colorPickerButton;
	}

	static JButton createDeleteButton(PathmakerPlugin plugin, int width, int height, JPanel panel, String itemName, String typeString, boolean redCross)
	{
		JButton deletePathButton = new JButton();
		ImageIcon crossIcon = redCross ? new ImageIcon(ImageUtil.recolorImage(crossImage, Color.RED)) : new ImageIcon(crossImage);
		deletePathButton.setIcon(crossIcon);
		deletePathButton.setToolTipText("Delete " + typeString);
		deletePathButton.setPreferredSize(new Dimension(width, height));
		String warningMsg = "Are you sure you want to permanently delete " + typeString + ": " + itemName + "?";
		Runnable deleteRunnable = getDeleteButtonRunnable(plugin, typeString, itemName);
		deletePathButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				int confirm = JOptionPane.showConfirmDialog(panel,
					warningMsg + (typeString.equals("group") ? "\n\nWARNING: This will also delete ALL ("+ ((GroupPanel) panel).getPathPanels().length +") of the paths within." : ""),
					"Warning", JOptionPane.OK_CANCEL_OPTION);

				if (confirm == 0)
				{
					deleteRunnable.run();
					plugin.rebuildPanel(true);
				}
			}
		});
		return deletePathButton;
	}

	static private Runnable getDeleteButtonRunnable(PathmakerPlugin plugin, String typeString, String itemName)
	{
		switch (typeString)
		{
			case "group":
			{
				return () -> {
					for (Component panel : plugin.pluginPanel.pathView.getComponents())
					{
						if (panel instanceof GroupPanel &&  ((GroupPanel) panel).getGroupName().equals(itemName))
						{
							for (Component memberPanel : ((GroupPanel) panel).getPathPanels())
							{
								plugin.removePath(((PathPanel) memberPanel).getPathLabel());
							}
						}
					}
				};
			}
			default: // Path
			{
				return () -> plugin.removePath(itemName);
			}
		}
	}

	static RuneliteColorPicker getColorPicker(ColorPickerManager colorPickerManager, Color color, JPanel owner, Component relativeTo, String panelTypeText)
	{
		RuneliteColorPicker colorPicker = colorPickerManager.create(
			SwingUtilities.windowForComponent(owner), color, panelTypeText + " color",true);
		colorPicker.setLocationRelativeTo(relativeTo);
		return colorPicker;
	}

	static ImageIcon getRecoloredBrushIcon(Color color)
	{
		return new ImageIcon(ImageUtil.recolorImage(PanelBuildUtils.BRUSH_IMAGE, color));
	}

	// EXPORT

	static JButton createExportButton(int width, int height, Gson gson, String panelTypeText)
	{
		JButton exportButton = new JButton();
		exportButton.setIcon(EXPORT_ICON);
		exportButton.setToolTipText("Export " + panelTypeText + " to clipboard");
		exportButton.setPreferredSize(new Dimension(width, height));
		return exportButton;
	}

	static void getExportButtonAction(Gson gson, String exportName, JsonObject object)
	{
		JsonObject exportPath = new JsonObject();
		exportPath.add(exportName, object);

		StringSelection json = new StringSelection(gson.toJson(exportPath));
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(json, null);
	}

	static JMenu createDrawToPlayerMenu(PathmakerPlugin plugin, PathmakerPath path, String pathName)
	{
		JMenu connectToPlayerSubMenu = new JMenu("Connect points to player");

		Function<Integer, MouseAdapter> drawToPlayerAdapter = mode ->
			new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					path.drawToPlayer = mode;
					plugin.savePath(pathName);
					plugin.rebuildPanel(false);
				}
			};

		JMenuItem connectNoPointsToPlayer = new JMenuItem("No points");
		connectNoPointsToPlayer.addMouseListener(drawToPlayerAdapter.apply(PathPanel.drawFromPlayerMode.NEVER.ordinal()));

		JMenuItem connectFirstPointToPlayer = new JMenuItem("First point only");
		connectFirstPointToPlayer.addMouseListener(drawToPlayerAdapter.apply(PathPanel.drawFromPlayerMode.START_ONLY.ordinal()));

		JMenuItem connectAllPointsToPlayer = new JMenuItem("All points");
		connectAllPointsToPlayer.addMouseListener(drawToPlayerAdapter.apply(PathPanel.drawFromPlayerMode.ALWAYS.ordinal()));

		connectToPlayerSubMenu.add(connectNoPointsToPlayer);
		connectToPlayerSubMenu.add(connectFirstPointToPlayer);
		connectToPlayerSubMenu.add(connectAllPointsToPlayer);
		return connectToPlayerSubMenu;
	}
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;
import javax.annotation.Nullable;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class DropAdapter extends MouseAdapter
{
	PathmakerPlugin plugin;
	JPanel parentPanel;
	JPanel panel;
	@Nullable String panelLabel;
	int margin;
	int trueIndexInParent;

	@Nullable String availableGroupName = null;

	DropAdapter(PathmakerPlugin plugin, JPanel parentPanel, JPanel panel, int trueIndexInParent, @Nullable String panelLabel, int margin)
	{
		this.plugin = plugin;
		this.parentPanel = parentPanel;
		this.panel = panel;
		this.trueIndexInParent = trueIndexInParent;
		this.panelLabel = panelLabel;
		this.margin = margin;
	}

	@Override
	public void mouseReleased(MouseEvent e)
	{
		panel.setBorder(BorderFactory.createEmptyBorder());
		panel.repaint();

		int targetIndex = MouseAdapterUtils.getHoveredPathIndex(e, parentPanel);
		JPanel targetPanel = MouseAdapterUtils.getHoveredPathPanel(parentPanel, targetIndex);
		int mouseOnBorder = MouseAdapterUtils.isMouseHoveringPathBorder(e, parentPanel, targetPanel, margin);

		targetIndex = MouseAdapterUtils.getTrueIndexInView(parentPanel, targetIndex);

		// DEBUG
		//printDebug(targetPanel, targetIndex);

		// Mouse is on a PathPanel
		if (mouseOnBorder == 0)
		{
			// Skip if a group is dropped directly on top of another group or path
			if (panel instanceof GroupPanel)
				return;

			PathmakerPath draggedPath = plugin.getStoredPaths().get(panelLabel);

			// Create group if dropped on another path
			if (targetPanel instanceof PathPanel)
			{
				String targetName = ((PathPanel) targetPanel).getPathLabel();
				PathmakerPath targetPath = plugin.getStoredPaths().get(targetName);

				// Create a new group with target as the first member
				if(availableGroupName == null)
				{
					log.debug("Available group name is null");
				}
				targetPath.pathGroup = availableGroupName;
				draggedPath.pathGroup = availableGroupName;

				// Moving target path position below target panel.
				targetIndex += trueIndexInParent > targetIndex ? 1 : 0;

			}
			else // Add panel to existing group
			{
				// Skip if it already belongs to the group
				String groupName = ((GroupPanel) targetPanel).getGroupName();
				if (groupName.equals(draggedPath.pathGroup))
					return;
				// Set panel index to be bottom of the group
				draggedPath.pathGroup = groupName;
				targetIndex += ((GroupPanel) targetPanel).getPathPanelCount();
				targetIndex -= trueIndexInParent >= targetIndex ? 0 : 1;
			}
		}

		// Correct target index for specific gap scenarios
		else if (mouseOnBorder == 1 && targetIndex > trueIndexInParent)
		{
			targetIndex -= 1;
		}
		else if (mouseOnBorder == -1)
		{
			if (targetPanel instanceof GroupPanel)
			{
				targetIndex += ((GroupPanel) targetPanel).getPathPanelCount();
				targetIndex -= trueIndexInParent >= targetIndex ? 0 : 1;
			}
			else if (targetIndex < trueIndexInParent)
			{
				targetIndex += 1;
			}
		}

		// Remove from existing group if path is dropped on a gap directly next to itself.
		if ((mouseOnBorder == -1 || mouseOnBorder == 1) && panel instanceof PathPanel)
		{
			int compIndex = MouseAdapterUtils.getIndexInView(parentPanel, trueIndexInParent);
			int compTargetIndex = MouseAdapterUtils.getIndexInView(parentPanel, targetIndex);

			if (compTargetIndex == compIndex)
			{
				plugin.getStoredPaths().get(panelLabel).pathGroup = null;
			}
		}

		LinkedHashMap<String, PathmakerPath> storedPaths = plugin.getStoredPaths();

		// Create new LinkedHashMap to replace the old plugin.paths map
		ArrayList<Map.Entry<String, PathmakerPath>> paths = new ArrayList<>(storedPaths.entrySet());

		// Move single path
		if (panelLabel != null)
		{
			//debugMoveTo(targetPanel, targetIndex);
			Map.Entry<String, PathmakerPath> movedPath = paths.remove(trueIndexInParent);
			if(targetIndex > paths.size() -1)
				paths.add(movedPath);
			else
				paths.add(targetIndex, movedPath);
		}
		else // Move group
		{
			//targetIndex += targetPanel instanceof PathGroup && trueIndexInParent < targetIndex ? ((PathGroup) targetPanel).getPathPanelCount() - 1 : 0;
			int numPanels = ((GroupPanel) panel).getPathPanelCount();
			int start = 	trueIndexInParent > targetIndex ? numPanels - 1 : 0;
			int end = 		trueIndexInParent > targetIndex ? -1 : numPanels;
			int itValue = 	trueIndexInParent > targetIndex ? -1 : 1;

			//log.debug("numPanels: " + numPanels + " start: " + start + " end: " + end + " itValue: " + itValue);

			for (int i = start; i != end; i+= itValue)
			{
				Map.Entry<String, PathmakerPath> movedGroupedPath = paths.remove(trueIndexInParent + start);
				if(targetIndex > paths.size() -1)
					paths.add(movedGroupedPath);
				else
					paths.add(targetIndex, movedGroupedPath);
			}
		}

		// Reorder paths
		storedPaths.clear();
		for (Map.Entry<String, PathmakerPath> path : paths)
		{
			storedPaths.put(path.getKey(), path.getValue());
		}

		plugin.rebuildPanel(true);
	}

	void debugThisAndTarget(JPanel targetPanel, int targetIndex)
	{
		if (panel instanceof PathPanel)
		{
			if (targetPanel instanceof GroupPanel)
			{
				log.debug("Panel ({}) is {}, TargetGroup ({}) is: {}", trueIndexInParent, ((PathPanel) panel).getPathLabel(), targetIndex, ((GroupPanel) targetPanel).getGroupName());
			}
			else
			{
				log.debug("Panel ({}) is {}, TargetPanel ({}) is: {}", trueIndexInParent, ((PathPanel) panel).getPathLabel(), targetIndex, ((PathPanel) targetPanel).getPathLabel());
			}
		}
		else if (panel instanceof GroupPanel)
		{
			if (targetPanel instanceof GroupPanel)
			{
				log.debug("Group ({}) is {}, TargetGroup ({}) is: {}", trueIndexInParent, ((GroupPanel) panel).getGroupName(), targetIndex, ((GroupPanel) targetPanel).getGroupName());
			}
			else
			{
				log.debug("Group ({}) is {}, TargetPanel ({}) is: {}", trueIndexInParent, ((GroupPanel) panel).getGroupName(), targetIndex, ((PathPanel) targetPanel).getPathLabel());
			}
		}
	}

	void debugMoveTo(JPanel targetPanel, int targetIndex)
	{
		if(targetPanel instanceof PathPanel)
			log.debug("Moved ({}) {} to ({}) {}", trueIndexInParent, ((PathPanel) panel).getPathLabel(), targetIndex, ((PathPanel) targetPanel).getPathLabel());
		else
			log.debug("Moved ({}) {} to ({}) {}", trueIndexInParent, ((PathPanel) panel).getPathLabel(), targetIndex, ((GroupPanel) targetPanel).getGroupName());
	}

	// Injected on drop just before mouse release if panel is PathPanel
	void setAvailableGroupName(@Nullable String availableGroupName)
	{
		this.availableGroupName = availableGroupName;
	}
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.geom.Point2D;
import java.util.Collection;
import javax.annotation.Nullable;
import javax.inject.Inject;
import net.runelite.api.MenuEntry;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;                  // For player position
import net.runelite.api.coords.WorldPoint;
import java.awt.geom.Line2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

import lombok.extern.slf4j.Slf4j; // https://projectlombok.org/features/log
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;


@Slf4j
public class PathmakerOverlay extends Overlay
{
    private final Client client;
    private final PathmakerPlugin plugin;
    private final PathmakerConfig config;
    private final ModelOutlineRenderer modelOutlineRenderer;

    private final float tileSize = 128;

    private LocalPoint startPoint;
    private LocalPoint hoveredTile;

    @Inject
    private PathmakerOverlay(Client client, PathmakerPlugin plugin, PathmakerConfig config, ModelOutlineRenderer modelOutlineRenderer)//, WorldView worldview)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.modelOutlineRenderer = modelOutlineRenderer;

        //this.worldview = worldview;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(PRIORITY_MED);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
		// Fetch player position
        // Doing getWorldLocation instead of getLocalLocation, because world loc. is server-side.
		WorldView pWv = client.getLocalPlayer().getWorldView();
		startPoint = LocalPoint.fromWorld(pWv,client.getLocalPlayer().getWorldLocation());

        // Current tile
        if (config.highlightPlayerTile())
        {
			Color trueTileColor = config.highlightPlayerColor();
			Color trueTileFillColor = getTileFillColor(trueTileColor);

			highlightTile(graphics, pWv, startPoint, trueTileColor, config.playerTileBorderWidth(), trueTileFillColor);
        }

        // Highlight tiles marked by the right-click menu and draw lines between them
        if(!plugin.getStoredPaths().isEmpty())
        {
			drawPath(graphics);
        }

		// Draw hovered tile elements
		if(!isMouseOverHud() &&
			(config.hoveredTileDrawModeSelect() == PathmakerConfig.hoveredTileDrawMode.ALWAYS ||
			(config.hoveredTileDrawModeSelect() == PathmakerConfig.hoveredTileDrawMode.SHIFT_DOWN &&
				plugin.hotKeyPressed)))
		{
			drawHoveredTile(graphics);
		}

        return null;
    }

	boolean isMouseOverHud()
	{
		MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
		int last = menuEntries.length - 1;

		if (last < 0)
		{
			return false;
		}

		MenuEntry menuEntry = menuEntries[last];
		String option = menuEntry.getOption();

		return menuEntry.getWidget() != null || option.equals("Cancel"); // STANDARD_HUD_INTERFACES.contains(widgetGroupId)
	}

    void drawHoveredTile(Graphics2D graphics)
    {
        // Fetch hovered tile
		WorldView wv = client.getLocalPlayer().getWorldView();
        Tile tile = wv.getSelectedSceneTile();

        // Set hovered tile to be last hovered tile if none is found
        if(tile == null)
		{
			wv = client.getTopLevelWorldView();
			tile = wv.getSelectedSceneTile();

			if (tile == null) return;
		}
        hoveredTile = tile.getLocalLocation();

        if (hoveredTile.getSceneX() == -1 && hoveredTile.getSceneY() == -1)//!wv.contains(hoveredTile))
			return;

		Color hoveredTileColor;

		if(config.hoverLineColorMatchPath())
		{
			hoveredTileColor = plugin.pathExists(plugin.getActivePathName()) ?
				plugin.getStoredPaths().get(plugin.getActivePathName()).color :
				config.pathColor();
		}
		else
		{
			hoveredTileColor = config.highlightHoveredColor();
		}

		Color hoveredTileFillColor = getTileFillColor(hoveredTileColor);

        // Highlight hovered tile
        if (config.highlightHoveredTile())
		{
			highlightTile(graphics, wv, hoveredTile, hoveredTileColor, config.hoveredTileBorderWidth(), hoveredTileFillColor);
        }

        // Add label
        if (config.hoveredTileLabelModeSelect() != PathmakerConfig.hoveredTileLabelMode.NONE) {
            String hoveredTileLabel = constructHoveredTileString(wv, tile);
            if (!hoveredTileLabel.isEmpty()) {
                addLabel(graphics, wv, hoveredTile, 0, hoveredTileLabel, config.hoveredTileLabelColor());
            }
        }

        // Draw line to hovered line
        // Set hover line to match the active path color if true
        if(config.drawHoverLine())
        {
            switch (config.hoveredTileLineOriginSelect()) {
                case PATH_END: {
                    if (!plugin.pathExists((plugin.getActivePathName()))) {
                        break;
                    }
                    PathmakerPath activePath = plugin.getStoredPaths().get(plugin.getActivePathName());
                    PathPoint lastPoint = activePath.getPointAtDrawIndex(activePath.getSize() - 1);
					//WorldView lastWv = client.getWorldView(lastPoint.getWorldViewId());

                    if (!activePath.isPointInRegions(lastPoint, client.getTopLevelWorldView().getMapRegions()))
                    {
                        break;
                    }

					LocalPoint lastPathPoint = pathPointToLocal(wv,lastPoint);//lastWv, lastPoint);
					if(lastPathPoint == null) break;

					//Set line origin to be in the center of objects
					if (lastPoint instanceof PathPointObject)
					{
						lastPathPoint = lastPathPoint.dx(((PathPointObject) lastPoint).getToCenterVectorX());
						lastPathPoint = lastPathPoint.dy(((PathPointObject) lastPoint).getToCenterVectorY());
					}

                    drawLine(graphics, lastPathPoint, hoveredTile, wv, wv, hoveredTileColor, (float) config.pathLineWidth());
                    break;
                }
                case TRUE_TILE: {
                    drawLine(graphics, startPoint, hoveredTile, client.getLocalPlayer().getWorldView(), wv, hoveredTileColor, (float) config.pathLineWidth());
                    break;
                }
                default:
                    break;
            }
        }
    }

    // Highlight tiles marked by the right-click menu and draw lines between them
    void drawPath(Graphics2D graphics)
    {
		if (plugin.getStoredPaths().isEmpty()) return;

        HashMap<String, PathmakerPath> paths = plugin.getStoredPaths();
		ArrayList<Integer> loadedRegions = new ArrayList<>();

		ArrayList<String> pathsToLoad = new ArrayList<>();

		for (int regionId : client.getTopLevelWorldView().getMapRegions())
		{
			loadedRegions.add(regionId);
		}

		if (client.getLocalPlayer().getWorldView().isInstance())
		{
			// needed for cox
			int playerRegion = client.getLocalPlayer().getWorldLocation().getRegionID();
			if (!loadedRegions.contains(playerRegion)) loadedRegions.add(playerRegion);

			// needed for sailboat
			WorldPoint baseInstancePoint = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
			if (!loadedRegions.contains(baseInstancePoint.getRegionID()))
				loadedRegions.add(baseInstancePoint.getRegionID());

			//log.debug("playerRegion: {}, BaseInstanceReg: {}", playerRegion, baseInstancePoint.getRegionID());
		}

		// Retrieve relevant paths for the loaded regions via the reverse lookup map
		for(int regionId : loadedRegions)
		{
			if (plugin.getReversePathLookup().containsKey(regionId))
			{
				for (String pathName : plugin.getReversePathLookup().get(regionId))
				{
					// skip duplicates
					if (!pathsToLoad.contains(pathName))
					{
						pathsToLoad.add(pathName);
					}
				}
			}
		}

//		StringBuilder debug = new StringBuilder("Paths to load (" +  pathsToLoad.size() + "):");
//		for(String pathName : pathsToLoad)
//		{
//			debug.append(pathName).append(", ");
//		}
//		log.debug(debug.toString());

		if (pathsToLoad.isEmpty())
		{
			return;
		}

        for (String pathName : pathsToLoad)
        {
            PathmakerPath path = paths.get(pathName);

			// path should only ever be null if it was just deleted.
			if(path == null || path.hidden)
			{
				continue;
			}

			ArrayList<LocalPoint> line = new ArrayList<>();
			ArrayList<WorldView> lineWVs = new ArrayList<>();
			ArrayList<Boolean> drawToPrevious = new ArrayList<>();

			ArrayList<PathPoint> drawOrder = paths.get(pathName).getDrawOrder(loadedRegions);

			if (drawOrder.isEmpty()) continue; // Continue if the path does not have any points within the loaded regions

			if(path.drawToPlayer == PathPanel.drawFromPlayerMode.ALWAYS.ordinal() ||
				(path.drawToPlayer == PathPanel.drawFromPlayerMode.START_ONLY.ordinal() &&
					drawOrder.get(0).getDrawIndex() == 0))
			{
				line.add(client.getLocalPlayer().getLocalLocation());
				lineWVs.add(client.getLocalPlayer().getWorldView());
				drawToPrevious.add(true);
			}

            if (config.drawPath())
            {
				Color pathPointColor = config.pointMatchPathColor() ? path.color : config.pathLinePointColor();
				Color pathPointFillColor = getTileFillColor(pathPointColor);

				boolean drawPointTiles = path.pointDrawMode == PathmakerConfig.pathPointMode.BOTH ||
					path.pointDrawMode == PathmakerConfig.pathPointMode.TILES;
				boolean drawPointEntities = path.pointDrawMode == PathmakerConfig.pathPointMode.BOTH ||
					path.pointDrawMode == PathmakerConfig.pathPointMode.ENTITIES;

				PathmakerConfig.pathPointLabelMode labelMode = path.labelMode;

				int lastDrawIndex = -1;

                for (int i = 0; i < drawOrder.size(); i++)
				{
					PathPoint point = drawOrder.get(i);

					WorldPoint wp = toLocalInstance(point.getWorldPoint(), loadedRegions);
					WorldView wv = wp == null ? client.getTopLevelWorldView() : client.getLocalPlayer().getWorldView();
					wp = wp == null ? point.getWorldPoint() : wp;

                    LocalPoint localP; //pathPointToLocal(wv, point);
                    //LocalPoint centerLocation;
                    // Draw outlines first, as this also lets us conveniently update the stored point locations
                    if(point instanceof PathPointObject)
                    {
						// Updating NPC world positions AND fetching current client side position to draw on

						boolean isNpc = ((PathPointObject) point).isNpc();
						int entityId = ((PathPointObject) point).getEntityId();


						localP = getCurrentEntityPosition(wv, point, true);

						if(localP != null)
						{
							if(drawPointEntities)
								drawOutline(wv, localP, isNpc, entityId, config.objectAndNpcOutlineWidth(), path.color, 200);

							if(drawPointTiles)
							{
								highlightTile(graphics, wv, plugin.getEntityPolygon(wv, localP, isNpc, entityId), pathPointColor, config.pathLinePointWidth(), pathPointFillColor);
							}

							localP = toEntityCenter((PathPointObject) point, localP);
						}

						//drawLabel(graphics, wv, labelMode, localP, point.getDrawIndex(), point.getLabel(), path.color);
                    }
					else
					{
						localP = LocalPoint.fromWorld(wv, wp);//pathPointToLocal(wv, point);
						if (localP == null) continue;

						// Draw non-entity tile highlights
						if(drawPointTiles)
							highlightTile(graphics, wv, localP, pathPointColor, config.pathLinePointWidth(), pathPointFillColor);
					}

                    // Only draw line if the previous point had a draw index that was directly behind this.
                   if (config.drawPath())// && (i > 0 && drawOrder.get(i - 1).getDrawIndex() == point.getDrawIndex() - 1) || (i == 0 && path.drawToPlayer != PathPanel.drawFromPlayerMode.NEVER.ordinal()))
				   {
					   boolean previousIsInScene = (lastDrawIndex == point.getDrawIndex() - 1) || path.drawToPlayer ==  PathPanel.drawFromPlayerMode.ALWAYS.ordinal();
					   lineWVs.add(wv);
					   line.add(localP);//drawLine(graphics, lastLocalP, localP, lastWv, wv, path.color, (float) config.pathLineWidth());
					   drawToPrevious.add(point.drawToPrevious && previousIsInScene);
					   lastDrawIndex = point.getDrawIndex();
				   }

					drawLabel(graphics, wv, labelMode, localP, point.getDrawIndex(), point.getLabel(), path.color);
                    //lastLocalP = localP;
					//lastWv = wv;
                }

            }

            // Loop path, making sure both ends are loaded
            if (path.loopPath &&
				path.getSize() > 2 &&
				config.drawPath() &&
				path.isPointInRegions(path.getPointAtDrawIndex(path.getSize() -1), loadedRegions) &&
				path.isPointInRegions(path.getPointAtDrawIndex(0), loadedRegions))
            {
				line.add(line.get(0));
				lineWVs.add(lineWVs.get(0));
				drawToPrevious.add(true);
            }

			if (line.size() > 1)
			{
				WorldView wv = client.getTopLevelWorldView();
				int LOCAL_HALF_TILE_SIZE = Perspective.LOCAL_HALF_TILE_SIZE;

				if (path.pathDrawOffset != PathPanel.pathDrawOffset.OFFSET_MIDDLE.ordinal() && path.drawToPlayer != PathPanel.drawFromPlayerMode.ALWAYS.ordinal())
				{
					ArrayList<int[]> tileXs = new ArrayList<>();
					ArrayList<int[]> tileYs = new ArrayList<>();
					boolean buildLeft = path.pathDrawOffset == PathPanel.pathDrawOffset.OFFSET_LEFT.ordinal();
					for (int i = 0; i < line.size(); i++)
					{
						LocalPoint lp = line.get(i);
						if (lp == null)
						{
							log.debug("LocalPoint index: {}, is null so can't be used as PathPoint", i);
							continue;
						}

						Tile tile = plugin.getTile(wv, lp.getSceneX(), lp.getSceneY());
						if (tile == null)
						{
							log.debug("Tile is null so can't be used as PathPoint");
							continue;
						}

						int[] tileX = new int[4];
						tileX[0] = lp.getX() - LOCAL_HALF_TILE_SIZE;
						tileX[1] = lp.getX() + LOCAL_HALF_TILE_SIZE;
						tileX[2] = lp.getX() + LOCAL_HALF_TILE_SIZE;
						tileX[3] = lp.getX() - LOCAL_HALF_TILE_SIZE;

						int[] tileY = new int[4];
						tileY[0] = lp.getY() + LOCAL_HALF_TILE_SIZE;
						tileY[1] = lp.getY() + LOCAL_HALF_TILE_SIZE;
						tileY[2] = lp.getY() - LOCAL_HALF_TILE_SIZE;
						tileY[3] = lp.getY() - LOCAL_HALF_TILE_SIZE;

						tileXs.add(tileX);
						tileYs.add(tileY);
					}

					ArrayList<ArrayList<LocalPoint>> lineVertices = PathTileOutline.build(lineWVs, tileXs, tileYs, buildLeft, drawToPrevious);

					for(int vis = 0; vis < drawToPrevious.size(); vis ++)
					{
						if((vis != 0 && drawToPrevious.get(vis) || (vis + 1 < drawToPrevious.size() && drawToPrevious.get(vis + 1))))
						{
						int itStart = (vis > 0 && !drawToPrevious.get(vis)) || (vis == 0 && !drawToPrevious.get(1)) ? 1 : 0;
						ArrayList<LocalPoint> lineV =  lineVertices.get(vis);
						itStart = itStart > lineV.size() ? 0 : itStart;


						for (int i = itStart; i < lineV.size(); i++)
							{
								LocalPoint startLp;
								if (path.drawToPlayer == PathPanel.drawFromPlayerMode.ALWAYS.ordinal())
									startLp = lineVertices.get(0).get(0);
								else if (vis > 0 && i == 0)
								{
									ArrayList<LocalPoint> prevVertArray = lineVertices.get(vis - 1);
									startLp = prevVertArray.get(prevVertArray.size() - 1);
								}
								else if (vis > 0 || i > 0)
									startLp = lineV.get(i - 1);
								else
									continue;

								LocalPoint endLp = lineV.get(i);

								if (startLp == null || endLp == null) continue;

								drawLine(graphics, startLp, endLp, wv, wv, path.color, (float) config.pathLineWidth());
							}
						}
					}
				}
				else
				{
					for (int i = 1; i < line.size(); i++)
					{
						LocalPoint startLp;
						WorldView startWv;

						if (!drawToPrevious.get(i)) continue;

						if(path.drawToPlayer == PathPanel.drawFromPlayerMode.ALWAYS.ordinal())
						{
							startLp = line.get(0);
							startWv = lineWVs.get(0);
						}
						else
						{
							startLp = line.get(i - 1);
							startWv = lineWVs.get(i - 1);
						}

						drawLine(graphics,
							startLp,
							line.get(i),
							startWv,
							lineWVs.get(i),
							path.color,
							(float) config.pathLineWidth());
					}
				}
			}
        }
    }

	LocalPoint toEntityCenter(PathPointObject point, LocalPoint localPoint)
	{
		localPoint = localPoint.dx(point.getToCenterVectorX());
		localPoint = localPoint.dy(point.getToCenterVectorY());
		return localPoint;
	}

    // Convert PathPoint (region point) to local
    LocalPoint pathPointToLocal(WorldView wv, PathPoint point)
    {
        WorldPoint wp = WorldPoint.fromRegion(point.getRegionId(), point.getX(), point.getY(), point.getZ());
        return LocalPoint.fromWorld(wv, wp);
    }

    boolean highlightTile(final Graphics2D graphics, final WorldView wv, final PathPoint point, final Color color, final double borderWidth, final Color fillColor)
    {
        return highlightTile(graphics, wv, pathPointToLocal(wv, point), color, borderWidth, fillColor);
    }

    boolean highlightTile(final Graphics2D graphics, final WorldView wv, final LocalPoint lp, final Color color, final double borderWidth, final Color fillColor)
    {
        if (lp == null)// || !isLocalPointInScene(lp))
        {
            // Occurs on unload
            //log.debug("Failed to highlight tile, LocalPoint is null.");
            return false;
        }
        return highlightTile(graphics, wv, Perspective.getCanvasTilePoly(client, lp), color, borderWidth, fillColor);
    }

    boolean highlightTile(final Graphics2D graphics, final WorldView wv, final Polygon poly, final Color color, final double borderWidth, final Color fillColor)
    {
        // poly will be null i the tile is within a loaded region, but outside the camera's frustum or not loaded (i.e. despawning npcs)
        if (poly == null) return false;

        int boundsX = (int) poly.getBounds().getLocation().getX();
        int boundsY = (int) poly.getBounds().getLocation().getY();

        if(!isLocalPointInScene(wv, new LocalPoint(boundsX, boundsY, wv))) return false;


        OverlayUtil.renderPolygon(graphics, poly, color, fillColor, new BasicStroke((float) borderWidth));
        return true;
    }

    // Draw a line between the provided start and end points
    private void drawLine(final Graphics2D graphics, final LocalPoint startLoc, final LocalPoint endLoc, WorldView startWv, WorldView endWv, final Color color, float lineWidth){ //, int counter) {
        if (startLoc == null || endLoc == null)
        {
            return;
        }

        final int startHeight = Perspective.getTileHeight(client, startLoc, startWv.getPlane());
        final int endHeight = Perspective.getTileHeight(client, endLoc, endWv.getPlane());

        Point p1 = Perspective.localToCanvas(client, startLoc.getWorldView(), startLoc.getX(), startLoc.getY(), startHeight - config.pathZOffset() * 10);
        Point p2 = Perspective.localToCanvas(client, endLoc.getWorldView(), endLoc.getX(), endLoc.getY(), endHeight - config.pathZOffset() * 10);

        if (p1 == null || p2 == null)
        {
            return;
        }

        Line2D.Double line = new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY());

        graphics.setColor(color);
        graphics.setStroke(new BasicStroke(lineWidth));
        graphics.draw(line);
    }

    // 0 tileObject, 1 npc
    void drawOutline(WorldView wv, LocalPoint lp, Boolean isNpc, int entityId, int width, Color color, int feather)
    {
        if(isNpc)
        {
            NPC npc = wv.npcs().byIndex(entityId);
            if(npc == null){return;}

            modelOutlineRenderer.drawOutline(npc,width,color,feather);
        }
        else
        {
            TileObject tileObject = plugin.getTileObject(wv, lp, entityId);
            if(tileObject == null){return;}
            modelOutlineRenderer.drawOutline(tileObject,width,color,feather);
        }
    }

	LocalPoint getCurrentEntityPosition(WorldView wv, PathPoint p, boolean updateMovable)
    {
		if (!(p instanceof PathPointObject)) return LocalPoint.fromWorld(wv, p.getWorldPoint());

		PathPointObject entity = (PathPointObject) p;
		LocalPoint lp = null;

        if(entity.isNpc())
        {
            NPC npc = wv.npcs().byIndex(entity.getEntityId());

			if(npc == null)
			{
				for (NPC localNpc : wv.npcs())
				{
					if (localNpc.getId() == entity.getBaseId())
					{
						npc = localNpc;

						if(updateMovable)
						{
							entity.setEntityId(localNpc.getIndex());

							Point toCenterVec = plugin.getEntityToCenterVector(wv, npc.getWorldLocation(), localNpc.getId(), true);
							entity.setToCenterVector(toCenterVec.getX(), toCenterVec.getY());
						}

						break;
					}
				}
			}

            if(npc != null)
			{
				if(updateMovable)
				{
					final WorldPoint worldNpc = WorldPoint.fromLocalInstance(wv.getScene(), npc.getLocalLocation(), wv.getPlane());

					// Update the stored belonging PathPoint
					plugin.updatePointLocation(
						entity.getPathOwnerName(),
						entity,
						worldNpc.getRegionID(),
						worldNpc.getRegionX(),
						worldNpc.getRegionY(),
						worldNpc.getPlane());
				}

				lp = npc.getLocalLocation();
			}
        }
		else if (wv.getScene().isInstance())
		{
			Collection<WorldPoint> iWps = WorldPoint.toLocalInstance(wv, entity.getWorldPoint());

			if (!iWps.isEmpty())
			{
				WorldPoint wp  = iWps.iterator().next();
				lp = LocalPoint.fromWorld(wv, wp);

				if (lp != null && updateMovable)
				{
					Point toCenterVec = plugin.getEntityToCenterVector(wv, wp, entity.getEntityId(), false);
					entity.setToCenterVector(toCenterVec.getX(), toCenterVec.getY());
				}
			}
		}

		if (lp == null)
		{
			lp = LocalPoint.fromWorld(wv, entity.getWorldPoint());
		}

		return lp;
    }

	// (point.getDrawIndex() + 1)
	void drawLabel(Graphics2D graphics, WorldView wv, PathmakerConfig.pathPointLabelMode pathLabelMode, LocalPoint lp, int drawIndex, @Nullable String pointLabel, Color pathColor)
	{
		Color color = config.labelMatchPathColor() ? pathColor : config.pathPointLabelColor();

		String label = "";
		boolean stringEmpty = pointLabel == null || pointLabel.isEmpty();

		switch (pathLabelMode)
		{
			case NONE:
				return;
			case BOTH:
			{
				label = "p" + (drawIndex + 1) + (stringEmpty ? "" : (", " + pointLabel));
				break;
			}
			case INDEX:
			{
				label = "p" + (drawIndex + 1);
				break;
			}
			case LABEL:
			{
				if(stringEmpty) return;
				label = pointLabel;
				break;
			}
		}

		addLabel(graphics, wv, lp, config.labelZOffset() * 10, label, color);
	}

	WorldPoint toLocalInstance(WorldPoint wp, ArrayList<Integer> loadedRegions)
	{
		if (client.getLocalPlayer().getWorldView().isInstance())// && !loadedRegions.contains(wp.getRegionID()))
		{
			Collection<WorldPoint> wPs = WorldPoint.toLocalInstance(client.getLocalPlayer().getWorldView(), wp);
			for (WorldPoint iWp : wPs)
			{
				if(loadedRegions.contains(iWp.getRegionID()))
				{
					return iWp;
				}
			}
		}
		return null;
	}

    String constructHoveredTileString(WorldView wv, Tile tile)
    {
        String returnString = "";
        switch (config.hoveredTileLabelModeSelect())
        {
            case REGION:
				returnString = getTileRegionString(tile);
				break;

            case LOCATION:
				returnString = getTileLocationString(tile);
				break;

            case OFFSET:
				if(config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.PATH_END &&
					!plugin.getStoredPaths().isEmpty() && plugin.getStoredPaths().containsKey(plugin.getActivePathName()) &&
					isLocalPointInScene(wv, getLastPointInActivePath()))
				{
					returnString = getTileOffsetString(hoveredTile, getLastPointInActivePath());
				}
				else if (config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.TRUE_TILE)
				{
					returnString = getTileOffsetString(hoveredTile, startPoint);
				}
                break;

            case DISTANCE:
				if(config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.PATH_END &&
					!plugin.getStoredPaths().isEmpty() && plugin.getStoredPaths().containsKey(plugin.getActivePathName()) &&
					isLocalPointInScene(wv, getLastPointInActivePath()))
				{
					returnString = getTileDistanceString(getLastPointInActivePath(), hoveredTile);
				}
				else if (config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.TRUE_TILE)
				{
					returnString = getTileDistanceString(hoveredTile, startPoint);
				}

				break;

            case ALL:
				// Region & Location
				returnString = "R: " + getTileRegionString(tile) + ", L: " + getTileLocationString(tile);

				// Offset & Distance
				if(config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.PATH_END &&
					!plugin.getStoredPaths().isEmpty() && plugin.getStoredPaths().containsKey(plugin.getActivePathName()) &&
					isLocalPointInScene(wv, getLastPointInActivePath()))
				{
					returnString += ", O: " + getTileOffsetString(hoveredTile, getLastPointInActivePath());
					returnString += ", D: " + getTileDistanceString(getLastPointInActivePath(), hoveredTile);
				}
				else if (config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.TRUE_TILE)
				{
					returnString += ", O: " + getTileOffsetString(hoveredTile, startPoint);
					returnString += ", D: " + getTileDistanceString(startPoint, hoveredTile);
				}
				break;

            default:
				break;
        }

        return returnString;
    }

    LocalPoint getLastPointInActivePath()
    {
        PathmakerPath activePath = plugin.getStoredPaths().get(plugin.getActivePathName());
        PathPoint lastPoint = activePath.getPointAtDrawIndex(activePath.getSize() - 1);
        WorldPoint wp = WorldPoint.fromRegion(lastPoint.getRegionId(),lastPoint.getX(), lastPoint.getY(), lastPoint.getZ());
        return LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
    }

    String getTileLocationString(Tile tile)
    {
        return "( " + tile.getWorldLocation().getX() + ", " + tile.getWorldLocation().getY() + " )";
    }

    String getTileOffsetString(LocalPoint start, LocalPoint end)
    {
        return "( " + (int) ((start.getX() - end.getX()) / tileSize) + ", " + (int) ((start.getY() - end.getY()) / tileSize) + " )";
    }

    String getTileDistanceString(LocalPoint from,  LocalPoint to)
    {
		if(from == null || to == null) return "";

		int x = Math.abs(to.getX() - from.getX());
		int y = Math.abs(to.getY() - from.getY());

        return String.valueOf((int) ((Math.max(x, y))/ tileSize)); // distance to is 1.414 to diagonal tiles
    }

	Color getTileFillColor(Color tileColor)
	{
		return new Color(tileColor.getRed(), tileColor.getGreen(), tileColor.getBlue(),  tileColor.getAlpha() / 5);
	}

    String getTileRegionString(Tile tile)
    {
        return String.valueOf(tile.getWorldLocation().getRegionID());
    }


    boolean addLabel(Graphics2D graphics, WorldView wv, LocalPoint tileLoc, int zOffset, String labelText, Color color)
    {
        if (tileLoc == null || !isLocalPointInScene(wv, tileLoc))
            return false;

        Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, tileLoc, labelText, zOffset);

        if (canvasTextLocation != null)
        {
            OverlayUtil.renderTextLocation(graphics, canvasTextLocation, labelText, color);
            return true;
        }
        return false;
    }

    boolean isLocalPointInScene(final WorldView wv, final LocalPoint point)
    {
		if(point == null) return false;
		return wv.contains(point);
    }

	float average (int[] ints)
	{
		return (float) Arrays.stream(ints).sum() / ints.length;
	}

	// Return 1 if positive, 0 if zero -1 if negative
	int sign(float v)
	{
		return v > 0 ? 1 : (v < 0 ? -1 : 0);
	}

	Point2D.Float normalize(Point a, Point b)
	{
		float dist = a.distanceTo(b);
		Point2D.Float ab = new Point2D.Float(b.getX() - a.getX(), b.getY() - a.getY());
		ab.setLocation(ab.x / dist, ab.y / dist);
		return ab;
	}
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import javax.annotation.Nullable;
import net.runelite.api.coords.WorldPoint;

// Ref: GroundMarkerPoint - https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/groundmarkers/GroundMarkerPoint.java#L38
public class PathPoint
{
    private int pathDrawIndex = -1;
    private int regionId;
    private int regionX;
    private int regionY;
    private int z;
	boolean drawToPrevious = true;

	private String pathOwner;
    private String label;

    PathPoint(String path, int regID, int regX, int regY, int plane)
    {
		this.pathOwner = path;
        this.regionId = regID;
        this.regionX = regX;
        this.regionY = regY;
        this.z = plane;
    }

    PathPoint(String path, WorldPoint worldPoint)
    {
		this.pathOwner = path;
        this.regionId = worldPoint.getRegionID();
        this.regionX = worldPoint.getRegionX();
        this.regionY = worldPoint.getRegionY();
        this.z = worldPoint.getPlane();
    }

	String getPathOwnerName()
	{
		return this.pathOwner;
	}

	void setPathOwnerName(String pathOwnerName)
	{
		this.pathOwner = pathOwnerName;
	}

    int getRegionId()
    {
        return regionId;
    }

    int getX()
    {
        return regionX;
    }
    int getY()
    {
        return regionY;
    }
    int getZ()
    {
        return z;
    }

    WorldPoint getWorldPoint()
    {
        return WorldPoint.fromRegion(regionId, regionX, regionY, z);
    }

    void setLabel(String newLabel)
    {
        this.label = newLabel;
    }

    @Nullable
    String getLabel()
    {
        return label;
    }

    void setDrawIndex(int index)
    {
        this.pathDrawIndex = index;
    }

    int getDrawIndex()
    {
        return pathDrawIndex;
    }

    void updateRegionLocation(int region, int x, int y, int z)
    {
        // DONT FORGET TO ALSO UPDATE BELONGING PathmakerPath! USE plugin.updatePointLocation
        this.regionId = region;
        this.regionX = x;
        this.regionY = y;
        this.z = z;
    }
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.awt.Color;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.Component;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.CompoundBorder;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.ImageIcon;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;

@Slf4j
public class PathPanel extends JPanel
{
    private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	private static final BufferedImage upArrowImage = ImageUtil.loadImageResource(PathmakerPlugin.class, "up_arrow.png");
	private static final ImageIcon COLLAPSE_ICON = new ImageIcon(upArrowImage);
    private static final ImageIcon EXPAND_ICON = new ImageIcon(ImageUtil.flipImage(upArrowImage, false, true));
    private static final ImageIcon LOOP_ON_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "loop_on.png"));
    private static final ImageIcon LOOP_OFF_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "loop_off.png"));
    private static final ImageIcon EYE_OPEN_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "eye_open.png"));
	private static final ImageIcon EYE_CLOSED_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "eye_closed.png"));
	private static final ImageIcon OFFSET_LEFT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "offset_left.png"));
	private static final ImageIcon OFFSET_MIDDLE_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "offset_middle.png"));
	private static final ImageIcon OFFSET_RIGHT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "offset_right.png"));
	//private static final ImageIcon PERSON_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "person.png"));
	private static final ImageIcon PERSON_GREEN_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "person_green.png"));
	private static final ImageIcon PERSON_GREEN_LINES_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "person_green_lines.png"));
	private static final ImageIcon TRIPLE_DOTS_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "triple_dots.png"));

	private static final ImageIcon DISABLED_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "disabled.png"));

	private static final ImageIcon HIGHLIGHT_MODE_BOTH_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "highlight_mode_both.png"));
	private static final ImageIcon HIGHLIGHT_MODE_OBJECTS_AND_NPCS_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "highlight_mode_objects_and_npcs.png"));
	private static final ImageIcon HIGHLIGHT_MODE_TILES_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "highlight_mode_tiles.png"));
	//private static final ImageIcon HIGHLIGHT_MODE_OFF_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "highlight_mode_off.png"));

	private static final ImageIcon LABEL_MODE_BOTH_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "label_mode_both.png"));
	private static final ImageIcon LABEL_MODE_LABEL_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "label_mode_label.png"));
	private static final ImageIcon LABEL_MODE_POINT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "label_mode_point.png"));

	private static final ImageIcon TRIPLE_DOTS_HORIZONTAL_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "triple_dots_horizontal.png"));

	private static final BufferedImage brushImage = ImageUtil.loadImageResource(PathmakerPlugin.class, "brush.png");
	private static final BufferedImage crossImage = ImageUtil.loadImageResource(PathmakerPlugin.class, "cross.png");

	enum pathDrawOffset
	{
		OFFSET_LEFT,
		OFFSET_MIDDLE,
		OFFSET_RIGHT,
	}

	enum drawFromPlayerMode
	{
		NEVER,
		START_ONLY,
		ALWAYS,
	}

    private final PathmakerPlugin plugin;
    private final PathmakerPath path;

    private final JPanel pathContainer = new JPanel();
    private final JButton label = new JButton();
	private final JPanel labelPanel;

    private final int ICON_WIDTH = 18;

    //private boolean panelExpanded = true;
    private final JButton expandToggle;
    private final JButton visibilityToggle;

    PathPanel(PathmakerPlugin plugin, String pathLabel)
    {
        this.plugin = plugin;
        this.path = plugin.getStoredPaths().get(pathLabel);
		pathContainer.setLayout(new BoxLayout(pathContainer, BoxLayout.Y_AXIS));

        labelPanel = new JPanel(new BorderLayout());
        labelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        label.setText(pathLabel);
        label.setForeground(Color.WHITE); //path.color);
		label.setToolTipText(pathLabel + ": " + path.getSize() + " point" + (path.getSize() > 1 ? "s, " : ", ") +
			path.getRegionIDs().size() + " region" + (path.getRegionIDs().size() > 1 ? "s" : ""));
        label.setPreferredSize(new Dimension(122, 20)); // Client.PANEL_WIDTH = 225. (18x6 buttons, 5 margin
        labelPanel.add(label, BorderLayout.CENTER);

        expandToggle = PanelBuildUtils.createExpandToggleButton(path.panelExpanded, ICON_WIDTH, 0, "path");
        expandToggle.addActionListener(actionEvent ->
        {
            toggleCollapsed();
			plugin.savePath(getPathLabel());
			plugin.rebuildPanel(false);
        });

        visibilityToggle = new JButton(path.hidden ? EYE_CLOSED_ICON : EYE_OPEN_ICON);
        visibilityToggle.setPreferredSize(new Dimension(ICON_WIDTH, 0));
        visibilityToggle.setToolTipText((path.hidden ? "Show" : "Hide") + " path");
        visibilityToggle.addActionListener(actionEvent ->
        {
            setVisibility(!path.hidden);
        });

        JButton colorPickerButton = PanelBuildUtils.createColorPickerButton(ICON_WIDTH, 0, path.color, "path");
        colorPickerButton.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                RuneliteColorPicker colorPicker = getColorPicker(path.color == null ? plugin.getDefaultPathColor() : path.color, colorPickerButton);
                colorPicker.setOnColorChange(newColor ->
                {
                    path.color = newColor;
                    label.setForeground(newColor);
                    colorPickerButton.setIcon(new ImageIcon(ImageUtil.recolorImage(brushImage, newColor)));
                });
                colorPicker.setVisible(true);
            }
        });

        // Add button panel on the left
        JPanel leftActionPanel = new JPanel(new BorderLayout());
        leftActionPanel.add(expandToggle, BorderLayout.WEST);
        leftActionPanel.add(visibilityToggle, BorderLayout.CENTER);
        leftActionPanel.add(colorPickerButton, BorderLayout.EAST);
        labelPanel.add(leftActionPanel, BorderLayout.WEST);

        JButton deletePathButton = PanelBuildUtils.createDeleteButton(plugin, ICON_WIDTH, 0 , this, getPathLabel(),"path",true);
//        deletePathButton.setIcon(new ImageIcon(ImageUtil.recolorImage(crossImage, Color.RED)));
//        deletePathButton.setToolTipText("Delete path");
//        deletePathButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
//        String warningMsg = "Are you sure you want to permanently delete path: " + label.getText() + "?";
//        deletePathButton.addMouseListener(new MouseAdapter()
//        {
//            @Override
//            public void mousePressed(MouseEvent mouseEvent) {
//                int confirm = JOptionPane.showConfirmDialog(PathPanel.this,
//                        warningMsg,
//                        "Warning", JOptionPane.OK_CANCEL_OPTION);
//
//                if (confirm == 0)
//                {
//                    plugin.removePath(label.getText());
//                    plugin.rebuildPanel(true);
//                }
//            }
//        });

        // Add loop button
//        JButton loopButton = new JButton();
//        loopButton.setIcon(path.loopPath ? LOOP_ON_ICON : LOOP_OFF_ICON);
//        loopButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
//        loopButton.setToolTipText((path.loopPath ? "disable" :  "enable") + " path loop");
//        loopButton.addMouseListener(new MouseAdapter()
//        {
//            @Override
//            public void mousePressed(MouseEvent mouseEvent)
//            {
//                path.loopPath = !path.loopPath;
//                loopButton.setToolTipText((path.loopPath ? "disable" :  "enable") + " path loop");
//                loopButton.setIcon(path.loopPath ? LOOP_ON_ICON : LOOP_OFF_ICON);
//            }
//        });

		// Add offset button
		JButton offsetButton = new JButton();
		offsetButton.setIcon(getPathDrawOffsetIcon(path));
		offsetButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
		offsetButton.setToolTipText("Set path draw offset");
		offsetButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				path.pathDrawOffset = path.pathDrawOffset + 1 > 2 ? 0 : path.pathDrawOffset + 1;
				offsetButton.setIcon(getPathDrawOffsetIcon(path));
				//plugin.saveAll();

				offsetButton.updateUI();
			}
		});

		int pathSize = path.getSize();
		ArrayList<PathPoint> drawOrder = path.getDrawOrder(null);

		// Add offset button
//		JButton loopToPlayerButton = new JButton();
//		loopToPlayerButton.setIcon(getLoopToPlayerIcon(path.drawToPlayer));
//		loopToPlayerButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
//		loopToPlayerButton.setToolTipText(getLoopToPlayerTooltip(path.drawToPlayer));
//		loopToPlayerButton.addMouseListener(new MouseAdapter()
//		{
//			@Override
//			public void mousePressed(MouseEvent mouseEvent)
//			{
//
//				path.drawToPlayer = path.drawToPlayer + 1 > 2 ? 0 : path.drawToPlayer + 1;
//				loopToPlayerButton.setIcon(getLoopToPlayerIcon(path.drawToPlayer));
//				loopToPlayerButton.setToolTipText(getLoopToPlayerTooltip(path.drawToPlayer));
//				plugin.savePath(getPathLabel());
//				plugin.rebuildPanel(false);
//			}
//		});

		// Main options & menu
		JButton optionsButton = new JButton();
		optionsButton.setIcon(TRIPLE_DOTS_ICON);
		optionsButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
		optionsButton.setToolTipText("Options");

		JPopupMenu optionsMenu = new JPopupMenu();

		Runnable openOptionsMenu = () -> {optionsMenu.show(optionsButton, 0, labelPanel.getHeight());};

		optionsButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				openOptionsMenu.run();
			}
		});

		int iconTextGap = 10;

		// Rename option
		JMenuItem renameMenuEntry = optionsMenu.add("Rename path");
		renameMenuEntry.setIcon(TRIPLE_DOTS_HORIZONTAL_ICON);
		renameMenuEntry.setIconTextGap(iconTextGap);
		renameMenuEntry.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				super.mouseReleased(mouseEvent);

				int MAX_PATH_NAME_LENGTH = plugin.pluginPanel.MAX_PATH_NAME_LENGTH;

				JLabel centeredNameText = new JLabel("Enter new path name (max " + MAX_PATH_NAME_LENGTH + " characters)", JLabel.CENTER); // "New path name"
				centeredNameText.setHorizontalTextPosition(SwingConstants.CENTER);

				String newPathName = getPathLabel();
				LinkedHashMap<String, PathmakerPath> paths = plugin.getStoredPaths();

				while (paths.containsKey(newPathName))
				{
					if (!newPathName.equals(pathLabel))
						centeredNameText.setText("The name \"" + newPathName + "\" already exist");
					newPathName = JOptionPane.showInputDialog(optionsButton, centeredNameText, newPathName);

					// Return if the OptionPane was cancelled
					if (newPathName == null) return;

					newPathName = newPathName.length() > MAX_PATH_NAME_LENGTH ?
						newPathName.substring(0, MAX_PATH_NAME_LENGTH) : newPathName;

					if  (newPathName.equals(pathLabel)) return;
				}

				// Replace entries in the reversePathLookup map
				Set<Integer> regionIds = path.getRegionIDs();
				HashMap<Integer, ArrayList<String>> reversePathLookup = plugin.getReversePathLookup();
				for (int regionId : regionIds)
				{
					ArrayList<String> regionPaths = reversePathLookup.get(regionId);
					int pathIndex = regionPaths.indexOf(pathLabel);
					regionPaths.remove(pathIndex);
					regionPaths.add(pathIndex, newPathName);
				}

				// Update save BEFORE paths is updated to make sure the old name is properly replaced
				plugin.savePath(pathLabel, newPathName);

				LinkedHashMap<String, PathmakerPath> pathsCopy = new LinkedHashMap<>(paths);
				paths.clear();

				// Insert the new key at the position of the old key in the iteration
				for (Map.Entry<String, PathmakerPath> entry : pathsCopy.entrySet())
				{
					if (entry.getKey().equals(pathLabel))
					{
						for (PathPoint point : entry.getValue().getDrawOrder(null))
							point.setPathOwnerName(newPathName);

						paths.put(newPathName, entry.getValue());
					} else {
						paths.put(entry.getKey(), entry.getValue());
					}
				}

				plugin.rebuildPanel(false);
			}
		});

		// Loop path
		JMenuItem loopMenuEntry = optionsMenu.add((path.loopPath ? "Unloop" : "Loop") + " path");
		loopMenuEntry.setIcon(path.loopPath ? LOOP_ON_ICON : LOOP_OFF_ICON);
		loopMenuEntry.setIconTextGap(iconTextGap);
		loopMenuEntry.setToolTipText((path.loopPath ? "Disable" :  "Enable") + " path loop");
		loopMenuEntry.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent mouseEvent)
			{
				super.mouseReleased(mouseEvent);
				path.loopPath = !path.loopPath;
				loopMenuEntry.setText((path.loopPath ? "Unloop" : "Loop") + " path");
				loopMenuEntry.setToolTipText((path.loopPath ? "Disable" :  "Enable") + " path loop");
				loopMenuEntry.setIcon(path.loopPath ? LOOP_ON_ICON : LOOP_OFF_ICON);

				openOptionsMenu.run();
			}
		});

		// Adapter for path highlight and label mode selection
		Function<JMenu, MouseAdapter> checkBoxModeAdapter = parentMenu ->
			new MouseAdapter()
			{
				@Override
				public void mouseReleased(MouseEvent e)
				{
					super.mouseReleased(e);

					JCheckBoxMenuItem checkBox = (JCheckBoxMenuItem) e.getSource();
					boolean boxState = checkBox.getState(); // (getState() changes after this is called)
					int relativeToType = checkBox.getText().equals("Tiles") || checkBox.getText().equals("Index") ? 1 : 2;
					int modeOrdinal;

					if(parentMenu.getText().equals("Text"))
						modeOrdinal = path.labelMode.ordinal();
					else
						modeOrdinal = path.pointDrawMode.ordinal();

					switch (modeOrdinal)
					{
						case 0: // NONE
						{
							if (boxState)
							{
								if (relativeToType == 1) modeOrdinal = 1;	// Returning INDEX or TILES
								else modeOrdinal = 2; 						// Returning LABEL or ENTITIES
							}
							break;
						}
						case 1: // INDEX or TILES
						{
							if (!boxState && relativeToType == 1) modeOrdinal = 0;		// Returning NONE
							else if (boxState && relativeToType == 2) modeOrdinal = 3;	// Returning BOTH
							break;
						}
						case 2: // LABEL or NPCS_AND_OBJECTS
						{
							if (boxState && relativeToType == 1) modeOrdinal = 3;		// Returning BOTH
							else if (!boxState && relativeToType == 2) modeOrdinal = 0;	// Returning NONE
							break;
						}
						case 3: // BOTH
						{
							if (!boxState)
							{
								if (relativeToType == 1) modeOrdinal = 2;	// Returning LABEL or ENTITIES
								else modeOrdinal = 1;						// Returning INDEX or TILES
							}
							break;
						}
					}

					if(parentMenu.getText().equals("Text"))
					{
						PathmakerConfig.pathPointLabelMode newMode = PathmakerConfig.pathPointLabelMode.values()[modeOrdinal];
						parentMenu.setIcon(getLabelModeIcon(newMode));
						path.labelMode = newMode;
					}
					else
					{
						PathmakerConfig.pathPointMode newMode = PathmakerConfig.pathPointMode.values()[modeOrdinal];
						parentMenu.setIcon(getHighlightModeIcon(newMode));
						path.pointDrawMode = newMode;
					}

					plugin.savePath(pathLabel);
				}
			};

		// Label mode option
		JMenu pointLabelModeSubMenu = new JMenu("Text");
		pointLabelModeSubMenu.setIcon(getLabelModeIcon(path.labelMode));
		pointLabelModeSubMenu.setIconTextGap(iconTextGap);
		optionsMenu.add(pointLabelModeSubMenu);

		JCheckBoxMenuItem indexModeMenuEntry =  new JCheckBoxMenuItem("Index");
		indexModeMenuEntry.setIconTextGap(iconTextGap);
		indexModeMenuEntry.setState(path.labelMode == PathmakerConfig.pathPointLabelMode.INDEX || path.labelMode == PathmakerConfig.pathPointLabelMode.BOTH);
		indexModeMenuEntry.addMouseListener(checkBoxModeAdapter.apply(pointLabelModeSubMenu));

		JCheckBoxMenuItem labelModeMenuEntry = new JCheckBoxMenuItem("Label");
		labelModeMenuEntry.setIconTextGap(iconTextGap);
		labelModeMenuEntry.setState(path.labelMode == PathmakerConfig.pathPointLabelMode.LABEL || path.labelMode == PathmakerConfig.pathPointLabelMode.BOTH);
		labelModeMenuEntry.addMouseListener(checkBoxModeAdapter.apply(pointLabelModeSubMenu));

		pointLabelModeSubMenu.add(indexModeMenuEntry);
		pointLabelModeSubMenu.add(labelModeMenuEntry);

		// Highlight mode option
		JMenu pointHighlightModeSubMenu = new JMenu("Highlight");
		pointHighlightModeSubMenu.setIcon(getHighlightModeIcon(path.pointDrawMode));
		pointHighlightModeSubMenu.setIconTextGap(iconTextGap);
		optionsMenu.add(pointHighlightModeSubMenu);

		JCheckBoxMenuItem highlightTilesMenuEntry = new JCheckBoxMenuItem("Tiles");
		highlightTilesMenuEntry.setIconTextGap(iconTextGap);
		highlightTilesMenuEntry.setState(path.pointDrawMode == PathmakerConfig.pathPointMode.BOTH ||
			path.pointDrawMode == PathmakerConfig.pathPointMode.TILES);
		highlightTilesMenuEntry.addMouseListener(checkBoxModeAdapter.apply(pointHighlightModeSubMenu));

		JCheckBoxMenuItem highlightObjectsAndNpcMenuEntry = new JCheckBoxMenuItem("Entities");
		highlightObjectsAndNpcMenuEntry.setIconTextGap(iconTextGap);
		highlightObjectsAndNpcMenuEntry.setState(path.pointDrawMode == PathmakerConfig.pathPointMode.BOTH ||
			path.pointDrawMode == PathmakerConfig.pathPointMode.ENTITIES);
		highlightObjectsAndNpcMenuEntry.addMouseListener(checkBoxModeAdapter.apply(pointHighlightModeSubMenu));

		pointHighlightModeSubMenu.add(highlightTilesMenuEntry);
		pointHighlightModeSubMenu.add(highlightObjectsAndNpcMenuEntry);

		// Connect to player sub menu
		JMenu connectToPlayerSubMenu = PanelBuildUtils.createDrawToPlayerMenu(plugin, path, pathLabel);
		connectToPlayerSubMenu.setIcon(getLoopToPlayerIcon(path.drawToPlayer));
		connectToPlayerSubMenu.setIconTextGap(iconTextGap);
		optionsMenu.add(connectToPlayerSubMenu);

		// Add button panel to the right
        JPanel rightActionPanel = new JPanel(new BorderLayout());
		//rightActionPanel.add(loopButton, BorderLayout.WEST);
		//rightActionPanel.add(loopToPlayerButton, BorderLayout.WEST);
		rightActionPanel.add(offsetButton, BorderLayout.WEST);
		rightActionPanel.add(optionsButton, BorderLayout.CENTER);
        rightActionPanel.add(deletePathButton, BorderLayout.EAST);
        labelPanel.add(rightActionPanel, BorderLayout.EAST);

        pathContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pathContainer.add(labelPanel, BorderLayout.CENTER);

		if (path.panelExpanded)
		{
			for (int i = pathSize - 1; i >= 0; i--)
			{
				PathPoint point = drawOrder.get(i);
				JPanel pointContainer = new JPanel(new BorderLayout());
				pointContainer.setBorder(new EmptyBorder(0, 0, 0, 0));
				pointContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

				//
				FlatTextField pointLabel = new FlatTextField();
				String label = "";// = "Point";
				label = (point.getLabel() != null && !point.getLabel().isEmpty()) ? point.getLabel() : label;
				pointLabel.setText(label);
				pointLabel.setForeground(Color.WHITE);
				pointLabel.setBackground(Color.DARK_GRAY);
				pointLabel.setPreferredSize(new Dimension(150, 20));
				pointLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
				((AbstractDocument) pointLabel.getTextField().getDocument()).setDocumentFilter(new MaxLengthFilter(plugin.MAX_POINT_LABEL_LENGTH));
				pointLabel.getDocument().addDocumentListener(new DocumentListener()
				{
					public void insertUpdate(DocumentEvent e)
					{
						point.setLabel(pointLabel.getText());
					}

					public void removeUpdate(DocumentEvent e)
					{
						point.setLabel(pointLabel.getText());
					}

					public void changedUpdate(DocumentEvent e)
					{
					}
				});

				pointContainer.add(pointLabel, BorderLayout.WEST);

				// Add spinner box for optionally assigning a new point index.
				JSpinner indexSpinner = new JSpinner(new SpinnerNumberModel(point.getDrawIndex() + 1, 1, pathSize, 1));
				indexSpinner.setToolTipText("point index");
				indexSpinner.addChangeListener(ce ->
				{
					path.setNewIndex(point, (Integer) indexSpinner.getValue() - 1);
					plugin.rebuildPanel(true);
				});
				SpinnerNumberModel model = (SpinnerNumberModel) indexSpinner.getModel();
				// indexSpinner.getComponents()[0].getName() == "Spinner.nextButton"
				// indexSpinner.getComponents()[1].getName() == "Spinner.previousButton"
				indexSpinner.getComponents()[0].setEnabled(!model.getMaximum().equals(model.getValue()));
				indexSpinner.getComponents()[1].setEnabled(!model.getMinimum().equals(model.getValue()));

				pointContainer.add(indexSpinner, BorderLayout.CENTER);

				JButton deletePathPointButton = new JButton();
				deletePathPointButton.setIcon(new ImageIcon(crossImage));
				deletePathPointButton.setToolTipText("Delete point");
				deletePathPointButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
				deletePathPointButton.addMouseListener(new MouseAdapter()
				{
					@Override
					public void mousePressed(MouseEvent mouseEvent)
					{
						plugin.removePoint(getPathLabel(), point);
						// Rebuilding in removePoint (because of the in-game shift+click dropdown menu)
					}
				});
				pointContainer.add(deletePathPointButton, BorderLayout.EAST);

				if (i > 0 || path.drawToPlayer != drawFromPlayerMode.NEVER.ordinal())
				{
					pointContainer.add(addDrawToLastButton(point), BorderLayout.SOUTH);
				}

				pointContainer.setVisible(path.panelExpanded);
				pathContainer.add(pointContainer);
			}
		}
        add(pathContainer);
    }

	private JButton addDrawToLastButton(PathPoint point)
	{
		JButton drawToLastButton = new JButton();
		//drawToLastButton.setIcon(new ImageIcon(crossImage));
		drawToLastButton.setToolTipText(point.drawToPrevious ? "Unlink from previous point" : "Link to previous point");
		Color defaultColor = drawToLastButton.getBackground();
		drawToLastButton.setBackground(point.drawToPrevious ? defaultColor : Color.RED);
		//drawToLastButton.setText(point.drawToPrevious ? "(linked)" : "(unlinked)");
		//drawToLastButton.setForeground(getBackground().brighter().brighter());
		drawToLastButton.setPreferredSize(new Dimension(0, 10));
		drawToLastButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				point.drawToPrevious = !point.drawToPrevious;
				drawToLastButton.setBackground(point.drawToPrevious ? defaultColor : Color.RED);
				//drawToLastButton.setText(point.drawToPrevious ? "(linked)" : "(unlinked)");
				//drawToLastButton.setForeground(getBackground().brighter().brighter());
				plugin.saveAll();
			}
		});
		return drawToLastButton;
	}

    private void toggleCollapsed()
    {
        path.panelExpanded = !path.panelExpanded;
        for (int i = 1; i < pathContainer.getComponentCount(); i++)
        {
            pathContainer.getComponent(i).setVisible(path.panelExpanded);
        }

        expandToggle.setIcon(path.panelExpanded ? COLLAPSE_ICON : EXPAND_ICON);
        expandToggle.setToolTipText((path.panelExpanded ? "Collapse" : "Expand") + " path");
    }

    void setVisibility(boolean hidden)
    {
        path.hidden = hidden;

        visibilityToggle.setIcon(path.hidden ? EYE_CLOSED_ICON : EYE_OPEN_ICON);
        visibilityToggle.setToolTipText((path.hidden ? "Show" : "Hide") + " path");
    }

    void setPathLabel(String label)
    {
        this.label.setText(label);
    }

	JButton getPathLabelButton()
	{
		return label;
	}

    String getPathLabel()
    {
        return label.getText();
    }

	JPanel getLabelPanel()
	{
		return labelPanel;
	}

	ImageIcon getPathDrawOffsetIcon(PathmakerPath path)
	{
		switch (pathDrawOffset.values()[path.pathDrawOffset])
		{
			case OFFSET_LEFT: return OFFSET_LEFT_ICON;
			case OFFSET_RIGHT: return OFFSET_RIGHT_ICON;
			default: return OFFSET_MIDDLE_ICON;
		}
	}

	ImageIcon getLoopToPlayerIcon(int drawToPlayer)
	{
		switch (drawFromPlayerMode.values()[drawToPlayer])
		{
			case START_ONLY: return PERSON_GREEN_ICON;
			case ALWAYS: return PERSON_GREEN_LINES_ICON;
			default: return DISABLED_ICON;
		}
	}

	String getLoopToPlayerTooltip(int drawToPlayer)
	{
		switch (drawFromPlayerMode.values()[drawToPlayer])
		{
			case START_ONLY: return "Set always draw to player";
			case ALWAYS: return "Un-set player from path";
			default: return "Set player as point 0";
		}
	}

    private RuneliteColorPicker getColorPicker(Color colour, Component relativeTo)
    {
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                colour,
                label.getText() + " path color",
                false);
        colorPicker.setLocationRelativeTo(relativeTo);
        return colorPicker;
    }

	private ImageIcon getLabelModeIcon(PathmakerConfig.pathPointLabelMode mode)
	{
		switch (mode)
		{
			case INDEX: return LABEL_MODE_POINT_ICON;
			case LABEL: return LABEL_MODE_LABEL_ICON;
			case BOTH: return LABEL_MODE_BOTH_ICON;
			default: return DISABLED_ICON;
		}
	}

	private ImageIcon getHighlightModeIcon(PathmakerConfig.pathPointMode mode)
	{
		switch (mode)
		{
			case TILES: return HIGHLIGHT_MODE_TILES_ICON;
			case ENTITIES: return HIGHLIGHT_MODE_OBJECTS_AND_NPCS_ICON;
			case BOTH: return HIGHLIGHT_MODE_BOTH_ICON;
			default: return DISABLED_ICON;
		}
	}
}
/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.awt.Color;
import java.util.function.Consumer;
import net.runelite.api.ChatMessageType;
import net.runelite.api.MenuEntry;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

public class MenuEntryUtil
{
	static Runnable getAddPointMenuEntryMethod(PathmakerPlugin plugin, String pathName, PathPoint point, String targetEntityString)
	{
		return () -> {
			plugin.createOrAddToPath(Text.removeTags(pathName), point); // Also sets the created path as the active path
			String targetLabel = Text.removeTags(targetEntityString);
			if (!targetLabel.equals("Tile"))
				point.setLabel(targetLabel);
			plugin.savePath(plugin.getActivePathName());
			plugin.rebuildPanel(false);
		};
	}

	static Consumer<MenuEntry> getAddPointMenuEntry(PathmakerPlugin plugin, String pathName, PathPoint point, String targetEntityString)
	{
		return menuEntry ->
		{
			getAddPointMenuEntryMethod(plugin, pathName, point, targetEntityString).run();
		};
	}

	static Runnable getAddPathMenuEntryMethod(PathmakerPlugin plugin, String prompt, String pathName, PathPoint point, String targetEntityString)
	{
		return () ->
		{
			plugin.chatboxPanelManager.openTextInput(prompt)
				.value(pathName)
				.onDone(label ->
				{
					if (label.length() > plugin.pluginPanel.MAX_PATH_NAME_LENGTH)
						label = label.substring(0, plugin.pluginPanel.MAX_PATH_NAME_LENGTH);

					if (!plugin.getStoredPaths().isEmpty() && plugin.getStoredPaths().containsKey(label))
					{
						String chatMessage =  ColorUtil.wrapWithColorTag(Text.removeTags("Path name \"" + label + "\" is already in use!"), Color.RED);
						plugin.chatMessageManager.queue(QueuedMessage.builder()
							.type(ChatMessageType.GAMEMESSAGE)
							.runeLiteFormattedMessage(chatMessage)
							.build());
					}
					else
						getAddPointMenuEntryMethod(plugin, label, point, targetEntityString).run();

				}).build();
		};
	}

	static Consumer<MenuEntry> getAddPathMenuEntry(PathmakerPlugin plugin, String pathName, PathPoint point, String targetEntityString)
	{
		return menuEntry ->
		{
			getAddPathMenuEntryMethod(plugin,"Path name", pathName, point, targetEntityString).run();
		};
	}

	static Consumer<MenuEntry> getLabelRenameMenuEntryMethod(PathmakerPlugin plugin, PathPoint point, String targetEntityString, int labelLength)
	{
		return menuEntry -> {
			String currentLabel = point.getLabel() == null ? "" : point.getLabel();

			plugin.chatboxPanelManager.openTextInput(targetEntityString + " label")
				.value(currentLabel)
				.onDone(label ->
				{
					if (label.length() > labelLength)
						label = label.substring(0, labelLength);
					point.setLabel(label); // From
					plugin.rebuildPanel(true);
				})
				.build();
		};
	}

	static Consumer<MenuEntry> getLoopMenuEntryMethod(PathmakerPlugin plugin, PathmakerPath path, String pathName, PathPoint point)
	{
		return menuEntry ->
		{
			// Reverse and unloop if target point is second to last in draw order (this preserves the path structure)
			if (path.loopPath &&
				(point != null && point.getDrawIndex() == path.getSize() - 2) ||
				(path.drawToPlayer == PathPanel.drawFromPlayerMode.START_ONLY.ordinal() && point != null && point.getDrawIndex() == path.getSize() - 1))
			{
				path.getPointAtDrawIndex(path.getSize() -1).drawToPrevious = true;
				path.setNewIndex(path.getPointAtDrawIndex(path.getSize() - 1), 0);
				path.reverseDrawOrder();
			}

			path.loopPath = !path.loopPath;

			plugin.savePath(pathName);
			plugin.rebuildPanel(false);
		};
	}

	static Consumer<MenuEntry> getRemovePointMenuEntry(PathmakerPlugin plugin, String pathName, PathPoint pathPoint)
	{
		return menuEntry ->
		{
			plugin.removePoint(pathName, pathPoint);
		};
	}
}
/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import javax.swing.event.DocumentEvent;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;

public class MaxLengthFilter extends DocumentFilter
{
    private final int max;

    public MaxLengthFilter(int max) {
        this.max = max;
    }

    @Override
    public void insertString(FilterBypass fb, int offset, String text, AttributeSet attrs)
            throws BadLocationException {

        // Swing sometimes passes null text during input events
        if (text == null)
            return;

        // Filter out non-printable control characters
        text = filterPrintable(text);

        // Only allow insertion if total length stays within limit
        int currentLength = fb.getDocument().getLength();
        int newLength = currentLength + text.length();

        if (newLength <= max)
        {
            // Entire text can be inserted safely
            super.insertString(fb, offset, text, attrs);
        }
        else
        {
            // Only insert part of the text that fits
            int allowed = max - currentLength;

            if (allowed > 0)
            {
                super.insertString(fb, offset, text.substring(0, allowed), attrs);
            }
        }
    }

    @Override
    public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs)
            throws BadLocationException
    {

        // Replace text can also be null
        if (text == null)
            text = "";

        int currentLength = fb.getDocument().getLength();
        int newLength = currentLength - length + text.length();

        if (newLength <= max)
        {
            // Replacement does not exceed max length
            super.replace(fb, offset, length, text, attrs);
        }
        else
        {
            // Only some of the new text can fit
            int allowed = max - (currentLength - length);
            if (allowed > 0)
            {
                // Insert only the allowed substring, preserving caret & selection
                super.replace(fb, offset, length, text.substring(0, allowed), attrs);
            }
        }
    }


     // remove() is called before text is deleted.
     // Usually no restrictions are needed for removal.

    @Override
    public void remove(FilterBypass fb, int offset, int length)
            throws BadLocationException {
        super.remove(fb, offset, length);
    }


    // Utility method to strip out non-printable control characters.
    // (Allows letters, digits, punctuation, symbols, emoji, etc.)
    private String filterPrintable(String input) {
        StringBuilder out = new StringBuilder();

        for (char c : input.toCharArray()) {
            if (!Character.isISOControl(c)) {  // filter out control chars
                out.append(c);
            }
        }
        return out.toString();
    }
}
/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.MouseEvent;
import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.border.Border;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class MouseAdapterUtils
{
	// 1 = top, -1 = bottom, 0 = false
	public static int isMouseHoveringPathBorder(MouseEvent e, JPanel listPanel, JPanel targetPanel, int margin)
	{
		int entryPosY = (int) (e.getYOnScreen() - listPanel.getLocationOnScreen().getY());
		int minY = (int) targetPanel.getBounds().getMinY();
		int maxY = (int) targetPanel.getBounds().getMaxY();

		if (entryPosY < minY + margin) return 1;
		if (entryPosY > maxY - margin) return -1;
		return 0;
	}

	public static void setPanelInnerBorderColor(JComponent panel, Color color)
	{
		Border outerBorder, innerBorder;
		outerBorder = BorderFactory.createEmptyBorder();
		innerBorder = BorderFactory.createLineBorder(color, 2);
		panel.setBorder(BorderFactory.createCompoundBorder(outerBorder, innerBorder));
	}

	public static void createGapBorders(JPanel topPanel, JPanel bottomPanel, Color color)
	{
		Border outerBorder, innerBorder;

		int thickness = 2;

		if (topPanel != null)
		{
			if(topPanel instanceof GroupPanel)
			{
				outerBorder = BorderFactory.createMatteBorder(0, 0, thickness, 0, color);
				topPanel.setBorder(BorderFactory.createCompoundBorder(outerBorder, topPanel.getBorder()));
			}
			else
			{
				outerBorder = BorderFactory.createEmptyBorder();
				innerBorder = BorderFactory.createMatteBorder(0, 0, thickness, 0, color);
				topPanel.setBorder(BorderFactory.createCompoundBorder(outerBorder, innerBorder));
			}
		}

		if (bottomPanel != null)
		{
			if(bottomPanel instanceof GroupPanel)
			{
				outerBorder = BorderFactory.createMatteBorder(thickness, 0, 0, 0, color);
				bottomPanel.setBorder(BorderFactory.createCompoundBorder(outerBorder, bottomPanel.getBorder()));
			}
			else
			{
				outerBorder = BorderFactory.createEmptyBorder();
				innerBorder = BorderFactory.createMatteBorder(thickness, 0, 0, 0, color);
				bottomPanel.setBorder(BorderFactory.createCompoundBorder(outerBorder, innerBorder));
			}
		}
	}

	static int getHoveredPathIndex(MouseEvent e, JPanel listPanel)
	{
		int hoverY = (int) (e.getYOnScreen() - listPanel.getLocationOnScreen().getY());

		// If the mouse Y position is above or below the panel, then return the first or last index
		if (hoverY < listPanel.getComponent(0).getBounds().getMinY())
			return 0;
		if (hoverY > listPanel.getComponent(listPanel.getComponentCount() - 1).getBounds().getMaxY())
			return listPanel.getComponentCount() - 1;

		for (int i = 0; i < listPanel.getComponentCount(); i++)
		{
			Component comp = listPanel.getComponent(i);
			int minY = (int) comp.getBounds().getMinY();
			int maxY = (int) comp.getBounds().getMaxY();

			if(isMouseHoveringPath(hoverY, minY, maxY))
			{
				return i;
			}
		}
		return -1;
	}

	static JPanel getHoveredPathPanel(JPanel listPanel, int index)
	{
		return (JPanel) listPanel.getComponent(index);
	}

	static boolean isMouseHoveringPath(int mouseY, int panelMinY, int panelMaxY)
	{
		return mouseY >= panelMinY && mouseY < panelMaxY;
	}

	static boolean isIndexValidDropTarget(int index, int targetIndex)
	{
		return targetIndex != -1 && index != targetIndex;
	}

	// Returns the actual path index, also counting grouped paths.
	// If viewIndex is a group, then the true index is trueIndex + comp index
	static int getTrueIndexInView(JPanel parentPanel, int viewIndex)
	{
		int trueIndex = 0;
		for (int i = 0; i < parentPanel.getComponentCount(); i++)
		{
			Component comp = parentPanel.getComponent(i);

			if(i == viewIndex)
			{
				return trueIndex;
			}

			if (comp instanceof GroupPanel)
			{
				trueIndex += ((GroupPanel)comp).getPathPanelCount();
			}
			else
			{
				trueIndex++;
			}
		}
		return -1;
	}

	// Return top layer component index of view (either group if in group, else path)
	static int getIndexInView(JPanel parentPanel, int trueIndex)
	{
		int index = 0;
		int parentPanelCompCount = parentPanel.getComponentCount();
		for (int i = 0; i < parentPanelCompCount; i++)
		{
			Component comp = parentPanel.getComponent(i);

			if (comp instanceof GroupPanel)
			{
				if (trueIndex >= index && trueIndex < index + ((GroupPanel) comp).getPathPanelCount())
				{
					return i;
				}
				index += ((GroupPanel)comp).getPathPanelCount();
			}
			else if (index == trueIndex)
			{
				return i;
			}
			else
			{
				index++;
			}
		}
		return parentPanelCompCount - 1;
	}
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.TileObject;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nonnull;
import java.awt.*;

@Slf4j
public class PathPointObject extends PathPoint
{
    // Should be assigned / unassigned as the player enters the area
    //private TileObject tileObject;

    private int id = -1; // active instance
	private final int baseId; // for lookup
    private final boolean isNpc;
    private int toCenterVectorX = 64;
    private int toCenterVectorY = 64;

	PathPointObject(String path, @Nonnull TileObject tileObject, int baseId)
	{
		super(path, tileObject.getWorldLocation().getRegionID(), tileObject.getWorldLocation().getRegionX(),
			tileObject.getWorldLocation().getRegionY(), tileObject.getWorldView().getPlane());

		isNpc = false;
		id = tileObject.getId();
		this.baseId = baseId;
	}

    PathPointObject(String path, @Nonnull NPC npc, int id, int baseId)
    {
        super(path, npc.getWorldLocation().getRegionID(),
                npc.getWorldLocation().getRegionX(),
                npc.getWorldLocation().getRegionY(),
                npc.getWorldView().getPlane());

        this.isNpc = true;
        this.id = id;
		this.baseId = baseId;
    }

    PathPointObject(String p, int r, int x, int y, int z, int id, int baseId, boolean isNpc)
    {
        super(p, r, x, y, z);

        this.isNpc = isNpc;
        this.id = id;
		this.baseId = baseId;
    }

    // footprint * TileSize / 2
    void setToCenterVector(int x, int y)
    {
        this.toCenterVectorX = x;
        this.toCenterVectorY = y;
    }

    int getToCenterVectorX()
    {
        return this.toCenterVectorX;
    }
    int getToCenterVectorY()
    {
        return this.toCenterVectorY;
    }

//    private Renderable getRenderableObject(TileObject tileObject)
//    {
//        Renderable renderObj = null;
//
//        if (tileObject instanceof GameObject) {renderObj = ((GameObject) tileObject).getRenderable();} // Boxes, trees
//        else if (tileObject instanceof GroundObject) {renderObj = ((GroundObject) tileObject).getRenderable();} // Grass
//        else if (tileObject instanceof ItemLayer) {renderObj = ((ItemLayer) tileObject).getBottom();}  // Items held by tile
//        else if (tileObject instanceof DecorativeObject) {renderObj = ((DecorativeObject) tileObject).getRenderable();}
//        else if (tileObject instanceof WallObject) {renderObj = ((WallObject) tileObject).getRenderable1();}
//        return renderObj;
//    }

	int getBaseId()
	{
		return this.baseId;
	}

    int getEntityId()
    {
        return this.id;
    }

	void setEntityId(int entityId)
	{
		this.id = entityId;
	}

    boolean isNpc()
    {
        return isNpc;
    }

//    TileObject getObject()
//    {
//        return tileObject;
//    }
//
//
//    TileObject loadObject(TileObject object)
//    {
//        this.tileObject = object;
//        return this.tileObject;
//    }
//
//    void unloadObject()
//    {
//        this.tileObject = null;
//    }

//    void loadNpc (NPC npc)
//    {
//        this.npc = npc;
//    }
//
//    void unloadNpc()
//    {
//        npc = npc;
//    }
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nullable;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Set;

// Collection of path points
@Slf4j
public class PathmakerPath
{
    // Map with RegionIDs for keys with an ArrayList<PathPoint> for the specified region
    // Because a path might be spread across multiple regions
    private final HashMap<Integer, ArrayList<PathPoint>> pathPoints = new HashMap<>();
    Color color;
    boolean loopPath = false;
    boolean hidden = false;
    boolean panelExpanded = true;
	int pathDrawOffset = PathPanel.pathDrawOffset.OFFSET_MIDDLE.ordinal(); // PathPanel.pathDrawOffset enum
	int drawToPlayer = PathPanel.drawFromPlayerMode.NEVER.ordinal();
	String pathGroup = null;
	PathmakerConfig.pathPointLabelMode labelMode = PathmakerConfig.pathPointLabelMode.BOTH;
	PathmakerConfig.pathPointMode pointDrawMode = PathmakerConfig.pathPointMode.BOTH;

    PathmakerPath(PathPoint initialPathPoint)
    {
        addPathPoint(initialPathPoint);
    }

    // Add point to existing path
    void addPathPoint(PathPoint pathPoint)
    {
        addPathPoint(pathPoint, pathPoint.getRegionId());
    }

    void addPathPoint(PathPoint pathPoint, int regionId)
    {
        // Add the tile's regionID as key for the belonging tile(s) if it doesn't already exist.
        if (!pathPoints.containsKey(regionId))
        {
            pathPoints.put(regionId, new ArrayList<>());
        }
        pathPoints.get(regionId).add(pathPoint);

        if(pathPoint.getDrawIndex() == -1)
            pathPoint.setDrawIndex(getSize()-1);
    }

    void removePathPoint(PathPoint point)
    {
        int removedIndex = point.getDrawIndex();

		if (removedIndex != getSize()-1)
		{
			getPointAtDrawIndex(removedIndex+1).drawToPrevious = point.drawToPrevious;
		}

        innerRemovePathPoint(point);

        ArrayList<PathPoint> drawOrder = getDrawOrder(null);
        for(int i = removedIndex; i < drawOrder.size(); i++)
        {
            drawOrder.get(i).setDrawIndex(i);
        }
    }

    // ONLY use this if moving tiles between regions! Removes point without reordering the draw order
    private void innerRemovePathPoint(PathPoint point)
    {
        int regionId = point.getRegionId();

        // Remove pathPoint from the ArrayList<PathPoint>
        pathPoints.get(regionId).remove(point);
        pathPoints.get(regionId).trimToSize();

        // Remove RegionID key if the ArrayList is empty.
        if (pathPoints.get(regionId).isEmpty())
        {
            pathPoints.remove(regionId);
        }
    }

    // Fetch all path points and close any draw index gaps
    void reconstructDrawOrder()
    {
        ArrayList<PathPoint> drawOrder = getDrawOrder(null);
        boolean startRearrangement = false;
        for  (int i = 0; i < drawOrder.size(); i++)
        {
            if (drawOrder.get(i).getDrawIndex() != i)
            {
                startRearrangement = true;
            }
            if (startRearrangement)
            {
                drawOrder.get(i).setDrawIndex(i);
            }
        }
    }

    // Remove point from old and add to new region. Reordering for iteration convenience.
    // The point xyz is moved independently.
    void updatePointRegion(PathPoint point, int newRegionId)
    {
        int oldRegionId = point.getRegionId();
        innerRemovePathPoint(point);
        addPathPoint(point, newRegionId);
        reconstructRegionDrawOrder(newRegionId);
    }

    // Return the relevant region IDs for this path
    Set<Integer> getRegionIDs()
    {
        return  pathPoints.keySet();
    }

    // Return tiles based on their regionID
    ArrayList<PathPoint> getPointsInRegion(int regionID)
    {
        return  pathPoints.get(regionID);
    }

    boolean hasPointsInRegion(int regionID)
    {
        return  pathPoints.containsKey(regionID);
    }

    boolean hasPointInRegion(int regionID, PathPoint point)
    {
        if(!pathPoints.containsKey(regionID)) return false;
        return pathPoints.get(regionID).contains(point);
    }


    // 2 -> 0
    // !newGreater
    // start = newIndex
    // target = oldIndex
    // i < target
    // idx += 1

    // 0 -> 2
    // newGreater
    // start = oldIndex + 1
    // target = newIndex + 1
    // i < target
    // idx += -1

// An easier look at what's going on in the uncommented for loop below
//        if(newGreater)
//        {
//            // 3p
//            // 0 -> 2
//            for(int i = oldIndex + 1; i <= newIndex; i++)
//            {
//                getPointAtDrawIndex(i).setDrawIndex(i - 1);
//            }
//        }
//        else
//        {
//            // 3p
//            // 2 -> 0
//            for(int i = oldIndex - 1; i >= newIndex; i--)
//            {
//                getPointAtDrawIndex(i).setDrawIndex(i + 1);
//            }
//        }

    // Set new draw index for a specific point and move the other point's indices accordingly
    void setNewIndex(PathPoint point, final int newIndex)
    {
        int oldIndex = point.getDrawIndex();

        if (oldIndex == newIndex){return;}

        boolean newGreater = newIndex > oldIndex;

        int indexMoveDir = newGreater ? -1 : 1;
        int startIndex = newGreater ? oldIndex + 1 : newIndex;
        int targetIndex = newGreater ? newIndex + 1 : oldIndex;

        ArrayList<PathPoint> pointsToMove = new ArrayList<>();
        ArrayList<Integer> regionsToReconstruct = new ArrayList<>();

        regionsToReconstruct.add(point.getRegionId());

        for(int i = startIndex; i < targetIndex; i ++)
        {
            pointsToMove.add(getPointAtDrawIndex(i));
        }

        // Changing draw index above is total bait, as it messes with getPointAtDrawIndex
        // So doing it here.
        for(int i = 0; i < pointsToMove.size(); i ++)
        {
            pointsToMove.get(i).setDrawIndex(pointsToMove.get(i).getDrawIndex() + indexMoveDir); // int indexMoveDir = newGreater ? -1 : 1;

            if(!regionsToReconstruct.contains(pointsToMove.get(i).getRegionId()))
            {
                regionsToReconstruct.add(pointsToMove.get(i).getRegionId());
            }
        }

        // Assign the specified index to the specified point
        point.setDrawIndex(newIndex);

        // Once the points have been reassigned their draw order, reorder the affected ArrayList to match
        // as this will make it easier for our getDrawOrder later
        for (int regionId : regionsToReconstruct)
        {
            reconstructRegionDrawOrder(regionId);
        }
    }

    // Sort the specified ArrayList in the order of draw indices
    void reconstructRegionDrawOrder(int regionId)
    {
        if (pathPoints.get(regionId).size() < 2) {return;}

        while(true)
        {
            boolean regionOrdered = true;
            for (int i = 1; i < pathPoints.get(regionId).size(); i++)
            {
                if(pathPoints.get(regionId).get(i).getDrawIndex() < pathPoints.get(regionId).get(i-1).getDrawIndex())
                {
                    Collections.swap(pathPoints.get(regionId), i, i-1);
                    regionOrdered = false;
                }
            }

            if(regionOrdered){break;}
        }
    }

    boolean isPointInRegions(PathPoint point, int[] regionIDs)
    {
        for (int regionID : regionIDs)
        {
            if (point.getRegionId() == regionID) {
                return true;
            }
        }
        return false;
    }

    boolean isPointInRegions(PathPoint point, ArrayList<Integer>regionIDs)
    {
        return regionIDs.contains(point.getRegionId());
    }

    boolean containsPoint(PathPoint point)
    {
        for (ArrayList<PathPoint> regionPoints : pathPoints.values())
            if (regionPoints.contains(point))
                return true;

        return false;
    }

    boolean containsEntity(int[] loadedRegions, boolean isNpc, int id)
    {
        for (int regionId : loadedRegions)
        {
            if (containsEntity(regionId, isNpc, id))
            {
                return true;
            }
        }
        return false;
    }

    // Only checking points within the loaded regions.
    boolean containsEntity(int region, boolean isNpc, int id)
    {
        if (!pathPoints.containsKey(region)) return false;

        for (PathPoint regionPoint : pathPoints.get(region))
        {
            if (regionPoint instanceof PathPointObject &&
                        ((PathPointObject) regionPoint).getEntityId() == id &&
                        ((PathPointObject) regionPoint).isNpc() == isNpc)
                return true;
        }
        return false;
    }

    PathPoint getPointAtDrawIndex(int index)
    {
        for(int regionId : pathPoints.keySet())
        {
            for (PathPoint point : pathPoints.get(regionId))
            {
                if (point.getDrawIndex() == index)
                {
                    return point;
                }
            }
        }

        log.debug("Could not find point at index: {}", index);
        return null;
    }

    public ArrayList<PathPoint> getReversedDrawOrder()
    {
        ArrayList<PathPoint> reverseDrawOrder = new ArrayList<>(getDrawOrder(null));
        Collections.reverse(reverseDrawOrder);
        return reverseDrawOrder;
    }

    public ArrayList<PathPoint> reverseDrawOrder()
    {
        ArrayList<PathPoint> reverseDrawOrder = getDrawOrder(null);
        for(int i = 0; i < getSize(); i++)
        {
            reverseDrawOrder.get(i).setDrawIndex(getSize() - 1 - i);
        }

        for (int regionId : pathPoints.keySet())
        {
            Collections.reverse(pathPoints.get(regionId));
        }

        return reverseDrawOrder;
    }

    // Return the size of all stored points (across all relevant regions) for this path
    int getSize()
    {
        int numPoints = 0;
        if(!pathPoints.isEmpty())
        {
            for (int regionId : pathPoints.keySet()) {
                numPoints += pathPoints.get(regionId).size();
            }
        }
        return numPoints;
    }

    // Return an ArrayList with the PathPoints in the order they should be drawn
    // NB! If param loadedRegions is null, then getDrawOrder will return the tiles also
    // NOT in loaded regions. (which you don't want to render, but is for sorting. See reconstructDrawOrder())
    ArrayList<PathPoint> getDrawOrder(@Nullable ArrayList<Integer> loadedRegions)
    {
        ArrayList<PathPoint> drawOrder = new ArrayList<>();

        // Calculate the number of points to collect (points that are inside the loaded regions)
        int numPointsToLoad = loadedRegions == null ? getSize() : 0;
        int searchIndex = 0;

        // Creating a map for tracking the last index checked in each of the RegionIDs
        // (which is used as keys for pathPoint) so the loops do not start at 0 every time
        // This works because stored points are sorted in their individual region ArrayLists
        // based on their draw order.
        final HashMap<Integer, Integer> loopIndexTracker = new HashMap<>();


        // Get the highest index value to be used as target, mostly in case of gaps
        int endIndex = 0;

        // If loadedRegions is null then return the full list of points in draw order regardless of region
        if(loadedRegions == null)
        {
            for (int regionId : pathPoints.keySet())
            {
                loopIndexTracker.put(regionId, 0);

                int numInRegion = pathPoints.get(regionId).size();
                int lastRegionIndex = pathPoints.get(regionId).get(numInRegion - 1).getDrawIndex();
                endIndex = Math.max(lastRegionIndex, endIndex);
            }

        }
        else
        {
            searchIndex = getSize();

            // Collect relevant regionIds with points that are both loaded and stored
            for (Integer loadedRegion : loadedRegions)
            {
                // Skip if region isn't loaded
                if (!pathPoints.containsKey(loadedRegion))
                {continue;}

                // Add regionID to the loop tracker
                loopIndexTracker.put(loadedRegion, 0);

                // Get final draw index. This will be used to limit the following while-loop
                int numInRegion = pathPoints.get(loadedRegion).size();
                int lastRegionIndex = pathPoints.get(loadedRegion).get(numInRegion - 1).getDrawIndex();
                endIndex = Math.max(lastRegionIndex, endIndex);

                numPointsToLoad += numInRegion;

                // Determine the starting draw index (may not be 0 if that tile is in an unloaded region)
                searchIndex = Math.min(pathPoints.get(loadedRegion).get(0).getDrawIndex(), searchIndex);

            }
        }

        // Iterate through the relevant list of points, collecting the points in the order of their draw index
        int lastSize = -1;
        while(drawOrder.size() < numPointsToLoad)
        {
            // If the next draw index cant be found, increase the index search gap
            if (lastSize == drawOrder.size())
            {
                searchIndex += 1;

                // Break if failed to find point within the scope
                if (searchIndex > endIndex)
                {
                    log.debug("Missing draw indices {}, out of: {}", numPointsToLoad- drawOrder.size(), numPointsToLoad);
                    break;
                }
            }


            lastSize = drawOrder.size();

            // Look for point with draw index equal to searchIndex. Store and break the current iterator index for a given ArrayList in
            // loopIndexTracker if the point found has an index that is greater than searchIndex.
            for (int relevantRegionId : loopIndexTracker.keySet())
            {
                for (int i = loopIndexTracker.get(relevantRegionId); i < pathPoints.get(relevantRegionId).size(); i++)
                {
                    PathPoint point = pathPoints.get(relevantRegionId).get(i);
                    int pointIndex = point.getDrawIndex();

                    if (pointIndex == searchIndex)
                    {
                        drawOrder.add(point);
                        searchIndex += 1;
                    }
                    else if (pointIndex > drawOrder.size())
                    {
                        loopIndexTracker.put(relevantRegionId, i);
                        break;
                    }
                    loopIndexTracker.put(relevantRegionId, i+1);
                }
            }
        }
        return drawOrder;
    }

	void loadPoints(HashMap<Integer, ArrayList<PathPoint>> pointsToLoad)
	{
		pathPoints.clear();
		pathPoints.putAll(pointsToLoad);
	}
}


/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.awt.Color;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class DragAdapter extends MouseMotionAdapter
{
	JPanel parentPanel;
	JPanel panel;
	boolean isGroupPanel;
	int panelMargin;

	DragAdapter(JPanel parentPanel, JPanel panel, int panelMargin)
	{
		this.parentPanel = parentPanel;
		this.panel = panel;
		this.panelMargin = panelMargin;
	}

	@Override
	public void mouseDragged(MouseEvent e)
	{
		super.mouseDragged(e);
		int panelIndex = -1;
		int pathCounter = 0;

		// Reset borders and find panelIndex
		for (int i = 0; i < parentPanel.getComponentCount(); i++)
		{
			JPanel p = ((JPanel) parentPanel.getComponents()[i]);

			if(p instanceof GroupPanel)
				p.setBorder(((GroupPanel) p).createDefaultBorder());
			else
				p.setBorder(BorderFactory.createEmptyBorder());

			if (p == panel)
			{
				panelIndex = pathCounter;
			}
			else if (p instanceof GroupPanel)
			{
				int groupedPathCount = ((GroupPanel) p).getPathPanelCount();
				for (int ii = 0; ii < groupedPathCount; ii++)
				{
					if (((GroupPanel) p).getPathPanel(ii) == panel)
					{
						panelIndex = pathCounter;
					}
				}
				pathCounter += groupedPathCount;
			}
			else
			{
				pathCounter++;
			}
		}

		// Set the dragged colour
		MouseAdapterUtils.setPanelInnerBorderColor(panel, Color.RED);
		parentPanel.repaint();

		int targetIndex = MouseAdapterUtils.getHoveredPathIndex(e, parentPanel);
		//log.debug("panelIndex: " + panelIndex + " targetIndex: " + targetIndex);
		if (!MouseAdapterUtils.isIndexValidDropTarget(panelIndex, MouseAdapterUtils.getTrueIndexInView(parentPanel, targetIndex))) return;

		// Is mouse on the path border?
		JPanel targetPanel = (JPanel) parentPanel.getComponent(targetIndex);
		int mouseOnBorder = MouseAdapterUtils.isMouseHoveringPathBorder(e, parentPanel, targetPanel, panelMargin);

		// Set the hovered path color
		if (mouseOnBorder == 1)
		{
			JPanel topPanel = targetIndex > 0 ? (JPanel) parentPanel.getComponent(targetIndex - 1) : null;
			MouseAdapterUtils.createGapBorders(topPanel, targetPanel, Color.GREEN);
		}
		else if (mouseOnBorder == -1)
		{
			JPanel bottomPanel = targetIndex < parentPanel.getComponentCount() - 1 ? (JPanel) parentPanel.getComponent(targetIndex + 1) : null;
			MouseAdapterUtils.createGapBorders(targetPanel, bottomPanel, Color.GREEN);
		}
		// Not allowing group placement directly on other pathView Entries.
		else if (!(panel instanceof GroupPanel))
			MouseAdapterUtils.setPanelInnerBorderColor(targetPanel, Color.GREEN);
		targetPanel.repaint();
	}
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.ComponentOrientation;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.GridLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.util.ImageUtil;
import java.awt.datatransfer.DataFlavor;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import javax.swing.border.EmptyBorder;
import javax.swing.text.AbstractDocument;

@Slf4j
public class PathmakerPluginPanel extends PluginPanel
{
	private static final ImageIcon IMPORT_ICON;
	private static final ImageIcon EXPORT_ICON;
	private static final ImageIcon COG_ICON;

	private final PluginErrorPanel noPathPanel = new PluginErrorPanel();
	final JPanel pathView = new JPanel();
	HashMap<String, PathGroup> pathGroups = new HashMap<>();

	Client client;
	PathmakerPlugin plugin;

	FlatTextField activePath;
	final int MAX_PATH_NAME_LENGTH = 20;
	//final int DRAG_DROP_Y_MARGIN = 10;

	static
	{
		IMPORT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "import.png"));
		EXPORT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "export.png"));
		COG_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "cog.png"));
	}

	static class PathGroup
	{
		boolean expanded = true;
		boolean hidden = false;
		Color color = new Color(0, 100,100);
	}

	PathmakerPluginPanel(Client client, PathmakerPlugin plugin)
	{
		this.client = client;
		this.plugin = plugin;

		// Define standard client panel layout
		setLayout(new BorderLayout());
		//setBorder(new EmptyBorder(10, 10, 10, 10));

		// Create title
		JLabel title = new JLabel();
		title.setText("Pathmaker");
		title.setPreferredSize(new Dimension(70, 20)); //getGraphics().getFontMetrics().stringWidth(title.getText()) + 10
		title.setForeground(Color.WHITE);
		title.setToolTipText("by Fraph");
		title.setFont(title.getFont().deriveFont(Font.BOLD));

		// EXPORT / IMPORT
		JButton exportButton = new JButton();
		exportButton.setIcon(EXPORT_ICON);
		exportButton.setToolTipText("Export active path to clipboard");
		exportButton.setPreferredSize(new Dimension(18, 18));
		exportButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (!plugin.getStoredPaths().containsKey(activePath.getText()))
				{
					return;
				}

				//new Pair<String, PathmakerPath>(activePath.getText(), plugin.getStoredPaths().get(activePath.getText()));
				JsonObject exportPath = new JsonObject();
				exportPath.add(activePath.getText(), plugin.pathToJson(activePath.getText()));

				StringSelection json = new StringSelection(plugin.gson.toJson(exportPath));
				Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
				clipboard.setContents(json, null);
			}
		});

		JButton importButton = new JButton();
		importButton.setIcon(IMPORT_ICON);
		importButton.setToolTipText("Import path from clipboard");
		importButton.setPreferredSize(new Dimension(18, 18));
		importButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				String json = "";
				try
				{
					json = (String) getToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);
				}
				catch (IllegalArgumentException | UnsupportedFlavorException | IllegalStateException |
					   NullPointerException | IOException ex)
				{
					log.debug("Clipboard is unavailable or has invalid content");
				}

				if (json.isEmpty())
				{
					return;
				}

				JsonObject object;
				try
				{
					JsonParser parser = new JsonParser();
					JsonElement element = parser.parse(json);
					if (element == null || !element.isJsonObject())
					{
						log.debug("Imported element is not a JsonObject");
						return;
					}

					object = element.getAsJsonObject();
				}
				catch (Exception e)
				{
					log.debug("String was not a valid JSON");
					return;
				}

				String jsonName = object.keySet().iterator().next();

				if (object.getAsJsonObject(jsonName).has("members"))
					importGroup(importButton, jsonName, object.getAsJsonObject(jsonName));
				else
					importPath(importButton, jsonName, object.getAsJsonObject(jsonName), true, true,null);
			}
		});

		JPanel centerActionTitlePanel = new JPanel();
		centerActionTitlePanel.add(importButton, BorderLayout.WEST);
		centerActionTitlePanel.add(exportButton, BorderLayout.EAST);
		importButton.setBackground(centerActionTitlePanel.getBackground());
		exportButton.setBackground(centerActionTitlePanel.getBackground());

		// Config button
		JButton configButton = new JButton();
		configButton.setIcon(COG_ICON);
		configButton.setToolTipText("Open plugin configuration");
		configButton.setPreferredSize(new Dimension(18, 18));

		// Dummy OverlayPanel class for providing a method of getting from the plugin panel to config menu
		class ToConfigOverlayPanel extends OverlayPanel{ToConfigOverlayPanel(PathmakerPlugin plugin){super(plugin);}}
		configButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				plugin.eventBus.post(new OverlayMenuClicked(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, null, null), new ToConfigOverlayPanel(plugin)));
			}
		});

		JPanel rightActionTitlePanel = new JPanel();
		rightActionTitlePanel.add(configButton, BorderLayout.CENTER);
		configButton.setBackground(rightActionTitlePanel.getBackground());

		// Create body panel and add titlePanel
		JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));
		northPanel.add(title, BorderLayout.WEST);
		northPanel.add(centerActionTitlePanel, BorderLayout.CENTER);
		northPanel.add(rightActionTitlePanel, BorderLayout.EAST);

		// Add Active Path text field
		JLabel activePathLabel = new JLabel("Active Path: ");
		activePathLabel.setPreferredSize(new Dimension(75, 20));
		activePathLabel.setForeground(Color.WHITE);

		activePath = new FlatTextField();
		((AbstractDocument) activePath.getDocument()).setDocumentFilter(new MaxLengthFilter(MAX_PATH_NAME_LENGTH));
		activePath.setText("unnamed");
		activePath.setForeground(Color.WHITE);
		activePath.setBackground(Color.DARK_GRAY);

		JPanel activePathPanel = new JPanel(new BorderLayout());
		activePathPanel.add(activePathLabel, BorderLayout.WEST);
		activePathPanel.add(activePath, BorderLayout.CENTER);

		northPanel.add(activePathPanel, BorderLayout.SOUTH);

		// Add panel to client panel
		add(northPanel, BorderLayout.NORTH);

		// Configure path view panel
		pathView.setLayout(new BoxLayout(pathView, BoxLayout.Y_AXIS));

		// Configure PluginErrorPanel
		noPathPanel.setVisible(false);
		//noPathPanel.setPreferredSize(new Dimension(50, 30));
		noPathPanel.setContent("No stored paths", "Shift right-click a tile to add a path point.");

		// Add body panel
		JPanel centerPanel = new JPanel(new BorderLayout());
		//centerPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH-5, 0));
		centerPanel.add(noPathPanel, BorderLayout.NORTH);

		centerPanel.add(pathView, BorderLayout.CENTER);

		add(centerPanel, BorderLayout.CENTER);

		rebuild();
	}

	void importGroup(JButton importButton, String groupName, JsonObject object)
	{
		JsonObject members = object.getAsJsonObject("members");
		JLabel centeredNameText = new JLabel("Group name", JLabel.CENTER);
		String inputGroupName = JOptionPane.showInputDialog(importButton, centeredNameText, groupName);

		for  (String pathName : members.keySet())
		{
			importPath(importButton, pathName, members.getAsJsonObject(pathName), false, false, inputGroupName);
		}

		PathGroup group = new PathGroup();
		if (object.has("expanded"))
			group.expanded = plugin.gson.fromJson(object.get("expanded"), boolean.class);
		if (object.has("hidden"))
			group.hidden = plugin.gson.fromJson(object.get("hidden"), boolean.class);
		if (object.has("color"))
			group.color = plugin.gson.fromJson(object.get("color"), Color.class);

		pathGroups.put(groupName, group);

		plugin.rebuildPanel(true);
	}

	void importPath(JButton importButton, String jsonPathName, JsonObject object, boolean rebuildPanel, boolean askForPathName, @Nullable String inputGroupName)
	{
		String inputPathName;
		if(askForPathName || plugin.getStoredPaths().containsKey(jsonPathName))
		{
			JLabel centeredNameText;
			if(plugin.getStoredPaths().containsKey(jsonPathName))
				centeredNameText = new JLabel("Path name already exists", JLabel.CENTER);
			else
				centeredNameText = new JLabel("Path name", JLabel.CENTER);
			centeredNameText.setHorizontalTextPosition(SwingConstants.CENTER);
			//String pathName = JOptionPane.showInputDialog(importButton, centeredNameText, loadedPath.getKey());
			inputPathName = JOptionPane.showInputDialog(importButton, centeredNameText, jsonPathName);
		}
		else
			inputPathName = jsonPathName;

		// Return if the window was cancelled or closed
		if (inputPathName == null)
		{
			return;
		}

		PathmakerPath path = null;

		inputPathName = inputPathName.length() > MAX_PATH_NAME_LENGTH ?
			inputPathName.substring(0, MAX_PATH_NAME_LENGTH) : inputPathName;

		// Show warning if imported path exists
		if (plugin.getStoredPaths().containsKey(inputPathName))
		{
			JLabel centeredWarningText = new JLabel("The path name " + inputPathName + " already exist.", JLabel.CENTER);
			JLabel centeredReplaceText = new JLabel("Replace it?", JLabel.CENTER);

			centeredWarningText.setHorizontalTextPosition(SwingConstants.CENTER);
			centeredReplaceText.setHorizontalTextPosition(SwingConstants.CENTER);

			JPanel centeredTextFrame = new JPanel(new GridLayout(0, 1));
			centeredTextFrame.setAlignmentX(Component.CENTER_ALIGNMENT);
			centeredTextFrame.add(centeredWarningText);
			centeredTextFrame.add(centeredReplaceText);

			int confirm = JOptionPane.showConfirmDialog(null,
				centeredTextFrame, "Warning", JOptionPane.YES_NO_OPTION);

			if (confirm == JOptionPane.YES_OPTION)// || confirm == JOptionPane.CLOSED_OPTION)
			{
				plugin.removePath(inputPathName);
				path = plugin.loadPathFromJson(object, inputPathName);
				activePath.setText(inputPathName);
			}
		}
		else
		{
			path = plugin.loadPathFromJson(object, inputPathName);
			activePath.setText(inputPathName);
		}

		if(path != null && inputGroupName != null)
			path.pathGroup = inputGroupName;
		if(rebuildPanel)
			plugin.rebuildPanel(true);
	}

	void rebuild()
	{
		pathView.removeAll();

		ArrayList<String> pathKeys = new ArrayList<>(plugin.getStoredPaths().keySet());
		ArrayList<String> validGroups = new ArrayList<>();
		String validGroup = null;

		for (int i = 0;  i < pathKeys.size(); i++)
		{
			String pathLabel = pathKeys.get(i);

			PathPanel pathEntry = new PathPanel(plugin, pathLabel);

			// Set as active path on label click
			pathEntry.getPathLabelButton().addActionListener(actionEvent ->
			{
				activePath.setText(pathEntry.getPathLabel());
			});

			int PANEL_MARGIN = 10;

			// Injecting an available group name whenever a PathPanel is dropped, to avoid passing the entire groupNames array
			DropAdapter dropAdapter = new DropAdapter(plugin, pathView, pathEntry, i, pathLabel, PANEL_MARGIN);
			pathEntry.getPathLabelButton().addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseReleased(MouseEvent e)
				{
					super.mouseReleased(e);
					dropAdapter.setAvailableGroupName(plugin.getAvailableName(pathGroups,"group"));
					dropAdapter.mouseReleased(e);
					dropAdapter.setAvailableGroupName(null);
				}
			});

			pathEntry.getPathLabelButton().addMouseMotionListener(new DragAdapter(pathView, pathEntry, PANEL_MARGIN));

			String groupName = plugin.getStoredPaths().get(pathLabel).pathGroup;

			if (groupName == null)
			{
				validGroup = null;
				pathView.add(pathEntry);
			}
			else
			{
				// Validate a group on first occurrence, by comparing it to the following path's group
				// If they're equal, then the group is valid.
				if (validGroup == null || !validGroup.equals(groupName))
				{
					validGroup = null;

					// Group is invalid
					if (i == pathKeys.size() - 1 ||
						!groupName.equals(plugin.getStoredPaths().get(pathKeys.get(i+1)).pathGroup))
					{
						plugin.getStoredPaths().get(pathLabel).pathGroup = null;
						pathView.add(pathEntry);
					}
					else // Group is valid, create it
					{
						validGroup = groupName;
						validGroups.add(validGroup);

						GroupPanel groupPanel = new GroupPanel(plugin, pathView, pathEntry, groupName, i);
						if (!pathGroups.containsKey(groupName))
						{
							pathGroups.put(groupName, new PathGroup());
						}
						else
						{
							groupPanel.importGroupData(pathGroups.get(groupName));
						}
						pathView.add(groupName, groupPanel);
						groupPanel.groupTextField.getTextField().addKeyListener(addOnGroupNameChangedListener(groupName, groupPanel));
					}
				}
				else // Last component is a valid group which this path belongs to
				{
					GroupPanel lastGroupPanel = ((GroupPanel) pathView.getComponent(pathView.getComponentCount()-1));
					lastGroupPanel.addPathPanel(pathEntry);

					if (i == pathKeys.size() - 1 || !groupName.equals(plugin.getStoredPaths().get(pathKeys.get(i+1)).pathGroup))
						lastGroupPanel.importGroupData(pathGroups.get(groupName));

				}
			}
		}

		// Delete invalid groups (ones with less than 2 group members next to each other)
		pathGroups = (HashMap<String, PathGroup>) pathGroups.entrySet().stream().filter(
			e -> validGroups.contains(e.getKey())).collect(Collectors.toMap(
				Map.Entry::getKey,
				Map.Entry::getValue));

		boolean empty = pathView.getComponentCount() == 0;
		noPathPanel.setVisible(empty);

		repaint();
		revalidate();
	}

	KeyAdapter addOnGroupNameChangedListener(String groupName, GroupPanel groupPanel)
	{
		JTextField textField = groupPanel.groupTextField.getTextField();
		return new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				super.keyPressed(e);

				if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					textField.setText(groupName);
					groupPanel.finalizeEditing();
				}

				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					// If name changed: rename entries group name
					if (!textField.getText().equals(groupName))
					{
						//log.debug("finalizeEditing: group name changed from {} to {}", groupName, groupTextField.getText());
						for (Component c : groupPanel.memberPanel.getComponents())
						{
							String pathLabel = ((PathPanel) c).getPathLabel();
							plugin.getStoredPaths().get(pathLabel).pathGroup = textField.getText();
						}

						PathGroup group = pathGroups.remove(groupName);
						pathGroups.put(groupPanel.getGroupName(), group);
						plugin.rebuildPanel(true);
						return;
					}

					groupPanel.finalizeEditing();
				}
			}
		};
	}
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;


@ConfigGroup(PathmakerConfig.CONFIG_GROUP)
public interface PathmakerConfig extends Config
{
    String CONFIG_GROUP = "pathmaker";
    String SHOW_MAP_ORB_MENU_OPTIONS = "showMapOrbMenuOptions";

    //------------------------------------------------------------//
    // Player Tile Section
    //------------------------------------------------------------//
    @ConfigSection(
            name = "Player tile",
            description = "Player tile configuration.",
            position = 3
    )
    String playerTile = "playerTile";

    @ConfigItem(
            keyName = "highlightCurrentTile",
            name = "Highlight true tile",
            description = "Highlights true tile player is on as seen by server.",
            position = 1,
            section = playerTile
    )
    default boolean highlightPlayerTile()
    {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "highlightCurrentColor",
            name = "Highlight color",
            description = "Configures the highlight color of current true tile.",
            position = 2,
            section = playerTile
    )
    default Color highlightPlayerColor()
    {
        return Color.CYAN;
    }

//    @Alpha
//    @ConfigItem(
//            keyName = "currentTileFillColor",
//            name = "Fill color",
//            description = "Configures the fill color of current true tile.",
//            position = 3,
//            section = playerTile
//    )
//    default Color playerTileFillColor()
//    {
//        return new Color(0, 0, 0, 50);
//    }

    @ConfigItem(
            keyName = "currentTileBorderWidth",
            name = "Border width",
            description = "Width of the true tile marker border.",
            position = 3,
            section = playerTile
    )
    @Range(max = 10)
    default int playerTileBorderWidth()
    {
        return 2;
    }

    //------------------------------------------------------------//
    // Hovered Tile Section
    //------------------------------------------------------------//
    @ConfigSection(
            name = "Hovered tile",
            description = "Cursor hovered tile configuration.",
            position = 2
    )
    String hoveredTile = "hoveredTile";


    enum hoveredTileDrawMode
    {
        NEVER,
        SHIFT_DOWN,
        ALWAYS,
    }
    @ConfigItem(
            keyName = "hoveredTileDrawModeSelect",
            name = "Hovered tile mode",
            description = "When the hovered tile elements should be drawn",
            position = 1,
            section = hoveredTile
    )
    default hoveredTileDrawMode hoveredTileDrawModeSelect()
    {
        return hoveredTileDrawMode.SHIFT_DOWN;
    }

    @ConfigItem(
            keyName = "highlightHoveredTile",
            name = "Highlight tile",
            description = "Highlights the tile that the player is hovering over.",
            position = 2,
            section = hoveredTile
    )
    default boolean highlightHoveredTile()
    {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "highlightHoveredColor",
            name = "Highlight color",
            description = "Configures the highlight color of hovered tile.",
            position = 3,
            section = hoveredTile
    )
    default Color highlightHoveredColor()
    {
        return new Color(255, 0, 0, 255);
    }

//    @Alpha
//    @ConfigItem(
//            keyName = "hoveredTileFillColor",
//            name = "Fill color",
//            description = "Configures the fill color of hovered tile.",
//            position = 4,
//            section = hoveredTile
//    )
//    default Color hoveredTileFillColor()
//    {
//        return new Color(255, 0, 0, 50);
//    }

    @ConfigItem(
            keyName = "hoveredTileBorderWidth",
            name = "Tile border width",
            description = "Width of the hovered tile marker border.",
            position = 4,
            section = hoveredTile
    )
    @Range(max = 10)
    default int hoveredTileBorderWidth()
    {
        return 2;
    }

    enum hoveredTileLabelMode
    {
        NONE,
        REGION,
        LOCATION,
        OFFSET,
        DISTANCE,
        ALL,
    }
    @ConfigItem(
            keyName = "hoveredTileLabelModeSelect",
            name = "Tile label mode",
            description = "Label to be placed on the hovered tile.",
            position = 5,
            section = hoveredTile
    )
    default hoveredTileLabelMode hoveredTileLabelModeSelect()
    {
        return hoveredTileLabelMode.NONE;
    }

    @Alpha
    @ConfigItem(
            keyName = "hoveredTileLabelColor",
            name = "Tile label color",
            description = "Configures the fill color of hovered tile label.",
            position = 6,
            section = hoveredTile
    )
    default Color hoveredTileLabelColor()
    {
        return new Color(255, 255, 0, 255);
    }

    @Alpha
    @ConfigItem(
            keyName = "drawHoverLine",
            name = "Draw line",
            description = "Draw line to hovered tile",
            position = 7,
            section = hoveredTile
    )
    default boolean drawHoverLine()
    {
        return true;
    }

    enum hoveredTileLineOrigin
    {
        TRUE_TILE,
        PATH_END,
    }
    @ConfigItem(
            keyName = "hoveredTileLineModeSelect",
            name = "Line origin",
            description = "Origin of hovered tile line.",
            position = 8,
            section = hoveredTile
    )
    default hoveredTileLineOrigin hoveredTileLineOriginSelect()
    {
        return hoveredTileLineOrigin.PATH_END;
    }

//    @Alpha
//    @ConfigItem(
//            keyName = "hoveredTileLineColor",
//            name = "Line color",
//            description = "Configures the line to the hovered tile color.",
//            position = 9,
//            section = hoveredTile
//    )
//    default Color hoveredTileLineColor()
//    {
//        return new Color(255, 0, 0, 255);
//    }

    @Alpha
    @ConfigItem(
            keyName = "hoverLineColorMatchPath",
            name = "Match active path",
            description = "Match the active path color",
            position = 9,
            section = hoveredTile
    )
    default boolean hoverLineColorMatchPath()
    {
        return false;
    }

    //------------------------------------------------------------//
    // Path Line Section
    //------------------------------------------------------------//
    @ConfigSection(
            name = "Path defaults",
            description = "Path configuration.",
            position = 1
    )
    String path = "path";

    @ConfigItem(
            keyName = "drawPath",
            name = "Draw",
            description = "Render path lines",
            section = path
    )
    default boolean drawPath()
    {
        return true;
    }


	enum pathPointMode
	{
		NONE,
		TILES,
		ENTITIES,
		BOTH,
	}
    @ConfigItem(
            keyName = "drawPathPoints",
            name = "Draw points",
            description = "Highlight path points mode.",
            section = path
    )
    default pathPointMode drawPathPointsMode()
    {
        return pathPointMode.BOTH;
    }

//	@ConfigItem(
//		keyName = "objectAndNpcOutline",
//		name = "Object and NPC outline",
//		description = "Draw an outline on objects and NPCs",
//		section = path
//	)
//	default boolean objectAndNpcOutline()
//	{
//		return true;
//	}

    @ConfigItem(
            keyName = "pathWidth",
            name = "Path width",
            description = "Width of the path line.",
            section = path
    )
    @Range(max = 10)
    default int pathLineWidth()
    {
        return 2;
    }

    @Alpha
    @ConfigItem(
            keyName = "pathLineColor",
            name = "Default path color",
            description = "Configures the default path color.",
            section = path
    )
    default Color pathColor()
    {
        return new Color(0, 255, 0, 255);
    }

    @Alpha
    @ConfigItem(
            keyName = "pathLinePointColor",
            name = "Path point tile color",
            description = "Configures the path line point tile color.",
            section = path
    )
    default Color pathLinePointColor()
    {
        return new Color(0, 150, 0, 255);
    }

	@ConfigItem(
		keyName = "pointMatchPathColor",
		name = "Points match path color",
		description = "Set path points to match path color.",
		section = path
	)
	default boolean pointMatchPathColor()
	{
		return true;
	}

//    @Alpha
//    @ConfigItem(
//            keyName = "pathLinePointFillColor",
//            name = "Path point tile fill color",
//            description = "Configures the path line point tile fill color.",
//            position = 8,
//            section = path
//    )
//    default Color pathLinePointFillColor()
//    {
//        return new Color(0, 255, 0, 50);
//    }

    @ConfigItem(
            keyName = "pathLinePointWidth",
            name = "Path point border width",
            description = "Width of the path line tile border.",
            section = path
    )
    @Range(min = 0, max = 10)
    default int pathLinePointWidth()
    {
        return 0;
    }

    @ConfigItem(
            keyName = "pathZOffset",
            name = "Path draw height",
            description = "Configure the default Z offset for paths.",
            section = path
    )
    @Range(min = 0, max = 20)
    default int pathZOffset()
    {
        return 0;
    }

    enum pathPointLabelMode
    {
        NONE,
        INDEX,
        LABEL,
        BOTH,
    }
    @ConfigItem(
            keyName = "pathPointLabelModeSelect",
            name = "Point text",
            description = "Set path point text mode.",
            section = path
    )
    default pathPointLabelMode pathPointLabelMode()
    {
        return pathPointLabelMode.BOTH;
    }

    @ConfigItem(
            keyName = "labelZOffset",
            name = "Label height offset",
            description = "Set label height offset from tile.",
            section = path
    )
    @Range(max = 20)
    default int labelZOffset()
    {
        return 0;
    }

    @Alpha
    @ConfigItem(
            keyName = "pathPointLabelColor",
            name = "Path point label color",
            description = "Configures default the color of point labels.",
            section = path
    )
    default Color pathPointLabelColor()
    {
        return Color.YELLOW;
    }

    @ConfigItem(
            keyName = "labelMatchPathColor",
            name = "label match path color",
            description = "Set labels to match path color.",
            section = path
    )
    default boolean labelMatchPathColor()
    {
        return false;
    }

	@ConfigItem(
		keyName = "objectAndNpcOutlineWidth",
		name = "Outline width",
		description = "Set the width of outlines to be drawn on objects and NPCs",
		section = path
	)
	@Range(max = 10)
	default int objectAndNpcOutlineWidth()
	{
		return 2;
	}

    /*
    // Buttons appear, but missing func
    @ConfigItem(
            keyName = SHOW_MAP_ORB_MENU_OPTIONS,
            name = "Show map orb menu options",
            description = "Adds import/export/clear options to the world map orb.",
            position = 10,
            section = path
    )
    default boolean showMapOrbMenuOptions()
    {
        return true;
    }
     */

    //------------------------------------------------------------//
    // Path Container Section
    //------------------------------------------------------------//
//    @ConfigSection(
//            name = "Path Container",
//            description = "Contains all paths.",
//            position = 4
//    )
//    String pathContainer = "pathContainer";

//    @ConfigItem(
//            keyName = "activePath",
//            name = "Active path",
//            description = "The currently selected path to add points to.",
//            position = 2,
//            section = pathContainer
//    )
//    default String activePath()
//    {
//        return "Unnamed";
//    }
//
//    @ConfigItem(
//            keyName = "storedPaths",
//            name = "Stored paths",
//            description = "A list of all of the stored paths. !NB Updates by returning to the plugin list and changing focus away from the plugin panel.",
//            position = 3,
//            section = pathContainer
//    )
//    default String storedPaths()
//    {
//        return "";
//    }
//
//    @ConfigItem(
//            keyName = "storedPaths",
//            name = "",
//            description = ""
//    )
//    void setStoredPaths(String pathString);

    //------------------------------------------------------------//
    // Info Box Section
    //------------------------------------------------------------//
//    @ConfigSection(
//            name = "Info Box",
//            description = "Info Box configuration.",
//            position = 4
//    )
//    String infoBox = "infoBox";
//
//    @ConfigItem(
//            keyName = "infoBoxEnabled",
//            name = "Enabled",
//            description = "Render info box",
//            position = 1,
//            section = infoBox
//    )
//    default boolean infoBoxEnabled()
//    {
//        return false;
//    }
//
//    @ConfigItem(
//            keyName = "infoBoxSpeed",
//            name = "Show Speed",
//            description = "Print how many tiles the player moved since last tick.",
//            position = 2,
//            section = infoBox
//    )
//    default boolean infoBoxSpeed()
//    {
//        return true;
//    }
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import com.google.gson.JsonObject;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.border.Border;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;
import javax.swing.text.Document;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;

@Slf4j
public class GroupPanel extends JPanel
{
	FlatTextField groupTextField = new FlatTextField();
	JPanel memberPanel = new JPanel();
	JButton visibilityToggle;
	JButton colorPicker;
	PathmakerPluginPanel.PathGroup group = new PathmakerPluginPanel.PathGroup();
	JButton expandToggle;
	boolean beingDragged = false;
//	boolean expanded = true;
//	boolean hidden = false;
//	Color color = new Color(0, 100,100);

	GroupPanel(PathmakerPlugin plugin, JPanel parentPanel, PathPanel firstPathEntry, String groupName, int parentPanelIndex)
	{
		JPanel groupPanel = this;
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		((AbstractDocument) groupTextField.getTextField().getDocument()).setDocumentFilter(new MaxLengthFilter(20));
		groupTextField.setText(groupName);
		groupTextField.getTextField().setEnabled(false);
		setBorder(createDefaultBorder());

		// Drag & Drop panel margin
		int PANEL_MARGIN = 20;
		// Add drag and drop adapters, but also extra logic to allow for renaming on click.
		MouseMotionAdapter dragAdapter = new DragAdapter(parentPanel, groupPanel, PANEL_MARGIN);
		groupTextField.getTextField().addMouseMotionListener(new MouseMotionAdapter()
		{
			@Override
			public void mouseDragged(MouseEvent e)
			{
				super.mouseDragged(e);
				beingDragged = true;
				dragAdapter.mouseDragged(e);
			}
		});

		DropAdapter dropAdapter = new DropAdapter(plugin, parentPanel, groupPanel, parentPanelIndex, null, PANEL_MARGIN);
		groupTextField.getTextField().addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				super.mouseClicked(e);
				groupTextField.getTextField().setEnabled(true);
				groupTextField.requestFocusInWindow();
				groupTextField.setBackground(Color.DARK_GRAY);
				beingDragged = false;
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				super.mouseReleased(e);
				if (beingDragged) // need to do this, otherwise mouseClicked doesn't get called
				{
					dropAdapter.mouseReleased(e);
					beingDragged = false;
				}
			}
		});
		groupTextField.getTextField().addFocusListener(new FocusAdapter()
		{
			@Override
			public void focusLost(FocusEvent e)
			{
				beingDragged = false;
				groupTextField.getTextField().setText(groupName);
				finalizeEditing();
			}
		});

		int iconSize = PanelBuildUtils.ICON_SIZE;
		String panelTypeText = "group";

		expandToggle = PanelBuildUtils.createExpandToggleButton(group.expanded, iconSize, iconSize, panelTypeText);
		expandToggle.addActionListener(actionEvent ->
		{
			setExpanded(!group.expanded);
			plugin.saveGroup(groupName);
			plugin.rebuildPanel(false);
		});

		visibilityToggle = PanelBuildUtils.createVisibilityToggleButton(group.hidden, iconSize, iconSize, panelTypeText);
		visibilityToggle.addActionListener(actionEvent ->
		{
			setHidden(!group.hidden);
			plugin.saveAll();
		});
		colorPicker = PanelBuildUtils.createColorPickerButton(iconSize, iconSize, group.color, panelTypeText);
		colorPicker.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				super.mousePressed(e);
				RuneliteColorPicker cPicker = PanelBuildUtils.getColorPicker(plugin.getColorPickerManager(), group.color, groupPanel, colorPicker, panelTypeText);
				cPicker.setOnColorChange(newColor ->
				{
					setColor(newColor);
					colorPicker.setIcon(PanelBuildUtils.getRecoloredBrushIcon(newColor));
				});
				cPicker.setVisible(true);
				cPicker.setOnClose(c -> {plugin.saveAll();});
			}
		});

		int actionBorder = 5;
		JPanel leftActions =  new JPanel();
		leftActions.setLayout(new BorderLayout(2,0));
		leftActions.setBorder(BorderFactory.createEmptyBorder(actionBorder,actionBorder,actionBorder,actionBorder));
		leftActions.add(expandToggle, BorderLayout.WEST);
		leftActions.add(visibilityToggle, BorderLayout.CENTER);
		leftActions.add(colorPicker, BorderLayout.EAST);
		int actionsWidth = (leftActions.getComponentCount() * (iconSize + 6));
		leftActions.setPreferredSize(new Dimension(actionsWidth, iconSize));

		JButton exportButton = PanelBuildUtils.createExportButton(iconSize, iconSize, plugin.gson, panelTypeText);
		exportButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				PanelBuildUtils.getExportButtonAction(plugin.gson, getGroupName(), groupToExportJson(plugin));
			}
		});

		JButton deleteButton = PanelBuildUtils.createDeleteButton(plugin, iconSize, iconSize, this, groupName, "group", true);


		JPanel rightActions = new JPanel();
		rightActions.setLayout(new BorderLayout(2, 0));
		rightActions.setBorder(BorderFactory.createEmptyBorder(actionBorder,actionBorder,actionBorder,actionBorder));
		rightActions.add(exportButton,  BorderLayout.WEST);
		rightActions.add(deleteButton,  BorderLayout.EAST);
		actionsWidth = (rightActions.getComponentCount() * (iconSize + 6));
		rightActions.setPreferredSize(new Dimension(actionsWidth, iconSize));

		JPanel topPanel = new JPanel(new BorderLayout(0, 0));
		topPanel.setPreferredSize(new Dimension(0, iconSize + actionBorder * 2));

		topPanel.add(leftActions, BorderLayout.WEST);
		topPanel.add(rightActions, BorderLayout.EAST);

		groupTextField.setPreferredSize(new Dimension(0, 20)); // PanelBuildUtils.PANEL_WIDTH - actionsWidth
		topPanel.add(groupTextField, BorderLayout.CENTER);

		setColor(group.color);

		add(topPanel);

		memberPanel.setLayout(new BoxLayout(memberPanel, BoxLayout.Y_AXIS));
		memberPanel.add(firstPathEntry);
		add(memberPanel);
	}

	JsonObject groupToExportJson(PathmakerPlugin plugin)
	{
		JsonObject groupJson = new JsonObject();
		JsonObject membersJson = new JsonObject();
		for (Component member : getPathPanels())
		{
			String pathName = ((PathPanel) member).getPathLabel();
			//log.debug("exporting member " + pathName);
			membersJson.add(pathName, plugin.pathToJson(pathName));
		}
		groupJson.add("members", membersJson);
		groupJson.add("expanded", plugin.gson.toJsonTree(group.expanded, boolean.class));
		groupJson.add("hidden", plugin.gson.toJsonTree(group.hidden, boolean.class));
		groupJson.add("color", plugin.gson.toJsonTree(group.color, Color.class));
		return groupJson;
	}

	void importGroupData(PathmakerPluginPanel.PathGroup group)
	{
		this.group = group;
		setExpanded(this.group.expanded);
		setHidden(this.group.hidden);
		setColor(this.group.color);
	}

	void setColor(Color newColor)
	{
		group.color = newColor;
		Color backgroundColor = getBackgroundColor();

		JPanel topPanel = (JPanel) groupTextField.getParent();

		for (Component member : topPanel.getComponents())
			member.setBackground(backgroundColor);

		colorPicker.setIcon(PanelBuildUtils.getRecoloredBrushIcon(this.group.color));

		topPanel.setBackground(backgroundColor);
		setBackground(newColor);
		setBorder(createDefaultBorder());
		repaint();
	}

	Color getBackgroundColor()
	{
		return group.color.darker().darker().darker();
	}

	void setHidden(boolean hidden)
	{
		group.hidden = hidden;
		PanelBuildUtils.getVisibilityAction(visibilityToggle, hidden, "group");

		for (Component panel : memberPanel.getComponents())
		{
			((PathPanel) panel).setVisibility(hidden);
		}
	}

	void setExpanded(boolean expanded)
	{
		group.expanded = expanded;
		PanelBuildUtils.getExpandToggleAction(memberPanel, expandToggle, expanded, "group");
	}

	void finalizeEditing()
	{
		groupTextField.getTextField().setEnabled(false);
		groupTextField.setBackground(getBackgroundColor());
	}

	Border createDefaultBorder()
	{
		return BorderFactory.createEmptyBorder(2, 2, 2, 2);
	}

	void addPathPanel(PathPanel panel)
	{
		memberPanel.add(panel);
		groupTextField.getTextField().setToolTipText(getGroupName() + ": " + memberPanel.getComponents().length + " paths");
	}

	Component[] getPathPanels()
	{
		return memberPanel.getComponents();
	}

	int getPathPanelCount()
	{
		return memberPanel.getComponentCount();
	}

	PathPanel getPathPanel(int index)
	{
		return (PathPanel) memberPanel.getComponent(index);
	}

	String getGroupName()
	{
		return groupTextField.getText();
	}
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.util.ArrayList;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;

/* Coordinate system:
 *   (1, 0) = right
 *   (0, 1) = up
 *
 * Tile corners:
 *   p0 = top-left
 *   p1 = top-right
 *   p2 = bottom-right
 *   p3 = bottom-left
 */
public class PathTileOutline
{
	/* ---------------- Tile side ---------------- */

	private enum Side
	{
		TOP,
		LEFT,
		BOTTOM,
		RIGHT
	}

	/* ---------------- Public API ---------------- */

	public static ArrayList<ArrayList<LocalPoint>> build(
		ArrayList<WorldView> tileWVs,
		ArrayList<int[]> tileXs,
		ArrayList<int[]> tileYs,
		boolean left,
		ArrayList<Boolean> drawToPrevious
	)
	{
		ArrayList<ArrayList<LocalPoint>> outFull = new ArrayList<>();
		int n = tileXs.size();
		if (n == 0)
		{
			return outFull;
		}

		boolean isLooped = tileXs.get(0)[0] == tileXs.get(n - 1)[0] && tileYs.get(0)[0] == tileYs.get(n - 1)[0];

		for (int i = 0; i < n; i++)
		{
			ArrayList<LocalPoint> out = new ArrayList<LocalPoint>();

			LocalPoint[] rect = rect(tileXs.get(i), tileYs.get(i), tileWVs.get(i));
			Point dirIn  = (i > 0)     ? direction(tileXs, tileYs, i - 1, i) : null;
			Point dirOut = (i < n - 1) ? direction(tileXs, tileYs, i, i + 1) : null;
			/* FIRST TILE:
			 * No entry direction.
			 * We only know where we are going next. */

			if (dirIn == null)
			{
				Side exit = sideOf(dirOut, left);
				addSide(out, rect, exit, left);
				outFull.add(out);
				continue;
			}

			/* LAST TILE:
			 * No exit direction.
			 * We only know where we came from. */

			if (dirOut == null)
			{
				Side inSide  = sideOf(dirIn, left);
				if (isLooped)
				{
					dirOut = direction(tileXs, tileYs, i,1);
					int cross = dirIn.getX() * dirOut.getY() - dirIn.getY() * dirOut.getX();
					boolean innerTurn = left ?  cross > 0 : cross < 0;
					Side outSide = sideOf(dirOut, left);

					if (inSide == outSide)
					{
						out.add(outFull.get(0).get(0));
					}
					else if(innerTurn)
					{
						if(outFull.get(0).size() > 1)
							outFull.get(0).remove(0);
						out.add(outFull.get(0).get(0));
					}
					else
					{
						outFull.get(0).remove(0);
						addSide(out, rect, inSide, left);
						addSide(out, rect, outSide, left);
					}
				}
				else
				{
					addSide(out, rect, inSide, left);
				}
				outFull.add(out);
				continue;
			}

			// MIDDLE TILE

			int cross = dirIn.getX() * dirOut.getY() - dirIn.getY() * dirOut.getX();
			boolean innerTurn = left ?  cross > 0 : cross < 0;

			Side inSide  = sideOf(dirIn, left);
			Side outSide = sideOf(dirOut, left);

			boolean dp = drawToPrevious.get(i);
			boolean nDp = drawToPrevious.get(i + 1); // i + 1 < drawToPrevious.size() ?  : true;
			if (!dp || !nDp)
			{
				boolean outerTurn = left ? cross < 0 : cross > 0;

				// Todo figure out the best !drawPreviousPoints to add
				if (left)
					if (outerTurn)
//						if (dp)
//							addSide(out, rect, inSide, left);
//						else
							addSideEndPoint(out, rect, inSide);
					else
//						if (dp)
//							addSide(out, rect, inSide, left);
//						else
							addSideStartPoint(out, rect, inSide);
				else
					if (outerTurn)
						addSideEndPoint(out, rect, outSide);
					else
						addSideStartPoint(out, rect, outSide);
			}
			else if (inSide == outSide)
			{
				// Normal straight / gentle turn
				addSide(out, rect, inSide, left);
			}
			else if(innerTurn)
			{
				if(left)
					addSideStartPoint(out,rect,inSide);
				else
					addSideEndPoint(out,rect,inSide);
			}
			else
			{
				// Diagonal / offset case
				// Replace diagonal with exactly two edges
				addSide(out, rect, inSide, left);
				addSide(out, rect, outSide, left);
			}
			outFull.add(out);
		}

		return outFull;
	}

	/* ---------------- Geometry helpers ---------------- */

	// Computes cardinal direction between tile centers.
	private static Point direction(
		ArrayList<int[]> xs,
		ArrayList<int[]> ys,
		int a,
		int b
	)
	{
		int ax = (xs.get(a)[0] + xs.get(a)[2]) / 2;
		int ay = (ys.get(a)[0] + ys.get(a)[2]) / 2;
		int bx = (xs.get(b)[0] + xs.get(b)[2]) / 2;
		int by = (ys.get(b)[0] + ys.get(b)[2]) / 2;

			return new Point(
				Integer.signum(bx - ax),
				Integer.signum(by - ay)
			);
	}

	private static LocalPoint[] rect(int[] xs, int[] ys, WorldView wv)
	{
		return new LocalPoint[]{
			new LocalPoint(xs[0], ys[0], wv), // p0 top-left
			new LocalPoint(xs[1], ys[1], wv), // p1 top-right
			new LocalPoint(xs[2], ys[2], wv), // p2 bottom-right
			new LocalPoint(xs[3], ys[3], wv)  // p3 bottom-left
		};
	}

	/* ---------------- Side logic ---------------- */

	// Determines which SIDE of a tile is on the LEFT/RIGHT of a given movement direction.
	private static Side sideOf(Point dir, boolean left)
	{
		if (left)
		{
			if (dir.getX() == 1 && dir.getY() == 0) return Side.TOP;
			if (dir.getX() == -1 && dir.getY() == 0) return Side.BOTTOM;
			if (dir.getX() == 0 && dir.getY() == 1) return Side.LEFT;
			if (dir.getX() == 0 && dir.getY() == -1) return Side.RIGHT;

			/* Diagonal case:
			 * Use the dominant component implicitly via boundary walking.
			 * We still return a side so entry/exit always exist. */
			if (dir.getX() > 0) return Side.TOP;
			if (dir.getX() < 0) return Side.BOTTOM;
			if (dir.getY() > 0) return Side.LEFT;
			return Side.RIGHT;
		}
		else
		{
			if (dir.getX() == 1 && dir.getY() == 0)  return Side.BOTTOM;
			if (dir.getX() == -1 && dir.getY() == 0) return Side.TOP;
			if (dir.getX() == 0 && dir.getY() == 1)  return Side.RIGHT;
			if (dir.getX() == 0 && dir.getY() == -1) return Side.LEFT;

			if (dir.getX() > 0)  return Side.BOTTOM;
			if (dir.getX() < 0)  return Side.TOP;
			if (dir.getY() > 0)  return Side.RIGHT;
			return Side.LEFT;
		}
	}

	/* ---------------- Emission ---------------- */

	private static void addSide(ArrayList<LocalPoint> out, LocalPoint[] r, Side s, boolean left)
	{
		if(left)
		{
			switch (s)
			{
				case TOP:
					add(out, r[0]);
					add(out, r[1]);
					break;
				case RIGHT:
					add(out, r[1]);
					add(out, r[2]);
					break;
				case BOTTOM:
					add(out, r[2]);
					add(out, r[3]);
					break;
				case LEFT:
					add(out, r[3]);
					add(out, r[0]);
					break;
			}
		}
		else
		{
			switch (s)
			{
				case TOP:
					add(out, r[1]);
					add(out, r[0]);
					break;
				case RIGHT:
					add(out, r[2]);
					add(out, r[1]);
					break;
				case BOTTOM:
					add(out, r[3]);
					add(out, r[2]);
					break;
				case LEFT:
					add(out, r[0]);
					add(out, r[3]);
					break;
			}
		}

	}

	private static void addSideStartPoint(ArrayList<LocalPoint> out, LocalPoint[] r, Side s)
	{
		switch (s)
		{
			case TOP:
				add(out, r[0]);
				break;
			case RIGHT:
				add(out, r[1]);
				break;
			case BOTTOM:
				add(out, r[2]);
				break;
			case LEFT:
				add(out, r[3]);
				break;
		}
	}

	private static void addSideEndPoint(ArrayList<LocalPoint> out, LocalPoint[] r, Side s)
	{
		switch (s)
		{
			case TOP:
				add(out, r[1]);
				break;
			case RIGHT:
				add(out, r[2]);
				break;
			case BOTTOM:
				add(out, r[3]);
				break;
			case LEFT:
				add(out, r[0]);
				break;
		}
	}

	private static boolean sidesAreOpposites(Side a, Side b)
	{
		if (a.equals(Side.TOP) &&  b.equals(Side.BOTTOM))
			return true;
		if (a.equals(Side.LEFT) &&  b.equals(Side.RIGHT))
			return true;
		if (a.equals(Side.RIGHT) &&  b.equals(Side.LEFT))
			return true;
		if (a.equals(Side.BOTTOM) &&  b.equals(Side.TOP))
			return true;

		return false;
	}

	private static void add(ArrayList<LocalPoint> out, LocalPoint p)
	{
		if (out.isEmpty() || !out.get(out.size() - 1).equals(p))
		{
			out.add(p);
		}
	}
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Color;
import javax.inject.Inject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.api.Client;

public class PathmakerPanelOverlay extends OverlayPanel
{
    private final PathmakerConfig config;
    private final Client client;

    // Move Speed - Add config toggle for move speed!
    private final String speedLabelPrefix = "Tiles pr/tick: ";
    WorldPoint lastPos = null;
    float moveSpeed = 0;

    @Inject
    private PathmakerPanelOverlay(PathmakerPlugin plugin, Client client, PathmakerConfig config)
    {
        super(plugin);

        setResizable(true);
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        this.client = client;
        this.config = config;
        this.panelComponent.setPreferredSize(new Dimension(20,0)); //graphics.getFontMetrics().stringWidth(speedLabelPrefix) +10
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
//        // InfoBox
//        if (config.infoBoxEnabled())
//        {
//            if (config.infoBoxSpeed())
//            {
//                this.panelComponent.getChildren().add(TitleComponent.builder().text(getSpeedLabelString(moveSpeed)).color(Color.WHITE).build());
//            }
//
//            // Render infobox
//            this.panelComponent.setPreferredSize(new Dimension(20,0));
//            return super.render(graphics);
//        }
        return null;
    }

    // Called by PathmakerPlugin.onGameTick()
    public void calculateCurrentSpeed()
    {
        WorldPoint playerPos = client.getLocalPlayer().getWorldLocation();

        if (lastPos != null)
        {
            float distance = lastPos.distanceTo(playerPos);
            //if (distance != 0) {
            moveSpeed = distance;
            //}
        }
        lastPos = playerPos;
    }

    public String getSpeedLabelString(float speed)
    {
        return speedLabelPrefix + String.format("%.2f", moveSpeed);
    }
}

/*
 * Copyright (c) 2025, JosteinE
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *	  list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *	  this list of conditions and the following disclaimer in the documentation
 *	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.Pathmaker;

import com.google.common.base.Strings;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.inject.Provides;
import java.awt.Color;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.JOptionPane;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.DecorativeObject;
import net.runelite.api.GameObject;
import net.runelite.api.GroundObject;
import net.runelite.api.ItemLayer;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collection;
import java.awt.Polygon;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

@Slf4j
@PluginDescriptor(
	name = "Pathmaker",
    description = "Draw lines between marked tiles.",
    tags = {"object,path,line,draw,tile,indicator,navigation"}
)
public class PathmakerPlugin extends Plugin
{
    private static final String ICON_FILE = "panel_icon.png";
    private static final String CONFIG_KEY = "paths";

    public final int  MAX_POINT_LABEL_LENGTH = 50;
    public final int  TILE_SIZE = 128; // Not in net.runelite.api.Constants?
    public final int  TILE_SIZE_HALF = TILE_SIZE / 2;

    private final LinkedHashMap<String, PathmakerPath> paths = new LinkedHashMap<>();
	private final HashMap<Integer, ArrayList<String>> reversePathsLookup = new HashMap<>(); // Look-up paths by their occupying regions

    PathmakerPluginPanel pluginPanel;
    private NavigationButton navButton;

    boolean hotKeyPressed = false;

	@Inject
	private Client client;

	@Inject
	private PathmakerConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private PathmakerOverlay overlay;

	//Previously used to display movement speed (tiles per tick)
	//@Inject
	//PathmakerPanelOverlay panelOverlay;

    @Inject
    EventBus eventBus;

    @Inject
    private ClientToolbar clientToolbar;

    @Getter
    @Inject
    private ColorPickerManager colorPickerManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    public Gson gson;

    @Inject
    ChatboxPanelManager chatboxPanelManager;

	@Inject
	ChatMessageManager chatMessageManager;

    @Provides
    PathmakerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(PathmakerConfig.class);
    }

	@Override
	protected void startUp() throws Exception
	{
		//log.info("Starting up Pathmaker plugin");

        overlayManager.add(overlay);
        //overlayManager.add(panelOverlay);
		pluginPanel = new PathmakerPluginPanel(client, this);
		reload(client.getTopLevelWorldView());

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);
		navButton = NavigationButton.builder()
			.tooltip("Pathmaker")
			.icon(icon)
			.priority(5)
			.panel(pluginPanel)
			.build();
		clientToolbar.addNavigation(navButton);

		if (!paths.isEmpty())
		{
			Iterator<String> iterator = paths.keySet().iterator();
			String lastPath = iterator.next();
			while (iterator.hasNext())
				lastPath = iterator.next();

			pluginPanel.activePath.setText(lastPath);
		}
		rebuildPanel(true);

//		log.debug("Pathmaker plugin loaded {} paths", paths.size());
//		for (String path : paths.keySet())
//		{
//			log.debug(path);
//		}
	}

	@Override
	protected void shutDown() throws Exception
	{
        overlayManager.remove(overlay);
        //overlayManager.remove(panelOverlay);
        clientToolbar.removeNavigation(navButton);

        paths.clear();
    }

    void saveAll()
    {
        configManager.unsetConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY);
		JsonObject saveJson = new JsonObject();

		if(!paths.isEmpty())
		{
			JsonObject pathsJson = new JsonObject();
			for (String pathName : paths.keySet())
			{
				pathsJson.add(pathName, pathToJson(pathName));
			}
			saveJson.add("paths", pathsJson);

			if (!pluginPanel.pathGroups.isEmpty())
			{
				JsonObject groupsJson = new JsonObject();
				for (String groupName : pluginPanel.pathGroups.keySet())
				{
					groupsJson.add(groupName, groupToJson(groupName));
				}

				saveJson.add("groups", groupsJson);
			}
			//String json = gson.toJson(paths);
			configManager.setConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY, saveJson);
		}
        configManager.sendConfig();
    }

	JsonObject groupToJson(String groupName)
	{
		PathmakerPluginPanel.PathGroup group = pluginPanel.pathGroups.get(groupName);
		JsonObject groupJson = new JsonObject();
		//log.debug("Saving group {}, with e: {}, h: {}, c: {}", groupName, group.expanded, group.hidden, group.color);
		groupJson.add("expanded", gson.toJsonTree(group.expanded, boolean.class));
		groupJson.add("hidden", gson.toJsonTree(group.hidden, boolean.class));
		groupJson.add("color", gson.toJsonTree(group.color, Color.class));
		return groupJson;
	}

	void savePath(String pathName)
	{
		savePath(pathName, null);
	}

	void savePath(String pathName, @Nullable String newName)
	{
		saveProperty("path", pathName, pathToJson(pathName), newName);
	}

	void saveGroup(String groupName)
	{
		saveProperty("group", groupName, groupToJson(groupName), null);
	}

	// Save group or path by copying everything else as-is, and replacing the entry for the specified property by the current version
	private void saveProperty(String propertyType, String propertyName, @Nullable JsonObject propertyJson, @Nullable String newName)
	{
		String json = configManager.getConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY);
		if (Strings.isNullOrEmpty(json)) return;

		JsonObject loadJSON = gson.fromJson(json, new TypeToken<JsonObject>(){}.getType());
		if (loadJSON == null) return;

		JsonObject loadedPropertyJSON = loadJSON.getAsJsonObject(propertyType + "s");
		JsonObject savePropertyJSON = new JsonObject();

		try
		{
			if (loadedPropertyJSON.isJsonNull() && propertyJson != null)
			{
				savePropertyJSON.add(propertyName, propertyJson);
			}
			else if (!loadedPropertyJSON.has(propertyName) && propertyJson != null)
			{
				savePropertyJSON = loadedPropertyJSON;
				savePropertyJSON.add(propertyName, propertyJson);
			}
			// Copy everything except for the specified path from the current save,
			// and replace the specified path with the latest version (unless it was removed)
			else
			{
				for (String pName : loadedPropertyJSON.keySet())
				{
					if (pName.equals(propertyName))
					{
						if(propertyJson == null) // Property was deleted
						{
							continue;
						}

						savePropertyJSON.add(newName == null ? pName : newName, propertyJson);
					}
					else
						savePropertyJSON.add(pName, loadedPropertyJSON.get(pName));
				}
			}
		} catch (JsonSyntaxException ignored){}

		// Validate that the new save is the expected size
		if (savePropertyJSON.size() == loadedPropertyJSON.size() ||
			savePropertyJSON.size() == loadedPropertyJSON.size() + 1 ||
			(propertyJson == null && savePropertyJSON.size() == loadedPropertyJSON.size() - 1))
		{
			loadJSON.remove(propertyType + "s");
			loadJSON.add(propertyType + "s", savePropertyJSON);
		}
		else return;

		configManager.unsetConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY);
		configManager.setConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY, loadJSON);


	}

	JsonObject pathToJson(String pathName)
	{
		if (!paths.containsKey(pathName))
		{
			return null;
		}

		PathmakerPath path = paths.get(pathName);

		//String pathJson;
		Set<Integer> regionIds = path.getRegionIDs();
		JsonObject pathJson = new JsonObject();

		JsonObject regionsJson = new JsonObject();
		for (int regionId : regionIds)
		{
			JsonArray regionJson = new JsonArray();
			for (PathPoint point : path.getPointsInRegion(regionId))
			{
				JsonObject pointJson = gson.toJsonTree(point, point instanceof PathPointObject ? PathPointObject.class : PathPoint.class).getAsJsonObject();

				// Don't need to export pathOwner per point, it's re-added when imported and added to a path.
				pointJson.remove("pathOwner");
				regionJson.add(gson.toJsonTree(pointJson));

				// Todo: Implement a save JSON that uses fewer symbols, but keep logic for legacy JSON
//				JsonObject pointJson = new JsonObject();
//
//				pointJson.addProperty("d", point.getDrawIndex());
//				pointJson.addProperty("rid", point.getRegionId());
//				pointJson.addProperty("x", point.getX());
//				pointJson.addProperty("y", point.getY());
//				pointJson.addProperty("z", point.getZ());
//				pointJson.addProperty("dtp", point.drawToPrevious);
//				pointJson.addProperty("l",  point.getLabel());
//
//				if (point instanceof PathPointObject)
//				{
//					pointJson.addProperty("id", ((PathPointObject) point).getEntityId());
//					pointJson.addProperty("bid", ((PathPointObject) point).getBaseId());
//					pointJson.addProperty("npc", ((PathPointObject) point).isNpc());
//					pointJson.addProperty("vX", ((PathPointObject) point).getToCenterVectorX());
//					pointJson.addProperty("vY", ((PathPointObject) point).getToCenterVectorY());
//				}
//				//regionJson.add(gson.toJsonTree(point, entityIsObject ? PathPointObject.class : PathPoint.class));
//				regionJson.add(gson.toJsonTree(pointJson));
			}
			regionsJson.add(String.valueOf(regionId), regionJson);
		}

		pathJson.add("regions", regionsJson);
		pathJson.add("color", gson.toJsonTree(path.color, Color.class));
		pathJson.add("looped", gson.toJsonTree(path.loopPath, boolean.class));
		pathJson.add("pathDrawOffset", gson.toJsonTree(path.pathDrawOffset, int.class));
		pathJson.add("panelExpanded", gson.toJsonTree(path.panelExpanded, boolean.class));
		pathJson.add("pathGroup", gson.toJsonTree(path.pathGroup, String.class));
		pathJson.add("labelMode", gson.toJsonTree(path.labelMode.ordinal(), int.class));
		pathJson.add("pointDrawMode", gson.toJsonTree(path.pointDrawMode.ordinal(), int.class));

		//log.debug("Saved path: {}", pathName);
		return pathJson;
	}

	PathmakerPath loadPathFromJson(JsonObject pathJson, String pathName)
	{
		if (pathJson == null)
		{
			log.debug("Could not load path {} from Json. PathJson is null.", pathName);
			return null;
		}

		JsonObject regionsJson = pathJson.get("regions").getAsJsonObject();

		for (String regionIdString : regionsJson.keySet())
		{
			//log.debug("Loading region: {}, for path: {}", regionIdString, pathName);
			for(JsonElement pointElement : regionsJson.get(regionIdString).getAsJsonArray())
			{
				PathPoint pathPoint = null;

				try
				{
					pathPoint = gson.fromJson(pointElement, pointElement.getAsJsonObject().has("id") ?
						PathPointObject.class : PathPoint.class);
				} catch (JsonSyntaxException e)
				{
					log.debug("Deserialized PathPoint is null.");
				}

				// Todo: Implement a load JSON that uses less symbols
//				try
//				{
//					JsonObject pointJson = pointElement.getAsJsonObject();
//					int regionId = pointJson.get("regionId").getAsInt();
//					int x = pointJson.get("x").getAsInt();
//					int y = pointJson.get("y").getAsInt();
//					int z = pointJson.get("z").getAsInt();
//
//					if (pointJson.has("id"))
//					{
//						int id = pointJson.get("id").getAsInt();
//						int baseId = pointJson.get("baseId").getAsInt();
//						boolean isNpc = pointJson.get("isNpc").getAsBoolean();
//
//						pathPoint = new PathPointObject(pathName, regionId, x, y, z, id, baseId, isNpc);
//
//						int toCenterVectorX = pointJson.get("toCenterVectorX").getAsInt();
//						int toCenterVectorY = pointJson.get("toCenterVectorY").getAsInt();
//
//						((PathPointObject) pathPoint).setToCenterVector(toCenterVectorX, toCenterVectorY);
//					}
//					else
//					{
//						pathPoint = new PathPoint(pathName, regionId, x, y, z);
//					}
//
//					pathPoint.setDrawIndex(pointJson.get("drawIndex").getAsInt());
//
//					pathPoint.setLabel(gson.fromJson(pointJson.get("label").getAsString(), String.class));
//					pathPoint.drawToPrevious = pointJson.get("drawToPrevious").getAsBoolean();
//				}
//				catch (JsonSyntaxException e)
//				{
//					log.debug("Deserialized PathPoint is null.");
//				}

				if (pathPoint != null)
				{
					createOrAddToPath(pathName, pathPoint);
				}
				else
					log.debug("Failed to add deserialized point to path: {}", pathName);
			}
		}

		PathmakerPath path = paths.get(pathName);

		if (pathJson.has("color"))
			path.color = gson.fromJson(pathJson.get("color"), Color.class);
		if (pathJson.has("looped"))
			path.loopPath = gson.fromJson(pathJson.get("looped"), Boolean.class);
		if (pathJson.has("pathDrawOffset"))
			path.pathDrawOffset = gson.fromJson(pathJson.get("pathDrawOffset"), int.class);
		if (pathJson.has("panelExpanded"))
			path.panelExpanded = gson.fromJson(pathJson.get("panelExpanded"), boolean.class);
		if (pathJson.has("pathGroup"))
			path.pathGroup = gson.fromJson(pathJson.get("pathGroup"), String.class);
		if (pathJson.has("labelMode"))
			path.labelMode = PathmakerConfig.pathPointLabelMode.values()[gson.fromJson(pathJson.get("labelMode"), int.class)];
		if (pathJson.has("pointDrawMode"))
			path.pointDrawMode = PathmakerConfig.pathPointMode.values()[gson.fromJson(pathJson.get("pointDrawMode"), int.class)];

		return path;
	}

    private void reload(WorldView wv)
    {
        paths.clear();
		reversePathsLookup.clear();
		pluginPanel.pathGroups.clear();
		//if (true) return;
        String json = configManager.getConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY);

        if (Strings.isNullOrEmpty(json))
        {
            return;
        }

        try
        {
			JsonObject loadJson = gson.fromJson(json, new TypeToken<JsonObject>(){}.getType());

			if (loadJson.isJsonNull()) return;

			JsonObject pathsJson = loadJson.has("paths") ? loadJson.getAsJsonObject("paths") : loadJson;

			for (String pathName : pathsJson.keySet())
			{
				//log.debug("Loading path: {}", pathName);
				loadPathFromJson(pathsJson.getAsJsonObject(pathName), pathName);
			}

			if(!loadJson.has("groups")) return;

			JsonObject groupsJson = loadJson.getAsJsonObject("groups");

			for (String groupName : groupsJson.keySet())
			{
				JsonObject groupJson = groupsJson.getAsJsonObject(groupName);
				PathmakerPluginPanel.PathGroup group = new PathmakerPluginPanel.PathGroup();
				group.expanded = gson.fromJson(groupJson.get("expanded"), boolean.class);
				group.hidden = gson.fromJson(groupJson.get("hidden"), boolean.class);
				group.color =  gson.fromJson(groupJson.get("color"), Color.class);
				pluginPanel.pathGroups.put(groupName, group);
			}
        }
        catch (IllegalStateException | JsonSyntaxException ignore)
        {
            JOptionPane.showConfirmDialog(pluginPanel,
                    "The paths you are trying to load are malformed",
                    "Warning", JOptionPane.OK_CANCEL_OPTION);
        }
    }

	//For my convenience
	/*
	@Subscribe
	public void onWorldViewLoaded(WorldViewLoaded event)
	{
		//log.debug("onWorldViewLoaded");
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
//		log.debug("GameObjectDespawned");
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
//		log.debug("GameObjectSpawned");
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned event)
	{
//		log.debug("WallObjectDespawned");
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned event)
	{
//		log.debug("WallObjectSpawned");
	}

	@Subscribe
	public void onGroundObjectDespawned(GroundObjectDespawned event)
	{
//		log.debug("GroundObjectDespawned");
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned event)
	{
//		log.debug("GroundObjectSpawned");
	}

	@Subscribe
	public void onDecorativeObjectSpawned(DecorativeObjectSpawned event)
	{
//		log.debug("DecorativeObjectSpawned");
	}

	@Subscribe
	public void onDecorativeObjectDespawned(DecorativeObjectDespawned event)
	{
//		log.debug("DecorativeObjectDespawned");
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned event)
	{
//		log.debug("ItemSpawned");
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned event)
	{
//		log.debug("ItemDespawned");
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
//		log.debug("NpcSpawned");
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
//		log.debug("NpcDespawned");
	}

    @Subscribe
    public void onGameTick(GameTick gameTick)
    {
		//log.debug("onGameTick");

//		if(config.infoBoxEnabled() && config.infoBoxSpeed())
//			panelOverlay.calculateCurrentSpeed();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
    	if (event.getGroup().equals(PathmakerConfig.CONFIG_GROUP))
    	{
    	}
    }
    */

    // Get marked tiles within the rendered regions
    Collection<PathPoint> getTilesToHighlight()
    {
        Collection<PathPoint>  pathPoints = new ArrayList<>();

        // Get rendered regionIDs
        int[] regionsToLoad = client.getTopLevelWorldView().getMapRegions();
        for (PathmakerPath path : paths.values())
        {
            for (int regionID : regionsToLoad)
            {
                Collection<PathPoint> pathPointsInRegion = path.getPointsInRegion(regionID);
                if  (pathPointsInRegion != null)
                {
                    pathPoints.addAll(path.getPointsInRegion(regionID));
                }
            }
        }
        return pathPoints;
    }

    @Subscribe
    public void onMenuEntryAdded(final MenuEntryAdded event)
    {
        // Only add menu option if shift is being held
		MenuAction menuAction = event.getMenuEntry().getType();
        hotKeyPressed = client.isKeyPressed(KeyCode.KC_SHIFT);

        if (!hotKeyPressed || (menuAction != MenuAction.WALK && menuAction != MenuAction.SET_HEADING &&
                menuAction != MenuAction.EXAMINE_NPC && menuAction != MenuAction.EXAMINE_OBJECT &&
			menuAction != MenuAction.EXAMINE_ITEM_GROUND))
        {
            return;
        }

		int startingMenuOptionCount = client.getMenu().getMenuEntries().length;

        // Fetch game world
        int worldId = event.getMenuEntry().getWorldViewId();
        WorldView wv = client.getWorldView(worldId);


        if (wv == null)
        {
            log.debug("No world view found for getMenuEntry().getWorldViewId " + worldId);
            return;
        }

        // Fetch selected tile
        final Tile selectedSceneTile = wv.getSelectedSceneTile();
        if (selectedSceneTile == null)
        {
            return;
        }

        // Get the tile under cursor
        PathPoint pathPoint;

        String targetEntityString;
        String targetPathName = getActiveOrDefaultPathColorString(getActivePathName());
        final WorldPoint worldPoint;
        Point toCenterVec = new Point(TILE_SIZE_HALF, TILE_SIZE_HALF);

		int trueEntityId = -1;

        // Attempt to get an actor (npc) under the cursor
        if (event.getMenuEntry().getNpc() != null)
        {
            NPC npc = event.getMenuEntry().getNpc();
            worldPoint = WorldPoint.fromLocalInstance(npc.getWorldView().getScene(), npc.getLocalLocation(), npc.getWorldView().getPlane());
            targetEntityString = getActiveOrDefaultPathColorString(npc.getName());
            toCenterVec = getNpcToCenterVector(wv, npc.getId());
			trueEntityId = npc.getId();
        }
        else // If not an actor it's a tile OR an object
        {
            if (menuAction == MenuAction.EXAMINE_OBJECT)
            {
                // BIG shoutout to the ObjectIndicatorsPlugin for this implementation.
                // Spent most of the day just fighting chatGPT, and it was not at all fruitful.

                final int sceneX = event.getMenuEntry().getParam0();
                final int sceneY = event.getMenuEntry().getParam1();

                Tile tile = getTile(wv, sceneX, sceneY);

                int targetId = event.getMenuEntry().getIdentifier();


                TileObject tileObject = null;
                if (tile != null)
                {
                    tileObject = getTileObject(tile, targetId);
                }
                if (tileObject != null)
                {
					trueEntityId = client.getObjectDefinition(tileObject.getId()).getId();
                    worldPoint = WorldPoint.fromLocalInstance(client, tileObject.getLocalLocation());
                    toCenterVec = getObjectToCenterVector(wv, worldPoint, event.getIdentifier());

                } else
                {
                    worldPoint = WorldPoint.fromLocalInstance(client, selectedSceneTile.getLocalLocation());
                }
            }
            else
            {
                worldPoint = WorldPoint.fromLocalInstance(client, selectedSceneTile.getLocalLocation());
            }

            String target = event.getMenuEntry().getTarget(); // Returns an empty string if not an object
            targetEntityString = getActiveOrDefaultPathColorString(target.isEmpty() ? "Tile" : target);
        }

		// Correct for sailing tiles
		//int z = wv.isTopLevel() ? wv.getPlane() : 0;

        // See if the point already exists
        pathPoint = getPathPointAtRegionTile(
			getActivePathName(),
			worldPoint.getRegionID(),
			worldPoint.getRegionX(),
			worldPoint.getRegionY(),
			worldPoint.getPlane());

        // If tile is not previously marked by this path, add the "add" option.
        if (pathPoint == null)
        {
			if (!paths.isEmpty() &&
				paths.containsKey(getActivePathName()) &&
				paths.get(getActivePathName()).drawToPlayer == PathPanel.drawFromPlayerMode.START_ONLY.ordinal() &&
				paths.get(getActivePathName()).getSize() > 1)
			{
				String optionString = (paths.get(getActivePathName()).loopPath ? "Unloop " : "Loop ") + getActiveOrDefaultPathColorString(getActivePathName());
				addMenuOption(-1, MenuEntryUtil.getLoopMenuEntryMethod(this, paths.get(getActivePathName()), getActivePathName(), pathPoint), optionString);
			}

            // Skip if the entityID has already been registered
            if (menuAction == MenuAction.EXAMINE_NPC || menuAction == MenuAction.EXAMINE_OBJECT)
            {
				int entityID = event.getIdentifier();
                final boolean isNpc = menuAction == MenuAction.EXAMINE_NPC;

                pathPoint = new PathPointObject(getActivePathName(), worldPoint.getRegionID(), worldPoint.getRegionX(),
                        worldPoint.getRegionY(), worldPoint.getPlane(), entityID, trueEntityId, isNpc);

                if(toCenterVec != null)
                    ((PathPointObject) pathPoint).setToCenterVector(toCenterVec.getX(), toCenterVec.getY());
            }
            else
            {
				pathPoint = new PathPoint(getActivePathName(), worldPoint.getRegionID(), worldPoint.getRegionX(),
                        worldPoint.getRegionY(), worldPoint.getPlane());
            }

			String optionString = "Add " + targetEntityString + " to " + targetPathName;
			addMenuOption(-1, MenuEntryUtil.getAddPointMenuEntry(this, getActivePathName(), pathPoint, targetEntityString), optionString);
        }

        // On existing POINTS
        else // actorPoint != null ||
        {
			final String activePathName = getActivePathName();

			// Do this if it belongs to the active path
			if(pathPoint.getPathOwnerName().equals(activePathName))
			{
				// Only configure add loop/unloop/label if point belongs to the active group
				// Only allow loop/unloop with points connected to the last point
				if (paths.get(activePathName).getSize() > 2 &&
					(pathPoint.getDrawIndex() == paths.get(activePathName).getSize() - 2 &&
					paths.get(activePathName).loopPath) ||
					(paths.get(activePathName).drawToPlayer == PathPanel.drawFromPlayerMode.NEVER.ordinal() &&
					pathPoint.getDrawIndex() == 0))
				{
					String optionString = (paths.get(activePathName).loopPath ? "Unloop " : "Loop ") + getActiveOrDefaultPathColorString(activePathName);
					addMenuOption(-1, MenuEntryUtil.getLoopMenuEntryMethod(this, paths.get(activePathName), activePathName, pathPoint), optionString);
				}

				// Add label rename option
				String optionString = "Set " + targetEntityString + " label";
				addMenuOption(-1, MenuEntryUtil.getLabelRenameMenuEntryMethod(this, pathPoint, targetEntityString, MAX_POINT_LABEL_LENGTH), optionString);
			}
        }

		// Add remove option regardless of path
		for(String pathName : paths.keySet())
		{
			PathPoint point = getPathPointAtRegionTile(pathName, worldPoint.getRegionID(), worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane());
			if(point == null) continue;

			// Eliminate double entries when a point is both the position of an entity and entity tile
			if(!(point instanceof PathPointObject) || (!Text.removeTags(targetEntityString).equals("Tile")))
			{
				String optionString = "Remove " +
					ColorUtil.wrapWithColorTag(Text.removeTags(targetEntityString), paths.get(pathName).color) +
					" from " + ColorUtil.wrapWithColorTag(Text.removeTags(pathName), paths.get(pathName).color);

				addMenuOption(-1, MenuEntryUtil.getRemovePointMenuEntry(this, pathName, point), optionString);
			}
		}

		// Add create new path option regardless
		if (!paths.isEmpty())
		{
			String newPathName = getAvailableName(paths, "unnamed");
			String optionString = "Start new path at " + ColorUtil.wrapWithColorTag(Text.removeTags(targetEntityString), config.pathColor());
			addMenuOption(startingMenuOptionCount, MenuEntryUtil.getAddPathMenuEntry(this, newPathName, pathPoint, targetEntityString), optionString);
		}
    }

	void addMenuOption(int index, Consumer<MenuEntry> entryMethod, String optionString)
	{
		client.getMenu().createMenuEntry(index)
			.setOption(optionString)
			.setType(MenuAction.RUNELITE)
			.onClick(entryMethod);
	}

    public LinkedHashMap<String, PathmakerPath> getStoredPaths()
    {
        return paths;
    }

	public HashMap<Integer, ArrayList<String>> getReversePathLookup()
	{
		return reversePathsLookup;
	}

    public boolean pathExists(String pathName)
    {
        return paths.containsKey(pathName);
    }

    // Returns pathPoints from all paths within the specified region
	ArrayList<PathPoint> getPathPointsInRegion(int regionId)
    {
		ArrayList<PathPoint> pathPoints = new ArrayList<>();

        for (String pathName : getPathsInRegionKeys(regionId))
        {
            PathmakerPath path = paths.get(pathName);
            pathPoints.addAll(path.getPointsInRegion(regionId));
        }

        return pathPoints;
    }

    // Iterate through the stored paths and find all that have tiles within the specified region
    Collection<String> getPathsInRegionKeys(int regionId)
    {
        Collection<String> pathsInRegionKeys = new ArrayList<>();
        for (String pathName : paths.keySet())
        {
            for (int pathRegionId : paths.get(pathName).getRegionIDs())
            {
                if(pathRegionId == regionId)
                {
                    pathsInRegionKeys.add(pathName);
                    break;
                }
            }
        }
        return pathsInRegionKeys;
    }

    Color getDefaultPathColor()
    {
        return config.pathColor();
    }

    // Return PathPoint if one was previously created on the specified tile
	PathPoint getPathPointAtRegionTile(String path, int regionId, int regionX,  int regionY, int plane)
    {
        if(paths.isEmpty() || !paths.containsKey(path) || !paths.get(path).hasPointsInRegion(regionId))
        {
            return null;
        }

        // Iterate through each region tile to determine if the selected tile has a PathPoint
        for (PathPoint point : paths.get(path).getPointsInRegion(regionId))
        {
            if(point.getX() == regionX && point.getY() == regionY)
            {
				return point;
            }
        }
		return null;
    }

    // Create a new path starting with the given point or add to existing path
    void createOrAddToPath(String pathName, PathPoint point)
    {
		//pluginPanel.activePath.getText();//config.activePath();

        if(pathName == null) return;

		point.setPathOwnerName(pathName);

        //log.debug("Checking for existing path: {}", activePath);
        PathmakerPath path;
        if(paths.containsKey(pathName))
        {
            path = paths.get(pathName);
            path.addPathPoint(point);
        }
        else
        {
            // Initialize new path with the initial point and default values
            path = new PathmakerPath(point);
            path.color = getDefaultPathColor();
			path.labelMode = config.pathPointLabelMode();
			path.pointDrawMode = config.drawPathPointsMode();

            paths.put(pathName, path);
			pluginPanel.activePath.setText(pathName);
        }

		// Add to the reverse lookup map
		if(!reversePathsLookup.containsKey(point.getRegionId()))
		{
			ArrayList<String> pathNameArray = new ArrayList<>();
			pathNameArray.add(pathName);
			reversePathsLookup.put(point.getRegionId(), pathNameArray);
		}
		else if (!reversePathsLookup.get(point.getRegionId()).contains(pathName))
			reversePathsLookup.get(point.getRegionId()).add(pathName);
    }

    void removePoint(String pathName, PathPoint point)
    {
		PathmakerPath path = paths.get(pathName);
		int regionID = point.getRegionId();

		path.removePathPoint(point);

		// Check if the path still has points within the region
		if(!path.hasPointsInRegion(regionID))
		{
			removePathReverseLookupRegion(regionID, pathName);
		}

        if (path.getSize() == 0)
        {
            removePath(pathName);
        }
		else
			savePath(pathName);

        rebuildPanel(false);
    }

    void removePath(String pathName)
    {
        PathmakerPath path = paths.remove(pathName);

		saveProperty("path", pathName, null, null);

		if(!path.getRegionIDs().isEmpty())
		{
			for (Integer integer : path.getRegionIDs())
			{
				removePathReverseLookupRegion(integer, pathName);
			}
		}
    }

	void removePathReverseLookupRegion(int regionId, String pathName)
	{
		ArrayList<String> regionPaths = reversePathsLookup.get(regionId);

		// Remove the name of the path from the reverse lookup map for the region
		if(regionPaths.size() > 1)
			regionPaths.remove(pathName);
		else // Delete region key if no paths have points within it
			reversePathsLookup.remove(regionId);
	}

    String getActivePathName()
    {
        return pluginPanel.activePath.getText();
    }

    // Default colour if active path contains no points
    String getActiveOrDefaultPathColorString(String string)
    {
        return (paths.containsKey(getActivePathName()) ?
                ColorUtil.wrapWithColorTag(Text.removeTags(string), paths.get(getActivePathName()).color) :
                ColorUtil.wrapWithColorTag(Text.removeTags(string), config.pathColor()));
    }

    // For moving points
    void updatePointLocation(String pathName, PathPoint point, int newRegionId, int x, int y, int z)
    {
        if(point.getRegionId() != newRegionId)
        {
            paths.get(pathName).updatePointRegion(point, newRegionId);
            //log.debug("Entity moved into a new region!");
        }

        point.updateRegionLocation(newRegionId, x, y, z);
    }

    void rebuildPanel(boolean savePaths)
    {
        pluginPanel.rebuild();
		if(savePaths)
			saveAll();
    }

    Tile getTile(WorldView wv, WorldPoint wp)
    {
        LocalPoint lp = LocalPoint.fromWorld(client, wp);
        if (lp == null) return null;

        return getTile(wv, lp.getSceneX(), lp.getSceneY());
    }

    Tile getTile(WorldView wv, int localSceneX, int localSceneY)
    {
        return wv.getScene().getTiles()[wv.getPlane()][localSceneX][localSceneY];
    }

    TileObject getTileObject(WorldView wv, PathPointObject point)
    {
        WorldPoint wp = WorldPoint.fromRegion(point.getRegionId(), point.getX(), point.getY(), wv.getPlane());
        return getTileObject(wv, wp, point.getEntityId());
    }

    TileObject getTileObject(WorldView wv, WorldPoint wp, int objectId)
    {
        return getTileObject(getTile(wv, wp), objectId);
    }

	TileObject getTileObject(WorldView wv, LocalPoint lp, int objectId)
	{
		return getTileObject(getTile(wv, lp.getSceneX(), lp.getSceneY()), objectId);
	}

    // THANK YOU ObjectIndicatorsPlugin for this!
    TileObject getTileObject(Tile tile, int id)
    {
        if (tile == null) return null;

        // Get all objects on tile
        final GameObject[] tileGameObjects = tile.getGameObjects();
        final DecorativeObject tileDecorativeObject = tile.getDecorativeObject();
        final WallObject tileWallObject = tile.getWallObject();
        final GroundObject groundObject = tile.getGroundObject();

        // Return the object with a matching ID
        if (isObjectIdEqual(tileWallObject, id)) return tileWallObject;
        if (isObjectIdEqual(tileDecorativeObject, id)) return tileDecorativeObject;
        if (isObjectIdEqual(groundObject, id)) return groundObject;
        for (GameObject object : tileGameObjects)
        {
            if (isObjectIdEqual(object, id))
            {
                return object;
            }
        }

        // Occurs also if an object within the loaded regions despawns (ie, tree chopped)
        //log.debug("No Object found with id " + id);
        return null;
    }

    // THANK YOU ObjectIndicatorsPlugin for this!
    boolean isObjectIdEqual(TileObject tileObject, int id)
    {
        if (tileObject == null) return false;
        if (tileObject.getId() == id) return true;

        // Menu action EXAMINE_OBJECT sends the transformed object id, not the base id, unlike
        // all of the GAME_OBJECT_OPTION actions, so check the id against the impostor ids
        final ObjectComposition comp = client.getObjectDefinition(tileObject.getId());

        if (comp.getImpostorIds() != null)
        {
            for (int impostorId : comp.getImpostorIds())
            {
                if (impostorId == id)
                {
                    return true;
                }
            }
        }
        return false;
    }

    Polygon getEntityPolygon(WorldView wv, PathPointObject point)
    {
        return getEntityPolygon(wv, LocalPoint.fromWorld(wv, point.getWorldPoint()), point.isNpc(), point.getEntityId());
    }

    Polygon getEntityPolygon(WorldView wv, LocalPoint lp, boolean isNpc, int entityId)
    {
        if(isNpc)
        {
            NPC npc = wv.npcs().byIndex(entityId);
            if(npc != null) return npc.getCanvasTilePoly();
        }
        else
        {
            TileObject object = getTileObject(getTile(wv, lp.getSceneX(), lp.getSceneY()), entityId);

            if (object instanceof GameObject) return ((GameObject) object).getCanvasTilePoly();
            else if (object instanceof DecorativeObject) return ((DecorativeObject) object).getCanvasTilePoly();
            else if (object instanceof GroundObject) return ((GroundObject) object).getCanvasTilePoly();
            else if (object instanceof WallObject) return ((WallObject) object).getCanvasTilePoly();
            else if (object instanceof ItemLayer) return ((ItemLayer) object).getCanvasTilePoly();
        }

        return null;
    }


    // NB LocalPoint is the center of a given tile


    // Cow: 2x2     Tree: 2x2
    // [ ][X]       [ ][X]
    // [ ][ ]       [ ][ ]

    Point getEntityToCenterVector(WorldView wv, WorldPoint wp, int entityId, boolean isNpc)
    {
        return isNpc ? getNpcToCenterVector(wv, entityId) : getObjectToCenterVector(wv, wp, entityId);
    }


    Point getNpcToCenterVector(WorldView wv, int npcId)
    {
		NPC npc = wv.npcs().byIndex(npcId);
		if (npc == null) return new Point(0, 0);

		int offsetX = npc.getWorldArea().getWidth() % 2 == 0 ? -TILE_SIZE_HALF : 0;
		int offsetY = npc.getWorldArea().getHeight() % 2 == 0 ? -TILE_SIZE_HALF : 0;

		return new Point(offsetX, offsetY);
    }

    Point getObjectToCenterVector(WorldView wv, WorldPoint wp, int entityId)
    {
        LocalPoint lp = LocalPoint.fromWorld(wv, wp);
        if(lp == null) return new Point(TILE_SIZE_HALF, TILE_SIZE_HALF);

        TileObject object = getTileObject(getTile(wv, wp),  entityId);
        LocalPoint objLp = object.getLocalLocation();

        return new Point(objLp.getX() - lp.getX(), objLp.getY() - lp.getY());
    }

	String getAvailableName(Map<?,?> map, String prefix)
	{
		String groupName = prefix + " 1";
		if (!map.isEmpty())
		{
			int num = 1;
			while (map.containsKey(groupName))
			{
				num++;
				groupName = prefix + " " + num;
			}
		}
		return groupName;
	}
}

package com.Pathmaker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PathmakerPlugin.class);
		RuneLite.main(args);
	}
}
