package com.Pathmaker;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.geom.Point2D;
import java.util.Collection;
import java.util.Collections;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.text.html.parser.Entity;
import net.runelite.api.GameObject;
import net.runelite.api.MenuEntry;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Player;
import net.runelite.api.Client;
import java.awt.geom.Point2D.Float;
import net.runelite.api.NPC;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Scene;
import net.runelite.api.SceneTileModel;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;                  // For player position
import net.runelite.api.coords.WorldPoint;
import java.awt.geom.Line2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

import lombok.extern.slf4j.Slf4j; // https://projectlombok.org/features/log
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import net.runelite.http.api.worlds.World;


@Slf4j
public class PathmakerOverlay extends Overlay
{
    private static final int MAX_DRAW_DISTANCE = 32;

    private final Client client;
    private final PathmakerPlugin plugin;
    private final PathmakerConfig config;
    private final ModelOutlineRenderer modelOutlineRenderer;

    private final float tileSize = 128;

    private LocalPoint startPoint;
    private LocalPoint hoveredTile;

    @Inject
    private PathmakerOverlay(Client client, PathmakerPlugin plugin, PathmakerConfig config, ModelOutlineRenderer modelOutlineRenderer)//, WorldView worldview)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.modelOutlineRenderer = modelOutlineRenderer;

        //this.worldview = worldview;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(PRIORITY_MED);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
		// Fetch player position
        // Doing getWorldLocation instead of getLocalLocation, because world loc. is server-side.
		WorldView pWv = client.getLocalPlayer().getWorldView();

        final WorldPoint playerPos = client.getLocalPlayer().getWorldLocation();
		LocalPoint playerPosLocal = playerPos == null ? null : LocalPoint.fromWorld(pWv, new WorldPoint(playerPos.getX(), playerPos.getY(), playerPos.getPlane()));

		startPoint = LocalPoint.fromWorld(pWv,client.getLocalPlayer().getWorldLocation());//playerPosLocal == null ? startPoint : playerPosLocal;

        // Current tile
        if (config.highlightPlayerTile())
        {
			Color trueTileColor = config.highlightPlayerColor();
			Color trueTileFillColor = getTileFillColor(trueTileColor);

			highlightTile(graphics, pWv, startPoint, trueTileColor, config.playerTileBorderWidth(), trueTileFillColor);
        }

//        // Fetch hovered tile and if successful, assign it to endPoint
//        WorldView wv = client.getTopLevelWorldView();//getLocalPlayer().getWorldView();

//		wv = client.getTopLevelWorldView();

		LocalPoint lastActivePathPoint = null;
        // Highlight tiles marked by the right-click menu and draw lines between them
        if(!plugin.getStoredPaths().isEmpty())
        {
			lastActivePathPoint = drawPath(graphics);
        }

		// Draw hovered tile elements
		if(!isMouseOverHud() &&
			(config.hoveredTileDrawModeSelect() == PathmakerConfig.hoveredTileDrawMode.ALWAYS ||
			(config.hoveredTileDrawModeSelect() == PathmakerConfig.hoveredTileDrawMode.SHIFT_DOWN &&
				plugin.hotKeyPressed)))
		{
			drawHoveredTile(graphics, lastActivePathPoint);
		}

        return null;
    }

	boolean isMouseOverHud()
	{
		MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
		int last = menuEntries.length - 1;

		if (last < 0)
		{
			return false;
		}

		MenuEntry menuEntry = menuEntries[last];
		String option = menuEntry.getOption();

		return menuEntry.getWidget() != null || option.equals("Cancel"); // STANDARD_HUD_INTERFACES.contains(widgetGroupId)
	}

    void drawHoveredTile(Graphics2D graphics, @Nullable LocalPoint lastPathPoint)
    {
        // Fetch hovered tile
		WorldView wv = client.getLocalPlayer().getWorldView();
        Tile tile = wv.getSelectedSceneTile();

        // Set hovered tile to be last hovered tile if none is found
        if(tile == null)
		{
			wv = client.getTopLevelWorldView();
			tile = wv.getSelectedSceneTile();

			if (tile == null) return;
		}
        //hoveredTile = tile == null ? hoveredTile : tile.getLocalLocation();
        hoveredTile = tile.getLocalLocation();

        // Return here if the distance to hovered tile exceeds the user interactable area.
        // If endPoint height = 0, it likely means it's out of bounds
//        if (startPoint.distanceTo(hoveredTile) / tileSize >= MAX_DRAW_DISTANCE)
//		{
//            return;
//        }

		Color hoveredTileColor;

		if(config.hoverLineColorMatchPath())
		{
			hoveredTileColor = plugin.pathExists(plugin.getActivePathName()) ?
				plugin.getStoredPaths().get(plugin.getActivePathName()).color :
				config.pathColor();
		}
		else
		{
			hoveredTileColor = config.highlightHoveredColor();
		}

		Color hoveredTileFillColor = getTileFillColor(hoveredTileColor);

        // Highlight hovered tile
        if (config.highlightHoveredTile())
		{
			highlightTile(graphics, wv, hoveredTile, hoveredTileColor, config.hoveredTileBorderWidth(), hoveredTileFillColor);
        }

        // Add label
        if (config.hoveredTileLabelModeSelect() != PathmakerConfig.hoveredTileLabelMode.NONE) {
            String hoveredTileLabel = constructHoveredTileString(wv, tile);
            if (!hoveredTileLabel.isEmpty()) {
                addLabel(graphics, wv, hoveredTile, 0, hoveredTileLabel, config.hoveredTileLabelColor());
            }
        }

        // Draw line to hovered line
        // Set hover line to match the active path color if true
        if(config.drawHoverLine())
        {
            switch (config.hoveredTileLineOriginSelect()) {
                case PATH_END: {
                    if (!plugin.pathExists((plugin.getActivePathName()))) {
                        break;
                    }
                    PathmakerPath activePath = plugin.getStoredPaths().get(plugin.getActivePathName());
                    PathPoint lastPoint = activePath.getPointAtDrawIndex(activePath.getSize() - 1);
					//WorldView lastWv = client.getWorldView(lastPoint.getWorldViewId());

                    if (!activePath.isPointInRegions(lastPoint, client.getTopLevelWorldView().getMapRegions()))
                    {
                        break;
                    }

					if (lastPathPoint == null)
					{
						lastPathPoint = pathPointToLocal(wv,lastPoint);//lastWv, lastPoint);
						if(lastPathPoint == null) break;

						//Set line origin to be in the center of objects
						if (lastPoint instanceof PathPointObject)
						{
							lastPathPoint = lastPathPoint.dx(((PathPointObject) lastPoint).getToCenterVectorX());
							lastPathPoint = lastPathPoint.dy(((PathPointObject) lastPoint).getToCenterVectorY());
						}
					}

                    drawLine(graphics, lastPathPoint, hoveredTile, wv, wv, hoveredTileColor, (float) config.pathLineWidth());
                    break;
                }
                case TRUE_TILE: {
                    drawLine(graphics, startPoint, hoveredTile, client.getLocalPlayer().getWorldView(), wv, hoveredTileColor, (float) config.pathLineWidth());
                    break;
                }
                default:
                    break;
            }
        }
    }

    // Highlight tiles marked by the right-click menu and draw lines between them
    LocalPoint drawPath(Graphics2D graphics)
    {
		if (plugin.getStoredPaths().isEmpty()) return null;
        HashMap<String, PathmakerPath> paths = plugin.getStoredPaths();
		ArrayList<Integer> loadedRegions = new ArrayList<>();
		String activePathName = plugin.getActivePathName();
		LocalPoint lastActivePathPoint = null;

		for (int regionId : client.getTopLevelWorldView().getMapRegions())
		{
			loadedRegions.add(regionId);
		}

		if (client.getLocalPlayer().getWorldView().isInstance())
		{
			// needed for cox
			int playerRegion = client.getLocalPlayer().getWorldLocation().getRegionID();
			if (!loadedRegions.contains(playerRegion)) loadedRegions.add(playerRegion);

			// needed for sailboat
			WorldPoint baseInstancePoint = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
			if (!loadedRegions.contains(baseInstancePoint.getRegionID()))
				loadedRegions.add(baseInstancePoint.getRegionID());

			//log.debug("playerRegion: {}, BaseInstanceReg: {}", playerRegion, baseInstancePoint.getRegionID());
		}

        for (String pathName : paths.keySet())
        {
			//LocalPoint lastLocalP = null;
			//WorldView lastWv = client.getTopLevelWorldView();
            PathmakerPath path = paths.get(pathName);
			ArrayList<LocalPoint> line = new ArrayList<>();
			ArrayList<WorldView> lineWVs = new ArrayList<>();
			ArrayList<Boolean> drawToPrevious = new ArrayList<>();

            if(path.hidden)
            {
                continue;
            }

			int pathSize = path.getSize();
			if(path.drawToPlayer == PathPanel.drawFromPlayerMode.START_ONLY.ordinal() || path.drawToPlayer == PathPanel.drawFromPlayerMode.ALWAYS.ordinal())
			{
				line.add(client.getLocalPlayer().getLocalLocation());
				lineWVs.add(client.getLocalPlayer().getWorldView());
				drawToPrevious.add(true);
			}

            ArrayList<PathPoint> drawOrder = paths.get(pathName).getDrawOrder(loadedRegions);

            if (config.drawPath() || config.drawPathPoints())
            {
				Color pathPointColor = config.pointMatchPathColor() ? path.color : config.pathLinePointColor();
				Color pathPointFillColor = getTileFillColor(pathPointColor);

                for (int i = 0; i < drawOrder.size(); i++)
				{
					PathPoint point = drawOrder.get(i);
					WorldPoint wp = toLocalInstance(point.getWorldPoint(), loadedRegions);
					WorldView wv;
					if (wp == null)
					{
						wp = point.getWorldPoint();
						wv = client.getTopLevelWorldView();
					}
					else
						wv = client.getLocalPlayer().getWorldView();

                    LocalPoint localP = LocalPoint.fromWorld(wv, wp);//pathPointToLocal(wv, point);
                    //LocalPoint centerLocation;
                    // Draw outlines first, as this also lets us conveniently update the stored point locations
                    if(point instanceof PathPointObject)
                    {
						// Updating NPC world positions AND fetching current client side position to draw on

						boolean isNpc = ((PathPointObject) point).isNpc();
						int entityId = ((PathPointObject) point).getEntityId();


						localP = getCurrentEntityPosition(wv, point, true);

						if(localP != null)
						{
							if(config.objectAndNpcOutline())
								drawOutline(wv, localP, isNpc, entityId, config.objectAndNpcOutlineWidth(), path.color, 200);

							if (config.drawPathPoints())
							{
								highlightTile(graphics, wv, plugin.getEntityPolygon(wv, localP, isNpc, entityId), pathPointColor, config.pathLinePointWidth(), pathPointFillColor);
							}

							localP = toEntityCenter((PathPointObject) point, localP);
//							localP = localP.dx(((PathPointObject) point).getToCenterVectorX());
//							localP = localP.dy(((PathPointObject) point).getToCenterVectorY());
						}

						drawLabel(graphics, wv, localP, point.getDrawIndex(), point.getLabel(), path.color);
                    }
					else if(config.drawPathPoints()) // Draw non-entity tile highlights
					{
						highlightTile(graphics, wv, localP, pathPointColor, config.pathLinePointWidth(), pathPointFillColor);
						//drawLabel(graphics, wv, point, path.color);
					}

                    // Only draw line if the previous point had a draw index that was directly behind this.
                   if ((config.drawPath()))// && pathSize > 1) && i > 0 && drawOrder.get(i - 1).getDrawIndex() == point.getDrawIndex() - 1)
				   {
					   lineWVs.add(wv);
					   line.add(localP);//drawLine(graphics, lastLocalP, localP, lastWv, wv, path.color, (float) config.pathLineWidth());
					   drawToPrevious.add(point.drawToPrevious);
				   }

					drawLabel(graphics, wv, localP, point.getDrawIndex(), point.getLabel(), path.color);
                    //lastLocalP = localP;
					//lastWv = wv;
                }

            }

            // Loop path
            if (path.loopPath &&
				path.getSize() > 2 &&
				config.drawPath() &&
				path.isPointInRegions(path.getPointAtDrawIndex(path.getSize() -1), loadedRegions) &&
				path.isPointInRegions(path.getPointAtDrawIndex(0), loadedRegions))
            {
				line.add(line.get(0));
				lineWVs.add(lineWVs.get(0));
				drawToPrevious.add(true);
//                // Making sure both ends are loaded
//                if(path.isPointInRegions(path.getPointAtDrawIndex(path.getSize() -1), loadedRegions) &&
//                        path.isPointInRegions(path.getPointAtDrawIndex(0), loadedRegions))
//                {
//					PathPoint startP = path.getPointAtDrawIndex(0);
//
//					WorldPoint startWp = toLocalInstance(startP.getWorldPoint(), loadedRegions);
//					WorldView startWv;
//					if(startWp != null)
//						startWv = client.getLocalPlayer().getWorldView();
//					else
//					{
//						startWv = client.getTopLevelWorldView();
//						//startWp = startP.getWorldPoint();
//					}
//
//					LocalPoint startLp = getCurrentEntityPosition(startWv, startP, false);
//
//					if(startP instanceof PathPointObject)
//						startLp = toEntityCenter((PathPointObject) startP, startLp);
//
//					//WorldView startWv = client.getWorldView(startP.getWorldViewId());
//					//LocalPoint startLp = pathPointToLocal(wv, path.getPointAtDrawIndex(0));
//
////                    PathPoint lastP = path.getPointAtDrawIndex(path.getSize() - 1);
//
//                    drawLine(graphics, lastLocalP, startLp, lastWv, startWv, path.color, (float) config.pathLineWidth());
//                }
            }

			if (line.size() > 1)
			{
				WorldView wv = client.getTopLevelWorldView();
				int LOCAL_HALF_TILE_SIZE = Perspective.LOCAL_HALF_TILE_SIZE;

				if (path.pathDrawOffset != PathPanel.pathDrawOffset.OFFSET_MIDDLE.ordinal() && path.drawToPlayer != PathPanel.drawFromPlayerMode.ALWAYS.ordinal())
				{
					ArrayList<int[]> tileXs = new ArrayList<>();
					ArrayList<int[]> tileYs = new ArrayList<>();
					boolean buildLeft = path.pathDrawOffset == PathPanel.pathDrawOffset.OFFSET_LEFT.ordinal();
					for (int i = 0; i < line.size(); i++)
					{
						LocalPoint lp = line.get(i);
						if (lp == null) continue;

						Tile tile = plugin.getTile(wv, lp.getSceneX(), lp.getSceneY());
						if (tile == null) continue;

						int[] tileX = new int[4];
						tileX[0] = lp.getX() - LOCAL_HALF_TILE_SIZE;
						tileX[1] = lp.getX() + LOCAL_HALF_TILE_SIZE;
						tileX[2] = lp.getX() + LOCAL_HALF_TILE_SIZE;
						tileX[3] = lp.getX() - LOCAL_HALF_TILE_SIZE;

						int[] tileY = new int[4];
						tileY[0] = lp.getY() + LOCAL_HALF_TILE_SIZE;
						tileY[1] = lp.getY() + LOCAL_HALF_TILE_SIZE;
						tileY[2] = lp.getY() - LOCAL_HALF_TILE_SIZE;
						tileY[3] = lp.getY() - LOCAL_HALF_TILE_SIZE;

						tileXs.add(tileX);
						tileYs.add(tileY);
					}

					ArrayList<ArrayList<LocalPoint>> lineVertices = PathTileOutline.build(lineWVs, tileXs, tileYs, buildLeft, drawToPrevious);

					for(int vis = 0; vis < drawToPrevious.size(); vis ++)
					{

//						if((vis > 0 && drawToPrevious.get(vis)) || (vis == 0 && drawToPrevious.get(vis + 1)))
//						{
						if((vis != 0 && drawToPrevious.get(vis) || (vis + 1 < drawToPrevious.size() && drawToPrevious.get(vis + 1))))
						{
						int itStart = (vis > 0 && !drawToPrevious.get(vis)) || (vis == 0 && !drawToPrevious.get(vis + 1)) ? 1 : 0;
						ArrayList<LocalPoint> lineV =  lineVertices.get(vis);
						itStart = itStart > lineV.size() ? 0 : itStart;


						for (int i = itStart; i < lineV.size(); i++)
							{
								LocalPoint startLp;
								if (path.drawToPlayer == PathPanel.drawFromPlayerMode.ALWAYS.ordinal())
									startLp = lineVertices.get(0).get(0);
								else if (vis > 0 && i == 0)
								{
									ArrayList<LocalPoint> prevVertArray = lineVertices.get(vis - 1);
									startLp = prevVertArray.get(prevVertArray.size() - 1);
								}
								else if (vis > 0 || i > 0)
									startLp = lineV.get(i - 1);
								else
									continue;

								LocalPoint endLp = lineV.get(i);

								if (startLp == null || endLp == null) continue;

								drawLine(graphics, startLp, endLp, wv, wv, path.color, (float) config.pathLineWidth());
							}
						}
					}
				}
				else
				{
					for (int i = 1; i < line.size(); i++)
					{
						LocalPoint startLp;
						WorldView startWv;

						if (!drawToPrevious.get(i)) continue;

						if(path.drawToPlayer == PathPanel.drawFromPlayerMode.ALWAYS.ordinal())
						{
							startLp = line.get(0);
							startWv = lineWVs.get(0);
						}
						else
						{
							startLp = line.get(i - 1);
							startWv = lineWVs.get(i - 1);
						}

						drawLine(graphics,
							startLp,
							line.get(i),
							startWv,
							lineWVs.get(i),
							path.color,
							(float) config.pathLineWidth());
					}
				}
			}
        }
		return  lastActivePathPoint;
    }

	LocalPoint toEntityCenter(PathPointObject point, LocalPoint localPoint)
	{
		localPoint = localPoint.dx(point.getToCenterVectorX());
		localPoint = localPoint.dy(point.getToCenterVectorY());
		return localPoint;
	}

//	int correctPlaneForSailing(WorldView wv)
//	{
//		return wv.isTopLevel() ? wv.getPlane() : 0;
//	}

    // Convert PathPoint (region point) to local
    LocalPoint pathPointToLocal(WorldView wv, PathPoint point)
    {
        WorldPoint wp = WorldPoint.fromRegion(point.getRegionId(), point.getX(), point.getY(), point.getZ());
        return LocalPoint.fromWorld(wv, wp);
    }

    boolean highlightTile(final Graphics2D graphics, final WorldView wv, final PathPoint point, final Color color, final double borderWidth, final Color fillColor)
    {
        return highlightTile(graphics, wv, pathPointToLocal(wv, point), color, borderWidth, fillColor);
    }

    boolean highlightTile(final Graphics2D graphics, final WorldView wv, final LocalPoint lp, final Color color, final double borderWidth, final Color fillColor)
    {
        if (lp == null)// || !isLocalPointInScene(lp))
        {
            // Occurs on unload
            //log.debug("Failed to highlight tile, LocalPoint is null.");
            return false;
        }
        return highlightTile(graphics, wv, Perspective.getCanvasTilePoly(client, lp), color, borderWidth, fillColor);
    }

    boolean highlightTile(final Graphics2D graphics, final WorldView wv, final Polygon poly, final Color color, final double borderWidth, final Color fillColor)
    {
        // poly will be null i the tile is within a loaded region, but outside the camera's frustum or not loaded (i.e. despawning npcs)
        if (poly == null) return false;

        int boundsX = (int) poly.getBounds().getLocation().getX();
        int boundsY = (int) poly.getBounds().getLocation().getY();

        if(!isLocalPointInScene(wv, new LocalPoint(boundsX, boundsY, wv))) return false;


        OverlayUtil.renderPolygon(graphics, poly, color, fillColor, new BasicStroke((float) borderWidth));
        return true;
    }

//    private void drawLine(final Graphics2D graphics, final WorldView wv, final PathPoint startPoint, final PathPoint endPoint, final Color color, float lineWidth)
//    {
//        LocalPoint lineStart = pathPointToLocal(wv, startPoint);
//        LocalPoint lineEnd = pathPointToLocal(wv, endPoint);
//
//		// Correct for sailing tiles
//
//        drawLine(graphics, lineStart, lineEnd, wv, color, lineWidth);
//    }

    // Draw a line between the provided start and end points
    private void drawLine(final Graphics2D graphics, final LocalPoint startLoc, final LocalPoint endLoc, WorldView startWv, WorldView endWv, final Color color, float lineWidth){ //, int counter) {
        if (startLoc == null || endLoc == null)
        {
            return;
        }

        final int startHeight = Perspective.getTileHeight(client, startLoc, startWv.getPlane());
        final int endHeight = Perspective.getTileHeight(client, endLoc, endWv.getPlane());

        Point p1 = Perspective.localToCanvas(client, startLoc.getWorldView(), startLoc.getX(), startLoc.getY(), startHeight - config.pathZOffset() * 10);
        Point p2 = Perspective.localToCanvas(client, endLoc.getWorldView(), endLoc.getX(), endLoc.getY(), endHeight - config.pathZOffset() * 10);

        if (p1 == null || p2 == null)
        {
            return;
        }

        Line2D.Double line = new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY());

        graphics.setColor(color);
        graphics.setStroke(new BasicStroke(lineWidth));
        graphics.draw(line);
    }

    // 0 tileObject, 1 npc
    void drawOutline(WorldView wv, LocalPoint lp, Boolean isNpc, int entityId, int width, Color color, int feather)
    {
//        if (point == null) {return;}

        if(isNpc)
        {
            NPC npc = wv.npcs().byIndex(entityId);
            if(npc == null){return;}

            modelOutlineRenderer.drawOutline(npc,width,color,feather);
        }
        else
        {
            TileObject tileObject = plugin.getTileObject(wv, lp, entityId);
            if(tileObject == null){return;}
            modelOutlineRenderer.drawOutline(tileObject,width,color,feather);
        }
    }

	LocalPoint getCurrentEntityPosition(WorldView wv, PathPoint p, boolean updateMovable)
    {
		if (!(p instanceof PathPointObject)) return LocalPoint.fromWorld(wv, p.getWorldPoint());

		PathPointObject entity = (PathPointObject) p;
		LocalPoint lp = null;

        if(entity.isNpc())
        {
            NPC npc = wv.npcs().byIndex(entity.getEntityId());

			if(npc == null)
			{
				for (NPC localNpc : wv.npcs())
				{
					if (localNpc.getId() == entity.getBaseId())
					{
						npc = localNpc;

						if(updateMovable)
						{
							entity.setEntityId(localNpc.getIndex());

							Point toCenterVec = plugin.getEntityToCenterVector(wv, npc.getWorldLocation(), localNpc.getId(), true);
							entity.setToCenterVector(toCenterVec.getX(), toCenterVec.getY());
						}

						break;
					}
				}
			}

            if(npc != null)
			{
				if(updateMovable)
				{
					final WorldPoint worldNpc = WorldPoint.fromLocalInstance(wv.getScene(), npc.getLocalLocation(), wv.getPlane());

					// Update the stored belonging PathPoint
					plugin.updatePointLocation(
						entity.getPathOwnerName(),
						entity,
						worldNpc.getRegionID(),
						worldNpc.getRegionX(),
						worldNpc.getRegionY(),
						worldNpc.getPlane());
				}

				lp = npc.getLocalLocation();
			}
        }
		else if (wv.getScene().isInstance())
		{
			Collection<WorldPoint> iWps = WorldPoint.toLocalInstance(wv, entity.getWorldPoint());

			if (!iWps.isEmpty())
			{
				WorldPoint wp  = iWps.iterator().next();
				lp = LocalPoint.fromWorld(wv, wp);

				if (lp != null && updateMovable)
				{
					Point toCenterVec = plugin.getEntityToCenterVector(wv, wp, entity.getEntityId(), false);
					entity.setToCenterVector(toCenterVec.getX(), toCenterVec.getY());
				}
			}
		}

		if (lp == null)
		{
			lp = LocalPoint.fromWorld(wv, entity.getWorldPoint());
		}

		return lp;
    }

	// (point.getDrawIndex() + 1)
	void drawLabel(Graphics2D graphics, WorldView wv, LocalPoint lp, int drawIndex, @Nullable String pointLabel, Color pathColor)
	{
		Color color = config.labelMatchPathColor() ? pathColor : config.pathPointLabelColor();

		String label = "";
		boolean stringEmpty = pointLabel == null || pointLabel.isEmpty();

		switch (config.pathPointLabelModeSelect())
		{
			case NONE:
				return;
			case BOTH:
			{
				label = "p" + (drawIndex + 1) + (stringEmpty ? "" : (", " + pointLabel));
				break;
			}
			case INDEX:
			{
				label = "p" + (drawIndex + 1);
				break;
			}
			case LABEL:
			{
				if(stringEmpty) return;
				label = pointLabel;
				break;
			}
		}

		addLabel(graphics, wv, lp, config.labelZOffset() * 10, label, color);
	}

//    void drawLabel(Graphics2D graphics, WorldView wv, PathPoint point, Color pathColor)//ArrayList<PathPoint> drawOrder, Color pathColor)
//    {
//		Color color = config.labelMatchPathColor() ? pathColor : config.pathPointLabelColor();
//
//		LocalPoint lp = pathPointToLocal(wv, point);
//		if(lp == null) return;
//
//		if(point instanceof PathPointObject)
//		{
//			lp = lp.dx(((PathPointObject) point).getToCenterVectorX());
//			lp = lp.dy(((PathPointObject) point).getToCenterVectorY());
//		}
//
//		drawLabel(graphics, wv, lp, point.getDrawIndex(), point.getLabel(), pathColor);

		// Draw label. Yes the split of loops here is intentional. More performant? Hopefully
//            switch (config.pathPointLabelModeSelect()) {
//                case INDEX: {
//                    for (PathPoint point : drawOrder)
//                    {
//                        LocalPoint lp = pathPointToLocal(wv, point);
//						if(lp == null) continue;
//
//                        if(point instanceof PathPointObject)
//                        {
//                            lp = lp.dx(((PathPointObject) point).getToCenterVectorX());//plugin.getEntityCenter(((PathPointObject) point).getInradius(), lp);
//                            lp = lp.dy(((PathPointObject) point).getToCenterVectorY());
//                        }
//
//                        addLabel(graphics, wv, lp, config.labelZOffset(), "p" + (point.getDrawIndex() + 1), color);
//                    }
//                    break;
//                }
//                case LABEL: {
//                    for (PathPoint point : drawOrder)
//                    {
//                        LocalPoint lp = pathPointToLocal(wv, point);
//						if(lp == null) continue;
//
//                        if(point instanceof PathPointObject)
//                        {
//                            lp = lp.dx(((PathPointObject) point).getToCenterVectorX());
//                            lp = lp.dy(((PathPointObject) point).getToCenterVectorY());
//                        }
//
//                        if (point.getLabel() != null && !point.getLabel().isEmpty())
//                            addLabel(graphics, wv, lp, config.labelZOffset(), point.getLabel(), color);
//                    }
//                    break;
//                }
//                case BOTH:
//                {
//                    for (PathPoint point : drawOrder)
//                    {
//                        LocalPoint lp = pathPointToLocal(wv, point);
//						if(lp == null) continue;
//
//                        if(point instanceof PathPointObject)
//                        {
//                            lp = lp.dx(((PathPointObject) point).getToCenterVectorX());
//                            lp = lp.dy(((PathPointObject) point).getToCenterVectorY());
//                        }
//
//                        String label = "p" + (point.getDrawIndex() + 1);
//                        if (point.getLabel() != null && !point.getLabel().isEmpty())
//                            label += ", " + point.getLabel();
//
//                        addLabel(graphics, wv, lp, config.labelZOffset() * 10, label, color);
//                    }
//                    break;
//                }
//                default:
//                    break;
//            }
//    }

	WorldPoint toLocalInstance(WorldPoint wp, ArrayList<Integer> loadedRegions)
	{
		if (client.getLocalPlayer().getWorldView().isInstance())// && !loadedRegions.contains(wp.getRegionID()))
		{
			Collection<WorldPoint> wPs = WorldPoint.toLocalInstance(client.getLocalPlayer().getWorldView(), wp);
			for (WorldPoint iWp : wPs)
			{
				if(loadedRegions.contains(iWp.getRegionID()))
				{
					return iWp;
				}
			}
		}
		return null;
	}

    String constructHoveredTileString(WorldView wv, Tile tile)
    {
        String returnString = "";
        switch (config.hoveredTileLabelModeSelect())
        {
            case REGION:
				returnString = getTileRegionString(tile);
				break;

            case LOCATION:
				returnString = getTileLocationString(tile);
				break;

            case OFFSET:
				if(config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.PATH_END &&
					!plugin.getStoredPaths().isEmpty() && plugin.getStoredPaths().containsKey(plugin.getActivePathName()) &&
					isLocalPointInScene(wv, getLastPointInActivePath()))
				{
					returnString = getTileOffsetString(hoveredTile, getLastPointInActivePath());
				}
				else if (config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.TRUE_TILE)
				{
					returnString = getTileOffsetString(hoveredTile, startPoint);
				}
                break;

            case DISTANCE:
				if(config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.PATH_END &&
					!plugin.getStoredPaths().isEmpty() && plugin.getStoredPaths().containsKey(plugin.getActivePathName()) &&
					isLocalPointInScene(wv, getLastPointInActivePath()))
				{
					returnString = getTileDistanceString(getLastPointInActivePath(), hoveredTile);
				}
				else if (config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.TRUE_TILE)
				{
					returnString = getTileDistanceString(hoveredTile, startPoint);
				}

				break;

            case ALL:
				// Region & Location
				returnString = "R: " + getTileRegionString(tile) + ", L: " + getTileLocationString(tile);

				// Offset & Distance
				if(config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.PATH_END &&
					!plugin.getStoredPaths().isEmpty() && plugin.getStoredPaths().containsKey(plugin.getActivePathName()) &&
					isLocalPointInScene(wv, getLastPointInActivePath()))
				{
					returnString += ", O: " + getTileOffsetString(hoveredTile, getLastPointInActivePath());
					returnString += ", D: " + getTileDistanceString(getLastPointInActivePath(), hoveredTile);
				}
				else if (config.hoveredTileLineOriginSelect() == PathmakerConfig.hoveredTileLineOrigin.TRUE_TILE)
				{
					returnString += ", O: " + getTileOffsetString(hoveredTile, startPoint);
					returnString += ", D: " + getTileDistanceString(startPoint, hoveredTile);
				}
				break;

            default:
				break;
        }

        return returnString;
    }

    LocalPoint getLastPointInActivePath()
    {
        PathmakerPath activePath = plugin.getStoredPaths().get(plugin.getActivePathName());
        PathPoint lastPoint = activePath.getPointAtDrawIndex(activePath.getSize() - 1);
        WorldPoint wp = WorldPoint.fromRegion(lastPoint.getRegionId(),lastPoint.getX(), lastPoint.getY(), lastPoint.getZ());
        return LocalPoint.fromWorld(client.getTopLevelWorldView(), wp);
    }

    String getTileLocationString(Tile tile)
    {
        return "( " + tile.getWorldLocation().getX() + ", " + tile.getWorldLocation().getY() + " )";
    }

    String getTileOffsetString(LocalPoint start, LocalPoint end)
    {
        return "( " + (int) ((start.getX() - end.getX()) / tileSize) + ", " + (int) ((start.getY() - end.getY()) / tileSize) + " )";
    }

    String getTileDistanceString(LocalPoint from,  LocalPoint to)
    {
		if(from == null || to == null) return "";

		int x = Math.abs(to.getX() - from.getX());
		int y = Math.abs(to.getY() - from.getY());


        return String.valueOf((int) ((Math.max(x, y))/ tileSize)); // distance to is 1.414 to diagonal tiles
    }

	Color getTileFillColor(Color tileColor)
	{
		return new Color(tileColor.getRed(), tileColor.getGreen(), tileColor.getBlue(),  tileColor.getAlpha() / 5);
	}

    String getTileRegionString(Tile tile)
    {
        return String.valueOf(tile.getWorldLocation().getRegionID());
    }


    boolean addLabel(Graphics2D graphics, WorldView wv, LocalPoint tileLoc, int zOffset, String labelText, Color color)
    {
        if (tileLoc == null || !isLocalPointInScene(wv, tileLoc))
            return false;

        Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, tileLoc, labelText, zOffset);

        if (canvasTextLocation != null)
        {
            OverlayUtil.renderTextLocation(graphics, canvasTextLocation, labelText, color);
            return true;
        }
        return false;
    }

    boolean isLocalPointInScene(final WorldView wv, final LocalPoint point)
    {
		return wv.contains(point);
    }

	float average (int[] ints)
	{
		return (float) Arrays.stream(ints).sum() / ints.length;
	}

	// Return 1 if positive, 0 if zero -1 if negative
	int sign(float v)
	{
		return v > 0 ? 1 : (v < 0 ? -1 : 0);
	}

	Point2D.Float normalize(Point a, Point b)
	{
		float dist = a.distanceTo(b);
		Point2D.Float ab = new Point2D.Float(b.getX() - a.getX(), b.getY() - a.getY());
		ab.setLocation(ab.x / dist, ab.y / dist);
		return ab;
	}
}

package com.Pathmaker;

import javax.annotation.Nullable;
import net.runelite.api.coords.WorldPoint;

// Ref: GroundMarkerPoint - https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/groundmarkers/GroundMarkerPoint.java#L38
public class PathPoint
{
    private int pathDrawIndex = -1;
    private int regionId;
    private int regionX;
    private int regionY;
    private int z;
	boolean drawToPrevious = true;

	private final String pathOwner;
    private String label;

    PathPoint(String path, int regID, int regX, int regY, int plane)
    {
		this.pathOwner = path;
        this.regionId = regID;
        this.regionX = regX;
        this.regionY = regY;
        this.z = plane;
    }

    PathPoint(String path, WorldPoint worldPoint)
    {
		this.pathOwner = path;
        this.regionId = worldPoint.getRegionID();
        this.regionX = worldPoint.getRegionX();
        this.regionY = worldPoint.getRegionY();
        this.z = worldPoint.getPlane();
    }

	String getPathOwnerName()
	{
		return this.pathOwner;
	}

    int getRegionId()
    {
        return regionId;
    }

    int getX()
    {
        return regionX;
    }
    int getY()
    {
        return regionY;
    }
    int getZ()
    {
        return z;
    }

    WorldPoint getWorldPoint()
    {
        return WorldPoint.fromRegion(regionId, regionX, regionY, z);
    }

    void setLabel(String newLabel)
    {
        this.label = newLabel;
    }

    @Nullable
    String getLabel()
    {
        return label;
    }

    void setDrawIndex(int index)
    {
        this.pathDrawIndex = index;
    }

    int getDrawIndex()
    {
        return pathDrawIndex;
    }

    void updateRegionLocation(int region, int x, int y, int z)
    {
        // DONT FORGET TO ALSO UPDATE BELONGING PathmakerPath! USE plugin.updatePointLocation
        this.regionId = region;
        this.regionX = x;
        this.regionY = y;
        this.z = z;
    }
}

package com.Pathmaker;


import java.awt.Color;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.awt.Component;

import java.util.ArrayList;
import java.util.Objects;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.border.CompoundBorder;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.ImageIcon;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;

@Slf4j
public class PathPanel extends JPanel
{
    private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

    private static final ImageIcon EXPAND_ICON;
    private static final ImageIcon COLLAPSE_ICON;
    private static final ImageIcon LOOP_ON_ICON;
    private static final ImageIcon LOOP_OFF_ICON;
    private static final ImageIcon EYE_OPEN_ICON;
	private static final ImageIcon EYE_CLOSED_ICON;
	private static final ImageIcon OFFSET_LEFT_ICON;
	private static final ImageIcon OFFSET_MIDDLE_ICON;
	private static final ImageIcon OFFSET_RIGHT_ICON;
	private static final ImageIcon PERSON_ICON;
	private static final ImageIcon PERSON_GREEN_ICON;
	private static final ImageIcon PERSON_GREEN_LINES_ICON;

	enum pathDrawOffset
	{
		OFFSET_LEFT,
		OFFSET_MIDDLE,
		OFFSET_RIGHT,
	}

	enum drawFromPlayerMode
	{
		NEVER,
		START_ONLY,
		ALWAYS,
	}

    private final PathmakerPlugin plugin;
    private final PathmakerPath path;

    private final JPanel pathContainer = new JPanel();
    private final JButton label = new JButton();

    private final int ICON_WIDTH = 18;

    //private boolean panelExpanded = true;
    private final JButton expandToggle;
    private final JButton visibilityToggle;

    private final BufferedImage brushImage = ImageUtil.loadImageResource(PathmakerPlugin.class, "brush.png");
    private final BufferedImage crossImage = ImageUtil.loadImageResource(PathmakerPlugin.class, "cross.png");

    //private final int MAX_LABEL_LENGTH = 15;

    static
    {
        final int MAX_LABEL_LENGTH = 15;
        BufferedImage upArrowImage = ImageUtil.loadImageResource(PathmakerPlugin.class, "up_arrow.png");
        COLLAPSE_ICON = new ImageIcon(upArrowImage);
        EXPAND_ICON = new ImageIcon(ImageUtil.flipImage(upArrowImage, false, true));
        LOOP_ON_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "loop_on.png"));
        LOOP_OFF_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "loop_off.png"));
		OFFSET_LEFT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "offset_left.png"));
		OFFSET_MIDDLE_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "offset_middle.png"));
		OFFSET_RIGHT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "offset_right.png"));
        EYE_OPEN_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "eye_open.png"));
        EYE_CLOSED_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "eye_closed.png"));
		PERSON_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "person.png"));
		PERSON_GREEN_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "person_green.png"));
		PERSON_GREEN_LINES_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "person_green_lines.png"));
    }

    PathPanel(PathmakerPlugin plugin, String pathLabel)
    {
        this.plugin = plugin;
        this.path = plugin.getStoredPaths().get(pathLabel);
		pathContainer.setLayout(new BoxLayout(pathContainer, BoxLayout.Y_AXIS));

        JPanel labelPanel = new JPanel(new BorderLayout());
        labelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        label.setText(pathLabel);
        label.setForeground(Color.WHITE); //path.color);
		label.setToolTipText(pathLabel);
        label.setPreferredSize(new Dimension(122, 20)); // Client.PANEL_WIDTH = 225. (18x6 buttons, 5 margin
        labelPanel.add(label, BorderLayout.CENTER);

        expandToggle = new JButton(path.panelExpanded ? COLLAPSE_ICON : EXPAND_ICON);
        expandToggle.setPreferredSize(new Dimension(ICON_WIDTH, 0));
        expandToggle.setToolTipText((path.panelExpanded ? "Expand" : "Collapse") + " path");
        expandToggle.addActionListener(actionEvent ->
        {
            toggleCollapsed();
        });

        visibilityToggle = new JButton(path.hidden ? EYE_CLOSED_ICON : EYE_OPEN_ICON);
        visibilityToggle.setPreferredSize(new Dimension(ICON_WIDTH, 0));
        visibilityToggle.setToolTipText((path.hidden ? "Show" : "Hide") + " path");
        visibilityToggle.addActionListener(actionEvent ->
        {
            toggleVisibility();
        });

        JButton colorPickerButton = new JButton();
        colorPickerButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
        colorPickerButton.setIcon(new ImageIcon(ImageUtil.recolorImage(brushImage, path.color)));
        colorPickerButton.setToolTipText("Choose path color");
        colorPickerButton.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                RuneliteColorPicker colorPicker = getColorPicker(path.color == null ? plugin.getDefaultPathColor() : path.color, colorPickerButton);
                colorPicker.setOnColorChange(newColor ->
                {
                    path.color = newColor;
                    label.setForeground(newColor);
                    colorPickerButton.setIcon(new ImageIcon(ImageUtil.recolorImage(brushImage, newColor)));
                });
                colorPicker.setVisible(true);
            }
        });

        // Add button panel on the left
        JPanel leftActionPanel = new JPanel(new BorderLayout());
        leftActionPanel.add(expandToggle, BorderLayout.WEST);
        leftActionPanel.add(visibilityToggle, BorderLayout.CENTER);
        leftActionPanel.add(colorPickerButton, BorderLayout.EAST);
        labelPanel.add(leftActionPanel, BorderLayout.WEST);

        JButton deletePathButton = new JButton();
        deletePathButton.setIcon(new ImageIcon(ImageUtil.recolorImage(crossImage, Color.RED)));
        deletePathButton.setToolTipText("Delete path");
        deletePathButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
        String warningMsg = "Are you sure you want to permanently delete path: " + label.getText() + "?";
        deletePathButton.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent) {
                int confirm = JOptionPane.showConfirmDialog(PathPanel.this,
                        warningMsg,
                        "Warning", JOptionPane.OK_CANCEL_OPTION);

                if (confirm == 0)
                {
                    plugin.removePath(label.getText());
                    plugin.rebuildPanel(true);
                }
            }
        });

        // Add loop button
        JButton loopButton = new JButton();
        loopButton.setIcon(path.loopPath ? LOOP_ON_ICON : LOOP_OFF_ICON);
        loopButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
        loopButton.setToolTipText((path.loopPath ? "disable" :  "enable") + " path loop");
        loopButton.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                path.loopPath = !path.loopPath;
                loopButton.setToolTipText((path.loopPath ? "disable" :  "enable") + " path loop");
                loopButton.setIcon(path.loopPath ? LOOP_ON_ICON : LOOP_OFF_ICON);
            }
        });

		// Add offset button
		JButton offsetButton = new JButton();
		offsetButton.setIcon(getPathDrawOffsetIcon(path));
		offsetButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
		offsetButton.setToolTipText("Set path draw offset");
		offsetButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				path.pathDrawOffset = path.pathDrawOffset + 1 > 2 ? 0 : path.pathDrawOffset + 1;
				offsetButton.setIcon(getPathDrawOffsetIcon(path));
				//plugin.saveAll();

				offsetButton.updateUI();
			}
		});

		int pathSize = path.getSize();
		ArrayList<PathPoint> drawOrder = path.getDrawOrder(null);

		// Add offset button
		JButton loopToPlayerButton = new JButton();
		loopToPlayerButton.setIcon(getLoopToPlayerIcon(path.drawToPlayer));
		loopToPlayerButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
		loopToPlayerButton.setToolTipText(getLoopToPlayerTooltip(path.drawToPlayer));
		loopToPlayerButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{

				path.drawToPlayer = path.drawToPlayer + 1 > 2 ? 0 : path.drawToPlayer + 1;
				loopToPlayerButton.setIcon(getLoopToPlayerIcon(path.drawToPlayer));
				loopToPlayerButton.setToolTipText(getLoopToPlayerTooltip(path.drawToPlayer));
//				if(path.drawToPlayer == drawFromPlayerMode.NEVER.ordinal())
//				{
//					pathContainer.remove(pathContainer.getComponentCount() -1);
//				}
//				else if (path.drawToPlayer - 1 == drawFromPlayerMode.NEVER.ordinal())
//				{
//					JButton drawToLastButton = addDrawToLastButton(drawOrder.get(0));
//					pathContainer.add(addDrawToLastButton(drawOrder.get(0)),BorderLayout.CENTER);
//					drawToLastButton.updateUI();
//				}

				plugin.rebuildPanel(true);
				//loopToPlayerButton.setIcon(getLoopToPlayerButtonIcon(path));
				//plugin.saveAll();
			}
		});


		// Add button panel to the right
        JPanel rightActionPanel = new JPanel(new BorderLayout());
		//rightActionPanel.add(loopButton, BorderLayout.WEST);
		rightActionPanel.add(loopToPlayerButton, BorderLayout.WEST);
        rightActionPanel.add(offsetButton, BorderLayout.CENTER);
        rightActionPanel.add(deletePathButton, BorderLayout.EAST);
        labelPanel.add(rightActionPanel, BorderLayout.EAST);


        pathContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pathContainer.add(labelPanel, BorderLayout.CENTER);

        for (int i = pathSize - 1; i >= 0; i--)
        {
			PathPoint point = drawOrder.get(i);
            JPanel pointContainer = new JPanel(new BorderLayout());
            pointContainer.setBorder(new EmptyBorder(0, 0, 0, 0));
            pointContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            //
            FlatTextField pointLabel = new FlatTextField();
            String label = "";// = "Point";
            label = (point.getLabel() != null && !point.getLabel().isEmpty()) ? point.getLabel() : label;
            pointLabel.setText(label);
            pointLabel.setForeground(Color.WHITE);
            pointLabel.setBackground(Color.DARK_GRAY);
            pointLabel.setPreferredSize(new Dimension(150, 20));
            pointLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
            ((AbstractDocument) pointLabel.getTextField().getDocument()).setDocumentFilter(new MaxLengthFilter(plugin.MAX_POINT_LABEL_LENGTH));
            pointLabel.getDocument().addDocumentListener(new DocumentListener()
            {
                public void insertUpdate(DocumentEvent e) {point.setLabel(pointLabel.getText());}
                public void removeUpdate(DocumentEvent e) {point.setLabel(pointLabel.getText());}
                public void changedUpdate(DocumentEvent e) {}
            });

            pointContainer.add(pointLabel, BorderLayout.WEST);

            // Add spinner box for optionally assigning a new point index.
            JSpinner indexSpinner = new JSpinner(new SpinnerNumberModel(point.getDrawIndex() + 1, 1, pathSize, 1));
            indexSpinner.setToolTipText("point index");
            indexSpinner.addChangeListener(ce ->
            {
                path.setNewIndex(point, (Integer) indexSpinner.getValue() - 1);
                plugin.rebuildPanel(true);
            });
			SpinnerNumberModel model = (SpinnerNumberModel) indexSpinner.getModel();
			// indexSpinner.getComponents()[0].getName() == "Spinner.nextButton"
			// indexSpinner.getComponents()[1].getName() == "Spinner.previousButton"
			indexSpinner.getComponents()[0].setEnabled(!model.getMaximum().equals(model.getValue()));
			indexSpinner.getComponents()[1].setEnabled(!model.getMinimum().equals(model.getValue()));

            pointContainer.add(indexSpinner, BorderLayout.CENTER);

            JButton deletePathPointButton = new JButton();
            deletePathPointButton.setIcon(new ImageIcon(crossImage));
            deletePathPointButton.setToolTipText("Delete point");
            deletePathPointButton.setPreferredSize(new Dimension(ICON_WIDTH, 0));
            deletePathPointButton.addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent mouseEvent) {
                    plugin.removePoint(getPathLabel().getText(), point);
                    // Rebuilding in removePoint (because of the in-game shift+click dropdown menu)
                }
            });
            pointContainer.add(deletePathPointButton, BorderLayout.EAST);

			if(i > 0 || path.drawToPlayer != drawFromPlayerMode.NEVER.ordinal())
			{
				pointContainer.add(addDrawToLastButton(point), BorderLayout.SOUTH);
			}

            pointContainer.setVisible(path.panelExpanded);
            pathContainer.add(pointContainer);
        }
        add(pathContainer);
    }

	private JButton addDrawToLastButton(PathPoint point)
	{
		JButton drawToLastButton = new JButton();
		//drawToLastButton.setIcon(new ImageIcon(crossImage));
		drawToLastButton.setToolTipText(point.drawToPrevious ? "Unlink from previous point" : "Link to previous point");
		Color defaultColor = drawToLastButton.getBackground();
		drawToLastButton.setBackground(point.drawToPrevious ? defaultColor : Color.RED);
		//drawToLastButton.setText(point.drawToPrevious ? "(linked)" : "(unlinked)");
		//drawToLastButton.setForeground(getBackground().brighter().brighter());
		drawToLastButton.setPreferredSize(new Dimension(0, 10));
		drawToLastButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				point.drawToPrevious = !point.drawToPrevious;
				drawToLastButton.setBackground(point.drawToPrevious ? defaultColor : Color.RED);
				//drawToLastButton.setText(point.drawToPrevious ? "(linked)" : "(unlinked)");
				//drawToLastButton.setForeground(getBackground().brighter().brighter());
				plugin.saveAll();
			}
		});
		return drawToLastButton;
	}

    private void toggleCollapsed()
    {
        path.panelExpanded = !path.panelExpanded;
        for (int i = 1; i < pathContainer.getComponentCount(); i++)
        {
            pathContainer.getComponent(i).setVisible(path.panelExpanded);
        }

        expandToggle.setIcon(path.panelExpanded ? COLLAPSE_ICON : EXPAND_ICON);
        expandToggle.setToolTipText((path.panelExpanded ? "Collapse" : "Expand") + " path");
    }

    private void toggleVisibility()
    {
        path.hidden = !path.hidden;

        visibilityToggle.setIcon(path.hidden ? EYE_CLOSED_ICON : EYE_OPEN_ICON);
        visibilityToggle.setToolTipText((path.hidden ? "Show" : "Hide") + " path");
    }

    void setPathLabel(String label)
    {
        this.label.setText(label);
    }

    JButton getPathLabel()
    {
        return label;
    }

	ImageIcon getPathDrawOffsetIcon(PathmakerPath path)
	{
		switch (pathDrawOffset.values()[path.pathDrawOffset])
		{
			case OFFSET_LEFT: return OFFSET_LEFT_ICON;
			case OFFSET_RIGHT: return OFFSET_RIGHT_ICON;
			default: return OFFSET_MIDDLE_ICON;
		}
	}

	ImageIcon getLoopToPlayerIcon(int drawToPlayer)
	{
		switch (drawFromPlayerMode.values()[drawToPlayer])
		{
			case START_ONLY: return PERSON_GREEN_ICON;
			case ALWAYS: return PERSON_GREEN_LINES_ICON;
			default: return PERSON_ICON;
		}
	}

	String getLoopToPlayerTooltip(int drawToPlayer)
	{
		switch (drawFromPlayerMode.values()[drawToPlayer])
		{
			case START_ONLY: return "Set always draw to player";
			case ALWAYS: return "Un-set player from path";
			default: return "Set player as point 0";
		}
	}

    private RuneliteColorPicker getColorPicker(Color colour, Component relativeTo)
    {
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                colour,
                label.getText() + " path color",
                false);
        colorPicker.setLocationRelativeTo(relativeTo);
        return colorPicker;
    }
}
package com.Pathmaker;

import javax.swing.event.DocumentEvent;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;

public class MaxLengthFilter extends DocumentFilter
{
    private final int max;

    public MaxLengthFilter(int max) {
        this.max = max;
    }

    @Override
    public void insertString(FilterBypass fb, int offset, String text, AttributeSet attrs)
            throws BadLocationException {

        // Swing sometimes passes null text during input events
        if (text == null)
            return;

        // Filter out non-printable control characters
        text = filterPrintable(text);

        // Only allow insertion if total length stays within limit
        int currentLength = fb.getDocument().getLength();
        int newLength = currentLength + text.length();

        if (newLength <= max)
        {
            // Entire text can be inserted safely
            super.insertString(fb, offset, text, attrs);
        }
        else
        {
            // Only insert part of the text that fits
            int allowed = max - currentLength;

            if (allowed > 0)
            {
                super.insertString(fb, offset, text.substring(0, allowed), attrs);
            }
        }
    }

    @Override
    public void replace(FilterBypass fb, int offset, int length, String text, AttributeSet attrs)
            throws BadLocationException
    {

        // Replace text can also be null
        if (text == null)
            text = "";

        int currentLength = fb.getDocument().getLength();
        int newLength = currentLength - length + text.length();

        if (newLength <= max)
        {
            // Replacement does not exceed max length
            super.replace(fb, offset, length, text, attrs);
        }
        else
        {
            // Only some of the new text can fit
            int allowed = max - (currentLength - length);
            if (allowed > 0)
            {
                // Insert only the allowed substring, preserving caret & selection
                super.replace(fb, offset, length, text.substring(0, allowed), attrs);
            }
        }
    }


     // remove() is called before text is deleted.
     // Usually no restrictions are needed for removal.

    @Override
    public void remove(FilterBypass fb, int offset, int length)
            throws BadLocationException {
        super.remove(fb, offset, length);
    }


    // Utility method to strip out non-printable control characters.
    // (Allows letters, digits, punctuation, symbols, emoji, etc.)
    private String filterPrintable(String input) {
        StringBuilder out = new StringBuilder();

        for (char c : input.toCharArray()) {
            if (!Character.isISOControl(c)) {  // filter out control chars
                out.append(c);
            }
        }
        return out.toString();
    }
}
package com.Pathmaker;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.TileObject;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nonnull;
import java.awt.*;

@Slf4j
public class PathPointObject extends PathPoint
{
    // Should be assigned / unassigned as the player enters the area
    //private TileObject tileObject;

    private int id = -1; // active instance
	private final int baseId; // for lookup
    private final boolean isNpc;
    private int toCenterVectorX = 64;
    private int toCenterVectorY = 64;

	PathPointObject(String path, @Nonnull TileObject tileObject, int baseId)
	{
		super(path, tileObject.getWorldLocation().getRegionID(), tileObject.getWorldLocation().getRegionX(),
			tileObject.getWorldLocation().getRegionY(), tileObject.getWorldView().getPlane());

		isNpc = false;
		id = tileObject.getId();
		this.baseId = baseId;
	}

    PathPointObject(String path, @Nonnull NPC npc, int id, int baseId)
    {
        super(path, npc.getWorldLocation().getRegionID(),
                npc.getWorldLocation().getRegionX(),
                npc.getWorldLocation().getRegionY(),
                npc.getWorldView().getPlane());

        this.isNpc = true;
        this.id = id;
		this.baseId = baseId;
    }

    PathPointObject(String p, int r, int x, int y, int z, int id, int baseId, boolean isNpc)
    {
        super(p, r, x, y, z);

        this.isNpc = isNpc;
        this.id = id;
		this.baseId = baseId;
    }

    // footprint * TileSize / 2
    void setToCenterVector(int x, int y)
    {
        this.toCenterVectorX = x;
        this.toCenterVectorY = y;
    }

    int getToCenterVectorX()
    {
        return this.toCenterVectorX;
    }
    int getToCenterVectorY()
    {
        return this.toCenterVectorY;
    }

//    private Renderable getRenderableObject(TileObject tileObject)
//    {
//        Renderable renderObj = null;
//
//        if (tileObject instanceof GameObject) {renderObj = ((GameObject) tileObject).getRenderable();} // Boxes, trees
//        else if (tileObject instanceof GroundObject) {renderObj = ((GroundObject) tileObject).getRenderable();} // Grass
//        else if (tileObject instanceof ItemLayer) {renderObj = ((ItemLayer) tileObject).getBottom();}  // Items held by tile
//        else if (tileObject instanceof DecorativeObject) {renderObj = ((DecorativeObject) tileObject).getRenderable();}
//        else if (tileObject instanceof WallObject) {renderObj = ((WallObject) tileObject).getRenderable1();}
//        return renderObj;
//    }

	int getBaseId()
	{
		return this.baseId;
	}

    int getEntityId()
    {
        return this.id;
    }

	void setEntityId(int entityId)
	{
		this.id = entityId;
	}

    boolean isNpc()
    {
        return isNpc;
    }

//    TileObject getObject()
//    {
//        return tileObject;
//    }
//
//
//    TileObject loadObject(TileObject object)
//    {
//        this.tileObject = object;
//        return this.tileObject;
//    }
//
//    void unloadObject()
//    {
//        this.tileObject = null;
//    }

//    void loadNpc (NPC npc)
//    {
//        this.npc = npc;
//    }
//
//    void unloadNpc()
//    {
//        npc = npc;
//    }
}

package com.Pathmaker;

import lombok.extern.slf4j.Slf4j;

import javax.annotation.Nullable;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Set;

// Collection of path points
@Slf4j
public class PathmakerPath
{
    // Map with RegionIDs for keys with an ArrayList<PathPoint> for the specified region
    // Because a path might be spread across multiple regions
    private final HashMap<Integer, ArrayList<PathPoint>> pathPoints = new HashMap<>();
    Color color;
    boolean loopPath = false;
    boolean hidden = false;
    boolean panelExpanded = true;
	int pathDrawOffset = PathPanel.pathDrawOffset.OFFSET_MIDDLE.ordinal(); // PathPanel.pathDrawOffset enum
	int drawToPlayer = PathPanel.drawFromPlayerMode.NEVER.ordinal();

    PathmakerPath(PathPoint initialPathPoint)
    {
        addPathPoint(initialPathPoint);
    }

    // Add point to existing path
    void addPathPoint(PathPoint pathPoint)
    {
        addPathPoint(pathPoint, pathPoint.getRegionId());
    }

    void addPathPoint(PathPoint pathPoint, int regionId)
    {
        // Add the tile's regionID as key for the belonging tile(s) if it doesn't already exist.
        if (!pathPoints.containsKey(regionId))
        {
            pathPoints.put(regionId, new ArrayList<PathPoint>());
        }
        pathPoints.get(regionId).add(pathPoint);

        if(pathPoint.getDrawIndex() == -1)
            pathPoint.setDrawIndex(getSize()-1);
    }

    void removePathPoint(PathPoint point)
    {
        int removedIndex = point.getDrawIndex();

		if (removedIndex != getSize()-1)
		{
			getPointAtDrawIndex(removedIndex+1).drawToPrevious = point.drawToPrevious;
		}

        innerRemovePathPoint(point);

        ArrayList<PathPoint> drawOrder = getDrawOrder(null);
        for(int i = removedIndex; i < drawOrder.size(); i++)
        {
            drawOrder.get(i).setDrawIndex(i);
        }
    }

    // ONLY use this if moving tiles between regions! Removes point without reordering the draw order
    private void innerRemovePathPoint(PathPoint point)
    {
        int regionId = point.getRegionId();

        // Remove pathPoint from the ArrayList<PathPoint>
        pathPoints.get(regionId).remove(point);
        pathPoints.get(regionId).trimToSize();

        // Remove RegionID key if the ArrayList is empty.
        if (pathPoints.get(regionId).isEmpty())
        {
            pathPoints.remove(regionId);
        }
    }

    // Fetch all path points and close any draw index gaps
    void reconstructDrawOrder()
    {
        ArrayList<PathPoint> drawOrder = getDrawOrder(null);
        boolean startRearrangement = false;
        for  (int i = 0; i < drawOrder.size(); i++)
        {
            if (drawOrder.get(i).getDrawIndex() != i)
            {
                startRearrangement = true;
            }
            if (startRearrangement)
            {
                drawOrder.get(i).setDrawIndex(i);
            }
        }
    }

    // Remove point from old and add to new region. Reordering for iteration convenience.
    // The point xyz is moved independently.
    void updatePointRegion(PathPoint point, int newRegionId)
    {
        int oldRegionId = point.getRegionId();
        innerRemovePathPoint(point);
        addPathPoint(point, newRegionId);
        reconstructRegionDrawOrder(newRegionId);
    }

    // Return the relevant region IDs for this path
    Set<Integer> getRegionIDs()
    {
        return  pathPoints.keySet();
    }

    // Return tiles based on their regionID
    ArrayList<PathPoint> getPointsInRegion(int regionID)
    {
        return  pathPoints.get(regionID);
    }

    boolean hasPointsInRegion(int regionID)
    {
        return  pathPoints.containsKey(regionID);
    }

    boolean hasPointInRegion(int regionID, PathPoint point)
    {
        if(!pathPoints.containsKey(regionID)) return false;
        return pathPoints.get(regionID).contains(point);
    }


    // 2 -> 0
    // !newGreater
    // start = newIndex
    // target = oldIndex
    // i < target
    // idx += 1

    // 0 -> 2
    // newGreater
    // start = oldIndex + 1
    // target = newIndex + 1
    // i < target
    // idx += -1

// An easier look at what's going on in the uncommented for loop below
//        if(newGreater)
//        {
//            // 3p
//            // 0 -> 2
//            for(int i = oldIndex + 1; i <= newIndex; i++)
//            {
//                getPointAtDrawIndex(i).setDrawIndex(i - 1);
//            }
//        }
//        else
//        {
//            // 3p
//            // 2 -> 0
//            for(int i = oldIndex - 1; i >= newIndex; i--)
//            {
//                getPointAtDrawIndex(i).setDrawIndex(i + 1);
//            }
//        }

    // Set new draw index for a specific point and move the other point's indices accordingly
    void setNewIndex(PathPoint point, final int newIndex)
    {
        int oldIndex = point.getDrawIndex();

        if (oldIndex == newIndex){return;}

        boolean newGreater = newIndex > oldIndex;

        int indexMoveDir = newGreater ? -1 : 1;
        int startIndex = newGreater ? oldIndex + 1 : newIndex;
        int targetIndex = newGreater ? newIndex + 1 : oldIndex;

        ArrayList<PathPoint> pointsToMove = new ArrayList<>();
        ArrayList<Integer> regionsToReconstruct = new ArrayList<>();

        regionsToReconstruct.add(point.getRegionId());

        for(int i = startIndex; i < targetIndex; i ++)
        {
            pointsToMove.add(getPointAtDrawIndex(i));
        }

        // Changing draw index above is total bait, as it messes with getPointAtDrawIndex
        // So doing it here.
        for(int i = 0; i < pointsToMove.size(); i ++)
        {
            pointsToMove.get(i).setDrawIndex(pointsToMove.get(i).getDrawIndex() + indexMoveDir); // int indexMoveDir = newGreater ? -1 : 1;

            if(!regionsToReconstruct.contains(pointsToMove.get(i).getRegionId()))
            {
                regionsToReconstruct.add(pointsToMove.get(i).getRegionId());
            }
        }

        // Assign the specified index to the specified point
        point.setDrawIndex(newIndex);

        // Once the points have been reassigned their draw order, reorder the affected ArrayList to match
        // as this will make it easier for our getDrawOrder later
        for (int regionId : regionsToReconstruct)
        {
            reconstructRegionDrawOrder(regionId);
        }
    }

    // Sort the specified ArrayList in the order of draw indices
    void reconstructRegionDrawOrder(int regionId)
    {
        if (pathPoints.get(regionId).size() < 2) {return;}

        while(true)
        {
            boolean regionOrdered = true;
            for (int i = 1; i < pathPoints.get(regionId).size(); i++)
            {
                if(pathPoints.get(regionId).get(i).getDrawIndex() < pathPoints.get(regionId).get(i-1).getDrawIndex())
                {
                    Collections.swap(pathPoints.get(regionId), i, i-1);
                    regionOrdered = false;
                }
            }

            if(regionOrdered){break;}
        }
    }

    boolean isPointInRegions(PathPoint point, int[] regionIDs)
    {
        for (int regionID : regionIDs)
        {
            if (point.getRegionId() == regionID) {
                return true;
            }
        }
        return false;
    }

    boolean isPointInRegions(PathPoint point, ArrayList<Integer>regionIDs)
    {
        return regionIDs.contains(point.getRegionId());
    }

    boolean containsPoint(PathPoint point)
    {
        for (ArrayList<PathPoint> regionPoints : pathPoints.values())
            if (regionPoints.contains(point))
                return true;

        return false;
    }

    boolean containsEntity(int[] loadedRegions, boolean isNpc, int id)
    {
        for (int regionId : loadedRegions)
        {
            if (containsEntity(regionId, isNpc, id))
            {
                return true;
            }
        }
        return false;
    }

    // Only checking points within the loaded regions.
    boolean containsEntity(int region, boolean isNpc, int id)
    {
        if (!pathPoints.containsKey(region)) return false;

        for (PathPoint regionPoint : pathPoints.get(region))
        {
            if (regionPoint instanceof PathPointObject &&
                        ((PathPointObject) regionPoint).getEntityId() == id &&
                        ((PathPointObject) regionPoint).isNpc() == isNpc)
                return true;
        }
        return false;
    }

    PathPoint getPointAtDrawIndex(int index)
    {
        for(int regionId : pathPoints.keySet())
        {
            for (PathPoint point : pathPoints.get(regionId))
            {
                if (point.getDrawIndex() == index)
                {
                    return point;
                }
            }
        }

        log.debug("Could not find point at index: {}", index);
        return null;
    }

    public ArrayList<PathPoint> getReversedDrawOrder()
    {
        ArrayList<PathPoint> reverseDrawOrder = new ArrayList<>(getDrawOrder(null));
        Collections.reverse(reverseDrawOrder);
        return reverseDrawOrder;
    }

    public ArrayList<PathPoint> reverseDrawOrder()
    {
        ArrayList<PathPoint> reverseDrawOrder = getDrawOrder(null);
        for(int i = 0; i < getSize(); i++)
        {
            reverseDrawOrder.get(i).setDrawIndex(getSize() - 1 - i);
        }

        for (int regionId : pathPoints.keySet())
        {
            Collections.reverse(pathPoints.get(regionId));
        }

        return reverseDrawOrder;
    }

    // Return the size of all stored points (across all relevant regions) for this path
    int getSize()
    {
        int numPoints = 0;
        if(!pathPoints.isEmpty())
        {
            for (int regionId : pathPoints.keySet()) {
                numPoints += pathPoints.get(regionId).size();
            }
        }
        return numPoints;
    }

    // Return an ArrayList with the PathPoints in the order they should be drawn
    // NB! If param loadedRegions is null, then getDrawOrder will return the tiles also
    // NOT in loaded regions. (which you don't want to render, but is for sorting. See reconstructDrawOrder())
    ArrayList<PathPoint> getDrawOrder(@Nullable ArrayList<Integer> loadedRegions)
    {
        ArrayList<PathPoint> drawOrder = new ArrayList<>();

        // Calculate the number of points to collect (points that are inside the loaded regions)
        int numPointsToLoad = loadedRegions == null ? getSize() : 0;
        int searchIndex = 0;

        // Creating a map for tracking the last index checked in each of the RegionIDs
        // (which is used as keys for pathPoint) so the loops do not start at 0 every time
        // This works because stored points are sorted in their individual region ArrayLists
        // based on their draw order.
        final HashMap<Integer, Integer> loopIndexTracker = new HashMap<>();


        // Get the highest index value to be used as target, mostly in case of gaps
        int endIndex = 0;

        // If loadedRegions is null then return the full list of points in draw order regardless of region
        if(loadedRegions == null)
        {
            for (int regionId : pathPoints.keySet())
            {
                loopIndexTracker.put(regionId, 0);

                int numInRegion = pathPoints.get(regionId).size();
                int lastRegionIndex = pathPoints.get(regionId).get(numInRegion - 1).getDrawIndex();
                endIndex = Math.max(lastRegionIndex, endIndex);
            }

        }
        else
        {
            searchIndex = getSize();

            // Collect relevant regionIds with points that are both loaded and stored
            for (Integer loadedRegion : loadedRegions)
            {
                // Skip if region isn't loaded
                if (!pathPoints.containsKey(loadedRegion))
                {continue;}

                // Add regionID to the loop tracker
                loopIndexTracker.put(loadedRegion, 0);

                // Get final draw index. This will be used to limit the following while-loop
                int numInRegion = pathPoints.get(loadedRegion).size();
                int lastRegionIndex = pathPoints.get(loadedRegion).get(numInRegion - 1).getDrawIndex();
                endIndex = Math.max(lastRegionIndex, endIndex);

                numPointsToLoad += numInRegion;

                // Determine the starting draw index (may not be 0 if that tile is in an unloaded region)
                searchIndex = Math.min(pathPoints.get(loadedRegion).get(0).getDrawIndex(), searchIndex);

            }
        }

        // Iterate through the relevant list of points, collecting the points in the order of their draw index
        int lastSize = -1;
        while(drawOrder.size() < numPointsToLoad)
        {
            // If the next draw index cant be found, increase the index search gap
            if (lastSize == drawOrder.size())
            {
                searchIndex += 1;

                // Break if failed to find point within the scope
                if (searchIndex > endIndex)
                {
                    log.debug("Missing draw indices {}, out of: {}", numPointsToLoad- drawOrder.size(), numPointsToLoad);
                    break;
                }
            }


            lastSize = drawOrder.size();

            // Look for point with draw index equal to searchIndex. Store and break the current iterator index for a given ArrayList in
            // loopIndexTracker if the point found has an index that is greater than searchIndex.
            for (int relevantRegionId : loopIndexTracker.keySet())
            {
                for (int i = loopIndexTracker.get(relevantRegionId); i < pathPoints.get(relevantRegionId).size(); i++)
                {
                    PathPoint point = pathPoints.get(relevantRegionId).get(i);
                    int pointIndex = point.getDrawIndex();

                    if (pointIndex == searchIndex)
                    {
                        drawOrder.add(point);
                        searchIndex += 1;
                    }
                    else if (pointIndex > drawOrder.size())
                    {
                        loopIndexTracker.put(relevantRegionId, i);
                        break;
                    }
                    loopIndexTracker.put(relevantRegionId, i+1);
                }
            }
        }
        return drawOrder;
    }

	void loadPoints(HashMap<Integer, ArrayList<PathPoint>> pointsToLoad)
	{
		pathPoints.clear();
		pathPoints.putAll(pointsToLoad);
	}
}


package com.Pathmaker;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonParser;
import com.google.gson.JsonSyntaxException;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;
import com.google.gson.reflect.TypeToken;
import java.awt.datatransfer.DataFlavor;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.util.HashMap;
import javax.swing.border.EmptyBorder;
import javax.swing.text.AbstractDocument;

@Slf4j
public class PathmakerPluginPanel extends PluginPanel
{
    private static final ImageIcon IMPORT_ICON;
    private static final ImageIcon EXPORT_ICON;

    private final PluginErrorPanel noPathPanel = new PluginErrorPanel();
    private final JPanel pathView = new JPanel();

    Client client;
    PathmakerPlugin plugin;

    FlatTextField activePath;
    final int MAX_PATH_NAME_LENGTH = 20; // Based on  (9)

    static
    {
        IMPORT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "import.png"));
        EXPORT_ICON = new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "export.png"));
    }

    // Making a pair inner class for import/export as path names aren't stored in pathmakerPaths
    public static class Pair<T, E>
    {
        @Getter
        private final T key;
        @Getter
        private final E value;

        Pair(T key, E value)
        {
            this.key = key;
            this.value = value;
        }
    }

    PathmakerPluginPanel(Client client, PathmakerPlugin plugin)
    {
        this.client = client;
	    this.plugin = plugin;

        // Define standard client panel layout
        setLayout(new BorderLayout());
        //setBorder(new EmptyBorder(10, 10, 10, 10));

        // Create title panel
        JPanel titlePanel = new JPanel();
        //titlePanel.setBorder(new EmptyBorder(1, 0, 10, 0));

        // Create label and add to title panel
        JLabel title = new JLabel();
        title.setText("Pathmaker");
        title.setPreferredSize(new Dimension(80,20)); //getGraphics().getFontMetrics().stringWidth(title.getText()) + 10
        title.setForeground(Color.WHITE);
        title.setToolTipText("by Fraph");
        titlePanel.add(title, BorderLayout.CENTER);

        // EXPORT / IMPORT
        JButton exportButton = new JButton();
        exportButton.setIcon(EXPORT_ICON);
        exportButton.setToolTipText("Export active path to clipboard");
        exportButton.setPreferredSize(new Dimension(18, 18));
        exportButton.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                if(!plugin.getStoredPaths().containsKey(activePath.getText())) {return;}

                //new Pair<String, PathmakerPath>(activePath.getText(), plugin.getStoredPaths().get(activePath.getText()));
				JsonObject exportPath = new JsonObject();
				exportPath.add(activePath.getText(), plugin.pathToJson(activePath.getText()));

                StringSelection json = new StringSelection(plugin.gson.toJson(exportPath));
                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                clipboard.setContents(json, null);
            }
        });

        JButton importButton = new JButton();
        importButton.setIcon(IMPORT_ICON);
        importButton.setToolTipText("Import path from clipboard");
        importButton.setPreferredSize(new Dimension(18, 18));
        importButton.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
				String json = "";
				try
				{
					json = (String) getToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);
				}
				catch (IllegalArgumentException | UnsupportedFlavorException | IllegalStateException |
					   NullPointerException | IOException ex)
				{
					log.debug("Clipboard is unavailable or has invalid content");
				}

				if (json.isEmpty())
				{
					return;
				}

				JsonObject element;
				try
				{
					element = new JsonParser().parse(json).getAsJsonObject();
				}
				catch (JsonParseException e)
				{
					log.debug("String was not a valid JSON: {}", e.getMessage());
					return;
				}

				// OLD
				// Pair<String, PathmakerPath> MUST be a JSON object
				// Returns if JSON is valid but not suitable for Pair<...>
//                if (!element.isJsonObject()) {return;}

//                Pair<String, PathmakerPath> loadedPath;
//                try{loadedPath = plugin.gson.fromJson(element, new TypeToken<Pair<String, PathmakerPath>>(){}.getType());}
//                catch (JsonSyntaxException e)
//                {
//                    log.debug("JSON is an object, but not in the correct Pair structure: {}", e.getMessage());
//                    return;
//                }

				String jsonPathName = element.keySet().iterator().next();

				JLabel centeredNameText = new JLabel("Path name", JLabel.CENTER);
				centeredNameText.setHorizontalTextPosition(SwingConstants.CENTER);
				//String pathName = JOptionPane.showInputDialog(importButton, centeredNameText, loadedPath.getKey());
				String inputPathName = JOptionPane.showInputDialog(importButton, centeredNameText, jsonPathName);

				// Return if the window was cancelled or closed
				if (inputPathName == null)
				{
					return;
				}

				// Show warning if imported path exists
				if (plugin.getStoredPaths().containsKey(inputPathName))
				{
					JLabel centeredWarningText = new JLabel("The path name " + inputPathName + " already exist.", JLabel.CENTER);
					JLabel centeredReplaceText = new JLabel("Replace it?", JLabel.CENTER);

					centeredWarningText.setHorizontalTextPosition(SwingConstants.CENTER);
					centeredReplaceText.setHorizontalTextPosition(SwingConstants.CENTER);

					JPanel centeredTextFrame = new JPanel(new GridLayout(0, 1));
					centeredTextFrame.setAlignmentX(Component.CENTER_ALIGNMENT);
					centeredTextFrame.add(centeredWarningText);
					centeredTextFrame.add(centeredReplaceText);

					int confirm = JOptionPane.showConfirmDialog(null,
						centeredTextFrame, "Warning", JOptionPane.YES_NO_OPTION);

					if (confirm == JOptionPane.YES_OPTION)// || confirm == JOptionPane.CLOSED_OPTION)
					{
						plugin.removePath(inputPathName);
						plugin.loadPathFromJson(element.get(jsonPathName).getAsJsonObject(), inputPathName);
						plugin.rebuildPanel(true);
						activePath.setText(inputPathName);
					}
				}
				else
				{
					plugin.loadPathFromJson(element.get(jsonPathName).getAsJsonObject(), inputPathName);
					plugin.rebuildPanel(true);
					activePath.setText(inputPathName);
				}
            }
        });

        JPanel rightActionTitlePanel = new JPanel();
        rightActionTitlePanel.add(importButton, BorderLayout.WEST);
        rightActionTitlePanel.add(exportButton, BorderLayout.EAST);
        titlePanel.add(rightActionTitlePanel, BorderLayout.EAST);

        // Create body panel and add titlePanel
        JPanel northPanel = new JPanel(new BorderLayout());
        northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));
        northPanel.add(titlePanel, BorderLayout.NORTH);

        // Add link to config button
        // But how? Watchdogs implementation
        // https://github.com/adamk33n3r/runelite-watchdog/blob/master/src/main/java/com/adamk33n3r/runelite/watchdog/NotificationOverlay.java
//        JButton configButton = new JButton();
//        configButton.setIcon(new ImageIcon(ImageUtil.loadImageResource(PathmakerPlugin.class, "cross.png")));
//        configButton.setToolTipText("Config");
//        configButton.addChangeListener(ce ->
//        {
//            plugin.getEventBus().post(
//                    new OverlayMenuClicked(
//                    new OverlayMenuEntry(
//                    RUNELITE_OVERLAY_CONFIG,
//                            null,
//                            null),
//                            notificationOverlay)); <---- What in this is relevant? (link above)
//        });
//        northPanel.add(configButton);

        // Add Active Path text field
        JLabel activePathLabel = new JLabel("Active Path: ");
        activePathLabel.setPreferredSize(new Dimension(75, 20));
        activePathLabel.setForeground(Color.WHITE);
        northPanel.add(activePathLabel, BorderLayout.WEST);

        activePath = new FlatTextField();
        ((AbstractDocument) activePath.getDocument()).setDocumentFilter(new MaxLengthFilter(MAX_PATH_NAME_LENGTH));
        activePath.setText("unnamed");
        activePath.setForeground(Color.WHITE);
        activePath.setBackground(Color.DARK_GRAY);

        northPanel.add(activePath);

        // Add panel to client panel
        add(northPanel, BorderLayout.NORTH);

        // Configure path view panel
        pathView.setLayout(new BoxLayout(pathView, BoxLayout.Y_AXIS));

        // Configure PluginErrorPanel
        noPathPanel.setVisible(false);
        //noPathPanel.setPreferredSize(new Dimension(50, 30));
        noPathPanel.setContent("No stored paths", "Shift right-click a tile to add a path point.");

        // Add body panel
        JPanel centerPanel = new JPanel(new BorderLayout());
        //centerPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH-5, 0));
        centerPanel.add(noPathPanel, BorderLayout.NORTH);
        centerPanel.add(pathView, BorderLayout.CENTER);

        add(centerPanel, BorderLayout.CENTER);

        rebuild();
    }

    void rebuild()
    {
        pathView.removeAll();

        // HashMap<String, PathmakerPath>
//        HashMap<String, PathmakerPath> paths = plugin.getStoredPaths();
        for (final String pathLabel : plugin.getStoredPaths().keySet())
        {
            // Create new path entry
            PathPanel pathEntry = new PathPanel(plugin, pathLabel);

            // Set as active path on label click
            pathEntry.getPathLabel().addActionListener(actionEvent ->
            {
                activePath.setText(pathEntry.getPathLabel().getText());
            });
            pathView.add(pathEntry, BorderLayout.CENTER);
        }

        boolean empty = pathView.getComponentCount() == 0;
        noPathPanel.setVisible(empty);

        repaint();
        revalidate();
    }
}

package com.Pathmaker;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;


@ConfigGroup(PathmakerConfig.CONFIG_GROUP)
public interface PathmakerConfig extends Config
{
    String CONFIG_GROUP = "pathmaker";
    String SHOW_MAP_ORB_MENU_OPTIONS = "showMapOrbMenuOptions";

    //------------------------------------------------------------//
    // Player Tile Section
    //------------------------------------------------------------//
    @ConfigSection(
            name = "Player tile",
            description = "Player tile configuration.",
            position = 3
    )
    String playerTile = "playerTile";

    @ConfigItem(
            keyName = "highlightCurrentTile",
            name = "Highlight true tile",
            description = "Highlights true tile player is on as seen by server.",
            position = 1,
            section = playerTile
    )
    default boolean highlightPlayerTile()
    {
        return false;
    }

    @Alpha
    @ConfigItem(
            keyName = "highlightCurrentColor",
            name = "Highlight color",
            description = "Configures the highlight color of current true tile.",
            position = 2,
            section = playerTile
    )
    default Color highlightPlayerColor()
    {
        return Color.CYAN;
    }

//    @Alpha
//    @ConfigItem(
//            keyName = "currentTileFillColor",
//            name = "Fill color",
//            description = "Configures the fill color of current true tile.",
//            position = 3,
//            section = playerTile
//    )
//    default Color playerTileFillColor()
//    {
//        return new Color(0, 0, 0, 50);
//    }

    @ConfigItem(
            keyName = "currentTileBorderWidth",
            name = "Border width",
            description = "Width of the true tile marker border.",
            position = 3,
            section = playerTile
    )
    @Range(max = 10)
    default int playerTileBorderWidth()
    {
        return 2;
    }

    //------------------------------------------------------------//
    // Hovered Tile Section
    //------------------------------------------------------------//
    @ConfigSection(
            name = "Hovered tile",
            description = "Cursor hovered tile configuration.",
            position = 2
    )
    String hoveredTile = "hoveredTile";


    enum hoveredTileDrawMode
    {
        NEVER,
        SHIFT_DOWN,
        ALWAYS,
    }
    @ConfigItem(
            keyName = "hoveredTileDrawModeSelect",
            name = "Hovered tile mode",
            description = "When the hovered tile elements should be drawn",
            position = 1,
            section = hoveredTile
    )
    default hoveredTileDrawMode hoveredTileDrawModeSelect()
    {
        return hoveredTileDrawMode.SHIFT_DOWN;
    }

    @ConfigItem(
            keyName = "highlightHoveredTile",
            name = "Highlight tile",
            description = "Highlights the tile that the player is hovering over.",
            position = 2,
            section = hoveredTile
    )
    default boolean highlightHoveredTile()
    {
        return true;
    }

    @Alpha
    @ConfigItem(
            keyName = "highlightHoveredColor",
            name = "Highlight color",
            description = "Configures the highlight color of hovered tile.",
            position = 3,
            section = hoveredTile
    )
    default Color highlightHoveredColor()
    {
        return new Color(255, 0, 0, 255);
    }

//    @Alpha
//    @ConfigItem(
//            keyName = "hoveredTileFillColor",
//            name = "Fill color",
//            description = "Configures the fill color of hovered tile.",
//            position = 4,
//            section = hoveredTile
//    )
//    default Color hoveredTileFillColor()
//    {
//        return new Color(255, 0, 0, 50);
//    }

    @ConfigItem(
            keyName = "hoveredTileBorderWidth",
            name = "Tile border width",
            description = "Width of the hovered tile marker border.",
            position = 4,
            section = hoveredTile
    )
    @Range(max = 10)
    default int hoveredTileBorderWidth()
    {
        return 2;
    }

    enum hoveredTileLabelMode
    {
        NONE,
        REGION,
        LOCATION,
        OFFSET,
        DISTANCE,
        ALL,
    }
    @ConfigItem(
            keyName = "hoveredTileLabelModeSelect",
            name = "Tile label mode",
            description = "Label to be placed on the hovered tile.",
            position = 5,
            section = hoveredTile
    )
    default hoveredTileLabelMode hoveredTileLabelModeSelect()
    {
        return hoveredTileLabelMode.NONE;
    }

    @Alpha
    @ConfigItem(
            keyName = "hoveredTileLabelColor",
            name = "Tile label color",
            description = "Configures the fill color of hovered tile label.",
            position = 6,
            section = hoveredTile
    )
    default Color hoveredTileLabelColor()
    {
        return new Color(255, 255, 0, 255);
    }

    @Alpha
    @ConfigItem(
            keyName = "drawHoverLine",
            name = "Draw line",
            description = "Draw line to hovered tile",
            position = 7,
            section = hoveredTile
    )
    default boolean drawHoverLine()
    {
        return true;
    }

    enum hoveredTileLineOrigin
    {
        TRUE_TILE,
        PATH_END,
    }
    @ConfigItem(
            keyName = "hoveredTileLineModeSelect",
            name = "Line origin",
            description = "Origin of hovered tile line.",
            position = 8,
            section = hoveredTile
    )
    default hoveredTileLineOrigin hoveredTileLineOriginSelect()
    {
        return hoveredTileLineOrigin.PATH_END;
    }

//    @Alpha
//    @ConfigItem(
//            keyName = "hoveredTileLineColor",
//            name = "Line color",
//            description = "Configures the line to the hovered tile color.",
//            position = 9,
//            section = hoveredTile
//    )
//    default Color hoveredTileLineColor()
//    {
//        return new Color(255, 0, 0, 255);
//    }

    @Alpha
    @ConfigItem(
            keyName = "hoverLineColorMatchPath",
            name = "Match active path",
            description = "Match the active path color",
            position = 9,
            section = hoveredTile
    )
    default boolean hoverLineColorMatchPath()
    {
        return false;
    }

    //------------------------------------------------------------//
    // Path Line Section
    //------------------------------------------------------------//
    @ConfigSection(
            name = "Path",
            description = "Path configuration.",
            position = 1
    )
    String path = "path";

    @ConfigItem(
            keyName = "drawPath",
            name = "Draw",
            description = "Render path lines",
            position = 1,
            section = path
    )
    default boolean drawPath()
    {
        return true;
    }

    @ConfigItem(
            keyName = "drawPathPoints",
            name = "Draw point tiles",
            description = "Highlight path point tiles.",
            position = 2,
            section = path
    )
    default boolean drawPathPoints()
    {
        return true;
    }

    @ConfigItem(
            keyName = "pathWidth",
            name = "Path width",
            description = "Width of the path line.",
            position = 3,
            section = path
    )
    @Range(max = 10)
    default int pathLineWidth()
    {
        return 2;
    }

    @Alpha
    @ConfigItem(
            keyName = "pathLineColor",
            name = "Default path color",
            description = "Configures the default path color.",
            position = 4,
            section = path
    )
    default Color pathColor()
    {
        return new Color(0, 255, 0, 255);
    }

    @Alpha
    @ConfigItem(
            keyName = "pathLinePointColor",
            name = "Path point tile color",
            description = "Configures the path line point tile color.",
            position = 6,
            section = path
    )
    default Color pathLinePointColor()
    {
        return new Color(0, 150, 0, 255);
    }

	@ConfigItem(
		keyName = "pointMatchPathColor",
		name = "Points match path color",
		description = "Set path points to match path color.",
		position = 7,
		section = path
	)
	default boolean pointMatchPathColor()
	{
		return true;
	}

//    @Alpha
//    @ConfigItem(
//            keyName = "pathLinePointFillColor",
//            name = "Path point tile fill color",
//            description = "Configures the path line point tile fill color.",
//            position = 8,
//            section = path
//    )
//    default Color pathLinePointFillColor()
//    {
//        return new Color(0, 255, 0, 50);
//    }

    @ConfigItem(
            keyName = "pathLinePointWidth",
            name = "Path point border width",
            description = "Width of the path line tile border.",
            position = 8,
            section = path
    )
    @Range(min = 0, max = 10)
    default int pathLinePointWidth()
    {
        return 0;
    }

    @ConfigItem(
            keyName = "pathZOffset",
            name = "Path draw height",
            description = "Configure the default Z offset for paths.",
            position = 9,
            section = path
    )
    @Range(min = 0, max = 20)
    default int pathZOffset()
    {
        return 0;
    }

    enum pathPointLabelMode
    {
        NONE,
        INDEX,
        LABEL,
        BOTH,
    }
    @ConfigItem(
            keyName = "pathPointLabelModeSelect",
            name = "Point label",
            description = "Add point labels.",
            position = 10,
            section = path
    )
    default pathPointLabelMode pathPointLabelModeSelect()
    {
        return pathPointLabelMode.BOTH;
    }

    @ConfigItem(
            keyName = "labelZOffset",
            name = "Label height offset",
            description = "Set label height offset from tile.",
            position = 11,
            section = path
    )
    @Range(max = 20)
    default int labelZOffset()
    {
        return 0;
    }

    @Alpha
    @ConfigItem(
            keyName = "pathPointLabelColor",
            name = "Path point label color",
            description = "Configures default the color of point labels.",
            position = 12,
            section = path
    )
    default Color pathPointLabelColor()
    {
        return Color.YELLOW;
    }

    @ConfigItem(
            keyName = "labelMatchPathColor",
            name = "label match path color",
            description = "Set labels to match path color.",
            position = 13,
            section = path
    )
    default boolean labelMatchPathColor()
    {
        return false;
    }

	@ConfigItem(
		keyName = "objectAndNpcOutline",
		name = "Object and NPC outline",
		description = "Draw an outline on objects and NPCs",
		position = 14,
		section = path
	)
	default boolean objectAndNpcOutline()
	{
		return true;
	}

	@ConfigItem(
		keyName = "objectAndNpcOutlineWidth",
		name = "Outline width",
		description = "Set the width of outlines to be drawn on objects and NPCs",
		position = 15,
		section = path
	)
	@Range(max = 10)
	default int objectAndNpcOutlineWidth()
	{
		return 2;
	}

    /*
    // Buttons appear, but missing func
    @ConfigItem(
            keyName = SHOW_MAP_ORB_MENU_OPTIONS,
            name = "Show map orb menu options",
            description = "Adds import/export/clear options to the world map orb.",
            position = 10,
            section = path
    )
    default boolean showMapOrbMenuOptions()
    {
        return true;
    }
     */

    //------------------------------------------------------------//
    // Path Container Section
    //------------------------------------------------------------//
//    @ConfigSection(
//            name = "Path Container",
//            description = "Contains all paths.",
//            position = 4
//    )
//    String pathContainer = "pathContainer";

//    @ConfigItem(
//            keyName = "activePath",
//            name = "Active path",
//            description = "The currently selected path to add points to.",
//            position = 2,
//            section = pathContainer
//    )
//    default String activePath()
//    {
//        return "Unnamed";
//    }
//
//    @ConfigItem(
//            keyName = "storedPaths",
//            name = "Stored paths",
//            description = "A list of all of the stored paths. !NB Updates by returning to the plugin list and changing focus away from the plugin panel.",
//            position = 3,
//            section = pathContainer
//    )
//    default String storedPaths()
//    {
//        return "";
//    }
//
//    @ConfigItem(
//            keyName = "storedPaths",
//            name = "",
//            description = ""
//    )
//    void setStoredPaths(String pathString);

    //------------------------------------------------------------//
    // Info Box Section
    //------------------------------------------------------------//
//    @ConfigSection(
//            name = "Info Box",
//            description = "Info Box configuration.",
//            position = 4
//    )
//    String infoBox = "infoBox";
//
//    @ConfigItem(
//            keyName = "infoBoxEnabled",
//            name = "Enabled",
//            description = "Render info box",
//            position = 1,
//            section = infoBox
//    )
//    default boolean infoBoxEnabled()
//    {
//        return false;
//    }
//
//    @ConfigItem(
//            keyName = "infoBoxSpeed",
//            name = "Show Speed",
//            description = "Print how many tiles the player moved since last tick.",
//            position = 2,
//            section = infoBox
//    )
//    default boolean infoBoxSpeed()
//    {
//        return true;
//    }
}

package com.Pathmaker;

import java.util.ArrayList;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;

/* Coordinate system:
 *   (1, 0) = right
 *   (0, 1) = up
 *
 * Tile corners:
 *   p0 = top-left
 *   p1 = top-right
 *   p2 = bottom-right
 *   p3 = bottom-left
 */
public class PathTileOutline
{
	/* ---------------- Tile side ---------------- */

	private enum Side
	{
		TOP,
		LEFT,
		BOTTOM,
		RIGHT
	}

	/* ---------------- Public API ---------------- */

	public static ArrayList<ArrayList<LocalPoint>> build(
		ArrayList<WorldView> tileWVs,
		ArrayList<int[]> tileXs,
		ArrayList<int[]> tileYs,
		boolean left,
		ArrayList<Boolean> drawToPrevious
	)
	{
		ArrayList<ArrayList<LocalPoint>> outFull = new ArrayList<>();
		int n = tileXs.size();
		if (n == 0)
		{
			return outFull;
		}

		boolean isLooped = tileXs.get(0)[0] == tileXs.get(n - 1)[0] && tileYs.get(0)[0] == tileYs.get(n - 1)[0];

		for (int i = 0; i < n; i++)
		{
			ArrayList<LocalPoint> out = new ArrayList<LocalPoint>();

			LocalPoint[] rect = rect(tileXs.get(i), tileYs.get(i), tileWVs.get(i));
			Point dirIn  = (i > 0)     ? direction(tileXs, tileYs, i - 1, i) : null;
			Point dirOut = (i < n - 1) ? direction(tileXs, tileYs, i, i + 1) : null;
			/* FIRST TILE:
			 * No entry direction.
			 * We only know where we are going next. */

			if (dirIn == null)
			{
				Side exit = sideOf(dirOut, left);
				addSide(out, rect, exit, left);
				outFull.add(out);
				continue;
			}

			/* LAST TILE:
			 * No exit direction.
			 * We only know where we came from. */

			if (dirOut == null)
			{
				Side inSide  = sideOf(dirIn, left);
				if (isLooped)
				{
					dirOut = direction(tileXs, tileYs, i,1);
					int cross = dirIn.getX() * dirOut.getY() - dirIn.getY() * dirOut.getX();
					boolean innerTurn = left ?  cross > 0 : cross < 0;
					Side outSide = sideOf(dirOut, left);

					if (inSide == outSide)
					{
						out.add(outFull.get(0).get(0));
					}
					else if(innerTurn)
					{
						if(outFull.get(0).size() > 1)
							outFull.get(0).remove(0);
						out.add(outFull.get(0).get(0));
					}
					else
					{
						outFull.get(0).remove(0);
						addSide(out, rect, inSide, left);
						addSide(out, rect, outSide, left);
					}
				}
				else
				{
					addSide(out, rect, inSide, left);
				}
				outFull.add(out);
				continue;
			}

			// MIDDLE TILE

			int cross = dirIn.getX() * dirOut.getY() - dirIn.getY() * dirOut.getX();
			boolean innerTurn = left ?  cross > 0 : cross < 0;

			Side inSide  = sideOf(dirIn, left);
			Side outSide = sideOf(dirOut, left);

			boolean dp = drawToPrevious.get(i);
			boolean nDp = drawToPrevious.get(i + 1); // i + 1 < drawToPrevious.size() ?  : true;
			if (!dp || !nDp)
			{
				boolean outerTurn = left ? cross < 0 : cross > 0;

				// Todo figure out the best !drawPreviousPoints to add
				if (left)
					if (outerTurn)
//						if (dp)
//							addSide(out, rect, inSide, left);
//						else
							addSideEndPoint(out, rect, inSide);
					else
//						if (dp)
//							addSide(out, rect, inSide, left);
//						else
							addSideStartPoint(out, rect, inSide);
				else
					if (outerTurn)
						addSideEndPoint(out, rect, outSide);
					else
						addSideStartPoint(out, rect, outSide);
			}
			else if (inSide == outSide)
			{
				// Normal straight / gentle turn
				addSide(out, rect, inSide, left);
			}
			else if(innerTurn)
			{
				if(left)
					addSideStartPoint(out,rect,inSide);
				else
					addSideEndPoint(out,rect,inSide);
			}
			else
			{
				// Diagonal / offset case
				// Replace diagonal with exactly two edges
				addSide(out, rect, inSide, left);
				addSide(out, rect, outSide, left);
			}
			outFull.add(out);
		}

		return outFull;
	}

	/* ---------------- Geometry helpers ---------------- */

	// Computes cardinal direction between tile centers.
	private static Point direction(
		ArrayList<int[]> xs,
		ArrayList<int[]> ys,
		int a,
		int b
	)
	{
		int ax = (xs.get(a)[0] + xs.get(a)[2]) / 2;
		int ay = (ys.get(a)[0] + ys.get(a)[2]) / 2;
		int bx = (xs.get(b)[0] + xs.get(b)[2]) / 2;
		int by = (ys.get(b)[0] + ys.get(b)[2]) / 2;

			return new Point(
				Integer.signum(bx - ax),
				Integer.signum(by - ay)
			);
	}

	private static LocalPoint[] rect(int[] xs, int[] ys, WorldView wv)
	{
		return new LocalPoint[]{
			new LocalPoint(xs[0], ys[0], wv), // p0 top-left
			new LocalPoint(xs[1], ys[1], wv), // p1 top-right
			new LocalPoint(xs[2], ys[2], wv), // p2 bottom-right
			new LocalPoint(xs[3], ys[3], wv)  // p3 bottom-left
		};
	}

	/* ---------------- Side logic ---------------- */

	// Determines which SIDE of a tile is on the LEFT/RIGHT of a given movement direction.
	private static Side sideOf(Point dir, boolean left)
	{
		if (left)
		{
			if (dir.getX() == 1 && dir.getY() == 0) return Side.TOP;
			if (dir.getX() == -1 && dir.getY() == 0) return Side.BOTTOM;
			if (dir.getX() == 0 && dir.getY() == 1) return Side.LEFT;
			if (dir.getX() == 0 && dir.getY() == -1) return Side.RIGHT;

			/* Diagonal case:
			 * Use the dominant component implicitly via boundary walking.
			 * We still return a side so entry/exit always exist. */
			if (dir.getX() > 0) return Side.TOP;
			if (dir.getX() < 0) return Side.BOTTOM;
			if (dir.getY() > 0) return Side.LEFT;
			return Side.RIGHT;
		}
		else
		{
			if (dir.getX() == 1 && dir.getY() == 0)  return Side.BOTTOM;
			if (dir.getX() == -1 && dir.getY() == 0) return Side.TOP;
			if (dir.getX() == 0 && dir.getY() == 1)  return Side.RIGHT;
			if (dir.getX() == 0 && dir.getY() == -1) return Side.LEFT;

			if (dir.getX() > 0)  return Side.BOTTOM;
			if (dir.getX() < 0)  return Side.TOP;
			if (dir.getY() > 0)  return Side.RIGHT;
			return Side.LEFT;
		}
	}

	/* ---------------- Emission ---------------- */

	private static void addSide(ArrayList<LocalPoint> out, LocalPoint[] r, Side s, boolean left)
	{
		if(left)
		{
			switch (s)
			{
				case TOP:
					add(out, r[0]);
					add(out, r[1]);
					break;
				case RIGHT:
					add(out, r[1]);
					add(out, r[2]);
					break;
				case BOTTOM:
					add(out, r[2]);
					add(out, r[3]);
					break;
				case LEFT:
					add(out, r[3]);
					add(out, r[0]);
					break;
			}
		}
		else
		{
			switch (s)
			{
				case TOP:
					add(out, r[1]);
					add(out, r[0]);
					break;
				case RIGHT:
					add(out, r[2]);
					add(out, r[1]);
					break;
				case BOTTOM:
					add(out, r[3]);
					add(out, r[2]);
					break;
				case LEFT:
					add(out, r[0]);
					add(out, r[3]);
					break;
			}
		}

	}

	private static void addSideStartPoint(ArrayList<LocalPoint> out, LocalPoint[] r, Side s)
	{
		switch (s)
		{
			case TOP:
				add(out, r[0]);
				break;
			case RIGHT:
				add(out, r[1]);
				break;
			case BOTTOM:
				add(out, r[2]);
				break;
			case LEFT:
				add(out, r[3]);
				break;
		}
	}

	private static void addSideEndPoint(ArrayList<LocalPoint> out, LocalPoint[] r, Side s)
	{
		switch (s)
		{
			case TOP:
				add(out, r[1]);
				break;
			case RIGHT:
				add(out, r[2]);
				break;
			case BOTTOM:
				add(out, r[3]);
				break;
			case LEFT:
				add(out, r[0]);
				break;
		}
	}

	private static boolean sidesAreOpposites(Side a, Side b)
	{
		if (a.equals(Side.TOP) &&  b.equals(Side.BOTTOM))
			return true;
		if (a.equals(Side.LEFT) &&  b.equals(Side.RIGHT))
			return true;
		if (a.equals(Side.RIGHT) &&  b.equals(Side.LEFT))
			return true;
		if (a.equals(Side.BOTTOM) &&  b.equals(Side.TOP))
			return true;

		return false;
	}

	private static void add(ArrayList<LocalPoint> out, LocalPoint p)
	{
		if (out.isEmpty() || !out.get(out.size() - 1).equals(p))
		{
			out.add(p);
		}
	}
}

package com.Pathmaker;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Color;
import javax.inject.Inject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.api.Client;

public class PathmakerPanelOverlay extends OverlayPanel
{
    private final PathmakerConfig config;
    private final Client client;

    // Move Speed - Add config toggle for move speed!
    private final String speedLabelPrefix = "Tiles pr/tick: ";
    WorldPoint lastPos = null;
    float moveSpeed = 0;

    @Inject
    private PathmakerPanelOverlay(PathmakerPlugin plugin, Client client, PathmakerConfig config)
    {
        super(plugin);

        setResizable(true);
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        this.client = client;
        this.config = config;
        this.panelComponent.setPreferredSize(new Dimension(20,0)); //graphics.getFontMetrics().stringWidth(speedLabelPrefix) +10
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
//        // InfoBox
//        if (config.infoBoxEnabled())
//        {
//            if (config.infoBoxSpeed())
//            {
//                this.panelComponent.getChildren().add(TitleComponent.builder().text(getSpeedLabelString(moveSpeed)).color(Color.WHITE).build());
//            }
//
//            // Render infobox
//            this.panelComponent.setPreferredSize(new Dimension(20,0));
//            return super.render(graphics);
//        }
        return null;
    }

    // Called by PathmakerPlugin.onGameTick()
    public void calculateCurrentSpeed()
    {
        WorldPoint playerPos = client.getLocalPlayer().getWorldLocation();

        if (lastPos != null)
        {
            float distance = lastPos.distanceTo(playerPos);
            //if (distance != 0) {
            moveSpeed = distance;
            //}
        }
        lastPos = playerPos;
    }

    public String getSpeedLabelString(float speed)
    {
        return speedLabelPrefix + String.format("%.2f", moveSpeed);
    }
}

package com.Pathmaker;

import com.google.common.base.Strings;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.inject.Provides;
import java.awt.Color;
import java.util.Set;
import javax.inject.Inject;
import javax.swing.JOptionPane;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.DecorativeObject;
import net.runelite.api.GameObject;
import net.runelite.api.GroundObject;
import net.runelite.api.ItemLayer;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.NPC;
import net.runelite.api.ObjectComposition;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.api.events.GroundObjectDespawned;
import net.runelite.api.events.DecorativeObjectDespawned;
import net.runelite.api.events.DecorativeObjectSpawned;
import net.runelite.api.events.WallObjectDespawned;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.api.events.ItemSpawned;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.WorldViewLoaded;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.awt.Polygon;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;

@Slf4j
@PluginDescriptor(
	name = "Pathmaker",
    description = "Draw lines between marked tiles.",
    tags = {"object,path,line,draw,tile,indicator,navigation"}
)
public class PathmakerPlugin extends Plugin
{
    private static final String ICON_FILE = "panel_icon.png";
    private static final String CONFIG_KEY = "paths";

    public final int  MAX_POINT_LABEL_LENGTH = 50;
    public final int  TILE_SIZE = 128; // Not in net.runelite.api.Constants?
    public final int  TILE_SIZE_HALF = TILE_SIZE / 2;

    private final HashMap<String, PathmakerPath> paths = new HashMap<>();
    private PathmakerPluginPanel pluginPanel;
    private NavigationButton navButton;

    boolean hotKeyPressed = false;

//    enum ObjectType
//    {
//        GROUND,
//        GAME,
//        ITEM,
//        WALL,
//        DECORATIVE,
//    }

	@Inject
	private Client client;

	@Inject
	private PathmakerConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private PathmakerOverlay overlay;

//    @Inject
//    private PathmakerPanelOverlay panelOverlay;

    @Inject
    private EventBus eventBus;

    @Inject
    private ClientToolbar clientToolbar;

    @Getter
    @Inject
    private ColorPickerManager colorPickerManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    public Gson gson;

    @Inject
    private ChatboxPanelManager chatboxPanelManager;

    @Provides
    PathmakerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(PathmakerConfig.class);
    }

	@Override
	protected void startUp() throws Exception
	{
		//log.info("Starting up Pathmaker plugin");

        overlayManager.add(overlay);
        //overlayManager.add(panelOverlay);

		reload(client.getTopLevelWorldView());
		pluginPanel = new PathmakerPluginPanel(client, this);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);
		navButton = NavigationButton.builder()
			.tooltip("Pathmaker")
			.icon(icon)
			.priority(5)
			.panel(pluginPanel)
			.build();
		clientToolbar.addNavigation(navButton);

		if (!paths.isEmpty())
			pluginPanel.activePath.setText(paths.keySet().iterator().next());
	}

	@Override
	protected void shutDown() throws Exception
	{
        overlayManager.remove(overlay);
        //overlayManager.remove(panelOverlay);
        clientToolbar.removeNavigation(navButton);

        paths.clear();
    }

    void saveAll()
    {
        configManager.unsetConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY);


		if(!paths.isEmpty())
		{
			JsonObject pathsJson = new JsonObject();
			for (String pathName : paths.keySet())
			{
				pathsJson.add(pathName, pathToJson(pathName));
			}

			//String json = gson.toJson(paths);
			configManager.setConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY, pathsJson);
		}
        configManager.sendConfig();
    }

	// TODO: make method that saves only a single path at a time
//	void save(String pathName)
//	{
//		String json = configManager.getConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY);
//
//		if (Strings.isNullOrEmpty(json))
//		{
//			return;
//		}
//
//		JsonObject loadedPaths = gson.fromJson(json, new TypeToken<JsonObject>(){}.getType());
//
//		try
//		{
//
//			if (loadedPaths.isJsonNull() || !loadedPaths.has(pathName))
//			{
//				loadedPaths.add(pathName, pathToJson(pathName));
//			}
//		} catch (JsonSyntaxException ignored){}
//
//		configManager.unsetConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY);
//		configManager.setConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY, loadedPaths);
//	}

	JsonObject pathToJson(String pathName)
	{
		if (!paths.containsKey(pathName))
		{
			return null;
		}

		//String pathJson;
		Set<Integer> regionIds = paths.get(pathName).getRegionIDs();
		JsonObject pathJson = new JsonObject();

		JsonObject regionsJson = new JsonObject();
		for (int regionId : regionIds)
		{
			JsonArray regionJson = new JsonArray();
			for (PathPoint point : paths.get(pathName).getPointsInRegion(regionId))
			{
//				JsonObject pointJson = new JsonObject();
				boolean entityIsObject = point instanceof PathPointObject;
//				pointJson.add(entityIsObject ? "object" : "tile",
//					gson.toJsonTree(point, entityIsObject ? PathPointObject.class : PathPoint.class));
				regionJson.add(gson.toJsonTree(point, entityIsObject ? PathPointObject.class : PathPoint.class));
			}
			regionsJson.add(String.valueOf(regionId), regionJson);
		}

		pathJson.add("regions", regionsJson);
		pathJson.add("color", gson.toJsonTree(paths.get(pathName).color, Color.class));
		pathJson.add("looped", gson.toJsonTree(paths.get(pathName).loopPath, boolean.class));
		pathJson.add("pathDrawOffset", gson.toJsonTree(paths.get(pathName).pathDrawOffset, int.class));

		//log.debug("Saved path: {}", pathName);
		return pathJson;
	}

	void loadPathFromJson(JsonObject pathJson, String pathName)
	{
		if (pathJson == null) return;

		JsonObject regionsJson = pathJson.get("regions").getAsJsonObject();

		for (String regionIdString : regionsJson.keySet())
		{
			//log.debug("Loading region: {}, for path: {}", regionIdString, pathName);
			for(JsonElement pointElement : regionsJson.get(regionIdString).getAsJsonArray())
			{
				PathPoint pathPoint = null;

				try
				{
					pathPoint = gson.fromJson(pointElement,
						pointElement.getAsJsonObject().has("id") ?
							PathPointObject.class :
							PathPoint.class);
				}
				catch (JsonSyntaxException e){log.debug("Deserialized PathPoint is null.");}

				if (pathPoint != null)
				{
					createOrAddToPath(pathName, pathPoint);
				}
				else
					log.debug("Failed to add deserialized point to path: {}", pathName);
			}
		}

		if (pathJson.has("color"))
			paths.get(pathName).color = gson.fromJson(pathJson.get("color"), Color.class);
		if (pathJson.has("looped"))
			paths.get(pathName).loopPath = gson.fromJson(pathJson.get("looped"), Boolean.class);
		if (pathJson.has("pathDrawOffset"))
			paths.get(pathName).pathDrawOffset = gson.fromJson(pathJson.get("pathDrawOffset"), int.class);
		//log.debug("Loaded path json: {}", pathName);
	}

    private void reload(WorldView wv)
    {
        paths.clear();
        String json = configManager.getConfiguration(PathmakerConfig.CONFIG_GROUP, CONFIG_KEY);

        if (Strings.isNullOrEmpty(json))
        {
            return;
        }

        try
        {
			JsonObject loadedPaths = gson.fromJson(json, new TypeToken<JsonObject>(){}.getType());

			if (loadedPaths.isJsonNull()) return;

			for (String pathName : loadedPaths.keySet())
			{
				log.debug("Loading path: {}", pathName);
				loadPathFromJson(loadedPaths.get(pathName).getAsJsonObject(), pathName);
			}
        }
        catch (IllegalStateException | JsonSyntaxException ignore)
        {
            JOptionPane.showConfirmDialog(pluginPanel,
                    "The paths you are trying to load are malformed",
                    "Warning", JOptionPane.OK_CANCEL_OPTION);
        }
    }

	@Subscribe
	public void onWorldViewLoaded(WorldViewLoaded event)
	{
		//log.debug("onWorldViewLoaded");
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
//		log.debug("GameObjectDespawned");
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
//		log.debug("GameObjectSpawned");
	}

	@Subscribe
	public void onWallObjectDespawned(WallObjectDespawned event)
	{
//		log.debug("WallObjectDespawned");
	}

	@Subscribe
	public void onWallObjectSpawned(WallObjectSpawned event)
	{
//		log.debug("WallObjectSpawned");
	}

	@Subscribe
	public void onGroundObjectDespawned(GroundObjectDespawned event)
	{
//		log.debug("GroundObjectDespawned");
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned event)
	{
//		log.debug("GroundObjectSpawned");
	}

	@Subscribe
	public void onDecorativeObjectSpawned(DecorativeObjectSpawned event)
	{
//		log.debug("DecorativeObjectSpawned");
	}

	@Subscribe
	public void onDecorativeObjectDespawned(DecorativeObjectDespawned event)
	{
//		log.debug("DecorativeObjectDespawned");
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned event)
	{
//		log.debug("ItemSpawned");
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned event)
	{
//		log.debug("ItemDespawned");
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
//		log.debug("NpcSpawned");
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
//		log.debug("NpcDespawned");
	}

    @Subscribe
    public void onGameTick(GameTick gameTick)
    {
		//log.debug("onGameTick");

//		if(config.infoBoxEnabled() && config.infoBoxSpeed())
//			panelOverlay.calculateCurrentSpeed();
    }

    // Get marked tiles within the rendered regions
    Collection<PathPoint> getTilesToHighlight()
    {
        Collection<PathPoint>  pathPoints = new ArrayList<>();

        // Get rendered regionIDs
        int[] regionsToLoad = client.getTopLevelWorldView().getMapRegions();
        for (PathmakerPath path : paths.values())
        {
            for (int regionID : regionsToLoad)
            {
                Collection<PathPoint> pathPointsInRegion = path.getPointsInRegion(regionID);
                if  (pathPointsInRegion != null)
                {
                    pathPoints.addAll(path.getPointsInRegion(regionID));
                }
            }
        }
        return pathPoints;
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (event.getGroup().equals(PathmakerConfig.CONFIG_GROUP))
        {
        }
    }

    @Subscribe
    public void onMenuEntryAdded(final MenuEntryAdded event)
    {
        // Only add menu option if shift is being held
        MenuAction menuAction = event.getMenuEntry().getType();
        hotKeyPressed = client.isKeyPressed(KeyCode.KC_SHIFT);

        if (!hotKeyPressed || (menuAction != MenuAction.WALK && menuAction != MenuAction.SET_HEADING &&
                menuAction != MenuAction.EXAMINE_NPC && menuAction != MenuAction.EXAMINE_OBJECT &&
			menuAction != MenuAction.EXAMINE_ITEM_GROUND))
        {
            return;
        }

        // Fetch game world
        int worldId = event.getMenuEntry().getWorldViewId();
        WorldView wv = client.getWorldView(worldId);


        if (wv == null)
        {
            log.debug("No world view found for getMenuEntry().getWorldViewId " + worldId);
            return;
        }

        // Fetch selected tile
        final Tile selectedSceneTile = wv.getSelectedSceneTile();
        if (selectedSceneTile == null)
        {
            return;
        }

        // Get the tile under cursor
        PathPoint pathPoint;

        String targetEntityString;
        String targetPathName = getActiveOrDefaultPathColorString(getActivePathName());
        final WorldPoint worldPoint;
        Point toCenterVec = new Point(TILE_SIZE_HALF, TILE_SIZE_HALF);

		int trueEntityId = -1;

        // Attempt to get an actor (npc) under the cursor
        if (event.getMenuEntry().getNpc() != null)
        {
            NPC npc = event.getMenuEntry().getNpc();
            worldPoint = WorldPoint.fromLocalInstance(npc.getWorldView().getScene(), npc.getLocalLocation(), npc.getWorldView().getPlane());
            targetEntityString = getActiveOrDefaultPathColorString(npc.getName());
            toCenterVec = getNpcToCenterVector(wv, npc.getId());
			trueEntityId = npc.getId();
        }
        else // If not an actor it's a tile OR an object
        {
            if (menuAction == MenuAction.EXAMINE_OBJECT)
            {
                // BIG shoutout to the ObjectIndicatorsPlugin for this implementation.
                // Spent most of the day just fighting chatGPT, and it was not at all fruitful.

                final int sceneX = event.getMenuEntry().getParam0();
                final int sceneY = event.getMenuEntry().getParam1();

                Tile tile = getTile(wv, sceneX, sceneY);

                int targetId = event.getMenuEntry().getIdentifier();


                TileObject tileObject = null;
                if (tile != null)
                {
                    tileObject = getTileObject(tile, targetId);
                }
                if (tileObject != null)
                {
					trueEntityId = client.getObjectDefinition(tileObject.getId()).getId();
                    worldPoint = WorldPoint.fromLocalInstance(client, tileObject.getLocalLocation());
                    toCenterVec = getObjectToCenterVector(wv, worldPoint, event.getIdentifier());

                } else
                {
                    worldPoint = WorldPoint.fromLocalInstance(client, selectedSceneTile.getLocalLocation());
                }
            }
            else // Note "toLocalInstance"
				// https://github.com/runelite/runelite/blob/ebe56b9a3b817476658981c46d7fad003daaf523/runelite-client/src/main/java/net/runelite/client/plugins/groundmarkers/GroundMarkerPlugin.java#L208
            {
                worldPoint = WorldPoint.fromLocalInstance(client, selectedSceneTile.getLocalLocation());
            }

            String target = event.getMenuEntry().getTarget(); // Returns an empty string if not an object
            targetEntityString = getActiveOrDefaultPathColorString(target.isEmpty() ? "Tile" : target);
        }

		// Correct for sailing tiles
		//int z = wv.isTopLevel() ? wv.getPlane() : 0;

        // See if the point already exists
        pathPoint = getPathPointAtRegionTile(
			getActivePathName(),
			worldPoint.getRegionID(),
			worldPoint.getRegionX(),
			worldPoint.getRegionY(),
			worldPoint.getPlane());

        // If tile is not previously marked by this path, add the "add" option.
        if (pathPoint == null)
        {
			if (!paths.isEmpty() &&
				paths.containsKey(getActivePathName()) &&
				paths.get(getActivePathName()).drawToPlayer == PathPanel.drawFromPlayerMode.START_ONLY.ordinal() &&
				paths.get(getActivePathName()).getSize() > 1)
				addLoopMenuOption(getActivePathName(), null);

            final PathPoint newPoint;

            // Skip if the entityID has already been registered
            if (menuAction == MenuAction.EXAMINE_NPC || menuAction == MenuAction.EXAMINE_OBJECT)
            {
				int entityID = event.getIdentifier();
                final boolean isNpc = menuAction == MenuAction.EXAMINE_NPC;

                newPoint = new PathPointObject(getActivePathName(), worldPoint.getRegionID(), worldPoint.getRegionX(),
                        worldPoint.getRegionY(), worldPoint.getPlane(), entityID, trueEntityId, isNpc);

                if(toCenterVec != null)
                    ((PathPointObject) newPoint).setToCenterVector(toCenterVec.getX(), toCenterVec.getY());
            }
            else
            {
                newPoint = new PathPoint(getActivePathName(), worldPoint.getRegionID(), worldPoint.getRegionX(),
                        worldPoint.getRegionY(), worldPoint.getPlane());
            }

            client.getMenu().createMenuEntry(-1)
                    .setOption("Add " + targetEntityString + " to")
                    .setTarget(targetPathName)
                    .setType(MenuAction.RUNELITE)
                    .onClick(e ->
					{
						createOrAddToPath(Text.removeTags(targetPathName), newPoint);
						String targetLabel = Text.removeTags(targetEntityString);
						if (!targetLabel.equals("Tile"))
							newPoint.setLabel(targetLabel);
						rebuildPanel(true);
					});
        }

        // On existing POINTS
        else // actorPoint != null ||
        {
			final String activePathName = getActivePathName();

			// Do this if it belongs to the active path
			if(pathPoint.getPathOwnerName().equals(activePathName))
			{
				// Only configure add loop/unloop/label if point belongs to the active group
				// Only allow loop/unloop with points connected to the last point
				if (paths.get(activePathName).getSize() > 2 &&
					(pathPoint.getDrawIndex() == paths.get(activePathName).getSize() - 2 &&
					paths.get(activePathName).loopPath) ||
					(paths.get(getActivePathName()).drawToPlayer == PathPanel.drawFromPlayerMode.NEVER.ordinal() &&
					pathPoint.getDrawIndex() == 0))
				{
					addLoopMenuOption(getActivePathName(), pathPoint);
//					client.getMenu().createMenuEntry(-1)
//						.setOption(paths.get(activePathName).loopPath ? "Unloop" : "Loop")
//						.setTarget(targetPathName)
//						.setType(MenuAction.RUNELITE)
//						.onClick(e ->
//						{
//							// Reverse and unloop if target point is second to last in draw order (this preserves the path structure)
//							if (pathPoint.getDrawIndex() == paths.get(activePathName).getSize() - 2)
//							{
//								paths.get(activePathName).setNewIndex(paths.get(activePathName).getPointAtDrawIndex(paths.get(activePathName).getSize() - 1), 0);
//								paths.get(activePathName).reverseDrawOrder();
//							}
//
//							paths.get(activePathName).loopPath = !paths.get(activePathName).loopPath;
//							rebuildPanel(true);
//						});
				}

				// Add label rename option
				client.getMenu().createMenuEntry(-1)
					.setOption("Set " + targetEntityString + " label")
					.setTarget(targetPathName)
					.setType(MenuAction.RUNELITE)
					.onClick(e ->
					{
						String currentLabel = pathPoint.getLabel() == null ? "" : pathPoint.getLabel();

						chatboxPanelManager.openTextInput(targetEntityString + " label")
							.value(currentLabel)
							.onDone(label ->
							{
								if (label.length() > MAX_POINT_LABEL_LENGTH)
									label = label.substring(0, MAX_POINT_LABEL_LENGTH);
								pathPoint.setLabel(label); // From
								rebuildPanel(true);
							})
							.build();
					});
			}
        }

		// Add remove option regardless of path
		for(String pathName : paths.keySet())
		{
			PathPoint point = getPathPointAtRegionTile(pathName, worldPoint.getRegionID(), worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane());
			if(point == null) continue;

			// Eliminate double entries when a point is both the position of an entity and entity tile
			if(!(point instanceof PathPointObject) || (!Text.removeTags(targetEntityString).equals("Tile")))
			{
				// Adding delete options, regardless of belonging path
				addRemoveMenuOption(pathName, point, "Remove " +
						ColorUtil.wrapWithColorTag(Text.removeTags(targetEntityString), paths.get(pathName).color) +
						" from",
					ColorUtil.wrapWithColorTag(Text.removeTags(pathName), paths.get(pathName).color));
			}
		}
    }

	void addLoopMenuOption(String pathName, PathPoint point)
	{
		PathmakerPath path = paths.get(pathName);
		client.getMenu().createMenuEntry(-1)
			.setOption(path.loopPath ? "Unloop" : "Loop")
			.setTarget(pathName)
			.setType(MenuAction.RUNELITE)
			.onClick(e ->
			{
				//(point == null && path.drawToPlayer == PathPanel.drawFromPlayerMode.START_ONLY.ordinal() && path.getSize() > 1)

				// Reverse and unloop if target point is second to last in draw order (this preserves the path structure)
				if (path.loopPath &&
					(point != null && point.getDrawIndex() == path.getSize() - 2) ||
					(path.drawToPlayer == PathPanel.drawFromPlayerMode.START_ONLY.ordinal() && point != null && point.getDrawIndex() == path.getSize() - 1))
				{
					path.getPointAtDrawIndex(path.getSize() -1).drawToPrevious = true;
					path.setNewIndex(path.getPointAtDrawIndex(path.getSize() - 1), 0);
					path.reverseDrawOrder();
				}

				path.loopPath = !path.loopPath;
				rebuildPanel(true);
			});
	}

    void addRemoveMenuOption(String pathName, PathPoint pathPoint, String optionString, String target)
    {
        // Add remove option regardless of belonging path
        client.getMenu().createMenuEntry(-1)
                .setOption(optionString)
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e -> removePoint(pathName, pathPoint));
    }


    public HashMap<String, PathmakerPath> getStoredPaths()
    {
        return paths;
    }

    public PathmakerPath getActivePath()
    {
        return paths.get(getActivePathName());
    }

    public boolean pathExists(String pathName)
    {
        return paths.containsKey(pathName);
    }

    // Returns pathPoints from all paths within the specified region
	ArrayList<PathPoint> getPathPointsInRegion(int regionId)
    {
		ArrayList<PathPoint> pathPoints = new ArrayList<>();

        for (String pathName : getPathsInRegionKeys(regionId))
        {
            PathmakerPath path = paths.get(pathName);
            pathPoints.addAll(path.getPointsInRegion(regionId));
        }

        return pathPoints;
    }

    // Iterate through the stored paths and find all that have tiles within the specified region
    Collection<String> getPathsInRegionKeys(int regionId)
    {
        Collection<String> pathsInRegionKeys = new ArrayList<>();
        for (String pathName : paths.keySet())
        {
            for (int pathRegionId : paths.get(pathName).getRegionIDs())
            {
                if(pathRegionId == regionId)
                {
                    pathsInRegionKeys.add(pathName);
                    break;
                }
            }
        }
        return pathsInRegionKeys;
    }

    Color getDefaultPathColor()
    {
        return config.pathColor();
    }

    // Return PathPoint if one was previously created on the specified tile
	PathPoint getPathPointAtRegionTile(String path, int regionId, int regionX,  int regionY, int plane)
    {
        if(paths.isEmpty() || !paths.containsKey(path) || !paths.get(path).hasPointsInRegion(regionId))
        {
            return null;
        }

        // Iterate through each region tile to determine if the selected tile has a PathPoint
        for (PathPoint point : paths.get(path).getPointsInRegion(regionId))
        {
            if(point.getX() == regionX && point.getY() == regionY)
            {
				return point;
            }
        }
		return null;
    }

    // Create a new path starting with the given point or add to existing path
    void createOrAddToPath(String pathName, PathPoint point)
    {
		//pluginPanel.activePath.getText();//config.activePath();

        if(pathName == null) return;

        //log.debug("Checking for existing path: {}", activePath);
        PathmakerPath path;
        if(paths.containsKey(pathName))
        {
            path = paths.get(pathName);
            path.addPathPoint(point);
        }
        else
        {
            // Initialize new path with the initial point
            path = new PathmakerPath(point);
            path.color = getDefaultPathColor();
            paths.put(pathName, path);
        }
    }

    void removePoint(String pathName, PathPoint point)
    {
        paths.get(pathName).removePathPoint(point);
        if (paths.get(pathName).getSize() == 0)
        {
            removePath(pathName);
        }
        rebuildPanel(true);
    }

    void removePath(String pathName)
    {
        paths.remove(pathName);
    }

    String getActivePathName()
    {
        return pluginPanel.activePath.getText();
    }

    // Default colour if active path contains no points
    String getActiveOrDefaultPathColorString(String string)
    {
        return (paths.containsKey(getActivePathName()) ?
                ColorUtil.wrapWithColorTag(Text.removeTags(string), paths.get(getActivePathName()).color) :
                ColorUtil.wrapWithColorTag(Text.removeTags(string), config.pathColor()));
    }

    // For moving points
    void updatePointLocation(String pathName, PathPoint point, int newRegionId, int x, int y, int z)
    {
        if(point.getRegionId() != newRegionId)
        {
            paths.get(pathName).updatePointRegion(point, newRegionId);
            //log.debug("Entity moved into a new region!");
        }

        point.updateRegionLocation(newRegionId, x, y, z);
    }

    void rebuildPanel(boolean savePaths)
    {
        pluginPanel.rebuild();
		if(savePaths)
			saveAll();
    }

    Tile getTile(WorldView wv, WorldPoint wp)
    {
        LocalPoint lp = LocalPoint.fromWorld(client, wp);
        if (lp == null) return null;

        return getTile(wv, lp.getSceneX(), lp.getSceneY());
    }

    Tile getTile(WorldView wv, int localSceneX, int localSceneY)
    {
        return wv.getScene().getTiles()[wv.getPlane()][localSceneX][localSceneY];
    }

    TileObject getTileObject(WorldView wv, PathPointObject point)
    {
        WorldPoint wp = WorldPoint.fromRegion(point.getRegionId(), point.getX(), point.getY(), wv.getPlane());
        return getTileObject(wv, wp, point.getEntityId());
    }

    TileObject getTileObject(WorldView wv, WorldPoint wp, int objectId)
    {
        return getTileObject(getTile(wv, wp), objectId);
    }

	TileObject getTileObject(WorldView wv, LocalPoint lp, int objectId)
	{
		return getTileObject(getTile(wv, lp.getSceneX(), lp.getSceneY()), objectId);
	}

    // THANK YOU ObjectIndicatorsPlugin for this!
    TileObject getTileObject(Tile tile, int id)
    {
        if (tile == null) return null;

        // Get all objects on tile
        final GameObject[] tileGameObjects = tile.getGameObjects();
        final DecorativeObject tileDecorativeObject = tile.getDecorativeObject();
        final WallObject tileWallObject = tile.getWallObject();
        final GroundObject groundObject = tile.getGroundObject();

        // Return the object with a matching ID
        if (isObjectIdEqual(tileWallObject, id)) return tileWallObject;
        if (isObjectIdEqual(tileDecorativeObject, id)) return tileDecorativeObject;
        if (isObjectIdEqual(groundObject, id)) return groundObject;
        for (GameObject object : tileGameObjects)
        {
            if (isObjectIdEqual(object, id))
            {
                return object;
            }
        }

        // Occurs also if an object within the loaded regions despawns (ie, tree chopped)
        //log.debug("No Object found with id " + id);
        return null;
    }

    // THANK YOU ObjectIndicatorsPlugin for this!
    boolean isObjectIdEqual(TileObject tileObject, int id)
    {
        if (tileObject == null) return false;
        if (tileObject.getId() == id) return true;

        // Menu action EXAMINE_OBJECT sends the transformed object id, not the base id, unlike
        // all of the GAME_OBJECT_OPTION actions, so check the id against the impostor ids
        final ObjectComposition comp = client.getObjectDefinition(tileObject.getId());

        if (comp.getImpostorIds() != null)
        {
            for (int impostorId : comp.getImpostorIds())
            {
                if (impostorId == id)
                {
                    return true;
                }
            }
        }
        return false;
    }

    Polygon getEntityPolygon(WorldView wv, PathPointObject point)
    {
        return getEntityPolygon(wv, LocalPoint.fromWorld(wv, point.getWorldPoint()), point.isNpc(), point.getEntityId());
    }

    Polygon getEntityPolygon(WorldView wv, LocalPoint lp, boolean isNpc, int entityId)
    {
        if(isNpc)
        {
            NPC npc = wv.npcs().byIndex(entityId);
            if(npc != null) return npc.getCanvasTilePoly();
        }
        else
        {
            TileObject object = getTileObject(getTile(wv, lp.getSceneX(), lp.getSceneY()), entityId);

            if (object instanceof GameObject) return ((GameObject) object).getCanvasTilePoly();
            else if (object instanceof DecorativeObject) return ((DecorativeObject) object).getCanvasTilePoly();
            else if (object instanceof GroundObject) return ((GroundObject) object).getCanvasTilePoly();
            else if (object instanceof WallObject) return ((WallObject) object).getCanvasTilePoly();
            else if (object instanceof ItemLayer) return ((ItemLayer) object).getCanvasTilePoly();
        }

        return null;
    }


    // NB LocalPoint is the center of a given tile


    // Cow: 2x2     Tree: 2x2
    // [ ][X]       [ ][X]
    // [ ][ ]       [ ][ ]

    Point getEntityToCenterVector(WorldView wv, WorldPoint wp, int entityId, boolean isNpc)
    {
        return isNpc ? getNpcToCenterVector(wv, entityId) : getObjectToCenterVector(wv, wp, entityId);
    }


    Point getNpcToCenterVector(WorldView wv, int npcId)
    {
		NPC npc = wv.npcs().byIndex(npcId);
		if (npc == null) return new Point(0, 0);

		int offsetX = npc.getWorldArea().getWidth() % 2 == 0 ? -TILE_SIZE_HALF : 0;
		int offsetY = npc.getWorldArea().getHeight() % 2 == 0 ? -TILE_SIZE_HALF : 0;

		return new Point(offsetX, offsetY);
    }

    Point getObjectToCenterVector(WorldView wv, WorldPoint wp, int entityId)
    {
        LocalPoint lp = LocalPoint.fromWorld(wv, wp);
        if(lp == null) return new Point(TILE_SIZE_HALF, TILE_SIZE_HALF);

        TileObject object = getTileObject(getTile(wv, wp),  entityId);
        LocalPoint objLp = object.getLocalLocation();

        return new Point(objLp.getX() - lp.getX(), objLp.getY() - lp.getY());
    }

    LocalPoint getEntityCenter(int inradius, LocalPoint lp)
    {
        lp = lp.dx(inradius); lp = lp.dy(inradius);
        return lp;
    }
}

package com.Pathmaker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PathmakerPlugin.class);
		RuneLite.main(args);
	}
}
