/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;

public class ImgUtil
{
	/**
	 * Combines the two images into one, from left to right using the first images specs.
	 * @param left image to center over background
	 * @param right image to overlap
	 * @return overlapped image
	 */
	public static BufferedImage combineImages(final BufferedImage left, final BufferedImage right)
	{
		BufferedImage combined = new BufferedImage(left.getWidth() + right.getWidth(), left.getHeight(), BufferedImage.TYPE_INT_ARGB);
		Graphics2D g2d = combined.createGraphics();
		g2d.drawImage(left, 0, 0, null);
		g2d.drawImage(right, left.getWidth(), 0, null);
		g2d.dispose();

		return combined;
	}

	/**
	 * Overlaps the foreground image centered over the background image.
	 * @param foreground image to center over background
	 * @param background image to overlap
	 * @return overlapped image
	 */
	public static BufferedImage overlapImages(final BufferedImage foreground, final BufferedImage background, boolean isEquipment)
	{
		final int centeredX = background.getWidth() / 2 - foreground.getWidth() / 2;
		final int centeredY = background.getHeight() / 2 - foreground.getHeight() / 2;

		BufferedImage combined = new BufferedImage(background.getWidth(), background.getHeight(), BufferedImage.TYPE_INT_ARGB);
		Graphics2D g2d = combined.createGraphics();
		g2d.drawImage(background, 0, 0, null);

		// For some reason equipment icons are offset and need to be adjusted
		if (isEquipment)
		{
			g2d.drawImage(foreground, centeredX + 2, centeredY, null);
		}
		else
		{
			g2d.drawImage(foreground, centeredX, centeredY, null);
		}

		g2d.dispose();

		return combined;
	}
}

package thestonedturtle.partypanel;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("partypanel")
public interface PartyPanelConfig extends Config
{
	@ConfigItem(
		keyName = "alwaysShowIcon",
		name = "Always show sidebar",
		description = "<html>Controls whether the sidebar icon is always shown (checked) or only shown while inside a party (unchecked)</html>"
	)
	default boolean alwaysShowIcon()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showPartyControls",
		name = "Show Party Controls",
		description = "<html>Controls whether we display the party control buttons like create and leave party</html>",
		position = 0
	)
	default boolean showPartyControls()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showPartyPassphrase",
		name = "Show Party Passphrase",
		description = "<html>Controls whether the party passphrase is displayed within the UI<br/>If disabled and party controls are shown you can still copy</html>",
		position = 1
	)
	default boolean showPartyPassphrase()
	{
		return true;
	}

	@ConfigItem(
		keyName = "autoExpandMembers",
		name = "Expand members by default",
		description = "<html>Controls whether party member details are automatically expanded (checked) or collapsed into banners (unchecked)</html>",
		position = 2
	)
	default boolean autoExpandMembers()
	{
		return false;
	}

	@ConfigItem(
		keyName = "displayVirtualLevels",
		name = "Display Virtual Levels",
		description = "<html>Controls whether we display a players virtual level as their base level</html>",
		position = 3
	)
	default boolean displayVirtualLevels()
	{
		return true;
	}

	@ConfigItem(
		keyName = "displayPlayerWorlds",
		name = "Display Player Worlds",
		description = "<html>Controls whether we display the world a player is currently on</html>",
		position = 4
	)
	default boolean displayPlayerWorlds()
	{
		return true;
	}



	@ConfigItem(
		keyName = "previousPartyId",
		name = "",
		description = "",
		hidden = true
	)
	default String previousPartyId()
	{
		return "";
	}

	@ConfigItem(
		keyName = "previousPartyId",
		name = "",
		description = "",
		hidden = true
	)
	void setPreviousPartyId(String id);
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data;

import lombok.AllArgsConstructor;
import lombok.Value;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.QuantityFormatter;

@Value
@AllArgsConstructor
public class GameItem
{
	int id;
	int qty;
	String name;
	boolean stackable;
	int price;

	public GameItem(final Item item, final ItemManager itemManager)
	{
		this(item.getId(), item.getQuantity(), itemManager);
	}

	public GameItem(final int id, final int qty, final ItemManager itemManager)
	{
		this.id = id;
		this.qty = qty;

		final ItemComposition c = itemManager.getItemComposition(id);

		this.name = c.getName();
		this.stackable = c.isStackable();
		this.price = itemManager.getItemPrice(c.getNote() != -1 ? c.getLinkedNoteId() : id);
	}

	public static GameItem[] convertItemsToGameItems(final int[] items, final ItemManager itemManager)
	{
		GameItem[] output = new GameItem[items.length / 2];
		for (int i = 0; i < items.length; i += 2)
		{
			if (items[i] == -1 || items[i + 1] <= 0)
			{
				output[i / 2] = null;
			}
			else
			{
				output[i / 2] = new GameItem(items[i], items[i + 1], itemManager);
			}
		}

		return output;
	}

	public static GameItem[] convertItemsToGameItems(final Item[] items, final ItemManager itemManager)
	{
		final GameItem[] output = new GameItem[items.length];
		for (int i = 0; i < items.length; i++)
		{
			final Item item = items[i];
			if (item == null || item.getId() == -1)
			{
				output[i] = null;
			}
			else
			{
				output[i] = new GameItem(item, itemManager);
			}
		}

		return output;
	}

	public String getDisplayName()
	{
		if (this.qty <= 1)
		{
			return this.name;
		}

		return this.name + " x " + QuantityFormatter.formatNumber(this.qty);
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data;

import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.Prayer;

@Data
@AllArgsConstructor
public class PrayerData
{
	private final Prayer prayer;
	private boolean available;
	private boolean enabled;
	private boolean unlocked;
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data;

import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import thestonedturtle.partypanel.data.events.PartyStatChange;

@Getter
@Setter
public class Stats
{
	private final Map<Skill, Integer> baseLevels = new HashMap<>();
	private final Map<Skill, Integer> boostedLevels = new HashMap<>();
	private int specialPercent;
	private int runEnergy;
	private int combatLevel;
	private int totalLevel;

	public Stats()
	{
		for (final Skill s : Skill.values())
		{
			baseLevels.put(s, 1);
			boostedLevels.put(s, 1);
		}

		baseLevels.put(Skill.HITPOINTS, 10);
		boostedLevels.put(Skill.HITPOINTS, 10);

		combatLevel = 3;
		specialPercent = 0;
		runEnergy = 0;
		combatLevel = 0;
		totalLevel = 0;
	}

	public Stats(final Client client)
	{
		final int[] bases = client.getSkillExperiences();
		final int[] boosts = client.getBoostedSkillLevels();
		for (final Skill s : Skill.values())
		{
			baseLevels.put(s, Experience.getLevelForXp(bases[s.ordinal()]));
			boostedLevels.put(s, boosts[s.ordinal()]);
		}

		recalculateCombatLevel();

		specialPercent = client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) / 10;
		totalLevel = client.getTotalLevel();
		runEnergy = client.getEnergy();
	}

	public int recalculateCombatLevel()
	{
		combatLevel = Experience.getCombatLevel(
			Math.min(baseLevels.get(Skill.ATTACK), 99),
			Math.min(baseLevels.get(Skill.STRENGTH), 99),
			Math.min(baseLevels.get(Skill.DEFENCE), 99),
			Math.min(baseLevels.get(Skill.HITPOINTS), 99),
			Math.min(baseLevels.get(Skill.MAGIC), 99),
			Math.min(baseLevels.get(Skill.RANGED), 99),
			Math.min(baseLevels.get(Skill.PRAYER), 99)
		);

		return combatLevel;
	}

	public PartyStatChange createPartyStatChangeForSkill(Skill s)
	{
		return new PartyStatChange(s.ordinal(), baseLevels.get(s), boostedLevels.get(s));
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data;

import java.util.List;
import lombok.Data;
import lombok.EqualsAndHashCode;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.party.PartyMember;
import thestonedturtle.partypanel.PartyPanelPlugin;

@Data
@EqualsAndHashCode
public class PartyPlayer
{
	private transient PartyMember member;
	private String username;
	private Stats stats;
	private GameItem[] inventory;
	private GameItem[] equipment;
	private Prayers prayers;
	private int stamina;
	private int poison;
	private int disease;
	private int world;
	private GameItem[] runesInPouch;

	public PartyPlayer(final PartyMember member)
	{
		this.member = member;
		this.username = "";
		this.stats = null;
		this.inventory = new GameItem[28];
		this.equipment = new GameItem[EquipmentInventorySlot.AMMO.getSlotIdx() + 1];
		this.prayers = null;
		this.stamina = 0;
		this.poison = 0;
		this.disease = 0;
		this.world = 0;
		this.runesInPouch = new GameItem[0];
	}

	public PartyPlayer(final PartyMember member, final Client client, final ItemManager itemManager, final ClientThread clientThread)
	{
		this(member);
		this.stamina = client.getVarbitValue(Varbits.STAMINA_EFFECT);
		this.poison = client.getVarpValue(VarPlayer.POISON);
		this.disease = client.getVarpValue(VarPlayer.DISEASE_VALUE);
		this.world = client.getWorld();

		clientThread.invoke(() -> updatePlayerInfo(client, itemManager));
	}

	public void updatePlayerInfo(final Client client, final ItemManager itemManager)
	{
		assert client.isClientThread();

		// Player is logged in
		if (client.getLocalPlayer() != null)
		{
			this.username = client.getLocalPlayer().getName();
			this.stats = new Stats(client);

			final ItemContainer invi = client.getItemContainer(InventoryID.INVENTORY);
			if (invi != null)
			{
				this.inventory = GameItem.convertItemsToGameItems(invi.getItems(), itemManager);
				final List<Item> runesInPouch = PartyPanelPlugin.getRunePouchContents(client);
				this.runesInPouch = GameItem.convertItemsToGameItems(runesInPouch.toArray(Item[]::new), itemManager);
			}

			final ItemContainer equip = client.getItemContainer(InventoryID.EQUIPMENT);
			if (equip != null)
			{
				this.equipment = GameItem.convertItemsToGameItems(equip.getItems(), itemManager);
			}

			if (this.prayers == null)
			{
				prayers = new Prayers(client);
			}
		}
	}

	public int getSkillBoostedLevel(final Skill skill)
	{
		if (stats == null)
		{
			return 0;
		}

		return stats.getBoostedLevels().get(skill);
	}

	public int getSkillRealLevel(final Skill skill)
	{
		return getSkillRealLevel(skill, false);
	}

	public int getSkillRealLevel(final Skill skill, final boolean allowVirtualLevels)
	{
		if (stats == null)
		{
			return 0;
		}

		assert skill != Skill.OVERALL;

		return Math.min(stats.getBaseLevels().get(skill), allowVirtualLevels ? 126 : 99);
	}

	public void setSkillsBoostedLevel(final Skill skill, final int level)
	{
		if (stats == null)
		{
			return;
		}

		stats.getBoostedLevels().put(skill, level);
	}

	public void setSkillsRealLevel(final Skill skill, final int level)
	{
		if (stats == null)
		{
			return;
		}

		stats.getBaseLevels().put(skill, level);
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data;

import java.util.HashMap;
import java.util.Map;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.Prayer;
import net.runelite.api.Varbits;
import thestonedturtle.partypanel.ui.prayer.PrayerSprites;

public class Prayers
{
	/**
	 * Checks if the prayer is available to be used (checks all requirements)
	 * <ul>
	 * <li> int	Jagex prayer index to check (See {@link PrayerSprites} scriptIndex property) </li>
	 * </ul>
	 * Returns
	 * <ul>
	 * <li> int	(boolean) whether the prayer can be activated </li>
	 * </ul>
	 */
	public static final int PRAYER_IS_AVAILABLE = 464;

	@Getter
	private final Map<Prayer, PrayerData> prayerData = new HashMap<>();
	private int[] prayerIds = new int[0];

	public Prayers()
	{
		for (final Prayer p : Prayer.values())
		{
			prayerData.put(p, new PrayerData(p, p.ordinal() == 0, false, isUnlockedByDefault(p)));
		}
	}

	public Prayers(final Client client)
	{
		// Initialize all prayers if created when logged in
		if (client.getLocalPlayer() != null)
		{
			for (final PrayerSprites p : PrayerSprites.values())
			{
				updatePrayerState(p, client);
			}
		}
		else
		{
			setCurrentPrayerIds(client);
		}
	}

	public boolean updatePrayerState(final PrayerSprites p, final Client client)
	{
		if (prayerIds.length == 0)
		{
			setCurrentPrayerIds(client);
		}

		assert prayerIds.length > 0;
		boolean changed, available, enabled, unlocked;

		PrayerData data = prayerData.get(p.getPrayer());
		if (p.isUnlocked(client))
		{
			client.runScript(PRAYER_IS_AVAILABLE, prayerIds[p.getScriptIndex()]);
			available = client.getIntStack()[0] > 0;
			enabled = client.isPrayerActive(p.getPrayer());
			unlocked = true;
		}
		else
		{
			available = false;
			enabled = false;
			unlocked = false;
		}


		if (data == null)
		{
			data = new PrayerData(p.getPrayer(), available, enabled, unlocked);
			changed = true;
		}
		else
		{
			changed = data.isAvailable() != available || data.isEnabled() != enabled || data.isUnlocked() != unlocked;
			data.setAvailable(available);
			data.setEnabled(enabled);
		}

		prayerData.put(data.getPrayer(), data);
		return changed;
	}

	private void setCurrentPrayerIds(Client client)
	{
		final EnumComposition prayers = getPrayerEnum(client);
		this.prayerIds = prayers.getIntVals();
	}

	private EnumComposition getPrayerEnum(Client client)
	{
		boolean deadeye = client.getVarbitValue(Varbits.PRAYER_DEADEYE_UNLOCKED) != 0;
		boolean vigour = client.getVarbitValue(Varbits.PRAYER_MYSTIC_VIGOUR_UNLOCKED) != 0;

		if (deadeye && vigour)
		{
			return client.getEnum(EnumID.PRAYERS_NORMAL_DEADEYE_MYSTIC_VIGOUR);
		}
		else if (deadeye)
		{
			return client.getEnum(EnumID.PRAYERS_NORMAL_DEADEYE);
		}
		else if (vigour)
		{
			return client.getEnum(EnumID.PRAYERS_NORMAL_MYSTIC_VIGOUR);
		}
		else
		{
			return client.getEnum(EnumID.PRAYERS_NORMAL);
		}
	}

	public static boolean isUnlockedByDefault(Prayer p)
	{
		return !p.name().equals("DEADEYE") && !p.name().equals("MYSTIC_VIGOUR");
	}
}

/*
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data.events;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import thestonedturtle.partypanel.data.PartyPlayer;

// Used for updating stuff that is just a single integer value and doesn't fit into the other classes
@Data
@Slf4j
public class PartyMiscChange implements PartyProcess
{
	PartyMisc t;
	Integer v;
	String s;

	public enum PartyMisc
	{
		S, // Special
		R, // RUN
		C, // Combat
		T, // Total
		ST, // Stamina duration
		P, // Poison
		D, // Disease
		W, // World
		U, // Username
	}

	public PartyMiscChange(PartyMisc t, Integer v)
	{
		this.t = t;
		this.v = v;
		this.s = null;
	}

	public PartyMiscChange(PartyMisc t, String s)
	{
		this.t = t;
		this.v = null;
		this.s = s;
	}

	@Override
	public void process(PartyPlayer p)
	{
		switch (t)
		{
			case S:
				p.getStats().setSpecialPercent(v);
				break;
			case C:
				p.getStats().setCombatLevel(v);
				break;
			case T:
				p.getStats().setTotalLevel(v);
				break;
			case R:
				p.getStats().setRunEnergy(v);
				break;
			case ST:
				p.setStamina(v);
				break;
			case P:
				p.setPoison(v);
				break;
			case D:
				p.setDisease(v);
				break;
			case W:
				p.setWorld(v);
				break;
			case U:
				p.setUsername(s);
				break;
			default:
				log.warn("Unhandled misc change type for event: {}", this);
		}
	}
}

/*
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data.events;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import net.runelite.api.Item;
import net.runelite.api.Prayer;
import net.runelite.client.game.ItemManager;
import net.runelite.client.party.messages.PartyMemberMessage;
import thestonedturtle.partypanel.data.GameItem;
import thestonedturtle.partypanel.data.PartyPlayer;

@Data
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class PartyBatchedChange extends PartyMemberMessage
{
	int[] i; // Inventory
	int[] e; // equipment
	Collection<PartyStatChange> s = new ArrayList<>(); // Stat Changes
	Collection<PartyMiscChange> m = new ArrayList<>(); // Misc Changes
	Integer ap; // Available Prayers, bit-packed & contains all available prayers on every change
	Integer ep; // Enabled Prayers, bit-packed & contains all enabled prayers on every change
	Integer up; // Unlocked Prayers, bit-packed & contains all unlocked prayers on every change. Only for deadeye/vigour currently
	int[] rp; // rp itemId and qty

	public boolean isValid()
	{
		return i != null
			|| e != null
			|| (s != null && !s.isEmpty())
			|| (m != null && !m.isEmpty())
			|| ap != null
			|| ep != null
			|| up != null
			|| rp != null;
	}

	// Unset unneeded variables to minimize payload
	public void removeDefaults()
	{
		s = (s == null || s.isEmpty()) ? null : s;
		m = (m == null || m.isEmpty()) ? null : m;
	}

	public void process(PartyPlayer player, ItemManager itemManager)
	{
		if (i != null)
		{
			final GameItem[] gameItems = GameItem.convertItemsToGameItems(i, itemManager);
			player.setInventory(gameItems);
		}

		if (e != null)
		{
			final GameItem[] gameItems = GameItem.convertItemsToGameItems(e, itemManager);
			player.setEquipment(gameItems);
		}

		if (s != null)
		{
			s.forEach(change -> change.process(player));
		}

		if (m != null)
		{
			m.forEach(change -> change.process(player));
		}

		if (ap != null || ep != null || up != null)
		{
			processPrayers(player);
		}

		if (rp != null)
		{
			Item[] runePouchContents = Arrays.stream(rp)
				.mapToObj(PartyBatchedChange::unpackRune)
				.toArray(Item[]::new);
			player.setRunesInPouch(GameItem.convertItemsToGameItems(runePouchContents, itemManager));
		}
	}

	private void processPrayers(PartyPlayer player)
	{
		// Default all prayers to not available and not enabled
		player.getPrayers().getPrayerData().forEach((idx, p) ->
		{
			p.setAvailable(false);
			p.setEnabled(false);
			p.setUnlocked(false);
		});

		for (final Prayer p : unpackActivePrayers())
		{
			player.getPrayers().getPrayerData().get(p).setAvailable(true);
		}

		for (final Prayer p : unpackEnabledPrayers())
		{
			player.getPrayers().getPrayerData().get(p).setEnabled(true);
		}

		for (final Prayer p : unpack(up))
		{
			player.getPrayers().getPrayerData().get(p).setUnlocked(true);
		}
	}

	public boolean hasBreakingBannerChange()
	{
		return m != null
			&& m.stream()
			.anyMatch(e ->
			{
				switch (e.t)
				{
					case C:
					case W:
					case U:
						return true;
				}

				return false;
			});
	}

	public boolean hasStatChange()
	{
		return (s != null && !s.isEmpty())
			|| (m != null && m.stream().anyMatch(e ->
			e.getT() == PartyMiscChange.PartyMisc.S
				|| e.getT() == PartyMiscChange.PartyMisc.R
				|| e.getT() == PartyMiscChange.PartyMisc.C
				|| e.getT() == PartyMiscChange.PartyMisc.T)
		);
	}

	public static <E extends Enum<E>> int pack(Collection<E> items)
	{
		int i = 0;
		for (E e : items)
		{
			assert e.ordinal() < 32;
			i |= (1 << e.ordinal());
		}

		return i;
	}

	private Collection<Prayer> unpack(int pack)
	{
		final List<Prayer> out = new ArrayList<>();
		for (Prayer p : Prayer.values())
		{
			// We bitpack into an int of 32 bits, as of now that's fine but the ruinous powers could break this
			// since the prayer enum has these defined still break out early.
			if (p.ordinal() >= 32)
			{
				break;
			}

			if ((pack & (1 << p.ordinal())) != 0)
			{
				out.add(p);
			}
		}

		return out;
	}

	public static int packRune(final Item item)
	{
		return packRune(item.getId(), item.getQuantity());
	}

	public static int packRune(final int itemId, final int qty)
	{
		// qty can only be between 1 and 16,000, which is 14 bits of the 31 available bits (excluding sign)
		// pack the qty into the left-most 14 bits by offsetting it by 18
		int packed = qty << 18;
		return packed | itemId;
	}

	public static Item unpackRune(final int packed)
	{
		final int qty = packed >>> 18;
		// To retrieve the itemId we need to set the left most 14 bits to 0
		final int itemId = packed & 0x3FFFF;

		return new Item(itemId, qty);
	}

	public Collection<Prayer> unpackActivePrayers()
	{
		return unpack(ap);
	}

	public Collection<Prayer> unpackEnabledPrayers()
	{
		return unpack(ep);
	}
}

/*
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data.events;

import thestonedturtle.partypanel.data.PartyPlayer;

public interface PartyProcess
{
	void process(PartyPlayer player);
}

/*
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.data.events;

import lombok.Value;
import net.runelite.api.Skill;
import thestonedturtle.partypanel.data.PartyPlayer;

@Value
public class PartyStatChange implements PartyProcess
{
	int s; // Skill ordinal
	int l; // Level
	int b; // Boosted Level

	@Override
	public void process(PartyPlayer p)
	{
		final Skill skill = Skill.values()[s];
		p.getStats().getBaseLevels().put(skill, l);
		p.getStats().getBoostedLevels().put(skill, b);
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel;

import com.google.common.base.Strings;
import com.google.inject.Inject;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import thestonedturtle.partypanel.data.PartyPlayer;
import thestonedturtle.partypanel.ui.ControlsPanel;
import thestonedturtle.partypanel.ui.PlayerPanel;

class PartyPanel extends PluginPanel
{
	private final PartyPanelPlugin plugin;
	@Getter
	private final HashMap<Long, PlayerPanel> playerPanelMap = new HashMap<>();
	private final JPanel basePanel = new JPanel();
	private final JPanel passphrasePanel = new JPanel();
	private final JLabel passphraseLabel = new JLabel();
	@Getter
	private final ControlsPanel controlsPanel;

	@Inject
	PartyPanel(final PartyPanelPlugin plugin)
	{
		super(false);
		this.plugin = plugin;
		this.setLayout(new BorderLayout());

		basePanel.setBorder(new EmptyBorder(BORDER_OFFSET, BORDER_OFFSET, BORDER_OFFSET, BORDER_OFFSET));
		basePanel.setLayout(new DynamicGridLayout(0, 1, 0, 5));

		final JPanel topPanel = new JPanel();
		topPanel.setBorder(new EmptyBorder(BORDER_OFFSET, 2, BORDER_OFFSET, 2));
		topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));

		passphrasePanel.setBorder(new EmptyBorder(4, 0, 0, 0));
		passphrasePanel.setLayout(new DynamicGridLayout(0, 1, 0, 5));

		final JLabel passphraseTopLabel = new JLabel("Party Passphrase");
		passphraseTopLabel.setForeground(Color.WHITE);
		passphraseTopLabel.setHorizontalTextPosition(JLabel.CENTER);
		passphraseTopLabel.setHorizontalAlignment(JLabel.CENTER);

		final JMenuItem copyOpt = new JMenuItem("Copy Passphrase");
		copyOpt.addActionListener(e ->
		{
			final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(new StringSelection(passphraseLabel.getText()), null);
		});

		final JPopupMenu copyPopup = new JPopupMenu();
		copyPopup.setBorder(new EmptyBorder(5, 5, 5, 5));
		copyPopup.add(copyOpt);

		passphraseLabel.setText(plugin.getPartyPassphrase());
		passphraseLabel.setHorizontalTextPosition(JLabel.CENTER);
		passphraseLabel.setHorizontalAlignment(JLabel.CENTER);
		passphraseLabel.setComponentPopupMenu(copyPopup);

		passphrasePanel.add(passphraseTopLabel);
		passphrasePanel.add(passphraseLabel);
		syncPartyPassphraseVisibility();

		controlsPanel = new ControlsPanel(plugin);
		topPanel.add(controlsPanel);
		topPanel.add(passphrasePanel);

		this.add(topPanel, BorderLayout.NORTH);

		// Wrap content to anchor to top and prevent expansion
		final JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.add(basePanel, BorderLayout.NORTH);
		final JScrollPane scrollPane = new JScrollPane(northPanel);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

		this.add(scrollPane, BorderLayout.CENTER);
	}

	void clearSidebar()
	{
		basePanel.removeAll();
		playerPanelMap.clear();

		basePanel.revalidate();
		basePanel.repaint();
	}

	/**
	 * Shows all members of the party, excluding the local player. See {@link thestonedturtle.partypanel.ui.PlayerBanner )
	 */
	void renderSidebar()
	{
		// Sort by their RSN first; If it doesn't exist sort by their Discord name instead
		final List<PartyPlayer> players = plugin.getPartyMembers().values()
			.stream()
			.sorted(Comparator.comparing(o -> Strings.isNullOrEmpty(o.getUsername()) ? o.getMember().getDisplayName() : o.getUsername()))
			.collect(Collectors.toList());

		for (final PartyPlayer player : players)
		{
			drawPlayerPanel(player);
		}

		if (getComponentCount() == 0)
		{
			basePanel.add(new JLabel("There are no members in your party"));
		}

		basePanel.revalidate();
		basePanel.repaint();
	}

	void drawPlayerPanel(PartyPlayer player)
	{
		drawPlayerPanel(player, false);
	}

	void drawPlayerPanel(PartyPlayer player, boolean hasBreakingBannerChange)
	{
		PlayerPanel panel = playerPanelMap.get(player.getMember().getMemberId());
		if (panel != null)
		{
			panel.updatePlayerData(player, true);
			return;
		}

		panel = new PlayerPanel(player, plugin.getConfig(), plugin.spriteManager, plugin.itemManager);
		playerPanelMap.put(player.getMember().getMemberId(), panel);
		panel.updatePlayerData(player, hasBreakingBannerChange);
		basePanel.add(panel);
		basePanel.revalidate();
		basePanel.repaint();
	}

	void removePartyPlayer(final PartyPlayer player)
	{
		if (player != null)
		{
			final PlayerPanel p = playerPanelMap.remove(player.getMember().getMemberId());
			if (p != null)
			{
				basePanel.remove(p);
				renderSidebar();
			}
		}
	}

	void updatePartyMembersExpand(boolean expand)
	{
		for (PlayerPanel panel : playerPanelMap.values())
		{
			panel.setShowInfo(expand);
			panel.getBanner().setExpandIcon(expand);
			panel.updatePanel();
		}
	}

	public void updatePartyControls()
	{
		controlsPanel.setVisible(plugin.getConfig().showPartyControls());
	}

	public void syncPartyPassphraseVisibility()
	{
		passphraseLabel.setText(plugin.getPartyPassphrase());
		passphrasePanel.setVisible(plugin.getConfig().showPartyPassphrase() && plugin.isInParty());
	}

	public void updateParty()
	{
		controlsPanel.updateControls();
		syncPartyPassphraseVisibility();
	}

	public void updateDisplayVirtualLevels()
	{
		playerPanelMap.values().forEach(PlayerPanel::updateDisplayVirtualLevels);
	}

	public void updateDisplayPlayerWorlds()
	{
		playerPanelMap.values().forEach(PlayerPanel::updateDisplayPlayerWorlds);
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui.skills;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import java.awt.Color;
import java.awt.Dimension;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import lombok.Getter;
import net.runelite.api.Skill;
import static net.runelite.api.Skill.AGILITY;
import static net.runelite.api.Skill.ATTACK;
import static net.runelite.api.Skill.CONSTRUCTION;
import static net.runelite.api.Skill.COOKING;
import static net.runelite.api.Skill.CRAFTING;
import static net.runelite.api.Skill.DEFENCE;
import static net.runelite.api.Skill.FARMING;
import static net.runelite.api.Skill.FIREMAKING;
import static net.runelite.api.Skill.FISHING;
import static net.runelite.api.Skill.FLETCHING;
import static net.runelite.api.Skill.HERBLORE;
import static net.runelite.api.Skill.HITPOINTS;
import static net.runelite.api.Skill.HUNTER;
import static net.runelite.api.Skill.MAGIC;
import static net.runelite.api.Skill.MINING;
import static net.runelite.api.Skill.PRAYER;
import static net.runelite.api.Skill.RANGED;
import static net.runelite.api.Skill.RUNECRAFT;
import static net.runelite.api.Skill.SLAYER;
import static net.runelite.api.Skill.SMITHING;
import static net.runelite.api.Skill.STRENGTH;
import static net.runelite.api.Skill.THIEVING;
import static net.runelite.api.Skill.WOODCUTTING;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import thestonedturtle.partypanel.data.PartyPlayer;

@Getter
public class PlayerSkillsPanel extends JPanel
{
	/**
	 * Skills ordered in the way they should be displayed in the panel.
	 */
	private static final List<Skill> SKILLS = ImmutableList.of(
		ATTACK, HITPOINTS, MINING,
		STRENGTH, AGILITY, SMITHING,
		DEFENCE, HERBLORE, FISHING,
		RANGED, THIEVING, COOKING,
		PRAYER, CRAFTING, FIREMAKING,
		MAGIC, FLETCHING, WOODCUTTING,
		RUNECRAFT, SLAYER, FARMING,
		CONSTRUCTION, HUNTER
	);

	private static final ImmutableMap<Skill, Integer> SPRITE_MAP;

	static
	{
		final ImmutableMap.Builder<Skill, Integer> map = ImmutableMap.builder();
		map.put(Skill.ATTACK, SpriteID.SKILL_ATTACK);
		map.put(Skill.STRENGTH, SpriteID.SKILL_STRENGTH);
		map.put(Skill.DEFENCE, SpriteID.SKILL_DEFENCE);
		map.put(Skill.RANGED, SpriteID.SKILL_RANGED);
		map.put(Skill.PRAYER, SpriteID.SKILL_PRAYER);
		map.put(Skill.MAGIC, SpriteID.SKILL_MAGIC);
		map.put(Skill.HITPOINTS, SpriteID.SKILL_HITPOINTS);
		map.put(Skill.AGILITY, SpriteID.SKILL_AGILITY);
		map.put(Skill.HERBLORE, SpriteID.SKILL_HERBLORE);
		map.put(Skill.THIEVING, SpriteID.SKILL_THIEVING);
		map.put(Skill.CRAFTING, SpriteID.SKILL_CRAFTING);
		map.put(Skill.FLETCHING, SpriteID.SKILL_FLETCHING);
		map.put(Skill.MINING, SpriteID.SKILL_MINING);
		map.put(Skill.SMITHING, SpriteID.SKILL_SMITHING);
		map.put(Skill.FISHING, SpriteID.SKILL_FISHING);
		map.put(Skill.COOKING, SpriteID.SKILL_COOKING);
		map.put(Skill.FIREMAKING, SpriteID.SKILL_FIREMAKING);
		map.put(Skill.WOODCUTTING, SpriteID.SKILL_WOODCUTTING);
		map.put(Skill.RUNECRAFT, SpriteID.SKILL_RUNECRAFT);
		map.put(Skill.SLAYER, SpriteID.SKILL_SLAYER);
		map.put(Skill.FARMING, SpriteID.SKILL_FARMING);
		map.put(Skill.CONSTRUCTION, SpriteID.SKILL_CONSTRUCTION);
		map.put(Skill.HUNTER, SpriteID.SKILL_HUNTER);
		SPRITE_MAP = map.build();
	}

	private static final Dimension PANEL_SIZE = new Dimension(PluginPanel.PANEL_WIDTH - 14, 296);

	private final Map<Skill, SkillPanelSlot> panelMap = new HashMap<>();
	private final TotalPanelSlot totalLevelPanel;

	public PlayerSkillsPanel(final PartyPlayer player, final boolean displayVirtualLevels, final SpriteManager spriteManager)
	{
		super();

		this.setMinimumSize(PANEL_SIZE);
		this.setPreferredSize(PANEL_SIZE);
		this.setBackground(new Color(62, 53, 41));
		this.setLayout(new DynamicGridLayout(8, 3, 2, 0));

		int totalLevel = 0;
		for (final Skill s : SKILLS)
		{
			int realLevel = player.getSkillRealLevel(s, displayVirtualLevels);
			final SkillPanelSlot slot = new SkillPanelSlot(player.getSkillBoostedLevel(s), realLevel);
			panelMap.put(s, slot);
			this.add(slot);
			spriteManager.getSpriteAsync(SPRITE_MAP.get(s), 0, img -> SwingUtilities.invokeLater(() -> slot.initImages(img, spriteManager)));

			updateSkill(player, s, displayVirtualLevels); // Call to ensure tooltip is correct

			totalLevel += realLevel;
		}

		// Add 9 since hp starts at 10
		totalLevel = player.getStats() == null ? (9 + Skill.values().length) : totalLevel;
		totalLevelPanel = new TotalPanelSlot(totalLevel, spriteManager);
		this.add(totalLevelPanel);
	}

	public void updateSkill(final PartyPlayer player, final Skill s, final boolean displayVirtualLevels)
	{
		int boosted = s == Skill.HITPOINTS ? 10 : 1;
		int baseLevel = s == Skill.HITPOINTS ? 10 : 1;
		if (player.getStats() != null)
		{
			boosted = player.getSkillBoostedLevel(s);
			baseLevel = player.getSkillRealLevel(s, displayVirtualLevels);
		}

		final SkillPanelSlot panel = panelMap.get(s);
		panel.updateBoostedLevel(boosted);
		panel.updateBaseLevel(baseLevel);
		panel.setToolTipText(s.getName());
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui.skills;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.image.BufferedImage;
import java.util.Objects;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.api.Constants;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import thestonedturtle.partypanel.ImgUtil;

public class SkillPanelSlot extends JPanel
{
	private static final Dimension PANEL_HALF_SIZE = new Dimension(Constants.ITEM_SPRITE_WIDTH, Constants.ITEM_SPRITE_HEIGHT + 4);
	static final Dimension PANEL_FULL_SIZE = new Dimension(PANEL_HALF_SIZE.width * 2, PANEL_HALF_SIZE.height);

	private final JLabel boostedLabel = new JLabel();
	private final JLabel baseLabel = new JLabel();
	private BufferedImage background;
	private BufferedImage skillHalf;
	private BufferedImage statHalf;

	@Override
	protected void paintComponent(Graphics g)
	{
		super.paintComponent(g);
		if (background == null)
		{
			return;
		}

		g.drawImage(background, 0, 0, null);
	}

	private void updateBackgroundImage()
	{
		if (skillHalf != null && statHalf != null)
		{
			background = ImgUtil.combineImages(skillHalf, statHalf);
			this.repaint();
		}
	}

	SkillPanelSlot(final int boostedLevel, final int baseLevel)
	{
		super();
		setOpaque(false);

		setPreferredSize(PANEL_FULL_SIZE);
		setLayout(new BorderLayout());

		final JPanel textPanel = new JPanel();
		textPanel.setLayout(new GridBagLayout());
		textPanel.setPreferredSize(PANEL_HALF_SIZE);
		textPanel.setOpaque(false);

		final GridBagConstraints c = new GridBagConstraints();
		c.gridx = 0;
		c.gridy = 0;
		c.weighty = .5;
		c.weightx = 1;
		c.fill = GridBagConstraints.BOTH;

		boostedLabel.setText(String.valueOf(boostedLevel));
		boostedLabel.setVerticalAlignment(JLabel.CENTER);
		boostedLabel.setHorizontalAlignment(JLabel.LEFT);
		boostedLabel.setFont(FontManager.getRunescapeSmallFont());
		boostedLabel.setForeground(Color.YELLOW);
		boostedLabel.setBorder(new EmptyBorder(6, 3, 0, 0));
		c.anchor = GridBagConstraints.NORTHWEST;
		textPanel.add(boostedLabel, c);

		baseLabel.setVerticalAlignment(JLabel.CENTER);
		baseLabel.setHorizontalAlignment(JLabel.RIGHT);
		baseLabel.setFont(FontManager.getRunescapeSmallFont());
		baseLabel.setForeground(Color.YELLOW);
		updateBaseLevel(baseLevel); // Call so the correct right border is used

		c.anchor = GridBagConstraints.SOUTHEAST;
		c.gridy++;
		textPanel.add(baseLabel, c);

		add(textPanel, BorderLayout.EAST);
	}

	void initImages(final BufferedImage skillIcon, final SpriteManager spriteManager)
	{
		spriteManager.getSpriteAsync(SpriteID.STATS_TILE_HALF_LEFT, 0, img ->
		{
			skillHalf = ImgUtil.overlapImages(skillIcon, SkillPanelSlot.resize(img), false);
			updateBackgroundImage();
		});
		spriteManager.getSpriteAsync(SpriteID.STATS_TILE_HALF_RIGHT_WITH_SLASH, 0, img ->
		{
			statHalf = SkillPanelSlot.resize(img);
			updateBackgroundImage();
		});
	}

	static BufferedImage resize(final BufferedImage img)
	{
		return ImageUtil.resizeImage(img, PANEL_HALF_SIZE.width, PANEL_HALF_SIZE.height);
	}

	public void updateBaseLevel(final int baseLevel)
	{
		final String levelAsString = String.valueOf(baseLevel);
		if (Objects.equals(levelAsString, baseLabel.getText()))
		{
			return;
		}

		// Adjust offset depending on amount of characters to make the UI look nicer
		int rightPadding = 8;
		if (baseLevel > 99)
		{
			rightPadding = 1;
		}
		else if (baseLevel > 9)
		{
			rightPadding = 4;
		}

		baseLabel.setText(levelAsString);
		baseLabel.setBorder(new EmptyBorder(0, 0, 4, rightPadding));
		baseLabel.repaint();
	}

	public void updateBoostedLevel(final int boostedLevel)
	{
		final String levelAsString = String.valueOf(boostedLevel);
		if (Objects.equals(levelAsString, boostedLabel.getText()))
		{
			return;
		}

		boostedLabel.setText(levelAsString);
		boostedLabel.repaint();
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui.skills;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.image.BufferedImage;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.FontManager;
import thestonedturtle.partypanel.ImgUtil;

public class TotalPanelSlot extends JPanel
{
	private final JLabel levelLabel = new JLabel();
	private BufferedImage background;
	private BufferedImage skillHalf;
	private BufferedImage statHalf;

	@Override
	protected void paintComponent(Graphics g)
	{
		super.paintComponent(g);
		if (background == null)
		{
			return;
		}

		g.drawImage(background, 0, 0, null);
	}

	private void updateBackgroundImage()
	{
		if (skillHalf != null && statHalf != null)
		{
			background = ImgUtil.combineImages(skillHalf, statHalf);
			this.repaint();
		}
	}

	TotalPanelSlot(final int totalLevel, final SpriteManager spriteManager)
	{
		super();
		setOpaque(false);

		spriteManager.getSpriteAsync(SpriteID.STATS_TILE_HALF_LEFT_BLACK, 0, img ->
		{
			skillHalf = SkillPanelSlot.resize(img);
			updateBackgroundImage();
		});
		spriteManager.getSpriteAsync(SpriteID.STATS_TILE_HALF_RIGHT_BLACK, 0, img ->
		{
			statHalf = SkillPanelSlot.resize(img);
			updateBackgroundImage();
		});

		setPreferredSize(SkillPanelSlot.PANEL_FULL_SIZE);
		setLayout(new GridBagLayout());
		final GridBagConstraints c = new GridBagConstraints();
		c.gridx = 0;
		c.gridy = 0;

		final JLabel textLabel = new JLabel("Total level:");
		textLabel.setFont(FontManager.getRunescapeSmallFont());
		textLabel.setForeground(Color.YELLOW);
		add(textLabel, c);

		if (totalLevel > 0)
		{
			levelLabel.setText(String.valueOf(totalLevel));
		}
		levelLabel.setFont(FontManager.getRunescapeSmallFont());
		levelLabel.setForeground(Color.YELLOW);
		c.gridy++;
		add(levelLabel, c);
	}

	public void updateTotalLevel(final int level)
	{
		levelLabel.setText(String.valueOf(level));
		levelLabel.repaint();
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui.equipment;

import com.google.common.collect.ImmutableMap;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.SpriteID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import thestonedturtle.partypanel.data.GameItem;

public class PlayerEquipmentPanel extends JPanel
{
	private static final ImmutableMap<EquipmentInventorySlot, Integer> EQUIPMENT_SLOT_SPRITE_MAP;
	static
	{
		final ImmutableMap.Builder<EquipmentInventorySlot, Integer> sprites = new ImmutableMap.Builder<>();
		sprites.put(EquipmentInventorySlot.HEAD, SpriteID.EQUIPMENT_SLOT_HEAD);
		sprites.put(EquipmentInventorySlot.CAPE, SpriteID.EQUIPMENT_SLOT_CAPE);
		sprites.put(EquipmentInventorySlot.AMULET, SpriteID.EQUIPMENT_SLOT_NECK);
		sprites.put(EquipmentInventorySlot.WEAPON, SpriteID.EQUIPMENT_SLOT_WEAPON);
		sprites.put(EquipmentInventorySlot.RING, SpriteID.EQUIPMENT_SLOT_RING);
		sprites.put(EquipmentInventorySlot.BODY, SpriteID.EQUIPMENT_SLOT_TORSO);
		sprites.put(EquipmentInventorySlot.SHIELD, SpriteID.EQUIPMENT_SLOT_SHIELD);
		sprites.put(EquipmentInventorySlot.LEGS, SpriteID.EQUIPMENT_SLOT_LEGS);
		sprites.put(EquipmentInventorySlot.GLOVES, SpriteID.EQUIPMENT_SLOT_HANDS);
		sprites.put(EquipmentInventorySlot.BOOTS, SpriteID.EQUIPMENT_SLOT_FEET);
		sprites.put(EquipmentInventorySlot.AMMO, SpriteID.EQUIPMENT_SLOT_AMMUNITION);

		EQUIPMENT_SLOT_SPRITE_MAP = sprites.build();
	}

	private static final BufferedImage PANEL_BACKGROUND = ImageUtil.loadImageResource(PlayerEquipmentPanel.class, "equipment-bars.png");
	private static final Dimension PANEL_SIZE = new Dimension(PluginPanel.PANEL_WIDTH - 14, 296);

	// Used to offset the weapon/shield and glove/ring slots
	private static final Border BORDER_LEFT = new EmptyBorder(0, 15, 0, 0);
	private static final Border BORDER_RIGHT = new EmptyBorder(0, 0, 0, 15);

	@Getter
	private final Map<EquipmentInventorySlot, EquipmentPanelSlot> panelMap = new HashMap<>();

	private final ItemManager itemManager;
	private final SpriteManager spriteManager;

	public PlayerEquipmentPanel(final GameItem[] items, final SpriteManager spriteManager, final ItemManager itemManager)
	{
		super();

		this.spriteManager = spriteManager;
		this.itemManager = itemManager;

		this.setMinimumSize(PANEL_SIZE);
		this.setPreferredSize(PANEL_SIZE);
		this.setLayout(new GridBagLayout());
		this.setBackground(new Color(62, 53, 41));

		spriteManager.getSpriteAsync(SpriteID.EQUIPMENT_SLOT_TILE, 0, img -> SwingUtilities.invokeLater(() -> createPanel(items, img)));
	}

	@Override
	protected void paintComponent(Graphics g)
	{
		super.paintComponent(g);
		Graphics2D g2d = (Graphics2D) g;
		final int x = (this.getWidth() - PANEL_BACKGROUND.getWidth()) / 2;
		final int y = (this.getHeight() - PANEL_BACKGROUND.getHeight()) / 2;
		g2d.drawImage(PANEL_BACKGROUND, x, y, null);
	}

	private void createPanel(final GameItem[] items, final BufferedImage background)
	{
		this.removeAll();

		final GridBagConstraints c = new GridBagConstraints();
		c.ipadx = 4;
		c.ipady = 3;
		c.anchor = GridBagConstraints.CENTER;

		// I don't see an iterative way to set up this layout correctly
		// First row
		c.gridx = 1;
		c.gridy = 0;
		createEquipmentPanelSlot(EquipmentInventorySlot.HEAD, items, background, c);

		c.gridx = 0;
		c.gridy++;
		c.anchor = GridBagConstraints.EAST;
		createEquipmentPanelSlot(EquipmentInventorySlot.CAPE, items, background, c);
		c.anchor = GridBagConstraints.CENTER;
		c.gridx++;
		createEquipmentPanelSlot(EquipmentInventorySlot.AMULET, items, background, c);
		c.gridx++;
		c.anchor = GridBagConstraints.WEST;
		createEquipmentPanelSlot(EquipmentInventorySlot.AMMO, items, background, c);
		c.anchor = GridBagConstraints.CENTER;

		c.gridx = 0;
		c.gridy++;
		createEquipmentPanelSlot(EquipmentInventorySlot.WEAPON, items, background, c, BORDER_RIGHT);
		c.gridx++;
		createEquipmentPanelSlot(EquipmentInventorySlot.BODY, items, background, c);
		c.gridx++;
		createEquipmentPanelSlot(EquipmentInventorySlot.SHIELD, items, background, c, BORDER_LEFT);

		c.gridx = 1;
		c.gridy++;
		createEquipmentPanelSlot(EquipmentInventorySlot.LEGS, items, background, c);
		c.gridx = 0;
		c.gridy++;
		createEquipmentPanelSlot(EquipmentInventorySlot.GLOVES, items, background, c, BORDER_RIGHT);
		c.gridx++;
		createEquipmentPanelSlot(EquipmentInventorySlot.BOOTS, items, background, c);
		c.gridx++;
		createEquipmentPanelSlot(EquipmentInventorySlot.RING, items, background, c, BORDER_LEFT);

		this.revalidate();
		this.repaint();
	}
	private void createEquipmentPanelSlot(final EquipmentInventorySlot slot, final GameItem[] items,
		final BufferedImage background, final GridBagConstraints c)
	{
		createEquipmentPanelSlot(slot, items, background, c, null);
	}

	private void createEquipmentPanelSlot(final EquipmentInventorySlot slot, final GameItem[] items,
		final BufferedImage background, final GridBagConstraints constraints, final Border border)
	{
		// Clone constraints for async support
		final GridBagConstraints c = (GridBagConstraints) constraints.clone();
		final GameItem item = items.length > slot.getSlotIdx() ? items[slot.getSlotIdx()] : null;
		final AsyncBufferedImage image = item == null ? null : itemManager.getImage(item.getId(), item.getQty(), item.isStackable());

		spriteManager.getSpriteAsync(EQUIPMENT_SLOT_SPRITE_MAP.get(slot), 0, img ->
			SwingUtilities.invokeLater(() ->
			{
				final EquipmentPanelSlot panel = new EquipmentPanelSlot(item, image, background, img);
				if (border != null)
				{
					panel.setBorder(border);
				}
				panelMap.put(slot, panel);

				if (image != null)
				{
					image.onLoaded(() -> panel.setGameItem(item, image));
				}

				add(panel, c);
			}));
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui.equipment;

import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import thestonedturtle.partypanel.ImgUtil;
import thestonedturtle.partypanel.data.GameItem;

public class EquipmentPanelSlot extends JLabel
{
	private final int IMAGE_SIZE = 48; // Background is squared at 32x32, we want 50% bigger so 48x48
	private final BufferedImage background;
	private final BufferedImage placeholder;
	@Getter
	private GameItem item = null;

	EquipmentPanelSlot(final GameItem item, final BufferedImage image, final BufferedImage background, final BufferedImage placeholder)
	{
		super();

		this.background = background;
		this.placeholder = ImageUtil.resizeImage(ImgUtil.overlapImages(placeholder, background, false), IMAGE_SIZE, IMAGE_SIZE);

		setVerticalAlignment(JLabel.CENTER);
		setHorizontalAlignment(JLabel.CENTER);
		setGameItem(item, image);
	}

	public void setGameItem(final GameItem item, final BufferedImage image)
	{
		this.item = item;

		if (item == null || image == null)
		{
			setIcon(new ImageIcon(placeholder));
			setToolTipText(null);
			return;
		}

		setIcon(new ImageIcon(ImageUtil.resizeImage(ImgUtil.overlapImages(image, background, true), IMAGE_SIZE, IMAGE_SIZE)));
		String name = item.getName();
		if (item.getQty() > 1)
		{
			name += " x " + QuantityFormatter.formatNumber(item.getQty());
		}
		setToolTipText(name);
	}
}

/*
 * Copyright (c) 2021, Jonathan Rousseau <https://github.com/JoRouss>
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui;

import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.Locale;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import thestonedturtle.partypanel.PartyPanelPlugin;

// A copy of the controls from the `net.runelite.client.plugins.party.PartyPanel` class
public class ControlsPanel extends JPanel
{
	private static final String BTN_CREATE_TEXT = "Create party";
	private static final String BTN_LEAVE_TEXT = "Leave party";

	private final JButton startButton = new JButton();
	private final JButton joinPartyButton = new JButton();
	private final JButton rejoinPartyButton = new JButton();
	private final JButton copyPartyIdButton = new JButton();

	private final PartyPanelPlugin plugin;

	public ControlsPanel(PartyPanelPlugin plugin)
	{
		this.plugin = plugin;
		this.setLayout(new GridBagLayout());

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.insets = new Insets(0, 2, 4, 2);

		c.gridx = 0;
		c.gridy = 0;
		this.add(startButton, c);

		c.gridx = 1;
		c.gridy = 0;
		this.add(joinPartyButton, c);

		c.gridx = 1;
		c.gridy = 0;
		this.add(copyPartyIdButton, c);

		c.gridx = 0;
		c.gridy = 1;
		c.gridwidth = 2;
		this.add(rejoinPartyButton, c);

		startButton.setText(plugin.isInParty() ? BTN_LEAVE_TEXT : BTN_CREATE_TEXT);
		startButton.setFocusable(false);

		joinPartyButton.setText("Join party");
		joinPartyButton.setFocusable(false);

		rejoinPartyButton.setText("Join previous party");
		rejoinPartyButton.setFocusable(false);

		copyPartyIdButton.setText("Copy passphrase");
		copyPartyIdButton.setFocusable(false);

		startButton.addActionListener(e ->
		{
			if (plugin.isInParty())
			{
				// Leave party
				final int result = JOptionPane.showOptionDialog(startButton,
					"Are you sure you want to leave the party?",
					"Leave party?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
					null, new String[]{"Yes", "No"}, "Yes");

				if (result == JOptionPane.YES_OPTION)
				{
					plugin.leaveParty();
				}
			}
			else
			{
				plugin.createParty();
			}
		});

		joinPartyButton.addActionListener(e ->
		{
			if (!plugin.isInParty())
			{
				String s = (String) JOptionPane.showInputDialog(
					joinPartyButton,
					"Please enter the party passphrase:",
					"Party Passphrase",
					JOptionPane.PLAIN_MESSAGE,
					null,
					null,
					"");

				if (s == null)
				{
					return;
				}

				s = s.toLowerCase(Locale.US);


				plugin.changeParty(s);
			}
		});

		rejoinPartyButton.addActionListener(e ->
		{
			if (!plugin.isInParty())
			{
				plugin.changeParty(plugin.getConfig().previousPartyId());
			}
		});

		copyPartyIdButton.addActionListener(e ->
		{
			if (plugin.isInParty())
			{
				Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
				clipboard.setContents(new StringSelection(plugin.getPartyPassphrase()), null);
			}
		});

		updateControls();
	}

	public void updateControls()
	{
		startButton.setText(plugin.isInParty() ? BTN_LEAVE_TEXT : BTN_CREATE_TEXT);
		joinPartyButton.setVisible(!plugin.isInParty());
		rejoinPartyButton.setVisible(!plugin.isInParty());
		copyPartyIdButton.setVisible(plugin.isInParty());

		if (!plugin.getConfig().showPartyControls())
		{
			this.setVisible(false);
		}
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.client.game.AlternateSprites;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import thestonedturtle.partypanel.PartyPanelConfig;
import thestonedturtle.partypanel.data.GameItem;
import thestonedturtle.partypanel.data.PartyPlayer;
import thestonedturtle.partypanel.data.PrayerData;
import thestonedturtle.partypanel.ui.equipment.EquipmentPanelSlot;
import thestonedturtle.partypanel.ui.equipment.PlayerEquipmentPanel;
import thestonedturtle.partypanel.ui.prayer.PlayerPrayerPanel;
import thestonedturtle.partypanel.ui.prayer.PrayerSlot;
import thestonedturtle.partypanel.ui.skills.PlayerSkillsPanel;

@Getter
public class PlayerPanel extends JPanel
{
	private static final Dimension IMAGE_SIZE = new Dimension(24, 24);
	private static final Color BACKGROUND_COLOR = ColorScheme.DARK_GRAY_COLOR;
	private static final Color BACKGROUND_HOVER_COLOR = ColorScheme.DARKER_GRAY_COLOR;
	private static final BufferedImage EXPAND_ICON = ImageUtil.loadImageResource(PlayerPanel.class, "expand.png");

	private static final int VENOM_THRESHOLD = 1000000;
	private static final BufferedImage HEART_DISEASE;
	private static final BufferedImage HEART_POISON;
	private static final BufferedImage HEART_VENOM;

	static
	{
		HEART_DISEASE = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.DISEASE_HEART);
		HEART_POISON = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.POISON_HEART);
		HEART_VENOM = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.VENOM_HEART);
	}

	private PartyPlayer player;
	private final SpriteManager spriteManager;
	private final ItemManager itemManager;

	private final PlayerBanner banner;
	private final PlayerInventoryPanel inventoryPanel;
	private final PlayerEquipmentPanel equipmentPanel;
	private final PlayerSkillsPanel skillsPanel;
	private final PlayerPrayerPanel prayersPanel;

	private final PartyPanelConfig config;

	@Setter
	private boolean showInfo;
	private final Map<Integer, Boolean> tabMap = new HashMap<>();

	public PlayerPanel(final PartyPlayer selectedPlayer, final PartyPanelConfig config,
		final SpriteManager spriteManager, final ItemManager itemManager)
	{
		this.player = selectedPlayer;
		this.config = config;
		this.spriteManager = spriteManager;
		this.itemManager = itemManager;
		this.showInfo = config.autoExpandMembers();
		this.banner = new PlayerBanner(selectedPlayer, showInfo, config.displayPlayerWorlds(), spriteManager);
		this.inventoryPanel = new PlayerInventoryPanel(selectedPlayer.getInventory(), selectedPlayer.getRunesInPouch(), itemManager);
		this.equipmentPanel = new PlayerEquipmentPanel(selectedPlayer.getEquipment(), spriteManager, itemManager);
		this.skillsPanel = new PlayerSkillsPanel(selectedPlayer, config.displayVirtualLevels(), spriteManager);
		this.prayersPanel = new PlayerPrayerPanel(selectedPlayer, spriteManager);

		// Non-optimal way to attach a mouse listener to
		// the entire panel, but easy to implement
		JPanel statsPanel = this.banner.getStatsPanel();
		JLabel expandIcon = this.banner.getExpandIcon();
		Component[] list = new Component[statsPanel.getComponentCount() + 1];
		System.arraycopy(statsPanel.getComponents(), 0, list, 0, list.length - 1);
		list[list.length - 1] = banner;

		for (Component comp : list)
		{
			if (comp instanceof JPanel)
			{
				comp.addMouseListener(new MouseAdapter()
				{
					@Override
					public void mousePressed(MouseEvent e)
					{
						if (e.getButton() == MouseEvent.BUTTON1)
						{
							ImageIcon retrieve = (ImageIcon) expandIcon.getIcon();
							BufferedImage buffered = (BufferedImage) retrieve.getImage();

							showInfo = !showInfo;
							expandIcon.setIcon(new ImageIcon(ImageUtil.rotateImage(buffered, Math.PI)));
							updatePanel();
						}
					}

					@Override
					public void mouseEntered(MouseEvent e)
					{
						banner.setBackground(BACKGROUND_HOVER_COLOR);
						statsPanel.setBackground(BACKGROUND_HOVER_COLOR);
					}

					@Override
					public void mouseExited(MouseEvent e)
					{
						banner.setBackground(BACKGROUND_COLOR);
						statsPanel.setBackground(BACKGROUND_COLOR);
					}
				});
			}
		}

		updatePanel();

		revalidate();
		repaint();
	}

	private void addTab(final MaterialTabGroup tabGroup, final int spriteID, final JPanel panel, final String tooltip)
	{
		spriteManager.getSpriteAsync(spriteID, 0, img ->
			SwingUtilities.invokeLater(() ->
			{
				final MaterialTab tab = new MaterialTab(createImageIcon(img), tabGroup, panel);
				tab.setToolTipText(tooltip);
				tabGroup.addTab(tab);
				tabGroup.revalidate();
				tabGroup.repaint();

				tabMap.put(spriteID, false);
				tab.setOnSelectEvent(() ->
				{
					tabMap.replaceAll((k, v) -> v = false);
					tabMap.put(spriteID, true);
					updatePlayerData(player, false);
					return true;
				});

				if (spriteID == SpriteID.TAB_INVENTORY)
				{
					tabGroup.select(tab);
					tabMap.put(spriteID, true);
				}
			}));
	}

	private ImageIcon createImageIcon(BufferedImage image)
	{
		return new ImageIcon(ImageUtil.resizeImage(image, IMAGE_SIZE.width, IMAGE_SIZE.height));
	}

	// TODO add smarter ways to update data
	public void updatePlayerData(PartyPlayer newPlayer, boolean hasBreakingBannerChange)
	{
		player = newPlayer;
		banner.setPlayer(player);

		if (hasBreakingBannerChange)
		{
			banner.recreatePanel();
		}

		if (player.getStats() != null)
		{
			banner.refreshStats();
		}

		BufferedImage heart = null;
		if (player.getPoison() >= VENOM_THRESHOLD)
		{
			heart = HEART_VENOM;
		}
		else if (player.getPoison() > 0)
		{
			heart = HEART_POISON;
		}
		else if (player.getDisease() > 0)
		{
			heart = HEART_DISEASE;
		}
		banner.setCurrentHeart(heart, spriteManager);
		banner.setUsingStamIcon(player.getStamina() > 0, spriteManager);

		if (!showInfo)
		{
			return;
		}

		if (tabMap.getOrDefault(SpriteID.TAB_INVENTORY, false))
		{
			inventoryPanel.updateInventory(player.getInventory(), player.getRunesInPouch());
		}

		if (tabMap.getOrDefault(SpriteID.TAB_EQUIPMENT, false))
		{
			for (final EquipmentInventorySlot equipSlot : EquipmentInventorySlot.values())
			{
				GameItem item = null;
				if (player.getEquipment().length > equipSlot.getSlotIdx())
				{
					item = player.getEquipment()[equipSlot.getSlotIdx()];
				}

				final EquipmentPanelSlot slot = this.equipmentPanel.getPanelMap().get(equipSlot);
				if (item != null && slot != null)
				{
					final AsyncBufferedImage img = itemManager.getImage(item.getId(), item.getQty(), item.isStackable());
					slot.setGameItem(item, img);

					// Ensure item is set when image loads
					final GameItem finalItem = item;
					img.onLoaded(() -> slot.setGameItem(finalItem, img));
				}
				else if (slot != null)
				{
					slot.setGameItem(null, null);
				}
			}
		}

		if (player.getStats() != null && tabMap.getOrDefault(SpriteID.TAB_STATS, false))
		{
			int totalLevel = 0;
			for (final Skill s : Skill.values())
			{
				totalLevel += player.getSkillRealLevel(s, config.displayVirtualLevels());

				updateSkill(s);
			}
			skillsPanel.getTotalLevelPanel().updateTotalLevel(totalLevel);
		}

		if (player.getPrayers() != null && tabMap.getOrDefault(SpriteID.TAB_PRAYER, false))
		{
			boolean unlockChanged = false;
			for (final Map.Entry<Prayer, PrayerSlot> entry : prayersPanel.getSlotMap().entrySet())
			{
				PrayerSlot slot = entry.getValue();
				final PrayerData data = player.getPrayers().getPrayerData().get(entry.getKey());
				if (data != null)
				{
					unlockChanged = unlockChanged || data.isUnlocked() != slot.getData().isUnlocked();
					entry.getValue().updatePrayerData(data);
				}
			}

			if (unlockChanged)
			{
				prayersPanel.updateSlots();
			}

			prayersPanel.updatePrayerRemaining(player.getSkillBoostedLevel(Skill.PRAYER), player.getSkillRealLevel(Skill.PRAYER));
		}
	}

	public void updatePanel()
	{
		this.removeAll();
		if (showInfo)
		{
			this.setBorder(new CompoundBorder(
				new MatteBorder(2, 2, 2, 2, new Color(87, 80, 64)),
				new EmptyBorder(0, 0, 5, 0)
			));
		}
		else
		{
			this.setBorder(new MatteBorder(2, 2, 2, 2, new Color(87, 80, 64)));
		}

		final JPanel view = new JPanel();
		view.setBorder(new EmptyBorder(5, 5, 0, 5));
		final MaterialTabGroup tabGroup = new MaterialTabGroup(view);
		tabGroup.setBorder(new EmptyBorder(10, 0, 4, 0));

		tabMap.clear();
		addTab(tabGroup, SpriteID.TAB_INVENTORY, inventoryPanel, "Inventory");
		addTab(tabGroup, SpriteID.TAB_EQUIPMENT, equipmentPanel, "Equipment");
		addTab(tabGroup, SpriteID.TAB_PRAYER, prayersPanel, "Prayers");
		addTab(tabGroup, SpriteID.TAB_STATS, skillsPanel, "Skills");

		setLayout(new DynamicGridLayout(0, 1));

		add(banner);
		if (this.showInfo)
		{
			add(tabGroup);
			add(view);
		}

		revalidate();
		repaint();
	}

	public void updateSkill(Skill s)
	{
		skillsPanel.updateSkill(player, s, config.displayVirtualLevels());
	}

	public void updateDisplayVirtualLevels()
	{
		int totalLevel = 0;
		for (final Skill s : Skill.values())
		{
			totalLevel += player.getSkillRealLevel(s, config.displayVirtualLevels());

			updateSkill(s);
		}

		skillsPanel.getTotalLevelPanel().updateTotalLevel(totalLevel);
	}

	public void updateDisplayPlayerWorlds()
	{
		banner.updateWorld(player.getWorld(), config.displayPlayerWorlds());
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui;

import com.google.common.base.Strings;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.OverlayLayout;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Constants;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import thestonedturtle.partypanel.data.PartyPlayer;

public class PlayerBanner extends JPanel
{
	private static final Dimension STAT_ICON_SIZE = new Dimension(18, 18);
	private static final Dimension ICON_SIZE = new Dimension(Constants.ITEM_SPRITE_WIDTH - 6, Constants.ITEM_SPRITE_HEIGHT - 4);
	private static final BufferedImage EXPAND_ICON = ImageUtil.loadImageResource(PlayerPanel.class, "expand.png");
	private static final String SPECIAL_ATTACK_NAME = "Special Attack";
	private static final String RUN_ENERGY_NAME = "Run Energy";

	@Getter
	private final JPanel statsPanel = new JPanel();
	private final JLabel iconLabel = new JLabel();
	private final Map<String, JLabel> statLabels = new HashMap<>();
	private final Map<String, JLabel> iconLabels = new HashMap<>();
	@Getter
	private final JLabel expandIcon = new JLabel();
	private final JLabel worldLabel = new JLabel();

	private final ImageIcon expandIconUp;
	private final ImageIcon expandIconDown;

	@Setter
	@Getter
	private PartyPlayer player;
	private boolean checkIcon;

	private BufferedImage currentHeart = null;
	private boolean usingStamIcon;

	public PlayerBanner(final PartyPlayer player, boolean expanded, boolean displayWorld, SpriteManager spriteManager)
	{
		super();
		this.player = player;

		this.setLayout(new GridBagLayout());
		this.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 14, 68));
		this.setBorder(new EmptyBorder(5, 5, 0,  5));

		statsPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 25));
		statsPanel.setLayout(new GridLayout(0, 4));
		statsPanel.setBorder(new EmptyBorder(5, 0, 0, 0));
		statsPanel.setOpaque(true);

		expandIconDown = new ImageIcon(EXPAND_ICON);
		expandIconUp = new ImageIcon(ImageUtil.rotateImage(EXPAND_ICON, Math.PI));
		if (expanded)
		{
			expandIcon.setIcon(expandIconUp);
		}
		else
		{
			expandIcon.setIcon(expandIconDown);
		}

		worldLabel.setHorizontalTextPosition(JLabel.LEFT);
		worldLabel.setVisible(displayWorld);

		usingStamIcon = player.getStamina() > 0;
		statsPanel.add(createIconPanel(spriteManager, SpriteID.SKILL_HITPOINTS, Skill.HITPOINTS.getName(), String.valueOf(player.getSkillBoostedLevel(Skill.HITPOINTS))));
		statsPanel.add(createIconPanel(spriteManager, SpriteID.SKILL_PRAYER, Skill.PRAYER.getName(), String.valueOf(player.getSkillBoostedLevel(Skill.PRAYER))));
		statsPanel.add(createIconPanel(spriteManager, SpriteID.MULTI_COMBAT_ZONE_CROSSED_SWORDS, SPECIAL_ATTACK_NAME, player.getStats() == null ? "0" : String.valueOf(player.getStats().getSpecialPercent())));
		statsPanel.add(createIconPanel(spriteManager,
			usingStamIcon ? SpriteID.MINIMAP_ORB_RUN_ICON_SLOWED_DEPLETION : SpriteID.MINIMAP_ORB_RUN_ICON,
			RUN_ENERGY_NAME, player.getStats() == null ? "0" : String.valueOf(player.getStats().getRunEnergy()))
		);

		recreatePanel();
	}

	// True = arrow up; False = arrow down
	public void setExpandIcon(boolean direction)
	{
		if (direction)
		{
			expandIcon.setIcon(expandIconUp);
		}
		else
		{
			expandIcon.setIcon(expandIconDown);
		}
	}

	public void recreatePanel()
	{
		removeAll();
		
		final GridBagConstraints c = new GridBagConstraints();
		c.anchor = GridBagConstraints.NORTHWEST;
		c.gridx = 0;
		c.gridy = 0;
		c.weightx = 0;
		c.weighty = 1.0;
		c.ipady = 4;

		// Add avatar label regardless of if one exists just to have UI matching
		iconLabel.setBorder(new MatteBorder(1, 1, 1, 1, ColorScheme.DARKER_GRAY_HOVER_COLOR));
		iconLabel.setPreferredSize(ICON_SIZE);
		iconLabel.setMinimumSize(ICON_SIZE);
		iconLabel.setOpaque(false);

		checkIcon = player.getMember().getAvatar() == null;
		if (!checkIcon)
		{
			addIcon();
		}

		add(iconLabel, c);
		c.gridx++;

		final JPanel nameContainer = new JPanel(new GridLayout(2, 1));
		nameContainer.setBorder(new EmptyBorder(0, 5, 0, 0));
		nameContainer.setOpaque(false);

		final JLabel usernameLabel = new JLabel();
		usernameLabel.setLayout(new OverlayLayout(usernameLabel));
		usernameLabel.setHorizontalTextPosition(JLabel.LEFT);
		if (Strings.isNullOrEmpty(player.getUsername()))
		{
			usernameLabel.setText("Not logged in");
		}
		else
		{
			final String levelText = player.getStats() == null ? "" : " (level-" + player.getStats().getCombatLevel() + ")";
			usernameLabel.setText(player.getUsername() + levelText);
		}

		expandIcon.setAlignmentX(Component.RIGHT_ALIGNMENT);
		usernameLabel.add(expandIcon, BorderLayout.EAST);
		nameContainer.add(usernameLabel);


		worldLabel.setText("Not logged in");
		if (Strings.isNullOrEmpty(player.getUsername()))
		{
			worldLabel.setText("");
		}
		else if (player.getWorld() > 0)
		{

			worldLabel.setText("World " + player.getWorld());
		}
		nameContainer.add(worldLabel);


		c.weightx = 1.0;
		c.fill = GridBagConstraints.HORIZONTAL;
		add(nameContainer, c);

		refreshStats();
		c.gridy++;
		c.weightx = 0;
		c.gridx = 0;
		c.gridwidth = 2;
		add(statsPanel, c);

		revalidate();
		repaint();
	}

	private void addIcon()
	{
		final BufferedImage resized = ImageUtil.resizeImage(player.getMember().getAvatar(), Constants.ITEM_SPRITE_WIDTH - 8, Constants.ITEM_SPRITE_HEIGHT - 4);
		iconLabel.setIcon(new ImageIcon(resized));
	}

	public void refreshStats()
	{
		if (checkIcon)
		{
			if (player.getMember().getAvatar() != null)
			{
				addIcon();
				checkIcon = false;
			}
		}

		statLabels.getOrDefault(Skill.HITPOINTS.getName(), new JLabel()).setText(String.valueOf(player.getSkillBoostedLevel(Skill.HITPOINTS)));
		statLabels.getOrDefault(Skill.PRAYER.getName(), new JLabel()).setText(String.valueOf(player.getSkillBoostedLevel(Skill.PRAYER)));
		statLabels.getOrDefault(SPECIAL_ATTACK_NAME, new JLabel()).setText(player.getStats() == null ? "0" : String.valueOf(player.getStats().getSpecialPercent()));
		statLabels.getOrDefault(RUN_ENERGY_NAME, new JLabel()).setText(player.getStats() == null ? "0" : String.valueOf(player.getStats().getRunEnergy()));

		statsPanel.revalidate();
		statsPanel.repaint();
	}

	private JPanel createIconPanel(final SpriteManager spriteManager, final int spriteID, final String name,
		final String value)
	{
		final JLabel iconLabel = new JLabel();
		iconLabel.setPreferredSize(STAT_ICON_SIZE);
		iconLabels.put(name, iconLabel);
		setSpriteIcon(name, spriteID, spriteManager);

		final JLabel textLabel = new JLabel(value);
		textLabel.setHorizontalAlignment(JLabel.CENTER);
		textLabel.setHorizontalTextPosition(JLabel.CENTER);
		statLabels.put(name, textLabel);

		final JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		panel.add(iconLabel, BorderLayout.WEST);
		panel.add(textLabel, BorderLayout.CENTER);
		panel.setOpaque(false);
		panel.setToolTipText(name);

		return panel;
	}

	private void setSpriteIcon(String statLabelKey, final int spriteID, final SpriteManager spriteManager)
	{
		final JLabel label = iconLabels.get(statLabelKey);
		spriteManager.getSpriteAsync(spriteID, 0, img ->
			SwingUtilities.invokeLater(() ->
			{
				if (spriteID == SpriteID.SKILL_PRAYER)
				{
					label.setIcon(new ImageIcon(ImageUtil.resizeImage(img, STAT_ICON_SIZE.width + 2, STAT_ICON_SIZE.height + 2)));
				}
				else
				{
					label.setIcon(new ImageIcon(ImageUtil.resizeImage(img, STAT_ICON_SIZE.width, STAT_ICON_SIZE.height)));
				}
				label.revalidate();
				label.repaint();
			}));
	}

	private void setBufferedIcon(String statLabelKey, final BufferedImage img)
	{
		final JLabel label = iconLabels.get(statLabelKey);
		SwingUtilities.invokeLater(() ->
		{
			label.setIcon(new ImageIcon(ImageUtil.resizeImage(img, STAT_ICON_SIZE.width, STAT_ICON_SIZE.height)));
			label.revalidate();
			label.repaint();
		});
	}

	public void setCurrentHeart(final BufferedImage img, SpriteManager spriteManager)
	{
		// If the new value is the same then do nothing
		if ( (img == null && currentHeart == null) || (img != null && img.equals(currentHeart)) )
		{
			return;
		}
		currentHeart = img;
		if (currentHeart == null)
		{
			setSpriteIcon(Skill.HITPOINTS.getName(), SpriteID.SKILL_HITPOINTS, spriteManager);
		}
		else
		{
			setBufferedIcon(Skill.HITPOINTS.getName(), currentHeart);
		}
		statsPanel.revalidate();
		statsPanel.repaint();
	}

	public void setUsingStamIcon(final boolean isStaminaPotted, SpriteManager spriteManager)
	{
		if (isStaminaPotted == usingStamIcon)
		{
			return;
		}

		usingStamIcon = isStaminaPotted;
		final int id = usingStamIcon ? SpriteID.MINIMAP_ORB_RUN_ICON_SLOWED_DEPLETION : SpriteID.MINIMAP_ORB_RUN_ICON;
		setSpriteIcon(RUN_ENERGY_NAME, id, spriteManager);
		statsPanel.revalidate();
		statsPanel.repaint();
	}

	public void updateWorld(int world, boolean displayWorlds)
	{
		worldLabel.setVisible(displayWorlds);
		worldLabel.setText("World " + world);
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.util.Arrays;
import java.util.Objects;
import java.util.stream.Collectors;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;
import org.apache.commons.lang3.ArrayUtils;
import thestonedturtle.partypanel.PartyPanelPlugin;
import thestonedturtle.partypanel.data.GameItem;

public class PlayerInventoryPanel extends JPanel
{
	private static final Dimension INVI_SLOT_SIZE = new Dimension(50, 42);
	private static final Dimension PANEL_SIZE = new Dimension(PluginPanel.PANEL_WIDTH - 14, 296);
	private static final Color INVI_BACKGROUND = new Color(62, 53, 41);

	private final ItemManager itemManager;

	public PlayerInventoryPanel(final GameItem[] items, final GameItem[] runePouchContents, final ItemManager itemManager)
	{
		super();

		this.itemManager = itemManager;

		setLayout(new DynamicGridLayout(7, 4, 2, 2));
		setBackground(INVI_BACKGROUND);
		setPreferredSize(PANEL_SIZE);

		updateInventory(items, runePouchContents);
	}

	public void updateInventory(final GameItem[] items, final GameItem[] runePouchContents)
	{
		this.removeAll();

		for (final GameItem i : items)
		{
			final JLabel label = new JLabel();
			label.setMinimumSize(INVI_SLOT_SIZE);
			label.setPreferredSize(INVI_SLOT_SIZE);
			label.setVerticalAlignment(JLabel.CENTER);
			label.setHorizontalAlignment(JLabel.CENTER);

			if (i != null)
			{
				String tooltip;
				if (ArrayUtils.contains(PartyPanelPlugin.RUNEPOUCH_ITEM_IDS, i.getId()))
				{
					tooltip = getRunePouchHoverText(i, runePouchContents);
				}
				else
				{
					tooltip = i.getDisplayName();
				}
				label.setToolTipText(tooltip);
				itemManager.getImage(i.getId(), i.getQty(), i.isStackable()).addTo(label);
			}

			add(label);
		}

		for (int i = getComponentCount(); i < 28; i++)
		{
			final JLabel label = new JLabel();
			label.setMinimumSize(INVI_SLOT_SIZE);
			label.setPreferredSize(INVI_SLOT_SIZE);
			label.setVerticalAlignment(JLabel.CENTER);
			label.setHorizontalAlignment(JLabel.CENTER);
			add(label);
		}

		revalidate();
		repaint();
	}

	public String getRunePouchHoverText(final GameItem runePouch, final GameItem[] contents)
	{
		final String contentNames = Arrays.stream(contents)
			.filter(Objects::nonNull)
			.map(GameItem::getDisplayName)
			.collect(Collectors.joining("<br>"));

		if (contentNames.isEmpty())
		{
			return runePouch.getDisplayName();
		}

		return "<html>"
			+ runePouch.getDisplayName()
			+ "<br><br>"
			+ contentNames
			+ "</html>";
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui.prayer;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Prayer;
import net.runelite.api.SpriteID;
import net.runelite.api.Varbits;

@AllArgsConstructor
@Getter
public enum PrayerSprites
{
	THICK_SKIN(Prayer.THICK_SKIN, SpriteID.PRAYER_THICK_SKIN, SpriteID.PRAYER_THICK_SKIN_DISABLED, 0),
	BURST_OF_STRENGTH(Prayer.BURST_OF_STRENGTH, SpriteID.PRAYER_BURST_OF_STRENGTH, SpriteID.PRAYER_BURST_OF_STRENGTH_DISABLED, 1),
	CLARITY_OF_THOUGHT(Prayer.CLARITY_OF_THOUGHT, SpriteID.PRAYER_CLARITY_OF_THOUGHT, SpriteID.PRAYER_CLARITY_OF_THOUGHT_DISABLED, 2),
	SHARP_EYE(Prayer.SHARP_EYE, SpriteID.PRAYER_SHARP_EYE, SpriteID.PRAYER_SHARP_EYE_DISABLED, 18),
	MYSTIC_WILL(Prayer.MYSTIC_WILL, SpriteID.PRAYER_MYSTIC_WILL, SpriteID.PRAYER_MYSTIC_WILL_DISABLED, 19),

	ROCK_SKIN(Prayer.ROCK_SKIN, SpriteID.PRAYER_ROCK_SKIN, SpriteID.PRAYER_ROCK_SKIN_DISABLED, 3),
	SUPERHUMAN_STRENGTH(Prayer.SUPERHUMAN_STRENGTH, SpriteID.PRAYER_SUPERHUMAN_STRENGTH, SpriteID.PRAYER_SUPERHUMAN_STRENGTH_DISABLED, 4),
	IMPROVED_REFLEXES(Prayer.IMPROVED_REFLEXES, SpriteID.PRAYER_IMPROVED_REFLEXES, SpriteID.PRAYER_IMPROVED_REFLEXES_DISABLED, 5),
	RAPID_RESTORE(Prayer.RAPID_RESTORE, SpriteID.PRAYER_RAPID_RESTORE, SpriteID.PRAYER_RAPID_RESTORE_DISABLED, 6),
	RAPID_HEAL(Prayer.RAPID_HEAL, SpriteID.PRAYER_RAPID_HEAL, SpriteID.PRAYER_RAPID_HEAL_DISABLED, 7),

	PROTECT_ITEM(Prayer.PROTECT_ITEM, SpriteID.PRAYER_PROTECT_ITEM, SpriteID.PRAYER_PROTECT_ITEM_DISABLED, 8),
	HAWK_EYE(Prayer.HAWK_EYE, SpriteID.PRAYER_HAWK_EYE, SpriteID.PRAYER_HAWK_EYE_DISABLED, 20),
	MYSTIC_LORE(Prayer.MYSTIC_LORE, SpriteID.PRAYER_MYSTIC_LORE, SpriteID.PRAYER_MYSTIC_LORE_DISABLED, 21),
	STEEL_SKIN(Prayer.STEEL_SKIN, SpriteID.PRAYER_STEEL_SKIN, SpriteID.PRAYER_STEEL_SKIN_DISABLED, 9),
	ULTIMATE_STRENGTH(Prayer.ULTIMATE_STRENGTH, SpriteID.PRAYER_ULTIMATE_STRENGTH, SpriteID.PRAYER_ULTIMATE_STRENGTH_DISABLED, 10),

	INCREDIBLE_REFLEXES(Prayer.INCREDIBLE_REFLEXES, SpriteID.PRAYER_INCREDIBLE_REFLEXES, SpriteID.PRAYER_INCREDIBLE_REFLEXES_DISABLED, 11),
	PROTECT_FROM_MAGIC(Prayer.PROTECT_FROM_MAGIC, SpriteID.PRAYER_PROTECT_FROM_MAGIC, SpriteID.PRAYER_PROTECT_FROM_MAGIC_DISABLED, 12),
	PROTECT_FROM_MISSILES(Prayer.PROTECT_FROM_MISSILES, SpriteID.PRAYER_PROTECT_FROM_MISSILES, SpriteID.PRAYER_PROTECT_FROM_MISSILES_DISABLED, 13),
	PROTECT_FROM_MELEE(Prayer.PROTECT_FROM_MELEE, SpriteID.PRAYER_PROTECT_FROM_MELEE, SpriteID.PRAYER_PROTECT_FROM_MELEE_DISABLED, 14),
	EAGLE_EYE(Prayer.EAGLE_EYE, SpriteID.PRAYER_EAGLE_EYE, SpriteID.PRAYER_EAGLE_EYE_DISABLED, 22)
		{
			@Override
			public boolean isUnlocked(Client client)
			{
				return !DEADEYE.isUnlocked(client);
			}
		},
	DEADEYE(Prayer.DEADEYE, SpriteID.PRAYER_DEADEYE, SpriteID.PRAYER_DEADEYE_DISABLED, 22)
		{
			@Override
			public boolean isUnlocked(Client client)
			{
				boolean inLms = client.getVarbitValue(Varbits.IN_LMS) != 0;
				boolean deadeye = client.getVarbitValue(Varbits.PRAYER_DEADEYE_UNLOCKED) != 0;
				return deadeye && !inLms;
			}
		},

	MYSTIC_MIGHT(Prayer.MYSTIC_MIGHT, SpriteID.PRAYER_MYSTIC_MIGHT, SpriteID.PRAYER_MYSTIC_MIGHT_DISABLED, 23)
		{
			@Override
			public boolean isUnlocked(Client client)
			{
				return !MYSTIC_VIGOUR.isUnlocked(client);
			}
		},
	MYSTIC_VIGOUR(Prayer.MYSTIC_VIGOUR, SpriteID.PRAYER_MYSTIC_VIGOUR, SpriteID.PRAYER_MYSTIC_VIGOUR_DISABLED, 23)
		{
			@Override
			public boolean isUnlocked(Client client)
			{
				boolean inLms = client.getVarbitValue(Varbits.IN_LMS) != 0;
				boolean vigour = client.getVarbitValue(Varbits.PRAYER_MYSTIC_VIGOUR_UNLOCKED) != 0;
				return vigour && !inLms;
			}
		},
	RETRIBUTION(Prayer.RETRIBUTION, SpriteID.PRAYER_RETRIBUTION, SpriteID.PRAYER_RETRIBUTION_DISABLED, 15),
	REDEMPTION(Prayer.REDEMPTION, SpriteID.PRAYER_REDEMPTION, SpriteID.PRAYER_REDEMPTION_DISABLED, 16),
	SMITE(Prayer.SMITE, SpriteID.PRAYER_SMITE, SpriteID.PRAYER_SMITE_DISABLED, 17),
	PRESERVE(Prayer.PRESERVE, SpriteID.PRAYER_PRESERVE, SpriteID.PRAYER_PRESERVE_DISABLED, 28),

	CHIVALRY(Prayer.CHIVALRY, SpriteID.PRAYER_CHIVALRY, SpriteID.PRAYER_CHIVALRY_DISABLED, 24),
	PIETY(Prayer.PIETY, SpriteID.PRAYER_PIETY, SpriteID.PRAYER_PIETY_DISABLED, 25),
	RIGOUR(Prayer.RIGOUR, SpriteID.PRAYER_RIGOUR, SpriteID.PRAYER_RIGOUR_DISABLED, 26),
	AUGURY(Prayer.AUGURY, SpriteID.PRAYER_AUGURY, SpriteID.PRAYER_AUGURY_DISABLED, 27),
	;

	private final Prayer prayer;
	private final int available;
	private final int unavailable;
	private final int scriptIndex;

	public boolean isUnlocked(Client client)
	{
		return true;
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui.prayer;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import lombok.Getter;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.util.Text;
import thestonedturtle.partypanel.ImgUtil;
import thestonedturtle.partypanel.data.PrayerData;
import static thestonedturtle.partypanel.data.Prayers.isUnlockedByDefault;

public class PrayerSlot extends JLabel
{
	private static final Dimension SIZE = new Dimension(40, 40);

	private BufferedImage unavailableImage;
	private BufferedImage availableImage;
	private BufferedImage activatedImage;

	@Getter
	private PrayerData data;

	public PrayerSlot(final PrayerSprites sprites, final SpriteManager spriteManager)
	{
		data = new PrayerData(sprites.getPrayer(), false, false, isUnlockedByDefault(sprites.getPrayer()));

		spriteManager.getSpriteAsync(sprites.getUnavailable(), 0, img -> unavailableImage = img);
		spriteManager.getSpriteAsync(sprites.getAvailable(), 0, img ->
		{
			availableImage = img;
			updateActivatedImage();
		});

		spriteManager.getSpriteAsync(SpriteID.ACTIVATED_PRAYER_BACKGROUND, 0, img ->
		{
			activatedImage = img;
			updateActivatedImage();
		});

		setToolTipText(Text.titleCase(sprites.getPrayer()));
		setVerticalAlignment(JLabel.CENTER);
		setHorizontalAlignment(JLabel.CENTER);
		setPreferredSize(SIZE);
		setMaximumSize(SIZE);
		setMinimumSize(SIZE);

		updatePrayerData(data);
	}

	private void updateActivatedImage()
	{
		if (availableImage != null && activatedImage != null)
		{
			activatedImage = ImgUtil.overlapImages(availableImage, activatedImage, false);
			updatePrayerData(data);
		}
	}

	public void updatePrayerData(final PrayerData updatedData)
	{
		if (!data.getPrayer().equals(updatedData.getPrayer()))
		{
			return;
		}

		data = updatedData;

		BufferedImage icon = data.isAvailable() ? availableImage : unavailableImage;
		if (data.isEnabled())
		{
			icon = activatedImage;
		}

		if (icon != null)
		{
			setIcon(new ImageIcon(icon));
		}

		revalidate();
		repaint();
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.partypanel.ui.prayer;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.HashMap;
import java.util.Map;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import thestonedturtle.partypanel.data.PartyPlayer;
import thestonedturtle.partypanel.data.PrayerData;
import thestonedturtle.partypanel.data.Prayers;

public class PlayerPrayerPanel extends JPanel
{
	private static final Dimension PANEL_SIZE = new Dimension(PluginPanel.PANEL_WIDTH - 14, 296);
	private static final Color BACKGROUND = new Color(62, 53, 41);

	private static final int MAX_COLUMNS = 5;

	@Getter
	private final Map<Prayer, PrayerSlot> slotMap = new HashMap<>();
	private final JLabel remainingLabel = new JLabel();
	private final JPanel prayerContainer = new JPanel();

	public PlayerPrayerPanel(final PartyPlayer player, final SpriteManager spriteManager)
	{
		super();

		setLayout(new BorderLayout());

		setBackground(BACKGROUND);
		setPreferredSize(PANEL_SIZE);

		prayerContainer.setLayout(new GridBagLayout());
		prayerContainer.setPreferredSize(new Dimension(PANEL_SIZE.width, PANEL_SIZE.height - 25));
		prayerContainer.setOpaque(false);

		createPrayerSlots(player.getPrayers(), spriteManager);

		add(prayerContainer, BorderLayout.NORTH);
		add(createPrayerRemainingPanel(spriteManager), BorderLayout.SOUTH);
		updatePrayerRemaining(player.getSkillBoostedLevel(Skill.PRAYER), player.getSkillRealLevel(Skill.PRAYER));
	}

	private void createPrayerSlots(final Prayers prayers, final SpriteManager spriteManager)
	{
		for (final PrayerSprites p : PrayerSprites.values())
		{
			final PrayerSlot slot = new PrayerSlot(p, spriteManager);

			if (prayers != null)
			{
				final PrayerData data = prayers.getPrayerData().get(p.getPrayer());
				if (data != null)
				{
					slot.updatePrayerData(data);
				}
			}

			slotMap.put(p.getPrayer(), slot);
		}
		updateSlots();
	}

	private JPanel createPrayerRemainingPanel(final SpriteManager spriteManager)
	{
		final GridBagConstraints c = new GridBagConstraints();
		c.anchor = GridBagConstraints.CENTER;
		c.fill = GridBagConstraints.HORIZONTAL;
		c.gridx = 0;
		c.gridy = 0;
		c.ipady = 4;
		c.gridwidth = 1;

		final JPanel panel = new JPanel();
		panel.setLayout(new GridBagLayout());
		panel.setOpaque(false);
		panel.setPreferredSize(new Dimension(PANEL_SIZE.width, 25));

		final JLabel iconLabel = new JLabel();
		iconLabel.setOpaque(false);
		spriteManager.addSpriteTo(iconLabel, SpriteID.UNKNOWN_PRAYER_ICON, 0);
		iconLabel.setHorizontalAlignment(JLabel.RIGHT);

		remainingLabel.setFont(FontManager.getRunescapeSmallFont());
		remainingLabel.setForeground(ColorScheme.BRAND_ORANGE);
		remainingLabel.setVerticalAlignment(JLabel.CENTER);
		remainingLabel.setHorizontalTextPosition(JLabel.LEFT);
		remainingLabel.setBorder(new EmptyBorder(0, 4, 0, 0));
		remainingLabel.setOpaque(false);

		panel.add(iconLabel, c);
		c.gridx++;
		panel.add(remainingLabel, c);

		return panel;
	}

	public void updatePrayerRemaining(final int remaining, final int maximum)
	{
		remainingLabel.setText(remaining + "/" + maximum);
	}

	public void updateSlots()
	{
		prayerContainer.removeAll();

		final GridBagConstraints c = new GridBagConstraints();
		c.gridx = 0;
		c.gridy = 0;
		c.weighty = .5;
		c.weightx = .5;
		c.ipadx = 2;
		c.ipady = 2;
		c.anchor = GridBagConstraints.CENTER;

		for (final PrayerSprites prayerSprites : PrayerSprites.values())
		{
			final PrayerSlot slot = slotMap.get(prayerSprites.getPrayer());
			if (!slot.getData().isUnlocked())
			{
				continue;

			}

			if (c.gridx == MAX_COLUMNS)
			{
				c.gridx = 0;
				c.gridy++;
			}

			prayerContainer.add(slot, c);
			c.gridx++;
		}
	}
}

package thestonedturtle.partypanel;

import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.inject.Inject;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.Experience;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.Prayer;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.events.PartyMemberAvatar;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.events.UserPart;
import net.runelite.client.party.messages.UserSync;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;
import thestonedturtle.partypanel.data.GameItem;
import thestonedturtle.partypanel.data.PartyPlayer;
import thestonedturtle.partypanel.data.PrayerData;
import thestonedturtle.partypanel.data.Prayers;
import thestonedturtle.partypanel.data.Stats;
import thestonedturtle.partypanel.data.events.PartyBatchedChange;
import thestonedturtle.partypanel.data.events.PartyMiscChange;
import thestonedturtle.partypanel.data.events.PartyStatChange;
import thestonedturtle.partypanel.ui.PlayerPanel;
import thestonedturtle.partypanel.ui.prayer.PrayerSprites;

@Slf4j
@PluginDescriptor(
	name = "Hub Party Panel"
)
public class PartyPanelPlugin extends Plugin
{
	private static final BufferedImage ICON = ImageUtil.loadImageResource(PartyPanelPlugin.class, "icon.png");
	private static final int[] RUNEPOUCH_AMOUNT_VARBITS = {
		Varbits.RUNE_POUCH_AMOUNT1, Varbits.RUNE_POUCH_AMOUNT2, Varbits.RUNE_POUCH_AMOUNT3, Varbits.RUNE_POUCH_AMOUNT4,
		Varbits.RUNE_POUCH_AMOUNT5, Varbits.RUNE_POUCH_AMOUNT6
	};
	private static final int[] RUNEPOUCH_RUNE_VARBITS = {
		Varbits.RUNE_POUCH_RUNE1, Varbits.RUNE_POUCH_RUNE2, Varbits.RUNE_POUCH_RUNE3, Varbits.RUNE_POUCH_RUNE4,
		Varbits.RUNE_POUCH_RUNE5, Varbits.RUNE_POUCH_RUNE6
	};
	public static final int[] RUNEPOUCH_ITEM_IDS = {
		ItemID.RUNE_POUCH, ItemID.RUNE_POUCH_L, ItemID.DIVINE_RUNE_POUCH, ItemID.DIVINE_RUNE_POUCH_L
	};

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Getter
	@Inject
	private PartyPanelConfig config;

	@Inject
	private PartyService partyService;

	@Inject
	private PluginManager pluginManager;

	@Inject
	SpriteManager spriteManager;

	@Inject
	ItemManager itemManager;

	@Inject
	private WSClient wsClient;

	@Provides
	PartyPanelConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PartyPanelConfig.class);
	}

	@Getter
	private final Map<Long, PartyPlayer> partyMembers = new HashMap<>();

	@Getter
	private PartyPlayer myPlayer = null;

	private NavigationButton navButton;
	private boolean addedButton = false;

	private PartyPanel panel;
	private Instant lastLogout;

	// All events should be deferred to the next game tick
	private PartyBatchedChange currentChange = new PartyBatchedChange();

	@Override
	protected void startUp() throws Exception
	{
		panel = new PartyPanel(this);
		navButton = NavigationButton.builder()
			.tooltip("Hub Party Panel")
			.icon(ICON)
			.priority(7)
			.panel(panel)
			.build();

		wsClient.registerMessage(PartyBatchedChange.class);

		if (isInParty() || config.alwaysShowIcon())
		{
			clientToolbar.addNavigation(navButton);
			addedButton = true;
		}

		if (isInParty())
		{
			clientThread.invokeLater(() ->
			{
				myPlayer = new PartyPlayer(partyService.getLocalMember(), client, itemManager, clientThread);
				partyService.send(new UserSync());
				partyService.send(partyPlayerAsBatchedChange());
			});
		}

		final Optional<Plugin> partyPlugin = pluginManager.getPlugins().stream().filter(p -> p.getName().equals("Party")).findFirst();
		if (partyPlugin.isPresent() && !pluginManager.isPluginEnabled(partyPlugin.get()))
		{
			pluginManager.setPluginEnabled(partyPlugin.get(), true);
		}

		lastLogout = Instant.now();
	}

	@Override
	protected void shutDown() throws Exception
	{
		if (isInParty())
		{
			final PartyBatchedChange cleanUserInfo = partyPlayerAsBatchedChange();
			cleanUserInfo.setI(new int[0]);
			cleanUserInfo.setE(new int[0]);
			cleanUserInfo.setM(Collections.emptySet());
			cleanUserInfo.setS(Collections.emptySet());
			cleanUserInfo.setRp(null);
			partyService.send(cleanUserInfo);
		}
		clientToolbar.removeNavigation(navButton);
		addedButton = false;
		partyMembers.clear();
		wsClient.unregisterMessage(PartyBatchedChange.class);
		currentChange = new PartyBatchedChange();
		panel.getPlayerPanelMap().clear();
		lastLogout = null;
	}

	@Subscribe
	protected void onConfigChanged(final ConfigChanged c)
	{
		if (!c.getGroup().equals("partypanel"))
		{
			return;
		}

		if (config.alwaysShowIcon())
		{
			if (!addedButton)
			{
				clientToolbar.addNavigation(navButton);
				addedButton = true;
			}
		}
		else if (addedButton && !isInParty())
		{
			clientToolbar.removeNavigation(navButton);
			addedButton = false;
		}
		addedButton = config.alwaysShowIcon();

		switch (c.getKey())
		{
			case "autoExpandMembers":
				panel.updatePartyMembersExpand(config.autoExpandMembers());
				break;
			case "showPartyControls":
				panel.updatePartyControls();
				break;
			case "showPartyPassphrase":
				panel.syncPartyPassphraseVisibility();
				break;
			case "displayVirtualLevels":
				panel.updateDisplayVirtualLevels();
				break;
			case "displayPlayerWorlds":
				panel.updateDisplayPlayerWorlds();
				break;
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged c)
	{
		if (!isInParty())
		{
			return;
		}

		if (c.getGameState() == GameState.LOGIN_SCREEN)
		{
			lastLogout = Instant.now();
		}

		if (myPlayer == null)
		{
			myPlayer = new PartyPlayer(partyService.getLocalMember(), client, itemManager, clientThread);
			final PartyBatchedChange ce = partyPlayerAsBatchedChange();
			partyService.send(ce);
			return;
		}

		if (c.getGameState() == GameState.LOGGED_IN)
		{
			PartyMiscChange e = new PartyMiscChange(PartyMiscChange.PartyMisc.W, client.getWorld());
			if (myPlayer.getWorld() == e.getV())
			{
				return;
			}

			myPlayer.setWorld(e.getV());
			currentChange.getM().add(e);
		}

		if (c.getGameState() == GameState.LOGIN_SCREEN)
		{
			if (myPlayer.getWorld() == 0)
			{
				return;
			}

			myPlayer.setWorld(0);
			currentChange.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.W, 0));

			partyService.send(currentChange);
			currentChange = new PartyBatchedChange();
		}
	}

	public boolean isInParty()
	{
		return partyService.isInParty();
	}

	public boolean isLocalPlayer(long id)
	{
		return partyService.getLocalMember() != null && partyService.getLocalMember().getMemberId() == id;
	}

	@Subscribe
	public void onUserPart(final UserPart event)
	{
		final PartyPlayer removed = partyMembers.remove(event.getMemberId());
		if (removed != null)
		{
			SwingUtilities.invokeLater(() -> panel.removePartyPlayer(removed));
		}

		if (addedButton && (!isInParty() || partyService.getMembers().size() == 0) && !config.alwaysShowIcon())
		{
			clientToolbar.removeNavigation(navButton);
			addedButton = false;
		}
	}

	@Subscribe
	public void onUserSync(final UserSync event)
	{
		if (!addedButton)
		{
			clientToolbar.addNavigation(navButton);
			addedButton = true;
		}

		if (myPlayer != null)
		{
			final PartyBatchedChange c = partyPlayerAsBatchedChange();
			if (c.isValid())
			{
				partyService.send(c);
			}
			return;
		}

		clientThread.invoke(() ->
		{
			myPlayer = new PartyPlayer(partyService.getLocalMember(), client, itemManager, clientThread);
			final PartyBatchedChange c = partyPlayerAsBatchedChange();
			if (c.isValid())
			{
				partyService.send(c);
			}
		});
	}

	@Subscribe
	public void onPartyChanged(final PartyChanged event)
	{
		partyMembers.clear();
		SwingUtilities.invokeLater(() ->
		{
			panel.clearSidebar();
			panel.renderSidebar();
		});
		myPlayer = null;

		panel.updateParty();

		if (!isInParty())
		{
			if (!config.alwaysShowIcon())
			{
				clientToolbar.removeNavigation(navButton);
				addedButton = false;
			}

			panel.getPlayerPanelMap().clear();
			return;
		}
		else if (!addedButton)
		{
			clientToolbar.addNavigation(navButton);
			addedButton = true;
		}

		config.setPreviousPartyId(event.getPassphrase());
	}

	@Subscribe
	public void onGameTick(final GameTick tick)
	{
		if (!isInParty() || client.getLocalPlayer() == null || partyService.getLocalMember() == null)
		{
			return;
		}

		// To reduce server load we should only process changes every X ticks
		if (client.getTickCount() % messageFreq(partyService.getMembers().size()) != 0)
		{
			return;
		}

		// First time logging in or they changed accounts so resend the entire player object
		if (myPlayer == null || !Objects.equals(client.getLocalPlayer().getName(), myPlayer.getUsername()))
		{
			myPlayer = new PartyPlayer(partyService.getLocalMember(), client, itemManager, clientThread);
			final PartyBatchedChange c = partyPlayerAsBatchedChange();
			partyService.send(c);
			return;
		}

		if (myPlayer.getStats() == null)
		{
			myPlayer.updatePlayerInfo(client, itemManager);

			for (final Skill s : Skill.values())
			{
				currentChange.getS().add(myPlayer.getStats().createPartyStatChangeForSkill(s));
			}
		}
		else
		{
			// We only need to check energy every tick as the special attack and stat levels are handled in their respective events
			final int energy = (client.getEnergy() / 100);
			if (myPlayer.getStats().getRunEnergy() != energy)
			{
				myPlayer.getStats().setRunEnergy(energy);
				currentChange.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.R, energy));
			}
		}

		if (myPlayer.getPrayers() == null)
		{
			myPlayer.setPrayers(new Prayers(client));
			final Collection<Prayer> available = new ArrayList<>();
			final Collection<Prayer> enabled = new ArrayList<>();
			final Collection<Prayer> unlocked = new ArrayList<>();
			for (final PrayerSprites p : PrayerSprites.values())
			{
				final PrayerData data = myPlayer.getPrayers().getPrayerData().get(p.getPrayer());
				if (data.isAvailable())
				{
					available.add(p.getPrayer());
				}

				if (data.isEnabled())
				{
					enabled.add(p.getPrayer());
				}

				if (data.isUnlocked())
				{
					unlocked.add(p.getPrayer());
				}
			}

			currentChange.setAp(PartyBatchedChange.pack(available));
			currentChange.setEp(PartyBatchedChange.pack(enabled));
			currentChange.setUp(PartyBatchedChange.pack(unlocked));
		}
		else
		{
			final Collection<Prayer> available = new ArrayList<>();
			final Collection<Prayer> enabled = new ArrayList<>();
			final Collection<Prayer> unlocked = new ArrayList<>();
			boolean change = false;
			for (final PrayerSprites p : PrayerSprites.values())
			{
				change = myPlayer.getPrayers().updatePrayerState(p, client) || change;

				// Store the data for this prayer regardless of if it changes since any update
				// will assume all prayers are not available & disabled
				final PrayerData data = myPlayer.getPrayers().getPrayerData().get(p.getPrayer());
				if (data.isAvailable())
				{
					available.add(p.getPrayer());
				}

				if (data.isEnabled())
				{
					enabled.add(p.getPrayer());
				}
			}

			// Send both arrays as bit-packed ints whenever any prayer has changed.
			if (change)
			{
				currentChange.setAp(PartyBatchedChange.pack(available));
				currentChange.setEp(PartyBatchedChange.pack(enabled));
				currentChange.setUp(PartyBatchedChange.pack(unlocked));
			}
		}

		if (currentChange.isValid())
		{
			currentChange.setMemberId(partyService.getLocalMember().getMemberId()); // Add member ID before sending
			currentChange.removeDefaults();
			partyService.send(currentChange);

			currentChange = new PartyBatchedChange();
		}
	}

	@Subscribe
	public void onStatChanged(final StatChanged event)
	{
		if (myPlayer == null || myPlayer.getStats() == null || !isInParty())
		{
			return;
		}

		// Always store the players "real" level using their virtual level so when they change the config the data still exists
		final Skill s = event.getSkill();
		if (myPlayer.getSkillBoostedLevel(s) == event.getBoostedLevel() &&
			Experience.getLevelForXp(event.getXp()) == myPlayer.getSkillRealLevel(s))
		{
			return;
		}

		final int virtualLvl = Experience.getLevelForXp(event.getXp());

		myPlayer.setSkillsBoostedLevel(event.getSkill(), event.getBoostedLevel());
		myPlayer.setSkillsRealLevel(event.getSkill(), virtualLvl);

		currentChange.getS().add(new PartyStatChange(event.getSkill().ordinal(), virtualLvl, event.getBoostedLevel()));

		// Total level change
		if (myPlayer.getStats().getTotalLevel() != client.getTotalLevel())
		{
			myPlayer.getStats().setTotalLevel(client.getTotalLevel());
			currentChange.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.T, myPlayer.getStats().getTotalLevel()));
		}

		// Combat level change
		final int oldCombatLevel = myPlayer.getStats().getCombatLevel();
		myPlayer.getStats().recalculateCombatLevel();
		if (myPlayer.getStats().getCombatLevel() != oldCombatLevel)
		{
			currentChange.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.C, myPlayer.getStats().getCombatLevel()));
		}
	}

	@Subscribe
	public void onItemContainerChanged(final ItemContainerChanged c)
	{
		if (myPlayer == null || !isInParty())
		{
			return;
		}

		if (c.getContainerId() == InventoryID.INVENTORY.getId())
		{
			final ItemContainer inventory = c.getItemContainer();
			myPlayer.setInventory(GameItem.convertItemsToGameItems(inventory.getItems(), itemManager));
			int[] items = convertItemsToArray(c.getItemContainer().getItems());
			currentChange.setI(items);

			if (itemContainerHasRunePouch(inventory))
			{
				final List<Item> runesInPouch = getRunePouchContents(client);
				myPlayer.setRunesInPouch(GameItem.convertItemsToGameItems(runesInPouch.toArray(Item[]::new), itemManager));
				currentChange.setRp(convertRunePouchContentsToPackedInts(runesInPouch));
			}
		}
		else if (c.getContainerId() == InventoryID.EQUIPMENT.getId())
		{
			myPlayer.setEquipment(GameItem.convertItemsToGameItems(c.getItemContainer().getItems(), itemManager));
			int[] items = convertItemsToArray(c.getItemContainer().getItems());
			currentChange.setE(items);
		}
	}

	private static boolean itemContainerHasRunePouch(ItemContainer inventory)
	{
		for (final int id : RUNEPOUCH_ITEM_IDS)
		{
			if (inventory.contains(id))
			{
				return true;
			}
		}
		return false;
	}

	public int[] convertRunePouchContentsToPackedInts(final List<Item> runesInPouch)
	{
		return runesInPouch.stream()
			.mapToInt(PartyBatchedChange::packRune)
			.toArray();
	}

	public static List<Item> getRunePouchContents(Client client)
	{
		final EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
		final List<Item> items = new ArrayList<>();
		for (int i = 0; i < RUNEPOUCH_AMOUNT_VARBITS.length; i++)
		{
			@Varbit int amount = client.getVarbitValue(RUNEPOUCH_AMOUNT_VARBITS[i]);
			if (amount <= 0)
			{
				continue;
			}

			@Varbit int runeId = client.getVarbitValue(RUNEPOUCH_RUNE_VARBITS[i]);
			if (runeId == 0)
			{
				continue;
			}

			final int itemId = runepouchEnum.getIntValue(runeId);
			items.add(new Item(itemId, amount));
		}

		return items;
	}

	@Subscribe
	public void onVarbitChanged(final VarbitChanged event)
	{
		if (myPlayer == null || myPlayer.getStats() == null || !isInParty())
		{
			return;
		}

		final int specialPercent = client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) / 10;
		if (specialPercent != myPlayer.getStats().getSpecialPercent())
		{
			myPlayer.getStats().setSpecialPercent(specialPercent);
			currentChange.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.S, specialPercent));
		}

		final int stamina = client.getVarbitValue(Varbits.STAMINA_EFFECT);
		if (stamina != myPlayer.getStamina())
		{
			myPlayer.setStamina(stamina);
			currentChange.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.ST, stamina));
		}

		final int poison = client.getVarpValue(VarPlayer.POISON);
		if (poison != myPlayer.getPoison())
		{
			myPlayer.setPoison(poison);
			currentChange.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.P, poison));
		}

		final int disease = client.getVarpValue(VarPlayer.DISEASE_VALUE);
		if (disease != myPlayer.getDisease())
		{
			myPlayer.setDisease(disease);
			currentChange.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.D, disease));
		}

		if (ArrayUtils.contains(RUNEPOUCH_RUNE_VARBITS, event.getVarbitId()) || ArrayUtils.contains(RUNEPOUCH_AMOUNT_VARBITS, event.getVarbitId()))
		{
			List<Item> runePouchContents = getRunePouchContents(client);
			myPlayer.setRunesInPouch(GameItem.convertItemsToGameItems(runePouchContents.toArray(Item[]::new), itemManager));
			currentChange.setRp(convertRunePouchContentsToPackedInts(runePouchContents));
		}
	}

	@Subscribe
	public void onPartyBatchedChange(PartyBatchedChange e)
	{
		if (isLocalPlayer(e.getMemberId()))
		{
			return;
		}

		// create new PartyPlayer for this member if they don't already exist
		final PartyPlayer player = partyMembers.computeIfAbsent(e.getMemberId(), k -> new PartyPlayer(partyService.getMemberById(e.getMemberId())));

		// Create placeholder stats object
		if (player.getStats() == null && e.hasStatChange())
		{
			player.setStats(new Stats());
		}

		// Create placeholder prayer object
		if (player.getPrayers() == null && (e.getAp() != null || e.getEp() != null || e.getUp() != null))
		{
			player.setPrayers(new Prayers());
		}
		clientThread.invoke(() ->
		{
			e.process(player, itemManager);

			SwingUtilities.invokeLater(() ->
			{
				panel.drawPlayerPanel(player, e.hasBreakingBannerChange());
			});
		});
	}

	@Subscribe
	public void onPartyMemberAvatar(PartyMemberAvatar e)
	{
		if (isLocalPlayer(e.getMemberId()) || partyMembers.get(e.getMemberId()) == null)
		{
			return;
		}

		final PartyPlayer player = partyMembers.get(e.getMemberId());
		player.getMember().setAvatar(e.getImage());
		SwingUtilities.invokeLater(() ->
		{
			final PlayerPanel p = panel.getPlayerPanelMap().get(e.getMemberId());
			if (p != null)
			{
				p.getBanner().refreshStats();
			}
		});
	}

	public void changeParty(String passphrase)
	{
		passphrase = passphrase.replace(" ", "-").trim();
		if (passphrase.length() == 0)
		{
			return;
		}

		for (int i = 0; i < passphrase.length(); ++i)
		{
			char ch = passphrase.charAt(i);
			if (!Character.isLetter(ch) && !Character.isDigit(ch) && ch != '-')
			{
				JOptionPane.showMessageDialog(panel.getControlsPanel(),
					"Party passphrase must be a combination of alphanumeric or hyphen characters.",
					"Invalid party passphrase",
					JOptionPane.ERROR_MESSAGE);
				return;
			}
		}

		partyService.changeParty(passphrase);
		panel.updateParty();
	}

	public void createParty()
	{
		// Create party
		clientThread.invokeLater(() -> changeParty(partyService.generatePassphrase()));
	}

	public String getPartyPassphrase()
	{
		return partyService.getPartyPassphrase();
	}

	public void leaveParty()
	{
		partyService.changeParty(null);
		panel.updateParty();
	}

	private int[] convertItemsToArray(Item[] items)
	{
		int[] eles = new int[items.length * 2];
		for (int i = 0; i < items.length * 2; i += 2)
		{
			if (items[i / 2] == null)
			{
				eles[i] = -1;
				eles[i + 1] = 0;
				continue;
			}

			eles[i] = items[i / 2].getId();
			eles[i + 1] = items[i / 2].getQuantity();
		}

		return eles;
	}

	private int[] convertGameItemsToArray(GameItem[] items)
	{
		int[] eles = new int[items.length * 2];
		for (int i = 0; i < items.length * 2; i += 2)
		{
			if (items[i / 2] == null)
			{
				eles[i] = -1;
				eles[i + 1] = 0;
				continue;
			}

			eles[i] = items[i / 2].getId();
			eles[i + 1] = items[i / 2].getQty();
		}

		return eles;
	}

	public PartyBatchedChange partyPlayerAsBatchedChange()
	{
		final PartyBatchedChange c = new PartyBatchedChange();
		if (myPlayer == null)
		{
			return c;
		}

		// Inventories
		c.setI(convertGameItemsToArray(myPlayer.getInventory()));
		c.setE(convertGameItemsToArray(myPlayer.getEquipment()));

		// Stats
		if (myPlayer.getStats() != null)
		{
			for (final Skill s : Skill.values())
			{
				c.getS().add(myPlayer.getStats().createPartyStatChangeForSkill(s));
			}

			c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.S, myPlayer.getStats().getSpecialPercent()));
			c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.R, myPlayer.getStats().getRunEnergy()));
			c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.C, myPlayer.getStats().getCombatLevel()));
			c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.T, myPlayer.getStats().getTotalLevel()));
		}

		// Misc
		c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.ST, myPlayer.getStamina()));
		c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.P, myPlayer.getPoison()));
		c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.D, myPlayer.getDisease()));
		c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.W, myPlayer.getWorld()));

		// Prayers
		if (myPlayer.getPrayers() != null)
		{
			final Collection<Prayer> available = new ArrayList<>();
			final Collection<Prayer> enabled = new ArrayList<>();
			final Collection<Prayer> unlocked = new ArrayList<>();
			for (final PrayerSprites p : PrayerSprites.values())
			{
				final PrayerData data = myPlayer.getPrayers().getPrayerData().get(p.getPrayer());
				if (data.isAvailable())
				{
					available.add(p.getPrayer());
				}

				if (data.isEnabled())
				{
					enabled.add(p.getPrayer());
				}

				if (data.isUnlocked())
				{
					unlocked.add(p.getPrayer());
				}
			}

			c.setAp(PartyBatchedChange.pack(available));
			c.setEp(PartyBatchedChange.pack(enabled));
			c.setUp(PartyBatchedChange.pack(unlocked));
		}

		c.getM().add(new PartyMiscChange(PartyMiscChange.PartyMisc.U, myPlayer.getUsername()));

		if (client.isClientThread())
		{
			c.setRp(convertRunePouchContentsToPackedInts(getRunePouchContents(client)));
		}

		c.setMemberId(partyService.getLocalMember().getMemberId()); // Add member ID before sending
		c.removeDefaults();

		return c;
	}

	@Schedule(
		period = 10,
		unit = ChronoUnit.SECONDS
	)
	public void checkIdle()
	{
		if (client.getGameState() != GameState.LOGIN_SCREEN)
		{
			return;
		}

		if (lastLogout != null && lastLogout.isBefore(Instant.now().minus(30, ChronoUnit.MINUTES))
			&& partyService.isInParty())
		{
			log.info("Leaving party due to inactivity");
			partyService.changeParty(null);
		}
	}

	private static int messageFreq(int partySize)
	{
		// introduce a tick delay for each member >6
		// Default the message frequency to every 2 ticks since this plugin sends a lot of data
		return Math.max(2, partySize - 6);
	}
}

package thestonedturtle.partypanel;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PartyPanelPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PartyPanelPlugin.class);
		RuneLite.main(args);
	}
}
