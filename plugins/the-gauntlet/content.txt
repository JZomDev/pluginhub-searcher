package ca.gauntlet;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TheGauntletPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TheGauntletPlugin.class);
		RuneLite.main(args);
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.maze;

import ca.gauntlet.TheGauntletConfig;
import ca.gauntlet.TheGauntletPlugin;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Collection;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
class MinimapOverlay extends Overlay
{
	private final TheGauntletConfig config;
	private final MazeModule mazeModule;
	private final ResourceManager resourceManager;

	@Inject
	MinimapOverlay(
		final TheGauntletPlugin plugin,
		final TheGauntletConfig config,
		final MazeModule mazeModule,
		final ResourceManager resourceManager)
	{
		super(plugin);

		this.config = config;
		this.mazeModule = mazeModule;
		this.resourceManager = resourceManager;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		if (config.minimapResourceOverlay())
		{
			renderMinimapResourceIcons(graphics2D, mazeModule.getResourceGameObjects());
		}

		if (config.minimapDemibossOverlay())
		{
			renderMinimapNPCIcons(graphics2D, mazeModule.getDemiBosses());
		}

		return null;
	}

	private void renderMinimapNPCIcons(final Graphics2D graphics2D, final Collection<Demiboss> demiBosses)
	{
		if (demiBosses.isEmpty())
		{
			return;
		}

		for (final Demiboss demiboss : demiBosses)
		{
			final Point point = demiboss.getMinimapPoint();

			if (point == null)
			{
				continue;
			}

			OverlayUtil.renderImageLocation(graphics2D, point, demiboss.getMinimapIcon());
		}
	}

	private void renderMinimapResourceIcons(final Graphics2D graphics2D, final Collection<ResourceGameObject> resourceGameObjects)
	{
		if (resourceGameObjects.isEmpty())
		{
			return;
		}

		for (final ResourceGameObject resourceGameObject : resourceGameObjects)
		{
			if (config.resourceTracker() &&
				config.resourceRemoveOutlineOnceAcquired() &&
				resourceManager.hasAcquired(resourceGameObject.getResource()))
			{
				continue;
			}

			final Point point = resourceGameObject.getMinimapPoint();

			if (point == null)
			{
				continue;
			}

			OverlayUtil.renderImageLocation(graphics2D, point, resourceGameObject.getMinimapIcon());
		}
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.maze;

import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Point;
import net.runelite.api.Skill;
import net.runelite.client.game.SkillIconManager;

class Demiboss
{
	private final NPC npc;

	@Getter(AccessLevel.PACKAGE)
	private final BufferedImage minimapIcon;

	Demiboss(@NonNull final NPC npc, @NonNull final SkillIconManager skillIconManager)
	{
		this.npc = npc;
		minimapIcon = getIcon(npc, skillIconManager);
	}

	boolean isNpc(final NPC npc)
	{
		return this.npc == npc;
	}

	@Nullable
	Point getMinimapPoint()
	{
		final Point point = npc.getMinimapLocation();

		if (point == null)
		{
			return null;
		}

		return new Point(point.getX() - minimapIcon.getHeight() / 2, point.getY() - minimapIcon.getWidth() / 2);
	}

	private static BufferedImage getIcon(final NPC npc, final SkillIconManager skillIconManager)
	{
		switch (npc.getId())
		{
			case NpcID.CRYSTALLINE_BEAR:
			case NpcID.CORRUPTED_BEAR:
				return skillIconManager.getSkillImage(Skill.ATTACK, true);
			case NpcID.CRYSTALLINE_DARK_BEAST:
			case NpcID.CORRUPTED_DARK_BEAST:
				return skillIconManager.getSkillImage(Skill.RANGED, true);
			case NpcID.CRYSTALLINE_DRAGON:
			case NpcID.CORRUPTED_DRAGON:
				return skillIconManager.getSkillImage(Skill.MAGIC, true);
			default:
				throw new IllegalArgumentException("Unsupported npc id: " + npc.getId());
		}
	}

	@Override
	public boolean equals(final Object o)
	{
		if (this == o)
		{
			return true;
		}

		if (!(o instanceof Demiboss))
		{
			return false;
		}

		final Demiboss that = (Demiboss) o;
		return npc.equals(that.npc);
	}

	@Override
	public int hashCode()
	{
		return npc.hashCode();
	}

	@Override
	public String toString()
	{
		return "Demiboss{npc=" + npc + '}';
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * Copyright (c) 2020, Anthony Alves
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.maze;

import java.util.AbstractMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.ItemID;

public enum Resource
{
	TELEPORT_CRYSTAL("Teleport crystal", ItemID.TELEPORT_CRYSTAL, false),
	CORRUPTED_TELEPORT_CRYSTAL("Corrupted teleport crystal", ItemID.CORRUPTED_TELEPORT_CRYSTAL, true),

	WEAPON_FRAME("Weapon frame", ItemID.WEAPON_FRAME_23871, false),
	CORRUPTED_WEAPON_FRAME("Weapon frame", ItemID.WEAPON_FRAME, true),

	CRYSTALLINE_BOWSTRING("Crystalline bowstring", ItemID.CRYSTALLINE_BOWSTRING, false),
	CORRUPTED_BOWSTRING("Corrupted bowstring", ItemID.CORRUPTED_BOWSTRING, true),

	CRYSTAL_SPIKE("Crystal spike", ItemID.CRYSTAL_SPIKE, false),
	CORRUPTED_SPIKE("Corrupted spike", ItemID.CORRUPTED_SPIKE, true),

	CRYSTAL_ORB("Crystal orb", ItemID.CRYSTAL_ORB, false),
	CORRUPTED_ORB("Corrupted orb", ItemID.CORRUPTED_ORB, true),

	RAW_PADDLEFISH("Raw paddlefish", ItemID.RAW_PADDLEFISH, "You manage to catch a fish\\.", false),

	CRYSTAL_SHARDS("Crystal shards", ItemID.CRYSTAL_SHARDS, "You find (\\d+) crystal shards\\.", false),
	CORRUPTED_SHARDS("Corrupted shards", ItemID.CORRUPTED_SHARDS, "You find (\\d+) corrupted shards\\.", true),

	CRYSTAL_ORE("Crystal ore", ItemID.CRYSTAL_ORE, "You manage to mine some ore\\.", false),
	CORRUPTED_ORE("Corrupted ore", ItemID.CORRUPTED_ORE, "You manage to mine some ore\\.", true),

	PHREN_BARK("Phren bark", ItemID.PHREN_BARK_23878, "You get some bark\\.", false),
	CORRUPTED_PHREN_BARK("Phren bark", ItemID.PHREN_BARK, "You get some bark\\.", true),

	LINUM_TIRINUM("Linum tirinum", ItemID.LINUM_TIRINUM_23876, "You pick some fibre from the plant\\.", false),
	CORRUPTED_LINUM_TIRINUM("Linum tirinum", ItemID.LINUM_TIRINUM, "You pick some fibre from the plant\\.", true),

	GRYM_LEAF("Grym leaf", ItemID.GRYM_LEAF_23875, "You pick a herb from the roots\\.", false),
	CORRUPTED_GRYM_LEAF("Grym leaf", ItemID.GRYM_LEAF, "You pick a herb from the roots\\.", true);

	private static final Resource[] VALUES = Resource.values();

	private final String name;
	@Getter(AccessLevel.PACKAGE)
	private final int itemId;
	private final Pattern pattern;
	private final boolean corrupted;

	Resource(final String name, final int itemId, final String pattern, final boolean corrupted)
	{
		this.name = name;
		this.itemId = itemId;
		this.corrupted = corrupted;
		this.pattern = pattern != null ? Pattern.compile(pattern) : null;
	}

	Resource(final String name, final int itemId, final boolean corrupted)
	{
		this(name, itemId, null, corrupted);
	}

	static Resource fromName(final String name, final boolean corrupted)
	{
		for (final Resource resource : VALUES)
		{
			if ((resource.corrupted == corrupted || resource == RAW_PADDLEFISH) &&
				resource.name.equals(name))
			{
				return resource;
			}
		}

		return null;
	}

	static AbstractMap.Entry<Resource, Integer> fromPattern(final String pattern, final boolean corrupted)
	{
		for (final Resource resource : VALUES)
		{
			if (resource.pattern == null ||
				(corrupted != resource.corrupted && resource != Resource.RAW_PADDLEFISH))
			{
				continue;
			}

			final Matcher matcher = resource.pattern.matcher(pattern);

			if (!matcher.matches())
			{
				continue;
			}

			final int itemCount = matcher.groupCount() == 1 ? Integer.parseInt(matcher.group(1)) : 1;

			return new AbstractMap.SimpleImmutableEntry<>(resource, itemCount);
		}

		return null;
	}

	@Override
	public String toString()
	{
		return this.name;
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * Copyright (c) 2019, ganom <https://github.com/Ganom>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.maze;

import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.GameObject;
import net.runelite.api.ObjectID;
import net.runelite.api.Point;
import net.runelite.api.Skill;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.util.ImageUtil;

class ResourceGameObject
{
	private static final int DEFAULT_ICON_SIZE = 14;

	@Getter(AccessLevel.PACKAGE)
	private final Resource resource;
	@Getter(AccessLevel.PACKAGE)
	private final GameObject gameObject;
	private final BufferedImage originalIcon;
	@Getter(AccessLevel.PACKAGE)
	private final BufferedImage minimapIcon;
	private BufferedImage icon;
	private int iconSize;

	ResourceGameObject(
		@NonNull final GameObject gameObject,
		@NonNull final SkillIconManager skillIconManager,
		final int iconSize)
	{
		this.gameObject = gameObject;
		this.iconSize = iconSize;
		this.resource = getResourceByObjectId(gameObject.getId());

		originalIcon = getOriginalIcon(resource, skillIconManager, false);
		minimapIcon = getOriginalIcon(resource, skillIconManager, true);
	}

	void setIconSize(final int iconSize)
	{
		this.iconSize = iconSize;
		final int size = iconSize <= 0 ? DEFAULT_ICON_SIZE : iconSize;
		icon = ImageUtil.resizeImage(originalIcon, size, size);
	}

	BufferedImage getIcon()
	{
		if (icon == null)
		{
			final int size = iconSize <= 0 ? DEFAULT_ICON_SIZE : iconSize;
			icon = ImageUtil.resizeImage(originalIcon, size, size);
		}

		return icon;
	}

	@Nullable
	Point getMinimapPoint()
	{
		final Point point = gameObject.getMinimapLocation();

		if (point == null)
		{
			return null;
		}

		return new Point(point.getX() - minimapIcon.getHeight() / 2, point.getY() - minimapIcon.getWidth() / 2);
	}

	private static BufferedImage getOriginalIcon(final Resource resource,
												 final SkillIconManager skillIconManager,
												 final boolean small)
	{
		switch (resource)
		{
			case RAW_PADDLEFISH:
				return skillIconManager.getSkillImage(Skill.FISHING, small);
			case CRYSTAL_ORE:
			case CORRUPTED_ORE:
				return skillIconManager.getSkillImage(Skill.MINING, small);
			case PHREN_BARK:
			case CORRUPTED_PHREN_BARK:
				return skillIconManager.getSkillImage(Skill.WOODCUTTING, small);
			case LINUM_TIRINUM:
			case CORRUPTED_LINUM_TIRINUM:
				return skillIconManager.getSkillImage(Skill.FARMING, small);
			case GRYM_LEAF:
			case CORRUPTED_GRYM_LEAF:
				return skillIconManager.getSkillImage(Skill.HERBLORE, small);
			default:
				throw new IllegalArgumentException("Unsupported resource: " + resource);
		}
	}

	private static Resource getResourceByObjectId(final int objectId)
	{
		switch (objectId)
		{
			case ObjectID.CRYSTAL_DEPOSIT:
				return Resource.CRYSTAL_ORE;
			case ObjectID.CORRUPT_DEPOSIT:
				return Resource.CORRUPTED_ORE;
			case ObjectID.PHREN_ROOTS:
				return Resource.PHREN_BARK;
			case ObjectID.CORRUPT_PHREN_ROOTS:
				return Resource.CORRUPTED_PHREN_BARK;
			case ObjectID.LINUM_TIRINUM:
				return Resource.LINUM_TIRINUM;
			case ObjectID.CORRUPT_LINUM_TIRINUM:
				return Resource.CORRUPTED_LINUM_TIRINUM;
			case ObjectID.GRYM_ROOT:
				return Resource.GRYM_LEAF;
			case ObjectID.CORRUPT_GRYM_ROOT:
				return Resource.CORRUPTED_GRYM_LEAF;
			case ObjectID.CORRUPT_FISHING_SPOT:
			case ObjectID.FISHING_SPOT_36068:
				return Resource.RAW_PADDLEFISH;
			default:
				throw new IllegalArgumentException("Unsupported game object id: " + objectId);
		}
	}

	@Override
	public boolean equals(final Object o)
	{
		if (this == o)
		{
			return true;
		}

		if (!(o instanceof ResourceGameObject))
		{
			return false;
		}

		final ResourceGameObject that = (ResourceGameObject) o;
		return gameObject.equals(that.gameObject);
	}

	@Override
	public int hashCode()
	{
		return gameObject.hashCode();
	}

	@Override
	public String toString()
	{
		return "SkillResource{resource=" + resource + ", gameObject=" + gameObject + '}';
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * Copyright (c) 2020, Anthony Alves
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.maze;

import ca.gauntlet.TheGauntletConfig;
import ca.gauntlet.TheGauntletConfig.TrackingMode;
import ca.gauntlet.TheGauntletPlugin;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.AbstractMap;
import java.util.EnumMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
class ResourceManager
{
	private static final Pattern PATTERN_RESOURCE_DROP = Pattern.compile("^.+ drop:\\s+((?<quantity>\\d+) x )?(?<name>.+)$");
	private static final int SHARD_COUNT_BREAK_DOWN = 80;
	private final EnumMap<Resource, ResourceCounter> counterByResource = new EnumMap<>(Resource.class);

	@Inject
	private TheGauntletPlugin plugin;
	@Inject
	private TheGauntletConfig config;
	@Inject
	private ItemManager itemManager;
	@Inject
	private InfoBoxManager infoBoxManager;

	private Region region = Region.UNKNOWN;

	void init(final int regionId)
	{
		region = Region.fromId(regionId);

		if (region != Region.UNKNOWN && config.resourceTracker())
		{
			createResourceCountersFromConfig();
		}
	}

	void reset()
	{
		region = Region.UNKNOWN;
		counterByResource.clear();
		infoBoxManager.removeIf(ResourceCounter.class::isInstance);
	}

	void parseChatMessage(final String chatMessage)
	{
		if (!config.resourceTracker() || region == Region.UNKNOWN)
		{
			return;
		}

		if (chatMessage.charAt(0) == '<')
		{
			// Loot drops always start with a color tag
			// e.g. <col=005f00>Player recieved a drop: ...
			// e.g. <col=ef1020>Untradeable drop: ...
			parseNpcChatMessage(chatMessage);
		}
		else
		{
			parseSkillChatMessage(chatMessage);
		}
	}

	boolean hasAcquired(final Resource resource)
	{
		final ResourceCounter resourceCounter = counterByResource.get(resource);
		return resourceCounter == null ? config.resourceRemoveAcquired() : resourceCounter.hasAcquiredTarget();
	}

	private void parseNpcChatMessage(final String message)
	{
		final String noTagsMessage = Text.removeTags(message);

		final Matcher matcher = PATTERN_RESOURCE_DROP.matcher(noTagsMessage);

		if (!matcher.matches())
		{
			return;
		}

		final String name = matcher.group("name");

		if (name == null)
		{
			return;
		}

		final Resource resource = Resource.fromName(name, region == Region.CORRUPTED);

		if (resource == null)
		{
			return;
		}

		final String quantity = matcher.group("quantity");

		final int count = quantity != null ? Integer.parseInt(quantity) : 1;

		updateResourceCounter(resource, count);
	}

	private void parseSkillChatMessage(final String message)
	{
		if (message.startsWith("break down", 4))
		{
			final Resource resource = region == Region.CORRUPTED ?
				Resource.CORRUPTED_SHARDS : Resource.CRYSTAL_SHARDS;

			updateResourceCounter(resource, SHARD_COUNT_BREAK_DOWN);
			return;
		}

		final AbstractMap.Entry<Resource, Integer> mapping = Resource.fromPattern(message, region == Region.CORRUPTED);

		if (mapping == null)
		{
			return;
		}

		updateResourceCounter(mapping.getKey(), mapping.getValue());
	}

	private void updateResourceCounter(final Resource resource, final int count)
	{
		final ResourceCounter resourceCounter = counterByResource.get(resource);

		if (resourceCounter == null)
		{
			return;
		}

		resourceCounter.updateCount(count);

		if (config.resourceRemoveAcquired() && resourceCounter.hasAcquiredTarget())
		{
			counterByResource.remove(resource);
			infoBoxManager.removeInfoBox(resourceCounter);
		}
	}

	private void createResourceCounter(final Resource resource, final int count)
	{
		if (count <= 0)
		{
			return;
		}

		final boolean decrement = config.resourceTrackingMode() == TrackingMode.DECREMENT;

		final ResourceCounter resourceCounter = new ResourceCounter(
			itemManager.getImage(resource.getItemId()),
			plugin,
			resource,
			decrement ? count : 0,
			decrement ? 0 : count
		);

		counterByResource.put(resource, resourceCounter);
		infoBoxManager.addInfoBox(resourceCounter);
	}

	private void createResourceCountersFromConfig()
	{
		final boolean corrupted = region == Region.CORRUPTED;
		createResourceCounter(corrupted ? Resource.CORRUPTED_ORE : Resource.CRYSTAL_ORE, config.resourceOre());
		createResourceCounter(corrupted ? Resource.CORRUPTED_PHREN_BARK : Resource.PHREN_BARK, config.resourceBark());
		createResourceCounter(corrupted ? Resource.CORRUPTED_LINUM_TIRINUM : Resource.LINUM_TIRINUM, config.resourceTirinum());
		createResourceCounter(corrupted ? Resource.CORRUPTED_GRYM_LEAF : Resource.GRYM_LEAF, config.resourceGrym());
		createResourceCounter(corrupted ? Resource.CORRUPTED_WEAPON_FRAME : Resource.WEAPON_FRAME, config.resourceFrame());
		createResourceCounter(Resource.RAW_PADDLEFISH, config.resourcePaddlefish());
		createResourceCounter(corrupted ? Resource.CORRUPTED_SHARDS : Resource.CRYSTAL_SHARDS, config.resourceShard());
		createResourceCounter(corrupted ? Resource.CORRUPTED_BOWSTRING : Resource.CRYSTALLINE_BOWSTRING, config.resourceBowstring() ? 1 : 0);
		createResourceCounter(corrupted ? Resource.CORRUPTED_SPIKE : Resource.CRYSTAL_SPIKE, config.resourceSpike() ? 1 : 0);
		createResourceCounter(corrupted ? Resource.CORRUPTED_ORB : Resource.CRYSTAL_ORB, config.resourceOrb() ? 1 : 0);
	}

	private enum Region
	{
		NORMAL,
		CORRUPTED,
		UNKNOWN;

		private static Region fromId(final int id)
		{
			switch (id)
			{
				case 7512:
					return NORMAL;
				case 7768:
					return CORRUPTED;
				default:
					return UNKNOWN;
			}
		}
	}

	private static class ResourceCounter extends InfoBox
	{
		private final int target;
		private int count;
		private String text;
		private Color color = Color.WHITE;

		private ResourceCounter(
			final BufferedImage bufferedImage,
			final TheGauntletPlugin plugin,
			final Resource resource,
			final int count,
			final int target)
		{
			super(bufferedImage, plugin);
			setPriority(getPriority(resource));
			this.count = count;
			this.target = Math.max(0, target);
			this.text = String.valueOf(count);
		}

		@Override
		public String getText()
		{
			return text;
		}

		@Override
		public Color getTextColor()
		{
			return color;
		}

		private void updateCount(final int count)
		{
			if (target == 0)
			{
				this.count = Math.max(0, this.count - count);
			}
			else
			{
				this.count += count;
			}

			if (hasAcquiredTarget())
			{
				color = Color.GRAY;
			}

			text = String.valueOf(this.count);
		}

		private boolean hasAcquiredTarget()
		{
			return target == 0 ? count <= target : count >= target;
		}

		private static InfoBoxPriority getPriority(final Resource resource)
		{
			switch (resource)
			{
				case CRYSTAL_ORE:
				case CORRUPTED_ORE:
				case PHREN_BARK:
				case CORRUPTED_PHREN_BARK:
				case LINUM_TIRINUM:
				case CORRUPTED_LINUM_TIRINUM:
					return InfoBoxPriority.HIGH;
				case GRYM_LEAF:
				case CORRUPTED_GRYM_LEAF:
					return InfoBoxPriority.MED;
				case CRYSTAL_SHARDS:
				case CORRUPTED_SHARDS:
				case RAW_PADDLEFISH:
					return InfoBoxPriority.NONE;
				default:
					return InfoBoxPriority.LOW;
			}
		}
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.maze;

import ca.gauntlet.TheGauntletConfig;
import ca.gauntlet.TheGauntletPlugin;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

@Singleton
class MazeOverlay extends Overlay
{
	private final Client client;
	private final TheGauntletConfig config;
	private final MazeModule mazeModule;
	private final ModelOutlineRenderer modelOutlineRenderer;
	private final ResourceManager resourceManager;

	@Inject
	MazeOverlay(
		final Client client,
		final TheGauntletPlugin plugin,
		final TheGauntletConfig config,
		final MazeModule mazeModule,
		final ModelOutlineRenderer modelOutlineRenderer,
		final ResourceManager resourceManager)
	{
		super(plugin);

		this.client = client;
		this.config = config;
		this.mazeModule = mazeModule;
		this.modelOutlineRenderer = modelOutlineRenderer;
		this.resourceManager = resourceManager;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		renderResources(graphics2D);
		renderUtilities();
		return null;
	}

	private void renderResources(final Graphics2D graphics2D)
	{
		if (!config.overlayResources() || mazeModule.getResourceGameObjects().isEmpty())
		{
			return;
		}

		for (final ResourceGameObject resourceGameObject : mazeModule.getResourceGameObjects())
		{
			if (!isOverlayEnabled(resourceGameObject.getResource()))
			{
				continue;
			}

			if (config.resourceTracker() &&
				config.resourceRemoveOutlineOnceAcquired() &&
				resourceManager.hasAcquired(resourceGameObject.getResource()))
			{
				continue;
			}

			final GameObject gameObject = resourceGameObject.getGameObject();

			final LocalPoint lp = gameObject.getLocalLocation();

			if (config.resourceHullOutlineWidth() > 0)
			{
				modelOutlineRenderer.drawOutline(gameObject, config.resourceHullOutlineWidth(),
					getResourceOutlineColor(resourceGameObject.getResource()), 1);
			}

			if (config.resourceTileOutlineWidth() > 0)
			{
				final Polygon polygon = Perspective.getCanvasTilePoly(client, lp);

				if (polygon != null)
				{
					OverlayUtil.renderPolygon(graphics2D, polygon, getResourceOutlineColor(resourceGameObject.getResource()),
						getResourceFillColor(resourceGameObject.getResource()), new BasicStroke(config.resourceTileOutlineWidth()));
				}
			}

			if (config.resourceIconSize() > 0)
			{
				OverlayUtil.renderImageLocation(client, graphics2D, lp, resourceGameObject.getIcon(), 0);
			}
		}
	}

	private void renderUtilities()
	{
		if (!config.utilitiesOutline() || mazeModule.getUtilities().isEmpty())
		{
			return;
		}

		for (final GameObject gameObject : mazeModule.getUtilities())
		{
			modelOutlineRenderer.drawOutline(gameObject, config.utilitiesOutlineWidth(),
				config.utilitiesOutlineColor(), 1);
		}
	}

	private Color getResourceOutlineColor(final Resource resource)
	{
		switch (resource)
		{
			case RAW_PADDLEFISH:
				return config.fishingSpotOutlineColor();
			case CRYSTAL_ORE:
			case CORRUPTED_ORE:
				return config.oreDepositOutlineColor();
			case PHREN_BARK:
			case CORRUPTED_PHREN_BARK:
				return config.phrenRootsOutlineColor();
			case LINUM_TIRINUM:
			case CORRUPTED_LINUM_TIRINUM:
				return config.linumTirinumOutlineColor();
			case GRYM_LEAF:
			case CORRUPTED_GRYM_LEAF:
				return config.grymRootOutlineColor();
			default:
				throw new IllegalArgumentException("Unsupported resource: " + resource);
		}
	}

	private Color getResourceFillColor(final Resource resource)
	{
		switch (resource)
		{
			case RAW_PADDLEFISH:
				return config.fishingSpotFillColor();
			case CRYSTAL_ORE:
			case CORRUPTED_ORE:
				return config.oreDepositFillColor();
			case PHREN_BARK:
			case CORRUPTED_PHREN_BARK:
				return config.phrenRootsFillColor();
			case LINUM_TIRINUM:
			case CORRUPTED_LINUM_TIRINUM:
				return config.linumTirinumFillColor();
			case GRYM_LEAF:
			case CORRUPTED_GRYM_LEAF:
				return config.grymRootFillColor();
			default:
				throw new IllegalArgumentException("Unsupported resource: " + resource);
		}
	}

	private boolean isOverlayEnabled(final Resource resource)
	{
		switch (resource)
		{
			case RAW_PADDLEFISH:
				return config.overlayFishingSpot();
			case CRYSTAL_ORE:
			case CORRUPTED_ORE:
				return config.overlayOreDeposit();
			case PHREN_BARK:
			case CORRUPTED_PHREN_BARK:
				return config.overlayPhrenRoots();
			case LINUM_TIRINUM:
			case CORRUPTED_LINUM_TIRINUM:
				return config.overlayLinumTirinum();
			case GRYM_LEAF:
			case CORRUPTED_GRYM_LEAF:
				return config.overlayGrymRoot();
			default:
				throw new IllegalArgumentException("Unsupported resource: " + resource);
		}
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.maze;

import ca.gauntlet.TheGauntletConfig;
import ca.gauntlet.module.Module;
import ca.gauntlet.module.overlay.TimerOverlay;
import java.awt.Color;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Function;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import static net.runelite.api.ItemID.RAW_PADDLEFISH;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.ObjectID;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.PostMenuSort;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.npcoverlay.HighlightedNpc;
import net.runelite.client.game.npcoverlay.NpcOverlayService;
import net.runelite.client.ui.overlay.OverlayManager;

@Singleton
public final class MazeModule implements Module
{
	private static final List<Integer> NPC_IDS_DEMIBOSS = List.of(
		NpcID.CRYSTALLINE_BEAR,
		NpcID.CRYSTALLINE_DARK_BEAST,
		NpcID.CRYSTALLINE_DRAGON,
		NpcID.CORRUPTED_BEAR,
		NpcID.CORRUPTED_DARK_BEAST,
		NpcID.CORRUPTED_DRAGON
	);
	private static final List<Integer> GAME_OBJECT_IDS_RESOURCE = List.of(
		ObjectID.CRYSTAL_DEPOSIT,
		ObjectID.PHREN_ROOTS,
		ObjectID.FISHING_SPOT_36068,
		ObjectID.GRYM_ROOT,
		ObjectID.LINUM_TIRINUM,
		ObjectID.CORRUPT_DEPOSIT,
		ObjectID.CORRUPT_PHREN_ROOTS,
		ObjectID.CORRUPT_FISHING_SPOT,
		ObjectID.CORRUPT_GRYM_ROOT,
		ObjectID.CORRUPT_LINUM_TIRINUM
	);
	private static final List<Integer> GAME_OBJECT_IDS_UTILITY = List.of(
		ObjectID.SINGING_BOWL_35966,
		ObjectID.RANGE_35980,
		ObjectID.WATER_PUMP_35981,
		ObjectID.SINGING_BOWL_36063,
		ObjectID.RANGE_36077,
		ObjectID.WATER_PUMP_36078
	);

	@Getter(AccessLevel.PACKAGE)
	private final Set<ResourceGameObject> resourceGameObjects = new HashSet<>();
	@Getter(AccessLevel.PACKAGE)
	private final Set<Demiboss> demiBosses = new HashSet<>();
	@Getter(AccessLevel.PACKAGE)
	private final Set<GameObject> utilities = new HashSet<>();
	private final Function<NPC, HighlightedNpc> npcHighlighter = this::highlightNpc;

	@Inject
	private EventBus eventBus;
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private TheGauntletConfig config;
	@Inject
	private NpcOverlayService npcOverlayService;
	@Inject
	private ResourceManager resourceManager;
	@Inject
	private SkillIconManager skillIconManager;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private MazeOverlay mazeOverlay;
	@Inject
	private MinimapOverlay minimapOverlay;
	@Inject
	private TimerOverlay timerOverlay;

	@Override
	public void start()
	{
		eventBus.register(this);
		npcOverlayService.registerHighlighter(npcHighlighter);
		overlayManager.add(mazeOverlay);
		overlayManager.add(minimapOverlay);
		overlayManager.add(timerOverlay);
	}

	@Override
	public void stop()
	{
		eventBus.unregister(this);
		npcOverlayService.unregisterHighlighter(npcHighlighter);
		overlayManager.remove(mazeOverlay);
		overlayManager.remove(minimapOverlay);
		overlayManager.remove(timerOverlay);
		resourceManager.reset();
		resourceGameObjects.clear();
		utilities.clear();
		demiBosses.clear();
	}

	@Subscribe
	void onConfigChanged(final ConfigChanged event)
	{
		if (!event.getGroup().equals(TheGauntletConfig.CONFIG_GROUP))
		{
			return;
		}

		clientThread.invoke(() -> {
			switch (event.getKey())
			{
				case "resourceIconSize":
					if (!resourceGameObjects.isEmpty())
					{
						resourceGameObjects.forEach(r -> r.setIconSize(config.resourceIconSize()));
					}
					break;
				case "resourceTracker":
				case "resourceTrackingMode":
				case "resourceRemoveAcquired":
					resourceManager.reset();
					resourceManager.init(client.getMapRegions()[0]);
					break;
				default:
					npcOverlayService.rebuild();
					break;
			}
		});
	}

	@Subscribe
	void onGameStateChanged(final GameStateChanged event)
	{
		switch (event.getGameState())
		{
			case LOADING:
				resourceGameObjects.clear();
				utilities.clear();
				break;
			case LOGIN_SCREEN:
			case HOPPING:
				stop();
				break;
		}
	}

	@Subscribe
	public void onPostMenuSort(final PostMenuSort postMenuSort)
	{
		if ((!config.utilitiesFishCheck()) || client.isMenuOpen())
		{
			return;
		}
		final ItemContainer container = client.getItemContainer(InventoryID.INVENTORY);
		if (container == null)
		{
			return;
		}

		final boolean hasRawFish = Arrays.stream(container.getItems()).anyMatch(x -> x.getId() == RAW_PADDLEFISH);
		if (!hasRawFish)
		{
			return;
		}

		// Remove Quick-pass and Pass
		final MenuEntry[] filteredEntires = Arrays.stream(client.getMenuEntries())
			.filter(x -> !x.getOption().equals("Quick-pass") && !x.getOption().equals("Pass"))
			.toArray(MenuEntry[]::new);

		client.setMenuEntries(filteredEntires);
	}

	@Subscribe
	void onWidgetLoaded(final WidgetLoaded event)
	{
		if (event.getGroupId() == InterfaceID.GAUNTLET_TIMER)
		{
			resourceManager.init(client.getMapRegions()[0]);
			timerOverlay.setGauntletStart();
		}
	}

	@Subscribe
	void onGameObjectSpawned(final GameObjectSpawned event)
	{
		final GameObject gameObject = event.getGameObject();

		final int id = gameObject.getId();

		if (GAME_OBJECT_IDS_RESOURCE.contains(id))
		{
			resourceGameObjects.add(new ResourceGameObject(gameObject, skillIconManager, config.resourceIconSize()));
		}
		else if (GAME_OBJECT_IDS_UTILITY.contains(id))
		{
			utilities.add(gameObject);
		}
	}

	@Subscribe
	void onGameObjectDespawned(final GameObjectDespawned event)
	{
		final GameObject gameObject = event.getGameObject();

		final int id = gameObject.getId();

		if (GAME_OBJECT_IDS_RESOURCE.contains(id))
		{
			resourceGameObjects.removeIf(o -> o.getGameObject() == gameObject);
		}
		else if (GAME_OBJECT_IDS_UTILITY.contains(id))
		{
			utilities.remove(gameObject);
		}
	}

	@Subscribe
	void onNpcSpawned(final NpcSpawned event)
	{
		final NPC npc = event.getNpc();

		if (NPC_IDS_DEMIBOSS.contains(npc.getId()))
		{
			demiBosses.add(new Demiboss(npc, skillIconManager));
		}
	}

	@Subscribe
	void onNpcDespawned(final NpcDespawned event)
	{
		final NPC npc = event.getNpc();

		if (NPC_IDS_DEMIBOSS.contains(npc.getId()))
		{
			demiBosses.removeIf(d -> d.isNpc(npc));
		}
	}

	@Subscribe
	void onActorDeath(final ActorDeath event)
	{
		if (event.getActor() == client.getLocalPlayer())
		{
			timerOverlay.onPlayerDeath();
		}
	}

	@Subscribe
	void onChatMessage(final ChatMessage event)
	{
		final ChatMessageType type = event.getType();

		if (type == ChatMessageType.SPAM || type == ChatMessageType.GAMEMESSAGE)
		{
			resourceManager.parseChatMessage(event.getMessage());
		}
	}

	private HighlightedNpc highlightNpc(final NPC npc)
	{
		final int id = npc.getId();

		final int borderWidth;
		final Color highlightColor;

		switch (id)
		{
			case NpcID.CRYSTALLINE_BAT:
			case NpcID.CORRUPTED_BAT:
			case NpcID.CRYSTALLINE_RAT:
			case NpcID.CORRUPTED_RAT:
			case NpcID.CRYSTALLINE_SPIDER:
			case NpcID.CORRUPTED_SPIDER:
				return HighlightedNpc.builder()
					.npc(npc)
					.outline(true)
					.borderWidth(config.weakNpcOutlineWidth())
					.highlightColor(config.weakNpcOutlineColor())
					.render(n -> config.weakNpcOutline() && !npc.isDead())
					.build();
			case NpcID.CRYSTALLINE_SCORPION:
			case NpcID.CORRUPTED_SCORPION:
			case NpcID.CRYSTALLINE_UNICORN:
			case NpcID.CORRUPTED_UNICORN:
			case NpcID.CRYSTALLINE_WOLF:
			case NpcID.CORRUPTED_WOLF:
				return HighlightedNpc.builder()
					.npc(npc)
					.outline(true)
					.borderWidth(config.strongNpcOutlineWidth())
					.highlightColor(config.strongNpcOutlineColor())
					.render(n -> config.strongNpcOutline() && !npc.isDead())
					.build();
			case NpcID.CRYSTALLINE_BEAR:
			case NpcID.CORRUPTED_BEAR:
				borderWidth = config.demibossOutlineWidth();
				highlightColor = config.bearOutlineColor();
				break;
			case NpcID.CRYSTALLINE_DARK_BEAST:
			case NpcID.CORRUPTED_DARK_BEAST:
				borderWidth = config.demibossOutlineWidth();
				highlightColor = config.darkBeastOutlineColor();
				break;
			case NpcID.CRYSTALLINE_DRAGON:
			case NpcID.CORRUPTED_DRAGON:
				borderWidth = config.demibossOutlineWidth();
				highlightColor = config.dragonOutlineColor();
				break;
			default:
				return null;
		}

		return HighlightedNpc.builder()
			.npc(npc)
			.outline(true)
			.borderWidth(borderWidth)
			.highlightColor(highlightColor)
			.render(n -> config.demibossOutline() && !npc.isDead())
			.build();
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * Copyright (c) 2018, Seth <http://github.com/sethtroll>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.overlay;

import ca.gauntlet.TheGauntletConfig;
import ca.gauntlet.TheGauntletPlugin;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.time.Instant;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.ChatMessageType;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Singleton
public final class TimerOverlay extends OverlayPanel
{
	private final TheGauntletConfig config;
	private final ChatMessageManager chatMessageManager;

	private final PanelComponent timerComponent;
	private final LineComponent prepTimeComponent;
	private final LineComponent totalTimeComponent;

	private long timeGauntletStart;
	private long timeHunllefStart;

	private long lastElapsed;

	@Inject
	TimerOverlay(final TheGauntletPlugin plugin, final TheGauntletConfig config, final ChatMessageManager chatMessageManager)
	{
		super(plugin);

		this.config = config;
		this.chatMessageManager = chatMessageManager;

		timerComponent = new PanelComponent();
		timerComponent.setBorder(new Rectangle(2, 1, 4, 0));
		timerComponent.setBackgroundColor(null);

		panelComponent.setBorder(new Rectangle(2, 2, 2, 2));
		panelComponent.getChildren().add(TitleComponent.builder().text("Gauntlet Timer").build());
		panelComponent.getChildren().add(timerComponent);

		prepTimeComponent = LineComponent.builder().left("Preparation:").right("").build();
		totalTimeComponent = LineComponent.builder().left("Total:").right("").build();

		timeGauntletStart = -1L;
		timeHunllefStart = -1L;
		lastElapsed = 0L;

		setClearChildren(false);
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "The Gauntlet timer"));
		setPosition(OverlayPosition.DYNAMIC);
		setMovable(true);
		setSnappable(true);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		if (!config.timerOverlay() || timeGauntletStart == -1)
		{
			return null;
		}

		graphics2D.setFont(FontManager.getRunescapeSmallFont());

		final LineComponent lineComponent = timeHunllefStart == -1 ? prepTimeComponent : totalTimeComponent;

		final long elapsed = Instant.now().getEpochSecond() - timeGauntletStart;

		if (elapsed != lastElapsed)
		{
			lineComponent.setRight(formatElapsedTime(elapsed));
			lastElapsed = elapsed;
		}

		return super.render(graphics2D);
	}

	public void reset()
	{
		timeGauntletStart = -1L;
		timeHunllefStart = -1L;
		lastElapsed = 0L;
		prepTimeComponent.setRight("");
		totalTimeComponent.setRight("");
		timerComponent.getChildren().clear();
	}

	public void setGauntletStart()
	{
		timeGauntletStart = Instant.now().getEpochSecond();
		prepTimeComponent.setLeftColor(Color.WHITE);
		prepTimeComponent.setRightColor(Color.WHITE);
		timerComponent.getChildren().clear();
		timerComponent.getChildren().add(prepTimeComponent);
	}

	public void setHunllefStart()
	{
		timeHunllefStart = Instant.now().getEpochSecond();
		prepTimeComponent.setLeftColor(Color.LIGHT_GRAY);
		prepTimeComponent.setRightColor(Color.LIGHT_GRAY);
		timerComponent.getChildren().clear();
		timerComponent.getChildren().add(prepTimeComponent);
		timerComponent.getChildren().add(totalTimeComponent);
	}

	public void onPlayerDeath()
	{
		if (!config.timerChatMessage())
		{
			return;
		}

		printTime();
		reset();
	}

	private void printTime()
	{
		if (timeGauntletStart == -1 || timeHunllefStart == -1)
		{
			return;
		}

		final long current = Instant.now().getEpochSecond();

		final String elapsedPrepTime = formatElapsedTime(timeHunllefStart, timeGauntletStart);
		final String elapsedBossTime = formatElapsedTime(current, timeHunllefStart);
		final String elapsedTotalTime = formatElapsedTime(current, timeGauntletStart);

		final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
			.append(ChatColorType.NORMAL)
			.append("Preparation time: ")
			.append(ChatColorType.HIGHLIGHT)
			.append(elapsedPrepTime)
			.append(ChatColorType.NORMAL)
			.append(". Hunllef time: ")
			.append(ChatColorType.HIGHLIGHT)
			.append(elapsedBossTime)
			.append(ChatColorType.NORMAL)
			.append(". Total time: ")
			.append(ChatColorType.HIGHLIGHT)
			.append(elapsedTotalTime)
			.append(ChatColorType.NORMAL)
			.append(".");

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(chatMessageBuilder.build())
			.build());
	}

	private static String formatElapsedTime(final long end, final long start)
	{
		return formatElapsedTime(end - start);
	}

	private static String formatElapsedTime(final long elapsed)
	{
		final long minutes = elapsed % 3600 / 60;
		final long seconds = elapsed % 60;

		return String.format("%01d:%02d", minutes, seconds);
	}
}


/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module;

public interface Module
{
	void start();

	void stop();
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.boss;

import ca.gauntlet.TheGauntletConfig;
import ca.gauntlet.TheGauntletConfig.TileOutline;
import ca.gauntlet.TheGauntletPlugin;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
class BossOverlay extends Overlay
{
	private final Client client;
	private final TheGauntletConfig config;
	private final BossModule bossModule;

	@Inject
	public BossOverlay(
		final Client client,
		final TheGauntletPlugin plugin,
		final TheGauntletConfig config,
		final BossModule bossModule)
	{
		super(plugin);

		this.client = client;
		this.config = config;
		this.bossModule = bossModule;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.UNDER_WIDGETS);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		renderTornadoes(graphics2D);
		renderHunllef(graphics2D);
		return null;
	}

	private void renderTornadoes(final Graphics2D graphics2D)
	{
		if (config.tornadoTileOutline() == TileOutline.OFF || bossModule.getTornadoes().isEmpty())
		{
			return;
		}

		final boolean trueTile = config.tornadoTileOutline() == TileOutline.TRUE_TILE;

		for (final NPC tornado : bossModule.getTornadoes())
		{
			final Polygon polygon;

			if (trueTile)
			{
				final WorldPoint worldPoint = tornado.getWorldLocation();

				if (worldPoint == null)
				{
					continue;
				}

				final LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);

				if (localPoint == null)
				{
					continue;
				}

				polygon = Perspective.getCanvasTilePoly(client, localPoint);
			}
			else
			{
				polygon = Perspective.getCanvasTilePoly(client, tornado.getLocalLocation());
			}

			if (polygon == null)
			{
				continue;
			}

			OverlayUtil.renderPolygon(graphics2D, polygon, config.tornadoOutlineColor(), config.tornadoFillColor(),
				new BasicStroke(config.tornadoTileOutlineWidth()));
		}
	}

	private void renderHunllef(final Graphics2D graphics2D)
	{
		final NPC npc = bossModule.getHunllef();

		if (npc == null || npc.isDead() || !config.hunllefTileOutline())
		{
			return;
		}

		final Polygon polygon = npc.getCanvasTilePoly();

		if (polygon == null)
		{
			return;
		}

		Color outlineColor = config.hunllefOutlineColor();

		switch (config.hunllefPrayerOutlineColor())
		{
			case OFF:
				break;
			case ON:
				switch (npc.getId())
				{
					// Protect from Melee
					case NpcID.CORRUPTED_HUNLLEF:
					case NpcID.CRYSTALLINE_HUNLLEF:
						outlineColor = Color.RED;
						break;
					// Protect from Missiles
					case NpcID.CRYSTALLINE_HUNLLEF_9022:
					case NpcID.CORRUPTED_HUNLLEF_9036:
						outlineColor = Color.GREEN;
						break;
					// Protect from Magic
					case NpcID.CRYSTALLINE_HUNLLEF_9023:
					case NpcID.CORRUPTED_HUNLLEF_9037:
						outlineColor = Color.BLUE;
						break;
				}
				break;
			case INVERTED:
				switch (npc.getId())
				{
					// Protect from Melee
					case NpcID.CORRUPTED_HUNLLEF:
					case NpcID.CRYSTALLINE_HUNLLEF:
						outlineColor = Color.RED;
						break;
					// Protect from Missiles
					case NpcID.CRYSTALLINE_HUNLLEF_9022:
					case NpcID.CORRUPTED_HUNLLEF_9036:
						outlineColor = Color.BLUE;
						break;
					// Protect from Magic
					case NpcID.CRYSTALLINE_HUNLLEF_9023:
					case NpcID.CORRUPTED_HUNLLEF_9037:
						outlineColor = Color.GREEN;
						break;
				}
				break;
		}

		OverlayUtil.renderPolygon(graphics2D, polygon, outlineColor, config.hunllefFillColor(),
			new BasicStroke(config.hunllefTileOutlineWidth()));
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet.module.boss;

import ca.gauntlet.module.Module;
import ca.gauntlet.module.overlay.TimerOverlay;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.NullNpcID;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;

@Singleton
public final class BossModule implements Module
{
	private static final List<Integer> HUNLLEF_IDS = List.of(
		NpcID.CRYSTALLINE_HUNLLEF,
		NpcID.CRYSTALLINE_HUNLLEF_9022,
		NpcID.CRYSTALLINE_HUNLLEF_9023,
		NpcID.CRYSTALLINE_HUNLLEF_9024,
		NpcID.CORRUPTED_HUNLLEF,
		NpcID.CORRUPTED_HUNLLEF_9036,
		NpcID.CORRUPTED_HUNLLEF_9037,
		NpcID.CORRUPTED_HUNLLEF_9038
	);

	private static final List<Integer> TORNADO_IDS = List.of(NullNpcID.NULL_9025, NullNpcID.NULL_9039);

	@Getter(AccessLevel.PACKAGE)
	private final List<NPC> tornadoes = new ArrayList<>();

	@Inject
	private EventBus eventBus;
	@Inject
	private Client client;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private TimerOverlay timerOverlay;
	@Inject
	private BossOverlay bossOverlay;

	@Nullable
	@Getter(AccessLevel.PACKAGE)
	private NPC hunllef;

	@Override
	public void start()
	{
		eventBus.register(this);

		for (final NPC npc : client.getNpcs())
		{
			onNpcSpawned(new NpcSpawned(npc));
		}

		overlayManager.add(timerOverlay);
		overlayManager.add(bossOverlay);
		timerOverlay.setHunllefStart();
	}

	@Override
	public void stop()
	{
		eventBus.unregister(this);
		overlayManager.remove(timerOverlay);
		overlayManager.remove(bossOverlay);
		timerOverlay.reset();
		tornadoes.clear();
		hunllef = null;
	}

	@Subscribe
	void onGameStateChanged(final GameStateChanged event)
	{
		switch (event.getGameState())
		{
			case LOGIN_SCREEN:
			case HOPPING:
				stop();
				break;
		}
	}

	@Subscribe
	void onActorDeath(final ActorDeath event)
	{
		if (event.getActor() == client.getLocalPlayer())
		{
			timerOverlay.onPlayerDeath();
		}
	}

	@Subscribe
	void onNpcSpawned(final NpcSpawned event)
	{
		final NPC npc = event.getNpc();

		if (TORNADO_IDS.contains(npc.getId()))
		{
			tornadoes.add(npc);
		}
		else if (HUNLLEF_IDS.contains(npc.getId()))
		{
			hunllef = npc;
		}
	}

	@Subscribe
	void onNpcDespawned(final NpcDespawned event)
	{
		final NPC npc = event.getNpc();

		if (TORNADO_IDS.contains(npc.getId()))
		{
			tornadoes.removeIf(t -> t == npc);
		}
		else if (HUNLLEF_IDS.contains(npc.getId()))
		{
			hunllef = null;
		}
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * Copyright (c) 2019, kThisIsCvpv <https://github.com/kThisIsCvpv>
 * Copyright (c) 2019, ganom <https://github.com/Ganom>
 * Copyright (c) 2019, kyle <https://github.com/Kyleeld>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet;

import ca.gauntlet.module.boss.BossModule;
import ca.gauntlet.module.maze.MazeModule;
import com.google.inject.Provides;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@PluginDescriptor(
	name = "The Gauntlet",
	description = "All-in-one plugin for The Gauntlet.",
	tags = {"the", "gauntlet"}
)
public final class TheGauntletPlugin extends Plugin
{
	private static final int VARBIT_MAZE = 9178;
	private static final int VARBIT_BOSS = 9177;

	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private MazeModule mazeModule;
	@Inject
	private BossModule bossModule;

	@Provides
	TheGauntletConfig provideConfig(final ConfigManager configManager)
	{
		return configManager.getConfig(TheGauntletConfig.class);
	}

	@Override
	protected void startUp()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		clientThread.invoke(() -> {
			if (client.getVarbitValue(VARBIT_BOSS) == 1)
			{
				bossModule.start();
			}
			else if (client.getVarbitValue(VARBIT_MAZE) == 1)
			{
				mazeModule.start();
			}
		});
	}

	@Override
	protected void shutDown()
	{
		mazeModule.stop();
		bossModule.stop();
	}

	@Subscribe
	void onVarbitChanged(final VarbitChanged event)
	{
		final int varbit = event.getVarbitId();

		if (varbit == VARBIT_MAZE)
		{
			if (event.getValue() == 1)
			{
				mazeModule.start();
			}
			else
			{
				mazeModule.stop();
			}
		}
		else if (varbit == VARBIT_BOSS)
		{
			if (event.getValue() == 1)
			{
				mazeModule.stop();
				bossModule.start();
			}
			else
			{
				bossModule.stop();
			}
		}
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2023, rdutta <https://github.com/rdutta>
 * Copyright (c) 2019, kThisIsCvpv <https://github.com/kThisIsCvpv>
 * Copyright (c) 2019, ganom <https://github.com/Ganom>
 * Copyright (c) 2019, kyle <https://github.com/Kyleeld>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.gauntlet;

import java.awt.Color;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(TheGauntletConfig.CONFIG_GROUP)
public interface TheGauntletConfig extends Config
{
	String CONFIG_GROUP = "thegauntlet";

	// Sections

	@ConfigSection(
		name = "Resource Tracking",
		description = "Resource tracking section.",
		position = 0,
		closedByDefault = true
	)
	String resourceTrackingSection = "resourceTracking";

	@ConfigSection(
		name = "Resource Overlay",
		description = "Resource overlay section.",
		position = 1,
		closedByDefault = true
	)
	String resourceOverlaySection = "resourceOverlay";

	@ConfigSection(
		name = "Utilities",
		description = "Utilities section.",
		position = 2,
		closedByDefault = true
	)
	String utilitiesSection = "utilities";

	@ConfigSection(
		name = "Npcs",
		description = "Npcs section.",
		position = 3,
		closedByDefault = true
	)
	String npcsSection = "npcs";

	@ConfigSection(
		name = "Hunllef",
		description = "Hunllef section.",
		position = 4,
		closedByDefault = true
	)
	String hunllefSection = "hunllef";

	@ConfigSection(
		name = "Timer",
		description = "Timer section.",
		position = 5,
		closedByDefault = true
	)
	String timerSection = "timer";

	// Resource Tracking

	@ConfigItem(
		name = "Track resources",
		description = "Track resources in counter infoboxes.",
		position = 0,
		keyName = "resourceTracker",
		section = resourceTrackingSection
	)
	default boolean resourceTracker()
	{
		return false;
	}

	@ConfigItem(
		name = "Tracking Mode",
		description = "Increment or decrement resource counters." +
			"<br>Disable a counter by setting value to 0.",
		position = 1,
		keyName = "resourceTrackingMode",
		section = resourceTrackingSection
	)
	default TrackingMode resourceTrackingMode()
	{
		return TrackingMode.DECREMENT;
	}

	@ConfigItem(
		name = "Remove acquired resources",
		description = "Remove counters when acquired amount reached.",
		position = 2,
		keyName = "resourceRemoveAcquired",
		section = resourceTrackingSection
	)
	default boolean resourceRemoveAcquired()
	{
		return false;
	}

	@ConfigItem(
		name = "Ore",
		description = "The desired number of ores to acquire.",
		position = 3,
		keyName = "resourceOre",
		section = resourceTrackingSection
	)
	default int resourceOre()
	{
		return 3;
	}

	@ConfigItem(
		name = "Phren bark",
		description = "The desired number of phren barks to acquire.",
		position = 4,
		keyName = "resourceBark",
		section = resourceTrackingSection
	)
	default int resourceBark()
	{
		return 3;
	}

	@ConfigItem(
		name = "Linum tirinum",
		description = "The desired number of linum tirinums to acquire.",
		position = 5,
		keyName = "resourceTirinum",
		section = resourceTrackingSection
	)
	default int resourceTirinum()
	{
		return 3;
	}

	@ConfigItem(
		name = "Grym leaf",
		description = "The desired number of grym leaves to acquire.",
		position = 6,
		keyName = "resourceGrym",
		section = resourceTrackingSection
	)
	default int resourceGrym()
	{
		return 2;
	}

	@ConfigItem(
		name = "Weapon frames",
		description = "The desired number of weapon frames to acquire.",
		position = 7,
		keyName = "resourceFrame",
		section = resourceTrackingSection
	)
	default int resourceFrame()
	{
		return 2;
	}

	@ConfigItem(
		name = "Paddlefish",
		description = "The desired number of paddlefish to acquire.",
		position = 8,
		keyName = "resourcePaddlefish",
		section = resourceTrackingSection
	)
	default int resourcePaddlefish()
	{
		return 20;
	}

	@ConfigItem(
		name = "Crystal shards",
		description = "The desired number of crystal shards to acquire.",
		position = 9,
		keyName = "resourceShard",
		section = resourceTrackingSection
	)
	default int resourceShard()
	{
		return 320;
	}

	@ConfigItem(
		name = "Bowstring",
		description = "Whether or not to acquire the crystalline or corrupted bowstring.",
		position = 10,
		keyName = "resourceBowstring",
		section = resourceTrackingSection
	)
	default boolean resourceBowstring()
	{
		return false;
	}

	@ConfigItem(
		name = "Spike",
		description = "Whether or not to acquire the crystal or corrupted spike.",
		position = 11,
		keyName = "resourceSpike",
		section = resourceTrackingSection
	)
	default boolean resourceSpike()
	{
		return false;
	}

	@ConfigItem(
		name = "Orb",
		description = "Whether or not to acquire the crystal or corrupted orb.",
		position = 12,
		keyName = "resourceOrb",
		section = resourceTrackingSection
	)
	default boolean resourceOrb()
	{
		return false;
	}

	// Resource Overlay Section

	@ConfigItem(
		name = "Overlay resources",
		description = "Toggle enabling/disabling resource overlays.",
		position = 0,
		keyName = "overlayResources",
		section = resourceOverlaySection
	)
	default boolean overlayResources()
	{
		return false;
	}

	@ConfigItem(
		name = "Ore Deposit",
		description = "Toggle overlaying ore deposits.",
		position = 1,
		keyName = "overlayOreDeposit",
		section = resourceOverlaySection
	)
	default boolean overlayOreDeposit()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		name = "Ore outline color",
		description = "Change the outline color of ore deposits.",
		position = 2,
		keyName = "oreDepositOutlineColor",
		section = resourceOverlaySection
	)
	default Color oreDepositOutlineColor()
	{
		return new Color(255, 0, 0, 255);
	}

	@Alpha
	@ConfigItem(
		name = "Ore fill color",
		description = "Change the fill color of ore deposits.",
		position = 3,
		keyName = "oreDepositFillColor",
		section = resourceOverlaySection
	)
	default Color oreDepositFillColor()
	{
		return new Color(255, 0, 0, 50);
	}

	@ConfigItem(
		name = "Phren Roots",
		description = "Toggle overlaying phren roots.",
		position = 4,
		keyName = "overlayPhrenRoots",
		section = resourceOverlaySection
	)
	default boolean overlayPhrenRoots()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		name = "Phren outline color",
		description = "Change the outline color of phren roots.",
		position = 5,
		keyName = "phrenRootsOutlineColor",
		section = resourceOverlaySection
	)
	default Color phrenRootsOutlineColor()
	{
		return new Color(0, 255, 0, 255);
	}

	@Alpha
	@ConfigItem(
		name = "Phren fill color",
		description = "Change the fill color of phren roots.",
		position = 6,
		keyName = "phrenRootsFillColor",
		section = resourceOverlaySection
	)
	default Color phrenRootsFillColor()
	{
		return new Color(0, 255, 0, 50);
	}

	@ConfigItem(
		name = "Linum Tirinum",
		description = "Toggle overlaying linum tirinum.",
		position = 7,
		keyName = "overlayLinumTirinum",
		section = resourceOverlaySection
	)
	default boolean overlayLinumTirinum()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		name = "Linum outline color",
		description = "Change the outline color of linum tirinum.",
		position = 8,
		keyName = "linumTirinumOutlineColor",
		section = resourceOverlaySection
	)
	default Color linumTirinumOutlineColor()
	{
		return new Color(255, 255, 255, 255);
	}

	@Alpha
	@ConfigItem(
		name = "Linum fill color",
		description = "Change the fill color of linum tirinum.",
		position = 9,
		keyName = "linumTirinumFillColor",
		section = resourceOverlaySection
	)
	default Color linumTirinumFillColor()
	{
		return new Color(255, 255, 255, 50);
	}

	@ConfigItem(
		name = "Grym Root",
		description = "Toggle overlaying grym roots.",
		position = 10,
		keyName = "overlayGrymRoot",
		section = resourceOverlaySection
	)
	default boolean overlayGrymRoot()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		name = "Grym outline color",
		description = "Change the outline color of grym roots.",
		position = 11,
		keyName = "grymRootOutlineColor",
		section = resourceOverlaySection
	)
	default Color grymRootOutlineColor()
	{
		return new Color(255, 255, 0, 255);
	}

	@Alpha
	@ConfigItem(
		name = "Grym fill color",
		description = "Change the fill color of grym roots.",
		position = 12,
		keyName = "grymRootFillColor",
		section = resourceOverlaySection
	)
	default Color grymRootFillColor()
	{
		return new Color(255, 255, 0, 50);
	}

	@ConfigItem(
		name = "Fishing Spot",
		description = "Toggle overlaying fishing spots.",
		position = 13,
		keyName = "overlayFishingSpot",
		section = resourceOverlaySection
	)
	default boolean overlayFishingSpot()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		name = "Fishing outline color",
		description = "Change the outline color of fishing spots.",
		position = 14,
		keyName = "fishingSpotOutlineColor",
		section = resourceOverlaySection
	)
	default Color fishingSpotOutlineColor()
	{
		return new Color(0, 255, 255, 255);
	}

	@Alpha
	@ConfigItem(
		name = "Fishing fill color",
		description = "Change the fill color of fishing spots.",
		position = 15,
		keyName = "fishingSpotFillColor",
		section = resourceOverlaySection
	)
	default Color fishingSpotFillColor()
	{
		return new Color(0, 255, 255, 50);
	}

	@Range(
		max = 64
	)
	@ConfigItem(
		name = "Icon size",
		description = "Change the size of the resource icons.<br>0px width = disabled",
		position = 16,
		keyName = "resourceIconSize",
		section = resourceOverlaySection
	)
	@Units(Units.PIXELS)
	default int resourceIconSize()
	{
		return 14;
	}

	@Range(
		max = 2
	)
	@ConfigItem(
		name = "Hull outline width",
		description = "Change the width of the resource hull outline.<br>0px width = disabled",
		position = 17,
		keyName = "resourceHullOutlineWidth",
		section = resourceOverlaySection
	)
	@Units(Units.PIXELS)
	default int resourceHullOutlineWidth()
	{
		return 1;
	}

	@Range(
		max = 2
	)
	@ConfigItem(
		name = "Tile outline width",
		description = "Change the width of the resource tile outline.<br>0px width = disabled",
		position = 18,
		keyName = "resourceTileOutlineWidth",
		section = resourceOverlaySection
	)
	@Units(Units.PIXELS)
	default int resourceTileOutlineWidth()
	{
		return 1;
	}

	@ConfigItem(
		name = "Minimap overlays",
		description = "Overlay the minimap with icons for resources.",
		position = 19,
		keyName = "minimapResourceOverlay",
		section = resourceOverlaySection
	)
	default boolean minimapResourceOverlay()
	{
		return false;
	}

	@ConfigItem(
		name = "Dynamically remove overlays",
		description = "Remove overlays for acquired tracked resources." +
			"<br>Disabled if incrementally tracking resources.",
		position = 20,
		keyName = "resourceRemoveOutlineOnceAcquired",
		section = resourceOverlaySection
	)
	default boolean resourceRemoveOutlineOnceAcquired()
	{
		return false;
	}

	// Utilities Section

	@ConfigItem(
		name = "Outline starting room utilities",
		description = "Outline various utilities in the starting room.",
		position = 0,
		keyName = "utilitiesOutline",
		section = utilitiesSection
	)
	default boolean utilitiesOutline()
	{
		return false;
	}

	@Range(
		min = 1,
		max = 2
	)
	@ConfigItem(
		name = "Outline width",
		description = "Change the width of the utilities outline.",
		position = 1,
		keyName = "utilitiesOutlineWidth",
		section = utilitiesSection
	)
	@Units(Units.PIXELS)
	default int utilitiesOutlineWidth()
	{
		return 1;
	}

	@Alpha
	@ConfigItem(
		name = "Outline color",
		description = "Change the color of the utilities outline.",
		position = 2,
		keyName = "utilitiesOutlineColor",
		section = utilitiesSection
	)
	default Color utilitiesOutlineColor()
	{
		return Color.MAGENTA;
	}

	@ConfigItem(
		name = "Prevent entry with uncooked fish",
		description = "Removes \"Pass\" and \"Quick-Pass\" while carrying uncooked paddlefish.",
		position = 3,
		keyName = "utilitiesFishCheck",
		section = utilitiesSection
	)
	default boolean utilitiesFishCheck()
	{
		return false;
	}


	// Hunllef Section

	@ConfigItem(
		name = "Outline Hunllef tile",
		description = "Outline the Hunllef's tile.",
		position = 0,
		keyName = "hunllefTileOutline",
		section = hunllefSection
	)
	default boolean hunllefTileOutline()
	{
		return false;
	}

	@ConfigItem(
		name = "Color tile by prayer",
		description = "Hunllef's tile color will correspond to its active prayer.",
		position = 1,
		keyName = "hunllefPrayerOutlineColor",
		section = hunllefSection
	)
	default PrayerTileOutline hunllefPrayerOutlineColor()
	{
		return PrayerTileOutline.OFF;
	}

	@Range(
		min = 1,
		max = 2
	)
	@ConfigItem(
		name = "Tile outline width",
		description = "Change the width of the Hunllef's tile outline.",
		position = 2,
		keyName = "hunllefTileOutlineWidth",
		section = hunllefSection
	)
	@Units(Units.PIXELS)
	default int hunllefTileOutlineWidth()
	{
		return 1;
	}

	@Alpha
	@ConfigItem(
		name = "Tile outline color",
		description = "Change the outline color of the Hunllef's tile.",
		position = 3,
		keyName = "hunllefOutlineColor",
		section = hunllefSection
	)
	default Color hunllefOutlineColor()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		name = "Tile fill color",
		description = "Change the fill color of the Hunllef's tile.",
		position = 4,
		keyName = "hunllefFillColor",
		section = hunllefSection
	)
	default Color hunllefFillColor()
	{
		return new Color(255, 255, 255, 0);
	}

	@ConfigItem(
		name = "Outline tornado tile",
		description = "Outline the tiles of tornadoes.",
		position = 5,
		keyName = "tornadoTileOutline",
		section = hunllefSection
	)
	default TileOutline tornadoTileOutline()
	{
		return TileOutline.OFF;
	}

	@Range(
		min = 1,
		max = 2
	)
	@ConfigItem(
		name = "Tile outline width",
		description = "Change tile outline width of tornadoes.",
		position = 6,
		keyName = "tornadoTileOutlineWidth",
		section = hunllefSection
	)
	@Units(Units.PIXELS)
	default int tornadoTileOutlineWidth()
	{
		return 1;
	}

	@Alpha
	@ConfigItem(
		name = "Tile outline color",
		description = "Color to outline the tile of a tornado.",
		position = 7,
		keyName = "tornadoOutlineColor",
		section = hunllefSection
	)
	default Color tornadoOutlineColor()
	{
		return Color.YELLOW;
	}

	@Alpha
	@ConfigItem(
		name = "Tile fill color",
		description = "Color to fill the tile of a tornado.",
		position = 8,
		keyName = "tornadoFillColor",
		section = hunllefSection
	)
	default Color tornadoFillColor()
	{
		return new Color(255, 255, 0, 50);
	}

	// Npcs Section

	@ConfigItem(
		name = "Outline demi-bosses",
		description = "Overlay demi-bosses with a colored outline.",
		position = 0,
		keyName = "demibossOutline",
		section = npcsSection
	)
	default boolean demibossOutline()
	{
		return false;
	}

	@Range(
		min = 1,
		max = 2
	)
	@ConfigItem(
		name = "Outline width",
		description = "Change the width of the demi-boss outline.",
		position = 1,
		keyName = "demibossOutlineWidth",
		section = npcsSection
	)
	@Units(Units.PIXELS)
	default int demibossOutlineWidth()
	{
		return 1;
	}

	@Alpha
	@ConfigItem(
		name = "Dark beast color",
		description = "Change the outline color of dark beasts.",
		position = 2,
		keyName = "darkBeastOutlineColor",
		section = npcsSection
	)
	default Color darkBeastOutlineColor()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		name = "Dragon color",
		description = "Change the outline color of dragons.",
		position = 3,
		keyName = "dragonOutlineColor",
		section = npcsSection
	)
	default Color dragonOutlineColor()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		name = "Bear color",
		description = "Change the outline color of bears.",
		position = 4,
		keyName = "bearOutlineColor",
		section = npcsSection
	)
	default Color bearOutlineColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		name = "Outline strong npcs",
		description = "Overlay strong npcs with a colored outline.",
		position = 5,
		keyName = "strongNpcOutline",
		section = npcsSection
	)
	default boolean strongNpcOutline()
	{
		return false;
	}

	@Range(
		min = 1,
		max = 2
	)
	@ConfigItem(
		name = "Outline width",
		description = "Change the width of the strong npcs outline.",
		position = 6,
		keyName = "strongNpcOutlineWidth",
		section = npcsSection
	)
	@Units(Units.PIXELS)
	default int strongNpcOutlineWidth()
	{
		return 1;
	}

	@Alpha
	@ConfigItem(
		name = "Outline color",
		description = "Change the outline color of strong npcs.",
		position = 7,
		keyName = "strongNpcOutlineColor",
		section = npcsSection
	)
	default Color strongNpcOutlineColor()
	{
		return Color.ORANGE;
	}

	@ConfigItem(
		name = "Outline weak npcs",
		description = "Overlay weak npcs with a colored outline.",
		position = 8,
		keyName = "weakNpcOutline",
		section = npcsSection
	)
	default boolean weakNpcOutline()
	{
		return false;
	}

	@Range(
		min = 1,
		max = 2
	)
	@ConfigItem(
		name = "Outline width",
		description = "Change the width of the weak npcs outline.",
		position = 9,
		keyName = "weakNpcOutlineWidth",
		section = npcsSection
	)
	@Units(Units.PIXELS)
	default int weakNpcOutlineWidth()
	{
		return 1;
	}

	@Alpha
	@ConfigItem(
		name = "Outline color",
		description = "Change the outline color of weak npcs.",
		position = 10,
		keyName = "weakNpcOutlineColor",
		section = npcsSection
	)
	default Color weakNpcOutlineColor()
	{
		return Color.ORANGE;
	}

	@ConfigItem(
		name = "Minimap overlays",
		description = "Overlay the minimap with icons for demi-bosses.",
		position = 11,
		keyName = "minimapDemibossOverlay",
		section = npcsSection
	)
	default boolean minimapDemibossOverlay()
	{
		return false;
	}

	// Timer Section

	@ConfigItem(
		position = 0,
		keyName = "timerOverlay",
		name = "Overlay timer",
		description = "Display an overlay that tracks your gauntlet time.",
		section = timerSection
	)
	default boolean timerOverlay()
	{
		return false;
	}

	@ConfigItem(
		position = 1,
		keyName = "timerChatMessage",
		name = "Chat timer",
		description = "Display a chat message on-death with your gauntlet time.",
		section = timerSection
	)
	default boolean timerChatMessage()
	{
		return false;
	}

	// Constants

	@Getter
	@AllArgsConstructor
	enum TileOutline
	{
		OFF("Off"),
		ON("On"),
		TRUE_TILE("True Tile");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	@AllArgsConstructor
	enum PrayerTileOutline
	{
		OFF("Off"),
		ON("On"),
		INVERTED("Inverted");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}

	@Getter
	@AllArgsConstructor
	enum TrackingMode
	{
		DECREMENT("Decrement"),
		INCREMENT("Increment");

		private final String name;

		@Override
		public String toString()
		{
			return name;
		}
	}
}

