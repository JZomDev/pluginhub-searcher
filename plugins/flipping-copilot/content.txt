package com.flippingcopilot.util;

import java.util.Arrays;
import java.util.HashSet;

public class GeTax {
    private final static int MAX_PRICE_FOR_GE_TAX = 500000000;
    private final static int GE_TAX_CAP = 5000000;
    private final static double GE_TAX = 0.01;
    private final static HashSet<Integer> GE_TAX_EXEMPT_ITEMS = new HashSet<>(
            Arrays.asList(13190, 1755, 5325, 1785, 2347, 1733, 233, 5341, 8794, 5329, 5343, 1735, 952, 5331));

    public static int getPostTaxPrice(int itemId, int price) {
        if (GE_TAX_EXEMPT_ITEMS.contains(itemId)) {
            return price;
        }
        if (price >= MAX_PRICE_FOR_GE_TAX) {
            return price - GE_TAX_CAP;
        }
        int tax = (int)Math.floor(price * GE_TAX);
        return price - tax;
    }
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

public class AtomicReferenceUtils {
    public static <T> OrElse ifPresent(AtomicReference<T> ref, Consumer<? super T> action) {
        T value = ref.get();
        if (value != null) {
            action.accept(value);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    public static <T, E> OrElse ifBothPresent(AtomicReference<T> ref1, AtomicReference<E> ref2, BiConsumer<? super T,? super E> action) {
        T value1 = ref1.get();
        E value2 = ref2.get();
        if (value1 != null && value2 != null) {
            action.accept(value1, value2);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    @AllArgsConstructor
    public static class OrElse {

        boolean shouldRun;

        public void orElse(Runnable r) {
            if(shouldRun) {
                r.run();
            }
        }
    }
}
package com.flippingcopilot.util;

public class Constants {
    public final static int MIN_GP_NEEDED_TO_FLIP = 1000;
    public final static int PLATINUM_TOKEN_VALUE = 1000;
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class MutableReference<T> {
    private T value;
}

package com.flippingcopilot.controller;
import com.flippingcopilot.model.OfferList;
import net.runelite.api.events.GrandExchangeOfferChanged;


public class OfferEventFilter {
    private final SlotOfferEventFilter[] slotOfferEventFilters;

    public OfferEventFilter() {
        slotOfferEventFilters = new SlotOfferEventFilter[OfferList.NUM_SLOTS];
        for(int i = 0; i < OfferList.NUM_SLOTS; i++) {
            slotOfferEventFilters[i] = new SlotOfferEventFilter();
        }
    }

    public boolean shouldProcess(GrandExchangeOfferChanged event) {

        return slotOfferEventFilters[event.getSlot()].shouldProcess(event);
    }

    void setExpectEmptyOffers() {
        for(SlotOfferEventFilter slotOfferEventFilter : slotOfferEventFilters) {
            slotOfferEventFilter.onLogout();
        }
    }

    void setToLoggedIn() {
        for(SlotOfferEventFilter slotOfferEventFilter : slotOfferEventFilters) {
            slotOfferEventFilter.setToLoggedIn();
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.LoginResponse;
import com.flippingcopilot.model.Offer;
import com.flippingcopilot.model.OfferList;
import com.flippingcopilot.model.SessionData;
import com.flippingcopilot.model.Transaction;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class Persistance {
    public static Gson gson;
    public static final File PARENT_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "flipping-copilot");
    public static final String UN_ACKED_TRANSACTIONS_FILE_TEMPLATE = "%s_un_acked.jsonl";
    public static final String ALL_TRANSACTIONS_FILE_TEMPLATE = "%s_all_transactions.jsonl";
    public static final String SESSION_DATA_FILE_TEMPLATE = "%s_session_data.jsonl";
    public static final String PREVIOUS_GE_OFFER_EVENTS = "%s_ge_offer_events.jsonl";
    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";
    public static File directory;

    public static void setUp(String directoryPath) throws IOException {
        directory = new File(directoryPath);
        createDirectory(directory);
        createRequiredFiles();
    }

    public static void setUp(Gson gson) throws IOException {
        Persistance.gson = gson;
        directory = PARENT_DIRECTORY;
        createDirectory(PARENT_DIRECTORY);
        createRequiredFiles();
    }

    private static void createRequiredFiles() throws IOException {
        generateFileIfDoesNotExist(LOGIN_RESPONSE_JSON_FILE);
    }

    private static void generateFileIfDoesNotExist(String filename) throws IOException {
        File file = new File(directory, filename);
        if (!file.exists()) {
            if (!file.createNewFile()) {
                log.info("Failed to generate file {}", file.getPath());
            }
        }
    }

    private static void createDirectory(File directory) throws IOException {
        if (!directory.exists()) {
            if (!directory.mkdir()) {
                throw new IOException("unable to create parent directory!");
            }
        }
    }

    public static LoginResponse loadLoginResponse() throws IOException {
        String jsonString = getFileContent(LOGIN_RESPONSE_JSON_FILE);
        return gson.fromJson(jsonString, LoginResponse.class);
    }

    public static void saveLoginResponse(LoginResponse loginResponse) {
        if (loginResponse == null) {
            return;
        }
        try {
            File file = new File(directory, LOGIN_RESPONSE_JSON_FILE);
            String json = gson.toJson(loginResponse);
            Files.write(file.toPath(), json.getBytes());
        } catch (IOException e) {
            log.warn("error saving login response {}", e.getMessage(), e);
        }
    }

    public static void deleteLoginResponse() {
        File file = new File(directory, LOGIN_RESPONSE_JSON_FILE);
        if (file.exists()) {
            file.delete();
        }
    }

    private static String getFileContent(String filename) throws IOException {
        Path filePath = Paths.get(directory.getAbsolutePath(), filename);
        byte[] fileBytes = Files.readAllBytes(filePath);
        return new String(fileBytes);
    }


    public static List<Transaction> loadUnAckedTransactions(String displayName) {
        List<Transaction> transactions = new ArrayList<>();
        File file = new File(PARENT_DIRECTORY, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        if (!file.exists()) {
            return new ArrayList<>();
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }
                try {
                    Transaction transaction = gson.fromJson(line, Transaction.class);
                    transactions.add(transaction);
                } catch (JsonSyntaxException e) {
                    log.warn("error deserializing transaction line '{}' file {}", line, file, e);
                }
            }
        } catch (FileNotFoundException e) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        } catch (IOException e) {
            log.warn("error loading un acked transaction file {}", file, e);
            return new ArrayList<>();
        }
        return transactions;
    }

    public static void storeTransaction(Transaction t, String displayName) {
        File allTransacitonsFile = new File(PARENT_DIRECTORY, String.format(ALL_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        try (BufferedWriter w = new BufferedWriter(new FileWriter(allTransacitonsFile, true))) {
            String json = gson.toJson(t);
            w.write(json);
            w.newLine();
        } catch (IOException e) {
            log.warn("error storing un acked transactions to file {}", allTransacitonsFile, e);
        }
    }

    public static void storeUnAckedTransactions(List<Transaction> transactions, String displayName) {
        File unackedTransactionsFile = new File(PARENT_DIRECTORY, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        try (BufferedWriter w = new BufferedWriter(new FileWriter(unackedTransactionsFile, false))) {
            for (Transaction transaction : transactions) {
                String json = gson.toJson(transaction);
                w.write(json);
                w.newLine();
            }
        } catch (IOException e) {
            log.warn("error storing un acked transactions to file {}", unackedTransactionsFile, e);
        }
    }

    public static SessionData loadSessionData(String displayName) {
        File file = new File(PARENT_DIRECTORY, String.format(SESSION_DATA_FILE_TEMPLATE, hashDisplayName(displayName)));
        if (!file.exists()) {
            return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, SessionData.class);
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading session data json file {}", file, e);
        }
        return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
    }

    public static void storeSessionData(SessionData data, String displayName) {
        File file = new File(PARENT_DIRECTORY, String.format(SESSION_DATA_FILE_TEMPLATE, hashDisplayName(displayName)));
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
            String json = gson.toJson(data);
            writer.write(json);
            writer.newLine();
        } catch (IOException e) {
            log.warn("error storing session data to file {}", file, e);
        }
    }


    public static OfferList loadPreviousGeOfferEvents(String displayName) {
        File file = new File(PARENT_DIRECTORY, String.format(PREVIOUS_GE_OFFER_EVENTS, hashDisplayName(displayName)));
        if (!file.exists()) {
            return null;
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            List<Offer> regularList = gson.fromJson(reader, new TypeToken<List<Offer>>(){}.getType());
            return new OfferList(regularList);
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading session data json file {}", file, e);
        }
        return null;
    }

    public static void storeGeOfferEvents(OfferList data, String displayName) {
        File file = new File(PARENT_DIRECTORY, String.format(PREVIOUS_GE_OFFER_EVENTS, hashDisplayName(displayName)));
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
            String json = gson.toJson(data);
            writer.write(json);
            writer.newLine();
        } catch (IOException e) {
            log.warn("error storing session data to file {}", file, e);
        }
        log.debug("stored {} current GE offers", displayName);
    }


    public static String hashDisplayName(String displayName) {
        if(displayName == null) {
            return "null";
        }
        // we hash the display name just to ensure that it's a valid file name
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            byte[] hashBytes = digest.digest(displayName.getBytes(StandardCharsets.UTF_8));
            StringBuilder hexString = new StringBuilder();
            for (byte b : hashBytes) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }

    public static void storeIsPaused(String displayName, boolean isPaused) {
        File file = new File(PARENT_DIRECTORY, String.format("%s_paused.json", hashDisplayName(displayName)));
        String text = isPaused ? "{\"isPaused\":true}" : "{\"isPaused\":false}";
        try {
            Files.write(file.toPath(), text.getBytes());
        } catch(IOException e) {
            log.warn("error storing paused.json file {}", file, e);
        }
    }

    public static boolean loadIsPaused(String displayName) {
        File file = new File(PARENT_DIRECTORY, String.format("%s_paused.json", hashDisplayName(displayName)));
        try {
            String text = Files.readString(file.toPath(), StandardCharsets.UTF_8);
            return text.contains("true");
        } catch (NoSuchFileException e){
            return false;
        } catch(IOException e) {
            log.warn("error loading paused.json file {}", file, e);
            return false;
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.Transaction;
import com.flippingcopilot.util.MutableReference;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import static com.flippingcopilot.util.AtomicReferenceUtils.ifPresent;

@Slf4j
public class TransactionManger {

    // dependencies
    private final AtomicReference<FlipManager> flipManager;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler api;

    // state
    private final String displayName;
    private final List<Transaction> unAckedTransactions;
    private boolean transactionSyncScheduled;
    public volatile boolean cancelOngoingSyncSignalled;

    public TransactionManger(AtomicReference<FlipManager> flipManager, ScheduledExecutorService executorService, ApiRequestHandler api, String displayName) {
        this.flipManager = flipManager;
        this.executorService = executorService;
        this.displayName = displayName;
        this.unAckedTransactions = Collections.synchronizedList(Persistance.loadUnAckedTransactions(displayName));
        this.api = api;
        scheduleSyncIn(0);
    }

    public void cancelOngoingSync() {
        this.cancelOngoingSyncSignalled = true;
    }

    public void syncUnAckedTransactions() {
        FlipManager fm = flipManager.get();
        if (fm == null || !fm.flipsLoaded) {
            scheduleSyncIn(1);
            return;
        }
        if(!unAckedTransactions.isEmpty()){
            try {
                long s = System.nanoTime();
                List<Transaction> toSend = new ArrayList<>(unAckedTransactions);
                fm.mergeFlips(api.SendTransactions(toSend, displayName), displayName);
                log.debug("sending transactions took {}ms", (System.nanoTime() - s) / 1000_000);
                toSend.forEach(unAckedTransactions::remove);
            } catch (Exception e) {
                log.warn("failed to send transactions to copilot server {}", e.getMessage(), e);
                scheduleSyncIn(10);
            }
        }
    }

    public long addTransaction(Transaction transaction) {
        unAckedTransactions.add(transaction);
        Persistance.storeUnAckedTransactions(unAckedTransactions, displayName);
        Persistance.storeTransaction(transaction, displayName);
        MutableReference<Long> profit = new MutableReference<>(0L);
        if (OfferStatus.SELL.equals(transaction.getType())) {
            ifPresent(flipManager, i -> profit.setValue(i.estimateTransactionProfit(displayName, transaction)));
        }
        // everything involving network calls to our server we run in the executor service to avoid possible blocking
        executorService.execute(this::syncUnAckedTransactions);
        return profit.getValue();
    }

    private synchronized void scheduleSyncIn(int seconds) {
        if (!transactionSyncScheduled && !cancelOngoingSyncSignalled) {
            log.info("scheduling attempt to re-sync transaction in {}s", seconds);
            executorService.schedule(() ->  {
                transactionSyncScheduled = false;
                this.syncUnAckedTransactions();
            }, seconds, TimeUnit.SECONDS);
            transactionSyncScheduled = true;
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.SessionData;
import lombok.Getter;

import java.time.Duration;
import java.time.Instant;

public class SessionManager {

    private final Runnable sessionStatsChangedCallback;
    private final SessionData data;
    @Getter private final String displayName;
    private Instant lastSessionUpdateTime;

    public SessionManager(String displayName, Runnable sessionStatsChangedCallback) {
        this.displayName = displayName;
        data = Persistance.loadSessionData(displayName);
        this.sessionStatsChangedCallback = sessionStatsChangedCallback;
    }

    public synchronized SessionData getData() {
        return new SessionData(data.startTime,  data.durationMillis, data.averageCash);
    }

    public synchronized void resetSession() {
        data.startTime = (int) Instant.now().getEpochSecond();
        data.averageCash = 0;
        data.durationMillis = 0;
        Persistance.storeSessionData(data, displayName);
        sessionStatsChangedCallback.run();
    }

    public synchronized void updateSessionStats(boolean currentlyFlipping, long cashStack) {
        if (!currentlyFlipping) {
            lastSessionUpdateTime = null;
        } else if (lastSessionUpdateTime == null) {
            lastSessionUpdateTime = Instant.now();
        } else {
            Instant now = Instant.now();
            long duration = Duration.between(lastSessionUpdateTime, now).toMillis();
            long newAverageCashStack = (cashStack * duration + data.durationMillis * data.averageCash) / (data.durationMillis + duration);
            data.durationMillis = data.durationMillis + duration;
            lastSessionUpdateTime = now;
            data.averageCash = newAverageCashStack;
            Persistance.storeSessionData(data, displayName);
            sessionStatsChangedCallback.run();
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;

import java.time.Instant;
import java.util.Objects;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class OfferHandler {

    private static final int GE_OFFER_INIT_STATE_CHILD_ID = 20;

    private FlippingCopilotPlugin plugin;

    @Getter
    private int lastViewedSlotItemId = -1;
    @Getter
    private int lastViewedSlotItemPrice = -1;
    @Getter
    private int lastViewedSlotPriceTime = 0;

    @Getter
    private int viewedSlotItemId = -1;
    @Getter
    private int viewedSlotItemPrice = -1;
    @Getter
    private String viewedSlotPriceErrorText = null;

    public OfferHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
    }

    public void fetchSlotItemPrice(boolean isViewingSlot) {
        if (isViewingSlot) {
            var currentItemId = plugin.client.getVarpValue(CURRENT_GE_ITEM);
            viewedSlotItemId = currentItemId;
            if (currentItemId == -1 || currentItemId == 0) return;

            var suggestion = plugin.suggestionHandler.getCurrentSuggestion();
            if (suggestion != null && suggestion.getItemId() == currentItemId &&
                    ((Objects.equals(suggestion.getType(), "sell") && isSelling()) ||
                            Objects.equals(suggestion.getType(), "buy") && isBuying())) {
                lastViewedSlotItemId = suggestion.getItemId();
                lastViewedSlotItemPrice = suggestion.getPrice();
                lastViewedSlotPriceTime = (int) Instant.now().getEpochSecond();
                return;
            }

            var fetchedPrice = plugin.apiRequestHandler.getItemPrice(currentItemId, plugin.osrsLoginHandler.getCurrentDisplayName());

            if (fetchedPrice == null) {
                viewedSlotPriceErrorText = "Unknown error";
                return;
            }

            if (fetchedPrice.getMessage() != null && !fetchedPrice.getMessage().isEmpty()) {
                viewedSlotPriceErrorText = fetchedPrice.getMessage();
            } else {
                viewedSlotPriceErrorText = null;
            }
            viewedSlotItemPrice = isSelling() ? fetchedPrice.getSellPrice() : fetchedPrice.getBuyPrice();
            lastViewedSlotItemId = viewedSlotItemId;
            lastViewedSlotItemPrice = viewedSlotItemPrice;
            lastViewedSlotPriceTime = (int) Instant.now().getEpochSecond();

            log.debug("fetched item {} price: {}", viewedSlotItemId,  viewedSlotItemPrice);
        } else {
            viewedSlotItemPrice = -1;
            viewedSlotItemId = -1;
            viewedSlotPriceErrorText = null;
        }
        plugin.highlightController.redraw();
    }

    public boolean isSettingQuantity() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();
        return chatInputText.equals("How many do you wish to buy?") || chatInputText.equals("How many do you wish to sell?");
    }

    public boolean isSettingPrice() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();

        var offerTextWidget = getOfferTextWidget();
        if (offerTextWidget == null) return false;
        String offerText = offerTextWidget.getText();
        return chatInputText.equals("Set a price for each item:") && (offerText.equals("Buy offer") || offerText.equals("Sell offer"));
    }


    private Widget getChatboxTitleWidget() {
        return plugin.client.getWidget(ComponentID.CHATBOX_TITLE);
    }

    private Widget getOfferTextWidget() {
        var offerContainerWidget = plugin.client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER);
        if (offerContainerWidget == null) return null;
        return offerContainerWidget.getChild(GE_OFFER_INIT_STATE_CHILD_ID);
    }

    public boolean isSelling() {
        return plugin.client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 1;
    }

    public boolean isBuying() {
        return plugin.client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 0;
    }

    public String getOfferType() {
        if (isBuying()) {
            return "buy";
        } else if (isSelling()) {
            return "sell";
        } else {
            return null;
        }
    }

    public void setSuggestedAction(Suggestion suggestion) {
        var currentItemId = plugin.client.getVarpValue(CURRENT_GE_ITEM);

        if (isSettingQuantity()) {
            if (suggestion == null || currentItemId != suggestion.getItemId()) {
                return;
            }
            setChatboxValue(suggestion.getQuantity());
        } else if (isSettingPrice()) {
            int price = -1;
            if (suggestion == null || currentItemId != suggestion.getItemId()) {
                if (viewedSlotItemId != currentItemId) {
                    return;
                }
                price = viewedSlotItemPrice;
            } else {
                price = suggestion.getPrice();
            }

            if (price == -1) return;

            setChatboxValue(price);
        }
    }

    public void setChatboxValue(int value) {
        var chatboxInputWidget = plugin.client.getWidget(ComponentID.CHATBOX_FULL_INPUT);
        if (chatboxInputWidget == null) return;
        chatboxInputWidget.setText(value + "*");
        plugin.client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(value));
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.HttpResponseException;
import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.ui.SuggestionPanel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatMessageBuilder;

import java.awt.*;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;

@Slf4j
@Getter
@Setter
public class SuggestionHandler {
    private Timer timer;
    private boolean suggestionNeeded;
    private Suggestion currentSuggestion;
    private FlippingCopilotPlugin plugin;
    private SuggestionPanel suggestionPanel;
    private boolean collectNeeded;

    private boolean isPaused = false;

    public SuggestionHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        this.suggestionPanel = plugin.mainPanel.copilotPanel.suggestionPanel;
        suggestionNeeded = false;
        collectNeeded = false;
        resetTimer();
    }

    public void togglePause() {
        if (isPaused) {
            unpause();
        } else {
            pause();
        }
    }

    public void pause() {
        isPaused = true;
        suggestionPanel.setIsPausedMessage();
        currentSuggestion = null;
        plugin.highlightController.removeAll();
        plugin.accountStatus.setSuggestionsPaused(true);
        Persistance.storeIsPaused(plugin.osrsLoginHandler.getCurrentDisplayName(), true);
    }

    public void unpause() {
        isPaused = false;
        suggestionNeeded = true;
        if (!plugin.osrsLoginHandler.isLoggedIn()) {
            suggestionPanel.suggestLogin();
        }
        plugin.accountStatus.setSuggestionsPaused(false);
        Persistance.storeIsPaused(plugin.osrsLoginHandler.getCurrentDisplayName(), false);
    }

    public void resetTimer() {
        if (timer != null) {
            timer.cancel();
        }
        timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                suggestionNeeded = true;
            }
        }, 10000);
    }

    public void skipCurrentSuggestion() {
        if (currentSuggestion != null) {
            plugin.accountStatus.setSkipSuggestion(currentSuggestion.getId());
        }
        suggestionNeeded = true;
    }

    void onGameTick() {
        if (suggestionNeeded && !(plugin.grandExchange.isSlotOpen() && !plugin.accountStatus.isSuggestionSkipped())) {
            getSuggestionAsync();
        }
    }

    public void getSuggestionAsync() {
        suggestionNeeded = false;
        plugin.executorService.execute(this::getSuggestion);
    }

    private void getSuggestion() {
        if (!plugin.osrsLoginHandler.isLoggedIn() || !plugin.copilotLoginController.isLoggedIn()) {
            return;
        }
        suggestionPanel.showLoading();
        try {
            log.debug("Getting suggestion");
            Suggestion oldSuggestion = currentSuggestion;
            currentSuggestion = plugin.apiRequestHandler.getSuggestion(plugin.accountStatus);

            // We moved isPaused check to here so the client would still send suggestion requests to the server
            // This way the server would still know about the offers to keep the server accurate
            if (isPaused) {
                suggestionPanel.setIsPausedMessage();
                return;
            }

            log.debug("Received suggestion: {}", currentSuggestion.toString());
            plugin.accountStatus.resetSkipSuggestion();
            plugin.gameUiChangesHandler.offerJustPlaced = false;
            displaySuggestion();
            showNotifications(oldSuggestion);
        } catch (HttpResponseException e) {
            handleHttpException(e);
        } catch (IOException e) {
            log.error("Error occurred while getting suggestion: ", e);
            suggestionPanel.setMessage(e.getMessage());
        } finally {
            resetTimer();
            suggestionPanel.hideLoading();
        }
    }

    void displaySuggestion() {
        if (plugin.osrsLoginHandler.isInvalidState()) {
            return;
        }
        suggestionPanel.setServerMessage(currentSuggestion.getMessage());
        collectNeeded = false;
        if (plugin.accountStatus.isCollectNeeded(currentSuggestion)) {
            collectNeeded = true;
            suggestionPanel.suggestCollect();
        } else if (currentSuggestion.getType().equals("wait") && plugin.accountStatus.moreGpNeeded()) {
            suggestionPanel.suggestAddGp();
        } else {
            suggestionPanel.updateSuggestion(currentSuggestion);
        }
        plugin.clientThread.invokeLater(() -> plugin.highlightController.redraw());
    }

    void showNotifications(Suggestion oldSuggestion) {
        if (shouldNotify(currentSuggestion, oldSuggestion)) {
            if (plugin.config.enableTrayNotifications()) {
                plugin.notifier.notify(currentSuggestion.toMessage());
            }
            if (!plugin.mainPanel.copilotPanel.isShowing() && plugin.config.enableChatNotifications()) {
                showChatNotifications();
            }
        }
    }

    static boolean shouldNotify(Suggestion newSuggestion, Suggestion oldSuggestion) {
        if (newSuggestion.getType().equals("wait")) {
            return false;
        }
        if (oldSuggestion != null && newSuggestion.equals(oldSuggestion)) {
            return false;
        }
        return true;
    }

    private void showChatNotifications() {
        if (plugin.accountStatus.isCollectNeeded(currentSuggestion)) {
            plugin.clientThread.invokeLater(() -> showChatNotification("Flipping Copilot: Collect items"));
        }
        plugin.clientThread.invokeLater(() -> showChatNotification(currentSuggestion.toMessage()));
    }

    private void showChatNotification(String message) {
        String chatMessage = new ChatMessageBuilder()
                .append(new Color(0x0040FF), message)
                .build();
        plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", chatMessage, "");
    }

    private void handleHttpException(HttpResponseException e) {
        if (e.getResponseCode() == 401) {
            plugin.copilotLoginController.onLogout();
            plugin.mainPanel.renderLoggedOutView();
            plugin.mainPanel.loginPanel.showLoginErrorMessage("Login timed out. Please log in again");
        } else {
            log.error("Error occurred while getting suggestion: ", e);
            suggestionPanel.setMessage("Error: " + e.getMessage());
        }
    }
}

package com.flippingcopilot.controller;

import java.util.function.Consumer;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

import com.flippingcopilot.ui.LoginPanel;
import com.flippingcopilot.model.LoginResponse;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import static com.flippingcopilot.util.AtomicReferenceUtils.ifPresent;

@Slf4j
public class CopilotLoginController {
    @Getter
    LoginPanel panel;
    private String email;
    private String password;
    private final Runnable changeToLoggedInViewRunnable;
    private final ApiRequestHandler apiRequestHandler;
    private final FlippingCopilotPlugin plugin;
    @Setter
    @Getter
    private boolean loggedIn = false;


    public CopilotLoginController(Runnable changeToLoggedInViewRunnable, FlippingCopilotPlugin plugin) {
        this.changeToLoggedInViewRunnable = changeToLoggedInViewRunnable;
        Consumer<String> onEmailTextChangedListener = this::onEmailTextChanged;
        Consumer<String> onPasswordTextChangedListener = this::onPasswordTextChanged;
        ActionListener onLoginPressedListener = this::onLoginPressed;
        this.panel = new LoginPanel(
                onEmailTextChangedListener,
                onPasswordTextChangedListener,
                onLoginPressedListener
        );
        this.plugin = plugin;
        this.apiRequestHandler = plugin.apiRequestHandler;
    }

    public void onLoginPressed(ActionEvent event) {
        Consumer<LoginResponse> loginCallback = loginResponse -> {
            if (loginResponse != null && !loginResponse.error) {
                changeToLoggedInViewRunnable.run();
                loggedIn = true;
                if (plugin.osrsLoginHandler.isLoggedIn()) {
                    plugin.suggestionHandler.setSuggestionNeeded(true);
                    ifPresent(plugin.flipManager, FlipManager::cancelFlipLoading);
                }
                FlipManager fm = new FlipManager(plugin.apiRequestHandler, plugin.executorService, () -> plugin.mainPanel.copilotPanel.statsPanel.updateStatsAndFlips(true));
                plugin.flipManager.set(fm);
                ifPresent(plugin.sessionManager, i -> {
                    fm.setIntervalDisplayName(i.getDisplayName());
                    fm.setIntervalStartTime(i.getData().startTime);
                });
            } else {
                String message = "Login failed";
                if(loginResponse != null) {
                    message = loginResponse.message;
                }
                panel.showLoginErrorMessage(message);
            }
            Persistance.saveLoginResponse(loginResponse);
            panel.endLoading();
        };

        if (this.email == null || this.password == null) {
            return;
        }
        panel.startLoading();
        apiRequestHandler.authenticate(this.email, this.password, loginCallback);
    }

    public void onLogout() {
        loggedIn = false;
        apiRequestHandler.onLogout();
        Persistance.deleteLoginResponse();
        plugin.suggestionHandler.setCurrentSuggestion(null);
        plugin.highlightController.removeAll();
    }

    public void onEmailTextChanged(String newEmail) {
        this.email = newEmail;
    }

    public void onPasswordTextChanged(String newPassword) {
        this.password = newPassword;
    }
}

package com.flippingcopilot.controller;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

public class GrandExchange {
    private final Client client;
    private final static int CURRENTLY_OPEN_GE_SLOT_VARBIT_ID = 4439;
    final static int SHOW_LAST_SEARCHED_VARBIT_ID = 10295;

    GrandExchange(Client client) {
        this.client = client;
    }

    boolean isHomeScreenOpen() {
        return isOpen() && !isSlotOpen();
    }

    boolean isSlotOpen() {
        return getOpenSlot() != -1;
    }

    boolean isOpen() {
        return client.getWidget(465, 7) != null;
    }

    int getOpenSlot() {
        return client.getVarbitValue(CURRENTLY_OPEN_GE_SLOT_VARBIT_ID) - 1;
    }

    Widget getSlotWidget(int slot) {
        return client.getWidget(465, 7 + slot);
    }

    Widget getBuyButton(int slot) {
        Widget slotWidget = getSlotWidget(slot);
        if (slotWidget == null) {
            return null;
        }
        return slotWidget.getChild(0);
    }

    Widget getCollectButton() {
        Widget topBar = client.getWidget(465, 6);
        if (topBar == null) {
            return null;
        }
        return topBar.getChild(1);
    }

    Widget getOfferContainerWidget() {
        return client.getWidget(465, 25);
    }

    Widget getOfferTypeWidget() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(20);
    }

    Widget getConfirmButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(58);
    }

    int getOfferQuantity() {
        return client.getVarbitValue(4396);
    }

    int getOfferPrice() {
        return client.getVarbitValue(4398);
    }

    public boolean isPreviousSearchSet() {
        return client.getVarpValue(2674) != -1;
    }

    public boolean showLastSearchEnabled() {
        return client.getVarbitValue(SHOW_LAST_SEARCHED_VARBIT_ID) == 0;
    }

    public Widget getSetQuantityButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(51);
    }

    public Widget getSetPriceButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(54);
    }

    public Widget getSetQuantityAllButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(50);
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.ui.UIUtilities;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;


@ConfigGroup("flippingcopilot")
public interface FlippingCopilotConfig extends Config
{
    public enum PriceGraphWebsite
    {
        OSRS_WIKI("OSRS Wiki"),
        GE_TRACKER("GE Tracker"),
        PLATINUM_TOKENS("PlatinumTokens"),
        GE_DATABASE("GE Database"),
        OSRS_CLOUD("Osrs.cloud"),
        OSRS_EXCHANGE("OSRS Exchange");

        private final String name;
        PriceGraphWebsite(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name;
        }

        public String getUrl(String itemName, int itemId)
        {
            switch (this)
            {
                case OSRS_WIKI:
                    return "https://prices.runescape.wiki/osrs/item/" + itemId;
                case GE_TRACKER:
                    return "https://www.ge-tracker.com/item/" + itemId;
                case PLATINUM_TOKENS:
                    String platinumTokensFormattedName = itemName
                            .toLowerCase()
                            .replace("'", "")
                            .replace("(", " ")
                            .replace(")", "")
                            .replace("+", " plus")
                            .replace("  ", " ")
                            .replace(" ", "-");
                    return "https://platinumtokens.com/item/" + platinumTokensFormattedName;
                case GE_DATABASE:
                    return "https://secure.runescape.com/m=itemdb_oldschool/viewitem?obj=" + itemId;
                case OSRS_EXCHANGE:
                    String osrsExchangeFormattedName = itemName.toLowerCase().replace(' ','-');
                    return "https://www.osrs.exchange/item/"
                            + URLEncoder.encode(osrsExchangeFormattedName, StandardCharsets.UTF_8);
                case OSRS_CLOUD:
                    return "https://prices.osrs.cloud/item/" + itemId;
                default:
                    return "";
            }
        }
    }


    @ConfigItem(
            keyName = "enableChatNotifications",
            name = "Enable chat notifications",
            description = "Show chat notifications for suggested action when the side panel is closed."
    )
    default boolean enableChatNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "enableTrayNotifications",
            name = "Enable tray notifications",
            description = "Show tray notifications for suggested action when runelite is out of focus."
    )
    default boolean enableTrayNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "profitAmountColor",
            name = "Flip tracker profit color",
            description = "The color of the profit amount text in the flip tracker"
    )
    default Color profitAmountColor() {
        return ColorScheme.GRAND_EXCHANGE_PRICE;
    }
    @ConfigItem(
            keyName = "lossAmountColor",
            name = "Flip tracker loss color",
            description = "The color of the loss amount text in the flip tracker"
    )
    default Color lossAmountColor() {
        return UIUtilities.OUTDATED_COLOR;
    }
    @ConfigItem(
            keyName = "webhook",
            name = "Webhook URL",
            description = "The Discord Webhook URL for sending display name and profit."
    )
    String webhook();
    @ConfigItem(
            keyName = "priceGraphWebsite",
            name = "Graph button site",
            description = "The website to open when the graph button is clicked."
    )
    default PriceGraphWebsite priceGraphWebsite()
    {
        return PriceGraphWebsite.OSRS_WIKI;
    }
    @ConfigItem(
            keyName = "suggestionHighlights",
            name = "Highlight suggested actions",
            description = "Show highlight overlays on the GE interface for suggested actions."
    )
    default boolean suggestionHighlights()
    {
        return true;
    }
    @ConfigItem(
            keyName = "quickSetKeybind",
            name = "Price/quantity set keybind",
            description = "Keybind to quickly set the price or quantity of a GE offer to the suggested value"
    )
    default Keybind quickSetKeybind()
    {
        return new Keybind(KeyEvent.VK_E, 0);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class GameUiChangesHandler {
    private static final int GE_HISTORY_TAB_WIDGET_ID = 149;
    private final FlippingCopilotPlugin plugin;
    boolean quantityOrPriceChatboxOpen;
    boolean itemSearchChatboxOpen = false;
    @Getter
    boolean offerJustPlaced = false;
    GameUiChangesHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
    }

    public void onVarClientIntChanged(VarClientIntChanged event) {
        Client client = plugin.getClient();

        if (event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 14
                && client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS) != null) {
            itemSearchChatboxOpen = true;
            plugin.getClientThread().invokeLater(plugin.gePreviousSearch::showSuggestedItemInSearch);
        }

        if (quantityOrPriceChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            quantityOrPriceChatboxOpen = false;
            return;
        }

        if (itemSearchChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            plugin.getClientThread().invokeLater(plugin.highlightController::redraw);
            itemSearchChatboxOpen = false;
            return;
        }

        //Check that it was the chat input that got enabled.
        if (event.getIndex() != VarClientInt.INPUT_TYPE
                || client.getWidget(ComponentID.CHATBOX_TITLE) == null
                || client.getVarcIntValue(VarClientInt.INPUT_TYPE) != 7
                || client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) == null) {
            return;
        }
        quantityOrPriceChatboxOpen = true;

        plugin.getClientThread().invokeLater(() ->
        {
            OfferEditor flippingWidget = new OfferEditor(client.getWidget(ComponentID.CHATBOX_CONTAINER), plugin);
            Suggestion suggestion = plugin.suggestionHandler.getCurrentSuggestion();
            flippingWidget.showSuggestion(suggestion);
        });
    }

    public void onVarClientStrChanged(VarClientStrChanged event) {
        if (event.getIndex() == VarClientStr.INPUT_TEXT && itemSearchChatboxOpen) {
            plugin.getClientThread().invokeLater(plugin.highlightController::redraw);
        }
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == 383
                || event.getGroupId() == InterfaceID.GRAND_EXCHANGE
                || event.getGroupId() == 213
                || event.getGroupId() == GE_HISTORY_TAB_WIDGET_ID) {
            plugin.getClientThread().invokeLater(plugin.highlightController::redraw);
        }
    }

    public void onWidgetClosed(WidgetClosed event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            plugin.getClientThread().invokeLater(plugin.highlightController::removeAll);
        }
    }

    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarpId() == 375
                || event.getVarpId() == CURRENT_GE_ITEM
                || event.getVarbitId() == 4396
                || event.getVarbitId() == 4398
                || event.getVarbitId() == 4439) {
            plugin.getClientThread().invokeLater(plugin.highlightController::redraw);
        }

        if (event.getVarpId() == CURRENT_GE_ITEM) {
            plugin.getClientThread().invokeLater(() -> plugin.offerHandler.fetchSlotItemPrice(event.getValue() > -1));
        }
    }

    public void handleMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals("Confirm") && plugin.grandExchange.isSlotOpen()) {
            offerJustPlaced = true;
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.ui.WidgetHighlightOverlay;
import net.runelite.api.ItemComposition;
import net.runelite.api.VarClientStr;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;

import java.awt.*;
import java.util.ArrayList;

import static com.flippingcopilot.ui.UIUtilities.BLUE_HIGHLIGHT_COLOR;
import static com.flippingcopilot.ui.UIUtilities.RED_HIGHLIGHT_COLOR;
import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;
import static net.runelite.api.Varbits.GE_OFFER_CREATION_TYPE;

public class HighlightController {
    FlippingCopilotPlugin plugin;
    private final ArrayList<WidgetHighlightOverlay> highlightOverlays = new ArrayList<>();

    public HighlightController(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
    }

    public void redraw() {
        removeAll();
        if(!plugin.config.suggestionHighlights()) {
            return;
        }
        if (plugin.gameUiChangesHandler.isOfferJustPlaced()) {
            return;
        }
        Suggestion suggestion = plugin.suggestionHandler.getCurrentSuggestion();
        if (suggestion == null) {
            return;
        }
        if (plugin.grandExchange.isHomeScreenOpen()) {
            drawHomeScreenHighLights(suggestion);
        } else if (plugin.grandExchange.isSlotOpen()) {
            drawOfferScreenHighlights(suggestion);
        }
    }

    private void drawHomeScreenHighLights(Suggestion suggestion) {
        if (plugin.suggestionHandler.isCollectNeeded()) {
            Widget collectButton = plugin.grandExchange.getCollectButton();
            if (collectButton != null) {
                add(collectButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(2, 1, 81, 18));
            }
        }
        else if (suggestion.getType().equals("abort")) {
            Widget slotWidget = plugin.grandExchange.getSlotWidget(suggestion.getBoxId());
            add(slotWidget, RED_HIGHLIGHT_COLOR);
        }
        else if (suggestion.getType().equals("buy")) {
            int slotId = plugin.accountStatus.getOffers().findEmptySlot();
            if (slotId != -1) {
                Widget buyButton = plugin.grandExchange.getBuyButton(slotId);
                if (buyButton != null && !buyButton.isHidden()) {
                    add(buyButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(0, 0, 45, 44));
                }
            }
        }
        else if (suggestion.getType().equals("sell")) {
            Widget itemWidget = getInventoryItemWidget(suggestion.getItemId());
            if (itemWidget != null && !itemWidget.isHidden()) {
                add(itemWidget, BLUE_HIGHLIGHT_COLOR, new Rectangle(0, 0, 34, 32));
            }
        }
    }

    private void drawOfferScreenHighlights(Suggestion suggestion) {
        Widget offerTypeWidget = plugin.grandExchange.getOfferTypeWidget();
        String offerType = plugin.client.getVarbitValue(GE_OFFER_CREATION_TYPE) == 1 ? "sell" : "buy";
        if (offerTypeWidget != null) {
            if (offerType.equals(suggestion.getType())) {
                if (plugin.client.getVarpValue(CURRENT_GE_ITEM) == suggestion.getItemId()) {
                    if (offerDetailsCorrect(suggestion)) {
                        highlightConfirm();
                    } else {
                        if (plugin.grandExchange.getOfferPrice() != suggestion.getPrice()) {
                            highlightPrice();
                        }
                        highlightQuantity(suggestion);
                    }
                } else if (plugin.client.getVarpValue(CURRENT_GE_ITEM ) == -1){
                    highlightItemInSearch(suggestion);
                }
            }
            // Check if unsuggested item/offer type is selected
            if (plugin.client.getVarpValue(CURRENT_GE_ITEM) != -1
                    && (plugin.client.getVarpValue(CURRENT_GE_ITEM) != suggestion.getItemId()
                        || !offerType.equals(suggestion.getType()))
                    && plugin.client.getVarpValue(CURRENT_GE_ITEM) == plugin.offerHandler.getViewedSlotItemId()
                    && plugin.offerHandler.getViewedSlotItemPrice() > 0) {
                if (plugin.grandExchange.getOfferPrice() == plugin.offerHandler.getViewedSlotItemPrice()) {
                    highlightConfirm();
                } else {
                    highlightPrice();
                }
            }
        }
    }

    private void highlightItemInSearch(Suggestion suggestion) {
        if (!plugin.client.getVarcStrValue(VarClientStr.INPUT_TEXT).isEmpty()) {
            return;
        }
        Widget searchResults = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        if (searchResults == null) {
            return;
        }
        for (Widget widget : searchResults.getDynamicChildren()) {
            if (widget.getName().equals("<col=ff9040>" + suggestion.getName() + "</col>")) {
                add(widget, BLUE_HIGHLIGHT_COLOR);
                return;
            }
        }
        Widget itemWidget = searchResults.getChild(3);
        if (itemWidget != null && itemWidget.getItemId() == suggestion.getItemId()) {
            add(itemWidget, BLUE_HIGHLIGHT_COLOR);
        }
    }

    private boolean offerDetailsCorrect(Suggestion suggestion) {
        return plugin.grandExchange.getOfferPrice() == suggestion.getPrice()
                && plugin.grandExchange.getOfferQuantity() == suggestion.getQuantity();
    }

    private void highlightPrice() {
        Widget setPriceButton = plugin.grandExchange.getSetPriceButton();
        if (setPriceButton != null) {
            add(setPriceButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(1, 6, 33, 23));
        }
    }

    private void highlightQuantity(Suggestion suggestion) {
        if (plugin.grandExchange.getOfferQuantity() != suggestion.getQuantity()) {
            Widget setQuantityButton;
            if (plugin.accountStatus.getInventory().getTotalAmount(suggestion.getItemId()) == suggestion.getQuantity()) {
                setQuantityButton = plugin.grandExchange.getSetQuantityAllButton();
            } else {
                setQuantityButton = plugin.grandExchange.getSetQuantityButton();
            }
            if (setQuantityButton != null) {
                add(setQuantityButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(1, 6, 33, 23));
            }
        }
    }

    private void highlightConfirm() {
        Widget confirmButton = plugin.grandExchange.getConfirmButton();
        if (confirmButton != null) {
            add(confirmButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(1, 1, 150, 38));
        }
    }

    private void add(Widget widget, Color color, Rectangle adjustedBounds) {
        WidgetHighlightOverlay overlay = new WidgetHighlightOverlay(widget, color, adjustedBounds);
        highlightOverlays.add(overlay);
        plugin.overlayManager.add(overlay);
    }

    private void add(Widget widget, Color color) {
        add(widget, color, new Rectangle(0, 0, widget.getWidth(), widget.getHeight()));
    }

    public void removeAll() {
        highlightOverlays.forEach(plugin.overlayManager::remove);
        highlightOverlays.clear();
    }

    private Widget getInventoryItemWidget(int unnotedItemId) {
        // Inventory has a different widget if GE is open
        Widget inventory = plugin.getClient().getWidget(467, 0);
        if (inventory == null) {
            inventory = plugin.getClient().getWidget(149, 0);
            if (inventory == null) {
                return null;
            }
        }

        Widget notedWidget = null;
        Widget unnotedWidget = null;

        for (Widget widget : inventory.getDynamicChildren()) {
            int itemId = widget.getItemId();
            ItemComposition itemComposition = plugin.client.getItemDefinition(itemId);

            if (itemComposition.getNote() != -1) {
                if (itemComposition.getLinkedNoteId() == unnotedItemId) {
                    notedWidget = widget;
                }
            } else if (itemId == unnotedItemId) {
                unnotedWidget = widget;
            }
        }
        return notedWidget != null ? notedWidget : unnotedWidget;
    }
}

package com.flippingcopilot.controller;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;

@Slf4j
public class SlotOfferEventFilter {
    @Getter
    private GrandExchangeOfferChanged slotPreviousEvent;
    private boolean emptyLoginEventReceived = false;

    boolean shouldProcess(GrandExchangeOfferChanged event) {
        boolean isEmpty = event.getOffer().getState().equals(GrandExchangeOfferState.EMPTY);

        if (!emptyLoginEventReceived && isEmpty) {
            log.debug("skipping event because its the empty login event: {}", event);
            emptyLoginEventReceived = true;
            return false;
        }
        if (slotPreviousEvent != null && eventsEqual(slotPreviousEvent, event)) {
            log.debug("skipping event because it is equal to previous event: {}", event);
            return false;
        }

        emptyLoginEventReceived = true;
        slotPreviousEvent = event;
        log.debug("processing event {}", event);

        return true;
    }

    private static boolean eventsEqual(GrandExchangeOfferChanged event1, GrandExchangeOfferChanged event2) {
        GrandExchangeOffer offer1 = event1.getOffer();
        GrandExchangeOffer offer2 = event2.getOffer();
        return offer1.getItemId() == offer2.getItemId()
                && offer1.getQuantitySold() == offer2.getQuantitySold()
                && offer1.getTotalQuantity() == offer2.getTotalQuantity()
                && offer1.getPrice() == offer2.getPrice()
                && offer1.getSpent() == offer2.getSpent()
                && offer1.getState() == offer2.getState();
    }

    void onLogout() {
        emptyLoginEventReceived = false;
    }
    void setToLoggedIn() {
        emptyLoginEventReceived = true;
    }
}

package com.flippingcopilot.controller;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.WorldType;
import net.runelite.api.events.GameStateChanged;

import static com.flippingcopilot.util.AtomicReferenceUtils.ifPresent;

@Slf4j
public class OsrsLoginHandler {
    private boolean previouslyLoggedIn;
    @Getter
    private String currentDisplayName;
    @Getter
    private String previousDisplayName;
    private final FlippingCopilotPlugin plugin;
    private final WorldType[] unSupportedWorlds = {WorldType.BETA_WORLD,
                                                    WorldType.DEADMAN,
                                                    WorldType.FRESH_START_WORLD,
                                                    WorldType.NOSAVE_MODE,
                                                    WorldType.PVP_ARENA,
                                                    WorldType.SEASONAL,
                                                    WorldType.QUEST_SPEEDRUNNING,
                                                    WorldType.TOURNAMENT_WORLD};

    @Getter
    private boolean invalidState = true;

    OsrsLoginHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        previouslyLoggedIn = false;
        currentDisplayName = null;
    }

    boolean isLoggedIn() {
        return currentDisplayName != null;
    }


    void init() {
        if (plugin.client.getGameState() == GameState.LOGGED_IN) {
            onLoggedInGameState();
            plugin.offerEventFilter.setToLoggedIn();
            plugin.accountStatus.setOffers(plugin.client.getGrandExchangeOffers());
        }
    }

    void handleGameStateChanged(GameStateChanged event) {
        log.debug("handling logged in game state {}", plugin.client.getGameState());
        if (event.getGameState() == GameState.HOPPING) {
            log.debug("setting expect empty offers due to hopping world");
            plugin.offerEventFilter.setExpectEmptyOffers();
        } else if (event.getGameState() == GameState.LOGGED_IN) {
            onLoggedInGameState();
        }  else if (event.getGameState() == GameState.LOGIN_SCREEN && previouslyLoggedIn) {
            //this randomly fired at night hours after i had logged off...so i'm adding this guard here.
            if (currentDisplayName != null && plugin.client.getGameState() != GameState.LOGGED_IN) {
                handleLogout();
            }
        }
    }

    private String loadPlayerDisplayName() {
        final Player player = plugin.client.getLocalPlayer();
        if (player != null) {
            final String name = player.getName();
            if (name != null && !name.isEmpty()) {
                return name;
            }
        }
        return null;
    }

    private void onLoggedInGameState() {
        if (plugin.client.getGameState() != GameState.LOGGED_IN) {
            return;
        }
        String name = loadPlayerDisplayName();
        if (name != null) {
            previouslyLoggedIn = true;
            handleLogin(name);
        } else {
            log.debug("unable to get player display name immediately after login");
            // note: for some reason when the LOGGED_IN event is received the local player may not be set yet
            //keep scheduling this task until it returns true (when we have access to a display name)
            plugin.clientThread.invokeLater(() ->
            {
                if (plugin.client.getGameState() != GameState.LOGGED_IN) {
                    return true;
                }
                final String name2 = loadPlayerDisplayName();
                if(name2 == null) {
                    return false;
                }
                previouslyLoggedIn = true;
                handleLogin(name2);
                return true;
            });
        }

    }

    public void handleLogin(String displayName) {
        log.debug("{} logging in", displayName);
        SessionManager sm = new SessionManager(displayName, () -> plugin.mainPanel.copilotPanel.statsPanel.updateStatsAndFlips(false));
        plugin.sessionManager.set(sm);
        ifPresent(plugin.flipManager, i -> {
            i.setIntervalDisplayName(sm.getDisplayName());
            i.setIntervalStartTime(sm.getData().startTime);
        });
        ifPresent(plugin.transactionManager, TransactionManger::cancelOngoingSync);
        TransactionManger tm = new TransactionManger(plugin.flipManager, plugin.executorService, plugin.apiRequestHandler, displayName);
        plugin.transactionManager.set(tm);

        plugin.mainPanel.copilotPanel.statsPanel.isLoggedOut = false;
        plugin.mainPanel.copilotPanel.statsPanel.resetIntervalDropdownToSession();
        plugin.mainPanel.copilotPanel.statsPanel.resetRsAccountDropdown();
        plugin.mainPanel.copilotPanel.statsPanel.updateStatsAndFlips(true);

        for (WorldType worldType : unSupportedWorlds) {
            if (plugin.client.getWorldType().contains(worldType)) {
                log.info("World is a {}", worldType);
                plugin.mainPanel.copilotPanel.suggestionPanel.setMessage(worldType + " worlds<br>are not supported");
                invalidState = true;
                return;
            }
        }

        if (plugin.client.getAccountType().isIronman()) {
            log.info("account is an ironman");
            plugin.mainPanel.copilotPanel.suggestionPanel.setMessage("Ironman accounts<br>are not supported");
            invalidState = true;
            return;
        }
        plugin.accountStatus.setMember(plugin.client.getWorldType().contains(WorldType.MEMBERS));
        plugin.accountStatus.setDisplayName(displayName);
        currentDisplayName = displayName;
        if (!currentDisplayName.equals(previousDisplayName)) {
            plugin.accountStatus.loadPreviousOffers(currentDisplayName);
        }
        previousDisplayName = displayName;
        log.debug("setting expect empty offers due to osrs login");
        plugin.offerEventFilter.setExpectEmptyOffers();
        plugin.mainPanel.copilotPanel.suggestionPanel.pauseButton.setPausedState(Persistance.loadIsPaused(displayName));

        invalidState = false;
        plugin.processQueuedOfferEvents();
    }

    public void handleLogout() {
        log.debug("{} is logging out", currentDisplayName);
        plugin.mainPanel.copilotPanel.statsPanel.isLoggedOut = true;
        log.debug("setting expect empty offers due to osrs logout");
        plugin.offerEventFilter.setExpectEmptyOffers();
        plugin.accountStatus.onLogout(currentDisplayName);
        currentDisplayName = null;
        plugin.mainPanel.copilotPanel.statsPanel.updateStatsAndFlips(true);
        plugin.mainPanel.copilotPanel.suggestionPanel.suggestLogin();
        invalidState = true;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.AccountStatus;
import com.flippingcopilot.model.LoginResponse;
import com.flippingcopilot.model.Transaction;
import com.flippingcopilot.ui.GePreviousSearch;
import com.flippingcopilot.ui.GpDropOverlay;
import com.flippingcopilot.ui.MainPanel;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import okhttp3.*;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import static com.flippingcopilot.util.AtomicReferenceUtils.ifBothPresent;
import static com.flippingcopilot.util.AtomicReferenceUtils.ifPresent;

@Slf4j
@PluginDescriptor(
		name = "Flipping Copilot",
		description = "Your AI assistant for trading"
)
public class FlippingCopilotPlugin extends Plugin {
	@Inject
	@Getter
	public Client client;
	@Inject
	@Getter
	ClientThread clientThread;
	@Inject
	public KeyManager keyManager;
	@Inject
	public FlippingCopilotConfig config;
	@Inject
	ScheduledExecutorService executorService;
	@Inject
	ClientToolbar clientToolbar;
	@Inject
	Notifier notifier;
	@Inject
	public OverlayManager overlayManager;
	@Inject
	public Gson gson;
	@Inject
	public OkHttpClient okHttpClient;
	public ApiRequestHandler apiRequestHandler;
	NavigationButton navButton;
	public final AccountStatus accountStatus = new AccountStatus();
	public SuggestionHandler suggestionHandler;
	public GrandExchange grandExchange;
	public OsrsLoginHandler osrsLoginHandler;

	GameUiChangesHandler gameUiChangesHandler;
	GrandExchangeCollectHandler grandExchangeCollectHandler;
	OfferEventFilter offerEventFilter;

	public final AtomicReference<FlipManager> flipManager = new AtomicReference<>(null);
	public final AtomicReference<TransactionManger> transactionManager = new AtomicReference<>(null);
	public final AtomicReference<SessionManager> sessionManager = new AtomicReference<>(null);

	MainPanel mainPanel;
	public CopilotLoginController copilotLoginController;

	@Inject
	private WebHookController webHookController;

	public HighlightController highlightController;
	GePreviousSearch gePreviousSearch;
	KeybindHandler keybindHandler;
	public OfferHandler offerHandler;

	@Override
	protected void startUp() throws Exception {
		Persistance.setUp(gson);
		apiRequestHandler = new ApiRequestHandler(gson, okHttpClient);
		mainPanel = new MainPanel(config, flipManager, sessionManager, webHookController);
		suggestionHandler = new SuggestionHandler(this);
		grandExchange = new GrandExchange(client);
		grandExchangeCollectHandler = new GrandExchangeCollectHandler(accountStatus, suggestionHandler);
		offerEventFilter = new OfferEventFilter();
		osrsLoginHandler = new OsrsLoginHandler(this);
		gameUiChangesHandler = new GameUiChangesHandler(this);
		copilotLoginController = new CopilotLoginController(() -> mainPanel.renderLoggedInView(), this);
		highlightController = new HighlightController(this);
		gePreviousSearch = new GePreviousSearch(this);
		keybindHandler = new KeybindHandler(this);
		offerHandler = new OfferHandler(this);
		mainPanel.init(this);
		setUpNavButton();
		setUpLogin();
		osrsLoginHandler.init();
		executorService.scheduleAtFixedRate(() -> {
			boolean isFlipping = osrsLoginHandler.isLoggedIn() && accountStatus.currentlyFlipping();
			ifPresent(sessionManager, s -> s.updateSessionStats(isFlipping, accountStatus.currentCashStack()));
		}, 2000, 1000, TimeUnit.MILLISECONDS);
	}

	private void setUpNavButton() {
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon-small.png");
		navButton = NavigationButton.builder()
				.tooltip("Flipping Copilot")
				.icon(icon)
				.priority(3)
				.panel(mainPanel)
				.build();
		clientToolbar.addNavigation(navButton);
	}

	private void setUpLogin() throws IOException {
		LoginResponse loginResponse = Persistance.loadLoginResponse();
		boolean isLoggedIn = loginResponse != null && !loginResponse.error && loginResponse.jwt != null;
		if (isLoggedIn) {
			apiRequestHandler.setLoginResponse(loginResponse);
			mainPanel.renderLoggedInView();
			copilotLoginController.setLoggedIn(true);
			ifPresent(this.flipManager, FlipManager::cancelFlipLoading);
			FlipManager fm = new FlipManager(this.apiRequestHandler, this.executorService, () -> this.mainPanel.copilotPanel.statsPanel.updateStatsAndFlips(true));
			this.flipManager.set(fm);
			ifPresent(this.sessionManager, i -> {
				fm.setIntervalDisplayName(i.getDisplayName());
				fm.setIntervalStartTime(i.getData().startTime);
			});
		}
	}


	@Override
	protected void shutDown() throws Exception {
		highlightController.removeAll();
		clientToolbar.removeNavigation(navButton);
		ifBothPresent(sessionManager, flipManager, (sm, fm) -> {
			accountStatus.onLogout(sm.getDisplayName());
			webHookController.sendMessage(fm.calculateStats(sm.getData().startTime, sm.getDisplayName()), sm.getData(), sm.getDisplayName(), false);
		});
		keybindHandler.unregister();
	}

	@Provides
	public FlippingCopilotConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(FlippingCopilotConfig.class);
	}

	private void processTransaction(Transaction transaction) {
		ifPresent(transactionManager, i -> {
			long profit = i.addTransaction(transaction);
			if (grandExchange.isHomeScreenOpen() && profit != 0) {
				new GpDropOverlay(this, profit, transaction.getBoxId());
			}
		});
	}

	//---------------------------- Event Handlers ----------------------------//
	private final List<GrandExchangeOfferChanged> queuedOfferEvents = new ArrayList<>();

	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event) {
		// we need to queue any offer events that arrive too early until the loginHandler is fully initialised
		queuedOfferEvents.add(event);
		if (osrsLoginHandler.isInvalidState()) {
			log.debug("queueing GE offer event until logged in user is initialised");
		} else {
			processQueuedOfferEvents();
		}
	}

	public void processQueuedOfferEvents() {
		while (!queuedOfferEvents.isEmpty()) {
			GrandExchangeOfferChanged event = queuedOfferEvents.remove(0);
			if (event.getSlot() == 0) {
				log.info("received box 0 offer event: {}, {}, {}/{}", event.getOffer().getState(), event.getOffer().getItemId(), event.getOffer().getQuantitySold(), event.getOffer().getTotalQuantity());
			}
			if (offerEventFilter.shouldProcess(event)) {
				if (event.getSlot() == 0) {
					log.info("box 0 is: processing transaction");
				}
				Transaction transaction = accountStatus.updateOffers(event,
						offerHandler.getLastViewedSlotItemId(),
						offerHandler.getLastViewedSlotItemPrice(),
						offerHandler.getLastViewedSlotPriceTime());
				if (transaction != null) {
					processTransaction(transaction);
				}
				suggestionHandler.setSuggestionNeeded(true);
			}
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event) {
		if (event.getContainerId() == InventoryID.INVENTORY.getId()) {
			accountStatus.handleInventoryChanged(event, client);
			suggestionHandler.setSuggestionNeeded(true);
		}
	}
	@Subscribe
	public void onGameTick(GameTick event) {
		suggestionHandler.onGameTick();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		int slot = grandExchange.getOpenSlot();
		grandExchangeCollectHandler.handleCollect(event, slot);
		gameUiChangesHandler.handleMenuOptionClicked(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		gameUiChangesHandler.onWidgetLoaded(event);
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		gameUiChangesHandler.onWidgetClosed(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		gameUiChangesHandler.onVarbitChanged(event);
	}

	@Subscribe
	public void onVarClientStrChanged(VarClientStrChanged event) {
		gameUiChangesHandler.onVarClientStrChanged(event);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		osrsLoginHandler.handleGameStateChanged(event);
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event) {
		gameUiChangesHandler.onVarClientIntChanged(event);
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown clientShutdownEvent) {
		log.debug("client shutdown event received");
		ifBothPresent(sessionManager, flipManager, (sm, fm) -> {
			accountStatus.onLogout(sm.getDisplayName());
			webHookController.sendMessage(fm.calculateStats(sm.getData().startTime, sm.getDisplayName()), sm.getData(), sm.getDisplayName(), false);
		});
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals("flippingcopilot")) {
			log.debug("copilot config changed event received");
			if (event.getKey().equals("profitAmountColor") || event.getKey().equals("lossAmountColor")) {
				mainPanel.copilotPanel.statsPanel.updateStatsAndFlips(true);
			}
			if (event.getKey().equals("suggestionHighlights")) {
				clientThread.invokeLater(() -> highlightController.redraw());
			}
		}
	}
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.AccountStatus;
import lombok.AllArgsConstructor;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;


@AllArgsConstructor
public class GrandExchangeCollectHandler {
    AccountStatus accountStatus;
    SuggestionHandler suggestionHandler;

    void handleCollect(MenuOptionClicked event, int slot) {
        String menuOption = event.getMenuOption();
        Widget widget = event.getWidget();

        if (widget != null) {
            handleCollectAll(menuOption, widget);
            handleCollectWithSlotOpen(menuOption, widget, slot);
            handleCollectionBoxCollectAll(menuOption, widget);
            handleCollectionBoxCollectItem(menuOption, widget);
        }
    }

    private void handleCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 30474246) {
            if (menuOption.equals("Collect to inventory")) {
                accountStatus.moveAllCollectablesToInventory();
            } else if (menuOption.equals("Collect to bank")) {
                accountStatus.removeCollectables();
            }
            else {
                return;
            }
            suggestionHandler.displaySuggestion();
        }
    }

    private void handleCollectWithSlotOpen(String menuOption, Widget widget, int slot) {
        if (widget.getId() == 30474264 ) {
            if (menuOption.contains("Collect")) {
                accountStatus.moveCollectedItemToInventory(slot, widget.getItemId());
            } else if (menuOption.contains("Bank")) {
                accountStatus.removeCollectedItem(slot, widget.getItemId());
            } else {
                return;
            }
            suggestionHandler.displaySuggestion();
        }
    }

    private void handleCollectionBoxCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 26345476 && menuOption.equals("Collect to bank")) {
            accountStatus.removeCollectables();
        } else if (widget.getId() == 26345475 && menuOption.equals("Collect to inventory")) {
            accountStatus.moveAllCollectablesToInventory();
        } else {
            return;
        }
        suggestionHandler.displaySuggestion();
    }

    private void handleCollectionBoxCollectItem(String menuOption, Widget widget) {
        int slot = widget.getId() - 26345477;
        if (slot >= 0 && slot <= 7) {
            if (menuOption.contains("Collect")) {
                accountStatus.moveCollectedItemToInventory(slot, widget.getItemId());
            } else if (menuOption.contains("Bank")) {
                accountStatus.removeCollectedItem(slot, widget.getItemId());
            } else {
                return;
            }
            suggestionHandler.displaySuggestion();
        }
    }

}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * This class is essentially a cache of user flips that facilitates efficient access to the flips and statistics for
 * any time range and rs account(s) combination. Since after several years a (very) active user could have hundreds of
 * thousands of flips, it would be too slow to filter and re-calculate flips/statistics from scratch every time.
 * A bucketed aggregation strategy is used where we keep pre-computed weekly buckets of statistics and flips. For any
 * time range we can efficiently combine the weekly buckets and only have to re-calculate statistics for the partial
 * weeks on the boundaries of the time range. Have tested the UI experience with >100k flips.
 */
@Slf4j
public class FlipManager {

    private static final int WEEK_SECS = 7 * 24 * 60 * 60;

    // dependencies
    private final ApiRequestHandler api;
    private final ScheduledExecutorService executorService;
    private final Runnable flipsChangedCallback;

    // state
    private String intervalDisplayName;
    private int intervalStartTime;
    private Stats intervalStats = new Stats();

    final Map<String, Integer> displayNameToAccountId = new HashMap<>();
    final Map<Integer, Map<Integer, FlipV2>> lastOpenFLipByItemId = new HashMap<>();
    final Map<UUID, Integer> existingCloseTimes = new HashMap<>();
    final List<WeekAggregate> weeks = new ArrayList<>(365*5);

    private volatile boolean cancelFlipLoadingSignalled;
    public volatile boolean flipsLoaded;

    public FlipManager(ApiRequestHandler api, ScheduledExecutorService executorService, Runnable flipsChangedCallback) {
        this.api = api;
        this.executorService = executorService;
        this.flipsChangedCallback = flipsChangedCallback;
        executorService.execute(this::loadFlips);
    }

    public void cancelFlipLoading() {
        this.cancelFlipLoadingSignalled = true;
    }

    public synchronized String getIntervalDisplayName() {
        return intervalDisplayName;
    }

    public synchronized List<String> getDisplayNameOptions() {
        return displayNameToAccountId.keySet().stream().sorted().collect(Collectors.toList());
    }

    public synchronized long estimateTransactionProfit(String displayName, Transaction t) {
        int accountId = displayNameToAccountId.get(displayName);
        if (lastOpenFLipByItemId.containsKey(accountId)) {
            FlipV2 flip = lastOpenFLipByItemId.get(accountId).get(t.getItemId());
            if(flip != null) {
                return flip.calculateProfit(t);
            }
        }
        return 0;
    }

    public synchronized void mergeFlips(List<FlipV2> flips, String displayName) {
        if(!flips.isEmpty() && displayName != null) {
            displayNameToAccountId.put(displayName, flips.get(0).getAccountId());
        }
        flips.forEach(this::mergeFlip_);
        flipsChangedCallback.run();
    }

    public synchronized Stats getIntervalStats() {
        return intervalStats.copy();
    }

    public synchronized Stats calculateStats(int startTime, String displayName) {
        if(displayName == null) {
            return calculateStatsAllAccounts(startTime);
        } else {
            return calculateStatsForAccount(startTime, displayNameToAccountId.getOrDefault(displayName, -1));
        }
    }

    public synchronized void setIntervalDisplayName(String displayName) {
        if (Objects.equals(displayName, intervalDisplayName)) {
            return;
        }
        intervalDisplayName = displayName;
        recalculateIntervalStats();
    }

    public synchronized void setIntervalStartTime(int startTime) {
        log.debug("time interval start set to: {}", Instant.ofEpochSecond(startTime));
        if (startTime == intervalStartTime) {
            return;
        }
        intervalStartTime = startTime;
        recalculateIntervalStats();
    }

    private void recalculateIntervalStats() {
        if(intervalDisplayName == null) {
            intervalStats = calculateStatsAllAccounts(intervalStartTime);
        } else {
            intervalStats = calculateStatsForAccount(intervalStartTime, displayNameToAccountId.getOrDefault(intervalDisplayName, -1));
        }
        log.debug("interval flips updated to {}, interval profit updated to {}", intervalStats.flipsMade, intervalStats.profit);
        flipsChangedCallback.run();
    }

    private Stats calculateStatsAllAccounts(int startTime) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfter(startTime, false)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).allStats);
        }
        return stats;
    }

    private Stats calculateStatsForAccount(int startTime, int accountId) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfterForAccount(startTime, accountId)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).accountIdToStats.get(accountId));
        }
        return stats;
    }

    public synchronized List<FlipV2> getPageFlips(int page, int pageSize) {
        Integer accountId = intervalDisplayName == null ? null : displayNameToAccountId.getOrDefault(intervalDisplayName, -1);
        if (Objects.equals(accountId,-1)) {
            return new ArrayList<>();
        }

        int toSkip = (page -1) * pageSize;
        WeekAggregate intervalWeek = getOrInitWeek(intervalStartTime);
        List<FlipV2> resultFlips = new ArrayList<>(pageSize);
        for(int i=weeks.size()-1; i >= intervalWeek.pos; i--) {
            if (weeks.get(i).weekEnd <= intervalStartTime || resultFlips.size() == pageSize) {
                break;
            }
            WeekAggregate w = weeks.get(i);
            List<FlipV2> weekFlips = accountId == null ? w.flipsAfter(intervalStartTime, true) : w.flipsAfterForAccount(intervalStartTime, accountId);
            int n = weekFlips.size();
            if (n > toSkip) {
                // note: weekFlips are ascending order but we return pages of descending order
                int end = n - toSkip;
                int start = Math.max(0, end - (pageSize - resultFlips.size()));
                for(int ii=end-1; ii >= start; ii--) {
                    resultFlips.add(weekFlips.get(ii));
                }
                toSkip = 0;
            } else {
                toSkip -= n;
            }
        }
        return resultFlips;
    }

    private void loadFlips() {
        try {
            long s = System.nanoTime();
            Map<String, Integer> names = api.loadUserDisplayNames();
            displayNameToAccountId.putAll(names);
            log.debug("loading account names took {}ms", (System.nanoTime() - s) / 1000_000);
            s = System.nanoTime();
            List<FlipV2> flips = api.LoadFlips();
            log.debug("loading flips took {}ms", (System.nanoTime() - s) / 1000_000);
            s = System.nanoTime();
            mergeFlips(flips, null);
            log.debug("merging flips to took {}ms", (System.nanoTime() - s) / 1000_000);
            flipsLoaded = true;
            flipsChangedCallback.run();
        } catch (Exception e) {
            if (!cancelFlipLoadingSignalled) {
                log.warn("failed to load historical flips from server {} try again in 10s", e.getMessage(), e);
                executorService.schedule(this::loadFlips, 10, TimeUnit.SECONDS);
            }
        }
    }

    private void mergeFlip_(FlipV2 flip) {
        Integer existingCloseTime = existingCloseTimes.get(flip.getId());
        Integer intervalAccountId = intervalDisplayName == null ? null : displayNameToAccountId.getOrDefault(intervalDisplayName, -1);

        if(existingCloseTime != null) {
            WeekAggregate wa = getOrInitWeek(existingCloseTime);
            FlipV2 removed = wa.removeFlip(flip.getId(), existingCloseTime, flip.getAccountId());
            if(removed.getClosedTime() >= intervalStartTime && (intervalAccountId == null || removed.getAccountId() == intervalAccountId)) {
                intervalStats.subtractFlip(removed);
            }
        }
        WeekAggregate wa = getOrInitWeek(flip.getClosedTime());
        wa.addFlip(flip);
        if(flip.getClosedTime() >= intervalStartTime && (intervalAccountId == null || flip.getAccountId() == intervalAccountId)) {
            intervalStats.addFlip(flip);
        }
        if(flip.getClosedQuantity() < flip.getOpenedQuantity()) {
            lastOpenFLipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).put(flip.getItemId(), flip);
        } else if (flip.isClosed()) {
            lastOpenFLipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).remove(flip.getItemId());
        }
        existingCloseTimes.put(flip.getId(), flip.getClosedTime());
    }

    private WeekAggregate getOrInitWeek(int closeTime) {
        int ws = closeTime - (closeTime % WEEK_SECS);
        int i = bisect(weeks.size(), (a) ->  Integer.compare(weeks.get(a).weekStart, ws));
        if (i >= 0){
            WeekAggregate w = weeks.get(i);
            w.pos = i;
            return w;
        }
        WeekAggregate wf = new WeekAggregate();
        wf.weekStart = ws;
        wf.weekEnd = ws + WEEK_SECS;
        wf.pos = -i-1;
        weeks.add(wf.pos, wf);
        return wf;
    }

    class WeekAggregate {

        int pos; // note: only correct when returned by getOrInitWeek
        int weekStart;
        int weekEnd;

        Stats allStats = new Stats();
        Map<Integer, Stats> accountIdToStats = new HashMap<>(20);
        Map<Integer, List<FlipV2>> accountIdToFlips = new HashMap<>(20);

        void addFlip(FlipV2 flip) {
            int accountId = flip.getAccountId();
            allStats.addFlip(flip);
            accountIdToStats.computeIfAbsent(accountId, (k) -> new Stats()).addFlip(flip);
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, flip.getId(), flip.getClosedTime()));
            flips.add(-i -1, flip);
        }

        FlipV2 removeFlip(UUID id, int closeTime, int accountId) {
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, id, closeTime));
            FlipV2 flip = flips.get(i);
            allStats.subtractFlip(flip);
            flips.remove(i);
            accountIdToStats.get(accountId).subtractFlip(flip);
            return flip;
        }

        public List<FlipV2> flipsAfterForAccount(int time, int accountId) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            if (time <= weekStart) {
                return flips;
            }
            int cut = -bisect(flips.size(), closedTimeCmp(flips, FlipV2.MAX_UUID, time)) - 1;
            return flips.subList(cut, flips.size());
        }

        public List<FlipV2> flipsAfter(int time, boolean requireSorted) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> combinedFlips = new ArrayList<>(allStats.flipsMade);
            accountIdToFlips.keySet().forEach(i -> combinedFlips.addAll(flipsAfterForAccount(time, i)));
            if (requireSorted) {
                combinedFlips.sort(Comparator.comparing(FlipV2::getClosedTime).thenComparing(FlipV2::getId));
            }
            return combinedFlips;
        }

        @Override
        public String toString() {
            return String.format("WeekAggregate[start=%s, flips=%d]", Instant.ofEpochSecond(weekStart), allStats.flipsMade);
        }
    }

    private Function<Integer, Integer> closedTimeCmp(List<FlipV2> flips, UUID id, int time) {
        return (a) -> {
            // sorts time ascending with id as tie-breaker
            int c = Integer.compare(flips.get(a).getClosedTime(), time);
            return c != 0 ? c : id.compareTo(flips.get(a).getId());
        };
    }

    private int bisect(int size, Function<Integer, Integer> cmpFunc) {
        int high = size -1;
        int low = 0;
        while (low <= high) {
            int mid = (low + high) >>> 1;
            int cmp = cmpFunc.apply(mid);
            if (cmp < 0)
                low = mid + 1;
            else if (cmp > 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found (low = insertion point)
    }
}

package com.flippingcopilot.controller;

import net.runelite.api.VarClientInt;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.input.KeyListener;

import java.awt.event.KeyEvent;

public class KeybindHandler {

    FlippingCopilotPlugin plugin;

    public KeybindHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        plugin.keyManager.registerKeyListener(offerEditorKeyListener());

    }

    public void unregister() {
        plugin.keyManager.unregisterKeyListener(offerEditorKeyListener());
    }


    private KeyListener offerEditorKeyListener() {
        return new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {
                // Prevent enter as a keybind as that will also submit the value
                if (e.getKeyCode() == KeyEvent.VK_ENTER) return;
                if (e.getKeyCode() != plugin.config.quickSetKeybind().getKeyCode()) return;

                plugin.getClientThread().invokeLater(this::handleKeybind);
            }

            @Override
            public void keyReleased(KeyEvent e) {

            }

            private void handleKeybind() {
                var suggestion = plugin.suggestionHandler.getCurrentSuggestion();

                var inputType = plugin.client.getVarcIntValue(VarClientInt.INPUT_TYPE);

                var isPriceOrQuantityBoxOpen = plugin.client.getWidget(ComponentID.CHATBOX_TITLE) != null
                        && inputType == 7
                        && plugin.client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) != null
                        && plugin.grandExchange.isSlotOpen();

                if (isPriceOrQuantityBoxOpen) {
                    plugin.offerHandler.setSuggestedAction(suggestion);
                }
            }
        };
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.google.gson.*;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import java.io.IOException;
import java.lang.reflect.Type;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@Slf4j
@Singleton
public class ApiRequestHandler {

    private static final String serverUrl = System.getenv("FLIPPING_COPILOT_HOST") != null ? System.getenv("FLIPPING_COPILOT_HOST")  : "https://api.flippingcopilot.com";

    // dependencies
    private final OkHttpClient client;
    private final Gson gson;

    // state todo: would be cleaner if this class was stateless
    private String jwtToken = null;
    private LoginResponse loginResponse = null;

    @Inject
    public ApiRequestHandler(Gson gson, OkHttpClient client) {
        this.gson = gson;
        this.client = client;
    }

    public void onLogout() {
        jwtToken = null;
        loginResponse = null;
    }

    public void setLoginResponse(LoginResponse loginResponse) {
        this.loginResponse = loginResponse;
        this.jwtToken = loginResponse.jwt;
    }

    public void authenticate(String username, String password, Consumer<LoginResponse> callback) {
        Request request = new Request.Builder()
                .url(serverUrl + "/login")
                .addHeader("Authorization", Credentials.basic(username, password))
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), ""))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.accept(null);
            }
            @Override
            public void onResponse(Call call, Response response) {
                // todo: this response can be a non 200 in which case we deserialize a null jwt
                handleLoginResponse(response, callback);
            }
        });
    }

    private void handleLoginResponse(Response response, Consumer<LoginResponse> callback) {
        try {
            JsonObject responseJson = gson.fromJson(response.body().string(), JsonObject.class);
            loginResponse = gson.fromJson(responseJson, LoginResponse.class);
            if (response.isSuccessful()) {
                jwtToken = responseJson.get("jwt").getAsString();
            }
            callback.accept(loginResponse);
        } catch (IOException e) {
            callback.accept(null);
        }
        catch (JsonParseException e) {
            loginResponse = new LoginResponse(true, response.message(), null, -1);
            callback.accept(loginResponse);
        }
    }

    public Suggestion getSuggestion(AccountStatus accountStatus) throws IOException {
        JsonObject status = accountStatus.toJson(gson);
        JsonObject suggestionJson = doHttpRequest("POST", status, "/suggestion", JsonObject.class);
        return Suggestion.fromJson(suggestionJson, gson);
    }

    public ItemPrice getItemPrice(int itemId, String displayName) {
        JsonObject respObj = null;
        try {
            JsonObject body = new JsonObject();
            body.add("item_id", new JsonPrimitive(itemId));
            body.add("display_name", new JsonPrimitive(displayName));
            return doHttpRequest("POST", body, "/prices", ItemPrice.class);
        } catch (HttpResponseException e) {
            log.error("error fetching copilot price for item {}, resp code {}", itemId, e.getResponseCode(), e);
            return new ItemPrice(0, 0, "Unable to fetch price copilot price (possible server update)");
        }
    }

    public List<FlipV2> SendTransactions(List<Transaction> transactions, String displayName) throws HttpResponseException {
        JsonArray body = new JsonArray();
        for (Transaction transaction : transactions) {
            body.add(transaction.toJsonObject());
        }
        String encodedDisplayName = URLEncoder.encode(displayName, StandardCharsets.UTF_8);
        Type respType = new TypeToken<List<FlipV2>>(){}.getType();
        return doHttpRequest("POST", body, "/profit-tracking/client-transactions?display_name=" + encodedDisplayName, respType);
    }

    public Map<String, Integer> loadUserDisplayNames() throws HttpResponseException {
        Type respType = new TypeToken<Map<String, Integer>>(){}.getType();
        Map<String, Integer> names = doHttpRequest("GET", null, "/profit-tracking/rs-account-names", respType);
        return names == null ? new HashMap<>() : names;
    }

    public List<FlipV2> LoadFlips() throws HttpResponseException {
        Type respType = new TypeToken<List<FlipV2>>(){}.getType();
        List<FlipV2> flips = doHttpRequest("GET", null, "/profit-tracking/client-flips", respType);
        return flips == null ? new ArrayList<>() : flips;
    }

    public <T> T doHttpRequest(String method, JsonElement bodyJson, String route, Type responseType) throws HttpResponseException {
        if (jwtToken == null) {
            throw new IllegalStateException("Not authenticated");
        }

        RequestBody body = bodyJson == null ? null : RequestBody.create(MediaType.get("application/json; charset=utf-8"), bodyJson.toString());
        Request request = new Request.Builder()
                .url(serverUrl + route)
                .addHeader("Authorization", "Bearer " + jwtToken)
                .method(method, body)
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                if (responseType == Void.class || response.body() == null) {
                    return null;
                }
                String responseBody = response.body().string();
                return gson.fromJson(responseBody, responseType);
            } else {
                String errorMessage = "Unknown error";
                if (response.body() != null) {
                    String bodyStr = response.body().string();
                    try {
                        JsonObject errorJson = gson.fromJson(bodyStr, JsonObject.class);
                        if (errorJson.has("message")) {
                            errorMessage = errorJson.get("message").getAsString();
                        }
                    } catch (JsonSyntaxException e) {
                        log.warn("Unable to parse http {} response body ({}): {}", response.code(), e.getMessage(), bodyStr);
                    }
                }
                throw new HttpResponseException(response.code(), errorMessage);
            }
        } catch (JsonSyntaxException | IOException e) {
            throw new HttpResponseException(-1, "Unknown server error (possible system update)", e);
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.DiscordWebhookBody;
import com.flippingcopilot.model.SessionData;
import com.flippingcopilot.model.Stats;
import com.flippingcopilot.ui.UIUtilities;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.time.Instant;

import static com.flippingcopilot.ui.FlipPanel.formatEpoch;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
public class WebHookController {

    @Inject
    private FlippingCopilotConfig config;
    @Inject
    private OkHttpClient okHttpClient;

    private void sendWebHook(DiscordWebhookBody discordWebhookBody) {
        String configURL = config.webhook();
        if (Strings.isNullOrEmpty(configURL)) {return; }

        HttpUrl url = HttpUrl.parse(configURL);
        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(discordWebhookBody));
        buildRequestAndSend(url, requestBodyBuilder);
    }

    private void buildRequestAndSend(HttpUrl url, MultipartBody.Builder requestBodyBuilder) {
        RequestBody requestBody = requestBodyBuilder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
        sendRequest(request);
    }

    private void sendRequest(Request request) {
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Error on webhook", e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                response.close();
            }
        });
    }

    public void sendMessage(Stats stats, SessionData sd, String displayName, boolean sessionIsFinished) {
        if (stats.profit != 0 && displayName != null) {

            long seconds = sd.durationMillis / 1000;
            String beganAtText = formatEpoch(sd.startTime);
            String endedAtText = sessionIsFinished ? formatEpoch(Instant.now().getEpochSecond()) : "n/a";
            String durationText = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            String profitText = UIUtilities.formatProfit(stats.profit);
            String taxText = UIUtilities.formatProfit(stats.taxPaid);
            String roiText = String.format("%.3f%%", stats.calculateRoi() * 100);
            String cashStackText = UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp";

            String template = "%s, your session stats are:\n" +
                    "```" +
                    "Session began at:      %s\n" +
                    "Session ended at:      %s\n" +
                    "Active session time:   %s\n" +
                    "Flips made:            %d\n" +
                    "Profit:                %s\n" +
                    "Tax paid:              %s\n" +
                    "Roi:                   %s\n" +
                    "Avg wealth:            %s\n" +
                    "```";

            String discordMessage = String.format(template, displayName, beganAtText, endedAtText, durationText, stats.flipsMade, profitText, taxText, roiText, cashStackText);
            DiscordWebhookBody discordWebhookBody = new DiscordWebhookBody();
            discordWebhookBody.setContent(discordMessage);
            sendWebHook(discordWebhookBody);
        }
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

import java.text.NumberFormat;

@Getter
@AllArgsConstructor
@ToString
public class Suggestion {
    private final String type;

    @SerializedName("box_id")
    private final int boxId;

    @SerializedName("item_id")
    private final int itemId;

    private final int price;

    private final int quantity;

    private final String name;

    @SerializedName("command_id")
    private final int id;

    private final String message;

    public static Suggestion fromJson(JsonObject json, Gson gson) {
        return gson.fromJson(json, Suggestion.class);
    }

    public boolean equals(Suggestion other) {
        return this.type.equals(other.type)
                && this.boxId == other.boxId
                && this.itemId == other.itemId
                && this.name.equals(other.name);
    }

    public String toMessage() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String string = "Flipping Copilot: ";
        switch (type) {
            case "buy":
                string += String.format("Buy %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "sell":
                string += String.format("Sell %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "abort":
                string += "Abort " + name;
                break;
            case "wait":
                string += "Wait";
                break;
            default:
                string += "Unknown suggestion type";
                break;
        }
        return string;
    }
}



package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.util.Constants;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.InventoryID;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.api.events.ItemContainerChanged;

import java.util.List;
import java.util.Map;


// note: we synchronize all public methods of this class as they read/modify its state and may
// be called by multiple threads at the same time
@Getter
public class AccountStatus {
    private OfferList offers;
    private Inventory inventory;
    @Setter private boolean sellOnlyMode = false;
    @Setter private boolean isMember = false;
    @Setter private int skipSuggestion = -1;
    @Setter private String displayName;
    @Setter private Boolean suggestionsPaused;
    public AccountStatus() {
        offers = new OfferList();
        inventory = new Inventory();
    }

    public synchronized void resetSkipSuggestion() {
        skipSuggestion = -1;
    }

    public synchronized boolean isSuggestionSkipped() {
        return skipSuggestion != -1;
    }

    public synchronized Transaction updateOffers(GrandExchangeOfferChanged event, int lastViewedSlotItemId, int lastViewedSlotItemPrice, int lastViewSlotTime) {
        return offers.update(event, lastViewedSlotItemId, lastViewedSlotItemPrice, lastViewSlotTime);
    }

    public synchronized void setOffers(GrandExchangeOffer[] runeliteOffers) {
        offers = OfferList.fromRunelite(runeliteOffers);
    }

    public synchronized void handleInventoryChanged(ItemContainerChanged event, Client client) {
        if (event.getContainerId() == InventoryID.INVENTORY.getId()) {
            inventory = Inventory.fromRunelite(event.getItemContainer(), client);
        }
    }

    public synchronized boolean isCollectNeeded(Suggestion suggestion) {
        return offers.isEmptySlotNeeded(suggestion)
                || !inventory.hasSufficientGp(suggestion)
                || !inventory.hasSufficientItems(suggestion)
                || offers.missingUncollectedItems();
    }

    public synchronized void moveAllCollectablesToInventory() {
        Map<Integer, Long> uncollectedItemAmounts = offers.getUncollectedItemAmounts();
        List<RSItem> uncollectedItems = Inventory.fromItemAmounts(uncollectedItemAmounts);
        inventory.addAll(uncollectedItems);
        removeCollectables();
    }

    public synchronized void removeCollectables() {
        offers.removeCollectables();
    }

    public synchronized JsonObject toJson(Gson gson) {
        JsonObject statusJson = new JsonObject();
        statusJson.addProperty("display_name", displayName);
        statusJson.addProperty("sell_only", sellOnlyMode);
        statusJson.addProperty("is_member", isMember);
        statusJson.addProperty("skip_suggestion", skipSuggestion);
        if (suggestionsPaused != null) {
            statusJson.addProperty("suggestions_paused", suggestionsPaused);
        }
        JsonArray offersJsonArray = offers.toJson(gson);
        JsonArray itemsJsonArray = getItemsJson();
        statusJson.add("offers", offersJsonArray);
        statusJson.add("items", itemsJsonArray);
        return statusJson;
    }

    private JsonArray getItemsJson() {
        Map<Integer, Long> itemsAmount = getItemAmounts();
        JsonArray itemsJsonArray = new JsonArray();
        for(Map.Entry<Integer, Long> entry : itemsAmount.entrySet()) {
            JsonObject itemJson = new JsonObject();
            itemJson.addProperty("item_id", entry.getKey());
            itemJson.addProperty("amount", entry.getValue());
            itemsJsonArray.add(itemJson);
        }
        return itemsJsonArray;
    }

    private Map<Integer, Long> getItemAmounts() {
        Map<Integer, Long> itemsAmount = inventory.getItemAmounts();
        Map<Integer, Long> uncollectedItemAmounts = offers.getUncollectedItemAmounts();
        uncollectedItemAmounts.forEach((key, value) -> itemsAmount.merge(key, value, Long::sum));
        itemsAmount.entrySet().removeIf(entry -> entry.getValue() == 0);
        return itemsAmount;
    }

    public synchronized void moveCollectedItemToInventory(int slot, int itemId) {
        RSItem collectedItem = offers.get(slot).removeCollectedItem(itemId);
        inventory.add(collectedItem);
    }

    public synchronized void removeCollectedItem(int slot, int itemId) {
        offers.get(slot).removeCollectedItem(itemId);
    }

    public synchronized boolean moreGpNeeded() {
        return offers.emptySlotExists() && getTotalGp() < Constants.MIN_GP_NEEDED_TO_FLIP;
    }

    private long getTotalGp() {
        return inventory.getTotalGp() + offers.getTotalGpToCollect();
    }

    public synchronized boolean currentlyFlipping() {
        return offers.stream().anyMatch(Offer::isActive);
    }

    public synchronized long currentCashStack() {
        // the cash stack is the gp in their inventory + the value on the market
        // todo: when a buy offer has fully finished its value will not count towards the cash stack
        //  size until they start selling it. We should probably track items that where recently bought
        //  and they should still count towards the cash stack size for some period of time
        return offers.getGpOnMarket() + inventory.getTotalGp();
    }

    public synchronized void onLogout(String currentDisplayName) {
        Persistance.storeGeOfferEvents(offers, currentDisplayName);
    }

    public synchronized void loadPreviousOffers(String currentDisplayName) {
        OfferList previousOffers = Persistance.loadPreviousGeOfferEvents(currentDisplayName);
        if (previousOffers != null && previousOffers.size() == OfferList.NUM_SLOTS) {
            this.offers = previousOffers;
        }
    }
}

package com.flippingcopilot.model;

import lombok.Getter;

import java.io.IOException;

@Getter
public class HttpResponseException extends IOException {
    private final int responseCode;
    private final String responseMessage;

    public HttpResponseException(int responseCode, String message) {
        super(message);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }

    public HttpResponseException(int responseCode, String message, Throwable cause) {
        super(message, cause);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }
}
package com.flippingcopilot.model;

import net.runelite.api.*;
import net.runelite.api.ItemID;
import static com.flippingcopilot.util.Constants.PLATINUM_TOKEN_VALUE;

import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Collectors;


public class Inventory extends ArrayList<RSItem> {
    boolean hasSufficientGp(Suggestion suggestion) {
        return !suggestion.getType().equals("buy")
                || getTotalGp() >= (long) suggestion.getPrice() * suggestion.getQuantity();
    }

    boolean hasSufficientItems(Suggestion suggestion) {
        return !suggestion.getType().equals("sell")
                || getTotalAmount(suggestion.getItemId()) >= suggestion.getQuantity();
    }

    public long getTotalGp() {
        return getTotalAmount(ItemID.COINS_995) + PLATINUM_TOKEN_VALUE * getTotalAmount(ItemID.PLATINUM_TOKEN);
    }

    public long getTotalAmount(long itemId) {
        long amount = 0;
        for (RSItem item : this) {
            if (item.getId() == itemId) {
                amount += item.getAmount();
            }
        }
        return amount;
    }


    static Inventory fromRunelite(ItemContainer inventory, Client client) {
        Inventory unnotedItems = new Inventory();
        Item[] items = inventory.getItems();
        for (Item item : items) {
            if (item.getId() == -1) {
                continue;
            }
            unnotedItems.add(RSItem.getUnnoted(item, client));
        }
        return unnotedItems;
    }

    Map<Integer, Long> getItemAmounts() {
        return stream().collect(Collectors.groupingBy(RSItem::getId,
                        Collectors.summingLong(RSItem::getAmount)));
    }

    static Inventory fromItemAmounts(Map<Integer, Long> itemAmounts) {
        Inventory inventory = new Inventory();
        for (Map.Entry<Integer, Long> entry : itemAmounts.entrySet()) {
            inventory.add(new RSItem(entry.getKey(), entry.getValue()));
        }
        return inventory;
    }

}

package com.flippingcopilot.model;

import com.flippingcopilot.util.GeTax;
import com.google.gson.annotations.SerializedName;
import lombok.Data;
import java.util.Comparator;
import java.util.UUID;

@Data
public class FlipV2 {

    public static UUID MAX_UUID = new UUID(-1L, -1L);
    public static UUID MIN_UUID = new UUID(0L, 0L);

    @SerializedName("id")
    private UUID id;

    @SerializedName("account_id")
    private int accountId;

    @SerializedName("item_id")
    private int itemId;

    @SerializedName("item_name")
    private String itemName;

    @SerializedName("opened_time")
    private int openedTime;

    @SerializedName("opened_quantity")
    private int openedQuantity;

    @SerializedName("spent")
    private long spent;

    @SerializedName("closed_time")
    private int closedTime;

    @SerializedName("closed_quantity")
    private int closedQuantity;

    @SerializedName("received_post_tax")
    private long receivedPostTax;

    @SerializedName("profit")
    private long profit;

    @SerializedName("tax_paid")
    private long taxPaid;

    @SerializedName("is_closed")
    private boolean isClosed;

    private String accountDisplayName;

    public long calculateProfit(Transaction transaction) {
        long amountToClose = Math.min(openedQuantity - closedQuantity, transaction.getQuantity());
        if(amountToClose <= 0 ){
            return 0;
        }
        long gpOut = (spent * amountToClose) / openedQuantity;
        int sellPrice  = transaction.getAmountSpent() / transaction.getQuantity();
        int sellPricePostTax = GeTax.getPostTaxPrice(transaction.getItemId(), sellPrice);
        long gpIn = amountToClose * sellPricePostTax;
        return gpIn - gpOut;
    }

    public long getAvgBuyPrice() {
        if (spent == 0) {
            return 0;
        }
        return spent / openedQuantity ;
    }

    public long getAvgSellPrice() {
        if (receivedPostTax == 0) {
            return 0;
        }
        return (receivedPostTax  + taxPaid) / closedQuantity;
    }
}

package com.flippingcopilot.model;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;

@Getter
@AllArgsConstructor
public class RSItem {
    int id;
    long amount;

    static RSItem getUnnoted(Item item, Client client) {
        int itemId = item.getId();
        ItemComposition itemComposition = client.getItemDefinition(itemId);
        if (itemComposition.getNote() != -1) {
            itemId = itemComposition.getLinkedNoteId();
        }
        return new RSItem(itemId, item.getQuantity());
    }
}
package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import net.runelite.api.GrandExchangeOfferState;

public enum OfferStatus {
    @SerializedName("sell")
    SELL,
    @SerializedName("buy")
    BUY,
    @SerializedName("empty")
    EMPTY;

    static OfferStatus fromRunelite(GrandExchangeOfferState state) {
        OfferStatus status;
        switch (state) {
            case SELLING:
            case CANCELLED_SELL:
            case SOLD:
                status = SELL;
                break;
            case BUYING:
            case CANCELLED_BUY:
            case BOUGHT:
                status = BUY;
                break;
            default:
                status = EMPTY;
        }
        return status;
    }
}

package com.flippingcopilot.model;

import com.google.gson.JsonObject;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.time.Instant;
import java.util.Comparator;
import java.util.UUID;


@Getter
@AllArgsConstructor
public class Transaction {

    @Setter private UUID id;
    private OfferStatus type;
    private int itemId;
    private int price;
    private int quantity;
    private int boxId;
    private int amountSpent;
    private Instant timestamp;
    private boolean copilotPriceUsed;

    public boolean equals(Transaction other) {
        return this.type == other.type &&
                this.itemId == other.itemId &&
                this.price == other.price &&
                this.quantity == other.quantity &&
                this.boxId == other.boxId &&
                this.amountSpent == other.amountSpent;
    }

    public JsonObject toJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty("id", id.toString());
        jsonObject.addProperty("item_id", itemId);
        jsonObject.addProperty("price", price);
        jsonObject.addProperty("quantity", type.equals(OfferStatus.BUY) ? quantity : -quantity);
        jsonObject.addProperty("box_id", boxId);
        jsonObject.addProperty("amount_spent", amountSpent);
        jsonObject.addProperty("time", timestamp.getEpochSecond());
        jsonObject.addProperty("copilot_price_used", copilotPriceUsed);
        return jsonObject;
    }
}



package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.events.GrandExchangeOfferChanged;
import static net.runelite.api.ItemID.COINS_995;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;


public class OfferList extends ArrayList<Offer> {
    public static final int NUM_SLOTS = 8;

    public OfferList(List<Offer> offers) {
        super();
        addAll(offers);
    }

    public OfferList() {
        super(NUM_SLOTS);
        for (int i = 0; i < NUM_SLOTS; i++) {
            add(Offer.getEmptyOffer(i));
        }
    }

    public Transaction update(GrandExchangeOfferChanged event, int lastViewedSlotItemId, int lastViewedSlotItemPrice, int lastViewSlotTime) {
        Offer oldOffer = get(event.getSlot());
        Offer newOffer = oldOffer.getUpdatedOffer(event, lastViewedSlotItemId, lastViewedSlotItemPrice, lastViewSlotTime);
        set(event.getSlot(), newOffer);
        return newOffer.getTransaction(oldOffer);
    }

    public static OfferList fromRunelite(GrandExchangeOffer[] runeliteOffers) {
        OfferList offers = new OfferList();
        for (int i = 0; i < runeliteOffers.length; i++) {
            offers.set(i, Offer.fromRunelite(runeliteOffers[i], i));
        }
        return offers;
    }

    public boolean missingUncollectedItems() {
        return stream().anyMatch(Offer::missingUncollectedItems);
    }

    public boolean isEmptySlotNeeded(Suggestion suggestion) {
        return (suggestion.getType().equals("buy") || suggestion.getType().equals("sell"))
                && !emptySlotExists();
    }

    boolean emptySlotExists() {
        return stream().anyMatch(offer -> offer.getStatus() == OfferStatus.EMPTY);
    }

    void removeCollectables() {
        forEach(Offer::removeCollectables);
    }

    Map<Integer, Long> getUncollectedItemAmounts() {
        Map<Integer, Long> itemsAmount = getUncollectedTradeablesAmounts();
        long totalGpToCollect = getTotalGpToCollect();
        itemsAmount.merge(COINS_995, totalGpToCollect, Long::sum);
        itemsAmount.entrySet().removeIf(entry -> entry.getValue() == 0);
        return itemsAmount;
    }

    public long getGpOnMarket() {
        return stream().mapToLong(Offer::cashStackGpValue).sum();
    }

    public long getTotalGpToCollect() {
        return stream().mapToLong(Offer::getGpToCollect).sum();
    }

    private Map<Integer, Long> getUncollectedTradeablesAmounts() {
        return stream().collect(Collectors.groupingBy(Offer::getItemId,
                        Collectors.summingLong(Offer::getItemsToCollect)));
    }

    JsonArray toJson(Gson gson) {
        List<JsonObject> list = stream()
                .map(offer -> offer.toJson(gson))
                .collect(Collectors.toList());
        JsonArray jsonArray = new JsonArray();
        list.forEach(jsonArray::add);
        return jsonArray;
    }

    public int findEmptySlot() {
        for (int i = 0; i < NUM_SLOTS; i++) {
            if (get(i).getStatus() == OfferStatus.EMPTY) {
                return i;
            }
        }
        return -1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

@Getter
@AllArgsConstructor
@ToString
public class ItemPrice {
    @SerializedName("sell_price")
    private final int sellPrice;

    @SerializedName("buy_price")
    private final int buyPrice;
    private final String message;

    public static ItemPrice fromJson(JsonObject json, Gson gson) {
        return gson.fromJson(json, ItemPrice.class);
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class LoginResponse {
    public boolean error;
    public String message;
    public String jwt;

    @SerializedName("user_id")
    public int userId;
}

package com.flippingcopilot.model;

import lombok.Getter;

@Getter
public enum IntervalTimeUnit {

    ALL(-1),
    SESSION(-1),
    HOUR(3600),
    DAY(86400),
    WEEK(604800),
    MONTH(2592000),
    YEAR(31536000);

    private final int seconds;;

    IntervalTimeUnit(int seconds) {
        this.seconds = seconds;
    }

    public static IntervalTimeUnit fromString(String str) {
        switch (str) {
            case "h":
                return IntervalTimeUnit.HOUR;
            case "d":
                return IntervalTimeUnit.DAY;
            case "w":
                return IntervalTimeUnit.WEEK;
            case "m":
                return IntervalTimeUnit.MONTH;
            case "y":
                return IntervalTimeUnit.YEAR;
            default:
                return IntervalTimeUnit.ALL;
        }
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;

import java.time.Instant;
import java.util.UUID;

import static net.runelite.api.ItemID.COINS_995;

@Getter
@AllArgsConstructor
@EqualsAndHashCode
public class Offer {
    private OfferStatus status;

    @SerializedName("item_id")
    private int itemId;

    private int price;

    @SerializedName("amount_total")
    private int amountTotal;

    @SerializedName("amount_spent")
    private int amountSpent;

    @SerializedName("amount_traded")
    private int amountTraded;

    @SerializedName("items_to_collect")
    private int itemsToCollect;

    @SerializedName("gp_to_collect")
    private int gpToCollect;

    @SerializedName("box_id")
    private int boxId;

    private boolean active;

    @Setter
    @SerializedName("copilot_price_used")
    private boolean copilotPriceUsed;

    public static Offer getEmptyOffer(int slotId) {
        return new Offer(OfferStatus.EMPTY, 0, 0, 0, 0, 0, 0, 0, slotId, false, false);
    }

    void removeCollectables() {
        itemsToCollect = 0;
        gpToCollect = 0;
    }

    RSItem removeCollectedItem(int itemId) {
        int amountCollected;
        if (itemId == COINS_995) {
            amountCollected = gpToCollect;
            gpToCollect = 0;
        } else {
            amountCollected = itemsToCollect;
            itemsToCollect = 0;
        }
        return new RSItem(itemId, amountCollected);
    }

    Offer getUpdatedOffer(GrandExchangeOfferChanged event, int lastViewedSlotItemId, int lastViewedSlotItemPrice, int lastViewSlotTime) {
        Offer newOffer = Offer.fromRuneliteEvent(event);
        if (isSameOffer(newOffer)) {
            newOffer.addUncollectedItems(this);
            newOffer.setCopilotPriceUsed(copilotPriceUsed);
            if (active) {
                newOffer.addUncollectedItemsOnAbort(event);
            }
        } else {
            if(newOffer.getItemId() == lastViewedSlotItemId && newOffer.getPrice() == lastViewedSlotItemPrice && Instant.now().minusSeconds(30).getEpochSecond() < lastViewSlotTime) {
                newOffer.setCopilotPriceUsed(true);
            }
        }
        return newOffer;
    }

    private void addUncollectedItems(Offer oldOffer) {
        itemsToCollect = oldOffer.itemsToCollect;
        gpToCollect = oldOffer.gpToCollect;
        if (status == OfferStatus.BUY) {
            itemsToCollect += amountTraded - oldOffer.amountTraded;
        } else if (status == OfferStatus.SELL) {
            gpToCollect += amountSpent - oldOffer.amountSpent;
        }
    }

    public long cashStackGpValue() {
        if (status == OfferStatus.SELL) {
            return (long) (amountTotal - amountTraded) * price + gpToCollect;
        } else if (status == OfferStatus.BUY){
            // for a buy just take the full amount even if they have collected
            // we assume they won't start selling any collected items until their buy offer is finished
            return (long) amountTotal * price;
        } else {
            return 0;
        }
    }

    public void addUncollectedItemsOnAbort(GrandExchangeOfferChanged event) {
        GrandExchangeOffer runeliteOffer = event.getOffer();
        if (runeliteOffer.getState().equals(GrandExchangeOfferState.CANCELLED_BUY)) {
            gpToCollect += (amountTotal - amountTraded) * price;
        } else if (runeliteOffer.getState().equals(GrandExchangeOfferState.CANCELLED_SELL)) {
            itemsToCollect += amountTotal - amountTraded;
        }
    }
    public static Offer fromRuneliteEvent(GrandExchangeOfferChanged event) {
        GrandExchangeOffer runeliteOffer = event.getOffer();
        return fromRunelite(runeliteOffer, event.getSlot());
    }

    public static Offer fromRunelite(GrandExchangeOffer runeliteOffer, int slotId) {
        OfferStatus status = OfferStatus.fromRunelite(runeliteOffer.getState());
        boolean active = runeliteOffer.getState().equals(GrandExchangeOfferState.BUYING)
                || runeliteOffer.getState().equals(GrandExchangeOfferState.SELLING);
        return new Offer(status,
                runeliteOffer.getItemId(),
                runeliteOffer.getPrice(),
                runeliteOffer.getTotalQuantity(),
                runeliteOffer.getSpent(),
                runeliteOffer.getQuantitySold(),
                0,
                0,
                slotId,
                active,
                false);
    }

    public Transaction getTransaction(Offer oldOffer) {
        boolean isNewOffer = status != oldOffer.status
                || itemId != oldOffer.itemId
                || price != oldOffer.price
                || amountTotal != oldOffer.amountTotal
                || boxId != oldOffer.boxId;
        int quantityDiff = isNewOffer ? amountTraded : amountTraded - oldOffer.amountTraded;
        int amountSpentDiff = isNewOffer ? amountSpent : amountSpent - oldOffer.amountSpent;
        if (quantityDiff > 0 && amountSpentDiff > 0) {
            return new Transaction(UUID.randomUUID(), status, itemId, price, quantityDiff, boxId, amountSpentDiff, Instant.now(), oldOffer.copilotPriceUsed);
        }
        return null;
    }

    public boolean missingUncollectedItems() {
        return !active && status != OfferStatus.EMPTY && (gpToCollect == 0 && itemsToCollect == 0);
    }

    JsonObject toJson(Gson gson) {
        JsonParser jsonParser = new JsonParser();
        return jsonParser.parse(gson.toJson(this)).getAsJsonObject();
    }

    private boolean isSameOffer(Offer newOffer) {
        return status == newOffer.status
                && itemId == newOffer.itemId
                && price == newOffer.price
                && amountTotal == newOffer.amountTotal
                && amountSpent <= newOffer.amountSpent
                && amountTraded <= newOffer.amountTraded
                && boxId == newOffer.boxId;
    }
}

package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class Stats {

    public long profit;
    public long gross;
    public long taxPaid;
    public int flipsMade;

    public float calculateRoi() {
        if (gross == 0){
            return 0;
        }
        return (float) (((double) profit) / ((double) gross));
    }

    public Stats copy() {
        return new Stats(profit, gross, taxPaid, flipsMade);
    }

    public void add(Stats s) {
        if(s != null) {
            profit += s.profit;
            gross += s.gross;
            taxPaid += s.taxPaid;
            flipsMade += s.flipsMade;
        }
    }

    public void addFlip(FlipV2 f) {
        profit += f.getProfit();
        gross += f.getSpent();
        taxPaid += f.getTaxPaid();
        flipsMade += 1;
    }

    public void subtractFlip(FlipV2 f) {
        profit -= f.getProfit();
        gross -= f.getSpent();
        taxPaid -= f.getTaxPaid();
        flipsMade -= 1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public class SessionData {

    @SerializedName("start_time")
    public int startTime;

    @SerializedName("duration_millis")
    public long durationMillis;

    @SerializedName("average_cash")
    public long averageCash;
}

package com.flippingcopilot.model;

import lombok.Data;

@Data
public class DiscordWebhookBody {
    private String content;
    private Embed embed;

    @Data
    static class Embed {
        final UrlEmbed image;
    }

    @Data
    static class UrlEmbed {
        final String url;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

public class PauseButton extends JButton
{
    private final FlippingCopilotPlugin plugin;

    private static final ImageIcon PLAY_ICON;
    private static final ImageIcon PAUSE_ICON;
    private static final ImageIcon PLAY_ICON_HOVER;
    private static final ImageIcon PAUSE_ICON_HOVER;

    static {
        var play = ImageUtil.loadImageResource(PauseButton.class, "/play.png");
        var pause = ImageUtil.loadImageResource(PauseButton.class, "/pause.png");
        PLAY_ICON = new ImageIcon(play);
        PAUSE_ICON = new ImageIcon(pause);
        PLAY_ICON_HOVER =  new ImageIcon(ImageUtil.luminanceScale(play, BUTTON_HOVER_LUMINANCE));
        PAUSE_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(pause, BUTTON_HOVER_LUMINANCE));
    }

    public PauseButton(FlippingCopilotPlugin plugin) {
        super(PAUSE_ICON);
        this.plugin = plugin;
        setToolTipText("Pause suggestions");
        addActionListener(e -> {
            plugin.suggestionHandler.togglePause();
            update();
        });

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(plugin.suggestionHandler.isPaused() ? PLAY_ICON_HOVER : PAUSE_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(plugin.suggestionHandler.isPaused() ? PLAY_ICON : PAUSE_ICON);
            }
        });

        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);

    }

    public void setPausedState(boolean paused) {
        if(paused) {
            plugin.suggestionHandler.pause();
            update();
        } else {
            plugin.suggestionHandler.unpause();
            update();
        }
    }

    private void update()
    {
        setIcon(plugin.suggestionHandler.isPaused() ? PLAY_ICON : PAUSE_ICON);
        setToolTipText(plugin.suggestionHandler.isPaused() ? "Unpause suggestions" :  "Pause suggestions");
    }
}

package com.flippingcopilot.ui;


import java.awt.Dimension;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JToggleButton;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

class SellOnlyModeToggleButton extends JToggleButton
{
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;

    static
    {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(CopilotPanel.class, "/switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    public SellOnlyModeToggleButton()
    {
        super(OFF_SWITCHER);
        setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        setPreferredSize(new Dimension(25, 25));
        addItemListener(l -> updateTooltip());
        updateTooltip();
    }

    private void updateTooltip()
    {
        setToolTipText(isSelected() ? "Disable sell-only mode" :  "Enable sell-only mode");
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.*;

import javax.swing.*;
import javax.swing.border.Border;
import java.awt.*;
import java.util.concurrent.atomic.AtomicReference;


public class CopilotPanel extends JPanel {
    public final SuggestionPanel suggestionPanel;
    private final ControlPanel controlPanel;
    public final StatsPanelV2 statsPanel;


public CopilotPanel(FlippingCopilotConfig config,
                    AtomicReference<FlipManager> flipTracker,
                    AtomicReference<SessionManager> sessionManager,
                    WebHookController webHookController) {
    setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
    suggestionPanel = new SuggestionPanel(config, webHookController);
    controlPanel = new ControlPanel();
    controlPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, controlPanel.getPreferredSize().height));
    controlPanel.setMinimumSize(new Dimension(Integer.MIN_VALUE, controlPanel.getPreferredSize().height));
    suggestionPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, suggestionPanel.getPreferredSize().height));
    suggestionPanel.setMinimumSize(new Dimension(Integer.MIN_VALUE, suggestionPanel.getPreferredSize().height));
    statsPanel = new StatsPanelV2(config, flipTracker, sessionManager, webHookController);
    add(suggestionPanel);
    add(Box.createRigidArea(new Dimension(0, 5)));
    add(controlPanel);
    add(Box.createRigidArea(new Dimension(0, 5)));
    add(Box.createVerticalGlue());
    add(statsPanel);
}
    public void init(FlippingCopilotPlugin plugin) {
        controlPanel.init(plugin);
        suggestionPanel.init(plugin);
    }
}

/* Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * Copyright (c) 2024, Cillian Brewitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;

import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class WidgetHighlightOverlay extends Overlay
{
    private final Widget widget;
    private final Color color;
    private final Rectangle relativeBounds;

    @Inject
    public WidgetHighlightOverlay(final Widget widget, Color color, Rectangle relativeBounds)
    {
        this.widget = widget;
        this.color = color;
        this.relativeBounds = relativeBounds;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (widget == null)
        {
            return null;
        }

        Rectangle highlightBounds = widget.getBounds();

        if (highlightBounds == null)
        {
            return null;
        }

        highlightBounds.x += relativeBounds.x;
        highlightBounds.y += relativeBounds.y;
        highlightBounds.width = relativeBounds.width;
        highlightBounds.height = relativeBounds.height;

        drawHighlight(graphics, highlightBounds);
        return null;
    }

    private void drawHighlight(Graphics2D graphics, Rectangle bounds)
    {
        graphics.setColor(color);
        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import com.flippingcopilot.model.Suggestion;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

public class GePreviousSearch {
    FlippingCopilotPlugin plugin;

    public GePreviousSearch(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
    }

    public void showSuggestedItemInSearch() {
        Suggestion suggestion = plugin.suggestionHandler.getCurrentSuggestion();

        if (suggestion != null && suggestion.getType().equals("buy")) {
            if (plugin.grandExchange.isPreviousSearchSet() && plugin.grandExchange.showLastSearchEnabled()) {
                setPreviousSearch(suggestion.getItemId(), suggestion.getName());
            } else {
                createPreviousSearchWidget(suggestion.getItemId(), suggestion.getName());
                createPreviousSearchItemNameWidget(suggestion.getName());
                createPreviousSearchItemWidget(suggestion.getItemId());
                createPreviousSearchTextWidget();
            }
            plugin.highlightController.redraw();
        }
    }

    private void setPreviousSearch(int itemId, String itemName) {
        Client client = plugin.getClient();
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget previousSearch = searchResults.getChild(0);
        previousSearch.setOnOpListener(754, itemId, 84);
        previousSearch.setOnKeyListener(754, itemId, -2147483640);
        previousSearch.setName("<col=ff9040>" + itemName + "</col>");
        Widget previousSearchText = searchResults.getChild(1);
        previousSearchText.setText("Copilot item:");
        Widget itemNameWidget = searchResults.getChild(2);
        itemNameWidget.setText(itemName);
        Widget item = searchResults.getChild(3);
        item.setItemId(itemId);
    }

    private void createPreviousSearchWidget(int itemId, String itemName) {
        Widget parentWidget = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.RECTANGLE);
        widget.setTextColor(0xFFFFFF);
        widget.setOpacity(255);
        widget.setName("<col=ff9040>" + itemName + "</col>");
        widget.setHasListener(true);
        widget.setFilled(true);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(256);
        widget.setOriginalHeight(32);
        widget.setOnOpListener(754, itemId, 84);
        widget.setOnKeyListener(754, itemId, -2147483640);
        widget.setHasListener(true);
        widget.setAction(0, "Select");
        // set opacity to 200 when mouse is hovering
        widget.setOnMouseOverListener((JavaScriptCallback) ev -> {
            widget.setOpacity(200);
        });
        // set opacity back to 255 when mouse is not hovering
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
            widget.setOpacity(255);
        });

        widget.revalidate();
    }

    private void createPreviousSearchItemNameWidget(String itemName) {
        Widget parentWidget = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText(itemName);
        widget.setFontId(495);
        widget.setOriginalX(254);
        widget.setOriginalY(0);
        widget.setOriginalWidth(116);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }

    private void createPreviousSearchItemWidget(int itemId) {
        Widget parentWidget = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.GRAPHIC);
        widget.setItemId(itemId);
        widget.setItemQuantity(1);
        widget.setItemQuantityMode(0);
        widget.setRotationX(550);
        widget.setModelZoom(1031);
        widget.setBorderType(1);
        widget.setOriginalX(214);
        widget.setOriginalY(0);
        widget.setOriginalWidth(36);
        widget.setOriginalHeight(32);
        widget.revalidate();
    }

    private void createPreviousSearchTextWidget() {
        Widget parentWidget = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText("Copilot item:");
        widget.setFontId(495);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(95);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlipManager;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.SessionManager;
import com.flippingcopilot.controller.WebHookController;
import com.flippingcopilot.model.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;


import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicComboBoxEditor;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.flippingcopilot.util.AtomicReferenceUtils.ifBothPresent;
import static com.flippingcopilot.util.AtomicReferenceUtils.ifPresent;

@Slf4j
public class StatsPanelV2 extends JPanel {


    public final BufferedImage TRASH_ICON = ImageUtil.loadImageResource(getClass(), "/trash.png");
    public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
    public final Icon OPEN_ICON = new ImageIcon(ARROW_ICON);
    public final Icon CLOSE_ICON = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(90)));

    private static final String ALL_ACCOUNTS_DROPDOWN_OPTION = "All accounts";
    private static final java.util.List<Integer> SESSION_STATS_INDS = Arrays.asList(3,4,5);
    private static final String[] TIME_INTERVAL_STRINGS = {
            "-1h (Past Hour)",
            "-4h (Past 4 Hours)",
            "-12h (Past 12 Hours)",
            "-1d (Past Day)",
            "-1w (Past Week)",
            "-1m (Past Month)",
            "Session",
            "All"};

    private static final Pattern INTERVAL_PATTERN = Pattern.compile("^-?(\\d+)([hdwmy])[()\\w\\s]*");

    // dependencies
    private final FlippingCopilotConfig config;
    private final AtomicReference<FlipManager> flipManager;
    private final AtomicReference<SessionManager> sessionManager;
    private final WebHookController webHookController;

    // state
    public boolean isLoggedOut = false;
    private JComboBox<String> timeIntervalDropdown;
    private final DefaultComboBoxModel<String> rsAccountDropdownModel = new DefaultComboBoxModel<>();
    private final JComboBox<String> rsAccountDropdown = new JComboBox<>(rsAccountDropdownModel);
    private final JButton sessionResetButton = new JButton("  reset  ");
    private JPanel profitAndSubInfoPanel;
    private JPanel subInfoPanel;
    private final JPanel flipsPanel;
    private final JLabel totalProfitVal = new JLabel("0 gp");
    private final JLabel roiVal = new JLabel("-0.00%");
    private final JLabel flipsMadeVal = new JLabel("0");
    private final JLabel taxPaidVal = new JLabel("0 gp");
    private final JLabel sessionTimeVal = new JLabel("00:00:00");
    private final JLabel hourlyProfitVal = new JLabel("0 gp/hr");
    private final JLabel avgCashVal = new JLabel("0 gp");
    private final Paginator paginator = new Paginator(() -> this.updateStatsAndFlips(true));

    private IntervalTimeUnit selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
    private int selectedIntervalValue = -1;

    public StatsPanelV2(FlippingCopilotConfig config, AtomicReference<FlipManager> FlipManager, AtomicReference<SessionManager> sessionManager, WebHookController webHookController) {
        this.sessionManager = sessionManager;
        this.webHookController = webHookController;
        this.config = config;
        this.flipManager = FlipManager;

        setLayout(new BorderLayout());

        setupTimeIntervalDropdown();
        setupProfitAndSubInfoPanel();
        setupSessionResetButton();

        flipsPanel = new JPanel();
        flipsPanel.setLayout(new BoxLayout(flipsPanel, BoxLayout.Y_AXIS));
        flipsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        flipsPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

        JScrollPane scrollPane = new JScrollPane(flipsPanel);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        // Create a main panel with vertical layout
        JPanel mainPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel timeIntervalDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        timeIntervalDropdownWrapper.setBorder(BorderFactory.createEmptyBorder()); // No border
        timeIntervalDropdownWrapper.add(timeIntervalDropdown, BorderLayout.CENTER);
        timeIntervalDropdownWrapper.add(sessionResetButton, BorderLayout.EAST);
        timeIntervalDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeIntervalDropdownWrapper.getPreferredSize().height));

        JPanel intervalRsAccountDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        rsAccountDropdown.setBorder(BorderFactory.createEmptyBorder());
        rsAccountDropdown.setMaximumSize(new Dimension(Integer.MAX_VALUE, rsAccountDropdown.getPreferredSize().height));
        intervalRsAccountDropdownWrapper.add(timeIntervalDropdownWrapper, BorderLayout.NORTH);
        intervalRsAccountDropdownWrapper.add(rsAccountDropdown, BorderLayout.SOUTH);
        rsAccountDropdown.addActionListener(e -> {
            String value = (String) rsAccountDropdown.getSelectedItem();
            log.info("selected rs account is: {}", value);
            if(value != null) {
                if (ALL_ACCOUNTS_DROPDOWN_OPTION.equals(value)) {
                    ifPresent(flipManager, fm -> fm.setIntervalDisplayName(null));
                } else {
                    ifPresent(flipManager, fm -> fm.setIntervalDisplayName(value));
                }
            }
        });
        intervalRsAccountDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, intervalRsAccountDropdownWrapper.getPreferredSize().height));

        mainPanel.add(intervalRsAccountDropdownWrapper);
        mainPanel.add(profitAndSubInfoPanel);
        mainPanel.add(scrollPane);

        add(mainPanel, BorderLayout.CENTER);

        add(paginator, BorderLayout.SOUTH);
    }

    public void resetRsAccountDropdown() {
        rsAccountDropdownModel.removeAllElements();
        rsAccountDropdown.setVisible(false);
    }

    public void resetIntervalDropdownToSession() {
        timeIntervalDropdown.setSelectedItem("Session");
        selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
        selectedIntervalValue = -1;
    }

    private void setupSessionResetButton() {
        sessionResetButton.setBorder(BorderFactory.createEmptyBorder());
        sessionResetButton.addActionListener((l) -> {
            JLabel resetIcon = new JLabel(new ImageIcon(TRASH_ICON));
            final int result = JOptionPane.showOptionDialog(resetIcon, "<html>Are you sure you want to reset the session?</html>",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");
            if (result == JOptionPane.YES_OPTION) {
                ifBothPresent(sessionManager, flipManager, (sm, fm) -> {
                        // send discord message before resetting session stats
                        webHookController.sendMessage(fm.calculateStats(sm.getData().startTime, sm.getDisplayName()), sm.getData(), sm.getDisplayName(), true);
                        sm.resetSession();
                        if(IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit)) {
                            fm.setIntervalStartTime(sm.getData().startTime);
                        }
                }).orElse(() -> ifPresent(sessionManager, SessionManager::resetSession));
            }
        });
    }

    private boolean extractAndUpdateTimeInterval(String value) {
        if (value != null) {
            if ("Session".equals(value)) {
                selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
                selectedIntervalValue = -1;
                return true;
            } else if ("All".equals(value)) {
                selectedIntervalTimeUnit = IntervalTimeUnit.ALL;
                selectedIntervalValue = -1;
                return true;
            } else {
                Matcher matcher = INTERVAL_PATTERN.matcher(value);
                if (matcher.matches()) {
                    selectedIntervalValue = Integer.parseInt(matcher.group(1));
                    selectedIntervalTimeUnit = IntervalTimeUnit.fromString(matcher.group(2));
                    return true;
                }
            }
        }
        return false;
    }


    private void setupTimeIntervalDropdown() {
        timeIntervalDropdown = new JComboBox<>(TIME_INTERVAL_STRINGS);
        timeIntervalDropdown.setEditable(true);
        timeIntervalDropdown.setSelectedItem("Session");
        timeIntervalDropdown.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setBorder(BorderFactory.createEmptyBorder());

        // Create a custom editor to handle both selection and manual input
        ComboBoxEditor editor = new BasicComboBoxEditor() {
            @Override
            public void setItem(Object item) {
                super.setItem(item);
                if (item != null) {
                    String value = item.toString();
                    if (extractAndUpdateTimeInterval(value)) {
                        updateFlipTrackerAndStats();
                    }
                }
            }
        };
        timeIntervalDropdown.setEditor(editor);

        // Add action listener for selection changes and manual edits
        timeIntervalDropdown.addActionListener(e -> {
            String value = (String) timeIntervalDropdown.getSelectedItem();
            if (extractAndUpdateTimeInterval(value)) {
                updateFlipTrackerAndStats();
            }
        });
    }

    private void updateFlipTrackerAndStats() {
        log.debug("selection interval value updated to {} {}", selectedIntervalValue, selectedIntervalTimeUnit);
        ifPresent(flipManager, fm -> {
            switch (selectedIntervalTimeUnit) {
                case ALL:
                    fm.setIntervalStartTime(1);
                    break;
                case SESSION:
                    ifPresent(sessionManager, sm -> fm.setIntervalStartTime(sm.getData().startTime));
                    break;
                default:
                    int startTime = (int) Instant.now().getEpochSecond() - selectedIntervalValue * selectedIntervalTimeUnit.getSeconds();
                    fm.setIntervalStartTime(startTime);
            }
        });
    }

    private JPanel buildSubInfoPanelItem(String key, JLabel value, Color valueColor) {
        JPanel item = new JPanel(new BorderLayout());
        item.setBorder(new EmptyBorder(4, 2, 4, 2));
        item.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel keyLabel = new JLabel(key);
        keyLabel.setFont(FontManager.getRunescapeSmallFont());
        item.add(keyLabel, BorderLayout.WEST);
        value.setFont(FontManager.getRunescapeSmallFont());
        value.setForeground(valueColor);
        item.add(value, BorderLayout.EAST);
        item.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));
        return item;
    }

    private JPanel buildSubInfoPanel() {
        JPanel subInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        subInfoPanel.add(buildSubInfoPanelItem("ROI:", roiVal, UIUtilities.TOMATO));
        subInfoPanel.add(buildSubInfoPanelItem("Flips made:", flipsMadeVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Tax paid:", taxPaidVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Session time:", sessionTimeVal, ColorScheme.GRAND_EXCHANGE_ALCH));
        subInfoPanel.add(buildSubInfoPanelItem("Hourly profit:", hourlyProfitVal, Color.WHITE));
        subInfoPanel.add(buildSubInfoPanelItem("Avg wealth:", avgCashVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        subInfoPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(0,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(2, 5, 5, 5)));
       return subInfoPanel;
    }

    private void setupProfitAndSubInfoPanel() {
        profitAndSubInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        profitAndSubInfoPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Create the header panel that can be clicked to expand/collapse sub info
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(5, 0, 5, 0)));

        final JLabel profitTitle = new JLabel("Profit: ");
        profitTitle.setFont(FontManager.getRunescapeBoldFont());

        totalProfitVal.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        totalProfitVal.setFont(FontManager.getRunescapeBoldFont().deriveFont(24f));
        totalProfitVal.setHorizontalAlignment(SwingConstants.CENTER);

        // Use a panel to stack the profitTitle and totalProfitVal vertically
        JPanel profitTextPanel = new JPanel();
        profitTextPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        profitTextPanel.add(profitTitle);
        profitTextPanel.add(Box.createRigidArea(new Dimension(5, 0))); // Spacing between title and value
        profitTextPanel.add(totalProfitVal);
        profitTextPanel.setBorder(BorderFactory.createEmptyBorder(2,4,2,4));

        // Arrow label
        JLabel arrowLabel = new JLabel(OPEN_ICON);
        arrowLabel.setHorizontalAlignment(SwingConstants.CENTER);
        arrowLabel.setVerticalAlignment(SwingConstants.CENTER);
        arrowLabel.setPreferredSize(new Dimension(16, 16)); // Adjust size as needed

        // Add components to headerPanel
        headerPanel.add(profitTextPanel, BorderLayout.CENTER);
        headerPanel.add(arrowLabel, BorderLayout.EAST);

        // Create the sub-info panel
        subInfoPanel = buildSubInfoPanel();

        headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 70));
        profitAndSubInfoPanel.add(headerPanel);
        profitAndSubInfoPanel.add(subInfoPanel);

        // Mouse listener to handle expand/collapse and hover effects
        MouseAdapter headerMouseListener = new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                boolean isExpanded = subInfoPanel.isVisible();
                if(!isExpanded && rsAccountDropdownModel.getSize() > 2) {
                    rsAccountDropdown.setVisible(true);
                } else if (isExpanded && rsAccountDropdownModel.getSize() > 2) {
                    rsAccountDropdown.setVisible(false);
                }
                subInfoPanel.setVisible(!isExpanded);
                arrowLabel.setIcon(isExpanded ? OPEN_ICON : CLOSE_ICON);
                log.debug("profit and sub info panel clicked");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                headerPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                headerPanel.setCursor(Cursor.getDefaultCursor());
            }
        };

        // Add mouse listener to header components
        headerPanel.addMouseListener(headerMouseListener);
        totalProfitVal.addMouseListener(headerMouseListener);
        profitTitle.addMouseListener(headerMouseListener);

    }

    // called when:
    //
    // - time interval drop down changed (Swing EDT thread)
    // - session reset button pressed (Swing EDT thread)
    // - transaction processing downstream (ScheduledExecutorService)
    // - FlipTrackerV2 initialisation (ScheduledExecutorService)
    // - session stats updated (ScheduledExecutorService)
    // - plugin config changed (Client thread)
    // - page changed (Swing EDT thread)
    //

    public void updateStatsAndFlips(boolean flipsMaybeChanged) {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(() -> updateStatsAndFlips(flipsMaybeChanged));
            return;
        }
        FlipManager fm = flipManager.get();
        SessionManager sm = sessionManager.get();
        if (isLoggedOut || fm == null || sm == null) {
            totalProfitVal.setText("0 gp");
            roiVal.setText("-0.00%");
            flipsMadeVal.setText("0");
            taxPaidVal.setText("0 gp");
            sessionTimeVal.setText("00:00:00");
            hourlyProfitVal.setText("0 gp/hr");
            avgCashVal.setText("0 gp");
            flipsPanel.removeAll();
            paginator.setTotalPages(1);
            boolean v = IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit);
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(v));
            rsAccountDropdownModel.removeAllElements();
            rsAccountDropdown.setVisible(false);
            return;
        }

        java.util.List<String> displayNameOptions = fm.getDisplayNameOptions();
        String selectedDisplayName = fm.getIntervalDisplayName();
        if (displayNameOptionsOutOfDate(displayNameOptions) || selectedDisplayNameOutOfDate(selectedDisplayName)) {
            rsAccountDropdownModel.removeAllElements();
            rsAccountDropdownModel.addAll(displayNameOptions);
            rsAccountDropdownModel.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
            if (selectedDisplayName == null) {
                rsAccountDropdown.setSelectedItem(rsAccountDropdownModel.getElementAt(rsAccountDropdownModel.getSize()-1));
            } else {
                rsAccountDropdown.setSelectedItem(selectedDisplayName);
            }
            if(rsAccountDropdownModel.getSize() > 2) {
                rsAccountDropdown.setVisible(true);
            }
        }

        SessionData sd = sm.getData();
        Stats stats = fm.getIntervalStats();
        paginator.setTotalPages(1 + stats.flipsMade / 50);
        long s = System.nanoTime();
        if (flipsMaybeChanged) {
            flipsPanel.removeAll();
            fm.getPageFlips(paginator.getPageNumber(), 50).forEach(f -> flipsPanel.add(new FlipPanel(f, config)));
            // labels displayed to the user
            roiVal.setText(String.format("%.3f%%", stats.calculateRoi() * 100));
            roiVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            flipsMadeVal.setText(String.format("%d", stats.flipsMade));
            taxPaidVal.setText(UIUtilities.formatProfit(stats.taxPaid));
            totalProfitVal.setText(UIUtilities.formatProfit(stats.profit));
            totalProfitVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            log.debug("populating flips took {}ms", (System.nanoTime() - s) / 1000_000);
        }

        // 'Session time', 'Hourly profit' and 'Avg wealth' should only be set if 'Session' is select in the dropdown
        if (IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit)) {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(true));
            long seconds = sd.durationMillis / 1000;
            float hoursFloat = (((float) seconds) / 3600.0f);
            long hourlyProfit = hoursFloat == 0 ? 0 : (long) (stats.profit / hoursFloat);
            sessionTimeVal.setText(String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60));
            hourlyProfitVal.setText(UIUtilities.formatProfitWithoutGp(hourlyProfit) + " gp/hr");
            hourlyProfitVal.setForeground(UIUtilities.getProfitColor(hourlyProfit, config));
            avgCashVal.setText(UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp");
        } else {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(false));
        }
    }

    private boolean selectedDisplayNameOutOfDate(String selectedDisplayName) {
        String oldSelectedDisplayName = (String) rsAccountDropdown.getSelectedItem();
        if (ALL_ACCOUNTS_DROPDOWN_OPTION.equals(oldSelectedDisplayName) && selectedDisplayName == null) {
            return false;
        }
        return !oldSelectedDisplayName.equals(selectedDisplayName);
    }

    private boolean displayNameOptionsOutOfDate(List<String> displayNameOptions) {
        if (displayNameOptions.size() + 1 != rsAccountDropdownModel.getSize()) {
            return true;
        }
        for(int i = 0; i< displayNameOptions.size(); i++) {
            if (!displayNameOptions.get(i).equals(rsAccountDropdownModel.getElementAt(i))) {
                return true;
            }
        }
        return false;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;

public class UIUtilities {
    public static final String discordIcon = "/discord.png";
    public static final String githubIcon = "/github.png";
    public static final String logoutIcon = "/logout.png";
    public static final String internetIcon = "/internet.png";
    public static final String graphIcon = "/graph.png";

    static final float BUTTON_HOVER_LUMINANCE = 0.65f;
    public static final Color OUTDATED_COLOR = new Color(250, 74, 75);
    public static final Color BLUE_HIGHLIGHT_COLOR =  new Color(27, 173, 255, 79);
    public static final Color RED_HIGHLIGHT_COLOR = new Color(255, 20, 20, 79);
    public static final Color TOMATO = new Color(255,99,71);
    public static final Color DARK_GRAY = new Color(27, 27, 27);

    private static final NumberFormat PRECISE_DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.###",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );
    private static final NumberFormat DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.#",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );

    public static synchronized String quantityToRSDecimalStack(long quantity, boolean precise)
    {
        if (Long.toString(quantity).length() <= 4)
        {
            return QuantityFormatter.formatNumber(quantity);
        }

        long power = (long) Math.log10(quantity);

        // Output thousandths for values above a million
        NumberFormat format = precise && power >= 6
                ? PRECISE_DECIMAL_FORMATTER
                : DECIMAL_FORMATTER;

        return format.format(quantity / Math.pow(10, (Long.divideUnsigned(power, 3)) * 3))
                + new String[] {"", "K", "M", "B", "T"}[(int) (power / 3)];
    }

    public static Color getProfitColor(long profit, FlippingCopilotConfig config) {
        if (profit > 0) {
            return config.profitAmountColor();
        } else if (profit < 0) {
            return config.lossAmountColor();
        } else {
            return Color.WHITE;
        }
    }

    public static String formatProfit(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true) + " gp";
    }

    public static String formatProfitWithoutGp(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true);
    }

    public static String truncateString(String string, int length) {
        if (string.length() > length) {
            return string.substring(0, length) + "...";
        }
        return string;
    }

    static JLabel buildButton(BufferedImage icon, String tooltip, Runnable onClick) {
        JLabel label = new JLabel();
        label.setToolTipText(tooltip);
        label.setHorizontalAlignment(JLabel.CENTER);
        ImageIcon iconOff = new ImageIcon(icon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(icon, BUTTON_HOVER_LUMINANCE));
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                try {
                    onClick.run();
                } catch (Exception error) {}
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                label.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setIcon(iconOff);
            }
        });
        label.setIcon(iconOff);
        return label;
    }

    static JLabel buildUriButton(BufferedImage icon, String tooltip, String uriString) {
        return buildButton(icon, tooltip, () -> {
            try {
                Desktop desktop = Desktop.getDesktop();
                URI uri = new URI(uriString);
                desktop.browse(uri);
            } catch (Exception error) {}
        });
    }

    public static JPanel newVerticalBoxLayoutJPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        return panel;
    }
}

package com.flippingcopilot.ui;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
public class Paginator extends JPanel {

	public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
	public final Icon ARROW_RIGHT = new ImageIcon(ARROW_ICON);
	public final Icon HIGHLIGHTED_ARROW_RIGHT = new ImageIcon(ImageUtil.luminanceScale(ARROW_ICON, BUTTON_HOVER_LUMINANCE));
	public final Icon ARROW_LEFT = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)));
	public final Icon HIGHLIGHTED_ARROW_LEFT = new ImageIcon(ImageUtil.luminanceScale(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)), BUTTON_HOVER_LUMINANCE));

	@Getter
	private int pageNumber = 1;
	@Getter
	private int totalPages = 1;
	private final JLabel statusText = new JLabel("Page 1 of 1", SwingUtilities.CENTER);
	private final JLabel arrowRight= new JLabel(ARROW_RIGHT);
	private final JLabel arrowLeft =  new JLabel(ARROW_LEFT);
	private final Runnable onPageChange;

	public Paginator(Runnable onPageChange) {
		this.onPageChange = onPageChange;
		this.statusText.setFont(FontManager.getRunescapeFont());
		this.arrowRight.setForeground(Color.blue);
		setLayout(new FlowLayout());
		add(arrowLeft);
		add(statusText);
		add(arrowRight);
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(3, 0, 0, 0));
		arrowLeft.addMouseListener(onDecreasePage());
		arrowRight.addMouseListener(onIncreasePage());
	}

	public void setTotalPages(int totalPages) {
		this.totalPages = totalPages;
		if(pageNumber > this.totalPages) {
			pageNumber = 1;
		}
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	private MouseAdapter onIncreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber < totalPages) {
					pageNumber++;
					onPageChange.run();
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowRight.setIcon(HIGHLIGHTED_ARROW_RIGHT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowRight.setIcon(ARROW_RIGHT);
			}
		};
	}

	private MouseAdapter onDecreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber > 1) {
					pageNumber--;
					onPageChange.run();
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowLeft.setIcon(HIGHLIGHTED_ARROW_LEFT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowLeft.setIcon(ARROW_LEFT);
			}
		};
	}
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.*;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.concurrent.atomic.AtomicReference;

import static com.flippingcopilot.ui.UIUtilities.buildButton;

public class MainPanel extends PluginPanel {
    public LoginPanel loginPanel;
    public CopilotPanel copilotPanel;
    public Runnable onCopilotLogout;

    public MainPanel(FlippingCopilotConfig config, AtomicReference<FlipManager> flipManager, AtomicReference<SessionManager> sessionManager, WebHookController webHookController) {
        super(false);
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(5, 6, 5, 6));
        copilotPanel = new CopilotPanel(config, flipManager, sessionManager, webHookController);
    }

    public void init(FlippingCopilotPlugin plugin) {
        copilotPanel.init(plugin);
        this.loginPanel = plugin.copilotLoginController.getPanel();
        this.onCopilotLogout = plugin.copilotLoginController::onLogout;
        renderLoggedOutView();
    }

    public void renderLoggedOutView() {
        removeAll();
        add(constructTopBar(false), BorderLayout.NORTH);
        loginPanel.showLoginErrorMessage("");
        add(loginPanel, BorderLayout.CENTER);
        revalidate();
    }

    public void renderLoggedInView() {
        removeAll();
        add(constructTopBar(true), BorderLayout.NORTH);
        add(copilotPanel, BorderLayout.CENTER);
        revalidate();
    }

    private JPanel constructTopBar(boolean isLoggedIn) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setLayout(new BorderLayout());
        JPanel topBar = new JPanel();
        topBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int columns = isLoggedIn ? 4 : 3;
        topBar.setLayout(new GridLayout(1, columns));

        JLabel github = buildTopBarUriButton(UIUtilities.githubIcon,
                "Flipping Copilot Github",
                "https://github.com/cbrewitt/flipping-copilot");
        topBar.add(github);

        JLabel discord = buildTopBarUriButton(UIUtilities.discordIcon,
                "Flipping Copilot Discord",
                "https://discord.gg/UyQxA4QJAq");
        topBar.add(discord);

        JLabel website = buildTopBarUriButton(UIUtilities.internetIcon,
                "Flipping Copilot website",
                "https://flippingcopilot.com");
        topBar.add(website);

        if (isLoggedIn) {
            BufferedImage icon = ImageUtil.loadImageResource(getClass(), UIUtilities.logoutIcon);
            JLabel logout = buildButton(icon, "Log out", () -> {
                onCopilotLogout.run();
                renderLoggedOutView();
            });
            topBar.add(logout);
        }

        container.add(topBar);
        container.setBorder(new EmptyBorder(3, 0, 10, 0));
        return container;
    }

    private JLabel buildTopBarUriButton(String iconPath, String tooltip, String uriString) {
        BufferedImage icon = ImageUtil.loadImageResource(getClass(), iconPath);
        return buildButton(icon, tooltip, () -> {
            LinkBrowser.browse(uriString);
        });
    }

}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import com.flippingcopilot.model.Suggestion;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.FontID;
import net.runelite.api.widgets.*;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class OfferEditor {
    private FlippingCopilotPlugin plugin;
    private Widget text;
    private static final int MOUSE_OFF_TEXT_COLOR = 0x0040FF;
    private static final int MOUSE_OFF_ERROR_TEXT_COLOR = 0xAA2222;

    public OfferEditor(Widget parent, FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        if (parent == null) {
            return;
        }

        text = parent.createChild(-1, WidgetType.TEXT);
        prepareTextWidget(text, WidgetTextAlignment.LEFT, WidgetPositionMode.ABSOLUTE_TOP, 40, 10);
    }

    private void prepareTextWidget(Widget widget, int xAlignment, int yMode, int yOffset, int xOffset) {
        widget.setTextColor(MOUSE_OFF_TEXT_COLOR);
        widget.setFontId(FontID.VERDANA_11_BOLD);
        widget.setYPositionMode(yMode);
        widget.setOriginalX(xOffset);
        widget.setOriginalY(yOffset);
        widget.setOriginalHeight(20);
        widget.setXTextAlignment(xAlignment);
        widget.setWidthMode(WidgetSizeMode.MINUS);
        widget.revalidate();
    }

    public void showSuggestion(Suggestion suggestion) {
        var currentItemId = plugin.client.getVarpValue(CURRENT_GE_ITEM);
        if (plugin.offerHandler.isSettingQuantity()) {
            if (currentItemId != suggestion.getItemId()) {
                return;
            }
            if (!suggestion.getType().equals(plugin.offerHandler.getOfferType())) {
                return;
            }

            shiftChatboxWidgetsDown();
            showQuantity(suggestion.getQuantity());
        } else if (plugin.offerHandler.isSettingPrice()) {
            if (currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(plugin.offerHandler.getOfferType())) {
                int price = plugin.offerHandler.getViewedSlotItemPrice();
                if (plugin.offerHandler.getViewedSlotPriceErrorText() != null && price <= 0) {
                    shiftChatboxWidgetsDown();
                    setErrorText(plugin.offerHandler.getViewedSlotPriceErrorText());
                    return;
                }

                if (plugin.offerHandler.getViewedSlotItemId() == currentItemId) {
                    shiftChatboxWidgetsDown();
                    if (plugin.offerHandler.getViewedSlotPriceErrorText() != null) {
                        showPriceWithWarning(price, plugin.offerHandler.getViewedSlotPriceErrorText());
                    } else {
                        showPrice(price);
                    }
                }
            } else {
                shiftChatboxWidgetsDown();
                showPrice(suggestion.getPrice());
            }
        }
    }

    private void showQuantity(int quantity) {
        text.setText("set to Copilot quantity: " + quantity);
        text.setAction(1, "Set quantity");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            plugin.offerHandler.setChatboxValue(quantity);
        });
    }

    private void showPrice(int price) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp");
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            plugin.offerHandler.setChatboxValue(price);
        });
    }

    private void showPriceWithWarning(int price, String warning) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp. " + warning);
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            plugin.offerHandler.setChatboxValue(price);
        });
    }

    private void setHoverListeners(Widget widget) {
        widget.setHasListener(true);
        widget.setOnMouseRepeatListener((JavaScriptCallback) ev -> widget.setTextColor(0xFFFFFF));
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> widget.setTextColor(MOUSE_OFF_TEXT_COLOR));
    }

    private void setErrorText(String message) {
        text.setText(message);
        text.setTextColor(MOUSE_OFF_ERROR_TEXT_COLOR);
        text.revalidate();
    }

    private void shiftChatboxWidgetsDown() {
        Widget chatboxTitle = plugin.client.getWidget(ComponentID.CHATBOX_TITLE);
        if (chatboxTitle != null) {
            chatboxTitle.setOriginalY(chatboxTitle.getOriginalY() + 7);
            chatboxTitle.revalidate();
        }
    }
}
package com.flippingcopilot.ui;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

@Getter
public class Spinner extends JPanel {
    private final JLabel spinnerLabel = new JLabel();

    public Spinner() {
        setLayout(new GridBagLayout());
        setOpaque(false);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = GridBagConstraints.REMAINDER;
        gbc.gridy = GridBagConstraints.REMAINDER;
        gbc.weightx = 1;
        gbc.weighty = 1;
        gbc.anchor = GridBagConstraints.CENTER;

        spinnerLabel.setPreferredSize(new Dimension(30, 30));
        add(spinnerLabel, gbc);
        setUpIcon();
        hide();
    }

    public void show() {
        spinnerLabel.setVisible(true);
    }

    public void hide() {
        spinnerLabel.setVisible(false);
    }

    private void setUpIcon() {
        IconTextField.Icon icon = IconTextField.Icon.LOADING;
        final ImageIcon imageIcon = new ImageIcon(Objects.requireNonNull(IconTextField.class.getResource(icon.getFile())));
        spinnerLabel.setIcon(imageIcon);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.FlippingCopilotPlugin;
import com.flippingcopilot.controller.WebHookController;
import com.flippingcopilot.model.Suggestion;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;

import static com.flippingcopilot.ui.UIUtilities.*;
import static com.flippingcopilot.util.Constants.MIN_GP_NEEDED_TO_FLIP;

public class SuggestionPanel extends JPanel {
    private FlippingCopilotPlugin plugin;
    private final JLabel suggestionText = new JLabel();
    public final Spinner spinner = new Spinner();
    private JLabel skipButton;
    private final JPanel buttonContainer = new JPanel();
    public PauseButton pauseButton;
    private JLabel graphButton;
    private FlippingCopilotConfig config;

    @Setter
    private String serverMessage = "";

    public SuggestionPanel(FlippingCopilotConfig config, WebHookController webHookController) {
        this.config = config;
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        setPreferredSize(new Dimension(0, 150));

        JLabel title = new JLabel("<html><center> <FONT COLOR=white><b>Suggested Action:" +
                "</b></FONT></center></html>");
        title.setHorizontalAlignment(SwingConstants.CENTER);
        add(title, BorderLayout.NORTH);

        JPanel suggestionContainer = new JPanel();
        suggestionContainer.setLayout(new CardLayout());
        suggestionContainer.setOpaque(true);
        suggestionContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.setPreferredSize(new Dimension(0, 85));
        add(suggestionContainer, BorderLayout.CENTER);

        suggestionText.setHorizontalAlignment(SwingConstants.CENTER);
        suggestionText.setOpaque(true);
        suggestionText.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.add(suggestionText);
        suggestionContainer.add(spinner);
        setupButtonContainer();
        suggestLogin();
    }

    public void init(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        setupPauseButton();
    }

    private void setupButtonContainer() {
        buttonContainer.setLayout(new BorderLayout());
        buttonContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        //buttonContainer.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));
        add(buttonContainer, BorderLayout.SOUTH);
        setupGraphButton();
        setupSkipButton();
    }

    private void setupGraphButton() {
        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/graph.png");
        graphButton = buildButton(graphIcon, "Price graph", () -> {
            Suggestion suggestion = plugin.suggestionHandler.getCurrentSuggestion();
            String url = config.priceGraphWebsite().getUrl(suggestion.getName(), suggestion.getItemId());
            LinkBrowser.browse(url);
        });
        buttonContainer.add(graphButton, BorderLayout.WEST);
    }


    private void setupSkipButton() {
        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/skip.png");
        skipButton = buildButton(graphIcon, "Skip suggestion", () -> {
            showLoading();
            plugin.suggestionHandler.skipCurrentSuggestion();
        });
        buttonContainer.add(skipButton, BorderLayout.EAST);
    }

    private void setupPauseButton() {
        pauseButton = new PauseButton(plugin);
        Box box = Box.createHorizontalBox();
        box.add(Box.createHorizontalGlue());
        box.add(pauseButton);
        box.add(Box.createHorizontalGlue());
        buttonContainer.add(box, BorderLayout.CENTER);
    }


    public void updateSuggestion(Suggestion suggestion) {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String suggestionString = "<html><center>";

        switch (suggestion.getType()) {
            case "wait":
                suggestionString += "Wait <br>";
                break;
            case "abort":
                suggestionString += "Abort offer for<br><FONT COLOR=white>" + suggestion.getName() + "<br></FONT>";
                break;
            case "buy":
            case "sell":
                String capitalisedAction = suggestion.getType().equals("buy") ? "Buy" : "Sell";
                suggestionString += capitalisedAction +
                        " <FONT COLOR=yellow>" + formatter.format(suggestion.getQuantity()) + "</FONT><br>" +
                        "<FONT COLOR=white>" + suggestion.getName() + "</FONT><br>" +
                        "for <FONT COLOR=yellow>" + formatter.format(suggestion.getPrice()) + "</FONT> gp<br>";
                break;
            default:
                suggestionString += "Error processing suggestion<br>";
        }
        suggestionString += suggestion.getMessage();
        suggestionString += "</center><html>";
        suggestionText.setText(suggestionString);
        suggestionText.setVisible(true);
        if(!suggestion.getType().equals("wait")) {
            setButtonsVisible(true);
        }
    }

    public void suggestCollect() {
        setMessage("Collect items");
        setButtonsVisible(false);
    }

    public void suggestAddGp() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        setMessage("Add at least <FONT COLOR=yellow>" + formatter.format(MIN_GP_NEEDED_TO_FLIP)
                               + "</FONT> gp<br>to your inventory<br>"
                               + "to get a flip suggestion");
    }

    public void suggestLogin() {
        setMessage("Log in to the game<br>to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void setIsPausedMessage() {
        setMessage("Suggestions are paused");
        setButtonsVisible(false);
    }

    public void showConnectionError() {
        setMessage("Failed to connect to server");
        setButtonsVisible(false);
    }

    public void setMessage(String message) {
        suggestionText.setText("<html><center>" + message +  "<br>" + serverMessage + "</center><html>");
        setButtonsVisible(false);
    }

    public void showLoading() {
        suggestionText.setVisible(false);
        setServerMessage("");
        spinner.show();
        setButtonsVisible(false);
    }

    public void hideLoading() {
        spinner.hide();
        suggestionText.setVisible(true);
    }

    private void setButtonsVisible(boolean visible) {
        skipButton.setVisible(visible);
        graphButton.setVisible(visible);
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

@Slf4j
public class ControlPanel extends JPanel {
    SellOnlyModeToggleButton sellOnlyModeToggleButton = new SellOnlyModeToggleButton();
    public ControlPanel() {
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setLayout(new BorderLayout(3, 0));
        setBorder(BorderFactory.createEmptyBorder(5, 50, 5, 50));

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new BorderLayout());
        buttonPanel.setOpaque(false);
        add(buttonPanel, BorderLayout.CENTER);

        JLabel buttonText = new JLabel("Sell-only Mode");
        buttonPanel.add(buttonText, BorderLayout.LINE_START);
        buttonPanel.add(sellOnlyModeToggleButton, BorderLayout.LINE_END);
    }

    public void init(FlippingCopilotPlugin plugin) {
        sellOnlyModeToggleButton.addItemListener(i ->
        {
            plugin.accountStatus.setSellOnlyMode(sellOnlyModeToggleButton.isSelected());
            plugin.suggestionHandler.setSuggestionNeeded(true);
            log.debug("Sell only mode is now: {}", plugin.accountStatus.isSellOnlyMode());
        });
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import java.awt.*;

public class GpDropOverlay extends Overlay {
    private final OverlayManager overlayManager;
    private final long profit;
    private final long startTime;
    private final Point startPosition = new Point(); // Starting position of the text
    final TextComponent textComponent = new TextComponent();

    public GpDropOverlay(FlippingCopilotPlugin plugin, long profit, int slot) {
        this.profit = profit;
        this.overlayManager = plugin.overlayManager;
        this.startTime = System.currentTimeMillis();

        Widget slotWidget =  plugin.client.getWidget(465, slot + 7);
        if (slotWidget == null) {
            return;
        }
        startPosition.x = slotWidget.getCanvasLocation().getX() + 35;
        startPosition.y = slotWidget.getCanvasLocation().getY() + 75;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        String absProfitText = UIUtilities.quantityToRSDecimalStack(Math.abs(profit), false);
        String profitText = (profit >= 0 ? "+ " : "- ") + absProfitText + " gp";
        textComponent.setText(profitText);
        textComponent.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 16f));
        if (profit < 0) {
            textComponent.setColor(Color.RED);
        } else {
            textComponent.setColor(Color.GREEN);
        }

        plugin.overlayManager.add(this);
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        long elapsed = System.currentTimeMillis() - startTime;
        if (elapsed > 3000) { // Display for 5 seconds
            overlayManager.remove(this);
            return null;
        }

        // Calculate the upward movement. Adjust the divisor to control the speed.
        int yOffset = (int) (elapsed / 50); // Moves up 1 pixel every 50ms

        // Ensure the text moves upwards by subtracting yOffset from the starting Y position
        Point currentPosition = new Point(startPosition.x, startPosition.y - yOffset);
        textComponent.setPosition(currentPosition);
        textComponent.render(graphics);

        return null;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.FlipV2;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;

public class FlipPanel extends JPanel {

    public FlipPanel(FlipV2 flip, FlippingCopilotConfig config) {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel itemQuantity = new JLabel(String.format("%d x ", flip.getClosedQuantity()));
        itemQuantity.setForeground(Color.WHITE);

        JLabel itemNameLabel = new JLabel(UIUtilities.truncateString(flip.getItemName(), 22));

        // Create a sub-panel for the left side
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        leftPanel.add(itemQuantity);
        leftPanel.add(itemNameLabel);

        JLabel profitLabel = new JLabel(UIUtilities.formatProfitWithoutGp(flip.getProfit()));
        profitLabel.setForeground(UIUtilities.getProfitColor(flip.getProfit(), config));

        // Add the sub-panel to the LINE_START position
        add(leftPanel, BorderLayout.LINE_START);
        add(profitLabel, BorderLayout.LINE_END);
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));

        String closeLabel = flip.getClosedQuantity() == flip.getOpenedQuantity() ? "Close time" : "Partial close time";

        String tooltipText = String.format("Opened time: %s\nAvg buy price: %s\n%s: %s\nAvg sell price: %s\nTax paid: %s\nProfit: %s",
                formatEpoch(flip.getOpenedTime()),
                UIUtilities.formatProfit(flip.getAvgBuyPrice()),
                closeLabel,
                formatEpoch(flip.getClosedTime()),
                UIUtilities.formatProfit(flip.getAvgSellPrice()),
                UIUtilities.formatProfit(flip.getTaxPaid()),
                UIUtilities.formatProfit(flip.getProfit()));
        setToolTipText(tooltipText);
    }

    public static String formatEpoch(long epochSeconds) {
        Instant instant = Instant.ofEpochSecond(epochSeconds);
        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)
                .withZone(ZoneId.systemDefault());
        return formatter.format(instant);
    }
}
package com.flippingcopilot.ui;

import net.runelite.client.input.KeyListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.net.URI;
import java.util.function.Consumer;

public class LoginPanel extends JPanel {
    private final static int PAGE_WIDTH = 225;

    JPanel loginContainer;

    private JButton loginButton;
    private JTextField emailTextField;
    private JTextField passwordTextField;
    private JLabel errorMessageLabel;

    public Spinner spinner;

    Consumer<String> onEmailTextChangedListener;
    Consumer<String> onPasswordTextChangedListener;
    ActionListener onLoginPressedListener;

    public LoginPanel(
        Consumer<String> onEmailTextChangedListener,
        Consumer<String> onPasswordTextChangedListener,
        ActionListener onLoginPressedListener
    ) {
        this.setLayout(new BorderLayout());
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.setSize(PAGE_WIDTH, 250);

        this.onEmailTextChangedListener = onEmailTextChangedListener;
        this.onPasswordTextChangedListener = onPasswordTextChangedListener;
        this.onLoginPressedListener = onLoginPressedListener;

        loginContainer = new JPanel();
        loginContainer.setLayout(new BoxLayout(loginContainer, BoxLayout.PAGE_AXIS));

        this.createLogo();
        this.createSpinner();
        this.createErrorMessageLabel();
        this.createEmailInput();
        this.createPasswordInput();
        this.createLoginButton();
        this.createCreateAccountLink();

        this.add(loginContainer, BorderLayout.NORTH);
    }

    public void createLogo() {
        JPanel container = new JPanel();
        ImageIcon icon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/logo.png"));
        Image resizedLogo = icon.getImage().getScaledInstance(50, 45, Image.SCALE_SMOOTH);
        JLabel logoLabel = new JLabel(new ImageIcon(resizedLogo));
        logoLabel.setSize(50, 45);
        container.add(logoLabel, BorderLayout.CENTER);
        container.setBorder(new EmptyBorder(10, 0, 10, 0));
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createSpinner() {
        JPanel container = new JPanel();
        spinner = new Spinner();
        container.add(spinner, BorderLayout.CENTER);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void startLoading() {
        spinner.show();
        loginButton.setEnabled(false);
        errorMessageLabel.setText("");
        errorMessageLabel.setVisible(false);
    }

    public void endLoading() {
        spinner.hide();
        loginButton.setEnabled(true);
    }

    public void createErrorMessageLabel() {
        JPanel container = new JPanel();
        errorMessageLabel = new JLabel();
        errorMessageLabel.setForeground(Color.RED);
        errorMessageLabel.setHorizontalAlignment(SwingConstants.LEFT);
        errorMessageLabel.setSize(PAGE_WIDTH, 40);
        errorMessageLabel.setVisible(false);
        container.add(errorMessageLabel); // Add the error message label under the logo
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createEmailInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        emailTextField = new JTextField();
        emailTextField.setSize(PAGE_WIDTH, 40);
        emailTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                onEmailTextChangedListener.accept(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        emailTextField.addActionListener(e -> onLoginPressedListener.actionPerformed(e));
        JLabel emailLabel = new JLabel("Email address");
        container.add(emailLabel, BorderLayout.WEST);
        container.add(emailTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createPasswordInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        passwordTextField = new JPasswordField();
        passwordTextField.setSize(PAGE_WIDTH, 40);
        passwordTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                onPasswordTextChangedListener.accept(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        passwordTextField.addActionListener(e -> onLoginPressedListener.actionPerformed(e));
        JLabel passwordLabel = new JLabel("Password");
        container.add(passwordLabel);
        container.add(passwordTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createCreateAccountLink() {
        JPanel container = new JPanel();
        JLabel createAccountLabel = new JLabel("Don't have an account? Sign up.");
        createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        createAccountLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                LinkBrowser.browse("https://flippingcopilot.com/signup");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.BRAND_ORANGE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            }
        });
        container.add(createAccountLabel);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createLoginButton() {
        JPanel container = new JPanel();
        loginButton = new JButton("Login");
        loginButton.addActionListener(this.onLoginPressedListener);
        container.add(loginButton);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void showLoginErrorMessage(String message) {
        errorMessageLabel.setText("<html><p>" + message + "</p></html>");
        errorMessageLabel.setVisible(true);
    }
}

package com.flippingcopilot.util;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class GeTaxTest {

    @Test
    public void postTaxPriceForExemptItemReturnsOriginalPrice() {
        int itemId = 13190;
        int price = 1000;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceNormalItem() {
        int itemId = 9999;
        int price = 1000;
        assertEquals(990, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceAboveCap() {
        int itemId = 9999;
        int price = 600000000;
        assertEquals(595000000, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceCheapItem() {
        int itemId = 13190;
        int price = 67;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }
}
package com.flippingcopilot.controller;

import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;
import org.junit.Test;

import java.util.ArrayList;

public class OfferEventFilterTest {

    @Test
    public void testShouldProcessOnLogin() {
        OfferEventFilter filter = new OfferEventFilter();

        ArrayList<GrandExchangeOfferChanged> events = new ArrayList<>();
        ArrayList<Boolean> expectedReturnValues = new ArrayList<>();

        events.add(mockOfferEvent(0, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(1, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(3, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(4, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(6, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);

        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(true);

        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);

        for (int i = 0; i < events.size(); i++) {
            assert filter.shouldProcess(events.get(i)) == expectedReturnValues.get(i);
        }
    }

    @Test
    public void testShouldProcessNewBuyOffer() {
        OfferEventFilter filter = new OfferEventFilter();
        GrandExchangeOfferChanged event1 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
        assert filter.shouldProcess(event1);
        GrandExchangeOfferChanged event2 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
        assert !filter.shouldProcess(event2);
    }

    @Test
    public void testLogoutLogin() {
        OfferEventFilter filter = new OfferEventFilter();
        GrandExchangeOfferChanged event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
        assert filter.shouldProcess(event);

        filter.setExpectEmptyOffers();

        for (int i = 0; i < 8; i++) {
            event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
            assert !filter.shouldProcess(event);
        }

        for (int i = 0; i < 8; i++) {
            if (i == 2) {
                event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
                assert !filter.shouldProcess(event);
            } else {
                event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
                assert filter.shouldProcess(event);
            }
        }

        event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
        assert !filter.shouldProcess(event);
    }

    static GrandExchangeOfferChanged mockOfferEvent(int slot, int itemId, int quantitySold, int totalQuantity,
                                                    int price, int spent, GrandExchangeOfferState state) {
        GrandExchangeOfferChanged event = new GrandExchangeOfferChanged();
        event.setSlot(slot);
        event.setOffer(new GrandExchangeOffer() {
            @Override
            public int getQuantitySold() {
                return quantitySold;
            }

            @Override
            public int getItemId() {
                return itemId;
            }

            @Override
            public int getTotalQuantity() {
                return totalQuantity;
            }

            @Override
            public int getPrice() {
                return price;
            }

            @Override
            public int getSpent() {
                return spent;
            }

            @Override
            public GrandExchangeOfferState getState() {
                return state;
            }
        });
        return event;
    }


}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.FlipV2;
import com.flippingcopilot.model.Stats;
import org.junit.Assert;
import org.junit.Test;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlipManagerTest {

    private static final String DISPLAY_NAME_1 = "Acc 1";
    private static final String DISPLAY_NAME_2 = "Acc 2";
    private static final String DISPLAY_NAME_3 = "Acc 3";
    private final Map<String, Integer> displayNameToAccountId = Map.of(DISPLAY_NAME_1, 0, DISPLAY_NAME_2, 1, DISPLAY_NAME_3, 2);

    @Test
    public void testOneAccount() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 10_000, List.of(0));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null, new DoesNothingExecutorService(), () -> {});
        flipManager.displayNameToAccountId.putAll(displayNameToAccountId);
        flipManager.mergeFlips(flips, null);
        flipManager.setIntervalDisplayName(DISPLAY_NAME_1);


        verifyflipManagerStoredOrder(flipManager);

        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(FlipV2::getId));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        for (int time : testTimes) {
            flipManager.setIntervalStartTime(time);

            // check stats equal
            Stats stats1 = flipManager.getIntervalStats();
            Stats stats2 = expectedStats(flips, time, DISPLAY_NAME_1);
            Assert.assertEquals(stats1, stats2);

            // check all flips equal
            List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
            List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), DISPLAY_NAME_1);
            assertFlipListsEqual(allFlips1, allFlips2);

            // check paginated flips equal
            for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                int numPages = stats1.flipsMade / pageSize + 1;
                for(int page=1; page <= numPages; page++) {
                    List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, DISPLAY_NAME_1);
                    List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                    assertFlipListsEqual(pageFlips1, pageFlips2);
                }
            }
        }
    }

    @Test
    public void testMultipleAccounts() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 5_000, List.of(0, 1, 2));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null, new DoesNothingExecutorService(), () -> {});
        flipManager.displayNameToAccountId.putAll(displayNameToAccountId);
        flipManager.mergeFlips(flips, null);
        verifyflipManagerStoredOrder(flipManager);


        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(Comparator.comparing(FlipV2::getId).reversed()));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        flipManager.setIntervalDisplayName(null);
        List<FlipV2> flips1 = flipManager.getPageFlips(1, flips.size());
        assertFlipListsEqual(flips1, flips);

        for (String name : Arrays.asList(DISPLAY_NAME_1, DISPLAY_NAME_2, DISPLAY_NAME_3, null)) {
            flipManager.setIntervalDisplayName(name);
            for (int time : testTimes) {
                flipManager.setIntervalStartTime(time);

                // check stats equal
                Stats stats1 = flipManager.getIntervalStats();
                Stats stats2 = expectedStats(flips, time, name);
                Assert.assertEquals(stats1, stats2);

                // check all flips equal
                List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
                List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), name);
                assertFlipListsEqual(allFlips1, allFlips2);

                // check paginated flips equal
                for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                    int numPages = stats1.flipsMade / pageSize + 1;
                    for (int page = 1; page <= numPages; page++) {
                        List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                        List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, name);
                        assertFlipListsEqual(pageFlips1, pageFlips2);
                    }
                }
            }
        }
    }

    public void verifyflipManagerStoredOrder(FlipManager flipManager) {
        for (int i =0; i < flipManager.weeks.size(); i++) {
            Assert.assertTrue(flipManager.weeks.get(Math.max(i-1,0)).weekStart <= flipManager.weeks.get(i).weekStart);
            FlipManager.WeekAggregate w = flipManager.weeks.get(i);
            for (List<FlipV2> flips : w.accountIdToFlips.values()) {
                for (int ii =1; ii < flips.size(); ii++) {
                    Assert.assertTrue(flips.get(ii-1).getClosedTime() <= flips.get(ii).getClosedTime());
                }
            }
        }
    }

    private List<FlipV2> expectedPage(List<FlipV2> flips, int time, int pageNumber, int pageSize, String displayName) {
        Integer accountId = displayName == null ? null : displayNameToAccountId.getOrDefault(displayName, -1);
        int toSkip = (pageNumber - 1) * pageSize;
        List<FlipV2> page = new ArrayList<>();
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                if(toSkip > 0) {
                    toSkip -= 1;
                } else {
                    page.add(f);
                    if(page.size() == pageSize) {
                        break;
                    }
                }
            }
        }
        return page;
    }

    private void assertFlipListsEqual(List<FlipV2> f1, List<FlipV2> f2) {
        if(f1.size() != f2.size()) {
            Assert.fail("flips lists not equal length");
        }
        for (int i=0; i < f1.size(); i++) {
            FlipV2 flip1 = f1.get(i);
            FlipV2 flip2 = f2.get(i);
            if (!flip1.equals(flip2)) {
                Assert.fail("flips don't match at index " + i);
            }
        }
    }

    private Stats expectedStats(List<FlipV2> flips, int time, String displayName) {
        Integer accountId = displayName == null ? null : displayNameToAccountId.getOrDefault(displayName, -1);
        Stats stats = new Stats(0,0,0,0);
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                stats.flipsMade += 1;
                stats.gross += f.getSpent();
                stats.profit += f.getProfit();
            }
        }
        return stats;
    }

    private List<FlipV2> generateFlipsBetween(int start, int end, int number, List<Integer> accountIds) {
        List<FlipV2> flips = new ArrayList<>();
        for (int i =0; i< number; i++) {
            FlipV2 f = new FlipV2();
            f.setId(UUID.randomUUID());
            f.setAccountId(accountIds.get(new Random().nextInt(accountIds.size())));
            // leave a small percentage as open flips
            if(randomIntBetween(0, 1000) > 2) {
                f.setClosedTime(randomIntBetween(start, end));
                f.setSpent(randomIntBetween(100, 1_000_000_000));
                f.setProfit(randomIntBetween(-2_000_000, 4_000_000));
                flips.add(f);
            }
        }
        return flips;
    }

    private int randomIntBetween(int min, int max) {
        return (int)(Math.random() * ((max - min) + 1)) + min;
    }
}
package com.flippingcopilot.controller;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;


public class DoesNothingExecutorService implements ScheduledExecutorService {
    @Override
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public void shutdown() {

    }

    @Override
    public List<Runnable> shutdownNow() {
        return List.of();
    }

    @Override
    public boolean isShutdown() {
        return false;
    }

    @Override
    public boolean isTerminated() {
        return false;
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return false;
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return null;
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return null;
    }

    @Override
    public Future<?> submit(Runnable task) {
        return null;
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return null;
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return null;
    }

    @Override
    public void execute(Runnable command) {

    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import org.junit.Test;

public class TestSuggestionHandler {

    @Test
    public void testShouldNotifyOnWait() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 1, "");
        assert !SuggestionHandler.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnNewBuy() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "");
        assert SuggestionHandler.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnRepeatedBuy() {
        Suggestion oldSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 0, "");;
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "");
        assert !SuggestionHandler.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnAbort() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("abort", 0, 560, 200, 25000, "Death rune", 1, "");
        assert SuggestionHandler.shouldNotify(newSuggestion, oldSuggestion);
    }
}

package com.flippingcopilot.model;

import org.junit.Test;


public class OfferListTest {
    @Test
    public void testIsEmptySlotNeededWithExistingOfferInSlot() {
        OfferList offerList = new OfferList();
        offerList.set(0, new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "");
        assert !offerList.isEmptySlotNeeded(suggestion);
    }

    @Test
    public void testIsEmptySlotNeededWithNoEmptySlots() {
        OfferList offerList = new OfferList();
        offerList.replaceAll(ignored -> new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "");
        assert offerList.isEmptySlotNeeded(suggestion);
    }

}

package com.flippingcopilot.model;

import org.junit.Test;

public class AccountStatusTest {

    @Test
    public void testMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        assert accountStatus.moreGpNeeded();
    }

    @Test
    public void testNoMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        accountStatus.getInventory().add(new RSItem(995, 2000));
        assert !accountStatus.moreGpNeeded();
    }
}

package com.flippingcopilot.model;

import org.junit.Test;

import java.time.Instant;

public class OfferTest {

    @Test
    public void testTransactionFromNewOffer() {
        Offer oldOffer = Offer.getEmptyOffer(0);
        Offer newOffer = new Offer(OfferStatus.BUY, 560, 100, 50, 1000,
                10, 10, 0, 0, true, false);
        Transaction expectedTransaction = new Transaction(null, OfferStatus.BUY, 560, 100, 10, 0, 1000, null,false);
        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
        assert expectedTransaction.equals(actualTransaction);
    }

    @Test
    public void testTransactionFromProgressingSell() {
        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
                10, 0, 1000, 0, true, false);
        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 4000,
                40, 0, 4000, 0, true, false);
        Transaction expectedTransaction = new Transaction(null, OfferStatus.SELL, 560, 100, 30, 0, 3000, null,false);
        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
        assert expectedTransaction.equals(actualTransaction);
    }

    @Test
    public void testNoTransaction() {
        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
                10, 0, 1000, 0, true, false);
        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
                10, 0, 1000, 0, true, false);
        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
        assert actualTransaction == null;
    }
}

package com.flippingcopilot.ui;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class UIUtilitiesTest {

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsGreaterThanStringLength() {
        String result = UIUtilities.truncateString("Hello", 10);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsLessThanStringLength() {
        String result = UIUtilities.truncateString("Hello, World!", 5);
        assertEquals("Hello...", result);
    }

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsEqualToStringLength() {
        String result = UIUtilities.truncateString("Hello", 5);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsEmptyString_whenInputStringIsEmpty() {
        String result = UIUtilities.truncateString("", 5);
        assertEquals("", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsZero() {
        String result = UIUtilities.truncateString("Hello, World!", 0);
        assertEquals("...", result);
    }
}
package com.flippingcopilot;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FlippingCopilotPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlippingCopilotPlugin.class);
		RuneLite.main(args);
	}
}
