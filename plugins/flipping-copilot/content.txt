package com.flippingcopilot.util;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.List;

public class MsgPackUtil {

    private static final int EXT_INT32 = 41;

    public static Object decodePrimitive(ByteBuffer b) {
        int format = b.get() & 0xFF;
        int length;

        // Boolean cases
        if (format == 0xC2) {
            // false
            return false;
        } else if (format == 0xC3) {
            // true
            return true;
        }
        // Null case
        else if (format == 0xC0) {
            // nil (null)
            return null;
        }
        // String cases
        else if ((format & 0xE0) == 0xA0) {
            // fixstr: format stores length in lower 5 bits
            length = format & 0x1F;
            return getString(length, new byte[length], b);
        } else if (format == 0xD9) {
            // str 8: next byte is length
            length = b.get() & 0xFF;
            return getString(length, new byte[length], b);
        } else if (format == 0xDA) {
            // str 16: next 2 bytes are length
            length = b.getShort() & 0xFFFF;
            return getString(length, new byte[length], b);
        } else if (format == 0xDB) {
            // str 32: next 4 bytes are length
            length = b.getInt();
            return getString(length, new byte[length], b);
        }
        // Integer cases
        else if (format <= 0x7F) {
            // positive fixint
            return (long) format;
        } else if ((format & 0xE0) == 0xE0) {
            // negative fixint (0xE0-0xFF represents -32 to -1)
            return (long) (format - 256);
        } else if (format == 0xCC) {
            // uint 8
            return (long) (b.get() & 0xFF);
        } else if (format == 0xCD) {
            // uint 16
            return (long) (b.getShort() & 0xFFFF);
        } else if (format == 0xCE) {
            // uint 32
            return (long) (b.getInt() & 0xFFFFFFFFL);
        } else if (format == 0xCF) {
            // uint 64
            return b.getLong();
        } else if (format == 0xD0) {
            // int 8
            return (long) b.get();
        } else if (format == 0xD1) {
            // int 16
            return (long) b.getShort();
        } else if (format == 0xD2) {
            // int 32
            return (long) b.getInt();
        } else if (format == 0xD3) {
            // int 64
            return b.getLong();
        }
        // Double case
        else if (format == 0xCB) {
            // float 64
            return b.getDouble();
        } else {
            throw new IllegalArgumentException("Invalid primitive format: " + format);
        }
    }

    private static String getString(int length, byte[] length1, ByteBuffer b) {
        if (length == 0) {
            return "";
        }
        byte[] bytes = length1;
        b.get(bytes);
        return new String(bytes, StandardCharsets.UTF_8);
    }

    public static int[] decodeInt32Array(ByteBuffer b) {
        int format = b.get() & 0xFF;

        if (format == 0xC0) {
            // nil (null)
            return null;
        } else if (format == 0xC9) {
            // ext 32 - extension with 32-bit length
            int byteLength = b.getInt();
            int extType = b.get() & 0xFF;
            if (extType != EXT_INT32) {
                throw new IllegalArgumentException("Expected extension type " + EXT_INT32 + ", got: " + extType);
            }
            int arrayLength = byteLength / 4;
            int[] result = new int[arrayLength];
            for (int i = 0; i < arrayLength; i++) {
                result[i] = (b.get() & 0xff) | ((b.get() & 0xff) << 8) |
                        ((b.get() & 0xff) << 16) | ((b.get() & 0xff) << 24);
            }
            return result;
        } else {
            throw new IllegalArgumentException("Expected extension format 0xC9 or nil 0xC0, got: " + format);
        }
    }

    public static Integer decodeMapSize(ByteBuffer b) {
        int format = b.get() & 0xFF;
        if (format == 0xC0) {
            // nil (null) - return null Data object
            return null;
        } else if ((format & 0xF0) == 0x80) {
            // fixmap: format stores size in lower 4 bits
            return format & 0x0F;
        } else if (format == 0xDE) {
            // map 16: next 2 bytes are size
            return b.getShort() & 0xFFFF;
        } else if (format == 0xDF) {
            // map 32: next 4 bytes are size (you were missing this case!)
            return b.getInt();
        } else {
            throw new IllegalArgumentException("Invalid map format: " + format);
        }
    }
}
package com.flippingcopilot.util;

import java.util.Arrays;
import java.util.HashSet;

public class GeTax {
    private final static int MAX_PRICE_FOR_GE_TAX = 250000000;
    private final static int GE_TAX_CAP = 5000000;
    private final static double GE_TAX = 0.02;
    private final static HashSet<Integer> GE_TAX_EXEMPT_ITEMS = new HashSet<>(
            Arrays.asList(8011, 365, 2309, 882, 806, 1891, 8010, 1755, 28824, 2140, 2142, 8009, 5325, 1785, 2347, 347,
                    884, 807, 28790, 379, 8008, 355, 2327, 558, 1733, 13190, 233, 351, 5341, 2552, 329, 8794, 5329,
                    5343, 1735, 315, 952, 886, 808, 8013, 361, 8007, 5331));

    public static int getPostTaxPrice(int itemId, int price) {
        if (GE_TAX_EXEMPT_ITEMS.contains(itemId)) {
            return price;
        }
        if (price >= MAX_PRICE_FOR_GE_TAX) {
            return price - GE_TAX_CAP;
        }
        int tax = (int)Math.floor(price * GE_TAX);
        return price - tax;
    }
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

public class AtomicReferenceUtils {
    public static <T> OrElse ifPresent(AtomicReference<T> ref, Consumer<? super T> action) {
        T value = ref.get();
        if (value != null) {
            action.accept(value);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    public static <T, E> OrElse ifBothPresent(AtomicReference<T> ref1, AtomicReference<E> ref2, BiConsumer<? super T,? super E> action) {
        T value1 = ref1.get();
        E value2 = ref2.get();
        if (value1 != null && value2 != null) {
            action.accept(value1, value2);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    @AllArgsConstructor
    public static class OrElse {

        boolean shouldRun;

        public void orElse(Runnable r) {
            if(shouldRun) {
                r.run();
            }
        }
    }
}
package com.flippingcopilot.util;

import java.util.UUID;

public class Constants {
    public final static int MIN_GP_NEEDED_TO_FLIP = 1000;
    public final static int PLATINUM_TOKEN_VALUE = 1000;

    public static UUID MAX_UUID = new UUID(-1L, -1L);
    public static UUID MIN_UUID = new UUID(0L, 0L);
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class MutableReference<T> {
    private T value;
}

package com.flippingcopilot.util;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;

public class DateUtil {

    public static String formatEpoch(long epochSeconds) {
        Instant instant = Instant.ofEpochSecond(epochSeconds);
        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)
                .withZone(ZoneId.systemDefault());
        return formatter.format(instant);
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.model.Transaction;
import com.flippingcopilot.model.TransactionManager;
import com.flippingcopilot.ui.GeAddTransactionsDialogPanel;
import com.flippingcopilot.ui.GeHistoryTransactionButton;
import com.google.common.collect.Lists;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Extracts data from the widgets in the trade history tab so that the TradeHistoryTabPanel can display them. I wanted
 * the TradeHistoryTabPanel, and all UI components, to pretty much only draw stuff and not do much else, hence the separation.
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GeHistoryTabController {

    private static Pattern MULTI_ITEM_PATTERN = Pattern.compile(">= (.*) each");
    private static Pattern SINGLE_ITEM_PATTERN = Pattern.compile(">(.*) coin");
    private static Pattern ORIGINAL_PRICE_PATTERN = Pattern.compile("\\((.*) -");

    // dependencies
    private final GeHistoryTransactionButton geHistoryTransactionButton;
    private final Client client;
    private final ApiRequestHandler apiRequestHandler;
    private final ItemController itemController;
    private final OsrsLoginManager osrsLoginManager;
    private final TransactionManager transactionManager;

    // dialog
    private JDialog dialog;

    public void onGeHistoryTabClosed() {
        SwingUtilities.invokeLater(() -> {
            geHistoryTransactionButton.setVisible(false);
            if (dialog != null) {
                dialog.dispose();
            }
        });
    }

    public void onGeHistoryTabOpened() {
        geHistoryTransactionButton.addActionListener(e -> {
            Widget w = client.getWidget(383, 3);
            if( w != null) {
                Widget[] widgets = w.getDynamicChildren();
                List<List<Widget>> groupsOfWidgets = Lists.partition(Arrays.asList(widgets), 6);
                List<Transaction> historyTransactions = groupsOfWidgets.stream().map(this::createTransaction).collect(Collectors.toList());
                historyTransactions.forEach(tx -> log.debug("ge history transaction: {}", tx));
                openAddTransactionsDialog(historyTransactions);
            }
        });
        geHistoryTransactionButton.setVisible(true);
    }

    private void openAddTransactionsDialog(List<Transaction> geTransactions) {
        SwingUtilities.invokeLater(() -> {
            // Get the parent frame
            if(dialog != null) {
                dialog.dispose();
            }
            dialog = new JDialog();
            dialog.setTitle("Add GE History Transactions");
            dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
            dialog.setModal(false);

            // Create the panel
            GeAddTransactionsDialogPanel panel = new GeAddTransactionsDialogPanel(
                    apiRequestHandler,
                    itemController,
                    osrsLoginManager.getPlayerDisplayName(),
                    transactionManager,
                    dialog::dispose,
                    geTransactions
            );

            dialog.setContentPane(panel);
            dialog.pack();
            dialog.setVisible(true);
        });
    }

    public Transaction createTransaction(List<Widget> widgets) {
        GrandExchangeOfferState offerState = getState(widgets.get(2));
        int quantity = widgets.get(4).getItemQuantity();
        int itemId = widgets.get(4).getItemId();
        int price = getPrice(widgets.get(5), quantity);
        boolean isBuy = offerState == GrandExchangeOfferState.BOUGHT;

        Transaction t = new Transaction();
        t.setId(UUID.randomUUID());
        t.setType(isBuy ? OfferStatus.BUY : OfferStatus.SELL);
        t.setItemId(itemId);
        t.setPrice(price);
        t.setQuantity(quantity);
        t.setBoxId(0);
        t.setAmountSpent(price * quantity);
        t.setTimestamp(Instant.now());
        t.setCopilotPriceUsed(true);
        t.setWasCopilotSuggestion(true);
        t.setOfferTotalQuantity(quantity);
        return t;
    }


    /**
     * Gets original price of each item (price before ge tax) from the ge history. We want
     * to get the price before ge tax bc the the price after ge tax is always calculated by the
     * OfferEvent class wherever we need to display it. That means that if we get the price after tax
     * here and then construct an OfferEvent with that price, and then try to display the OfferEvent's price
     * using OfferEvent.getPrice(), we will effectively be applying the ge tax twice.
     * @return the original price of each item in the offer
     */
    private static int getPrice(Widget w, int quantity) {
        String text = w.getText();
        String numString = text;
        Matcher m;
        boolean isTotalPrice = false;
        // This will trigger anytime there is the ge tax text on an offer in the history
        // For example when you have that text with the format "({original price} - {ge_tax})
        // Whenever that text is present, we want to get the original price (NOT THE PRICE
        // AFTER THE TAX). However, since the original price displayed is not the price of each item
        //we have to divide it by the quantity to get the original price of each item.
        if (text.contains(")</col>")) {
            m = ORIGINAL_PRICE_PATTERN.matcher(text);
            isTotalPrice = true;
        }
        //if the case above doesn't trigger that means there is no tax on the item, so we check if "each"
        //is present which allows us to use the regex for getting the price of each item when multiple
        //have been traded.
        else if (text.contains("each")) {
            m = MULTI_ITEM_PATTERN.matcher(text);
        }
        //if this case triggers than it is an offer for a single item that is untaxed
        else {
            m = SINGLE_ITEM_PATTERN.matcher(text);
        }
        m.find();
        numString = m.group(1);
        StringBuilder s = new StringBuilder();
        for (char c : numString.toCharArray()) {
            if (Character.isDigit(c)) {
                s.append(c);
            }
        }

        int price = Integer.parseInt(s.toString());
        if (isTotalPrice) {
            return price/quantity;
        }
        return price;
    }

    private static GrandExchangeOfferState getState(Widget w) {
        String text = w.getText();
        if (text.startsWith("Bought")) {
            return GrandExchangeOfferState.BOUGHT;
        } else {
            return GrandExchangeOfferState.SOLD;
        }
    }
}

package com.flippingcopilot.controller;

import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class HighlightColorController {

    /*
    For the highlighted colors we oscillate the actual colors through different shades
     */

    // Color ranges for red highlight (R,G,B values)
    private static final int[] RED_START = {205, 0, 50};
    private static final int[] RED_END = {255, 50, 0};

    // Color ranges for blue highlight (R,G,B values)
    private static final int[] BLUE_START = {5, 153, 255};
    private static final int[] BLUE_END = {55, 205, 205};

    // Constants for controlling the drift
    private static final long CYCLE_DURATION = 600000; // 10 minutes for one complete cycle
    private static final int ALPHA = 79;

    public Color getRedColor() {
        double phase = calculatePhase();
        return interpolateColor(RED_START, RED_END, phase, ALPHA);
    }

    public Color getBlueColor() {
        double phase = calculatePhase();
        return interpolateColor(BLUE_START, BLUE_END, phase, ALPHA);
    }

    private double calculatePhase() {
        // Current time modulo cycle duration gives us position in the cycle
        long currentTime = System.currentTimeMillis();
        double cyclePosition = (currentTime % CYCLE_DURATION) / (double) CYCLE_DURATION;

        // Use absolute sine wave to create smooth back-and-forth oscillation
        return Math.abs(Math.sin(cyclePosition * Math.PI));
    }

    private Color interpolateColor(int[] start, int[] end, double phase, int alpha) {
        int red = interpolateComponent(start[0], end[0], phase);
        int green = interpolateComponent(start[1], end[1], phase);
        int blue = interpolateComponent(start[2], end[2], phase);

        return new Color(red, green, blue, alpha);
    }

    private int interpolateComponent(int start, int end, double phase) {
        return (int) Math.round(start + (end - start) * phase);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.Transaction;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

@Slf4j
public class Persistance {
    public static Gson gson;
    public static final File PARENT_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "flipping-copilot");
    public static final String UN_ACKED_TRANSACTIONS_FILE_TEMPLATE = "%s_un_acked.jsonl";
    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";
    public static File directory;

    public static void setUp(String directoryPath) throws IOException {
        directory = new File(directoryPath);
        createDirectory(directory);
        createRequiredFiles();
    }

    public static void setUp(Gson gson) throws IOException {
        Persistance.gson = gson;
        directory = PARENT_DIRECTORY;
        createDirectory(PARENT_DIRECTORY);
        createRequiredFiles();
    }

    private static void createRequiredFiles() throws IOException {
        generateFileIfDoesNotExist(LOGIN_RESPONSE_JSON_FILE);
    }

    private static void generateFileIfDoesNotExist(String filename) throws IOException {
        File file = new File(directory, filename);
        if (!file.exists()) {
            if (!file.createNewFile()) {
                log.info("Failed to generate file {}", file.getPath());
            }
        }
    }

    private static void createDirectory(File directory) throws IOException {
        if (!directory.exists()) {
            if (!directory.mkdir()) {
                throw new IOException("unable to create parent directory!");
            }
        }
    }


    public static List<Transaction> loadUnAckedTransactions(String displayName) {
        List<Transaction> transactions = new ArrayList<>();
        File file = new File(PARENT_DIRECTORY, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        if (!file.exists()) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        }
        Set<UUID> added = new HashSet<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }
                try {
                    Transaction transaction = gson.fromJson(line, Transaction.class);
                    // there was previously a bug where the same transaction was being added many times to the list
                    // just clean things here to be safe
                    if (!added.contains(transaction.getId())) {
                        transactions.add(transaction);
                        added.add(transaction.getId());
                    }
                } catch (JsonSyntaxException e) {
                    log.warn("error deserializing transaction line '{}' file {}", line, file, e);
                }
            }
        } catch (FileNotFoundException e) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        } catch (IOException e) {
            log.warn("error loading un acked transaction file {}", file, e);
            return new ArrayList<>();
        } catch (JsonSyntaxException e) {
            log.warn("corrupted un acked transaction file {}", file, e);
            return new ArrayList<>();
        }
        log.info("loaded {} stored transactions for {}", transactions.size(), displayName);
        return transactions;
    }

    public static void storeUnAckedTransactions(List<Transaction> transactions, String displayName) {
        File unackedTransactionsFile = new File(PARENT_DIRECTORY, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        try (BufferedWriter w = new BufferedWriter(new FileWriter(unackedTransactionsFile, false))) {
            for (Transaction transaction : transactions) {
                String json = gson.toJson(transaction);
                w.write(json);
                w.newLine();
            }
        } catch (IOException e) {
            log.warn("error storing un acked transactions to file {}", unackedTransactionsFile, e);
        }
    }

    public static String hashDisplayName(String displayName) {
        if(displayName == null) {
            return "null";
        }
        // we hash the display name just to ensure that it's a valid file name
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            byte[] hashBytes = digest.digest(displayName.getBytes(StandardCharsets.UTF_8));
            StringBuilder hexString = new StringBuilder();
            for (byte b : hashBytes) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.UIUtilities;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;

import java.awt.*;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.flippingcopilot.model.OfferStatus.SELL;
import static com.flippingcopilot.util.GeTax.getPostTaxPrice;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class TooltipController {
    private static final int SCRIPT_TOOLTIP_GE = 526;

    private static final FontMetrics FONT_METRICS = Toolkit.getDefaultToolkit().getFontMetrics(FontManager.getRunescapeFont());
    private static final int WIDTH_PADDING = 4;

    private final Client client;
    private final OfferManager offerManager;
    private final FlipManager flipManager;
    private final OsrsLoginManager osrsLoginManager;
    private final CopilotLoginManager copilotLoginManager;

    public void tooltip(ScriptPostFired e) {
        if(e.getScriptId() != SCRIPT_TOOLTIP_GE) {
            return;
        }

        Widget tooltip = client.getWidget(InterfaceID.GeOffers.TOOLTIP);

        if(tooltip == null || tooltip.isHidden()) {
            return;
        }

        Widget background = tooltip.getChild(0);
        Widget border = tooltip.getChild(1);
        Widget text = tooltip.getChild(2);

        if (text != null && background != null && border != null) {
            if (text.getText().contains("Profit:")) {
                // If the tooltip already contains profit information, we don't need to process it again
                return;
            }

            if(!isItemSelling(text.getText())) {
                return;
            }

            String name = getItemNameFromTooltipText(text.getText());

            if(name != null) {
                long profit = getProfitFromItemName(name);
                text.setText(text.getText()  + "<br>Profit: " + UIUtilities.quantityToRSDecimalStack(profit, false) + " gp");

                tooltip.setOriginalHeight(45);
                text.setOriginalHeight(45);

                int width = calculateTooltipWidth(text.getText());
                tooltip.setOriginalWidth(width);
                text.setOriginalWidth(width);

                tooltip.revalidate();
                border.revalidate();
                background.revalidate();
            }
        }
    }

    public boolean isItemSelling(String text) {
        text = text.replaceAll("<br>", " ").trim();
        Pattern pattern = Pattern.compile("^(Buying|Selling): (.+) (\\d{1,3}(?:,\\d{3})*|\\d+) / (\\d{1,3}(?:,\\d{3})*|\\d+)( Profit: -?[\\d,]+ gp?)?$");
        Matcher matcher = pattern.matcher(text);

        if (matcher.find()) {
            String action = matcher.group(1);
            return action.equals("Selling");
        } else {
            return false; // or handle as you wish
        }
    }

    public long getProfitFromItemName(String itemName) {
        String displayName = osrsLoginManager.getPlayerDisplayName();

        for(int i = 0; i < 8; i++) {
            long accountHash = client.getAccountHash();
            SavedOffer offer = offerManager.loadOffer(accountHash, i);

            if(offer.getOfferStatus().equals(SELL)) {
                Integer accountId = copilotLoginManager.getAccountId(displayName);
                if(accountId != null && accountId != -1) {
                    FlipV2 flip = flipManager.getLastFlipByItemId(accountId, offer.getItemId());

                    if (flip == null || FlipStatus.FINISHED.equals(flip.getStatus())) {
                        continue;
                    }

                    if(flip.getCachedItemName().equals(itemName)) {
                        return ((long) getPostTaxPrice(offer.getItemId(), offer.getPrice()) * offer.getTotalQuantity()) - (flip.getAvgBuyPrice() * offer.getTotalQuantity());
                    }
                }
            }
        }

        return 0;
    }

    public String getItemNameFromTooltipText(String text) {
        text = text.replaceAll("<br>", " ").trim();
        Pattern pattern = Pattern.compile("^(Buying|Selling): (.+) (\\d{1,3}(?:,\\d{3})*|\\d+) / (\\d{1,3}(?:,\\d{3})*|\\d+)( Profit: -?[\\d,]+ gp?)?$");
        Matcher matcher = pattern.matcher(text);

        if (matcher.find()) {
            return matcher.group(2);
        } else {
            return null; // or handle as you wish
        }
    }

    private int calculateTooltipWidth(String text)
    {
        final String[] lines = text.split("<br>");
        int maxWidth = 0;
        for (String line : lines) {
            String left = "";
            left = line;

            int width = FONT_METRICS.stringWidth(left);
            if (width > maxWidth) {
                maxWidth = width;
            }
        }
        return maxWidth + WIDTH_PADDING;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
@Getter
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OfferHandler {

    private static final int GE_OFFER_INIT_STATE_CHILD_ID = 20;

    // dependencies
    private final Client client;
    private final ClientThread clientThread;
    private final SuggestionManager suggestionManager;
    private final ApiRequestHandler apiRequestHandler;
    private final OsrsLoginManager osrsLoginManager;
    private final OfferManager offerManager;
    private final HighlightController highlightController;
    private final CopilotLoginManager copilotLoginManager;

    // state
    private String viewedSlotPriceErrorText = null;

    public void fetchSlotItemPrice(boolean isViewingSlot, Supplier<OfferEditor> offerEditorSupplier) {
        if (isViewingSlot) {
            var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);
            offerManager.setViewedSlotItemId(currentItemId);
            if (currentItemId == -1 || currentItemId == 0) return;

            var suggestion = suggestionManager.getSuggestion();
            if (suggestion != null && suggestion.getItemId() == currentItemId &&
                    ((Objects.equals(suggestion.getType(), "sell") && isSelling()) ||
                            Objects.equals(suggestion.getType(), "buy") && isBuying())) {
                offerManager.setLastViewedSlotItemId(suggestion.getItemId());
                offerManager.setLastViewedSlotItemPrice(suggestion.getPrice());
                offerManager.setLastViewedSlotItemPrice((int) Instant.now().getEpochSecond());
                return;
            }

            if (!copilotLoginManager.isLoggedIn()) {
                viewedSlotPriceErrorText = "Login to copilot to see item price.";
                return;
            }
            viewedSlotPriceErrorText = "Loading copilot item price..";
            Consumer<ItemPrice> itemPriceConsumer = (fetchedPrice) -> {
                clientThread.invoke(() -> {
                    if (fetchedPrice == null) {
                        viewedSlotPriceErrorText = "Unknown error";
                        return;
                    }

                    if (fetchedPrice.getMessage() != null && !fetchedPrice.getMessage().isEmpty()) {
                        viewedSlotPriceErrorText = fetchedPrice.getMessage();
                    } else {
                        viewedSlotPriceErrorText = null;
                    }
                    offerManager.setViewedSlotItemPrice(isSelling() ? fetchedPrice.getSellPrice() : fetchedPrice.getBuyPrice());
                    offerManager.setLastViewedSlotItemId(offerManager.getViewedSlotItemId());
                    offerManager.setLastViewedSlotItemPrice(offerManager.getViewedSlotItemPrice());
                    offerManager.setLastViewedSlotPriceTime((int) Instant.now().getEpochSecond());

                    highlightController.redraw();
                    log.debug("fetched item {} price: {}", offerManager.getViewedSlotItemId(), offerManager.getViewedSlotItemPrice());

                    // todo: Usage of OfferEditor is messy. It mutates a widget so we need to get the original instance
                    //  of it which is created downstream on some other event handler path. This is why we use a supplier
                    //  but probably it should be an injected class of some kind. We should clean this up in the future
                    //  but for now just need it to work as currently broken.

                    OfferEditor flippingWidget = offerEditorSupplier.get();
                    if (flippingWidget != null) {
                        flippingWidget.showPrice(offerManager.getViewedSlotItemPrice());
                    }
                });
            };


            apiRequestHandler.asyncGetItemPriceWithGraphData(currentItemId, osrsLoginManager.getPlayerDisplayName(), itemPriceConsumer, false);

        } else {
            offerManager.setViewedSlotItemPrice(-1);
            offerManager.setViewedSlotItemId(-1);
            viewedSlotPriceErrorText = null;
        }
        highlightController.redraw();
    }

    public boolean isSettingQuantity() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();
        return chatInputText.equals("How many do you wish to buy?") || chatInputText.equals("How many do you wish to sell?");
    }

    public boolean isSettingPrice() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();

        var offerTextWidget = getOfferTextWidget();
        if (offerTextWidget == null) return false;
        String offerText = offerTextWidget.getText();
        return chatInputText.equals("Set a price for each item:") && (offerText.equals("Buy offer") || offerText.equals("Sell offer"));
    }


    private Widget getChatboxTitleWidget() {
        return client.getWidget(ComponentID.CHATBOX_TITLE);
    }

    private Widget getOfferTextWidget() {
        var offerContainerWidget = client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER);
        if (offerContainerWidget == null) return null;
        return offerContainerWidget.getChild(GE_OFFER_INIT_STATE_CHILD_ID);
    }

    public boolean isSelling() {
        return client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 1;
    }

    public boolean isBuying() {
        return client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 0;
    }

    public String getOfferType() {
        if (isBuying()) {
            return "buy";
        } else if (isSelling()) {
            return "sell";
        } else {
            return null;
        }
    }

    public void setSuggestedAction(Suggestion suggestion) {
        var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);

        if (isSettingQuantity()) {
            if (suggestion == null || currentItemId != suggestion.getItemId()) {
                return;
            }
            setChatboxValue(suggestion.getQuantity());
        } else if (isSettingPrice()) {
            int price = -1;
            if (suggestion == null || currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(getOfferType())) {
                if (offerManager.getViewedSlotItemId() != currentItemId) {
                    return;
                }
                price = offerManager.getViewedSlotItemPrice();
            } else {
                price = suggestion.getPrice();
            }

            if (price == -1) return;

            setChatboxValue(price);
        }
    }

    public void setChatboxValue(int value) {
        var chatboxInputWidget = client.getWidget(ComponentID.CHATBOX_FULL_INPUT);
        if (chatboxInputWidget == null) return;
        chatboxInputWidget.setText(value + "*");
        client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(value));
    }
}

package com.flippingcopilot.controller;

import java.awt.event.ActionEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.LoginPanel;
import com.flippingcopilot.ui.MainPanel;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class CopilotLoginController {

    // dependencies
    @Setter
    private LoginPanel loginPanel;
    @Setter
    private MainPanel mainPanel;
    private final ApiRequestHandler apiRequestHandler;
    private final FlipManager flipManager;
    private final HighlightController highlightController;
    private final CopilotLoginManager copilotLoginManager;
    private final SuggestionManager suggestionManager;
    private final OsrsLoginManager osrsLoginManager;
    private final SessionManager sessionManager;
    private final TransactionManager transactionManager;
    private final ScheduledExecutorService executorService;

    // state
    private String email;
    private String password;

    @Inject
    public CopilotLoginController(ApiRequestHandler apiRequestHandler,
                                  FlipManager flipManager,
                                  HighlightController highlightController,
                                  CopilotLoginManager copilotLoginManager,
                                  SuggestionManager suggestionManager,
                                  OsrsLoginManager osrsLoginManager,
                                  SessionManager sessionManager,
                                  TransactionManager transactionManager,
                                  ScheduledExecutorService executorService) {
        this.apiRequestHandler = apiRequestHandler;
        this.flipManager = flipManager;
        this.highlightController = highlightController;
        this.copilotLoginManager = copilotLoginManager;
        this.suggestionManager = suggestionManager;
        this.osrsLoginManager = osrsLoginManager;
        this.sessionManager = sessionManager;
        this.transactionManager = transactionManager;
        this.executorService = executorService;
        flipManager.setCopilotUserId(copilotLoginManager.getCopilotUserId());
        executorService.schedule(() ->loadCopilotAccounts(0), 0, TimeUnit.SECONDS);
        executorService.schedule(() -> syncFlips(copilotLoginManager.getCopilotUserId(), new HashMap<>(), 0), 5, TimeUnit.SECONDS);
    }

    private void loadCopilotAccounts(int previousFailures) {
        int userId = copilotLoginManager.getCopilotUserId();
        if(userId == -1) {
            return;
        }
        long s = System.nanoTime();
        Consumer<Map<String, Integer>> onSuccess = (displayNameToAccountId) -> {
            displayNameToAccountId.forEach((key, value) ->
                    copilotLoginManager.addAccountIfMissing(value, key, userId));
            log.info("loading {} copilot accounts succeeded - took {}ms", displayNameToAccountId.size(), (System.nanoTime() - s) / 1000_000);
        };
        Consumer<String> onFailure = (errorMessage) -> {
            if (copilotLoginManager.isLoggedIn()) {
                long backOffSeconds = Math.min(15, (long) Math.exp(previousFailures));
                log.info("failed to load copilot accounts ({}) retrying in {}s", errorMessage, backOffSeconds);
                executorService.schedule(() -> loadCopilotAccounts(previousFailures + 1), backOffSeconds, TimeUnit.SECONDS);
            }
        };
        apiRequestHandler.asyncLoadAccounts(onSuccess, onFailure);
    }

    private void syncFlips(int userId, Map<Integer, Integer> accountIdTime, int previousFailures) {
        // Continuously sync's the delta of new or updated flips from the server with back off on failure
        if(copilotLoginManager.getCopilotUserId() != userId) {
            log.info("user={}, no longer logged in, stopping syncFlips.", userId);
            return;
        }
        Set<Integer> accountIds = copilotLoginManager.accountIds();
        if(accountIds.isEmpty()) {
            long backOffSeconds = Math.min(30, (long) 1+previousFailures);
            log.info("user={}, no accounts loaded - re-scheduling runSyncFlips in {}s", userId, backOffSeconds);
            executorService.schedule(() -> syncFlips(userId, accountIdTime, previousFailures+1), backOffSeconds, TimeUnit.SECONDS);
            return;
        }
        accountIds.forEach(a -> accountIdTime.computeIfAbsent(a, i -> 0));
        long s = System.nanoTime();
        BiConsumer<Integer, FlipsDeltaResult> onSuccess = (Integer copilotUserId, FlipsDeltaResult r) -> {
            if(!flipManager.mergeFlips(r.flips, userId)) {
                log.info("user={}, no longer logged in, stopping syncFlips.", userId);
                return;
            }
            log.debug("user={}, loading {} updated flips - took {}ms", userId, r.flips.size(), (System.nanoTime() - s) / 1000_000);
            accountIds.forEach((a) -> accountIdTime.put(a, r.time));
            executorService.schedule(() -> syncFlips(userId, accountIdTime, 0), 5, TimeUnit.SECONDS);
        };
        Consumer<String> onFailure = (errorMessage) -> {
            long backOffSeconds = Math.min(30, (long) Math.exp(previousFailures));
            log.info("user={}, failed to load updated flips ({}) retrying in {}s", userId, errorMessage, backOffSeconds);
            executorService.schedule(() -> syncFlips(userId, accountIdTime, previousFailures + 1), backOffSeconds, TimeUnit.SECONDS);
        };
        apiRequestHandler.asyncLoadFlips(accountIdTime, onSuccess, onFailure);
    }

    public void onLoginPressed(ActionEvent event) {
        Consumer<LoginResponse> onSuccess = (LoginResponse loginResponse) -> {
            copilotLoginManager.setLoginResponse(loginResponse);
            mainPanel.refresh();
            String displayName = osrsLoginManager.getPlayerDisplayName();
            if(displayName != null) {
                flipManager.setIntervalAccount(null);
                flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                transactionManager.scheduleSyncIn(0, displayName);
            }
            flipManager.setCopilotUserId(loginResponse.getUserId());
            loadCopilotAccounts(0);
            syncFlips(copilotLoginManager.getCopilotUserId(), new HashMap<>(),0);
            loginPanel.endLoading();
        };
        Consumer<String> onFailure = (String errorMessage) -> {
            copilotLoginManager.reset();
            loginPanel.showLoginErrorMessage(errorMessage);
            loginPanel.endLoading();
        };
        if (this.email == null || this.password == null) {
            return;
        }
        loginPanel.startLoading();
        apiRequestHandler.authenticate(this.email, this.password, onSuccess, onFailure);
    }

    public void onLogout() {
        flipManager.reset();
        copilotLoginManager.reset();
        suggestionManager.reset();
        highlightController.removeAll();
        mainPanel.refresh();
    }

    public void onEmailTextChanged(String newEmail) {
        this.email = newEmail;
    }

    public void onPasswordTextChanged(String newPassword) {
        this.password = newPassword;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GePreviousSearch {

    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final HighlightController highlightController;
    private final Client client;


    public void showSuggestedItemInSearch() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion != null && suggestion.getType().equals("buy")) {
            if (grandExchange.isPreviousSearchSet() && grandExchange.showLastSearchEnabled()) {
                setPreviousSearch(suggestion.getItemId(), suggestion.getName());
            } else {
                createPreviousSearchWidget(suggestion.getItemId(), suggestion.getName());
                createPreviousSearchItemNameWidget(suggestion.getName());
                createPreviousSearchItemWidget(suggestion.getItemId());
                createPreviousSearchTextWidget();
            }
            highlightController.redraw();
        }
    }

    private void setPreviousSearch(int itemId, String itemName) {
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget previousSearch = searchResults.getChild(0);
        previousSearch.setOnOpListener(754, itemId, 84);
        previousSearch.setOnKeyListener(754, itemId, -2147483640);
        previousSearch.setName("<col=ff9040>" + itemName + "</col>");
        Widget previousSearchText = searchResults.getChild(1);
        previousSearchText.setText("Copilot item:");
        Widget itemNameWidget = searchResults.getChild(2);
        itemNameWidget.setText(itemName);
        Widget item = searchResults.getChild(3);
        item.setItemId(itemId);
    }

    private void createPreviousSearchWidget(int itemId, String itemName) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.RECTANGLE);
        widget.setTextColor(0xFFFFFF);
        widget.setOpacity(255);
        widget.setName("<col=ff9040>" + itemName + "</col>");
        widget.setHasListener(true);
        widget.setFilled(true);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(256);
        widget.setOriginalHeight(32);
        widget.setOnOpListener(754, itemId, 84);
        widget.setOnKeyListener(754, itemId, -2147483640);
        widget.setHasListener(true);
        widget.setAction(0, "Select");
        // set opacity to 200 when mouse is hovering
        widget.setOnMouseOverListener((JavaScriptCallback) ev -> {
            widget.setOpacity(200);
        });
        // set opacity back to 255 when mouse is not hovering
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
            widget.setOpacity(255);
        });

        widget.revalidate();
    }

    private void createPreviousSearchItemNameWidget(String itemName) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText(itemName);
        widget.setFontId(495);
        widget.setOriginalX(254);
        widget.setOriginalY(0);
        widget.setOriginalWidth(116);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }

    private void createPreviousSearchItemWidget(int itemId) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.GRAPHIC);
        widget.setItemId(itemId);
        widget.setItemQuantity(1);
        widget.setItemQuantityMode(0);
        widget.setRotationX(550);
        widget.setModelZoom(1031);
        widget.setBorderType(1);
        widget.setOriginalX(214);
        widget.setOriginalY(0);
        widget.setOriginalWidth(36);
        widget.setOriginalHeight(32);
        widget.revalidate();
    }

    private void createPreviousSearchTextWidget() {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText("Copilot item:");
        widget.setFontId(495);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(95);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }
}

package com.flippingcopilot.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchange {

    private final static int CURRENTLY_OPEN_GE_SLOT_VARBIT_ID = 4439;
    final static int SHOW_LAST_SEARCHED_VARBIT_ID = 10295;

    private final Client client;

    boolean isHomeScreenOpen() {
        return isOpen() && !isSlotOpen();
    }

    boolean isSlotOpen() {
        return getOpenSlot() != -1;
    }

    boolean isCollectButtonVisible() {
        Widget w = client.getWidget(InterfaceID.GRAND_EXCHANGE, 6);
        if (w == null) {
            return false;
        }
        Widget[] children = w.getChildren();
        if(children == null) {
            return false;
        }
        return Arrays.stream(children).anyMatch(c -> !c.isHidden() && "Collect".equals(c.getText()));
    }

    int getOpenSlot() {
        return client.getVarbitValue(CURRENTLY_OPEN_GE_SLOT_VARBIT_ID) - 1;
    }

    Widget getSlotWidget(int slot) {
        return client.getWidget(465, 7 + slot);
    }

    Widget getBuyButton(int slot) {
        Widget slotWidget = getSlotWidget(slot);
        if (slotWidget == null) {
            return null;
        }
        return slotWidget.getChild(0);
    }

    Widget getCollectButton() {
        Widget topBar = client.getWidget(465, 6);
        if (topBar == null) {
            return null;
        }
        return topBar.getChild(2);
    }

    Widget getOfferContainerWidget() {
        return client.getWidget(465, 26);
    }

    Widget getOfferTypeWidget() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(20);
    }

    Widget getConfirmButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(58);
    }

    int getOfferQuantity() {
        return client.getVarbitValue(4396);
    }

    int getOfferPrice() {
        return client.getVarbitValue(4398);
    }

    public boolean isOpen() {
        return client.getWidget(InterfaceID.GRAND_EXCHANGE, 7) != null;
    }

    public boolean isPreviousSearchSet() {
        return client.getVarpValue(2674) != -1;
    }

    public boolean showLastSearchEnabled() {
        return client.getVarbitValue(SHOW_LAST_SEARCHED_VARBIT_ID) == 0;
    }

    public Widget getSetQuantityButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(51);
    }

    public Widget getSetPriceButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(54);
    }

    public Widget getSetQuantityAllButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(50);
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.graph.PriceGraphController;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;
import static net.runelite.api.Varbits.GE_OFFER_CREATION_TYPE;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class MenuHandler {

    private final FlippingCopilotConfig config;
    private final Client client;
    private final OfferManager offerManager;
    private final PriceGraphController priceGraphController;
    private final GrandExchange grandExchange;
    private final SuggestionManager suggestionManager;


    public void injectCopilotPriceGraphMenuEntry(MenuEntryAdded event) {
        if(!config.priceGraphMenuOptionEnabled()) {
            return;
        }
        if (event.getOption().equals("View offer")) {
            long slotWidgetId = event.getActionParam1();
            client.getMenu()
                    .createMenuEntry(-1)
                    .setOption("Copilot price graph")
                    .onClick((MenuEntry e) -> {
                        GrandExchangeOffer[] offers = client.getGrandExchangeOffers();
                        for (int i = 0; i < offers.length; i++) {
                            Widget slotWidget = client.getWidget(465, 7 + i);
                            if (slotWidget != null && slotWidget.getId() == slotWidgetId) {
                                int itemId = offers[i].getItemId();
                                priceGraphController.setUserItemGraphData(null);
                                priceGraphController.loadAndAndShowPriceGraph(itemId);
                                log.debug("matched widget to slot {}, item {}", i, offers[i].getItemId());
                            }
                        }
                    });
        }
    }

    public void injectConfirmMenuEntry(MenuEntryAdded event) {
        if(!config.disableLeftClickConfirm()) {
            return;
        }

        if(offerDetailsCorrect()) {
            return;
        }

        if(event.getOption().equals("Confirm") && grandExchange.isSlotOpen()) {
            log.debug("Adding deprioritized menu entry for offer");
            client.getMenu()
                    .createMenuEntry(-1)
                    .setOption("Nothing");

            event.getMenuEntry().setDeprioritized(true);
        }
    }

    private boolean offerDetailsCorrect() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return false;
        }
        String offerType = client.getVarbitValue(GE_OFFER_CREATION_TYPE) == 1 ? "sell" : "buy";
        if (client.getVarpValue(CURRENT_GE_ITEM) == suggestion.getItemId() && offerType.equals(suggestion.getType())) {
            return grandExchange.getOfferPrice() == suggestion.getPrice()
                    && grandExchange.getOfferQuantity() == suggestion.getQuantity();
        } else if (client.getVarpValue(CURRENT_GE_ITEM) == offerManager.getViewedSlotItemId()
                && offerManager.getViewedSlotItemPrice() > 0) {
            return grandExchange.getOfferPrice() == offerManager.getViewedSlotItemPrice();
        }
        return false;
    }
}



package com.flippingcopilot.controller;

import com.flippingcopilot.ui.UIUtilities;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;


@ConfigGroup("flippingcopilot")
public interface FlippingCopilotConfig extends Config
{
    public enum PriceGraphWebsite
    {
        FLIPPING_COPILOT("Flipping Copilot"),
        OSRS_WIKI("OSRS Wiki"),
        GE_TRACKER("GE Tracker"),
        PLATINUM_TOKENS("PlatinumTokens"),
        GE_DATABASE("GE Database"),
        OSRS_CLOUD("Osrs.cloud"),
        OSRS_EXCHANGE("OSRS Exchange"),
        FLIPPING_GG("Flipping.gg");


        private final String name;
        PriceGraphWebsite(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name;
        }

        public String getUrl(String itemName, int itemId)
        {
            switch (this)
            {
                case OSRS_WIKI:
                    return "https://prices.runescape.wiki/osrs/item/" + itemId;
                case GE_TRACKER:
                    return "https://www.ge-tracker.com/item/" + itemId;
                case PLATINUM_TOKENS:
                    String platinumTokensFormattedName = itemName
                            .toLowerCase()
                            .replace("'", "")
                            .replace("(", " ")
                            .replace(")", "")
                            .replace("+", " plus")
                            .replace("  ", " ")
                            .replace(" ", "-");
                    return "https://platinumtokens.com/item/" + platinumTokensFormattedName;
                case GE_DATABASE:
                    return "https://secure.runescape.com/m=itemdb_oldschool/viewitem?obj=" + itemId;
                case OSRS_EXCHANGE:
                    String osrsExchangeFormattedName = itemName.toLowerCase().replace(' ','-');
                    return "https://www.osrs.exchange/item/"
                            + URLEncoder.encode(osrsExchangeFormattedName, StandardCharsets.UTF_8);
                case OSRS_CLOUD:
                    return "https://prices.osrs.cloud/item/" + itemId;
                case FLIPPING_GG:
                    return "https://www.flipping.gg/items/" + itemId;
                default:
                    return "";
            }
        }
    }


    @ConfigItem(
            keyName = "enableChatNotifications",
            name = "Enable chat notifications",
            description = "Show chat notifications for suggested action when the side panel is closed."
    )
    default boolean enableChatNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "enableTrayNotifications",
            name = "Enable tray notifications",
            description = "Show tray notifications for suggested action when runelite is out of focus."
    )
    default boolean enableTrayNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "profitAmountColor",
            name = "Flip tracker profit color",
            description = "The color of the profit amount text in the flip tracker"
    )
    default Color profitAmountColor() {
        return ColorScheme.GRAND_EXCHANGE_PRICE;
    }
    @ConfigItem(
            keyName = "lossAmountColor",
            name = "Flip tracker loss color",
            description = "The color of the loss amount text in the flip tracker"
    )
    default Color lossAmountColor() {
        return UIUtilities.OUTDATED_COLOR;
    }
    @ConfigItem(
            keyName = "chatTextColor",
            name = "Chat text color",
            description = "The color of the text for copilot messages in the chat."
    )
    default Color chatTextColor() {
        return new Color(0x0040FF);
    }
    @ConfigItem(
            keyName = "webhook",
            name = "Webhook URL",
            description = "The Discord Webhook URL for sending display name and profit."
    )
    String webhook();
    @ConfigItem(
            keyName = "priceGraphButton",
            name = "Graph button",
            description = "The page to open when the graph button is clicked."
    )
    default PriceGraphWebsite priceGraphWebsite()
    {
        return PriceGraphWebsite.FLIPPING_COPILOT;
    }
    @ConfigItem(
            keyName = "suggestionHighlights",
            name = "Highlight suggested actions",
            description = "Show highlight overlays on the GE interface for suggested actions."
    )
    default boolean suggestionHighlights()
    {
        return true;
    }
    @ConfigItem(
            keyName = "misClickProtection",
            name = "Mis-click prevention",
            description = "Require right click to confirm when price/quantity set incorrectly"
    )
    default boolean disableLeftClickConfirm()
    {
        return false;
    }
    @ConfigItem(
            keyName = "quickSetKeybind",
            name = "Price/quantity set keybind",
            description = "Keybind to quickly set the price or quantity of a GE offer to the suggested value"
    )
    default Keybind quickSetKeybind()
    {
        return new Keybind(KeyEvent.VK_E, 0);
    }

    @ConfigItem(
            keyName = "enabledPriceGraphMenuOpton",
            name = "Enable price graph menu option",
            description = "Adds a menu option to open copilot price graph on applicable right clicks."
    )
    default boolean priceGraphMenuOptionEnabled()
    {
        return true;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GameUiChangesHandler {
    private static final int GE_HISTORY_TAB_WIDGET_ID = 149;

    // dependencies
    private final ClientThread clientThread;
    private final Client client;
    private final GePreviousSearch gePreviousSearch;
    private final HighlightController highlightController;
    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final OfferManager offerManager;
    private final OfferHandler offerHandler;
    // state
    boolean quantityOrPriceChatboxOpen;
    boolean itemSearchChatboxOpen = false;
    @Getter
    OfferEditor flippingWidget = null;

    public void onVarClientIntChanged(VarClientIntChanged event) {
        if (event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 14
                && client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS) != null) {
            itemSearchChatboxOpen = true;
            clientThread.invokeLater(gePreviousSearch::showSuggestedItemInSearch);
        }

        if (quantityOrPriceChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            quantityOrPriceChatboxOpen = false;
            return;
        }

        if (itemSearchChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            clientThread.invokeLater(highlightController::redraw);
            itemSearchChatboxOpen = false;
            return;
        }

        //Check that it was the chat input that got enabled.
        if (event.getIndex() != VarClientInt.INPUT_TYPE
                || client.getWidget(ComponentID.CHATBOX_TITLE) == null
                || client.getVarcIntValue(VarClientInt.INPUT_TYPE) != 7
                || client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) == null) {
            return;
        }
        quantityOrPriceChatboxOpen = true;

        clientThread.invokeLater(() ->
        {
            flippingWidget = new OfferEditor(offerManager, client.getWidget(ComponentID.CHATBOX_CONTAINER), offerHandler, client);
            Suggestion suggestion = suggestionManager.getSuggestion();
            if (suggestion != null) {
                flippingWidget.showSuggestion(suggestion);
            }
        });
    }

    public void onVarClientStrChanged(VarClientStrChanged event) {
        if (event.getIndex() == VarClientStr.INPUT_TEXT && itemSearchChatboxOpen) {
            clientThread.invokeLater(highlightController::redraw);
        }
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            suggestionManager.setSuggestionNeeded(true);
        }
        if (event.getGroupId() == 383
                || event.getGroupId() == InterfaceID.GRAND_EXCHANGE
                || event.getGroupId() == 213
                || event.getGroupId() == GE_HISTORY_TAB_WIDGET_ID) {
            clientThread.invokeLater(highlightController::redraw);
        }
    }

    public void onWidgetClosed(WidgetClosed event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            clientThread.invokeLater(highlightController::removeAll);
            suggestionManager.setSuggestionNeeded(true);
        }
    }

    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarpId() == 375
                || event.getVarpId() == CURRENT_GE_ITEM
                || event.getVarbitId() == 4396
                || event.getVarbitId() == 4398
                || event.getVarbitId() == 4439) {
            clientThread.invokeLater(highlightController::redraw);
        }

        if (event.getVarpId() == CURRENT_GE_ITEM) {
            clientThread.invokeLater(() -> offerHandler.fetchSlotItemPrice(event.getValue() > -1, this::getFlippingWidget));
        }
    }

    public void handleMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals("Confirm") && grandExchange.isSlotOpen()) {
            log.debug("offer confirmed tick {}", client.getTickCount());
            offerManager.setOfferJustPlaced(true);
            suggestionManager.setLastOfferSubmittedTick(client.getTickCount());
            suggestionManager.setSuggestionNeeded(true);
            Suggestion suggestion = suggestionManager.getSuggestion();
            if(suggestion != null) {
                suggestionManager.setSuggestionItemIdOnOfferSubmitted(suggestion.getItemId());
                suggestionManager.setSuggestionOfferStatusOnOfferSubmitted(suggestionOfferStatus(suggestion));
            } else {
                suggestionManager.setSuggestionItemIdOnOfferSubmitted(-1);
                suggestionManager.setSuggestionOfferStatusOnOfferSubmitted(null);
            }
        }
    }

    private OfferStatus suggestionOfferStatus(Suggestion suggestion) {
        if ("sell".equals(suggestion.getType())) {
            return OfferStatus.SELL;
        } else if ("buy".equals(suggestion.getType())) {
            return OfferStatus.BUY;
        } else {
            return null;
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.PremiumInstanceStatus;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.PremiumInstancePanel;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.util.function.Consumer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PremiumInstanceController {

    private final ApiRequestHandler apiRequestHandler;
    private final FlippingCopilotConfig copilotConfig;
    private final SuggestionManager suggestionManager;
    private JDialog dialog;

    public void loadAndOpenPremiumInstanceDialog() {
        // Create the dialog
        if(dialog != null) {
            dialog.dispose();
        }
        dialog = new JDialog();
        dialog.setTitle("Premium accounts management");
        dialog.setModal(false);
        dialog.setSize(400, 300);
        dialog.setLocationRelativeTo(null);

        // Create the panel
        PremiumInstancePanel panel = new PremiumInstancePanel(copilotConfig, apiRequestHandler, suggestionManager);
        dialog.setContentPane(panel);

        // Show loading state
        panel.showLoading();
        Consumer<PremiumInstanceStatus> c = (status) -> {
            SwingUtilities.invokeLater(() -> {  // Make sure UI updates happen on EDT
                if (status.getLoadingError() != null && !status.getLoadingError().isEmpty()) {
                    panel.showError(status.getLoadingError());
                } else {
                    panel.showManagementView(status);
                }
            });
        };
        apiRequestHandler.asyncGetPremiumInstanceStatus(c);
        dialog.setVisible(true);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.WidgetHighlightOverlay;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.VarClientStr;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;
import static net.runelite.api.Varbits.GE_OFFER_CREATION_TYPE;


@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class HighlightController {

    // dependencies
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final AccountStatusManager accountStatusManager;
    private final Client client;
    private final OfferManager offerManager;
    private final OverlayManager overlayManager;
    private final HighlightColorController highlightColorController;

    // state
    private final ArrayList<WidgetHighlightOverlay> highlightOverlays = new ArrayList<>();

    public void redraw() {
        removeAll();
        if(!config.suggestionHighlights()) {
            return;
        }
        if(!grandExchange.isOpen()) {
            return;
        }
        if (offerManager.isOfferJustPlaced()) {
            return;
        }
        if(suggestionManager.getSuggestionError() != null) {
            return;
        }
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return;
        }
        if (grandExchange.isHomeScreenOpen()) {
            drawHomeScreenHighLights(suggestion);
        } else if (grandExchange.isSlotOpen()) {
            drawOfferScreenHighlights(suggestion);
        }
    }

    private void drawHomeScreenHighLights(Suggestion suggestion) {
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (accountStatus.isCollectNeeded(suggestion)) {
            Widget collectButton = grandExchange.getCollectButton();
            if (collectButton != null) {
                add(collectButton, highlightColorController.getBlueColor(), new Rectangle(2, 1, 81, 18));
            }
        }
        else if (suggestion.getType().equals("abort")) {
            Widget slotWidget = grandExchange.getSlotWidget(suggestion.getBoxId());
            add(slotWidget, highlightColorController.getRedColor());
        }
        else if (suggestion.getType().equals("buy")) {
            int slotId = accountStatus.findEmptySlot();
            if (slotId != -1) {
                Widget buyButton = grandExchange.getBuyButton(slotId);
                if (buyButton != null && !buyButton.isHidden()) {
                    add(buyButton, highlightColorController.getBlueColor(), new Rectangle(0, 0, 45, 44));
                }
            }
        }
        else if (suggestion.getType().equals("sell")) {
            Widget itemWidget = getInventoryItemWidget(suggestion.getItemId());
            if (itemWidget != null && !itemWidget.isHidden()) {
                add(itemWidget, highlightColorController.getBlueColor(), new Rectangle(0, 0, 34, 32));
            }
        }
    }

    private void drawOfferScreenHighlights(Suggestion suggestion) {
        Widget offerTypeWidget = grandExchange.getOfferTypeWidget();
        String offerType = client.getVarbitValue(GE_OFFER_CREATION_TYPE) == 1 ? "sell" : "buy";
        if (offerTypeWidget != null) {
            if (offerType.equals(suggestion.getType())) {
                if (client.getVarpValue(CURRENT_GE_ITEM) == suggestion.getItemId()) {
                    if (offerDetailsCorrect(suggestion)) {
                        highlightConfirm();
                    } else {
                        if (grandExchange.getOfferPrice() != suggestion.getPrice()) {
                            highlightPrice();
                        }
                        highlightQuantity(suggestion);
                    }
                } else if (client.getVarpValue(CURRENT_GE_ITEM ) == -1){
                    highlightItemInSearch(suggestion);
                }
            }
            // Check if unsuggested item/offer type is selected
            if (client.getVarpValue(CURRENT_GE_ITEM) != -1
                    && (client.getVarpValue(CURRENT_GE_ITEM) != suggestion.getItemId()
                        || !offerType.equals(suggestion.getType()))
                    && client.getVarpValue(CURRENT_GE_ITEM) == offerManager.getViewedSlotItemId()
                    && offerManager.getViewedSlotItemPrice() > 0) {
                if (grandExchange.getOfferPrice() == offerManager.getViewedSlotItemPrice()) {
                    highlightConfirm();
                } else {
                    highlightPrice();
                }
            }
        }
    }

    private void highlightItemInSearch(Suggestion suggestion) {
        if (!client.getVarcStrValue(VarClientStr.INPUT_TEXT).isEmpty()) {
            return;
        }
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        if (searchResults == null) {
            return;
        }
        for (Widget widget : searchResults.getDynamicChildren()) {
            if (widget.getName().equals("<col=ff9040>" + suggestion.getName() + "</col>")) {
                add(widget, highlightColorController.getBlueColor());
                return;
            }
        }
        Widget itemWidget = searchResults.getChild(3);
        if (itemWidget != null && itemWidget.getItemId() == suggestion.getItemId()) {
            add(itemWidget, highlightColorController.getBlueColor());
        }
    }

    private boolean offerDetailsCorrect(Suggestion suggestion) {
        return grandExchange.getOfferPrice() == suggestion.getPrice()
                && grandExchange.getOfferQuantity() == suggestion.getQuantity();
    }

    private void highlightPrice() {
        Widget setPriceButton = grandExchange.getSetPriceButton();
        if (setPriceButton != null) {
            add(setPriceButton, highlightColorController.getBlueColor(), new Rectangle(1, 6, 33, 23));
        }
    }

    private void highlightQuantity(Suggestion suggestion) {
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (grandExchange.getOfferQuantity() != suggestion.getQuantity()) {
            Widget setQuantityButton;
            if (accountStatus.getInventory().getTotalAmount(suggestion.getItemId()) == suggestion.getQuantity()) {
                setQuantityButton = grandExchange.getSetQuantityAllButton();
            } else {
                setQuantityButton = grandExchange.getSetQuantityButton();
            }
            if (setQuantityButton != null) {
                add(setQuantityButton, highlightColorController.getBlueColor(), new Rectangle(1, 6, 33, 23));
            }
        }
    }

    private void highlightConfirm() {
        Widget confirmButton = grandExchange.getConfirmButton();
        if (confirmButton != null) {
            add(confirmButton, highlightColorController.getBlueColor(), new Rectangle(1, 1, 150, 38));
        }
    }

    private void add(Widget widget, Color color, Rectangle adjustedBounds) {
        SwingUtilities.invokeLater(() -> {
            WidgetHighlightOverlay overlay = new WidgetHighlightOverlay(widget, color, adjustedBounds);
            highlightOverlays.add(overlay);
            overlayManager.add(overlay);
        });
    }

    private void add(Widget widget, Color color) {
        add(widget, color, new Rectangle(0, 0, widget.getWidth(), widget.getHeight()));
    }

    public void removeAll() {
        SwingUtilities.invokeLater(() -> {
            highlightOverlays.forEach(overlayManager::remove);
            highlightOverlays.clear();
        });
    }

    private Widget getInventoryItemWidget(int unnotedItemId) {
        // Inventory has a different widget if GE is open
        Widget inventory = client.getWidget(467, 0);
        if (inventory == null) {
            inventory = client.getWidget(149, 0);
            if (inventory == null) {
                return null;
            }
        }

        Widget notedWidget = null;
        Widget unnotedWidget = null;

        for (Widget widget : inventory.getDynamicChildren()) {
            int itemId = widget.getItemId();
            ItemComposition itemComposition = client.getItemDefinition(itemId);

            if (itemComposition.getNote() != -1) {
                if (itemComposition.getLinkedNoteId() == unnotedItemId) {
                    notedWidget = widget;
                }
            } else if (itemId == unnotedItemId) {
                unnotedWidget = widget;
            }
        }
        return notedWidget != null ? notedWidget : unnotedWidget;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.ItemIdName;
import com.flippingcopilot.ui.FuzzySearchScorer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collectors;
import java.util.stream.IntStream;


@Slf4j
@Singleton
public class ItemController {
    private static final int NAME_CHAR_LIMIT = 25;

    // dependencies
    private final FuzzySearchScorer fuzzySearchScorer;
    private final ItemManager itemManager;
    private final ClientThread clientThread;

    // state
    private final Map<Integer, String> cachedItemNames = new ConcurrentHashMap<>();
    private volatile List<ItemIdName> cachedItems = new ArrayList<>(); // volatile used to guarantee immediate visibility across threads on re-assignment
    private final AtomicBoolean initScheduled = new AtomicBoolean(false);

    @Inject
    public ItemController(Client client,
                          ClientThread clientThread,
                          ItemManager itemManager,
                          FuzzySearchScorer fuzzySearchScorer,
                          ScheduledExecutorService executorService) {
        this.fuzzySearchScorer = fuzzySearchScorer;
        this.itemManager = itemManager;
        this.clientThread = clientThread;

        Runnable initItems = () -> {
            // only allow one init attempt at a time
            if(initScheduled.compareAndSet(false, true)) {
                clientThread.invokeLater(() -> {
                    List<ItemIdName> items = IntStream.range(0, client.getItemCount())
                            .mapToObj(itemManager::getItemComposition)
                            .filter(item -> item.isTradeable() && item.getNote() == -1)
                            .map(i -> new ItemIdName(i.getId(), i.getName()))
                            .collect(Collectors.toList());
                    if (!items.isEmpty()) {
                        cachedItems = items;
                        cachedItems.forEach(i -> cachedItemNames.put(i.itemId, i.name));
                        initScheduled.set(false);
                        log.debug("initialised {} items", items.size());
                        return true;
                    }
                    // if no items are found try again
                    return false;
                });
            }
        };

        // re-init every 5 mins just in case new items are added without restart
        executorService.scheduleAtFixedRate(initItems, 0, 5, TimeUnit.MINUTES);
    }

    public List<ItemIdName> search(String input, Set<Integer> existingSelectedItems) {

        if(input == null || input.isBlank()) {
            return cachedItems.stream()
                    .sorted(Comparator.comparing((ItemIdName i) -> !existingSelectedItems.contains(i.itemId)).thenComparing(i -> i.name))
                    .collect(Collectors.toList());
        }

        ToDoubleFunction<ItemIdName> comparator = fuzzySearchScorer.comparator(input);
        return cachedItems.stream()
                .filter(item -> comparator.applyAsDouble(item) > 0)
                .sorted(Comparator.comparing((ItemIdName i) -> !existingSelectedItems.contains(i.itemId)).thenComparing(Comparator.comparingDouble(comparator).reversed()
                        .thenComparing(i -> i.name)))
                .collect(Collectors.toList());
    }


    private String trimName(String name) {
        if(name.length() > NAME_CHAR_LIMIT) {
            return name.substring(0, NAME_CHAR_LIMIT - 1) + "..";
        }
        return name;
    }

    public Set<Integer> allItemIds() {
        return cachedItemNames.keySet();
    }

    public String getItemName(Integer itemId) {
        return cachedItemNames.getOrDefault(itemId, "Name unavailable");
    }

    public void loadImage(Integer itemId, Consumer<AsyncBufferedImage> c) {
        clientThread.invokeLater(() -> {
            c.accept(itemManager.getImage(itemId));
        });
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.*;
import com.google.gson.Gson;
import com.google.inject.Provides;
import com.google.inject.Singleton;
import com.google.inject.name.Named;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
@PluginDescriptor(
		name = "Flipping Copilot",
		description = "Your AI assistant for trading"
)
public class FlippingCopilotPlugin extends Plugin {

	@Inject
	private FlippingCopilotConfig config;
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	@Named("copilotExecutor")
	private ScheduledExecutorService executorService;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private Gson gson;
	@Inject
	private GrandExchange grandExchange;
	@Inject
	private GrandExchangeCollectHandler grandExchangeCollectHandler;
	@Inject
	private GrandExchangeOfferEventHandler offerEventHandler;
	@Inject
	private ApiRequestHandler apiRequestHandler;
	@Inject
	private AccountStatusManager accountStatusManager;
	@Inject
	private SuggestionController suggestionController;
	@Inject
	private SuggestionManager suggestionManager;
	@Inject
	private WebHookController webHookController;
	@Inject
	private KeybindHandler keybindHandler;
	@Inject
	private CopilotLoginController copilotLoginController;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private CopilotLoginManager copilotLoginManager;
	@Inject
	private HighlightController highlightController;
	@Inject
	private GameUiChangesHandler gameUiChangesHandler;
	@Inject
	private OsrsLoginManager osrsLoginManager;
	@Inject
	private FlipManager flipManager;
	@Inject
	private SessionManager sessionManager;
	@Inject
	private GrandExchangeUncollectedManager grandExchangeUncollectedManager;
	@Inject
	private TransactionManager transactionManager;
	@Inject
	private OfferManager offerManager;
	@Inject
	private TooltipController tooltipController;
  	@Inject
	private MenuHandler menuHandler;
    @Inject
	private GeHistoryTabController geHistoryTabController;

	// We use our own ThreadPool since the default ScheduledExecutorService only has a single thread and we don't want to block it
	@Provides
	@Singleton
	@Named("copilotExecutor")
	public ScheduledExecutorService provideCustomExecutorService() {
		return Executors.newScheduledThreadPool(2);
	}

	@Provides
	@Singleton
	public ExecutorService provideExecutorService(@Named("copilotExecutor") ScheduledExecutorService scheduledExecutor) {
		return scheduledExecutor;
	}

	private MainPanel mainPanel;
	private StatsPanelV2 statsPanel;
	private NavigationButton navButton;

	@Override
	protected void startUp() throws Exception {
		Persistance.setUp(gson);

		// seems we need to delay instantiating the UI till here as otherwise the panels look different
		mainPanel = injector.getInstance(MainPanel.class);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon-small.png");
		navButton = NavigationButton.builder()
				.tooltip("Flipping Copilot")
				.icon(icon)
				.priority(3)
				.panel(mainPanel)
				.build();
		clientToolbar.addNavigation(navButton);
		apiRequestHandler.setCopilotLoginController(copilotLoginController);
		copilotLoginController.setLoginPanel(mainPanel.loginPanel);
		copilotLoginController.setMainPanel(mainPanel);
		suggestionController.setCopilotPanel(mainPanel.copilotPanel);
		suggestionController.setMainPanel(mainPanel);
		suggestionController.setLoginPanel(mainPanel.loginPanel);
		suggestionController.setSuggestionPanel(mainPanel.copilotPanel.suggestionPanel);
		grandExchangeCollectHandler.setSuggestionPanel(mainPanel.copilotPanel.suggestionPanel);
		statsPanel = mainPanel.copilotPanel.statsPanel;

		mainPanel.refresh();

		if(osrsLoginManager.getInvalidStateDisplayMessage() == null) {
			flipManager.setIntervalAccount(null);
			flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
		}
		executorService.scheduleAtFixedRate(() ->
			clientThread.invoke(() -> {
				boolean loginValid = osrsLoginManager.isValidLoginState();
				if (loginValid) {
					AccountStatus accStatus = accountStatusManager.getAccountStatus();
					boolean isFlipping = accStatus != null && accStatus.currentlyFlipping();
					long cashStack = accStatus == null ? 0 : accStatus.currentCashStack();
					if(sessionManager.updateSessionStats(isFlipping, cashStack)) {
						mainPanel.copilotPanel.statsPanel.refresh(false, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
					}
				}
			})
		, 2000, 1000, TimeUnit.MILLISECONDS);
	}

	@Override
	protected void shutDown() throws Exception {
		offerManager.saveAll();
		highlightController.removeAll();
		clientToolbar.removeNavigation(navButton);
		if(copilotLoginManager.isLoggedIn()) {
			String displayName = osrsLoginManager.getLastDisplayName();
			Integer accountId = copilotLoginManager.getAccountId(displayName);
			if (accountId != null && accountId != -1) {
				webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, accountId), sessionManager.getCachedSessionData(), displayName, false);
			}
		}
		keybindHandler.unregister();
	}

	@Provides
	public FlippingCopilotConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(FlippingCopilotConfig.class);
	}

	//---------------------------- Event Handlers ----------------------------//
	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event) {
		offerEventHandler.onGrandExchangeOfferChanged(event);
		clientThread.invokeLater(() -> highlightController.redraw());
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event) {
		if (event.getContainerId() == InventoryID.INV && grandExchange.isOpen()) {
			suggestionManager.setSuggestionNeeded(true);
			clientThread.invokeLater(() -> highlightController.redraw());
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		suggestionController.onGameTick();
		offerEventHandler.onGameTick();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		int slot = grandExchange.getOpenSlot();
		grandExchangeCollectHandler.handleCollect(event, slot);
		gameUiChangesHandler.handleMenuOptionClicked(event);
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired e) {
		tooltipController.tooltip(e);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		menuHandler.injectCopilotPriceGraphMenuEntry(event);
		menuHandler.injectConfirmMenuEntry(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		if (event.getGroupId() == 383) {
			clientThread.invokeLater(() -> {
				geHistoryTabController.onGeHistoryTabOpened();
			});
		}
		gameUiChangesHandler.onWidgetLoaded(event);
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		if (event.getGroupId() == 383) {
			geHistoryTabController.onGeHistoryTabClosed();
		}
		gameUiChangesHandler.onWidgetClosed(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		gameUiChangesHandler.onVarbitChanged(event);
	}

	@Subscribe
	public void onVarClientStrChanged(VarClientStrChanged event) {
		gameUiChangesHandler.onVarClientStrChanged(event);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		switch (event.getGameState())
		{
			case LOGIN_SCREEN:
				sessionManager.reset();
				suggestionManager.reset();
				osrsLoginManager.reset();
				geHistoryTabController.onGeHistoryTabClosed();
				accountStatusManager.reset();
				grandExchangeUncollectedManager.reset();
				statsPanel.refresh(true, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
				mainPanel.refresh();
				break;
			case LOGGING_IN:
			case HOPPING:
			case CONNECTION_LOST:
				osrsLoginManager.setLastLoginTick(client.getTickCount());
				break;
			case LOGGED_IN:
				// we want to update the flips panel on login but unfortunately the display name
				// is not available immediately so schedule what we need to do here for in the future
				// todo: move to just using the accountHash which is available immediately to simply things
				clientThread.invokeLater(() -> {
					if (client.getGameState() != GameState.LOGGED_IN) {
						return true;
					}
					final String name = osrsLoginManager.getPlayerDisplayName();
					if(name == null) {
						return false;
					}
					statsPanel.resetIntervalDropdownToSession();
					Integer accountId = copilotLoginManager.getAccountId(name);
					if (accountId != null && accountId != -1) {
						flipManager.setIntervalAccount(accountId);
					} else {
						flipManager.setIntervalAccount(null);
					}
					flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
					statsPanel.refresh(true, copilotLoginManager.isLoggedIn()  && osrsLoginManager.isValidLoginState());
					mainPanel.refresh();
					if(copilotLoginManager.isLoggedIn()) {
						transactionManager.scheduleSyncIn(0, name);
					}
					return true;
				});
		}
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event) {
		gameUiChangesHandler.onVarClientIntChanged(event);
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown clientShutdownEvent) {
		log.debug("client shutdown event received");
		offerManager.saveAll();
		if(copilotLoginManager.isLoggedIn()) {
			String displayName = osrsLoginManager.getLastDisplayName();
			Integer accountId = copilotLoginManager.getAccountId(displayName);
			if (accountId != null && accountId != -1) {
				webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, accountId), sessionManager.getCachedSessionData(), displayName, false);
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals("flippingcopilot")) {
			log.debug("copilot config changed event received");
			if (event.getKey().equals("profitAmountColor") || event.getKey().equals("lossAmountColor")) {
				mainPanel.copilotPanel.statsPanel.refresh(true, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
			}
			if (event.getKey().equals("suggestionHighlights")) {
				clientThread.invokeLater(() -> highlightController.redraw());
			}
		}
	}
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.GrandExchangeUncollectedManager;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.ui.SuggestionPanel;
import com.google.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchangeCollectHandler {

    // dependencies
    private final OsrsLoginManager osrsLoginManager;
    private final GrandExchangeUncollectedManager geUncollected;
    @Setter
    private SuggestionPanel suggestionPanel;

    public void handleCollect(MenuOptionClicked event, int slot) {
        String menuOption = event.getMenuOption();
        Widget widget = event.getWidget();
        if (widget != null) {
            handleCollectAll(menuOption, widget);
            handleCollectWithSlotOpen(menuOption, widget, slot);
            handleCollectionBoxCollectAll(menuOption, widget);
            handleCollectionBoxCollectItem(menuOption, widget);
        }
    }

    private void handleCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 30474246) {
            if (menuOption.equals("Collect to inventory")) {
                geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            } else if (menuOption.equals("Collect to bank")) {
                geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            }
            suggestionPanel.refresh();
        }
    }

    private void handleCollectWithSlotOpen(String menuOption, Widget widget, int slot) {
        if (widget.getId() == 30474264 ) {
            if (menuOption.contains("Collect")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            } else if (menuOption.contains("Bank")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            }
            suggestionPanel.refresh();
        }
    }

    private void handleCollectionBoxCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 26345476 && menuOption.equals("Collect to bank")) {
            geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionPanel.refresh();
            
        } else if (widget.getId() == 26345475 && menuOption.equals("Collect to inventory")) {
            geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionPanel.refresh();
        }
    }

    private void handleCollectionBoxCollectItem(String menuOption, Widget widget) {
        int slot = widget.getId() - 26345477;
        if (slot >= 0 && slot <= 7) {
            if (menuOption.contains("Collect")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            } else if (menuOption.contains("Bank")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            }
            suggestionPanel.refresh();
        }
    }
}

package com.flippingcopilot.controller;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.GpDropOverlay;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import javax.inject.Inject;
import javax.inject.Singleton;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.client.ui.overlay.OverlayManager;

import static com.flippingcopilot.model.OsrsLoginManager.GE_LOGIN_BURST_WINDOW;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchangeOfferEventHandler {

    // dependencies
    private final Client client;
    private final OfferManager offerPersistence;
    private final GrandExchange grandExchange;
    private final TransactionManager transactionManager;
    private final OsrsLoginManager osrsLoginManager;
    private final OverlayManager overlayManager;
    private final GrandExchangeUncollectedManager grandExchangeUncollectedManager;
    private final OfferManager offerManager;
    private final SuggestionManager suggestionManager;

    // state
    private final Queue<Transaction> transactionsToProcess = new ConcurrentLinkedQueue<>();

    public void onGameTick() {
        if(!transactionsToProcess.isEmpty()) {
            processTransactions();
        }
    }

    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerEvent) {
        final int slot = offerEvent.getSlot();
        final GrandExchangeOffer offer = offerEvent.getOffer();
        Long accountHash = client.getAccountHash();

        if (offer.getState() == GrandExchangeOfferState.EMPTY && client.getGameState() != GameState.LOGGED_IN) {
            // Trades are cleared by the client during LOGIN_SCREEN/HOPPING/LOGGING_IN, ignore those
            return;
        }

        log.debug("tick {} GE offer updated: state: {}, slot: {}, item: {}, qty: {}, lastLoginTick: {}", client.getTickCount(), offer.getState(), slot, offer.getItemId(), offer.getQuantitySold(), osrsLoginManager.getLastLoginTick());

        SavedOffer o = SavedOffer.fromGrandExchangeOffer(offer);

        SavedOffer prev = offerPersistence.loadOffer(accountHash, slot);

        if(Objects.equals(o, prev)) {
            log.debug("skipping duplicate offer event {}", o);
            return;
        }

        o.setCopilotPriceUsed(wasCopilotPriceUsed(o, prev));
        o.setWasCopilotSuggestion(wasCopilotSuggestion(o, prev));

        boolean consistent = isConsistent(prev, o);
        if(!consistent) {
            log.warn("offer on slot {} is inconsistent with previous saved offer", slot);
        }

        Transaction t = inferTransaction(slot, o, prev, consistent);
        if(t != null) {
            transactionsToProcess.add(t);
            processTransactions();
            log.debug("inferred transaction {}", t);
        }
        updateUncollected(accountHash, slot, o, prev, consistent);
        offerPersistence.saveOffer(accountHash, slot, o);

        // Always fetch suggestion to ensure fast response for better UX
        suggestionManager.setSuggestionNeeded(true);
    }

    private boolean wasCopilotPriceUsed(SavedOffer o, SavedOffer prev) {
        if(isNewOffer(prev, o)){
            return o.getItemId() == offerManager.getLastViewedSlotItemId() && o.getPrice() == offerManager.getLastViewedSlotItemPrice() && Instant.now().minusSeconds(30).getEpochSecond() < offerManager.getLastViewedSlotPriceTime();
        } else {
            return prev.isCopilotPriceUsed();
        }
    }

    private boolean wasCopilotSuggestion(SavedOffer o, SavedOffer prev) {
        if(isNewOffer(prev, o)){
            return o.getItemId() == suggestionManager.getSuggestionItemIdOnOfferSubmitted() && o.getOfferStatus().equals(suggestionManager.getSuggestionOfferStatusOnOfferSubmitted());
        } else {
            return prev.isWasCopilotSuggestion();
        }
    }

    private void updateUncollected(Long accountHash, int slot, SavedOffer o, SavedOffer prev, boolean consistent) {
        if(!consistent) {
            return;
        }
        int uncollectedGp = 0;
        int uncollectedItems = 0;
        switch (o.getState()) {
            case BUYING:
            case BOUGHT:
                uncollectedItems = isNewOffer(prev, o) ? o.getQuantitySold() : o.getQuantitySold() - prev.getQuantitySold();
                break;
            case SOLD:
            case SELLING:
                uncollectedGp = (isNewOffer(prev, o) ? o.getQuantitySold() : o.getQuantitySold() - prev.getQuantitySold()) * o.getPrice();
                break;
            case CANCELLED_BUY:
                uncollectedGp = (o.getTotalQuantity() - o.getQuantitySold()) * o.getPrice();
                break;
            case CANCELLED_SELL:
                uncollectedItems = o.getTotalQuantity() - o.getQuantitySold();
                break;
            case EMPTY:
                // if the slot is empty we want to ensure that the un collected manager doesn't think there is something to collect
                // this can happen due to race conditions between the collection and offer fills timing
                grandExchangeUncollectedManager.ensureSlotClear(accountHash, slot);
                suggestionManager.setSuggestionNeeded(true);
                return;
        }
        grandExchangeUncollectedManager.addUncollected(accountHash, slot, o.getItemId(), uncollectedItems, uncollectedGp);

    }

    private void processTransactions() {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        if(displayName != null) {
            Transaction transaction;
            while ((transaction = transactionsToProcess.poll()) != null) {
                long profit = transactionManager.addTransaction(transaction, displayName);
                if (grandExchange.isHomeScreenOpen() && profit != 0) {
                    new GpDropOverlay(overlayManager, client, profit, transaction.getBoxId());
                }
            }
        }
    }

    public Transaction inferTransaction(int slot, SavedOffer offer, SavedOffer prev, boolean consistent) {
        boolean login = client.getTickCount() <= osrsLoginManager.getLastLoginTick() + GE_LOGIN_BURST_WINDOW;
        boolean isNewOffer = isNewOffer(prev, offer);
        int quantityDiff = isNewOffer ? offer.getQuantitySold() : offer.getQuantitySold() - prev.getQuantitySold();
        int amountSpentDiff = isNewOffer ? offer.getSpent() : offer.getSpent() - prev.getSpent();
        if (quantityDiff > 0 && amountSpentDiff > 0) {
            Transaction t = new Transaction();
            t.setId(UUID.randomUUID());
            t.setType(offer.getOfferStatus());
            t.setItemId(offer.getItemId());
            t.setPrice(offer.getPrice());
            t.setQuantity(quantityDiff);
            t.setBoxId(slot);
            t.setAmountSpent(amountSpentDiff);
            t.setTimestamp(Instant.now());
            t.setCopilotPriceUsed(offer.isCopilotPriceUsed());
            t.setWasCopilotSuggestion(offer.isWasCopilotSuggestion());
            t.setOfferTotalQuantity(offer.getTotalQuantity());
            t.setLogin(login);
            t.setConsistent(consistent);
            return t;
        }
        return null;
    }

    private boolean isConsistent(SavedOffer prev, SavedOffer updated) {
        if(prev == null) {
            return false;
        }
        if(updated.getState() == GrandExchangeOfferState.EMPTY) {
            return true;
        }
        if(prev.getState() == GrandExchangeOfferState.EMPTY && !(updated.getState() == GrandExchangeOfferState.CANCELLED_BUY || updated.getState() == GrandExchangeOfferState.CANCELLED_SELL)) {
            return true;
        }
        return prev.getOfferStatus() == updated.getOfferStatus() ||
                prev.getItemId() == updated.getItemId()
                || prev.getPrice() == updated.getPrice()
                || prev.getTotalQuantity() == updated.getTotalQuantity();
    }

    private boolean isNewOffer(SavedOffer prev, SavedOffer updated) {
        if (prev == null) {
            return true;
        }
        return prev.getOfferStatus() != updated.getOfferStatus() ||
                prev.getItemId() != updated.getItemId()
                || prev.getPrice() != updated.getPrice()
                || prev.getTotalQuantity() != updated.getTotalQuantity()
                || prev.getQuantitySold() > updated.getQuantitySold()
                || prev.getSpent() > updated.getSpent();
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.*;
import com.flippingcopilot.ui.graph.PriceGraphController;
import com.flippingcopilot.ui.graph.model.Data;
import com.google.gson.Gson;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;

@Slf4j
@Getter
@Setter
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SuggestionController {

    // dependencies
    private final PausedManager pausedManager;
    private final Client client;
    private final Gson gson;
    private final OsrsLoginManager osrsLoginManager;
    private final HighlightController highlightController;
    private final GrandExchange grandExchange;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler apiRequestHandler;
    private final Notifier notifier;
    private final OfferManager offerManager;
    private final CopilotLoginManager copilotLoginManager;
    private final ClientThread clientThread;
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final AccountStatusManager accountStatusManager;
    private final GrandExchangeUncollectedManager uncollectedManager;
    private final PriceGraphController graphPriceGraphController;

    private MainPanel mainPanel;
    private LoginPanel loginPanel;
    private CopilotPanel copilotPanel;
    private SuggestionPanel suggestionPanel;

    public void togglePause() {
        if (pausedManager.isPaused()) {
            pausedManager.setPaused(false);
            suggestionManager.setSuggestionNeeded(true);
            suggestionPanel.refresh();
        } else {
            pausedManager.setPaused(true);
            highlightController.removeAll();
            suggestionPanel.refresh();
        }
    }

    void onGameTick() {
        if(suggestionManager.isSuggestionRequestInProgress() || suggestionManager.isGraphDataReadingInProgress()) {
            return;
        }
        // There is a race condition when the collect button is hit at the same time as offers fill.
        // In such a case we can end up with the uncollectedManager falsely thinking there is items to collect.
        // We identify if this has happened here by checking if the collect button is actually visible.
        if(isUncollectedOutOfSync()) {
            log.warn("uncollected is out of sync, it thinks there are items to collect but the GE is open and the Collect button not visible");
            uncollectedManager.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionManager.setSuggestionNeeded(true);
        }
        // on initial login the state of the GE offers isn't correct we need to wait a couple ticks before requesting a suggestion
        if (osrsLoginManager.hasJustLoggedIn()) {
            return;
        }
        if ((suggestionManager.isSuggestionNeeded() || suggestionManager.suggestionOutOfDate()) && !(grandExchange.isSlotOpen() && !accountStatusManager.isSuggestionSkipped())) {
            getSuggestionAsync();
        }
    }

    private boolean isUncollectedOutOfSync() {
        if (client.getTickCount() <= uncollectedManager.getLastUncollectedAddedTick() + 2) {
            return false;
        }
        if(!grandExchange.isHomeScreenOpen() || grandExchange.isCollectButtonVisible()) {
            return false;
        }
        if(uncollectedManager.HasUncollected(osrsLoginManager.getAccountHash())) {
            return true;
        }
        if(suggestionPanel.isCollectItemsSuggested()) {
            return true;
        }
        return false;
    }

    public void getSuggestionAsync() {
        suggestionManager.setSuggestionNeeded(false);
        if (!copilotLoginManager.isLoggedIn() || !osrsLoginManager.isValidLoginState()) {
            return;
        }
        if (suggestionManager.isSuggestionRequestInProgress()) {
            return;
        }
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (accountStatus == null) {
            return;
        }
        suggestionManager.setSuggestionRequestInProgress(true);
        suggestionManager.setGraphDataReadingInProgress(true);
        Suggestion oldSuggestion = suggestionManager.getSuggestion();
        Consumer<Suggestion> suggestionConsumer = (newSuggestion) -> {
            suggestionManager.setSuggestion(newSuggestion);
            suggestionManager.setSuggestionError(null);
            suggestionManager.setSuggestionRequestInProgress(false);
            log.debug("Received suggestion: {}", newSuggestion.toString());
            accountStatusManager.resetSkipSuggestion();
            offerManager.setOfferJustPlaced(false);
            suggestionPanel.refresh();
            showNotifications(oldSuggestion, newSuggestion, accountStatus);
        };
        Consumer<Data> graphDataConsumer = (d) -> {
            graphPriceGraphController.setSuggestedItemGraphData(d);
            suggestionManager.setGraphDataReadingInProgress(false);
        };
        Consumer<HttpResponseException> onFailure = (e) -> {
            suggestionManager.setSuggestion(null);
            suggestionManager.setSuggestionError(e);
            suggestionManager.setSuggestionRequestInProgress(false);
            suggestionManager.setGraphDataReadingInProgress(false);
            if (e.getResponseCode() == 401) {
                copilotLoginManager.reset();
                mainPanel.refresh();
                loginPanel.showLoginErrorMessage("Login timed out. Please log in again");
            } else {
                suggestionPanel.refresh();
            }
        };
        suggestionPanel.refresh();
        log.debug("tick {} getting suggestion", client.getTickCount());
        apiRequestHandler.getSuggestionAsync(accountStatus.toJson(gson, grandExchange.isOpen(), config.priceGraphWebsite() == FlippingCopilotConfig.PriceGraphWebsite.FLIPPING_COPILOT), suggestionConsumer, graphDataConsumer, onFailure);
    }


    void showNotifications(Suggestion oldSuggestion, Suggestion newSuggestion, AccountStatus accountStatus) {
        if (shouldNotify(newSuggestion, oldSuggestion)) {
            if (config.enableTrayNotifications()) {
                notifier.notify(newSuggestion.toMessage());
            }
            if (!copilotPanel.isShowing() && config.enableChatNotifications()) {
                showChatNotifications(newSuggestion, accountStatus);
            }
        }
    }

    static boolean shouldNotify(Suggestion newSuggestion, Suggestion oldSuggestion) {
        if (newSuggestion.getType().equals("wait")) {
            return false;
        }
        if (oldSuggestion != null && newSuggestion.equals(oldSuggestion)) {
            return false;
        }
        return true;
    }

    private void showChatNotifications(Suggestion newSuggestion, AccountStatus accountStatus) {
        if (accountStatus.isCollectNeeded(newSuggestion)) {
            clientThread.invokeLater(() -> showChatNotification("Flipping Copilot: Collect items"));
        }
        clientThread.invokeLater(() -> showChatNotification(newSuggestion.toMessage()));
    }

    private void showChatNotification(String message) {
        String chatMessage = new ChatMessageBuilder()
                .append(config.chatTextColor(), message)
                .build();
        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", chatMessage, "");
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.SuggestionManager;
import net.runelite.api.Client;
import net.runelite.api.VarClientInt;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.KeyEvent;


@Singleton
public class KeybindHandler {

    private final KeyManager keyManager;
    private final FlippingCopilotConfig config;
    private final ClientThread clientThread;
    private final SuggestionManager suggestionManager;
    private final Client client;
    private final GrandExchange grandExchange;
    private final OfferHandler offerHandler;


    @Inject
    public KeybindHandler(KeyManager keyManager, FlippingCopilotConfig config, ClientThread clientThread, SuggestionManager suggestionManager, Client client, GrandExchange grandExchange, OfferHandler offerHandler) {
        this.keyManager = keyManager;
        this.config = config;
        this.clientThread = clientThread;
        this.suggestionManager = suggestionManager;
        this.client = client;
        this.grandExchange = grandExchange;
        this.offerHandler = offerHandler;
        keyManager.registerKeyListener(offerEditorKeyListener());
    }

    public void unregister() {
        keyManager.unregisterKeyListener(offerEditorKeyListener());
    }


    private KeyListener offerEditorKeyListener() {
        return new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {
                // Prevent enter as a keybind as that will also submit the value
                if (e.getKeyCode() == KeyEvent.VK_ENTER) return;
                if (e.getKeyCode() !=config.quickSetKeybind().getKeyCode()) return;

               clientThread.invokeLater(this::handleKeybind);
            }

            @Override
            public void keyReleased(KeyEvent e) {

            }

            private void handleKeybind() {
                var suggestion = suggestionManager.getSuggestion();

                var inputType = client.getVarcIntValue(VarClientInt.INPUT_TYPE);

                var isPriceOrQuantityBoxOpen =client.getWidget(ComponentID.CHATBOX_TITLE) != null
                        && inputType == 7
                        &&client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) != null
                        &&grandExchange.isSlotOpen();

                if (isPriceOrQuantityBoxOpen) {
                   offerHandler.setSuggestedAction(suggestion);
                }
            }
        };
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.graph.model.Data;
import com.google.gson.*;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Type;
import java.net.URLEncoder;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ApiRequestHandler {

    private static final String serverUrl = System.getenv("FLIPPING_COPILOT_HOST") != null ? System.getenv("FLIPPING_COPILOT_HOST")  : "https://api.flippingcopilot.com";
    public static final String DEFAULT_COPILOT_PRICE_ERROR_MESSAGE = "Unable to fetch price copilot price (possible server update)";
    public static final String DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE = "Error loading premium instance data (possible server update)";
    public static final String UNKNOWN_ERROR = "Unknown error";
    public static final int UNAUTHORIZED_CODE = 401;
    // dependencies
    private final OkHttpClient client;
    private final Gson gson;
    private final CopilotLoginManager copilotLoginManager;
    @Setter
    private CopilotLoginController copilotLoginController;
    private final SuggestionPreferencesManager preferencesManager;
    private final ClientThread clientThread;


    public void authenticate(String username, String password, Consumer<LoginResponse> successCallback, Consumer<String> failureCallback) {
        Request request = new Request.Builder()
                .url(serverUrl + "/login")
                .addHeader("Authorization", Credentials.basic(username, password))
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), ""))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                failureCallback.accept(UNKNOWN_ERROR);
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.warn("login failed with http status code {}", response.code());
                        String errorMessage = extractErrorMessage(response);
                        failureCallback.accept(errorMessage);
                        return;
                    }
                    String body = response.body() == null ? "" : response.body().string();
                    LoginResponse loginResponse = gson.fromJson(body, LoginResponse.class);
                    successCallback.accept(loginResponse);
                } catch (IOException | JsonParseException e) {
                    log.warn("error reading/decoding login response body", e);
                    failureCallback.accept(UNKNOWN_ERROR);
                }
            }
        });
    }

    public void getSuggestionAsync(JsonObject status,
                                   Consumer<Suggestion> suggestionConsumer,
                                   Consumer<Data> graphDataConsumer,
                                   Consumer<HttpResponseException>  onFailure) {
        log.debug("sending status {}", status.toString());
        Request request = new Request.Builder()
                .url(serverUrl + "/suggestion")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .addHeader("Accept", "application/x-msgpack")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), status.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("call to get suggestion failed", e);
                clientThread.invoke(() -> onFailure.accept(new HttpResponseException(-1, UNKNOWN_ERROR)));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.warn("get suggestion failed with http status code {}", response.code());
                        clientThread.invoke(() -> onFailure.accept(new HttpResponseException(response.code(), extractErrorMessage(response))));
                        return;
                    }
                    handleSuggestionResponse(response, suggestionConsumer, graphDataConsumer);
                } catch (Exception e) {
                    log.warn("error reading/parsing suggestion response body", e);
                    clientThread.invoke(() -> onFailure.accept(new HttpResponseException(-1, UNKNOWN_ERROR)));
                }
            }
        });
    }

    private void handleSuggestionResponse(Response response, Consumer<Suggestion> suggestionConsumer, Consumer<Data> graphDataConsumer) throws IOException {
        if (response.body() == null) {
            throw new IOException("empty suggestion request response");
        }
        String contentType = response.header("Content-Type");
        Suggestion s;
        if (contentType != null && contentType.contains("application/x-msgpack")) {
            int contentLength = resolveContentLength(response);
            int suggestionContentLength = resolveSuggestionContentLength(response);
            int graphDataContentLength = contentLength - suggestionContentLength;
            log.debug("msgpack suggestion response size is: {}, suggestion size is {}", contentLength, suggestionContentLength);

            Data d = new Data();
            try(InputStream is = response.body().byteStream()) {
                // This is some bespoke handling to make the user experience better. We basically pack two different
                // objects in the response body. The suggestion (first object) and the graph data (second
                // object). The graph data can be a few kb, and we want the suggestion to be displayed
                // immediately, without having to wait for the graph data to be loaded.

                byte[] suggestionBytes = new byte[suggestionContentLength];
                int bytesRead = is.readNBytes(suggestionBytes, 0, suggestionContentLength);
                if (bytesRead != suggestionContentLength) {
                    throw new IOException("failed to read complete suggestion content: " + bytesRead + " of " + suggestionContentLength + " bytes");
                }
                s = Suggestion.fromMsgPack(ByteBuffer.wrap(suggestionBytes));
                log.debug("suggestion received");
                clientThread.invoke(() -> suggestionConsumer.accept(s));

                if (graphDataContentLength == 0) {
                    d.loadingErrorMessage = "No graph data loaded for this item.";
                } else {
                    try {
                        byte[] remainingBytes = is.readAllBytes();
                        if (graphDataContentLength != remainingBytes.length) {
                            log.error("the graph data bytes read {} doesn't match the expected bytes {}", bytesRead, graphDataContentLength);
                            d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                        } else {
                            try {
                                d = Data.fromMsgPack(ByteBuffer.wrap(remainingBytes));
                                log.debug("graph data received");
                            } catch (Exception e) {
                                log.error("error deserializing graph data", e);
                                d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                            }
                        }
                    } catch (IOException e) {
                        log.error("error on reading graph data bytes from the suggestion response", e);
                        d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                    }
                }
            }
            if (s != null && "wait".equals(s.getType())){
                d.fromWaitSuggestion = true;
            }
            Data finalD = d;
            clientThread.invoke(() -> graphDataConsumer.accept(finalD));
        } else {
            String body = response.body().string();
            log.debug("json suggestion response size is: {}", body.getBytes().length);
            s = gson.fromJson(body, Suggestion.class);
            clientThread.invoke(() -> suggestionConsumer.accept(s));
            Data d = new Data();
            d.loadingErrorMessage = "No graph data loaded for this item.";
            clientThread.invoke(() -> graphDataConsumer.accept(d));
        }
    }

    private int resolveContentLength(Response resp) throws IOException {
        try {
            String cl = resp.header("Content-Length");
            return Integer.parseInt(cl != null ? cl : "missing Content-Length header");
        } catch (NumberFormatException  e) {
            throw new IOException("Failed to parse response Content-Length", e);
        }
    }

    private int resolveSuggestionContentLength(Response resp) throws IOException {
        try {
            String cl = resp.header("X-Suggestion-Content-Length");
            return Integer.parseInt(cl != null ? cl : "missing Content-Length header");
        } catch (NumberFormatException  e) {
            throw new IOException("Failed to parse response Content-Length", e);
        }
    }

    public void sendTransactionsAsync(List<Transaction> transactions, String displayName, BiConsumer<Integer, List<FlipV2>> onSuccess, Consumer<HttpResponseException> onFailure) {
        log.debug("sending {} transactions for display name {}", transactions.size(), displayName);
        JsonArray body = new JsonArray();
        for (Transaction transaction : transactions) {
            body.add(transaction.toJsonObject());
        }
        Integer userId = copilotLoginManager.getCopilotUserId();
        String encodedDisplayName = URLEncoder.encode(displayName, StandardCharsets.UTF_8);
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/client-transactions?display_name=" + encodedDisplayName)
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .header("Accept", "application/x-bytes")
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("call to sync transactions failed", e);
                onFailure.accept(new HttpResponseException(-1, UNKNOWN_ERROR));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.warn("call to sync transactions failed status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(new HttpResponseException(response.code(), errorMessage));
                        return;
                    }
                    List<FlipV2> changedFlips = FlipV2.listFromRaw(response.body().bytes());
                    onSuccess.accept(userId, changedFlips);
                } catch (Exception e) {
                    log.warn("error reading/parsing sync transactions response body", e);
                    onFailure.accept(new HttpResponseException(-1, UNKNOWN_ERROR));
                }
            }
        });
    }

    private String extractErrorMessage(Response response) {
        if (response.body() != null) {
            try {
                String bodyStr = response.body().string();
                JsonObject errorJson = gson.fromJson(bodyStr, JsonObject.class);
                if (errorJson.has("message")) {
                    return errorJson.get("message").getAsString();
                }
            } catch (Exception e) {
                log.warn("failed reading/parsing error message from http {} response body", response.code(), e);
            }
        }
        return UNKNOWN_ERROR;
    }

    public void asyncGetItemPriceWithGraphData(int itemId, String displayName, Consumer<ItemPrice> consumer, boolean includeGraphData) {
        JsonObject body = new JsonObject();
        body.add("item_id", new JsonPrimitive(itemId));
        body.add("display_name", new JsonPrimitive(displayName));
        body.addProperty("f2p_only", preferencesManager.getPreferences().isF2pOnlyMode());
        body.addProperty("timeframe_minutes", preferencesManager.getTimeframe());
        body.addProperty("include_graph_data", includeGraphData);
        log.debug("requesting price graph data for item {}", itemId);
        Request request = new Request.Builder()
                .url(serverUrl +"/prices")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .addHeader("Accept", "application/x-msgpack")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newBuilder()
                .callTimeout(30, TimeUnit.SECONDS) // Overall timeout
                .build()
                .newCall(request)
                .enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error fetching copilot price for item {}", itemId, e);
                ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                clientThread.invoke(() -> consumer.accept(ip));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("get copilot price for item {} failed with http status code {}", itemId, response.code());
                        ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                        clientThread.invoke(() -> consumer.accept(ip));
                    } else {
                        byte[] d = response.body().bytes();
                        ItemPrice ip = ItemPrice.fromMsgPack(ByteBuffer.wrap(d));
                        log.debug("price graph data received for item {}", itemId);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error fetching copilot price for item {}", itemId, e);
                    ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                    clientThread.invoke(() -> consumer.accept(ip));
                }
            }
        });
    }


    public void asyncUpdatePremiumInstances(Consumer<PremiumInstanceStatus> consumer, List<String> displayNames) {
        JsonObject payload = new JsonObject();
        JsonArray arr = new JsonArray();
        displayNames.forEach(arr::add);
        payload.add("premium_display_names", arr);

        Request request = new Request.Builder()
                .url(serverUrl +"/premium-instances/update-assignments")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), payload.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error updating premium instance assignments", e);
                clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("update premium instances failed with http status code {}", response.code());
                        clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                    } else {
                        PremiumInstanceStatus ip = gson.fromJson(response.body().string(), PremiumInstanceStatus.class);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error updating premium instance assignments", e);
                    clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                }
            }
        });
    }

    public void asyncGetPremiumInstanceStatus(Consumer<PremiumInstanceStatus> consumer) {
        Request request = new Request.Builder()
                .url(serverUrl +"/premium-instances/status")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .get()
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error fetching premium instance status", e);
                clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("get premium instance status failed with http status code {}", response.code());
                        clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                    } else {
                        PremiumInstanceStatus ip = gson.fromJson(response.body().string(), PremiumInstanceStatus.class);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error fetching premium instance status", e);
                    clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                }
            }
        });

    }

    public void asyncDeleteFlip(FlipV2 flip, Consumer<FlipV2> onSuccess, Runnable onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("flip_id", flip.getId().toString());

        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/delete-flip")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("deleting flip {}", flip.getId(), e);
                onFailure.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("deleting flip {}, bad response code {}", flip.getId(), response.code());
                        onFailure.run();
                    } else {
                        FlipV2 flip = FlipV2.fromRaw(response.body().bytes());
                        onSuccess.accept(flip);
                    }
                } catch (Exception e) {
                    log.error("deleting flip {}", flip.getId(), e);
                    onFailure.run();
               }
            }
        });
    }

    public void asyncDeleteAccount(int accountId, Runnable onSuccess, Runnable onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("account_id", accountId);

        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/delete-account")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("deleting account {}", accountId, e);
                onFailure.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("deleting account {}, bad response code {}", accountId, response.code());
                        onFailure.run();
                    }
                    onSuccess.run();
                } catch (Exception e) {
                    log.error("deleting account {}", accountId, e);
                    onFailure.run();
                }
            }
        });
    }

    public void asyncLoadAccounts(Consumer<Map<String, Integer>> onSuccess, Consumer<String> onFailure) {
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/rs-account-names")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .method("GET", null)
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error loading user display names", e);
                onFailure.accept(UNKNOWN_ERROR);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.error("load user display names failed with http status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(errorMessage);
                        return;
                    }
                    String responseBody = response.body() != null ? response.body().string() : "{}";
                    Type respType = new TypeToken<Map<String, Integer>>(){}.getType();
                    Map<String, Integer> names = gson.fromJson(responseBody, respType);
                    Map<String, Integer> result = names != null ? names : new HashMap<>();
                    onSuccess.accept(result);
                } catch (Exception e) {
                    log.error("error reading/parsing user display names response body", e);
                    onFailure.accept(UNKNOWN_ERROR);
                }
            }
        });
    }

    public void asyncLoadFlips(Map<Integer, Integer> accountIdTime, BiConsumer<Integer, FlipsDeltaResult> onSuccess, Consumer<String> onFailure) {
        Integer userId = copilotLoginManager.getCopilotUserId();
        DataDeltaRequest body = new DataDeltaRequest(accountIdTime);
        String bodyStr = gson.toJson(body);

        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/client-flips-delta")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .method("POST", RequestBody.create(MediaType.get("application/json; charset=utf-8"), bodyStr))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error loading flips", e);
                onFailure.accept(UNKNOWN_ERROR);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.error("load flips failed with http status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(errorMessage);
                        return;
                    }
                    FlipsDeltaResult res = FlipsDeltaResult.fromRaw(response.body().bytes());
                    onSuccess.accept(userId, res);
                } catch (Exception e) {
                    log.error("error reading/parsing flips response body", e);
                    onFailure.accept(UNKNOWN_ERROR);
                }
            }
        });
    }

    public void asyncLoadTransactionsData(Consumer<byte[]> onSuccess, Consumer<String> onFailure) {

        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/client-transactions")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .get()
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error loading transactions", e);
                onFailure.accept(UNKNOWN_ERROR);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.error("load transactions failed with http status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(errorMessage);
                        return;
                    }
                    byte[] data = response.body().bytes();
                    onSuccess.accept(Arrays.copyOfRange(data, 4, data.length-4));
                } catch (Exception e) {
                    log.error("error reading/parsing transactions response body", e);
                    onFailure.accept(UNKNOWN_ERROR);
                }
            }
        });
    }


    public void asyncOrphanTransaction(AckedTransaction transaction, BiConsumer<Integer, List<FlipV2>> onSuccess, Runnable onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("transaction_id", transaction.getId().toString());
        body.addProperty("account_id", transaction.getAccountId());
        Integer userId = copilotLoginManager.getCopilotUserId();
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/orphan-transaction")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("orphaning transaction {}", transaction.getId(), e);
                onFailure.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("orphaning transaction {}, bad response code {}", transaction.getId(), response.code());
                        onFailure.run();
                    } else {
                        List<FlipV2> flips = FlipV2.listFromRaw(response.body().bytes());
                        onSuccess.accept(userId, flips);
                    }
                } catch (Exception e) {
                    log.error("orphaning transaction {}", transaction.getId(), e);
                    onFailure.run();
                }
            }
        });
    }

    public void asyncLoadRecentAccountTransactions(String displayName, int endTime, Consumer<List<AckedTransaction>> onSuccess, Consumer<String> onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("limit", 30);
        body.addProperty("end", endTime);
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/account-client-transactions?display_name=" + displayName)
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error loading transactions", e);
                onFailure.accept(UNKNOWN_ERROR);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.error("load transactions failed with http status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(errorMessage);
                        return;
                    }
                    onSuccess.accept(AckedTransaction.listFromRaw(response.body().bytes()));
                } catch (Exception e) {
                    log.error("error reading/parsing transactions response body", e);
                    onFailure.accept(UNKNOWN_ERROR);
                }
            }
        });
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.DiscordWebhookBody;
import com.flippingcopilot.model.SessionData;
import com.flippingcopilot.model.Stats;
import com.flippingcopilot.ui.UIUtilities;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.Instant;

import static com.flippingcopilot.util.DateUtil.formatEpoch;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class WebHookController {

    private final FlippingCopilotConfig config;
    private final OkHttpClient okHttpClient;

    private void sendWebHook(DiscordWebhookBody discordWebhookBody) {
        String configURL = config.webhook();
        if (Strings.isNullOrEmpty(configURL)) {return; }

        HttpUrl url = HttpUrl.parse(configURL);
        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(discordWebhookBody));
        buildRequestAndSend(url, requestBodyBuilder);
    }

    private void buildRequestAndSend(HttpUrl url, MultipartBody.Builder requestBodyBuilder) {
        RequestBody requestBody = requestBodyBuilder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
        sendRequest(request);
    }

    private void sendRequest(Request request) {
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Error on webhook", e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                response.close();
            }
        });
    }

    public void sendMessage(Stats stats, SessionData sd, String displayName, boolean sessionIsFinished) {
        if (stats.profit != 0 && displayName != null) {

            long seconds = sd.durationMillis / 1000;
            String beganAtText = formatEpoch(sd.startTime);
            String endedAtText = sessionIsFinished ? formatEpoch(Instant.now().getEpochSecond()) : "n/a";
            String durationText = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            String profitText = UIUtilities.formatProfit(stats.profit);
            String taxText = UIUtilities.formatProfit(stats.taxPaid);
            String roiText = String.format("%.3f%%", stats.calculateRoi() * 100);
            String cashStackText = UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp";

            String template = "%s, your session stats are:\n" +
                    "```" +
                    "Session began at:      %s\n" +
                    "Session ended at:      %s\n" +
                    "Active session time:   %s\n" +
                    "Flips made:            %d\n" +
                    "Profit:                %s\n" +
                    "Tax paid:              %s\n" +
                    "Roi:                   %s\n" +
                    "Avg wealth:            %s\n" +
                    "```";

            String discordMessage = String.format(template, displayName, beganAtText, endedAtText, durationText, stats.flipsMade, profitText, taxText, roiText, cashStackText);
            DiscordWebhookBody discordWebhookBody = new DiscordWebhookBody();
            discordWebhookBody.setContent(discordMessage);
            sendWebHook(discordWebhookBody);
        }
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.*;

import java.nio.ByteBuffer;
import java.text.NumberFormat;

@Setter
@Getter
@AllArgsConstructor
@ToString
@NoArgsConstructor
public class Suggestion {
    private String type;
    @SerializedName("box_id")
    private int boxId;
    @SerializedName("item_id")
    private int itemId;
    private int price;
    private int quantity;
    private String name;
    @SerializedName("command_id")
    private int id;
    private String message;
    private Double expectedProfit;
    private Double expectedDuration;

    @SerializedName("graph_data")
    private Data graphData;


    public boolean equals(Suggestion other) {
        return this.type.equals(other.type)
                && this.boxId == other.boxId
                && this.itemId == other.itemId
                && this.name.equals(other.name);
    }

    public String toMessage() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String string = "Flipping Copilot: ";
        switch (type) {
            case "buy":
                string += String.format("Buy %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "sell":
                string += String.format("Sell %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "abort":
                string += "Abort " + name;
                break;
            case "wait":
                string += "Wait";
                break;
            default:
                string += "Unknown suggestion type";
                break;
        }
        return string;
    }

    public static Suggestion fromMsgPack(ByteBuffer b) {
        Suggestion s = new Suggestion();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }

        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "t":
                    s.type = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "b":
                    s.boxId = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "i":
                    s.itemId = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "p":
                    s.price = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "q":
                    s.quantity = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "n":
                    s.name = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "id":
                    s.id = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "m":
                    s.message = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "ed":
                    s.expectedDuration = (Double) MsgPackUtil.decodePrimitive(b);
                    break;
                case "ep":
                    s.expectedProfit = (Double) MsgPackUtil.decodePrimitive(b);
                    break;
                case "gd":
                    s.graphData = Data.fromMsgPack(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }

        return s;
    }
}



package com.flippingcopilot.model;
import com.flippingcopilot.util.Constants;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


// note: we synchronize all public methods of this class as they read/modify its state and may
// be called by multiple threads at the same time

@Slf4j
@Data
public class AccountStatus {

    private StatusOfferList offers;
    private Inventory inventory;
    private Map<Integer, Long> uncollected;
    private boolean isWorldMember = false;
    private boolean isAccountMember = false;
    private int skipSuggestion = -1;
    private String displayName;
    private Long rsAccountHash;
    private Boolean suggestionsPaused;
    private boolean sellOnlyMode = false;
    private boolean f2pOnlyMode = false;
    private List<Integer> blockedItems;
    private int timeframe = 5; // Default to 5 minutes

    public AccountStatus() {
        offers = new StatusOfferList();
        inventory = new Inventory();
    }

    public synchronized boolean isCollectNeeded(Suggestion suggestion) {
        if (offers.isEmptySlotNeeded(suggestion, isWorldMember || isAccountMember)) {
            log.debug("collected needed isEmptySlotNeeded");
            return true;
        }
        if (!inventory.hasSufficientGp(suggestion)) {
            log.debug("collected needed hasSufficientGp");
            return true;
        }
        if (!inventory.hasSufficientItems(suggestion)) {
            log.debug("collected needed hasSufficientItems");
            return true;
        }
        return false;
    }

    public int findEmptySlot() {
        return getOffers().findEmptySlot(isWorldMember || isAccountMember);
    }

    public synchronized JsonObject toJson(Gson gson, boolean geOpen, boolean sendGraphData) {
        JsonObject statusJson = new JsonObject();
        statusJson.addProperty("timeframe", 5);
        statusJson.addProperty("display_name", displayName);
        statusJson.addProperty("sell_only", sellOnlyMode);
        statusJson.addProperty("f2p_only", f2pOnlyMode);
        statusJson.addProperty("is_member", isWorldMember);
        statusJson.addProperty("is_account_member", isAccountMember);
        statusJson.addProperty("skip_suggestion", skipSuggestion);
        statusJson.addProperty("send_graph_data", sendGraphData);
        statusJson.addProperty("timeframe", timeframe);
        if (suggestionsPaused != null) {
            statusJson.addProperty("suggestions_paused", suggestionsPaused);
        }
        JsonArray offersJsonArray = offers.toJson(gson);
        JsonArray itemsJsonArray = getItemsJson();
        statusJson.add("offers", offersJsonArray);
        statusJson.add("items", itemsJsonArray);
        JsonArray blockItemsArray = new JsonArray();
        if(blockedItems != null) {
            blockedItems.forEach(blockItemsArray::add);
        }
        statusJson.add("blocked_items", blockItemsArray);

        Set<String> requestedSuggestionTypes = new HashSet<>();
        if (!geOpen) {
            requestedSuggestionTypes.add("abort");
        } else if(sellOnlyMode) {
            requestedSuggestionTypes.add("abort");
            requestedSuggestionTypes.add("sell");
        }
        if(!requestedSuggestionTypes.isEmpty()) {
           JsonArray rstArray = new JsonArray();
           requestedSuggestionTypes.forEach(rstArray::add);
           statusJson.add("requested_suggestion_types", rstArray);
        }
        return statusJson;
    }

    private JsonArray getItemsJson() {
        Map<Integer, Long> itemsAmount = getItemAmounts();
        JsonArray itemsJsonArray = new JsonArray();
        for(Map.Entry<Integer, Long> entry : itemsAmount.entrySet()) {
            JsonObject itemJson = new JsonObject();
            itemJson.addProperty("item_id", entry.getKey());
            itemJson.addProperty("amount", entry.getValue());
            itemsJsonArray.add(itemJson);
        }
        return itemsJsonArray;
    }

    private Map<Integer, Long> getItemAmounts() {
        Map<Integer, Long> itemsAmount = inventory.getItemAmounts();
        uncollected.forEach((key, value) -> itemsAmount.merge(key, value, Long::sum));
        itemsAmount.entrySet().removeIf(entry -> entry.getValue() == 0);
        return itemsAmount;
    }

    public synchronized boolean moreGpNeeded() {
        return emptySlotExists() && getTotalGp() < Constants.MIN_GP_NEEDED_TO_FLIP;
    }

    public synchronized boolean emptySlotExists() {
        return offers.emptySlotExists(isWorldMember || isAccountMember);
    }

    private long getTotalGp() {
        return inventory.getTotalGp() + offers.getTotalGpToCollect();
    }

    public synchronized boolean currentlyFlipping() {
        return offers.stream().anyMatch(Offer::isActive);
    }

    public synchronized long currentCashStack() {
        // the cash stack is the gp in their inventory + the value on the market
        // todo: when a buy offer has fully finished its value will not count towards the cash stack
        //  size until they start selling it. We should probably track items that where recently bought
        //  and they should still count towards the cash stack size for some period of time
        return offers.getGpOnMarket() + inventory.getTotalGp();
    }
}

package com.flippingcopilot.model;

import lombok.Getter;

import java.io.IOException;

@Getter
public class HttpResponseException extends IOException {
    private final int responseCode;
    private final String responseMessage;

    public HttpResponseException(int responseCode, String message) {
        super(message);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }

    public HttpResponseException(int responseCode, String message, Throwable cause) {
        super(message, cause);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }
}
package com.flippingcopilot.model;

import com.google.common.base.MoreObjects;

public enum FlipStatus {
    BUYING,
    SELLING,
    FINISHED;

    public static FlipStatus fromValue(String value) {
        switch (MoreObjects.firstNonNull(value, "").toUpperCase()) {
            case "O":
                return FlipStatus.BUYING;
            case "C":
                return FlipStatus.SELLING;
            case "F":
                return FlipStatus.FINISHED;
            default:
                return FlipStatus.BUYING;
        }
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.ui.FuzzySearchScorer;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SuggestionPreferencesManager {

    private static final String SHARED_PREFERENCES_FILE = "shared_preferences.json";

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    private SuggestionPreferences sharedPreferences;
    
    public synchronized SuggestionPreferences getPreferences() {
        if (sharedPreferences == null) {
            sharedPreferences = load();

            // Set these false reduce avoid user error
            sharedPreferences.setF2pOnlyMode(false);
            sharedPreferences.setSellOnlyMode(false);
        }
        return sharedPreferences;
    }

    public synchronized void setSellOnlyMode(boolean sellOnlyMode) {
        SuggestionPreferences preferences = getPreferences();
        preferences.setSellOnlyMode(sellOnlyMode);
        saveAsync();
        log.debug("Sell only mode is now: {}", sellOnlyMode);
    }

    public synchronized void setF2pOnlyMode(boolean f2pOnlyMode) {
        SuggestionPreferences preferences = getPreferences();
        preferences.setF2pOnlyMode(f2pOnlyMode);
        saveAsync();
        log.debug("F2p only mode is now: {}", f2pOnlyMode);
    }

    public synchronized void setTimeframe(int minutes) {
        SuggestionPreferences preferences = getPreferences();
        preferences.setTimeframe(minutes);
        saveAsync();
        log.debug("Timeframe is now: {} minutes", minutes);
    }

    public synchronized int getTimeframe() {
        return getPreferences().getTimeframe();
    }

    public synchronized void setBlockedItems(Set<Integer> blockedItems) {
        SuggestionPreferences preferences = getPreferences();
        preferences.setBlockedItemIds(new ArrayList<>(blockedItems));
        saveAsync();
    }

    public synchronized void blockItem(int itemId) {
        SuggestionPreferences preferences = getPreferences();
        List<Integer> blockedList = preferences.getBlockedItemIds();
        if(blockedList == null) {
            blockedList = new ArrayList<>();
        }
        if(!blockedList.contains(itemId)) {
            blockedList.add(itemId);
        }
        preferences.setBlockedItemIds(blockedList);
        saveAsync();
        log.debug("blocked item {}", itemId);
    }

    public synchronized void unblockItem(int itemId) {
        SuggestionPreferences preferences = getPreferences();
        List<Integer> blockedList = preferences.getBlockedItemIds();
        if(blockedList == null) {
            blockedList = new ArrayList<>();
        }
        blockedList.removeIf(i -> i==itemId);
        preferences.setBlockedItemIds(blockedList);
        saveAsync();
        log.debug("unblocked item {}", itemId);
    }

    public List<Integer> blockedItems() {
        return getPreferences().getBlockedItemIds();
    }

    private SuggestionPreferences load() {
        File file = getSharedFile();
        if (!file.exists()) {
            SuggestionPreferences merged = mergeExistingPreferences();
            sharedPreferences = merged;
            saveAsync();
            return merged;
        }
        
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, SuggestionPreferences.class);
        } catch (FileNotFoundException ignored) {
            return new SuggestionPreferences();
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading preferences json file {}", file, e);
            return new SuggestionPreferences();
        }
    }

    private SuggestionPreferences mergeExistingPreferences() {
        SuggestionPreferences mergedPreferences = new SuggestionPreferences();
        Set<Integer> mergedBlockedItems = new HashSet<>();

        File parentDir = Persistance.PARENT_DIRECTORY;
        if (!parentDir.exists()) {
            return mergedPreferences;
        }

        File[] files = parentDir.listFiles((dir, name) -> name.matches("acc_-?\\d+_preferences\\.json"));
        if (files != null) {
            for (File file : files) {
                try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                    SuggestionPreferences accountPrefs = gson.fromJson(reader, SuggestionPreferences.class);
                    if (accountPrefs != null && accountPrefs.getBlockedItemIds() != null) {
                        mergedBlockedItems.addAll(accountPrefs.getBlockedItemIds());
                    }
                } catch (Exception e) {
                    log.warn("Error reading preferences file {} during merge", file, e);
                }
            }
        }

        mergedPreferences.setBlockedItemIds(new ArrayList<>(mergedBlockedItems));
        log.info("Merged preferences from {} existing account files", files != null ? files.length : 0);
        return mergedPreferences;
    }

    private void saveAsync() {
        executorService.submit(() -> {
            File file = getSharedFile();
            synchronized (file) {
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(sharedPreferences);
                    writer.write(json);
                    writer.newLine();
                } catch (IOException e) {
                    log.warn("error saving preferences json file {}", file, e);
                }
            }
        });
    }

    private File getSharedFile() {
        return new File(Persistance.PARENT_DIRECTORY, SHARED_PREFERENCES_FILE);
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SessionManager {

    public static final String SESSION_DATA_FILE_TEMPLATE = "%s_session_data.jsonl";

    private final OsrsLoginManager osrsLoginManager;
    private final ScheduledExecutorService executorService;
    private final Gson gson;

    private final Map<String, SessionData> cachedSessionData =  new HashMap<>();
    private final Map<String, File> displayNameToFile = new HashMap<>();

    private Instant lastSessionUpdateTime;

    public synchronized SessionData getCachedSessionData() {
        SessionData sd = getSessionData(osrsLoginManager.getPlayerDisplayName());
        return new SessionData(sd.startTime,  sd.durationMillis, sd.averageCash);
    }

    public synchronized void resetSession() {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        SessionData sd = getSessionData(displayName);
        sd.startTime = (int) Instant.now().getEpochSecond();
        sd.averageCash = 0;
        sd.durationMillis = 0;
        saveAsync(displayName);
    }

    public synchronized boolean updateSessionStats(boolean currentlyFlipping, long cashStack) {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        if (!currentlyFlipping || displayName == null) {
            lastSessionUpdateTime = null;
            return false;
        } else if (lastSessionUpdateTime == null) {
            lastSessionUpdateTime = Instant.now();
            return false;
        } else {
            SessionData sd = getSessionData(displayName);
            Instant now = Instant.now();
            long duration = Duration.between(lastSessionUpdateTime, now).toMillis();
            long newAverageCashStack = (cashStack * duration + sd.durationMillis * sd.averageCash) / (sd.durationMillis + duration);
            sd.durationMillis = sd.durationMillis + duration;
            lastSessionUpdateTime = now;
            sd.averageCash = newAverageCashStack;
            saveAsync(displayName);
            return true;
        }
    }

    private void saveAsync(String displayName) {
        executorService.submit(() -> {
            File file = getFile(displayName);
            synchronized (file) {
                SessionData data = cachedSessionData.computeIfAbsent(displayName, this::load);
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(data);
                    writer.write(json);
                    writer.newLine();
                } catch (IOException e) {
                    log.warn("error storing session data to file {}", file, e);
                }
            }
        });
    }

     private SessionData load(String displayName) {
        File file = getFile(displayName);
        if (!file.exists()) {
            return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            SessionData sd =  gson.fromJson(reader, SessionData.class);
            if (sd != null) {
                return sd;
            }
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading session data json file {}", file, e);
        }
        return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
    }

    private File getFile(String displayName) {
        return displayNameToFile.computeIfAbsent(displayName,
                (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(SESSION_DATA_FILE_TEMPLATE, Persistance.hashDisplayName(displayName))));
    }

    private SessionData getSessionData(String displayName) {
         return cachedSessionData.computeIfAbsent(displayName, this::load);
    }

    public synchronized void reset() {
        lastSessionUpdateTime = null;
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.util.MutableReference;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class TransactionManager {

    // dependencies
    private final FlipManager flipManager;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler api;
    private final CopilotLoginManager copilotLoginManager;
    private final OsrsLoginManager osrsLoginManager;

    // state
    private final ConcurrentMap<String, List<Transaction>> cachedUnAckedTransactions = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, AtomicBoolean> transactionSyncScheduled = new ConcurrentHashMap<>();

    public void syncUnAckedTransactions(String displayName) {

        long s = System.nanoTime();
        List<Transaction> toSend;
        synchronized (this) {
            toSend = new ArrayList<>(getUnAckedTransactions(displayName));
            if(toSend.isEmpty()) {
                transactionSyncScheduled.get(displayName).set(false);
                return;
            }
        }

        BiConsumer<Integer, List<FlipV2>> onSuccess = (userId, flips) -> {
            if(!flips.isEmpty()) {
                copilotLoginManager.addAccountIfMissing(flips.get(0).getAccountId(), displayName, userId);
            }
            flipManager.mergeFlips(flips, userId);
            log.info("sending {} transactions took {}ms", toSend.size(), (System.nanoTime() - s) / 1000_000);
            synchronized (this) {
                List<Transaction> unAckedTransactions  = getUnAckedTransactions(displayName);
                transactionSyncScheduled.get(displayName).set(false);
                toSend.forEach(unAckedTransactions::remove);
                if(!unAckedTransactions.isEmpty()) {
                    scheduleSyncIn(0, displayName);
                }
            }
        };

        Consumer<HttpResponseException> onFailure = (e) -> {
            synchronized (this) {
                transactionSyncScheduled.get(displayName).set(false);
            }
            String currentDisplayName = osrsLoginManager.getPlayerDisplayName();
            if (copilotLoginManager.isLoggedIn() && (currentDisplayName == null || currentDisplayName.equals(displayName))) {
                log.warn("failed to send transactions to copilot server {}", e.getMessage(), e);
                scheduleSyncIn(10, displayName);
            }
        };
        api.sendTransactionsAsync(toSend, displayName, onSuccess, onFailure);
    }

    public long addTransaction(Transaction transaction, String displayName) {
        synchronized (this) {
            List<Transaction> unAckedTransactions = getUnAckedTransactions(displayName);
            unAckedTransactions.add(transaction);
            Persistance.storeUnAckedTransactions(unAckedTransactions, displayName);
        }
        MutableReference<Long> profit = new MutableReference<>(0L);
        if (OfferStatus.SELL.equals(transaction.getType())) {
            Integer accountId = copilotLoginManager.getAccountId(displayName);
            if (accountId != null && accountId != -1) {
                Long p = flipManager.estimateTransactionProfit(accountId, transaction);
                if (p != null) {
                    profit.setValue(p);
                }
            }
        }
        if (copilotLoginManager.isLoggedIn()) {
            scheduleSyncIn(0, displayName);
        }
        return profit.getValue();
    }

    public List<Transaction> getUnAckedTransactions(String displayName) {
        return cachedUnAckedTransactions.computeIfAbsent(displayName, (k) -> Persistance.loadUnAckedTransactions(displayName));
    }

    public synchronized void scheduleSyncIn(int seconds, String displayName) {
        AtomicBoolean scheduled = transactionSyncScheduled.computeIfAbsent(displayName, k -> new AtomicBoolean(false));
        if(scheduled.compareAndSet(false, true)) {
            log.info("scheduling {} attempt to sync {} transactions in {}s", displayName, getUnAckedTransactions(displayName).size(), seconds);
            executorService.schedule(() ->  {
                this.syncUnAckedTransactions(displayName);
            }, seconds, TimeUnit.SECONDS);
        } else {
            log.debug("skipping scheduling sync as already scheduled");
        }
    }
}

package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ItemIdName {
    public final Integer itemId;
    public final String name;
}

package com.flippingcopilot.model;

import lombok.Getter;
import lombok.Setter;

import javax.inject.Singleton;
import java.time.Instant;

@Singleton
@Getter
@Setter
public class SuggestionManager {

    private volatile boolean suggestionNeeded;
    private volatile boolean suggestionRequestInProgress;
    private volatile boolean graphDataReadingInProgress;
    private Instant lastFailureAt;
    private HttpResponseException suggestionError;
    private Suggestion suggestion;
    private Instant suggestionReceivedAt;
    private int lastOfferSubmittedTick = -1;

    // these two variables get set based on the current suggestion when the confirm offer button is clicked.
    // this allows us to track on the subsequent offer events whether the offer originates from a copilot suggestion
    // this flag can then eventually be propagated onto each transaction and can be used by the server to
    // determine which items in the inventory were bought based upon copilot suggestions and which are not
    private int suggestionItemIdOnOfferSubmitted = -1;
    private OfferStatus suggestionOfferStatusOnOfferSubmitted = null;


    public void setSuggestion(Suggestion suggestion) {
        this.suggestion = suggestion;
        suggestionReceivedAt = Instant.now();

    }

    public void setSuggestionError(HttpResponseException error) {
        this.suggestionError = error;
        lastFailureAt= Instant.now();
    }

    public void reset() {
        suggestionNeeded = false;
        suggestion = null;
        suggestionReceivedAt = null;
        lastFailureAt = null;
        lastOfferSubmittedTick = -1;
        suggestionError = null;
        suggestionItemIdOnOfferSubmitted = -1;
        suggestionOfferStatusOnOfferSubmitted = null;
    }

    public boolean suggestionOutOfDate() {
        Instant tenSecondsAgo = Instant.now().minusSeconds(10L);
        if (suggestionReceivedAt == null || tenSecondsAgo.isAfter(suggestionReceivedAt)) {
            return lastFailureAt == null || tenSecondsAgo.isAfter(lastFailureAt);
        }
        return false;
    }
}

package com.flippingcopilot.model;

import net.runelite.api.*;
import net.runelite.api.ItemID;
import static com.flippingcopilot.util.Constants.PLATINUM_TOKEN_VALUE;

import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Collectors;


public class Inventory extends ArrayList<RSItem> {

    boolean hasSufficientGp(Suggestion suggestion) {
        return !suggestion.getType().equals("buy")
                || getTotalGp() >= (long) suggestion.getPrice() * suggestion.getQuantity();
    }

    boolean hasSufficientItems(Suggestion suggestion) {
        return !suggestion.getType().equals("sell")
                || getTotalAmount(suggestion.getItemId()) >= suggestion.getQuantity();
    }

    public long getTotalGp() {
        return getTotalAmount(ItemID.COINS_995) + PLATINUM_TOKEN_VALUE * getTotalAmount(ItemID.PLATINUM_TOKEN);
    }

    public long getTotalAmount(long itemId) {
        long amount = 0;
        for (RSItem item : this) {
            if (item.getId() == itemId) {
                amount += item.getAmount();
            }
        }
        return amount;
    }


    public static Inventory fromRunelite(ItemContainer inventory, Client client) {
        Inventory unnotedItems = new Inventory();
        Item[] items = inventory.getItems();
        for (Item item : items) {
            if (item.getId() == -1) {
                continue;
            }
            unnotedItems.add(RSItem.getUnnoted(item, client));
        }
        return unnotedItems;
    }

    Map<Integer, Long> getItemAmounts() {
        return stream().collect(Collectors.groupingBy(RSItem::getId,
                        Collectors.summingLong(RSItem::getAmount)));
    }

    public void mergeItem(RSItem i) {
        for(RSItem item : this) {
            if(item.id == i.id) {
                item.amount += i.amount;
                return;
            }
        }
        add(i);
    }

     public boolean missingJustCollected( Map<Integer, Long> inLimboItems) {
         for (Map.Entry<Integer, Long> entry : inLimboItems.entrySet()) {
             Integer itemId = entry.getKey();
             Long qty = entry.getValue();
             if (qty > 0) {
                 long inventoryQty = getTotalAmount(itemId);
                 if (inventoryQty < qty) {
                     return true;
                 }
             }
         }
         return false;
    }
}

package com.flippingcopilot.model;

import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
public class SuggestionPreferences {

    private boolean f2pOnlyMode = false;
    private boolean sellOnlyMode = false;
    private List<Integer> blockedItemIds = new ArrayList<>();
    private int timeframe = 5;
}

package com.flippingcopilot.model;

import com.flippingcopilot.util.GeTax;
import lombok.Data;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@Data
public class FlipV2 {

    public static final int RAW_SIZE = 84;

    private UUID id;
    private int accountId;
    private int itemId;
    private int openedTime;
    private int openedQuantity;
    private long spent;
    private int closedTime;
    private int closedQuantity;
    private long receivedPostTax;
    private long profit;
    private long taxPaid;
    private FlipStatus status;
    private int updatedTime;
    private boolean deleted;

    private String cachedItemName;

    public FlipV2 setCachedItemName(String cachedItemName) {
        this.cachedItemName = cachedItemName;
        return this;
    }

    public long calculateProfit(Transaction transaction) {
        long amountToClose = Math.min(openedQuantity - closedQuantity, transaction.getQuantity());
        if(amountToClose <= 0 ){
            return 0;
        }
        long gpOut = (spent * amountToClose) / openedQuantity;
        int sellPrice  = transaction.getAmountSpent() / transaction.getQuantity();
        int sellPricePostTax = GeTax.getPostTaxPrice(transaction.getItemId(), sellPrice);
        long gpIn = amountToClose * sellPricePostTax;
        return gpIn - gpOut;
    }

    public long getAvgBuyPrice() {
        if (spent == 0) {
            return 0;
        }
        return spent / openedQuantity ;
    }

    public long getAvgSellPrice() {
        if (receivedPostTax == 0) {
            return 0;
        }
        return (receivedPostTax  + taxPaid) / closedQuantity;
    }

    public static List<FlipV2> listFromRaw(byte[] raw) {
        if (raw.length < 4) {
            throw new IllegalArgumentException("Raw data must be at least 4 bytes to contain record count");
        }

        ByteBuffer b = ByteBuffer.wrap(raw);
        b.order(ByteOrder.BIG_ENDIAN);

        // Read the number of records (int32)
        int recordCount = b.getInt();
        int expectedSize = 4 + (recordCount * RAW_SIZE);
        if (raw.length != expectedSize) {
            throw new IllegalArgumentException("Raw data size " + raw.length + " doesn't match expected size " + expectedSize + " for " + recordCount + " records");
        }
        List<FlipV2> flips = new ArrayList<>(recordCount);
        for (int i = 0; i < recordCount; i++) {
            byte[] recordBytes = new byte[RAW_SIZE];
            b.get(recordBytes);
            flips.add(fromRaw(recordBytes));
        }

        return flips;
    }

    public static FlipV2 fromRaw(byte[] raw) {
        if (raw.length != RAW_SIZE) {
            throw new IllegalArgumentException("Raw data must be exactly " + RAW_SIZE + " bytes");
        }

        ByteBuffer b = ByteBuffer.wrap(raw);
        b.order(ByteOrder.BIG_ENDIAN);
        FlipV2 flip = new FlipV2();

        // Read UUID (16 bytes)
        long idMostSig = b.getLong();
        long idLeastSig = b.getLong();
        flip.id = new UUID(idMostSig, idLeastSig);

        // Read primitive fields
        flip.accountId = b.getInt();           // 4 bytes
        flip.itemId = b.getInt();              // 4 bytes
        flip.openedTime = b.getInt();          // 4 bytes
        flip.openedQuantity = b.getInt();      // 4 bytes
        flip.spent = b.getLong();              // 8 bytes
        flip.closedTime = b.getInt();          // 4 bytes
        flip.closedQuantity = b.getInt();      // 4 bytes
        flip.receivedPostTax = b.getLong();    // 8 bytes
        flip.profit = b.getLong();             // 8 bytes
        flip.taxPaid = b.getLong();            // 8 bytes

        // Read FlipStatus as int32 ordinal
        int statusOrdinal = b.getInt();        // 4 bytes
        flip.status = FlipStatus.values()[statusOrdinal];

        flip.updatedTime = b.getInt();         // 4 bytes
        flip.deleted = b.getInt() > 0;

        return flip;
    }

    public boolean isClosed() {
        return Objects.equals(status, FlipStatus.FINISHED);
    }

    public int lastTransactionTime() {
        return closedTime == 0 ? openedTime : closedTime;
    }
}
package com.flippingcopilot.model;

import lombok.Data;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;

import java.util.Objects;

@Data
public class SavedOffer
{
	private int itemId;
	private int quantitySold;
	private int totalQuantity;
	private int price;
	private int spent;
	private GrandExchangeOfferState state;
	private boolean copilotPriceUsed;
	private boolean wasCopilotSuggestion;


	public static SavedOffer fromGrandExchangeOffer(GrandExchangeOffer offer) {
		SavedOffer o =  new SavedOffer();
		o.setItemId(offer.getItemId());
		o.setQuantitySold(offer.getQuantitySold());
		o.setTotalQuantity(offer.getTotalQuantity());
		o.setPrice(offer.getPrice());
		o.setSpent(offer.getSpent());
		o.setState(offer.getState());
		return o;
	}

	public OfferStatus getOfferStatus() {
		switch (state) {
			case SELLING:
			case CANCELLED_SELL:
			case SOLD:
				return OfferStatus.SELL;
			case BUYING:
			case CANCELLED_BUY:
			case BOUGHT:
				return OfferStatus.BUY;
			default:
				return OfferStatus.EMPTY;
		}
	}

	public boolean isFreeSlot() {
		switch (state) {
			case CANCELLED_SELL:
			case CANCELLED_BUY:
			case EMPTY:
			case BOUGHT:
			case SOLD:
				return true;
			default:
				return false;
		}
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		SavedOffer that = (SavedOffer) o;
		return itemId == that.itemId && quantitySold == that.quantitySold && totalQuantity == that.totalQuantity && price == that.price && spent == that.spent && state == that.state;
	}

	@Override
	public int hashCode() {
		return Objects.hash(itemId, quantitySold, totalQuantity, price, spent, state, copilotPriceUsed);
	}
}

package com.flippingcopilot.model;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;

@Getter
@AllArgsConstructor
public class RSItem {
    int id;
    long amount;

    static RSItem getUnnoted(Item item, Client client) {
        int itemId = item.getId();
        ItemComposition itemComposition = client.getItemDefinition(itemId);
        if (itemComposition.getNote() != -1) {
            itemId = itemComposition.getLinkedNoteId();
        }
        return new RSItem(itemId, item.getQuantity());
    }
}
package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import net.runelite.api.GrandExchangeOfferState;

public enum OfferStatus {
    @SerializedName("sell")
    SELL,
    @SerializedName("buy")
    BUY,
    @SerializedName("empty")
    EMPTY;

    static OfferStatus fromRunelite(GrandExchangeOfferState state) {
        OfferStatus status;
        switch (state) {
            case SELLING:
            case CANCELLED_SELL:
            case SOLD:
                status = SELL;
                break;
            case BUYING:
            case CANCELLED_BUY:
            case BOUGHT:
                status = BUY;
                break;
            default:
                status = EMPTY;
        }
        return status;
    }
}

package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.List;

@Data
@NoArgsConstructor
public class FlipsDeltaResult {

    public int time;
    public List<FlipV2> flips;

    public static FlipsDeltaResult fromRaw(byte[] raw) {
        FlipsDeltaResult res = new FlipsDeltaResult();
        ByteBuffer b = ByteBuffer.wrap(Arrays.copyOfRange(raw, 0, 4));
        b.order(ByteOrder.BIG_ENDIAN);
        res.time = b.getInt();
        res.flips = FlipV2.listFromRaw(Arrays.copyOfRange(raw, 4, raw.length));
        return res;
    }
}

package com.flippingcopilot.model;

import com.google.gson.JsonObject;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;


@Getter
@AllArgsConstructor
@NoArgsConstructor
@Setter
public class Transaction {

    private UUID id;
    private OfferStatus type;
    private int itemId;
    private int price;
    private int quantity;
    private int boxId;
    private int amountSpent;
    private Instant timestamp;
    private boolean copilotPriceUsed;
    private boolean wasCopilotSuggestion;
    private int offerTotalQuantity;
    private boolean login;
    private boolean consistent;
    private boolean geTransactionAlreadyAdded;

    public boolean equals(Transaction other) {
        return this.type == other.type &&
                this.itemId == other.itemId &&
                this.price == other.price &&
                this.quantity == other.quantity &&
                this.boxId == other.boxId &&
                this.amountSpent == other.amountSpent;
    }

    public JsonObject toJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty("id", id.toString());
        jsonObject.addProperty("item_id", itemId);
        jsonObject.addProperty("price", price);
        jsonObject.addProperty("quantity", type.equals(OfferStatus.BUY) ? quantity : -quantity);
        jsonObject.addProperty("box_id", boxId);
        jsonObject.addProperty("amount_spent", amountSpent);
        jsonObject.addProperty("time", timestamp.getEpochSecond());
        jsonObject.addProperty("copilot_price_used", copilotPriceUsed);
        jsonObject.addProperty("was_copilot_suggestion", wasCopilotSuggestion);
        jsonObject.addProperty("consistent_previous_offer", consistent);
        jsonObject.addProperty("login", login);
        return jsonObject;
    }

    @Override
    public String toString() {
        return String.format("%s %d %d on slot %d", type, quantity, itemId, boxId);
    }
}



package com.flippingcopilot.model;

import com.flippingcopilot.util.MutableReference;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemID;

import java.util.*;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @javax.inject.Inject)
public class GrandExchangeUncollectedManager {

    // dependencies
    private final Client client;

    // stated
    private int lastUncollectedAddedTick = -1;
    private int lastClearedTick = -1;
    private final Map<Integer, Long> lastClearedUncollected = new HashMap<>();
    private final List<Integer> lastClearedSlots = new ArrayList<>();
    // accountId -> [slot -> [itemID -> quantity]]
    private final Map<Long, Map<Integer, Map<Integer, Long>>> uncollected = new HashMap<>();

    public synchronized boolean HasUncollected(Long accountHash) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        MutableReference<Boolean> hasUncollected = new MutableReference<>(false);
        slotToUncollected.forEach((slot, itemToQty) -> {
            itemToQty.forEach((i, q) -> {
                if(q > 0) {
                    log.debug("{} slot {} item {} uncollected {}", accountHash, slot, i, q);
                    hasUncollected.setValue(true);
                }
            });
        });
        return hasUncollected.getValue();
    }

    public synchronized Map<Integer, Long> loadAllUncollected(Long accountHash) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        Map<Integer, Long> itemIdToQuantity = new HashMap<>();
        slotToUncollected.values().forEach(itemIdToQty -> itemIdToQty.forEach((k, v) -> itemIdToQuantity.merge(k, v, Long::sum)));
        return itemIdToQuantity;
    }

    public synchronized Map<Integer, Long> loadSlotUncollected(Long accountHash, Integer slot) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToUncollected.computeIfAbsent(slot, (k) -> new HashMap<>());
    }

    public synchronized void addUncollected(Long accountHash, Integer slot, int itemId, long quantity, long gp) {
        lastUncollectedAddedTick = client.getTickCount();
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        Map<Integer, Long> itemIdToQuantity = slotToUncollected.computeIfAbsent(slot, (k) -> new HashMap<>());
        if (!itemIdToQuantity.containsKey(itemId)) {
           // must be a new offer
           itemIdToQuantity.clear();
        }
        if(quantity > 0) {
            log.debug("tick {} added {} of item {} to uncollected", client.getTickCount(), itemId, quantity);
            itemIdToQuantity.merge(itemId, quantity, Long::sum);
        }
        if (gp > 0) {
            log.debug("tick {} added {} gp to uncollected", client.getTickCount(), gp);
            itemIdToQuantity.merge(ItemID.COINS_995, gp, Long::sum);
        }
    }

    public synchronized void ensureSlotClear(Long accountHash, int slot) {
        Map<Integer, Long> slotUncollected = loadSlotUncollected(accountHash, slot);
        slotUncollected.remove(slot);
    }

    public synchronized void clearSlotUncollected(Long accountHash, int slot) {
        Map<Integer, Long> slotUncollected = loadSlotUncollected(accountHash, slot);
        int tick = client.getTickCount();
        if(tick != lastClearedTick) {
            lastClearedUncollected.clear();
            lastClearedSlots.clear();
            lastClearedTick = tick;
        }
        lastClearedSlots.add(slot);
        slotUncollected.forEach((key, value) -> lastClearedUncollected.merge(key, value, Long::sum));
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        slotToUncollected.remove(slot);
    }

    public synchronized void clearAllUncollected(Long accountHash) {
        log.debug("tick {} clearAllUncollected", client.getTickCount());
        Map<Integer, Long> allUncollected = loadAllUncollected(accountHash);
        int tick = client.getTickCount();
        if(tick != lastClearedTick) {
            lastClearedUncollected.clear();
            lastClearedSlots.clear();
            lastClearedTick = tick;
        }
        lastClearedSlots.addAll(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7));
        allUncollected.forEach((key, value) -> {
            if(value > 0) {
                log.debug("tick {} cleared item {}, qty {}", client.getTickCount(), key, value);
                lastClearedUncollected.merge(key, value, Long::sum);
            }
        });
        uncollected.remove(accountHash);
    }

    public synchronized int getLastClearedTick() {
        return lastClearedTick;
    }

    public synchronized Map<Integer, Long> getLastClearedUncollected() {
        return lastClearedUncollected;
    }

    public synchronized List<Integer> getLastClearedSlots() {
        return lastClearedSlots;
    }

    public synchronized int getLastUncollectedAddedTick() {
        return lastUncollectedAddedTick;
    }

    public synchronized void reset() {
        lastClearedUncollected.clear();
        lastClearedTick = -1;
        lastUncollectedAddedTick = -1;
        uncollected.clear();
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;


@Getter
@Setter
@AllArgsConstructor
@ToString
@NoArgsConstructor
public class PremiumInstanceStatus {
    private String loadingError;
    @SerializedName("premium_instances_count")
    private int premiumInstancesCount;
    @SerializedName("changes_remaining")
    private int changesRemaining;
    @SerializedName("currently_assigned_display_names")
    private List<String> currentlyAssignedDisplayNames;
    @SerializedName("available_display_names")
    private List<String> availableDisplayNames;

    public static PremiumInstanceStatus ErrorInstance(String error) {
        PremiumInstanceStatus pi = new PremiumInstanceStatus();
        pi.setLoadingError(error);
        return pi;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.runelite.api.GrandExchangeOffer;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;


public class StatusOfferList extends ArrayList<Offer> {
    public static final int NUM_SLOTS = 8;
    public static final int NUM_F2P_SLOTS = 3;

    public StatusOfferList() {
        super(NUM_SLOTS);
        for (int i = 0; i < NUM_SLOTS; i++) {
            add(Offer.getEmptyOffer(i));
        }
    }

    public static StatusOfferList fromRunelite(GrandExchangeOffer[] runeliteOffers) {
        StatusOfferList offers = new StatusOfferList();
        for (int i = 0; i < runeliteOffers.length; i++) {
            offers.set(i, Offer.fromRunelite(runeliteOffers[i], i));
        }
        return offers;
    }

    public boolean isEmptySlotNeeded(Suggestion suggestion, boolean isMember) {
        return (suggestion.getType().equals("buy") || suggestion.getType().equals("sell"))
                && !emptySlotExists(isMember);
    }

    boolean emptySlotExists(boolean isMember) {
        return findEmptySlot(isMember) != -1;
    }

    public long getGpOnMarket() {
        return stream().mapToLong(Offer::cashStackGpValue).sum();
    }

    public long getTotalGpToCollect() {
        return stream().mapToLong(Offer::getGpToCollect).sum();
    }

    JsonArray toJson(Gson gson) {
        List<JsonObject> list = stream()
                .map(offer -> offer.toJson(gson))
                .collect(Collectors.toList());
        JsonArray jsonArray = new JsonArray();
        list.forEach(jsonArray::add);
        return jsonArray;
    }

    public int findEmptySlot(boolean isMember) {
        int numUsableSlots = isMember ? NUM_SLOTS : NUM_F2P_SLOTS;
        for (int i = 0; i < numUsableSlots; i++) {
            if (get(i).getStatus() == OfferStatus.EMPTY) {
                return i;
            }
        }
        return -1;
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.nio.ByteBuffer;

@Getter
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class ItemPrice {
    @SerializedName("sell_price")
    private int sellPrice;
    @SerializedName("buy_price")
    private  int buyPrice;
    private  String message;
    @SerializedName("graph_data")
    private Data graphData;

    public static ItemPrice fromMsgPack(ByteBuffer b) {
        ItemPrice ip = new ItemPrice();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }
        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "sp":
                    ip.sellPrice = (int) (long)MsgPackUtil.decodePrimitive(b);
                    break;
                case "bp":
                    ip.buyPrice = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "m":
                    ip.message = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "gd":
                    ip.graphData = Data.fromMsgPack(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }
        return ip;
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class LoginResponse {
    public String jwt;

    @SerializedName("user_id")
    public int userId;
}

package com.flippingcopilot.model;

import lombok.Getter;

@Getter
public enum IntervalTimeUnit {

    ALL(-1),
    SESSION(-1),
    HOUR(3600),
    DAY(86400),
    WEEK(604800),
    MONTH(2592000),
    YEAR(31536000);

    private final int seconds;;

    IntervalTimeUnit(int seconds) {
        this.seconds = seconds;
    }

    public static IntervalTimeUnit fromString(String str) {
        switch (str) {
            case "h":
                return IntervalTimeUnit.HOUR;
            case "d":
                return IntervalTimeUnit.DAY;
            case "w":
                return IntervalTimeUnit.WEEK;
            case "m":
                return IntervalTimeUnit.MONTH;
            case "y":
                return IntervalTimeUnit.YEAR;
            default:
                return IntervalTimeUnit.ALL;
        }
    }
}

package com.flippingcopilot.model;

import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.InventoryID;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.List;
import java.util.Map;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class AccountStatusManager {

    // dependencies
    private final Client client;
    private final OsrsLoginManager osrsLoginManager;
    private final GrandExchangeUncollectedManager geUncollected;
    private final SuggestionPreferencesManager suggestionPreferencesManager;
    private final PausedManager pausedManager;

    // state
    @Setter
    private int skipSuggestion = -1;

    public synchronized AccountStatus getAccountStatus() {
        Long accountHash =  osrsLoginManager.getAccountHash();
        ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
        Inventory inventory;
        if(itemContainer == null) {
            inventory = new Inventory();
        } else {
            inventory = Inventory.fromRunelite(itemContainer, client);
        }
        Map<Integer, Long> u = geUncollected.loadAllUncollected(accountHash);

        GrandExchangeOffer[] geOffers = client.getGrandExchangeOffers();
        StatusOfferList offerList = StatusOfferList.fromRunelite(geOffers);

        AccountStatus status = new AccountStatus();
        status.setOffers(offerList);
        status.setInventory(inventory);
        status.setUncollected(u);
        status.setDisplayName(osrsLoginManager.getPlayerDisplayName());
        status.setRsAccountHash(accountHash);
        status.setSkipSuggestion(skipSuggestion);
        status.setSellOnlyMode(suggestionPreferencesManager.getPreferences().isSellOnlyMode());
        status.setF2pOnlyMode(suggestionPreferencesManager.getPreferences().isF2pOnlyMode());
        status.setWorldMember(osrsLoginManager.isMembersWorld());
        status.setAccountMember(osrsLoginManager.isAccountMember());
        status.setSuggestionsPaused(pausedManager.isPaused());
        status.setBlockedItems(suggestionPreferencesManager.blockedItems());
        status.setTimeframe(suggestionPreferencesManager.getTimeframe());

        Map<Integer, Long> inLimboItems = geUncollected.getLastClearedUncollected();
        List<Integer> clearedSlots = geUncollected.getLastClearedSlots();
        if (geUncollected.getLastClearedTick() == client.getTickCount()) {
            log.debug("tick {} in limbo items {}, cleared slots {}", client.getTickCount(), inLimboItems, clearedSlots);
            if(inventory.missingJustCollected(inLimboItems)) {
                inLimboItems.forEach((itemId, qty) -> {
                    if (qty > 0) {
                        log.debug("tick {} move in limbo item {}, qty {} to inventory", client.getTickCount(), itemId, qty);
                        inventory.mergeItem(new RSItem(itemId, qty));
                    }
                });
            }
            for (Integer slot : clearedSlots) {
                Offer o = offerList.get(slot);
                GrandExchangeOffer geOffer = geOffers[slot];
                if (!isActive(geOffer.getState()) && geOffer.getState() != GrandExchangeOfferState.EMPTY) {
                    log.debug("tick {} in-activate slot {} just collected setting to EMPTY", client.getTickCount(), slot);
                    o.setStatus(OfferStatus.EMPTY);
                }
            }
        }

        return status;
    }

    private boolean isActive(GrandExchangeOfferState state) {
        switch (state){
            case EMPTY:
            case CANCELLED_BUY:
            case CANCELLED_SELL:
            case BOUGHT:
            case SOLD:
                return false;
            default:
                return true;
        }
    }

    public boolean isSuggestionSkipped() {
        return skipSuggestion != -1;
    }

    public void resetSkipSuggestion() {
        skipSuggestion = -1;
    }

    public void reset() {
        skipSuggestion = -1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;


@Getter
@AllArgsConstructor
@EqualsAndHashCode
public class Offer {

    @Setter
    private OfferStatus status;

    @SerializedName("item_id")
    private int itemId;

    private int price;

    @SerializedName("amount_total")
    private int amountTotal;

    @SerializedName("amount_spent")
    private int amountSpent;

    @SerializedName("amount_traded")
    private int amountTraded;

    @SerializedName("items_to_collect")
    private int itemsToCollect;

    @SerializedName("gp_to_collect")
    private int gpToCollect;

    @SerializedName("box_id")
    private int boxId;

    private boolean active;

    @Setter
    @SerializedName("copilot_price_used")
    private boolean copilotPriceUsed;

    public static Offer getEmptyOffer(int slotId) {
        return new Offer(OfferStatus.EMPTY, 0, 0, 0, 0, 0, 0, 0, slotId, false, false);
    }


    public long cashStackGpValue() {
        if (status == OfferStatus.SELL) {
            return (long) (amountTotal - amountTraded) * price + gpToCollect;
        } else if (status == OfferStatus.BUY){
            // for a buy just take the full amount even if they have collected
            // we assume they won't start selling any collected items until their buy offer is finished
            return (long) amountTotal * price;
        } else {
            return 0;
        }
    }


    public static Offer fromRunelite(GrandExchangeOffer runeliteOffer, int slotId) {
        OfferStatus status = OfferStatus.fromRunelite(runeliteOffer.getState());
        boolean active = runeliteOffer.getState().equals(GrandExchangeOfferState.BUYING)
                || runeliteOffer.getState().equals(GrandExchangeOfferState.SELLING);
        return new Offer(status,
                runeliteOffer.getItemId(),
                runeliteOffer.getPrice(),
                runeliteOffer.getTotalQuantity(),
                runeliteOffer.getSpent(),
                runeliteOffer.getQuantitySold(),
                0,
                0,
                slotId,
                active,
                false);
    }


    JsonObject toJson(Gson gson) {
        JsonParser jsonParser = new JsonParser();
        return jsonParser.parse(gson.toJson(this)).getAsJsonObject();
    }

}

package com.flippingcopilot.model;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class ItemAggregate {
    private final int itemId;
    private final String itemName;
    private final int numberOfFlips;
    private final int totalQuantityFlipped;
    private final long biggestLoss;
    private final long biggestWin;
    private final long totalProfit;
    private final long avgProfit;
    private final long avgProfitEa;
}
package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class Stats {

    public long profit;
    public long gross;
    public long taxPaid;
    public int flipsMade;

    public float calculateRoi() {
        if (gross == 0){
            return 0;
        }
        return (float) (((double) profit) / ((double) gross));
    }

    public Stats copy() {
        return new Stats(profit, gross, taxPaid, flipsMade);
    }

    public void add(Stats s) {
        if(s != null) {
            profit += s.profit;
            gross += s.gross;
            taxPaid += s.taxPaid;
            flipsMade += s.flipsMade;
        }
    }

    public void addFlip(FlipV2 f) {
        profit += f.getProfit();
        gross += f.getSpent();
        taxPaid += f.getTaxPaid();
        flipsMade += 1;
    }

    public void subtractFlip(FlipV2 f) {
        profit -= f.getProfit();
        gross -= f.getSpent();
        taxPaid -= f.getTaxPaid();
        flipsMade -= 1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public class SessionData {

    @SerializedName("start_time")
    public int startTime;

    @SerializedName("duration_millis")
    public long durationMillis;

    @SerializedName("average_cash")
    public long averageCash;
}

package com.flippingcopilot.model;

public enum SortDirection {
    ASC,
    DESC
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.util.Constants;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.time.Instant;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * This class is essentially a cache of user flips that facilitates efficient access to the flips and statistics for
 * any time range and rs account(s) combination. Since after several years a (very) active user could have hundreds of
 * thousands of flips, it would be too slow to filter and re-calculate flips/statistics from scratch every time.
 * A bucketed aggregation strategy is used where we keep pre-computed weekly buckets of statistics and flips. For any
 * time range we can efficiently combine the weekly buckets and only have to re-calculate statistics for the partial
 * weeks on the boundaries of the time range. Have tested the UI experience with >100k flips.
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class FlipManager {

    private static final int WEEK_SECS = 7 * 24 * 60 * 60;

    public static final Comparator<FlipV2> FLIP_STATUS_TIME_COMPARATOR =
                Comparator.comparing(FlipV2::isClosed).reversed().thenComparing(f -> f.getClosedTime() > 0 ? f.getClosedTime() : f.getOpenedTime());
    public static final Comparator<FlipV2> TIME_DESC_COMPARATOR = Comparator.comparing(FlipV2::lastTransactionTime).reversed();

    // dependencies
    private final ItemController itemController;

    @Setter
    private Runnable flipsChangedCallback = () -> {};

    // state
    @Setter
    private volatile int copilotUserId;
    private Integer intervalAccount;
    private int intervalStartTime;
    private Stats intervalStats = new Stats();

    final Map<Integer, Map<Integer, FlipV2>> lastOpenFlipByItemId = new HashMap<>();
    final Map<UUID, Integer> existingCloseTimes = new HashMap<>();
    final List<WeekAggregate> weeks = new ArrayList<>(365*5);


    public synchronized Integer getIntervalAccount() {
        return intervalAccount;
    }

    public synchronized Long estimateTransactionProfit(Integer accountId, Transaction t) {
        if (accountId != null && lastOpenFlipByItemId.containsKey(accountId)) {
            FlipV2 flip = lastOpenFlipByItemId.get(accountId).get(t.getItemId());
            if(flip != null) {
                return flip.calculateProfit(t);
            }
        }
        return null;
    }

    public synchronized FlipV2 getLastFlipByItemId(Integer accountId, int itemId) {
        if (accountId != null && lastOpenFlipByItemId.containsKey(accountId)) {
            Map<Integer, FlipV2> flips = lastOpenFlipByItemId.get(accountId);
            FlipV2 flip = flips.get(itemId);
            if (flip != null) {
                flip.setCachedItemName(itemController.getItemName(flip.getItemId()));
                return flip;
            }
        }
        return null;
    }


    public synchronized boolean mergeFlips(List<FlipV2> flips, int copilotUserId) {
        if (copilotUserId != this.copilotUserId) {
            return false;
        }
        flips.sort(FLIP_STATUS_TIME_COMPARATOR);
        flips.forEach(this::mergeFlip_);
        SwingUtilities.invokeLater(flipsChangedCallback);
        return true;
    }

    public synchronized Stats getIntervalStats() {
        return intervalStats.copy();
    }

    public synchronized Stats calculateStats(int startTime, Integer accountId) {
        if(accountId == null) {
            return calculateStatsAllAccounts(startTime);
        } else {
            return calculateStatsForAccount(startTime, accountId);
        }
    }

    public synchronized void setIntervalAccount(Integer account) {
        if (Objects.equals(account, intervalAccount)) {
            return;
        }
        intervalAccount = account;
        recalculateIntervalStats();
    }

    public synchronized void setIntervalStartTime(int startTime) {
        log.debug("time interval start set to: {}", Instant.ofEpochSecond(startTime));
        if (startTime == intervalStartTime) {
            return;
        }
        intervalStartTime = startTime;
        recalculateIntervalStats();
    }

    private void recalculateIntervalStats() {
        if(intervalAccount == null) {
            intervalStats = calculateStatsAllAccounts(intervalStartTime);
        } else {
            intervalStats = calculateStatsForAccount(intervalStartTime, intervalAccount);
        }
        log.debug("interval flips updated to {}, interval profit updated to {}", intervalStats.flipsMade, intervalStats.profit);
        SwingUtilities.invokeLater(flipsChangedCallback);
    }

    private Stats calculateStatsAllAccounts(int startTime) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfter(startTime, false)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).allStats);
        }
        return stats;
    }

    private Stats calculateStatsForAccount(int startTime, int accountId) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfterForAccount(startTime, accountId)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).accountIdToStats.get(accountId));
        }
        return stats;
    }

    public List<FlipV2> getPageFlips(int page, int pageSize) {
        return getPageFlips(page, pageSize,  intervalStartTime, intervalAccount);
    }

    public synchronized void aggregateFlips(int intervalStartTime, Integer accountId, boolean includeBuyingFlips, Consumer<FlipV2> c) {
        if (Objects.equals(accountId,-1)) {
            return;
        }
        if(includeBuyingFlips) {
            WeekAggregate w = getOrInitWeek(0);
            List<FlipV2> f = accountId == null ? w.flipsAfter(-1, false) : w.flipsAfterForAccount(-1, accountId);
            f.stream().filter(i -> i.getOpenedTime() > intervalStartTime).forEach(c);
        }
        WeekAggregate intervalWeek = getOrInitWeek(intervalStartTime);
        for(int i=weeks.size()-1; i >= intervalWeek.pos; i--) {
            if (weeks.get(i).weekEnd <= intervalStartTime) {
                break;
            }
            WeekAggregate w = weeks.get(i);
            List<FlipV2> weekFlips = accountId == null ? w.flipsAfter(intervalStartTime, true) : w.flipsAfterForAccount(intervalStartTime, accountId);
            int n = weekFlips.size();
            // note: weekFlips are ascending order but we consume in descending order
            for(int ii=n-1; ii >= 0; ii--) {
                c.accept(weekFlips.get(ii));
            }
        }
    }

    public synchronized List<FlipV2> getPageFlips(int page, int pageSize, int intervalStartTime, Integer accountId) {
        if (Objects.equals(accountId,-1)) {
            return new ArrayList<>();
        }

        int toSkip = (page -1) * pageSize;
        WeekAggregate intervalWeek = getOrInitWeek(intervalStartTime);
        List<FlipV2> pageFlips = new ArrayList<>(pageSize == Integer.MAX_VALUE ? 0 : pageSize);
        for(int i=weeks.size()-1; i >= intervalWeek.pos; i--) {
            if (weeks.get(i).weekEnd <= intervalStartTime || pageFlips.size() == pageSize) {
                break;
            }
            WeekAggregate w = weeks.get(i);
            List<FlipV2> weekFlips = accountId == null ? w.flipsAfter(intervalStartTime, true) : w.flipsAfterForAccount(intervalStartTime, accountId);
            int n = weekFlips.size();
            if (n > toSkip) {
                // note: weekFlips are ascending order but we return pages of descending order
                int end = n - toSkip;
                int start = Math.max(0, end - (pageSize - pageFlips.size()));
                for(int ii=end-1; ii >= start; ii--) {
                    pageFlips.add(weekFlips.get(ii));
                }
                toSkip = 0;
            } else {
                toSkip -= n;
            }
        }
        pageFlips.forEach(flip -> flip.setCachedItemName(itemController.getItemName(flip.getItemId())));
        return pageFlips;
    }

    public synchronized void reset() {
        intervalAccount = null;
        intervalStartTime = 0;
        copilotUserId = 0;
        intervalStats = new Stats();
        lastOpenFlipByItemId.clear();
        existingCloseTimes.clear();
        weeks.clear();
    }

    private void mergeFlip_(FlipV2 flip) {
        Integer existingCloseTime = existingCloseTimes.get(flip.getId());

        if(existingCloseTime != null) {
            WeekAggregate wa = getOrInitWeek(existingCloseTime);
            FlipV2 removed = wa.removeFlipIfUpdatedBefore(flip.getId(), existingCloseTime, flip.getAccountId(), flip.getUpdatedTime());
            if (removed == null) {
                // the flip we are merging is an out of date instance of the same flip
                return;
            }
            if(isInInterval(removed)) {
                intervalStats.subtractFlip(removed);
            }
        }
        if(flip.isDeleted()) {
            existingCloseTimes.remove(flip.getId());
            return;
        }
        WeekAggregate wa = getOrInitWeek(flip.getClosedTime());
        wa.addFlip(flip);
        if(isInInterval(flip)) {
            intervalStats.addFlip(flip);
        }

        if(!flip.getStatus().equals(FlipStatus.FINISHED)) {
            lastOpenFlipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).put(flip.getItemId(), flip);
        } else {
            lastOpenFlipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).remove(flip.getItemId());
        }

        existingCloseTimes.put(flip.getId(), flip.getClosedTime());
    }

    private boolean isInInterval(FlipV2 flip) {
        return flip.getClosedTime() >= intervalStartTime && (intervalAccount == null || flip.getAccountId() == intervalAccount);
    }

    private WeekAggregate getOrInitWeek(int closeTime) {
        int ws = closeTime - (closeTime % WEEK_SECS);
        int i = bisect(weeks.size(), (a) ->  Integer.compare(weeks.get(a).weekStart, ws));
        if (i >= 0){
            WeekAggregate w = weeks.get(i);
            w.pos = i;
            return w;
        }
        WeekAggregate wf = new WeekAggregate();
        wf.weekStart = ws;
        wf.weekEnd = ws + WEEK_SECS;
        wf.pos = -i-1;
        weeks.add(wf.pos, wf);
        return wf;
    }

    public synchronized void deleteAccount(int accountId) {
        for (WeekAggregate week : weeks) {
            week.deleteAccountFlips(accountId);
        }
        if (intervalAccount != null && intervalAccount == accountId) {
            // change the intervalAccount if it is the one being deleted
            intervalAccount = null;
            recalculateIntervalStats();
        } else if (intervalAccount == null) {
            recalculateIntervalStats();
        }
        lastOpenFlipByItemId.remove(accountId);
        SwingUtilities.invokeLater(flipsChangedCallback);
    }

    class WeekAggregate {

        int pos; // note: only correct when returned by getOrInitWeek
        int weekStart;
        int weekEnd;

        Stats allStats = new Stats();
        Map<Integer, Stats> accountIdToStats = new HashMap<>(20);
        Map<Integer, List<FlipV2>> accountIdToFlips = new HashMap<>(20);

        void addFlip(FlipV2 flip) {
            int accountId = flip.getAccountId();
            allStats.addFlip(flip);
            accountIdToStats.computeIfAbsent(accountId, (k) -> new Stats()).addFlip(flip);
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, flip.getId(), flip.getClosedTime()));
            flips.add(-i -1, flip);
        }

        FlipV2 removeFlipIfUpdatedBefore(UUID id, int closeTime, int accountId, int newUpdatedTime) {
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, id, closeTime));
            FlipV2 flip = flips.get(i);
            // if the existing instance of the flip is updated more recently return null
            if (flip.getUpdatedTime() > newUpdatedTime) {
                return null;
            }
            allStats.subtractFlip(flip);
            flips.remove(i);
            accountIdToStats.get(accountId).subtractFlip(flip);
            return flip;
        }

        public List<FlipV2> flipsAfterForAccount(int time, int accountId) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            if (time <= weekStart) {
                return flips;
            }
            int cut = -bisect(flips.size(), closedTimeCmp(flips, Constants.MAX_UUID, time)) - 1;
            return flips.subList(cut, flips.size());
        }

        public List<FlipV2> flipsAfter(int time, boolean requireSorted) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> combinedFlips = new ArrayList<>(allStats.flipsMade);
            accountIdToFlips.keySet().forEach(i -> combinedFlips.addAll(flipsAfterForAccount(time, i)));
            if (requireSorted) {
                combinedFlips.sort(Comparator.comparing(FlipV2::getClosedTime).thenComparing(FlipV2::getId));
            }
            return combinedFlips;
        }
        public void deleteAccountFlips(int accountId) {
            accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>()).forEach((FlipV2 f) -> {
                    allStats.subtractFlip(f);
                }
            );
            accountIdToFlips.remove(accountId);
            accountIdToStats.remove(accountId);
        }

        @Override
        public String toString() {
            return String.format("WeekAggregate[start=%s, flips=%d]", Instant.ofEpochSecond(weekStart), allStats.flipsMade);
        }

    }

    private Function<Integer, Integer> closedTimeCmp(List<FlipV2> flips, UUID id, int time) {
        return (a) -> {
            // sorts time ascending with id as tie-breaker
            int c = Integer.compare(flips.get(a).getClosedTime(), time);
            return c != 0 ? c : id.compareTo(flips.get(a).getId());
        };
    }

    private int bisect(int size, Function<Integer, Integer> cmpFunc) {
        int high = size -1;
        int low = 0;
        while (low <= high) {
            int mid = (low + high) >>> 1;
            int cmp = cmpFunc.apply(mid);
            if (cmp < 0)
                low = mid + 1;
            else if (cmp > 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found (low = insertion point)
    }
}

package com.flippingcopilot.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumSet;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OsrsLoginManager {

    public static final int GE_LOGIN_BURST_WINDOW = 2; // ticks

    public static String LOGIN_TO_GET_SUGGESTION_MESSAGE = "Log in to the game<br>to get a flip suggestion";
    private static final WorldType[] COPILOT_UNSUPPORTED_WORLDS = {WorldType.BETA_WORLD,
            WorldType.DEADMAN,
            WorldType.FRESH_START_WORLD,
            WorldType.NOSAVE_MODE,
            WorldType.PVP_ARENA,
            WorldType.SEASONAL,
            WorldType.QUEST_SPEEDRUNNING,
            WorldType.TOURNAMENT_WORLD};

    private final Client client;

    private String cachedDisplayName;
    private long lastAccountHash;

    @Getter
    @Setter
    private int lastLoginTick;

    private boolean lastIsIronman = false;

    public boolean isMembersWorld() {
        return client.getWorldType().contains(WorldType.MEMBERS);
    }

    public boolean isAccountMember()
    {
        int daysLeft = client.getVarpValue(VarPlayer.MEMBERSHIP_DAYS);
        return daysLeft > 0;
    }

    public boolean isValidLoginState() {
        return getInvalidStateDisplayMessage() == null;
    }

    public String getInvalidStateDisplayMessage() {
        if (client.getGameState() != GameState.LOGGED_IN || getPlayerDisplayName() == null) {
            return LOGIN_TO_GET_SUGGESTION_MESSAGE;
        }

        EnumSet<WorldType> worldTypes  =  client.getWorldType();

        for (WorldType worldType : COPILOT_UNSUPPORTED_WORLDS) {
            if (worldTypes.contains(worldType)) {
                return worldType + " worlds<br>are not supported";
            }
        }
        if(client.isClientThread()) {
            lastIsIronman = client.getVarbitValue(Varbits.ACCOUNT_TYPE) != 0;
        }
        if (lastIsIronman) {
            return "Ironman accounts<br>are not supported";
        }
        return null;
    }

    // todo: inline this method
    public Long getAccountHash() {
        return client.getAccountHash();
    }

    public String getPlayerDisplayName() {
        long accountHash = client.getAccountHash();
        if(lastAccountHash == accountHash && cachedDisplayName != null) {
            return cachedDisplayName;
        }
        final Player player = client.getLocalPlayer();
        if (player != null) {
            final String name = player.getName();
            if (name != null && !name.isEmpty()) {
                lastAccountHash = accountHash;
                cachedDisplayName = name;
                return name;
            }
        }
        return null;
    }

    public String getLastDisplayName() {
        return cachedDisplayName != null ? cachedDisplayName : getPlayerDisplayName();
    }

    public void reset() {

    }

    public boolean hasJustLoggedIn() {
        return client.getTickCount() <= lastLoginTick + GE_LOGIN_BURST_WINDOW;
    }
}

package com.flippingcopilot.model;
import lombok.*;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@ToString
public class AckedTransaction {

    public static final int RAW_SIZE = 56;

    private UUID id;
    private UUID clientFlipId;
    private int accountId;
    private int time;
    private int itemId;
    private int quantity;
    private int price;
    private int amountSpent;

    public static List<AckedTransaction> listFromRaw(byte[] raw) {
        if (raw.length < 4) {
            throw new IllegalArgumentException("Raw data must be at least 4 bytes to contain record count");
        }

        ByteBuffer b = ByteBuffer.wrap(raw);
        b.order(ByteOrder.BIG_ENDIAN);

        // Read the number of records (int32)
        int recordCount = b.getInt();
        int expectedSize = 4 + (recordCount * RAW_SIZE);
        if (raw.length != expectedSize) {
            throw new IllegalArgumentException("Raw data size " + raw.length + " doesn't match expected size " + expectedSize + " for " + recordCount + " records");
        }
        List<AckedTransaction> txs = new ArrayList<>(recordCount);
        for (int i = 0; i < recordCount; i++) {
            byte[] recordBytes = new byte[RAW_SIZE];
            b.get(recordBytes);
            txs.add(fromRaw(recordBytes));
        }
        return txs;
    }
    
    public static AckedTransaction fromRaw(byte[] raw) {
        if (raw.length != RAW_SIZE) {
            throw new IllegalArgumentException("Raw data must be exactly " + RAW_SIZE + " bytes");
        }

        ByteBuffer b = ByteBuffer.wrap(raw);
        b.order(ByteOrder.BIG_ENDIAN);
        AckedTransaction transaction = new AckedTransaction();

        long idMostSig = b.getLong();
        long idLeastSig = b.getLong();
        transaction.id = new UUID(idMostSig, idLeastSig);
        long clientFlipIdMostSig = b.getLong();
        long clientFlipIdLeastSig = b.getLong();
        transaction.clientFlipId = new UUID(clientFlipIdMostSig, clientFlipIdLeastSig);
        transaction.accountId = b.getInt();
        transaction.time = b.getInt();
        transaction.itemId = b.getInt();
        transaction.quantity = b.getInt();
        transaction.price = b.getInt();
        transaction.amountSpent = b.getInt();
        return transaction;
    }

    public byte[] toRaw() {
        ByteBuffer b = ByteBuffer.allocate(RAW_SIZE);
        b.order(ByteOrder.BIG_ENDIAN);
        b.putLong(id.getMostSignificantBits());
        b.putLong(id.getLeastSignificantBits());
        b.putLong(clientFlipId.getMostSignificantBits());
        b.putLong(clientFlipId.getLeastSignificantBits());
        b.putInt(accountId);
        b.putInt(time);
        b.putInt(itemId);
        b.putInt(quantity);
        b.putInt(price);
        b.putInt(amountSpent);
        return b.array();
    }
}
package com.flippingcopilot.model;

import lombok.Data;

@Data
public class DiscordWebhookBody {
    private String content;
    private Embed embed;

    @Data
    static class Embed {
        final UrlEmbed image;
    }

    @Data
    static class UrlEmbed {
        final String url;
    }
}
package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OfferManager {

    private static final String OFFER_FILE_TEMPLATE = "acc_%d_%d.json";

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    @Getter
    @Setter
    private int lastViewedSlotItemId = -1;
    @Getter
    @Setter
    private int lastViewedSlotItemPrice = -1;
    @Getter
    @Setter
    private int lastViewedSlotPriceTime = 0;
    @Getter
    @Setter
    private int viewedSlotItemId = -1;
    @Getter
    @Setter
    private int viewedSlotItemPrice = -1;
    @Getter
    @Setter
    boolean offerJustPlaced = false;

    private final Map<Long, Map<Integer, SavedOffer>> cachedOffers = new HashMap<>();
    private final Map<Long, Map<Integer, File>> files = new HashMap<>();
    private final Map<Long, Map<Integer, SavedOffer>> lastSaved = new HashMap<>();

    public synchronized SavedOffer loadOffer(Long accountHash, Integer slot) {
        Map<Integer, SavedOffer> slotToOffer = cachedOffers.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToOffer.computeIfAbsent(slot, (k) -> {
            File file = getFile(accountHash, k);
            try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                return gson.fromJson(reader, SavedOffer.class);
            } catch (FileNotFoundException ignored) {
                return null;
            } catch (JsonSyntaxException | JsonIOException | IOException e) {
                log.warn("error loading saved offer json file {}", file, e);
                return null;
            }
        });
    }

    public synchronized void saveOffer(Long accountHash, Integer slot, SavedOffer offer) {
        Map<Integer, SavedOffer> slotToOffer = cachedOffers.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        slotToOffer.put(slot, offer);
        saveAsync(accountHash, slot);
    }

    private void saveAsync(Long accountHash, Integer slot) {
        executorService.submit(() -> save(accountHash, slot));
    }

    public synchronized void saveAll() {
        for(Long accountHash: cachedOffers.keySet()) {
            for(Integer slot: cachedOffers.get(accountHash).keySet()) {
                save(accountHash, slot);
            }
        }
    }

    private void save(Long accountHash, Integer slot) {
        File file = getFile(accountHash,slot);
        synchronized (file) {
            SavedOffer offer = loadOffer(accountHash, slot);
            Map<Integer, SavedOffer> slotToLastSaved = lastSaved.computeIfAbsent(accountHash, (k)->new HashMap<>());
            SavedOffer lastSaved = slotToLastSaved.get(slot);
            if(!Objects.equals(offer, lastSaved)) {
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(offer);
                    writer.write(json);
                    writer.newLine();
                    slotToLastSaved.put(slot, offer);
                } catch (IOException e) {
                    log.warn("error saving offer json file {}", file, e);
                    slotToLastSaved.put(slot, null);
                }
            }
        }
    }


    private File getFile(Long accountHash, Integer slot) {
        Map<Integer, File> slotToFile = files.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToFile.computeIfAbsent(slot, (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(OFFER_FILE_TEMPLATE, accountHash, slot)));
    }
}

package com.flippingcopilot.model;

import lombok.Builder;
import lombok.Data;


@Data
@Builder
public class AccountAggregate {
    private int accountId;
    private String accountName;
    private int numberOfFlips;
    private long biggestLoss;
    private long biggestWin;
    private long totalProfit;
}
package com.flippingcopilot.model;


import com.flippingcopilot.controller.Persistance;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PausedManager {

    private static final String PAUSED_FILE_TEMPLATE = "acc_%d_paused.json";

    // dependencies
    private final OsrsLoginManager osrsLoginManager;
    private final ScheduledExecutorService executorService;

    // state
    private final Map<Long, Boolean> cachedPaused = new HashMap<>();
    private final Map<Long, File> accountHashToFile = new HashMap<>();

    public synchronized boolean isPaused() {
        Long accountHash = osrsLoginManager.getAccountHash();
        return cachedPaused.computeIfAbsent(accountHash, (k) -> {
            File file = getFile(k);
            try {
                String text = Files.readString(file.toPath(), StandardCharsets.UTF_8);
                return text.contains("true");
            } catch (NoSuchFileException e ){
                return false;
            } catch (JsonSyntaxException | JsonIOException | IOException e) {
                log.warn("error loading stored paused state file {}", file, e);
                return false;
            }
        });
    }

    public synchronized void setPaused(boolean isPaused) {
        Long accountHash = osrsLoginManager.getAccountHash();
        cachedPaused.put(accountHash, isPaused);
        saveAsync(accountHash);
    }

    private void saveAsync(Long accountHash) {
        executorService.submit(() -> {
            File file = getFile(accountHash);
            synchronized (file) {
                boolean isPaused = cachedPaused.getOrDefault(accountHash, false);
                String text = isPaused ? "{\"isPaused\":true}" : "{\"isPaused\":false}";
                try {
                    Files.write(file.toPath(), text.getBytes());
                } catch (IOException e) {
                    log.warn("error storing paused.json file {}", file, e);
                }
            }
        });
    }

    private File getFile(Long accountHash) {
        return accountHashToFile.computeIfAbsent(accountHash,
                (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(PAUSED_FILE_TEMPLATE, accountHash)));
    }
}
package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.Map;

@AllArgsConstructor
@Data
public class DataDeltaRequest {

    @SerializedName("account_id_time")
    private final Map<Integer, Integer> accountIdTime;

}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.SuggestionController;
import com.flippingcopilot.model.PausedManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Singleton
public class PauseButton extends JButton {

    private final PausedManager pausedManager;

    private static final ImageIcon PLAY_ICON;
    private static final ImageIcon PAUSE_ICON;
    private static final ImageIcon PLAY_ICON_HOVER;
    private static final ImageIcon PAUSE_ICON_HOVER;

    static {
        var play = ImageUtil.loadImageResource(PauseButton.class, "/play.png");
        var pause = ImageUtil.loadImageResource(PauseButton.class, "/pause.png");
        PLAY_ICON = new ImageIcon(play);
        PAUSE_ICON = new ImageIcon(pause);
        PLAY_ICON_HOVER =  new ImageIcon(ImageUtil.luminanceScale(play, BUTTON_HOVER_LUMINANCE));
        PAUSE_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(pause, BUTTON_HOVER_LUMINANCE));
    }

    @Inject
    public PauseButton(PausedManager pausedManager,
                       SuggestionController suggestionController) {
        super(PAUSE_ICON);
        this.pausedManager = pausedManager;
        setToolTipText("Pause suggestions");
        addActionListener(e -> {
            suggestionController.togglePause();
            update();
        });

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(pausedManager.isPaused() ? PLAY_ICON_HOVER : PAUSE_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(pausedManager.isPaused() ? PLAY_ICON : PAUSE_ICON);
            }
        });

        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);
    }

    private void update() {
        boolean isPaused = pausedManager.isPaused();
        setIcon(isPaused ? PLAY_ICON : PAUSE_ICON);
        setToolTipText(isPaused ? "Unpause suggestions" :  "Pause suggestions");
    }
}

package com.flippingcopilot.ui;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;

@Singleton
public class CopilotPanel extends JPanel {

    public final SuggestionPanel suggestionPanel;
    public final StatsPanelV2 statsPanel;
    public final ControlPanel controlPanel;

    @Inject
    public CopilotPanel(SuggestionPanel suggestionPanel,
                        StatsPanelV2 statsPanel,
                        ControlPanel controlPanel) {
        this.statsPanel = statsPanel;
        this.suggestionPanel = suggestionPanel;
        this.controlPanel = controlPanel;
        
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        suggestionPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, suggestionPanel.getPreferredSize().height));
        suggestionPanel.setMinimumSize(new Dimension(Integer.MIN_VALUE, suggestionPanel.getPreferredSize().height));
        add(suggestionPanel);
        add(Box.createRigidArea(new Dimension(0, 5)));
        add(controlPanel);
        add(Box.createRigidArea(new Dimension(0, 5)));
        add(Box.createVerticalGlue());
        add(statsPanel);
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        suggestionPanel.refresh();
        controlPanel.refresh();
    }
}

/* Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * Copyright (c) 2024, Cillian Brewitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;

import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class WidgetHighlightOverlay extends Overlay
{
    private final Widget widget;
    private final Color color;
    private final Rectangle relativeBounds;

    public WidgetHighlightOverlay(final Widget widget, Color color, Rectangle relativeBounds)
    {
        this.widget = widget;
        this.color = color;
        this.relativeBounds = relativeBounds;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (widget == null)
        {
            return null;
        }

        Rectangle highlightBounds = widget.getBounds();

        if (highlightBounds == null)
        {
            return null;
        }

        highlightBounds.x += relativeBounds.x;
        highlightBounds.y += relativeBounds.y;
        highlightBounds.width = relativeBounds.width;
        highlightBounds.height = relativeBounds.height;

        drawHighlight(graphics, highlightBounds);
        return null;
    }

    private void drawHighlight(Graphics2D graphics, Rectangle bounds)
    {
        graphics.setColor(color);
        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import net.runelite.client.util.ImageUtil;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
@Singleton
public class BlockButton extends JButton
{
    private final SuggestionManager suggestionManager;
    private final SuggestionPreferencesManager preferencesManager;

    private static final ImageIcon BLOCK_ICON;
    private static final ImageIcon BLOCK_ICON_HOVER;

    static
    {
        var blockImg = ImageUtil.loadImageResource(BlockButton.class, "/block.png");
        BLOCK_ICON = new ImageIcon(blockImg);
        BLOCK_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(blockImg, BUTTON_HOVER_LUMINANCE));
    }

    @Inject
    public BlockButton(SuggestionManager suggestionManager, SuggestionPreferencesManager preferencesManager)
    {
        super(BLOCK_ICON);
        this.suggestionManager = suggestionManager;
        this.preferencesManager = preferencesManager;

        setToolTipText("Block this item");
        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);

        // Click action
        addActionListener(e -> confirmAndBlock());

        // Hover effects
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                setIcon(BLOCK_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                setIcon(BLOCK_ICON);
            }
        });
    }

    private void confirmAndBlock()
    {
        Suggestion s = suggestionManager.getSuggestion();
        if (s == null)
        {
            log.debug("No current suggestion to block.");
            return;
        }

        // Get item name or fallback text
        String itemName = s.getName() != null ? s.getName() : "this item";

        // Show a confirmation dialog
        int choice = JOptionPane.showConfirmDialog(
                this,
                "Do you want to block " + itemName + "?",
                "Confirm Block",
                JOptionPane.YES_NO_OPTION
        );

        // If user clicks YES, proceed with blocking
        if (choice == JOptionPane.YES_OPTION)
        {
            preferencesManager.blockItem(s.getItemId());
            log.debug("Blocked item with ID {} ({})", s.getItemId(), itemName);
            suggestionManager.setSuggestionNeeded(true);
        }
        else
        {
            log.debug("User canceled blocking for {}", itemName);
        }
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.model.AckedTransaction;
import com.flippingcopilot.model.Transaction;
import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.TransactionManager;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
public class GeAddTransactionsDialogPanel extends JPanel {

    private static final String CARD_LOADING = "loading";
    private static final String CARD_CONTENT = "content";
    private static final String CARD_ERROR = "error";

    private final TransactionManager transactionManager;
    private final CardLayout cardLayout;
    private final JPanel cardPanel;
    private JPanel transactionListPanel;
    private final List<TransactionCheckbox> checkboxes;
    private JButton addButton;
    private JButton cancelButton;
    private JLabel successLabel;
    private final JLabel errorCardLabel;
    private final ApiRequestHandler apiRequestHandler;
    private final ItemController itemController;
    private final String displayName;
    private final Runnable onClose;

    private List<AckedTransaction> serverTransactions;
    private List<Transaction> geTransactions;

    public GeAddTransactionsDialogPanel(
            ApiRequestHandler apiRequestHandler,
            ItemController itemController,
            String displayName,
            TransactionManager transactionManager,
            Runnable onClose,
            List<Transaction> geTransactions) {

        this.geTransactions = geTransactions;
        this.apiRequestHandler = apiRequestHandler;
        this.itemController = itemController;
        this.displayName = displayName;
        this.transactionManager = transactionManager;
        this.onClose = onClose;
        this.checkboxes = new ArrayList<>();

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setPreferredSize(new Dimension(500, 400));

        // Setup cards
        cardLayout = new CardLayout();
        cardPanel = new JPanel(cardLayout);
        cardPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.add(createLoadingPanel(), CARD_LOADING);
        cardPanel.add(createContentPanel(), CARD_CONTENT);
        JPanel errorPanel = new JPanel(new GridBagLayout());
        errorPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        errorCardLabel = new JLabel();
        errorCardLabel.setForeground(Color.RED);
        errorCardLabel.setFont(FontManager.getRunescapeBoldFont());
        errorPanel.add(errorCardLabel);
        cardPanel.add(errorPanel, CARD_ERROR);
        add(cardPanel, BorderLayout.CENTER);

        // show initial card
        if (this.geTransactions == null || this.geTransactions.isEmpty()) {
            showError("Failed to extract GE transactions.");
        } else {
            cardLayout.show(cardPanel, CARD_LOADING);
            this.apiRequestHandler.asyncLoadRecentAccountTransactions(
                    this.displayName,
                    (int) (Instant.now().getEpochSecond()),
                    loadedTransactions -> SwingUtilities.invokeLater(() -> {
                        this.serverTransactions = loadedTransactions;
                        markAlreadyAdded(new ArrayList<>(serverTransactions), this.geTransactions);
                        populateTransactionList();
                        cardLayout.show(cardPanel, CARD_CONTENT);
                    }),
                    error -> SwingUtilities.invokeLater(() -> {
                        showError("Error checking server transactions: " + error);
                    })
            );
        }
    }

    private JPanel createLoadingPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(0, 0, 10, 0);
        Spinner spinner = new Spinner();
        spinner.show();
        panel.add(spinner, gbc);
        gbc.gridy = 1;
        JLabel loadingLabel = new JLabel("Checking recent transactions...");
        loadingLabel.setForeground(Color.WHITE);
        loadingLabel.setFont(FontManager.getRunescapeFont());
        panel.add(loadingLabel, gbc);
        return panel;
    }

    private JPanel createContentPanel() {
        JPanel contentPanel = new JPanel(new BorderLayout());
        contentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        JLabel titleLabel = new JLabel("Select transactions to add:");
        titleLabel.setFont(FontManager.getRunescapeFont());
        titleLabel.setForeground(Color.WHITE);
        headerPanel.add(titleLabel, BorderLayout.NORTH);
        contentPanel.add(headerPanel, BorderLayout.NORTH);

        transactionListPanel = new JPanel();
        transactionListPanel.setLayout(new BoxLayout(transactionListPanel, BoxLayout.Y_AXIS));
        transactionListPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JScrollPane scrollPane = new JScrollPane(transactionListPanel);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        JPanel centerPanel = new JPanel(new BorderLayout());
        centerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        centerPanel.add(scrollPane, BorderLayout.CENTER);

        JLabel warningLabel = new JLabel("<html><div style='text-align: left; width: 400px;'>" +
                "Only add transactions not recorded by Copilot. It is your responsibility not to add duplicates." +
                "</div></html>");
        warningLabel.setFont(FontManager.getRunescapeFont());
        warningLabel.setForeground(Color.RED);
        warningLabel.setHorizontalAlignment(SwingConstants.CENTER);
        warningLabel.setBorder(new EmptyBorder(10, 10, 10, 10));
        centerPanel.add(warningLabel, BorderLayout.SOUTH);

        contentPanel.add(centerPanel, BorderLayout.CENTER);

        // Button panel
        contentPanel.add(createButtonPanel(), BorderLayout.SOUTH);

        return contentPanel;
    }

    private JPanel createButtonPanel() {
        JPanel buttonPanel = new JPanel(new BorderLayout());
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        buttonPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        successLabel = new JLabel();
        successLabel.setForeground(Color.GREEN);
        successLabel.setFont(FontManager.getRunescapeFont());
        successLabel.setVisible(false);
        successLabel.setName("successLabel");
        buttonPanel.add(successLabel, BorderLayout.WEST);
        JPanel rightButtonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        rightButtonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cancelButton = new JButton("Cancel");
        cancelButton.setFont(FontManager.getRunescapeFont());
        cancelButton.addActionListener(e -> onClose.run());
        addButton = new JButton("Add Selected");
        addButton.setFont(FontManager.getRunescapeFont());
        addButton.setEnabled(false);
        addButton.addActionListener(e -> handleAddSelected());
        rightButtonPanel.add(cancelButton);
        rightButtonPanel.add(Box.createHorizontalStrut(10));
        rightButtonPanel.add(addButton);
        buttonPanel.add(rightButtonPanel, BorderLayout.EAST);
        return buttonPanel;
    }

    private void handleAddSelected() {
        List<Transaction> selectedTransactions = checkboxes.stream()
                .filter(tc -> tc.checkbox.isSelected())
                .map(tc -> tc.transaction)
                .collect(Collectors.toList());

        selectedTransactions.forEach(transaction -> {
            transactionManager.addTransaction(transaction, displayName);
            transaction.setGeTransactionAlreadyAdded(true);
        });
        successLabel.setText("Transactions queued to server");
        successLabel.setVisible(true);
        populateTransactionList();
    }

    private void showError(String errorMessage) {
        errorCardLabel.setText(errorMessage);
        cardLayout.show(cardPanel, CARD_ERROR);
    }

    private void markAlreadyAdded(List<AckedTransaction> serverTransactions, List<Transaction> geTransactions) {
        log.debug("Checking already added transactions. Server txs: {}, GE txs: {}",
                serverTransactions.size(), geTransactions.size());
        for (Transaction geTransaction : geTransactions) {
            int geQuantity = geTransaction.getType() == OfferStatus.BUY
                    ? geTransaction.getQuantity()
                    : -geTransaction.getQuantity();

            for (int i = 0; i < serverTransactions.size(); i++) {
                AckedTransaction serverTx = serverTransactions.get(i);
                if (serverTx.getItemId() == geTransaction.getItemId() &&
                        serverTx.getQuantity() == geQuantity &&
                        serverTx.getPrice() == geTransaction.getPrice()) {
                    geTransaction.setGeTransactionAlreadyAdded(true);
                    serverTransactions.remove(i);
                    break;
                }
            }
        }
    }

    private void populateTransactionList() {
        transactionListPanel.removeAll();
        checkboxes.clear();
        for (Transaction transaction : geTransactions) {
            if(!transaction.isGeTransactionAlreadyAdded()) {
                TransactionCheckbox checkbox = createTransactionRow(transaction);
                checkboxes.add(checkbox);
                transactionListPanel.add(checkbox.panel);
                transactionListPanel.add(Box.createRigidArea(new Dimension(0, 5)));
            }
        }
        transactionListPanel.revalidate();
        transactionListPanel.repaint();
    }

    private TransactionCheckbox createTransactionRow(Transaction transaction) {
        JPanel rowPanel = new JPanel(new BorderLayout());
        rowPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        rowPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR, 1),
                new EmptyBorder(5, 10, 5, 10)
        ));
        rowPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 60));
        JCheckBox checkbox = new JCheckBox();
        checkbox.setBackground(ColorScheme.DARK_GRAY_COLOR);
        checkbox.addActionListener(e -> updateAddButtonState());
        rowPanel.add(checkbox, BorderLayout.WEST);
        rowPanel.add(createTransactionDetailsPanel(transaction), BorderLayout.CENTER);
        return new TransactionCheckbox(checkbox, rowPanel, transaction);
    }

    private JPanel createTransactionDetailsPanel(Transaction transaction) {
        JPanel detailsPanel = new JPanel(new GridBagLayout());
        detailsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.anchor = GridBagConstraints.WEST;
        gbc.insets = new Insets(2, 10, 2, 10);

        // Item icon
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.gridheight = 2;
        JLabel iconLabel = new JLabel();
        itemController.loadImage(transaction.getItemId(), i -> i.addTo(iconLabel));
        detailsPanel.add(iconLabel, gbc);

        gbc.gridx = 1;
        gbc.gridy = 0;
        gbc.gridheight = 1;
        gbc.weightx = 1.0;
        String itemName = itemController.getItemName(transaction.getItemId());
        JLabel nameLabel = new JLabel(itemName + " x" + transaction.getQuantity());
        nameLabel.setFont(FontManager.getRunescapeBoldFont());
        nameLabel.setForeground(Color.WHITE);
        detailsPanel.add(nameLabel, gbc);

        gbc.gridy = 1;
        String typeText = transaction.getType() == OfferStatus.BUY ? "Bought" : "Sold";
        String priceText = String.format("%s for %,d gp each", typeText, transaction.getPrice());
        JLabel priceLabel = new JLabel(priceText);
        priceLabel.setFont(FontManager.getRunescapeSmallFont());
        priceLabel.setForeground(Color.LIGHT_GRAY);
        detailsPanel.add(priceLabel, gbc);

        return detailsPanel;
    }

    private void updateAddButtonState() {
        boolean anySelected = checkboxes.stream().anyMatch(tc -> tc.checkbox.isSelected());
        addButton.setEnabled(anySelected);
    }

    @AllArgsConstructor
    private static class TransactionCheckbox {
        final JCheckBox checkbox;
        final JPanel panel;
        final Transaction transaction;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.controller.PremiumInstanceController;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.components.ItemSearchMultiSelect;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.util.HashSet;

@Singleton
public class PreferencesPanel extends JPanel {

    private final SuggestionPreferencesManager preferencesManager;
    private final JPanel sellOnlyButton;
    private final PreferencesToggleButton sellOnlyModeToggleButton;
    private final JPanel f2pOnlyButton;
    private final PreferencesToggleButton f2pOnlyModeToggleButton;
    private final ItemSearchMultiSelect blocklistDropdownPanel;

    @Inject
    public PreferencesPanel(
            SuggestionManager suggestionManager,
            SuggestionPreferencesManager preferencesManager,
            PremiumInstanceController premiumInstanceController,
            ItemController itemController) {
        super();
        this.preferencesManager = preferencesManager;
        blocklistDropdownPanel = new ItemSearchMultiSelect(
                () -> new HashSet<>(preferencesManager.blockedItems()),
                itemController::allItemIds,
                itemController::search,
                (bl) -> {
                    preferencesManager.setBlockedItems(bl);
                    suggestionManager.setSuggestionNeeded(true);
                },
                "Item blocklist...");
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        setBounds(0, 0, 300, 150);

        JLabel preferencesTitle = new JLabel("Suggestion Settings");
        preferencesTitle.setForeground(Color.WHITE);
        preferencesTitle.setFont(preferencesTitle.getFont().deriveFont(Font.BOLD));
        preferencesTitle.setAlignmentX(Component.CENTER_ALIGNMENT);
        preferencesTitle.setMinimumSize(new Dimension(300, preferencesTitle.getPreferredSize().height));
        preferencesTitle.setMaximumSize(new Dimension(300, preferencesTitle.getPreferredSize().height));
        preferencesTitle.setHorizontalAlignment(SwingConstants.CENTER);
        add(preferencesTitle);
        add(Box.createRigidArea(new Dimension(0, 8)));
        blocklistDropdownPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0), blocklistDropdownPanel.getBorder()));
        add(blocklistDropdownPanel);

        sellOnlyModeToggleButton = new PreferencesToggleButton("Disable sell-only mode", "Enable sell-only mode");
        sellOnlyButton = new JPanel();
        sellOnlyButton.setLayout(new BorderLayout());
        sellOnlyButton.setOpaque(false);
        add(sellOnlyButton);
        JLabel buttonText = new JLabel("Sell-only mode");
        sellOnlyButton.add(buttonText, BorderLayout.LINE_START);
        sellOnlyButton.add(sellOnlyModeToggleButton, BorderLayout.LINE_END);
        sellOnlyModeToggleButton.addItemListener(i ->
        {
            preferencesManager.setSellOnlyMode(sellOnlyModeToggleButton.isSelected());
            suggestionManager.setSuggestionNeeded(true);
        });
        add(Box.createRigidArea(new Dimension(0, 3)));

        f2pOnlyModeToggleButton = new PreferencesToggleButton("Disable F2P-only mode",  "Enable F2P-only mode");
        f2pOnlyButton = new JPanel();
        f2pOnlyButton.setLayout(new BorderLayout());
        f2pOnlyButton.setOpaque(false);
        add(f2pOnlyButton);
        JLabel f2pOnlyButtonText = new JLabel("F2P-only mode");
        f2pOnlyButton.add(f2pOnlyButtonText, BorderLayout.LINE_START);
        f2pOnlyButton.add(f2pOnlyModeToggleButton, BorderLayout.LINE_END);
        f2pOnlyModeToggleButton.addItemListener(i ->
        {
            preferencesManager.setF2pOnlyMode(f2pOnlyModeToggleButton.isSelected());
            suggestionManager.setSuggestionNeeded(true);
        });

        // Premium instances panel - moved to the bottom
        add(Box.createRigidArea(new Dimension(0, 3)));
        JPanel premiumInstancesPanel = new JPanel();
        premiumInstancesPanel.setLayout(new BorderLayout());
        premiumInstancesPanel.setOpaque(false);
        JLabel premiumInstancesLabel = new JLabel("Premium accounts:");
        JButton manageButton = new JButton("manage");
        manageButton.addActionListener(e -> {
            premiumInstanceController.loadAndOpenPremiumInstanceDialog();
        });
        premiumInstancesPanel.add(premiumInstancesLabel, BorderLayout.LINE_START);
        premiumInstancesPanel.add(manageButton, BorderLayout.LINE_END);
        add(premiumInstancesPanel);
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }

        sellOnlyModeToggleButton.setSelected(preferencesManager.getPreferences().isSellOnlyMode());
        sellOnlyButton.setVisible(true);
        f2pOnlyModeToggleButton.setSelected(preferencesManager.getPreferences().isF2pOnlyMode());
        f2pOnlyButton.setVisible(true);
        blocklistDropdownPanel.setVisible(true);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.*;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.IntervalDropdown;
import com.flippingcopilot.ui.flipsdialog.FlipsDialogController;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;


import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.Arrays;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
@Singleton
public class StatsPanelV2 extends JPanel {


    public final BufferedImage TRASH_ICON = ImageUtil.loadImageResource(getClass(), "/trash.png");
    public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
    public final Icon OPEN_ICON = new ImageIcon(ARROW_ICON);
    public final Icon CLOSE_ICON = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(90)));
    public final BufferedImage FLIPS_DIALOG_ICON = ImageUtil.recolorImage(ImageUtil.resizeImage(ImageUtil.loadImageResource(getClass(),"/popout-flips.png"), 20, 20),ColorScheme.LIGHT_GRAY_COLOR);
    public final Icon FLIPS_DIALOG = new ImageIcon(FLIPS_DIALOG_ICON);
    public final Icon HIGHLIGHTED_FLIPS_DIALOG = new ImageIcon(ImageUtil.luminanceScale(FLIPS_DIALOG_ICON, BUTTON_HOVER_LUMINANCE));


    private static final java.util.List<Integer> SESSION_STATS_INDS = Arrays.asList(3,4,5);

    // dependencies
    private final CopilotLoginManager copilotLoginManager;
    private final OsrsLoginManager osrsLoginManager;
    private final FlippingCopilotConfig config;
    private final FlipManager flipManager;
    private final SessionManager sessionManager;
    private final WebHookController webHookController;
    private final ClientThread clientThread;
    private final FlipsDialogController flipsDialogController;

    // state
    private IntervalDropdown intervalDropdown;
    private AccountDropdown accountDropdown;
    private final JButton sessionResetButton = new JButton("  Reset session ");
    private JPanel profitAndSubInfoPanel;
    private JPanel subInfoPanel;
    private final JPanel flipsPanel = new JPanel();
    private final JLabel totalProfitVal = new JLabel("0 gp");
    private final JLabel roiVal = new JLabel("-0.00%");
    private final JLabel flipsMadeVal = new JLabel("0");
    private final JLabel taxPaidVal = new JLabel("0 gp");
    private final JLabel sessionTimeVal = new JLabel("00:00:00");
    private final JLabel hourlyProfitVal = new JLabel("0 gp/hr");
    private final JLabel avgCashVal = new JLabel("0 gp");
    private final Paginator paginator;
    private final JButton flipsDialogButton = new JButton();

    private volatile boolean lastValidState = false;

    // Modified constructor
    @Inject
    public StatsPanelV2(CopilotLoginManager copilotLoginManager,
                        OsrsLoginManager osrsLoginManager,
                        FlippingCopilotConfig config,
                        FlipManager FlipManager,
                        SessionManager sessionManager,
                        WebHookController webHookController,
                        ClientThread clientThread,
                        FlipsDialogController flipsDialogController,
                        GeHistoryTransactionButton geHistoryTransactionButton) { // Added parameter
        this.copilotLoginManager = copilotLoginManager;
        this.osrsLoginManager = osrsLoginManager;
        this.sessionManager = sessionManager;
        this.webHookController = webHookController;
        this.config = config;
        this.flipManager = FlipManager;
        this.clientThread = clientThread;
        this.flipsDialogController = flipsDialogController;
        setLayout(new BorderLayout());

        setupTimeIntervalDropdown();
        setupProfitAndSubInfoPanel();
        setupSessionResetButton();
        setupFlipsDialogButton();

        flipsPanel.setLayout(new BoxLayout(flipsPanel, BoxLayout.Y_AXIS));
        flipsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        flipsPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

        JScrollPane scrollPane = new JScrollPane(flipsPanel);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        // Create a main panel with vertical layout
        JPanel mainPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel timeIntervalDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        timeIntervalDropdownWrapper.setBorder(BorderFactory.createEmptyBorder()); // No border
        timeIntervalDropdownWrapper.add(intervalDropdown, BorderLayout.CENTER);
        timeIntervalDropdownWrapper.add(sessionResetButton, BorderLayout.EAST);
        timeIntervalDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeIntervalDropdownWrapper.getPreferredSize().height));

        JPanel intervalRsAccountDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        accountDropdown = new AccountDropdown(
                copilotLoginManager::displayNameToAccountIdMap,
                flipManager::setIntervalAccount,
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        intervalRsAccountDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, intervalRsAccountDropdownWrapper.getPreferredSize().height));
        intervalRsAccountDropdownWrapper.add(timeIntervalDropdownWrapper, BorderLayout.NORTH);
        intervalRsAccountDropdownWrapper.add(accountDropdown, BorderLayout.SOUTH);

        mainPanel.add(intervalRsAccountDropdownWrapper);
        mainPanel.add(profitAndSubInfoPanel);
        mainPanel.add(scrollPane);

        add(mainPanel, BorderLayout.CENTER);

        paginator = new Paginator((i) -> refresh(true, lastValidState));

        // Create container for paginator and flips dialog button
        JPanel middleBottomPanel = new JPanel(new BorderLayout());
        middleBottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        middleBottomPanel.add(paginator, BorderLayout.CENTER);
        middleBottomPanel.add(flipsDialogButton, BorderLayout.EAST);

        // Create the very bottom panel for the GE History button
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bottomPanel.add(middleBottomPanel, BorderLayout.NORTH);
        bottomPanel.add(geHistoryTransactionButton, BorderLayout.SOUTH);

        add(bottomPanel, BorderLayout.SOUTH);

        flipManager.setFlipsChangedCallback(() -> refresh(true, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState()));
    }

    private void setupFlipsDialogButton() {
        flipsDialogButton.setIcon(FLIPS_DIALOG);
        flipsDialogButton.setOpaque(true);
        flipsDialogButton.setEnabled(true);
        flipsDialogButton.setFocusable(true);
        flipsDialogButton.setBorder(BorderFactory.createEmptyBorder(0,0,0,5));
        flipsDialogButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        flipsDialogButton.setToolTipText("Open flips dialog");

        flipsDialogButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                flipsDialogController.showFlipsDialog();
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                flipsDialogButton.setIcon(HIGHLIGHTED_FLIPS_DIALOG);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                flipsDialogButton.setIcon(FLIPS_DIALOG);
            }
        });
    }

    private void setupSessionResetButton() {
        sessionResetButton.setBorder(BorderFactory.createEmptyBorder());
        sessionResetButton.addActionListener((l) -> {
            JLabel resetIcon = new JLabel(new ImageIcon(TRASH_ICON));
            final int result = JOptionPane.showOptionDialog(resetIcon, "<html>Are you sure you want to reset the session?</html>",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");
            if (result == JOptionPane.YES_OPTION) {
                // send discord message before resetting session stats
                clientThread.invoke(() -> {
                    if (osrsLoginManager.isValidLoginState()) {
                        String displayName = osrsLoginManager.getPlayerDisplayName();
                        Integer accountId = copilotLoginManager.getAccountId(displayName);
                        if(accountId != null && accountId != -1) {
                            webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, accountId), sessionManager.getCachedSessionData(), displayName, true);
                            sessionManager.resetSession();
                            if (IntervalTimeUnit.SESSION.equals(intervalDropdown.getSelectedIntervalTimeUnit())) {
                                flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                            }
                        }
                        refresh(true, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
                    }
                });
            }
        });
    }

    private void setupTimeIntervalDropdown() {
        intervalDropdown = new IntervalDropdown((intervalTimeUnit, intervalValue) -> {
            long startTime = IntervalDropdown.calculateStartTime(intervalTimeUnit, intervalValue, sessionManager.getCachedSessionData().startTime);
            flipManager.setIntervalStartTime((int) startTime);
        }, IntervalDropdown.ALL_TIME, true);
    }

    public void resetIntervalDropdownToSession() {
        intervalDropdown.resetToSession();
    }

    private JPanel buildSubInfoPanelItem(String key, JLabel value, Color valueColor) {
        JPanel item = new JPanel(new BorderLayout());
        item.setBorder(new EmptyBorder(4, 2, 4, 2));
        item.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel keyLabel = new JLabel(key);
        keyLabel.setFont(FontManager.getRunescapeSmallFont());
        item.add(keyLabel, BorderLayout.WEST);
        value.setFont(FontManager.getRunescapeSmallFont());
        value.setForeground(valueColor);
        item.add(value, BorderLayout.EAST);
        item.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));
        return item;
    }

    private JPanel buildSubInfoPanel() {
        JPanel subInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        subInfoPanel.add(buildSubInfoPanelItem("ROI:", roiVal, UIUtilities.TOMATO));
        subInfoPanel.add(buildSubInfoPanelItem("Flips made:", flipsMadeVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Tax paid:", taxPaidVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Session time:", sessionTimeVal, ColorScheme.GRAND_EXCHANGE_ALCH));
        subInfoPanel.add(buildSubInfoPanelItem("Hourly profit:", hourlyProfitVal, Color.WHITE));
        subInfoPanel.add(buildSubInfoPanelItem("Avg wealth:", avgCashVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        subInfoPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(0,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(2, 5, 5, 5)));
        return subInfoPanel;
    }

    private void setupProfitAndSubInfoPanel() {
        profitAndSubInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        profitAndSubInfoPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Create the header panel that can be clicked to expand/collapse sub info
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(5, 0, 5, 0)));

        final JLabel profitTitle = new JLabel("Profit: ");
        profitTitle.setFont(FontManager.getRunescapeBoldFont());

        totalProfitVal.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        totalProfitVal.setFont(FontManager.getRunescapeBoldFont().deriveFont(24f));
        totalProfitVal.setHorizontalAlignment(SwingConstants.CENTER);

        // Use a panel to stack the profitTitle and totalProfitVal vertically
        JPanel profitTextPanel = new JPanel();
        profitTextPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        profitTextPanel.add(profitTitle);
        profitTextPanel.add(Box.createRigidArea(new Dimension(5, 0))); // Spacing between title and value
        profitTextPanel.add(totalProfitVal);
        profitTextPanel.setBorder(BorderFactory.createEmptyBorder(2,4,2,4));

        // Arrow label
        JLabel arrowLabel = new JLabel(OPEN_ICON);
        arrowLabel.setHorizontalAlignment(SwingConstants.CENTER);
        arrowLabel.setVerticalAlignment(SwingConstants.CENTER);
        arrowLabel.setPreferredSize(new Dimension(16, 16)); // Adjust size as needed

        // Add components to headerPanel
        headerPanel.add(profitTextPanel, BorderLayout.CENTER);
        headerPanel.add(arrowLabel, BorderLayout.EAST);

        // Create the sub-info panel
        subInfoPanel = buildSubInfoPanel();

        headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 70));
        profitAndSubInfoPanel.add(headerPanel);
        profitAndSubInfoPanel.add(subInfoPanel);

        // Mouse listener to handle expand/collapse and hover effects
        MouseAdapter headerMouseListener = new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                boolean isExpanded = subInfoPanel.isVisible();
                subInfoPanel.setVisible(!isExpanded);
                arrowLabel.setIcon(isExpanded ? OPEN_ICON : CLOSE_ICON);
                log.debug("profit and sub info panel clicked");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                headerPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                headerPanel.setCursor(Cursor.getDefaultCursor());
            }
        };

        // Add mouse listener to header components
        headerPanel.addMouseListener(headerMouseListener);
        totalProfitVal.addMouseListener(headerMouseListener);
        profitTitle.addMouseListener(headerMouseListener);

    }

    // called when:
    //
    // - time interval drop down changed (Swing EDT thread)
    // - session reset button pressed (Swing EDT thread)
    // - transaction processing downstream (ScheduledExecutorService)
    // - FlipTrackerV2 initialisation (ScheduledExecutorService)
    // - session stats updated (ScheduledExecutorService)
    // - plugin config changed (Client thread)
    // - page changed (Swing EDT thread)
    //

    public void refresh(boolean flipsMaybeChanged, boolean validLoginState) {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(() -> refresh(flipsMaybeChanged, validLoginState));
            return;
        }
        lastValidState = validLoginState;
        if (!validLoginState) {
            totalProfitVal.setText("0 gp");
            roiVal.setText("-0.00%");
            flipsMadeVal.setText("0");
            taxPaidVal.setText("0 gp");
            sessionTimeVal.setText("00:00:00");
            hourlyProfitVal.setText("0 gp/hr");
            avgCashVal.setText("0 gp");
            flipsPanel.removeAll();
            paginator.setTotalPages(1);
            boolean v = IntervalTimeUnit.SESSION.equals(intervalDropdown.getSelectedIntervalTimeUnit());
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(v));
            accountDropdown.setVisible(false);
            return;
        }

        accountDropdown.setSelectedAccountId(flipManager.getIntervalAccount());
        accountDropdown.setVisible(true);
        accountDropdown.refresh();

        SessionData sd = sessionManager.getCachedSessionData();
        Stats stats = flipManager.getIntervalStats();
        paginator.setTotalPages(1 + stats.flipsMade / 50);
        long s = System.nanoTime();
        if (flipsMaybeChanged) {
            flipsPanel.removeAll();
            flipManager.getPageFlips(paginator.getPageNumber(), 50).forEach(f -> flipsPanel.add(new FlipPanel(f, config)));
            // labels displayed to the user
            roiVal.setText(String.format("%.3f%%", stats.calculateRoi() * 100));
            roiVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            flipsMadeVal.setText(String.format("%d", stats.flipsMade));
            taxPaidVal.setText(UIUtilities.formatProfit(stats.taxPaid));
            totalProfitVal.setText(UIUtilities.formatProfit(stats.profit));
            totalProfitVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            log.debug("populating flips took {}ms", (System.nanoTime() - s) / 1000_000);
        }

        // 'Session time', 'Hourly profit' and 'Avg wealth' should only be set if 'Session' is select in the dropdown
        if (IntervalTimeUnit.SESSION.equals(intervalDropdown.getSelectedIntervalTimeUnit())) {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(true));
            long seconds = sd.durationMillis / 1000;
            float hoursFloat = (((float) seconds) / 3600.0f);
            long hourlyProfit = hoursFloat == 0 ? 0 : (long) (stats.profit / hoursFloat);
            String sessionTime = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            sessionTimeVal.setText(sessionTime);
            hourlyProfitVal.setText(UIUtilities.formatProfitWithoutGp(hourlyProfit) + " gp/hr");
            hourlyProfitVal.setForeground(UIUtilities.getProfitColor(hourlyProfit, config));
            avgCashVal.setText(UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp");
        } else {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(false));
        }
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;

public class UIUtilities {
    public static final String discordIcon = "/discord.png";
    public static final String githubIcon = "/github.png";
    public static final String logoutIcon = "/logout.png";
    public static final String internetIcon = "/internet.png";
    public static final String graphIcon = "/graph.png";

    static final float BUTTON_HOVER_LUMINANCE = 0.65f;
    public static final Color OUTDATED_COLOR = new Color(250, 74, 75);
    public static final Color BLUE_HIGHLIGHT_COLOR =  new Color(27, 173, 255, 79);
    public static final Color RED_HIGHLIGHT_COLOR = new Color(255, 20, 20, 79);
    public static final Color TOMATO = new Color(255,99,71);
    public static final Color DARK_GRAY = new Color(27, 27, 27);

    private static final NumberFormat PRECISE_DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.###",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );
    private static final NumberFormat DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.#",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );

    public static synchronized String quantityToRSDecimalStack(long quantity, boolean precise)
    {
        if (Long.toString(quantity).length() <= 4)
        {
            return QuantityFormatter.formatNumber(quantity);
        }

        long power = (long) Math.log10(quantity);

        // Output thousandths for values above a million
        NumberFormat format = precise && power >= 6
                ? PRECISE_DECIMAL_FORMATTER
                : DECIMAL_FORMATTER;

        return format.format(quantity / Math.pow(10, (Long.divideUnsigned(power, 3)) * 3))
                + new String[] {"", "K", "M", "B", "T"}[(int) (power / 3)];
    }

    public static Color getProfitColor(long profit, FlippingCopilotConfig config) {
        if (profit > 0) {
            return config.profitAmountColor();
        } else if (profit < 0) {
            return config.lossAmountColor();
        } else {
            return Color.WHITE;
        }
    }

    public static String formatProfit(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true) + " gp";
    }

    public static String formatProfitWithoutGp(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true);
    }

    public static String truncateString(String string, int length) {
        if (string.length() > length) {
            return string.substring(0, length) + "...";
        }
        return string;
    }

    static JLabel buildButton(BufferedImage icon, String tooltip, Runnable onClick) {
        JLabel label = new JLabel();
        label.setToolTipText(tooltip);
        label.setHorizontalAlignment(JLabel.CENTER);
        ImageIcon iconOff = new ImageIcon(icon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(icon, BUTTON_HOVER_LUMINANCE));
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                try {
                    onClick.run();
                } catch (Exception error) {}
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                label.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setIcon(iconOff);
            }
        });
        label.setIcon(iconOff);
        return label;
    }

    static JLabel buildUriButton(BufferedImage icon, String tooltip, String uriString) {
        return buildButton(icon, tooltip, () -> {
            try {
                Desktop desktop = Desktop.getDesktop();
                URI uri = new URI(uriString);
                desktop.browse(uri);
            } catch (Exception error) {}
        });
    }

    public static JPanel newVerticalBoxLayoutJPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        return panel;
    }
}

package com.flippingcopilot.ui;


import java.awt.Dimension;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JToggleButton;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

class PreferencesToggleButton extends JToggleButton
{
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;
    private final String unSelectedToolTipText;
    private final String selectedToolTipText;


    public PreferencesToggleButton(String selectedToolTipText, String unSelectedToolTipText) {
        super(OFF_SWITCHER);
        setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        setPreferredSize(new Dimension(25, 25));
        addItemListener(l -> updateTooltip());
        updateTooltip();
        this.selectedToolTipText = selectedToolTipText;
        this.unSelectedToolTipText = unSelectedToolTipText;
    }

    static
    {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(CopilotPanel.class, "/switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    private void updateTooltip()
    {
        setToolTipText(isSelected() ? selectedToolTipText :  unSelectedToolTipText);
    }
}

package com.flippingcopilot.ui;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.function.Consumer;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
public class Paginator extends JPanel {

	public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
	public final Icon ARROW_RIGHT = new ImageIcon(ARROW_ICON);
	public final Icon HIGHLIGHTED_ARROW_RIGHT = new ImageIcon(ImageUtil.luminanceScale(ARROW_ICON, BUTTON_HOVER_LUMINANCE));
	public final Icon ARROW_LEFT = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)));
	public final Icon HIGHLIGHTED_ARROW_LEFT = new ImageIcon(ImageUtil.luminanceScale(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)), BUTTON_HOVER_LUMINANCE));

	@Getter
	private int pageNumber = 1;
	@Getter
	private int totalPages = 1;
	private final JLabel statusText = new JLabel("Page 1 of 1", SwingUtilities.CENTER);
	private final JLabel arrowRight= new JLabel(ARROW_RIGHT);
	private final JLabel arrowLeft =  new JLabel(ARROW_LEFT);
	private final Consumer<Integer> onPageChange;

	public Paginator(Consumer<Integer> onPageChange) {
		this.onPageChange = onPageChange;
		this.statusText.setFont(FontManager.getRunescapeFont());
		this.arrowRight.setForeground(Color.blue);
		setLayout(new FlowLayout());
		add(arrowLeft);
		add(statusText);
		add(arrowRight);
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(3, 0, 0, 0));
		arrowLeft.addMouseListener(onDecreasePage());
		arrowRight.addMouseListener(onIncreasePage());
	}

	public void setTotalPages(int totalPages) {
		this.totalPages = totalPages;
		if(pageNumber > this.totalPages) {
			pageNumber = 1;
			onPageChange.accept(pageNumber);
		}
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	public void setTotalPagesWithoutEffect(int totalPages) {
		this.totalPages = totalPages;
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	public void setPageNumber(int pageNumber) {
		this.pageNumber = pageNumber;
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	private MouseAdapter onIncreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber < totalPages) {
					pageNumber++;
					onPageChange.accept(pageNumber);
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowRight.setIcon(HIGHLIGHTED_ARROW_RIGHT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowRight.setIcon(ARROW_RIGHT);
			}
		};
	}

	private MouseAdapter onDecreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber > 1) {
					pageNumber--;
					onPageChange.accept(pageNumber);
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowLeft.setIcon(HIGHLIGHTED_ARROW_LEFT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowLeft.setIcon(ARROW_LEFT);
			}
		};
	}
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.CopilotLoginController;
import com.flippingcopilot.manager.CopilotLoginManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;;

import static com.flippingcopilot.ui.UIUtilities.buildButton;

@Singleton
public class MainPanel extends PluginPanel {

    // dependencies
    public final LoginPanel loginPanel;
    public final CopilotPanel copilotPanel;
    private final CopilotLoginManager copilotLoginManager;
    private final CopilotLoginController copilotLoginController;

    private Boolean isLoggedInView;

    @Inject
    public MainPanel(CopilotPanel copilotPanel,
                     LoginPanel loginPanel,
                     CopilotLoginManager copilotLoginManager,
                     CopilotLoginController copilotLoginController) {
        super(false);
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(5, 6, 5, 6));
        this.copilotLoginManager = copilotLoginManager;
        this.copilotPanel = copilotPanel;
        this.loginPanel = loginPanel;
        this.copilotLoginController = copilotLoginController;
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        boolean shouldBeLoggedInView = copilotLoginManager.isLoggedIn();
        if(shouldBeLoggedInView) {
            if (isLoggedInView == null || !isLoggedInView) {
                renderLoggedInView();
            }
            copilotPanel.refresh();
        } else {
            if (isLoggedInView == null || isLoggedInView) {
                renderLoggedOutView();
            }
            loginPanel.refresh();
            copilotPanel.suggestionPanel.refresh();
        }
    }

    public void renderLoggedOutView() {
        removeAll();
        add(constructTopBar(false), BorderLayout.NORTH);
        loginPanel.showLoginErrorMessage("");
        add(loginPanel, BorderLayout.CENTER);
        revalidate();
        isLoggedInView = false;
    }

    public void renderLoggedInView() {
        removeAll();
        add(constructTopBar(true), BorderLayout.NORTH);
        add(copilotPanel, BorderLayout.CENTER);
        revalidate();
        isLoggedInView = true;
    }

    private JPanel constructTopBar(boolean isLoggedIn) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setLayout(new BorderLayout());
        JPanel topBar = new JPanel();
        topBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int columns = isLoggedIn ? 4 : 3;
        topBar.setLayout(new GridLayout(1, columns));

        JLabel discord = buildTopBarUriButton(UIUtilities.discordIcon,
                "Flipping Copilot Discord",
                "https://discord.gg/UyQxA4QJAq");
        topBar.add(discord);

        JLabel website = buildTopBarUriButton(UIUtilities.internetIcon,
                "Flipping Copilot website",
                "https://flippingcopilot.com");
        topBar.add(website);

        if (isLoggedIn) {
            BufferedImage icon = ImageUtil.loadImageResource(getClass(), UIUtilities.logoutIcon);
            JLabel logout = buildButton(icon, "Log out", () -> {
                copilotLoginController.onLogout();
                renderLoggedOutView();
            });
            topBar.add(logout);
        }

        container.add(topBar);
        container.setBorder(new EmptyBorder(3, 0, 10, 0));
        return container;
    }

    private JLabel buildTopBarUriButton(String iconPath, String tooltip, String uriString) {
        BufferedImage icon = ImageUtil.loadImageResource(getClass(), iconPath);
        return buildButton(icon, tooltip, () -> {
            LinkBrowser.browse(uriString);
        });
    }

}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.GrandExchange;
import com.flippingcopilot.controller.OfferHandler;
import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.Suggestion;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.widgets.*;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class OfferEditor {
    private final OfferManager offerManager;
    private final OfferHandler offerHandler;
    private final Client client;

    private Widget text;
    private Widget priceGraphText;
    private static final int MOUSE_OFF_TEXT_COLOR = 0x0040FF;
    private static final int MOUSE_OFF_ERROR_TEXT_COLOR = 0xAA2222;

    public OfferEditor(OfferManager offerManager, Widget parent, OfferHandler offerHandler, Client client) {
        this.offerManager = offerManager;
        this.offerHandler = offerHandler;
        this.client = client;
        if (parent == null) {
            return;
        }

        text = parent.createChild(-1, WidgetType.TEXT);
        prepareTextWidget(text, WidgetTextAlignment.LEFT, WidgetPositionMode.ABSOLUTE_TOP, 40, 10);
    }

    private void prepareTextWidget(Widget widget, int xAlignment, int yMode, int yOffset, int xOffset) {
        widget.setTextColor(MOUSE_OFF_TEXT_COLOR);
        widget.setFontId(FontID.VERDANA_11_BOLD);
        widget.setYPositionMode(yMode);
        widget.setOriginalX(xOffset);
        widget.setOriginalY(yOffset);
        widget.setOriginalHeight(20);
        widget.setXTextAlignment(xAlignment);
        widget.setWidthMode(WidgetSizeMode.MINUS);
        widget.revalidate();
    }

    public void showSuggestion(Suggestion suggestion) {
        var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);
        if (offerHandler.isSettingQuantity()) {
            if (currentItemId != suggestion.getItemId()) {
                return;
            }
            if (!suggestion.getType().equals(offerHandler.getOfferType())) {
                return;
            }

            shiftChatboxWidgetsDown();
            showQuantity(suggestion.getQuantity());
        } else if (offerHandler.isSettingPrice()) {
            if (currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(offerHandler.getOfferType())) {
                int price = offerManager.getViewedSlotItemPrice();
                if (offerHandler.getViewedSlotPriceErrorText() != null && price <= 0) {
                    shiftChatboxWidgetsDown();
                    setErrorText(offerHandler.getViewedSlotPriceErrorText());
                    return;
                }

                if (offerManager.getViewedSlotItemId() == currentItemId) {
                    shiftChatboxWidgetsDown();
                    if (offerHandler.getViewedSlotPriceErrorText() != null) {
                        showPriceWithWarning(price, offerHandler.getViewedSlotPriceErrorText());
                    } else {
                        showPrice(price);
                    }
                }
            } else {
                shiftChatboxWidgetsDown();
                showPrice(suggestion.getPrice());
            }
        }
    }

    private void showQuantity(int quantity) {
        text.setText("set to Copilot quantity: " + quantity);
        text.setAction(1, "Set quantity");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(quantity);
        });
    }

    public void showPrice(int price) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp");
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(price);
        });
    }

    private void showPriceWithWarning(int price, String warning) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp. " + warning);
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(price);
        });
    }

    private void setHoverListeners(Widget widget) {
        widget.setHasListener(true);
        widget.setOnMouseRepeatListener((JavaScriptCallback) ev -> widget.setTextColor(0xFFFFFF));
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> widget.setTextColor(MOUSE_OFF_TEXT_COLOR));
    }

    private void setErrorText(String message) {
        text.setText(message);
        text.setTextColor(MOUSE_OFF_ERROR_TEXT_COLOR);
        text.revalidate();
    }

    private void shiftChatboxWidgetsDown() {
        Widget chatboxTitle = client.getWidget(ComponentID.CHATBOX_TITLE);
        if (chatboxTitle != null) {
            chatboxTitle.setOriginalY(chatboxTitle.getOriginalY() + 7);
            chatboxTitle.revalidate();
        }
    }
}

package com.flippingcopilot.ui;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

@Getter
public class Spinner extends JPanel {
    private final JLabel spinnerLabel = new JLabel();

    public Spinner() {
        setLayout(new GridBagLayout());
        setOpaque(false);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = GridBagConstraints.REMAINDER;
        gbc.gridy = GridBagConstraints.REMAINDER;
        gbc.weightx = 1;
        gbc.weighty = 1;
        gbc.anchor = GridBagConstraints.CENTER;

        spinnerLabel.setPreferredSize(new Dimension(30, 30));
        add(spinnerLabel, gbc);
        setUpIcon();
        hide();
    }

    public void show() {
        spinnerLabel.setVisible(true);
    }

    public void hide() {
        spinnerLabel.setVisible(false);
    }

    private void setUpIcon() {
        IconTextField.Icon icon = IconTextField.Icon.LOADING;
        final ImageIcon imageIcon = new ImageIcon(Objects.requireNonNull(IconTextField.class.getResource(icon.getFile())));
        spinnerLabel.setIcon(imageIcon);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.GrandExchange;
import com.flippingcopilot.controller.HighlightController;
import com.flippingcopilot.controller.PremiumInstanceController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.graph.PriceGraphController;
import joptsimple.internal.Strings;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;

import static com.flippingcopilot.ui.UIUtilities.*;
import static com.flippingcopilot.util.Constants.MIN_GP_NEEDED_TO_FLIP;


@Singleton
@Slf4j
public class SuggestionPanel extends JPanel {

    // dependencies
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final AccountStatusManager accountStatusManager;
    public final PauseButton pauseButton;
    private final BlockButton blockButton;
    private final OsrsLoginManager osrsLoginManager;
    private final Client client;
    private final PausedManager pausedManager;
    private final GrandExchangeUncollectedManager uncollectedManager;
    private final ClientThread clientThread;
    private final HighlightController highlightController;
    private final ItemManager itemManager;
    private final GrandExchange grandExchange;
    private final PriceGraphController priceGraphController;
    private final PremiumInstanceController premiumInstanceController;
    private final FlipManager flipManager;
    private final CopilotLoginManager copilotLoginManager;

    private final JLabel suggestionText = new JLabel();
    private final JLabel suggestionIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png")));
    private final JPanel suggestionTextContainer = new JPanel();
    private final JLabel additionalInfoText = new JLabel();
    public final Spinner spinner = new Spinner();
    private JLabel skipButton;
    private final JPanel buttonContainer = new JPanel();
    private JLabel graphButton;
    private final JPanel suggestedActionPanel;
    private final PreferencesPanel preferencesPanel;
    private final JLayeredPane layeredPane = new JLayeredPane();
    private boolean isPreferencesPanelVisible = false;
    private final JLabel gearButton;
    private String innerSuggestionMessage;
    private String highlightedColor = "yellow";

    @Setter
    private String serverMessage = "";


    @Inject
    public SuggestionPanel(FlippingCopilotConfig config,
                           SuggestionManager suggestionManager,
                           AccountStatusManager accountStatusManager,
                           PauseButton pauseButton,
                           BlockButton blockButton,
                           PreferencesPanel preferencesPanel,
                           OsrsLoginManager osrsLoginManager,
                           Client client, PausedManager pausedManager,
                           GrandExchangeUncollectedManager uncollectedManager,
                           ClientThread clientThread,
                           HighlightController highlightController,
                           ItemManager itemManager,
                           GrandExchange grandExchange, PriceGraphController priceGraphController, PremiumInstanceController premiumInstanceController, FlipManager flipManager, CopilotLoginManager copilotLoginManager) {
        this.preferencesPanel = preferencesPanel;
        this.config = config;
        this.suggestionManager = suggestionManager;
        this.accountStatusManager = accountStatusManager;
        this.pauseButton = pauseButton;
        this.blockButton = blockButton;
        this.osrsLoginManager = osrsLoginManager;
        this.client = client;
        this.pausedManager = pausedManager;
        this.uncollectedManager = uncollectedManager;
        this.clientThread = clientThread;
        this.highlightController = highlightController;
        this.itemManager = itemManager;
        this.grandExchange = grandExchange;
        this.priceGraphController = priceGraphController;
        this.premiumInstanceController = premiumInstanceController;
        this.flipManager = flipManager;
        this.copilotLoginManager = copilotLoginManager;

        // Create the layered pane first
        layeredPane.setLayout(null);  // LayeredPane needs null layout

        // Create a main panel that will hold all the regular components
        suggestedActionPanel = new JPanel(new BorderLayout());
        suggestedActionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestedActionPanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 10, 5));
        suggestedActionPanel.setBounds(0, 0, 300, 150);  // Set appropriate size

        JPanel suggestionContainer = new JPanel(new BorderLayout());
        suggestionContainer.setOpaque(true);
        suggestionContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.setPreferredSize(new Dimension(0, 85));
        suggestedActionPanel.add(suggestionContainer, BorderLayout.CENTER);

        // Center panel for main suggestion content (icon and text)
        JPanel suggestionMainPanel = new JPanel();
        suggestionMainPanel.setLayout(new CardLayout());
        suggestionMainPanel.setOpaque(true);
        suggestionMainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.add(suggestionMainPanel, BorderLayout.CENTER);

        suggestionTextContainer.setLayout(new BoxLayout(suggestionTextContainer, BoxLayout.X_AXIS));
        suggestionTextContainer.add(Box.createHorizontalGlue());
        suggestionTextContainer.add(suggestionIcon);
        suggestionTextContainer.add(suggestionText);
        suggestionTextContainer.add(Box.createHorizontalGlue());
        suggestionTextContainer.setOpaque(true);
        suggestionTextContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionIcon.setVisible(false);
        suggestionIcon.setOpaque(true);
        suggestionIcon.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionIcon.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));

        suggestionText.setHorizontalAlignment(SwingConstants.CENTER);
        suggestionText.setBorder(BorderFactory.createEmptyBorder(0, 3, 0, 3));
        suggestionMainPanel.add(suggestionTextContainer);

        suggestionMainPanel.add(spinner);

        // Add expected profit text to SOUTH of suggestionContainer
        additionalInfoText.setHorizontalAlignment(SwingConstants.CENTER);
        additionalInfoText.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        additionalInfoText.setText("");
        additionalInfoText.setBorder(BorderFactory.createEmptyBorder(0, 6, 8, 6)); // top, left, bottom, right
        suggestionContainer.add(additionalInfoText, BorderLayout.SOUTH);

        setupButtonContainer();
        suggestedActionPanel.add(buttonContainer, BorderLayout.SOUTH);


        layeredPane.add(suggestedActionPanel, JLayeredPane.DEFAULT_LAYER);

        // Build the suggestion preferences panel:
        this.preferencesPanel.setVisible(false);
        layeredPane.add(this.preferencesPanel, JLayeredPane.DEFAULT_LAYER);

        // Create and add the gear button
        BufferedImage gearIcon = ImageUtil.loadImageResource(getClass(), "/preferences-icon.png");
        gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
        BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
        gearButton = buildButton(recoloredIcon, "Settings", () -> {});
        gearButton.setEnabled(true);
        gearButton.setFocusable(true);
        gearButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        gearButton.setOpaque(true);
        ImageIcon iconOff = new ImageIcon(recoloredIcon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(recoloredIcon, BUTTON_HOVER_LUMINANCE));
        // Replace the existing gear button MouseAdapter with this implementation
        gearButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (!SwingUtilities.isEventDispatchThread()) {
                    SwingUtilities.invokeLater(() -> handleGearClick());
                    return;
                }
                handleGearClick();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                gearButton.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                gearButton.setIcon(iconOff);
            }
        });
        gearButton.setOpaque(true);
        gearButton.setBounds(5, 5, 20, 20);
        layeredPane.add(gearButton, JLayeredPane.PALETTE_LAYER);

        // Set up the main panel
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setPreferredSize(new Dimension(0, 150));

        add(layeredPane);

        // Add a component listener to handle resizing
        addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                preferencesPanel.setBounds(0, 0, getWidth(), getHeight());
                suggestedActionPanel.setBounds(0, 0, getWidth(), getHeight());
                layeredPane.setPreferredSize(new Dimension(getWidth(), getHeight()));
            }
        });
    }

    private void handleGearClick() {
        isPreferencesPanelVisible = !isPreferencesPanelVisible;
        preferencesPanel.setVisible(isPreferencesPanelVisible);
        suggestedActionPanel.setVisible(!isPreferencesPanelVisible);
        refresh();
        layeredPane.revalidate();
        layeredPane.repaint();
    }

    private void setupButtonContainer() {
        buttonContainer.setLayout(new BorderLayout());
        buttonContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel centerPanel = new JPanel(new GridLayout(1, 5, 15, 0));
        centerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/graph.png");
        graphButton = buildButton(graphIcon, "Price graph", () -> {
            if(config.priceGraphWebsite().equals(FlippingCopilotConfig.PriceGraphWebsite.FLIPPING_COPILOT)) {
                Suggestion suggestion = suggestionManager.getSuggestion();
                priceGraphController.showPriceGraph( suggestion.getName(),true);
            } else {
                Suggestion suggestion = suggestionManager.getSuggestion();
                String url = config.priceGraphWebsite().getUrl(suggestion.getName(), suggestion.getItemId());
                LinkBrowser.browse(url);
            }
        });
        centerPanel.add(graphButton);

        JPanel emptyPanel = new JPanel();
        emptyPanel.setOpaque(false);
        centerPanel.add(emptyPanel);
        centerPanel.add(pauseButton);
        centerPanel.add(blockButton);

        BufferedImage skipIcon = ImageUtil.loadImageResource(getClass(), "/skip.png");
        skipButton = buildButton(skipIcon, "Skip suggestion", () -> {
            showLoading();
            Suggestion s = suggestionManager.getSuggestion();
            accountStatusManager.setSkipSuggestion(s != null ? s.getId() : -1);
            suggestionManager.setSuggestionNeeded(true);
        });
        centerPanel.add(skipButton);

        buttonContainer.add(centerPanel, BorderLayout.CENTER);
    }


    private void setItemIcon(int itemId) {
        AsyncBufferedImage image = itemManager.getImage(itemId);
        if (image != null) {
            image.addTo(suggestionIcon);
            suggestionIcon.setVisible(true);
        }
    }

    public void setAdditionalInfoText(String text) {
        additionalInfoText.setText("<html><center>" + text + "</center></html>");
    }

    public void updateSuggestion(Suggestion suggestion) {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String suggestionString = "<html><center>";
        suggestionTextContainer.setVisible(false);
        additionalInfoText.setText("");
        switch (suggestion.getType()) {
            case "wait":
                suggestionString += "Wait <br>";
                break;
            case "abort":
                suggestionString += "Abort offer for<br><FONT COLOR=white>" + suggestion.getName() + "<br></FONT>";
                setItemIcon(suggestion.getItemId());
                break;
            case "buy":
            case "sell":
                String capitalisedAction = suggestion.getType().equals("buy") ? "Buy" : "Sell";
                suggestionString += capitalisedAction +
                        " <FONT COLOR=" + highlightedColor + ">" + formatter.format(suggestion.getQuantity()) + "</FONT><br>" +
                        "<FONT COLOR=white>" + suggestion.getName() + "</FONT><br>" +
                        "for <FONT COLOR=" + highlightedColor + ">" + formatter.format(suggestion.getPrice()) + "</FONT> gp<br>";
                setItemIcon(suggestion.getItemId());
                break;
            default:
                suggestionString += "Error processing suggestion<br>";
        }
        String additionalInfoMessage = Strings.isNullOrEmpty(suggestion.getMessage()) ? "" : "<br>" + suggestion.getMessage();

        suggestionString += "</center><html>";
        innerSuggestionMessage = "";
        if(!suggestion.getType().equals("wait")) {
            setButtonsVisible(true);
        }
        suggestionText.setText(suggestionString);
        suggestionText.setMaximumSize(new Dimension(suggestionText.getPreferredSize().width, Integer.MAX_VALUE));
        if (suggestion.getType().equals("buy")) {
            setAdditionalInfoText(formatExpectedProfitAndDuration(suggestion.getExpectedProfit(), suggestion.getExpectedDuration()) + additionalInfoMessage);
        } else if (suggestion.getType().equals("sell")) {
            Transaction t = new Transaction();
            t.setItemId(suggestion.getItemId());
            t.setPrice(suggestion.getPrice());
            t.setQuantity(suggestion.getQuantity());
            t.setAmountSpent(suggestion.getPrice() * suggestion.getQuantity());
            t.setType(OfferStatus.SELL);
            Integer accountId = copilotLoginManager.getAccountId(osrsLoginManager.getLastDisplayName());
            String text = "";
            if (accountId != null) {
                Long profit = flipManager.estimateTransactionProfit(accountId, t);
                if (profit != null) {
                    text = formatSellProfitLossAndDuration((double) profit, suggestion.getExpectedDuration());
                }
            }
            setAdditionalInfoText(text + additionalInfoMessage);
        } else {
            setAdditionalInfoText(additionalInfoMessage);
        }

        suggestionTextContainer.setVisible(true);
        suggestionTextContainer.revalidate();
        suggestionTextContainer.repaint();
    }

    public void suggestCollect() {
        setMessage("Collect items");
        setButtonsVisible(false);
    }

    public void suggestAddGp() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        setMessage("Add " +
                "at least <FONT COLOR=" + highlightedColor + ">" + formatter.format(MIN_GP_NEEDED_TO_FLIP)
                + "</FONT> gp<br>to your inventory<br>"
                + "to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void suggestOpenGe() {
        setMessage("Open the Grand Exchange<br>"
                + "to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void setIsPausedMessage() {
        setMessage("Suggestions are paused");
        setButtonsVisible(false);
    }

    public void setMessage(String message) {
        additionalInfoText.setVisible(false);
        innerSuggestionMessage = message;
        setButtonsVisible(false);

        // Check if message contains "<manage>"
        String displayMessage = message;
        if (message != null && message.contains("<manage>")) {
            // Replace <manage> with a styled link
            displayMessage = message.replace("<manage>",
                    "<a href='#' style='text-decoration:underline'>manage</a>");

            // Add mouse listener if not already present
            boolean hasListener = false;
            for (MouseListener listener : suggestionText.getMouseListeners()) {
                if (listener instanceof ManageClickListener) {
                    hasListener = true;
                    break;
                }
            }

            if (!hasListener) {
                suggestionText.addMouseListener(new ManageClickListener());
                // Make the label show a hand cursor when hovering over it
                suggestionText.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
        } else {
            suggestionText.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
        }
        suggestionText.setText("<html><center>" + displayMessage + "<br>" + serverMessage + "</center></html>");
        suggestionText.setMaximumSize(new Dimension(suggestionText.getPreferredSize().width, Integer.MAX_VALUE));
        suggestionTextContainer.revalidate();
        suggestionTextContainer.repaint();
    }

    private class ManageClickListener extends MouseAdapter {
        @Override
        public void mouseClicked(MouseEvent e) {
            String text = suggestionText.getText();
            if (text.contains("manage")) {
                premiumInstanceController.loadAndOpenPremiumInstanceDialog();
            }
        }
    }

    public boolean isCollectItemsSuggested() {
        return suggestionText.isVisible() && "Collect items".equals(innerSuggestionMessage);
    }

    public void showLoading() {
        suggestionTextContainer.setVisible(false);
        setServerMessage("");
        spinner.show();
        setButtonsVisible(false);
        suggestionIcon.setVisible(false);
        additionalInfoText.setText("");
        additionalInfoText.setVisible(false);
        suggestionText.setText("");
    }

    public void hideLoading() {
        spinner.hide();
        suggestionTextContainer.setVisible(true);
        additionalInfoText.setVisible(true);
    }

    private void setButtonsVisible(boolean visible) {
        skipButton.setVisible(visible);
        blockButton.setVisible(visible);
        graphButton.setVisible(visible);
        suggestionIcon.setVisible(visible);
    }

    public void displaySuggestion() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return;
        }
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if(accountStatus == null) {
            return;
        }
        setServerMessage(suggestion.getMessage());
        boolean collectNeeded = accountStatus.isCollectNeeded(suggestion);
        if(collectNeeded && !uncollectedManager.HasUncollected(osrsLoginManager.getAccountHash())) {
            log.warn("tick {} collect is suggested but there is nothing to collect! suggestion: {} {} {}", client.getTickCount(), suggestion.getType(), suggestion.getQuantity(), suggestion.getItemId());
        }
        if (collectNeeded) {
            suggestCollect();
        } else if(suggestion.getType().equals("wait") && !grandExchange.isOpen() && accountStatus.emptySlotExists()) {
            suggestOpenGe();
        } else if (suggestion.getType().equals("wait") && accountStatus.moreGpNeeded()) {
            suggestAddGp();
        }  else {
            updateSuggestion(suggestion);
        }
        highlightController.redraw();
    }

    public void refresh() {
        log.debug("refreshing suggestion panel {}", client.getGameState());
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        if(isPreferencesPanelVisible) {
            preferencesPanel.refresh();
        }
        if (pausedManager.isPaused()) {
            hideLoading();
            setIsPausedMessage();
            return;
        }

        String errorMessage = osrsLoginManager.getInvalidStateDisplayMessage();
        if (errorMessage != null) {
            hideLoading();
            setMessage(errorMessage);
            return;
        }

        if(suggestionManager.isSuggestionRequestInProgress()) {
            showLoading();
            return;
        }
        hideLoading();

        final HttpResponseException suggestionError = suggestionManager.getSuggestionError();
        if(suggestionError != null) {
            highlightController.redraw();
            setMessage("Error: " + suggestionError.getMessage());
            return;
        }

        if(!client.isClientThread()) {
            clientThread.invoke(this::displaySuggestion);
        } else {
            displaySuggestion();
        }
    }

    private String formatSellProfitLossAndDuration(Double expectedProfit, Double expectedDuration) {
        String formattedProfit = formatProfit(expectedProfit);
        Color color = config.profitAmountColor();
        if(expectedProfit < 0) {
            color = config.lossAmountColor();
        }
        String colorHex = String.format("#%06X", (0xFFFFFF & color.getRGB()));
        String text = "<b><font color='" + colorHex + "'>" + formattedProfit + "</font></b> profit";
        if (expectedDuration != null) {
            String formattedDuration = formatDuration(expectedDuration);
            text += " in <b>" + formattedDuration + "</b>";
        }
        return text;
    }

    private String formatExpectedProfitAndDuration(Double expectedProfit, Double expectedDuration) {
        if (expectedProfit == null || expectedDuration == null) {
            return "";
        }
        String formattedProfit = formatProfit(expectedProfit);
        String formattedDuration = formatDuration(expectedDuration);
        Color profitColor = config.profitAmountColor();

        String colorHex = String.format("#%06X", (0xFFFFFF & profitColor.getRGB()));
        return "<b><font color='" + colorHex + "'>" + formattedProfit + "</font></b> profit in <b>" + formattedDuration + "</b>";
    }

    private String formatProfit(double profit) {
        if (Math.abs(profit) >= 1_000_000) {
            return String.format("%.1fM", profit / 1_000_000).replace(".0", "");
        } else if (Math.abs(profit) >= 1_000) {
            return String.format("%.1fK", profit / 1_000).replace(".0", "");
        } else {
            return String.format("%.0f", profit);
        }
    }

    private String formatDuration(double durationSeconds) {
        int totalMinutes = (int) Math.round(durationSeconds / 60.0);
        // Round to nearest 5 minutes
        totalMinutes = Math.round(totalMinutes / 5.0f) * 5;
        totalMinutes = Math.max(totalMinutes, 5);
        if (totalMinutes < 60) {
            return totalMinutes + "min";
        } else {
            int hours = totalMinutes / 60;
            int minutes = totalMinutes % 60;
            if (minutes == 0) {
                return hours + "h";
            } else {
                return hours + "h " + minutes + "m";
            }
        }
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.PremiumInstanceStatus;
import com.flippingcopilot.model.SuggestionManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

@Slf4j
public class PremiumInstancePanel extends JPanel {

    private final CardLayout cardLayout;
    private final JPanel cardPanel;
    private final List<JComboBox<String>> instanceDropdowns;
    private final FlippingCopilotConfig config;
    private final ApiRequestHandler apiRequestHandler;
    private final SuggestionManager suggestionManager;

    public PremiumInstancePanel(FlippingCopilotConfig config, ApiRequestHandler apiRequestHandler, SuggestionManager suggestionManager) {
        this.config = config;
        this.apiRequestHandler = apiRequestHandler;
        this.suggestionManager = suggestionManager;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        cardLayout = new CardLayout();
        cardPanel = new JPanel(cardLayout);
        cardPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create loading panel
        JPanel loadingPanel = createLoadingPanel();
        cardPanel.add(loadingPanel, "loading");

        // Create error panel container (will be populated when error occurs)
        JPanel errorPanel = new JPanel(new BorderLayout());
        errorPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.add(errorPanel, "error");

        // Create management panel container (will be populated when data loads)
        JPanel managementPanel = new JPanel(new BorderLayout());
        managementPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.add(managementPanel, "management");

        add(cardPanel, BorderLayout.CENTER);

        instanceDropdowns = new ArrayList<>();
    }

    private JPanel createLoadingPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(0, 0, 10, 0);

        Spinner spinner = new Spinner();
        spinner.show();
        panel.add(spinner, gbc);

        gbc.gridy = 1;
        JLabel loadingLabel = new JLabel("Loading premium account data");
        loadingLabel.setForeground(Color.WHITE);
        panel.add(loadingLabel, gbc);

        return panel;
    }

    public void showLoading() {
        cardLayout.show(cardPanel, "loading");
    }

    public void showError(String errorMessage) {
        JPanel errorPanel = (JPanel) cardPanel.getComponent(1); // error panel
        errorPanel.removeAll();
        errorPanel.setLayout(new GridBagLayout());

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        JLabel errorLabel = new JLabel("<html><center>" + errorMessage + "</center></html>");
        errorLabel.setForeground(Color.RED);
        errorLabel.setHorizontalAlignment(SwingConstants.CENTER);
        errorPanel.add(errorLabel, gbc);

        cardLayout.show(cardPanel, "error");
    }

    public void showManagementView(PremiumInstanceStatus status) {
        JPanel managementPanel = (JPanel) cardPanel.getComponent(2); // management panel
        managementPanel.removeAll();
        managementPanel.setLayout(new BorderLayout());
        managementPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        managementPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create header panel for the count label
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new BoxLayout(headerPanel, BoxLayout.Y_AXIS));
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add premium instances count
        JLabel countLabel = new JLabel("You have " + status.getPremiumInstancesCount() + " premium accounts");
        countLabel.setFont(countLabel.getFont().deriveFont(Font.BOLD));
        countLabel.setForeground(Color.WHITE);
        countLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        headerPanel.add(countLabel);
        headerPanel.add(Box.createRigidArea(new Dimension(0, 15)));

        // Add header to the top of the management panel
        managementPanel.add(headerPanel, BorderLayout.NORTH);

        // Clear existing dropdowns
        instanceDropdowns.clear();

        // Create a panel for the scrollable content
        JPanel scrollContent = new JPanel();
        scrollContent.setLayout(new BoxLayout(scrollContent, BoxLayout.Y_AXIS));
        scrollContent.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add dropdowns for each instance
        for (int i = 0; i < status.getPremiumInstancesCount(); i++) {
            JPanel instancePanel = new JPanel();
            instancePanel.setLayout(new FlowLayout(FlowLayout.LEFT));
            instancePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            instancePanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 35));

            JLabel instanceLabel = new JLabel("Premium account " + (i + 1) + ":");
            instanceLabel.setForeground(Color.WHITE);
            instanceLabel.setPreferredSize(new Dimension(130, 25));
            instancePanel.add(instanceLabel);

            JComboBox<String> dropdown = new JComboBox<>();
            dropdown.setPreferredSize(new Dimension(200, 25));

            // Add current assignment if exists
            String currentAssignment = null;
            if (i < status.getCurrentlyAssignedDisplayNames().size()) {
                dropdown.addItem("Unassigned");
                currentAssignment = status.getCurrentlyAssignedDisplayNames().get(i);
                dropdown.addItem(currentAssignment);
                dropdown.setSelectedIndex(1);
            } else {
                dropdown.addItem("Unassigned");
            }

            // Add available names
            for (String availableName : status.getAvailableDisplayNames()) {
                if (!availableName.equals(currentAssignment)) {
                    dropdown.addItem(availableName);
                }
            }

            instancePanel.add(dropdown);
            instanceDropdowns.add(dropdown);

            scrollContent.add(instancePanel);
            scrollContent.add(Box.createRigidArea(new Dimension(0, 5)));
        }

        // Add vertical glue to push everything to the top
        scrollContent.add(Box.createVerticalGlue());

        // Create a scroll pane for the content
        JScrollPane scrollPane = new JScrollPane(scrollContent);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add the scroll pane to the center of the management panel
        managementPanel.add(scrollPane, BorderLayout.CENTER);

        // Add bottom panel with changes remaining and update button
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bottomPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));

        JLabel changesLabel = new JLabel("Changes remaining (re-charges 1 per day): " + status.getChangesRemaining());
        changesLabel.setForeground(config.lossAmountColor());
        changesLabel.setToolTipText("Remaining updates. This limit recharges by 1 every day up to a max of 12.");
        bottomPanel.add(changesLabel, BorderLayout.WEST);

        JButton updateButton = new JButton("Update");
        // Disable the update button if no changes remaining
        updateButton.setEnabled(status.getChangesRemaining() > 0);
        // Add tooltip to explain why button is disabled when changes = 0
        if (status.getChangesRemaining() <= 0) {
            updateButton.setToolTipText("No changes remaining. Wait for daily recharge.");
        }

        updateButton.addActionListener(e -> {
            this.showLoading();
            Consumer<PremiumInstanceStatus> c = (s) -> {
                SwingUtilities.invokeLater(() -> {  // Make sure UI updates happen on EDT
                    if (s.getLoadingError() != null && !s.getLoadingError().isEmpty()) {
                        this.showError(s.getLoadingError());
                    } else {
                        this.showManagementView(s);
                        suggestionManager.setSuggestionNeeded(true);
                    }
                });
            };
            List<String> desiredAssignedDisplayNames = new ArrayList<>();
            for (JComboBox<String> dropdown : instanceDropdowns) {
                String selectedName = (String) dropdown.getSelectedItem();
                if (selectedName != null && !selectedName.equals("Unassigned") && !desiredAssignedDisplayNames.contains(selectedName)) {
                    desiredAssignedDisplayNames.add(selectedName);
                }
            }
            apiRequestHandler.asyncUpdatePremiumInstances(c, desiredAssignedDisplayNames);
        });
        bottomPanel.add(updateButton, BorderLayout.EAST);

        // Add the bottom panel to the south of the management panel
        managementPanel.add(bottomPanel, BorderLayout.SOUTH);

        cardLayout.show(cardPanel, "management");
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;

@Singleton
public class ControlPanel extends JPanel {

    private final SuggestionPreferencesManager preferencesManager;
    private final JPanel timeframePanel;
    private final JToggleButton btn5m;
    private final JToggleButton btn30m;
    private final JToggleButton btn2h;
    private final JToggleButton btn8h;

    @Inject
    public ControlPanel(
            SuggestionManager suggestionManager,
            SuggestionPreferencesManager preferencesManager) {
        this.preferencesManager = preferencesManager;
        
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        setBounds(0, 0, 300, 150);

        // Add timeframe buttons
        timeframePanel = new JPanel();
        timeframePanel.setLayout(new BoxLayout(timeframePanel, BoxLayout.Y_AXIS));
        timeframePanel.setOpaque(false);
        JLabel timeframeLabel = new JLabel("How often do you adjust offers?");
        timeframeLabel.setHorizontalAlignment(SwingConstants.LEFT);
        timeframeLabel.setMaximumSize(timeframeLabel.getPreferredSize());
        JPanel labelPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        labelPanel.setOpaque(false);
        labelPanel.add(timeframeLabel);
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(1, 4, 0, 0));
        buttonPanel.setOpaque(false);
        ButtonGroup timeframeButtonGroup = new ButtonGroup();
        btn5m = createTimeframeButton("5m", 5, suggestionManager);
        btn30m = createTimeframeButton("30m", 30, suggestionManager);
        btn2h = createTimeframeButton("2h", 120, suggestionManager);
        btn8h = createTimeframeButton("8h", 480, suggestionManager);
        timeframeButtonGroup.add(btn5m);
        timeframeButtonGroup.add(btn30m);
        timeframeButtonGroup.add(btn2h);
        timeframeButtonGroup.add(btn8h);
        buttonPanel.add(btn5m);
        buttonPanel.add(btn30m);
        buttonPanel.add(btn2h);
        buttonPanel.add(btn8h);
        timeframePanel.add(labelPanel);
        timeframePanel.add(Box.createRigidArea(new Dimension(0, 3)));
        timeframePanel.add(buttonPanel);
        add(timeframePanel);
    }

    private JToggleButton createTimeframeButton(String label, int value, SuggestionManager suggestionManager) {
        JToggleButton button = new JToggleButton();
        button.addActionListener(e -> {
            preferencesManager.setTimeframe(value);
            suggestionManager.setSuggestionNeeded(true);
        });
        button.setMargin(new Insets(2, 4, 2, 4));
        button.setFocusPainted(false);
        button.setOpaque(true);
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setForeground(ColorScheme.TEXT_COLOR);

        // Set initial text as white
        button.setText("<html><font color='rgb(198, 198, 198)'>" + label + "</font></html>");

        // Change color and text when selected/unselected
        button.addChangeListener(e -> {
            if (button.isSelected()) {
                button.setBackground(ColorScheme.BRAND_ORANGE);
                button.setText("<html><font color='black'>" + label + "</font></html>");
            } else {
                button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                button.setText("<html><font color='rgb(198, 198, 198)'>" + label + "</font></html>");
            }
        });

        return button;
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        
        int tf = preferencesManager.getTimeframe();
        btn5m.setSelected(tf == 5);
        btn30m.setSelected(tf == 30);
        btn2h.setSelected(tf == 120);
        btn8h.setSelected(tf == 480);
    }
} 
package com.flippingcopilot.ui;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;

@Singleton
public class GeHistoryTransactionButton extends JButton {

    @Inject
    public GeHistoryTransactionButton() {
        super("Add GE history transactions");
        setupButton();
    }
    
    private void setupButton() {
        setFont(FontManager.getRunescapeBoldFont());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        setBorder(new EmptyBorder(8, 20, 8, 20));
        setOpaque(true);
        setFocusable(false);
        setVisible(false);
        
        // Add hover effect
        addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e) {
                setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
            }
            
            @Override
            public void mouseExited(java.awt.event.MouseEvent e) {
                setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });
    }
}
/*
 * Copyright (c) 2023, LlemonDuck <napkinorton@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import com.flippingcopilot.model.ItemIdName;
import org.apache.commons.text.similarity.JaroWinklerDistance;
import org.apache.commons.text.similarity.LongestCommonSubsequence;
import org.apache.commons.text.similarity.SimilarityScore;

import javax.inject.Singleton;
import java.util.function.ToDoubleFunction;

@Singleton
public class FuzzySearchScorer
{

	// can be swapped, but i found jaro-winkler to do well considering the variable length of inputs
	// whereas levenshtein biases toward strings of same len, regardless of overlap
	private final SimilarityScore<Double> baseAlgorithm = new JaroWinklerDistance();

	public Double score(String query, String itemName)
	{
		query = query.toLowerCase().replace('-', ' ');
		itemName = itemName.toLowerCase().replace('-', ' ');

		// we raise the score for longest substring of a word, scoring within [0,1]
		String[] queryWords = query.split(" ");
		String[] itemWords = itemName.split(" ");
		double lcsScore = 0.0;
		for (String queryWord : queryWords)
		{
			for (String itemWord : itemWords)
			{
				int lcsLen = new LongestCommonSubsequence().longestCommonSubsequence(queryWord, itemWord).length();
				lcsScore = Math.max(lcsScore, ((double) lcsLen) / queryWord.length());
			}
		}

		// and also raise the score for string "closeness", but strongly prefer high closeness, scoring within [-0.5,0.5]
		double proximityScore = Math.log10(10 * baseAlgorithm.apply(query, itemName)) - 0.5;

		// subtract 1.0 to filter out low-scoring results
		return lcsScore + proximityScore - 1.0;
	}

	public ToDoubleFunction<ItemIdName> comparator(String query)
	{
		// We do this so that for example the items "Anti-venom ..." are still at the top
		// when searching "anti venom"
		return item -> score(
			query.toLowerCase().replace('-', ' '),
			item.getName().toLowerCase().replace('-', ' ')
		);
	}

}

package com.flippingcopilot.ui;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import java.awt.*;

public class GpDropOverlay extends Overlay {
    private final OverlayManager overlayManager;
    private final long startTime;
    private final Point startPosition = new Point(); // Starting position of the text
    final TextComponent textComponent = new TextComponent();

    public GpDropOverlay(OverlayManager overlayManager, Client client, long profit, int slot) {
        this.overlayManager = overlayManager;
        this.startTime = System.currentTimeMillis();

        Widget slotWidget = client.getWidget(465, slot + 7);
        if (slotWidget == null) {
            return;
        }
        startPosition.x = slotWidget.getCanvasLocation().getX() + 35;
        startPosition.y = slotWidget.getCanvasLocation().getY() + 75;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        String absProfitText = UIUtilities.quantityToRSDecimalStack(Math.abs(profit), false);
        String profitText = (profit >= 0 ? "+ " : "- ") + absProfitText + " gp";
        textComponent.setText(profitText);
        textComponent.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 16f));
        if (profit < 0) {
            textComponent.setColor(Color.RED);
        } else {
            textComponent.setColor(Color.GREEN);
        }
        overlayManager.add(this);
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        long elapsed = System.currentTimeMillis() - startTime;
        if (elapsed > 3000) { // Display for 5 seconds
            overlayManager.remove(this);
            return null;
        }

        // Calculate the upward movement. Adjust the divisor to control the speed.
        int yOffset = (int) (elapsed / 50); // Moves up 1 pixel every 50ms

        // Ensure the text moves upwards by subtracting yOffset from the starting Y position
        Point currentPosition = new Point(startPosition.x, startPosition.y - yOffset);
        textComponent.setPosition(currentPosition);
        textComponent.render(graphics);

        return null;
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.FlipManager;
import com.flippingcopilot.model.FlipV2;
import com.flippingcopilot.model.IntervalTimeUnit;
import com.flippingcopilot.model.SortDirection;
import joptsimple.internal.Strings;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Named;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;
import java.util.function.Predicate;


@Slf4j
public class FlipFilterAndSort {

    public static final int DEFAULT_PAGE_SIZE = 50;

    // Sort comparators map
    private static final Map<String, Comparator<FlipV2>> SORT_COMPARATORS = new HashMap<>();

    static {
        // Last sell time - special handling for non-closed trades
        SORT_COMPARATORS.put("Last sell time", Comparator.comparing(FlipV2::lastTransactionTime).reversed());
        SORT_COMPARATORS.put("First buy time", Comparator.comparing(FlipV2::getOpenedTime));
        SORT_COMPARATORS.put("Account", Comparator.comparing(FlipV2::getAccountId));
        SORT_COMPARATORS.put("Item", Comparator.comparing(f -> f.getCachedItemName() != null ? f.getCachedItemName() : ""));
        SORT_COMPARATORS.put("Status", Comparator.comparing(FlipV2::getStatus));
        SORT_COMPARATORS.put("Bought", Comparator.comparing(FlipV2::getOpenedQuantity));
        SORT_COMPARATORS.put("Sold", Comparator.comparing(FlipV2::getClosedQuantity));
        SORT_COMPARATORS.put("Avg. buy price", Comparator.comparing(FlipV2::getSpent));
        SORT_COMPARATORS.put("Avg. sell price", Comparator.comparing(FlipV2::getReceivedPostTax));
        SORT_COMPARATORS.put("Tax", Comparator.comparing(FlipV2::getTaxPaid));
        SORT_COMPARATORS.put("Profit", Comparator.comparing(FlipV2::getProfit));
        SORT_COMPARATORS.put("Profit ea.", Comparator.comparing(f -> f.getClosedQuantity() > 0 ? f.getProfit() / f.getClosedQuantity() : 0L));
    }

    // dependencies
    private final FlipManager flipManager;
    private final Consumer<List<FlipV2>> flipsCallback;
    private final Consumer<Integer> totalPagesChangedCallback;
    private final Consumer<Boolean> slowLoadingCallback;
    private final ExecutorService executorService;
    private final CopilotLoginManager copilotLoginManager;
    private final ItemController itemController;

    // state
    private List<FlipV2> cachedFlips = new ArrayList<>();
    private Integer cachedAccountId = null;
    private int cachedIntervalStartTime = -10;
    private boolean cachedIncludeBuyingFlips = true;
    private Set<Integer> cachedFilteredItems = new HashSet<>();
    private SortDirection cachedSortDirection = SortDirection.DESC;
    private String cachedSortColumn = "";

    private int intervalStartTime = -1;
    private Integer accountId = null;
    private boolean includeBuyingFlips = true;
    @Getter
    private String sortColumn = "Last sell time";
    @Getter
    private SortDirection sortDirection = SortDirection.DESC;
    private Set<Integer> filteredItems = new HashSet<>();
    @Getter
    private int pageSize = DEFAULT_PAGE_SIZE;
    private int totalFlips = 1;
    private int page = 1;

    public FlipFilterAndSort(FlipManager flipManager,
                             Consumer<List<FlipV2>> flipsCallback,
                             Consumer<Integer> totalPagesChangedCallback,
                             Consumer<Boolean> slowLoadingCallback,
                             @Named("copilotExecutor") ExecutorService executorService,
                             CopilotLoginManager copilotLoginManager, ItemController itemController) {
        this.flipManager = flipManager;

        this.flipsCallback = flipsCallback;
        this.totalPagesChangedCallback = totalPagesChangedCallback;
        this.slowLoadingCallback = slowLoadingCallback;
        this.executorService = executorService;
        this.copilotLoginManager = copilotLoginManager;
        this.itemController = itemController;
    }

    public synchronized void setIncludeBuyingFlips(boolean b) {
        includeBuyingFlips = b;
        reloadFlips(true, false);
    }

    public synchronized void setInterval(IntervalTimeUnit timeUnit, Integer value) {
        switch (timeUnit) {
            case ALL:
                intervalStartTime = 1;
                break;
            case SESSION:
                // TODO: Get session start time from SessionManager
                intervalStartTime = (int) Instant.now().getEpochSecond() - 3600; // Default to 1 hour ago
                break;
            default:
                intervalStartTime = (int) (Instant.now().getEpochSecond() - (long) value * timeUnit.getSeconds());
        }
        reloadFlips(true, false);
    }

    public synchronized void setAccountId(Integer accountId) {
        if(!Objects.equals(accountId,this.accountId)) {
            this.accountId = accountId;
            reloadFlips(true, false);
        }
    }

    public synchronized Set<Integer> getFilteredItems() {
        return new HashSet<>(filteredItems);
    }

    public synchronized void setFilteredItems(Set<Integer> filteredItems) {
        if(!Objects.equals(filteredItems, this.filteredItems)) {
            this.filteredItems = filteredItems;
            reloadFlips(true, false);
        }
    }

    public synchronized void setPageSize(int newSize) {
        if(newSize != pageSize) {
            pageSize = newSize;
            reloadFlips(true, false);
        }
    }

    public synchronized void setSortColumn(String sortColumn) {
        if(!sortColumn.equals(this.sortColumn)) {
            this.sortColumn = sortColumn;
            reloadFlips(false, false);
        }
    }

    public synchronized void setSortDirection(SortDirection sortDirection) {
        if(!Objects.equals(sortDirection, this.sortDirection)) {
            this.sortDirection = sortDirection;
            reloadFlips(false, false);
        }
    }

    public synchronized void setPage(int page) {
        if(page != this.page) {
            this.page = page;
            reloadFlips(false, false);
        }
    }
    public void reloadFlips(boolean totalPagesMaybeChanged, boolean forceReload) {
        executorService.submit(() -> _reloadFlips(totalPagesMaybeChanged, forceReload));
    }

    private synchronized void _reloadFlips(boolean totalPagesMaybeChanged, boolean forceReload) {
        try {
            if (canUseFlipsManager()) {
                if (totalPagesMaybeChanged || forceReload) {
                    totalFlips = flipManager.calculateStats(intervalStartTime, accountId).flipsMade;
                    totalPagesChangedCallback.accept(1 + totalFlips / pageSize);
                }
                flipsCallback.accept(flipManager.getPageFlips(page, pageSize, intervalStartTime, accountId));
            } else {
                slowLoadingCallback.accept(true);
                boolean cachedFlipsOutOfDate = !Objects.equals(cachedAccountId, accountId) || !cachedFilteredItems.equals(filteredItems) || cachedIntervalStartTime != intervalStartTime || cachedIncludeBuyingFlips != includeBuyingFlips;
                boolean cachedSortOutOfDate = cachedFlipsOutOfDate || !cachedSortColumn.equals(sortColumn) || !cachedSortDirection.equals(sortDirection);
                log.debug("cachedFlipsOutOfDate={}, cachedSortOutOfDate={}", cachedFlipsOutOfDate, cachedSortOutOfDate);
                if (cachedFlipsOutOfDate || forceReload) {
                    log.debug("reloading cached flips");
                    cachedAccountId = accountId;
                    cachedFilteredItems.clear();
                    cachedFilteredItems.addAll(filteredItems);
                    cachedIntervalStartTime = intervalStartTime;
                    cachedIncludeBuyingFlips = includeBuyingFlips;
                    cachedFlips.clear();
                    Predicate<FlipV2> flipFilter = filteredItems.isEmpty() ? f -> true : f -> filteredItems.contains(f.getItemId());
                    flipManager.aggregateFlips(intervalStartTime, accountId, includeBuyingFlips, (f) -> {
                        if(flipFilter.test(f)) {
                            f.setCachedItemName(itemController.getItemName(f.getItemId()));
                            cachedFlips.add(f);
                        }
                    });
                    log.debug("loaded {} cached flips", cachedFlips.size());
                }

                if (totalPagesMaybeChanged || forceReload) {
                    log.debug("updating total pages");
                    int totalPages = 1 + cachedFlips.size() / pageSize;
                    totalPagesChangedCallback.accept(totalPages);
                    log.debug("updated total pages to {} cached flips", totalPages);
                }

                if (cachedSortOutOfDate || forceReload) {
                    log.debug("re-sorting cached flips");
                    cachedSortColumn = sortColumn;
                    cachedSortDirection = sortDirection;

                    // Apply sorting
                    Comparator<FlipV2> comparator = SORT_COMPARATORS.get(sortColumn);
                    if (comparator != null) {
                        if (sortDirection == SortDirection.ASC) {
                            comparator = comparator.reversed();
                        }
                        cachedFlips.sort(comparator);
                    }
                    log.debug("re-sorted flips");
                }
                int startIndex = (page - 1) * pageSize;
                int endIndex = Math.min(startIndex + pageSize, cachedFlips.size());
                slowLoadingCallback.accept(false);
                flipsCallback.accept(cachedFlips.subList(startIndex, endIndex));
                log.debug("_reloadFlips end");
            }
        } catch (Exception e) {
            log.warn("error filtering/sorting flips", e);
        }
    }

    private boolean canUseFlipsManager() {
        return !includeBuyingFlips && sortDirection == SortDirection.DESC && sortColumn.equals("Last sell time") && filteredItems.isEmpty();
    }

    public synchronized void writeCsvRecords(FileWriter writer) {
        try {
            writer.write(Strings.join(FlipsPanel.COLUMN_NAMES, ","));
        } catch (IOException e) {
            throw new RuntimeException("writing flips CSV header", e);
        }

        Consumer<FlipV2> c = f -> {
            try {
                writer.write("\n"+toCSVRow(f));
            } catch (IOException e) {
                throw new RuntimeException("writing flips CSV row", e);
            }
        };
        if (canUseFlipsManager()) {
            flipManager.aggregateFlips(intervalStartTime, accountId, includeBuyingFlips, c);
        } else {
            cachedFlips.forEach(c);
        }
    }

    private String toCSVRow(FlipV2 f) {
        Map<Integer, String> accountIdToDisplayName = copilotLoginManager.accountIDToDisplayNameMap();
        long profitPerItem = f.getClosedQuantity() > 0 ? f.getProfit() / f.getClosedQuantity() : 0L;

        return String.join(",",
                formatTimestampISO(f.getOpenedTime()),
                formatTimestampISO(f.getClosedTime()),
                escapeCSV(accountIdToDisplayName.getOrDefault(f.getAccountId(), "Display name not loaded")),
                escapeCSV(f.getCachedItemName()),
                f.getStatus().name(),
                String.valueOf(f.getOpenedQuantity()),
                String.valueOf(f.getClosedQuantity()),
                String.valueOf(f.getSpent() / f.getOpenedQuantity()),
                String.valueOf(f.getClosedQuantity() == 0 ? 0 : (f.getReceivedPostTax() + f.getTaxPaid()) / f.getClosedQuantity()),
                String.valueOf(f.getTaxPaid()),
                String.valueOf(f.getProfit()),
                String.valueOf(profitPerItem)
        );
    }

    public static String formatTimestampISO(int timestamp) {
        if (timestamp == 0) {
            return "";
        }
        return Instant.ofEpochSecond(timestamp).toString();
    }

    public static String escapeCSV(String value) {
        if (value == null) {
            return "";
        }
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.model.AckedTransaction;
import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.IntStream;
import java.util.stream.Stream;

@AllArgsConstructor
public class TransactionDataWrapper {

    // 1 million transactions would be ~56MB in memory. Average transactions per user as of Aug 2025 is ~5000
    private volatile byte[] data;

    public List<AckedTransaction> getPage(Set<Integer> filteredItems, Integer selectedAccount, int page, int pageSize) {
        int n = data.length / AckedTransaction.RAW_SIZE;
        int toSkip = pageSize*(page-1);
        int found = 0;
        List<AckedTransaction> pageTransactions = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            AckedTransaction t = atIndex(i);
            if((filteredItems.isEmpty() || filteredItems.contains(t.getItemId())) && (selectedAccount == null || selectedAccount.equals(t.getAccountId()))){
                if(found < toSkip) {
                    toSkip--;
                    found++;
                } else {
                    pageTransactions.add(t);
                    found++;
                    if (found == pageSize) {
                        return pageTransactions;
                    }
                }
            }
        }
        return pageTransactions;
    }

    public int totalRecords(Set<Integer> filteredItems, Integer selectedAccount) {
        int found =0;
        int n = data.length / AckedTransaction.RAW_SIZE;
        for(int i = 0; i < n; i++) {
            AckedTransaction t = atIndex(i);
            if((filteredItems.isEmpty() || filteredItems.contains(t.getItemId())) && (selectedAccount == null || selectedAccount.equals(t.getAccountId()))){
                found++;
            }
        }
        return found;
    }

    private AckedTransaction atIndex(int n) {
        byte[] record = new byte[AckedTransaction.RAW_SIZE];
        System.arraycopy(data, AckedTransaction.RAW_SIZE*n, record, 0, AckedTransaction.RAW_SIZE);
        return AckedTransaction.fromRaw(record);
    }

    public Stream<AckedTransaction> stream(Set<Integer> filteredItems, Integer selectedAccount) {
        int totalTransactions = (data.length) / AckedTransaction.RAW_SIZE;
        return IntStream.range(0, totalTransactions)
                .mapToObj(this::atIndex)
                .filter(t -> (filteredItems.isEmpty() || filteredItems.contains(t.getItemId()))
                        && (selectedAccount == null || selectedAccount.equals(t.getAccountId())));
    }


    public void deleteOne(Predicate<AckedTransaction> predicate) {
        int totalTransactions = (data.length) / AckedTransaction.RAW_SIZE;
        for (int i = 0; i < totalTransactions; i++) {
            AckedTransaction transaction = atIndex(i);
            if (predicate.test(transaction)) {
                byte[] newData = new byte[data.length - AckedTransaction.RAW_SIZE];
                System.arraycopy(data, 0, newData, 0, i * AckedTransaction.RAW_SIZE);
                int rightSide = (totalTransactions - i - 1) * AckedTransaction.RAW_SIZE;
                if (rightSide > 0) {
                    System.arraycopy(data, (i + 1) * AckedTransaction.RAW_SIZE, newData, i * AckedTransaction.RAW_SIZE, rightSide);
                }
                data = newData;
                break;
            }
        }
    }

    public void update(AckedTransaction t) {
        byte[] newRaw = t.toRaw();
        int totalTransactions = (data.length) / AckedTransaction.RAW_SIZE;
        for (int i = 0; i < totalTransactions; i++) {
            int o = i * AckedTransaction.RAW_SIZE;
            // Compare first 16 bytes to match by ID
            if (data[o] == newRaw[0] && data[o + 1] == newRaw[1] && data[o + 2] == newRaw[2] && data[o + 3] == newRaw[3] &&
                    data[o + 4] == newRaw[4] && data[o + 5] == newRaw[5] && data[o + 6] == newRaw[6] && data[o + 7] == newRaw[7] &&
                    data[o + 8] == newRaw[8] && data[o + 9] == newRaw[9] && data[o + 10] == newRaw[10] && data[o + 11] == newRaw[11] &&
                    data[o + 12] == newRaw[12] && data[o + 13] == newRaw[13] && data[o + 14] == newRaw[14] && data[o + 15] == newRaw[15]) {
                // Overwrite the entire transaction with new raw data
                System.arraycopy(newRaw, 0, data, o, AckedTransaction.RAW_SIZE);
                break;
            }
        }
    }
}

package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.Paginator;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.ItemSearchMultiSelect;
import com.flippingcopilot.util.GeTax;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;

import static com.flippingcopilot.ui.flipsdialog.FlipFilterAndSort.escapeCSV;
import static com.flippingcopilot.ui.flipsdialog.FlipFilterAndSort.formatTimestampISO;
import static com.flippingcopilot.util.DateUtil.formatEpoch;

@Slf4j
public class TransactionsPanel extends JPanel {

    private static final UUID ZERO_UUID = new UUID(0L, 0L);
    private static final Integer[] PAGE_SIZE_OPTIONS = {10, 25, 50, 100, 200, 500, 1000, 2000};
    private static final int DEFAULT_PAGE_SIZE = 200;

    private final String[] columnNames = {
            "Timestamp", "Account", "Side", "Item", "Quantity", "Paid/Received", "Tax", "Price ea.", "Part of Flip"
    };

    // dependencies
    private final CopilotLoginManager copilotLoginManager;
    private final ItemController itemController;
    private final ExecutorService executorService;
    private final ApiRequestHandler apiRequestHandler;
    private final FlipManager flipManager;

    // ui components
    private final DefaultTableModel tableModel;
    private final JTable table;
    private final Paginator paginatorPanel;
    private final Spinner spinner;
    private final JScrollPane scrollPane;
    private final JPanel spinnerOverlay;
    private final ItemSearchMultiSelect searchField;
    private final JComboBox<Integer> pageSizeComboBox;
    private final JLabel loadingText;
    private AccountDropdown accountDropdown;
    private JLabel errorLabel;
    private JButton downloadButton;

    // state
    private final AtomicBoolean loadTransactionsTriggered = new AtomicBoolean(false);
    private TransactionDataWrapper transactionDataWrapper;
    private volatile Set<Integer> filteredItems = new HashSet<>();
    private volatile int pageSize = DEFAULT_PAGE_SIZE;
    private volatile int totalPages = 1;
    private volatile int currentPage = 1;
    private volatile Integer selectedAccountId;
    private volatile List<AckedTransaction> currentTransactions = new ArrayList<>();

    public TransactionsPanel(CopilotLoginManager copilotLoginManager,
                             ItemController itemController,
                             @Named("copilotExecutor") ExecutorService executorService,
                             ApiRequestHandler apiRequestHandler,
                             FlippingCopilotConfig config, FlipManager flipManager) {
        this.copilotLoginManager = copilotLoginManager;
        this.itemController = itemController;
        this.executorService = executorService;
        this.apiRequestHandler = apiRequestHandler;
        this.flipManager = flipManager;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        paginatorPanel = new Paginator((n) -> {
            if(n != currentPage) {
                currentPage = n;
                applyFilters(false);
            }
        });

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Create left panel with dropdowns
        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        searchField = new ItemSearchMultiSelect(
                () -> new HashSet<>(filteredItems),
                this.itemController::allItemIds,
                this.itemController::search,
                items -> {
                    if (!Objects.equals(items, this.filteredItems)) {
                        this.filteredItems = new HashSet<>(items);
                        currentPage = 1;
                        paginatorPanel.setPageNumber(1);
                        applyFilters(true);
                    }
                },
                "Items filter...");
        searchField.setMinimumSize(new Dimension(300, 0));
        searchField.setToolTipText("Search by item name");

        // Account dropdown
        accountDropdown = new AccountDropdown(
                this.copilotLoginManager::displayNameToAccountIdMap,
                accountId -> {
                    if (!Objects.equals(accountId, this.selectedAccountId)) {
                        currentPage = 1;
                        paginatorPanel.setPageNumber(currentPage);
                        this.selectedAccountId = accountId;
                        applyFilters(true);
                    }
                },
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        accountDropdown.setPreferredSize(new Dimension(120, accountDropdown.getPreferredSize().height));
        accountDropdown.setToolTipText("Select account");
        accountDropdown.refresh();

        // Page size combo box
        pageSizeComboBox = new JComboBox<>(PAGE_SIZE_OPTIONS);
        pageSizeComboBox.setSelectedItem(pageSize);
        pageSizeComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizeComboBox.setFocusable(false);
        pageSizeComboBox.setToolTipText("Page size");
        pageSizeComboBox.addActionListener(e -> {
            int newPageSize = (Integer) pageSizeComboBox.getSelectedItem();
            if (newPageSize != this.pageSize) {
                this.pageSize = newPageSize;
                currentPage = 1;
                paginatorPanel.setPageNumber(1);
                applyFilters(true);
            }
        });

        leftPanel.add(searchField);
        leftPanel.add(Box.createRigidArea(new Dimension(3, 0)));
        leftPanel.add(accountDropdown);

        // Create right panel with download button
        JPanel rightPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        rightPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        downloadButton = new JButton("Download");
        downloadButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        downloadButton.setFocusable(false);
        downloadButton.setToolTipText("Download transactions as CSV");
        downloadButton.addActionListener(e -> downloadTransactionsCSV());

        rightPanel.add(downloadButton);

        topPanel.add(leftPanel, BorderLayout.WEST);
        topPanel.add(rightPanel, BorderLayout.EAST);
        add(topPanel, BorderLayout.NORTH);

        // Create table
        tableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        table = new JTable(tableModel);
        setupTable(config);

        // Create layered pane for spinner overlay
        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        layeredPane.setOpaque(true);

        // Create error label
        errorLabel = new JLabel("Error loading transactions from server", SwingConstants.CENTER);
        errorLabel.setFont(errorLabel.getFont().deriveFont(14f));
        errorLabel.setVisible(false);

        spinner = new Spinner();
        spinner.show();

        // Create spinner overlay with loading text
        spinnerOverlay = new JPanel(new GridBagLayout());
        spinnerOverlay.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spinnerOverlay.setOpaque(true);

        // Create a panel to hold the loading text and spinner horizontally
        JPanel loadingPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        loadingPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        loadingPanel.setOpaque(false);

        // Create loading text label
        loadingText = new JLabel("Downloading transactions..");
        loadingText.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        loadingText.setFont(loadingText.getFont().deriveFont(14f));

        // Add text and spinner to the loading panel
        loadingPanel.add(loadingText);
        loadingPanel.add(spinner);

        // Add the loading panel to the spinner overlay
        spinnerOverlay.add(loadingPanel);
        spinnerOverlay.setVisible(false); // Initially hidden until first access

        scrollPane = new JScrollPane(table);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);

        layeredPane.setLayout(new OverlayLayout(layeredPane));
        layeredPane.add(spinnerOverlay, JLayeredPane.MODAL_LAYER);
        layeredPane.add(errorLabel, JLayeredPane.PALETTE_LAYER);
        layeredPane.add(scrollPane, JLayeredPane.DEFAULT_LAYER);

        add(layeredPane, BorderLayout.CENTER);

        // Create bottom panel with pagination
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel pageSizePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        pageSizePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizePanel.setBorder(BorderFactory.createEmptyBorder(4, 0, 0, 0));
        JLabel pageSizeLabel = new JLabel("Page size:");
        pageSizeLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        pageSizePanel.add(pageSizeLabel);
        pageSizePanel.add(pageSizeComboBox);

        // Adjust paginator border to account for page size panel width
        paginatorPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createEmptyBorder(0, 0, 0, pageSizePanel.getPreferredSize().width),
                paginatorPanel.getBorder()));

        bottomPanel.add(pageSizePanel, BorderLayout.WEST);
        bottomPanel.add(paginatorPanel, BorderLayout.CENTER);

        add(bottomPanel, BorderLayout.SOUTH);
    }

    /**
     * Load transactions when the panel is first shown
     */
    public void loadTransactionsIfNeeded() {
        if (loadTransactionsTriggered.compareAndSet(false, true)) {
            loadTransactions();
        }
    }

    private void setupTable(FlippingCopilotConfig config) {
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        table.setSelectionBackground(ColorScheme.BRAND_ORANGE);
        table.setSelectionForeground(Color.WHITE);
        table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
        table.setRowHeight(25);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
        table.setFocusable(false);

        // Disable sorting
        table.setRowSorter(null);
        table.getTableHeader().setReorderingAllowed(false);

        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            private void showPopup(MouseEvent e) {
                int row = table.rowAtPoint(e.getPoint());
                if (row >= 0 && row < table.getRowCount()) {
                    table.setRowSelectionInterval(row, row);
                    showTransactionMenu(e, row);
                }
            }
        });

        // Setup renderers
        DefaultTableCellRenderer moneyRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    setText(FlipsPanel.GP_FORMAT.format(value));
                    setHorizontalAlignment(RIGHT);
                }
                return c;
            }
        };

        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        DefaultTableCellRenderer booleanRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Boolean) {
                    setText((Boolean) value ? "Yes" : "No");
                    setHorizontalAlignment(CENTER);
                }
                return c;
            }
        };

        // Apply renderers to columns
        table.getColumnModel().getColumn(1).setCellRenderer(centerRenderer); // Account
        table.getColumnModel().getColumn(2).setCellRenderer(centerRenderer); // Side
        table.getColumnModel().getColumn(4).setCellRenderer(centerRenderer); // Quantity
        table.getColumnModel().getColumn(5).setCellRenderer(moneyRenderer); // Paid/Received
        table.getColumnModel().getColumn(6).setCellRenderer(moneyRenderer); // Tax
        table.getColumnModel().getColumn(7).setCellRenderer(moneyRenderer); // Price ea.
        table.getColumnModel().getColumn(8).setCellRenderer(booleanRenderer); // Part of Flip
    }

    private void loadTransactions() {
        setSpinnerVisible(true);
        errorLabel.setVisible(false);
        apiRequestHandler.asyncLoadTransactionsData(
                transactionsData -> {
                    SwingUtilities.invokeLater(() -> {
                        setSpinnerVisible(false);
                        transactionDataWrapper = new TransactionDataWrapper(transactionsData);
                        applyFilters(true);
                    });
                },
                error -> {
                    SwingUtilities.invokeLater(() -> {
                        setSpinnerVisible(false);
                        errorLabel.setVisible(true);
                        log.error("Failed to load transactions: {}", error);
                    });
                }
        );
    }

    private void setSpinnerVisible(boolean visible) {
        if (visible) {
            spinnerOverlay.setVisible(true);
            table.setEnabled(false);
        } else {
            spinnerOverlay.setVisible(false);
            table.setEnabled(true);
        }
    }

    private void applyFilters(boolean updateTotalPages) {
        executorService.submit(() -> {
            synchronized (this) {
                try {
                    if (updateTotalPages) {
                        int n = transactionDataWrapper.totalRecords(filteredItems, selectedAccountId);
                        totalPages = (int) Math.ceil((double) n / (double) pageSize);
                        paginatorPanel.setTotalPagesWithoutEffect(totalPages);
                    }
                    List<AckedTransaction> txs = transactionDataWrapper.getPage(filteredItems, selectedAccountId, currentPage, pageSize);
                    SwingUtilities.invokeLater(() -> updateTable(txs));
                } catch (Exception e) {
                    errorLabel.setText("Error decoding transaction data.");
                    errorLabel.setVisible(true);
                    log.error("loading transaction page", e);
                }
            }
        });
    }

    private void updateTable(List<AckedTransaction> txs) {
        currentTransactions = txs;
        tableModel.setRowCount(0);
        Map<Integer, String> accountIdToDisplayName = copilotLoginManager.accountIDToDisplayNameMap();

        for (AckedTransaction tx : txs) {
            int absQuantity = Math.abs(tx.getQuantity());
            long paidReceived = Math.abs(tx.getAmountSpent());
            long priceEa = tx.getPrice();
            Object[] row = {
                    formatEpoch(tx.getTime()),
                    accountIdToDisplayName.getOrDefault(tx.getAccountId(), "Unknown"),
                    tx.getQuantity() > 0 ? "BUY" : "SELL",
                    itemController.getItemName(tx.getItemId()),
                    absQuantity,
                    paidReceived,
                    calculateTax(tx),
                    priceEa,
                    !ZERO_UUID.equals(tx.getClientFlipId()),
            };
            tableModel.addRow(row);
        }
    }

    private long calculateTax(AckedTransaction tx) {
        if (tx.getQuantity() < 0) {
            int pricePerItem = tx.getAmountSpent() / tx.getQuantity();
            int pricePostTax = GeTax.getPostTaxPrice(tx.getItemId(), pricePerItem);
            return (long)(pricePerItem - pricePostTax) * tx.getQuantity();
        }
        return 0;
    }

    private void showTransactionMenu(MouseEvent e, int row) {
        if (row >= currentTransactions.size()) {
            return;
        }
        AckedTransaction transaction = currentTransactions.get(row);
        if (ZERO_UUID.equals(transaction.getClientFlipId())) {
            return;
        }
        JPopupMenu menu = new JPopupMenu();
        JMenuItem orphanItem = new JMenuItem("Remove from flip");
        orphanItem.addActionListener(evt -> {
            int result = JOptionPane.showConfirmDialog(this,
                    "Are you sure you want to remove the transaction from its flip? The flip and any profit will also be updated. This operation cannot be undone.",
                    "Confirm Action",
                    JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION) {
                loadingText.setText("");
                setSpinnerVisible(true);
                log.info("orphaning transaction with ID: {}", transaction.getId());

                BiConsumer<Integer, List<FlipV2>> onSuccess = (userId, flips) -> {
                    flipManager.mergeFlips(flips, userId);
                    setSpinnerVisible(false);
                    transaction.setClientFlipId(ZERO_UUID);
                    transactionDataWrapper.update(transaction);
                    applyFilters(false);
                };

                Runnable onFailure = () -> {
                    setSpinnerVisible(false);
                    JOptionPane.showMessageDialog(this,
                            "Failed to update transaction. Please try again.",
                            "Error",
                            JOptionPane.ERROR_MESSAGE);
                };

                apiRequestHandler.asyncOrphanTransaction(transaction, onSuccess, onFailure);
            }
        });
        menu.add(orphanItem);
        menu.show(e.getComponent(), e.getX(), e.getY());
    }

    private void downloadTransactionsCSV() {
        if (transactionDataWrapper == null) {
            JOptionPane.showMessageDialog(this,
                    "No transaction data available to download.",
                    "Download Error",
                    JOptionPane.WARNING_MESSAGE);
            return;
        }

        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Save Transactions CSV");
        fileChooser.setSelectedFile(new File("transactions.csv"));

        if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            executorService.submit(() -> {
                try (FileWriter writer = new FileWriter(file)) {
                    writer.write(Strings.join(columnNames, ","));

                    Map<Integer, String> accountIdToDisplayName = copilotLoginManager.accountIDToDisplayNameMap();

                    // Use the stream method to write all matching transactions
                    transactionDataWrapper.stream(filteredItems, selectedAccountId)
                            .forEach(tx -> {
                                try {
                                    int absQuantity = Math.abs(tx.getQuantity());
                                    long paidReceived = Math.abs(tx.getAmountSpent());
                                    long priceEa = tx.getPrice();
                                    long tax = calculateTax(tx);
                                    String row = String.join(",",
                                            formatTimestampISO(tx.getTime()),
                                            escapeCSV(accountIdToDisplayName.getOrDefault(tx.getAccountId(), "Unknown")),
                                            tx.getQuantity() > 0 ? "BUY" : "SELL",
                                            escapeCSV(itemController.getItemName(tx.getItemId())),
                                            String.valueOf(absQuantity),
                                            String.valueOf(paidReceived),
                                            String.valueOf(tax),
                                            String.valueOf(priceEa),
                                            !ZERO_UUID.equals(tx.getClientFlipId()) ? "YES" : "NO"
                                    );
                                    writer.write( "\n"+ row);
                                } catch (IOException e) {
                                    throw new RuntimeException(e);
                                }
                            });

                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this,
                                "Transactions exported successfully to " + file.getName(),
                                "Export Complete",
                                JOptionPane.INFORMATION_MESSAGE);
                    });

                } catch (Exception e) {
                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this,
                                "Error exporting transactions: " + e.getMessage(),
                                "Export Error",
                                JOptionPane.ERROR_MESSAGE);
                    });
                    log.error("Error exporting transactions to CSV", e);
                }
            });
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.ui.graph.model.Bounds;

import javax.swing.*;
import java.awt.*;
import java.awt.geom.Path2D;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

public class ProfitGraphPanel extends JPanel {

    // Layout constants
    private static final int PADDING_LEFT = 80;
    private static final int PADDING_RIGHT = 30;
    private static final int PADDING_TOP = 30;
    private static final int PADDING_BOTTOM = 50;

    // Visual constants
    private static final Color BACKGROUND_COLOR = new Color(43, 43, 43);
    private static final Color PLOT_AREA_COLOR = new Color(51, 51, 51);
    private static final Color GRID_COLOR = new Color(85, 85, 85, 90);
    private static final Color AXIS_COLOR = new Color(150, 150, 150);
    private static final Color TEXT_COLOR = new Color(225, 225, 225);
    private static final Color ZERO_LINE_COLOR = new Color(200, 200, 200);

    private static final float FONT_SIZE = 16f;
    private static final Stroke LINE_STROKE = new BasicStroke(2f);
    private static final Stroke GRID_STROKE = new BasicStroke(
            0.8f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{3}, 0
    );
    private final Color lossColor;
    private final Color profitColor;

    // Calculated bounds
    private Bounds bounds;
    private List<ProfitDataPoint> data;


    public void setData(List<ProfitDataPoint> newData, Bounds bounds) {
        this.data = newData;
        this.bounds = bounds;
    }

    public static class ProfitDataPoint {
        public final long timestamp; // Unix timestamp in seconds
        public final long profit;    // Profit value in gp

        public ProfitDataPoint(long timestamp, long profit) {
            this.timestamp = timestamp;
            this.profit = profit;
        }
    }

    public ProfitGraphPanel(Color profitColor, Color lossColor) {
        this.data = new ArrayList<>();
        this.bounds = new Bounds();
        this.bounds.yMax = 10_000_000;
        this.profitColor = profitColor;
        this.lossColor = lossColor;

        setBackground(BACKGROUND_COLOR);
        setPreferredSize(new Dimension(600, 400));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

        int width = getWidth();
        int height = getHeight();

        int plotWidth = width - PADDING_LEFT - PADDING_RIGHT;
        int plotHeight = height - PADDING_TOP - PADDING_BOTTOM;

        g2.setColor(PLOT_AREA_COLOR);
        g2.fillRect(PADDING_LEFT, PADDING_TOP, plotWidth, plotHeight);

        drawGrid(g2, plotWidth, plotHeight);
        drawAxes(g2, plotWidth, plotHeight);

        if (!data.isEmpty()) {
            drawProfitLine(g2, plotWidth, plotHeight);
        }

        drawAxisLabels(g2, plotWidth, plotHeight);
    }

    private void drawGrid(Graphics2D g2, int plotWidth, int plotHeight) {
        g2.setColor(GRID_COLOR);
        g2.setStroke(GRID_STROKE);

        // Vertical grid lines (time)
        int numVerticalLines = Math.min(10, Math.max(4, plotWidth / 100));
        for (int i = 0; i <= numVerticalLines; i++) {
            int x = PADDING_LEFT + (plotWidth * i / numVerticalLines);
            g2.drawLine(x, PADDING_TOP, x, PADDING_TOP + plotHeight);
        }

        // Horizontal grid lines (profit)
        int numHorizontalLines = Math.min(10, Math.max(4, plotHeight / 50));
        for (int i = 0; i <= numHorizontalLines; i++) {
            int y = PADDING_TOP + (plotHeight * i / numHorizontalLines);
            g2.drawLine(PADDING_LEFT, y, PADDING_LEFT + plotWidth, y);
        }

        g2.setColor(ZERO_LINE_COLOR);
        g2.setStroke(new BasicStroke(1.5f));
        int zeroY = profitToY(0, plotHeight);
        g2.drawLine(PADDING_LEFT, zeroY, PADDING_LEFT + plotWidth, zeroY);
    }

    private void drawAxes(Graphics2D g2, int plotWidth, int plotHeight) {
        g2.setColor(AXIS_COLOR);
        g2.setStroke(new BasicStroke(1.0f));

        g2.drawLine(PADDING_LEFT, PADDING_TOP + plotHeight,
                PADDING_LEFT + plotWidth, PADDING_TOP + plotHeight);

        g2.drawLine(PADDING_LEFT, PADDING_TOP,
                PADDING_LEFT, PADDING_TOP + plotHeight);
    }

    private void drawProfitLine(Graphics2D g2, int plotWidth, int plotHeight) {
        if (data.size() < 2) {
            // Just draw a point if we only have one data point
            if (data.size() == 1) {
                ProfitDataPoint point = data.get(0);
                int x = timeToX(point.timestamp, plotWidth);
                int y = profitToY(point.profit, plotHeight);

                g2.setColor(point.profit >= 0 ? profitColor : lossColor);
                g2.fillOval(x - 3, y - 3, 6, 6);
            }
            return;
        }

        g2.setStroke(LINE_STROKE);

        // Create the line path
        Path2D.Float path = new Path2D.Float();
        boolean started = false;

        for (int i = 0; i < data.size(); i++) {
            ProfitDataPoint point = data.get(i);
            int x = timeToX(point.timestamp, plotWidth);
            int y = profitToY(point.profit, plotHeight);

            if (!started) {
                path.moveTo(x, y);
                started = true;
            } else {
                // Draw segment with appropriate color
                ProfitDataPoint prevPoint = data.get(i - 1);
                int prevX = timeToX(prevPoint.timestamp, plotWidth);
                int prevY = profitToY(prevPoint.profit, plotHeight);

                // Determine color based on whether we're above or below zero
                boolean currentPositive = point.profit >= 0;
                boolean prevPositive = prevPoint.profit >= 0;

                if (currentPositive == prevPositive) {
                    // Same sign, simple line
                    g2.setColor(currentPositive ? profitColor : lossColor);
                    g2.drawLine(prevX, prevY, x, y);
                } else {
                    // Crossing zero, need to interpolate
                    double ratio = Math.abs((double)prevPoint.profit) /
                            (Math.abs(prevPoint.profit) + Math.abs(point.profit));
                    int crossX = prevX + (int)((x - prevX) * ratio);
                    int crossY = profitToY(0, plotHeight);

                    // Draw first segment
                    g2.setColor(prevPositive ? profitColor : lossColor);
                    g2.drawLine(prevX, prevY, crossX, crossY);

                    // Draw second segment
                    g2.setColor(currentPositive ? profitColor : lossColor);
                    g2.drawLine(crossX, crossY, x, y);
                }

                path.lineTo(x, y);
            }
        }

        // Draw points
        g2.setStroke(new BasicStroke(1.0f));
        for (ProfitDataPoint point : data) {
            int x = timeToX(point.timestamp, plotWidth);
            int y = profitToY(point.profit, plotHeight);

            g2.setColor(point.profit >= 0 ? profitColor : lossColor);
            g2.fillOval(x - 3, y - 3, 6, 6);

        }
    }

    private void drawAxisLabels(Graphics2D g2, int plotWidth, int plotHeight) {
        g2.setFont(g2.getFont().deriveFont(FONT_SIZE));
        g2.setColor(TEXT_COLOR);
        FontMetrics fm = g2.getFontMetrics();

        // X-axis labels (time)
        SimpleDateFormat dateFormat = new SimpleDateFormat("MMM d");

        int numLabels = Math.min(8, Math.max(2, plotWidth / 100));
        for (int i = 0; i <= numLabels; i++) {
            long time = bounds.xMin + (long) bounds.xDelta() * i / numLabels;
            int x = PADDING_LEFT + (plotWidth * i / numLabels);

            Date date = new Date(time * 1000L);
            String label;
            label = dateFormat.format(date);

            int labelWidth = fm.stringWidth(label);
            g2.drawString(label, x - labelWidth / 2,
                    PADDING_TOP + plotHeight + 20);
        }

        // Y-axis labels (profit)
        NumberFormat nf = NumberFormat.getInstance();
        int numYLabels = Math.min(10, Math.max(4, plotHeight / 40));

        for (int i = 0; i <= numYLabels; i++) {
            long profit = bounds.yMin + (bounds.yDelta()) * i / numYLabels;
            int y = PADDING_TOP + plotHeight - (plotHeight * i / numYLabels);

            String label = formatProfit(profit);
            int labelWidth = fm.stringWidth(label);

            g2.drawString(label, PADDING_LEFT - labelWidth - 10,
                    y + fm.getHeight() / 3);
        }
    }

    private String formatProfit(long profit) {
        String sign = profit >= 0 ? "" : "-";

        if (Math.abs(profit) >= 1_000_000_000) {
            return sign + String.format("%.2fB", profit / 1_000_000_000.0);
        } else if (Math.abs(profit) >= 1_000_000) {
            return sign + String.format("%.1fM", profit / 1_000_000.0);
        } else if (Math.abs(profit) >= 1_000) {
            return sign + String.format("%.1fK", profit / 1_000.0);
        } else {
            return sign + profit;
        }
    }

    private int timeToX(long time, int plotWidth) {
        if (bounds.xDelta() == 0) return PADDING_LEFT + plotWidth / 2;
        return PADDING_LEFT + (int)((time - bounds.xMin) * plotWidth / bounds.xDelta());
    }

    private int profitToY(long profit, int plotHeight) {
        if (bounds.yDelta() == 0) return PADDING_TOP + plotHeight / 2;
        return PADDING_TOP + plotHeight -
                (int)((profit - bounds.yMin) * plotHeight / (bounds.yDelta()));
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Named;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;

@Slf4j
public class AccountsAggregateFilterSort {

    // dependencies
    private final FlipManager flipManager;
    private final CopilotLoginManager copilotLoginManager;
    private final Consumer<List<AccountAggregate>> aggregatesCallback;
    private final Consumer<Boolean> slowLoadingCallback;
    private final ExecutorService executorService;

    // state
    private int intervalStartTime = -1;
    private int cachedIntervalStartTime = Integer.MIN_VALUE;
    private final List<AccountAggregate> cachedAggregates =  new ArrayList<>();

    public AccountsAggregateFilterSort(FlipManager flipManager,
                                       CopilotLoginManager copilotLoginManager,
                                       Consumer<List<AccountAggregate>> aggregatesCallback,
                                       Consumer<Boolean> slowLoadingCallback,
                                       @Named("copilotExecutor") ExecutorService executorService) {
        this.flipManager = flipManager;
        this.copilotLoginManager = copilotLoginManager;
        this.aggregatesCallback = aggregatesCallback;
        this.slowLoadingCallback = slowLoadingCallback;
        this.executorService = executorService;
    }

    public synchronized void setInterval(IntervalTimeUnit timeUnit, Integer value) {
        switch (timeUnit) {
            case ALL:
                intervalStartTime = 1;
                break;
            case SESSION:
                // TODO: Get session start time from SessionManager
                intervalStartTime = (int) Instant.now().getEpochSecond() - 3600; // Default to 1 hour ago
                break;
            default:
                intervalStartTime = (int) (Instant.now().getEpochSecond() - (long) value * timeUnit.getSeconds());
        }
        reloadAggregates(false);
    }

    public void reloadAggregates(boolean forceReload) {
        executorService.submit(() -> _reloadAggregates(forceReload));
    }

    private synchronized void _reloadAggregates(boolean forceReload) {
        try {
            slowLoadingCallback.accept(true);

            if(forceReload || cachedIntervalStartTime != intervalStartTime) {
                log.debug("loading account aggregates");
                cachedAggregates.clear();
                Aggregator a = new Aggregator();
                copilotLoginManager.accountIDToDisplayNameMap().forEach(
                        (accountId, displayName)  -> a.accounts.put(accountId, new AccountAggregator(accountId))
                );
                flipManager.aggregateFlips(intervalStartTime, null, false, a);
                cachedIntervalStartTime = intervalStartTime;
                a.accounts.forEach((k, v) -> cachedAggregates.add(v.toAccountAggregate(copilotLoginManager.getDisplayName(k))));
                log.debug("loaded {} account aggregates", cachedAggregates.size());
            }
            // Final callback to indicate completion
            slowLoadingCallback.accept(false);
            aggregatesCallback.accept(cachedAggregates);
        } catch (Exception e) {
            log.warn("error loading account aggregates", e);
            slowLoadingCallback.accept(false);
        }
    }

    static class Aggregator implements Consumer<FlipV2> {
        final Map<Integer, AccountAggregator> accounts = new HashMap<>();

        public void accept(FlipV2 flip) {
            {
                AccountAggregator a = accounts.computeIfAbsent(flip.getAccountId(), AccountAggregator::new);
                long profit = flip.getProfit();
                a.totalProfit += profit;
                a.numberOfFlips++;
                if (profit < 0) {
                    a.biggestLoss = Math.min(a.biggestLoss, profit);
                } else {
                    a.biggestWin = Math.max(a.biggestWin, profit);
                }
            }
        }
    }

    @RequiredArgsConstructor
    static class AccountAggregator {
        final int accountId;
        long totalProfit = 0;
        long biggestLoss = Long.MAX_VALUE;
        long biggestWin = Long.MIN_VALUE;
        int numberOfFlips = 0;

        public AccountAggregate toAccountAggregate(String accountName) {
            return AccountAggregate.builder()
                    .accountId(accountId)
                    .accountName(accountName == null ? "Unknown" : accountName)
                    .numberOfFlips(numberOfFlips)
                    .biggestLoss(biggestLoss == Long.MAX_VALUE ? 0 : biggestLoss)
                    .biggestWin(biggestWin == Long.MIN_VALUE ? 0 : biggestWin)
                    .totalProfit(totalProfit)
                    .build();
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.components.IntervalDropdown;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import javax.swing.table.TableRowSorter;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.NumberFormat;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;

@Slf4j
public class AccountsAggregatePanel extends JPanel {

    private static final NumberFormat GP_FORMAT = NumberFormat.getNumberInstance(Locale.US);
    // dependencies
    private final CopilotLoginManager copilotLoginManager;
    private final ApiRequestHandler apiRequestHandler;
    private final FlipManager flipManager;
    private final ExecutorService executorService;

    // ui components
    private final DefaultTableModel tableModel;
    private final JTable table;
    private final Spinner spinner;
    private final JScrollPane scrollPane;
    private IntervalDropdown timeIntervalDropdown;

    // state
    private AccountsAggregateFilterSort sortAndFilter;
    private List<AccountAggregate> currentItems;

    private final String[] columnNames = {
            "Account", "Number of flips", "Biggest loss", "Biggest win", "Total profit"
    };
    private JPanel spinnerOverlay;

    public AccountsAggregatePanel(FlipManager flipsManager,
                                  CopilotLoginManager copilotLoginManager,
                                  @Named("copilotExecutor") ExecutorService executorService,
                                  FlippingCopilotConfig config, ApiRequestHandler apiRequestHandler, FlipManager flipManager) {
        this.copilotLoginManager = copilotLoginManager;
        this.apiRequestHandler = apiRequestHandler;
        this.flipManager = flipManager;
        this.executorService = executorService;

        // Initialize sort and filter
        sortAndFilter = new AccountsAggregateFilterSort(flipsManager, copilotLoginManager,
                this::showAggregates, this::setSpinnerVisible, executorService);

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Create top panel with all controls
        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        timeIntervalDropdown = new IntervalDropdown(sortAndFilter::setInterval, IntervalDropdown.ALL_TIME, false);
        timeIntervalDropdown.setPreferredSize(new Dimension(150, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setToolTipText("Select time interval");

        leftPanel.add(timeIntervalDropdown);

        topPanel.add(leftPanel, BorderLayout.WEST);
        add(topPanel, BorderLayout.NORTH);

        // Create table model
        tableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        // Create table
        table = new JTable(tableModel);
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        table.setSelectionBackground(ColorScheme.BRAND_ORANGE);
        table.setSelectionForeground(Color.WHITE);
        table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
        table.setRowHeight(25);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

        // Enable built-in table sorting
        TableRowSorter<DefaultTableModel> sorter = new TableRowSorter<>(tableModel);
        table.setRowSorter(sorter);
        table.getTableHeader().setReorderingAllowed(false);
        table.setFocusable(false);

        // Custom renderer for money columns
        DefaultTableCellRenderer moneyRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    setText(formatGp((Long) value));
                    setHorizontalAlignment(RIGHT);
                }
                return c;
            }
        };

        // Custom renderer for profit columns (with color)
        DefaultTableCellRenderer profitRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    long amount = (Long) value;
                    setText(formatGp(amount));
                    setHorizontalAlignment(RIGHT);

                    // Color profit/loss only if not selected
                    if (!isSelected) {
                        if (amount > 0) {
                            setForeground(config.profitAmountColor());
                        } else if (amount < 0) {
                            setForeground(config.lossAmountColor());
                        } else {
                            setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                        }
                    }
                }
                return c;
            }
        };

        // Center align for count column
        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        // Apply renderers
        table.getColumnModel().getColumn(1).setCellRenderer(centerRenderer); // Number of flips
        table.getColumnModel().getColumn(2).setCellRenderer(moneyRenderer); // Biggest loss
        table.getColumnModel().getColumn(3).setCellRenderer(moneyRenderer); // Biggest win
        table.getColumnModel().getColumn(4).setCellRenderer(profitRenderer); // Total profit (with color)
        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            private void showPopup(MouseEvent e) {
                int row = table.rowAtPoint(e.getPoint());
                if (row >= 0 && row < table.getRowCount()) {
                    table.setRowSelectionInterval(row, row);
                    showAccountMenu(e, row);
                }
            }
        });

        // Create layered pane for spinner overlay
        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        layeredPane.setOpaque(true);

        // Create spinner with semi-transparent background
        spinner = new Spinner();
        spinner.show();
        spinnerOverlay = new JPanel(new GridBagLayout());
        spinnerOverlay.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spinnerOverlay.setOpaque(true);
        spinnerOverlay.add(spinner);
        spinnerOverlay.setVisible(false); // Initially hidden

        scrollPane = new JScrollPane(table);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);

        layeredPane.setLayout(new OverlayLayout(layeredPane));
        layeredPane.add(spinnerOverlay, JLayeredPane.MODAL_LAYER);
        layeredPane.add(scrollPane, JLayeredPane.DEFAULT_LAYER);

        add(layeredPane, BorderLayout.CENTER);
    }

    private void setSpinnerVisible(boolean visible) {
        SwingUtilities.invokeLater(() -> {
            spinnerOverlay.setVisible(visible);
        });
    }

    private void showAggregates(List<AccountAggregate> aggregates) {
        SwingUtilities.invokeLater(() -> {
            currentItems = aggregates;
            tableModel.setRowCount(0);
            for (AccountAggregate aggregate : aggregates) {
                Object[] row = {
                        aggregate.getAccountName(),
                        aggregate.getNumberOfFlips(),
                        aggregate.getBiggestLoss(),
                        aggregate.getBiggestWin(),
                        aggregate.getTotalProfit(),
                };
                tableModel.addRow(row);
            }
            for (int i = 0; i < table.getColumnCount(); i++) {
                resizeColumnWidth(table, i);
            }
        });
    }

    private void resizeColumnWidth(JTable table, int column) {
        TableColumn tableColumn = table.getColumnModel().getColumn(column);
        int preferredWidth = tableColumn.getMinWidth();
        int maxWidth = tableColumn.getMaxWidth();

        // Check header width
        Component comp = table.getTableHeader().getDefaultRenderer()
                .getTableCellRendererComponent(table, tableColumn.getHeaderValue(), false, false, 0, column);
        preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);

        // Check cell widths
        for (int row = 0; row < table.getRowCount(); row++) {
            comp = table.getCellRenderer(row, column)
                    .getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);
            preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);
        }

        preferredWidth = Math.min(preferredWidth, maxWidth);
        tableColumn.setPreferredWidth(preferredWidth);
    }

    private void showAccountMenu(MouseEvent e, int row) {
        AccountAggregate a = currentItems.get(row);
        JPopupMenu menu = new JPopupMenu();
        JMenuItem deleteItem = new JMenuItem("Delete account");
        deleteItem.addActionListener(evt -> {
            int result = JOptionPane.showConfirmDialog(this,
                    "Are you sure you want to delete " + a.getAccountName() + "?",
                    "Confirm Delete",
                    JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION) {
                setSpinnerVisible(true);
                log.info("Deleting account: {}", a.getAccountId());
                Runnable onSuccess = () -> {
                    copilotLoginManager.removeAccount(a.getAccountId());
                    executorService.submit(() -> flipManager.deleteAccount(a.getAccountId()));
                    setSpinnerVisible(false);
                    sortAndFilter.reloadAggregates(true);
                };
                apiRequestHandler.asyncDeleteAccount(a.getAccountId(), onSuccess, () -> setSpinnerVisible(false));
            }
        });
        menu.add(deleteItem);
        menu.show(e.getComponent(), e.getX(), e.getY());
    }

    private String formatGp(long amount) {
        return GP_FORMAT.format(amount);
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.model.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Named;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;
import java.util.function.Predicate;

@Slf4j
public class ItemAggregateFilterSort {

    public static final int DEFAULT_PAGE_SIZE = 50;

    private static final Map<String, Comparator<ItemAggregate>> SORT_COMPARATORS = new HashMap<>();
    static {
        SORT_COMPARATORS.put("Item", Comparator.comparing(ItemAggregate::getItemName));
        SORT_COMPARATORS.put("Number of flips", Comparator.comparing(ItemAggregate::getNumberOfFlips));
        SORT_COMPARATORS.put("Biggest loss", Comparator.comparing(ItemAggregate::getBiggestLoss));
        SORT_COMPARATORS.put("Biggest win", Comparator.comparing(ItemAggregate::getBiggestWin));
        SORT_COMPARATORS.put("Total profit", Comparator.comparing(ItemAggregate::getTotalProfit));
        SORT_COMPARATORS.put("Avg profit", Comparator.comparing(ItemAggregate::getAvgProfit));
        SORT_COMPARATORS.put("Avg profit ea.", Comparator.comparing(ItemAggregate::getAvgProfitEa));
        SORT_COMPARATORS.put("Total quantity flipped", Comparator.comparing(ItemAggregate::getTotalQuantityFlipped));
    }

    // dependencies
    private final FlipManager flipManager;
    private final ItemController itemController;
    private final Consumer<List<ItemAggregate>> aggregatesCallback;
    private final Consumer<Integer> totalPagesChangedCallback;
    private final Consumer<Boolean> slowLoadingCallback;
    private final ExecutorService executorService;

    // state
    private List<ItemAggregate> cachedAggregates = new ArrayList<>();
    private Integer cachedAccountId = null;
    private int cachedIntervalStartTime = -10;
    private Set<Integer> cachedFilteredItems = new HashSet<>();
    private SortDirection cachedSortDirection = SortDirection.ASC;
    private String cachedSortColumn = "";

    private int intervalStartTime = -1;
    private Integer accountId = null;
    @Getter
    private String sortColumn = "Total profit";
    @Getter
    private SortDirection sortDirection = SortDirection.ASC;
    private Set<Integer> filteredItems = new HashSet<>();
    @Getter
    private int pageSize = DEFAULT_PAGE_SIZE;
    private int page = 1;

    public ItemAggregateFilterSort(FlipManager flipManager,
                                   ItemController itemController,
                                   Consumer<List<ItemAggregate>> aggregatesCallback,
                                   Consumer<Integer> totalPagesChangedCallback,
                                   Consumer<Boolean> slowLoadingCallback,
                                   @Named("copilotExecutor") ExecutorService executorService) {
        this.flipManager = flipManager;
        this.itemController = itemController;
        this.aggregatesCallback = aggregatesCallback;
        this.totalPagesChangedCallback = totalPagesChangedCallback;
        this.slowLoadingCallback = slowLoadingCallback;
        this.executorService = executorService;
    }

    public synchronized void setInterval(IntervalTimeUnit timeUnit, Integer value) {
        switch (timeUnit) {
            case ALL:
                intervalStartTime = 1;
                break;
            case SESSION:
                // TODO: Get session start time from SessionManager
                intervalStartTime = (int) Instant.now().getEpochSecond() - 3600; // Default to 1 hour ago
                break;
            default:
                intervalStartTime = (int) (Instant.now().getEpochSecond() - (long) value * timeUnit.getSeconds());
        }
        reloadAggregates(true);
    }

    public synchronized void setAccountId(Integer accountId) {
        if (!Objects.equals(accountId, this.accountId)) {
            this.accountId = accountId;
            reloadAggregates(true);
        }
    }

    public synchronized void setFilteredItems(Set<Integer> filteredItems) {
        if (!Objects.equals(filteredItems, this.filteredItems)) {
            this.filteredItems = filteredItems;
            reloadAggregates(true);
        }
    }
    public synchronized Set<Integer> getFilteredItems() {
        return new HashSet<>(filteredItems);
    }

    public synchronized void setPageSize(int newSize) {
        if (newSize != pageSize) {
            pageSize = newSize;
            reloadAggregates(true);
        }
    }

    public synchronized void setSortColumn(String sortColumn) {
        if (!sortColumn.equals(this.sortColumn)) {
            this.sortColumn = sortColumn;
            reloadAggregates(false);
        }
    }

    public synchronized void setSortDirection(SortDirection sortDirection) {
        if (!Objects.equals(sortDirection, this.sortDirection)) {
            this.sortDirection = sortDirection;
            reloadAggregates(false);
        }
    }

    public synchronized void setPage(int page) {
        if (page != this.page) {
            this.page = page;
            reloadAggregates(false);
        }
    }

    private void reloadAggregates(boolean totalPagesMaybeChanged) {
        executorService.submit(() -> _reloadAggregates(totalPagesMaybeChanged));
    }


    private synchronized void _reloadAggregates(boolean totalPagesMaybeChanged) {
        try {
            slowLoadingCallback.accept(true);

            boolean cachedAggregatesOutOfDate = !Objects.equals(cachedAccountId, accountId) ||
                    !cachedFilteredItems.equals(filteredItems) ||
                    cachedIntervalStartTime != intervalStartTime;
            boolean cachedSortOutOfDate = cachedAggregatesOutOfDate ||
                    !cachedSortColumn.equals(sortColumn) ||
                    !cachedSortDirection.equals(sortDirection);

            log.debug("cachedAggregatesOutOfDate={}, cachedSortOutOfDate={}", cachedAggregatesOutOfDate, cachedSortOutOfDate);

            if (cachedAggregatesOutOfDate) {
                log.debug("reloading cached item aggregates");
                cachedAccountId = accountId;
                cachedFilteredItems.clear();
                cachedFilteredItems.addAll(filteredItems);
                cachedIntervalStartTime = intervalStartTime;
                cachedAggregates.clear();
                Predicate<FlipV2> flipFilter = filteredItems.isEmpty() ? f -> true : f -> filteredItems.contains(f.getItemId());
                Aggregator a = new Aggregator(flipFilter);
                flipManager.aggregateFlips(intervalStartTime, cachedAccountId, false, a);
                cachedIntervalStartTime = intervalStartTime;
                a.items.forEach((k, v) -> cachedAggregates.add(v.toItemAggregate(itemController.getItemName(k))));
                log.debug("loaded {} cached item aggregates", cachedAggregates.size());
            }

            if (totalPagesMaybeChanged) {
                log.debug("updating total pages");
                int totalPages = 1 + cachedAggregates.size() / pageSize;
                totalPagesChangedCallback.accept(totalPages);
                log.debug("updated total pages to {}", totalPages);
            }

            if (cachedSortOutOfDate) {
                log.debug("re-sorting cached item aggregates");
                cachedSortColumn = sortColumn;
                cachedSortDirection = sortDirection;

                // Apply sorting
                Comparator<ItemAggregate> comparator = SORT_COMPARATORS.get(sortColumn);
                if (comparator != null) {
                    if (sortDirection == SortDirection.ASC) {
                        comparator = comparator.reversed();
                    }
                    cachedAggregates.sort(comparator);
                }
                log.debug("re-sorted item aggregates");
            }

            int startIndex = (page - 1) * pageSize;
            int endIndex = Math.min(startIndex + pageSize, cachedAggregates.size());
            slowLoadingCallback.accept(false);
            aggregatesCallback.accept(cachedAggregates.subList(startIndex, endIndex));
            log.debug("_reloadAggregates end");

        } catch (Exception e) {
            log.warn("error filtering/sorting item aggregates", e);
        }
    }

    @AllArgsConstructor
    static class Aggregator implements Consumer<FlipV2> {
        final Predicate<FlipV2> p;
        final Map<Integer,  ItemAggregator> items = new HashMap<>();

        public void accept(FlipV2 flip) {
            if(p.test(flip)) {
                ItemAggregator i = items.computeIfAbsent(flip.getItemId(), (k) -> new ItemAggregator());
                long profit = flip.getProfit();
                long quantitySold = flip.getClosedQuantity();
                i.totalProfit += profit;
                i.totalQuantitySold += quantitySold;
                i.numberOfFlips++;
                if (profit < 0) {
                    i.biggestLoss = Math.min(i.biggestLoss, profit);
                } else {
                    i.biggestWin = Math.max(i.biggestWin, profit);
                }
                i.quantityFlipped += flip.getClosedQuantity();
            }
        }
    }

    static class ItemAggregator {
        private long totalProfit = 0;
        private long totalQuantitySold = 0;
        private long biggestLoss = Long.MAX_VALUE;
        private long biggestWin = Long.MIN_VALUE;
        private int numberOfFlips = 0;
        private int quantityFlipped = 0;


        public ItemAggregate toItemAggregate(String itemName) {
            return ItemAggregate.builder()
                    .itemName(itemName)
                    .numberOfFlips(numberOfFlips)
                    .totalQuantityFlipped(quantityFlipped)
                    .biggestLoss(biggestLoss == Long.MAX_VALUE ? 0 : biggestLoss)
                    .biggestWin(biggestWin == Long.MIN_VALUE ? 0 : biggestWin)
                    .totalProfit(totalProfit)
                    .avgProfit(numberOfFlips == 0 ? 0 : totalProfit / numberOfFlips)
                    .avgProfitEa(totalQuantitySold == 0 ? 0 : totalProfit / totalQuantitySold)
                    .build();
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.Paginator;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.IntervalDropdown;
import com.flippingcopilot.ui.components.ItemSearchMultiSelect;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.NumberFormat;
import java.time.Instant;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import static com.flippingcopilot.util.DateUtil.formatEpoch;

@Slf4j
public class FlipsPanel extends JPanel {


    private static final Integer[] PAGE_SIZE_OPTIONS = {10, 25, 50, 100, 200, 500, 1000, 2000};
    public static final NumberFormat GP_FORMAT = NumberFormat.getNumberInstance(Locale.US);
    public static final String[] COLUMN_NAMES = {
            "First buy time", "Last sell time", "Account", "Item", "Status", "Bought", "Sold",
            "Avg. buy price", "Avg. sell price", "Tax", "Profit", "Profit ea."
    };

    // dependencies
    private final FlipManager flipsManager;
    private final CopilotLoginManager copilotLoginManager;
    private final ApiRequestHandler apiRequestHandler;

    // ui components
    private final DefaultTableModel tableModel;
    private final JTable table;
    private final Paginator paginatorPanel;
    private final Spinner spinner;
    private final JScrollPane scrollPane;
    private final JPanel spinnerOverlay;
    private final ItemSearchMultiSelect searchField;
    private final JCheckBox showOpeningFlipsCheckbox;
    private IntervalDropdown timeIntervalDropdown;
    private AccountDropdown accountDropdown;
    private final JComboBox<Integer> pageSizeComboBox;

    // state
    private List<FlipV2> currentFlips = new ArrayList<>();
    public FlipFilterAndSort sortAndFilter;



    public FlipsPanel(FlipManager flipsManager,
                      ItemController itemController,
                      CopilotLoginManager copilotLoginManager,
                      @Named("copilotExecutor") ExecutorService executorService,
                      FlippingCopilotConfig config,
                      ApiRequestHandler apiRequestHandler) {
        this.copilotLoginManager = copilotLoginManager;
        this.apiRequestHandler = apiRequestHandler;

        // Initialize pagination first (before loadFlips is called)
        paginatorPanel = new Paginator((i) -> sortAndFilter.setPage(i));
        sortAndFilter = new FlipFilterAndSort(flipsManager, this::showFlips, paginatorPanel::setTotalPages, this::setSpinnerVisible, executorService, copilotLoginManager, itemController);
        this.flipsManager = flipsManager;
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        searchField = new ItemSearchMultiSelect(
                sortAndFilter::getFilteredItems,
                itemController::allItemIds,
                itemController::search,
                sortAndFilter::setFilteredItems,
                "Items filter...");
        searchField.setMinimumSize(new Dimension(300, 0));
        searchField.setToolTipText("Search by item name");

        showOpeningFlipsCheckbox= new JCheckBox("Show buying flips", true);
        showOpeningFlipsCheckbox.setBackground(ColorScheme.DARK_GRAY_COLOR);
        showOpeningFlipsCheckbox.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        showOpeningFlipsCheckbox.setFocusable(false);
        showOpeningFlipsCheckbox.addActionListener(e -> sortAndFilter.setIncludeBuyingFlips(showOpeningFlipsCheckbox.isSelected()));

        pageSizeComboBox = new JComboBox<>(PAGE_SIZE_OPTIONS);
        pageSizeComboBox.setSelectedItem(sortAndFilter.getPageSize());
        pageSizeComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizeComboBox.setFocusable(false);
        pageSizeComboBox.setToolTipText("Page size");
        pageSizeComboBox.addActionListener(e -> sortAndFilter.setPageSize((Integer) pageSizeComboBox.getSelectedItem()));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        JButton downloadButton = createDownloadButton();
        buttonPanel.add(downloadButton);

        topPanel.add(leftPanel, BorderLayout.WEST);
        topPanel.add(buttonPanel, BorderLayout.EAST);
        add(topPanel, BorderLayout.NORTH);

        tableModel = new DefaultTableModel(COLUMN_NAMES, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        table = new JTable(tableModel);
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        table.setSelectionBackground(ColorScheme.BRAND_ORANGE);
        table.setSelectionForeground(Color.WHITE);
        table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
        table.setRowHeight(25);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

        // Disable default table sorting and set up custom header click handling
        table.setRowSorter(null);
        table.getTableHeader().setReorderingAllowed(false);
        table.setFocusable(false);


        // Add custom header click listener for sorting
        table.getTableHeader().addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                int columnIndex = table.getTableHeader().columnAtPoint(e.getPoint());
                if (columnIndex >= 0 && columnIndex < COLUMN_NAMES.length) {
                    String clickedColumn = COLUMN_NAMES[columnIndex];

                    // Toggle sort direction if clicking the same column, otherwise default to DESC
                    SortDirection newDirection = SortDirection.DESC;
                    if (clickedColumn.equals(sortAndFilter.getSortColumn())) {
                        newDirection = sortAndFilter.getSortDirection() == SortDirection.DESC ?
                                SortDirection.ASC : SortDirection.DESC;
                    }

                    sortAndFilter.setSortColumn(clickedColumn);
                    sortAndFilter.setSortDirection(newDirection);
                }
            }
        });

        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            private void showPopup(MouseEvent e) {
                int row = table.rowAtPoint(e.getPoint());
                if (row >= 0 && row < table.getRowCount()) {
                    table.setRowSelectionInterval(row, row);
                    showFlipMenu(e, row);
                }
            }
        });

        DefaultTableCellRenderer moneyRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    setText(GP_FORMAT.format((long) (Long) value));
                    setHorizontalAlignment(RIGHT);
                } else if (value instanceof String) {
                    setHorizontalAlignment(CENTER);
                }
                return c;
            }
        };

        DefaultTableCellRenderer profitRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    long amount = (Long) value;
                    setText(GP_FORMAT.format(amount));
                    setHorizontalAlignment(RIGHT);

                    // Color profit/loss only if not selected
                    if (!isSelected) {
                        if (amount > 0) {
                            setForeground(config.profitAmountColor());
                        } else if (amount < 0) {
                            setForeground(config.lossAmountColor());
                        } else {
                            setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                        }
                    }
                }
                return c;
            }
        };

        table.getColumnModel().getColumn(7).setCellRenderer(moneyRenderer); // Avg. buy price
        table.getColumnModel().getColumn(8).setCellRenderer(moneyRenderer); // Avg. sell price
        table.getColumnModel().getColumn(9).setCellRenderer(moneyRenderer); // Tax
        table.getColumnModel().getColumn(10).setCellRenderer(profitRenderer); // Profit (with color)
        table.getColumnModel().getColumn(11).setCellRenderer(moneyRenderer); // Profit ea.

        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);
        table.getColumnModel().getColumn(2).setCellRenderer(centerRenderer); // Account
        table.getColumnModel().getColumn(4).setCellRenderer(centerRenderer); // Status
        table.getColumnModel().getColumn(5).setCellRenderer(centerRenderer); // Bought
        table.getColumnModel().getColumn(6).setCellRenderer(centerRenderer); // Sold

        setupDropdowns();

        leftPanel.add(searchField);
        leftPanel.add(Box.createRigidArea(new Dimension(3,0)));
        leftPanel.add(timeIntervalDropdown);
        leftPanel.add(Box.createRigidArea(new Dimension(3,0)));
        leftPanel.add(accountDropdown);
        leftPanel.add(Box.createRigidArea(new Dimension(3,0)));
        leftPanel.add(showOpeningFlipsCheckbox);

        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        layeredPane.setOpaque(true);

        spinner = new Spinner();
        spinner.show();
        spinnerOverlay = new JPanel(new GridBagLayout());
        spinnerOverlay.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spinnerOverlay.setOpaque(true);
        spinnerOverlay.add(spinner);
        spinnerOverlay.setVisible(false); // Initially hidden

        scrollPane = new JScrollPane(table);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);

        layeredPane.setLayout(new OverlayLayout(layeredPane));
        layeredPane.add(spinnerOverlay, JLayeredPane.MODAL_LAYER);
        layeredPane.add(scrollPane, JLayeredPane.DEFAULT_LAYER);

        add(layeredPane, BorderLayout.CENTER);

        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel pageSizePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        pageSizePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizePanel.setBorder(BorderFactory.createEmptyBorder(4,0, 0,0));
        JLabel pageSizeLabel = new JLabel("Page size:");
        pageSizePanel.add(pageSizeLabel);
        pageSizePanel.add(pageSizeComboBox);
        paginatorPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(0,0, 0,pageSizePanel.getPreferredSize().width ), paginatorPanel.getBorder()));
        bottomPanel.add(pageSizePanel, BorderLayout.WEST);
        bottomPanel.add(paginatorPanel, BorderLayout.CENTER);

        add(bottomPanel, BorderLayout.SOUTH);
        sortAndFilter.setPageSize(FlipFilterAndSort.DEFAULT_PAGE_SIZE);
    }

    private void setSpinnerVisible(boolean visible) {
        SwingUtilities.invokeLater(() -> {
            if (visible) {
                spinnerOverlay.setVisible(true);
                table.setEnabled(false);
            } else {
                spinnerOverlay.setVisible(false);
                table.setEnabled(true);
            }
        });
    }

    private JButton createDownloadButton() {
        JButton button = new JButton();
        button.setToolTipText("Download as CSV");
        button.setFocusable(false);
        button.setText("Download");
        button.addActionListener(e -> downloadAsCSV());
        return button;
    }

    private void setupDropdowns() {
        accountDropdown = new AccountDropdown(
                copilotLoginManager::displayNameToAccountIdMap,
                sortAndFilter::setAccountId,
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        accountDropdown.setPreferredSize(new Dimension(120, accountDropdown.getPreferredSize().height));
        accountDropdown.setToolTipText("Select account");
        accountDropdown.refresh();

        timeIntervalDropdown = new IntervalDropdown(sortAndFilter::setInterval, IntervalDropdown.ALL_TIME, false);
        timeIntervalDropdown.setPreferredSize(new Dimension(150, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setToolTipText("Select time interval");
    }

    private void showFlipMenu(MouseEvent e, int row) {
        FlipV2 flip = currentFlips.get(row);

        JPopupMenu menu = new JPopupMenu();
        JMenuItem deleteItem = new JMenuItem("Delete flip");
        deleteItem.addActionListener(evt -> {
            int result = JOptionPane.showConfirmDialog(this,
                    "Are you sure you want to delete this flip?",
                    "Confirm Delete",
                    JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION) {
                setSpinnerVisible(true);
                log.info("deleting flip with ID: {}", flip.getId());
                Consumer<FlipV2> onSuccess = (f) -> {
                    flipsManager.mergeFlips(Collections.singletonList(f),copilotLoginManager.getCopilotUserId());
                    setSpinnerVisible(false);
                    sortAndFilter.reloadFlips(true, true);
                };
                apiRequestHandler.asyncDeleteFlip(flip, onSuccess, () -> setSpinnerVisible(false));
            }
        });
        menu.add(deleteItem);

        String displayName = copilotLoginManager.getDisplayName(flip.getAccountId());
        if (displayName != null && !FlipStatus.FINISHED.equals(flip.getStatus())) {
            JMenuItem missedSellTransaction = new JMenuItem("Add missed sell transaction");
            missedSellTransaction.addActionListener(evt -> {
                int qty = flip.getOpenedQuantity() - flip.getClosedQuantity();
                int suggestedPrice = (int) (flip.getAvgBuyPrice() * 1.02);

                JPanel dialogPanel = new JPanel(new GridBagLayout());
                GridBagConstraints gbc = new GridBagConstraints();
                gbc.insets = new Insets(5, 5, 5, 5);
                gbc.anchor = GridBagConstraints.WEST;
                gbc.gridx = 0; gbc.gridy = 0;
                dialogPanel.add(new JLabel("Item:"), gbc);
                gbc.gridx = 1;
                dialogPanel.add(new JLabel(flip.getCachedItemName()), gbc);
                gbc.gridx = 0; gbc.gridy = 1;
                dialogPanel.add(new JLabel("Quantity:"), gbc);
                gbc.gridx = 1;
                dialogPanel.add(new JLabel(String.valueOf(qty)), gbc);
                gbc.gridx = 0; gbc.gridy = 2;
                dialogPanel.add(new JLabel("Sell Price:"), gbc);
                gbc.gridx = 1;
                JTextField priceField = new JTextField(String.valueOf(suggestedPrice), 10);
                dialogPanel.add(priceField, gbc);

                int result = JOptionPane.showConfirmDialog(this,
                        dialogPanel,
                        "Add Missed Sell Transaction",
                        JOptionPane.YES_NO_OPTION,
                        JOptionPane.PLAIN_MESSAGE);

                if (result == JOptionPane.YES_OPTION) {
                    try {
                        int price = Integer.parseInt(priceField.getText().trim());
                        if (price <= 0) {
                            JOptionPane.showMessageDialog(this,
                                    "Price must be a positive number.",
                                    "Invalid Price",
                                    JOptionPane.ERROR_MESSAGE);
                            return;
                        }

                        setSpinnerVisible(true);
                        log.info("Adding missed sell transaction for flip with ID: {}", flip.getId());

                        Transaction t = new Transaction();
                        t.setId(UUID.randomUUID());
                        t.setType(OfferStatus.SELL);
                        t.setItemId(flip.getItemId());
                        t.setPrice(price);
                        t.setQuantity(qty);
                        t.setBoxId(0);
                        t.setAmountSpent(price * qty);
                        t.setTimestamp(Instant.now());
                        t.setCopilotPriceUsed(true);
                        t.setWasCopilotSuggestion(true);
                        t.setOfferTotalQuantity(qty);

                        BiConsumer<Integer, List<FlipV2>> onSuccess = (userId, flips) -> {
                            flipsManager.mergeFlips(flips, userId);
                            setSpinnerVisible(false);
                            sortAndFilter.reloadFlips(true, true);
                        };
                        Consumer<HttpResponseException> onFailure = (r) -> {
                            setSpinnerVisible(false);
                            JOptionPane.showMessageDialog(this,
                                    "Failed to add sell transaction. Please try again.",
                                    "Transaction Error",
                                    JOptionPane.ERROR_MESSAGE);
                        };
                        apiRequestHandler.sendTransactionsAsync(List.of(t), displayName, onSuccess, onFailure);

                    } catch (NumberFormatException ex) {
                        JOptionPane.showMessageDialog(this,
                                "Please enter a valid number for the price.",
                                "Invalid Price",
                                JOptionPane.ERROR_MESSAGE);
                    }
                }
            });
            menu.add(missedSellTransaction);
        }
        menu.show(e.getComponent(), e.getX(), e.getY());
    }

    private void downloadAsCSV() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setSelectedFile(new File("flips.csv"));
        if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            try (FileWriter writer = new FileWriter(file)) {
                sortAndFilter.writeCsvRecords(writer);
                JOptionPane.showMessageDialog(this, "Flips exported successfully!",
                        "Export Complete", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                log.error("Error exporting flips", ex);
                JOptionPane.showMessageDialog(this, "Error exporting flips: " + ex.getMessage(),
                        "Export Error", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    private void showFlips(List<FlipV2> flips) {
        SwingUtilities.invokeLater(() -> {
            currentFlips = flips;
            tableModel.setRowCount(0);
            Map<Integer, String> accountIdToDisplayName = copilotLoginManager.accountIDToDisplayNameMap();
            for (FlipV2 flip : flips) {
                long profitPerItem = flip.getClosedQuantity() > 0 ? flip.getProfit() / flip.getClosedQuantity() : 0L;

                Object[] row = {
                        formatTimestamp(flip.getOpenedTime()),
                        formatTimestamp(flip.getClosedTime()),
                        accountIdToDisplayName.getOrDefault(flip.getAccountId(), "Display name not loaded"),
                        flip.getCachedItemName(),
                        flip.getStatus().name(),
                        flip.getOpenedQuantity(),
                        flip.getClosedQuantity(),
                        flip.getSpent() / flip.getOpenedQuantity(),
                        flip.getClosedQuantity() ==0 ? 0 : (flip.getReceivedPostTax() + flip.getTaxPaid()) / flip.getClosedQuantity(),
                        flip.getTaxPaid(),
                        flip.getProfit(),
                        profitPerItem
                };
                tableModel.addRow(row);
            }

            for (int i = 0; i < table.getColumnCount(); i++) {
                resizeColumnWidth(table, i);
            }
        });
    }

    private void resizeColumnWidth(JTable table, int column) {
        TableColumn tableColumn = table.getColumnModel().getColumn(column);
        int preferredWidth = tableColumn.getMinWidth();
        int maxWidth = tableColumn.getMaxWidth();
        Component comp = table.getTableHeader().getDefaultRenderer()
                .getTableCellRendererComponent(table, tableColumn.getHeaderValue(), false, false, 0, column);
        preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);
        for (int row = 0; row < table.getRowCount(); row++) {
            comp = table.getCellRenderer(row, column)
                    .getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);
            preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);
        }

        preferredWidth = Math.min(preferredWidth, maxWidth);
        tableColumn.setPreferredWidth(preferredWidth);
    }

    private String formatTimestamp(int epochSeconds) {
        if (epochSeconds == 0) {
            return "N/A";
        }
        return formatEpoch(epochSeconds);
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.FlipManager;
import com.flippingcopilot.model.SessionManager;
import com.google.inject.name.Named;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.concurrent.ExecutorService;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class FlipsDialogController {

    private final ItemController itemController;
    private final FlipManager flipsManager;
    @Named("copilotExecutor")
    private final ExecutorService executorService;
    private final SessionManager sessionManager;
    private final CopilotLoginManager copilotLoginManager;
    private final FlippingCopilotConfig config;
    private final ApiRequestHandler apiRequestHandler;

    private JDialog currentDialog = null;
    private Point lastDialogPosition = null;
    private Dimension lastDialogSize = null;

    public void showFlipsDialog() {
        if (!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(this::showFlipsDialog);
            return;
        }

        try {
            long st = System.currentTimeMillis();
            log.info("showing flips dialog");

            if (currentDialog != null) {
                lastDialogPosition = currentDialog.getLocation();
                lastDialogSize = currentDialog.getSize();
                currentDialog.dispose();
            }

            JDialog dialog = new JDialog();
            dialog.setTitle("Flipping Copilot - Flips & Transactions");
            dialog.setResizable(true);
            dialog.setMinimumSize(new Dimension(800, 600));

            JTabbedPane tabbedPane = new JTabbedPane();
            tabbedPane.setBackground(ColorScheme.DARK_GRAY_COLOR);

            // Initialize all panels upfront
            log.debug("Creating FlipsPanel...");
            long startTime = System.currentTimeMillis();
            FlipsPanel flipsPanel = new FlipsPanel(flipsManager, itemController, copilotLoginManager,
                    executorService, config, apiRequestHandler);
            log.debug("FlipsPanel created in {}s", (System.currentTimeMillis() - startTime) / 1000.0);

            log.debug("Creating ItemAggregatePanel...");
            startTime = System.currentTimeMillis();
            ItemAggregatePanel itemsPanel = new ItemAggregatePanel(flipsManager, itemController,
                    copilotLoginManager, executorService, config);
            log.debug("ItemAggregatePanel created in {}s", (System.currentTimeMillis() - startTime) / 1000.0);

            log.debug("Creating AccountsAggregatePanel...");
            startTime = System.currentTimeMillis();
            AccountsAggregatePanel accountsPanel = new AccountsAggregatePanel(flipsManager, copilotLoginManager,
                    executorService, config, apiRequestHandler, flipsManager);
            log.debug("AccountsAggregatePanel created in {}s", (System.currentTimeMillis() - startTime) / 1000.0);

            log.debug("Creating ProfitPanel...");
            startTime = System.currentTimeMillis();
            ProfitPanel profitPanel = new ProfitPanel(flipsManager, executorService, sessionManager,
                    copilotLoginManager, config);
            log.debug("ProfitPanel created in {}s", (System.currentTimeMillis() - startTime) / 1000.0);

            log.debug("Creating TransactionsPanel...");
            startTime = System.currentTimeMillis();
            TransactionsPanel transactionsPanel = new TransactionsPanel(copilotLoginManager, itemController,
                    executorService, apiRequestHandler, config, flipsManager);
            log.debug("TransactionsPanel created in {}s", (System.currentTimeMillis() - startTime) / 1000.0);



            // Add all tabs
            tabbedPane.addTab("Flips", flipsPanel);
            tabbedPane.addTab("Items", itemsPanel);
            tabbedPane.addTab("Accounts", accountsPanel);
            tabbedPane.addTab("Profit graph", profitPanel);
            tabbedPane.addTab("Transactions", transactionsPanel);

            tabbedPane.addChangeListener(e -> {
                if (tabbedPane.getSelectedIndex() == 4) {
                    transactionsPanel.loadTransactionsIfNeeded();
                } else if (tabbedPane.getSelectedIndex() == 0) {
                    flipsPanel.sortAndFilter.reloadFlips(true, true);
                }
            });


            dialog.setContentPane(tabbedPane);

            // Set size and position
            if (lastDialogSize != null && lastDialogPosition != null) {
                dialog.setSize(lastDialogSize);
                dialog.setLocation(lastDialogPosition);
            } else {
                GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
                Rectangle bounds = env.getMaximumWindowBounds(); // Excludes taskbar
                dialog.setSize(bounds.width, bounds.height);
                dialog.setLocation(bounds.x, bounds.y);
            }

            // Add window listener to save position
            dialog.addWindowListener(new WindowAdapter() {
                @Override
                public void windowClosing(WindowEvent e) {
                    lastDialogPosition = dialog.getLocation();
                    lastDialogSize = dialog.getSize();
                    log.info("saved dialog position: {} and size: {}", lastDialogPosition, lastDialogSize);
                }
            });

            currentDialog = dialog;
            dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
            dialog.setModalityType(Dialog.ModalityType.MODELESS);
            dialog.setVisible(true);

            log.info("flips dialog shown successfully {}s", (System.currentTimeMillis() - st) / 1000.0);
        } catch (Exception e) {
            log.error("Error showing flips dialog: {}", e.getMessage(), e);
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.FlipManager;
import com.flippingcopilot.model.FlipV2;
import com.flippingcopilot.model.SessionManager;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.IntervalDropdown;
import com.flippingcopilot.ui.graph.model.Bounds;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Named;
import javax.swing.*;
import java.awt.*;
import java.time.*;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;

@Slf4j
public class ProfitPanel extends JPanel {

    // dependencies
    private final FlipManager flipManager;
    private final ExecutorService executorService;

    private final ProfitGraphPanel graphPanel;
    private final AccountDropdown accountDropdown;
    private final IntervalDropdown intervalDropdown;

    // State
    private int cachedIntervalStartTime = -1; // Default to ALL
    private Integer cachedAccountId = null;
    private List<ProfitGraphPanel.ProfitDataPoint> cachedDataPoints = new ArrayList<>();
    private Bounds cachedBounds = new Bounds(0, 0, 0, 0);

    public ProfitPanel(FlipManager flipManager,
                       @Named("copilotExecutor") ExecutorService executorService,
                       SessionManager sessionManager,
                       CopilotLoginManager copilotLoginManager,
                       FlippingCopilotConfig config) {
        this.flipManager = flipManager;
        this.executorService = executorService;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create top panel with controls
        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Create left panel with dropdowns
        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        intervalDropdown = new IntervalDropdown((units, value) -> refreshGraph(), IntervalDropdown.ALL_TIME, false);
        intervalDropdown.setPreferredSize(new Dimension(150, intervalDropdown.getPreferredSize().height));
        intervalDropdown.setToolTipText("Select time interval");

        accountDropdown = new AccountDropdown(
                copilotLoginManager::displayNameToAccountIdMap,
                accountId -> refreshGraph(),
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        accountDropdown.setPreferredSize(new Dimension(120, accountDropdown.getPreferredSize().height));
        accountDropdown.setToolTipText("Select account");
        accountDropdown.refresh();

        leftPanel.add(intervalDropdown);
        leftPanel.add(Box.createRigidArea(new Dimension(3, 0)));
        leftPanel.add(accountDropdown);

        topPanel.add(leftPanel, BorderLayout.WEST);
        add(topPanel, BorderLayout.NORTH);

        // Create graph panel with initial empty data
        graphPanel = new ProfitGraphPanel(config.profitAmountColor(), config.lossAmountColor());
        add(graphPanel, BorderLayout.CENTER);
        refreshGraph();
    }

    private void refreshGraph() {
        executorService.submit(() -> {
            try {
                // not fully initialised
                if(accountDropdown == null || intervalDropdown == null) {
                    return;
                }
                // Check if we need to regenerate the data
                Integer accountId = accountDropdown.getSelectedAccountId();
                int startTime = (int) IntervalDropdown.calculateStartTime(intervalDropdown.getSelectedIntervalTimeUnit(), intervalDropdown.getSelectedIntervalValue(), 0);
                boolean needsRegeneration = cachedDataPoints.isEmpty() ||
                        !Objects.equals(cachedAccountId, accountId) ||
                        cachedIntervalStartTime != startTime;

                if (needsRegeneration) {
                    log.debug("Regenerating profit data points");
                    ProfitAggregator aggregator = new ProfitAggregator();
                    cachedIntervalStartTime = startTime;
                    cachedAccountId = accountId;
                    flipManager.aggregateFlips(cachedIntervalStartTime, cachedAccountId, false, aggregator);
                    Pair<List<ProfitGraphPanel.ProfitDataPoint>, Bounds> data = aggregator.generateProfitDataPoints();
                    cachedDataPoints = data.getLeft();
                    cachedBounds = data.getRight();
                    log.debug("Generated {} profit data points", cachedDataPoints.size());
                }

                SwingUtilities.invokeLater(() -> {
                    graphPanel.setData(cachedDataPoints, cachedBounds);
                    graphPanel.repaint();
                });
            } catch (Exception e) {
                log.error("Error refreshing profit graph", e);
            }
        });
    }

    @AllArgsConstructor
    private static class ProfitAggregator implements Consumer<FlipV2> {
        private final Map<LocalDate, Long> dailyProfits = new TreeMap<>();
        private final ZoneId zoneId = ZoneId.systemDefault();

        @Override
        public void accept(FlipV2 flip) {
            if (flip.getClosedQuantity() > 0) {
                LocalDate flipDate = LocalDate.ofInstant(Instant.ofEpochSecond(flip.getClosedTime()), zoneId);
                dailyProfits.merge(flipDate, flip.getProfit(), Long::sum);
            }
        }

        public Pair<List<ProfitGraphPanel.ProfitDataPoint>, Bounds> generateProfitDataPoints() {
            long now = Instant.now().getEpochSecond();
            List<ProfitGraphPanel.ProfitDataPoint> dataPoints = new ArrayList<>();

            if (dailyProfits.isEmpty()) {
                Bounds bounds = new Bounds((int) now, (int) now, 0, 1_000_000);
                dataPoints.add(new ProfitGraphPanel.ProfitDataPoint(now, 0));
                return Pair.of(dataPoints, bounds);
            }

            // Initialize bounds
            LocalDate firstDate = dailyProfits.keySet().iterator().next();
            long firstTimestamp = firstDate.atStartOfDay(zoneId).toEpochSecond();
            Bounds bounds = new Bounds((int) firstTimestamp, (int) now, 0, 0);

            long cumulativeProfit = 0;

            dataPoints.add(new ProfitGraphPanel.ProfitDataPoint(firstTimestamp, 0));

            for (Map.Entry<LocalDate, Long> entry : dailyProfits.entrySet()) {
                LocalDate date = entry.getKey();
                long dailyProfit = entry.getValue();

                long startOfDay = date.atStartOfDay(zoneId).toEpochSecond();
                dataPoints.add(new ProfitGraphPanel.ProfitDataPoint(startOfDay, cumulativeProfit));

                cumulativeProfit += dailyProfit;

                long endOfDay = date.atTime(23, 59, 59).atZone(zoneId).toEpochSecond();
                dataPoints.add(new ProfitGraphPanel.ProfitDataPoint(endOfDay, cumulativeProfit));

                bounds.yMin = Math.min(bounds.yMin, cumulativeProfit);
                bounds.yMax = Math.max(bounds.yMax, cumulativeProfit);
            }

            // todo: something weird going on with last timestamp > now - probably time zones issue
            ProfitGraphPanel.ProfitDataPoint last = dataPoints.get(dataPoints.size()-1);
            if(last.timestamp < now) {
                dataPoints.add(new ProfitGraphPanel.ProfitDataPoint(now, cumulativeProfit));
            } else {
                bounds.xMax = (int) last.timestamp;
            }
            bounds.yMax += (long) (0.1d * bounds.yDelta());
            if (bounds.yMax == 0) {
                bounds.yMax = 1_000_000;
            }
            return Pair.of(dataPoints, bounds);
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.Paginator;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.IntervalDropdown;
import com.flippingcopilot.ui.components.ItemSearchMultiSelect;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.NumberFormat;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;

@Slf4j
public class ItemAggregatePanel extends JPanel {

    private static final Integer[] PAGE_SIZE_OPTIONS = {10, 25, 50, 100, 200, 500, 1000, 2000};
    private static final NumberFormat GP_FORMAT = NumberFormat.getNumberInstance(Locale.US);

    // dependencies
    private final CopilotLoginManager copilotLoginManager;

    // ui components
    private final DefaultTableModel tableModel;
    private final JTable table;
    private final Paginator paginatorPanel;
    private final Spinner spinner;
    private final JScrollPane scrollPane;
    private ItemSearchMultiSelect searchField;
    private IntervalDropdown timeIntervalDropdown;
    private AccountDropdown accountDropdown;
    private JComboBox<Integer> pageSizeComboBox;

    // state
    private ItemAggregateFilterSort sortAndFilter;

    private final String[] columnNames = {
            "Item", "Number of flips", "Total quantity flipped", "Biggest loss", "Biggest win", "Total profit", "Avg profit", "Avg profit ea."
    };
    private JPanel spinnerOverlay;

    public ItemAggregatePanel(FlipManager flipsManager,
                              ItemController itemController,
                              CopilotLoginManager copilotLoginManager,
                              @Named("copilotExecutor") ExecutorService executorService,
                              FlippingCopilotConfig config) {
        this.copilotLoginManager = copilotLoginManager;
        setFocusable(true);

        paginatorPanel = new Paginator((i) -> sortAndFilter.setPage(i));
        sortAndFilter = new ItemAggregateFilterSort(flipsManager, itemController, this::showAggregates,
                paginatorPanel::setTotalPages, this::setSpinnerVisible, executorService);

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        searchField = new ItemSearchMultiSelect(
                sortAndFilter::getFilteredItems,
                itemController::allItemIds,
                itemController::search,
                sortAndFilter::setFilteredItems,
                "Items filter...");
        searchField.setMinimumSize(new Dimension(300, 0));
        searchField.setToolTipText("Search by item name");

        pageSizeComboBox = new JComboBox<>(PAGE_SIZE_OPTIONS);
        pageSizeComboBox.setSelectedItem(sortAndFilter.getPageSize());
        pageSizeComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizeComboBox.setFocusable(false);
        pageSizeComboBox.setToolTipText("Page size");
        pageSizeComboBox.addActionListener(e -> sortAndFilter.setPageSize((Integer) pageSizeComboBox.getSelectedItem()));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        topPanel.add(leftPanel, BorderLayout.WEST);
        topPanel.add(buttonPanel, BorderLayout.EAST);
        add(topPanel, BorderLayout.NORTH);

        tableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        table = new JTable(tableModel);
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        table.setSelectionBackground(ColorScheme.BRAND_ORANGE);
        table.setSelectionForeground(Color.WHITE);
        table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
        table.setRowHeight(25);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

        table.setRowSorter(null);
        table.getTableHeader().setReorderingAllowed(false);
        table.setFocusable(false);

        table.getTableHeader().addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                int columnIndex = table.getTableHeader().columnAtPoint(e.getPoint());
                if (columnIndex >= 0 && columnIndex < columnNames.length) {
                    String clickedColumn = columnNames[columnIndex];

                    SortDirection newDirection = SortDirection.DESC;
                    if (clickedColumn.equals(sortAndFilter.getSortColumn())) {
                        newDirection = sortAndFilter.getSortDirection() == SortDirection.DESC ?
                                SortDirection.ASC : SortDirection.DESC;
                    }

                    sortAndFilter.setSortColumn(clickedColumn);
                    sortAndFilter.setSortDirection(newDirection);
                }
            }
        });

        DefaultTableCellRenderer moneyRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    setText(formatGp((Long) value));
                    setHorizontalAlignment(RIGHT);
                }
                return c;
            }
        };

        DefaultTableCellRenderer profitRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    long amount = (Long) value;
                    setText(formatGp(amount));
                    setHorizontalAlignment(RIGHT);

                    // Color profit/loss only if not selected
                    if (!isSelected) {
                        if (amount > 0) {
                            setForeground(config.profitAmountColor());
                        } else if (amount < 0) {
                            setForeground(config.lossAmountColor());
                        } else {
                            setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                        }
                    }
                }
                return c;
            }
        };

        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        table.getColumnModel().getColumn(1).setCellRenderer(centerRenderer);
        table.getColumnModel().getColumn(2).setCellRenderer(moneyRenderer);
        table.getColumnModel().getColumn(3).setCellRenderer(moneyRenderer);
        table.getColumnModel().getColumn(4).setCellRenderer(profitRenderer);
        table.getColumnModel().getColumn(5).setCellRenderer(profitRenderer);
        table.getColumnModel().getColumn(6).setCellRenderer(profitRenderer);
        table.getColumnModel().getColumn(7).setCellRenderer(profitRenderer);

        setupDropdowns();

        leftPanel.add(searchField);
        leftPanel.add(Box.createRigidArea(new Dimension(3, 0)));
        leftPanel.add(timeIntervalDropdown);
        leftPanel.add(Box.createRigidArea(new Dimension(3, 0)));
        leftPanel.add(accountDropdown);

        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        layeredPane.setOpaque(true);

        spinner = new Spinner();
        spinner.show();
        spinnerOverlay = new JPanel(new GridBagLayout());
        spinnerOverlay.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spinnerOverlay.setOpaque(true);
        spinnerOverlay.add(spinner);
        spinnerOverlay.setVisible(false); // Initially hidden

        scrollPane = new JScrollPane(table);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);

        layeredPane.setLayout(new OverlayLayout(layeredPane));
        layeredPane.add(spinnerOverlay, JLayeredPane.MODAL_LAYER);
        layeredPane.add(scrollPane, JLayeredPane.DEFAULT_LAYER);

        add(layeredPane, BorderLayout.CENTER);

        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel pageSizePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        pageSizePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizePanel.setBorder(BorderFactory.createEmptyBorder(4, 0, 0, 0));
        JLabel pageSizeLabel = new JLabel("Page size:");
        pageSizePanel.add(pageSizeLabel);
        pageSizePanel.add(pageSizeComboBox);
        paginatorPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createEmptyBorder(0, 0, 0, pageSizePanel.getPreferredSize().width),
                paginatorPanel.getBorder()));
        bottomPanel.add(pageSizePanel, BorderLayout.WEST);
        bottomPanel.add(paginatorPanel, BorderLayout.CENTER);

        add(bottomPanel, BorderLayout.SOUTH);
        sortAndFilter.setPageSize(ItemAggregateFilterSort.DEFAULT_PAGE_SIZE);
    }

    private void setSpinnerVisible(boolean visible) {
        SwingUtilities.invokeLater(() -> {
            if (visible) {
                spinnerOverlay.setVisible(true);
                table.setEnabled(false);
            } else {
                spinnerOverlay.setVisible(false);
                table.setEnabled(true);
            }
        });
    }

    private void setupDropdowns() {
        accountDropdown = new AccountDropdown(
                copilotLoginManager::displayNameToAccountIdMap,
                sortAndFilter::setAccountId,
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        accountDropdown.setPreferredSize(new Dimension(120, accountDropdown.getPreferredSize().height));
        accountDropdown.setToolTipText("Select account");
        accountDropdown.refresh();

        timeIntervalDropdown = new IntervalDropdown(sortAndFilter::setInterval, IntervalDropdown.ALL_TIME, false);
        timeIntervalDropdown.setPreferredSize(new Dimension(150, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setToolTipText("Select time interval");
    }

    private void showAggregates(List<ItemAggregate> aggregates) {
        SwingUtilities.invokeLater(() -> {
            tableModel.setRowCount(0);
            for (ItemAggregate aggregate : aggregates) {
                Object[] row = {
                        aggregate.getItemName(),
                        aggregate.getNumberOfFlips(),
                        aggregate.getTotalQuantityFlipped(),
                        aggregate.getBiggestLoss(),
                        aggregate.getBiggestWin(),
                        aggregate.getTotalProfit(),
                        aggregate.getAvgProfit(),
                        aggregate.getAvgProfitEa()
                };
                tableModel.addRow(row);
            }

            for (int i = 0; i < table.getColumnCount(); i++) {
                resizeColumnWidth(table, i);
            }
        });
    }

    private void resizeColumnWidth(JTable table, int column) {
        TableColumn tableColumn = table.getColumnModel().getColumn(column);
        int preferredWidth = tableColumn.getMinWidth();
        int maxWidth = tableColumn.getMaxWidth();

        Component comp = table.getTableHeader().getDefaultRenderer()
                .getTableCellRendererComponent(table, tableColumn.getHeaderValue(), false, false, 0, column);
        preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);

        for (int row = 0; row < table.getRowCount(); row++) {
            comp = table.getCellRenderer(row, column)
                    .getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);
            preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);
        }

        preferredWidth = Math.min(preferredWidth, maxWidth);
        tableColumn.setPreferredWidth(preferredWidth);
    }

    private String formatGp(long amount) {
        return GP_FORMAT.format(amount);
    }
}
package com.flippingcopilot.ui.components;

import com.flippingcopilot.model.IntervalTimeUnit;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.plaf.basic.BasicComboBoxEditor;
import java.awt.*;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.function.BiConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class IntervalDropdown extends JComboBox<String> {

    public static final String SESSION = "Session";
    public static final String ALL_TIME = "All time";
    public static final String PICK_START_DATE = "Pick start date";
    private static final String[] TIME_INTERVAL_STRINGS = {
            "-1h (Past Hour)",
            "-4h (Past 4 Hours)",
            "-12h (Past 12 Hours)",
            "-1d (Past Day)",
            "-1w (Past Week)",
            "-1m (Past Month)",
            SESSION,
            ALL_TIME,
            PICK_START_DATE
    };

    private static final Pattern INTERVAL_PATTERN = Pattern.compile("^-?(\\d+(?:\\.\\d+)?)([hdwmy])[()\\w\\s]*");

    // state
    private final BiConsumer<IntervalTimeUnit, Integer> onIntervalChanged;
    @Getter
    private IntervalTimeUnit selectedIntervalTimeUnit = IntervalTimeUnit.ALL;
    @Getter
    private int selectedIntervalValue = -1;

    public IntervalDropdown(BiConsumer<IntervalTimeUnit, Integer> onIntervalChanged, String initialValue, boolean includeSessionOption) {
        super(Arrays.stream(TIME_INTERVAL_STRINGS).filter(i -> !i.equals(SESSION) || includeSessionOption).toArray(String[]::new));
        this.onIntervalChanged = onIntervalChanged;

        setEditable(true);
        setSelectedItem(initialValue);
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));
        setBorder(BorderFactory.createEmptyBorder());

        // Create a custom editor to handle both selection and manual input
        ComboBoxEditor editor = new BasicComboBoxEditor() {
            @Override
            public void setItem(Object item) {
                super.setItem(item);
                if (item != null) {
                    String value = item.toString();
                    if (PICK_START_DATE.equals(value)) {
                        // Don't process immediately, wait for action listener
                        return;
                    }
                    if (extractAndUpdateTimeInterval(value)) {
                        onIntervalChanged.accept(selectedIntervalTimeUnit, selectedIntervalValue);
                    }
                }
            }
        };
        setEditor(editor);

        // Add action listener for selection changes and manual edits
        addActionListener(e -> {
            String value = (String) getSelectedItem();
            if (PICK_START_DATE.equals(value)) {
                showDatePicker();
            } else if (extractAndUpdateTimeInterval(value)) {
                onIntervalChanged.accept(selectedIntervalTimeUnit, selectedIntervalValue);
            }
        });
    }

    private void showDatePicker() {
        // Create a date spinner
        SpinnerDateModel dateModel = new SpinnerDateModel();
        JSpinner dateSpinner = new JSpinner(dateModel);
        JSpinner.DateEditor dateEditor = new JSpinner.DateEditor(dateSpinner, "yyyy-MM-dd");
        dateSpinner.setEditor(dateEditor);

        dateSpinner.setValue(new Date());
        int result = JOptionPane.showConfirmDialog(
                SwingUtilities.getWindowAncestor(this),
                dateSpinner,
                PICK_START_DATE,
                JOptionPane.OK_CANCEL_OPTION,
                JOptionPane.PLAIN_MESSAGE
        );

        if (result == JOptionPane.OK_OPTION) {
            Date selectedDate = (Date) dateSpinner.getValue();
            String intervalString = convertDateToIntervalString(selectedDate);
            setSelectedItem(intervalString);
            extractAndUpdateTimeInterval(intervalString);
            onIntervalChanged.accept(selectedIntervalTimeUnit, selectedIntervalValue);
        }
    }

    /**
     * Converts a selected date to an interval string like "3.5w" or "2d"
     */
    private String convertDateToIntervalString(Date selectedDate) {
        LocalDate selected = selectedDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        LocalDate today = LocalDate.now();

        long daysDiff = ChronoUnit.DAYS.between(selected, today);

        if (daysDiff < 0) {
            // Future date, return as days
            return Math.abs(daysDiff) + "d (Future)";
        }

        // Convert to appropriate unit
        if (daysDiff < 1) {
            // Less than a day, use hours
            long hoursDiff = ChronoUnit.HOURS.between(
                    selected.atStartOfDay(ZoneId.systemDefault()),
                    today.atStartOfDay(ZoneId.systemDefault())
            );
            return "-" + hoursDiff + "h";
        } else if (daysDiff < 7) {
            // Less than a week, use days
            return "-" + daysDiff + "d";
        } else if (daysDiff < 30) {
            // Less than a month, use weeks (with decimal)
            double weeks = daysDiff / 7.0;
            if (weeks == Math.floor(weeks)) {
                return "-" + (int)weeks + "w";
            } else {
                return String.format("-%.1fw", weeks);
            }
        } else if (daysDiff < 365) {
            // Less than a year, use months (approximation)
            double months = daysDiff / 30.0;
            if (months == Math.floor(months)) {
                return "-" + (int)months + "m";
            } else {
                return String.format("-%.1fm", months);
            }
        } else {
            // More than a year, use years
            double years = daysDiff / 365.0;
            if (years == Math.floor(years)) {
                return "-" + (int)years + "y";
            } else {
                return String.format("-%.1fy", years);
            }
        }
    }

    private boolean extractAndUpdateTimeInterval(String value) {
        if (value != null) {
            if ("Session".equals(value)) {
                selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
                selectedIntervalValue = -1;
                return true;
            } else if (ALL_TIME.equals(value)) {
                selectedIntervalTimeUnit = IntervalTimeUnit.ALL;
                selectedIntervalValue = -1;
                return true;
            } else if (PICK_START_DATE.equals(value)) {
                // Don't update here, handled in action listener
                return false;
            } else {
                Matcher matcher = INTERVAL_PATTERN.matcher(value);
                if (matcher.matches()) {
                    String numberStr = matcher.group(1);
                    // Handle decimal values by rounding
                    double doubleValue = Double.parseDouble(numberStr);
                    selectedIntervalValue = (int) Math.round(doubleValue);
                    selectedIntervalTimeUnit = IntervalTimeUnit.fromString(matcher.group(2));
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Resets the dropdown to "Session" selection.
     */
    public void resetToSession() {
        setSelectedItem("Session");
        selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
        selectedIntervalValue = -1;
        onIntervalChanged.accept(selectedIntervalTimeUnit, selectedIntervalValue);
    }

    public static long calculateStartTime(IntervalTimeUnit selectedUnits, Integer selectedValue, Integer sessionStartTime) {
        switch (selectedUnits) {
            case ALL:
                return 1;
            case SESSION:
                return sessionStartTime;
            default:
                return Instant.now().getEpochSecond() - (long) selectedValue * selectedUnits.getSeconds();
        }
    }
}
package com.flippingcopilot.ui.components;
import com.google.common.base.MoreObjects;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.util.Map;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Supplier;

@Slf4j
public class AccountDropdown extends JComboBox<String> {

    public static final String ALL_ACCOUNTS_DROPDOWN_OPTION = "All accounts";

    // dependencies
    private final Supplier<Map<String, Integer>> accountsGetter;

    // state
    private Map<String, Integer> cachedAccounts;
    private volatile boolean refreshInProgress = false;

    public AccountDropdown(Supplier<Map<String, Integer>> accountsGetter, Consumer<Integer> onSelectedAccountChanged, String initialValue) {

        super();
        this.accountsGetter = accountsGetter;
        DefaultComboBoxModel<String> model = (DefaultComboBoxModel<String>) getModel();
        if(ALL_ACCOUNTS_DROPDOWN_OPTION.equals(initialValue)) {
            model.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
        } else {
            model.addElement(initialValue);
            model.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
        }
        setBorder(BorderFactory.createEmptyBorder());
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));
        setSelectedItem(initialValue);
        addItemListener(e -> {
            if (!refreshInProgress && e.getStateChange() == ItemEvent.SELECTED) {
                onSelectedAccountChanged.accept(getSelectedAccountId());
            }
        });
    }

    public Integer getSelectedAccountId() {
        String value = (String) getSelectedItem();
        if (value == null || ALL_ACCOUNTS_DROPDOWN_OPTION.equals(value)) {
            return null;
        }
        return cachedAccounts.getOrDefault(value, -1);
    }

    public void refresh() {
        Map<String, Integer> displayNameOptions = accountsGetter.get();
        if (!Objects.equals(displayNameOptions, cachedAccounts)) {
            cachedAccounts = displayNameOptions;
            String previousSelectedItem = (String) getSelectedItem();
            refreshInProgress = true;
            DefaultComboBoxModel<String> model = (DefaultComboBoxModel<String>) getModel();
            model.removeAllElements();
            cachedAccounts.forEach((k, v) -> {
                model.addElement(k);
            });
            model.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
            setVisible(model.getSize() > 1);
            refreshInProgress = false;
            setSelectedItem(MoreObjects.firstNonNull(previousSelectedItem, ALL_ACCOUNTS_DROPDOWN_OPTION));
        }
    }

    public void setSelectedAccountId(Integer accountId) {
        if (accountId == null) {
            setSelectedItem(ALL_ACCOUNTS_DROPDOWN_OPTION);
        } else {
            if(cachedAccounts == null) {
                cachedAccounts = accountsGetter.get();
            }
            for (Map.Entry<String, Integer> a : cachedAccounts.entrySet()) {
                if(a.getValue().equals(accountId)) {
                    setSelectedItem(a.getKey());
                }
            }
        }
    }
}
package com.flippingcopilot.ui.components;

import com.flippingcopilot.model.ItemIdName;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import org.apache.commons.lang3.tuple.Pair;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Supplier;

@Slf4j
@Singleton
public class ItemSearchMultiSelect extends JPanel {

    private static final int ITEM_HEIGHT = 20; // Fixed height for each item
    private static final int VISIBLE_ITEMS = 15; // Number of visible items at once


    private final String placeholderText;
    private final JTextField displayField;
    private final JWindow dropdownWindow;
    private final VirtualScrollPanel virtualScrollPanel;
    private final JScrollPane scrollPane;
    private final JPanel actionButtonsPanel;
    private final Supplier<Set<Integer>> allItemIdsSupplier;
    private final BiFunction<String, Set<Integer>, List<ItemIdName>> searchFunc;
    private final Consumer<Set<Integer>> onItemSelectionChanged;
    private final Supplier<Set<Integer>> selectedItemsGetter;
    private List<ItemIdName> currentSearchResults = new ArrayList<>();

    @Inject
    public ItemSearchMultiSelect(
            Supplier<Set<Integer>> selectedItemsGetter,
            Supplier<Set<Integer>> allItemIdsSupplier,
            BiFunction<String, Set<Integer>, List<ItemIdName>> searchFunc,
            Consumer<Set<Integer>> onItemSelectionChanged,
            String placeholderText) {
        super();
        this.allItemIdsSupplier = allItemIdsSupplier;
        this.selectedItemsGetter = selectedItemsGetter;
        this.searchFunc = searchFunc;
        this.onItemSelectionChanged = onItemSelectionChanged;
        this.placeholderText = placeholderText;

        setLayout(new BorderLayout());

        // Create main display field with placeholder
        displayField = new JTextField(placeholderText);
        displayField.setPreferredSize(new Dimension(200, displayField.getPreferredSize().height));
        displayField.setForeground(Color.GRAY);
        displayField.setFocusable(true);
        displayField.setEditable(true);


        // Remove focus border
        displayField.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR), BorderFactory.createEmptyBorder(5, 5, 5, 5)));

        // Setup display field panel without border
        JPanel dropdownPanel = new JPanel(new BorderLayout());
        dropdownPanel.add(displayField, BorderLayout.CENTER);
        dropdownPanel.setBackground(displayField.getBackground());

        // Add the dropdown panel directly without label
        add(dropdownPanel, BorderLayout.CENTER);
        setOpaque(true);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Setup dropdown components
        dropdownWindow = new JWindow();
        dropdownWindow.setFocusableWindowState(true);

        // Create action buttons panel (Select All / Unselect All)
        actionButtonsPanel = createActionButtonsPanel();

        // Use virtual scroll panel instead of regular panel
        virtualScrollPanel = new VirtualScrollPanel();
        scrollPane = new JScrollPane(virtualScrollPanel);
        scrollPane.setPreferredSize(new Dimension(300, ITEM_HEIGHT * VISIBLE_ITEMS));
        scrollPane.getVerticalScrollBar().setUnitIncrement(ITEM_HEIGHT);

        // Create dropdown content panel
        JPanel dropdownContent = new JPanel(new BorderLayout());
        dropdownContent.add(actionButtonsPanel, BorderLayout.NORTH);
        dropdownContent.add(scrollPane, BorderLayout.CENTER);
        dropdownContent.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));

        dropdownWindow.add(dropdownContent);
        setupListeners();
    }

    private JPanel createActionButtonsPanel() {
        JPanel panel = new JPanel(new GridLayout(1, 2, 0, 0)); // Use GridLayout for equal width buttons
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(null);

        JButton selectAllButton = new JButton("Select All");
        selectAllButton.setPreferredSize(new Dimension(0, ITEM_HEIGHT+5)); // Use ITEM_HEIGHT for button height
        selectAllButton.setFont(selectAllButton.getFont().deriveFont(Font.PLAIN, 14f));
        selectAllButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        selectAllButton.setForeground(Color.WHITE);
        selectAllButton.setBorder(BorderFactory.createRaisedBevelBorder());
        selectAllButton.setFocusPainted(false);

        JButton unselectAllButton = new JButton("Unselect All");
        unselectAllButton.setPreferredSize(new Dimension(0, ITEM_HEIGHT+5)); // Use ITEM_HEIGHT for button height
        unselectAllButton.setFont(unselectAllButton.getFont().deriveFont(Font.PLAIN, 14f));
        unselectAllButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        unselectAllButton.setForeground(Color.WHITE);
        unselectAllButton.setBorder(BorderFactory.createRaisedBevelBorder());
        unselectAllButton.setFocusPainted(false);

        selectAllButton.addActionListener(e -> selectAllItems());
        unselectAllButton.addActionListener(e -> unselectAllItems());

        panel.add(selectAllButton);
        panel.add(unselectAllButton);

        return panel;
    }

    private void selectAllItems() {
        Set<Integer> newState = allItemIdsSupplier.get();
        Set<Integer> selectedItems = selectedItemsGetter.get();
        if(!selectedItems.equals(newState)) {
            selectedItems.addAll(allItemIdsSupplier.get());
            onItemSelectionChanged.accept(new HashSet<>(selectedItems));
        }
        virtualScrollPanel.refreshItems();
    }

    private void unselectAllItems() {
        Set<Integer> selectedItems = selectedItemsGetter.get();
        if(!selectedItems.isEmpty()) {
            selectedItems.clear();
            onItemSelectionChanged.accept(new HashSet<>(selectedItems));
        }
        virtualScrollPanel.refreshItems();
    }

    private void updateDropdown(String searchText) {
        currentSearchResults = searchFunc.apply(searchText, selectedItemsGetter.get());

        SwingUtilities.invokeLater(() -> {
            log.debug("there are {} search results", currentSearchResults.size());

            // Update virtual scroll panel with new results
            virtualScrollPanel.setItems(currentSearchResults);

            // Calculate dimensions
            Point location = getLocationOnScreen();
            int actionButtonsHeight = actionButtonsPanel.getPreferredSize().height;
            int scrollBarHeight = scrollPane.getHorizontalScrollBar().getPreferredSize().height;
            int contentHeight = Math.min(currentSearchResults.size() * ITEM_HEIGHT, ITEM_HEIGHT * VISIBLE_ITEMS);

            int totalHeight = contentHeight + actionButtonsHeight + scrollBarHeight + 12; // 12 for border and padding

            // Update window
            dropdownWindow.setLocation(location.x, location.y + getHeight());
            dropdownWindow.setSize(getWidth(), totalHeight);
            dropdownWindow.setVisible(true);
        });
    }

    private void setupListeners() {
        displayField.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                log.debug("clicked");
                if (displayField.getText().equals(placeholderText)) {
                    displayField.setText("");
                }
                updateDropdown(displayField.getText());
            }
        });

        displayField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                log.debug("focus gained {}",e.getCause());
                if (displayField.getText().equals(placeholderText)) {
                    displayField.setText("");
                }

//                FocusEvent.Cause c = e.getCause();
//                if(FocusEvent.Cause.MOUSE_EVENT.equals(c)) {
//                    if (displayField.getText().equals(placeholderText)) {
//                        displayField.setText("");
//                        updateDropdown(displayField.getText());
//                    }
//                }
            }

            @Override
            public void focusLost(FocusEvent e) {
                log.debug("focus lost to {} setting text to {}", e.getOppositeComponent(), placeholderText);
                displayField.setText(placeholderText);
                displayField.setForeground(Color.GRAY);
                dropdownWindow.setVisible(false);
            }
        });

        displayField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    updateDropdown(displayField.getText());
                    e.consume();
                } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
                    // Allow escape key to close dropdown and remove focus
                    dropdownWindow.setVisible(false);
                    displayField.transferFocus();
                    e.consume();
                }
            }
        });

        dropdownWindow.addHierarchyListener(new HierarchyListener() {
            @Override
            public void hierarchyChanged(HierarchyEvent e) {
                log.debug("hierarchy changed {} {} {}", dropdownWindow.isVisible(), dropdownWindow.isShowing(), e);
                if(!displayField.hasFocus()) {
                    dropdownWindow.setVisible(false);
                }
            }
        });
    }

    /**
     * Virtual scrolling panel that only renders visible items
     */
    private class VirtualScrollPanel extends JPanel implements Scrollable {
        private List<ItemIdName> items = new ArrayList<>();
        private final Map<Integer, JPanel> panelCache = new HashMap<>();
        private int firstVisibleIndex = 0;
        private int lastVisibleIndex = 0;

        public VirtualScrollPanel() {
            setLayout(null); // Use absolute positioning
            setBackground(ColorScheme.DARK_GRAY_COLOR);

            // Add viewport change listener to handle scrolling
            addComponentListener(new ComponentAdapter() {
                @Override
                public void componentResized(ComponentEvent e) {
                    updateVisibleItems();
                }
            });
        }

        public void setItems(List<ItemIdName> items) {
            this.items = items;
            panelCache.clear(); // Clear cache when items change

            // Set preferred size based on total items
            setPreferredSize(new Dimension(getWidth(), items.size() * ITEM_HEIGHT));

            updateVisibleItems();
            revalidate();
            repaint();
        }

        public void refreshItems() {
            panelCache.clear(); // Clear cache to force recreation of panels with updated icons
            updateVisibleItems();
        }

        private void updateVisibleItems() {
            if (items.isEmpty()) {
                removeAll();
                return;
            }

            Rectangle viewRect = scrollPane.getViewport().getViewRect();
            firstVisibleIndex = Math.max(0, viewRect.y / ITEM_HEIGHT);
            lastVisibleIndex = Math.min(items.size() - 1,
                    (viewRect.y + viewRect.height) / ITEM_HEIGHT + 1);

            // Remove all components and add only visible ones
            removeAll();

            for (int i = firstVisibleIndex; i <= lastVisibleIndex; i++) {
                JPanel itemPanel = getOrCreateItemPanel(i);
                itemPanel.setBounds(0, i * ITEM_HEIGHT, getWidth(), ITEM_HEIGHT);
                add(itemPanel);
            }

            revalidate();
            repaint();
        }

        private JPanel getOrCreateItemPanel(int index) {
            if (index < 0 || index >= items.size()) {
                return new JPanel();
            }

            // Check cache first
            if (panelCache.containsKey(index)) {
                return panelCache.get(index);
            }

            // Create new panel
            ItemIdName item = items.get(index);
            JPanel panel = createItemPanel(item);

            // Cache the panel
            panelCache.put(index, panel);

            return panel;
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);

            // Update visible items when painting
            updateVisibleItems();
        }

        // Scrollable interface methods
        @Override
        public Dimension getPreferredScrollableViewportSize() {
            return new Dimension(getWidth(), ITEM_HEIGHT * VISIBLE_ITEMS);
        }

        @Override
        public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
            return ITEM_HEIGHT;
        }

        @Override
        public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
            return ITEM_HEIGHT * VISIBLE_ITEMS;
        }

        @Override
        public boolean getScrollableTracksViewportWidth() {
            return true;
        }

        @Override
        public boolean getScrollableTracksViewportHeight() {
            return false;
        }
    }

    private JPanel createItemPanel(ItemIdName item) {
        Set<Integer> selectedItems = selectedItemsGetter.get();
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(BorderFactory.createEmptyBorder(1, 2, 1, 2));
        panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, ITEM_HEIGHT));
        panel.setPreferredSize(new Dimension(panel.getPreferredSize().width, ITEM_HEIGHT));
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        panel.setOpaque(true);

        JLabel nameLabel = new JLabel(item.name);
        panel.add(nameLabel, BorderLayout.CENTER);

        JCheckBox checkBox = new JCheckBox();
        checkBox.setSelected(selectedItems.contains(item.itemId));
        checkBox.setBackground(ColorScheme.DARK_GRAY_COLOR);
        checkBox.setPreferredSize(new Dimension(20, 16));

        // Scale down the checkbox icon
        checkBox.setFont(checkBox.getFont().deriveFont(10f));
        checkBox.setMargin(new Insets(0, 0, 0, 0));

        Runnable onClick = () -> {
            if (selectedItems.contains(item.itemId)) {
                selectedItems.remove(item.itemId);
                checkBox.setSelected(false);
            } else {
                selectedItems.add(item.itemId);
                checkBox.setSelected(true);
            }
            onItemSelectionChanged.accept(new HashSet<>(selectedItems));
            panel.revalidate();
            panel.repaint();
        };

        checkBox.addActionListener(e -> onClick.run());

        panel.add(checkBox, BorderLayout.EAST);

        // Add hover effect - clicking anywhere on panel toggles checkbox
        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent ee) {
                onClick.run();
            }
        });

        return panel;
    }
}
package com.flippingcopilot.ui.graph;


import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.PriceAxis;
import com.flippingcopilot.ui.graph.model.TimeAxis;

import java.time.Instant;
import java.time.ZoneId;
import java.time.ZoneOffset;

public class AxisCalculator {

    public static TimeAxis calculateTimeAxis(PlotArea pa, int localTimeOffsetSeconds) {

        int timeMin = pa.bounds.xMin;
        int timeMax = pa.bounds.xMax;

        int days = pa.bounds.xDelta() / Constants.DAY_SECONDS;
        int daysStep = Math.max(1, days / 7);

        int maxDay = ((timeMax + localTimeOffsetSeconds) / Constants.DAY_SECONDS) * Constants.DAY_SECONDS - localTimeOffsetSeconds;
        int minDay = ((timeMin + localTimeOffsetSeconds) / Constants.DAY_SECONDS) * Constants.DAY_SECONDS - localTimeOffsetSeconds;
        int[] dayTicks = new int[]{};
        while (maxDay > timeMin) {
            dayTicks = append(dayTicks, maxDay);
            maxDay -= daysStep * Constants.DAY_SECONDS;
        }

        int[] timeTicks = new int[]{};
        if (daysStep == 1) {
            if (dayTicks.length < 5) {
                // add 06:00, 12:00, 18:00
                for (int d : preAppend(dayTicks, minDay)) {
                    int tick06 = d + 6 * 60 * 60;     // 06:00
                    int tick12 = d + 12 * 60 * 60;    // 12:00
                    int tick18 = d + 18 * 60 * 60;    // 18:00

                    if (tick06 < timeMax && tick06 > timeMin) {
                        timeTicks = append(timeTicks, tick06);
                    }
                    if (tick12 < timeMax && tick12 > timeMin) {
                        timeTicks = append(timeTicks, tick12);
                    }
                    if (tick18 < timeMax && tick18 > timeMin) {
                        timeTicks = append(timeTicks, tick18);
                    }
                }
            } else if (dayTicks.length < 10){
                // add only 12:00
                for (int d : preAppend(dayTicks, dayTicks[0] - Constants.DAY_SECONDS)) {
                    int tick12 = d + 12 * 60 * 60;    // 12:00
                    if (tick12 > timeMin && tick12 < timeMax) {
                        timeTicks = append(timeTicks, tick12);
                    }
                }
            }
        }

        return new TimeAxis(
                dayTicks,
                timeTicks,
                new int[]{}
        );
    }

    public static PriceAxis calculatePriceAxis(PlotArea pa) {
        int maxAllowableTicks = 18;
        int maxAllowableGridLines = 28;

        int priceRange = (int) pa.bounds.yDelta();
        int priceMin = (int) pa.bounds.yMin;
        int priceMax = (int) pa.bounds.yMax;

        int magnitude = (int) Math.floor(Math.log10(priceRange));
        int[] possibleSteps = {1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500};

        int stepSize = 0;
        int numTicks = Integer.MAX_VALUE;

        for (int baseStep : possibleSteps) {
            int candidateStep = baseStep * (int) Math.pow(10, magnitude - 1);
            candidateStep = Math.max(1, candidateStep);

            int candidateTicks = priceRange / candidateStep + 1;

            if (candidateTicks <= maxAllowableTicks && candidateStep > 0) {
                stepSize = candidateStep;
                numTicks = candidateTicks;
                break;
            }
        }

        if (stepSize == 0) {
            stepSize = 500 * (int) Math.pow(10, magnitude - 1);
            numTicks = priceRange / stepSize + 1;
        }

        int startTick = (priceMin / stepSize) * stepSize;
        if (startTick < priceMin) {
            startTick += stepSize;
        }

        int[] tickPrices = new int[numTicks];
        int tickIndex = 0;

        for (int price = startTick; price <= priceMax && tickIndex < numTicks; price += stepSize) {
            tickPrices[tickIndex++] = price;
        }

        if (tickIndex < numTicks) {
            int[] resizedTicks = new int[tickIndex];
            System.arraycopy(tickPrices, 0, resizedTicks, 0, tickIndex);
            tickPrices = resizedTicks;
        }

        int[] gridOnlyPrices = new int[0];

        if (tickPrices.length > 1) {
            int gridStep = stepSize / 2;
            if (gridStep > 0 && (tickPrices.length * 2 - 1) <= maxAllowableGridLines) {
                gridOnlyPrices = new int[tickPrices.length - 1];

                for (int i = 0; i < tickPrices.length - 1; i++) {
                    gridOnlyPrices[i] = tickPrices[i] + gridStep;
                }
            }
        }

        return new PriceAxis(tickPrices, gridOnlyPrices);
    }


    public static int[] append(int[] arr, int v) {
        int[] result = new int[arr.length + 1];
        System.arraycopy(arr, 0, result, 0, arr.length);
        result[arr.length] = v;
        return result;
    }

    public static int[] preAppend(int[] arr, int v) {
        int[] result = new int[arr.length + 1];
        result[0] = v;
        System.arraycopy(arr, 0, result, 1, arr.length);
        return result;
    }

    public static int getLocalTimeOffsetSeconds() {
        ZoneOffset offset = ZoneId.systemDefault().getRules().getOffset(Instant.now());
        return offset.getTotalSeconds();
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.Bounds;
import com.flippingcopilot.ui.graph.model.Config;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.awt.geom.RoundRectangle2D;

@Slf4j
@Getter
public class ZoomHandler {

    private static final int MIN_TIME_DELTA = 60*60;
    private static final int MIN_PRICE_DELTA = 5;
    @Setter
    private Point selectionStart = null;
    @Setter
    private Point selectionEnd = null;
    private boolean isSelecting = false;

    private final Rectangle homeButtonRect = new Rectangle();
    private final Rectangle maxButtonRect = new Rectangle();
    private final Rectangle zoomInButtonRect = new Rectangle();
    private final Rectangle zoomOutButtonRect = new Rectangle();
    private final Rectangle weekButtonRect = new Rectangle();
    private final Rectangle monthButtonRect = new Rectangle();

    public Bounds maxViewBounds;
    public Bounds homeViewBounds;
    public Bounds weekViewBounds;
    public Bounds monthViewBounds;

    public void startSelection(Point point) {
        selectionStart = new Point(point);
        selectionEnd = null;
        isSelecting = true;
    }

    public void applySelection(PlotArea pa) {
        if (selectionStart == null || selectionEnd == null) return;

        int selectionX1 = Math.max(Math.min(selectionStart.x, selectionEnd.x), 0);
        int selectionX2 = Math.min(Math.max(selectionStart.x, selectionEnd.x), pa.w);

        int selectionY1 = Math.max(Math.min(selectionStart.y, selectionEnd.y), 0);
        int selectionY2 = Math.min(Math.max(selectionStart.y, selectionEnd.y), pa.h);

        int newTimeMin = pa.bounds.xMin + (int)(((long)pa.bounds.xDelta() * (long)(selectionX1)) / pa.w);
        int newTimeMax = pa.bounds.xMin + (int)(((long)pa.bounds.xDelta() * (long)(selectionX2)) / pa.w);

        int newPriceMax = (int) (pa.bounds.yMax - ((pa.bounds.yDelta() * (long)(selectionY1)) / pa.h));
        int newPriceMin = (int) (pa.bounds.yMax - ((pa.bounds.yDelta() * (long)(selectionY2)) / pa.h));

        if (newTimeMax - newTimeMin < MIN_TIME_DELTA) {
            log.debug("zoomed time delta {}s too small", newTimeMax - newTimeMin);
            cancelSelection();
            return;
        }

        if (newPriceMax - newPriceMin < MIN_PRICE_DELTA) {
            log.debug("zoomed price delta {}s too small", newPriceMax - newPriceMin);
            cancelSelection();
            return;
        }

        pa.bounds = new Bounds(newTimeMin, newTimeMax, newPriceMin, newPriceMax);

        cancelSelection();
    }

    public void applyZoomIn(PlotArea pa) {
        pa.bounds.xMin = Math.min(pa.bounds.xMax - MIN_TIME_DELTA, pa.bounds.xMin + (int) (pa.bounds.xDelta()*0.2));

    }

    public void applyZoomOut(PlotArea pa) {
        int td = pa.bounds.xDelta();
        pa.bounds.xMin= Math.max(maxViewBounds.xMin, pa.bounds.xMin- (int) (td*0.2));
        pa.bounds.xMax = Math.min(maxViewBounds.xMax, pa.bounds.xMax + (int) (td*0.2));
        int pd = (int) pa.bounds.yDelta();
        pa.bounds.yMin = Math.max(maxViewBounds.yMin, pa.bounds.yMin - (int) (pd*0.1));
        pa.bounds.yMax = Math.min(maxViewBounds.yMax, pa.bounds.yMax + (int) (pd*0.1));
    }

    public void applyHomeView(PlotArea pa) {
        pa.bounds = homeViewBounds.copy();
    }

    public void applyMaxView(PlotArea pa) {
        pa.bounds = maxViewBounds.copy();
    }

    public void applyWeekView(PlotArea pa) {
        pa.bounds = weekViewBounds.copy();
    }

    public void applyMonthView(PlotArea pa) {
        pa.bounds = monthViewBounds.copy();
    }

    public void cancelSelection() {
        selectionStart = null;
        selectionEnd = null;
        isSelecting = false;
    }

    public void drawSelectionRectangle(Graphics2D plotAreaG2) {
        if (!isSelecting || selectionStart == null || selectionEnd == null) return;

        int x = Math.min(selectionStart.x, selectionEnd.x);
        int y = Math.min(selectionStart.y, selectionEnd.y);
        int width = Math.abs(selectionEnd.x - selectionStart.x);
        int height = Math.abs(selectionEnd.y - selectionStart.y);

        plotAreaG2.setColor(Config.SELECTION_COLOR);
        plotAreaG2.fillRect(x, y, width, height);

        plotAreaG2.setColor(Config.SELECTION_BORDER_COLOR);
        plotAreaG2.setStroke(Config.SELECTION_STROKE);
        plotAreaG2.drawRect(x, y, width, height);
    }

    public void drawButtons(Graphics2D plotAreaG2, PlotArea pa, Point p) {

        int x = pa.w - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        int y = Config.GRAPH_BUTTON_MARGIN;

        // Width for text buttons (Week and Month)
        int textButtonWidth = Config.GRAPH_BUTTON_SIZE * 2;

        // Draw home button
        homeButtonRect.setBounds(x, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverHomeButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape homeButtonShape = new RoundRectangle2D.Float(
                x, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(homeButtonShape);
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setStroke(new java.awt.BasicStroke(1.5f));

        int margin = 4;
        int houseX = x + margin;
        int houseY = y + margin;
        int houseWidth = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int houseHeight = Config.GRAPH_BUTTON_SIZE - 2 * margin;

        // Roof
        int[] xPoints = {houseX, houseX + houseWidth / 2, houseX + houseWidth};
        int[] yPoints = {houseY + houseHeight / 2, houseY, houseY + houseHeight / 2};
        plotAreaG2.fillPolygon(xPoints, yPoints, 3);

        // House body
        plotAreaG2.fillRect(houseX + houseWidth / 5, houseY + houseHeight / 2,
                3 * houseWidth / 5, houseHeight / 2);

        // Draw max button
        int maxButtonX = x - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        maxButtonRect.setBounds(maxButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverMaxButton(p)  ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape maxButtonShape = new RoundRectangle2D.Float(
                maxButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(maxButtonShape);

        // Draw max icon (four outward arrows)
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setStroke(new java.awt.BasicStroke(1.5f));

        int maxMargin = 7;
        int centerX = maxButtonX + Config.GRAPH_BUTTON_SIZE / 2;
        int centerY = y + Config.GRAPH_BUTTON_SIZE / 2;
        int arrowSize = Config.GRAPH_BUTTON_SIZE / 2 - maxMargin;

        // Draw a simple expand icon (four outward arrows)
        // Top-left arrow
        plotAreaG2.drawLine(centerX - 2, centerY - 2, centerX - arrowSize, centerY - arrowSize);
        plotAreaG2.drawLine(centerX - arrowSize, centerY - 2, centerX - arrowSize, centerY - arrowSize);
        plotAreaG2.drawLine(centerX - 2, centerY - arrowSize, centerX - arrowSize, centerY - arrowSize);

        // Top-right arrow
        plotAreaG2.drawLine(centerX + 2, centerY - 2, centerX + arrowSize, centerY - arrowSize);
        plotAreaG2.drawLine(centerX + arrowSize, centerY - 2, centerX + arrowSize, centerY - arrowSize);
        plotAreaG2.drawLine(centerX + 2, centerY - arrowSize, centerX + arrowSize, centerY - arrowSize);

        // Bottom-left arrow
        plotAreaG2.drawLine(centerX - 2, centerY + 2, centerX - arrowSize, centerY + arrowSize);
        plotAreaG2.drawLine(centerX - arrowSize, centerY + 2, centerX - arrowSize, centerY + arrowSize);
        plotAreaG2.drawLine(centerX - 2, centerY + arrowSize, centerX - arrowSize, centerY + arrowSize);

        // Bottom-right arrow
        plotAreaG2.drawLine(centerX + 2, centerY + 2, centerX + arrowSize, centerY + arrowSize);
        plotAreaG2.drawLine(centerX + arrowSize, centerY + 2, centerX + arrowSize, centerY + arrowSize);
        plotAreaG2.drawLine(centerX + 2, centerY + arrowSize, centerX + arrowSize, centerY + arrowSize);

        // Draw zoom in (+) button
        int zoomInButtonX = maxButtonX - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        zoomInButtonRect.setBounds(zoomInButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverZoomInButton(p)  ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape zoomInButtonShape = new RoundRectangle2D.Float(
                zoomInButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(zoomInButtonShape);

        // Draw + symbol
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setStroke(new java.awt.BasicStroke(2.0f));

        int plusSize = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int plusX = zoomInButtonX + margin;
        int plusY = y + margin;

        // Horizontal line
        plotAreaG2.drawLine(
                plusX + plusSize / 4,
                plusY + plusSize / 2,
                plusX + 3 * plusSize / 4,
                plusY + plusSize / 2
        );

        // Vertical line
        plotAreaG2.drawLine(
                plusX + plusSize / 2,
                plusY + plusSize / 4,
                plusX + plusSize / 2,
                plusY + 3 * plusSize / 4
        );

        // Draw zoom out (-) button
        int zoomOutButtonX = zoomInButtonX - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        zoomOutButtonRect.setBounds(zoomOutButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverZoomOutButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape zoomOutButtonShape = new RoundRectangle2D.Float(
                zoomOutButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(zoomOutButtonShape);

        // Draw - symbol
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setStroke(new java.awt.BasicStroke(2.0f));

        int minusSize = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int minusX = zoomOutButtonX + margin;
        int minusY = y + margin;

        // Horizontal line (minus symbol)
        plotAreaG2.drawLine(
                minusX + minusSize / 4,
                minusY + minusSize / 2,
                minusX + 3 * minusSize / 4,
                minusY + minusSize / 2
        );

        // Draw Week button (wider than the others)
        int weekButtonX = zoomOutButtonX - textButtonWidth - Config.GRAPH_BUTTON_MARGIN;
        weekButtonRect.setBounds(weekButtonX, y, textButtonWidth, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverWeekButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape weekButtonShape = new RoundRectangle2D.Float(
                weekButtonX, y,
                textButtonWidth, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(weekButtonShape);

        // Draw Week text
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setFont(new Font("SansSerif", Font.PLAIN, 12));
        FontMetrics fm = plotAreaG2.getFontMetrics();
        String weekText = "Week";
        int textWidth = fm.stringWidth(weekText);
        int textHeight = fm.getHeight();
        plotAreaG2.drawString(weekText,
                weekButtonX + (textButtonWidth - textWidth) / 2,
                y + (Config.GRAPH_BUTTON_SIZE + textHeight) / 2 - 2);

        // Draw Month button (wider than the others)
        int monthButtonX = weekButtonX - textButtonWidth - Config.GRAPH_BUTTON_MARGIN;
        monthButtonRect.setBounds(monthButtonX, y, textButtonWidth, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverMonthButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape monthButtonShape = new RoundRectangle2D.Float(
                monthButtonX, y,
                textButtonWidth, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(monthButtonShape);

        // Draw Month text
        plotAreaG2.setColor(java.awt.Color.WHITE);
        // Use the same font as for the Week button - plain instead of bold
        String monthText = "Month";
        textWidth = fm.stringWidth(monthText);
        plotAreaG2.drawString(monthText,
                monthButtonX + (textButtonWidth - textWidth) / 2,
                y + (Config.GRAPH_BUTTON_SIZE + textHeight) / 2 - 2);
    }

    public boolean isOverHomeButton(Point point) {
        return homeButtonRect.contains(point);
    }

    public boolean isOverMaxButton(Point point) {
        return maxButtonRect.contains(point);
    }

    public boolean isOverZoomInButton(Point point) {
        return zoomInButtonRect.contains(point);
    }

    public boolean isOverZoomOutButton(Point point) {
        return zoomOutButtonRect.contains(point);
    }

    public boolean isOverWeekButton(Point point) {
        return weekButtonRect.contains(point);
    }

    public boolean isOverMonthButton(Point point) {
        return monthButtonRect.contains(point);
    }
}
package com.flippingcopilot.ui.graph;
import com.flippingcopilot.ui.graph.model.Bounds;
import lombok.NoArgsConstructor;

import java.awt.*;

@NoArgsConstructor
public class PlotArea {

    // this is the padding between the plot area and the edge of the panel
    public final int leftPadding = 80;
    public final int topPadding = 100;
    public final int rightPadding = 20;
    public final int bottomPadding = 50;

    public int w;
    public int h;

    public Bounds bounds;

    public int timeDeltaToXDelta(int d) {
        return  (int)((long)w * (long)d / (long) bounds.xDelta());
    }
    public int priceDeltaToYDelta(int d) {
        return  (int)((long)h * (long)d / (long) bounds.yDelta());
    }

    public int timeToX(int t) {
        return  (int)(((long)w * (long)(t - bounds.xMin)) / bounds.xDelta());
    }

    public int priceToY(int p) {
        return (int)(((long)h * (long)(bounds.yMax - p)) / bounds.yDelta());
    }

    public Point relativePoint(Point p) {
        return new Point( p.x - leftPadding, p.y - topPadding);
    }

    public boolean pointInPlotArea(Point p) {
        return p.x <= w && p.y <= h;
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.Constants;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.border.MatteBorder;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.text.NumberFormat;
import java.util.Date;

@Slf4j
public class StatsPanel extends JPanel {
    private final DataManager dataManager;
    private final JTable statsTable;

    public StatsPanel(DataManager dataManager, PriceGraphConfigManager configManager, FlippingCopilotConfig copilotConfig) {
        this.dataManager = dataManager;
        this.setLayout(new BorderLayout());

        // Create table model with two columns and no row editing
        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        model.addColumn("Statistic");
        model.addColumn("Value");

        statsTable = new JTable(model);
        statsTable.setFillsViewportHeight(true);
        statsTable.setRowHeight(24);
        statsTable.getTableHeader().setReorderingAllowed(false);
        statsTable.getTableHeader().setResizingAllowed(true);
        statsTable.setBackground(configManager.getConfig().backgroundColor);

        statsTable.setShowGrid(false);
        statsTable.setIntercellSpacing(new Dimension(0, 0));

        statsTable.getColumnModel().getColumn(0).setPreferredWidth(150);
        statsTable.getColumnModel().getColumn(1).setPreferredWidth(120);

        statsTable.setTableHeader(null);

        // Set custom cell renderer for value column to color the change percentages
        statsTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                // Apply color to the price change rows (24h change and week change)
                if (row == 5 || row == 6) { // Index of 24h change and week change rows
                    String valueStr = value.toString();
                    // Check if the percentage is negative (contains '-' character)
                    if (valueStr.contains("-")) {
                        c.setForeground(copilotConfig.lossAmountColor());
                    } else if (!valueStr.equals("0%")) {
                        c.setForeground(copilotConfig.profitAmountColor());
                    } else {
                        c.setForeground(table.getForeground());
                    }
                } else {
                    c.setForeground(table.getForeground());
                }

                return c;
            }
        });

        statsTable.setBorder(new MatteBorder(1, 0, 0, 0, Color.GRAY));
        JScrollPane scrollPane = new JScrollPane(statsTable);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());

        scrollPane.setColumnHeaderView(null);

        this.add(scrollPane, BorderLayout.CENTER);

        populateTable();
        this.setPreferredSize(new Dimension(280, 400));
    }

    /**
     * Populates the stats table with data
     */
    private void populateTable() {
        DefaultTableModel model = (DefaultTableModel) statsTable.getModel();

        // Daily volume
        model.addRow(new Object[]{"Daily Volume", formatNumber((long) dataManager.data.dailyVolume)});

        // Last Instabuy (show even if zero)
        model.addRow(new Object[]{"Last low time", dataManager.lastLowTime > 0 ? Constants.SECOND_DATE_FORMAT.format(new Date(dataManager.lastLowTime* 1000L)) : "n/a"});
        model.addRow(new Object[]{"Last low price", dataManager.lastLowPrice > 0 ? formatNumber(dataManager.lastLowPrice) : "n/a"});

        // Last Instasell (show even if zero)
        model.addRow(new Object[]{"Last high time", dataManager.lastHighTime > 0 ? Constants.SECOND_DATE_FORMAT.format(new Date(dataManager.lastHighTime * 1000L)) : "n/a"});
        model.addRow(new Object[]{"Last high price", dataManager.lastHighPrice > 0 ? formatNumber(dataManager.lastHighPrice) : "n/a"});

        // Price changes
        model.addRow(new Object[]{"24h change", formatPercentage((float) dataManager.priceChange24H)});
        model.addRow(new Object[]{"Week change", formatPercentage((float) dataManager.priceChangeWeek)});
//
//        // Copilot price and margin
//        model.addRow(new Object[]{"Copilot buy price", formatNumber(dataManager.data.buyPrice)});
//        model.addRow(new Object[]{"Copilot sell price", formatNumber(dataManager.data.sellPrice)});
//
//        model.addRow(new Object[]{"Margin", formatNumber(dataManager.margin)});
//        model.addRow(new Object[]{"Tax", formatNumber(dataManager.tax)});
//        model.addRow(new Object[]{"Profit", formatNumber(dataManager.profit)});
    }


    private String formatNumber(long number) {
        return NumberFormat.getNumberInstance().format(number);
    }

    private String formatPercentage(float value) {
        NumberFormat format = NumberFormat.getPercentInstance();
        format.setMaximumFractionDigits(2);
        return format.format(value);
    }
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.*;

import java.awt.*;
import java.awt.geom.Path2D;
import java.util.List;

public class RenderV2 {

    public void drawGrid(Graphics2D plotAreaG2,Config config,  PlotArea pa, TimeAxis xAxis, PriceAxis yAxis) {
        plotAreaG2.setColor(config.gridColor);
        plotAreaG2.setStroke(Config.GRID_STROKE);
        for (int t : xAxis.dateOnlyTickTimes) {
            Stroke originalStroke = plotAreaG2.getStroke();
            int x = pa.timeToX(t);
            plotAreaG2.setStroke(new BasicStroke(1.0f));
            plotAreaG2.drawLine(x, 0, x, pa.h);
            plotAreaG2.setStroke(originalStroke);
        }
        for (int t : xAxis.timeOnlyTickTimes) {
            int x = pa.timeToX(t);
            plotAreaG2.drawLine(x, 0, x, pa.h);
        }
        for (int t : xAxis.gridOnlyTickTimes) {
            int x = pa.timeToX(t);
            plotAreaG2.drawLine(x, 0, x, pa.h);
        }
        for (int p : yAxis.tickPrices) {
            int y = pa.priceToY(p);
            plotAreaG2.drawLine(0, y, pa.w, y);
        }
        for (int p : yAxis.gridOnlyPrices) {
            int y = pa.priceToY(p);
            plotAreaG2.drawLine(0, y, pa.w, y);
        }
    }

    public void drawAxes(Graphics2D g2, Config config,  PlotArea pa, TimeAxis xAxis, PriceAxis yAxis) {
        g2.setColor(config.axisColor);
        g2.setStroke(new BasicStroke(1.0f));
        g2.drawLine(pa.leftPadding,  pa.topPadding + pa.h, pa.leftPadding + pa.w, pa.topPadding + pa.h);
        g2.drawLine(pa.leftPadding, pa.topPadding, pa.leftPadding, pa.topPadding +pa.h);
        drawXAxisLabels(g2,config, pa, xAxis);
        drawYAxisLabels(g2, config,pa, yAxis);
    }

    public void drawXAxisLabels(Graphics2D g2, Config config, PlotArea pa, TimeAxis xAxis) {
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        g2.setColor(config.textColor);
        FontMetrics metrics = g2.getFontMetrics();

        java.text.SimpleDateFormat dateFormat = new java.text.SimpleDateFormat("d MMM");
        java.text.SimpleDateFormat timeFormat = new java.text.SimpleDateFormat("HH:mm");

        // Draw date labels (longer ticks)
        for (int time : xAxis.dateOnlyTickTimes) {
            int x = pa.timeToX(time);
            g2.drawLine(pa.leftPadding + x, pa.topPadding + pa.h, pa.leftPadding + x, pa.topPadding + pa.h + Config.TICK_SIZE * 2);
            String label = dateFormat.format(new java.util.Date(time * 1000L));
            int labelWidth = metrics.stringWidth(label);
            g2.drawString(label, pa.leftPadding + x - labelWidth / 2, pa.topPadding + pa.h + Config.TICK_SIZE * 2 + 9 + metrics.getHeight());
        }

        // Draw time labels (shorter ticks)
        for (int time : xAxis.timeOnlyTickTimes) {
            int x = pa.timeToX(time);

            g2.drawLine(pa.leftPadding +x, pa.topPadding + pa.h, pa.leftPadding +x, pa.topPadding +  pa.h + Config.TICK_SIZE);

            String label = timeFormat.format(new java.util.Date(time * 1000L));
            int labelWidth = metrics.stringWidth(label);
            g2.drawString(label, pa.leftPadding + x - labelWidth / 2, pa.topPadding +  pa.h + Config.TICK_SIZE + metrics.getHeight());
        }
    }

    public void drawYAxisLabels(Graphics2D g2, Config config, PlotArea pa, PriceAxis yAxis) {
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        g2.setColor(config.textColor);
        FontMetrics metrics = g2.getFontMetrics();
        for (int price : yAxis.tickPrices) {
            int y = pa.priceToY(price);
            g2.drawLine(pa.leftPadding - Config.TICK_SIZE,pa.topPadding + y, pa.leftPadding, pa.topPadding+ y);

            // Format and draw the price label
            String label = com.flippingcopilot.ui.UIUtilities.quantityToRSDecimalStack(price, true);
            g2.drawString(label,
                    pa.leftPadding - metrics.stringWidth(label) - Config.LABEL_PADDING,
                    pa.topPadding + y + metrics.getHeight() / 3);
        }
    }


    public void drawPredictionIQR(Graphics2D plotAreaG2, Config config, PlotArea pa, int[] times, int[] lowerPrices, int[] upperPrices, boolean isLow) {
        if (times.length < 2) return;

        // Set appropriate color
        plotAreaG2.setColor(isLow ? config.lowShadeColor : config.highShadeColor);

        // Create path for shaded area with clipping
        Path2D path = new Path2D.Double();
        boolean started = false;

        // Start at the first point that's in range
        for (int i = 0; i < times.length; i++) {
            int time = times[i];
            if (time >= pa.bounds.xMin && time <=pa.bounds.xMax) {
                int x = pa.timeToX(time);
                int y = pa.priceToY(lowerPrices[i]);

                if (!started) {
                    path.moveTo(x, y);
                    started = true;
                } else {
                    path.lineTo(x, y);
                }
            }
        }

        // Draw the upper bound from right to left (for points in range)
        for (int i = times.length - 1; i >= 0; i--) {
            int time = times[i];
            if (time >= pa.bounds.xMin && time <= pa.bounds.xMax) {
                int x = pa.timeToX(time);
                int y = pa.priceToY(upperPrices[i]);
                path.lineTo(x, y);
            }
        }

        // Close the path if we drew anything
        if (started) {
            path.closePath();
            plotAreaG2.fill(path);
        }
    }

    public void drawLines(Graphics2D plotAreaG2,
                          PlotArea pa,
                          List<Datapoint> datapoints,
                          Color color,
                          Stroke stroke) {
        if (datapoints.isEmpty()) return;

        // Set the specified stroke and color
        plotAreaG2.setStroke(stroke);
        plotAreaG2.setColor(color);

        // Create a clip rectangle matching the plot area bounds
        java.awt.Shape originalClip = plotAreaG2.getClip();
        plotAreaG2.setClip(0, 0, pa.w, pa.h);

        // Create path for line segments
        java.awt.geom.Path2D.Float path = new java.awt.geom.Path2D.Float();

        // Start the path at the first point
        int x = pa.timeToX(datapoints.get(0).time);
        int y = pa.priceToY(datapoints.get(0).price);
        path.moveTo(x, y);

        for (Datapoint d : datapoints.subList(1, datapoints.size())) {
            x = pa.timeToX(d.time);
            y = pa.priceToY(d.price);
            path.lineTo(x, y);
        }

        plotAreaG2.draw(path);
        plotAreaG2.setClip(originalClip);
    }

    public void drawStartPoints(Graphics2D plotAreaG2,
                                PlotArea pa,
                                List<Datapoint> startPoints,
                                Color color,
                                int size
    ) {
        if (startPoints.isEmpty()) return;

        // Save original color
        Color originalColor = plotAreaG2.getColor();

        // Set the specified color
        plotAreaG2.setColor(color);

        // Create a clip rectangle matching the plot area bounds
        java.awt.Shape originalClip = plotAreaG2.getClip();
        plotAreaG2.setClip(0, 0, pa.w, pa.h);

        // Draw each start point as a filled oval
        for (Datapoint d : startPoints) {
            if (d.time < pa.bounds.xMin || d.time > pa.bounds.xMax) {
                continue;
            }

            // Get current point coordinates
            int x = pa.timeToX(d.time);
            int y = pa.priceToY(d.price);

            // Draw an asterisk (*) at the point
            // Save the original stroke
            Stroke originalStroke = plotAreaG2.getStroke();

            // Set stroke based on size
            float strokeWidth = Math.max(1, size / 5);
            plotAreaG2.setStroke(new BasicStroke(strokeWidth));

            // Draw the lines of the asterisk (*)
            int halfSize = size / 2;

            // Horizontal line
            plotAreaG2.drawLine(x - halfSize, y, x + halfSize, y);

            // Vertical line
            plotAreaG2.drawLine(x, y - halfSize, x, y + halfSize);

            // Diagonal line from top-left to bottom-right
            plotAreaG2.drawLine(x - halfSize, y - halfSize, x + halfSize, y + halfSize);

            // Diagonal line from top-right to bottom-left
            plotAreaG2.drawLine(x + halfSize, y - halfSize, x - halfSize, y + halfSize);

            // Restore the original stroke
            plotAreaG2.setStroke(originalStroke);
        }

        // Restore original clip and color
        plotAreaG2.setClip(originalClip);
        plotAreaG2.setColor(originalColor);
    }

    public void drawPoints(Graphics2D plotAreaG2,
                            PlotArea pa,
                            List<Datapoint> datapoints,
                            Color color,
                            int size
    ) {
        if (datapoints.isEmpty()) return;

        // Save original color
        Color originalColor = plotAreaG2.getColor();

        // Set the specified color
        plotAreaG2.setColor(color);

        // Create a clip rectangle matching the plot area bounds
        java.awt.Shape originalClip = plotAreaG2.getClip();
        plotAreaG2.setClip(0, 0, pa.w, pa.h);

        // Draw each point as a filled oval
        for (Datapoint d : datapoints) {
            if (d.time < pa.bounds.xMin || d.time > pa.bounds.xMax) {
                continue;
            }

            // Get current point coordinates
            int x = pa.timeToX(d.time);
            int y = pa.priceToY(d.price);

            // Calculate the top-left corner for the oval (centered on x,y)
            int ovalX = x - size / 2;
            int ovalY = y - size / 2;

            if (d.type == Datapoint.Type.PREDICTION || d.type == Datapoint.Type.INSTA_SELL_BUY) {
                // filled oval for latest price points
                plotAreaG2.fillOval(ovalX, ovalY, size, size);
            } else {
                // rectangle for 5m/1h averages
                int timeDelta = d.type == Datapoint.Type.FIVE_MIN_AVERAGE ? Constants.FIVE_MIN_SECONDS : Constants.HOUR_SECONDS;
                int w = pa.timeDeltaToXDelta(timeDelta);
                plotAreaG2.fillRect(x, y, w + size, size);
            }
        }

        // Restore original clip and color
        plotAreaG2.setClip(originalClip);
        plotAreaG2.setColor(originalColor);
    }

    public void drawLegend(Graphics2D g2, Config config, PlotArea pa) {
        int xMid = pa.leftPadding + pa.w / 2;
        g2.setFont(g2.getFont().deriveFont(Font.PLAIN, Config.FONT_SIZE));
        FontMetrics metrics = g2.getFontMetrics();

        // Legend item text labels - now with additional entries
        String[] labels = {"Lows (insta-sell)", "Highs (insta-buy)", "Low prediction", "High prediction"};
        String[] labels2 = {"Low IQR", "High IQR"};  // New line for IQR entries

        // Calculate legend position - now above the plot area
        int legendY = pa.topPadding / 2; // Half the padding from the top
        int lineLength = 20;
        int itemHeight = 15;
        int itemPadding = 30; // Space between text end and next item start
        int lineSpacing = 20; // Space between first and second row

        // Calculate widths for each legend item based on text length
        int[] itemWidths = new int[labels.length];
        int totalWidth = 0;

        for (int i = 0; i < labels.length; i++) {
            itemWidths[i] = lineLength + 5 + metrics.stringWidth(labels[i]);
            totalWidth += itemWidths[i];
        }

        // Add padding between items to total width
        totalWidth += itemPadding * (labels.length - 1);

        // Calculate starting X position to center the legend
        int legendStartX = xMid - totalWidth / 2;
        int currentX = legendStartX;

        // First row of legend items

        // Low prices
        g2.setColor(config.lowColor);
        g2.setStroke(Config.NORMAL_STROKE);
        if (config.connectPoints) {
            g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        }
        g2.fillOval(currentX + lineLength / 2 - 2, legendY + itemHeight/2 - 2, 5, 5);
        g2.setColor(config.textColor);
        g2.drawString(labels[0], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        currentX += itemWidths[0] + itemPadding;

        // High prices
        g2.setColor(config.highColor);
        g2.setStroke(Config.NORMAL_STROKE);
        if (config.connectPoints) {
            g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        }
        g2.fillOval(currentX + lineLength / 2 - 2, legendY + itemHeight/2 - 2, 5, 5);
        g2.setColor(config.textColor);
        g2.drawString(labels[1], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        currentX += itemWidths[1] + itemPadding;

        // Low prediction mean
        g2.setColor(config.lowColor);
        g2.setStroke(Config.DOTTED_STROKE);
        g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        g2.setColor(config.textColor);
        g2.drawString(labels[2], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        currentX += itemWidths[2] + itemPadding;

        // High prediction mean
        g2.setColor(config.highColor);
        g2.setStroke(Config.DOTTED_STROKE);
        g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        g2.setColor(config.textColor);
        g2.drawString(labels[3], currentX + lineLength + 5, legendY + itemHeight/2 + 4);

        // Second row with IQR entries
        // Calculate widths for second row items
        int[] itemWidths2 = new int[labels2.length];
        int totalWidth2 = 0;

        for (int i = 0; i < labels2.length; i++) {
            itemWidths2[i] = lineLength + 5 + metrics.stringWidth(labels2[i]);
            totalWidth2 += itemWidths2[i];
        }

        // Add padding between items to total width for second row
        totalWidth2 += itemPadding * (labels2.length - 1);

        // Calculate starting X position to center the second row
        int legendStartX2 = xMid - totalWidth2 / 2;
        int currentX2 = legendStartX2;
        int legendY2 = legendY + itemHeight + 13; // Position for second row

        // Low IQR
        g2.setColor(config.lowShadeColor);
        // Draw a small filled rectangle to represent the shaded area
        g2.fillRect(currentX2, legendY2 + itemHeight/2 - 5, lineLength, 10);
        g2.setColor(config.textColor);
        g2.drawString(labels2[0], currentX2 + lineLength + 5, legendY2 + itemHeight/2 + 4);
        currentX2 += itemWidths2[0] + itemPadding;

        // High IQR
        g2.setColor(config.highShadeColor);
        // Draw a small filled rectangle to represent the shaded area
        g2.fillRect(currentX2, legendY2 + itemHeight/2 - 5, lineLength, 10);
        g2.setColor(config.textColor);
        g2.drawString(labels2[1], currentX2 + lineLength + 5, legendY2 + itemHeight/2 + 4);
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.model.ItemPrice;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.Data;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.function.Consumer;

import static com.google.common.base.MoreObjects.firstNonNull;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PriceGraphController {

    private final JLabel itemIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png")));

    // dependencies
    private final PriceGraphConfigManager configManager;
    private final FlippingCopilotConfig copilotConfig;
    private final ApiRequestHandler apiRequestHandler;
    private final OsrsLoginManager osrsLoginManager;
    private final ItemManager itemManager;

    // state
    private GraphPanel graphPanel;
    private JDialog currentDialog = null;
    private JPanel mainPanel = null;
    private View currentView = null;
    private boolean currentIsSuggestedItem = false;

    private Point lastDialogPosition = null;
    private Dimension lastDialogSize = null;

    @Getter
    private Data suggestedItemGraphData;

    @Getter
    private Data userItemGraphData;


    private void clear() {
        currentDialog = null;
        mainPanel = null;
        currentView = null;
        graphPanel = null;
    }

    // Custom setters to handle data updates
    public void setSuggestedItemGraphData(Data data) {
        SwingUtilities.invokeLater(() -> {
            if (currentDialog != null && data.isFromWaitSuggestion()) {
                // do nothing if it was a wait suggestion
                return;
            }
            this.suggestedItemGraphData = data;
            if (currentDialog != null && currentIsSuggestedItem) {
                updateUIAfterDataChange(data);
            }
        });
    }

    public void setUserItemGraphData(Data data) {
        SwingUtilities.invokeLater(() -> {
            this.userItemGraphData = data;
            if (currentDialog != null && !currentIsSuggestedItem) {
                updateUIAfterDataChange(data);
            } else {
                log.debug("discarding price graph data for user selected item {}", data != null ? data.name : "null");
            }
        });
    }

    private void updateUIAfterDataChange(Data data) {
        if (currentDialog != null && mainPanel != null) {
            if (data != null && data.getLoadingErrorMessage() != null && !data.getLoadingErrorMessage().isEmpty()) {
                showErrorView(data.getLoadingErrorMessage());
            } else if (data != null) {
                showGraphView(data.name, data);
            }
        } else {
            log.debug("dialog or main panel null");
        }
    }

    public void loadAndAndShowPriceGraph(int itemId) {
        Consumer<ItemPrice> consumer = (ItemPrice i) -> {
            Data d = firstNonNull(i.getGraphData(), new Data());
            d.loadingErrorMessage = i.getMessage();
            setUserItemGraphData(d);
        };
        ItemComposition item = itemManager.getItemComposition(itemId);
        apiRequestHandler.asyncGetItemPriceWithGraphData(itemId, osrsLoginManager.getPlayerDisplayName(), consumer, true);
        showPriceGraph(item.getName(), false);
    }

    public void showPriceGraph(String itemName, boolean isSuggestedItem) {
        if(!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(() -> showPriceGraph(itemName, isSuggestedItem));
            return;
        }
        try {
            log.debug("Showing price graph panel for item: " + itemName);
            this.currentIsSuggestedItem = isSuggestedItem;

            // If there's already a dialog showing, dispose it
            if (currentDialog != null) {
                lastDialogPosition = currentDialog.getLocation();
                lastDialogSize = currentDialog.getSize();
                log.debug("Disposing existing dialog");
                currentDialog.dispose();
            }
            clear();


            // Create new dialog with decorations for moving and resizing
            JDialog dialog = new JDialog();
            dialog.setUndecorated(false); // Keep window decorations to allow resizing
            dialog.setTitle(itemName + " statistics");
            dialog.setResizable(true); // Allow resizing

            // Set minimum size to prevent making the graph too small
            dialog.setMinimumSize(new Dimension(500, 250));

            // Create main panel to contain the components
            mainPanel = new JPanel(new BorderLayout());
            mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            Data currentData = isSuggestedItem ? suggestedItemGraphData : userItemGraphData;

            if (currentData == null) {
                showLoadingView(itemName);
            } else if (currentData.getLoadingErrorMessage() != null && !currentData.getLoadingErrorMessage().isEmpty()) {
                showErrorView(currentData.getLoadingErrorMessage());
            } else {
                showGraphView(itemName, currentData);
            }

            dialog.setContentPane(mainPanel);
            if (lastDialogSize != null && lastDialogPosition != null) {
                dialog.setSize(lastDialogSize);
                dialog.setLocation(lastDialogPosition);
            } else {
                Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
                dialog.setSize(screenSize.width, screenSize.height);
                dialog.setLocation(0, 0);
            }

            // Make the dialog modal so it stays on top but doesn't block
            dialog.setModalityType(Dialog.ModalityType.MODELESS);

            dialog.addComponentListener(new ComponentAdapter() {
                @Override
                public void componentResized(ComponentEvent e) {
                    if (!View.SETTINGS.equals(currentView) && mainPanel.getComponentCount() > 0) {
                        Component comp = mainPanel.getComponent(0);
                        if (comp instanceof JSplitPane) {
                            JSplitPane splitPane = (JSplitPane) comp;
                            Component leftComp = splitPane.getLeftComponent();
                            if (leftComp instanceof GraphPanel) {
                                ((GraphPanel) leftComp).repaint();
                            }
                        }
                    }
                }
            });

            dialog.addWindowListener(new WindowAdapter() {
                @Override
                public void windowClosing(WindowEvent e) {
                    lastDialogPosition = dialog.getLocation();
                    lastDialogSize = dialog.getSize();
                    log.debug("Saved dialog position: {} and size: {}", lastDialogPosition, lastDialogSize);
                }
            });


            // Store the current dialog reference
            currentDialog = dialog;

            // Set default close operation
            dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

            // Make dialog visible
            dialog.setVisible(true);
            log.debug("Price graph panel shown successfully");
        } catch (Exception e) {
            log.error("Error showing price graph panel: {}", e.getMessage(), e);
        }
    }

    private void showLoadingView(String itemName) {
        currentView = View.LOADING;
        mainPanel.removeAll();

        // Create loading panel
        JPanel loadingPanel = new JPanel(new GridBagLayout());
        loadingPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        // Add spinner
        Spinner spinner = new Spinner();
        spinner.show();
        loadingPanel.add(spinner, gbc);

        // Add loading text
        gbc.gridy = 1;
        JLabel loadingLabel = new JLabel("Loading price data for " + itemName + "...");
        loadingLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        loadingLabel.setFont(loadingLabel.getFont().deriveFont(Font.BOLD, 14f));
        loadingPanel.add(loadingLabel, gbc);

        mainPanel.add(loadingPanel, BorderLayout.CENTER);
        mainPanel.revalidate();
        mainPanel.repaint();
    }

    private void showErrorView(String errorMessage) {
        currentView = View.ERROR;
        mainPanel.removeAll();

        // Create error panel
        JPanel errorPanel = new JPanel(new GridBagLayout());
        errorPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        // Add error icon (optional - you could add a red X icon here)
        JLabel errorIcon = new JLabel("");
        errorIcon.setForeground(Color.RED);
        errorIcon.setFont(errorIcon.getFont().deriveFont(Font.BOLD, 24f));
        errorPanel.add(errorIcon, gbc);

        // Add error message
        gbc.gridy = 1;
        JLabel errorLabel = new JLabel("<html><center>" + errorMessage + "</center></html>");
        errorLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        errorLabel.setFont(errorLabel.getFont().deriveFont(14f));
        errorLabel.setHorizontalAlignment(SwingConstants.CENTER);
        errorPanel.add(errorLabel, gbc);

        // Add close button
        gbc.gridy = 2;
        gbc.insets = new Insets(20, 10, 10, 10);
        JButton closeButton = new JButton("Close");
        closeButton.addActionListener(e -> {
            if (currentDialog != null) {
                currentDialog.dispose();
            }
        });
        closeButton.addActionListener(e -> {
            if (currentDialog != null) {
                lastDialogPosition = currentDialog.getLocation();
                lastDialogSize = currentDialog.getSize();
                log.debug("Saved dialog position and size on error close");
                currentDialog.dispose();
            }
        });
        errorPanel.add(closeButton, gbc);

        mainPanel.add(errorPanel, BorderLayout.CENTER);
        mainPanel.revalidate();
        mainPanel.repaint();
    }

    private void showGraphView(String itemName, Data data) {
        if (mainPanel == null) {
            log.error("Cannot show graph view, main panel or data is null");
            return;
        }
        if(graphPanel != null && graphPanel.itemName.equals(itemName) && View.GRAPH.equals(currentView)) {
            // if it's the same item just update the data and repaint
            DataManager dm = new DataManager(data);
            graphPanel.dataManager = dm;
            graphPanel.zoomHandler.maxViewBounds = dm.calculateBounds((p) -> true);
            graphPanel.zoomHandler.homeViewBounds = dm.calculateBounds((p) -> p.time > graphPanel.zoomHandler.maxViewBounds.xMax - 4 * Constants.DAY_SECONDS);
            graphPanel.zoomHandler.weekViewBounds = dm.calculateBounds((p) -> p.time > graphPanel.zoomHandler.maxViewBounds.xMax - 7 * Constants.DAY_SECONDS);
            graphPanel.zoomHandler.monthViewBounds = dm.calculateBounds((p) -> p.time > graphPanel.zoomHandler.maxViewBounds.xMax - 30 * Constants.DAY_SECONDS);
            graphPanel.repaint();
            return;
        }

        currentView = View.GRAPH;
        // Clear the main panel
        setItemIcon(data.itemId);
        mainPanel.removeAll();
        DataManager dm = new DataManager(data);
        graphPanel = new GraphPanel(dm, configManager);

        // Create settings button with gear icon
        JPanel statsHeaderPanel = new JPanel(new BorderLayout());
        statsHeaderPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        try {
            BufferedImage gearIcon = ImageUtil.loadImageResource(PriceGraphController.class, "/preferences-icon.png");
            gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
            BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
            JLabel settingsButton = ConfigPanel.buildButton(recoloredIcon, "Settings", () -> {
                showSettingsView(itemName, data);
            });
            statsHeaderPanel.add(settingsButton, BorderLayout.EAST);
            statsHeaderPanel.setBackground(configManager.getConfig().backgroundColor);
        } catch (Exception e) {
            log.error("Error creating settings button", e);
            // Fallback to text button if icon loading fails
            JButton settingsButton = new JButton("Settings");
            settingsButton.addActionListener(e1 -> {
                showSettingsView(itemName, data);
            });
            statsHeaderPanel.add(settingsButton, BorderLayout.EAST);
        }

        // Create the stats panel
        StatsPanel statsPanel = new StatsPanel(dm, configManager, copilotConfig);
        statsPanel.setBackground(configManager.getConfig().backgroundColor);

        // Create a panel to contain both the item icon and stats panel
        JPanel statsContentPanel = new JPanel();
        statsContentPanel.setLayout(new BoxLayout(statsContentPanel, BoxLayout.Y_AXIS));
        statsContentPanel.setBackground(configManager.getConfig().backgroundColor);
        statsContentPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 10));

        // Create an icon panel with no bottom margin
        JPanel iconPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        iconPanel.setBackground(configManager.getConfig().backgroundColor);
        iconPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 15, 0)); // Only top and left padding

        // Add icon and name
        itemIcon.setBorder(null); // Remove any border from the icon
        iconPanel.add(itemIcon);

        JLabel itemNameLabel = new JLabel(itemName);
        itemNameLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        itemNameLabel.setFont(itemNameLabel.getFont().deriveFont(Font.BOLD, 16f));
        iconPanel.add(itemNameLabel);

        // Add the icon panel to the content panel
        statsContentPanel.add(iconPanel);
        statsPanel.setBorder(null);
        statsContentPanel.add(statsPanel);

        JPanel statsContainer = new JPanel(new BorderLayout(0, 0));
        statsContainer.add(statsHeaderPanel, BorderLayout.NORTH);
        statsContainer.add(statsContentPanel, BorderLayout.CENTER);

        // Create split pane with graph on left and stats container on right
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, true);
        splitPane.setLeftComponent(graphPanel);
        splitPane.setRightComponent(statsContainer);
        splitPane.setResizeWeight(1.0); // Graph gets all extra space
        splitPane.setDividerLocation(0.75); // Initial position of divider at 75%

        graphPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        statsContainer.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));

        mainPanel.add(splitPane, BorderLayout.CENTER);

        if (currentDialog != null && itemName != null) {
            currentDialog.setTitle(itemName + " statistics");
        }

        mainPanel.revalidate();
        mainPanel.repaint();
    }

    private  void showSettingsView(String itemName, Data data) {
        if (mainPanel == null) {
            log.error("Cannot show settings view, main panel is null");
            return;
        }
        currentView = View.SETTINGS;

        mainPanel.removeAll();

        // Create the top panel for back button
        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        try {
            BufferedImage gearIcon = ImageUtil.loadImageResource(PriceGraphController.class, "/preferences-icon.png");
            gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
            BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
            JLabel backButton = ConfigPanel.buildButton(recoloredIcon, "Back to Graph", () -> {
                showGraphView(itemName, data);
            });
            topPanel.setBackground(configManager.getConfig().backgroundColor);
            topPanel.add(backButton, BorderLayout.EAST);
        } catch (Exception e) {
            log.error("Error creating back button", e);
        }

        ConfigPanel configPanel = new ConfigPanel(configManager, () -> showGraphView(itemName, data));

        mainPanel.add(topPanel, BorderLayout.NORTH);
        mainPanel.add(configPanel, BorderLayout.CENTER);

        if (currentDialog != null) {
            currentDialog.setTitle("Graph Settings");
        }

        mainPanel.revalidate();
        mainPanel.repaint();
    }


    private void setItemIcon(int itemId) {
        itemIcon.setVisible(false);
        AsyncBufferedImage image = itemManager.getImage(itemId);
        if (image != null) {
            image.addTo(itemIcon);
            itemIcon.setVisible(true);
        }
    }

    public static enum View {
        GRAPH,
        SETTINGS,
        LOADING,
        ERROR
    }
}
package com.flippingcopilot.ui.graph;


@FunctionalInterface
public interface CoordinateConverter {
    int toValue(int coordinate);
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.Config;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class ConfigPanel extends JPanel {
    private final Map<String, Component> configComponents = new HashMap<>();
    private final Runnable onApplyCallback;
    private final PriceGraphConfigManager configManager;
    private final Config configInstance;

    public ConfigPanel(PriceGraphConfigManager configManager, Runnable callback) {
        this.configManager = configManager;
        this.configInstance = configManager.getConfig();
        this.onApplyCallback = callback;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel settingsPanel = new JPanel();
        settingsPanel.setLayout(new GridBagLayout());
        settingsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1.0;
        c.anchor = GridBagConstraints.NORTH;
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(5, 5, 5, 5);

        JLabel titleLabel = new JLabel("Graph Settings");
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 16f));
        titleLabel.setBorder(new EmptyBorder(0, 0, 15, 0));
        settingsPanel.add(titleLabel, c);
        c.gridy++;

        // boolean
        addBooleanSetting(settingsPanel, c, "connectPoints", configInstance.isConnectPoints());

        // colours
        addColorSetting(settingsPanel, c, "lowColor", configInstance.getLowColor());
        addColorSetting(settingsPanel, c, "highColor", configInstance.getHighColor());
        addColorSetting(settingsPanel, c, "lowShadeColor", configInstance.getLowShadeColor());
        addColorSetting(settingsPanel, c, "highShadeColor", configInstance.getHighShadeColor());
        addColorSetting(settingsPanel, c, "backgroundColor", configInstance.getBackgroundColor());
        addColorSetting(settingsPanel, c, "plotAreaColor", configInstance.getPlotAreaColor());
        addColorSetting(settingsPanel, c, "textColor", configInstance.getTextColor());
        addColorSetting(settingsPanel, c, "axisColor", configInstance.getAxisColor());
        addColorSetting(settingsPanel, c, "gridColor", configInstance.getGridColor());

        // Add a filler component to push everything to the top
        GridBagConstraints fillerConstraints = new GridBagConstraints();
        fillerConstraints.gridx = 0;
        fillerConstraints.gridy = c.gridy;
        fillerConstraints.gridwidth = GridBagConstraints.REMAINDER;
        fillerConstraints.fill = GridBagConstraints.BOTH;
        fillerConstraints.weightx = 1.0;
        fillerConstraints.weighty = 1.0;

        JPanel fillerPanel = new JPanel();
        fillerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        settingsPanel.add(fillerPanel, fillerConstraints);

        JScrollPane scrollPane = new JScrollPane(settingsPanel);
        scrollPane.setBorder(null);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JButton applyButton = new JButton("Apply");
        applyButton.setFocusPainted(false);
        applyButton.setBackground(ColorScheme.BRAND_ORANGE);
        applyButton.setForeground(Color.WHITE);
        applyButton.addActionListener(e -> {
            applySettings();
            if (onApplyCallback != null) {
                onApplyCallback.run();
            }
        });

        buttonPanel.add(applyButton);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void addBooleanSetting(JPanel panel, GridBagConstraints c, String name, boolean value) {
        JLabel label = new JLabel(formatFieldName(name));
        label.setForeground(Color.WHITE);
        panel.add(label, c);
        c.gridx = 1;

        JCheckBox checkBox = new JCheckBox();
        checkBox.setSelected(value);
        checkBox.setToolTipText(name);
        checkBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        configComponents.put(name, checkBox);
        panel.add(checkBox, c);

        c.gridx = 0;
        c.gridy++;
    }

    private void addColorSetting(JPanel panel, GridBagConstraints c, String name, Color value) {
        JLabel label = new JLabel(formatFieldName(name));
        label.setForeground(Color.WHITE);
        panel.add(label, c);
        c.gridx = 1;

        JPanel colorPanel = new JPanel();
        colorPanel.setBackground(value);
        colorPanel.setPreferredSize(new Dimension(30, 20));
        colorPanel.setBorder(BorderFactory.createLineBorder(Color.WHITE));

        JButton colorButton = new JButton("Choose...");
        colorButton.setToolTipText(name);
        colorButton.addActionListener(e -> {
            Color newColor = JColorChooser.showDialog(this, "Choose " + formatFieldName(name), colorPanel.getBackground());
            if (newColor != null) {
                colorPanel.setBackground(newColor);
            }
        });

        JPanel wrapper = new JPanel(new FlowLayout(FlowLayout.LEFT));
        wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        wrapper.add(colorPanel);
        wrapper.add(colorButton);

        configComponents.put(name, wrapper);
        panel.add(wrapper, c);

        c.gridx = 0;
        c.gridy++;
    }

    private String formatFieldName(String name) {
        StringBuilder result = new StringBuilder();
        for (char ch : name.toCharArray()) {
            if (Character.isUpperCase(ch)) {
                result.append(' ').append(Character.toLowerCase(ch));
            } else {
                result.append(ch);
            }
        }
        return result.toString().trim();
    }

    private Color extractColor(String key) {
        JPanel wrapper = (JPanel) configComponents.get(key);
        JPanel colorPanel = (JPanel) wrapper.getComponent(0);
        return colorPanel.getBackground();
    }

    private void applySettings() {
        try {
            // boolean
            JCheckBox connectPointsBox = (JCheckBox) configComponents.get("connectPoints");
            configInstance.setConnectPoints(connectPointsBox.isSelected());

            // colours
            configInstance.setLowColor(extractColor("lowColor"));
            configInstance.setHighColor(extractColor("highColor"));
            configInstance.setLowShadeColor(extractColor("lowShadeColor"));
            configInstance.setHighShadeColor(extractColor("highShadeColor"));
            configInstance.setBackgroundColor(extractColor("backgroundColor"));
            configInstance.setPlotAreaColor(extractColor("plotAreaColor"));
            configInstance.setTextColor(extractColor("textColor"));
            configInstance.setAxisColor(extractColor("axisColor"));
            configInstance.setGridColor(extractColor("gridColor"));

            configManager.setConfig(configInstance);
            log.debug("Applied and saved graph settings");
        } catch (Exception e) {
            log.error("Error applying settings", e);
            JOptionPane.showMessageDialog(this, "Error applying settings: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    public static JLabel buildButton(Image icon, String tooltip, Runnable onClick) {
        JLabel button = new JLabel(new ImageIcon(icon));
        button.setToolTipText(tooltip);
        button.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                onClick.run();
            }

            public void mouseEntered(java.awt.event.MouseEvent evt) {
                button.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
        });
        return button;
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.Bounds;
import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.ui.graph.model.Datapoint;
import com.flippingcopilot.util.GeTax;
import lombok.Getter;

import java.awt.*;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;


@Getter
public class DataManager {

    public final List<Datapoint> highDatapoints = new ArrayList<>();
    public final List<Datapoint> lowDatapoints = new ArrayList<>();
    public final List<Datapoint> predictionLowDatapoints = new ArrayList<>();
    public final List<Datapoint> predictionHighDatapoints = new ArrayList<>();

    public final Data data;
    public double priceChange24H = 0;
    public double priceChangeWeek = 0;
    public int lastLowTime = 0;
    public int lastLowPrice = 0;
    public int lastHighTime = 0;
    public int lastHighPrice = 0;
    public long margin;
    public long tax;
    public long profit;


    public DataManager(Data data) {
        this.data = data;
        processDatapoints();
        calculateStats();
    }

    public Datapoint findClosestPoint(Point mousePos, int hoverRadius, PlotArea pa) {
        if (mousePos == null) return null;

        Datapoint closest = null;
        double minDistance = hoverRadius;

        for(List<Datapoint> datapoints : Arrays.asList(highDatapoints, lowDatapoints, predictionLowDatapoints, predictionHighDatapoints)) {
            for (Datapoint d : datapoints) {
                Point hoverPosition = d.getHoverPosition(pa);
                double distance = mousePos.distance(hoverPosition);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = d;
                }
            }
        }
        return closest;
    }


    public Bounds calculateBounds(Predicate<Datapoint> p) {
        Bounds b = new Bounds();

        b.xMin = Integer.MAX_VALUE;
        b.xMax = Integer.MIN_VALUE;
        b.yMax =  Integer.MIN_VALUE;
        b.yMin = Integer.MAX_VALUE;

        long yMean = 0;
        long n = 0;

        for(List<Datapoint> datapoints : Arrays.asList(highDatapoints, lowDatapoints, predictionLowDatapoints, predictionHighDatapoints)) {
            for (Datapoint d : datapoints) {
                if (p.test(d)) {
                    yMean = (n * yMean + (long) d.price) / (n+1);
                    n+=1;

                    b.xMin = Math.min(b.xMin, d.time);
                    b.xMax = Math.max(b.xMax, d.time);

                    // Update price bounds
                    b.yMin = Math.min(b.yMin, d.price);
                    b.yMax = Math.max(b.yMax, d.price);

                    // Check IQR bounds for prediction points
                    if (d.type == Datapoint.Type.PREDICTION) {
                        if (d.iqrLower != null) {
                            b.yMin = Math.min(b.yMin, d.iqrLower);
                        }
                        if (d.iqrUpper != null) {
                            b.yMax = Math.max(b.yMax, d.iqrUpper);
                        }
                    }
                }
            }
        }
        int pricePadding = (int) (0.03 * yMean);
        if (pricePadding < 1) pricePadding = 1;

        b.yMin = Math.max(0, b.yMin - pricePadding);
        b.yMax+= pricePadding;

        return b;
    }

    private void processDatapoints() {
        highDatapoints.clear();
        lowDatapoints.clear();
        predictionHighDatapoints.clear();
        predictionLowDatapoints.clear();
        
        // here we combine the hour / 5min / latest wiki price data points into a continuous dataset where hour points 
        // transition into the 5min points that transition into the latest points. So we get increasingly finer granularity.
        // We truncate the points correctly at the boundaries to ensure no overlap.

        for (int i = 0; i < data.lowLatestTimes.length; i++) {
            lowDatapoints.add(new Datapoint(data.lowLatestTimes[i], data.lowLatestPrices[i], true, Datapoint.Type.INSTA_SELL_BUY));
        }
        int fiveMinLowsCut;
        if (!lowDatapoints.isEmpty()) {
            fiveMinLowsCut = Constants.FIVE_MIN_SECONDS * (lowDatapoints.get(0).time / Constants.FIVE_MIN_SECONDS)  + Constants.FIVE_MIN_SECONDS;
            lowDatapoints.removeIf((i) -> i.time < fiveMinLowsCut);
        } else {
            fiveMinLowsCut = Integer.MAX_VALUE;
        }
        for (int i = data.low5mTimes.length-1; i >= 0; i--) {
            if (data.low5mTimes[i] < fiveMinLowsCut) {
                lowDatapoints.add(0, new Datapoint(data.low5mTimes[i], data.low5mPrices[i], true, Datapoint.Type.FIVE_MIN_AVERAGE));
            }
        }
        int oneHourLowsCut;
        if (!lowDatapoints.isEmpty()) {
            oneHourLowsCut = Constants.HOUR_SECONDS * (lowDatapoints.get(0).time / Constants.HOUR_SECONDS)  + Constants.HOUR_SECONDS;
            lowDatapoints.removeIf((i) -> i.time < oneHourLowsCut);
        } else {
            oneHourLowsCut = Integer.MAX_VALUE;
        }
        for (int i = data.low1hTimes.length-1; i >= 0; i--) {
            if (data.low1hTimes[i] < oneHourLowsCut) {
                lowDatapoints.add(0, new Datapoint(data.low1hTimes[i], data.low1hPrices[i], true, Datapoint.Type.HOUR_AVERAGE));
            }
        }

        for (int i = 0; i < data.highLatestTimes.length; i++) {
            highDatapoints.add(new Datapoint(data.highLatestTimes[i], data.highLatestPrices[i], false, Datapoint.Type.INSTA_SELL_BUY));
        }
        int fiveMinHighsCut;
        if (!highDatapoints.isEmpty()) {
            fiveMinHighsCut = Constants.FIVE_MIN_SECONDS * (highDatapoints.get(0).time / Constants.FIVE_MIN_SECONDS)  + Constants.FIVE_MIN_SECONDS;
            highDatapoints.removeIf((i) -> i.time < fiveMinHighsCut);
        } else {
            fiveMinHighsCut = Integer.MAX_VALUE;
        }
        for (int i = data.high5mTimes.length-1; i >= 0; i--) {
            if (data.high5mTimes[i] < fiveMinHighsCut) {
                highDatapoints.add(0, new Datapoint(data.high5mTimes[i], data.high5mPrices[i], false, Datapoint.Type.FIVE_MIN_AVERAGE));
            }
        }
        int oneHourHighsCut;
        if (!highDatapoints.isEmpty()) {
            oneHourHighsCut = Constants.HOUR_SECONDS * (highDatapoints.get(0).time / Constants.HOUR_SECONDS)  + Constants.HOUR_SECONDS;
            highDatapoints.removeIf((i) -> i.time < oneHourHighsCut);
        } else {
            oneHourHighsCut = Integer.MAX_VALUE;
        }
        for (int i = data.high1hTimes.length-1; i >= 0; i--) {
            if (data.high1hTimes[i] < oneHourHighsCut) {
                highDatapoints.add(0, new Datapoint(data.high1hTimes[i], data.high1hPrices[i], false, Datapoint.Type.HOUR_AVERAGE));
            }
        }
        
        // add the prediction data points
        for (int i = 0; i < data.predictionTimes.length; i++) {
            predictionLowDatapoints.add(new Datapoint(
                    data.predictionTimes[i],
                    data.predictionLowMeans[i],
                    data.predictionLowIQRLower[i],
                    data.predictionLowIQRUpper[i],
                    true
            ));
            predictionHighDatapoints.add(new Datapoint(
                    data.predictionTimes[i],
                    data.predictionHighMeans[i],
                    data.predictionHighIQRLower[i],
                    data.predictionHighIQRUpper[i],
                    false
            ));
        }
    }

    private void calculateStats() {
        int cut24h = (int) Instant.now().minus(Duration.ofDays(1)).getEpochSecond();
        int cutWeek = (int) Instant.now().minus(Duration.ofDays(7)).getEpochSecond();
        if (!lowDatapoints.isEmpty() && !highDatapoints.isEmpty()){
            double priceCurrent = (lowDatapoints.get(lowDatapoints.size()-1).price *0.5 + highDatapoints.get(highDatapoints.size()-1).price *0.5);
            double lowPrice24hAgo = lowDatapoints.stream().filter(i-> i.time > cut24h).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double highPrice24hAgo = highDatapoints.stream().filter(i-> i.time > cut24h).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double price24hAgo = lowPrice24hAgo*0.5 + highPrice24hAgo*0.5;
            if (price24hAgo > 0 ) {
                this.priceChange24H = (priceCurrent - price24hAgo) / price24hAgo;
            }
            double lowPriceWeekAgo = lowDatapoints.stream().filter(i-> i.time > cutWeek).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double highPriceWeekAgo = highDatapoints.stream().filter(i-> i.time > cutWeek).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double priceWeekAgo = lowPriceWeekAgo*0.5 + highPriceWeekAgo*0.5;
            if (priceWeekAgo > 0 ) {
                this.priceChangeWeek = (priceCurrent - priceWeekAgo) / priceWeekAgo;
            }
        }

        if(!highDatapoints.isEmpty()) {
            lastHighTime = highDatapoints.get(highDatapoints.size()-1).time;
            lastHighPrice = highDatapoints.get(highDatapoints.size()-1).price;
        }

        if(!lowDatapoints.isEmpty()) {
            lastLowTime = lowDatapoints.get(lowDatapoints.size()-1).time;
            lastLowPrice = lowDatapoints.get(lowDatapoints.size()-1).price;
        }

        margin = data.sellPrice - data.buyPrice;
        tax = data.sellPrice - GeTax.getPostTaxPrice(data.itemId, (int) data.sellPrice);
        profit = margin - tax;
    }

    public List<Datapoint> sellPriceDataPoint() {
        return Collections.singletonList(new Datapoint(
                (int) Instant.now().getEpochSecond(),
                (int) data.sellPrice,
                false,
                Datapoint.Type.PREDICTION
        ));
    }

    public List<Datapoint> buyPriceDataPoint() {
        return Collections.singletonList(new Datapoint(
                (int) Instant.now().getEpochSecond(),
                (int) data.buyPrice,
                true,
                Datapoint.Type.PREDICTION
        ));
    }
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class GraphPanel extends JPanel {
    public final String itemName;

    // Component references
    private final PriceGraphConfigManager configManager;
    public DataManager dataManager;
    private final RenderV2 renderer;
    public final ZoomHandler zoomHandler;
    private final DatapointTooltip tooltip;
    public final PlotArea pa;

    // For point hovering
    private Point mousePosition = new Point(0,0);
    private Datapoint hoveredPoint = null;

    public GraphPanel(DataManager dm, PriceGraphConfigManager configManager) {
        this.itemName = dm.data.name;

        // Initialize components
        this.dataManager = dm;
        this.configManager = configManager;
        this.renderer = new RenderV2();
        this.zoomHandler = new ZoomHandler();
        this.tooltip = new DatapointTooltip();

        // Set up panel
        setBackground(configManager.getConfig().backgroundColor);
        setPreferredSize(new Dimension(500, 300));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        this.pa = new PlotArea();
        zoomHandler.maxViewBounds = dataManager.calculateBounds((p) -> true);
        zoomHandler.homeViewBounds = dataManager.calculateBounds((p) -> p.time > zoomHandler.maxViewBounds.xMax - 4 * Constants.DAY_SECONDS);
        zoomHandler.weekViewBounds = dataManager.calculateBounds((p) -> p.time > zoomHandler.maxViewBounds.xMax - 7 * Constants.DAY_SECONDS);
        zoomHandler.monthViewBounds = dataManager.calculateBounds((p) -> p.time > zoomHandler.maxViewBounds.xMax - 30 * Constants.DAY_SECONDS);
        pa.bounds = zoomHandler.homeViewBounds.copy();
        setupMouseListeners();
    }


    private void setupMouseListeners() {
        MouseAdapter mouseAdapter = new MouseAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                mousePosition = e.getPoint();
                hoveredPoint = dataManager.findClosestPoint(pa.relativePoint(e.getPoint()), Config.HOVER_RADIUS, pa);
                repaint();
            }

            @Override
            public void mousePressed(MouseEvent e) {
                mousePosition = e.getPoint();
                Point plotPoint = pa.relativePoint(mousePosition);
                if (!pa.pointInPlotArea(plotPoint)) {
                    return;
                }

                if (zoomHandler.isOverHomeButton(plotPoint)) {
                    zoomHandler.applyHomeView(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverMaxButton(plotPoint)) {
                    zoomHandler.applyMaxView(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverZoomInButton(plotPoint)) {
                    zoomHandler.applyZoomIn(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverZoomOutButton(plotPoint)) {
                    zoomHandler.applyZoomOut(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverWeekButton(plotPoint)) {
                    zoomHandler.applyWeekView(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverMonthButton(plotPoint)) {
                    zoomHandler.applyMonthView(pa);
                    repaint();
                    return;
                }

                zoomHandler.startSelection(plotPoint);
                hoveredPoint = null;
                setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
                repaint();
            }

            @Override
            public void mouseDragged(MouseEvent e) {
                mousePosition = e.getPoint();
                if (zoomHandler.isSelecting()) {
                    zoomHandler.setSelectionEnd(pa.relativePoint(mousePosition));
                    repaint();
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                mousePosition = e.getPoint();
                if (zoomHandler.isSelecting()) {
                    setCursor(Cursor.getDefaultCursor());
                    zoomHandler.setSelectionEnd(pa.relativePoint(mousePosition));
                    zoomHandler.applySelection(pa);
                    repaint();
                }
            }

            @Override
            public void mouseExited(MouseEvent e) {
                mousePosition = e.getPoint();
                hoveredPoint = null;
                repaint();
            }
        };

        addMouseMotionListener(mouseAdapter);
        addMouseListener(mouseAdapter);
    }


    @Override
    protected void paintComponent(Graphics g) {

        super.paintComponent(g);
        pa.w = getWidth() - pa.leftPadding - pa.rightPadding;
        pa.h = getHeight() - pa.topPadding - pa.bottomPadding;


        Data data = dataManager.getData();
        if (data == null) return;
        Config config = configManager.getConfig();
        setBackground(config.backgroundColor);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);

        Graphics2D plotAreaG2 = (Graphics2D) g2.create(pa.leftPadding, pa.topPadding, pa.w, pa.h);

        // First draw the legend above the plot area
        renderer.drawLegend(g2, config, pa);

        // Draw the plot area background with dynamic padding
        plotAreaG2.setColor(config.plotAreaColor);
        plotAreaG2.fillRect(0,0, pa.w, pa.h);

        TimeAxis xAxis = AxisCalculator.calculateTimeAxis(pa, AxisCalculator.getLocalTimeOffsetSeconds());
        PriceAxis yAxis = AxisCalculator.calculatePriceAxis(pa);
        renderer.drawGrid(plotAreaG2, config, pa, xAxis, yAxis);
        renderer.drawAxes(g2, config, pa, xAxis, yAxis);


        int pointSize = dynamicPointSize(Config.BASE_POINT_SIZE, pa);
        renderer.drawPoints(plotAreaG2, pa, dataManager.lowDatapoints, config.lowColor, pointSize);
        renderer.drawPoints(plotAreaG2, pa, dataManager.highDatapoints, config.highColor, pointSize);
        if (config.connectPoints) {
            renderer.drawLines(plotAreaG2, pa, dataManager.lowDatapoints, config.lowColor, Config.NORMAL_STROKE);
            renderer.drawLines(plotAreaG2, pa, dataManager.highDatapoints, config.highColor, Config.NORMAL_STROKE);
        }
        renderer.drawStartPoints(plotAreaG2, pa, dataManager.buyPriceDataPoint(), Color.WHITE, pointSize);
        renderer.drawStartPoints(plotAreaG2, pa, dataManager.sellPriceDataPoint(), Color.WHITE, pointSize);

        renderer.drawLines(plotAreaG2, pa, dataManager.predictionLowDatapoints, config.lowColor, Config.DOTTED_STROKE);
        renderer.drawLines(plotAreaG2, pa, dataManager.predictionHighDatapoints, config.highColor, Config.DOTTED_STROKE);
        renderer.drawPredictionIQR(plotAreaG2, config, pa, data.predictionTimes, data.predictionLowIQRLower, data.predictionLowIQRUpper, true);
        renderer.drawPredictionIQR(plotAreaG2, config, pa, data.predictionTimes, data.predictionHighIQRLower, data.predictionHighIQRUpper, false);
        zoomHandler.drawButtons(plotAreaG2, pa, pa.relativePoint(mousePosition));
        zoomHandler.drawSelectionRectangle(plotAreaG2);

        // Draw tooltip for hovered point
        if (hoveredPoint != null) {
            tooltip.draw(plotAreaG2, config, pa, hoveredPoint);
        }
    }

    private int dynamicPointSize(int baseSize, PlotArea pa) {
        int td = pa.bounds.xMax - pa.bounds.xMin;
        if (td < Constants.DAY_SECONDS) {
            return (int) ((float) baseSize * 1.25);
        } else if (td > Constants.DAY_SECONDS * 20) {
            return (int) ((float) baseSize * 0.5);
        } else if (td > Constants.DAY_SECONDS * 6) {
            return (int) ((float) baseSize * 0.75);
        }
        return baseSize;
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;

@Getter
@Setter
@NoArgsConstructor
public class Config {
    public static int LABEL_PADDING = 20;
    public static int TICK_SIZE = 5;
    public static int BASE_POINT_SIZE = 4;

    public static int GRAPH_BUTTON_SIZE = 24;
    public static int GRAPH_BUTTON_MARGIN = 5;

    public static int HOVER_RADIUS = 8; // Distance in pixels to detect hovering

    public static final Stroke NORMAL_STROKE = new BasicStroke(1f);
    public static final Stroke DOTTED_STROKE = new BasicStroke(
            1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{5}, 0
    );
    public static final Stroke GRID_STROKE = new BasicStroke(
            0.8f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{3}, 0
    );
    public static final Stroke SELECTION_STROKE = new BasicStroke(1.5f);

    public static float FONT_SIZE = 16f;

    public static Color TOOLTIP_BACKGROUND = new Color(20, 20, 20, 220);
    public static Color TOOLTIP_BORDER = new Color(100, 100, 100);
    public static Color SELECTION_COLOR = new Color(100, 100, 240, 80); // Color for zoom selection
    public static Color SELECTION_BORDER_COLOR = new Color(70, 70, 220);
    public static Color GRAPH_BUTTON_COLOR = new Color(150, 150, 150, 200);
    public static Color GRAPH_BUTTON_HOVER_COLOR = new Color(100,100,100);

    // configurable properties
    public boolean connectPoints = false;
    public Color lowColor = new Color(0, 153, 255);
    public Color highColor = new Color(255, 102, 0);
    public Color lowShadeColor = new Color(0, 153, 255, 60);
    public Color highShadeColor = new Color(255, 102, 0, 60);

    public Color backgroundColor = ColorScheme.DARKER_GRAY_COLOR.brighter();
    public Color plotAreaColor = new Color(51, 51, 51);
    public Color textColor = new Color(225, 225, 225);
    public Color axisColor = new Color(150, 150, 150);
    public Color gridColor = new Color(85, 85, 85, 90);
}
package com.flippingcopilot.ui.graph.model;

import com.flippingcopilot.ui.graph.PlotArea;
import lombok.Getter;
import lombok.Setter;

import java.awt.Point;

@Getter
@Setter
public class Datapoint {

    public final int time;
    public final int price;
    public final Type type;
    public final boolean isLow; // true if buy/low point, false if sell/high point

    // IQR values for prediction points
    public final Integer iqrLower;
    public final Integer iqrUpper;

    public Datapoint(int time, int price, boolean isLow, Type type) {
        this.time = time;
        this.price = price;
        this.isLow = isLow;
        this.type = type;
        this.iqrLower = null;
        this.iqrUpper = null;
    }

    public Datapoint(int time, int price, int iqrLower, int iqrUpper, boolean isLow) {
        this.time = time;
        this.price = price;
        this.isLow = isLow;
        this.type = Type.PREDICTION;
        this.iqrLower = iqrLower;
        this.iqrUpper = iqrUpper;
    }

    public Point getHoverPosition(PlotArea pa) {
        int x = pa.timeToX(time);
        int y = pa.priceToY(price);
        if (type == Type.FIVE_MIN_AVERAGE) {
            x += pa.timeDeltaToXDelta(Constants.FIVE_MIN_SECONDS / 2);
        } else if (type == Type.HOUR_AVERAGE) {
            x += pa.timeDeltaToXDelta(Constants.HOUR_SECONDS / 2);
        }
        return new Point(x, y);
    }

    public enum Type {
        INSTA_SELL_BUY,
        FIVE_MIN_AVERAGE,
        HOUR_AVERAGE,
        PREDICTION,
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class PriceAxis {
    public int[] tickPrices;
    public int[] gridOnlyPrices;
}

package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

import java.time.Instant;

@AllArgsConstructor
public class Bounds {
    public int xMin;
    public int xMax;
    public long yMin;
    public long yMax;

    public Bounds() {
        xMax = (int) Instant.now().getEpochSecond();
        xMin = xMax - 24*60*60*4;
        yMax = Integer.MAX_VALUE;
        yMin = 0;
    }

    public long yDelta() {
        return yMax - yMin;
    }

    public int xDelta() {
        return xMax - xMin;
    }

    public Bounds copy() {
        return new Bounds(xMin, xMax, yMin, yMax);
    }
}

package com.flippingcopilot.ui.graph.model;

import java.text.SimpleDateFormat;

public class Constants {
    public static final int DAY_SECONDS = 86400;
    public static final int FIVE_MIN_SECONDS = 60*5;
    public static final int HOUR_SECONDS = 60*60;
    public static final SimpleDateFormat SECOND_DATE_FORMAT = new SimpleDateFormat("d MMM HH:mm:ss");
    public static final SimpleDateFormat MINUTE_DATE_FORMAT = new SimpleDateFormat("d MMM HH:mm");
}

package com.flippingcopilot.ui.graph.model;

import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import java.nio.ByteBuffer;

public class Data {

    @Getter
    public String loadingErrorMessage;

    @Getter
    public boolean fromWaitSuggestion;

    // 6 months 1h data
    @SerializedName("low_1h_times")
    public int[] low1hTimes;

    @SerializedName("low_1h_prices")
    public int[] low1hPrices;

    @SerializedName("high_1h_times")
    public int[] high1hTimes;

    @SerializedName("high_1h_prices")
    public int[] high1hPrices;

    // 1 month 5m data
    @SerializedName("low_5m_times")
    public int[] low5mTimes;

    @SerializedName("low_5m_prices")
    public int[] low5mPrices;

    @SerializedName("high_5m_times")
    public int[] high5mTimes;

    @SerializedName("high_5m_prices")
    public int[] high5mPrices;

    // several days latest data
    @SerializedName("low_latest_times")
    public int[] lowLatestTimes;

    @SerializedName("low_latest_prices")
    public int[] lowLatestPrices;

    @SerializedName("high_latest_times")
    public int[] highLatestTimes;

    @SerializedName("high_latest_prices")
    public int[] highLatestPrices;

    @SerializedName("prediction_times")
    public int[] predictionTimes;

    @SerializedName("prediction_low_means")
    public int[] predictionLowMeans;

    @SerializedName("prediction_low_iqr_upper")
    public int[] predictionLowIQRUpper;

    @SerializedName("prediction_low_iqr_lower")
    public int[] predictionLowIQRLower;

    @SerializedName("prediction_high_means")
    public int[] predictionHighMeans;

    @SerializedName("prediction_high_iqr_upper")
    public int[] predictionHighIQRUpper;

    @SerializedName("prediction_high_iqr_lower")
    public int[] predictionHighIQRLower;

    // stats
    @SerializedName("item_id")
    public int itemId;

    @SerializedName("name")
    public String name;

    @SerializedName("daily_volume")
    public double dailyVolume;

    @SerializedName("sell_price")
    public long sellPrice;
    @SerializedName("buy_price")
    public long buyPrice;


    public static Data fromMsgPack(ByteBuffer b) {
        Data d = new Data();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }
        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "l1ht":
                    d.low1hTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l1hp":
                    d.low1hPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h1ht":
                    d.high1hTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h1hp":
                    d.high1hPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l5mt":
                    d.low5mTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l5mp":
                    d.low5mPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h5mt":
                    d.high5mTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h5mp":
                    d.high5mPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "llt":
                    d.lowLatestTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "llp":
                    d.lowLatestPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "hlt":
                    d.highLatestTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "hlp":
                    d.highLatestPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "pt":
                    d.predictionTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "plm":
                    d.predictionLowMeans = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "pliu":
                    d.predictionLowIQRUpper = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "plil":
                    d.predictionLowIQRLower = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phm":
                    d.predictionHighMeans = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phiu":
                    d.predictionHighIQRUpper = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phil":
                    d.predictionHighIQRLower = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "id":
                    d.itemId =  (int) (long)MsgPackUtil.decodePrimitive(b);
                    break;
                case "n":
                    d.name = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "dv":
                    d.dailyVolume = (double) MsgPackUtil.decodePrimitive(b);
                    break;
                case "sp":
                    d.sellPrice = (long) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "bp":
                    d.buyPrice = (long) MsgPackUtil.decodePrimitive(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }

        return d;
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class TimeAxis {
    public int[] dateOnlyTickTimes;
    public int[] timeOnlyTickTimes;
    public int[] gridOnlyTickTimes;
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.UIUtilities;
import com.flippingcopilot.ui.graph.model.Config;
import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.Datapoint;
import lombok.Getter;
import net.runelite.client.util.QuantityFormatter;

import java.awt.*;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Date;
import java.util.Locale;

@Getter
public class DatapointTooltip {

    private Rectangle bounds;
    private int padding;

    public DatapointTooltip() {
        this.bounds = new Rectangle();
        this.padding = 8; // Padding inside tooltip
    }

    public void draw(Graphics2D g2, Config config, PlotArea pa, Datapoint point) {
        // Prepare tooltip text
        NumberFormat format = new DecimalFormat("#,###", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
        String priceStr = format.format(point.getPrice());

        final String typeText;
        final String timeText;
        switch (point.type) {
            case INSTA_SELL_BUY:
                typeText = point.isLow() ? "low (insta-sell)" : "high (insta-buy)";
                timeText = Constants.SECOND_DATE_FORMAT.format(new Date(point.getTime() * 1000L));
                break;
            case FIVE_MIN_AVERAGE:
                typeText = point.isLow() ? "low 5m average" : "high 5min average";
                timeText = Constants.MINUTE_DATE_FORMAT.format(new Date(point.getTime() * 1000L)) + " - " + Constants.MINUTE_DATE_FORMAT.format(new Date((point.getTime()+ Constants.FIVE_MIN_SECONDS) * 1000L));
                break;
            case HOUR_AVERAGE:
                typeText = point.isLow() ? "low 1h average" : "high 1h average";
                timeText = Constants.MINUTE_DATE_FORMAT.format(new Date(point.getTime() * 1000L)) + " - " + Constants.MINUTE_DATE_FORMAT.format(new Date((point.getTime()+ Constants.HOUR_SECONDS) * 1000L));
                break;
            case PREDICTION:
                typeText = point.isLow() ? "low prediction" : "high prediction";
                timeText = Constants.SECOND_DATE_FORMAT.format(new Date(point.getTime() * 1000L));
                break;
            default:
                throw new IllegalArgumentException("invalid point type: "+ point.type);
        }

        // Calculate tooltip dimensions
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        FontMetrics fm = g2.getFontMetrics();
        int typeTextWidth = fm.stringWidth(typeText);
        int timeTextWidth = fm.stringWidth(timeText);
        int priceStrWidth = fm.stringWidth(priceStr);
        int textWidth = Math.max(Math.max(typeTextWidth, timeTextWidth), priceStrWidth);
        int textHeight = fm.getHeight() * 3; // Three lines of text

        int tooltipWidth = textWidth + padding * 2;
        int tooltipHeight = textHeight + padding * 2;

        Point hoverPosition = point.getHoverPosition(pa);

        // Position tooltip near point but ensure it stays within panel bounds
        int tooltipX = hoverPosition.x + 15;
        int tooltipY = hoverPosition.y - tooltipHeight - 5;

        // Adjust if tooltip would go off screen
        if (tooltipX + tooltipWidth > pa.w) {
            tooltipX = hoverPosition.x - tooltipWidth - 5;
        }
        if (tooltipY < 0) {
            tooltipY = hoverPosition.y + 15;
        }

        // Update bounds for later hit testing if needed
        bounds.setBounds(tooltipX, tooltipY, tooltipWidth, tooltipHeight);

        // Draw tooltip background
        g2.setColor(Config.TOOLTIP_BACKGROUND);
        g2.fillRoundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8, 8);

        // Draw tooltip border
        g2.setColor(Config.TOOLTIP_BORDER);
        g2.drawRoundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8, 8);

        // Draw tooltip text - first line (type text)
        g2.setColor(config.textColor);
        int yPos = tooltipY + padding + fm.getAscent();
        g2.drawString(typeText, tooltipX + padding, yPos);

        // Draw tooltip text - second line (time)
        yPos += fm.getHeight();
        g2.drawString(timeText, tooltipX + padding, yPos);

        // Draw tooltip text - third line (price)
        yPos += fm.getHeight();
        g2.drawString(priceStr, tooltipX + padding, yPos);

        // Highlight the hovered point
        if (point.isLow()) {
            g2.setColor(config.lowColor);
        } else {
            g2.setColor(config.highColor);
        }

        // Draw larger point to highlight hover

        int highlightSize = 8;
        g2.fillOval(hoverPosition.x - highlightSize / 2,
                hoverPosition.y - highlightSize / 2,
                highlightSize, highlightSize);

        g2.setColor(Color.WHITE);
        g2.drawOval(hoverPosition.x - highlightSize / 2 - 1,
                hoverPosition.y - highlightSize / 2 - 1,
                highlightSize + 2, highlightSize + 2);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.FlipV2;
import net.runelite.client.ui.ColorScheme;

import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;

import static com.flippingcopilot.util.DateUtil.formatEpoch;

public class FlipPanel extends JPanel {

    public FlipPanel(FlipV2 flip, FlippingCopilotConfig config) {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel itemQuantity = new JLabel(String.format("%d x ", flip.getClosedQuantity()));
        itemQuantity.setForeground(Color.WHITE);

        JLabel itemNameLabel = new JLabel(UIUtilities.truncateString(flip.getCachedItemName(), 20));

        // Create a sub-panel for the left side
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        leftPanel.add(itemQuantity);
        leftPanel.add(itemNameLabel);

        JLabel profitLabel = new JLabel(UIUtilities.formatProfitWithoutGp(flip.getProfit()));
        profitLabel.setForeground(UIUtilities.getProfitColor(flip.getProfit(), config));

        // Add the sub-panel to the LINE_START position
        add(leftPanel, BorderLayout.LINE_START);
        add(profitLabel, BorderLayout.LINE_END);
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));

        String closeLabel = flip.getClosedQuantity() == flip.getOpenedQuantity() ? "Close time" : "Partial close time";

        String tooltipText = String.format("Opened time: %s\nAvg buy price: %s\n%s: %s\nAvg sell price: %s\nTax paid: %s\nProfit: %s",
                formatEpoch(flip.getOpenedTime()),
                UIUtilities.formatProfit(flip.getAvgBuyPrice()),
                closeLabel,
                formatEpoch(flip.getClosedTime()),
                UIUtilities.formatProfit(flip.getAvgSellPrice()),
                UIUtilities.formatProfit(flip.getTaxPaid()),
                UIUtilities.formatProfit(flip.getProfit()));
        setToolTipText(tooltipText);
    }
}
package com.flippingcopilot.ui;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class BlacklistIcons {

    public static ImageIcon createTickIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();

        g2d.setColor(new Color(40, 167, 69));
        g2d.setStroke(new BasicStroke(2));
        g2d.drawLine(3, 8, 7, 12);
        g2d.drawLine(7, 12, 13, 4);
        g2d.dispose();

        return new ImageIcon(image);
    }

    public static ImageIcon createXIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();

        g2d.setColor(new Color(220, 53, 69));
        g2d.setStroke(new BasicStroke(2));
        g2d.drawLine(4, 4, 12, 12);
        g2d.drawLine(4, 12, 12, 4);
        g2d.dispose();

        return new ImageIcon(image);
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.CopilotLoginController;
import net.runelite.client.input.KeyListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;


@Singleton
public class LoginPanel extends JPanel {
    private final static int PAGE_WIDTH = 225;

    private final CopilotLoginController copilotLoginController;

    private JPanel loginContainer;
    private JButton loginButton;
    private JTextField emailTextField;
    private JTextField passwordTextField;
    private JLabel errorMessageLabel;

    public final Spinner spinner = new Spinner();

    @Inject
    public LoginPanel(CopilotLoginController copilotLoginController) {
        this.copilotLoginController = copilotLoginController;
        this.setLayout(new BorderLayout());
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.setSize(PAGE_WIDTH, 250);

        loginContainer = new JPanel();
        loginContainer.setLayout(new BoxLayout(loginContainer, BoxLayout.PAGE_AXIS));

        this.createLogo();
        this.createSpinner();
        this.createErrorMessageLabel();
        this.createEmailInput();
        this.createPasswordInput();
        this.createLoginButton();
        this.createCreateAccountLink();

        this.add(loginContainer, BorderLayout.NORTH);
    }

    public void createLogo() {
        JPanel container = new JPanel();
        ImageIcon icon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/logo.png"));
        Image resizedLogo = icon.getImage().getScaledInstance(50, 45, Image.SCALE_SMOOTH);
        JLabel logoLabel = new JLabel(new ImageIcon(resizedLogo));
        logoLabel.setSize(50, 45);
        container.add(logoLabel, BorderLayout.CENTER);
        container.setBorder(new EmptyBorder(10, 0, 10, 0));
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createSpinner() {
        JPanel container = new JPanel();
        container.add(spinner, BorderLayout.CENTER);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void startLoading() {
        spinner.show();
        loginButton.setEnabled(false);
        errorMessageLabel.setText("");
        errorMessageLabel.setVisible(false);
    }

    public void endLoading() {
        spinner.hide();
        loginButton.setEnabled(true);
    }

    public void createErrorMessageLabel() {
        JPanel container = new JPanel();
        errorMessageLabel = new JLabel();
        errorMessageLabel.setForeground(Color.RED);
        errorMessageLabel.setHorizontalAlignment(SwingConstants.LEFT);
        errorMessageLabel.setSize(PAGE_WIDTH, 40);
        errorMessageLabel.setVisible(false);
        container.add(errorMessageLabel); // Add the error message label under the logo
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createEmailInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        emailTextField = new JTextField();
        emailTextField.setSize(PAGE_WIDTH, 40);
        emailTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                copilotLoginController.onEmailTextChanged(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        emailTextField.addActionListener(copilotLoginController::onLoginPressed);
        JLabel emailLabel = new JLabel("Email address");
        container.add(emailLabel, BorderLayout.WEST);
        container.add(emailTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createPasswordInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        passwordTextField = new JPasswordField();
        passwordTextField.setSize(PAGE_WIDTH, 40);
        passwordTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                copilotLoginController.onPasswordTextChanged(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        passwordTextField.addActionListener(copilotLoginController::onLoginPressed);
        JLabel passwordLabel = new JLabel("Password");
        container.add(passwordLabel);
        container.add(passwordTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createCreateAccountLink() {
        JPanel container = new JPanel();
        JLabel createAccountLabel = new JLabel("Don't have an account? Sign up.");
        createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        createAccountLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                LinkBrowser.browse("https://flippingcopilot.com/signup");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.BRAND_ORANGE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            }
        });
        container.add(createAccountLabel);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createLoginButton() {
        JPanel container = new JPanel();
        loginButton = new JButton("Login");
        loginButton.addActionListener(copilotLoginController::onLoginPressed);
        container.add(loginButton);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void showLoginErrorMessage(String message) {
        errorMessageLabel.setText("<html><p>" + message + "</p></html>");
        errorMessageLabel.setVisible(true);
    }

    public void refresh() {

    }
}

package com.flippingcopilot.manager;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.ui.graph.model.Config;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.file.Files;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PriceGraphConfigManager {

    public static final String JSON_FILE = "price_graph_config.json";

    private final File file = new File(Persistance.PARENT_DIRECTORY, JSON_FILE);

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    private Config cachedConfig;

    public synchronized Config getConfig() {
        if(cachedConfig != null) {
            return cachedConfig;
        }
        cachedConfig = load();
        return cachedConfig;
    }

    public synchronized void setConfig(Config config) {
        if (config == null) {
            return;
        }
        cachedConfig = config;
        saveAsync();
    }

    public void saveAsync() {
        executorService.submit(() -> {
            synchronized (file) {
                Config config = getConfig();
                try {
                    String json = gson.toJson(config);
                    Files.write(file.toPath(), json.getBytes());
                } catch (IOException e) {
                    log.warn("error saving graph config {}", e.getMessage(), e);
                }
            }
        });
    }

    public Config load() {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, Config.class);
        } catch (FileNotFoundException ignored) {
            return new Config();
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading saved graph config json file {}", file, e);
            return new Config();
        }
    }
}

package com.flippingcopilot.manager;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.model.LoginResponse;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CopilotLoginManager {

    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";

    private final File file = new File(Persistance.PARENT_DIRECTORY, LOGIN_RESPONSE_JSON_FILE);

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    private LoginResponse cachedLoginResponse;
    private final ConcurrentMap<String,Integer> displayNameToAccountId = new ConcurrentHashMap<>();
    private final ConcurrentMap<Integer, String> accountIdToDisplayName = new ConcurrentHashMap<>();

    public synchronized void removeAccount(Integer accountId) {
        String displayName = accountIdToDisplayName.get(accountId);
        accountIdToDisplayName.remove(accountId);
        if(displayName != null){
            displayNameToAccountId.remove(displayName);
        }
    }
    public void addAccountIfMissing(Integer accountId, String displayName, int copilotUserId) {
        if(!accountIdToDisplayName.containsKey(accountId) && getCopilotUserId() == copilotUserId) {
            synchronized (this) {
                displayNameToAccountId.put(displayName, accountId);
                accountIdToDisplayName.put(accountId, displayName);
            }
        }
    }

    public synchronized Map<String, Integer> displayNameToAccountIdMap() {
        return new HashMap<>(displayNameToAccountId);
    }

    public synchronized Map<Integer, String> accountIDToDisplayNameMap() {
        return new HashMap<>(accountIdToDisplayName);
    }

    public synchronized Set<Integer> accountIds() {
        return new HashSet<>(accountIdToDisplayName.keySet());
    }

    public synchronized Integer getAccountId(String displayName) {
        if(displayName == null) {
            return null;
        }
        return displayNameToAccountId.getOrDefault(displayName, -1);
    }

    public synchronized String getDisplayName(Integer accountId) {
        if(accountId == null){
            return null;
        }
        return accountIdToDisplayName.getOrDefault(accountId, "Unknown");
    }

    public synchronized void setLoginResponse(LoginResponse loginResponse) {
        if (loginResponse == null) {
            return;
        }
        cachedLoginResponse = loginResponse;
        saveLoginResponseAsync();
    }

    public synchronized boolean isLoggedIn() {
        LoginResponse loginResponse = getLoginResponse();
        return loginResponse != null && !Strings.isNullOrEmpty(loginResponse.jwt);
    }

    public synchronized void reset() {
        cachedLoginResponse = null;
        displayNameToAccountId.clear();
        accountIdToDisplayName.clear();
        if (file.exists()) {
            if(!file.delete()) {
                log.warn("failed to delete login response file {}", file);
            }
        }
    }

    public synchronized int getCopilotUserId() {
        LoginResponse loginResponse = getLoginResponse();
        if (loginResponse != null) {
            return loginResponse.userId;
        }
        return -1;
    }

    public synchronized String getJwtToken() {
        if(!isLoggedIn()) {
            return null;
        }
        return getLoginResponse().getJwt();
    }

    private LoginResponse getLoginResponse() {
        if(cachedLoginResponse != null) {
            return cachedLoginResponse;
        }
        cachedLoginResponse = loadLoginResponse();
        return cachedLoginResponse;
    }

    private void saveLoginResponseAsync() {
        executorService.submit(() -> {
            synchronized (file) {
                LoginResponse loginResponse = getLoginResponse();
                if (loginResponse != null) {
                    try {
                        String json = gson.toJson(loginResponse);
                        Files.write(file.toPath(), json.getBytes());
                    } catch (IOException e) {
                        log.warn("error saving login response {}", e.getMessage(), e);
                    }
                }
            }
        });
    }

    private LoginResponse loadLoginResponse() {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, LoginResponse.class);
        } catch (FileNotFoundException ignored) {
            return null;
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading saved login json file {}", file, e);
            return null;
        }
    }
}

package com.flippingcopilot.util;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class GeTaxTest {

    @Test
    public void postTaxPriceForExemptItemReturnsOriginalPrice() {
        int itemId = 13190;
        int price = 1000;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceNormalItem() {
        int itemId = 9999;
        int price = 1000;
        assertEquals(990, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceAboveCap() {
        int itemId = 9999;
        int price = 600000000;
        assertEquals(595000000, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceCheapItem() {
        int itemId = 13190;
        int price = 67;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }
}
//package com.flippingcopilot.controller;
//
//import net.runelite.api.GrandExchangeOffer;
//import net.runelite.api.GrandExchangeOfferState;
//import net.runelite.api.events.GrandExchangeOfferChanged;
//import org.junit.Test;
//
//import java.util.ArrayList;
//
//public class OfferEventFilterTest {
//
//    @Test
//    public void testShouldProcessOnLogin() {
//        OfferEventFilter filter = new OfferEventFilter();
//
//        ArrayList<GrandExchangeOfferChanged> events = new ArrayList<>();
//        ArrayList<Boolean> expectedReturnValues = new ArrayList<>();
//
//        events.add(mockOfferEvent(0, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(1, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(3, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(4, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(6, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//
//        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//
//        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//
//        for (int i = 0; i < events.size(); i++) {
//            assert filter.shouldProcess(events.get(i)) == expectedReturnValues.get(i);
//        }
//    }
//
//    @Test
//    public void testShouldProcessNewBuyOffer() {
//        OfferEventFilter filter = new OfferEventFilter();
//        GrandExchangeOfferChanged event1 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert filter.shouldProcess(event1);
//        GrandExchangeOfferChanged event2 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert !filter.shouldProcess(event2);
//    }
//
//    @Test
//    public void testLogoutLogin() {
//        OfferEventFilter filter = new OfferEventFilter();
//        GrandExchangeOfferChanged event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert filter.shouldProcess(event);
//
//
//        for (int i = 0; i < 8; i++) {
//            event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
//            assert !filter.shouldProcess(event);
//        }
//
//        for (int i = 0; i < 8; i++) {
//            if (i == 2) {
//                event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//                assert !filter.shouldProcess(event);
//            } else {
//                event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
//                assert filter.shouldProcess(event);
//            }
//        }
//
//        event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert !filter.shouldProcess(event);
//    }
//
//    static GrandExchangeOfferChanged mockOfferEvent(int slot, int itemId, int quantitySold, int totalQuantity,
//                                                    int price, int spent, GrandExchangeOfferState state) {
//        GrandExchangeOfferChanged event = new GrandExchangeOfferChanged();
//        event.setSlot(slot);
//        event.setOffer(new GrandExchangeOffer() {
//            @Override
//            public int getQuantitySold() {
//                return quantitySold;
//            }
//
//            @Override
//            public int getItemId() {
//                return itemId;
//            }
//
//            @Override
//            public int getTotalQuantity() {
//                return totalQuantity;
//            }
//
//            @Override
//            public int getPrice() {
//                return price;
//            }
//
//            @Override
//            public int getSpent() {
//                return spent;
//            }
//
//            @Override
//            public GrandExchangeOfferState getState() {
//                return state;
//            }
//        });
//        return event;
//    }
//
//
//}

package com.flippingcopilot.controller;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;


public class DoesNothingExecutorService implements ScheduledExecutorService {
    @Override
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public void shutdown() {

    }

    @Override
    public List<Runnable> shutdownNow() {
        return List.of();
    }

    @Override
    public boolean isShutdown() {
        return false;
    }

    @Override
    public boolean isTerminated() {
        return false;
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return false;
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return null;
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return null;
    }

    @Override
    public Future<?> submit(Runnable task) {
        return null;
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return null;
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return null;
    }

    @Override
    public void execute(Runnable command) {

    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import org.junit.Test;

public class TestSuggestionController {

    @Test
    public void testShouldNotifyOnWait() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null, null, null);
        Suggestion newSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 1, "", null, null, null);
        assert !SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnNewBuy() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null, null, null);
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "", null, null, null);
        assert SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnRepeatedBuy() {
        Suggestion oldSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 0, "", null, null, null);;
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "", null, null, null);
        assert !SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnAbort() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null, null, null);
        Suggestion newSuggestion = new Suggestion("abort", 0, 560, 200, 25000, "Death rune", 1, "", null, null, null);
        assert SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }
}

package com.flippingcopilot.model;

import org.junit.Test;


public class OfferListTest {
    @Test
    public void testIsEmptySlotNeededWithExistingOfferInSlot() {
        StatusOfferList offerList = new StatusOfferList();
        offerList.set(0, new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "", null, null, null);
        assert !offerList.isEmptySlotNeeded(suggestion, true);
    }

    @Test
    public void testIsEmptySlotNeededWithNoEmptySlots() {
        StatusOfferList offerList = new StatusOfferList();
        offerList.replaceAll(ignored -> new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "", null, null, null);
        assert offerList.isEmptySlotNeeded(suggestion, true);
    }

}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.DoesNothingExecutorService;
import okhttp3.OkHttpClient;
import org.junit.Assert;
import org.junit.Test;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlipPriceGraphControllerTest {

    private static final Integer ACCOUNT_ID_1 = 1;
    private static final Integer ACCOUNT_ID_2 = 2;
    private static final Integer ACCOUNT_ID_3 = 3;

    @Test
    public void testOneAccount() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 10_000, List.of(ACCOUNT_ID_1));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null);
        flipManager.setFlipsChangedCallback(() -> {});
        flipManager.mergeFlips(flips, 0);
        flipManager.setIntervalAccount(ACCOUNT_ID_1);


        verifyflipManagerStoredOrder(flipManager);

        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(FlipV2::getId));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        for (int time : testTimes) {
            flipManager.setIntervalStartTime(time);

            // check stats equal
            Stats stats1 = flipManager.getIntervalStats();
            Stats stats2 = expectedStats(flips, time, ACCOUNT_ID_1);
            Assert.assertEquals(stats1, stats2);

            // check all flips equal
            List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
            List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), ACCOUNT_ID_1);
            assertFlipListsEqual(allFlips1, allFlips2);

            // check paginated flips equal
            for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                int numPages = stats1.flipsMade / pageSize + 1;
                for(int page=1; page <= numPages; page++) {
                    List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, ACCOUNT_ID_1);
                    List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                    assertFlipListsEqual(pageFlips1, pageFlips2);
                }
            }
        }
    }

    @Test
    public void testMultipleAccounts() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 5_000, List.of(ACCOUNT_ID_1, ACCOUNT_ID_2, ACCOUNT_ID_3));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null);
        flipManager.setFlipsChangedCallback(() -> {});
        flipManager.mergeFlips(flips, 0);
        verifyflipManagerStoredOrder(flipManager);


        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(Comparator.comparing(FlipV2::getId).reversed()));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        flipManager.setIntervalAccount(null);
        List<FlipV2> flips1 = flipManager.getPageFlips(1, flips.size());
        assertFlipListsEqual(flips1, flips);

        for (Integer accountId : Arrays.asList(ACCOUNT_ID_1, ACCOUNT_ID_2, ACCOUNT_ID_3, null)) {
            flipManager.setIntervalAccount(accountId);
            for (int time : testTimes) {
                flipManager.setIntervalStartTime(time);

                // check stats equal
                Stats stats1 = flipManager.getIntervalStats();
                Stats stats2 = expectedStats(flips, time, accountId);
                Assert.assertEquals(stats1, stats2);

                // check all flips equal
                List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
                List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), accountId);
                assertFlipListsEqual(allFlips1, allFlips2);

                // check paginated flips equal
                for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                    int numPages = stats1.flipsMade / pageSize + 1;
                    for (int page = 1; page <= numPages; page++) {
                        List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                        List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, accountId);
                        assertFlipListsEqual(pageFlips1, pageFlips2);
                    }
                }
            }
        }
    }

    public void verifyflipManagerStoredOrder(FlipManager flipManager) {
        for (int i =0; i < flipManager.weeks.size(); i++) {
            Assert.assertTrue(flipManager.weeks.get(Math.max(i-1,0)).weekStart <= flipManager.weeks.get(i).weekStart);
            FlipManager.WeekAggregate w = flipManager.weeks.get(i);
            for (List<FlipV2> flips : w.accountIdToFlips.values()) {
                for (int ii =1; ii < flips.size(); ii++) {
                    Assert.assertTrue(flips.get(ii-1).getClosedTime() <= flips.get(ii).getClosedTime());
                }
            }
        }
    }

    private List<FlipV2> expectedPage(List<FlipV2> flips, int time, int pageNumber, int pageSize, Integer accountId) {
        int toSkip = (pageNumber - 1) * pageSize;
        List<FlipV2> page = new ArrayList<>();
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                if(toSkip > 0) {
                    toSkip -= 1;
                } else {
                    page.add(f);
                    if(page.size() == pageSize) {
                        break;
                    }
                }
            }
        }
        return page;
    }

    private void assertFlipListsEqual(List<FlipV2> f1, List<FlipV2> f2) {
        if(f1.size() != f2.size()) {
            Assert.fail("flips lists not equal length");
        }
        for (int i=0; i < f1.size(); i++) {
            FlipV2 flip1 = f1.get(i);
            FlipV2 flip2 = f2.get(i);
            if (!flip1.equals(flip2)) {
                Assert.fail("flips don't match at index " + i);
            }
        }
    }

    private Stats expectedStats(List<FlipV2> flips, int time, Integer accountId) {
        Stats stats = new Stats(0,0,0,0);
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                stats.flipsMade += 1;
                stats.gross += f.getSpent();
                stats.profit += f.getProfit();
            }
        }
        return stats;
    }

    private List<FlipV2> generateFlipsBetween(int start, int end, int number, List<Integer> accountIds) {
        List<FlipV2> flips = new ArrayList<>();
        for (int i =0; i< number; i++) {
            FlipV2 f = new FlipV2();
            f.setId(UUID.randomUUID());
            f.setAccountId(accountIds.get(new Random().nextInt(accountIds.size())));
            f.setStatus(FlipStatus.FINISHED);
            // leave a small percentage as open flips
            if(randomIntBetween(0, 1000) > 2) {
                f.setStatus(FlipStatus.SELLING);
                f.setClosedTime(randomIntBetween(start, end));
                f.setSpent(randomIntBetween(100, 1_000_000_000));
                f.setProfit(randomIntBetween(-2_000_000, 4_000_000));
                flips.add(f);
            }
        }
        return flips;
    }

    private int randomIntBetween(int min, int max) {
        return (int)(Math.random() * ((max - min) + 1)) + min;
    }
}
package com.flippingcopilot.model;

import org.junit.Test;

public class AccountStatusTest {

    @Test
    public void testMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        assert accountStatus.moreGpNeeded();
    }

    @Test
    public void testNoMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        accountStatus.getInventory().add(new RSItem(995, 2000));
        assert !accountStatus.moreGpNeeded();
    }
}

//package com.flippingcopilot.model;
//
//import org.junit.Test;
//
//import java.time.Instant;
//
//public class OfferTest {
//
//    @Test
//    public void testTransactionFromNewOffer() {
//        Offer oldOffer = Offer.getEmptyOffer(0);
//        Offer newOffer = new Offer(OfferStatus.BUY, 560, 100, 50, 1000,
//                10, 10, 0, 0, true, false);
//        Transaction expectedTransaction = new Transaction(null, OfferStatus.BUY, 560, 100, 10, 0, 1000, null,false, 0, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert expectedTransaction.equals(actualTransaction);
//    }
//
//    @Test
//    public void testTransactionFromProgressingSell() {
//        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 4000,
//                40, 0, 4000, 0, true, false);
//        Transaction expectedTransaction = new Transaction(null, OfferStatus.SELL, 560, 100, 30, 0, 3000, null,false, 0, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert expectedTransaction.equals(actualTransaction);
//    }
//
//    @Test
//    public void testNoTransaction() {
//        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert actualTransaction == null;
//    }
//}

package com.flippingcopilot.ui;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class UIUtilitiesTest {

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsGreaterThanStringLength() {
        String result = UIUtilities.truncateString("Hello", 10);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsLessThanStringLength() {
        String result = UIUtilities.truncateString("Hello, World!", 5);
        assertEquals("Hello...", result);
    }

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsEqualToStringLength() {
        String result = UIUtilities.truncateString("Hello", 5);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsEmptyString_whenInputStringIsEmpty() {
        String result = UIUtilities.truncateString("", 5);
        assertEquals("", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsZero() {
        String result = UIUtilities.truncateString("Hello, World!", 0);
        assertEquals("...", result);
    }
}
package com.flippingcopilot;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FlippingCopilotPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlippingCopilotPlugin.class);
		RuneLite.main(args);
	}
}
