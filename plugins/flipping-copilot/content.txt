package com.flippingcopilot.util;

import java.util.Arrays;
import java.util.HashSet;

public class GeTax {
    private final static int MAX_PRICE_FOR_GE_TAX = 250000000;
    private final static int GE_TAX_CAP = 5000000;
    private final static double GE_TAX = 0.02;
    private final static HashSet<Integer> GE_TAX_EXEMPT_ITEMS = new HashSet<>(
            Arrays.asList(13190, 1755, 5325, 1785, 2347, 1733, 233, 5341, 8794, 5329, 5343, 1735, 952, 5331));

    public static int getPostTaxPrice(int itemId, int price) {
        if (GE_TAX_EXEMPT_ITEMS.contains(itemId)) {
            return price;
        }
        if (price >= MAX_PRICE_FOR_GE_TAX) {
            return price - GE_TAX_CAP;
        }
        int tax = (int)Math.floor(price * GE_TAX);
        return price - tax;
    }
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

public class AtomicReferenceUtils {
    public static <T> OrElse ifPresent(AtomicReference<T> ref, Consumer<? super T> action) {
        T value = ref.get();
        if (value != null) {
            action.accept(value);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    public static <T, E> OrElse ifBothPresent(AtomicReference<T> ref1, AtomicReference<E> ref2, BiConsumer<? super T,? super E> action) {
        T value1 = ref1.get();
        E value2 = ref2.get();
        if (value1 != null && value2 != null) {
            action.accept(value1, value2);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    @AllArgsConstructor
    public static class OrElse {

        boolean shouldRun;

        public void orElse(Runnable r) {
            if(shouldRun) {
                r.run();
            }
        }
    }
}
package com.flippingcopilot.util;

public class Constants {
    public final static int MIN_GP_NEEDED_TO_FLIP = 1000;
    public final static int PLATINUM_TOKEN_VALUE = 1000;
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class MutableReference<T> {
    private T value;
}

package com.flippingcopilot.controller;

import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class HighlightColorController {

    /*
    For the highlighted colors we oscillate the actual colors through different shades
     */

    // Color ranges for red highlight (R,G,B values)
    private static final int[] RED_START = {205, 0, 50};
    private static final int[] RED_END = {255, 50, 0};

    // Color ranges for blue highlight (R,G,B values)
    private static final int[] BLUE_START = {5, 153, 255};
    private static final int[] BLUE_END = {55, 205, 205};

    // Constants for controlling the drift
    private static final long CYCLE_DURATION = 600000; // 10 minutes for one complete cycle
    private static final int ALPHA = 79;

    public Color getRedColor() {
        double phase = calculatePhase();
        return interpolateColor(RED_START, RED_END, phase, ALPHA);
    }

    public Color getBlueColor() {
        double phase = calculatePhase();
        return interpolateColor(BLUE_START, BLUE_END, phase, ALPHA);
    }

    private double calculatePhase() {
        // Current time modulo cycle duration gives us position in the cycle
        long currentTime = System.currentTimeMillis();
        double cyclePosition = (currentTime % CYCLE_DURATION) / (double) CYCLE_DURATION;

        // Use absolute sine wave to create smooth back-and-forth oscillation
        return Math.abs(Math.sin(cyclePosition * Math.PI));
    }

    private Color interpolateColor(int[] start, int[] end, double phase, int alpha) {
        int red = interpolateComponent(start[0], end[0], phase);
        int green = interpolateComponent(start[1], end[1], phase);
        int blue = interpolateComponent(start[2], end[2], phase);

        return new Color(red, green, blue, alpha);
    }

    private int interpolateComponent(int start, int end, double phase) {
        return (int) Math.round(start + (end - start) * phase);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.LoginResponse;
import com.flippingcopilot.model.SessionData;
import com.flippingcopilot.model.Transaction;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.util.*;

@Slf4j
public class Persistance {
    public static Gson gson;
    public static final File PARENT_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "flipping-copilot");
    public static final String UN_ACKED_TRANSACTIONS_FILE_TEMPLATE = "%s_un_acked.jsonl";
    public static final String ALL_TRANSACTIONS_FILE_TEMPLATE = "%s_all_transactions.jsonl";
    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";
    public static File directory;

    public static void setUp(String directoryPath) throws IOException {
        directory = new File(directoryPath);
        createDirectory(directory);
        createRequiredFiles();
    }

    public static void setUp(Gson gson) throws IOException {
        Persistance.gson = gson;
        directory = PARENT_DIRECTORY;
        createDirectory(PARENT_DIRECTORY);
        createRequiredFiles();
    }

    private static void createRequiredFiles() throws IOException {
        generateFileIfDoesNotExist(LOGIN_RESPONSE_JSON_FILE);
    }

    private static void generateFileIfDoesNotExist(String filename) throws IOException {
        File file = new File(directory, filename);
        if (!file.exists()) {
            if (!file.createNewFile()) {
                log.info("Failed to generate file {}", file.getPath());
            }
        }
    }

    private static void createDirectory(File directory) throws IOException {
        if (!directory.exists()) {
            if (!directory.mkdir()) {
                throw new IOException("unable to create parent directory!");
            }
        }
    }

    public static LoginResponse loadLoginResponse() throws IOException {
        String jsonString = getFileContent(LOGIN_RESPONSE_JSON_FILE);
        return gson.fromJson(jsonString, LoginResponse.class);
    }

    public static void saveLoginResponse(LoginResponse loginResponse) {
        if (loginResponse == null) {
            return;
        }
        try {
            File file = new File(directory, LOGIN_RESPONSE_JSON_FILE);
            String json = gson.toJson(loginResponse);
            Files.write(file.toPath(), json.getBytes());
        } catch (IOException e) {
            log.warn("error saving login response {}", e.getMessage(), e);
        }
    }

    public static void deleteLoginResponse() {
        File file = new File(directory, LOGIN_RESPONSE_JSON_FILE);
        if (file.exists()) {
            file.delete();
        }
    }

    private static String getFileContent(String filename) throws IOException {
        Path filePath = Paths.get(directory.getAbsolutePath(), filename);
        byte[] fileBytes = Files.readAllBytes(filePath);
        return new String(fileBytes);
    }


    public static List<Transaction> loadUnAckedTransactions(String displayName) {
        List<Transaction> transactions = new ArrayList<>();
        File file = new File(PARENT_DIRECTORY, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        if (!file.exists()) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        }
        Set<UUID> added = new HashSet<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }
                try {
                    Transaction transaction = gson.fromJson(line, Transaction.class);
                    // there was previously a bug where the same transaction was being added many times to the list
                    // just clean things here to be safe
                    if (!added.contains(transaction.getId())) {
                        transactions.add(transaction);
                        added.add(transaction.getId());
                    }
                } catch (JsonSyntaxException e) {
                    log.warn("error deserializing transaction line '{}' file {}", line, file, e);
                }
            }
        } catch (FileNotFoundException e) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        } catch (IOException e) {
            log.warn("error loading un acked transaction file {}", file, e);
            return new ArrayList<>();
        }
        log.info("loaded {} stored transactions for {}", transactions.size(), displayName);
        return transactions;
    }

    public static void storeUnAckedTransactions(List<Transaction> transactions, String displayName) {
        File unackedTransactionsFile = new File(PARENT_DIRECTORY, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        try (BufferedWriter w = new BufferedWriter(new FileWriter(unackedTransactionsFile, false))) {
            for (Transaction transaction : transactions) {
                String json = gson.toJson(transaction);
                w.write(json);
                w.newLine();
            }
        } catch (IOException e) {
            log.warn("error storing un acked transactions to file {}", unackedTransactionsFile, e);
        }
    }

    public static String hashDisplayName(String displayName) {
        if(displayName == null) {
            return "null";
        }
        // we hash the display name just to ensure that it's a valid file name
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            byte[] hashBytes = digest.digest(displayName.getBytes(StandardCharsets.UTF_8));
            StringBuilder hexString = new StringBuilder();
            for (byte b : hashBytes) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
@Getter
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OfferHandler {

    private static final int GE_OFFER_INIT_STATE_CHILD_ID = 20;

    // dependencies
    private final Client client;
    private final ClientThread clientThread;
    private final SuggestionManager suggestionManager;
    private final ApiRequestHandler apiRequestHandler;
    private final OsrsLoginManager osrsLoginManager;
    private final OfferManager offerManager;
    private final HighlightController highlightController;
    private final LoginResponseManager loginResponseManager;

    // state
    private String viewedSlotPriceErrorText = null;

    public void fetchSlotItemPrice(boolean isViewingSlot, Supplier<OfferEditor> offerEditorSupplier) {
        if (isViewingSlot) {
            var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);
            offerManager.setViewedSlotItemId(currentItemId);
            if (currentItemId == -1 || currentItemId == 0) return;

            var suggestion = suggestionManager.getSuggestion();
            if (suggestion != null && suggestion.getItemId() == currentItemId &&
                    ((Objects.equals(suggestion.getType(), "sell") && isSelling()) ||
                            Objects.equals(suggestion.getType(), "buy") && isBuying())) {
                offerManager.setLastViewedSlotItemId(suggestion.getItemId());
                offerManager.setLastViewedSlotItemPrice(suggestion.getPrice());
                offerManager.setLastViewedSlotItemPrice((int) Instant.now().getEpochSecond());
                return;
            }

            if (!loginResponseManager.isLoggedIn()) {
                viewedSlotPriceErrorText = "Login to copilot to see item price.";
                return;
            }
            viewedSlotPriceErrorText = "Loading copilot item price..";
            Consumer<ItemPrice> itemPriceConsumer = (fetchedPrice) -> {
                clientThread.invoke(() -> {
                    if (fetchedPrice == null) {
                        viewedSlotPriceErrorText = "Unknown error";
                        return;
                    }

                    if (fetchedPrice.getMessage() != null && !fetchedPrice.getMessage().isEmpty()) {
                        viewedSlotPriceErrorText = fetchedPrice.getMessage();
                    } else {
                        viewedSlotPriceErrorText = null;
                    }
                    offerManager.setViewedSlotItemPrice(isSelling() ? fetchedPrice.getSellPrice() : fetchedPrice.getBuyPrice());
                    offerManager.setLastViewedSlotItemId(offerManager.getViewedSlotItemId());
                    offerManager.setLastViewedSlotItemPrice(offerManager.getViewedSlotItemPrice());
                    offerManager.setLastViewedSlotPriceTime((int) Instant.now().getEpochSecond());

                    log.debug("fetched item {} price: {}", offerManager.getViewedSlotItemId(), offerManager.getViewedSlotItemPrice());

                    highlightController.redraw();

                    // todo: Usage of OfferEditor is messy. It mutates a widget so we need to get the original instance
                    //  of it which is created downstream on some other event handler path. This is why we use a supplier
                    //  but probably it should be an injected class of some kind. We should clean this up in the future
                    //  but for now just need it to work as currently broken.

                    OfferEditor flippingWidget = offerEditorSupplier.get();
                    if (flippingWidget != null) {
                        flippingWidget.showPrice(offerManager.getViewedSlotItemPrice());
                    }
                });
            };


            apiRequestHandler.fetchItemPriceAsync(currentItemId, osrsLoginManager.getPlayerDisplayName(), itemPriceConsumer);

        } else {
            offerManager.setViewedSlotItemPrice(-1);
            offerManager.setViewedSlotItemId(-1);
            viewedSlotPriceErrorText = null;
        }
        highlightController.redraw();
    }

    public boolean isSettingQuantity() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();
        return chatInputText.equals("How many do you wish to buy?") || chatInputText.equals("How many do you wish to sell?");
    }

    public boolean isSettingPrice() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();

        var offerTextWidget = getOfferTextWidget();
        if (offerTextWidget == null) return false;
        String offerText = offerTextWidget.getText();
        return chatInputText.equals("Set a price for each item:") && (offerText.equals("Buy offer") || offerText.equals("Sell offer"));
    }


    private Widget getChatboxTitleWidget() {
        return client.getWidget(ComponentID.CHATBOX_TITLE);
    }

    private Widget getOfferTextWidget() {
        var offerContainerWidget = client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER);
        if (offerContainerWidget == null) return null;
        return offerContainerWidget.getChild(GE_OFFER_INIT_STATE_CHILD_ID);
    }

    public boolean isSelling() {
        return client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 1;
    }

    public boolean isBuying() {
        return client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 0;
    }

    public String getOfferType() {
        if (isBuying()) {
            return "buy";
        } else if (isSelling()) {
            return "sell";
        } else {
            return null;
        }
    }

    public void setSuggestedAction(Suggestion suggestion) {
        var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);

        if (isSettingQuantity()) {
            if (suggestion == null || currentItemId != suggestion.getItemId()) {
                return;
            }
            setChatboxValue(suggestion.getQuantity());
        } else if (isSettingPrice()) {
            int price = -1;
            if (suggestion == null || currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(getOfferType())) {
                if (offerManager.getViewedSlotItemId() != currentItemId) {
                    return;
                }
                price = offerManager.getViewedSlotItemPrice();
            } else {
                price = suggestion.getPrice();
            }

            if (price == -1) return;

            setChatboxValue(price);
        }
    }

    public void setChatboxValue(int value) {
        var chatboxInputWidget = client.getWidget(ComponentID.CHATBOX_FULL_INPUT);
        if (chatboxInputWidget == null) return;
        chatboxInputWidget.setText(value + "*");
        client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(value));
    }
}

package com.flippingcopilot.controller;

import java.awt.event.ActionEvent;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.LoginPanel;
import com.flippingcopilot.ui.MainPanel;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CopilotLoginController {

    // dependencies
    @Setter
    private LoginPanel loginPanel;
    @Setter
    private MainPanel mainPanel;
    private final ApiRequestHandler apiRequestHandler;
    private final FlipManager flipManager;
    private final HighlightController highlightController;
    private final LoginResponseManager loginResponseManager;
    private final SuggestionManager suggestionManager;
    private final OsrsLoginManager osrsLoginManager;
    private final SessionManager sessionManager;
    private final TransactionManger transactionManger;

    // state
    private String email;
    private String password;

    public void onLoginPressed(ActionEvent event) {
        Runnable loginCallback = () -> {
            if (loginResponseManager.isLoggedIn()) {
                flipManager.loadFlipsAsync();
                mainPanel.refresh();
                String displayName = osrsLoginManager.getPlayerDisplayName();
                if(displayName != null) {
                    flipManager.setIntervalDisplayName(displayName);
                    flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                    transactionManger.scheduleSyncIn(0, displayName);
                }
            } else {
                LoginResponse loginResponse = loginResponseManager.getLoginResponse();
                String message = loginResponse != null ? loginResponse.message : "Login failed";
                loginPanel.showLoginErrorMessage(message);
            };
            loginPanel.endLoading();
        };

        if (this.email == null || this.password == null) {
            return;
        }
        loginPanel.startLoading();
        apiRequestHandler.authenticate(this.email, this.password, loginCallback);
    }

    public void onLogout() {
        flipManager.reset();
        loginResponseManager.reset();
        suggestionManager.reset();
        highlightController.removeAll();
    }

    public void onEmailTextChanged(String newEmail) {
        this.email = newEmail;
    }

    public void onPasswordTextChanged(String newPassword) {
        this.password = newPassword;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GePreviousSearch {

    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final HighlightController highlightController;
    private final Client client;


    public void showSuggestedItemInSearch() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion != null && suggestion.getType().equals("buy")) {
            if (grandExchange.isPreviousSearchSet() && grandExchange.showLastSearchEnabled()) {
                setPreviousSearch(suggestion.getItemId(), suggestion.getName());
            } else {
                createPreviousSearchWidget(suggestion.getItemId(), suggestion.getName());
                createPreviousSearchItemNameWidget(suggestion.getName());
                createPreviousSearchItemWidget(suggestion.getItemId());
                createPreviousSearchTextWidget();
            }
            highlightController.redraw();
        }
    }

    private void setPreviousSearch(int itemId, String itemName) {
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget previousSearch = searchResults.getChild(0);
        previousSearch.setOnOpListener(754, itemId, 84);
        previousSearch.setOnKeyListener(754, itemId, -2147483640);
        previousSearch.setName("<col=ff9040>" + itemName + "</col>");
        Widget previousSearchText = searchResults.getChild(1);
        previousSearchText.setText("Copilot item:");
        Widget itemNameWidget = searchResults.getChild(2);
        itemNameWidget.setText(itemName);
        Widget item = searchResults.getChild(3);
        item.setItemId(itemId);
    }

    private void createPreviousSearchWidget(int itemId, String itemName) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.RECTANGLE);
        widget.setTextColor(0xFFFFFF);
        widget.setOpacity(255);
        widget.setName("<col=ff9040>" + itemName + "</col>");
        widget.setHasListener(true);
        widget.setFilled(true);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(256);
        widget.setOriginalHeight(32);
        widget.setOnOpListener(754, itemId, 84);
        widget.setOnKeyListener(754, itemId, -2147483640);
        widget.setHasListener(true);
        widget.setAction(0, "Select");
        // set opacity to 200 when mouse is hovering
        widget.setOnMouseOverListener((JavaScriptCallback) ev -> {
            widget.setOpacity(200);
        });
        // set opacity back to 255 when mouse is not hovering
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
            widget.setOpacity(255);
        });

        widget.revalidate();
    }

    private void createPreviousSearchItemNameWidget(String itemName) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText(itemName);
        widget.setFontId(495);
        widget.setOriginalX(254);
        widget.setOriginalY(0);
        widget.setOriginalWidth(116);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }

    private void createPreviousSearchItemWidget(int itemId) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.GRAPHIC);
        widget.setItemId(itemId);
        widget.setItemQuantity(1);
        widget.setItemQuantityMode(0);
        widget.setRotationX(550);
        widget.setModelZoom(1031);
        widget.setBorderType(1);
        widget.setOriginalX(214);
        widget.setOriginalY(0);
        widget.setOriginalWidth(36);
        widget.setOriginalHeight(32);
        widget.revalidate();
    }

    private void createPreviousSearchTextWidget() {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText("Copilot item:");
        widget.setFontId(495);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(95);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }
}

package com.flippingcopilot.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchange {

    private final static int CURRENTLY_OPEN_GE_SLOT_VARBIT_ID = 4439;
    final static int SHOW_LAST_SEARCHED_VARBIT_ID = 10295;

    private final Client client;

    boolean isHomeScreenOpen() {
        return isOpen() && !isSlotOpen();
    }

    boolean isSlotOpen() {
        return getOpenSlot() != -1;
    }

    boolean isCollectButtonVisible() {
        Widget w = client.getWidget(InterfaceID.GRAND_EXCHANGE, 6);
        if (w == null) {
            return false;
        }
        Widget[] children = w.getChildren();
        if(children == null) {
            return false;
        }
        return Arrays.stream(children).anyMatch(c -> !c.isHidden() && "Collect".equals(c.getText()));
    }

    int getOpenSlot() {
        return client.getVarbitValue(CURRENTLY_OPEN_GE_SLOT_VARBIT_ID) - 1;
    }

    Widget getSlotWidget(int slot) {
        return client.getWidget(465, 7 + slot);
    }

    Widget getBuyButton(int slot) {
        Widget slotWidget = getSlotWidget(slot);
        if (slotWidget == null) {
            return null;
        }
        return slotWidget.getChild(0);
    }

    Widget getCollectButton() {
        Widget topBar = client.getWidget(465, 6);
        if (topBar == null) {
            return null;
        }
        return topBar.getChild(2);
    }

    Widget getOfferContainerWidget() {
        return client.getWidget(465, 26);
    }

    Widget getOfferTypeWidget() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(20);
    }

    Widget getConfirmButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(58);
    }

    int getOfferQuantity() {
        return client.getVarbitValue(4396);
    }

    int getOfferPrice() {
        return client.getVarbitValue(4398);
    }

    public boolean isOpen() {
        return client.getWidget(InterfaceID.GRAND_EXCHANGE, 7) != null;
    }

    public boolean isPreviousSearchSet() {
        return client.getVarpValue(2674) != -1;
    }

    public boolean showLastSearchEnabled() {
        return client.getVarbitValue(SHOW_LAST_SEARCHED_VARBIT_ID) == 0;
    }

    public Widget getSetQuantityButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(51);
    }

    public Widget getSetPriceButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(54);
    }

    public Widget getSetQuantityAllButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(50);
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.ui.UIUtilities;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;


@ConfigGroup("flippingcopilot")
public interface FlippingCopilotConfig extends Config
{
    public enum PriceGraphWebsite
    {
        OSRS_WIKI("OSRS Wiki"),
        GE_TRACKER("GE Tracker"),
        PLATINUM_TOKENS("PlatinumTokens"),
        GE_DATABASE("GE Database"),
        OSRS_CLOUD("Osrs.cloud"),
        OSRS_EXCHANGE("OSRS Exchange"),
        FLIPPING_GG("Flipping.gg");

        private final String name;
        PriceGraphWebsite(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name;
        }

        public String getUrl(String itemName, int itemId)
        {
            switch (this)
            {
                case OSRS_WIKI:
                    return "https://prices.runescape.wiki/osrs/item/" + itemId;
                case GE_TRACKER:
                    return "https://www.ge-tracker.com/item/" + itemId;
                case PLATINUM_TOKENS:
                    String platinumTokensFormattedName = itemName
                            .toLowerCase()
                            .replace("'", "")
                            .replace("(", " ")
                            .replace(")", "")
                            .replace("+", " plus")
                            .replace("  ", " ")
                            .replace(" ", "-");
                    return "https://platinumtokens.com/item/" + platinumTokensFormattedName;
                case GE_DATABASE:
                    return "https://secure.runescape.com/m=itemdb_oldschool/viewitem?obj=" + itemId;
                case OSRS_EXCHANGE:
                    String osrsExchangeFormattedName = itemName.toLowerCase().replace(' ','-');
                    return "https://www.osrs.exchange/item/"
                            + URLEncoder.encode(osrsExchangeFormattedName, StandardCharsets.UTF_8);
                case OSRS_CLOUD:
                    return "https://prices.osrs.cloud/item/" + itemId;
                case FLIPPING_GG:
                    return "https://www.flipping.gg/items/" + itemId;
                default:
                    return "";
            }
        }
    }


    @ConfigItem(
            keyName = "enableChatNotifications",
            name = "Enable chat notifications",
            description = "Show chat notifications for suggested action when the side panel is closed."
    )
    default boolean enableChatNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "enableTrayNotifications",
            name = "Enable tray notifications",
            description = "Show tray notifications for suggested action when runelite is out of focus."
    )
    default boolean enableTrayNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "profitAmountColor",
            name = "Flip tracker profit color",
            description = "The color of the profit amount text in the flip tracker"
    )
    default Color profitAmountColor() {
        return ColorScheme.GRAND_EXCHANGE_PRICE;
    }
    @ConfigItem(
            keyName = "lossAmountColor",
            name = "Flip tracker loss color",
            description = "The color of the loss amount text in the flip tracker"
    )
    default Color lossAmountColor() {
        return UIUtilities.OUTDATED_COLOR;
    }
    @ConfigItem(
            keyName = "chatTextColor",
            name = "Chat text color",
            description = "The color of the text for copilot messages in the chat."
    )
    default Color chatTextColor() {
        return new Color(0x0040FF);
    }
    @ConfigItem(
            keyName = "webhook",
            name = "Webhook URL",
            description = "The Discord Webhook URL for sending display name and profit."
    )
    String webhook();
    @ConfigItem(
            keyName = "priceGraphWebsite",
            name = "Graph button site",
            description = "The website to open when the graph button is clicked."
    )
    default PriceGraphWebsite priceGraphWebsite()
    {
        return PriceGraphWebsite.OSRS_WIKI;
    }
    @ConfigItem(
            keyName = "suggestionHighlights",
            name = "Highlight suggested actions",
            description = "Show highlight overlays on the GE interface for suggested actions."
    )
    default boolean suggestionHighlights()
    {
        return true;
    }
    @ConfigItem(
            keyName = "quickSetKeybind",
            name = "Price/quantity set keybind",
            description = "Keybind to quickly set the price or quantity of a GE offer to the suggested value"
    )
    default Keybind quickSetKeybind()
    {
        return new Keybind(KeyEvent.VK_E, 0);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GameUiChangesHandler {
    private static final int GE_HISTORY_TAB_WIDGET_ID = 149;

    // dependencies
    private final ClientThread clientThread;
    private final Client client;
    private final GePreviousSearch gePreviousSearch;
    private final HighlightController highlightController;
    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final OfferManager offerManager;
    private final OfferHandler offerHandler;

    // state
    boolean quantityOrPriceChatboxOpen;
    boolean itemSearchChatboxOpen = false;
    @Getter
    OfferEditor flippingWidget = null;

    public void onVarClientIntChanged(VarClientIntChanged event) {
        if (event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 14
                && client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS) != null) {
            itemSearchChatboxOpen = true;
            clientThread.invokeLater(gePreviousSearch::showSuggestedItemInSearch);
        }

        if (quantityOrPriceChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            quantityOrPriceChatboxOpen = false;
            return;
        }

        if (itemSearchChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            clientThread.invokeLater(highlightController::redraw);
            itemSearchChatboxOpen = false;
            return;
        }

        //Check that it was the chat input that got enabled.
        if (event.getIndex() != VarClientInt.INPUT_TYPE
                || client.getWidget(ComponentID.CHATBOX_TITLE) == null
                || client.getVarcIntValue(VarClientInt.INPUT_TYPE) != 7
                || client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) == null) {
            return;
        }
        quantityOrPriceChatboxOpen = true;

        clientThread.invokeLater(() ->
        {
            flippingWidget = new OfferEditor(offerManager, client.getWidget(ComponentID.CHATBOX_CONTAINER), offerHandler, client);
            Suggestion suggestion = suggestionManager.getSuggestion();
            if (suggestion != null) {
                flippingWidget.showSuggestion(suggestion);
            }
        });
    }

    public void onVarClientStrChanged(VarClientStrChanged event) {
        if (event.getIndex() == VarClientStr.INPUT_TEXT && itemSearchChatboxOpen) {
            clientThread.invokeLater(highlightController::redraw);
        }
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            suggestionManager.setSuggestionNeeded(true);
        }
        if (event.getGroupId() == 383
                || event.getGroupId() == InterfaceID.GRAND_EXCHANGE
                || event.getGroupId() == 213
                || event.getGroupId() == GE_HISTORY_TAB_WIDGET_ID) {
            clientThread.invokeLater(highlightController::redraw);
        }
    }

    public void onWidgetClosed(WidgetClosed event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            clientThread.invokeLater(highlightController::removeAll);
            suggestionManager.setSuggestionNeeded(true);
        }
    }

    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarpId() == 375
                || event.getVarpId() == CURRENT_GE_ITEM
                || event.getVarbitId() == 4396
                || event.getVarbitId() == 4398
                || event.getVarbitId() == 4439) {
            clientThread.invokeLater(highlightController::redraw);
        }

        if (event.getVarpId() == CURRENT_GE_ITEM) {
            clientThread.invokeLater(() -> offerHandler.fetchSlotItemPrice(event.getValue() > -1, this::getFlippingWidget));
        }
    }

    public void handleMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals("Confirm") && grandExchange.isSlotOpen()) {
            log.debug("offer confirmed tick {}", client.getTickCount());
            offerManager.setOfferJustPlaced(true);
            suggestionManager.setLastOfferSubmittedTick(client.getTickCount());
            suggestionManager.setSuggestionNeeded(true);
            Suggestion suggestion = suggestionManager.getSuggestion();
            if(suggestion != null) {
                suggestionManager.setSuggestionItemIdOnOfferSubmitted(suggestion.getItemId());
                suggestionManager.setSuggestionOfferStatusOnOfferSubmitted(suggestionOfferStatus(suggestion));
            } else {
                suggestionManager.setSuggestionItemIdOnOfferSubmitted(-1);
                suggestionManager.setSuggestionOfferStatusOnOfferSubmitted(null);
            }
        }
    }

    private OfferStatus suggestionOfferStatus(Suggestion suggestion) {
        if ("sell".equals(suggestion.getType())) {
            return OfferStatus.SELL;
        } else if ("buy".equals(suggestion.getType())) {
            return OfferStatus.BUY;
        } else {
            return null;
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.WidgetHighlightOverlay;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.VarClientStr;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;
import static net.runelite.api.Varbits.GE_OFFER_CREATION_TYPE;


@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class HighlightController {

    // dependencies
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final AccountStatusManager accountStatusManager;
    private final Client client;
    private final OfferManager offerManager;
    private final OverlayManager overlayManager;
    private final HighlightColorController highlightColorController;

    // state
    private final ArrayList<WidgetHighlightOverlay> highlightOverlays = new ArrayList<>();

    public void redraw() {
        removeAll();
        if(!config.suggestionHighlights()) {
            return;
        }
        if (offerManager.isOfferJustPlaced()) {
            return;
        }
        if(suggestionManager.getSuggestionError() != null) {
            return;
        }
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return;
        }
        if (grandExchange.isHomeScreenOpen()) {
            drawHomeScreenHighLights(suggestion);
        } else if (grandExchange.isSlotOpen()) {
            drawOfferScreenHighlights(suggestion);
        }
    }

    private void drawHomeScreenHighLights(Suggestion suggestion) {
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (accountStatus.isCollectNeeded(suggestion)) {
            Widget collectButton = grandExchange.getCollectButton();
            if (collectButton != null) {
                add(collectButton, highlightColorController.getBlueColor(), new Rectangle(2, 1, 81, 18));
            }
        }
        else if (suggestion.getType().equals("abort")) {
            Widget slotWidget = grandExchange.getSlotWidget(suggestion.getBoxId());
            add(slotWidget, highlightColorController.getRedColor());
        }
        else if (suggestion.getType().equals("buy")) {
            int slotId = accountStatus.getOffers().findEmptySlot();
            if (slotId != -1) {
                Widget buyButton = grandExchange.getBuyButton(slotId);
                if (buyButton != null && !buyButton.isHidden()) {
                    add(buyButton, highlightColorController.getBlueColor(), new Rectangle(0, 0, 45, 44));
                }
            }
        }
        else if (suggestion.getType().equals("sell")) {
            Widget itemWidget = getInventoryItemWidget(suggestion.getItemId());
            if (itemWidget != null && !itemWidget.isHidden()) {
                add(itemWidget, highlightColorController.getBlueColor(), new Rectangle(0, 0, 34, 32));
            }
        }
    }

    private void drawOfferScreenHighlights(Suggestion suggestion) {
        Widget offerTypeWidget = grandExchange.getOfferTypeWidget();
        String offerType = client.getVarbitValue(GE_OFFER_CREATION_TYPE) == 1 ? "sell" : "buy";
        if (offerTypeWidget != null) {
            if (offerType.equals(suggestion.getType())) {
                if (client.getVarpValue(CURRENT_GE_ITEM) == suggestion.getItemId()) {
                    if (offerDetailsCorrect(suggestion)) {
                        highlightConfirm();
                    } else {
                        if (grandExchange.getOfferPrice() != suggestion.getPrice()) {
                            highlightPrice();
                        }
                        highlightQuantity(suggestion);
                    }
                } else if (client.getVarpValue(CURRENT_GE_ITEM ) == -1){
                    highlightItemInSearch(suggestion);
                }
            }
            // Check if unsuggested item/offer type is selected
            if (client.getVarpValue(CURRENT_GE_ITEM) != -1
                    && (client.getVarpValue(CURRENT_GE_ITEM) != suggestion.getItemId()
                        || !offerType.equals(suggestion.getType()))
                    && client.getVarpValue(CURRENT_GE_ITEM) == offerManager.getViewedSlotItemId()
                    && offerManager.getViewedSlotItemPrice() > 0) {
                if (grandExchange.getOfferPrice() == offerManager.getViewedSlotItemPrice()) {
                    highlightConfirm();
                } else {
                    highlightPrice();
                }
            }
        }
    }

    private void highlightItemInSearch(Suggestion suggestion) {
        if (!client.getVarcStrValue(VarClientStr.INPUT_TEXT).isEmpty()) {
            return;
        }
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        if (searchResults == null) {
            return;
        }
        for (Widget widget : searchResults.getDynamicChildren()) {
            if (widget.getName().equals("<col=ff9040>" + suggestion.getName() + "</col>")) {
                add(widget, highlightColorController.getBlueColor());
                return;
            }
        }
        Widget itemWidget = searchResults.getChild(3);
        if (itemWidget != null && itemWidget.getItemId() == suggestion.getItemId()) {
            add(itemWidget, highlightColorController.getBlueColor());
        }
    }

    private boolean offerDetailsCorrect(Suggestion suggestion) {
        return grandExchange.getOfferPrice() == suggestion.getPrice()
                && grandExchange.getOfferQuantity() == suggestion.getQuantity();
    }

    private void highlightPrice() {
        Widget setPriceButton = grandExchange.getSetPriceButton();
        if (setPriceButton != null) {
            add(setPriceButton, highlightColorController.getBlueColor(), new Rectangle(1, 6, 33, 23));
        }
    }

    private void highlightQuantity(Suggestion suggestion) {
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (grandExchange.getOfferQuantity() != suggestion.getQuantity()) {
            Widget setQuantityButton;
            if (accountStatus.getInventory().getTotalAmount(suggestion.getItemId()) == suggestion.getQuantity()) {
                setQuantityButton = grandExchange.getSetQuantityAllButton();
            } else {
                setQuantityButton = grandExchange.getSetQuantityButton();
            }
            if (setQuantityButton != null) {
                add(setQuantityButton, highlightColorController.getBlueColor(), new Rectangle(1, 6, 33, 23));
            }
        }
    }

    private void highlightConfirm() {
        Widget confirmButton = grandExchange.getConfirmButton();
        if (confirmButton != null) {
            add(confirmButton, highlightColorController.getBlueColor(), new Rectangle(1, 1, 150, 38));
        }
    }

    private void add(Widget widget, Color color, Rectangle adjustedBounds) {
        SwingUtilities.invokeLater(() -> {
            WidgetHighlightOverlay overlay = new WidgetHighlightOverlay(widget, color, adjustedBounds);
            highlightOverlays.add(overlay);
            overlayManager.add(overlay);
        });
    }

    private void add(Widget widget, Color color) {
        add(widget, color, new Rectangle(0, 0, widget.getWidth(), widget.getHeight()));
    }

    public void removeAll() {
        SwingUtilities.invokeLater(() -> {
            highlightOverlays.forEach(overlayManager::remove);
            highlightOverlays.clear();
        });
    }

    private Widget getInventoryItemWidget(int unnotedItemId) {
        // Inventory has a different widget if GE is open
        Widget inventory = client.getWidget(467, 0);
        if (inventory == null) {
            inventory = client.getWidget(149, 0);
            if (inventory == null) {
                return null;
            }
        }

        Widget notedWidget = null;
        Widget unnotedWidget = null;

        for (Widget widget : inventory.getDynamicChildren()) {
            int itemId = widget.getItemId();
            ItemComposition itemComposition = client.getItemDefinition(itemId);

            if (itemComposition.getNote() != -1) {
                if (itemComposition.getLinkedNoteId() == unnotedItemId) {
                    notedWidget = widget;
                }
            } else if (itemId == unnotedItemId) {
                unnotedWidget = widget;
            }
        }
        return notedWidget != null ? notedWidget : unnotedWidget;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.*;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
@PluginDescriptor(
		name = "Flipping Copilot",
		description = "Your AI assistant for trading"
)
public class FlippingCopilotPlugin extends Plugin {

	@Inject
	private FlippingCopilotConfig config;
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private ScheduledExecutorService executorService;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private Gson gson;
	@Inject
	private GrandExchange grandExchange;
	@Inject
	private GrandExchangeCollectHandler grandExchangeCollectHandler;
	@Inject
	private GrandExchangeOfferEventHandler offerEventHandler;
	@Inject
	private ApiRequestHandler apiRequestHandler;
	@Inject
	private AccountStatusManager accountStatusManager;
	@Inject
	private SuggestionController suggestionController;
	@Inject
	private SuggestionManager suggestionManager;
	@Inject
	private WebHookController webHookController;
	@Inject
	private KeybindHandler keybindHandler;
	@Inject
	private CopilotLoginController copilotLoginController;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private LoginResponseManager loginResponseManager;
	@Inject
	private HighlightController highlightController;
	@Inject
	private GameUiChangesHandler gameUiChangesHandler;
	@Inject
	private OsrsLoginManager osrsLoginManager;
	@Inject
	private FlipManager flipManager;
	@Inject
	private SessionManager sessionManager;
	@Inject
	private GrandExchangeUncollectedManager grandExchangeUncollectedManager;
	@Inject
	private TransactionManger transactionManger;
	@Inject
	private OfferManager offerManager;

	private MainPanel mainPanel;
	private StatsPanelV2 statsPanel;
	private NavigationButton navButton;

    @Override
	protected void startUp() throws Exception {
		Persistance.setUp(gson);

		// seems we need to delay instantiating the UI till here as otherwise the panels look different
		mainPanel = injector.getInstance(MainPanel.class);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon-small.png");
		navButton = NavigationButton.builder()
				.tooltip("Flipping Copilot")
				.icon(icon)
				.priority(3)
				.panel(mainPanel)
				.build();
		clientToolbar.addNavigation(navButton);

		copilotLoginController.setLoginPanel(mainPanel.loginPanel);
		copilotLoginController.setMainPanel(mainPanel);
		suggestionController.setCopilotPanel(mainPanel.copilotPanel);
		suggestionController.setMainPanel(mainPanel);
		suggestionController.setLoginPanel(mainPanel.loginPanel);
		suggestionController.setSuggestionPanel(mainPanel.copilotPanel.suggestionPanel);
		grandExchangeCollectHandler.setSuggestionPanel(mainPanel.copilotPanel.suggestionPanel);
		statsPanel = mainPanel.copilotPanel.statsPanel;

		mainPanel.refresh();
		if(loginResponseManager.isLoggedIn()) {
			flipManager.loadFlipsAsync();
		}
		if(osrsLoginManager.getInvalidStateDisplayMessage() == null) {
			flipManager.setIntervalDisplayName(osrsLoginManager.getPlayerDisplayName());
			flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
		}
		executorService.scheduleAtFixedRate(() ->
			clientThread.invoke(() -> {
				boolean loginValid = osrsLoginManager.isValidLoginState();
				if (loginValid) {
					AccountStatus accStatus = accountStatusManager.getAccountStatus();
					boolean isFlipping = accStatus != null && accStatus.currentlyFlipping();
					long cashStack = accStatus == null ? 0 : accStatus.currentCashStack();
					if(sessionManager.updateSessionStats(isFlipping, cashStack)) {
						mainPanel.copilotPanel.statsPanel.refresh(false, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
					}
				}
			})
		, 2000, 1000, TimeUnit.MILLISECONDS);
	}

	@Override
	protected void shutDown() throws Exception {
		offerManager.saveAll();
		highlightController.removeAll();
		clientToolbar.removeNavigation(navButton);
		if(loginResponseManager.isLoggedIn()) {
			String displayName = osrsLoginManager.getLastDisplayName();
			webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, displayName), sessionManager.getCachedSessionData(), displayName, false);
		}
		keybindHandler.unregister();
	}

	@Provides
	public FlippingCopilotConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(FlippingCopilotConfig.class);
	}

	//---------------------------- Event Handlers ----------------------------//
	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event) {
		offerEventHandler.onGrandExchangeOfferChanged(event);
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event) {
		if (event.getContainerId() == InventoryID.INVENTORY.getId() && grandExchange.isOpen()) {
			suggestionManager.setSuggestionNeeded(true);
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		suggestionController.onGameTick();
		offerEventHandler.onGameTick();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		int slot = grandExchange.getOpenSlot();
		grandExchangeCollectHandler.handleCollect(event, slot);
		gameUiChangesHandler.handleMenuOptionClicked(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		gameUiChangesHandler.onWidgetLoaded(event);
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		gameUiChangesHandler.onWidgetClosed(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		gameUiChangesHandler.onVarbitChanged(event);
	}

	@Subscribe
	public void onVarClientStrChanged(VarClientStrChanged event) {
		gameUiChangesHandler.onVarClientStrChanged(event);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		switch (event.getGameState())
		{
			case LOGIN_SCREEN:
				sessionManager.reset();
				suggestionManager.reset();
				osrsLoginManager.reset();
				accountStatusManager.reset();
				grandExchangeUncollectedManager.reset();
				statsPanel.refresh(true, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
				mainPanel.refresh();
				break;
			case LOGGING_IN:
			case HOPPING:
			case CONNECTION_LOST:
				osrsLoginManager.setLastLoginTick(client.getTickCount());
				break;
			case LOGGED_IN:
				// we want to update the flips panel on login but unfortunately the display name
				// is not available immediately so schedule what we need to do here for in the future
				// todo: move to just using the accountHash which is available immediately to simply things
				clientThread.invokeLater(() -> {
					if (client.getGameState() != GameState.LOGGED_IN) {
						return true;
					}
					final String name = osrsLoginManager.getPlayerDisplayName();
					if(name == null) {
						return false;
					}
					statsPanel.resetIntervalDropdownToSession();
					flipManager.setIntervalDisplayName(name);
					flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
					statsPanel.refresh(true, loginResponseManager.isLoggedIn()  && osrsLoginManager.isValidLoginState());
					mainPanel.refresh();
					if(loginResponseManager.isLoggedIn()) {
						transactionManger.scheduleSyncIn(0, name);
					}
					return true;
				});
		}
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event) {
		gameUiChangesHandler.onVarClientIntChanged(event);
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown clientShutdownEvent) {
		log.debug("client shutdown event received");
		offerManager.saveAll();
		if(loginResponseManager.isLoggedIn()) {
			String displayName = osrsLoginManager.getLastDisplayName();
			webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, displayName), sessionManager.getCachedSessionData(), displayName, false);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals("flippingcopilot")) {
			log.debug("copilot config changed event received");
			if (event.getKey().equals("profitAmountColor") || event.getKey().equals("lossAmountColor")) {
				mainPanel.copilotPanel.statsPanel.refresh(true, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
			}
			if (event.getKey().equals("suggestionHighlights")) {
				clientThread.invokeLater(() -> highlightController.redraw());
			}
		}
	}
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.GrandExchangeUncollectedManager;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.ui.SuggestionPanel;
import com.google.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchangeCollectHandler {

    // dependencies
    private final OsrsLoginManager osrsLoginManager;
    private final GrandExchangeUncollectedManager geUncollected;
    @Setter
    private SuggestionPanel suggestionPanel;

    public void handleCollect(MenuOptionClicked event, int slot) {
        String menuOption = event.getMenuOption();
        Widget widget = event.getWidget();
        if (widget != null) {
            handleCollectAll(menuOption, widget);
            handleCollectWithSlotOpen(menuOption, widget, slot);
            handleCollectionBoxCollectAll(menuOption, widget);
            handleCollectionBoxCollectItem(menuOption, widget);
        }
    }

    private void handleCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 30474246) {
            if (menuOption.equals("Collect to inventory")) {
                geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            } else if (menuOption.equals("Collect to bank")) {
                geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            }
            suggestionPanel.refresh();
        }
    }

    private void handleCollectWithSlotOpen(String menuOption, Widget widget, int slot) {
        if (widget.getId() == 30474264 ) {
            if (menuOption.contains("Collect")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            } else if (menuOption.contains("Bank")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            }
            suggestionPanel.refresh();
        }
    }

    private void handleCollectionBoxCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 26345476 && menuOption.equals("Collect to bank")) {
            geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionPanel.refresh();
            
        } else if (widget.getId() == 26345475 && menuOption.equals("Collect to inventory")) {
            geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionPanel.refresh();
        }
    }

    private void handleCollectionBoxCollectItem(String menuOption, Widget widget) {
        int slot = widget.getId() - 26345477;
        if (slot >= 0 && slot <= 7) {
            if (menuOption.contains("Collect")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            } else if (menuOption.contains("Bank")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            }
            suggestionPanel.refresh();
        }
    }
}

package com.flippingcopilot.controller;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.GpDropOverlay;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import javax.inject.Inject;
import javax.inject.Singleton;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.client.ui.overlay.OverlayManager;

import static com.flippingcopilot.model.OsrsLoginManager.GE_LOGIN_BURST_WINDOW;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchangeOfferEventHandler {

    // dependencies
    private final Client client;
    private final OfferManager offerPersistence;
    private final GrandExchange grandExchange;
    private final TransactionManger transactionManager;
    private final OsrsLoginManager osrsLoginManager;
    private final OverlayManager overlayManager;
    private final GrandExchangeUncollectedManager grandExchangeUncollectedManager;
    private final OfferManager offerManager;
    private final SuggestionManager suggestionManager;

    // state
    private final Queue<Transaction> transactionsToProcess = new ConcurrentLinkedQueue<>();

    public void onGameTick() {
        if(!transactionsToProcess.isEmpty()) {
            processTransactions();
        }
    }

    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerEvent) {
        final int slot = offerEvent.getSlot();
        final GrandExchangeOffer offer = offerEvent.getOffer();
        Long accountHash = client.getAccountHash();

        if (offer.getState() == GrandExchangeOfferState.EMPTY && client.getGameState() != GameState.LOGGED_IN) {
            // Trades are cleared by the client during LOGIN_SCREEN/HOPPING/LOGGING_IN, ignore those
            return;
        }

        log.debug("tick {} GE offer updated: state: {}, slot: {}, item: {}, qty: {}, lastLoginTick: {}", client.getTickCount(), offer.getState(), slot, offer.getItemId(), offer.getQuantitySold(), osrsLoginManager.getLastLoginTick());

        SavedOffer o = SavedOffer.fromGrandExchangeOffer(offer);

        SavedOffer prev = offerPersistence.loadOffer(accountHash, slot);

        if(Objects.equals(o, prev)) {
            log.debug("skipping duplicate offer event {}", o);
            return;
        }

        o.setCopilotPriceUsed(wasCopilotPriceUsed(o, prev));
        o.setWasCopilotSuggestion(wasCopilotSuggestion(o, prev));

        boolean consistent = isConsistent(prev, o);
        if(!consistent) {
            log.warn("offer on slot {} is inconsistent with previous saved offer", slot);
        }

        if(hasSlotBecomeFree(o, prev, consistent)) {
            suggestionManager.setSuggestionNeeded(true);
        }

        Transaction t = inferTransaction(slot, o, prev, consistent);
        if(t != null) {
            transactionsToProcess.add(t);
            processTransactions();
            suggestionManager.setSuggestionNeeded(true);
            log.debug("inferred transaction {}", t);
        }
        updateUncollected(accountHash, slot, o, prev, consistent);
        offerPersistence.saveOffer(accountHash, slot, o);
    }

    private boolean hasSlotBecomeFree(SavedOffer offer, SavedOffer prev, boolean consistent) {
        return offer.isFreeSlot() && (prev == null || !consistent || !prev.isFreeSlot());
    }

    private boolean wasCopilotPriceUsed(SavedOffer o, SavedOffer prev) {
        if(isNewOffer(prev, o)){
            return o.getItemId() == offerManager.getLastViewedSlotItemId() && o.getPrice() == offerManager.getLastViewedSlotItemPrice() && Instant.now().minusSeconds(30).getEpochSecond() < offerManager.getLastViewedSlotPriceTime();
        } else {
            return prev.isCopilotPriceUsed();
        }
    }

    private boolean wasCopilotSuggestion(SavedOffer o, SavedOffer prev) {
        if(isNewOffer(prev, o)){
            return o.getItemId() == suggestionManager.getSuggestionItemIdOnOfferSubmitted() && o.getOfferStatus().equals(suggestionManager.getSuggestionOfferStatusOnOfferSubmitted());
        } else {
            return prev.isWasCopilotSuggestion();
        }
    }

    private void updateUncollected(Long accountHash, int slot, SavedOffer o, SavedOffer prev, boolean consistent) {
        if(!consistent) {
            return;
        }
        int uncollectedGp = 0;
        int uncollectedItems = 0;
        switch (o.getState()) {
            case BUYING:
            case BOUGHT:
                uncollectedItems = isNewOffer(prev, o) ? o.getQuantitySold() : o.getQuantitySold() - prev.getQuantitySold();
                break;
            case SOLD:
            case SELLING:
                uncollectedGp = (isNewOffer(prev, o) ? o.getQuantitySold() : o.getQuantitySold() - prev.getQuantitySold()) * o.getPrice();
                break;
            case CANCELLED_BUY:
                uncollectedGp = (o.getTotalQuantity() - o.getQuantitySold()) * o.getPrice();
                break;
            case CANCELLED_SELL:
                uncollectedItems = o.getTotalQuantity() - o.getQuantitySold();
                break;
            case EMPTY:
                // if the slot is empty we want to ensure that the un collected manager doesn't think there is something to collect
                // this can happen due to race conditions between the collection and offer fills timing
                grandExchangeUncollectedManager.ensureSlotClear(accountHash, slot);
                suggestionManager.setSuggestionNeeded(true);
                return;
        }
        grandExchangeUncollectedManager.addUncollected(accountHash, slot, o.getItemId(), uncollectedItems, uncollectedGp);

    }

    private void processTransactions() {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        if(displayName != null) {
            Transaction transaction;
            while ((transaction = transactionsToProcess.poll()) != null) {
                long profit = transactionManager.addTransaction(transaction, displayName);
                if (grandExchange.isHomeScreenOpen() && profit != 0) {
                    new GpDropOverlay(overlayManager, client, profit, transaction.getBoxId());
                }
            }
        }
    }

    public Transaction inferTransaction(int slot, SavedOffer offer, SavedOffer prev, boolean consistent) {
        boolean login = client.getTickCount() <= osrsLoginManager.getLastLoginTick() + GE_LOGIN_BURST_WINDOW;
        boolean isNewOffer = isNewOffer(prev, offer);
        int quantityDiff = isNewOffer ? offer.getQuantitySold() : offer.getQuantitySold() - prev.getQuantitySold();
        int amountSpentDiff = isNewOffer ? offer.getSpent() : offer.getSpent() - prev.getSpent();
        if (quantityDiff > 0 && amountSpentDiff > 0) {
            Transaction t = new Transaction();
            t.setId(UUID.randomUUID());
            t.setType(offer.getOfferStatus());
            t.setItemId(offer.getItemId());
            t.setPrice(offer.getPrice());
            t.setQuantity(quantityDiff);
            t.setBoxId(slot);
            t.setAmountSpent(amountSpentDiff);
            t.setTimestamp(Instant.now());
            t.setCopilotPriceUsed(offer.isCopilotPriceUsed());
            t.setWasCopilotSuggestion(offer.isWasCopilotSuggestion());
            t.setOfferTotalQuantity(offer.getTotalQuantity());
            t.setLogin(login);
            t.setConsistent(consistent);
            return t;
        }
        return null;
    }

    private boolean isConsistent(SavedOffer prev, SavedOffer updated) {
        if(prev == null) {
            return false;
        }
        if(updated.getState() == GrandExchangeOfferState.EMPTY) {
            return true;
        }
        if(prev.getState() == GrandExchangeOfferState.EMPTY && !(updated.getState() == GrandExchangeOfferState.CANCELLED_BUY || updated.getState() == GrandExchangeOfferState.CANCELLED_SELL)) {
            return true;
        }
        return prev.getOfferStatus() == updated.getOfferStatus() ||
                prev.getItemId() == updated.getItemId()
                || prev.getPrice() == updated.getPrice()
                || prev.getTotalQuantity() == updated.getTotalQuantity();
    }

    private boolean isNewOffer(SavedOffer prev, SavedOffer updated) {
        if (prev == null) {
            return true;
        }
        return prev.getOfferStatus() != updated.getOfferStatus() ||
                prev.getItemId() != updated.getItemId()
                || prev.getPrice() != updated.getPrice()
                || prev.getTotalQuantity() != updated.getTotalQuantity()
                || prev.getQuantitySold() > updated.getQuantitySold()
                || prev.getSpent() > updated.getSpent();
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.*;
import com.google.gson.Gson;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;

@Slf4j
@Getter
@Setter
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SuggestionController {

    // dependencies
    private final PausedManager pausedManager;
    private final Client client;
    private final Gson gson;
    private final OsrsLoginManager osrsLoginManager;
    private final HighlightController highlightController;
    private final GrandExchange grandExchange;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler apiRequestHandler;
    private final Notifier notifier;
    private final OfferManager offerManager;
    private final LoginResponseManager loginResponseManager;
    private final ClientThread clientThread;
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final AccountStatusManager accountStatusManager;
    private final GrandExchangeUncollectedManager uncollectedManager;
    private MainPanel mainPanel;
    private LoginPanel loginPanel;
    private CopilotPanel copilotPanel;
    private SuggestionPanel suggestionPanel;

    public void togglePause() {
        if (pausedManager.isPaused()) {
            pausedManager.setPaused(false);
            suggestionManager.setSuggestionNeeded(true);
            suggestionPanel.refresh();
        } else {
            pausedManager.setPaused(true);
            highlightController.removeAll();
            suggestionPanel.refresh();
        }
    }

    void onGameTick() {
        if(suggestionManager.isSuggestionRequestInProgress()) {
            return;
        }
        // There is a race condition when the collect button is hit at the same time as offers fill.
        // In such a case we can end up with the uncollectedManager falsely thinking there is items to collect.
        // We identify if this has happened here by checking if the collect button is actually visible.
        if(isUncollectedOutOfSync()) {
            log.warn("uncollected is out of sync, it thinks there are items to collect but the GE is open and the Collect button not visible");
            uncollectedManager.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionManager.setSuggestionNeeded(true);
        }
        // on initial login the state of the GE offers isn't correct we need to wait a couple ticks before requesting a suggestion
        if (osrsLoginManager.hasJustLoggedIn()) {
            return;
        }
        if ((suggestionManager.isSuggestionNeeded() || suggestionManager.suggestionOutOfDate()) && !(grandExchange.isSlotOpen() && !accountStatusManager.isSuggestionSkipped())) {
            getSuggestionAsync();
        }
    }

    private boolean isUncollectedOutOfSync() {
        if (client.getTickCount() <= uncollectedManager.getLastUncollectedAddedTick() + 2) {
            return false;
        }
        if(!grandExchange.isHomeScreenOpen() || grandExchange.isCollectButtonVisible()) {
            return false;
        }
        if(uncollectedManager.HasUncollected(osrsLoginManager.getAccountHash())) {
            return true;
        }
        if(suggestionPanel.isCollectItemsSuggested()) {
            return true;
        }
        return false;
    }

    public void getSuggestionAsync() {
        suggestionManager.setSuggestionNeeded(false);
        if (!loginResponseManager.isLoggedIn() || !osrsLoginManager.isValidLoginState()) {
            return;
        }
        if (suggestionManager.isSuggestionRequestInProgress()) {
            return;
        }
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (accountStatus == null) {
            return;
        }
        suggestionManager.setSuggestionRequestInProgress(true);
        Suggestion oldSuggestion = suggestionManager.getSuggestion();
        Consumer<Suggestion> onSuccess = (newSuggestion) -> {
            suggestionManager.setSuggestion(newSuggestion);
            suggestionManager.setSuggestionError(null);
            suggestionManager.setSuggestionRequestInProgress(false);
            log.debug("Received suggestion: {}", newSuggestion.toString());
            accountStatusManager.resetSkipSuggestion();
            offerManager.setOfferJustPlaced(false);
            suggestionPanel.refresh();
            showNotifications(oldSuggestion, newSuggestion, accountStatus);
        };
        Consumer<HttpResponseException> onFailure = (e) -> {
            suggestionManager.setSuggestion(null);
            suggestionManager.setSuggestionError(e);
            suggestionManager.setSuggestionRequestInProgress(false);
            if (e.getResponseCode() == 401) {
                loginResponseManager.reset();
                mainPanel.refresh();
                loginPanel.showLoginErrorMessage("Login timed out. Please log in again");
            } else {
                suggestionPanel.refresh();
            }
        };
        suggestionPanel.refresh();
        log.debug("tick {} getting suggestion", client.getTickCount());
        apiRequestHandler.getSuggestionAsync(accountStatus.toJson(gson, grandExchange.isOpen()), onSuccess, onFailure);
    }


    void showNotifications(Suggestion oldSuggestion, Suggestion newSuggestion, AccountStatus accountStatus) {
        if (shouldNotify(newSuggestion, oldSuggestion)) {
            if (config.enableTrayNotifications()) {
                notifier.notify(newSuggestion.toMessage());
            }
            if (!copilotPanel.isShowing() && config.enableChatNotifications()) {
                showChatNotifications(newSuggestion, accountStatus);
            }
        }
    }

    static boolean shouldNotify(Suggestion newSuggestion, Suggestion oldSuggestion) {
        if (newSuggestion.getType().equals("wait")) {
            return false;
        }
        if (oldSuggestion != null && newSuggestion.equals(oldSuggestion)) {
            return false;
        }
        return true;
    }

    private void showChatNotifications(Suggestion newSuggestion, AccountStatus accountStatus) {
        if (accountStatus.isCollectNeeded(newSuggestion)) {
            clientThread.invokeLater(() -> showChatNotification("Flipping Copilot: Collect items"));
        }
        clientThread.invokeLater(() -> showChatNotification(newSuggestion.toMessage()));
    }

    private void showChatNotification(String message) {
        String chatMessage = new ChatMessageBuilder()
                .append(config.chatTextColor(), message)
                .build();
        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", chatMessage, "");
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.SuggestionManager;
import net.runelite.api.Client;
import net.runelite.api.VarClientInt;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.KeyEvent;


@Singleton
public class KeybindHandler {

    private final KeyManager keyManager;
    private final FlippingCopilotConfig config;
    private final ClientThread clientThread;
    private final SuggestionManager suggestionManager;
    private final Client client;
    private final GrandExchange grandExchange;
    private final OfferHandler offerHandler;


    @Inject
    public KeybindHandler(KeyManager keyManager, FlippingCopilotConfig config, ClientThread clientThread, SuggestionManager suggestionManager, Client client, GrandExchange grandExchange, OfferHandler offerHandler) {
        this.keyManager = keyManager;
        this.config = config;
        this.clientThread = clientThread;
        this.suggestionManager = suggestionManager;
        this.client = client;
        this.grandExchange = grandExchange;
        this.offerHandler = offerHandler;
        keyManager.registerKeyListener(offerEditorKeyListener());
    }

    public void unregister() {
        keyManager.unregisterKeyListener(offerEditorKeyListener());
    }


    private KeyListener offerEditorKeyListener() {
        return new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {
                // Prevent enter as a keybind as that will also submit the value
                if (e.getKeyCode() == KeyEvent.VK_ENTER) return;
                if (e.getKeyCode() !=config.quickSetKeybind().getKeyCode()) return;

               clientThread.invokeLater(this::handleKeybind);
            }

            @Override
            public void keyReleased(KeyEvent e) {

            }

            private void handleKeybind() {
                var suggestion = suggestionManager.getSuggestion();

                var inputType = client.getVarcIntValue(VarClientInt.INPUT_TYPE);

                var isPriceOrQuantityBoxOpen =client.getWidget(ComponentID.CHATBOX_TITLE) != null
                        && inputType == 7
                        &&client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) != null
                        &&grandExchange.isSlotOpen();

                if (isPriceOrQuantityBoxOpen) {
                   offerHandler.setSuggestedAction(suggestion);
                }
            }
        };
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.google.gson.*;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import okhttp3.*;

import java.io.IOException;
import java.lang.reflect.Type;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @javax.inject.Inject)
public class ApiRequestHandler {

    private static final String serverUrl = System.getenv("FLIPPING_COPILOT_HOST") != null ? System.getenv("FLIPPING_COPILOT_HOST")  : "https://api.flippingcopilot.com";

    // dependencies
    private final OkHttpClient client;
    private final Gson gson;
    private final LoginResponseManager loginResponseManager;
    private final SuggestionPreferencesManager preferencesManager;
    private final ClientThread clientThread;

    // state
    private Instant lastDebugMessageSent = Instant.now();


    public void authenticate(String username, String password, Runnable callback) {
        Request request = new Request.Builder()
                .url(serverUrl + "/login")
                .addHeader("Authorization", Credentials.basic(username, password))
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), ""))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        log.warn("login failed with http status code {}", response.code());
                    }
                    String body = response.body() == null ? "" : response.body().string();
                    LoginResponse loginResponse = gson.fromJson(body, LoginResponse.class);
                    loginResponseManager.setLoginResponse(loginResponse);
                } catch (IOException e) {
                    log.warn("error reading/decoding login response body", e);
                } catch (JsonParseException e) {
                    loginResponseManager.setLoginResponse(new LoginResponse(true, response.message(), null, -1));
                } finally {
                    callback.run();
                }
            }
        });
    }

    public void getSuggestionAsync(JsonObject status, Consumer<Suggestion> onSuccess, Consumer<HttpResponseException>  onFailure) {
        log.debug("sending status {}", status.toString());
        Request request = new Request.Builder()
            .url(serverUrl + "/suggestion")
            .addHeader("Authorization", "Bearer " + loginResponseManager.getJwtToken())
            .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), status.toString()))
            .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("call to get suggestion failed", e);
                clientThread.invoke(() -> onFailure.accept(new HttpResponseException(-1, "Unknown Error")));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        log.warn("get suggestion failed with http status code {}", response.code());
                        clientThread.invoke(() -> onFailure.accept(new HttpResponseException(response.code(), extractErrorMessage(response))));
                        return;
                    }
                    String body = response.body() == null ? "" : response.body().string();
                    Suggestion suggestion = gson.fromJson(body, Suggestion.class);
                    clientThread.invoke(() -> onSuccess.accept(suggestion));
                } catch (IOException | JsonParseException e) {
                    log.warn("error reading/parsing suggestion response body", e);
                    clientThread.invoke(() -> onFailure.accept(new HttpResponseException(-1, "Unknown Error")));
                }
            }
        });
    }

    public void sendTransactionsAsync(List<Transaction> transactions, String displayName, Consumer<List<FlipV2>> onSuccess, Consumer<HttpResponseException> onFailure) {
        log.debug("sending {} transactions for display name {}", transactions.size(), displayName);
        JsonArray body = new JsonArray();
        for (Transaction transaction : transactions) {
            body.add(transaction.toJsonObject());
        }
        String encodedDisplayName = URLEncoder.encode(displayName, StandardCharsets.UTF_8);
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/client-transactions?display_name=" + encodedDisplayName)
                .addHeader("Authorization", "Bearer " + loginResponseManager.getJwtToken())
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("call to sync transactions failed", e);
                onFailure.accept(new HttpResponseException(-1, "Unknown Error"));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        String errorMessage = extractErrorMessage(response);
                        log.warn("call to sync transactions failed status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(new HttpResponseException(response.code(), errorMessage));
                        return;
                    }
                    String body = response.body() == null ? "" : response.body().string();
                    List<FlipV2> changedFlips = gson.fromJson(body, new TypeToken<List<FlipV2>>(){}.getType());
                    onSuccess.accept(changedFlips);
                } catch (IOException | JsonParseException e) {
                    log.warn("error reading/parsing sync transactions response body", e);
                    onFailure.accept(new HttpResponseException(-1, "Unknown Error"));
                }
            }
        });
    }

    private String extractErrorMessage(Response response) {
        if (response.body() != null) {
            try {
                String bodyStr = response.body().string();
                JsonObject errorJson = gson.fromJson(bodyStr, JsonObject.class);
                if (errorJson.has("message")) {
                    return errorJson.get("message").getAsString();
                }
            } catch (JsonSyntaxException | IOException e) {
                log.warn("failed reading/parsing error message from http {} response body", response.code(), e);
            }
        }
        return "Unknown Error";
    }

    public void fetchItemPriceAsync(int itemId, String displayName, Consumer<ItemPrice> resultConsumer) {
        JsonObject body = new JsonObject();
        body.add("item_id", new JsonPrimitive(itemId));
        body.add("display_name", new JsonPrimitive(displayName));
        body.addProperty("f2p_only", preferencesManager.getPreferences().isF2pOnlyMode());

        Request request = new Request.Builder()
                .url(serverUrl + "/prices")
                .addHeader("Authorization", "Bearer " + loginResponseManager.getJwtToken())
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        ItemPrice failureResult = new ItemPrice(0, 0, "Unable to fetch price copilot price (possible server update)");

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("IO error on copilot price request for item {}", itemId, e);
                resultConsumer.accept(failureResult);
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        String errorMessage = extractErrorMessage(response);
                        log.error("error fetching copilot price for item {}, resp code {}, err msg {}", itemId, response.code(), errorMessage);
                        resultConsumer.accept(failureResult);
                        return;
                    }
                    String body = response.body() == null ? "" : response.body().string();
                    ItemPrice itemPrice = gson.fromJson(body, ItemPrice.class);
                    resultConsumer.accept(itemPrice);
                } catch (IOException | JsonParseException e) {
                    log.warn("error reading/parsing sync item price response body", e);
                    resultConsumer.accept(failureResult);
                }
            }
        });
    }

    public Map<String, Integer> loadUserDisplayNames() throws HttpResponseException {
        Type respType = new TypeToken<Map<String, Integer>>(){}.getType();
        Map<String, Integer> names = doHttpRequest("GET", null, "/profit-tracking/rs-account-names", respType);
        return names == null ? new HashMap<>() : names;
    }

    public List<FlipV2> LoadFlips() throws HttpResponseException {
        Type respType = new TypeToken<List<FlipV2>>(){}.getType();
        List<FlipV2> flips = doHttpRequest("GET", null, "/profit-tracking/client-flips", respType);
        return flips == null ? new ArrayList<>() : flips;
    }

    public <T> T doHttpRequest(String method, JsonElement bodyJson, String route, Type responseType) throws HttpResponseException {
        String jwtToken = loginResponseManager.getJwtToken();
        if (jwtToken == null) {
            throw new IllegalStateException("Not authenticated");
        }

        RequestBody body = bodyJson == null ? null : RequestBody.create(MediaType.get("application/json; charset=utf-8"), bodyJson.toString());
        Request request = new Request.Builder()
                .url(serverUrl + route)
                .addHeader("Authorization", "Bearer " + jwtToken)
                .method(method, body)
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                if (responseType == Void.class || response.body() == null) {
                    return null;
                }
                String responseBody = response.body().string();
                return gson.fromJson(responseBody, responseType);
            } else {
                throw new HttpResponseException(response.code(), extractErrorMessage(response));
            }
        } catch (JsonSyntaxException | IOException e) {
            throw new HttpResponseException(-1, "Unknown server error (possible system update)", e);
        }
    }

    public void sendDebugData(JsonObject bodyJson) {
        String jwtToken = loginResponseManager.getJwtToken();
        Instant now = Instant.now();
        if (now.minusSeconds(5).isBefore(lastDebugMessageSent)){
            // we don't want to spam
            return;
        }
        RequestBody body = RequestBody.create(MediaType.get("application/json; charset=utf-8"), bodyJson.toString());
        Request request = new Request.Builder()
                .url(serverUrl + "/debug-data")
                .addHeader("Authorization", "Bearer " + jwtToken)
                .method("POST", body)
                .build();
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
               log.debug("failed to send debug data", e);
            }
            @Override
            public void onResponse(Call call, Response response) {}
        });
        lastDebugMessageSent = Instant.now();
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.DiscordWebhookBody;
import com.flippingcopilot.model.SessionData;
import com.flippingcopilot.model.Stats;
import com.flippingcopilot.ui.UIUtilities;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.Instant;

import static com.flippingcopilot.ui.FlipPanel.formatEpoch;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class WebHookController {

    private final FlippingCopilotConfig config;
    private final OkHttpClient okHttpClient;

    private void sendWebHook(DiscordWebhookBody discordWebhookBody) {
        String configURL = config.webhook();
        if (Strings.isNullOrEmpty(configURL)) {return; }

        HttpUrl url = HttpUrl.parse(configURL);
        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(discordWebhookBody));
        buildRequestAndSend(url, requestBodyBuilder);
    }

    private void buildRequestAndSend(HttpUrl url, MultipartBody.Builder requestBodyBuilder) {
        RequestBody requestBody = requestBodyBuilder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
        sendRequest(request);
    }

    private void sendRequest(Request request) {
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Error on webhook", e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                response.close();
            }
        });
    }

    public void sendMessage(Stats stats, SessionData sd, String displayName, boolean sessionIsFinished) {
        if (stats.profit != 0 && displayName != null) {

            long seconds = sd.durationMillis / 1000;
            String beganAtText = formatEpoch(sd.startTime);
            String endedAtText = sessionIsFinished ? formatEpoch(Instant.now().getEpochSecond()) : "n/a";
            String durationText = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            String profitText = UIUtilities.formatProfit(stats.profit);
            String taxText = UIUtilities.formatProfit(stats.taxPaid);
            String roiText = String.format("%.3f%%", stats.calculateRoi() * 100);
            String cashStackText = UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp";

            String template = "%s, your session stats are:\n" +
                    "```" +
                    "Session began at:      %s\n" +
                    "Session ended at:      %s\n" +
                    "Active session time:   %s\n" +
                    "Flips made:            %d\n" +
                    "Profit:                %s\n" +
                    "Tax paid:              %s\n" +
                    "Roi:                   %s\n" +
                    "Avg wealth:            %s\n" +
                    "```";

            String discordMessage = String.format(template, displayName, beganAtText, endedAtText, durationText, stats.flipsMade, profitText, taxText, roiText, cashStackText);
            DiscordWebhookBody discordWebhookBody = new DiscordWebhookBody();
            discordWebhookBody.setContent(discordMessage);
            sendWebHook(discordWebhookBody);
        }
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.util.MutableReference;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class TransactionManger {

    // dependencies
    private final FlipManager flipManager;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler api;
    private final LoginResponseManager loginResponseManager;
    private final OsrsLoginManager osrsLoginManager;

    // state
    private final ConcurrentMap<String, List<Transaction>> cachedUnAckedTransactions = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, AtomicBoolean> transactionSyncScheduled = new ConcurrentHashMap<>();

    public void syncUnAckedTransactions(String displayName) {

        long s = System.nanoTime();
        List<Transaction> toSend;
        synchronized (this) {
            toSend = new ArrayList<>(getUnAckedTransactions(displayName));
            if(toSend.isEmpty()) {
                transactionSyncScheduled.get(displayName).set(false);
                return;
            }
        }

        Consumer<List<FlipV2>> onSuccess = (flips) -> {
            for (FlipV2 f : flips) {
                log.debug("server updated flip for {} closed qty {}, profit {}", f.getItemName(), f.getClosedQuantity(), f.getProfit());
            }
            flipManager.mergeFlips(flips, displayName);
            log.info("sending {} transactions took {}ms", toSend.size(), (System.nanoTime() - s) / 1000_000);
            synchronized (this) {
                List<Transaction> unAckedTransactions  = getUnAckedTransactions(displayName);
                transactionSyncScheduled.get(displayName).set(false);
                toSend.forEach(unAckedTransactions::remove);
                if(!unAckedTransactions.isEmpty()) {
                    scheduleSyncIn(0, displayName);
                }
            }
        };

        Consumer<HttpResponseException> onFailure = (e) -> {
            synchronized (this) {
                transactionSyncScheduled.get(displayName).set(false);
            }
            String currentDisplayName = osrsLoginManager.getPlayerDisplayName();
            if (loginResponseManager.isLoggedIn() && (currentDisplayName == null || currentDisplayName.equals(displayName))) {
                log.warn("failed to send transactions to copilot server {}", e.getMessage(), e);
                scheduleSyncIn(10, displayName);
            }
        };
        api.sendTransactionsAsync(toSend, displayName, onSuccess, onFailure);
    }

    public long addTransaction(Transaction transaction, String displayName) {
        synchronized (this) {
            List<Transaction> unAckedTransactions = getUnAckedTransactions(displayName);
            unAckedTransactions.add(transaction);
            Persistance.storeUnAckedTransactions(unAckedTransactions, displayName);
        }
        MutableReference<Long> profit = new MutableReference<>(0L);
        if (OfferStatus.SELL.equals(transaction.getType())) {
            profit.setValue(flipManager.estimateTransactionProfit(displayName, transaction));
        }
        if (loginResponseManager.isLoggedIn()) {
            scheduleSyncIn(0, displayName);
        }
        return profit.getValue();
    }

    private List<Transaction> getUnAckedTransactions(String displayName) {
        return cachedUnAckedTransactions.computeIfAbsent(displayName, (k) -> Persistance.loadUnAckedTransactions(displayName));
    }

    public synchronized void scheduleSyncIn(int seconds, String displayName) {
        AtomicBoolean scheduled = transactionSyncScheduled.computeIfAbsent(displayName, k -> new AtomicBoolean(false));
        if(scheduled.compareAndSet(false, true)) {
            log.info("scheduling {} attempt to sync {} transactions in {}s", displayName, getUnAckedTransactions(displayName).size(), seconds);
            executorService.schedule(() ->  {
                this.syncUnAckedTransactions(displayName);
            }, seconds, TimeUnit.SECONDS);
        } else {
            log.debug("skipping scheduling sync as already scheduled");
        }
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

import java.text.NumberFormat;

@Getter
@AllArgsConstructor
@ToString
public class Suggestion {
    private final String type;

    @SerializedName("box_id")
    private final int boxId;

    @SerializedName("item_id")
    private final int itemId;

    private final int price;

    private final int quantity;

    private final String name;

    @SerializedName("command_id")
    private final int id;

    private final String message;

    public static Suggestion fromJson(JsonObject json, Gson gson) {
        return gson.fromJson(json, Suggestion.class);
    }

    public boolean equals(Suggestion other) {
        return this.type.equals(other.type)
                && this.boxId == other.boxId
                && this.itemId == other.itemId
                && this.name.equals(other.name);
    }

    public String toMessage() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String string = "Flipping Copilot: ";
        switch (type) {
            case "buy":
                string += String.format("Buy %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "sell":
                string += String.format("Sell %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "abort":
                string += "Abort " + name;
                break;
            case "wait":
                string += "Wait";
                break;
            default:
                string += "Unknown suggestion type";
                break;
        }
        return string;
    }
}



package com.flippingcopilot.model;
import com.flippingcopilot.util.Constants;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


// note: we synchronize all public methods of this class as they read/modify its state and may
// be called by multiple threads at the same time

@Slf4j
@Data
public class AccountStatus {

    private StatusOfferList offers;
    private Inventory inventory;
    private Map<Integer, Long> uncollected;
    private boolean isMember = false;
    private int skipSuggestion = -1;
    private String displayName;
    private Long rsAccountHash;
    private Boolean suggestionsPaused;
    private boolean sellOnlyMode = false;
    private boolean f2pOnlyMode = false;
    private List<Integer> blockedItems;

    public AccountStatus() {
        offers = new StatusOfferList();
        inventory = new Inventory();
    }

    public synchronized boolean isCollectNeeded(Suggestion suggestion) {
        if (offers.isEmptySlotNeeded(suggestion)) {
            log.debug("collected needed isEmptySlotNeeded");
            return true;
        }
        if (!inventory.hasSufficientGp(suggestion)) {
            log.debug("collected needed hasSufficientGp");
            return true;
        }
        if (!inventory.hasSufficientItems(suggestion)) {
            log.debug("collected needed hasSufficientItems");
            return true;
        }
        return false;
    }

    public synchronized JsonObject toJson(Gson gson, boolean geOpen) {
        JsonObject statusJson = new JsonObject();
        statusJson.addProperty("display_name", displayName);
        statusJson.addProperty("sell_only", sellOnlyMode);
        statusJson.addProperty("f2p_only", f2pOnlyMode);
        statusJson.addProperty("is_member", isMember);
        statusJson.addProperty("skip_suggestion", skipSuggestion);
        if (suggestionsPaused != null) {
            statusJson.addProperty("suggestions_paused", suggestionsPaused);
        }
        JsonArray offersJsonArray = offers.toJson(gson);
        JsonArray itemsJsonArray = getItemsJson();
        statusJson.add("offers", offersJsonArray);
        statusJson.add("items", itemsJsonArray);
        JsonArray blockItemsArray = new JsonArray();
        if(blockedItems != null) {
            blockedItems.forEach(blockItemsArray::add);
        }
        statusJson.add("blocked_items", blockItemsArray);

        Set<String> requestedSuggestionTypes = new HashSet<>();
        if (!geOpen) {
            requestedSuggestionTypes.add("abort");
            requestedSuggestionTypes.add("sell");
        }
        if(sellOnlyMode) {
            requestedSuggestionTypes.clear();
            requestedSuggestionTypes.add("abort");
            requestedSuggestionTypes.add("sell");
        }
        if(!requestedSuggestionTypes.isEmpty()) {
           JsonArray rstArray = new JsonArray();
           requestedSuggestionTypes.forEach(rstArray::add);
           statusJson.add("requested_suggestion_types", rstArray);
        }
        return statusJson;
    }

    private JsonArray getItemsJson() {
        Map<Integer, Long> itemsAmount = getItemAmounts();
        JsonArray itemsJsonArray = new JsonArray();
        for(Map.Entry<Integer, Long> entry : itemsAmount.entrySet()) {
            JsonObject itemJson = new JsonObject();
            itemJson.addProperty("item_id", entry.getKey());
            itemJson.addProperty("amount", entry.getValue());
            itemsJsonArray.add(itemJson);
        }
        return itemsJsonArray;
    }

    private Map<Integer, Long> getItemAmounts() {
        Map<Integer, Long> itemsAmount = inventory.getItemAmounts();
        uncollected.forEach((key, value) -> itemsAmount.merge(key, value, Long::sum));
        itemsAmount.entrySet().removeIf(entry -> entry.getValue() == 0);
        return itemsAmount;
    }

    public synchronized boolean moreGpNeeded() {
        return offers.emptySlotExists() && getTotalGp() < Constants.MIN_GP_NEEDED_TO_FLIP;
    }

    public synchronized boolean emptySlotExists() {
        return offers.emptySlotExists();
    }

    private long getTotalGp() {
        return inventory.getTotalGp() + offers.getTotalGpToCollect();
    }

    public synchronized boolean currentlyFlipping() {
        return offers.stream().anyMatch(Offer::isActive);
    }

    public synchronized long currentCashStack() {
        // the cash stack is the gp in their inventory + the value on the market
        // todo: when a buy offer has fully finished its value will not count towards the cash stack
        //  size until they start selling it. We should probably track items that where recently bought
        //  and they should still count towards the cash stack size for some period of time
        return offers.getGpOnMarket() + inventory.getTotalGp();
    }
}

package com.flippingcopilot.model;

import lombok.Getter;

import java.io.IOException;

@Getter
public class HttpResponseException extends IOException {
    private final int responseCode;
    private final String responseMessage;

    public HttpResponseException(int responseCode, String message) {
        super(message);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }

    public HttpResponseException(int responseCode, String message, Throwable cause) {
        super(message, cause);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }
}
package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.ui.FuzzySearchScorer;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collectors;
import java.util.stream.IntStream;


@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SuggestionPreferencesManager {

    private static final String SUGGESTION_PREFERENCES_FILE_TEMPLATE = "acc_%d_preferences.json";

    // dependencies
    private final Gson gson;
    private final OsrsLoginManager osrsLoginManager;
    private final FuzzySearchScorer fuzzySearchScorer;
    private final Client client;
    private final ItemManager itemManager;
    private final ScheduledExecutorService executorService;

    // state
    private final Map<Long, SuggestionPreferences> cached = new HashMap<>();
    private final Map<Long, File> accountHashToFile = new HashMap<>();
    
    public synchronized SuggestionPreferences getPreferences() {
        Long accountHash = osrsLoginManager.getAccountHash();
        return cached.computeIfAbsent(accountHash, this::load);
    }

    public synchronized void setSellOnlyMode(boolean sellOnlyMode) {
        Long accountHash = osrsLoginManager.getAccountHash();
        SuggestionPreferences preferences = cached.computeIfAbsent(accountHash, this::load);
        preferences.setSellOnlyMode(sellOnlyMode);
        saveAsync(accountHash);
        log.debug("Sell only mode is now: {}", sellOnlyMode);
    }
    public synchronized void setF2pOnlyMode(boolean f2pOnlyMode) {
        Long accountHash = osrsLoginManager.getAccountHash();
        SuggestionPreferences preferences = cached.computeIfAbsent(accountHash, this::load);
        preferences.setF2pOnlyMode(f2pOnlyMode);
        saveAsync(accountHash);
        log.debug("F2p only mode is now: {}", f2pOnlyMode);
    }

    public synchronized void blockItem(int itemId) {
        Long accountHash = osrsLoginManager.getAccountHash();
        SuggestionPreferences preferences = cached.computeIfAbsent(accountHash, this::load);
        List<Integer> blockedList = preferences.getBlockedItemIds();
        if(blockedList == null) {
            blockedList = new ArrayList<>();
        }
        if(!blockedList.contains(itemId)) {
            blockedList.add(itemId);
        }
        preferences.setBlockedItemIds(blockedList);
        saveAsync(accountHash);
        log.debug("blocked item {}", itemId);
    }

    public synchronized void unblockItem(int itemId) {
        Long accountHash = osrsLoginManager.getAccountHash();
        SuggestionPreferences preferences = cached.computeIfAbsent(accountHash, this::load);
        List<Integer> blockedList = preferences.getBlockedItemIds();
        if(blockedList == null) {
            blockedList = new ArrayList<>();
        }
        blockedList.removeIf(i -> i==itemId);
        preferences.setBlockedItemIds(blockedList);
        saveAsync(accountHash);
        log.debug("unblocked item {}", itemId);
    }

    public List<Pair<Integer, String>> search(String input) {
        Set<Integer> blockedItems = new HashSet<>(blockedItems());
        if(input == null || input.isBlank()) {
            return IntStream.range(0, client.getItemCount())
                    .mapToObj(itemManager::getItemComposition)
                    .filter(item -> item.isTradeable() && item.getNote() == -1)
                    .sorted(Comparator.comparing((ItemComposition i) -> !blockedItems.contains(i.getId())).thenComparing(ItemComposition::getName))
                    .limit(250)
                    .map((i) -> Pair.of(i.getId(), trimName(i.getName())))
                    .collect(Collectors.toList());
        }

        ToDoubleFunction<ItemComposition> comparator = fuzzySearchScorer.comparator(input);
        return IntStream.range(0, client.getItemCount())
            .mapToObj(itemManager::getItemComposition)
            .filter(item -> item.isTradeable() && item.getNote() == -1)
            .filter(item -> comparator.applyAsDouble(item) > 0)
            .sorted(Comparator.comparing((ItemComposition i) -> !blockedItems.contains(i.getId())).thenComparing(Comparator.comparingDouble(comparator).reversed()
                    .thenComparing(ItemComposition::getName)))
            .limit(250)
            .map((i) -> Pair.of(i.getId(), trimName(i.getName())))
            .collect(Collectors.toList());
    }

    public List<Integer> blockedItems() {
        return getPreferences().getBlockedItemIds();
    }

    private String trimName(String name) {
        if(name.length() > 23) {
            return name.substring(0, 23) + "..";
        }
        return name;
    }

    private SuggestionPreferences load(Long accountHash) {
        File file = getFile(accountHash);
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, SuggestionPreferences.class);
        } catch (FileNotFoundException ignored) {
            return new SuggestionPreferences();
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading preferences json file {}", file, e);
            return new SuggestionPreferences();
        }
    }

    private void saveAsync(Long accountHash) {
        executorService.submit(() -> {
            File file = getFile(accountHash);
            synchronized (file) {
                SuggestionPreferences p = cached.computeIfAbsent(accountHash, this::load);
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(p);
                    writer.write(json);
                    writer.newLine();
                } catch (IOException e) {
                    log.warn("error saving preferences json file {}", file, e);
                }
            }
        });
    }

    private File getFile(Long accountHash) {
        return accountHashToFile.computeIfAbsent(accountHash,
                (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(SUGGESTION_PREFERENCES_FILE_TEMPLATE, accountHash)));
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SessionManager {

    public static final String SESSION_DATA_FILE_TEMPLATE = "%s_session_data.jsonl";

    private final OsrsLoginManager osrsLoginManager;
    private final ScheduledExecutorService executorService;
    private final Gson gson;

    private final Map<String, SessionData> cachedSessionData =  new HashMap<>();
    private final Map<String, File> displayNameToFile = new HashMap<>();

    private Instant lastSessionUpdateTime;

    public synchronized SessionData getCachedSessionData() {
        SessionData sd = getSessionData(osrsLoginManager.getPlayerDisplayName());
        return new SessionData(sd.startTime,  sd.durationMillis, sd.averageCash);
    }

    public synchronized void resetSession() {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        SessionData sd = getSessionData(displayName);
        sd.startTime = (int) Instant.now().getEpochSecond();
        sd.averageCash = 0;
        sd.durationMillis = 0;
        saveAsync(displayName);
    }

    public synchronized boolean updateSessionStats(boolean currentlyFlipping, long cashStack) {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        if (!currentlyFlipping || displayName == null) {
            lastSessionUpdateTime = null;
            return false;
        } else if (lastSessionUpdateTime == null) {
            lastSessionUpdateTime = Instant.now();
            return false;
        } else {
            SessionData sd = getSessionData(displayName);
            Instant now = Instant.now();
            long duration = Duration.between(lastSessionUpdateTime, now).toMillis();
            long newAverageCashStack = (cashStack * duration + sd.durationMillis * sd.averageCash) / (sd.durationMillis + duration);
            sd.durationMillis = sd.durationMillis + duration;
            lastSessionUpdateTime = now;
            sd.averageCash = newAverageCashStack;
            saveAsync(displayName);
            return true;
        }
    }

    private void saveAsync(String displayName) {
        executorService.submit(() -> {
            File file = getFile(displayName);
            synchronized (file) {
                SessionData data = cachedSessionData.computeIfAbsent(displayName, this::load);
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(data);
                    writer.write(json);
                    writer.newLine();
                } catch (IOException e) {
                    log.warn("error storing session data to file {}", file, e);
                }
            }
        });
    }

     private SessionData load(String displayName) {
        File file = getFile(displayName);
        if (!file.exists()) {
            return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            SessionData sd =  gson.fromJson(reader, SessionData.class);
            if (sd != null) {
                return sd;
            }
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading session data json file {}", file, e);
        }
        return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
    }

    private File getFile(String displayName) {
        return displayNameToFile.computeIfAbsent(displayName,
                (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(SESSION_DATA_FILE_TEMPLATE, Persistance.hashDisplayName(displayName))));
    }

    private SessionData getSessionData(String displayName) {
         return cachedSessionData.computeIfAbsent(displayName, this::load);
    }

    public synchronized void reset() {
        lastSessionUpdateTime = null;
    }
}

package com.flippingcopilot.model;

import lombok.Getter;
import lombok.Setter;

import javax.inject.Singleton;
import java.time.Instant;

@Singleton
@Getter
@Setter
public class SuggestionManager {

    private volatile boolean suggestionNeeded;
    private volatile boolean suggestionRequestInProgress;
    private Instant lastFailureAt;
    private HttpResponseException suggestionError;
    private Suggestion suggestion;
    private Instant suggestionReceivedAt;
    private int lastOfferSubmittedTick = -1;

    // these two variables get set based on the current suggestion when the confirm offer button is clicked.
    // this allows us to track on the subsequent offer events whether the offer originates from a copilot suggestion
    // this flag can then eventually be propagated onto each transaction and can be used by the server to
    // determine which items in the inventory were bought based upon copilot suggestions and which are not
    private int suggestionItemIdOnOfferSubmitted = -1;
    private OfferStatus suggestionOfferStatusOnOfferSubmitted = null;


    public void setSuggestion(Suggestion suggestion) {
        this.suggestion = suggestion;
        suggestionReceivedAt = Instant.now();
    }

    public void setSuggestionError(HttpResponseException error) {
        this.suggestionError = error;
        lastFailureAt= Instant.now();
    }

    public void reset() {
        suggestionNeeded = false;
        suggestion = null;
        suggestionReceivedAt = null;
        lastFailureAt = null;
        lastOfferSubmittedTick = -1;
        suggestionError = null;
        suggestionItemIdOnOfferSubmitted = -1;
        suggestionOfferStatusOnOfferSubmitted = null;
    }

    public boolean suggestionOutOfDate() {
        Instant tenSecondsAgo = Instant.now().minusSeconds(10L);
        if (suggestionReceivedAt == null || tenSecondsAgo.isAfter(suggestionReceivedAt)) {
            return lastFailureAt == null || tenSecondsAgo.isAfter(lastFailureAt);
        }
        return false;
    }
}

package com.flippingcopilot.model;

import net.runelite.api.*;
import net.runelite.api.ItemID;
import static com.flippingcopilot.util.Constants.PLATINUM_TOKEN_VALUE;

import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Collectors;


public class Inventory extends ArrayList<RSItem> {

    boolean hasSufficientGp(Suggestion suggestion) {
        return !suggestion.getType().equals("buy")
                || getTotalGp() >= (long) suggestion.getPrice() * suggestion.getQuantity();
    }

    boolean hasSufficientItems(Suggestion suggestion) {
        return !suggestion.getType().equals("sell")
                || getTotalAmount(suggestion.getItemId()) >= suggestion.getQuantity();
    }

    public long getTotalGp() {
        return getTotalAmount(ItemID.COINS_995) + PLATINUM_TOKEN_VALUE * getTotalAmount(ItemID.PLATINUM_TOKEN);
    }

    public long getTotalAmount(long itemId) {
        long amount = 0;
        for (RSItem item : this) {
            if (item.getId() == itemId) {
                amount += item.getAmount();
            }
        }
        return amount;
    }


    public static Inventory fromRunelite(ItemContainer inventory, Client client) {
        Inventory unnotedItems = new Inventory();
        Item[] items = inventory.getItems();
        for (Item item : items) {
            if (item.getId() == -1) {
                continue;
            }
            unnotedItems.add(RSItem.getUnnoted(item, client));
        }
        return unnotedItems;
    }

    Map<Integer, Long> getItemAmounts() {
        return stream().collect(Collectors.groupingBy(RSItem::getId,
                        Collectors.summingLong(RSItem::getAmount)));
    }

    public void mergeItem(RSItem i) {
        for(RSItem item : this) {
            if(item.id == i.id) {
                item.amount += i.amount;
                return;
            }
        }
        add(i);
    }

     public boolean missingJustCollected( Map<Integer, Long> inLimboItems) {
         for (Map.Entry<Integer, Long> entry : inLimboItems.entrySet()) {
             Integer itemId = entry.getKey();
             Long qty = entry.getValue();
             if (qty > 0) {
                 long inventoryQty = getTotalAmount(itemId);
                 if (inventoryQty < qty) {
                     return true;
                 }
             }
         }
         return false;
    }
}

package com.flippingcopilot.model;

import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
public class SuggestionPreferences {

    private boolean f2pOnlyMode = false;
    private boolean sellOnlyMode = false;
    private List<Integer> blockedItemIds = new ArrayList<>();
}

package com.flippingcopilot.model;

import com.flippingcopilot.util.GeTax;
import com.google.gson.annotations.SerializedName;
import lombok.Data;
import java.util.Comparator;
import java.util.UUID;

@Data
public class FlipV2 {

    public static UUID MAX_UUID = new UUID(-1L, -1L);
    public static UUID MIN_UUID = new UUID(0L, 0L);

    @SerializedName("id")
    private UUID id;

    @SerializedName("account_id")
    private int accountId;

    @SerializedName("item_id")
    private int itemId;

    @SerializedName("item_name")
    private String itemName;

    @SerializedName("opened_time")
    private int openedTime;

    @SerializedName("opened_quantity")
    private int openedQuantity;

    @SerializedName("spent")
    private long spent;

    @SerializedName("closed_time")
    private int closedTime;

    @SerializedName("closed_quantity")
    private int closedQuantity;

    @SerializedName("received_post_tax")
    private long receivedPostTax;

    @SerializedName("profit")
    private long profit;

    @SerializedName("tax_paid")
    private long taxPaid;

    @SerializedName("is_closed")
    private boolean isClosed;

    private String accountDisplayName;

    public long calculateProfit(Transaction transaction) {
        long amountToClose = Math.min(openedQuantity - closedQuantity, transaction.getQuantity());
        if(amountToClose <= 0 ){
            return 0;
        }
        long gpOut = (spent * amountToClose) / openedQuantity;
        int sellPrice  = transaction.getAmountSpent() / transaction.getQuantity();
        int sellPricePostTax = GeTax.getPostTaxPrice(transaction.getItemId(), sellPrice);
        long gpIn = amountToClose * sellPricePostTax;
        return gpIn - gpOut;
    }

    public long getAvgBuyPrice() {
        if (spent == 0) {
            return 0;
        }
        return spent / openedQuantity ;
    }

    public long getAvgSellPrice() {
        if (receivedPostTax == 0) {
            return 0;
        }
        return (receivedPostTax  + taxPaid) / closedQuantity;
    }
}

package com.flippingcopilot.model;

import lombok.Data;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;

import java.util.Objects;

@Data
public class SavedOffer
{
	private int itemId;
	private int quantitySold;
	private int totalQuantity;
	private int price;
	private int spent;
	private GrandExchangeOfferState state;
	private boolean copilotPriceUsed;
	private boolean wasCopilotSuggestion;


	public static SavedOffer fromGrandExchangeOffer(GrandExchangeOffer offer) {
		SavedOffer o =  new SavedOffer();
		o.setItemId(offer.getItemId());
		o.setQuantitySold(offer.getQuantitySold());
		o.setTotalQuantity(offer.getTotalQuantity());
		o.setPrice(offer.getPrice());
		o.setSpent(offer.getSpent());
		o.setState(offer.getState());
		return o;
	}

	public OfferStatus getOfferStatus() {
		switch (state) {
			case SELLING:
			case CANCELLED_SELL:
			case SOLD:
				return OfferStatus.SELL;
			case BUYING:
			case CANCELLED_BUY:
			case BOUGHT:
				return OfferStatus.BUY;
			default:
				return OfferStatus.EMPTY;
		}
	}

	public boolean isFreeSlot() {
		switch (state) {
			case CANCELLED_SELL:
			case CANCELLED_BUY:
			case EMPTY:
			case BOUGHT:
			case SOLD:
				return true;
			default:
				return false;
		}
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		SavedOffer that = (SavedOffer) o;
		return itemId == that.itemId && quantitySold == that.quantitySold && totalQuantity == that.totalQuantity && price == that.price && spent == that.spent && state == that.state;
	}

	@Override
	public int hashCode() {
		return Objects.hash(itemId, quantitySold, totalQuantity, price, spent, state, copilotPriceUsed);
	}
}

package com.flippingcopilot.model;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;

@Getter
@AllArgsConstructor
public class RSItem {
    int id;
    long amount;

    static RSItem getUnnoted(Item item, Client client) {
        int itemId = item.getId();
        ItemComposition itemComposition = client.getItemDefinition(itemId);
        if (itemComposition.getNote() != -1) {
            itemId = itemComposition.getLinkedNoteId();
        }
        return new RSItem(itemId, item.getQuantity());
    }
}
package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import net.runelite.api.GrandExchangeOfferState;

public enum OfferStatus {
    @SerializedName("sell")
    SELL,
    @SerializedName("buy")
    BUY,
    @SerializedName("empty")
    EMPTY;

    static OfferStatus fromRunelite(GrandExchangeOfferState state) {
        OfferStatus status;
        switch (state) {
            case SELLING:
            case CANCELLED_SELL:
            case SOLD:
                status = SELL;
                break;
            case BUYING:
            case CANCELLED_BUY:
            case BOUGHT:
                status = BUY;
                break;
            default:
                status = EMPTY;
        }
        return status;
    }
}

package com.flippingcopilot.model;

import com.google.gson.JsonObject;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;


@Getter
@AllArgsConstructor
@NoArgsConstructor
@Setter
public class Transaction {

    private UUID id;
    private OfferStatus type;
    private int itemId;
    private int price;
    private int quantity;
    private int boxId;
    private int amountSpent;
    private Instant timestamp;
    private boolean copilotPriceUsed;
    private boolean wasCopilotSuggestion;
    private int offerTotalQuantity;
    private boolean login;
    private boolean consistent;

    public boolean equals(Transaction other) {
        return this.type == other.type &&
                this.itemId == other.itemId &&
                this.price == other.price &&
                this.quantity == other.quantity &&
                this.boxId == other.boxId &&
                this.amountSpent == other.amountSpent;
    }

    public JsonObject toJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty("id", id.toString());
        jsonObject.addProperty("item_id", itemId);
        jsonObject.addProperty("price", price);
        jsonObject.addProperty("quantity", type.equals(OfferStatus.BUY) ? quantity : -quantity);
        jsonObject.addProperty("box_id", boxId);
        jsonObject.addProperty("amount_spent", amountSpent);
        jsonObject.addProperty("time", timestamp.getEpochSecond());
        jsonObject.addProperty("copilot_price_used", copilotPriceUsed);
        jsonObject.addProperty("was_copilot_suggestion", wasCopilotSuggestion);
        jsonObject.addProperty("consistent_previous_offer", consistent);
        jsonObject.addProperty("login", login);
        return jsonObject;
    }

    @Override
    public String toString() {
        return String.format("%s %d %d on slot %d", type, quantity, itemId, boxId);
    }
}



package com.flippingcopilot.model;

import com.flippingcopilot.util.MutableReference;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemID;

import java.util.*;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @javax.inject.Inject)
public class GrandExchangeUncollectedManager {

    // dependencies
    private final Client client;

    // stated
    private int lastUncollectedAddedTick = -1;
    private int lastClearedTick = -1;
    private final Map<Integer, Long> lastClearedUncollected = new HashMap<>();
    private final List<Integer> lastClearedSlots = new ArrayList<>();
    // accountId -> [slot -> [itemID -> quantity]]
    private final Map<Long, Map<Integer, Map<Integer, Long>>> uncollected = new HashMap<>();

    public synchronized boolean HasUncollected(Long accountHash) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        MutableReference<Boolean> hasUncollected = new MutableReference<>(false);
        slotToUncollected.forEach((slot, itemToQty) -> {
            itemToQty.forEach((i, q) -> {
                if(q > 0) {
                    log.debug("{} slot {} item {} uncollected {}", accountHash, slot, i, q);
                    hasUncollected.setValue(true);
                }
            });
        });
        return hasUncollected.getValue();
    }

    public synchronized Map<Integer, Long> loadAllUncollected(Long accountHash) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        Map<Integer, Long> itemIdToQuantity = new HashMap<>();
        slotToUncollected.values().forEach(itemIdToQty -> itemIdToQty.forEach((k, v) -> itemIdToQuantity.merge(k, v, Long::sum)));
        return itemIdToQuantity;
    }

    public synchronized Map<Integer, Long> loadSlotUncollected(Long accountHash, Integer slot) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToUncollected.computeIfAbsent(slot, (k) -> new HashMap<>());
    }

    public synchronized void addUncollected(Long accountHash, Integer slot, int itemId, long quantity, long gp) {
        lastUncollectedAddedTick = client.getTickCount();
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        Map<Integer, Long> itemIdToQuantity = slotToUncollected.computeIfAbsent(slot, (k) -> new HashMap<>());
        if (!itemIdToQuantity.containsKey(itemId)) {
           // must be a new offer
           itemIdToQuantity.clear();
        }
        if(quantity > 0) {
            log.debug("tick {} added {} of item {} to uncollected", client.getTickCount(), itemId, quantity);
            itemIdToQuantity.merge(itemId, quantity, Long::sum);
        }
        if (gp > 0) {
            log.debug("tick {} added {} gp to uncollected", client.getTickCount(), gp);
            itemIdToQuantity.merge(ItemID.COINS_995, gp, Long::sum);
        }
    }

    public synchronized void ensureSlotClear(Long accountHash, int slot) {
        Map<Integer, Long> slotUncollected = loadSlotUncollected(accountHash, slot);
        slotUncollected.remove(slot);
    }

    public synchronized void clearSlotUncollected(Long accountHash, int slot) {
        Map<Integer, Long> slotUncollected = loadSlotUncollected(accountHash, slot);
        int tick = client.getTickCount();
        if(tick != lastClearedTick) {
            lastClearedUncollected.clear();
            lastClearedSlots.clear();
            lastClearedTick = tick;
        }
        lastClearedSlots.add(slot);
        slotUncollected.forEach((key, value) -> lastClearedUncollected.merge(key, value, Long::sum));
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        slotToUncollected.remove(slot);
    }

    public synchronized void clearAllUncollected(Long accountHash) {
        log.debug("tick {} clearAllUncollected", client.getTickCount());
        Map<Integer, Long> allUncollected = loadAllUncollected(accountHash);
        int tick = client.getTickCount();
        if(tick != lastClearedTick) {
            lastClearedUncollected.clear();
            lastClearedSlots.clear();
            lastClearedTick = tick;
        }
        lastClearedSlots.addAll(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7));
        allUncollected.forEach((key, value) -> {
            if(value > 0) {
                log.debug("tick {} cleared item {}, qty {}", client.getTickCount(), key, value);
                lastClearedUncollected.merge(key, value, Long::sum);
            }
        });
        uncollected.remove(accountHash);
    }

    public synchronized int getLastClearedTick() {
        return lastClearedTick;
    }

    public synchronized Map<Integer, Long> getLastClearedUncollected() {
        return lastClearedUncollected;
    }

    public synchronized List<Integer> getLastClearedSlots() {
        return lastClearedSlots;
    }

    public synchronized int getLastUncollectedAddedTick() {
        return lastUncollectedAddedTick;
    }

    public synchronized void reset() {
        lastClearedUncollected.clear();
        lastClearedTick = -1;
        lastUncollectedAddedTick = -1;
        uncollected.clear();
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.runelite.api.GrandExchangeOffer;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;


public class StatusOfferList extends ArrayList<Offer> {
    public static final int NUM_SLOTS = 8;

    public StatusOfferList() {
        super(NUM_SLOTS);
        for (int i = 0; i < NUM_SLOTS; i++) {
            add(Offer.getEmptyOffer(i));
        }
    }

    public static StatusOfferList fromRunelite(GrandExchangeOffer[] runeliteOffers) {
        StatusOfferList offers = new StatusOfferList();
        for (int i = 0; i < runeliteOffers.length; i++) {
            offers.set(i, Offer.fromRunelite(runeliteOffers[i], i));
        }
        return offers;
    }

    public boolean isEmptySlotNeeded(Suggestion suggestion) {
        return (suggestion.getType().equals("buy") || suggestion.getType().equals("sell"))
                && !emptySlotExists();
    }

    boolean emptySlotExists() {
        return stream().anyMatch(offer -> offer.getStatus() == OfferStatus.EMPTY);
    }

    public long getGpOnMarket() {
        return stream().mapToLong(Offer::cashStackGpValue).sum();
    }

    public long getTotalGpToCollect() {
        return stream().mapToLong(Offer::getGpToCollect).sum();
    }

    JsonArray toJson(Gson gson) {
        List<JsonObject> list = stream()
                .map(offer -> offer.toJson(gson))
                .collect(Collectors.toList());
        JsonArray jsonArray = new JsonArray();
        list.forEach(jsonArray::add);
        return jsonArray;
    }

    public int findEmptySlot() {
        for (int i = 0; i < NUM_SLOTS; i++) {
            if (get(i).getStatus() == OfferStatus.EMPTY) {
                return i;
            }
        }
        return -1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

@Getter
@AllArgsConstructor
@ToString
public class ItemPrice {
    @SerializedName("sell_price")
    private final int sellPrice;

    @SerializedName("buy_price")
    private final int buyPrice;
    private final String message;

    public static ItemPrice fromJson(JsonObject json, Gson gson) {
        return gson.fromJson(json, ItemPrice.class);
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class LoginResponse {
    public boolean error;
    public String message;
    public String jwt;

    @SerializedName("user_id")
    public int userId;
}

package com.flippingcopilot.model;

import lombok.Getter;

@Getter
public enum IntervalTimeUnit {

    ALL(-1),
    SESSION(-1),
    HOUR(3600),
    DAY(86400),
    WEEK(604800),
    MONTH(2592000),
    YEAR(31536000);

    private final int seconds;;

    IntervalTimeUnit(int seconds) {
        this.seconds = seconds;
    }

    public static IntervalTimeUnit fromString(String str) {
        switch (str) {
            case "h":
                return IntervalTimeUnit.HOUR;
            case "d":
                return IntervalTimeUnit.DAY;
            case "w":
                return IntervalTimeUnit.WEEK;
            case "m":
                return IntervalTimeUnit.MONTH;
            case "y":
                return IntervalTimeUnit.YEAR;
            default:
                return IntervalTimeUnit.ALL;
        }
    }
}

package com.flippingcopilot.model;

import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.List;
import java.util.Map;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class AccountStatusManager {

    // dependencies
    private final Client client;
    private final OsrsLoginManager osrsLoginManager;
    private final GrandExchangeUncollectedManager geUncollected;
    private final SuggestionPreferencesManager suggestionPreferencesManager;
    private final PausedManager pausedManager;

    // state
    @Setter
    private int skipSuggestion = -1;

    public synchronized AccountStatus getAccountStatus() {
        Long accountHash =  osrsLoginManager.getAccountHash();
        ItemContainer itemContainer = client.getItemContainer(InventoryID.INVENTORY);
        if(itemContainer == null) {
            log.warn("unable to fetch inventory item container");
            return null;
        }
        Inventory inventory = Inventory.fromRunelite(itemContainer, client);
        Map<Integer, Long> u = geUncollected.loadAllUncollected(accountHash);

        GrandExchangeOffer[] geOffers = client.getGrandExchangeOffers();
        StatusOfferList offerList = StatusOfferList.fromRunelite(geOffers);

        AccountStatus status = new AccountStatus();
        status.setOffers(offerList);
        status.setInventory(inventory);
        status.setUncollected(u);
        status.setDisplayName(osrsLoginManager.getPlayerDisplayName());
        status.setRsAccountHash(accountHash);
        status.setSkipSuggestion(skipSuggestion);
        status.setSellOnlyMode(suggestionPreferencesManager.getPreferences().isSellOnlyMode());
        status.setF2pOnlyMode(suggestionPreferencesManager.getPreferences().isF2pOnlyMode());
        status.setMember(osrsLoginManager.isMembersWorld());
        status.setSuggestionsPaused(pausedManager.isPaused());
        status.setBlockedItems(suggestionPreferencesManager.blockedItems());

        Map<Integer, Long> inLimboItems = geUncollected.getLastClearedUncollected();
        List<Integer> clearedSlots = geUncollected.getLastClearedSlots();
        if (geUncollected.getLastClearedTick() == client.getTickCount()) {
            log.debug("tick {} in limbo items {}, cleared slots {}", client.getTickCount(), inLimboItems, clearedSlots);
            if(inventory.missingJustCollected(inLimboItems)) {
                inLimboItems.forEach((itemId, qty) -> {
                    if (qty > 0) {
                        log.debug("tick {} move in limbo item {}, qty {} to inventory", client.getTickCount(), itemId, qty);
                        inventory.mergeItem(new RSItem(itemId, qty));
                    }
                });
            }
            for (Integer slot : clearedSlots) {
                Offer o = offerList.get(slot);
                GrandExchangeOffer geOffer = geOffers[slot];
                if (!isActive(geOffer.getState()) && geOffer.getState() != GrandExchangeOfferState.EMPTY) {
                    log.debug("tick {} in-activate slot {} just collected setting to EMPTY", client.getTickCount(), slot);
                    o.setStatus(OfferStatus.EMPTY);
                }
            }
        }

        return status;
    }

    private boolean isActive(GrandExchangeOfferState state) {
        switch (state){
            case EMPTY:
            case CANCELLED_BUY:
            case CANCELLED_SELL:
            case BOUGHT:
            case SOLD:
                return false;
            default:
                return true;
        }
    }

    public boolean isSuggestionSkipped() {
        return skipSuggestion != -1;
    }

    public void resetSkipSuggestion() {
        skipSuggestion = -1;
    }

    public void reset() {
        skipSuggestion = -1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;


@Getter
@AllArgsConstructor
@EqualsAndHashCode
public class Offer {

    @Setter
    private OfferStatus status;

    @SerializedName("item_id")
    private int itemId;

    private int price;

    @SerializedName("amount_total")
    private int amountTotal;

    @SerializedName("amount_spent")
    private int amountSpent;

    @SerializedName("amount_traded")
    private int amountTraded;

    @SerializedName("items_to_collect")
    private int itemsToCollect;

    @SerializedName("gp_to_collect")
    private int gpToCollect;

    @SerializedName("box_id")
    private int boxId;

    private boolean active;

    @Setter
    @SerializedName("copilot_price_used")
    private boolean copilotPriceUsed;

    public static Offer getEmptyOffer(int slotId) {
        return new Offer(OfferStatus.EMPTY, 0, 0, 0, 0, 0, 0, 0, slotId, false, false);
    }


    public long cashStackGpValue() {
        if (status == OfferStatus.SELL) {
            return (long) (amountTotal - amountTraded) * price + gpToCollect;
        } else if (status == OfferStatus.BUY){
            // for a buy just take the full amount even if they have collected
            // we assume they won't start selling any collected items until their buy offer is finished
            return (long) amountTotal * price;
        } else {
            return 0;
        }
    }


    public static Offer fromRunelite(GrandExchangeOffer runeliteOffer, int slotId) {
        OfferStatus status = OfferStatus.fromRunelite(runeliteOffer.getState());
        boolean active = runeliteOffer.getState().equals(GrandExchangeOfferState.BUYING)
                || runeliteOffer.getState().equals(GrandExchangeOfferState.SELLING);
        return new Offer(status,
                runeliteOffer.getItemId(),
                runeliteOffer.getPrice(),
                runeliteOffer.getTotalQuantity(),
                runeliteOffer.getSpent(),
                runeliteOffer.getQuantitySold(),
                0,
                0,
                slotId,
                active,
                false);
    }


    JsonObject toJson(Gson gson) {
        JsonParser jsonParser = new JsonParser();
        return jsonParser.parse(gson.toJson(this)).getAsJsonObject();
    }

}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.file.Files;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class LoginResponseManager {

    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";

    private final File file = new File(Persistance.PARENT_DIRECTORY, LOGIN_RESPONSE_JSON_FILE);

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    private LoginResponse cachedLoginResponse;

    public synchronized LoginResponse getLoginResponse() {
        if(cachedLoginResponse != null) {
            return cachedLoginResponse;
        }
        cachedLoginResponse = load();
        return cachedLoginResponse;
    }

    public synchronized void setLoginResponse(LoginResponse loginResponse) {
        if (loginResponse == null) {
            return;
        }
        cachedLoginResponse = loginResponse;
        saveAsync();
    }

    public boolean isLoggedIn() {
        LoginResponse loginResponse = getLoginResponse();
        return loginResponse != null && !loginResponse.error && !Strings.isNullOrEmpty(loginResponse.jwt);
    }

    public void reset() {
        cachedLoginResponse = null;
        if (file.exists()) {
            if(!file.delete()) {
                log.warn("failed to delete login response file {}", file);
            }
        }
    }

    public void saveAsync() {
        executorService.submit(() -> {
            synchronized (file) {
                LoginResponse loginResponse = getLoginResponse();
                if (loginResponse != null) {
                    try {
                        String json = gson.toJson(loginResponse);
                        Files.write(file.toPath(), json.getBytes());
                    } catch (IOException e) {
                        log.warn("error saving login response {}", e.getMessage(), e);
                    }
                }
            }
        });
    }

    public LoginResponse load() {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, LoginResponse.class);
        } catch (FileNotFoundException ignored) {
            return null;
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading saved login json file {}", file, e);
            return null;
        }
    }

    public String getJwtToken() {
        if(!isLoggedIn()) {
            return null;
        }
        return getLoginResponse().getJwt();
    }
}

package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class Stats {

    public long profit;
    public long gross;
    public long taxPaid;
    public int flipsMade;

    public float calculateRoi() {
        if (gross == 0){
            return 0;
        }
        return (float) (((double) profit) / ((double) gross));
    }

    public Stats copy() {
        return new Stats(profit, gross, taxPaid, flipsMade);
    }

    public void add(Stats s) {
        if(s != null) {
            profit += s.profit;
            gross += s.gross;
            taxPaid += s.taxPaid;
            flipsMade += s.flipsMade;
        }
    }

    public void addFlip(FlipV2 f) {
        profit += f.getProfit();
        gross += f.getSpent();
        taxPaid += f.getTaxPaid();
        flipsMade += 1;
    }

    public void subtractFlip(FlipV2 f) {
        profit -= f.getProfit();
        gross -= f.getSpent();
        taxPaid -= f.getTaxPaid();
        flipsMade -= 1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public class SessionData {

    @SerializedName("start_time")
    public int startTime;

    @SerializedName("duration_millis")
    public long durationMillis;

    @SerializedName("average_cash")
    public long averageCash;
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.ApiRequestHandler;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * This class is essentially a cache of user flips that facilitates efficient access to the flips and statistics for
 * any time range and rs account(s) combination. Since after several years a (very) active user could have hundreds of
 * thousands of flips, it would be too slow to filter and re-calculate flips/statistics from scratch every time.
 * A bucketed aggregation strategy is used where we keep pre-computed weekly buckets of statistics and flips. For any
 * time range we can efficiently combine the weekly buckets and only have to re-calculate statistics for the partial
 * weeks on the boundaries of the time range. Have tested the UI experience with >100k flips.
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class FlipManager {

    private static final int WEEK_SECS = 7 * 24 * 60 * 60;

    // dependencies
    private final ApiRequestHandler api;
    private final ScheduledExecutorService executorService;
    private final OkHttpClient okHttpClient;

    @Setter
    private Runnable flipsChangedCallback = () -> {};

    // state
    private String intervalDisplayName;
    private int intervalStartTime;
    private Stats intervalStats = new Stats();

    final Map<String, Integer> displayNameToAccountId = new HashMap<>();
    final Map<Integer, Map<Integer, FlipV2>> lastOpenFLipByItemId = new HashMap<>();
    final Map<UUID, Integer> existingCloseTimes = new HashMap<>();
    final List<WeekAggregate> weeks = new ArrayList<>(365*5);

    private int resetSeq = 0;
    public volatile boolean flipsLoaded;

    public synchronized String getIntervalDisplayName() {
        return intervalDisplayName;
    }

    public synchronized List<String> getDisplayNameOptions() {
        return displayNameToAccountId.keySet().stream().sorted().collect(Collectors.toList());
    }

    public synchronized long estimateTransactionProfit(String displayName, Transaction t) {
        Integer accountId = displayNameToAccountId.get(displayName);
        if (accountId != null && lastOpenFLipByItemId.containsKey(accountId)) {
            FlipV2 flip = lastOpenFLipByItemId.get(accountId).get(t.getItemId());
            if(flip != null) {
                return flip.calculateProfit(t);
            }
        }
        return 0;
    }

    public synchronized void mergeFlips(List<FlipV2> flips, String displayName) {
        if(!flips.isEmpty() && displayName != null) {
            displayNameToAccountId.put(displayName, flips.get(0).getAccountId());
        }
        flips.forEach(this::mergeFlip_);
        flipsChangedCallback.run();
    }

    public synchronized Stats getIntervalStats() {
        return intervalStats.copy();
    }

    public synchronized Stats calculateStats(int startTime, String displayName) {
        if(displayName == null) {
            return calculateStatsAllAccounts(startTime);
        } else {
            return calculateStatsForAccount(startTime, displayNameToAccountId.getOrDefault(displayName, -1));
        }
    }

    public synchronized void setIntervalDisplayName(String displayName) {
        if (Objects.equals(displayName, intervalDisplayName)) {
            return;
        }
        if (displayName != null && !displayNameToAccountId.containsKey(displayName)) {
            displayNameToAccountId.put(displayName, -1);
        }
        intervalDisplayName = displayName;
        recalculateIntervalStats();
    }

    public synchronized void setIntervalStartTime(int startTime) {
        log.debug("time interval start set to: {}", Instant.ofEpochSecond(startTime));
        if (startTime == intervalStartTime) {
            return;
        }
        intervalStartTime = startTime;
        recalculateIntervalStats();
    }

    private void recalculateIntervalStats() {
        if(intervalDisplayName == null) {
            intervalStats = calculateStatsAllAccounts(intervalStartTime);
        } else {
            intervalStats = calculateStatsForAccount(intervalStartTime, displayNameToAccountId.getOrDefault(intervalDisplayName, -1));
        }
        log.debug("interval flips updated to {}, interval profit updated to {}", intervalStats.flipsMade, intervalStats.profit);
        flipsChangedCallback.run();
    }

    private Stats calculateStatsAllAccounts(int startTime) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfter(startTime, false)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).allStats);
        }
        return stats;
    }

    private Stats calculateStatsForAccount(int startTime, int accountId) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfterForAccount(startTime, accountId)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).accountIdToStats.get(accountId));
        }
        return stats;
    }

    public synchronized List<FlipV2> getPageFlips(int page, int pageSize) {
        Integer accountId = intervalDisplayName == null ? null : displayNameToAccountId.getOrDefault(intervalDisplayName, -1);
        if (Objects.equals(accountId,-1)) {
            return new ArrayList<>();
        }

        int toSkip = (page -1) * pageSize;
        WeekAggregate intervalWeek = getOrInitWeek(intervalStartTime);
        List<FlipV2> resultFlips = new ArrayList<>(pageSize);
        for(int i=weeks.size()-1; i >= intervalWeek.pos; i--) {
            if (weeks.get(i).weekEnd <= intervalStartTime || resultFlips.size() == pageSize) {
                break;
            }
            WeekAggregate w = weeks.get(i);
            List<FlipV2> weekFlips = accountId == null ? w.flipsAfter(intervalStartTime, true) : w.flipsAfterForAccount(intervalStartTime, accountId);
            int n = weekFlips.size();
            if (n > toSkip) {
                // note: weekFlips are ascending order but we return pages of descending order
                int end = n - toSkip;
                int start = Math.max(0, end - (pageSize - resultFlips.size()));
                for(int ii=end-1; ii >= start; ii--) {
                    resultFlips.add(weekFlips.get(ii));
                }
                toSkip = 0;
            } else {
                toSkip -= n;
            }
        }
        return resultFlips;
    }

    public void loadFlipsAsync() {
        executorService.execute(() -> this.loadFlips(resetSeq));
    }

    private void loadFlips(int seq) {
        // ScheduledExecutorService only has one thread, we don't really want to block it. Need to
        // refactor the API call to be async style but until then just run in okHttpClient's executor
        okHttpClient.dispatcher().executorService().submit(() -> {
            try {
                long s = System.nanoTime();
                Map<String, Integer> names = api.loadUserDisplayNames();
                synchronized (this) {
                    if (seq != resetSeq) {
                        return;
                    }
                    displayNameToAccountId.putAll(names);
                }
                log.debug("loading account names took {}ms", (System.nanoTime() - s) / 1000_000);
                s = System.nanoTime();
                List<FlipV2> flips = api.LoadFlips();
                log.debug("loading {} flips took {}ms", flips.size(), (System.nanoTime() - s) / 1000_000);
                s = System.nanoTime();
                synchronized (this) {
                    if (seq != resetSeq) {
                        return;
                    }
                    mergeFlips(flips, null);
                    log.debug("merging flips to took {}ms", (System.nanoTime() - s) / 1000_000);
                    flipsLoaded = true;
                }
                flipsChangedCallback.run();
            } catch (Exception e) {
                if (this.resetSeq == seq) {
                    log.warn("failed to load historical flips from server {} try again in 10s", e.getMessage(), e);
                    executorService.schedule(() -> this.loadFlips(seq), 10, TimeUnit.SECONDS);
                }
            }
        });
    }


    public synchronized void reset() {
        intervalDisplayName = null;
        intervalStartTime = 0;
        intervalStats = new Stats();
        displayNameToAccountId.clear();
        lastOpenFLipByItemId.clear();
        existingCloseTimes.clear();
        weeks.clear();
        flipsLoaded = false;
        resetSeq += 1;
    }

    private void mergeFlip_(FlipV2 flip) {
        Integer existingCloseTime = existingCloseTimes.get(flip.getId());
        Integer intervalAccountId = intervalDisplayName == null ? null : displayNameToAccountId.getOrDefault(intervalDisplayName, -1);

        if(existingCloseTime != null) {
            WeekAggregate wa = getOrInitWeek(existingCloseTime);
            FlipV2 removed = wa.removeFlip(flip.getId(), existingCloseTime, flip.getAccountId());
            if(removed.getClosedTime() >= intervalStartTime && (intervalAccountId == null || removed.getAccountId() == intervalAccountId)) {
                intervalStats.subtractFlip(removed);
            }
        }
        WeekAggregate wa = getOrInitWeek(flip.getClosedTime());
        wa.addFlip(flip);
        if(flip.getClosedTime() >= intervalStartTime && (intervalAccountId == null || flip.getAccountId() == intervalAccountId)) {
            intervalStats.addFlip(flip);
        }
        if(flip.getClosedQuantity() < flip.getOpenedQuantity()) {
            lastOpenFLipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).put(flip.getItemId(), flip);
        } else if (flip.isClosed()) {
            lastOpenFLipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).remove(flip.getItemId());
        }
        existingCloseTimes.put(flip.getId(), flip.getClosedTime());
    }

    private WeekAggregate getOrInitWeek(int closeTime) {
        int ws = closeTime - (closeTime % WEEK_SECS);
        int i = bisect(weeks.size(), (a) ->  Integer.compare(weeks.get(a).weekStart, ws));
        if (i >= 0){
            WeekAggregate w = weeks.get(i);
            w.pos = i;
            return w;
        }
        WeekAggregate wf = new WeekAggregate();
        wf.weekStart = ws;
        wf.weekEnd = ws + WEEK_SECS;
        wf.pos = -i-1;
        weeks.add(wf.pos, wf);
        return wf;
    }

    class WeekAggregate {

        int pos; // note: only correct when returned by getOrInitWeek
        int weekStart;
        int weekEnd;

        Stats allStats = new Stats();
        Map<Integer, Stats> accountIdToStats = new HashMap<>(20);
        Map<Integer, List<FlipV2>> accountIdToFlips = new HashMap<>(20);

        void addFlip(FlipV2 flip) {
            int accountId = flip.getAccountId();
            allStats.addFlip(flip);
            accountIdToStats.computeIfAbsent(accountId, (k) -> new Stats()).addFlip(flip);
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, flip.getId(), flip.getClosedTime()));
            flips.add(-i -1, flip);
        }

        FlipV2 removeFlip(UUID id, int closeTime, int accountId) {
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, id, closeTime));
            FlipV2 flip = flips.get(i);
            allStats.subtractFlip(flip);
            flips.remove(i);
            accountIdToStats.get(accountId).subtractFlip(flip);
            return flip;
        }

        public List<FlipV2> flipsAfterForAccount(int time, int accountId) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            if (time <= weekStart) {
                return flips;
            }
            int cut = -bisect(flips.size(), closedTimeCmp(flips, FlipV2.MAX_UUID, time)) - 1;
            return flips.subList(cut, flips.size());
        }

        public List<FlipV2> flipsAfter(int time, boolean requireSorted) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> combinedFlips = new ArrayList<>(allStats.flipsMade);
            accountIdToFlips.keySet().forEach(i -> combinedFlips.addAll(flipsAfterForAccount(time, i)));
            if (requireSorted) {
                combinedFlips.sort(Comparator.comparing(FlipV2::getClosedTime).thenComparing(FlipV2::getId));
            }
            return combinedFlips;
        }

        @Override
        public String toString() {
            return String.format("WeekAggregate[start=%s, flips=%d]", Instant.ofEpochSecond(weekStart), allStats.flipsMade);
        }
    }

    private Function<Integer, Integer> closedTimeCmp(List<FlipV2> flips, UUID id, int time) {
        return (a) -> {
            // sorts time ascending with id as tie-breaker
            int c = Integer.compare(flips.get(a).getClosedTime(), time);
            return c != 0 ? c : id.compareTo(flips.get(a).getId());
        };
    }

    private int bisect(int size, Function<Integer, Integer> cmpFunc) {
        int high = size -1;
        int low = 0;
        while (low <= high) {
            int mid = (low + high) >>> 1;
            int cmp = cmpFunc.apply(mid);
            if (cmp < 0)
                low = mid + 1;
            else if (cmp > 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found (low = insertion point)
    }
}

package com.flippingcopilot.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumSet;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OsrsLoginManager {

    public static final int GE_LOGIN_BURST_WINDOW = 2; // ticks

    public static String LOGIN_TO_GET_SUGGESTION_MESSAGE = "Log in to the game<br>to get a flip suggestion";
    private static final WorldType[] COPILOT_UNSUPPORTED_WORLDS = {WorldType.BETA_WORLD,
            WorldType.DEADMAN,
            WorldType.FRESH_START_WORLD,
            WorldType.NOSAVE_MODE,
            WorldType.PVP_ARENA,
            WorldType.SEASONAL,
            WorldType.QUEST_SPEEDRUNNING,
            WorldType.TOURNAMENT_WORLD};

    private final Client client;

    private String cachedDisplayName;
    private long lastAccountHash;

    @Getter
    @Setter
    private int lastLoginTick;

    private boolean lastIsIronman = false;

    public boolean isMembersWorld() {
        return client.getWorldType().contains(WorldType.MEMBERS);
    }

    public boolean isValidLoginState() {
        return getInvalidStateDisplayMessage() == null;
    }

    public String getInvalidStateDisplayMessage() {
        if (client.getGameState() != GameState.LOGGED_IN || getPlayerDisplayName() == null) {
            return LOGIN_TO_GET_SUGGESTION_MESSAGE;
        }

        EnumSet<WorldType> worldTypes  =  client.getWorldType();

        for (WorldType worldType : COPILOT_UNSUPPORTED_WORLDS) {
            if (worldTypes.contains(worldType)) {
                return worldType + " worlds<br>are not supported";
            }
        }
        if(client.isClientThread()) {
            lastIsIronman = client.getVarbitValue(Varbits.ACCOUNT_TYPE) != 0;
        }
        if (lastIsIronman) {
            return "Ironman accounts<br>are not supported";
        }
        return null;
    }

    // todo: inline this method
    public Long getAccountHash() {
        return client.getAccountHash();
    }

    public String getPlayerDisplayName() {
        long accountHash = client.getAccountHash();
        if(lastAccountHash == accountHash && cachedDisplayName != null) {
            return cachedDisplayName;
        }
        final Player player = client.getLocalPlayer();
        if (player != null) {
            final String name = player.getName();
            if (name != null && !name.isEmpty()) {
                lastAccountHash = accountHash;
                cachedDisplayName = name;
                return name;
            }
        }
        return null;
    }

    public String getLastDisplayName() {
        return cachedDisplayName != null ? cachedDisplayName : getPlayerDisplayName();
    }

    public void reset() {

    }

    public boolean hasJustLoggedIn() {
        return client.getTickCount() <= lastLoginTick + GE_LOGIN_BURST_WINDOW;
    }
}

package com.flippingcopilot.model;

import lombok.Data;

@Data
public class DiscordWebhookBody {
    private String content;
    private Embed embed;

    @Data
    static class Embed {
        final UrlEmbed image;
    }

    @Data
    static class UrlEmbed {
        final String url;
    }
}
package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OfferManager {

    private static final String OFFER_FILE_TEMPLATE = "acc_%d_%d.json";

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    @Getter
    @Setter
    private int lastViewedSlotItemId = -1;
    @Getter
    @Setter
    private int lastViewedSlotItemPrice = -1;
    @Getter
    @Setter
    private int lastViewedSlotPriceTime = 0;
    @Getter
    @Setter
    private int viewedSlotItemId = -1;
    @Getter
    @Setter
    private int viewedSlotItemPrice = -1;
    @Getter
    @Setter
    boolean offerJustPlaced = false;

    private final Map<Long, Map<Integer, SavedOffer>> cachedOffers = new HashMap<>();
    private final Map<Long, Map<Integer, File>> files = new HashMap<>();
    private final Map<Long, Map<Integer, SavedOffer>> lastSaved = new HashMap<>();

    public synchronized SavedOffer loadOffer(Long accountHash, Integer slot) {
        Map<Integer, SavedOffer> slotToOffer = cachedOffers.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToOffer.computeIfAbsent(slot, (k) -> {
            File file = getFile(accountHash, k);
            try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                return gson.fromJson(reader, SavedOffer.class);
            } catch (FileNotFoundException ignored) {
                return null;
            } catch (JsonSyntaxException | JsonIOException | IOException e) {
                log.warn("error loading saved offer json file {}", file, e);
                return null;
            }
        });
    }

    public synchronized void saveOffer(Long accountHash, Integer slot, SavedOffer offer) {
        Map<Integer, SavedOffer> slotToOffer = cachedOffers.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        slotToOffer.put(slot, offer);
        saveAsync(accountHash, slot);
    }

    private void saveAsync(Long accountHash, Integer slot) {
        executorService.submit(() -> save(accountHash, slot));
    }

    public synchronized void saveAll() {
        for(Long accountHash: cachedOffers.keySet()) {
            for(Integer slot: cachedOffers.get(accountHash).keySet()) {
                save(accountHash, slot);
            }
        }
    }

    private void save(Long accountHash, Integer slot) {
        File file = getFile(accountHash,slot);
        synchronized (file) {
            SavedOffer offer = loadOffer(accountHash, slot);
            Map<Integer, SavedOffer> slotToLastSaved = lastSaved.computeIfAbsent(accountHash, (k)->new HashMap<>());
            SavedOffer lastSaved = slotToLastSaved.get(slot);
            if(!Objects.equals(offer, lastSaved)) {
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(offer);
                    writer.write(json);
                    writer.newLine();
                    slotToLastSaved.put(slot, offer);
                } catch (IOException e) {
                    log.warn("error saving offer json file {}", file, e);
                    slotToLastSaved.put(slot, null);
                }
            }
        }
    }


    private File getFile(Long accountHash, Integer slot) {
        Map<Integer, File> slotToFile = files.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToFile.computeIfAbsent(slot, (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(OFFER_FILE_TEMPLATE, accountHash, slot)));
    }
}

package com.flippingcopilot.model;


import com.flippingcopilot.controller.Persistance;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PausedManager {

    private static final String PAUSED_FILE_TEMPLATE = "acc_%d_paused.json";

    // dependencies
    private final OsrsLoginManager osrsLoginManager;
    private final ScheduledExecutorService executorService;

    // state
    private final Map<Long, Boolean> cachedPaused = new HashMap<>();
    private final Map<Long, File> accountHashToFile = new HashMap<>();

    public synchronized boolean isPaused() {
        Long accountHash = osrsLoginManager.getAccountHash();
        return cachedPaused.computeIfAbsent(accountHash, (k) -> {
            File file = getFile(k);
            try {
                String text = Files.readString(file.toPath(), StandardCharsets.UTF_8);
                return text.contains("true");
            } catch (NoSuchFileException e ){
                return false;
            } catch (JsonSyntaxException | JsonIOException | IOException e) {
                log.warn("error loading stored paused state file {}", file, e);
                return false;
            }
        });
    }

    public synchronized void setPaused(boolean isPaused) {
        Long accountHash = osrsLoginManager.getAccountHash();
        cachedPaused.put(accountHash, isPaused);
        saveAsync(accountHash);
    }

    private void saveAsync(Long accountHash) {
        executorService.submit(() -> {
            File file = getFile(accountHash);
            synchronized (file) {
                boolean isPaused = cachedPaused.getOrDefault(accountHash, false);
                String text = isPaused ? "{\"isPaused\":true}" : "{\"isPaused\":false}";
                try {
                    Files.write(file.toPath(), text.getBytes());
                } catch (IOException e) {
                    log.warn("error storing paused.json file {}", file, e);
                }
            }
        });
    }

    private File getFile(Long accountHash) {
        return accountHashToFile.computeIfAbsent(accountHash,
                (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(PAUSED_FILE_TEMPLATE, accountHash)));
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.SuggestionController;
import com.flippingcopilot.model.PausedManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Singleton
public class PauseButton extends JButton {

    private final PausedManager pausedManager;

    private static final ImageIcon PLAY_ICON;
    private static final ImageIcon PAUSE_ICON;
    private static final ImageIcon PLAY_ICON_HOVER;
    private static final ImageIcon PAUSE_ICON_HOVER;

    static {
        var play = ImageUtil.loadImageResource(PauseButton.class, "/play.png");
        var pause = ImageUtil.loadImageResource(PauseButton.class, "/pause.png");
        PLAY_ICON = new ImageIcon(play);
        PAUSE_ICON = new ImageIcon(pause);
        PLAY_ICON_HOVER =  new ImageIcon(ImageUtil.luminanceScale(play, BUTTON_HOVER_LUMINANCE));
        PAUSE_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(pause, BUTTON_HOVER_LUMINANCE));
    }

    @Inject
    public PauseButton(PausedManager pausedManager,
                       SuggestionController suggestionController) {
        super(PAUSE_ICON);
        this.pausedManager = pausedManager;
        setToolTipText("Pause suggestions");
        addActionListener(e -> {
            suggestionController.togglePause();
            update();
        });

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(pausedManager.isPaused() ? PLAY_ICON_HOVER : PAUSE_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(pausedManager.isPaused() ? PLAY_ICON : PAUSE_ICON);
            }
        });

        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);
    }

    private void update() {
        boolean isPaused = pausedManager.isPaused();
        setIcon(isPaused ? PLAY_ICON : PAUSE_ICON);
        setToolTipText(isPaused ? "Unpause suggestions" :  "Pause suggestions");
    }
}

package com.flippingcopilot.ui;


import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;

@Singleton
public class CopilotPanel extends JPanel {

    public final SuggestionPanel suggestionPanel;
    public final StatsPanelV2 statsPanel;

    @Inject
    public CopilotPanel(SuggestionPanel suggestionPanel,
                        StatsPanelV2 statsPanel) {
        this.statsPanel = statsPanel;
        this.suggestionPanel = suggestionPanel;
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        suggestionPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, suggestionPanel.getPreferredSize().height));
        suggestionPanel.setMinimumSize(new Dimension(Integer.MIN_VALUE, suggestionPanel.getPreferredSize().height));
        add(suggestionPanel);
        add(Box.createRigidArea(new Dimension(0, 5)));
        add(Box.createVerticalGlue());
        add(statsPanel);
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        suggestionPanel.refresh();
    }
}

/* Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * Copyright (c) 2024, Cillian Brewitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;

import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class WidgetHighlightOverlay extends Overlay
{
    private final Widget widget;
    private final Color color;
    private final Rectangle relativeBounds;

    public WidgetHighlightOverlay(final Widget widget, Color color, Rectangle relativeBounds)
    {
        this.widget = widget;
        this.color = color;
        this.relativeBounds = relativeBounds;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (widget == null)
        {
            return null;
        }

        Rectangle highlightBounds = widget.getBounds();

        if (highlightBounds == null)
        {
            return null;
        }

        highlightBounds.x += relativeBounds.x;
        highlightBounds.y += relativeBounds.y;
        highlightBounds.width = relativeBounds.width;
        highlightBounds.height = relativeBounds.height;

        drawHighlight(graphics, highlightBounds);
        return null;
    }

    private void drawHighlight(Graphics2D graphics, Rectangle bounds)
    {
        graphics.setColor(color);
        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import net.runelite.client.util.ImageUtil;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
@Singleton
public class BlockButton extends JButton
{
    private final SuggestionManager suggestionManager;
    private final SuggestionPreferencesManager preferencesManager;

    private static final ImageIcon BLOCK_ICON;
    private static final ImageIcon BLOCK_ICON_HOVER;

    static
    {
        var blockImg = ImageUtil.loadImageResource(BlockButton.class, "/block.png");
        BLOCK_ICON = new ImageIcon(blockImg);
        BLOCK_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(blockImg, BUTTON_HOVER_LUMINANCE));
    }

    @Inject
    public BlockButton(SuggestionManager suggestionManager, SuggestionPreferencesManager preferencesManager)
    {
        super(BLOCK_ICON);
        this.suggestionManager = suggestionManager;
        this.preferencesManager = preferencesManager;

        setToolTipText("Block this item");
        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);

        // Click action
        addActionListener(e -> confirmAndBlock());

        // Hover effects
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                setIcon(BLOCK_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                setIcon(BLOCK_ICON);
            }
        });
    }

    private void confirmAndBlock()
    {
        Suggestion s = suggestionManager.getSuggestion();
        if (s == null)
        {
            log.debug("No current suggestion to block.");
            return;
        }

        // Get item name or fallback text
        String itemName = s.getName() != null ? s.getName() : "this item";

        // Show a confirmation dialog
        int choice = JOptionPane.showConfirmDialog(
                this,
                "Do you want to block " + itemName + "?",
                "Confirm Block",
                JOptionPane.YES_NO_OPTION
        );

        // If user clicks YES, proceed with blocking
        if (choice == JOptionPane.YES_OPTION)
        {
            preferencesManager.blockItem(s.getItemId());
            log.debug("Blocked item with ID {} ({})", s.getItemId(), itemName);
            suggestionManager.setSuggestionNeeded(true);
        }
        else
        {
            log.debug("User canceled blocking for {}", itemName);
        }
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import com.flippingcopilot.model.SuggestionManager;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;

@Singleton
public class PreferencesPanel extends JPanel {

    public static String LOGIN_TO_MANAGE_SETTINGS = "Log in to manage settings";

    private final Client client;
    private final OsrsLoginManager osrsLoginManager;
    private final SuggestionPreferencesManager preferencesManager;
    private final JPanel sellOnlyButton;
    private final PreferencesToggleButton sellOnlyModeToggleButton;
    private final JPanel f2pOnlyButton;
    private final PreferencesToggleButton f2pOnlyModeToggleButton;
    private final BlacklistDropdownPanel blacklistDropdownPanel;
    private final JLabel messageText = new JLabel();

    @Inject
    public PreferencesPanel(
            OsrsLoginManager osrsLoginManager,
            SuggestionManager suggestionManager,
            SuggestionPreferencesManager suggestionPreferencesManager, Client client,
            SuggestionPreferencesManager preferencesManager,
            BlacklistDropdownPanel blocklistDropdownPanel) {
        super();
        this.osrsLoginManager = osrsLoginManager;
        this.client = client;
        this.preferencesManager = preferencesManager;
        this.blacklistDropdownPanel = blocklistDropdownPanel;
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        setBounds(0, 0, 300, 150);

        JLabel preferencesTitle = new JLabel("Suggestion Settings");
        preferencesTitle.setForeground(Color.WHITE);
        preferencesTitle.setFont(preferencesTitle.getFont().deriveFont(Font.BOLD));
        preferencesTitle.setAlignmentX(Component.CENTER_ALIGNMENT);
        preferencesTitle.setMinimumSize(new Dimension(300, preferencesTitle.getPreferredSize().height));
        preferencesTitle.setMaximumSize(new Dimension(300, preferencesTitle.getPreferredSize().height));
        preferencesTitle.setHorizontalAlignment(SwingConstants.CENTER);
        add(preferencesTitle);
        add(Box.createRigidArea(new Dimension(0, 6)));
        sellOnlyModeToggleButton = new PreferencesToggleButton("Disable sell-only mode", "Enable sell-only mode");
        sellOnlyButton = new JPanel();
        sellOnlyButton.setLayout(new BorderLayout());
        sellOnlyButton.setOpaque(false);
        add(sellOnlyButton);
        JLabel buttonText = new JLabel("Sell-only mode");
        sellOnlyButton.add(buttonText, BorderLayout.LINE_START);
        sellOnlyButton.add(sellOnlyModeToggleButton, BorderLayout.LINE_END);
        sellOnlyModeToggleButton.addItemListener(i ->
        {
            suggestionPreferencesManager.setSellOnlyMode(sellOnlyModeToggleButton.isSelected());
            suggestionManager.setSuggestionNeeded(true);
        });
        add(Box.createRigidArea(new Dimension(0, 3)));

        f2pOnlyModeToggleButton = new PreferencesToggleButton("Disable F2P-only mode",  "Enable F2P-only mode");
        f2pOnlyButton = new JPanel();
        f2pOnlyButton.setLayout(new BorderLayout());
        f2pOnlyButton.setOpaque(false);
        add(f2pOnlyButton);
        JLabel f2pOnlyButtonText = new JLabel("F2P-only mode");
        f2pOnlyButton.add(f2pOnlyButtonText, BorderLayout.LINE_START);
        f2pOnlyButton.add(f2pOnlyModeToggleButton, BorderLayout.LINE_END);
        f2pOnlyModeToggleButton.addItemListener(i ->
        {
            suggestionPreferencesManager.setF2pOnlyMode(f2pOnlyModeToggleButton.isSelected());
            suggestionManager.setSuggestionNeeded(true);
        });
        add(Box.createRigidArea(new Dimension(0, 3)));

        add(this.blacklistDropdownPanel);
        add(Box.createRigidArea(new Dimension(0, 30)));
        add(messageText);
        messageText.setText(LOGIN_TO_MANAGE_SETTINGS);
        messageText.setVisible(false);
        messageText.setAlignmentX(Component.CENTER_ALIGNMENT);
        messageText.setHorizontalAlignment(SwingConstants.CENTER);
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        if(osrsLoginManager.getPlayerDisplayName() != null && client.getGameState() == GameState.LOGGED_IN) {
            sellOnlyModeToggleButton.setSelected(preferencesManager.getPreferences().isSellOnlyMode());
            sellOnlyButton.setVisible(true);
            f2pOnlyModeToggleButton.setSelected(preferencesManager.getPreferences().isF2pOnlyMode());
            f2pOnlyButton.setVisible(true);
            blacklistDropdownPanel.setVisible(true);
            messageText.setVisible(false);
        } else {
            sellOnlyButton.setVisible(false);
            f2pOnlyButton.setVisible(false);
            blacklistDropdownPanel.setVisible(false);
            messageText.setVisible(true);
        }
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.*;
import com.flippingcopilot.model.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;


import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicComboBoxEditor;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class StatsPanelV2 extends JPanel {


    public final BufferedImage TRASH_ICON = ImageUtil.loadImageResource(getClass(), "/trash.png");
    public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
    public final Icon OPEN_ICON = new ImageIcon(ARROW_ICON);
    public final Icon CLOSE_ICON = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(90)));

    private static final String ALL_ACCOUNTS_DROPDOWN_OPTION = "All accounts";
    private static final java.util.List<Integer> SESSION_STATS_INDS = Arrays.asList(3,4,5);
    private static final String[] TIME_INTERVAL_STRINGS = {
            "-1h (Past Hour)",
            "-4h (Past 4 Hours)",
            "-12h (Past 12 Hours)",
            "-1d (Past Day)",
            "-1w (Past Week)",
            "-1m (Past Month)",
            "Session",
            "All"};

    private static final Pattern INTERVAL_PATTERN = Pattern.compile("^-?(\\d+)([hdwmy])[()\\w\\s]*");

    // dependencies
    private final LoginResponseManager loginResponseManager;
    private final OsrsLoginManager osrsLoginManager;
    private final FlippingCopilotConfig config;
    private final FlipManager flipManager;
    private final SessionManager sessionManager;
    private final WebHookController webHookController;
    private final ClientThread clientThread;

    // state
    private JComboBox<String> timeIntervalDropdown;
    private final DefaultComboBoxModel<String> rsAccountDropdownModel = new DefaultComboBoxModel<>();
    private final JComboBox<String> rsAccountDropdown = new JComboBox<>(rsAccountDropdownModel);
    private final JButton sessionResetButton = new JButton("  Reset session ");
    private JPanel profitAndSubInfoPanel;
    private JPanel subInfoPanel;
    private final JPanel flipsPanel = new JPanel();
    private final JLabel totalProfitVal = new JLabel("0 gp");
    private final JLabel roiVal = new JLabel("-0.00%");
    private final JLabel flipsMadeVal = new JLabel("0");
    private final JLabel taxPaidVal = new JLabel("0 gp");
    private final JLabel sessionTimeVal = new JLabel("00:00:00");
    private final JLabel hourlyProfitVal = new JLabel("0 gp/hr");
    private final JLabel avgCashVal = new JLabel("0 gp");
    private final Paginator paginator;

    private IntervalTimeUnit selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
    private int selectedIntervalValue = -1;
    private volatile boolean lastValidState = false;

    @Inject
    public StatsPanelV2(LoginResponseManager loginResponseManager,
                        OsrsLoginManager osrsLoginManager,
                        FlippingCopilotConfig config,
                        FlipManager FlipManager,
                        SessionManager sessionManager,
                        WebHookController webHookController,
                        ClientThread clientThread) {
        this.loginResponseManager = loginResponseManager;
        this.osrsLoginManager = osrsLoginManager;
        this.sessionManager = sessionManager;
        this.webHookController = webHookController;
        this.config = config;
        this.flipManager = FlipManager;
        this.clientThread = clientThread;
        setLayout(new BorderLayout());

        setupTimeIntervalDropdown();
        setupProfitAndSubInfoPanel();
        setupSessionResetButton();

        flipsPanel.setLayout(new BoxLayout(flipsPanel, BoxLayout.Y_AXIS));
        flipsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        flipsPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

        JScrollPane scrollPane = new JScrollPane(flipsPanel);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        // Create a main panel with vertical layout
        JPanel mainPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel timeIntervalDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        timeIntervalDropdownWrapper.setBorder(BorderFactory.createEmptyBorder()); // No border
        timeIntervalDropdownWrapper.add(timeIntervalDropdown, BorderLayout.CENTER);
        timeIntervalDropdownWrapper.add(sessionResetButton, BorderLayout.EAST);
        timeIntervalDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeIntervalDropdownWrapper.getPreferredSize().height));

        JPanel intervalRsAccountDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        rsAccountDropdown.setBorder(BorderFactory.createEmptyBorder());
        rsAccountDropdown.setMaximumSize(new Dimension(Integer.MAX_VALUE, rsAccountDropdown.getPreferredSize().height));
        intervalRsAccountDropdownWrapper.add(timeIntervalDropdownWrapper, BorderLayout.NORTH);
        intervalRsAccountDropdownWrapper.add(rsAccountDropdown, BorderLayout.SOUTH);
        rsAccountDropdown.addActionListener(e -> {
            String value = (String) rsAccountDropdown.getSelectedItem();
            log.info("selected rs account is: {}", value);
            if(value != null) {
                if (ALL_ACCOUNTS_DROPDOWN_OPTION.equals(value)) {
                    flipManager.setIntervalDisplayName(null);
                } else {
                    flipManager.setIntervalDisplayName(value);
                }
            }
        });
        intervalRsAccountDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, intervalRsAccountDropdownWrapper.getPreferredSize().height));

        mainPanel.add(intervalRsAccountDropdownWrapper);
        mainPanel.add(profitAndSubInfoPanel);
        mainPanel.add(scrollPane);

        add(mainPanel, BorderLayout.CENTER);

        paginator = new Paginator(() -> refresh(true, lastValidState));
        add(paginator, BorderLayout.SOUTH);

        flipManager.setFlipsChangedCallback(() -> refresh(true, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState()));
    }

    private void setupSessionResetButton() {
        sessionResetButton.setBorder(BorderFactory.createEmptyBorder());
        sessionResetButton.addActionListener((l) -> {
            JLabel resetIcon = new JLabel(new ImageIcon(TRASH_ICON));
            final int result = JOptionPane.showOptionDialog(resetIcon, "<html>Are you sure you want to reset the session?</html>",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");
            if (result == JOptionPane.YES_OPTION) {
                // send discord message before resetting session stats
                clientThread.invoke(() -> {
                    if (osrsLoginManager.isValidLoginState()) {
                        String displayName = osrsLoginManager.getPlayerDisplayName();
                        webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, displayName), sessionManager.getCachedSessionData(), displayName, true);
                        sessionManager.resetSession();
                        if (IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit)) {
                            flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                        }
                        refresh(true, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
                    }
                });
            }
        });
    }

    public void resetIntervalDropdownToSession() {
        timeIntervalDropdown.setSelectedItem("Session");
        selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
        selectedIntervalValue = -1;
    }

    private boolean extractAndUpdateTimeInterval(String value) {
        if (value != null) {
            if ("Session".equals(value)) {
                selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
                selectedIntervalValue = -1;
                return true;
            } else if ("All".equals(value)) {
                selectedIntervalTimeUnit = IntervalTimeUnit.ALL;
                selectedIntervalValue = -1;
                return true;
            } else {
                Matcher matcher = INTERVAL_PATTERN.matcher(value);
                if (matcher.matches()) {
                    selectedIntervalValue = Integer.parseInt(matcher.group(1));
                    selectedIntervalTimeUnit = IntervalTimeUnit.fromString(matcher.group(2));
                    return true;
                }
            }
        }
        return false;
    }


    private void setupTimeIntervalDropdown() {
        timeIntervalDropdown = new JComboBox<>(TIME_INTERVAL_STRINGS);
        timeIntervalDropdown.setEditable(true);
        timeIntervalDropdown.setSelectedItem("Session");
        timeIntervalDropdown.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setBorder(BorderFactory.createEmptyBorder());

        // Create a custom editor to handle both selection and manual input
        ComboBoxEditor editor = new BasicComboBoxEditor() {
            @Override
            public void setItem(Object item) {
                super.setItem(item);
                if (item != null) {
                    String value = item.toString();
                    if (extractAndUpdateTimeInterval(value)) {
                        updateFlipManagerAndStats();
                    }
                }
            }
        };
        timeIntervalDropdown.setEditor(editor);

        // Add action listener for selection changes and manual edits
        timeIntervalDropdown.addActionListener(e -> {
            String value = (String) timeIntervalDropdown.getSelectedItem();
            if (extractAndUpdateTimeInterval(value)) {
                updateFlipManagerAndStats();
            }
        });
    }

    private void updateFlipManagerAndStats() {
        log.debug("selection interval value updated to {} {}", selectedIntervalValue, selectedIntervalTimeUnit);
        switch (selectedIntervalTimeUnit) {
            case ALL:
                flipManager.setIntervalStartTime(1);
                break;
            case SESSION:
                flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                break;
            default:
                int startTime = (int) Instant.now().getEpochSecond() - selectedIntervalValue * selectedIntervalTimeUnit.getSeconds();
                flipManager.setIntervalStartTime(startTime);
        }
    }

    private JPanel buildSubInfoPanelItem(String key, JLabel value, Color valueColor) {
        JPanel item = new JPanel(new BorderLayout());
        item.setBorder(new EmptyBorder(4, 2, 4, 2));
        item.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel keyLabel = new JLabel(key);
        keyLabel.setFont(FontManager.getRunescapeSmallFont());
        item.add(keyLabel, BorderLayout.WEST);
        value.setFont(FontManager.getRunescapeSmallFont());
        value.setForeground(valueColor);
        item.add(value, BorderLayout.EAST);
        item.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));
        return item;
    }

    private JPanel buildSubInfoPanel() {
        JPanel subInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        subInfoPanel.add(buildSubInfoPanelItem("ROI:", roiVal, UIUtilities.TOMATO));
        subInfoPanel.add(buildSubInfoPanelItem("Flips made:", flipsMadeVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Tax paid:", taxPaidVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Session time:", sessionTimeVal, ColorScheme.GRAND_EXCHANGE_ALCH));
        subInfoPanel.add(buildSubInfoPanelItem("Hourly profit:", hourlyProfitVal, Color.WHITE));
        subInfoPanel.add(buildSubInfoPanelItem("Avg wealth:", avgCashVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        subInfoPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(0,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(2, 5, 5, 5)));
       return subInfoPanel;
    }

    private void setupProfitAndSubInfoPanel() {
        profitAndSubInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        profitAndSubInfoPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Create the header panel that can be clicked to expand/collapse sub info
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(5, 0, 5, 0)));

        final JLabel profitTitle = new JLabel("Profit: ");
        profitTitle.setFont(FontManager.getRunescapeBoldFont());

        totalProfitVal.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        totalProfitVal.setFont(FontManager.getRunescapeBoldFont().deriveFont(24f));
        totalProfitVal.setHorizontalAlignment(SwingConstants.CENTER);

        // Use a panel to stack the profitTitle and totalProfitVal vertically
        JPanel profitTextPanel = new JPanel();
        profitTextPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        profitTextPanel.add(profitTitle);
        profitTextPanel.add(Box.createRigidArea(new Dimension(5, 0))); // Spacing between title and value
        profitTextPanel.add(totalProfitVal);
        profitTextPanel.setBorder(BorderFactory.createEmptyBorder(2,4,2,4));

        // Arrow label
        JLabel arrowLabel = new JLabel(OPEN_ICON);
        arrowLabel.setHorizontalAlignment(SwingConstants.CENTER);
        arrowLabel.setVerticalAlignment(SwingConstants.CENTER);
        arrowLabel.setPreferredSize(new Dimension(16, 16)); // Adjust size as needed

        // Add components to headerPanel
        headerPanel.add(profitTextPanel, BorderLayout.CENTER);
        headerPanel.add(arrowLabel, BorderLayout.EAST);

        // Create the sub-info panel
        subInfoPanel = buildSubInfoPanel();

        headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 70));
        profitAndSubInfoPanel.add(headerPanel);
        profitAndSubInfoPanel.add(subInfoPanel);

        // Mouse listener to handle expand/collapse and hover effects
        MouseAdapter headerMouseListener = new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                boolean isExpanded = subInfoPanel.isVisible();
                if(!isExpanded && rsAccountDropdownModel.getSize() > 2) {
                    rsAccountDropdown.setVisible(true);
                } else if (isExpanded && rsAccountDropdownModel.getSize() > 2) {
                    rsAccountDropdown.setVisible(false);
                }
                subInfoPanel.setVisible(!isExpanded);
                arrowLabel.setIcon(isExpanded ? OPEN_ICON : CLOSE_ICON);
                log.debug("profit and sub info panel clicked");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                headerPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                headerPanel.setCursor(Cursor.getDefaultCursor());
            }
        };

        // Add mouse listener to header components
        headerPanel.addMouseListener(headerMouseListener);
        totalProfitVal.addMouseListener(headerMouseListener);
        profitTitle.addMouseListener(headerMouseListener);

    }

    // called when:
    //
    // - time interval drop down changed (Swing EDT thread)
    // - session reset button pressed (Swing EDT thread)
    // - transaction processing downstream (ScheduledExecutorService)
    // - FlipTrackerV2 initialisation (ScheduledExecutorService)
    // - session stats updated (ScheduledExecutorService)
    // - plugin config changed (Client thread)
    // - page changed (Swing EDT thread)
    //

    public void refresh(boolean flipsMaybeChanged, boolean validLoginState) {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(() -> refresh(flipsMaybeChanged, validLoginState));
            return;
        }
        lastValidState = validLoginState;
        if (!validLoginState) {
            totalProfitVal.setText("0 gp");
            roiVal.setText("-0.00%");
            flipsMadeVal.setText("0");
            taxPaidVal.setText("0 gp");
            sessionTimeVal.setText("00:00:00");
            hourlyProfitVal.setText("0 gp/hr");
            avgCashVal.setText("0 gp");
            flipsPanel.removeAll();
            paginator.setTotalPages(1);
            boolean v = IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit);
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(v));
            rsAccountDropdownModel.removeAllElements();
            rsAccountDropdown.setVisible(false);
            return;
        }

        java.util.List<String> displayNameOptions = flipManager.getDisplayNameOptions();
        String selectedDisplayName = flipManager.getIntervalDisplayName();
        if (displayNameOptionsOutOfDate(displayNameOptions) || selectedDisplayNameOutOfDate(selectedDisplayName)) {
            rsAccountDropdownModel.removeAllElements();
            rsAccountDropdownModel.addAll(displayNameOptions);
            rsAccountDropdownModel.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
            if (selectedDisplayName == null) {
                rsAccountDropdown.setSelectedItem(rsAccountDropdownModel.getElementAt(rsAccountDropdownModel.getSize()-1));
            } else {
                rsAccountDropdown.setSelectedItem(selectedDisplayName);
            }
            if(rsAccountDropdownModel.getSize() > 2) {
                rsAccountDropdown.setVisible(true);
            }
        }

        SessionData sd = sessionManager.getCachedSessionData();
        Stats stats = flipManager.getIntervalStats();
        paginator.setTotalPages(1 + stats.flipsMade / 50);
        long s = System.nanoTime();
        if (flipsMaybeChanged) {
            flipsPanel.removeAll();
            flipManager.getPageFlips(paginator.getPageNumber(), 50).forEach(f -> flipsPanel.add(new FlipPanel(f, config)));
            // labels displayed to the user
            roiVal.setText(String.format("%.3f%%", stats.calculateRoi() * 100));
            roiVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            flipsMadeVal.setText(String.format("%d", stats.flipsMade));
            taxPaidVal.setText(UIUtilities.formatProfit(stats.taxPaid));
            totalProfitVal.setText(UIUtilities.formatProfit(stats.profit));
            totalProfitVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            log.debug("populating flips took {}ms", (System.nanoTime() - s) / 1000_000);
        }

        // 'Session time', 'Hourly profit' and 'Avg wealth' should only be set if 'Session' is select in the dropdown
        if (IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit)) {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(true));
            long seconds = sd.durationMillis / 1000;
            float hoursFloat = (((float) seconds) / 3600.0f);
            long hourlyProfit = hoursFloat == 0 ? 0 : (long) (stats.profit / hoursFloat);
            String sessionTime = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            sessionTimeVal.setText(sessionTime);
            hourlyProfitVal.setText(UIUtilities.formatProfitWithoutGp(hourlyProfit) + " gp/hr");
            hourlyProfitVal.setForeground(UIUtilities.getProfitColor(hourlyProfit, config));
            avgCashVal.setText(UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp");
        } else {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(false));
        }
    }

    private boolean selectedDisplayNameOutOfDate(String selectedDisplayName) {
        String oldSelectedDisplayName = (String) rsAccountDropdown.getSelectedItem();
        if (ALL_ACCOUNTS_DROPDOWN_OPTION.equals(oldSelectedDisplayName) && selectedDisplayName == null) {
            return false;
        }
        return !Objects.equals(oldSelectedDisplayName, selectedDisplayName);
    }

    private boolean displayNameOptionsOutOfDate(List<String> displayNameOptions) {
        if (displayNameOptions.size() + 1 != rsAccountDropdownModel.getSize()) {
            return true;
        }
        for(int i = 0; i< displayNameOptions.size(); i++) {
            if (!displayNameOptions.get(i).equals(rsAccountDropdownModel.getElementAt(i))) {
                return true;
            }
        }
        return false;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;

public class UIUtilities {
    public static final String discordIcon = "/discord.png";
    public static final String githubIcon = "/github.png";
    public static final String logoutIcon = "/logout.png";
    public static final String internetIcon = "/internet.png";
    public static final String graphIcon = "/graph.png";

    static final float BUTTON_HOVER_LUMINANCE = 0.65f;
    public static final Color OUTDATED_COLOR = new Color(250, 74, 75);
    public static final Color BLUE_HIGHLIGHT_COLOR =  new Color(27, 173, 255, 79);
    public static final Color RED_HIGHLIGHT_COLOR = new Color(255, 20, 20, 79);
    public static final Color TOMATO = new Color(255,99,71);
    public static final Color DARK_GRAY = new Color(27, 27, 27);

    private static final NumberFormat PRECISE_DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.###",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );
    private static final NumberFormat DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.#",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );

    public static synchronized String quantityToRSDecimalStack(long quantity, boolean precise)
    {
        if (Long.toString(quantity).length() <= 4)
        {
            return QuantityFormatter.formatNumber(quantity);
        }

        long power = (long) Math.log10(quantity);

        // Output thousandths for values above a million
        NumberFormat format = precise && power >= 6
                ? PRECISE_DECIMAL_FORMATTER
                : DECIMAL_FORMATTER;

        return format.format(quantity / Math.pow(10, (Long.divideUnsigned(power, 3)) * 3))
                + new String[] {"", "K", "M", "B", "T"}[(int) (power / 3)];
    }

    public static Color getProfitColor(long profit, FlippingCopilotConfig config) {
        if (profit > 0) {
            return config.profitAmountColor();
        } else if (profit < 0) {
            return config.lossAmountColor();
        } else {
            return Color.WHITE;
        }
    }

    public static String formatProfit(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true) + " gp";
    }

    public static String formatProfitWithoutGp(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true);
    }

    public static String truncateString(String string, int length) {
        if (string.length() > length) {
            return string.substring(0, length) + "...";
        }
        return string;
    }

    static JLabel buildButton(BufferedImage icon, String tooltip, Runnable onClick) {
        JLabel label = new JLabel();
        label.setToolTipText(tooltip);
        label.setHorizontalAlignment(JLabel.CENTER);
        ImageIcon iconOff = new ImageIcon(icon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(icon, BUTTON_HOVER_LUMINANCE));
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                try {
                    onClick.run();
                } catch (Exception error) {}
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                label.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setIcon(iconOff);
            }
        });
        label.setIcon(iconOff);
        return label;
    }

    static JLabel buildUriButton(BufferedImage icon, String tooltip, String uriString) {
        return buildButton(icon, tooltip, () -> {
            try {
                Desktop desktop = Desktop.getDesktop();
                URI uri = new URI(uriString);
                desktop.browse(uri);
            } catch (Exception error) {}
        });
    }

    public static JPanel newVerticalBoxLayoutJPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        return panel;
    }
}

package com.flippingcopilot.ui;


import java.awt.Dimension;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JToggleButton;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

class PreferencesToggleButton extends JToggleButton
{
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;
    private final String unSelectedToolTipText;
    private final String selectedToolTipText;


    public PreferencesToggleButton(String selectedToolTipText, String unSelectedToolTipText) {
        super(OFF_SWITCHER);
        setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        setPreferredSize(new Dimension(25, 25));
        addItemListener(l -> updateTooltip());
        updateTooltip();
        this.selectedToolTipText = selectedToolTipText;
        this.unSelectedToolTipText = unSelectedToolTipText;
    }

    static
    {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(CopilotPanel.class, "/switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    private void updateTooltip()
    {
        setToolTipText(isSelected() ? selectedToolTipText :  unSelectedToolTipText);
    }
}

package com.flippingcopilot.ui;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
public class Paginator extends JPanel {

	public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
	public final Icon ARROW_RIGHT = new ImageIcon(ARROW_ICON);
	public final Icon HIGHLIGHTED_ARROW_RIGHT = new ImageIcon(ImageUtil.luminanceScale(ARROW_ICON, BUTTON_HOVER_LUMINANCE));
	public final Icon ARROW_LEFT = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)));
	public final Icon HIGHLIGHTED_ARROW_LEFT = new ImageIcon(ImageUtil.luminanceScale(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)), BUTTON_HOVER_LUMINANCE));

	@Getter
	private int pageNumber = 1;
	@Getter
	private int totalPages = 1;
	private final JLabel statusText = new JLabel("Page 1 of 1", SwingUtilities.CENTER);
	private final JLabel arrowRight= new JLabel(ARROW_RIGHT);
	private final JLabel arrowLeft =  new JLabel(ARROW_LEFT);
	private final Runnable onPageChange;

	public Paginator(Runnable onPageChange) {
		this.onPageChange = onPageChange;
		this.statusText.setFont(FontManager.getRunescapeFont());
		this.arrowRight.setForeground(Color.blue);
		setLayout(new FlowLayout());
		add(arrowLeft);
		add(statusText);
		add(arrowRight);
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(3, 0, 0, 0));
		arrowLeft.addMouseListener(onDecreasePage());
		arrowRight.addMouseListener(onIncreasePage());
	}

	public void setTotalPages(int totalPages) {
		this.totalPages = totalPages;
		if(pageNumber > this.totalPages) {
			pageNumber = 1;
		}
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	private MouseAdapter onIncreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber < totalPages) {
					pageNumber++;
					onPageChange.run();
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowRight.setIcon(HIGHLIGHTED_ARROW_RIGHT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowRight.setIcon(ARROW_RIGHT);
			}
		};
	}

	private MouseAdapter onDecreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber > 1) {
					pageNumber--;
					onPageChange.run();
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowLeft.setIcon(HIGHLIGHTED_ARROW_LEFT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowLeft.setIcon(ARROW_LEFT);
			}
		};
	}
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.CopilotLoginController;
import com.flippingcopilot.model.LoginResponseManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;;

import static com.flippingcopilot.ui.UIUtilities.buildButton;

@Singleton
public class MainPanel extends PluginPanel {

    // dependencies
    public final LoginPanel loginPanel;
    public final CopilotPanel copilotPanel;
    private final LoginResponseManager loginResponseManager;
    private final CopilotLoginController copilotLoginController;

    private Boolean isLoggedInView;

    @Inject
    public MainPanel(CopilotPanel copilotPanel,
                     LoginPanel loginPanel,
                     LoginResponseManager loginResponseManager,
                     CopilotLoginController copilotLoginController) {
        super(false);
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(5, 6, 5, 6));
        this.loginResponseManager = loginResponseManager;
        this.copilotPanel = copilotPanel;
        this.loginPanel = loginPanel;
        this.copilotLoginController = copilotLoginController;
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        boolean shouldBeLoggedInView = loginResponseManager.isLoggedIn();
        if(shouldBeLoggedInView) {
            if (isLoggedInView == null || !isLoggedInView) {
                renderLoggedInView();
            }
            copilotPanel.refresh();
        } else {
            if (isLoggedInView == null || isLoggedInView) {
                renderLoggedOutView();
            }
            loginPanel.refresh();
            copilotPanel.suggestionPanel.refresh();
        }
    }

    public void renderLoggedOutView() {
        removeAll();
        add(constructTopBar(false), BorderLayout.NORTH);
        loginPanel.showLoginErrorMessage("");
        add(loginPanel, BorderLayout.CENTER);
        revalidate();
        isLoggedInView = false;
    }

    public void renderLoggedInView() {
        removeAll();
        add(constructTopBar(true), BorderLayout.NORTH);
        add(copilotPanel, BorderLayout.CENTER);
        revalidate();
        isLoggedInView = true;
    }

    private JPanel constructTopBar(boolean isLoggedIn) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setLayout(new BorderLayout());
        JPanel topBar = new JPanel();
        topBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int columns = isLoggedIn ? 4 : 3;
        topBar.setLayout(new GridLayout(1, columns));

        JLabel github = buildTopBarUriButton(UIUtilities.githubIcon,
                "Flipping Copilot Github",
                "https://github.com/cbrewitt/flipping-copilot");
        topBar.add(github);

        JLabel discord = buildTopBarUriButton(UIUtilities.discordIcon,
                "Flipping Copilot Discord",
                "https://discord.gg/UyQxA4QJAq");
        topBar.add(discord);

        JLabel website = buildTopBarUriButton(UIUtilities.internetIcon,
                "Flipping Copilot website",
                "https://flippingcopilot.com");
        topBar.add(website);

        if (isLoggedIn) {
            BufferedImage icon = ImageUtil.loadImageResource(getClass(), UIUtilities.logoutIcon);
            JLabel logout = buildButton(icon, "Log out", () -> {
                copilotLoginController.onLogout();
                renderLoggedOutView();
            });
            topBar.add(logout);
        }

        container.add(topBar);
        container.setBorder(new EmptyBorder(3, 0, 10, 0));
        return container;
    }

    private JLabel buildTopBarUriButton(String iconPath, String tooltip, String uriString) {
        BufferedImage icon = ImageUtil.loadImageResource(getClass(), iconPath);
        return buildButton(icon, tooltip, () -> {
            LinkBrowser.browse(uriString);
        });
    }

}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.OfferHandler;
import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.Suggestion;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.widgets.*;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class OfferEditor {
    private final OfferManager offerManager;
    private final OfferHandler offerHandler;
    private final Client client;

    private Widget text;
    private static final int MOUSE_OFF_TEXT_COLOR = 0x0040FF;
    private static final int MOUSE_OFF_ERROR_TEXT_COLOR = 0xAA2222;

    public OfferEditor(OfferManager offerManager, Widget parent, OfferHandler offerHandler, Client client) {
        this.offerManager = offerManager;
        this.offerHandler = offerHandler;
        this.client = client;
        if (parent == null) {
            return;
        }

        text = parent.createChild(-1, WidgetType.TEXT);
        prepareTextWidget(text, WidgetTextAlignment.LEFT, WidgetPositionMode.ABSOLUTE_TOP, 40, 10);
    }

    private void prepareTextWidget(Widget widget, int xAlignment, int yMode, int yOffset, int xOffset) {
        widget.setTextColor(MOUSE_OFF_TEXT_COLOR);
        widget.setFontId(FontID.VERDANA_11_BOLD);
        widget.setYPositionMode(yMode);
        widget.setOriginalX(xOffset);
        widget.setOriginalY(yOffset);
        widget.setOriginalHeight(20);
        widget.setXTextAlignment(xAlignment);
        widget.setWidthMode(WidgetSizeMode.MINUS);
        widget.revalidate();
    }

    public void showSuggestion(Suggestion suggestion) {
        var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);
        if (offerHandler.isSettingQuantity()) {
            if (currentItemId != suggestion.getItemId()) {
                return;
            }
            if (!suggestion.getType().equals(offerHandler.getOfferType())) {
                return;
            }

            shiftChatboxWidgetsDown();
            showQuantity(suggestion.getQuantity());
        } else if (offerHandler.isSettingPrice()) {
            if (currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(offerHandler.getOfferType())) {
                int price = offerManager.getViewedSlotItemPrice();
                if (offerHandler.getViewedSlotPriceErrorText() != null && price <= 0) {
                    shiftChatboxWidgetsDown();
                    setErrorText(offerHandler.getViewedSlotPriceErrorText());
                    return;
                }

                if (offerManager.getViewedSlotItemId() == currentItemId) {
                    shiftChatboxWidgetsDown();
                    if (offerHandler.getViewedSlotPriceErrorText() != null) {
                        showPriceWithWarning(price, offerHandler.getViewedSlotPriceErrorText());
                    } else {
                        showPrice(price);
                    }
                }
            } else {
                shiftChatboxWidgetsDown();
                showPrice(suggestion.getPrice());
            }
        }
    }

    private void showQuantity(int quantity) {
        text.setText("set to Copilot quantity: " + quantity);
        text.setAction(1, "Set quantity");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(quantity);
        });
    }

    public void showPrice(int price) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp");
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(price);
        });
    }

    private void showPriceWithWarning(int price, String warning) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp. " + warning);
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(price);
        });
    }

    private void setHoverListeners(Widget widget) {
        widget.setHasListener(true);
        widget.setOnMouseRepeatListener((JavaScriptCallback) ev -> widget.setTextColor(0xFFFFFF));
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> widget.setTextColor(MOUSE_OFF_TEXT_COLOR));
    }

    private void setErrorText(String message) {
        text.setText(message);
        text.setTextColor(MOUSE_OFF_ERROR_TEXT_COLOR);
        text.revalidate();
    }

    private void shiftChatboxWidgetsDown() {
        Widget chatboxTitle = client.getWidget(ComponentID.CHATBOX_TITLE);
        if (chatboxTitle != null) {
            chatboxTitle.setOriginalY(chatboxTitle.getOriginalY() + 7);
            chatboxTitle.revalidate();
        }
    }
}
package com.flippingcopilot.ui;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

@Getter
public class Spinner extends JPanel {
    private final JLabel spinnerLabel = new JLabel();

    public Spinner() {
        setLayout(new GridBagLayout());
        setOpaque(false);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = GridBagConstraints.REMAINDER;
        gbc.gridy = GridBagConstraints.REMAINDER;
        gbc.weightx = 1;
        gbc.weighty = 1;
        gbc.anchor = GridBagConstraints.CENTER;

        spinnerLabel.setPreferredSize(new Dimension(30, 30));
        add(spinnerLabel, gbc);
        setUpIcon();
        hide();
    }

    public void show() {
        spinnerLabel.setVisible(true);
    }

    public void hide() {
        spinnerLabel.setVisible(false);
    }

    private void setUpIcon() {
        IconTextField.Icon icon = IconTextField.Icon.LOADING;
        final ImageIcon imageIcon = new ImageIcon(Objects.requireNonNull(IconTextField.class.getResource(icon.getFile())));
        spinnerLabel.setIcon(imageIcon);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.GrandExchange;
import com.flippingcopilot.controller.HighlightController;
import com.flippingcopilot.model.*;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;

import static com.flippingcopilot.ui.UIUtilities.*;
import static com.flippingcopilot.util.Constants.MIN_GP_NEEDED_TO_FLIP;


@Singleton
@Slf4j
public class SuggestionPanel extends JPanel {

    // dependencies
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final AccountStatusManager accountStatusManager;
    public final PauseButton pauseButton;
    private final BlockButton blockButton;
    private final OsrsLoginManager osrsLoginManager;
    private final Client client;
    private final PausedManager pausedManager;
    private final GrandExchangeUncollectedManager uncollectedManager;
    private final ClientThread clientThread;
    private final HighlightController highlightController;
    private final ItemManager itemManager;
    private final GrandExchange grandExchange;

    private final JLabel suggestionText = new JLabel();
    private final JLabel suggestionIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png")));
    private final JPanel suggestionTextContainer = new JPanel();
    public final Spinner spinner = new Spinner();
    private JLabel skipButton;
    private final JPanel buttonContainer = new JPanel();
    private JLabel graphButton;
    private final JPanel suggestedActionPanel;
    private final PreferencesPanel preferencesPanel;
    private final JLayeredPane layeredPane = new JLayeredPane();
    private boolean isPreferencesPanelVisible = false;
    private final JLabel gearButton;
    private String innerSuggestionMessage;

    @Setter
    private String serverMessage = "";


    @Inject
    public SuggestionPanel(FlippingCopilotConfig config,
                           SuggestionManager suggestionManager,
                           AccountStatusManager accountStatusManager,
                           PauseButton pauseButton,
                           BlockButton blockButton,
                           PreferencesPanel preferencesPanel,
                           OsrsLoginManager osrsLoginManager,
                           Client client, PausedManager pausedManager,
                           GrandExchangeUncollectedManager uncollectedManager,
                           ClientThread clientThread,
                           HighlightController highlightController,
                           ItemManager itemManager,
                           GrandExchange grandExchange) {
        this.preferencesPanel = preferencesPanel;
        this.config = config;
        this.suggestionManager = suggestionManager;
        this.accountStatusManager = accountStatusManager;
        this.pauseButton = pauseButton;
        this.blockButton = blockButton;
        this.osrsLoginManager = osrsLoginManager;
        this.client = client;
        this.pausedManager = pausedManager;
        this.uncollectedManager = uncollectedManager;
        this.clientThread = clientThread;
        this.highlightController = highlightController;
        this.itemManager = itemManager;
        this.grandExchange = grandExchange;

        // Create the layered pane first
        layeredPane.setLayout(null);  // LayeredPane needs null layout

        // Create a main panel that will hold all the regular components
        suggestedActionPanel = new JPanel(new BorderLayout());
        suggestedActionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestedActionPanel.setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        suggestedActionPanel.setBounds(0, 0, 300, 150);  // Set appropriate size
        JLabel title = new JLabel("<html><center> <FONT COLOR=white><b>Suggested Action:" +
                "</b></FONT></center></html>");
        title.setHorizontalAlignment(SwingConstants.CENTER);
        suggestedActionPanel.add(title, BorderLayout.NORTH);

        JPanel suggestionContainer = new JPanel();
        suggestionContainer.setLayout(new CardLayout());
        suggestionContainer.setOpaque(true);
        suggestionContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.setPreferredSize(new Dimension(0, 85));
        suggestedActionPanel.add(suggestionContainer, BorderLayout.CENTER);

        suggestionTextContainer.setLayout(new BoxLayout(suggestionTextContainer, BoxLayout.X_AXIS));
        suggestionTextContainer.add(Box.createHorizontalGlue());
        suggestionTextContainer.add(suggestionIcon);
        suggestionTextContainer.add(suggestionText);
        suggestionTextContainer.add(Box.createHorizontalGlue());
        suggestionTextContainer.setOpaque(true);
        suggestionTextContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionIcon.setVisible(false);
        suggestionIcon.setOpaque(true);
        suggestionIcon.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionIcon.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));

        suggestionText.setHorizontalAlignment(SwingConstants.CENTER);
        suggestionText.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 6));
        suggestionContainer.add(suggestionTextContainer);

        suggestionContainer.add(spinner);
        setupButtonContainer();
        suggestedActionPanel.add(buttonContainer, BorderLayout.SOUTH);




        layeredPane.add(suggestedActionPanel, JLayeredPane.DEFAULT_LAYER);

        // Build the suggestion preferences panel:
        this.preferencesPanel.setVisible(false);
        layeredPane.add(this.preferencesPanel, JLayeredPane.DEFAULT_LAYER);

        // Create and add the gear button
        BufferedImage gearIcon = ImageUtil.loadImageResource(getClass(), "/preferences-icon.png");
        gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
        BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
        gearButton = buildButton(recoloredIcon, "Settings", () -> {});
        gearButton.setEnabled(true);
        gearButton.setFocusable(true);
        gearButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        gearButton.setOpaque(true);
        ImageIcon iconOff = new ImageIcon(recoloredIcon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(recoloredIcon, BUTTON_HOVER_LUMINANCE));
        // Replace the existing gear button MouseAdapter with this implementation
        gearButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (!SwingUtilities.isEventDispatchThread()) {
                    SwingUtilities.invokeLater(() -> handleGearClick());
                    return;
                }
                handleGearClick();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                gearButton.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                gearButton.setIcon(iconOff);
            }
        });
        gearButton.setOpaque(true);
        gearButton.setBounds(5, 5, 20, 20);
        layeredPane.add(gearButton, JLayeredPane.PALETTE_LAYER);

        // Set up the main panel
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setPreferredSize(new Dimension(0, 150));

        add(layeredPane);

        // Add a component listener to handle resizing
        addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                preferencesPanel.setBounds(0, 0, getWidth(), getHeight());
                suggestedActionPanel.setBounds(0, 0, getWidth(), getHeight());
                layeredPane.setPreferredSize(new Dimension(getWidth(), getHeight()));
            }
        });
    }

    // Add this as a private method in the class
    private void handleGearClick() {
        log.debug("clicked suggestion preferences");
        isPreferencesPanelVisible = !isPreferencesPanelVisible;
        preferencesPanel.setVisible(isPreferencesPanelVisible);
        suggestedActionPanel.setVisible(!isPreferencesPanelVisible);
        refresh();
        layeredPane.revalidate();
        layeredPane.repaint();
    }

    private void setupButtonContainer() {
        buttonContainer.setLayout(new BorderLayout());
        buttonContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    
        JPanel centerPanel = new JPanel(new GridLayout(1, 5, 15, 0));
        centerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    
        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/graph.png");
        graphButton = buildButton(graphIcon, "Price graph", () -> {
            Suggestion suggestion = suggestionManager.getSuggestion();
            String url = config.priceGraphWebsite().getUrl(suggestion.getName(), suggestion.getItemId());
            LinkBrowser.browse(url);
        });
        centerPanel.add(graphButton);
    
        JPanel emptyPanel = new JPanel();
        emptyPanel.setOpaque(false);
        centerPanel.add(emptyPanel);
        centerPanel.add(pauseButton);
        centerPanel.add(blockButton);
    
        BufferedImage skipIcon = ImageUtil.loadImageResource(getClass(), "/skip.png");
        skipButton = buildButton(skipIcon, "Skip suggestion", () -> {
            showLoading();
            Suggestion s = suggestionManager.getSuggestion();
            accountStatusManager.setSkipSuggestion(s != null ? s.getId() : -1);
            suggestionManager.setSuggestionNeeded(true);
        });
        centerPanel.add(skipButton);
        
        buttonContainer.add(centerPanel, BorderLayout.CENTER);
    }

    private void setupGraphButton() {
        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/graph.png");
        graphButton = buildButton(graphIcon, "Price graph", () -> {
            Suggestion suggestion = suggestionManager.getSuggestion();
            String url = config.priceGraphWebsite().getUrl(suggestion.getName(), suggestion.getItemId());
            LinkBrowser.browse(url);
        });
        buttonContainer.add(graphButton, BorderLayout.WEST);
    }

    private void setupPauseButton() {
        Box box = Box.createHorizontalBox();
        box.add(Box.createHorizontalGlue());
        box.add(pauseButton);
        box.add(Box.createHorizontalGlue());
        buttonContainer.add(box, BorderLayout.CENTER);
    }


    private void setItemIcon(int itemId) {
        AsyncBufferedImage image = itemManager.getImage(itemId);
        if (image != null) {
            image.addTo(suggestionIcon);
            suggestionIcon.setVisible(true);
        }
    }


    public void updateSuggestion(Suggestion suggestion) {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String suggestionString = "<html><center>";
        suggestionTextContainer.setVisible(false);

        switch (suggestion.getType()) {
            case "wait":
                suggestionString += "Wait <br>";
                break;
            case "abort":
                suggestionString += "Abort offer for<br><FONT COLOR=white>" + suggestion.getName() + "<br></FONT>";
                setItemIcon(suggestion.getItemId());
                break;
            case "buy":
            case "sell":
                String capitalisedAction = suggestion.getType().equals("buy") ? "Buy" : "Sell";
                suggestionString += capitalisedAction +
                        " <FONT COLOR=yellow>" + formatter.format(suggestion.getQuantity()) + "</FONT><br>" +
                        "<FONT COLOR=white>" + suggestion.getName() + "</FONT><br>" +
                        "for <FONT COLOR=yellow>" + formatter.format(suggestion.getPrice()) + "</FONT> gp<br>";
                setItemIcon(suggestion.getItemId());
                break;
            default:
                suggestionString += "Error processing suggestion<br>";
        }
        suggestionString += suggestion.getMessage();
        suggestionString += "</center><html>";
        innerSuggestionMessage = "";
        if(!suggestion.getType().equals("wait")) {
            setButtonsVisible(true);
        }
        suggestionText.setText(suggestionString);
        suggestionText.setMaximumSize(new Dimension(suggestionText.getPreferredSize().width, Integer.MAX_VALUE));
        suggestionTextContainer.setVisible(true);
        suggestionTextContainer.revalidate();
        suggestionTextContainer.repaint();
    }

    public void suggestCollect() {
        setMessage("Collect items");
        setButtonsVisible(false);
    }

    public void suggestAddGp() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        setMessage("Add " +
                "at least <FONT COLOR=yellow>" + formatter.format(MIN_GP_NEEDED_TO_FLIP)
                               + "</FONT> gp<br>to your inventory<br>"
                               + "to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void suggestOpenGe() {
        setMessage("Open the Grand Exchange<br>"
                + "to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void setIsPausedMessage() {
        setMessage("Suggestions are paused");
        setButtonsVisible(false);
    }

    public void setMessage(String message) {
        innerSuggestionMessage = message;
        setButtonsVisible(false);
        suggestionText.setText("<html><center>" + innerSuggestionMessage +  "<br>" + serverMessage + "</center><html>");
        suggestionText.setMaximumSize(new Dimension(suggestionText.getPreferredSize().width, Integer.MAX_VALUE));
        suggestionTextContainer.revalidate();
        suggestionTextContainer.repaint();
    }

    public boolean isCollectItemsSuggested() {
        return suggestionText.isVisible() && "Collect items".equals(innerSuggestionMessage);
    }

    public void showLoading() {
        suggestionTextContainer.setVisible(false);
        setServerMessage("");
        spinner.show();
        setButtonsVisible(false);
        suggestionIcon.setVisible(false);
        suggestionText.setText("");
    }

    public void hideLoading() {
        spinner.hide();
        suggestionTextContainer.setVisible(true);
    }

    private void setButtonsVisible(boolean visible) {
        skipButton.setVisible(visible);
        blockButton.setVisible(visible);
        graphButton.setVisible(visible);
        suggestionIcon.setVisible(visible);
    }

    public void displaySuggestion() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return;
        }
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        setServerMessage(suggestion.getMessage());
        boolean collectNeeded = accountStatus.isCollectNeeded(suggestion);
        if(collectNeeded && !uncollectedManager.HasUncollected(osrsLoginManager.getAccountHash())) {
            log.warn("tick {} collect is suggested but there is nothing to collect! suggestion: {} {} {}", client.getTickCount(), suggestion.getType(), suggestion.getQuantity(), suggestion.getItemId());
        }
        if (collectNeeded) {
            suggestCollect();
        } else if (suggestion.getType().equals("wait") && accountStatus.moreGpNeeded()) {
            suggestAddGp();
        } else if(suggestion.getType().equals("wait") && !grandExchange.isOpen() && accountStatus.emptySlotExists()) {
            suggestOpenGe();
        } else {
            updateSuggestion(suggestion);
        }
        highlightController.redraw();
    }

    public void refresh() {
        log.debug("refreshing suggestion panel {}", client.getGameState());
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        if(isPreferencesPanelVisible) {
            preferencesPanel.refresh();
        }
        if (pausedManager.isPaused()) {
            setIsPausedMessage();
            hideLoading();
            return;
        }

        String errorMessage = osrsLoginManager.getInvalidStateDisplayMessage();
        if (errorMessage != null) {
            setMessage(errorMessage);
            hideLoading();
        }

        if(suggestionManager.isSuggestionRequestInProgress()) {
            showLoading();
            return;
        }
        hideLoading();

        final HttpResponseException suggestionError = suggestionManager.getSuggestionError();
        if(suggestionError != null) {
            highlightController.redraw();
            setMessage("Error: " + suggestionError.getMessage());
            return;
        }

        if(!client.isClientThread()) {
            clientThread.invoke(this::displaySuggestion);
        } else {
            displaySuggestion();
        }
    }
}

/*
 * Copyright (c) 2023, LlemonDuck <napkinorton@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import net.runelite.api.ItemComposition;
import org.apache.commons.text.similarity.JaroWinklerDistance;
import org.apache.commons.text.similarity.LongestCommonSubsequence;
import org.apache.commons.text.similarity.SimilarityScore;

import javax.inject.Singleton;
import java.util.function.ToDoubleFunction;

@Singleton
public class FuzzySearchScorer
{

	// can be swapped, but i found jaro-winkler to do well considering the variable length of inputs
	// whereas levenshtein biases toward strings of same len, regardless of overlap
	private final SimilarityScore<Double> baseAlgorithm = new JaroWinklerDistance();

	public Double score(String query, String itemName)
	{
		query = query.toLowerCase().replace('-', ' ');
		itemName = itemName.toLowerCase().replace('-', ' ');

		// we raise the score for longest substring of a word, scoring within [0,1]
		String[] queryWords = query.split(" ");
		String[] itemWords = itemName.split(" ");
		double lcsScore = 0.0;
		for (String queryWord : queryWords)
		{
			for (String itemWord : itemWords)
			{
				int lcsLen = new LongestCommonSubsequence().longestCommonSubsequence(queryWord, itemWord).length();
				lcsScore = Math.max(lcsScore, ((double) lcsLen) / queryWord.length());
			}
		}

		// and also raise the score for string "closeness", but strongly prefer high closeness, scoring within [-0.5,0.5]
		double proximityScore = Math.log10(10 * baseAlgorithm.apply(query, itemName)) - 0.5;

		// subtract 1.0 to filter out low-scoring results
		return lcsScore + proximityScore - 1.0;
	}

	public ToDoubleFunction<ItemComposition> comparator(String query)
	{
		// We do this so that for example the items "Anti-venom ..." are still at the top
		// when searching "anti venom"
		return item -> score(
			query.toLowerCase().replace('-', ' '),
			item.getName().toLowerCase().replace('-', ' ')
		);
	}

}

package com.flippingcopilot.ui;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import java.awt.*;

public class GpDropOverlay extends Overlay {
    private final OverlayManager overlayManager;
    private final long startTime;
    private final Point startPosition = new Point(); // Starting position of the text
    final TextComponent textComponent = new TextComponent();

    public GpDropOverlay(OverlayManager overlayManager, Client client, long profit, int slot) {
        this.overlayManager = overlayManager;
        this.startTime = System.currentTimeMillis();

        Widget slotWidget = client.getWidget(465, slot + 7);
        if (slotWidget == null) {
            return;
        }
        startPosition.x = slotWidget.getCanvasLocation().getX() + 35;
        startPosition.y = slotWidget.getCanvasLocation().getY() + 75;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        String absProfitText = UIUtilities.quantityToRSDecimalStack(Math.abs(profit), false);
        String profitText = (profit >= 0 ? "+ " : "- ") + absProfitText + " gp";
        textComponent.setText(profitText);
        textComponent.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 16f));
        if (profit < 0) {
            textComponent.setColor(Color.RED);
        } else {
            textComponent.setColor(Color.GREEN);
        }
        overlayManager.add(this);
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        long elapsed = System.currentTimeMillis() - startTime;
        if (elapsed > 3000) { // Display for 5 seconds
            overlayManager.remove(this);
            return null;
        }

        // Calculate the upward movement. Adjust the divisor to control the speed.
        int yOffset = (int) (elapsed / 50); // Moves up 1 pixel every 50ms

        // Ensure the text moves upwards by subtracting yOffset from the starting Y position
        Point currentPosition = new Point(startPosition.x, startPosition.y - yOffset);
        textComponent.setPosition(currentPosition);
        textComponent.render(graphics);

        return null;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.FlipV2;
import net.runelite.client.ui.ColorScheme;

import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;

public class FlipPanel extends JPanel {

    public FlipPanel(FlipV2 flip, FlippingCopilotConfig config) {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel itemQuantity = new JLabel(String.format("%d x ", flip.getClosedQuantity()));
        itemQuantity.setForeground(Color.WHITE);

        JLabel itemNameLabel = new JLabel(UIUtilities.truncateString(flip.getItemName(), 20));

        // Create a sub-panel for the left side
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        leftPanel.add(itemQuantity);
        leftPanel.add(itemNameLabel);

        JLabel profitLabel = new JLabel(UIUtilities.formatProfitWithoutGp(flip.getProfit()));
        profitLabel.setForeground(UIUtilities.getProfitColor(flip.getProfit(), config));

        // Add the sub-panel to the LINE_START position
        add(leftPanel, BorderLayout.LINE_START);
        add(profitLabel, BorderLayout.LINE_END);
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));

        String closeLabel = flip.getClosedQuantity() == flip.getOpenedQuantity() ? "Close time" : "Partial close time";

        String tooltipText = String.format("Opened time: %s\nAvg buy price: %s\n%s: %s\nAvg sell price: %s\nTax paid: %s\nProfit: %s",
                formatEpoch(flip.getOpenedTime()),
                UIUtilities.formatProfit(flip.getAvgBuyPrice()),
                closeLabel,
                formatEpoch(flip.getClosedTime()),
                UIUtilities.formatProfit(flip.getAvgSellPrice()),
                UIUtilities.formatProfit(flip.getTaxPaid()),
                UIUtilities.formatProfit(flip.getProfit()));
        setToolTipText(tooltipText);
    }

    public static String formatEpoch(long epochSeconds) {
        Instant instant = Instant.ofEpochSecond(epochSeconds);
        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)
                .withZone(ZoneId.systemDefault());
        return formatter.format(instant);
    }
}
package com.flippingcopilot.ui;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class BlacklistIcons {

    public static ImageIcon createTickIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();

        g2d.setColor(new Color(40, 167, 69));
        g2d.setStroke(new BasicStroke(2));
        g2d.drawLine(3, 8, 7, 12);
        g2d.drawLine(7, 12, 13, 4);
        g2d.dispose();

        return new ImageIcon(image);
    }

    public static ImageIcon createXIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();

        g2d.setColor(new Color(220, 53, 69));
        g2d.setStroke(new BasicStroke(2));
        g2d.drawLine(4, 4, 12, 12);
        g2d.drawLine(4, 12, 12, 4);
        g2d.dispose();

        return new ImageIcon(image);
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.model.SuggestionPreferencesManager;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import org.apache.commons.lang3.tuple.Pair;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;

@Slf4j
@Singleton
public class BlacklistDropdownPanel extends JPanel {
    private final SuggestionPreferencesManager preferencesManager;
    private final JTextField displayField;
    private final JWindow dropdownWindow;
    private final JPanel resultsPanel;
    private final JScrollPane scrollPane;
    private final JTextField searchField;
    private final ClientThread clientThread;

    @Inject
    public BlacklistDropdownPanel(SuggestionPreferencesManager preferencesManager, ClientThread clientThread) {
        super();
        this.preferencesManager = preferencesManager;
        this.clientThread = clientThread;

        setLayout(new BorderLayout());

        // Create main display field with placeholder
        displayField = new JTextField("Search an item...");
        displayField.setEditable(true);
        displayField.setPreferredSize(new Dimension(12, displayField.getPreferredSize().height));
        displayField.setForeground(Color.GRAY);

        // Create label
        JLabel label = new JLabel("Blocklist:");
        label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));
        label.setOpaque(true);
        label.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Setup display field panel
        JPanel dropdownPanel = new JPanel(new BorderLayout());
        dropdownPanel.add(displayField, BorderLayout.CENTER);
        dropdownPanel.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));

        // Create container panel
        JPanel containerPanel = new JPanel(new BorderLayout(5, 0));
        containerPanel.add(label, BorderLayout.WEST);
        containerPanel.add(dropdownPanel, BorderLayout.CENTER);
        containerPanel.setOpaque(true);
        containerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        add(containerPanel, BorderLayout.CENTER);

        // Setup dropdown components
        dropdownWindow = new JWindow();
        searchField = new JTextField();
        resultsPanel = new JPanel();
        resultsPanel.setLayout(new BoxLayout(resultsPanel, BoxLayout.Y_AXIS));

        scrollPane = new JScrollPane(resultsPanel);
        scrollPane.setPreferredSize(new Dimension(300, 400));

        // Create dropdown content panel
        JPanel dropdownContent = new JPanel(new BorderLayout());
        dropdownContent.add(searchField, BorderLayout.NORTH);
        dropdownContent.add(scrollPane, BorderLayout.CENTER);
        dropdownContent.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));

        dropdownWindow.add(dropdownContent);

        setupListeners();
    }

    private void updateDropdown(String searchText) {
        clientThread.invoke(() -> {
            // Get fresh data
            List<Pair<Integer, String>> searchResults = preferencesManager.search(searchText);
            Set<Integer> blockedItems = new HashSet<>(preferencesManager.blockedItems());

            SwingUtilities.invokeLater(() -> {

                // Update results panel
                resultsPanel.removeAll();
                for (Pair<Integer, String> item : searchResults) {
                    resultsPanel.add(createItemPanel(item, blockedItems));
                }
                // Calculate dimensions
                Point location = getLocationOnScreen();
                int searchHeight = searchField.getPreferredSize().height;
                int scrollBarHeight = scrollPane.getHorizontalScrollBar().getPreferredSize().height;
                int contentHeight = Arrays.stream(resultsPanel.getComponents())
                        .mapToInt(comp -> comp.getPreferredSize().height)
                        .sum();

                int totalHeight = Math.min(
                        contentHeight + searchHeight + scrollBarHeight + 12, // 12 for border and padding
                        400 // Maximum height
                );

                // Update window
                dropdownWindow.setLocation(location.x, location.y + getHeight());
                dropdownWindow.setSize(getWidth(), totalHeight);
                dropdownWindow.setVisible(true);

                // Update UI
                resultsPanel.revalidate();
                resultsPanel.repaint();
                searchField.setText(searchText);
            });
        });
    }

    private void setupListeners() {

        displayField.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                log.debug("mouse clicked");
                updateDropdown(displayField.getText());
            }
        });

        displayField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                if (displayField.getText().equals("Search an item...")) {
                    displayField.setText("");
                    updateDropdown(displayField.getText());
                }
            }

            @Override
            public void focusLost(FocusEvent e) {
                log.debug("focus lost");
                displayField.setText("Search an item...");
                displayField.setForeground(Color.GRAY);
                dropdownWindow.setVisible(false);
            }
        });

        // Display field key listener
        displayField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    updateDropdown(displayField.getText());
                    e.consume();
                }
            }
        });
    }

    private JPanel createItemPanel(Pair<Integer, String> item, Set<Integer> blockedItemIds) {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(BorderFactory.createEmptyBorder(1, 2, 1, 2));

        JLabel nameLabel = new JLabel(item.getValue());
        panel.add(nameLabel, BorderLayout.CENTER);

        JButton toggleButton = new JButton(blockedItemIds.contains(item.getKey()) ? BlacklistIcons.createXIcon() : BlacklistIcons.createTickIcon());
        toggleButton.setBorderPainted(false);
        toggleButton.setContentAreaFilled(false);
        toggleButton.setPreferredSize(new Dimension(16, 16));

         Runnable onClick = () -> {
            if (blockedItemIds.contains(item.getKey())) {
                preferencesManager.unblockItem(item.getKey());
                blockedItemIds.remove(item.getKey());
                toggleButton.setIcon(BlacklistIcons.createTickIcon());
            } else {
                preferencesManager.blockItem(item.getKey());
                blockedItemIds.add(item.getKey());
                toggleButton.setIcon(BlacklistIcons.createXIcon());
            }
            panel.revalidate();
            panel.repaint();
        };

        toggleButton.addActionListener(e -> onClick.run());

        panel.add(toggleButton, BorderLayout.EAST);

        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent ee) {
                onClick.run();
            }
        });
        return panel;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.CopilotLoginController;
import net.runelite.client.input.KeyListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;


@Singleton
public class LoginPanel extends JPanel {
    private final static int PAGE_WIDTH = 225;

    private final CopilotLoginController copilotLoginController;

    private JPanel loginContainer;
    private JButton loginButton;
    private JTextField emailTextField;
    private JTextField passwordTextField;
    private JLabel errorMessageLabel;

    public final Spinner spinner = new Spinner();

    @Inject
    public LoginPanel(CopilotLoginController copilotLoginController) {
        this.copilotLoginController = copilotLoginController;
        this.setLayout(new BorderLayout());
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.setSize(PAGE_WIDTH, 250);

        loginContainer = new JPanel();
        loginContainer.setLayout(new BoxLayout(loginContainer, BoxLayout.PAGE_AXIS));

        this.createLogo();
        this.createSpinner();
        this.createErrorMessageLabel();
        this.createEmailInput();
        this.createPasswordInput();
        this.createLoginButton();
        this.createCreateAccountLink();

        this.add(loginContainer, BorderLayout.NORTH);
    }

    public void createLogo() {
        JPanel container = new JPanel();
        ImageIcon icon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/logo.png"));
        Image resizedLogo = icon.getImage().getScaledInstance(50, 45, Image.SCALE_SMOOTH);
        JLabel logoLabel = new JLabel(new ImageIcon(resizedLogo));
        logoLabel.setSize(50, 45);
        container.add(logoLabel, BorderLayout.CENTER);
        container.setBorder(new EmptyBorder(10, 0, 10, 0));
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createSpinner() {
        JPanel container = new JPanel();
        container.add(spinner, BorderLayout.CENTER);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void startLoading() {
        spinner.show();
        loginButton.setEnabled(false);
        errorMessageLabel.setText("");
        errorMessageLabel.setVisible(false);
    }

    public void endLoading() {
        spinner.hide();
        loginButton.setEnabled(true);
    }

    public void createErrorMessageLabel() {
        JPanel container = new JPanel();
        errorMessageLabel = new JLabel();
        errorMessageLabel.setForeground(Color.RED);
        errorMessageLabel.setHorizontalAlignment(SwingConstants.LEFT);
        errorMessageLabel.setSize(PAGE_WIDTH, 40);
        errorMessageLabel.setVisible(false);
        container.add(errorMessageLabel); // Add the error message label under the logo
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createEmailInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        emailTextField = new JTextField();
        emailTextField.setSize(PAGE_WIDTH, 40);
        emailTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                copilotLoginController.onEmailTextChanged(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        emailTextField.addActionListener(copilotLoginController::onLoginPressed);
        JLabel emailLabel = new JLabel("Email address");
        container.add(emailLabel, BorderLayout.WEST);
        container.add(emailTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createPasswordInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        passwordTextField = new JPasswordField();
        passwordTextField.setSize(PAGE_WIDTH, 40);
        passwordTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                copilotLoginController.onPasswordTextChanged(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        passwordTextField.addActionListener(copilotLoginController::onLoginPressed);
        JLabel passwordLabel = new JLabel("Password");
        container.add(passwordLabel);
        container.add(passwordTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createCreateAccountLink() {
        JPanel container = new JPanel();
        JLabel createAccountLabel = new JLabel("Don't have an account? Sign up.");
        createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        createAccountLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                LinkBrowser.browse("https://flippingcopilot.com/signup");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.BRAND_ORANGE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            }
        });
        container.add(createAccountLabel);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createLoginButton() {
        JPanel container = new JPanel();
        loginButton = new JButton("Login");
        loginButton.addActionListener(copilotLoginController::onLoginPressed);
        container.add(loginButton);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void showLoginErrorMessage(String message) {
        errorMessageLabel.setText("<html><p>" + message + "</p></html>");
        errorMessageLabel.setVisible(true);
    }

    public void refresh() {

    }
}

package com.flippingcopilot.util;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class GeTaxTest {

    @Test
    public void postTaxPriceForExemptItemReturnsOriginalPrice() {
        int itemId = 13190;
        int price = 1000;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceNormalItem() {
        int itemId = 9999;
        int price = 1000;
        assertEquals(990, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceAboveCap() {
        int itemId = 9999;
        int price = 600000000;
        assertEquals(595000000, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceCheapItem() {
        int itemId = 13190;
        int price = 67;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }
}
//package com.flippingcopilot.controller;
//
//import net.runelite.api.GrandExchangeOffer;
//import net.runelite.api.GrandExchangeOfferState;
//import net.runelite.api.events.GrandExchangeOfferChanged;
//import org.junit.Test;
//
//import java.util.ArrayList;
//
//public class OfferEventFilterTest {
//
//    @Test
//    public void testShouldProcessOnLogin() {
//        OfferEventFilter filter = new OfferEventFilter();
//
//        ArrayList<GrandExchangeOfferChanged> events = new ArrayList<>();
//        ArrayList<Boolean> expectedReturnValues = new ArrayList<>();
//
//        events.add(mockOfferEvent(0, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(1, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(3, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(4, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(6, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//
//        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//
//        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//
//        for (int i = 0; i < events.size(); i++) {
//            assert filter.shouldProcess(events.get(i)) == expectedReturnValues.get(i);
//        }
//    }
//
//    @Test
//    public void testShouldProcessNewBuyOffer() {
//        OfferEventFilter filter = new OfferEventFilter();
//        GrandExchangeOfferChanged event1 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert filter.shouldProcess(event1);
//        GrandExchangeOfferChanged event2 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert !filter.shouldProcess(event2);
//    }
//
//    @Test
//    public void testLogoutLogin() {
//        OfferEventFilter filter = new OfferEventFilter();
//        GrandExchangeOfferChanged event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert filter.shouldProcess(event);
//
//
//        for (int i = 0; i < 8; i++) {
//            event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
//            assert !filter.shouldProcess(event);
//        }
//
//        for (int i = 0; i < 8; i++) {
//            if (i == 2) {
//                event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//                assert !filter.shouldProcess(event);
//            } else {
//                event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
//                assert filter.shouldProcess(event);
//            }
//        }
//
//        event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert !filter.shouldProcess(event);
//    }
//
//    static GrandExchangeOfferChanged mockOfferEvent(int slot, int itemId, int quantitySold, int totalQuantity,
//                                                    int price, int spent, GrandExchangeOfferState state) {
//        GrandExchangeOfferChanged event = new GrandExchangeOfferChanged();
//        event.setSlot(slot);
//        event.setOffer(new GrandExchangeOffer() {
//            @Override
//            public int getQuantitySold() {
//                return quantitySold;
//            }
//
//            @Override
//            public int getItemId() {
//                return itemId;
//            }
//
//            @Override
//            public int getTotalQuantity() {
//                return totalQuantity;
//            }
//
//            @Override
//            public int getPrice() {
//                return price;
//            }
//
//            @Override
//            public int getSpent() {
//                return spent;
//            }
//
//            @Override
//            public GrandExchangeOfferState getState() {
//                return state;
//            }
//        });
//        return event;
//    }
//
//
//}

package com.flippingcopilot.controller;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;


public class DoesNothingExecutorService implements ScheduledExecutorService {
    @Override
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public void shutdown() {

    }

    @Override
    public List<Runnable> shutdownNow() {
        return List.of();
    }

    @Override
    public boolean isShutdown() {
        return false;
    }

    @Override
    public boolean isTerminated() {
        return false;
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return false;
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return null;
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return null;
    }

    @Override
    public Future<?> submit(Runnable task) {
        return null;
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return null;
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return null;
    }

    @Override
    public void execute(Runnable command) {

    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import org.junit.Test;

public class TestSuggestionController {

    @Test
    public void testShouldNotifyOnWait() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 1, "");
        assert !SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnNewBuy() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "");
        assert SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnRepeatedBuy() {
        Suggestion oldSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 0, "");;
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "");
        assert !SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnAbort() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("abort", 0, 560, 200, 25000, "Death rune", 1, "");
        assert SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }
}

package com.flippingcopilot.model;

import org.junit.Test;


public class OfferListTest {
    @Test
    public void testIsEmptySlotNeededWithExistingOfferInSlot() {
        StatusOfferList offerList = new StatusOfferList();
        offerList.set(0, new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "");
        assert !offerList.isEmptySlotNeeded(suggestion);
    }

    @Test
    public void testIsEmptySlotNeededWithNoEmptySlots() {
        StatusOfferList offerList = new StatusOfferList();
        offerList.replaceAll(ignored -> new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "");
        assert offerList.isEmptySlotNeeded(suggestion);
    }

}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.DoesNothingExecutorService;
import okhttp3.OkHttpClient;
import org.junit.Assert;
import org.junit.Test;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlipManagerTest {

    private static final String DISPLAY_NAME_1 = "Acc 1";
    private static final String DISPLAY_NAME_2 = "Acc 2";
    private static final String DISPLAY_NAME_3 = "Acc 3";
    private final Map<String, Integer> displayNameToAccountId = Map.of(DISPLAY_NAME_1, 0, DISPLAY_NAME_2, 1, DISPLAY_NAME_3, 2);

    @Test
    public void testOneAccount() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 10_000, List.of(0));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null, new DoesNothingExecutorService(), new OkHttpClient.Builder().build());
        flipManager.setFlipsChangedCallback(() -> {});
        flipManager.displayNameToAccountId.putAll(displayNameToAccountId);
        flipManager.mergeFlips(flips, null);
        flipManager.setIntervalDisplayName(DISPLAY_NAME_1);


        verifyflipManagerStoredOrder(flipManager);

        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(FlipV2::getId));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        for (int time : testTimes) {
            flipManager.setIntervalStartTime(time);

            // check stats equal
            Stats stats1 = flipManager.getIntervalStats();
            Stats stats2 = expectedStats(flips, time, DISPLAY_NAME_1);
            Assert.assertEquals(stats1, stats2);

            // check all flips equal
            List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
            List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), DISPLAY_NAME_1);
            assertFlipListsEqual(allFlips1, allFlips2);

            // check paginated flips equal
            for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                int numPages = stats1.flipsMade / pageSize + 1;
                for(int page=1; page <= numPages; page++) {
                    List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, DISPLAY_NAME_1);
                    List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                    assertFlipListsEqual(pageFlips1, pageFlips2);
                }
            }
        }
    }

    @Test
    public void testMultipleAccounts() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 5_000, List.of(0, 1, 2));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null, new DoesNothingExecutorService(), new OkHttpClient.Builder().build());
        flipManager.setFlipsChangedCallback(() -> {});
        flipManager.displayNameToAccountId.putAll(displayNameToAccountId);
        flipManager.mergeFlips(flips, null);
        verifyflipManagerStoredOrder(flipManager);


        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(Comparator.comparing(FlipV2::getId).reversed()));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        flipManager.setIntervalDisplayName(null);
        List<FlipV2> flips1 = flipManager.getPageFlips(1, flips.size());
        assertFlipListsEqual(flips1, flips);

        for (String name : Arrays.asList(DISPLAY_NAME_1, DISPLAY_NAME_2, DISPLAY_NAME_3, null)) {
            flipManager.setIntervalDisplayName(name);
            for (int time : testTimes) {
                flipManager.setIntervalStartTime(time);

                // check stats equal
                Stats stats1 = flipManager.getIntervalStats();
                Stats stats2 = expectedStats(flips, time, name);
                Assert.assertEquals(stats1, stats2);

                // check all flips equal
                List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
                List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), name);
                assertFlipListsEqual(allFlips1, allFlips2);

                // check paginated flips equal
                for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                    int numPages = stats1.flipsMade / pageSize + 1;
                    for (int page = 1; page <= numPages; page++) {
                        List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                        List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, name);
                        assertFlipListsEqual(pageFlips1, pageFlips2);
                    }
                }
            }
        }
    }

    public void verifyflipManagerStoredOrder(FlipManager flipManager) {
        for (int i =0; i < flipManager.weeks.size(); i++) {
            Assert.assertTrue(flipManager.weeks.get(Math.max(i-1,0)).weekStart <= flipManager.weeks.get(i).weekStart);
            FlipManager.WeekAggregate w = flipManager.weeks.get(i);
            for (List<FlipV2> flips : w.accountIdToFlips.values()) {
                for (int ii =1; ii < flips.size(); ii++) {
                    Assert.assertTrue(flips.get(ii-1).getClosedTime() <= flips.get(ii).getClosedTime());
                }
            }
        }
    }

    private List<FlipV2> expectedPage(List<FlipV2> flips, int time, int pageNumber, int pageSize, String displayName) {
        Integer accountId = displayName == null ? null : displayNameToAccountId.getOrDefault(displayName, -1);
        int toSkip = (pageNumber - 1) * pageSize;
        List<FlipV2> page = new ArrayList<>();
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                if(toSkip > 0) {
                    toSkip -= 1;
                } else {
                    page.add(f);
                    if(page.size() == pageSize) {
                        break;
                    }
                }
            }
        }
        return page;
    }

    private void assertFlipListsEqual(List<FlipV2> f1, List<FlipV2> f2) {
        if(f1.size() != f2.size()) {
            Assert.fail("flips lists not equal length");
        }
        for (int i=0; i < f1.size(); i++) {
            FlipV2 flip1 = f1.get(i);
            FlipV2 flip2 = f2.get(i);
            if (!flip1.equals(flip2)) {
                Assert.fail("flips don't match at index " + i);
            }
        }
    }

    private Stats expectedStats(List<FlipV2> flips, int time, String displayName) {
        Integer accountId = displayName == null ? null : displayNameToAccountId.getOrDefault(displayName, -1);
        Stats stats = new Stats(0,0,0,0);
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                stats.flipsMade += 1;
                stats.gross += f.getSpent();
                stats.profit += f.getProfit();
            }
        }
        return stats;
    }

    private List<FlipV2> generateFlipsBetween(int start, int end, int number, List<Integer> accountIds) {
        List<FlipV2> flips = new ArrayList<>();
        for (int i =0; i< number; i++) {
            FlipV2 f = new FlipV2();
            f.setId(UUID.randomUUID());
            f.setAccountId(accountIds.get(new Random().nextInt(accountIds.size())));
            // leave a small percentage as open flips
            if(randomIntBetween(0, 1000) > 2) {
                f.setClosedTime(randomIntBetween(start, end));
                f.setSpent(randomIntBetween(100, 1_000_000_000));
                f.setProfit(randomIntBetween(-2_000_000, 4_000_000));
                flips.add(f);
            }
        }
        return flips;
    }

    private int randomIntBetween(int min, int max) {
        return (int)(Math.random() * ((max - min) + 1)) + min;
    }
}
package com.flippingcopilot.model;

import org.junit.Test;

public class AccountStatusTest {

    @Test
    public void testMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        assert accountStatus.moreGpNeeded();
    }

    @Test
    public void testNoMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        accountStatus.getInventory().add(new RSItem(995, 2000));
        assert !accountStatus.moreGpNeeded();
    }
}

//package com.flippingcopilot.model;
//
//import org.junit.Test;
//
//import java.time.Instant;
//
//public class OfferTest {
//
//    @Test
//    public void testTransactionFromNewOffer() {
//        Offer oldOffer = Offer.getEmptyOffer(0);
//        Offer newOffer = new Offer(OfferStatus.BUY, 560, 100, 50, 1000,
//                10, 10, 0, 0, true, false);
//        Transaction expectedTransaction = new Transaction(null, OfferStatus.BUY, 560, 100, 10, 0, 1000, null,false, 0, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert expectedTransaction.equals(actualTransaction);
//    }
//
//    @Test
//    public void testTransactionFromProgressingSell() {
//        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 4000,
//                40, 0, 4000, 0, true, false);
//        Transaction expectedTransaction = new Transaction(null, OfferStatus.SELL, 560, 100, 30, 0, 3000, null,false, 0, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert expectedTransaction.equals(actualTransaction);
//    }
//
//    @Test
//    public void testNoTransaction() {
//        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert actualTransaction == null;
//    }
//}

package com.flippingcopilot.ui;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class UIUtilitiesTest {

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsGreaterThanStringLength() {
        String result = UIUtilities.truncateString("Hello", 10);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsLessThanStringLength() {
        String result = UIUtilities.truncateString("Hello, World!", 5);
        assertEquals("Hello...", result);
    }

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsEqualToStringLength() {
        String result = UIUtilities.truncateString("Hello", 5);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsEmptyString_whenInputStringIsEmpty() {
        String result = UIUtilities.truncateString("", 5);
        assertEquals("", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsZero() {
        String result = UIUtilities.truncateString("Hello, World!", 0);
        assertEquals("...", result);
    }
}
package com.flippingcopilot;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FlippingCopilotPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlippingCopilotPlugin.class);
		RuneLite.main(args);
	}
}
