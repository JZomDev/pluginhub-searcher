package com.flippingcopilot.util;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.List;

public class MsgPackUtil {

    private static final int EXT_INT32 = 41;

    public static Object decodePrimitive(ByteBuffer b) {
        int format = b.get() & 0xFF;
        int length;

        // Boolean cases
        if (format == 0xC2) {
            // false
            return false;
        } else if (format == 0xC3) {
            // true
            return true;
        }
        // Null case
        else if (format == 0xC0) {
            // nil (null)
            return null;
        }
        // String cases
        else if ((format & 0xE0) == 0xA0) {
            // fixstr: format stores length in lower 5 bits
            length = format & 0x1F;
            return getString(length, new byte[length], b);
        } else if (format == 0xD9) {
            // str 8: next byte is length
            length = b.get() & 0xFF;
            return getString(length, new byte[length], b);
        } else if (format == 0xDA) {
            // str 16: next 2 bytes are length
            length = b.getShort() & 0xFFFF;
            return getString(length, new byte[length], b);
        } else if (format == 0xDB) {
            // str 32: next 4 bytes are length
            length = b.getInt();
            return getString(length, new byte[length], b);
        }
        // Integer cases
        else if (format <= 0x7F) {
            // positive fixint
            return (long) format;
        } else if ((format & 0xE0) == 0xE0) {
            // negative fixint (0xE0-0xFF represents -32 to -1)
            return (long) (format - 256);
        } else if (format == 0xCC) {
            // uint 8
            return (long) (b.get() & 0xFF);
        } else if (format == 0xCD) {
            // uint 16
            return (long) (b.getShort() & 0xFFFF);
        } else if (format == 0xCE) {
            // uint 32
            return (long) (b.getInt() & 0xFFFFFFFFL);
        } else if (format == 0xCF) {
            // uint 64
            return b.getLong();
        } else if (format == 0xD0) {
            // int 8
            return (long) b.get();
        } else if (format == 0xD1) {
            // int 16
            return (long) b.getShort();
        } else if (format == 0xD2) {
            // int 32
            return (long) b.getInt();
        } else if (format == 0xD3) {
            // int 64
            return b.getLong();
        }
        // Double case
        else if (format == 0xCB) {
            // float 64
            return b.getDouble();
        } else {
            throw new IllegalArgumentException("Invalid primitive format: " + format);
        }
    }

    private static String getString(int length, byte[] length1, ByteBuffer b) {
        if (length == 0) {
            return "";
        }
        byte[] bytes = length1;
        b.get(bytes);
        return new String(bytes, StandardCharsets.UTF_8);
    }

    public static int[] decodeInt32Array(ByteBuffer b) {
        int format = b.get() & 0xFF;

        if (format == 0xC0) {
            // nil (null)
            return null;
        } else if (format == 0xC9) {
            // ext 32 - extension with 32-bit length
            int byteLength = b.getInt();
            int extType = b.get() & 0xFF;
            if (extType != EXT_INT32) {
                throw new IllegalArgumentException("Expected extension type " + EXT_INT32 + ", got: " + extType);
            }
            int arrayLength = byteLength / 4;
            int[] result = new int[arrayLength];
            for (int i = 0; i < arrayLength; i++) {
                result[i] = (b.get() & 0xff) | ((b.get() & 0xff) << 8) |
                        ((b.get() & 0xff) << 16) | ((b.get() & 0xff) << 24);
            }
            return result;
        } else {
            throw new IllegalArgumentException("Expected extension format 0xC9 or nil 0xC0, got: " + format);
        }
    }

    public static Integer decodeMapSize(ByteBuffer b) {
        int format = b.get() & 0xFF;
        if (format == 0xC0) {
            // nil (null) - return null Data object
            return null;
        } else if ((format & 0xF0) == 0x80) {
            // fixmap: format stores size in lower 4 bits
            return format & 0x0F;
        } else if (format == 0xDE) {
            // map 16: next 2 bytes are size
            return b.getShort() & 0xFFFF;
        } else if (format == 0xDF) {
            // map 32: next 4 bytes are size (you were missing this case!)
            return b.getInt();
        } else {
            throw new IllegalArgumentException("Invalid map format: " + format);
        }
    }
}
package com.flippingcopilot.util;

import java.util.Arrays;
import java.util.HashSet;

public class GeTax {
    private final static int MAX_PRICE_FOR_GE_TAX = 250000000;
    private final static int GE_TAX_CAP = 5000000;
    private final static double GE_TAX = 0.02;
    private final static HashSet<Integer> GE_TAX_EXEMPT_ITEMS = new HashSet<>(
            Arrays.asList(8011, 365, 2309, 882, 806, 1891, 8010, 1755, 28824, 2140, 2142, 8009, 5325, 1785, 2347, 347,
                    884, 807, 28790, 379, 8008, 355, 2327, 558, 1733, 13190, 233, 351, 5341, 2552, 329, 8794, 5329,
                    5343, 1735, 315, 952, 886, 808, 8013, 361, 8007, 5331));

    public static int getPostTaxPrice(int itemId, int price) {
        if (GE_TAX_EXEMPT_ITEMS.contains(itemId)) {
            return price;
        }
        if (price >= MAX_PRICE_FOR_GE_TAX) {
            return price - GE_TAX_CAP;
        }
        int tax = (int)Math.floor(price * GE_TAX);
        return price - tax;
    }
}

package com.flippingcopilot.util;

public class MathUtil {

    public static int clamp(int x, int min, int max) {
        if (x > max) {
            return max;
        } else {
            return Math.max(x, min);
        }
    }
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

public class AtomicReferenceUtils {
    public static <T> OrElse ifPresent(AtomicReference<T> ref, Consumer<? super T> action) {
        T value = ref.get();
        if (value != null) {
            action.accept(value);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    public static <T, E> OrElse ifBothPresent(AtomicReference<T> ref1, AtomicReference<E> ref2, BiConsumer<? super T,? super E> action) {
        T value1 = ref1.get();
        E value2 = ref2.get();
        if (value1 != null && value2 != null) {
            action.accept(value1, value2);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    @AllArgsConstructor
    public static class OrElse {

        boolean shouldRun;

        public void orElse(Runnable r) {
            if(shouldRun) {
                r.run();
            }
        }
    }
}
package com.flippingcopilot.util;

import java.util.UUID;

public class Constants {
    public final static int MIN_GP_NEEDED_TO_FLIP = 1000;
    public final static int PLATINUM_TOKEN_VALUE = 1000;

    public static UUID MAX_UUID = new UUID(-1L, -1L);
    public static UUID MIN_UUID = new UUID(0L, 0L);
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class MutableReference<T> {
    private T value;
}

package com.flippingcopilot.util;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;

public class DateUtil {

    public static String formatEpoch(long epochSeconds) {
        Instant instant = Instant.ofEpochSecond(epochSeconds);
        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)
                .withZone(ZoneId.systemDefault());
        return formatter.format(instant);
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.model.Transaction;
import com.flippingcopilot.model.TransactionManager;
import com.flippingcopilot.ui.GeAddTransactionsDialogPanel;
import com.flippingcopilot.ui.GeHistoryTransactionButton;
import com.google.common.collect.Lists;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Extracts data from the widgets in the trade history tab so that the TradeHistoryTabPanel can display them. I wanted
 * the TradeHistoryTabPanel, and all UI components, to pretty much only draw stuff and not do much else, hence the separation.
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GeHistoryTabController {

    private static Pattern MULTI_ITEM_PATTERN = Pattern.compile(">= (.*) each");
    private static Pattern SINGLE_ITEM_PATTERN = Pattern.compile(">(.*) coin");
    private static Pattern ORIGINAL_PRICE_PATTERN = Pattern.compile("\\((.*) -");

    // dependencies
    private final GeHistoryTransactionButton geHistoryTransactionButton;
    private final Client client;
    private final ApiRequestHandler apiRequestHandler;
    private final ItemController itemController;
    private final OsrsLoginManager osrsLoginManager;
    private final TransactionManager transactionManager;

    // dialog
    private JDialog dialog;

    public void onGeHistoryTabClosed() {
        SwingUtilities.invokeLater(() -> {
            geHistoryTransactionButton.setVisible(false);
            if (dialog != null) {
                dialog.dispose();
            }
        });
    }

    public void onGeHistoryTabOpened() {
        geHistoryTransactionButton.addActionListener(e -> {
            Widget w = client.getWidget(383, 3);
            if( w != null) {
                Widget[] widgets = w.getDynamicChildren();
                List<List<Widget>> groupsOfWidgets = Lists.partition(Arrays.asList(widgets), 6);
                List<Transaction> historyTransactions = groupsOfWidgets.stream().map(this::createTransaction).collect(Collectors.toList());
                historyTransactions.forEach(tx -> log.debug("ge history transaction: {}", tx));
                openAddTransactionsDialog(historyTransactions);
            }
        });
        geHistoryTransactionButton.setVisible(true);
    }

    private void openAddTransactionsDialog(List<Transaction> geTransactions) {
        SwingUtilities.invokeLater(() -> {
            // Get the parent frame
            if(dialog != null) {
                dialog.dispose();
            }
            dialog = new JDialog();
            dialog.setTitle("Add GE History Transactions");
            dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
            dialog.setModal(false);

            // Create the panel
            GeAddTransactionsDialogPanel panel = new GeAddTransactionsDialogPanel(
                    apiRequestHandler,
                    itemController,
                    osrsLoginManager.getPlayerDisplayName(),
                    transactionManager,
                    dialog::dispose,
                    geTransactions
            );

            dialog.setContentPane(panel);
            dialog.pack();
            dialog.setVisible(true);
        });
    }

    public Transaction createTransaction(List<Widget> widgets) {
        GrandExchangeOfferState offerState = getState(widgets.get(2));
        int quantity = widgets.get(4).getItemQuantity();
        int itemId = widgets.get(4).getItemId();
        int price = getPrice(widgets.get(5), quantity);
        boolean isBuy = offerState == GrandExchangeOfferState.BOUGHT;

        Transaction t = new Transaction();
        t.setId(UUID.randomUUID());
        t.setType(isBuy ? OfferStatus.BUY : OfferStatus.SELL);
        t.setItemId(itemId);
        t.setPrice(price);
        t.setQuantity(quantity);
        t.setBoxId(0);
        t.setAmountSpent(price * quantity);
        t.setTimestamp(Instant.now());
        t.setCopilotPriceUsed(true);
        t.setWasCopilotSuggestion(true);
        t.setOfferTotalQuantity(quantity);
        return t;
    }


    /**
     * Gets original price of each item (price before ge tax) from the ge history. We want
     * to get the price before ge tax bc the the price after ge tax is always calculated by the
     * OfferEvent class wherever we need to display it. That means that if we get the price after tax
     * here and then construct an OfferEvent with that price, and then try to display the OfferEvent's price
     * using OfferEvent.getPrice(), we will effectively be applying the ge tax twice.
     * @return the original price of each item in the offer
     */
    private static int getPrice(Widget w, int quantity) {
        String text = w.getText();
        String numString = text;
        Matcher m;
        boolean isTotalPrice = false;
        // This will trigger anytime there is the ge tax text on an offer in the history
        // For example when you have that text with the format "({original price} - {ge_tax})
        // Whenever that text is present, we want to get the original price (NOT THE PRICE
        // AFTER THE TAX). However, since the original price displayed is not the price of each item
        //we have to divide it by the quantity to get the original price of each item.
        if (text.contains(")</col>")) {
            m = ORIGINAL_PRICE_PATTERN.matcher(text);
            isTotalPrice = true;
        }
        //if the case above doesn't trigger that means there is no tax on the item, so we check if "each"
        //is present which allows us to use the regex for getting the price of each item when multiple
        //have been traded.
        else if (text.contains("each")) {
            m = MULTI_ITEM_PATTERN.matcher(text);
        }
        //if this case triggers than it is an offer for a single item that is untaxed
        else {
            m = SINGLE_ITEM_PATTERN.matcher(text);
        }
        m.find();
        numString = m.group(1);
        StringBuilder s = new StringBuilder();
        for (char c : numString.toCharArray()) {
            if (Character.isDigit(c)) {
                s.append(c);
            }
        }

        int price = Integer.parseInt(s.toString());
        if (isTotalPrice) {
            return price/quantity;
        }
        return price;
    }

    private static GrandExchangeOfferState getState(Widget w) {
        String text = w.getText();
        if (text.startsWith("Bought")) {
            return GrandExchangeOfferState.BOUGHT;
        } else {
            return GrandExchangeOfferState.SOLD;
        }
    }
}

package com.flippingcopilot.controller;

import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class HighlightColorController {

    /*
    For the highlighted colors we oscillate the actual colors through different shades
     */

    // Color ranges for red highlight (R,G,B values)
    private static final int[] RED_START = {205, 0, 50};
    private static final int[] RED_END = {255, 50, 0};

    // Color ranges for blue highlight (R,G,B values)
    private static final int[] BLUE_START = {5, 153, 255};
    private static final int[] BLUE_END = {55, 205, 205};

    // Constants for controlling the drift
    private static final long CYCLE_DURATION = 600000; // 10 minutes for one complete cycle
    private static final int ALPHA = 79;

    public Color getRedColor() {
        double phase = calculatePhase();
        return interpolateColor(RED_START, RED_END, phase, ALPHA);
    }

    public Color getBlueColor() {
        double phase = calculatePhase();
        return interpolateColor(BLUE_START, BLUE_END, phase, ALPHA);
    }

    private double calculatePhase() {
        // Current time modulo cycle duration gives us position in the cycle
        long currentTime = System.currentTimeMillis();
        double cyclePosition = (currentTime % CYCLE_DURATION) / (double) CYCLE_DURATION;

        // Use absolute sine wave to create smooth back-and-forth oscillation
        return Math.abs(Math.sin(cyclePosition * Math.PI));
    }

    private Color interpolateColor(int[] start, int[] end, double phase, int alpha) {
        int red = interpolateComponent(start[0], end[0], phase);
        int green = interpolateComponent(start[1], end[1], phase);
        int blue = interpolateComponent(start[2], end[2], phase);

        return new Color(red, green, blue, alpha);
    }

    private int interpolateComponent(int start, int end, double phase) {
        return (int) Math.round(start + (end - start) * phase);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.Transaction;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

@Slf4j
public class Persistance {
    public static Gson gson;
    public static final File COPILOT_DIR = new File(RuneLite.RUNELITE_DIR, "flipping-copilot");
    public static final String UN_ACKED_TRANSACTIONS_FILE_TEMPLATE = "%s_un_acked.jsonl";
    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";
    public static File directory;

    public static void setUp(String directoryPath) throws IOException {
        directory = new File(directoryPath);
        createDirectory(directory);
        createRequiredFiles();
    }

    public static void setUp(Gson gson) throws IOException {
        Persistance.gson = gson;
        directory = COPILOT_DIR;
        createDirectory(COPILOT_DIR);
        createRequiredFiles();
    }

    private static void createRequiredFiles() throws IOException {
        generateFileIfDoesNotExist(LOGIN_RESPONSE_JSON_FILE);
    }

    private static void generateFileIfDoesNotExist(String filename) throws IOException {
        File file = new File(directory, filename);
        if (!file.exists()) {
            if (!file.createNewFile()) {
                log.info("Failed to generate file {}", file.getPath());
            }
        }
    }

    private static void createDirectory(File directory) throws IOException {
        if (!directory.exists()) {
            if (!directory.mkdir()) {
                throw new IOException("unable to create parent directory!");
            }
        }
    }


    public static List<Transaction> loadUnAckedTransactions(String displayName) {
        List<Transaction> transactions = new ArrayList<>();
        File file = new File(COPILOT_DIR, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        if (!file.exists()) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        }
        Set<UUID> added = new HashSet<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }
                try {
                    Transaction transaction = gson.fromJson(line, Transaction.class);
                    // there was previously a bug where the same transaction was being added many times to the list
                    // just clean things here to be safe
                    if (!added.contains(transaction.getId())) {
                        transactions.add(transaction);
                        added.add(transaction.getId());
                    }
                } catch (JsonSyntaxException e) {
                    log.warn("error deserializing transaction line '{}' file {}", line, file, e);
                }
            }
        } catch (FileNotFoundException e) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        } catch (IOException e) {
            log.warn("error loading un acked transaction file {}", file, e);
            return new ArrayList<>();
        } catch (JsonSyntaxException e) {
            log.warn("corrupted un acked transaction file {}", file, e);
            return new ArrayList<>();
        }
        log.info("loaded {} stored transactions for {}", transactions.size(), displayName);
        return transactions;
    }

    public static void storeUnAckedTransactions(List<Transaction> transactions, String displayName) {
        File unackedTransactionsFile = new File(COPILOT_DIR, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        try (BufferedWriter w = new BufferedWriter(new FileWriter(unackedTransactionsFile, false))) {
            for (Transaction transaction : transactions) {
                String json = gson.toJson(transaction);
                w.write(json);
                w.newLine();
            }
        } catch (IOException e) {
            log.warn("error storing un acked transactions to file {}", unackedTransactionsFile, e);
        }
    }

    public static String hashDisplayName(String displayName) {
        if(displayName == null) {
            return "null";
        }
        // we hash the display name just to ensure that it's a valid file name
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            byte[] hashBytes = digest.digest(displayName.getBytes(StandardCharsets.UTF_8));
            StringBuilder hexString = new StringBuilder();
            for (byte b : hashBytes) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.UIUtilities;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontTypeFace;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.flippingcopilot.model.OfferStatus.SELL;
import static com.flippingcopilot.util.GeTax.getPostTaxPrice;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class TooltipController {
    private static final int SCRIPT_TOOLTIP_GE = 526;

    private static final int WIDTH_PADDING = 4;

    private final Client client;
    private final OfferManager offerManager;
    private final FlipManager flipManager;
    private final OsrsLoginManager osrsLoginManager;
    private final CopilotLoginManager copilotLoginManager;

    public void tooltip(ScriptPostFired e) {
        if(e.getScriptId() != SCRIPT_TOOLTIP_GE) {
            return;
        }

        Widget tooltip = client.getWidget(InterfaceID.GeOffers.TOOLTIP);

        if(tooltip == null || tooltip.isHidden()) {
            return;
        }

        Widget background = tooltip.getChild(0);
        Widget border = tooltip.getChild(1);
        Widget text = tooltip.getChild(2);

        if (text != null && background != null && border != null) {

            if (text.getText().contains("Profit:")) {
                // If the tooltip already contains profit information, we don't need to process it again
                return;
            }

            if(!isItemSelling(text.getText())) {
                return;
            }

            String name = getItemNameFromTooltipText(text.getText());

            if(name != null) {
                long profit = getProfitFromItemName(name);
                text.setText(text.getText()  + "<br>Profit: " + UIUtilities.quantityToRSDecimalStack(profit, false) + " gp");
                tooltip.setOriginalHeight(45);

                int width = calculateTooltipWidth(text.getFont(), text.getText());
                tooltip.setOriginalWidth(width);

                tooltip.revalidate();
                border.revalidate();
                background.revalidate();
                text.revalidate();
            }
        }
    }

    public boolean isItemSelling(String text) {
        text = text.replaceAll("<br>", " ").trim();
        Pattern pattern = Pattern.compile("^(Buying|Selling): (.+) (\\d{1,3}(?:,\\d{3})*|\\d+) / (\\d{1,3}(?:,\\d{3})*|\\d+)( Profit: -?[\\d,]+ gp?)?$");
        Matcher matcher = pattern.matcher(text);

        if (matcher.find()) {
            String action = matcher.group(1);
            return action.equals("Selling");
        } else {
            return false; // or handle as you wish
        }
    }

    public long getProfitFromItemName(String itemName) {
        String displayName = osrsLoginManager.getPlayerDisplayName();

        for(int i = 0; i < 8; i++) {
            long accountHash = client.getAccountHash();
            SavedOffer offer = offerManager.loadOffer(accountHash, i);

            if(offer.getOfferStatus().equals(SELL)) {
                Integer accountId = copilotLoginManager.getAccountId(displayName);
                if(accountId != null && accountId != -1) {
                    FlipV2 flip = flipManager.getLastFlipByItemId(accountId, offer.getItemId());

                    if (flip == null || FlipStatus.FINISHED.equals(flip.getStatus())) {
                        continue;
                    }

                    if(flip.getCachedItemName().equals(itemName)) {
                        return ((long) getPostTaxPrice(offer.getItemId(), offer.getPrice()) * offer.getTotalQuantity()) - (flip.getAvgBuyPrice() * offer.getTotalQuantity());
                    }
                }
            }
        }

        return 0;
    }

    public String getItemNameFromTooltipText(String text) {
        text = text.replaceAll("<br>", " ").trim();
        Pattern pattern = Pattern.compile("^(Buying|Selling): (.+) (\\d{1,3}(?:,\\d{3})*|\\d+) / (\\d{1,3}(?:,\\d{3})*|\\d+)( Profit: -?[\\d,]+ gp?)?$");
        Matcher matcher = pattern.matcher(text);

        if (matcher.find()) {
            return matcher.group(2);
        } else {
            return null; // or handle as you wish
        }
    }

    private int calculateTooltipWidth(FontTypeFace f, String text)
    {
        final String[] lines = text.split("<br>");
        int maxWidth = 0;
        for (String line : lines) {
            String left = "";
            left = line;

            int width = f.getTextWidth(left);
            if (width > maxWidth) {
                maxWidth = width;
            }
        }
        return maxWidth + WIDTH_PADDING;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
@Getter
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OfferHandler {

    private static final int GE_OFFER_INIT_STATE_CHILD_ID = 20;

    // dependencies
    private final Client client;
    private final ClientThread clientThread;
    private final SuggestionManager suggestionManager;
    private final ApiRequestHandler apiRequestHandler;
    private final OsrsLoginManager osrsLoginManager;
    private final OfferManager offerManager;
    private final HighlightController highlightController;
    private final CopilotLoginManager copilotLoginManager;

    // state
    private String viewedSlotPriceErrorText = null;

    public void fetchSlotItemPrice(boolean isViewingSlot, Supplier<OfferEditor> offerEditorSupplier) {
        if (isViewingSlot) {
            var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);
            offerManager.setViewedSlotItemId(currentItemId);
            if (currentItemId == -1 || currentItemId == 0) return;

            var suggestion = suggestionManager.getSuggestion();
            if (suggestion != null && suggestion.getItemId() == currentItemId &&
                    ((Objects.equals(suggestion.getType(), "sell") && isSelling()) ||
                            Objects.equals(suggestion.getType(), "buy") && isBuying())) {
                offerManager.setLastViewedSlotItemId(suggestion.getItemId());
                offerManager.setLastViewedSlotItemPrice(suggestion.getPrice());
                offerManager.setLastViewedSlotItemPrice((int) Instant.now().getEpochSecond());
                return;
            }

            if (!copilotLoginManager.isLoggedIn()) {
                viewedSlotPriceErrorText = "Login to copilot to see item price.";
                return;
            }
            viewedSlotPriceErrorText = "Loading copilot item price..";
            Consumer<ItemPrice> itemPriceConsumer = (fetchedPrice) -> {
                clientThread.invoke(() -> {
                    if (fetchedPrice == null) {
                        viewedSlotPriceErrorText = "Unknown error";
                        return;
                    }

                    if (fetchedPrice.getMessage() != null && !fetchedPrice.getMessage().isEmpty()) {
                        viewedSlotPriceErrorText = fetchedPrice.getMessage();
                    } else {
                        viewedSlotPriceErrorText = null;
                    }
                    offerManager.setViewedSlotItemPrice(isSelling() ? fetchedPrice.getSellPrice() : fetchedPrice.getBuyPrice());
                    offerManager.setLastViewedSlotItemId(offerManager.getViewedSlotItemId());
                    offerManager.setLastViewedSlotItemPrice(offerManager.getViewedSlotItemPrice());
                    offerManager.setLastViewedSlotPriceTime((int) Instant.now().getEpochSecond());

                    highlightController.redraw();
                    log.debug("fetched item {} price: {}", offerManager.getViewedSlotItemId(), offerManager.getViewedSlotItemPrice());

                    // todo: Usage of OfferEditor is messy. It mutates a widget so we need to get the original instance
                    //  of it which is created downstream on some other event handler path. This is why we use a supplier
                    //  but probably it should be an injected class of some kind. We should clean this up in the future
                    //  but for now just need it to work as currently broken.

                    OfferEditor flippingWidget = offerEditorSupplier.get();
                    if (flippingWidget != null) {
                        flippingWidget.showPrice(offerManager.getViewedSlotItemPrice());
                    }
                });
            };


            apiRequestHandler.asyncGetItemPriceWithGraphData(currentItemId, osrsLoginManager.getPlayerDisplayName(), itemPriceConsumer, false);

        } else {
            offerManager.setViewedSlotItemPrice(-1);
            offerManager.setViewedSlotItemId(-1);
            viewedSlotPriceErrorText = null;
        }
        highlightController.redraw();
    }

    public boolean isSettingQuantity() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();
        return chatInputText.equals("How many do you wish to buy?") || chatInputText.equals("How many do you wish to sell?");
    }

    public boolean isSettingPrice() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();

        var offerTextWidget = getOfferTextWidget();
        if (offerTextWidget == null) return false;
        String offerText = offerTextWidget.getText();
        return chatInputText.equals("Set a price for each item:") && (offerText.equals("Buy offer") || offerText.equals("Sell offer"));
    }


    private Widget getChatboxTitleWidget() {
        return client.getWidget(ComponentID.CHATBOX_TITLE);
    }

    private Widget getOfferTextWidget() {
        var offerContainerWidget = client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER);
        if (offerContainerWidget == null) return null;
        return offerContainerWidget.getChild(GE_OFFER_INIT_STATE_CHILD_ID);
    }

    public boolean isSelling() {
        return client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 1;
    }

    public boolean isBuying() {
        return client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 0;
    }

    public String getOfferType() {
        if (isBuying()) {
            return "buy";
        } else if (isSelling()) {
            return "sell";
        } else {
            return null;
        }
    }

    public void setSuggestedAction(Suggestion suggestion) {
        var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);

        if (isSettingQuantity()) {
            if (suggestion == null || currentItemId != suggestion.getItemId()) {
                return;
            }
            setChatboxValue(suggestion.getQuantity());
        } else if (isSettingPrice()) {
            int price = -1;
            if (suggestion == null || currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(getOfferType())) {
                if (offerManager.getViewedSlotItemId() != currentItemId) {
                    return;
                }
                price = offerManager.getViewedSlotItemPrice();
            } else {
                price = suggestion.getPrice();
            }

            if (price == -1) return;

            setChatboxValue(price);
        }
    }

    public void setChatboxValue(int value) {
        var chatboxInputWidget = client.getWidget(ComponentID.CHATBOX_FULL_INPUT);
        if (chatboxInputWidget == null) return;
        chatboxInputWidget.setText(value + "*");
        client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(value));
    }
}

package com.flippingcopilot.controller;

import java.awt.event.ActionEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.LoginPanel;
import com.flippingcopilot.ui.MainPanel;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class CopilotLoginController {

    // dependencies
    @Setter
    private LoginPanel loginPanel;
    @Setter
    private MainPanel mainPanel;
    private final ApiRequestHandler apiRequestHandler;
    private final FlipManager flipManager;
    private final HighlightController highlightController;
    private final CopilotLoginManager copilotLoginManager;
    private final SuggestionManager suggestionManager;
    private final OsrsLoginManager osrsLoginManager;
    private final SessionManager sessionManager;
    private final TransactionManager transactionManager;
    private final ScheduledExecutorService executorService;


    @Inject
    public CopilotLoginController(ApiRequestHandler apiRequestHandler,
                                  FlipManager flipManager,
                                  HighlightController highlightController,
                                  CopilotLoginManager copilotLoginManager,
                                  SuggestionManager suggestionManager,
                                  OsrsLoginManager osrsLoginManager,
                                  SessionManager sessionManager,
                                  TransactionManager transactionManager,
                                  ScheduledExecutorService executorService) {
        this.apiRequestHandler = apiRequestHandler;
        this.flipManager = flipManager;
        this.highlightController = highlightController;
        this.copilotLoginManager = copilotLoginManager;
        this.suggestionManager = suggestionManager;
        this.osrsLoginManager = osrsLoginManager;
        this.sessionManager = sessionManager;
        this.transactionManager = transactionManager;
        this.executorService = executorService;
        flipManager.setCopilotUserId(copilotLoginManager.getCopilotUserId());
        loadCopilotAccounts(0);
    }

    private void loadCopilotAccounts(int previousFailures) {
        int userId = copilotLoginManager.getCopilotUserId();
        if(userId == -1) {
            return;
        }
        long s = System.nanoTime();
        Consumer<Map<String, Integer>> onSuccess = (displayNameToAccountId) -> {
            displayNameToAccountId.forEach((key, value) ->
                    copilotLoginManager.addAccountIfMissing(value, key, userId));
            log.info("loading {} copilot accounts succeeded - took {}ms", displayNameToAccountId.size(), (System.nanoTime() - s) / 1000_000);
            syncFlips(copilotLoginManager.getCopilotUserId(), new HashMap<>(), 0);
        };
        Consumer<String> onFailure = (errorMessage) -> {
            if (copilotLoginManager.isLoggedIn()) {
                long backOffSeconds = Math.min(15, (long) Math.exp(previousFailures));
                log.info("failed to load copilot accounts ({}) retrying in {}s", errorMessage, backOffSeconds);
                executorService.schedule(() -> loadCopilotAccounts(previousFailures + 1), backOffSeconds, TimeUnit.SECONDS);
            }
        };
        apiRequestHandler.asyncLoadAccounts(onSuccess, onFailure);
    }

    private void syncFlips(int userId, Map<Integer, Integer> accountIdTime, int previousFailures) {
        // Continuously sync's the delta of new or updated flips from the server with back off on failure
        if(copilotLoginManager.getCopilotUserId() != userId) {
            log.info("user={}, no longer logged in, stopping syncFlips.", userId);
            return;
        }
        Set<Integer> accountIds = copilotLoginManager.accountIds();
        if(accountIds.isEmpty()) {
            long backOffSeconds = Math.min(45, (long) 1+previousFailures);
            log.info("user={}, no accounts loaded - re-scheduling runSyncFlips in {}s", userId, backOffSeconds);
            executorService.schedule(() -> syncFlips(userId, accountIdTime, previousFailures+1), backOffSeconds, TimeUnit.SECONDS);
            return;
        }
        accountIds.forEach(a -> accountIdTime.computeIfAbsent(a, i -> 0));
        long s = System.nanoTime();
        BiConsumer<Integer, FlipsDeltaResult> onSuccess = (Integer copilotUserId, FlipsDeltaResult r) -> {
            if(!flipManager.mergeFlips(r.flips, userId)) {
                log.info("user={}, no longer logged in, stopping syncFlips.", userId);
                return;
            }
            log.debug("user={}, loading {} updated flips - took {}ms", userId, r.flips.size(), (System.nanoTime() - s) / 1000_000);
            accountIds.forEach((a) -> accountIdTime.put(a, r.time));
            executorService.schedule(() -> syncFlips(userId, accountIdTime, 0), 5, TimeUnit.SECONDS);
        };
        Consumer<String> onFailure = (errorMessage) -> {
            long backOffSeconds = Math.min(45, (long) Math.exp(previousFailures));
            log.info("user={}, failed to load updated flips ({}) retrying in {}s", userId, errorMessage, backOffSeconds);
            executorService.schedule(() -> syncFlips(userId, accountIdTime, previousFailures + 1), backOffSeconds, TimeUnit.SECONDS);
        };
        apiRequestHandler.asyncLoadFlips(accountIdTime, onSuccess, onFailure);
    }

    public void onLoginPressed(String email, String password) {
        Consumer<LoginResponse> onSuccess = (LoginResponse loginResponse) -> {
            copilotLoginManager.setLoginResponse(loginResponse);
            mainPanel.refresh();
            String displayName = osrsLoginManager.getPlayerDisplayName();
            if(displayName != null) {
                flipManager.setIntervalAccount(null);
                flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                transactionManager.scheduleSyncIn(0, displayName);
            }
            flipManager.setCopilotUserId(loginResponse.getUserId());
            loadCopilotAccounts(0);
            loginPanel.endLoading();
        };
        Consumer<String> onFailure = (String errorMessage) -> {
            copilotLoginManager.reset();
            loginPanel.showLoginErrorMessage(errorMessage);
            loginPanel.endLoading();
        };
        if (email == null || password == null) {
            return;
        }
        loginPanel.startLoading();
        apiRequestHandler.authenticate(email, password, onSuccess, onFailure);
    }

    public void onLogout() {
        flipManager.reset();
        copilotLoginManager.reset();
        suggestionManager.reset();
        highlightController.removeAll();
        mainPanel.refresh();
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GePreviousSearch {

    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final HighlightController highlightController;
    private final Client client;


    public void showSuggestedItemInSearch() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion != null && suggestion.getType().equals("buy")) {
            if (grandExchange.isPreviousSearchSet() && grandExchange.showLastSearchEnabled()) {
                setPreviousSearch(suggestion.getItemId(), suggestion.getName());
            } else {
                createPreviousSearchWidget(suggestion.getItemId(), suggestion.getName());
                createPreviousSearchItemNameWidget(suggestion.getName());
                createPreviousSearchItemWidget(suggestion.getItemId());
                createPreviousSearchTextWidget();
            }
            highlightController.redraw();
        }
    }

    private void setPreviousSearch(int itemId, String itemName) {
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget previousSearch = searchResults.getChild(0);
        previousSearch.setOnOpListener(754, itemId, 84);
        previousSearch.setOnKeyListener(754, itemId, -2147483640);
        previousSearch.setName("<col=ff9040>" + itemName + "</col>");
        Widget previousSearchText = searchResults.getChild(1);
        previousSearchText.setText("Copilot item:");
        Widget itemNameWidget = searchResults.getChild(2);
        itemNameWidget.setText(itemName);
        Widget item = searchResults.getChild(3);
        item.setItemId(itemId);
    }

    private void createPreviousSearchWidget(int itemId, String itemName) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.RECTANGLE);
        widget.setTextColor(0xFFFFFF);
        widget.setOpacity(255);
        widget.setName("<col=ff9040>" + itemName + "</col>");
        widget.setHasListener(true);
        widget.setFilled(true);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(256);
        widget.setOriginalHeight(32);
        widget.setOnOpListener(754, itemId, 84);
        widget.setOnKeyListener(754, itemId, -2147483640);
        widget.setHasListener(true);
        widget.setAction(0, "Select");
        // set opacity to 200 when mouse is hovering
        widget.setOnMouseOverListener((JavaScriptCallback) ev -> {
            widget.setOpacity(200);
        });
        // set opacity back to 255 when mouse is not hovering
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
            widget.setOpacity(255);
        });

        widget.revalidate();
    }

    private void createPreviousSearchItemNameWidget(String itemName) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText(itemName);
        widget.setFontId(495);
        widget.setOriginalX(254);
        widget.setOriginalY(0);
        widget.setOriginalWidth(116);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }

    private void createPreviousSearchItemWidget(int itemId) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.GRAPHIC);
        widget.setItemId(itemId);
        widget.setItemQuantity(1);
        widget.setItemQuantityMode(0);
        widget.setRotationX(550);
        widget.setModelZoom(1031);
        widget.setBorderType(1);
        widget.setOriginalX(214);
        widget.setOriginalY(0);
        widget.setOriginalWidth(36);
        widget.setOriginalHeight(32);
        widget.revalidate();
    }

    private void createPreviousSearchTextWidget() {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText("Copilot item:");
        widget.setFontId(495);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(95);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }
}

package com.flippingcopilot.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchange {

    private final static int CURRENTLY_OPEN_GE_SLOT_VARBIT_ID = 4439;
    final static int SHOW_LAST_SEARCHED_VARBIT_ID = 10295;

    private final Client client;

    boolean isHomeScreenOpen() {
        return isOpen() && !isSlotOpen();
    }

    boolean isSlotOpen() {
        return getOpenSlot() != -1;
    }

    boolean isCollectButtonVisible() {
        Widget w = client.getWidget(InterfaceID.GRAND_EXCHANGE, 6);
        if (w == null) {
            return false;
        }
        Widget[] children = w.getChildren();
        if(children == null) {
            return false;
        }
        return Arrays.stream(children).anyMatch(c -> !c.isHidden() && "Collect".equals(c.getText()));
    }

    int getOpenSlot() {
        return client.getVarbitValue(CURRENTLY_OPEN_GE_SLOT_VARBIT_ID) - 1;
    }

    Widget getSlotWidget(int slot) {
        return client.getWidget(465, 7 + slot);
    }

    Widget getBuyButton(int slot) {
        Widget slotWidget = getSlotWidget(slot);
        if (slotWidget == null) {
            return null;
        }
        return slotWidget.getChild(0);
    }

    Widget getCollectButton() {
        Widget topBar = client.getWidget(465, 6);
        if (topBar == null) {
            return null;
        }
        return topBar.getChild(2);
    }

    Widget getOfferContainerWidget() {
        return client.getWidget(465, 26);
    }

    Widget getOfferTypeWidget() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(20);
    }

    Widget getConfirmButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(58);
    }

    int getOfferQuantity() {
        return client.getVarbitValue(4396);
    }

    int getOfferPrice() {
        return client.getVarbitValue(4398);
    }

    public boolean isOpen() {
        return client.getWidget(InterfaceID.GRAND_EXCHANGE, 7) != null;
    }

    public boolean isPreviousSearchSet() {
        return client.getVarpValue(2674) != -1;
    }

    public boolean showLastSearchEnabled() {
        return client.getVarbitValue(SHOW_LAST_SEARCHED_VARBIT_ID) == 0;
    }

    public Widget getSetQuantityButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(51);
    }

    public Widget getSetPriceButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(54);
    }

    public Widget getSetQuantityAllButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(50);
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.flipsdialog.FlipsDialogController;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;
import static net.runelite.api.Varbits.GE_OFFER_CREATION_TYPE;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class MenuHandler {

    private final FlippingCopilotConfig config;
    private final Client client;
    private final OfferManager offerManager;
    private final GrandExchange grandExchange;
    private final SuggestionManager suggestionManager;
    private final FlipsDialogController flipsDialogController;


    public void injectCopilotPriceGraphMenuEntry(MenuEntryAdded event) {
        if(!config.priceGraphMenuOptionEnabled()) {
            return;
        }
        if (event.getOption().equals("View offer")) {
            long slotWidgetId = event.getActionParam1();
            client.getMenu()
                    .createMenuEntry(-1)
                    .setOption("Copilot price graph")
                    .onClick((MenuEntry e) -> {
                        GrandExchangeOffer[] offers = client.getGrandExchangeOffers();
                        for (int i = 0; i < offers.length; i++) {
                            Widget slotWidget = client.getWidget(465, 7 + i);
                            if (slotWidget != null && slotWidget.getId() == slotWidgetId) {
                                int itemId = offers[i].getItemId();
                                flipsDialogController.showPriceGraphTab(itemId, false);
                                log.debug("matched widget to slot {}, item {}", i, offers[i].getItemId());
                            }
                        }
                    });
        }
    }

    public void injectConfirmMenuEntry(MenuEntryAdded event) {
        if(!config.disableLeftClickConfirm()) {
            return;
        }

        if(offerDetailsCorrect()) {
            return;
        }

        if(event.getOption().equals("Confirm") && grandExchange.isSlotOpen()) {
            log.debug("Adding deprioritized menu entry for offer");
            client.getMenu()
                    .createMenuEntry(-1)
                    .setOption("Nothing");

            event.getMenuEntry().setDeprioritized(true);
        }
    }

    private boolean offerDetailsCorrect() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return false;
        }
        String offerType = client.getVarbitValue(GE_OFFER_CREATION_TYPE) == 1 ? "sell" : "buy";
        if (client.getVarpValue(CURRENT_GE_ITEM) == suggestion.getItemId() && offerType.equals(suggestion.getType())) {
            return grandExchange.getOfferPrice() == suggestion.getPrice()
                    && grandExchange.getOfferQuantity() == suggestion.getQuantity();
        } else if (client.getVarpValue(CURRENT_GE_ITEM) == offerManager.getViewedSlotItemId()
                && offerManager.getViewedSlotItemPrice() > 0) {
            return grandExchange.getOfferPrice() == offerManager.getViewedSlotItemPrice();
        }
        return false;
    }
}



package com.flippingcopilot.controller;

import com.flippingcopilot.ui.UIUtilities;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;


@ConfigGroup("flippingcopilot")
public interface FlippingCopilotConfig extends Config
{
    public enum PriceGraphWebsite
    {
        FLIPPING_COPILOT("Flipping Copilot"),
        OSRS_WIKI("OSRS Wiki"),
        GE_TRACKER("GE Tracker"),
        PLATINUM_TOKENS("PlatinumTokens"),
        GE_DATABASE("GE Database"),
        OSRS_CLOUD("Osrs.cloud"),
        OSRS_EXCHANGE("OSRS Exchange"),
        FLIPPING_GG("Flipping.gg");


        private final String name;
        PriceGraphWebsite(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name;
        }

        public String getUrl(String itemName, int itemId)
        {
            switch (this)
            {
                case OSRS_WIKI:
                    return "https://prices.runescape.wiki/osrs/item/" + itemId;
                case GE_TRACKER:
                    return "https://www.ge-tracker.com/item/" + itemId;
                case PLATINUM_TOKENS:
                    String platinumTokensFormattedName = itemName
                            .toLowerCase()
                            .replace("'", "")
                            .replace("(", " ")
                            .replace(")", "")
                            .replace("+", " plus")
                            .replace("  ", " ")
                            .replace(" ", "-");
                    return "https://platinumtokens.com/item/" + platinumTokensFormattedName;
                case GE_DATABASE:
                    return "https://secure.runescape.com/m=itemdb_oldschool/viewitem?obj=" + itemId;
                case OSRS_EXCHANGE:
                    String osrsExchangeFormattedName = itemName.toLowerCase().replace(' ','-');
                    return "https://www.osrs.exchange/item/"
                            + URLEncoder.encode(osrsExchangeFormattedName, StandardCharsets.UTF_8);
                case OSRS_CLOUD:
                    return "https://prices.osrs.cloud/item/" + itemId;
                case FLIPPING_GG:
                    return "https://www.flipping.gg/items/" + itemId;
                default:
                    return "";
            }
        }
    }


    @ConfigItem(
            keyName = "enableChatNotifications",
            name = "Enable chat notifications",
            description = "Show chat notifications for suggested action when the side panel is closed."
    )
    default boolean enableChatNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "enableTrayNotifications",
            name = "Enable tray notifications",
            description = "Show tray notifications for suggested action when runelite is out of focus."
    )
    default boolean enableTrayNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "profitAmountColor",
            name = "Flip tracker profit color",
            description = "The color of the profit amount text in the flip tracker"
    )
    default Color profitAmountColor() {
        return ColorScheme.GRAND_EXCHANGE_PRICE;
    }
    @ConfigItem(
            keyName = "lossAmountColor",
            name = "Flip tracker loss color",
            description = "The color of the loss amount text in the flip tracker"
    )
    default Color lossAmountColor() {
        return UIUtilities.OUTDATED_COLOR;
    }
    @ConfigItem(
            keyName = "chatTextColor",
            name = "Chat text color",
            description = "The color of the text for copilot messages in the chat."
    )
    default Color chatTextColor() {
        return new Color(0x0040FF);
    }
    @ConfigItem(
            keyName = "webhook",
            name = "Webhook URL",
            description = "The Discord Webhook URL for sending display name and profit."
    )
    String webhook();
    @ConfigItem(
            keyName = "priceGraphButton",
            name = "Graph button",
            description = "The page to open when the graph button is clicked."
    )
    default PriceGraphWebsite priceGraphWebsite()
    {
        return PriceGraphWebsite.FLIPPING_COPILOT;
    }
    @ConfigItem(
            keyName = "suggestionHighlights",
            name = "Highlight suggested actions",
            description = "Show highlight overlays on the GE interface for suggested actions."
    )
    default boolean suggestionHighlights()
    {
        return true;
    }
    @ConfigItem(
            keyName = "misClickProtection",
            name = "Mis-click prevention",
            description = "Require right click to confirm when price/quantity set incorrectly"
    )
    default boolean disableLeftClickConfirm()
    {
        return false;
    }
    @ConfigItem(
            keyName = "quickSetKeybind",
            name = "Price/quantity set keybind",
            description = "Keybind to quickly set the price or quantity of a GE offer to the suggested value"
    )
    default Keybind quickSetKeybind()
    {
        return new Keybind(KeyEvent.VK_E, 0);
    }

    @ConfigItem(
            keyName = "enabledPriceGraphMenuOpton",
            name = "Enable price graph menu option",
            description = "Adds a menu option to open copilot price graph on applicable right clicks."
    )
    default boolean priceGraphMenuOptionEnabled()
    {
        return true;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GameUiChangesHandler {
    private static final int GE_HISTORY_TAB_WIDGET_ID = 149;

    // dependencies
    private final ClientThread clientThread;
    private final Client client;
    private final GePreviousSearch gePreviousSearch;
    private final HighlightController highlightController;
    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final OfferManager offerManager;
    private final OfferHandler offerHandler;
    // state
    boolean quantityOrPriceChatboxOpen;
    boolean itemSearchChatboxOpen = false;
    @Getter
    OfferEditor flippingWidget = null;

    public void onVarClientIntChanged(VarClientIntChanged event) {
        if (event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 14
                && client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS) != null) {
            itemSearchChatboxOpen = true;
            clientThread.invokeLater(gePreviousSearch::showSuggestedItemInSearch);
        }

        if (quantityOrPriceChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            quantityOrPriceChatboxOpen = false;
            return;
        }

        if (itemSearchChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            clientThread.invokeLater(highlightController::redraw);
            itemSearchChatboxOpen = false;
            return;
        }

        //Check that it was the chat input that got enabled.
        if (event.getIndex() != VarClientInt.INPUT_TYPE
                || client.getWidget(ComponentID.CHATBOX_TITLE) == null
                || client.getVarcIntValue(VarClientInt.INPUT_TYPE) != 7
                || client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) == null) {
            return;
        }
        quantityOrPriceChatboxOpen = true;

        clientThread.invokeLater(() ->
        {
            flippingWidget = new OfferEditor(offerManager, client.getWidget(ComponentID.CHATBOX_CONTAINER), offerHandler, client);
            Suggestion suggestion = suggestionManager.getSuggestion();
            if (suggestion != null) {
                flippingWidget.showSuggestion(suggestion);
            }
        });
    }

    public void onVarClientStrChanged(VarClientStrChanged event) {
        if (event.getIndex() == VarClientStr.INPUT_TEXT && itemSearchChatboxOpen) {
            clientThread.invokeLater(highlightController::redraw);
        }
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            suggestionManager.setSuggestionNeeded(true);
        }
        if (event.getGroupId() == 383
                || event.getGroupId() == InterfaceID.GRAND_EXCHANGE
                || event.getGroupId() == 213
                || event.getGroupId() == GE_HISTORY_TAB_WIDGET_ID) {
            clientThread.invokeLater(highlightController::redraw);
        }
    }

    public void onWidgetClosed(WidgetClosed event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            clientThread.invokeLater(highlightController::removeAll);
            suggestionManager.setSuggestionNeeded(true);
        }
    }

    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarpId() == 375
                || event.getVarpId() == CURRENT_GE_ITEM
                || event.getVarbitId() == 4396
                || event.getVarbitId() == 4398
                || event.getVarbitId() == 4439) {
            clientThread.invokeLater(highlightController::redraw);
        }

        if (event.getVarpId() == CURRENT_GE_ITEM) {
            clientThread.invokeLater(() -> offerHandler.fetchSlotItemPrice(event.getValue() > -1, this::getFlippingWidget));
        }
    }

    public void handleMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals("Confirm") && grandExchange.isSlotOpen()) {
            log.debug("offer confirmed tick {}", client.getTickCount());
            offerManager.setOfferJustPlaced(true);
            suggestionManager.setLastOfferSubmittedTick(client.getTickCount());
            suggestionManager.setSuggestionNeeded(true);
            Suggestion suggestion = suggestionManager.getSuggestion();
            if(suggestion != null) {
                suggestionManager.setSuggestionItemIdOnOfferSubmitted(suggestion.getItemId());
                suggestionManager.setSuggestionOfferStatusOnOfferSubmitted(suggestionOfferStatus(suggestion));
            } else {
                suggestionManager.setSuggestionItemIdOnOfferSubmitted(-1);
                suggestionManager.setSuggestionOfferStatusOnOfferSubmitted(null);
            }
        }
    }

    private OfferStatus suggestionOfferStatus(Suggestion suggestion) {
        if ("sell".equals(suggestion.getType())) {
            return OfferStatus.SELL;
        } else if ("buy".equals(suggestion.getType())) {
            return OfferStatus.BUY;
        } else {
            return null;
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.PremiumInstanceStatus;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.PremiumInstancePanel;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.util.function.Consumer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PremiumInstanceController {

    private final ApiRequestHandler apiRequestHandler;
    private final FlippingCopilotConfig copilotConfig;
    private final SuggestionManager suggestionManager;
    private JDialog dialog;

    public void loadAndOpenPremiumInstanceDialog() {
        // Create the dialog
        if(dialog != null) {
            dialog.dispose();
        }
        dialog = new JDialog();
        dialog.setTitle("Premium accounts management");
        dialog.setModal(false);
        dialog.setSize(400, 300);
        dialog.setLocationRelativeTo(null);

        // Create the panel
        PremiumInstancePanel panel = new PremiumInstancePanel(copilotConfig, apiRequestHandler, suggestionManager);
        dialog.setContentPane(panel);

        // Show loading state
        panel.showLoading();
        Consumer<PremiumInstanceStatus> c = (status) -> {
            SwingUtilities.invokeLater(() -> {  // Make sure UI updates happen on EDT
                if (status.getLoadingError() != null && !status.getLoadingError().isEmpty()) {
                    panel.showError(status.getLoadingError());
                } else {
                    panel.showManagementView(status);
                }
            });
        };
        apiRequestHandler.asyncGetPremiumInstanceStatus(c);
        dialog.setVisible(true);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.WidgetHighlightOverlay;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.VarClientStr;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;
import static net.runelite.api.Varbits.GE_OFFER_CREATION_TYPE;


@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class HighlightController {

    // dependencies
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final AccountStatusManager accountStatusManager;
    private final Client client;
    private final OfferManager offerManager;
    private final OverlayManager overlayManager;
    private final HighlightColorController highlightColorController;

    // state
    private final ArrayList<WidgetHighlightOverlay> highlightOverlays = new ArrayList<>();

    public void redraw() {
        removeAll();
        if(!config.suggestionHighlights()) {
            return;
        }
        if(!grandExchange.isOpen()) {
            return;
        }
        if (offerManager.isOfferJustPlaced()) {
            return;
        }
        if(suggestionManager.getSuggestionError() != null) {
            return;
        }
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return;
        }
        if (grandExchange.isHomeScreenOpen()) {
            drawHomeScreenHighLights(suggestion);
        } else if (grandExchange.isSlotOpen()) {
            drawOfferScreenHighlights(suggestion);
        }
    }

    private void drawHomeScreenHighLights(Suggestion suggestion) {
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (accountStatus.isCollectNeeded(suggestion)) {
            Widget collectButton = grandExchange.getCollectButton();
            if (collectButton != null) {
                add(collectButton, highlightColorController.getBlueColor(), new Rectangle(2, 1, 81, 18));
            }
        }
        else if (suggestion.getType().equals("abort")) {
            Widget slotWidget = grandExchange.getSlotWidget(suggestion.getBoxId());
            add(slotWidget, highlightColorController.getRedColor());
        }
        else if (suggestion.getType().equals("buy")) {
            int slotId = accountStatus.findEmptySlot();
            if (slotId != -1) {
                Widget buyButton = grandExchange.getBuyButton(slotId);
                if (buyButton != null && !buyButton.isHidden()) {
                    add(buyButton, highlightColorController.getBlueColor(), new Rectangle(0, 0, 45, 44));
                }
            }
        }
        else if (suggestion.getType().equals("sell")) {
            Widget itemWidget = getInventoryItemWidget(suggestion.getItemId());
            if (itemWidget != null && !itemWidget.isHidden()) {
                add(itemWidget, highlightColorController.getBlueColor(), new Rectangle(0, 0, 34, 32));
            }
        }
    }

    private void drawOfferScreenHighlights(Suggestion suggestion) {
        Widget offerTypeWidget = grandExchange.getOfferTypeWidget();
        String offerType = client.getVarbitValue(GE_OFFER_CREATION_TYPE) == 1 ? "sell" : "buy";
        if (offerTypeWidget != null) {
            if (offerType.equals(suggestion.getType())) {
                if (client.getVarpValue(CURRENT_GE_ITEM) == suggestion.getItemId()) {
                    if (offerDetailsCorrect(suggestion)) {
                        highlightConfirm();
                    } else {
                        if (grandExchange.getOfferPrice() != suggestion.getPrice()) {
                            highlightPrice();
                        }
                        highlightQuantity(suggestion);
                    }
                } else if (client.getVarpValue(CURRENT_GE_ITEM ) == -1){
                    highlightItemInSearch(suggestion);
                }
            }
            // Check if unsuggested item/offer type is selected
            if (client.getVarpValue(CURRENT_GE_ITEM) != -1
                    && (client.getVarpValue(CURRENT_GE_ITEM) != suggestion.getItemId()
                        || !offerType.equals(suggestion.getType()))
                    && client.getVarpValue(CURRENT_GE_ITEM) == offerManager.getViewedSlotItemId()
                    && offerManager.getViewedSlotItemPrice() > 0) {
                if (grandExchange.getOfferPrice() == offerManager.getViewedSlotItemPrice()) {
                    highlightConfirm();
                } else {
                    highlightPrice();
                }
            }
        }
    }

    private void highlightItemInSearch(Suggestion suggestion) {
        if (!client.getVarcStrValue(VarClientStr.INPUT_TEXT).isEmpty()) {
            return;
        }
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        if (searchResults == null) {
            return;
        }
        for (Widget widget : searchResults.getDynamicChildren()) {
            if (widget.getName().equals("<col=ff9040>" + suggestion.getName() + "</col>")) {
                add(widget, highlightColorController.getBlueColor());
                return;
            }
        }
        Widget itemWidget = searchResults.getChild(3);
        if (itemWidget != null && itemWidget.getItemId() == suggestion.getItemId()) {
            add(itemWidget, highlightColorController.getBlueColor());
        }
    }

    private boolean offerDetailsCorrect(Suggestion suggestion) {
        return grandExchange.getOfferPrice() == suggestion.getPrice()
                && grandExchange.getOfferQuantity() == suggestion.getQuantity();
    }

    private void highlightPrice() {
        Widget setPriceButton = grandExchange.getSetPriceButton();
        if (setPriceButton != null) {
            add(setPriceButton, highlightColorController.getBlueColor(), new Rectangle(1, 6, 33, 23));
        }
    }

    private void highlightQuantity(Suggestion suggestion) {
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (grandExchange.getOfferQuantity() != suggestion.getQuantity()) {
            Widget setQuantityButton;
            if (accountStatus.getInventory().getTotalAmount(suggestion.getItemId()) == suggestion.getQuantity()) {
                setQuantityButton = grandExchange.getSetQuantityAllButton();
            } else {
                setQuantityButton = grandExchange.getSetQuantityButton();
            }
            if (setQuantityButton != null) {
                add(setQuantityButton, highlightColorController.getBlueColor(), new Rectangle(1, 6, 33, 23));
            }
        }
    }

    private void highlightConfirm() {
        Widget confirmButton = grandExchange.getConfirmButton();
        if (confirmButton != null) {
            add(confirmButton, highlightColorController.getBlueColor(), new Rectangle(1, 1, 150, 38));
        }
    }

    private void add(Widget widget, Color color, Rectangle adjustedBounds) {
        SwingUtilities.invokeLater(() -> {
            WidgetHighlightOverlay overlay = new WidgetHighlightOverlay(widget, color, adjustedBounds);
            highlightOverlays.add(overlay);
            overlayManager.add(overlay);
        });
    }

    private void add(Widget widget, Color color) {
        add(widget, color, new Rectangle(0, 0, widget.getWidth(), widget.getHeight()));
    }

    public void removeAll() {
        SwingUtilities.invokeLater(() -> {
            highlightOverlays.forEach(overlayManager::remove);
            highlightOverlays.clear();
        });
    }

    private Widget getInventoryItemWidget(int unnotedItemId) {
        // Inventory has a different widget if GE is open
        Widget inventory = client.getWidget(467, 0);
        if (inventory == null) {
            inventory = client.getWidget(149, 0);
            if (inventory == null) {
                return null;
            }
        }

        Widget notedWidget = null;
        Widget unnotedWidget = null;

        for (Widget widget : inventory.getDynamicChildren()) {
            int itemId = widget.getItemId();
            ItemComposition itemComposition = client.getItemDefinition(itemId);

            if (itemComposition.getNote() != -1) {
                if (itemComposition.getLinkedNoteId() == unnotedItemId) {
                    notedWidget = widget;
                }
            } else if (itemId == unnotedItemId) {
                unnotedWidget = widget;
            }
        }
        return notedWidget != null ? notedWidget : unnotedWidget;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.ItemIdName;
import com.flippingcopilot.ui.FuzzySearchScorer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collectors;
import java.util.stream.IntStream;


@Slf4j
@Singleton
public class ItemController {
    private static final int NAME_CHAR_LIMIT = 25;

    // dependencies
    private final FuzzySearchScorer fuzzySearchScorer;
    private final ItemManager itemManager;
    private final ClientThread clientThread;

    // state
    private final Map<Integer, String> cachedItemNames = new ConcurrentHashMap<>();
    private volatile List<ItemIdName> cachedItems = new ArrayList<>(); // volatile used to guarantee immediate visibility across threads on re-assignment
    private final AtomicBoolean initScheduled = new AtomicBoolean(false);

    @Inject
    public ItemController(Client client,
                          ClientThread clientThread,
                          ItemManager itemManager,
                          FuzzySearchScorer fuzzySearchScorer,
                          ScheduledExecutorService executorService) {
        this.fuzzySearchScorer = fuzzySearchScorer;
        this.itemManager = itemManager;
        this.clientThread = clientThread;

        Runnable initItems = () -> {
            // only allow one init attempt at a time
            if(initScheduled.compareAndSet(false, true)) {
                clientThread.invokeLater(() -> {
                    List<ItemIdName> items = IntStream.range(0, client.getItemCount())
                            .mapToObj(itemManager::getItemComposition)
                            .filter(item -> item.isTradeable() && item.getNote() == -1)
                            .map(i -> new ItemIdName(i.getId(), i.getName()))
                            .collect(Collectors.toList());
                    if (!items.isEmpty()) {
                        cachedItems = items;
                        cachedItems.forEach(i -> cachedItemNames.put(i.itemId, i.name));
                        initScheduled.set(false);
                        log.debug("initialised {} items", items.size());
                        return true;
                    }
                    // if no items are found try again
                    return false;
                });
            }
        };

        // re-init every 5 mins just in case new items are added without restart
        executorService.scheduleAtFixedRate(initItems, 0, 5, TimeUnit.MINUTES);
    }

    public List<ItemIdName> search(String input, Set<Integer> existingSelectedItems) {

        if(input == null || input.isBlank()) {
            return cachedItems.stream()
                    .sorted(Comparator.comparing((ItemIdName i) -> !existingSelectedItems.contains(i.itemId)).thenComparing(i -> i.name))
                    .collect(Collectors.toList());
        }

        ToDoubleFunction<ItemIdName> comparator = fuzzySearchScorer.comparator(input);
        return cachedItems.stream()
                .filter(item -> comparator.applyAsDouble(item) > 0)
                .sorted(Comparator.comparing((ItemIdName i) -> !existingSelectedItems.contains(i.itemId)).thenComparing(Comparator.comparingDouble(comparator).reversed()
                        .thenComparing(i -> i.name)))
                .collect(Collectors.toList());
    }


    private String trimName(String name) {
        if(name.length() > NAME_CHAR_LIMIT) {
            return name.substring(0, NAME_CHAR_LIMIT - 1) + "..";
        }
        return name;
    }

    public Set<Integer> allItemIds() {
        return cachedItemNames.keySet();
    }

    public String getItemName(Integer itemId) {
        return cachedItemNames.getOrDefault(itemId, "Name unavailable");
    }

    public void loadImage(Integer itemId, Consumer<AsyncBufferedImage> c) {
        clientThread.invokeLater(() -> {
            c.accept(itemManager.getImage(itemId));
        });
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.*;
import com.flippingcopilot.ui.flipsdialog.FlipsDialogController;
import com.google.gson.Gson;
import com.google.inject.Provides;
import com.google.inject.Singleton;
import com.google.inject.name.Named;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
@PluginDescriptor(
		name = "Flipping Copilot",
		description = "Your AI assistant for trading"
)
public class FlippingCopilotPlugin extends Plugin {

	@Inject
	private FlippingCopilotConfig config;
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	@Named("copilotExecutor")
	private ScheduledExecutorService executorService;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private Gson gson;
	@Inject
	private GrandExchange grandExchange;
	@Inject
	private GrandExchangeCollectHandler grandExchangeCollectHandler;
	@Inject
	private GrandExchangeOfferEventHandler offerEventHandler;
	@Inject
	private ApiRequestHandler apiRequestHandler;
	@Inject
	private AccountStatusManager accountStatusManager;
	@Inject
	private SuggestionController suggestionController;
	@Inject
	private SuggestionManager suggestionManager;
	@Inject
	private WebHookController webHookController;
	@Inject
	private KeybindHandler keybindHandler;
	@Inject
	private CopilotLoginController copilotLoginController;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private CopilotLoginManager copilotLoginManager;
	@Inject
	private HighlightController highlightController;
	@Inject
	private GameUiChangesHandler gameUiChangesHandler;
	@Inject
	private OsrsLoginManager osrsLoginManager;
	@Inject
	private FlipManager flipManager;
	@Inject
	private SessionManager sessionManager;
	@Inject
	private GrandExchangeUncollectedManager grandExchangeUncollectedManager;
	@Inject
	private TransactionManager transactionManager;
	@Inject
	private OfferManager offerManager;
	@Inject
	private TooltipController tooltipController;
  	@Inject
	private MenuHandler menuHandler;
    @Inject
	private GeHistoryTabController geHistoryTabController;
	@Inject
	private FlipsDialogController flipsDialogController;
	@Inject
	private SuggestionPreferencesManager preferencesManager;

	// We use our own ThreadPool since the default ScheduledExecutorService only has a single thread and we don't want to block it
	@Provides
	@Singleton
	@Named("copilotExecutor")
	public ScheduledExecutorService provideCustomExecutorService() {
		return Executors.newScheduledThreadPool(2);
	}

	@Provides
	@Singleton
	public ExecutorService provideExecutorService(@Named("copilotExecutor") ScheduledExecutorService scheduledExecutor) {
		return scheduledExecutor;
	}

	private MainPanel mainPanel;
	private StatsPanelV2 statsPanel;
	private NavigationButton navButton;

	@Override
	protected void startUp() throws Exception {
		Persistance.setUp(gson);
		// seems we need to delay instantiating the UI till here as otherwise the panels look different
		mainPanel = injector.getInstance(MainPanel.class);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon-small.png");
		navButton = NavigationButton.builder()
				.tooltip("Flipping Copilot")
				.icon(icon)
				.priority(3)
				.panel(mainPanel)
				.build();
		clientToolbar.addNavigation(navButton);
		apiRequestHandler.setCopilotLoginController(copilotLoginController);
		copilotLoginController.setLoginPanel(mainPanel.loginPanel);
		copilotLoginController.setMainPanel(mainPanel);
		suggestionController.setCopilotPanel(mainPanel.copilotPanel);
		suggestionController.setMainPanel(mainPanel);
		suggestionController.setLoginPanel(mainPanel.loginPanel);
		suggestionController.setSuggestionPanel(mainPanel.copilotPanel.suggestionPanel);
		grandExchangeCollectHandler.setSuggestionPanel(mainPanel.copilotPanel.suggestionPanel);
		statsPanel = mainPanel.copilotPanel.statsPanel;

		mainPanel.refresh();

		if(osrsLoginManager.getInvalidStateDisplayMessage() == null) {
			flipManager.setIntervalAccount(null);
			flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
		}
		flipsDialogController.initDialog(SwingUtilities.getWindowAncestor(mainPanel));
		executorService.scheduleAtFixedRate(() ->
			clientThread.invoke(() -> {
				boolean loginValid = osrsLoginManager.isValidLoginState();
				if (loginValid) {
					AccountStatus accStatus = accountStatusManager.getAccountStatus();
					boolean isFlipping = accStatus != null && accStatus.currentlyFlipping();
					long cashStack = accStatus == null ? 0 : accStatus.currentCashStack();
					if(sessionManager.updateSessionStats(isFlipping, cashStack)) {
						mainPanel.copilotPanel.statsPanel.refresh(false, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
					}
				}
			})
		, 2000, 1000, TimeUnit.MILLISECONDS);
	}

	@Override
	protected void shutDown() throws Exception {
		offerManager.saveAll();
		highlightController.removeAll();
		clientToolbar.removeNavigation(navButton);
		if(copilotLoginManager.isLoggedIn()) {
			String displayName = osrsLoginManager.getLastDisplayName();
			Integer accountId = copilotLoginManager.getAccountId(displayName);
			if (accountId != null && accountId != -1) {
				webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, accountId), sessionManager.getCachedSessionData(), displayName, false);
			}
		}
		keybindHandler.unregister();
	}

	@Provides
	public FlippingCopilotConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(FlippingCopilotConfig.class);
	}

	//---------------------------- Event Handlers ----------------------------//
	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event) {
		offerEventHandler.onGrandExchangeOfferChanged(event);
		clientThread.invokeLater(() -> highlightController.redraw());
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event) {
		if (event.getContainerId() == InventoryID.INV && grandExchange.isOpen()) {
			suggestionManager.setSuggestionNeeded(true);
//			log.debug("inventory change item {} qty {}", lastItems, event.getItemContainer().getItems());
			clientThread.invokeLater(() -> highlightController.redraw());
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		suggestionController.onGameTick();
		offerEventHandler.onGameTick();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		int slot = grandExchange.getOpenSlot();
		grandExchangeCollectHandler.handleCollect(event, slot);
		gameUiChangesHandler.handleMenuOptionClicked(event);
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired e) {
		tooltipController.tooltip(e);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		menuHandler.injectCopilotPriceGraphMenuEntry(event);
		menuHandler.injectConfirmMenuEntry(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		if (event.getGroupId() == 383) {
			clientThread.invokeLater(() -> {
				geHistoryTabController.onGeHistoryTabOpened();
			});
		}
		gameUiChangesHandler.onWidgetLoaded(event);
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		if (event.getGroupId() == 383) {
			geHistoryTabController.onGeHistoryTabClosed();
		}
		gameUiChangesHandler.onWidgetClosed(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		gameUiChangesHandler.onVarbitChanged(event);
	}

	@Subscribe
	public void onVarClientStrChanged(VarClientStrChanged event) {
		gameUiChangesHandler.onVarClientStrChanged(event);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		switch (event.getGameState())
		{
			case LOGIN_SCREEN:
				sessionManager.reset();
				suggestionManager.reset();
				osrsLoginManager.reset();
				geHistoryTabController.onGeHistoryTabClosed();
				accountStatusManager.reset();
				grandExchangeUncollectedManager.reset();
				statsPanel.refresh(true, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
				mainPanel.refresh();
				break;
			case LOGGING_IN:
			case HOPPING:
			case CONNECTION_LOST:
				osrsLoginManager.setLastLoginTick(client.getTickCount());
				break;
			case LOGGED_IN:
				// we want to update the flips panel on login but unfortunately the display name
				// is not available immediately so schedule what we need to do here for in the future
				// todo: move to just using the accountHash which is available immediately to simply things
				clientThread.invokeLater(() -> {
					if (client.getGameState() != GameState.LOGGED_IN) {
						return true;
					}
					final String name = osrsLoginManager.getPlayerDisplayName();
					if(name == null) {
						return false;
					}
					statsPanel.resetIntervalDropdownToSession();
					Integer accountId = copilotLoginManager.getAccountId(name);
					if (accountId != null && accountId != -1) {
						flipManager.setIntervalAccount(accountId);
					} else {
						flipManager.setIntervalAccount(null);
					}
					flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
					statsPanel.refresh(true, copilotLoginManager.isLoggedIn()  && osrsLoginManager.isValidLoginState());
					mainPanel.refresh();
					if(copilotLoginManager.isLoggedIn()) {
						transactionManager.scheduleSyncIn(0, name);
					}
					preferencesManager.loadAccountPreferences();

					return true;
				});
		}
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event) {
		gameUiChangesHandler.onVarClientIntChanged(event);
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown clientShutdownEvent) {
		log.debug("client shutdown event received");
		offerManager.saveAll();
		if(copilotLoginManager.isLoggedIn()) {
			String displayName = osrsLoginManager.getLastDisplayName();
			Integer accountId = copilotLoginManager.getAccountId(displayName);
			if (accountId != null && accountId != -1) {
				webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, accountId), sessionManager.getCachedSessionData(), displayName, false);
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals("flippingcopilot")) {
			log.debug("copilot config changed event received");
			if (event.getKey().equals("profitAmountColor") || event.getKey().equals("lossAmountColor")) {
				mainPanel.copilotPanel.statsPanel.refresh(true, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
			}
			if (event.getKey().equals("suggestionHighlights")) {
				clientThread.invokeLater(() -> highlightController.redraw());
			}
		}
	}
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.GrandExchangeUncollectedManager;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.SuggestionPanel;
import com.google.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchangeCollectHandler {

    // dependencies
    private final OsrsLoginManager osrsLoginManager;
    private final GrandExchangeUncollectedManager geUncollected;
    private final SuggestionManager suggestionManager;
    private final Client client;

    @Setter
    private SuggestionPanel suggestionPanel;

    public void handleCollect(MenuOptionClicked event, int slot) {
        String menuOption = event.getMenuOption();
        Widget widget = event.getWidget();
        if (widget != null) {
            handleCollectAll(menuOption, widget);
            handleCollectWithSlotOpen(menuOption, widget, slot);
            handleCollectionBoxCollectAll(menuOption, widget);
            handleCollectionBoxCollectItem(menuOption, widget);
            handleModifyOffer(menuOption, widget);
        }
    }

    private void handleModifyOffer(String menuOption, Widget widget) {
        if (menuOption.equals("Modify offer")) {
            int slot = widget.getId() - 30474247;
            log.debug("modify offer clicked on slot {}", slot);
            suggestionManager.suggestionsDelayedUntil = client.getTickCount() + 2;
            geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
        }
    }

    private void handleCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 30474246) {
            if (menuOption.equals("Collect to inventory")) {
                geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            } else if (menuOption.equals("Collect to bank")) {
                geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            }
            suggestionPanel.refresh();
        }
    }

    private void handleCollectWithSlotOpen(String menuOption, Widget widget, int slot) {
        if (widget.getId() == 30474264 ) {
            if (menuOption.contains("Collect")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            } else if (menuOption.contains("Bank")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            }
            suggestionPanel.refresh();
        }
    }

    private void handleCollectionBoxCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 26345476 && menuOption.equals("Collect to bank")) {
            geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionPanel.refresh();
            
        } else if (widget.getId() == 26345475 && menuOption.equals("Collect to inventory")) {
            geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionPanel.refresh();
        }
    }

    private void handleCollectionBoxCollectItem(String menuOption, Widget widget) {
        int slot = widget.getId() - 26345477;
        if (slot >= 0 && slot <= 7) {
            if (menuOption.contains("Collect")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            } else if (menuOption.contains("Bank")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            }
            suggestionPanel.refresh();
        }
    }
}

package com.flippingcopilot.controller;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.GpDropOverlay;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import javax.inject.Inject;
import javax.inject.Singleton;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.client.ui.overlay.OverlayManager;

import static com.flippingcopilot.model.OsrsLoginManager.GE_LOGIN_BURST_WINDOW;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchangeOfferEventHandler {

    // dependencies
    private final Client client;
    private final OfferManager offerPersistence;
    private final GrandExchange grandExchange;
    private final TransactionManager transactionManager;
    private final OsrsLoginManager osrsLoginManager;
    private final OverlayManager overlayManager;
    private final GrandExchangeUncollectedManager grandExchangeUncollectedManager;
    private final OfferManager offerManager;
    private final SuggestionManager suggestionManager;

    // state
    private final Queue<Transaction> transactionsToProcess = new ConcurrentLinkedQueue<>();

    public void onGameTick() {
        if(!transactionsToProcess.isEmpty()) {
            processTransactions();
        }
    }

    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerEvent) {
        final int slot = offerEvent.getSlot();
        final GrandExchangeOffer offer = offerEvent.getOffer();
        Long accountHash = client.getAccountHash();

        if (offer.getState() == GrandExchangeOfferState.EMPTY && client.getGameState() != GameState.LOGGED_IN) {
            // Trades are cleared by the client during LOGIN_SCREEN/HOPPING/LOGGING_IN, ignore those
            return;
        }

        log.debug("tick {} GE offer updated: state: {}, slot: {}, item: {}, qty: {}, lastLoginTick: {}", client.getTickCount(), offer.getState(), slot, offer.getItemId(), offer.getQuantitySold(), osrsLoginManager.getLastLoginTick());

        SavedOffer o = SavedOffer.fromGrandExchangeOffer(offer);

        SavedOffer prev = offerPersistence.loadOffer(accountHash, slot);

        if(Objects.equals(o, prev)) {
            log.debug("skipping duplicate offer event {}", o);
            return;
        }

        o.setCopilotPriceUsed(wasCopilotPriceUsed(o, prev));
        o.setWasCopilotSuggestion(wasCopilotSuggestion(o, prev));

        boolean consistent = isConsistent(prev, o);
        if(!consistent) {
            log.warn("offer on slot {} is inconsistent with previous saved offer", slot);
        }

        Transaction t = inferTransaction(slot, o, prev, consistent);
        if(t != null) {
            transactionsToProcess.add(t);
            processTransactions();
            log.debug("inferred transaction {}", t);
        }
        updateUncollected(accountHash, slot, o, prev, consistent);
        offerPersistence.saveOffer(accountHash, slot, o);

        // Always fetch suggestion to ensure fast response for better UX
        suggestionManager.setSuggestionNeeded(true);
    }

    private boolean wasCopilotPriceUsed(SavedOffer o, SavedOffer prev) {
        if(isNewOffer(prev, o)){
            return o.getItemId() == offerManager.getLastViewedSlotItemId() && o.getPrice() == offerManager.getLastViewedSlotItemPrice() && Instant.now().minusSeconds(30).getEpochSecond() < offerManager.getLastViewedSlotPriceTime();
        } else {
            return prev.isCopilotPriceUsed();
        }
    }

    private boolean wasCopilotSuggestion(SavedOffer o, SavedOffer prev) {
        if(isNewOffer(prev, o)){
            return o.getItemId() == suggestionManager.getSuggestionItemIdOnOfferSubmitted() && o.getOfferStatus().equals(suggestionManager.getSuggestionOfferStatusOnOfferSubmitted());
        } else {
            return prev.isWasCopilotSuggestion();
        }
    }

    private void updateUncollected(Long accountHash, int slot, SavedOffer o, SavedOffer prev, boolean consistent) {
        if(!consistent) {
            return;
        }
        int uncollectedGp = 0;
        int uncollectedItems = 0;
        switch (o.getState()) {
            case BUYING:
            case BOUGHT:
                uncollectedItems = isNewOffer(prev, o) ? o.getQuantitySold() : o.getQuantitySold() - prev.getQuantitySold();
                break;
            case SOLD:
            case SELLING:
                uncollectedGp = (isNewOffer(prev, o) ? o.getQuantitySold() : o.getQuantitySold() - prev.getQuantitySold()) * o.getPrice();
                break;
            case CANCELLED_BUY:
                uncollectedGp = (o.getTotalQuantity() - o.getQuantitySold()) * o.getPrice();
                break;
            case CANCELLED_SELL:
                uncollectedItems = o.getTotalQuantity() - o.getQuantitySold();
                break;
            case EMPTY:
                // if the slot is empty we want to ensure that the un collected manager doesn't think there is something to collect
                // this can happen due to race conditions between the collection and offer fills timing
                grandExchangeUncollectedManager.ensureSlotClear(accountHash, slot);
                suggestionManager.setSuggestionNeeded(true);
                return;
        }
        grandExchangeUncollectedManager.addUncollected(accountHash, slot, o.getItemId(), uncollectedItems, uncollectedGp);

    }

    private void processTransactions() {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        if(displayName != null) {
            Transaction transaction;
            while ((transaction = transactionsToProcess.poll()) != null) {
                long profit = transactionManager.addTransaction(transaction, displayName);
                if (grandExchange.isHomeScreenOpen() && profit != 0) {
                    new GpDropOverlay(overlayManager, client, profit, transaction.getBoxId());
                }
            }
        }
    }

    public Transaction inferTransaction(int slot, SavedOffer offer, SavedOffer prev, boolean consistent) {
        boolean login = client.getTickCount() <= osrsLoginManager.getLastLoginTick() + GE_LOGIN_BURST_WINDOW;
        boolean isNewOffer = isNewOffer(prev, offer);
        int quantityDiff = isNewOffer ? offer.getQuantitySold() : offer.getQuantitySold() - prev.getQuantitySold();
        int amountSpentDiff = isNewOffer ? offer.getSpent() : offer.getSpent() - prev.getSpent();
        if (quantityDiff > 0 && amountSpentDiff > 0) {
            Transaction t = new Transaction();
            t.setId(UUID.randomUUID());
            t.setType(offer.getOfferStatus());
            t.setItemId(offer.getItemId());
            t.setPrice(offer.getPrice());
            t.setQuantity(quantityDiff);
            t.setBoxId(slot);
            t.setAmountSpent(amountSpentDiff);
            t.setTimestamp(Instant.now());
            t.setCopilotPriceUsed(offer.isCopilotPriceUsed());
            t.setWasCopilotSuggestion(offer.isWasCopilotSuggestion());
            t.setOfferTotalQuantity(offer.getTotalQuantity());
            t.setLogin(login);
            t.setConsistent(consistent);
            return t;
        }
        return null;
    }

    private boolean isConsistent(SavedOffer prev, SavedOffer updated) {
        if(prev == null) {
            return false;
        }
        if(updated.getState() == GrandExchangeOfferState.EMPTY) {
            return true;
        }
        if(prev.getState() == GrandExchangeOfferState.EMPTY && !(updated.getState() == GrandExchangeOfferState.CANCELLED_BUY || updated.getState() == GrandExchangeOfferState.CANCELLED_SELL)) {
            return true;
        }
        return prev.getOfferStatus() == updated.getOfferStatus() ||
                prev.getItemId() == updated.getItemId()
                || prev.getPrice() == updated.getPrice()
                || prev.getTotalQuantity() == updated.getTotalQuantity();
    }

    private boolean isNewOffer(SavedOffer prev, SavedOffer updated) {
        if (prev == null) {
            return true;
        }
        return prev.getOfferStatus() != updated.getOfferStatus() ||
                prev.getItemId() != updated.getItemId()
                || prev.getPrice() != updated.getPrice()
                || prev.getTotalQuantity() != updated.getTotalQuantity()
                || prev.getQuantitySold() > updated.getQuantitySold()
                || prev.getSpent() > updated.getSpent();
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.*;
import com.flippingcopilot.ui.flipsdialog.FlipsDialogController;
import com.flippingcopilot.ui.graph.model.Data;
import com.google.gson.Gson;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;

@Slf4j
@Getter
@Setter
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SuggestionController {

    // dependencies
    private final PausedManager pausedManager;
    private final Client client;
    private final Gson gson;
    private final OsrsLoginManager osrsLoginManager;
    private final HighlightController highlightController;
    private final GrandExchange grandExchange;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler apiRequestHandler;
    private final Notifier notifier;
    private final OfferManager offerManager;
    private final CopilotLoginManager copilotLoginManager;
    private final ClientThread clientThread;
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final AccountStatusManager accountStatusManager;
    private final GrandExchangeUncollectedManager uncollectedManager;
    private final FlipsDialogController flipDialogController;

    private MainPanel mainPanel;
    private LoginPanel loginPanel;
    private CopilotPanel copilotPanel;
    private SuggestionPanel suggestionPanel;

    public void togglePause() {
        if (pausedManager.isPaused()) {
            pausedManager.setPaused(false);
            suggestionManager.setSuggestionNeeded(true);
            suggestionPanel.refresh();
        } else {
            pausedManager.setPaused(true);
            highlightController.removeAll();
            suggestionPanel.refresh();
        }
    }

    void onGameTick() {
        if(suggestionManager.isSuggestionRequestInProgress() || suggestionManager.isGraphDataReadingInProgress()) {
            return;
        }
        // There is a race condition when the collect button is hit at the same time as offers fill.
        // In such a case we can end up with the uncollectedManager falsely thinking there is items to collect.
        // We identify if this has happened here by checking if the collect button is actually visible.
        if(isUncollectedOutOfSync()) {
            log.warn("uncollected is out of sync, it thinks there are items to collect but the GE is open and the Collect button not visible");
            uncollectedManager.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionManager.setSuggestionNeeded(true);
        }
        // on initial login the state of the GE offers isn't correct we need to wait a couple ticks before requesting a suggestion
        if (osrsLoginManager.hasJustLoggedIn()) {
            return;
        }
        if (suggestionManager.suggestionsDelayedUntil < client.getTickCount() && (suggestionManager.isSuggestionNeeded() || suggestionManager.suggestionOutOfDate()) && !(grandExchange.isSlotOpen() && !accountStatusManager.isSuggestionSkipped())) {
            getSuggestionAsync();
        }
    }

    private boolean isUncollectedOutOfSync() {
        if (client.getTickCount() <= uncollectedManager.getLastUncollectedAddedTick() + 2) {
            return false;
        }
        if(!grandExchange.isHomeScreenOpen() || grandExchange.isCollectButtonVisible()) {
            return false;
        }
        if(uncollectedManager.HasUncollected(osrsLoginManager.getAccountHash())) {
            return true;
        }
        if(suggestionPanel.isCollectItemsSuggested()) {
            return true;
        }
        return false;
    }

    public void getSuggestionAsync() {
        suggestionManager.setSuggestionNeeded(false);
        if (!copilotLoginManager.isLoggedIn() || !osrsLoginManager.isValidLoginState()) {
            return;
        }
        if (suggestionManager.isSuggestionRequestInProgress()) {
            return;
        }
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (accountStatus == null) {
            return;
        }
        suggestionManager.setSuggestionRequestInProgress(true);
        suggestionManager.setGraphDataReadingInProgress(true);
        Suggestion oldSuggestion = suggestionManager.getSuggestion();
        Consumer<Suggestion> suggestionConsumer = (newSuggestion) -> {
            suggestionManager.setSuggestion(newSuggestion);
            suggestionManager.setSuggestionError(null);
            suggestionManager.setSuggestionRequestInProgress(false);
            log.debug("Received suggestion: {}", newSuggestion.toString());
            accountStatusManager.resetSkipSuggestion();
            offerManager.setOfferJustPlaced(false);
            suggestionPanel.refresh();
            showNotifications(oldSuggestion, newSuggestion, accountStatus);
            if(!newSuggestion.getType().equals("wait")) {
                SwingUtilities.invokeLater(() ->flipDialogController.priceGraphPanel.newSuggestedItemId(newSuggestion.getItemId()));
            }
        };
        Consumer<Data> graphDataConsumer = (d) -> {
            SwingUtilities.invokeLater(() -> flipDialogController.priceGraphPanel.setSuggestionPriceData(d));
            suggestionManager.setGraphDataReadingInProgress(false);
        };
        Consumer<HttpResponseException> onFailure = (e) -> {
            suggestionManager.setSuggestion(null);
            suggestionManager.setSuggestionError(e);
            suggestionManager.setSuggestionRequestInProgress(false);
            suggestionManager.setGraphDataReadingInProgress(false);
            if (e.getResponseCode() == 401) {
                copilotLoginManager.reset();
                mainPanel.refresh();
                loginPanel.showLoginErrorMessage("Login timed out. Please log in again");
            } else {
                suggestionPanel.refresh();
            }
        };
        suggestionPanel.refresh();
        log.debug("tick {} getting suggestion", client.getTickCount());
        apiRequestHandler.getSuggestionAsync(accountStatus.toJson(gson, grandExchange.isOpen(), config.priceGraphWebsite() == FlippingCopilotConfig.PriceGraphWebsite.FLIPPING_COPILOT), suggestionConsumer, graphDataConsumer, onFailure);
    }

    void showNotifications(Suggestion oldSuggestion, Suggestion newSuggestion, AccountStatus accountStatus) {
        if (shouldNotify(newSuggestion, oldSuggestion)) {
            if (config.enableTrayNotifications()) {
                notifier.notify(newSuggestion.toMessage());
            }
            if (!copilotPanel.isShowing() && config.enableChatNotifications()) {
                showChatNotifications(newSuggestion, accountStatus);
            }
        }
    }

    static boolean shouldNotify(Suggestion newSuggestion, Suggestion oldSuggestion) {
        if (newSuggestion.getType().equals("wait")) {
            return false;
        }
        if (oldSuggestion != null && newSuggestion.equals(oldSuggestion)) {
            return false;
        }
        return true;
    }

    private void showChatNotifications(Suggestion newSuggestion, AccountStatus accountStatus) {
        if (accountStatus.isCollectNeeded(newSuggestion)) {
            clientThread.invokeLater(() -> showChatNotification("Flipping Copilot: Collect items"));
        }
        clientThread.invokeLater(() -> showChatNotification(newSuggestion.toMessage()));
    }

    private void showChatNotification(String message) {
        String chatMessage = new ChatMessageBuilder()
                .append(config.chatTextColor(), message)
                .build();
        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", chatMessage, "");
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.SuggestionManager;
import net.runelite.api.Client;
import net.runelite.api.VarClientInt;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.KeyEvent;


@Singleton
public class KeybindHandler {

    private final KeyManager keyManager;
    private final FlippingCopilotConfig config;
    private final ClientThread clientThread;
    private final SuggestionManager suggestionManager;
    private final Client client;
    private final GrandExchange grandExchange;
    private final OfferHandler offerHandler;


    @Inject
    public KeybindHandler(KeyManager keyManager, FlippingCopilotConfig config, ClientThread clientThread, SuggestionManager suggestionManager, Client client, GrandExchange grandExchange, OfferHandler offerHandler) {
        this.keyManager = keyManager;
        this.config = config;
        this.clientThread = clientThread;
        this.suggestionManager = suggestionManager;
        this.client = client;
        this.grandExchange = grandExchange;
        this.offerHandler = offerHandler;
        keyManager.registerKeyListener(offerEditorKeyListener());
    }

    public void unregister() {
        keyManager.unregisterKeyListener(offerEditorKeyListener());
    }


    private KeyListener offerEditorKeyListener() {
        return new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {
                // Prevent enter as a keybind as that will also submit the value
                if (e.getKeyCode() == KeyEvent.VK_ENTER) return;
                if (e.getKeyCode() !=config.quickSetKeybind().getKeyCode()) return;

               clientThread.invokeLater(this::handleKeybind);
            }

            @Override
            public void keyReleased(KeyEvent e) {

            }

            private void handleKeybind() {
                var suggestion = suggestionManager.getSuggestion();

                var inputType = client.getVarcIntValue(VarClientInt.INPUT_TYPE);

                var isPriceOrQuantityBoxOpen =client.getWidget(ComponentID.CHATBOX_TITLE) != null
                        && inputType == 7
                        &&client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) != null
                        &&grandExchange.isSlotOpen();

                if (isPriceOrQuantityBoxOpen) {
                   offerHandler.setSuggestedAction(suggestion);
                }
            }
        };
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.graph.model.Data;
import com.google.gson.*;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Type;
import java.net.URLEncoder;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.function.Consumer;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ApiRequestHandler {

    private static final String serverUrl = System.getenv("FLIPPING_COPILOT_HOST") != null ? System.getenv("FLIPPING_COPILOT_HOST")  : "https://api.flippingcopilot.com";
    public static final String DEFAULT_COPILOT_PRICE_ERROR_MESSAGE = "Unable to fetch price copilot price (possible server update)";
    public static final String DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE = "Error loading premium instance data (possible server update)";
    public static final String UNKNOWN_ERROR = "Unknown error";
    public static final int UNAUTHORIZED_CODE = 401;
    // dependencies
    private final OkHttpClient client;
    private final Gson gson;
    private final CopilotLoginManager copilotLoginManager;
    @Setter
    private CopilotLoginController copilotLoginController;
    private final SuggestionPreferencesManager preferencesManager;
    private final ClientThread clientThread;


    public void authenticate(String username, String password, Consumer<LoginResponse> successCallback, Consumer<String> failureCallback) {
        Request request = new Request.Builder()
                .url(serverUrl + "/login")
                .addHeader("Authorization", Credentials.basic(username, password))
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), ""))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                failureCallback.accept(UNKNOWN_ERROR);
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.warn("login failed with http status code {}", response.code());
                        String errorMessage = extractErrorMessage(response);
                        failureCallback.accept(errorMessage);
                        return;
                    }
                    String body = response.body() == null ? "" : response.body().string();
                    LoginResponse loginResponse = gson.fromJson(body, LoginResponse.class);
                    successCallback.accept(loginResponse);
                } catch (IOException | JsonParseException e) {
                    log.warn("error reading/decoding login response body", e);
                    failureCallback.accept(UNKNOWN_ERROR);
                }
            }
        });
    }

    public void getSuggestionAsync(JsonObject status,
                                   Consumer<Suggestion> suggestionConsumer,
                                   Consumer<Data> graphDataConsumer,
                                   Consumer<HttpResponseException>  onFailure) {
        log.debug("sending status {}", status.toString());
        Request request = new Request.Builder()
                .url(serverUrl + "/suggestion")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .addHeader("Accept", "application/x-msgpack")
                .addHeader("X-VERSION", "1")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), status.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("call to get suggestion failed", e);
                clientThread.invoke(() -> onFailure.accept(new HttpResponseException(-1, UNKNOWN_ERROR)));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.warn("get suggestion failed with http status code {}", response.code());
                        clientThread.invoke(() -> onFailure.accept(new HttpResponseException(response.code(), extractErrorMessage(response))));
                        return;
                    }
                    handleSuggestionResponse(response, suggestionConsumer, graphDataConsumer);
                } catch (Exception e) {
                    log.warn("error reading/parsing suggestion response body", e);
                    clientThread.invoke(() -> onFailure.accept(new HttpResponseException(-1, UNKNOWN_ERROR)));
                }
            }
        });
    }

    private void handleSuggestionResponse(Response response, Consumer<Suggestion> suggestionConsumer, Consumer<Data> graphDataConsumer) throws IOException {
        if (response.body() == null) {
            throw new IOException("empty suggestion request response");
        }
        String contentType = response.header("Content-Type");
        Suggestion s;
        if (contentType != null && contentType.contains("application/x-msgpack")) {
            int contentLength = resolveContentLength(response);
            int suggestionContentLength = resolveSuggestionContentLength(response);
            int graphDataContentLength = contentLength - suggestionContentLength;
            log.debug("msgpack suggestion response size is: {}, suggestion size is {}", contentLength, suggestionContentLength);

            Data d = new Data();
            try(InputStream is = response.body().byteStream()) {
                // This is some bespoke handling to make the user experience better. We basically pack two different
                // objects in the response body. The suggestion (first object) and the graph data (second
                // object). The graph data can be a few kb, and we want the suggestion to be displayed
                // immediately, without having to wait for the graph data to be loaded.

                byte[] suggestionBytes = new byte[suggestionContentLength];
                int bytesRead = is.readNBytes(suggestionBytes, 0, suggestionContentLength);
                if (bytesRead != suggestionContentLength) {
                    throw new IOException("failed to read complete suggestion content: " + bytesRead + " of " + suggestionContentLength + " bytes");
                }
                s = Suggestion.fromMsgPack(ByteBuffer.wrap(suggestionBytes));
                log.debug("suggestion received");
                clientThread.invoke(() -> suggestionConsumer.accept(s));

                if (graphDataContentLength == 0) {
                    d.loadingErrorMessage = "No graph data loaded for this item.";
                } else {
                    try {
                        byte[] remainingBytes = is.readAllBytes();
                        if (graphDataContentLength != remainingBytes.length) {
                            log.error("the graph data bytes read {} doesn't match the expected bytes {}", bytesRead, graphDataContentLength);
                            d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                        } else {
                            try {
                                d = Data.fromMsgPack(ByteBuffer.wrap(remainingBytes));
                                log.debug("graph data received");
                            } catch (Exception e) {
                                log.error("error deserializing graph data", e);
                                d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                            }
                        }
                    } catch (IOException e) {
                        log.error("error on reading graph data bytes from the suggestion response", e);
                        d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                    }
                }
            }
            if (s != null && "wait".equals(s.getType())){
                d.fromWaitSuggestion = true;
            }
            Data finalD = d;
            clientThread.invoke(() -> graphDataConsumer.accept(finalD));
        } else {
            String body = response.body().string();
            log.debug("json suggestion response size is: {}", body.getBytes().length);
            s = gson.fromJson(body, Suggestion.class);
            clientThread.invoke(() -> suggestionConsumer.accept(s));
            Data d = new Data();
            d.loadingErrorMessage = "No graph data loaded for this item.";
            clientThread.invoke(() -> graphDataConsumer.accept(d));
        }
    }

    private int resolveContentLength(Response resp) throws IOException {
        try {
            String cl = resp.header("Content-Length");
            return Integer.parseInt(cl != null ? cl : "missing Content-Length header");
        } catch (NumberFormatException  e) {
            throw new IOException("Failed to parse response Content-Length", e);
        }
    }

    private int resolveSuggestionContentLength(Response resp) throws IOException {
        try {
            String cl = resp.header("X-Suggestion-Content-Length");
            return Integer.parseInt(cl != null ? cl : "missing Content-Length header");
        } catch (NumberFormatException  e) {
            throw new IOException("Failed to parse response Content-Length", e);
        }
    }

    public void sendTransactionsAsync(List<Transaction> transactions, String displayName, BiConsumer<Integer, List<FlipV2>> onSuccess, Consumer<HttpResponseException> onFailure) {
        log.debug("sending {} transactions for display name {}", transactions.size(), displayName);
        JsonArray body = new JsonArray();
        for (Transaction transaction : transactions) {
            body.add(transaction.toJsonObject());
        }
        Integer userId = copilotLoginManager.getCopilotUserId();
        String encodedDisplayName = URLEncoder.encode(displayName, StandardCharsets.UTF_8);
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/client-transactions?display_name=" + encodedDisplayName)
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .header("Accept", "application/x-bytes")
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("call to sync transactions failed", e);
                onFailure.accept(new HttpResponseException(-1, UNKNOWN_ERROR));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.warn("call to sync transactions failed status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(new HttpResponseException(response.code(), errorMessage));
                        return;
                    }
                    List<FlipV2> changedFlips = FlipV2.listFromRaw(response.body().bytes());
                    onSuccess.accept(userId, changedFlips);
                } catch (Exception e) {
                    log.warn("error reading/parsing sync transactions response body", e);
                    onFailure.accept(new HttpResponseException(-1, UNKNOWN_ERROR));
                }
            }
        });
    }

    private String extractErrorMessage(Response response) {
        if (response.body() != null) {
            try {
                String bodyStr = response.body().string();
                JsonObject errorJson = gson.fromJson(bodyStr, JsonObject.class);
                if (errorJson.has("message")) {
                    return errorJson.get("message").getAsString();
                }
            } catch (Exception e) {
                log.warn("failed reading/parsing error message from http {} response body", response.code(), e);
            }
        }
        return UNKNOWN_ERROR;
    }


    public void asyncGetVisualizeFlipData(UUID flipID, String displayName, Consumer<VisualizeFlipResponse> onSuccess, Consumer<String> onFailure) {
        JsonObject body = new JsonObject();
        body.add("flip_id", new JsonPrimitive(flipID.toString()));
        body.add("display_name", new JsonPrimitive(displayName));
        log.debug("requesting visualize data for flip {}", flipID);
        Request request = new Request.Builder()
                .url(serverUrl +"/profit-tracking/visualize-flip")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .addHeader("Accept", "application/x-msgpack")
                .addHeader("X-VERSION", "1")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newBuilder()
                .callTimeout(30, TimeUnit.SECONDS) // Overall timeout
                .build()
                .newCall(request)
                .enqueue(new Callback() {
                    @Override
                    public void onFailure(Call call, IOException e) {
                        onFailure.accept(e.toString());
                    }
                    @Override
                    public void onResponse(Call call, Response response) {
                        try {
                            if (!response.isSuccessful()) {
                                if(response.code() == UNAUTHORIZED_CODE) {
                                    copilotLoginController.onLogout();
                                }
                                log.error("get visualize data for flip {} failed with http status code {}", flipID, response.code());
                                onFailure.accept(UNKNOWN_ERROR);
                            } else {
                                byte[] d = response.body().bytes();
                                VisualizeFlipResponse rsp = VisualizeFlipResponse.fromMsgPack(ByteBuffer.wrap(d));
                                log.debug("visualize data received for flip {}", flipID);
                                onSuccess.accept(rsp);
                            }
                        } catch (Exception e) {
                            log.error("error visualize data received for flip {}", flipID, e);
                            onFailure.accept(UNKNOWN_ERROR);
                        }
                    }
                });
    }

    public void asyncGetItemPriceWithGraphData(int itemId, String displayName, Consumer<ItemPrice> consumer, boolean includeGraphData) {
        JsonObject body = new JsonObject();
        body.add("item_id", new JsonPrimitive(itemId));
        body.add("display_name", new JsonPrimitive(displayName));
        body.addProperty("f2p_only", preferencesManager.isF2pOnlyMode());
        body.addProperty("timeframe_minutes", preferencesManager.getTimeframe());
        body.addProperty("risk_level", preferencesManager.getRiskLevel().toApiValue());
        body.addProperty("include_graph_data", includeGraphData);
        log.debug("requesting price graph data for item {}", itemId);
        Request request = new Request.Builder()
                .url(serverUrl +"/prices")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .addHeader("Accept", "application/x-msgpack")
                .addHeader("X-VERSION", "1")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newBuilder()
                .callTimeout(30, TimeUnit.SECONDS) // Overall timeout
                .build()
                .newCall(request)
                .enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error fetching copilot price for item {}", itemId, e);
                ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                clientThread.invoke(() -> consumer.accept(ip));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("get copilot price for item {} failed with http status code {}", itemId, response.code());
                        ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                        clientThread.invoke(() -> consumer.accept(ip));
                    } else {
                        byte[] d = response.body().bytes();
                        ItemPrice ip = ItemPrice.fromMsgPack(ByteBuffer.wrap(d));
                        log.debug("price graph data received for item {}", itemId);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error fetching copilot price for item {}", itemId, e);
                    ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                    clientThread.invoke(() -> consumer.accept(ip));
                }
            }
        });
    }


    public void asyncUpdatePremiumInstances(Consumer<PremiumInstanceStatus> consumer, List<String> displayNames) {
        JsonObject payload = new JsonObject();
        JsonArray arr = new JsonArray();
        displayNames.forEach(arr::add);
        payload.add("premium_display_names", arr);

        Request request = new Request.Builder()
                .url(serverUrl +"/premium-instances/update-assignments")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), payload.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error updating premium instance assignments", e);
                clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("update premium instances failed with http status code {}", response.code());
                        clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                    } else {
                        PremiumInstanceStatus ip = gson.fromJson(response.body().string(), PremiumInstanceStatus.class);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error updating premium instance assignments", e);
                    clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                }
            }
        });
    }

    public void asyncGetPremiumInstanceStatus(Consumer<PremiumInstanceStatus> consumer) {
        Request request = new Request.Builder()
                .url(serverUrl +"/premium-instances/status")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .get()
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error fetching premium instance status", e);
                clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("get premium instance status failed with http status code {}", response.code());
                        clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                    } else {
                        PremiumInstanceStatus ip = gson.fromJson(response.body().string(), PremiumInstanceStatus.class);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error fetching premium instance status", e);
                    clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                }
            }
        });

    }

    public void asyncDeleteFlip(FlipV2 flip, Consumer<FlipV2> onSuccess, Runnable onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("flip_id", flip.getId().toString());

        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/delete-flip")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("deleting flip {}", flip.getId(), e);
                onFailure.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("deleting flip {}, bad response code {}", flip.getId(), response.code());
                        onFailure.run();
                    } else {
                        FlipV2 flip = FlipV2.fromRaw(response.body().bytes());
                        onSuccess.accept(flip);
                    }
                } catch (Exception e) {
                    log.error("deleting flip {}", flip.getId(), e);
                    onFailure.run();
               }
            }
        });
    }

    public void asyncDeleteAccount(int accountId, Runnable onSuccess, Runnable onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("account_id", accountId);

        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/delete-account")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("deleting account {}", accountId, e);
                onFailure.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("deleting account {}, bad response code {}", accountId, response.code());
                        onFailure.run();
                    }
                    onSuccess.run();
                } catch (Exception e) {
                    log.error("deleting account {}", accountId, e);
                    onFailure.run();
                }
            }
        });
    }

    public void asyncLoadAccounts(Consumer<Map<String, Integer>> onSuccess, Consumer<String> onFailure) {
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/rs-account-names")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .method("GET", null)
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error loading user display names", e);
                onFailure.accept(UNKNOWN_ERROR);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.error("load user display names failed with http status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(errorMessage);
                        return;
                    }
                    String responseBody = response.body() != null ? response.body().string() : "{}";
                    Type respType = new TypeToken<Map<String, Integer>>(){}.getType();
                    Map<String, Integer> names = gson.fromJson(responseBody, respType);
                    Map<String, Integer> result = names != null ? names : new HashMap<>();
                    onSuccess.accept(result);
                } catch (Exception e) {
                    log.error("error reading/parsing user display names response body", e);
                    onFailure.accept(UNKNOWN_ERROR);
                }
            }
        });
    }

    public void asyncLoadFlips(Map<Integer, Integer> accountIdTime, BiConsumer<Integer, FlipsDeltaResult> onSuccess, Consumer<String> onFailure) {
        Integer userId = copilotLoginManager.getCopilotUserId();
        DataDeltaRequest body = new DataDeltaRequest(accountIdTime);
        String bodyStr = gson.toJson(body);

        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/client-flips-delta")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .method("POST", RequestBody.create(MediaType.get("application/json; charset=utf-8"), bodyStr))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error loading flips", e);
                onFailure.accept(UNKNOWN_ERROR);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.error("load flips failed with http status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(errorMessage);
                        return;
                    }
                    FlipsDeltaResult res = FlipsDeltaResult.fromRaw(response.body().bytes());
                    onSuccess.accept(userId, res);
                } catch (Exception e) {
                    log.error("error reading/parsing flips response body", e);
                    onFailure.accept(UNKNOWN_ERROR);
                }
            }
        });
    }

    public void asyncLoadTransactionsData(Consumer<byte[]> onSuccess, Consumer<String> onFailure) {

        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/client-transactions")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .get()
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error loading transactions", e);
                onFailure.accept(UNKNOWN_ERROR);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.error("load transactions failed with http status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(errorMessage);
                        return;
                    }
                    byte[] data = response.body().bytes();
                    onSuccess.accept(Arrays.copyOfRange(data, 4, data.length-4));
                } catch (Exception e) {
                    log.error("error reading/parsing transactions response body", e);
                    onFailure.accept(UNKNOWN_ERROR);
                }
            }
        });
    }


    public void asyncOrphanTransaction(AckedTransaction transaction, BiConsumer<Integer, List<FlipV2>> onSuccess, Runnable onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("transaction_id", transaction.getId().toString());
        body.addProperty("account_id", transaction.getAccountId());
        Integer userId = copilotLoginManager.getCopilotUserId();
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/orphan-transaction")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("orphaning transaction {}", transaction.getId(), e);
                onFailure.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("orphaning transaction {}, bad response code {}", transaction.getId(), response.code());
                        onFailure.run();
                    } else {
                        List<FlipV2> flips = FlipV2.listFromRaw(response.body().bytes());
                        onSuccess.accept(userId, flips);
                    }
                } catch (Exception e) {
                    log.error("orphaning transaction {}", transaction.getId(), e);
                    onFailure.run();
                }
            }
        });
    }

    public void asyncDeleteTransaction(AckedTransaction transaction, BiConsumer<Integer, List<FlipV2>> onSuccess, Runnable onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("transaction_id", transaction.getId().toString());
        body.addProperty("account_id", transaction.getAccountId());
        Integer userId = copilotLoginManager.getCopilotUserId();
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/delete-transaction")
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("delete transaction {}", transaction.getId(), e);
                onFailure.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        log.error("delete transaction {}, bad response code {}", transaction.getId(), response.code());
                        onFailure.run();
                    } else {
                        List<FlipV2> flips = FlipV2.listFromRaw(response.body().bytes());
                        onSuccess.accept(userId, flips);
                    }
                } catch (Exception e) {
                    log.error("delete transaction {}", transaction.getId(), e);
                    onFailure.run();
                }
            }
        });
    }

    public void asyncLoadRecentAccountTransactions(String displayName, int endTime, Consumer<List<AckedTransaction>> onSuccess, Consumer<String> onFailure) {
        JsonObject body = new JsonObject();
        body.addProperty("limit", 30);
        body.addProperty("end", endTime);
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/account-client-transactions?display_name=" + displayName)
                .addHeader("Authorization", "Bearer " + copilotLoginManager.getJwtToken())
                .header("Accept", "application/x-bytes")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error loading transactions", e);
                onFailure.accept(UNKNOWN_ERROR);
            }

            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        if(response.code() == UNAUTHORIZED_CODE) {
                            copilotLoginController.onLogout();
                        }
                        String errorMessage = extractErrorMessage(response);
                        log.error("load transactions failed with http status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(errorMessage);
                        return;
                    }
                    onSuccess.accept(AckedTransaction.listFromRaw(response.body().bytes()));
                } catch (Exception e) {
                    log.error("error reading/parsing transactions response body", e);
                    onFailure.accept(UNKNOWN_ERROR);
                }
            }
        });
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.DiscordWebhookBody;
import com.flippingcopilot.model.SessionData;
import com.flippingcopilot.model.Stats;
import com.flippingcopilot.ui.UIUtilities;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.Instant;

import static com.flippingcopilot.util.DateUtil.formatEpoch;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class WebHookController {

    private final FlippingCopilotConfig config;
    private final OkHttpClient okHttpClient;

    private void sendWebHook(DiscordWebhookBody discordWebhookBody) {
        String configURL = config.webhook();
        if (Strings.isNullOrEmpty(configURL)) {return; }

        HttpUrl url = HttpUrl.parse(configURL);
        if (url == null) {
            log.warn("bad discord webhook url {}", configURL);
            return;
        }
        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(discordWebhookBody));
        buildRequestAndSend(url, requestBodyBuilder);
    }

    private void buildRequestAndSend(HttpUrl url, MultipartBody.Builder requestBodyBuilder) {
        RequestBody requestBody = requestBodyBuilder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
        sendRequest(request);
    }

    private void sendRequest(Request request) {
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Error on webhook", e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                response.close();
            }
        });
    }

    public void sendMessage(Stats stats, SessionData sd, String displayName, boolean sessionIsFinished) {
        if (stats.profit != 0 && displayName != null) {

            long seconds = sd.durationMillis / 1000;
            String beganAtText = formatEpoch(sd.startTime);
            String endedAtText = sessionIsFinished ? formatEpoch(Instant.now().getEpochSecond()) : "n/a";
            String durationText = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            String profitText = UIUtilities.formatProfit(stats.profit);
            String taxText = UIUtilities.formatProfit(stats.taxPaid);
            String roiText = String.format("%.3f%%", stats.calculateRoi() * 100);
            String cashStackText = UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp";

            String template = "%s, your session stats are:\n" +
                    "```" +
                    "Session began at:      %s\n" +
                    "Session ended at:      %s\n" +
                    "Active session time:   %s\n" +
                    "Flips made:            %d\n" +
                    "Profit:                %s\n" +
                    "Tax paid:              %s\n" +
                    "Roi:                   %s\n" +
                    "Avg wealth:            %s\n" +
                    "```";

            String discordMessage = String.format(template, displayName, beganAtText, endedAtText, durationText, stats.flipsMade, profitText, taxText, roiText, cashStackText);
            DiscordWebhookBody discordWebhookBody = new DiscordWebhookBody();
            discordWebhookBody.setContent(discordMessage);
            sendWebHook(discordWebhookBody);
        }
    }
}

package com.flippingcopilot.model;

import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
public class ProfileSuggestionPreferences {

    public List<Integer> blockedItemIds = new ArrayList<>();
}

package com.flippingcopilot.model;

import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.*;

import java.nio.ByteBuffer;
import java.text.NumberFormat;

@Setter
@Getter
@AllArgsConstructor
@ToString
@NoArgsConstructor
public class Suggestion {
    private String type;
    @SerializedName("box_id")
    private int boxId;
    @SerializedName("item_id")
    private int itemId;
    private int price;
    private int quantity;
    private String name;
    @SerializedName("command_id")
    private int id;
    private String message;
    private Double expectedProfit;
    private Double expectedDuration;

    @SerializedName("graph_data")
    private Data graphData;


    public boolean equals(Suggestion other) {
        return this.type.equals(other.type)
                && this.boxId == other.boxId
                && this.itemId == other.itemId
                && this.name.equals(other.name);
    }

    public String toMessage() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String string = "Flipping Copilot: ";
        switch (type) {
            case "buy":
                string += String.format("Buy %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "sell":
                string += String.format("Sell %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "abort":
                string += "Abort " + name;
                break;
            case "wait":
                string += "Wait";
                break;
            default:
                string += "Unknown suggestion type";
                break;
        }
        return string;
    }

    public static Suggestion fromMsgPack(ByteBuffer b) {
        Suggestion s = new Suggestion();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }

        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "t":
                    s.type = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "b":
                    s.boxId = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "i":
                    s.itemId = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "p":
                    s.price = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "q":
                    s.quantity = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "n":
                    s.name = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "id":
                    s.id = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "m":
                    s.message = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "ed":
                    s.expectedDuration = (Double) MsgPackUtil.decodePrimitive(b);
                    break;
                case "ep":
                    s.expectedProfit = (Double) MsgPackUtil.decodePrimitive(b);
                    break;
                case "gd":
                    s.graphData = Data.fromMsgPack(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }

        return s;
    }
}



package com.flippingcopilot.model;
import com.flippingcopilot.util.Constants;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


// note: we synchronize all public methods of this class as they read/modify its state and may
// be called by multiple threads at the same time

@Slf4j
@Data
public class AccountStatus {

    private StatusOfferList offers;
    private Inventory inventory;
    private Map<Integer, Long> uncollected;
    private boolean isWorldMember = false;
    private boolean isAccountMember = false;
    private int skipSuggestion = -1;
    private String displayName;
    private Long rsAccountHash;
    private Boolean suggestionsPaused;
    private boolean sellOnlyMode = false;
    private boolean f2pOnlyMode = false;
    private List<Integer> blockedItems;
    private int timeframe = 5; // Default to 5 minutes
    private RiskLevel riskLevel = RiskLevel.MEDIUM;

    public AccountStatus() {
        offers = new StatusOfferList();
        inventory = new Inventory();
    }

    public synchronized boolean isCollectNeeded(Suggestion suggestion) {
        if (offers.isEmptySlotNeeded(suggestion, isWorldMember || isAccountMember)) {
            log.debug("collected needed isEmptySlotNeeded");
            return true;
        }
        if (!inventory.hasSufficientGp(suggestion)) {
            log.debug("collected needed hasSufficientGp");
            return true;
        }
        if (!inventory.hasSufficientItems(suggestion)) {
            log.debug("collected needed hasSufficientItems");
            return true;
        }
        return false;
    }

    public int findEmptySlot() {
        return getOffers().findEmptySlot(isWorldMember || isAccountMember);
    }

    public synchronized JsonObject toJson(Gson gson, boolean geOpen, boolean sendGraphData) {
        JsonObject statusJson = new JsonObject();
        statusJson.addProperty("display_name", displayName);
        statusJson.addProperty("sell_only", sellOnlyMode);
        statusJson.addProperty("f2p_only", f2pOnlyMode);
        statusJson.addProperty("is_member", isWorldMember);
        statusJson.addProperty("is_account_member", isAccountMember);
        statusJson.addProperty("skip_suggestion", skipSuggestion);
        statusJson.addProperty("send_graph_data", sendGraphData);
        statusJson.addProperty("timeframe", timeframe);
        RiskLevel effectiveRiskLevel = riskLevel != null ? riskLevel : RiskLevel.MEDIUM;
        statusJson.addProperty("risk_level", effectiveRiskLevel.toApiValue());
        if (suggestionsPaused != null) {
            statusJson.addProperty("suggestions_paused", suggestionsPaused);
        }
        JsonArray offersJsonArray = offers.toJson(gson);
        JsonArray itemsJsonArray = getItemsJson();
        statusJson.add("offers", offersJsonArray);
        statusJson.add("items", itemsJsonArray);
        JsonArray blockItemsArray = new JsonArray();
        if(blockedItems != null) {
            blockedItems.forEach(blockItemsArray::add);
        }
        statusJson.add("blocked_items", blockItemsArray);

        Set<String> requestedSuggestionTypes = new HashSet<>();
        if (!geOpen) {
            requestedSuggestionTypes.add("abort");
        } else if(sellOnlyMode) {
            requestedSuggestionTypes.add("abort");
            requestedSuggestionTypes.add("sell");
        }
        if(!requestedSuggestionTypes.isEmpty()) {
           JsonArray rstArray = new JsonArray();
           requestedSuggestionTypes.forEach(rstArray::add);
           statusJson.add("requested_suggestion_types", rstArray);
        }
        return statusJson;
    }

    private JsonArray getItemsJson() {
        Map<Integer, Long> itemsAmount = getItemAmounts();
        JsonArray itemsJsonArray = new JsonArray();
        for(Map.Entry<Integer, Long> entry : itemsAmount.entrySet()) {
            JsonObject itemJson = new JsonObject();
            itemJson.addProperty("item_id", entry.getKey());
            itemJson.addProperty("amount", entry.getValue());
            itemsJsonArray.add(itemJson);
        }
        return itemsJsonArray;
    }

    private Map<Integer, Long> getItemAmounts() {
        Map<Integer, Long> itemsAmount = inventory.getItemAmounts();
        uncollected.forEach((key, value) -> itemsAmount.merge(key, value, Long::sum));
        itemsAmount.entrySet().removeIf(entry -> entry.getValue() == 0);
        return itemsAmount;
    }

    public synchronized boolean moreGpNeeded() {
        return emptySlotExists() && getTotalGp() < Constants.MIN_GP_NEEDED_TO_FLIP;
    }

    public synchronized boolean emptySlotExists() {
        return offers.emptySlotExists(isWorldMember || isAccountMember);
    }

    private long getTotalGp() {
        return inventory.getTotalGp() + offers.getTotalGpToCollect();
    }

    public synchronized boolean currentlyFlipping() {
        return offers.stream().anyMatch(Offer::isActive);
    }

    public synchronized long currentCashStack() {
        // the cash stack is the gp in their inventory + the value on the market
        // todo: when a buy offer has fully finished its value will not count towards the cash stack
        //  size until they start selling it. We should probably track items that where recently bought
        //  and they should still count towards the cash stack size for some period of time
        return offers.getGpOnMarket() + inventory.getTotalGp();
    }
}

package com.flippingcopilot.model;

import lombok.Getter;

import java.io.IOException;

@Getter
public class HttpResponseException extends IOException {
    private final int responseCode;
    private final String responseMessage;

    public HttpResponseException(int responseCode, String message) {
        super(message);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }

    public HttpResponseException(int responseCode, String message, Throwable cause) {
        super(message, cause);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }
}
package com.flippingcopilot.model;

import com.google.common.base.MoreObjects;

public enum FlipStatus {
    BUYING,
    SELLING,
    FINISHED;

    public static FlipStatus fromValue(String value) {
        switch (MoreObjects.firstNonNull(value, "").toUpperCase()) {
            case "O":
                return FlipStatus.BUYING;
            case "C":
                return FlipStatus.SELLING;
            case "F":
                return FlipStatus.FINISHED;
            default:
                return FlipStatus.BUYING;
        }
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.inject.name.Named;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Singleton
@Slf4j
public class SuggestionPreferencesManager {

    private static final int DEFAULT_TIMEFRAME = 5;

    public static final Path DEFAULT_PROFILE_PATH = Paths.get(Persistance.COPILOT_DIR.getPath(), "Default profile.profile.json");
    public static final String PROFILE_SUFFIX = ".profile.json";

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;
    private final OsrsLoginManager osrsLoginManager;

    // state
    private AccountSuggestionPreferences accountSuggestionPreferences = new AccountSuggestionPreferences();
    private ProfileSuggestionPreferences cachedPreferences;
    private Path selectedProfile;
    private List<Path> availableProfiles;

    @Getter
    @Setter
    private volatile boolean sellOnlyMode = false;

    @Inject
    public SuggestionPreferencesManager(Gson gson, @Named("copilotExecutor") ScheduledExecutorService executorService, OsrsLoginManager osrsLoginManager) {
        this.gson = gson;
        this.executorService = executorService;
        this.osrsLoginManager = osrsLoginManager;
        loadAvailableProfiles();
        selectedProfile = DEFAULT_PROFILE_PATH;
        loadCurrentProfile();
        executorService.scheduleAtFixedRate(() -> {
            this.loadAvailableProfiles();
            this.loadCurrentProfile();
        }, 5L, 5L, TimeUnit.SECONDS);
    }

    public synchronized List<String> getAvailableProfiles() {
        return availableProfiles.stream().map(this::toDisplayName).collect(Collectors.toList());
    }

    public synchronized boolean isF2pOnlyMode() {
        return accountSuggestionPreferences.isF2pOnlyMode();
    }

    public synchronized void setF2pOnlyMode(boolean f2pOnlyMode) {
        accountSuggestionPreferences.setF2pOnlyMode(f2pOnlyMode);
        executorService.submit(() -> updateAccountPreferences(accountSuggestionPreferences));
    }

    public synchronized void setTimeframe(int minutes) {
        accountSuggestionPreferences.setTimeframe(minutes > 0 ? minutes : DEFAULT_TIMEFRAME);
        executorService.submit(() -> updateAccountPreferences(accountSuggestionPreferences));
    }

    public synchronized int getTimeframe() {
        return accountSuggestionPreferences.getTimeframe();
    }

    public synchronized void setRiskLevel(RiskLevel riskLevel) {
        accountSuggestionPreferences.setRiskLevel(riskLevel == null ? RiskLevel.MEDIUM : riskLevel);
        executorService.submit(() -> updateAccountPreferences(accountSuggestionPreferences));
    }

    public synchronized RiskLevel getRiskLevel() {
        return accountSuggestionPreferences.getRiskLevel();
    }

    public synchronized void setBlockedItems(Set<Integer> blockedItems) {
        List<Integer> toUnblock = cachedPreferences.blockedItemIds.stream().filter(i -> !blockedItems.contains(i)).collect(Collectors.toList());
        List<Integer> toBlock = blockedItems.stream().filter(i -> !cachedPreferences.blockedItemIds.contains(i)).collect(Collectors.toList());
        Consumer<ProfileSuggestionPreferences> update = (s) -> {
            s.blockedItemIds.removeIf(toUnblock::contains);
            toBlock.forEach(i -> {
                if(!s.blockedItemIds.contains(i)) {
                    s.blockedItemIds.add(i);
                }
            });
        };
        log.debug("blocking {}, unblocking {}", toBlock, toUnblock);
        update.accept(cachedPreferences);
        executorService.submit(() -> updateProfile(selectedProfile, update));
    }

    public synchronized void blockItem(int itemId) {
        Consumer<ProfileSuggestionPreferences> update = (s) -> {
            if(!s.blockedItemIds.contains(itemId)) {
                s.blockedItemIds.add(itemId);
            }
        };
        update.accept(cachedPreferences);
        executorService.submit(() -> updateProfile(selectedProfile, update));
        log.debug("blocked item {}", itemId);
    }

    public synchronized List<Integer> blockedItems() {
        return cachedPreferences.getBlockedItemIds();
    }

    public synchronized boolean isDefaultProfileSelected() {
        return DEFAULT_PROFILE_PATH.equals(selectedProfile);
    }

    public synchronized String getCurrentProfile() {
        return toDisplayName(selectedProfile);
    }

    public synchronized void setCurrentProfile(String name) {
        selectedProfile = fromDisplayName(name);
        loadCurrentProfile();
    }

    public synchronized void addProfile(String name) throws IOException {
        Path p = Paths.get(Persistance.COPILOT_DIR.toString(), name + PROFILE_SUFFIX);
        createProfileFile(p);
        availableProfiles.add(p);
        selectedProfile = p;
        loadCurrentProfile();
    }

    private synchronized void updateProfile(Path profile, Consumer<ProfileSuggestionPreferences> changes) {
        Path lockFile = Paths.get(profile+ ".lock");
        Path tmpFile = Paths.get(profile+ ".tmp");
        try {
            ProfileSuggestionPreferences preferences;
            if (Files.exists(profile)) {
                preferences = gson.fromJson(Files.readString(profile), ProfileSuggestionPreferences.class);
            } else {
                preferences = new ProfileSuggestionPreferences();
            }
            changes.accept(preferences);
            String toWrite = gson.toJson(preferences);
            // acquire <file>.lock
            try (FileChannel lockChannel = FileChannel.open(lockFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE); FileLock l = lockChannel.lock()) {
                // write as .tmp file then re-name
                Files.writeString(tmpFile,toWrite );
                Files.move(tmpFile, profile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            } finally {
                Files.deleteIfExists(lockFile);
                Files.deleteIfExists(tmpFile);
            }
        } catch (IOException e) {
            log.warn("error saving preferences json file {}", profile, e);
        }
    }

    private synchronized void loadCurrentProfile() {
        try {
            if (Files.exists(selectedProfile)) {
                cachedPreferences = gson.fromJson(Files.readString(selectedProfile), ProfileSuggestionPreferences.class);
            } else {
                cachedPreferences = new ProfileSuggestionPreferences();
            }
        } catch (IOException e) {
            log.error("reading profile {}", selectedProfile, e);
        }
    }

    private synchronized void loadAvailableProfiles() {
        try (Stream<Path> paths = Files.list(Persistance.COPILOT_DIR.toPath())) {
            availableProfiles = paths
                    .filter(p -> p.toString().endsWith(PROFILE_SUFFIX))
                    .collect(Collectors.toList());
        } catch (IOException e) {
            availableProfiles = new ArrayList<>();
            availableProfiles.add(DEFAULT_PROFILE_PATH);
            log.error("loading available profiles", e);
        }
    }

    private String toDisplayName(Path p ) {
        return p == null ? null : p.getFileName().toString().replaceAll("\\.profile\\.json$", "");
    }

    private Path fromDisplayName(String name) {
        return Paths.get(Persistance.COPILOT_DIR.toString(), name + PROFILE_SUFFIX);
    }

    public synchronized void deleteSelectedProfile() throws IOException {
        Path lockFile = Paths.get(selectedProfile+ ".lock");
        try (FileChannel lockChannel = FileChannel.open(lockFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE); FileLock l = lockChannel.lock()) {
            Files.delete(selectedProfile);
        } finally {
            Files.deleteIfExists(lockFile);
        }
        selectedProfile = DEFAULT_PROFILE_PATH;
        loadCurrentProfile();
        loadAvailableProfiles();
    }

    private void createProfileFile(Path profile) throws IOException {
        Path lockFile = Paths.get(profile + ".lock");
        Path tmpFile = Paths.get(profile + ".tmp");
        String toWrite = "{}";
        // acquire <file>.lock
        try (FileChannel lockChannel = FileChannel.open(lockFile, StandardOpenOption.CREATE, StandardOpenOption.WRITE); FileLock l = lockChannel.lock()) {
            // write as .tmp file then re-name
            Files.writeString(tmpFile, toWrite);
            Files.move(tmpFile, profile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
        } finally {
            Files.deleteIfExists(lockFile);
        }
    }

    public synchronized void loadAccountPreferences() {
        if(osrsLoginManager.getAccountHash() == null){
            return;
        }
        Path f = accountPreferencesPath();
        try {
            if(Files.exists(f)) {
                accountSuggestionPreferences = gson.fromJson(Files.readString(f), AccountSuggestionPreferences.class);
            } else {
                accountSuggestionPreferences = new AccountSuggestionPreferences();
            }
        } catch (IOException e) {
            log.warn("error loading account preferences json file {}", f, e);
        }
    }

    private synchronized void updateAccountPreferences(AccountSuggestionPreferences ap) {
        Long osrsAccountHash = osrsLoginManager.getAccountHash();
        if (osrsAccountHash == null) {
            return;
        }
        Path f = accountPreferencesPath();
        Path tmpFile = Paths.get(f + ".tmp");
        try {
            String toWrite = gson.toJson(ap);
            // acquire <file>.lock
            try {
                Files.writeString(tmpFile,toWrite );
                Files.move(tmpFile, f, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            } finally {
                Files.deleteIfExists(tmpFile);
            }
        } catch (IOException e) {
            log.warn("error saving preferences json file {}", f, e);
        }
    }

    private Path accountPreferencesPath() {
        return Paths.get(Persistance.COPILOT_DIR.getPath(), "acc_" + osrsLoginManager.getAccountHash() + "_prefs.json");
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SessionManager {

    public static final String SESSION_DATA_FILE_TEMPLATE = "%s_session_data.jsonl";

    private final OsrsLoginManager osrsLoginManager;
    private final ScheduledExecutorService executorService;
    private final Gson gson;

    private final Map<String, SessionData> cachedSessionData =  new HashMap<>();
    private final Map<String, File> displayNameToFile = new HashMap<>();

    private Instant lastSessionUpdateTime;

    public synchronized SessionData getCachedSessionData() {
        SessionData sd = getSessionData(osrsLoginManager.getPlayerDisplayName());
        return new SessionData(sd.startTime,  sd.durationMillis, sd.averageCash);
    }

    public synchronized void resetSession() {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        SessionData sd = getSessionData(displayName);
        sd.startTime = (int) Instant.now().getEpochSecond();
        sd.averageCash = 0;
        sd.durationMillis = 0;
        saveAsync(displayName);
    }

    public synchronized boolean updateSessionStats(boolean currentlyFlipping, long cashStack) {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        if (!currentlyFlipping || displayName == null) {
            lastSessionUpdateTime = null;
            return false;
        } else if (lastSessionUpdateTime == null) {
            lastSessionUpdateTime = Instant.now();
            return false;
        } else {
            SessionData sd = getSessionData(displayName);
            Instant now = Instant.now();
            long duration = Duration.between(lastSessionUpdateTime, now).toMillis();
            long newAverageCashStack = (cashStack * duration + sd.durationMillis * sd.averageCash) / (sd.durationMillis + duration);
            sd.durationMillis = sd.durationMillis + duration;
            lastSessionUpdateTime = now;
            sd.averageCash = newAverageCashStack;
            saveAsync(displayName);
            return true;
        }
    }

    private void saveAsync(String displayName) {
        executorService.submit(() -> {
            File file = getFile(displayName);
            synchronized (file) {
                SessionData data = cachedSessionData.computeIfAbsent(displayName, this::load);
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(data);
                    writer.write(json);
                    writer.newLine();
                } catch (IOException e) {
                    log.warn("error storing session data to file {}", file, e);
                }
            }
        });
    }

     private SessionData load(String displayName) {
        File file = getFile(displayName);
        if (!file.exists()) {
            return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            SessionData sd =  gson.fromJson(reader, SessionData.class);
            if (sd != null) {
                return sd;
            }
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading session data json file {}", file, e);
        }
        return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
    }

    private File getFile(String displayName) {
        return displayNameToFile.computeIfAbsent(displayName,
                (k) -> new File(Persistance.COPILOT_DIR, String.format(SESSION_DATA_FILE_TEMPLATE, Persistance.hashDisplayName(displayName))));
    }

    private SessionData getSessionData(String displayName) {
         return cachedSessionData.computeIfAbsent(displayName, this::load);
    }

    public synchronized void reset() {
        lastSessionUpdateTime = null;
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.util.MutableReference;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class TransactionManager {

    // dependencies
    private final FlipManager flipManager;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler api;
    private final CopilotLoginManager copilotLoginManager;
    private final OsrsLoginManager osrsLoginManager;

    // state
    private final ConcurrentMap<String, List<Transaction>> cachedUnAckedTransactions = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, AtomicBoolean> transactionSyncScheduled = new ConcurrentHashMap<>();

    public void syncUnAckedTransactions(String displayName) {

        long s = System.nanoTime();
        List<Transaction> toSend;
        synchronized (this) {
            toSend = new ArrayList<>(getUnAckedTransactions(displayName));
            if(toSend.isEmpty()) {
                transactionSyncScheduled.get(displayName).set(false);
                return;
            }
        }

        BiConsumer<Integer, List<FlipV2>> onSuccess = (userId, flips) -> {
            if(!flips.isEmpty()) {
                copilotLoginManager.addAccountIfMissing(flips.get(0).getAccountId(), displayName, userId);
            }
            flipManager.mergeFlips(flips, userId);
            log.info("sending {} transactions took {}ms", toSend.size(), (System.nanoTime() - s) / 1000_000);
            synchronized (this) {
                List<Transaction> unAckedTransactions  = getUnAckedTransactions(displayName);
                transactionSyncScheduled.get(displayName).set(false);
                toSend.forEach(unAckedTransactions::remove);
                if(!unAckedTransactions.isEmpty()) {
                    scheduleSyncIn(0, displayName);
                }
            }
        };

        Consumer<HttpResponseException> onFailure = (e) -> {
            synchronized (this) {
                transactionSyncScheduled.get(displayName).set(false);
            }
            String currentDisplayName = osrsLoginManager.getPlayerDisplayName();
            if (copilotLoginManager.isLoggedIn() && (currentDisplayName == null || currentDisplayName.equals(displayName))) {
                log.warn("failed to send transactions to copilot server {}", e.getMessage(), e);
                scheduleSyncIn(10, displayName);
            }
        };
        api.sendTransactionsAsync(toSend, displayName, onSuccess, onFailure);
    }

    public long addTransaction(Transaction transaction, String displayName) {
        synchronized (this) {
            List<Transaction> unAckedTransactions = getUnAckedTransactions(displayName);
            unAckedTransactions.add(transaction);
            Persistance.storeUnAckedTransactions(unAckedTransactions, displayName);
        }
        MutableReference<Long> profit = new MutableReference<>(0L);
        if (OfferStatus.SELL.equals(transaction.getType())) {
            Integer accountId = copilotLoginManager.getAccountId(displayName);
            if (accountId != null && accountId != -1) {
                Long p = flipManager.estimateTransactionProfit(accountId, transaction);
                if (p != null) {
                    profit.setValue(p);
                }
            }
        }
        if (copilotLoginManager.isLoggedIn()) {
            scheduleSyncIn(0, displayName);
        }
        return profit.getValue();
    }

    public List<Transaction> getUnAckedTransactions(String displayName) {
        return cachedUnAckedTransactions.computeIfAbsent(displayName, (k) -> Persistance.loadUnAckedTransactions(displayName));
    }

    public synchronized void scheduleSyncIn(int seconds, String displayName) {
        AtomicBoolean scheduled = transactionSyncScheduled.computeIfAbsent(displayName, k -> new AtomicBoolean(false));
        if(scheduled.compareAndSet(false, true)) {
            log.info("scheduling {} attempt to sync {} transactions in {}s", displayName, getUnAckedTransactions(displayName).size(), seconds);
            executorService.schedule(() ->  {
                this.syncUnAckedTransactions(displayName);
            }, seconds, TimeUnit.SECONDS);
        } else {
            log.debug("skipping scheduling sync as already scheduled");
        }
    }
}

package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@AllArgsConstructor
@EqualsAndHashCode
public class ItemIdName {
    public final Integer itemId;
    public final String name;

    public String toString() {
        return name;
    }
}

package com.flippingcopilot.model;

import lombok.Getter;
import lombok.Setter;

import javax.inject.Singleton;
import java.time.Instant;

@Singleton
@Getter
@Setter
public class SuggestionManager {

    private volatile boolean suggestionNeeded;
    private volatile boolean suggestionRequestInProgress;
    private volatile boolean graphDataReadingInProgress;
    private Instant lastFailureAt;
    private HttpResponseException suggestionError;
    private Suggestion suggestion;
    private Instant suggestionReceivedAt;
    private int lastOfferSubmittedTick = -1;

    // these two variables get set based on the current suggestion when the confirm offer button is clicked.
    // this allows us to track on the subsequent offer events whether the offer originates from a copilot suggestion
    // this flag can then eventually be propagated onto each transaction and can be used by the server to
    // determine which items in the inventory were bought based upon copilot suggestions and which are not
    private int suggestionItemIdOnOfferSubmitted = -1;
    private OfferStatus suggestionOfferStatusOnOfferSubmitted = null;


    public volatile int suggestionsDelayedUntil = 0;

    public void setSuggestion(Suggestion suggestion) {
        this.suggestion = suggestion;
        suggestionReceivedAt = Instant.now();

    }

    public void setSuggestionError(HttpResponseException error) {
        this.suggestionError = error;
        lastFailureAt= Instant.now();
    }

    public void reset() {
        suggestionNeeded = false;
        suggestion = null;
        suggestionReceivedAt = null;
        lastFailureAt = null;
        lastOfferSubmittedTick = -1;
        suggestionError = null;
        suggestionItemIdOnOfferSubmitted = -1;
        suggestionOfferStatusOnOfferSubmitted = null;
    }

    public boolean suggestionOutOfDate() {
        Instant tenSecondsAgo = Instant.now().minusSeconds(10L);
        if (suggestionReceivedAt == null || tenSecondsAgo.isAfter(suggestionReceivedAt)) {
            return lastFailureAt == null || tenSecondsAgo.isAfter(lastFailureAt);
        }
        return false;
    }
}

package com.flippingcopilot.model;

import net.runelite.api.*;
import net.runelite.api.ItemID;
import static com.flippingcopilot.util.Constants.PLATINUM_TOKEN_VALUE;

import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Collectors;


public class Inventory extends ArrayList<RSItem> {

    boolean hasSufficientGp(Suggestion suggestion) {
        return !suggestion.getType().equals("buy")
                || getTotalGp() >= (long) suggestion.getPrice() * suggestion.getQuantity();
    }

    boolean hasSufficientItems(Suggestion suggestion) {
        return !suggestion.getType().equals("sell")
                || getTotalAmount(suggestion.getItemId()) >= suggestion.getQuantity();
    }

    public long getTotalGp() {
        return getTotalAmount(ItemID.COINS_995) + PLATINUM_TOKEN_VALUE * getTotalAmount(ItemID.PLATINUM_TOKEN);
    }

    public long getTotalAmount(long itemId) {
        long amount = 0;
        for (RSItem item : this) {
            if (item.getId() == itemId) {
                amount += item.getAmount();
            }
        }
        return amount;
    }


    public static Inventory fromRunelite(ItemContainer inventory, Client client) {
        Inventory unnotedItems = new Inventory();
        Item[] items = inventory.getItems();
        for (Item item : items) {
            if (item.getId() == -1) {
                continue;
            }
            unnotedItems.add(RSItem.getUnnoted(item, client));
        }
        return unnotedItems;
    }

    Map<Integer, Long> getItemAmounts() {
        return stream().collect(Collectors.groupingBy(RSItem::getId,
                        Collectors.summingLong(RSItem::getAmount)));
    }

    public void mergeItem(RSItem i) {
        for(RSItem item : this) {
            if(item.id == i.id) {
                item.amount += i.amount;
                return;
            }
        }
        add(i);
    }

     public boolean missingJustCollected( Map<Integer, Long> inLimboItems) {
         for (Map.Entry<Integer, Long> entry : inLimboItems.entrySet()) {
             Integer itemId = entry.getKey();
             Long qty = entry.getValue();
             if (qty > 0) {
                 long inventoryQty = getTotalAmount(itemId);
                 if (inventoryQty < qty) {
                     return true;
                 }
             }
         }
         return false;
    }
}

package com.flippingcopilot.model;

public enum RiskLevel
{
    LOW,
    MEDIUM,
    HIGH;

    public String toApiValue()
    {
        return name().toLowerCase();
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.util.GeTax;
import lombok.Data;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@Data
public class FlipV2 {

    public static final int RAW_SIZE = 84;

    private UUID id;
    private int accountId;
    private int itemId;
    private int openedTime;
    private int openedQuantity;
    private long spent;
    private int closedTime;
    private int closedQuantity;
    private long receivedPostTax;
    private long profit;
    private long taxPaid;
    private FlipStatus status;
    private int updatedTime;
    private boolean deleted;

    private String cachedItemName;

    public FlipV2 setCachedItemName(String cachedItemName) {
        this.cachedItemName = cachedItemName;
        return this;
    }

    public long calculateProfit(Transaction transaction) {
        long amountToClose = Math.min(openedQuantity - closedQuantity, transaction.getQuantity());
        if(amountToClose <= 0 ){
            return 0;
        }
        long gpOut = (spent * amountToClose) / openedQuantity;
        int sellPrice  = transaction.getAmountSpent() / transaction.getQuantity();
        int sellPricePostTax = GeTax.getPostTaxPrice(transaction.getItemId(), sellPrice);
        long gpIn = amountToClose * sellPricePostTax;
        return gpIn - gpOut;
    }

    public long getAvgBuyPrice() {
        if (spent == 0) {
            return 0;
        }
        return spent / openedQuantity ;
    }

    public long getAvgSellPrice() {
        if (receivedPostTax == 0) {
            return 0;
        }
        return (receivedPostTax  + taxPaid) / closedQuantity;
    }

    public static List<FlipV2> listFromRaw(byte[] raw) {
        if (raw.length < 4) {
            throw new IllegalArgumentException("Raw data must be at least 4 bytes to contain record count");
        }

        ByteBuffer b = ByteBuffer.wrap(raw);
        b.order(ByteOrder.BIG_ENDIAN);

        // Read the number of records (int32)
        int recordCount = b.getInt();
        int expectedSize = 4 + (recordCount * RAW_SIZE);
        if (raw.length != expectedSize) {
            throw new IllegalArgumentException("Raw data size " + raw.length + " doesn't match expected size " + expectedSize + " for " + recordCount + " records");
        }
        List<FlipV2> flips = new ArrayList<>(recordCount);
        for (int i = 0; i < recordCount; i++) {
            byte[] recordBytes = new byte[RAW_SIZE];
            b.get(recordBytes);
            flips.add(fromRaw(recordBytes));
        }

        return flips;
    }

    public static FlipV2 fromRaw(byte[] raw) {
        if (raw.length != RAW_SIZE) {
            throw new IllegalArgumentException("Raw data must be exactly " + RAW_SIZE + " bytes");
        }

        ByteBuffer b = ByteBuffer.wrap(raw);
        b.order(ByteOrder.BIG_ENDIAN);
        FlipV2 flip = new FlipV2();

        // Read UUID (16 bytes)
        long idMostSig = b.getLong();
        long idLeastSig = b.getLong();
        flip.id = new UUID(idMostSig, idLeastSig);

        // Read primitive fields
        flip.accountId = b.getInt();           // 4 bytes
        flip.itemId = b.getInt();              // 4 bytes
        flip.openedTime = b.getInt();          // 4 bytes
        flip.openedQuantity = b.getInt();      // 4 bytes
        flip.spent = b.getLong();              // 8 bytes
        flip.closedTime = b.getInt();          // 4 bytes
        flip.closedQuantity = b.getInt();      // 4 bytes
        flip.receivedPostTax = b.getLong();    // 8 bytes
        flip.profit = b.getLong();             // 8 bytes
        flip.taxPaid = b.getLong();            // 8 bytes

        // Read FlipStatus as int32 ordinal
        int statusOrdinal = b.getInt();        // 4 bytes
        flip.status = FlipStatus.values()[statusOrdinal];

        flip.updatedTime = b.getInt();         // 4 bytes
        flip.deleted = b.getInt() > 0;

        return flip;
    }

    public boolean isClosed() {
        return Objects.equals(status, FlipStatus.FINISHED);
    }

    public int lastTransactionTime() {
        return closedTime == 0 ? openedTime : closedTime;
    }

    public boolean isNewer(FlipV2 o) {
        if (updatedTime == o.updatedTime) {
            return closedQuantity > o.closedQuantity || (closedQuantity == o.closedQuantity && openedQuantity > o.openedQuantity);
        }
        return updatedTime > o.updatedTime;
    }
}
package com.flippingcopilot.model;

import lombok.Data;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;

import java.util.Objects;

@Data
public class SavedOffer
{
	private int itemId;
	private int quantitySold;
	private int totalQuantity;
	private int price;
	private int spent;
	private GrandExchangeOfferState state;
	private boolean copilotPriceUsed;
	private boolean wasCopilotSuggestion;


	public static SavedOffer fromGrandExchangeOffer(GrandExchangeOffer offer) {
		SavedOffer o =  new SavedOffer();
		o.setItemId(offer.getItemId());
		o.setQuantitySold(offer.getQuantitySold());
		o.setTotalQuantity(offer.getTotalQuantity());
		o.setPrice(offer.getPrice());
		o.setSpent(offer.getSpent());
		o.setState(offer.getState());
		return o;
	}

	public OfferStatus getOfferStatus() {
		switch (state) {
			case SELLING:
			case CANCELLED_SELL:
			case SOLD:
				return OfferStatus.SELL;
			case BUYING:
			case CANCELLED_BUY:
			case BOUGHT:
				return OfferStatus.BUY;
			default:
				return OfferStatus.EMPTY;
		}
	}

	public boolean isFreeSlot() {
		switch (state) {
			case CANCELLED_SELL:
			case CANCELLED_BUY:
			case EMPTY:
			case BOUGHT:
			case SOLD:
				return true;
			default:
				return false;
		}
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		SavedOffer that = (SavedOffer) o;
		return itemId == that.itemId && quantitySold == that.quantitySold && totalQuantity == that.totalQuantity && price == that.price && spent == that.spent && state == that.state;
	}

	@Override
	public int hashCode() {
		return Objects.hash(itemId, quantitySold, totalQuantity, price, spent, state, copilotPriceUsed);
	}
}

package com.flippingcopilot.model;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;

@Getter
@AllArgsConstructor
public class RSItem {
    int id;
    long amount;

    static RSItem getUnnoted(Item item, Client client) {
        int itemId = item.getId();
        ItemComposition itemComposition = client.getItemDefinition(itemId);
        if (itemComposition.getNote() != -1) {
            itemId = itemComposition.getLinkedNoteId();
        }
        return new RSItem(itemId, item.getQuantity());
    }
}
package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import net.runelite.api.GrandExchangeOfferState;

public enum OfferStatus {
    @SerializedName("sell")
    SELL,
    @SerializedName("buy")
    BUY,
    @SerializedName("empty")
    EMPTY;

    static OfferStatus fromRunelite(GrandExchangeOfferState state) {
        OfferStatus status;
        switch (state) {
            case SELLING:
            case CANCELLED_SELL:
            case SOLD:
                status = SELL;
                break;
            case BUYING:
            case CANCELLED_BUY:
            case BOUGHT:
                status = BUY;
                break;
            default:
                status = EMPTY;
        }
        return status;
    }
}

package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.List;

@Data
@NoArgsConstructor
public class FlipsDeltaResult {

    public int time;
    public List<FlipV2> flips;

    public static FlipsDeltaResult fromRaw(byte[] raw) {
        FlipsDeltaResult res = new FlipsDeltaResult();
        ByteBuffer b = ByteBuffer.wrap(Arrays.copyOfRange(raw, 0, 4));
        b.order(ByteOrder.BIG_ENDIAN);
        res.time = b.getInt();
        res.flips = FlipV2.listFromRaw(Arrays.copyOfRange(raw, 4, raw.length));
        return res;
    }
}

package com.flippingcopilot.model;

import com.google.gson.JsonObject;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;


@Getter
@AllArgsConstructor
@NoArgsConstructor
@Setter
public class Transaction {

    private UUID id;
    private OfferStatus type;
    private int itemId;
    private int price;
    private int quantity;
    private int boxId;
    private int amountSpent;
    private Instant timestamp;
    private boolean copilotPriceUsed;
    private boolean wasCopilotSuggestion;
    private int offerTotalQuantity;
    private boolean login;
    private boolean consistent;
    private boolean geTransactionAlreadyAdded;

    public boolean equals(Transaction other) {
        return this.type == other.type &&
                this.itemId == other.itemId &&
                this.price == other.price &&
                this.quantity == other.quantity &&
                this.boxId == other.boxId &&
                this.amountSpent == other.amountSpent;
    }

    public JsonObject toJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty("id", id.toString());
        jsonObject.addProperty("item_id", itemId);
        jsonObject.addProperty("price", price);
        jsonObject.addProperty("quantity", type.equals(OfferStatus.BUY) ? quantity : -quantity);
        jsonObject.addProperty("box_id", boxId);
        jsonObject.addProperty("amount_spent", amountSpent);
        jsonObject.addProperty("time", timestamp.getEpochSecond());
        jsonObject.addProperty("copilot_price_used", copilotPriceUsed);
        jsonObject.addProperty("was_copilot_suggestion", wasCopilotSuggestion);
        jsonObject.addProperty("consistent_previous_offer", consistent);
        jsonObject.addProperty("login", login);
        return jsonObject;
    }

    @Override
    public String toString() {
        return String.format("%s %d %d on slot %d", type, quantity, itemId, boxId);
    }
}



package com.flippingcopilot.model;

import com.flippingcopilot.util.MutableReference;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemID;

import java.util.*;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @javax.inject.Inject)
public class GrandExchangeUncollectedManager {

    // dependencies
    private final Client client;

    // stated
    private int lastUncollectedAddedTick = -1;
    private int lastClearedTick = -1;
    private final Map<Integer, Long> lastClearedUncollected = new HashMap<>();
    private final List<Integer> lastClearedSlots = new ArrayList<>();
    // accountId -> [slot -> [itemID -> quantity]]
    private final Map<Long, Map<Integer, Map<Integer, Long>>> uncollected = new HashMap<>();

    public synchronized boolean HasUncollected(Long accountHash) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        MutableReference<Boolean> hasUncollected = new MutableReference<>(false);
        slotToUncollected.forEach((slot, itemToQty) -> {
            itemToQty.forEach((i, q) -> {
                if(q > 0) {
                    log.debug("{} slot {} item {} uncollected {}", accountHash, slot, i, q);
                    hasUncollected.setValue(true);
                }
            });
        });
        return hasUncollected.getValue();
    }

    public synchronized Map<Integer, Long> loadAllUncollected(Long accountHash) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        Map<Integer, Long> itemIdToQuantity = new HashMap<>();
        slotToUncollected.values().forEach(itemIdToQty -> itemIdToQty.forEach((k, v) -> itemIdToQuantity.merge(k, v, Long::sum)));
        return itemIdToQuantity;
    }

    public synchronized Map<Integer, Long> loadSlotUncollected(Long accountHash, Integer slot) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToUncollected.computeIfAbsent(slot, (k) -> new HashMap<>());
    }

    public synchronized void addUncollected(Long accountHash, Integer slot, int itemId, long quantity, long gp) {
        lastUncollectedAddedTick = client.getTickCount();
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        Map<Integer, Long> itemIdToQuantity = slotToUncollected.computeIfAbsent(slot, (k) -> new HashMap<>());
        if (!itemIdToQuantity.containsKey(itemId)) {
           // must be a new offer
           itemIdToQuantity.clear();
        }
        if(quantity > 0) {
            log.debug("tick {} added {} of item {} to uncollected", client.getTickCount(), quantity, itemId);
            itemIdToQuantity.merge(itemId, quantity, Long::sum);
        }
        if (gp > 0) {
            log.debug("tick {} added {} gp to uncollected", client.getTickCount(), gp);
            itemIdToQuantity.merge(ItemID.COINS_995, gp, Long::sum);
        }
    }

    public synchronized void ensureSlotClear(Long accountHash, int slot) {
        Map<Integer, Long> slotUncollected = loadSlotUncollected(accountHash, slot);
        slotUncollected.remove(slot);
    }

    public synchronized void clearSlotUncollected(Long accountHash, int slot) {
        Map<Integer, Long> slotUncollected = loadSlotUncollected(accountHash, slot);
        int tick = client.getTickCount();
        if(tick != lastClearedTick) {
            lastClearedUncollected.clear();
            lastClearedSlots.clear();
            lastClearedTick = tick;
        }
        lastClearedSlots.add(slot);
        slotUncollected.forEach((key, value) -> lastClearedUncollected.merge(key, value, Long::sum));
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        slotToUncollected.remove(slot);
    }

    public synchronized void clearAllUncollected(Long accountHash) {
        log.debug("tick {} clearAllUncollected", client.getTickCount());
        Map<Integer, Long> allUncollected = loadAllUncollected(accountHash);
        int tick = client.getTickCount();
        if(tick != lastClearedTick) {
            lastClearedUncollected.clear();
            lastClearedSlots.clear();
            lastClearedTick = tick;
        }
        lastClearedSlots.addAll(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7));
        allUncollected.forEach((key, value) -> {
            if(value > 0) {
                log.debug("tick {} cleared item {}, qty {}", client.getTickCount(), key, value);
                lastClearedUncollected.merge(key, value, Long::sum);
            }
        });
        uncollected.remove(accountHash);
    }

    public synchronized int getLastClearedTick() {
        return lastClearedTick;
    }

    public synchronized Map<Integer, Long> getLastClearedUncollected() {
        return lastClearedUncollected;
    }

    public synchronized List<Integer> getLastClearedSlots() {
        return lastClearedSlots;
    }

    public synchronized int getLastUncollectedAddedTick() {
        return lastUncollectedAddedTick;
    }

    public synchronized void reset() {
        lastClearedUncollected.clear();
        lastClearedTick = -1;
        lastUncollectedAddedTick = -1;
        uncollected.clear();
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.nio.ByteBuffer;

@Getter
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class VisualizeFlipResponse {

    public int[] buyTimes;
    public int[] buyVolumes;
    public int[] buyPrices;
    public int[] sellTimes;
    public int[] sellVolumes;
    public int[] sellPrices;
    public Data graphData;

    public static VisualizeFlipResponse fromMsgPack(ByteBuffer b) {
        VisualizeFlipResponse ip = new VisualizeFlipResponse();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }
        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "bt":
                    ip.buyTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "bv":
                    ip.buyVolumes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "bp":
                    ip.buyPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "st":
                    ip.sellTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "sv":
                    ip.sellVolumes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "sp":
                    ip.sellPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "gd":
                    ip.graphData = Data.fromMsgPack(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }
        return ip;
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;


@Getter
@Setter
@AllArgsConstructor
@ToString
@NoArgsConstructor
public class PremiumInstanceStatus {
    private String loadingError;
    @SerializedName("premium_instances_count")
    private int premiumInstancesCount;
    @SerializedName("changes_remaining")
    private int changesRemaining;
    @SerializedName("currently_assigned_display_names")
    private List<String> currentlyAssignedDisplayNames;
    @SerializedName("available_display_names")
    private List<String> availableDisplayNames;

    public static PremiumInstanceStatus ErrorInstance(String error) {
        PremiumInstanceStatus pi = new PremiumInstanceStatus();
        pi.setLoadingError(error);
        return pi;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.runelite.api.GrandExchangeOffer;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;


public class StatusOfferList extends ArrayList<Offer> {
    public static final int NUM_SLOTS = 8;
    public static final int NUM_F2P_SLOTS = 3;

    public StatusOfferList() {
        super(NUM_SLOTS);
        for (int i = 0; i < NUM_SLOTS; i++) {
            add(Offer.getEmptyOffer(i));
        }
    }

    public static StatusOfferList fromRunelite(GrandExchangeOffer[] runeliteOffers) {
        StatusOfferList offers = new StatusOfferList();
        for (int i = 0; i < runeliteOffers.length; i++) {
            offers.set(i, Offer.fromRunelite(runeliteOffers[i], i));
        }
        return offers;
    }

    public boolean isEmptySlotNeeded(Suggestion suggestion, boolean isMember) {
        return (suggestion.getType().equals("buy") || suggestion.getType().equals("sell"))
                && !emptySlotExists(isMember);
    }

    boolean emptySlotExists(boolean isMember) {
        return findEmptySlot(isMember) != -1;
    }

    public long getGpOnMarket() {
        return stream().mapToLong(Offer::cashStackGpValue).sum();
    }

    public long getTotalGpToCollect() {
        return stream().mapToLong(Offer::getGpToCollect).sum();
    }

    JsonArray toJson(Gson gson) {
        List<JsonObject> list = stream()
                .map(offer -> offer.toJson(gson))
                .collect(Collectors.toList());
        JsonArray jsonArray = new JsonArray();
        list.forEach(jsonArray::add);
        return jsonArray;
    }

    public int findEmptySlot(boolean isMember) {
        int numUsableSlots = isMember ? NUM_SLOTS : NUM_F2P_SLOTS;
        for (int i = 0; i < numUsableSlots; i++) {
            if (get(i).getStatus() == OfferStatus.EMPTY) {
                return i;
            }
        }
        return -1;
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.nio.ByteBuffer;

@Getter
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class ItemPrice {
    @SerializedName("sell_price")
    private int sellPrice;
    @SerializedName("buy_price")
    private  int buyPrice;
    private  String message;
    @SerializedName("graph_data")
    private Data graphData;

    public static ItemPrice fromMsgPack(ByteBuffer b) {
        ItemPrice ip = new ItemPrice();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }
        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "sp":
                    ip.sellPrice = (int) (long)MsgPackUtil.decodePrimitive(b);
                    break;
                case "bp":
                    ip.buyPrice = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "m":
                    ip.message = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "gd":
                    ip.graphData = Data.fromMsgPack(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }
        return ip;
    }
}

package com.flippingcopilot.model;

import lombok.Data;

@Data
public class AccountSuggestionPreferences {
    public int timeframe = 5;
    public boolean f2pOnlyMode = false;
    public RiskLevel riskLevel = RiskLevel.MEDIUM;
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class LoginResponse {
    public String jwt;

    @SerializedName("user_id")
    public int userId;
}

package com.flippingcopilot.model;

import lombok.Getter;

@Getter
public enum IntervalTimeUnit {

    ALL(-1),
    SESSION(-1),
    HOUR(3600),
    DAY(86400),
    WEEK(604800),
    MONTH(2592000),
    YEAR(31536000);

    private final int seconds;;

    IntervalTimeUnit(int seconds) {
        this.seconds = seconds;
    }

    public static IntervalTimeUnit fromString(String str) {
        switch (str) {
            case "h":
                return IntervalTimeUnit.HOUR;
            case "d":
                return IntervalTimeUnit.DAY;
            case "w":
                return IntervalTimeUnit.WEEK;
            case "m":
                return IntervalTimeUnit.MONTH;
            case "y":
                return IntervalTimeUnit.YEAR;
            default:
                return IntervalTimeUnit.ALL;
        }
    }
}

package com.flippingcopilot.model;

import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.InventoryID;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.List;
import java.util.Map;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class AccountStatusManager {

    // dependencies
    private final Client client;
    private final OsrsLoginManager osrsLoginManager;
    private final GrandExchangeUncollectedManager geUncollected;
    private final SuggestionPreferencesManager suggestionPreferencesManager;
    private final PausedManager pausedManager;

    // state
    @Setter
    private int skipSuggestion = -1;

    public synchronized AccountStatus getAccountStatus() {
        Long accountHash =  osrsLoginManager.getAccountHash();
        ItemContainer itemContainer = client.getItemContainer(InventoryID.INV);
        Inventory inventory;
        if(itemContainer == null) {
            log.warn("Item container was null!");
            inventory = new Inventory();
        } else {
            inventory = Inventory.fromRunelite(itemContainer, client);
        }
        Map<Integer, Long> u = geUncollected.loadAllUncollected(accountHash);

        GrandExchangeOffer[] geOffers = client.getGrandExchangeOffers();
        StatusOfferList offerList = StatusOfferList.fromRunelite(geOffers);

        AccountStatus status = new AccountStatus();
        status.setOffers(offerList);
        status.setInventory(inventory);
        status.setUncollected(u);
        status.setDisplayName(osrsLoginManager.getPlayerDisplayName());
        status.setRsAccountHash(accountHash);
        status.setSkipSuggestion(skipSuggestion);
        status.setSellOnlyMode(suggestionPreferencesManager.isSellOnlyMode());
        status.setF2pOnlyMode(suggestionPreferencesManager.isF2pOnlyMode());
        status.setWorldMember(osrsLoginManager.isMembersWorld());
        status.setAccountMember(osrsLoginManager.isAccountMember());
        status.setSuggestionsPaused(pausedManager.isPaused());
        status.setBlockedItems(suggestionPreferencesManager.blockedItems());
        status.setTimeframe(suggestionPreferencesManager.getTimeframe());
        status.setRiskLevel(suggestionPreferencesManager.getRiskLevel());

        Map<Integer, Long> inLimboItems = geUncollected.getLastClearedUncollected();
        List<Integer> clearedSlots = geUncollected.getLastClearedSlots();
        if (geUncollected.getLastClearedTick() == client.getTickCount()) {
            log.debug("tick {} in limbo items {}, cleared slots {}", client.getTickCount(), inLimboItems, clearedSlots);
            if(inventory.missingJustCollected(inLimboItems)) {
                inLimboItems.forEach((itemId, qty) -> {
                    if (qty > 0) {
                        log.debug("tick {} move in limbo item {}, qty {} to inventory", client.getTickCount(), itemId, qty);
                        inventory.mergeItem(new RSItem(itemId, qty));
                    }
                });
            }
            for (Integer slot : clearedSlots) {
                Offer o = offerList.get(slot);
                GrandExchangeOffer geOffer = geOffers[slot];
                if (!isActive(geOffer.getState()) && geOffer.getState() != GrandExchangeOfferState.EMPTY) {
                    log.debug("tick {} in-activate slot {} just collected setting to EMPTY", client.getTickCount(), slot);
                    o.setStatus(OfferStatus.EMPTY);
                }
            }
        }

        return status;
    }

    private boolean isActive(GrandExchangeOfferState state) {
        switch (state){
            case EMPTY:
            case CANCELLED_BUY:
            case CANCELLED_SELL:
            case BOUGHT:
            case SOLD:
                return false;
            default:
                return true;
        }
    }

    public boolean isSuggestionSkipped() {
        return skipSuggestion != -1;
    }

    public void resetSkipSuggestion() {
        skipSuggestion = -1;
    }

    public void reset() {
        skipSuggestion = -1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;


@Getter
@AllArgsConstructor
@EqualsAndHashCode
public class Offer {

    @Setter
    private OfferStatus status;

    @SerializedName("item_id")
    private int itemId;

    private int price;

    @SerializedName("amount_total")
    private int amountTotal;

    @SerializedName("amount_spent")
    private int amountSpent;

    @SerializedName("amount_traded")
    private int amountTraded;

    @SerializedName("items_to_collect")
    private int itemsToCollect;

    @SerializedName("gp_to_collect")
    private int gpToCollect;

    @SerializedName("box_id")
    private int boxId;

    private boolean active;

    @Setter
    @SerializedName("copilot_price_used")
    private boolean copilotPriceUsed;

    public static Offer getEmptyOffer(int slotId) {
        return new Offer(OfferStatus.EMPTY, 0, 0, 0, 0, 0, 0, 0, slotId, false, false);
    }


    public long cashStackGpValue() {
        if (status == OfferStatus.SELL) {
            return (long) (amountTotal - amountTraded) * price + gpToCollect;
        } else if (status == OfferStatus.BUY){
            // for a buy just take the full amount even if they have collected
            // we assume they won't start selling any collected items until their buy offer is finished
            return (long) amountTotal * price;
        } else {
            return 0;
        }
    }


    public static Offer fromRunelite(GrandExchangeOffer runeliteOffer, int slotId) {
        OfferStatus status = OfferStatus.fromRunelite(runeliteOffer.getState());
        boolean active = runeliteOffer.getState().equals(GrandExchangeOfferState.BUYING)
                || runeliteOffer.getState().equals(GrandExchangeOfferState.SELLING);
        return new Offer(status,
                runeliteOffer.getItemId(),
                runeliteOffer.getPrice(),
                runeliteOffer.getTotalQuantity(),
                runeliteOffer.getSpent(),
                runeliteOffer.getQuantitySold(),
                0,
                0,
                slotId,
                active,
                false);
    }


    JsonObject toJson(Gson gson) {
        JsonParser jsonParser = new JsonParser();
        return jsonParser.parse(gson.toJson(this)).getAsJsonObject();
    }

}

package com.flippingcopilot.model;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class ItemAggregate {
    private final int itemId;
    private final String itemName;
    private final int numberOfFlips;
    private final int totalQuantityFlipped;
    private final long biggestLoss;
    private final long biggestWin;
    private final long totalProfit;
    private final long avgProfit;
    private final long avgProfitEa;
}
package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class Stats {

    public long profit;
    public long gross;
    public long taxPaid;
    public int flipsMade;

    public float calculateRoi() {
        if (gross == 0){
            return 0;
        }
        return (float) (((double) profit) / ((double) gross));
    }

    public Stats copy() {
        return new Stats(profit, gross, taxPaid, flipsMade);
    }

    public void add(Stats s) {
        if(s != null) {
            profit += s.profit;
            gross += s.gross;
            taxPaid += s.taxPaid;
            flipsMade += s.flipsMade;
        }
    }

    public void addFlip(FlipV2 f) {
        profit += f.getProfit();
        gross += f.getSpent();
        taxPaid += f.getTaxPaid();
        flipsMade += 1;
    }

    public void subtractFlip(FlipV2 f) {
        profit -= f.getProfit();
        gross -= f.getSpent();
        taxPaid -= f.getTaxPaid();
        flipsMade -= 1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public class SessionData {

    @SerializedName("start_time")
    public int startTime;

    @SerializedName("duration_millis")
    public long durationMillis;

    @SerializedName("average_cash")
    public long averageCash;
}

package com.flippingcopilot.model;

public enum SortDirection {
    ASC,
    DESC
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.util.Constants;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.time.Instant;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * This class is essentially a cache of user flips that facilitates efficient access to the flips and statistics for
 * any time range and rs account(s) combination. Since after several years a (very) active user could have hundreds of
 * thousands of flips, it would be too slow to filter and re-calculate flips/statistics from scratch every time.
 * A bucketed aggregation strategy is used where we keep pre-computed weekly buckets of statistics and flips. For any
 * time range we can efficiently combine the weekly buckets and only have to re-calculate statistics for the partial
 * weeks on the boundaries of the time range. Have tested the UI experience with >100k flips.
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class FlipManager {

    private static final int WEEK_SECS = 7 * 24 * 60 * 60;

    public static final Comparator<FlipV2> FLIP_STATUS_TIME_COMPARATOR =
                Comparator.comparing(FlipV2::isClosed).reversed().thenComparing(f -> f.getClosedTime() > 0 ? f.getClosedTime() : f.getOpenedTime());
    public static final Comparator<FlipV2> TIME_DESC_COMPARATOR = Comparator.comparing(FlipV2::lastTransactionTime).reversed();

    // dependencies
    private final ItemController itemController;

    @Setter
    private Runnable flipsChangedCallback = () -> {};

    // state
    @Setter
    private volatile int copilotUserId;
    private Integer intervalAccount;
    private int intervalStartTime;
    private Stats intervalStats = new Stats();

    final Map<Integer, Map<Integer, FlipV2>> lastOpenFlipByItemId = new HashMap<>();
    final Map<UUID, Integer> existingCloseTimes = new HashMap<>();
    final List<WeekAggregate> weeks = new ArrayList<>(365*5);


    public synchronized Integer getIntervalAccount() {
        return intervalAccount;
    }

    public synchronized Long estimateTransactionProfit(Integer accountId, Transaction t) {
        if (accountId != null && lastOpenFlipByItemId.containsKey(accountId)) {
            FlipV2 flip = lastOpenFlipByItemId.get(accountId).get(t.getItemId());
            if(flip != null) {
                return flip.calculateProfit(t);
            }
        }
        return null;
    }

    public synchronized FlipV2 getLastFlipByItemId(Integer accountId, int itemId) {
        if (accountId != null && lastOpenFlipByItemId.containsKey(accountId)) {
            Map<Integer, FlipV2> flips = lastOpenFlipByItemId.get(accountId);
            FlipV2 flip = flips.get(itemId);
            if (flip != null) {
                flip.setCachedItemName(itemController.getItemName(flip.getItemId()));
                return flip;
            }
        }
        return null;
    }


    public synchronized boolean mergeFlips(List<FlipV2> flips, int copilotUserId) {
        if (copilotUserId != this.copilotUserId) {
            return false;
        }
        flips.sort(FLIP_STATUS_TIME_COMPARATOR);
        flips.forEach(this::mergeFlip_);
        SwingUtilities.invokeLater(flipsChangedCallback);
        return true;
    }

    public synchronized Stats getIntervalStats() {
        return intervalStats.copy();
    }

    public synchronized Stats calculateStats(int startTime, Integer accountId) {
        if(accountId == null) {
            return calculateStatsAllAccounts(startTime);
        } else {
            return calculateStatsForAccount(startTime, accountId);
        }
    }

    public synchronized void setIntervalAccount(Integer account) {
        if (Objects.equals(account, intervalAccount)) {
            return;
        }
        intervalAccount = account;
        recalculateIntervalStats();
    }

    public synchronized void setIntervalStartTime(int startTime) {
        log.debug("time interval start set to: {}", Instant.ofEpochSecond(startTime));
        if (startTime == intervalStartTime) {
            return;
        }
        intervalStartTime = startTime;
        recalculateIntervalStats();
    }

    private void recalculateIntervalStats() {
        if(intervalAccount == null) {
            intervalStats = calculateStatsAllAccounts(intervalStartTime);
        } else {
            intervalStats = calculateStatsForAccount(intervalStartTime, intervalAccount);
        }
        log.debug("interval flips updated to {}, interval profit updated to {}", intervalStats.flipsMade, intervalStats.profit);
        SwingUtilities.invokeLater(flipsChangedCallback);
    }

    private Stats calculateStatsAllAccounts(int startTime) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfter(startTime, false)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).allStats);
        }
        return stats;
    }

    private Stats calculateStatsForAccount(int startTime, int accountId) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfterForAccount(startTime, accountId)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).accountIdToStats.get(accountId));
        }
        return stats;
    }

    public List<FlipV2> getPageFlips(int page, int pageSize) {
        return getPageFlips(page, pageSize,  intervalStartTime, intervalAccount);
    }

    public synchronized void aggregateFlips(int intervalStartTime, Integer accountId, boolean includeBuyingFlips, Consumer<FlipV2> c) {
        if (Objects.equals(accountId,-1)) {
            return;
        }

        // todo: buying flips also exist in the special Week with closed_time = 0, if arg intervalStartTime <= 0 then we
        //  can end up with duplicates pushed to the consumer because the BUYING flips gets added here and in the later section
        //  this is confusing and can lead to bugs - need to clean this up
        if(includeBuyingFlips) {
            WeekAggregate w = getOrInitWeek(0);
            List<FlipV2> f = accountId == null ? w.flipsAfter(-1, false) : w.flipsAfterForAccount(-1, accountId);
            f.stream().filter(i -> i.getOpenedTime() > intervalStartTime).forEach(c);
        }
        WeekAggregate intervalWeek = getOrInitWeek(intervalStartTime);
        for(int i=weeks.size()-1; i >= intervalWeek.pos; i--) {
            if (weeks.get(i).weekEnd <= intervalStartTime) {
                break;
            }
            WeekAggregate w = weeks.get(i);
            List<FlipV2> weekFlips = accountId == null ? w.flipsAfter(intervalStartTime, true) : w.flipsAfterForAccount(intervalStartTime, accountId);
            int n = weekFlips.size();
            // note: weekFlips are ascending order but we consume in descending order
            for(int ii=n-1; ii >= 0; ii--) {
                FlipV2 f = weekFlips.get(ii);
                c.accept(f);
            }
        }
    }

    public synchronized List<FlipV2> getPageFlips(int page, int pageSize, int intervalStartTime, Integer accountId) {
        if (Objects.equals(accountId,-1)) {
            return new ArrayList<>();
        }

        int toSkip = (page -1) * pageSize;
        WeekAggregate intervalWeek = getOrInitWeek(intervalStartTime);
        List<FlipV2> pageFlips = new ArrayList<>(pageSize == Integer.MAX_VALUE ? 0 : pageSize);
        for(int i=weeks.size()-1; i >= intervalWeek.pos; i--) {
            if (weeks.get(i).weekEnd <= intervalStartTime || pageFlips.size() == pageSize) {
                break;
            }
            WeekAggregate w = weeks.get(i);
            List<FlipV2> weekFlips = accountId == null ? w.flipsAfter(intervalStartTime, true) : w.flipsAfterForAccount(intervalStartTime, accountId);
            int n = weekFlips.size();
            if (n > toSkip) {
                // note: weekFlips are ascending order but we return pages of descending order
                int end = n - toSkip;
                int start = Math.max(0, end - (pageSize - pageFlips.size()));
                for(int ii=end-1; ii >= start; ii--) {
                    pageFlips.add(weekFlips.get(ii));
                }
                toSkip = 0;
            } else {
                toSkip -= n;
            }
        }
        pageFlips.forEach(flip -> flip.setCachedItemName(itemController.getItemName(flip.getItemId())));
        return pageFlips;
    }

    public synchronized void reset() {
        intervalAccount = null;
        intervalStartTime = 0;
        copilotUserId = 0;
        intervalStats = new Stats();
        lastOpenFlipByItemId.clear();
        existingCloseTimes.clear();
        weeks.clear();
    }

    private void mergeFlip_(FlipV2 flip) {
        Integer existingCloseTime = existingCloseTimes.get(flip.getId());

        if(existingCloseTime != null) {
            WeekAggregate wa = getOrInitWeek(existingCloseTime);
            FlipV2 removed = wa.removeFlipIfUpdatedBefore(existingCloseTime, flip);
            if (removed == null) {
                // the flip we are merging is an out of date instance of the same flip
                return;
            }
            if(isInInterval(removed)) {
                intervalStats.subtractFlip(removed);
            }
        }
        if(flip.isDeleted()) {
            existingCloseTimes.remove(flip.getId());
            return;
        }
        WeekAggregate wa = getOrInitWeek(flip.getClosedTime());
        wa.addFlip(flip);
        if(isInInterval(flip)) {
            intervalStats.addFlip(flip);
        }

        if(!flip.getStatus().equals(FlipStatus.FINISHED)) {
            lastOpenFlipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).put(flip.getItemId(), flip);
        } else {
            lastOpenFlipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).remove(flip.getItemId());
        }

        existingCloseTimes.put(flip.getId(), flip.getClosedTime());
    }

    private boolean isInInterval(FlipV2 flip) {
        return flip.getClosedTime() >= intervalStartTime && (intervalAccount == null || flip.getAccountId() == intervalAccount);
    }

    private WeekAggregate getOrInitWeek(int closeTime) {
        int ws = closeTime - (closeTime % WEEK_SECS);
        int i = bisect(weeks.size(), (a) ->  Integer.compare(weeks.get(a).weekStart, ws));
        if (i >= 0){
            WeekAggregate w = weeks.get(i);
            w.pos = i;
            return w;
        }
        WeekAggregate wf = new WeekAggregate();
        wf.weekStart = ws;
        wf.weekEnd = ws + WEEK_SECS;
        wf.pos = -i-1;
        weeks.add(wf.pos, wf);
        return wf;
    }

    public synchronized void deleteAccount(int accountId) {
        for (WeekAggregate week : weeks) {
            week.deleteAccountFlips(accountId);
        }
        if (intervalAccount != null && intervalAccount == accountId) {
            // change the intervalAccount if it is the one being deleted
            intervalAccount = null;
            recalculateIntervalStats();
        } else if (intervalAccount == null) {
            recalculateIntervalStats();
        }
        lastOpenFlipByItemId.remove(accountId);
        SwingUtilities.invokeLater(flipsChangedCallback);
    }

    class WeekAggregate {

        int pos; // note: only correct when returned by getOrInitWeek
        int weekStart;
        int weekEnd;

        Stats allStats = new Stats();
        Map<Integer, Stats> accountIdToStats = new HashMap<>(20);
        Map<Integer, List<FlipV2>> accountIdToFlips = new HashMap<>(20);

        void addFlip(FlipV2 flip) {
            int accountId = flip.getAccountId();
            allStats.addFlip(flip);
            accountIdToStats.computeIfAbsent(accountId, (k) -> new Stats()).addFlip(flip);
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, flip.getId(), flip.getClosedTime()));
            flips.add(-i -1, flip);
        }

        FlipV2 removeFlipIfUpdatedBefore(int existingCloseTime, FlipV2 updatedFlip) {
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(updatedFlip.getAccountId(), (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, updatedFlip.getId(), existingCloseTime));
            FlipV2 flip = flips.get(i);
            // if the existing instance of the flip is updated more recently return null
            if (flip.isNewer(updatedFlip)) {
                return null;
            }
            allStats.subtractFlip(flip);
            flips.remove(i);
            accountIdToStats.get(updatedFlip.getAccountId()).subtractFlip(flip);
            return flip;
        }

        public List<FlipV2> flipsAfterForAccount(int time, int accountId) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            if (time <= weekStart) {
                return flips;
            }
            int cut = -bisect(flips.size(), closedTimeCmp(flips, Constants.MAX_UUID, time)) - 1;
            return flips.subList(cut, flips.size());
        }

        public List<FlipV2> flipsAfter(int time, boolean requireSorted) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> combinedFlips = new ArrayList<>(allStats.flipsMade);
            accountIdToFlips.keySet().forEach(i -> combinedFlips.addAll(flipsAfterForAccount(time, i)));
            if (requireSorted) {
                combinedFlips.sort(Comparator.comparing(FlipV2::getClosedTime).thenComparing(FlipV2::getId));
            }
            return combinedFlips;
        }
        public void deleteAccountFlips(int accountId) {
            accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>()).forEach((FlipV2 f) -> {
                    allStats.subtractFlip(f);
                }
            );
            accountIdToFlips.remove(accountId);
            accountIdToStats.remove(accountId);
        }

        @Override
        public String toString() {
            return String.format("WeekAggregate[start=%s, flips=%d]", Instant.ofEpochSecond(weekStart), allStats.flipsMade);
        }

    }

    private Function<Integer, Integer> closedTimeCmp(List<FlipV2> flips, UUID id, int time) {
        return (a) -> {
            // sorts time ascending with id as tie-breaker
            int c = Integer.compare(flips.get(a).getClosedTime(), time);
            return c != 0 ? c : id.compareTo(flips.get(a).getId());
        };
    }

    private int bisect(int size, Function<Integer, Integer> cmpFunc) {
        int high = size -1;
        int low = 0;
        while (low <= high) {
            int mid = (low + high) >>> 1;
            int cmp = cmpFunc.apply(mid);
            if (cmp < 0)
                low = mid + 1;
            else if (cmp > 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found (low = insertion point)
    }
}

package com.flippingcopilot.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumSet;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OsrsLoginManager {

    public static final int GE_LOGIN_BURST_WINDOW = 2; // ticks

    public static String LOGIN_TO_GET_SUGGESTION_MESSAGE = "Log in to the game<br>to get a flip suggestion";
    private static final WorldType[] COPILOT_UNSUPPORTED_WORLDS = {WorldType.BETA_WORLD,
            WorldType.DEADMAN,
            WorldType.FRESH_START_WORLD,
            WorldType.NOSAVE_MODE,
            WorldType.PVP_ARENA,
            WorldType.SEASONAL,
            WorldType.QUEST_SPEEDRUNNING,
            WorldType.TOURNAMENT_WORLD};

    private final Client client;

    private String cachedDisplayName;
    private long lastAccountHash;

    @Getter
    @Setter
    private int lastLoginTick;

    private boolean lastIsIronman = false;

    public boolean isMembersWorld() {
        return client.getWorldType().contains(WorldType.MEMBERS);
    }

    public boolean isAccountMember()
    {
        int daysLeft = client.getVarpValue(VarPlayer.MEMBERSHIP_DAYS);
        return daysLeft > 0;
    }

    public boolean isValidLoginState() {
        return getInvalidStateDisplayMessage() == null;
    }

    public String getInvalidStateDisplayMessage() {
        if (client.getGameState() != GameState.LOGGED_IN || getPlayerDisplayName() == null) {
            return LOGIN_TO_GET_SUGGESTION_MESSAGE;
        }

        EnumSet<WorldType> worldTypes  =  client.getWorldType();

        for (WorldType worldType : COPILOT_UNSUPPORTED_WORLDS) {
            if (worldTypes.contains(worldType)) {
                return worldType + " worlds<br>are not supported";
            }
        }
        if(client.isClientThread()) {
            lastIsIronman = client.getVarbitValue(Varbits.ACCOUNT_TYPE) != 0;
        }
        if (lastIsIronman) {
            return "Ironman accounts<br>are not supported";
        }
        return null;
    }

    // todo: inline this method
    public Long getAccountHash() {
        return client.getAccountHash();
    }

    public String getPlayerDisplayName() {
        long accountHash = client.getAccountHash();
        if(lastAccountHash == accountHash && cachedDisplayName != null) {
            return cachedDisplayName;
        }
        final Player player = client.getLocalPlayer();
        if (player != null) {
            final String name = player.getName();
            if (name != null && !name.isEmpty()) {
                lastAccountHash = accountHash;
                cachedDisplayName = name;
                return name;
            }
        }
        return null;
    }

    public String getLastDisplayName() {
        return cachedDisplayName != null ? cachedDisplayName : getPlayerDisplayName();
    }

    public void reset() {

    }

    public boolean hasJustLoggedIn() {
        return client.getTickCount() <= lastLoginTick + GE_LOGIN_BURST_WINDOW;
    }
}

package com.flippingcopilot.model;
import lombok.*;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@ToString
public class AckedTransaction {

    public static final int RAW_SIZE = 56;

    private UUID id;
    private UUID clientFlipId;
    private int accountId;
    private int time;
    private int itemId;
    private int quantity;
    private int price;
    private int amountSpent;

    public static List<AckedTransaction> listFromRaw(byte[] raw) {
        if (raw.length < 4) {
            throw new IllegalArgumentException("Raw data must be at least 4 bytes to contain record count");
        }

        ByteBuffer b = ByteBuffer.wrap(raw);
        b.order(ByteOrder.BIG_ENDIAN);

        // Read the number of records (int32)
        int recordCount = b.getInt();
        int expectedSize = 4 + (recordCount * RAW_SIZE);
        if (raw.length != expectedSize) {
            throw new IllegalArgumentException("Raw data size " + raw.length + " doesn't match expected size " + expectedSize + " for " + recordCount + " records");
        }
        List<AckedTransaction> txs = new ArrayList<>(recordCount);
        for (int i = 0; i < recordCount; i++) {
            byte[] recordBytes = new byte[RAW_SIZE];
            b.get(recordBytes);
            txs.add(fromRaw(recordBytes));
        }
        return txs;
    }
    
    public static AckedTransaction fromRaw(byte[] raw) {
        if (raw.length != RAW_SIZE) {
            throw new IllegalArgumentException("Raw data must be exactly " + RAW_SIZE + " bytes");
        }

        ByteBuffer b = ByteBuffer.wrap(raw);
        b.order(ByteOrder.BIG_ENDIAN);
        AckedTransaction transaction = new AckedTransaction();

        long idMostSig = b.getLong();
        long idLeastSig = b.getLong();
        transaction.id = new UUID(idMostSig, idLeastSig);
        long clientFlipIdMostSig = b.getLong();
        long clientFlipIdLeastSig = b.getLong();
        transaction.clientFlipId = new UUID(clientFlipIdMostSig, clientFlipIdLeastSig);
        transaction.accountId = b.getInt();
        transaction.time = b.getInt();
        transaction.itemId = b.getInt();
        transaction.quantity = b.getInt();
        transaction.price = b.getInt();
        transaction.amountSpent = b.getInt();
        return transaction;
    }

    public byte[] toRaw() {
        ByteBuffer b = ByteBuffer.allocate(RAW_SIZE);
        b.order(ByteOrder.BIG_ENDIAN);
        b.putLong(id.getMostSignificantBits());
        b.putLong(id.getLeastSignificantBits());
        b.putLong(clientFlipId.getMostSignificantBits());
        b.putLong(clientFlipId.getLeastSignificantBits());
        b.putInt(accountId);
        b.putInt(time);
        b.putInt(itemId);
        b.putInt(quantity);
        b.putInt(price);
        b.putInt(amountSpent);
        return b.array();
    }
}
package com.flippingcopilot.model;

import lombok.Data;

@Data
public class DiscordWebhookBody {
    private String content;
    private Embed embed;

    @Data
    static class Embed {
        final UrlEmbed image;
    }

    @Data
    static class UrlEmbed {
        final String url;
    }
}
package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OfferManager {

    private static final String OFFER_FILE_TEMPLATE = "acc_%d_%d.json";

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    @Getter
    @Setter
    private int lastViewedSlotItemId = -1;
    @Getter
    @Setter
    private int lastViewedSlotItemPrice = -1;
    @Getter
    @Setter
    private int lastViewedSlotPriceTime = 0;
    @Getter
    @Setter
    private int viewedSlotItemId = -1;
    @Getter
    @Setter
    private int viewedSlotItemPrice = -1;
    @Getter
    @Setter
    boolean offerJustPlaced = false;

    private final Map<Long, Map<Integer, SavedOffer>> cachedOffers = new HashMap<>();
    private final Map<Long, Map<Integer, File>> files = new HashMap<>();
    private final Map<Long, Map<Integer, SavedOffer>> lastSaved = new HashMap<>();

    public synchronized SavedOffer loadOffer(Long accountHash, Integer slot) {
        Map<Integer, SavedOffer> slotToOffer = cachedOffers.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToOffer.computeIfAbsent(slot, (k) -> {
            File file = getFile(accountHash, k);
            try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                return gson.fromJson(reader, SavedOffer.class);
            } catch (FileNotFoundException ignored) {
                return null;
            } catch (JsonSyntaxException | JsonIOException | IOException e) {
                log.warn("error loading saved offer json file {}", file, e);
                return null;
            }
        });
    }

    public synchronized void saveOffer(Long accountHash, Integer slot, SavedOffer offer) {
        Map<Integer, SavedOffer> slotToOffer = cachedOffers.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        slotToOffer.put(slot, offer);
        saveAsync(accountHash, slot);
    }

    private void saveAsync(Long accountHash, Integer slot) {
        executorService.submit(() -> save(accountHash, slot));
    }

    public synchronized void saveAll() {
        for(Long accountHash: cachedOffers.keySet()) {
            for(Integer slot: cachedOffers.get(accountHash).keySet()) {
                save(accountHash, slot);
            }
        }
    }

    private void save(Long accountHash, Integer slot) {
        File file = getFile(accountHash,slot);
        synchronized (file) {
            SavedOffer offer = loadOffer(accountHash, slot);
            Map<Integer, SavedOffer> slotToLastSaved = lastSaved.computeIfAbsent(accountHash, (k)->new HashMap<>());
            SavedOffer lastSaved = slotToLastSaved.get(slot);
            if(!Objects.equals(offer, lastSaved)) {
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(offer);
                    writer.write(json);
                    writer.newLine();
                    slotToLastSaved.put(slot, offer);
                } catch (IOException e) {
                    log.warn("error saving offer json file {}", file, e);
                    slotToLastSaved.put(slot, null);
                }
            }
        }
    }


    private File getFile(Long accountHash, Integer slot) {
        Map<Integer, File> slotToFile = files.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToFile.computeIfAbsent(slot, (k) -> new File(Persistance.COPILOT_DIR, String.format(OFFER_FILE_TEMPLATE, accountHash, slot)));
    }
}

package com.flippingcopilot.model;

import lombok.Builder;
import lombok.Data;


@Data
@Builder
public class AccountAggregate {
    private int accountId;
    private String accountName;
    private int numberOfFlips;
    private long biggestLoss;
    private long biggestWin;
    private long totalProfit;
}
package com.flippingcopilot.model;


import com.flippingcopilot.controller.Persistance;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PausedManager {

    private static final String PAUSED_FILE_TEMPLATE = "acc_%d_paused.json";

    // dependencies
    private final OsrsLoginManager osrsLoginManager;
    private final ScheduledExecutorService executorService;

    // state
    private final Map<Long, Boolean> cachedPaused = new HashMap<>();
    private final Map<Long, File> accountHashToFile = new HashMap<>();

    public synchronized boolean isPaused() {
        Long accountHash = osrsLoginManager.getAccountHash();
        return cachedPaused.computeIfAbsent(accountHash, (k) -> {
            File file = getFile(k);
            try {
                String text = Files.readString(file.toPath(), StandardCharsets.UTF_8);
                return text.contains("true");
            } catch (NoSuchFileException e ){
                return false;
            } catch (JsonSyntaxException | JsonIOException | IOException e) {
                log.warn("error loading stored paused state file {}", file, e);
                return false;
            }
        });
    }

    public synchronized void setPaused(boolean isPaused) {
        Long accountHash = osrsLoginManager.getAccountHash();
        cachedPaused.put(accountHash, isPaused);
        saveAsync(accountHash);
    }

    private void saveAsync(Long accountHash) {
        executorService.submit(() -> {
            File file = getFile(accountHash);
            synchronized (file) {
                boolean isPaused = cachedPaused.getOrDefault(accountHash, false);
                String text = isPaused ? "{\"isPaused\":true}" : "{\"isPaused\":false}";
                try {
                    Files.write(file.toPath(), text.getBytes());
                } catch (IOException e) {
                    log.warn("error storing paused.json file {}", file, e);
                }
            }
        });
    }

    private File getFile(Long accountHash) {
        return accountHashToFile.computeIfAbsent(accountHash,
                (k) -> new File(Persistance.COPILOT_DIR, String.format(PAUSED_FILE_TEMPLATE, accountHash)));
    }
}
package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.Map;

@AllArgsConstructor
@Data
public class DataDeltaRequest {

    @SerializedName("account_id_time")
    private final Map<Integer, Integer> accountIdTime;

}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.SuggestionController;
import com.flippingcopilot.model.PausedManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Singleton
public class PauseButton extends JButton {

    private final PausedManager pausedManager;

    private static final ImageIcon PLAY_ICON;
    private static final ImageIcon PAUSE_ICON;
    private static final ImageIcon PLAY_ICON_HOVER;
    private static final ImageIcon PAUSE_ICON_HOVER;

    static {
        var play = ImageUtil.loadImageResource(PauseButton.class, "/play.png");
        var pause = ImageUtil.loadImageResource(PauseButton.class, "/pause.png");
        PLAY_ICON = new ImageIcon(play);
        PAUSE_ICON = new ImageIcon(pause);
        PLAY_ICON_HOVER =  new ImageIcon(ImageUtil.luminanceScale(play, BUTTON_HOVER_LUMINANCE));
        PAUSE_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(pause, BUTTON_HOVER_LUMINANCE));
    }

    @Inject
    public PauseButton(PausedManager pausedManager,
                       SuggestionController suggestionController) {
        super(PAUSE_ICON);
        this.pausedManager = pausedManager;
        setToolTipText("Pause suggestions");
        addActionListener(e -> {
            suggestionController.togglePause();
            update();
        });

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(pausedManager.isPaused() ? PLAY_ICON_HOVER : PAUSE_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(pausedManager.isPaused() ? PLAY_ICON : PAUSE_ICON);
            }
        });

        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);
    }

    private void update() {
        boolean isPaused = pausedManager.isPaused();
        setIcon(isPaused ? PLAY_ICON : PAUSE_ICON);
        setToolTipText(isPaused ? "Unpause suggestions" :  "Pause suggestions");
    }
}

package com.flippingcopilot.ui;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;

@Singleton
public class CopilotPanel extends JPanel {

    public final SuggestionPanel suggestionPanel;
    public final StatsPanelV2 statsPanel;
    public final ControlPanel controlPanel;

    @Inject
    public CopilotPanel(SuggestionPanel suggestionPanel,
                        StatsPanelV2 statsPanel,
                        ControlPanel controlPanel) {
        this.statsPanel = statsPanel;
        this.suggestionPanel = suggestionPanel;
        this.controlPanel = controlPanel;

        setLayout(new BorderLayout());

        JPanel topPanel = new JPanel();
        topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
        topPanel.add(suggestionPanel);
        topPanel.add(Box.createRigidArea(new Dimension(MainPanel.CONTENT_WIDTH, 5)));
        topPanel.add(controlPanel);
        topPanel.add(Box.createRigidArea(new Dimension(MainPanel.CONTENT_WIDTH, 5)));

        add(topPanel, BorderLayout.NORTH);
        add(statsPanel, BorderLayout.CENTER);
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        suggestionPanel.refresh();
        controlPanel.refresh();
    }
}

/* Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * Copyright (c) 2024, Cillian Brewitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;

import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class WidgetHighlightOverlay extends Overlay
{
    private final Widget widget;
    private final Color color;
    private final Rectangle relativeBounds;

    public WidgetHighlightOverlay(final Widget widget, Color color, Rectangle relativeBounds)
    {
        this.widget = widget;
        this.color = color;
        this.relativeBounds = relativeBounds;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (widget == null)
        {
            return null;
        }

        Rectangle highlightBounds = widget.getBounds();

        if (highlightBounds == null)
        {
            return null;
        }

        highlightBounds.x += relativeBounds.x;
        highlightBounds.y += relativeBounds.y;
        highlightBounds.width = relativeBounds.width;
        highlightBounds.height = relativeBounds.height;

        drawHighlight(graphics, highlightBounds);
        return null;
    }

    private void drawHighlight(Graphics2D graphics, Rectangle bounds)
    {
        graphics.setColor(color);
        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import net.runelite.client.util.ImageUtil;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
@Singleton
public class BlockButton extends JButton
{
    private final SuggestionManager suggestionManager;
    private final SuggestionPreferencesManager preferencesManager;

    private static final ImageIcon BLOCK_ICON;
    private static final ImageIcon BLOCK_ICON_HOVER;

    static
    {
        var blockImg = ImageUtil.loadImageResource(BlockButton.class, "/block.png");
        BLOCK_ICON = new ImageIcon(blockImg);
        BLOCK_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(blockImg, BUTTON_HOVER_LUMINANCE));
    }

    @Inject
    public BlockButton(SuggestionManager suggestionManager, SuggestionPreferencesManager preferencesManager)
    {
        super(BLOCK_ICON);
        this.suggestionManager = suggestionManager;
        this.preferencesManager = preferencesManager;

        setToolTipText("Block this item");
        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);

        // Click action
        addActionListener(e -> confirmAndBlock());

        // Hover effects
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                setIcon(BLOCK_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                setIcon(BLOCK_ICON);
            }
        });
    }

    private void confirmAndBlock()
    {
        Suggestion s = suggestionManager.getSuggestion();
        if (s == null)
        {
            log.debug("No current suggestion to block.");
            return;
        }

        // Get item name or fallback text
        String itemName = s.getName() != null ? s.getName() : "this item";

        // Show a confirmation dialog
        int choice = JOptionPane.showConfirmDialog(
                this,
                "Do you want to block " + itemName + "?",
                "Confirm Block",
                JOptionPane.YES_NO_OPTION
        );

        // If user clicks YES, proceed with blocking
        if (choice == JOptionPane.YES_OPTION)
        {
            preferencesManager.blockItem(s.getItemId());
            log.debug("Blocked item with ID {} ({})", s.getItemId(), itemName);
            suggestionManager.setSuggestionNeeded(true);
        }
        else
        {
            log.debug("User canceled blocking for {}", itemName);
        }
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.model.AckedTransaction;
import com.flippingcopilot.model.Transaction;
import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.TransactionManager;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
public class GeAddTransactionsDialogPanel extends JPanel {

    private static final String CARD_LOADING = "loading";
    private static final String CARD_CONTENT = "content";
    private static final String CARD_ERROR = "error";

    private final TransactionManager transactionManager;
    private final CardLayout cardLayout;
    private final JPanel cardPanel;
    private JPanel transactionListPanel;
    private final List<TransactionCheckbox> checkboxes;
    private JButton addButton;
    private JButton cancelButton;
    private JLabel successLabel;
    private final JLabel errorCardLabel;
    private final ApiRequestHandler apiRequestHandler;
    private final ItemController itemController;
    private final String displayName;
    private final Runnable onClose;

    private List<AckedTransaction> serverTransactions;
    private List<Transaction> geTransactions;

    public GeAddTransactionsDialogPanel(
            ApiRequestHandler apiRequestHandler,
            ItemController itemController,
            String displayName,
            TransactionManager transactionManager,
            Runnable onClose,
            List<Transaction> geTransactions) {

        this.geTransactions = geTransactions;
        this.apiRequestHandler = apiRequestHandler;
        this.itemController = itemController;
        this.displayName = displayName;
        this.transactionManager = transactionManager;
        this.onClose = onClose;
        this.checkboxes = new ArrayList<>();

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setPreferredSize(new Dimension(500, 400));

        // Setup cards
        cardLayout = new CardLayout();
        cardPanel = new JPanel(cardLayout);
        cardPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.add(createLoadingPanel(), CARD_LOADING);
        cardPanel.add(createContentPanel(), CARD_CONTENT);
        JPanel errorPanel = new JPanel(new GridBagLayout());
        errorPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        errorCardLabel = new JLabel();
        errorCardLabel.setForeground(Color.RED);
        errorCardLabel.setFont(FontManager.getRunescapeBoldFont());
        errorPanel.add(errorCardLabel);
        cardPanel.add(errorPanel, CARD_ERROR);
        add(cardPanel, BorderLayout.CENTER);

        // show initial card
        if (this.geTransactions == null || this.geTransactions.isEmpty()) {
            showError("Failed to extract GE transactions.");
        } else {
            cardLayout.show(cardPanel, CARD_LOADING);
            this.apiRequestHandler.asyncLoadRecentAccountTransactions(
                    this.displayName,
                    (int) (Instant.now().getEpochSecond()),
                    loadedTransactions -> SwingUtilities.invokeLater(() -> {
                        this.serverTransactions = loadedTransactions;
                        markAlreadyAdded(new ArrayList<>(serverTransactions), this.geTransactions);
                        populateTransactionList();
                        cardLayout.show(cardPanel, CARD_CONTENT);
                    }),
                    error -> SwingUtilities.invokeLater(() -> {
                        showError("Error checking server transactions: " + error);
                    })
            );
        }
    }

    private JPanel createLoadingPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(0, 0, 10, 0);
        Spinner spinner = new Spinner();
        spinner.show();
        panel.add(spinner, gbc);
        gbc.gridy = 1;
        JLabel loadingLabel = new JLabel("Checking recent transactions...");
        loadingLabel.setForeground(Color.WHITE);
        loadingLabel.setFont(FontManager.getRunescapeFont());
        panel.add(loadingLabel, gbc);
        return panel;
    }

    private JPanel createContentPanel() {
        JPanel contentPanel = new JPanel(new BorderLayout());
        contentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

        JLabel titleLabel = new JLabel("Select transactions to add:");
        titleLabel.setFont(FontManager.getRunescapeFont());
        titleLabel.setForeground(Color.WHITE);
        headerPanel.add(titleLabel, BorderLayout.NORTH);
        contentPanel.add(headerPanel, BorderLayout.NORTH);

        transactionListPanel = new JPanel();
        transactionListPanel.setLayout(new BoxLayout(transactionListPanel, BoxLayout.Y_AXIS));
        transactionListPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JScrollPane scrollPane = new JScrollPane(transactionListPanel);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);

        JPanel centerPanel = new JPanel(new BorderLayout());
        centerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        centerPanel.add(scrollPane, BorderLayout.CENTER);

        JLabel warningLabel = new JLabel("<html><div style='text-align: left; width: 400px;'>" +
                "Only add transactions not recorded by Copilot. It is your responsibility not to add duplicates." +
                "</div></html>");
        warningLabel.setFont(FontManager.getRunescapeFont());
        warningLabel.setForeground(Color.RED);
        warningLabel.setHorizontalAlignment(SwingConstants.CENTER);
        warningLabel.setBorder(new EmptyBorder(10, 10, 10, 10));
        centerPanel.add(warningLabel, BorderLayout.SOUTH);

        contentPanel.add(centerPanel, BorderLayout.CENTER);

        // Button panel
        contentPanel.add(createButtonPanel(), BorderLayout.SOUTH);

        return contentPanel;
    }

    private JPanel createButtonPanel() {
        JPanel buttonPanel = new JPanel(new BorderLayout());
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        buttonPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        successLabel = new JLabel();
        successLabel.setForeground(Color.GREEN);
        successLabel.setFont(FontManager.getRunescapeFont());
        successLabel.setVisible(false);
        successLabel.setName("successLabel");
        buttonPanel.add(successLabel, BorderLayout.WEST);
        JPanel rightButtonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        rightButtonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cancelButton = new JButton("Cancel");
        cancelButton.setFont(FontManager.getRunescapeFont());
        cancelButton.addActionListener(e -> onClose.run());
        addButton = new JButton("Add Selected");
        addButton.setFont(FontManager.getRunescapeFont());
        addButton.setEnabled(false);
        addButton.addActionListener(e -> handleAddSelected());
        rightButtonPanel.add(cancelButton);
        rightButtonPanel.add(Box.createHorizontalStrut(10));
        rightButtonPanel.add(addButton);
        buttonPanel.add(rightButtonPanel, BorderLayout.EAST);
        return buttonPanel;
    }

    private void handleAddSelected() {
        List<Transaction> selectedTransactions = checkboxes.stream()
                .filter(tc -> tc.checkbox.isSelected())
                .map(tc -> tc.transaction)
                .collect(Collectors.toList());

        selectedTransactions.forEach(transaction -> {
            transactionManager.addTransaction(transaction, displayName);
            transaction.setGeTransactionAlreadyAdded(true);
        });
        successLabel.setText("Transactions queued to server");
        successLabel.setVisible(true);
        populateTransactionList();
    }

    private void showError(String errorMessage) {
        errorCardLabel.setText(errorMessage);
        cardLayout.show(cardPanel, CARD_ERROR);
    }

    private void markAlreadyAdded(List<AckedTransaction> serverTransactions, List<Transaction> geTransactions) {
        log.debug("Checking already added transactions. Server txs: {}, GE txs: {}",
                serverTransactions.size(), geTransactions.size());
        for (Transaction geTransaction : geTransactions) {
            int geQuantity = geTransaction.getType() == OfferStatus.BUY
                    ? geTransaction.getQuantity()
                    : -geTransaction.getQuantity();

            for (int i = 0; i < serverTransactions.size(); i++) {
                AckedTransaction serverTx = serverTransactions.get(i);
                if (serverTx.getItemId() == geTransaction.getItemId() &&
                        serverTx.getQuantity() == geQuantity &&
                        serverTx.getPrice() == geTransaction.getPrice()) {
                    geTransaction.setGeTransactionAlreadyAdded(true);
                    serverTransactions.remove(i);
                    break;
                }
            }
        }
    }

    private void populateTransactionList() {
        transactionListPanel.removeAll();
        checkboxes.clear();
        for (Transaction transaction : geTransactions) {
            if(!transaction.isGeTransactionAlreadyAdded()) {
                TransactionCheckbox checkbox = createTransactionRow(transaction);
                checkboxes.add(checkbox);
                transactionListPanel.add(checkbox.panel);
                transactionListPanel.add(Box.createRigidArea(new Dimension(0, 5)));
            }
        }
        transactionListPanel.revalidate();
        transactionListPanel.repaint();
    }

    private TransactionCheckbox createTransactionRow(Transaction transaction) {
        JPanel rowPanel = new JPanel(new BorderLayout());
        rowPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        rowPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR, 1),
                new EmptyBorder(5, 10, 5, 10)
        ));
        rowPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 60));
        JCheckBox checkbox = new JCheckBox();
        checkbox.setBackground(ColorScheme.DARK_GRAY_COLOR);
        checkbox.addActionListener(e -> updateAddButtonState());
        rowPanel.add(checkbox, BorderLayout.WEST);
        rowPanel.add(createTransactionDetailsPanel(transaction), BorderLayout.CENTER);
        return new TransactionCheckbox(checkbox, rowPanel, transaction);
    }

    private JPanel createTransactionDetailsPanel(Transaction transaction) {
        JPanel detailsPanel = new JPanel(new GridBagLayout());
        detailsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.anchor = GridBagConstraints.WEST;
        gbc.insets = new Insets(2, 10, 2, 10);

        // Item icon
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.gridheight = 2;
        JLabel iconLabel = new JLabel();
        itemController.loadImage(transaction.getItemId(), i -> i.addTo(iconLabel));
        detailsPanel.add(iconLabel, gbc);

        gbc.gridx = 1;
        gbc.gridy = 0;
        gbc.gridheight = 1;
        gbc.weightx = 1.0;
        String itemName = itemController.getItemName(transaction.getItemId());
        JLabel nameLabel = new JLabel(itemName + " x" + transaction.getQuantity());
        nameLabel.setFont(FontManager.getRunescapeBoldFont());
        nameLabel.setForeground(Color.WHITE);
        detailsPanel.add(nameLabel, gbc);

        gbc.gridy = 1;
        String typeText = transaction.getType() == OfferStatus.BUY ? "Bought" : "Sold";
        String priceText = String.format("%s for %,d gp each", typeText, transaction.getPrice());
        JLabel priceLabel = new JLabel(priceText);
        priceLabel.setFont(FontManager.getRunescapeSmallFont());
        priceLabel.setForeground(Color.LIGHT_GRAY);
        detailsPanel.add(priceLabel, gbc);

        return detailsPanel;
    }

    private void updateAddButtonState() {
        boolean anySelected = checkboxes.stream().anyMatch(tc -> tc.checkbox.isSelected());
        addButton.setEnabled(anySelected);
    }

    @AllArgsConstructor
    private static class TransactionCheckbox {
        final JCheckBox checkbox;
        final JPanel panel;
        final Transaction transaction;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.controller.PremiumInstanceController;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.components.ItemSearchMultiSelect;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;

@Slf4j
@Singleton
public class PreferencesPanel extends JPanel {

    private final SuggestionPreferencesManager preferencesManager;
    private final JPanel sellOnlyButton;
    private final PreferencesToggleButton sellOnlyModeToggleButton;
    private final JPanel f2pOnlyButton;
    private final PreferencesToggleButton f2pOnlyModeToggleButton;
    private final ItemSearchMultiSelect blocklistDropdownPanel;
    private final JComboBox<String> profileSelector;
    private final JButton addProfileButton;
    private final JButton deleteProfileButton;

    @Inject
    public PreferencesPanel(
            SuggestionManager suggestionManager,
            SuggestionPreferencesManager preferencesManager,
            PremiumInstanceController premiumInstanceController,
            ItemController itemController) {
        super();
        this.preferencesManager = preferencesManager;

        blocklistDropdownPanel = new ItemSearchMultiSelect(
                () -> new HashSet<>(preferencesManager.blockedItems()),
                itemController::allItemIds,
                itemController::search,
                (bl) -> {
                    preferencesManager.setBlockedItems(bl);
                    suggestionManager.setSuggestionNeeded(true);
                },
                "Item blocklist...",
                SwingUtilities.getWindowAncestor(this));

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));

        JLabel preferencesTitle = new JLabel("Suggestion Settings");
        preferencesTitle.setForeground(Color.WHITE);
        preferencesTitle.setFont(preferencesTitle.getFont().deriveFont(Font.BOLD));
        preferencesTitle.setAlignmentX(Component.CENTER_ALIGNMENT);
        preferencesTitle.setMinimumSize(new Dimension(MainPanel.CONTENT_WIDTH - 30, preferencesTitle.getPreferredSize().height));
        preferencesTitle.setMaximumSize(new Dimension(MainPanel.CONTENT_WIDTH - 30, preferencesTitle.getPreferredSize().height));
        preferencesTitle.setHorizontalAlignment(SwingConstants.CENTER);
        add(preferencesTitle);
        add(Box.createRigidArea(new Dimension(0, 8)));

        // Profile selector panel
        JPanel profilePanel = new JPanel();
        profilePanel.setLayout(new BorderLayout());
        profilePanel.setOpaque(false);
        profilePanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));

        // Panel for dropdown and buttons
        JPanel profileControlPanel = new JPanel();
        profileControlPanel.setLayout(new BoxLayout(profileControlPanel, BoxLayout.X_AXIS));
        profileControlPanel.setOpaque(false);

        // Initialize profile model with default
        profileSelector = new JComboBox<>();
        profileSelector.setPreferredSize(new Dimension(160, 25));
        profileSelector.setMaximumSize(new Dimension(160, 25));
        profileSelector.addActionListener(e -> {
            String selectedProfile = (String) profileSelector.getSelectedItem();
            if (selectedProfile != null && !selectedProfile.equals(preferencesManager.getCurrentProfile())) {
                preferencesManager.setCurrentProfile(selectedProfile);
                refresh();
            }
        });

        // Add button for creating new profiles
        addProfileButton = new JButton("+");
        addProfileButton.setPreferredSize(new Dimension(15, 25));
        addProfileButton.setMaximumSize(new Dimension(15, 25));
        addProfileButton.setToolTipText("Add new profile");
        addProfileButton.addActionListener(e -> {
            String newProfileName = JOptionPane.showInputDialog(
                    SwingUtilities.getWindowAncestor(this),
                    "Enter new profile name (must be valid file name):",
                    "New preferences profile",
                    JOptionPane.PLAIN_MESSAGE);
            if (newProfileName != null && !newProfileName.trim().isEmpty()) {
                newProfileName = newProfileName.trim();
                try {
                    preferencesManager.addProfile(newProfileName);
                    refresh();
                } catch (IOException ex) {
                    log.error("adding new profile: {}", newProfileName, ex);
                    JOptionPane.showMessageDialog(
                            SwingUtilities.getWindowAncestor(this),
                            "Error adding new profile: "+ ex.getMessage(),
                            "Add profile failed",
                            JOptionPane.WARNING_MESSAGE);
                }
            }
        });

        // Delete button for removing custom profiles
        deleteProfileButton = new JButton("-");
        deleteProfileButton.setPreferredSize(new Dimension(15, 25));
        deleteProfileButton.setMaximumSize(new Dimension(15, 25));
        deleteProfileButton.setToolTipText("Delete current profile");
        deleteProfileButton.addActionListener(e -> {
            String selectedProfile = (String) profileSelector.getSelectedItem();
            if (selectedProfile != null) {
                int result = JOptionPane.showConfirmDialog(
                        SwingUtilities.getWindowAncestor(this),
                        "Delete profile '" + selectedProfile + "'?",
                        "Delete Profile",
                        JOptionPane.YES_NO_OPTION,
                        JOptionPane.QUESTION_MESSAGE);
                if (result == JOptionPane.YES_OPTION) {
                    ((DefaultComboBoxModel<String>) profileSelector.getModel()).removeElement(selectedProfile);
                    try {
                        preferencesManager.deleteSelectedProfile();
                        profileSelector.setSelectedItem(preferencesManager.getCurrentProfile());
                    } catch (IOException ex) {
                        log.error("removing profile: {}", selectedProfile, ex);
                        JOptionPane.showMessageDialog(
                                SwingUtilities.getWindowAncestor(this),
                                "Error deleting profile: "+ ex.getMessage(),
                                "Remove profile failed",
                                JOptionPane.WARNING_MESSAGE);
                    }
                    refresh();
                }
            }
        });

        profileControlPanel.add(profileSelector);
        profileControlPanel.add(Box.createRigidArea(new Dimension(5, 0)));
        profileControlPanel.add(addProfileButton);
        profileControlPanel.add(Box.createRigidArea(new Dimension(2, 0)));
        profileControlPanel.add(deleteProfileButton);

        profilePanel.add(profileControlPanel, BorderLayout.LINE_START);
        add(profilePanel);

        // Blocklist dropdown panel
        blocklistDropdownPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createEmptyBorder(5, 0, 5, 0),
                blocklistDropdownPanel.getBorder()));
        add(blocklistDropdownPanel);

        // Sell-only mode toggle
        sellOnlyModeToggleButton = new PreferencesToggleButton("Disable sell-only mode", "Enable sell-only mode");
        sellOnlyButton = new JPanel();
        sellOnlyButton.setLayout(new BorderLayout());
        sellOnlyButton.setOpaque(false);
        add(sellOnlyButton);
        JLabel buttonText = new JLabel("Sell-only mode");
        sellOnlyButton.add(buttonText, BorderLayout.LINE_START);
        sellOnlyButton.add(sellOnlyModeToggleButton, BorderLayout.LINE_END);
        sellOnlyModeToggleButton.addItemListener(i -> {
            preferencesManager.setSellOnlyMode(sellOnlyModeToggleButton.isSelected());
            suggestionManager.setSuggestionNeeded(true);
        });
        add(Box.createRigidArea(new Dimension(0, 3)));

        // F2P-only mode toggle
        f2pOnlyModeToggleButton = new PreferencesToggleButton("Disable F2P-only mode",  "Enable F2P-only mode");
        f2pOnlyButton = new JPanel();
        f2pOnlyButton.setLayout(new BorderLayout());
        f2pOnlyButton.setOpaque(false);
        add(f2pOnlyButton);
        JLabel f2pOnlyButtonText = new JLabel("F2P-only mode");
        f2pOnlyButton.add(f2pOnlyButtonText, BorderLayout.LINE_START);
        f2pOnlyButton.add(f2pOnlyModeToggleButton, BorderLayout.LINE_END);
        f2pOnlyModeToggleButton.addItemListener(i -> {
            preferencesManager.setF2pOnlyMode(f2pOnlyModeToggleButton.isSelected());
            suggestionManager.setSuggestionNeeded(true);
        });

        // Premium instances panel - moved to the bottom
        add(Box.createRigidArea(new Dimension(0, 3)));
        JPanel premiumInstancesPanel = new JPanel();
        premiumInstancesPanel.setLayout(new BorderLayout());
        premiumInstancesPanel.setOpaque(false);
        JLabel premiumInstancesLabel = new JLabel("Premium accounts:");
        JButton manageButton = new JButton("manage");
        manageButton.addActionListener(e -> {
            premiumInstanceController.loadAndOpenPremiumInstanceDialog();
        });
        premiumInstancesPanel.add(premiumInstancesLabel, BorderLayout.LINE_START);
        premiumInstancesPanel.add(manageButton, BorderLayout.LINE_END);
        add(premiumInstancesPanel);
    }


    public void refresh() {
        if (!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        sellOnlyModeToggleButton.setSelected(preferencesManager.isSellOnlyMode());
        f2pOnlyModeToggleButton.setSelected(preferencesManager.isF2pOnlyMode());
        deleteProfileButton.setVisible(!preferencesManager.isDefaultProfileSelected());
        List<String> correctOptions = preferencesManager.getAvailableProfiles();
        DefaultComboBoxModel<String> model = (DefaultComboBoxModel<String>) profileSelector.getModel();
        model.removeAllElements();
        model.addAll(correctOptions);
        model.setSelectedItem(preferencesManager.getCurrentProfile());
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.*;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.IntervalDropdown;
import com.flippingcopilot.ui.flipsdialog.FlipsDialogController;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;


import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.Arrays;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
@Singleton
public class StatsPanelV2 extends JPanel {


    public final BufferedImage TRASH_ICON = ImageUtil.loadImageResource(getClass(), "/trash.png");
    public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
    public final Icon OPEN_ICON = new ImageIcon(ARROW_ICON);
    public final Icon CLOSE_ICON = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(90)));
    public final BufferedImage FLIPS_DIALOG_ICON = ImageUtil.recolorImage(ImageUtil.resizeImage(ImageUtil.loadImageResource(getClass(),"/popout-flips.png"), 20, 20),ColorScheme.LIGHT_GRAY_COLOR);
    public final Icon FLIPS_DIALOG = new ImageIcon(FLIPS_DIALOG_ICON);
    public final Icon HIGHLIGHTED_FLIPS_DIALOG = new ImageIcon(ImageUtil.luminanceScale(FLIPS_DIALOG_ICON, BUTTON_HOVER_LUMINANCE));


    private static final java.util.List<Integer> SESSION_STATS_INDS = Arrays.asList(3,4,5);

    // dependencies
    private final CopilotLoginManager copilotLoginManager;
    private final OsrsLoginManager osrsLoginManager;
    private final FlippingCopilotConfig config;
    private final FlipManager flipManager;
    private final SessionManager sessionManager;
    private final WebHookController webHookController;
    private final ClientThread clientThread;
    private final FlipsDialogController flipsDialogController;

    // state
    private IntervalDropdown intervalDropdown;
    private final AccountDropdown accountDropdown;
    private final JButton sessionResetButton = new JButton("  Reset session ");
    private JPanel profitAndSubInfoPanel;
    private JPanel subInfoPanel;
    private final JPanel flipsPanel = new JPanel();
    private final JLabel totalProfitVal = new JLabel("0 gp");
    private final JLabel roiVal = new JLabel("-0.00%");
    private final JLabel flipsMadeVal = new JLabel("0");
    private final JLabel taxPaidVal = new JLabel("0 gp");
    private final JLabel sessionTimeVal = new JLabel("00:00:00");
    private final JLabel hourlyProfitVal = new JLabel("0 gp/hr");
    private final JLabel avgCashVal = new JLabel("0 gp");
    private final Paginator paginator;
    private final JButton flipsDialogButton = new JButton();

    private volatile boolean lastValidState = false;

    // Modified constructor
    @Inject
    public StatsPanelV2(CopilotLoginManager copilotLoginManager,
                        OsrsLoginManager osrsLoginManager,
                        FlippingCopilotConfig config,
                        FlipManager FlipManager,
                        SessionManager sessionManager,
                        WebHookController webHookController,
                        ClientThread clientThread,
                        FlipsDialogController flipsDialogController,
                        GeHistoryTransactionButton geHistoryTransactionButton) { // Added parameter
        this.copilotLoginManager = copilotLoginManager;
        this.osrsLoginManager = osrsLoginManager;
        this.sessionManager = sessionManager;
        this.webHookController = webHookController;
        this.config = config;
        this.flipManager = FlipManager;
        this.clientThread = clientThread;
        this.flipsDialogController = flipsDialogController;
        setLayout(new BorderLayout());

        setupTimeIntervalDropdown();
        setupProfitAndSubInfoPanel();
        setupSessionResetButton();
        setupFlipsDialogButton();

        flipsPanel.setLayout(new BoxLayout(flipsPanel, BoxLayout.Y_AXIS));
        flipsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        flipsPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

        JScrollPane scrollPane = new JScrollPane(flipsPanel);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        // Create a main panel with vertical layout
        JPanel mainPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel timeIntervalDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        timeIntervalDropdownWrapper.setBorder(BorderFactory.createEmptyBorder()); // No border
        timeIntervalDropdownWrapper.add(intervalDropdown, BorderLayout.CENTER);
        timeIntervalDropdownWrapper.add(sessionResetButton, BorderLayout.EAST);
        timeIntervalDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeIntervalDropdownWrapper.getPreferredSize().height));

        JPanel intervalRsAccountDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        accountDropdown = new AccountDropdown(
                copilotLoginManager::displayNameToAccountIdMap,
                flipManager::setIntervalAccount,
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        intervalRsAccountDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, intervalRsAccountDropdownWrapper.getPreferredSize().height));
        intervalRsAccountDropdownWrapper.add(timeIntervalDropdownWrapper, BorderLayout.NORTH);
        intervalRsAccountDropdownWrapper.add(accountDropdown, BorderLayout.SOUTH);

        mainPanel.add(intervalRsAccountDropdownWrapper);
        mainPanel.add(profitAndSubInfoPanel);
        mainPanel.add(scrollPane);

        add(mainPanel, BorderLayout.CENTER);

        paginator = new Paginator((i) -> refresh(true, lastValidState));

        // Create container for paginator and flips dialog button
        JPanel middleBottomPanel = new JPanel(new BorderLayout());
        middleBottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        middleBottomPanel.add(paginator, BorderLayout.CENTER);
        middleBottomPanel.add(flipsDialogButton, BorderLayout.EAST);

        // Create the very bottom panel for the GE History button
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bottomPanel.add(middleBottomPanel, BorderLayout.NORTH);
        bottomPanel.add(geHistoryTransactionButton, BorderLayout.SOUTH);

        add(bottomPanel, BorderLayout.SOUTH);

        flipManager.setFlipsChangedCallback(() -> refresh(true, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState()));
    }

    private void setupFlipsDialogButton() {
        flipsDialogButton.setIcon(FLIPS_DIALOG);
        flipsDialogButton.setOpaque(true);
        flipsDialogButton.setEnabled(true);
        flipsDialogButton.setFocusable(true);
        flipsDialogButton.setBorder(BorderFactory.createEmptyBorder(0,0,0,5));
        flipsDialogButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        flipsDialogButton.setToolTipText("Open flips dialog");

        flipsDialogButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                flipsDialogController.showFlipsTab();
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                flipsDialogButton.setIcon(HIGHLIGHTED_FLIPS_DIALOG);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                flipsDialogButton.setIcon(FLIPS_DIALOG);
            }
        });
    }

    private void setupSessionResetButton() {
        sessionResetButton.setBorder(BorderFactory.createEmptyBorder());
        sessionResetButton.addActionListener((l) -> {
            final int result = JOptionPane.showOptionDialog(SwingUtilities.getWindowAncestor(this), "<html>Are you sure you want to reset the session?</html>",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");
            if (result == JOptionPane.YES_OPTION) {
                // send discord message before resetting session stats
                clientThread.invoke(() -> {
                    if (osrsLoginManager.isValidLoginState()) {
                        String displayName = osrsLoginManager.getPlayerDisplayName();
                        Integer accountId = copilotLoginManager.getAccountId(displayName);
                        if(accountId != null && accountId != -1) {
                            webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, accountId), sessionManager.getCachedSessionData(), displayName, true);
                            sessionManager.resetSession();
                            if (IntervalTimeUnit.SESSION.equals(intervalDropdown.getSelectedIntervalTimeUnit())) {
                                flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                            }
                        }
                        refresh(true, copilotLoginManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
                    }
                });
            }
        });
    }

    private void setupTimeIntervalDropdown() {
        intervalDropdown = new IntervalDropdown((intervalTimeUnit, intervalValue) -> {
            long startTime = IntervalDropdown.calculateStartTime(intervalTimeUnit, intervalValue, sessionManager.getCachedSessionData().startTime);
            flipManager.setIntervalStartTime((int) startTime);
        }, IntervalDropdown.ALL_TIME, true);
    }

    public void resetIntervalDropdownToSession() {
        intervalDropdown.resetToSession();
    }

    private JPanel buildSubInfoPanelItem(String key, JLabel value, Color valueColor) {
        JPanel item = new JPanel(new BorderLayout());
        item.setBorder(new EmptyBorder(4, 2, 4, 2));
        item.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel keyLabel = new JLabel(key);
        keyLabel.setFont(FontManager.getRunescapeSmallFont());
        item.add(keyLabel, BorderLayout.WEST);
        value.setFont(FontManager.getRunescapeSmallFont());
        value.setForeground(valueColor);
        item.add(value, BorderLayout.EAST);
        item.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));
        return item;
    }

    private JPanel buildSubInfoPanel() {
        JPanel subInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        subInfoPanel.add(buildSubInfoPanelItem("ROI:", roiVal, UIUtilities.TOMATO));
        subInfoPanel.add(buildSubInfoPanelItem("Flips made:", flipsMadeVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Tax paid:", taxPaidVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Session time:", sessionTimeVal, ColorScheme.GRAND_EXCHANGE_ALCH));
        subInfoPanel.add(buildSubInfoPanelItem("Hourly profit:", hourlyProfitVal, Color.WHITE));
        subInfoPanel.add(buildSubInfoPanelItem("Avg wealth:", avgCashVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        subInfoPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(0,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(2, 5, 5, 5)));
        return subInfoPanel;
    }

    private void setupProfitAndSubInfoPanel() {
        profitAndSubInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        profitAndSubInfoPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Create the header panel that can be clicked to expand/collapse sub info
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(5, 0, 5, 0)));

        final JLabel profitTitle = new JLabel("Profit: ");
        profitTitle.setFont(FontManager.getRunescapeBoldFont());

        totalProfitVal.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        totalProfitVal.setFont(FontManager.getRunescapeBoldFont().deriveFont(24f));
        totalProfitVal.setHorizontalAlignment(SwingConstants.CENTER);

        // Use a panel to stack the profitTitle and totalProfitVal vertically
        JPanel profitTextPanel = new JPanel();
        profitTextPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        profitTextPanel.add(profitTitle);
        profitTextPanel.add(Box.createRigidArea(new Dimension(5, 0))); // Spacing between title and value
        profitTextPanel.add(totalProfitVal);
        profitTextPanel.setBorder(BorderFactory.createEmptyBorder(2,4,2,4));

        // Arrow label
        JLabel arrowLabel = new JLabel(OPEN_ICON);
        arrowLabel.setHorizontalAlignment(SwingConstants.CENTER);
        arrowLabel.setVerticalAlignment(SwingConstants.CENTER);
        arrowLabel.setPreferredSize(new Dimension(16, 16)); // Adjust size as needed

        // Add components to headerPanel
        headerPanel.add(profitTextPanel, BorderLayout.CENTER);
        headerPanel.add(arrowLabel, BorderLayout.EAST);

        // Create the sub-info panel
        subInfoPanel = buildSubInfoPanel();

        headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 70));
        profitAndSubInfoPanel.add(headerPanel);
        profitAndSubInfoPanel.add(subInfoPanel);

        // Mouse listener to handle expand/collapse and hover effects
        MouseAdapter headerMouseListener = new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                boolean isExpanded = subInfoPanel.isVisible();
                subInfoPanel.setVisible(!isExpanded);
                arrowLabel.setIcon(isExpanded ? OPEN_ICON : CLOSE_ICON);
                log.debug("profit and sub info panel clicked");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                headerPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                headerPanel.setCursor(Cursor.getDefaultCursor());
            }
        };

        // Add mouse listener to header components
        headerPanel.addMouseListener(headerMouseListener);
        totalProfitVal.addMouseListener(headerMouseListener);
        profitTitle.addMouseListener(headerMouseListener);

    }

    // called when:
    //
    // - time interval drop down changed (Swing EDT thread)
    // - session reset button pressed (Swing EDT thread)
    // - transaction processing downstream (ScheduledExecutorService)
    // - FlipTrackerV2 initialisation (ScheduledExecutorService)
    // - session stats updated (ScheduledExecutorService)
    // - plugin config changed (Client thread)
    // - page changed (Swing EDT thread)
    //

    public void refresh(boolean flipsMaybeChanged, boolean validLoginState) {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(() -> refresh(flipsMaybeChanged, validLoginState));
            return;
        }
        lastValidState = validLoginState;
        if (!validLoginState) {
            totalProfitVal.setText("0 gp");
            roiVal.setText("-0.00%");
            flipsMadeVal.setText("0");
            taxPaidVal.setText("0 gp");
            sessionTimeVal.setText("00:00:00");
            hourlyProfitVal.setText("0 gp/hr");
            avgCashVal.setText("0 gp");
            flipsPanel.removeAll();
            paginator.setTotalPages(1);
            boolean v = IntervalTimeUnit.SESSION.equals(intervalDropdown.getSelectedIntervalTimeUnit());
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(v));
            accountDropdown.setVisible(false);
            return;
        }

        accountDropdown.setSelectedAccountId(flipManager.getIntervalAccount());
        accountDropdown.setVisible(true);
        accountDropdown.refresh();

        SessionData sd = sessionManager.getCachedSessionData();
        Stats stats = flipManager.getIntervalStats();
        paginator.setTotalPages(1 + stats.flipsMade / 50);
        long s = System.nanoTime();
        if (flipsMaybeChanged) {
            flipsPanel.removeAll();
            flipManager.getPageFlips(paginator.getPageNumber(), 50).forEach(f -> flipsPanel.add(new FlipPanel(f, config)));
            // labels displayed to the user
            roiVal.setText(String.format("%.3f%%", stats.calculateRoi() * 100));
            roiVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            flipsMadeVal.setText(String.format("%d", stats.flipsMade));
            taxPaidVal.setText(UIUtilities.formatProfit(stats.taxPaid));
            totalProfitVal.setText(UIUtilities.formatProfit(stats.profit));
            totalProfitVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            log.debug("populating flips took {}ms", (System.nanoTime() - s) / 1000_000);
        }

        // 'Session time', 'Hourly profit' and 'Avg wealth' should only be set if 'Session' is select in the dropdown
        if (IntervalTimeUnit.SESSION.equals(intervalDropdown.getSelectedIntervalTimeUnit())) {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(true));
            long seconds = sd.durationMillis / 1000;
            float hoursFloat = (((float) seconds) / 3600.0f);
            long hourlyProfit = hoursFloat == 0 ? 0 : (long) (stats.profit / hoursFloat);
            String sessionTime = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            sessionTimeVal.setText(sessionTime);
            hourlyProfitVal.setText(UIUtilities.formatProfitWithoutGp(hourlyProfit) + " gp/hr");
            hourlyProfitVal.setForeground(UIUtilities.getProfitColor(hourlyProfit, config));
            avgCashVal.setText(UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp");
        } else {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(false));
        }
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;

public class UIUtilities {
    public static final String redditIcon = "/reddit-icon.png";
    public static final String discordIcon = "/discord.png";
    public static final String githubIcon = "/github.png";
    public static final String logoutIcon = "/logout.png";
    public static final String internetIcon = "/internet.png";
    public static final String graphIcon = "/graph.png";

    public static final float BUTTON_HOVER_LUMINANCE = 0.65f;
    public static final Color OUTDATED_COLOR = new Color(250, 74, 75);
    public static final Color BLUE_HIGHLIGHT_COLOR =  new Color(27, 173, 255, 79);
    public static final Color RED_HIGHLIGHT_COLOR = new Color(255, 20, 20, 79);
    public static final Color TOMATO = new Color(255,99,71);
    public static final Color DARK_GRAY = new Color(27, 27, 27);

    private static final NumberFormat PRECISE_DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.###",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );
    private static final NumberFormat DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.#",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );

    public static synchronized String quantityToRSDecimalStack(long quantity, boolean precise)
    {
        String sign = quantity > 0 ? "" : "-";
        quantity = Math.abs(quantity);
        if (Long.toString(quantity).length() <= 4)
        {
            return QuantityFormatter.formatNumber(quantity);
        }

        long power = (long) Math.log10(quantity);

        // Output thousandths for values above a million
        NumberFormat format = precise && power >= 6
                ? PRECISE_DECIMAL_FORMATTER
                : DECIMAL_FORMATTER;

        return sign+format.format(quantity / Math.pow(10, (Long.divideUnsigned(power, 3)) * 3))
                + new String[] {"", "K", "M", "B", "T"}[(int) (power / 3)];
    }

    public static Color getProfitColor(long profit, FlippingCopilotConfig config) {
        if (profit > 0) {
            return config.profitAmountColor();
        } else if (profit < 0) {
            return config.lossAmountColor();
        } else {
            return Color.WHITE;
        }
    }

    public static String formatProfit(long profit) {
        return quantityToRSDecimalStack(profit, true) + " gp";
    }

    public static String formatProfitWithoutGp(long profit) {
        return quantityToRSDecimalStack(profit, true);
    }

    public static String truncateString(String string, int length) {
        if (string.length() > length) {
            return string.substring(0, length) + "...";
        }
        return string;
    }

    public static JLabel buildButton(BufferedImage icon, String tooltip, Runnable onClick) {
        JLabel label = new JLabel();
        label.setToolTipText(tooltip);
        label.setHorizontalAlignment(JLabel.CENTER);
        ImageIcon iconOff = new ImageIcon(icon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(icon, BUTTON_HOVER_LUMINANCE));
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                try {
                    onClick.run();
                } catch (Exception error) {}
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                label.setCursor(new Cursor(Cursor.HAND_CURSOR));
                label.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setIcon(iconOff);
            }
        });
        label.setIcon(iconOff);
        return label;
    }

    static JLabel buildUriButton(BufferedImage icon, String tooltip, String uriString) {
        return buildButton(icon, tooltip, () -> {
            try {
                Desktop desktop = Desktop.getDesktop();
                URI uri = new URI(uriString);
                desktop.browse(uri);
            } catch (Exception error) {}
        });
    }

    public static JPanel newVerticalBoxLayoutJPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        return panel;
    }
}

package com.flippingcopilot.ui;


import java.awt.Dimension;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JToggleButton;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

class PreferencesToggleButton extends JToggleButton
{
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;
    private final String unSelectedToolTipText;
    private final String selectedToolTipText;


    public PreferencesToggleButton(String selectedToolTipText, String unSelectedToolTipText) {
        super(OFF_SWITCHER);
        setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        setPreferredSize(new Dimension(25, 25));
        addItemListener(l -> updateTooltip());
        updateTooltip();
        this.selectedToolTipText = selectedToolTipText;
        this.unSelectedToolTipText = unSelectedToolTipText;
    }

    static
    {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(CopilotPanel.class, "/switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    private void updateTooltip()
    {
        setToolTipText(isSelected() ? selectedToolTipText :  unSelectedToolTipText);
    }
}

package com.flippingcopilot.ui;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.function.Consumer;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
public class Paginator extends JPanel {

	public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
	public final Icon ARROW_RIGHT = new ImageIcon(ARROW_ICON);
	public final Icon HIGHLIGHTED_ARROW_RIGHT = new ImageIcon(ImageUtil.luminanceScale(ARROW_ICON, BUTTON_HOVER_LUMINANCE));
	public final Icon ARROW_LEFT = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)));
	public final Icon HIGHLIGHTED_ARROW_LEFT = new ImageIcon(ImageUtil.luminanceScale(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)), BUTTON_HOVER_LUMINANCE));

	@Getter
	private int pageNumber = 1;
	@Getter
	private int totalPages = 1;
	private final JLabel statusText = new JLabel("Page 1 of 1", SwingUtilities.CENTER);
	private final JLabel arrowRight= new JLabel(ARROW_RIGHT);
	private final JLabel arrowLeft =  new JLabel(ARROW_LEFT);
	private final Consumer<Integer> onPageChange;

	public Paginator(Consumer<Integer> onPageChange) {
		this.onPageChange = onPageChange;
		this.statusText.setFont(FontManager.getRunescapeFont());
		this.arrowRight.setForeground(Color.blue);
		setLayout(new FlowLayout());
		add(arrowLeft);
		add(statusText);
		add(arrowRight);
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(3, 0, 0, 0));
		arrowLeft.addMouseListener(onDecreasePage());
		arrowRight.addMouseListener(onIncreasePage());
	}

	public void setTotalPages(int totalPages) {
		this.totalPages = totalPages;
		if(pageNumber > this.totalPages) {
			pageNumber = 1;
			onPageChange.accept(pageNumber);
		}
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	public void setTotalPagesWithoutEffect(int totalPages) {
		this.totalPages = totalPages;
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	public void setPageNumber(int pageNumber) {
		this.pageNumber = pageNumber;
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	private MouseAdapter onIncreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber < totalPages) {
					pageNumber++;
					onPageChange.accept(pageNumber);
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowRight.setIcon(HIGHLIGHTED_ARROW_RIGHT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowRight.setIcon(ARROW_RIGHT);
			}
		};
	}

	private MouseAdapter onDecreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber > 1) {
					pageNumber--;
					onPageChange.accept(pageNumber);
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowLeft.setIcon(HIGHLIGHTED_ARROW_LEFT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowLeft.setIcon(ARROW_LEFT);
			}
		};
	}
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.CopilotLoginController;
import com.flippingcopilot.manager.CopilotLoginManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;

import static com.flippingcopilot.ui.UIUtilities.buildButton;

@Singleton
@Slf4j
public class MainPanel extends PluginPanel {

    public static final int CONTENT_WIDTH = 242 - 12;

    // dependencies
    public final LoginPanel loginPanel;
    public final CopilotPanel copilotPanel;
    private final CopilotLoginManager copilotLoginManager;
    private final CopilotLoginController copilotLoginController;

    // UI components
    private final CardLayout cardLayout = new CardLayout();

    @Inject
    public MainPanel(CopilotPanel copilotPanel,
                     LoginPanel loginPanel,
                     CopilotLoginManager copilotLoginManager,
                     CopilotLoginController copilotLoginController) {
        super(false);
        this.copilotLoginManager = copilotLoginManager;
        this.copilotPanel = copilotPanel;
        this.loginPanel = loginPanel;
        this.copilotLoginController = copilotLoginController;

        setLayout(cardLayout);
        setBorder(BorderFactory.createEmptyBorder(5, 6, 5, 6));
        add(buildLoggedInView(), "logged-in");
        add(buildLoggedOutView(), "logged-out");
        cardLayout.show(this, copilotLoginManager.isLoggedIn() ? "logged-in" : "logged-out");

    }

    private JPanel buildLoggedOutView() {
        JPanel wrapper = new JPanel();
        wrapper.setLayout(new BorderLayout());
        JPanel topBar = constructTopBar(false);
        wrapper.add(topBar, BorderLayout.NORTH);
        wrapper.add(loginPanel, BorderLayout.CENTER);
        return wrapper;
    }

    private JPanel buildLoggedInView() {
        JPanel wrapper = new JPanel();
        wrapper.setLayout(new BorderLayout());
        JPanel topBar = constructTopBar(true);
        wrapper.add(topBar, BorderLayout.NORTH);
        wrapper.add(copilotPanel, BorderLayout.CENTER);
        return wrapper;
    }



    public void refresh() {
        if (!SwingUtilities.isEventDispatchThread()) {
            // Always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        if (copilotLoginManager.isLoggedIn()) {
            showLoggedInView();
            copilotPanel.refresh();
        } else {
            showLoggedOutView();
            loginPanel.refresh();
            copilotPanel.suggestionPanel.refresh();
        }
    }

    private void showLoggedOutView() {
        loginPanel.showLoginErrorMessage("");
        cardLayout.show(this, "logged-out");
        revalidate();
        repaint();
    }

    private void showLoggedInView() {
        cardLayout.show(this, "logged-in");
        revalidate();
        repaint();
    }

    private JPanel constructTopBar(boolean isLoggedIn) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setLayout(new BorderLayout());

        JPanel topBar = new JPanel();
        topBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int columns = isLoggedIn ? 4 : 3;
        topBar.setLayout(new GridLayout(1, columns));

        JLabel reddit = buildTopBarUriButton(UIUtilities.redditIcon,
                "Flipping Copilot reddit",
                "https://www.reddit.com/r/FlippingCopilot/");
        topBar.add(reddit);

        JLabel discord = buildTopBarUriButton(UIUtilities.discordIcon,
                "Flipping Copilot Discord",
                "https://discord.gg/UyQxA4QJAq");
        topBar.add(discord);

        JLabel website = buildTopBarUriButton(UIUtilities.internetIcon,
                "Flipping Copilot website",
                "https://flippingcopilot.com");
        topBar.add(website);


        if (isLoggedIn) {
            BufferedImage icon = ImageUtil.loadImageResource(getClass(), UIUtilities.logoutIcon);
            JLabel logout = buildButton(icon, "Log out", () -> {
                copilotLoginController.onLogout();
                showLoggedOutView();
            });
            topBar.add(logout);
        }

        container.add(topBar);
        container.setBorder(new EmptyBorder(3, 0, 10, 0));
        return container;
    }

    private JLabel buildTopBarUriButton(String iconPath, String tooltip, String uriString) {
        BufferedImage icon = ImageUtil.loadImageResource(getClass(), iconPath);
        return buildButton(icon, tooltip, () -> {
            LinkBrowser.browse(uriString);
        });
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.GrandExchange;
import com.flippingcopilot.controller.OfferHandler;
import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.Suggestion;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.widgets.*;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class OfferEditor {
    private final OfferManager offerManager;
    private final OfferHandler offerHandler;
    private final Client client;

    private Widget text;
    private Widget priceGraphText;
    private static final int MOUSE_OFF_TEXT_COLOR = 0x0040FF;
    private static final int MOUSE_OFF_ERROR_TEXT_COLOR = 0xAA2222;

    public OfferEditor(OfferManager offerManager, Widget parent, OfferHandler offerHandler, Client client) {
        this.offerManager = offerManager;
        this.offerHandler = offerHandler;
        this.client = client;
        if (parent == null) {
            return;
        }

        text = parent.createChild(-1, WidgetType.TEXT);
        prepareTextWidget(text, WidgetTextAlignment.LEFT, WidgetPositionMode.ABSOLUTE_TOP, 40, 10);
    }

    private void prepareTextWidget(Widget widget, int xAlignment, int yMode, int yOffset, int xOffset) {
        widget.setTextColor(MOUSE_OFF_TEXT_COLOR);
        widget.setFontId(FontID.VERDANA_11_BOLD);
        widget.setYPositionMode(yMode);
        widget.setOriginalX(xOffset);
        widget.setOriginalY(yOffset);
        widget.setOriginalHeight(20);
        widget.setXTextAlignment(xAlignment);
        widget.setWidthMode(WidgetSizeMode.MINUS);
        widget.revalidate();
    }

    public void showSuggestion(Suggestion suggestion) {
        var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);
        if (offerHandler.isSettingQuantity()) {
            if (currentItemId != suggestion.getItemId()) {
                return;
            }
            if (!suggestion.getType().equals(offerHandler.getOfferType())) {
                return;
            }

            shiftChatboxWidgetsDown();
            showQuantity(suggestion.getQuantity());
        } else if (offerHandler.isSettingPrice()) {
            if (currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(offerHandler.getOfferType())) {
                int price = offerManager.getViewedSlotItemPrice();
                if (offerHandler.getViewedSlotPriceErrorText() != null && price <= 0) {
                    shiftChatboxWidgetsDown();
                    setErrorText(offerHandler.getViewedSlotPriceErrorText());
                    return;
                }

                if (offerManager.getViewedSlotItemId() == currentItemId) {
                    shiftChatboxWidgetsDown();
                    if (offerHandler.getViewedSlotPriceErrorText() != null) {
                        showPriceWithWarning(price, offerHandler.getViewedSlotPriceErrorText());
                    } else {
                        showPrice(price);
                    }
                }
            } else {
                shiftChatboxWidgetsDown();
                showPrice(suggestion.getPrice());
            }
        }
    }

    private void showQuantity(int quantity) {
        text.setText("set to Copilot quantity: " + quantity);
        text.setAction(1, "Set quantity");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(quantity);
        });
    }

    public void showPrice(int price) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp");
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(price);
        });
    }

    private void showPriceWithWarning(int price, String warning) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp. " + warning);
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(price);
        });
    }

    private void setHoverListeners(Widget widget) {
        widget.setHasListener(true);
        widget.setOnMouseRepeatListener((JavaScriptCallback) ev -> widget.setTextColor(0xFFFFFF));
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> widget.setTextColor(MOUSE_OFF_TEXT_COLOR));
    }

    private void setErrorText(String message) {
        text.setText(message);
        text.setTextColor(MOUSE_OFF_ERROR_TEXT_COLOR);
        text.revalidate();
    }

    private void shiftChatboxWidgetsDown() {
        Widget chatboxTitle = client.getWidget(ComponentID.CHATBOX_TITLE);
        if (chatboxTitle != null) {
            chatboxTitle.setOriginalY(chatboxTitle.getOriginalY() + 7);
            chatboxTitle.revalidate();
        }
    }
}

package com.flippingcopilot.ui;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

@Getter
public class Spinner extends JPanel {
    private final JLabel spinnerLabel = new JLabel();

    public Spinner() {
        setLayout(new GridBagLayout());
        setOpaque(false);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = GridBagConstraints.REMAINDER;
        gbc.gridy = GridBagConstraints.REMAINDER;
        gbc.weightx = 1;
        gbc.weighty = 1;
        gbc.anchor = GridBagConstraints.CENTER;

        spinnerLabel.setPreferredSize(new Dimension(30, 30));
        add(spinnerLabel, gbc);
        setUpIcon();
        hide();
    }

    public void show() {
        spinnerLabel.setVisible(true);
    }

    public void hide() {
        spinnerLabel.setVisible(false);
    }

    private void setUpIcon() {
        IconTextField.Icon icon = IconTextField.Icon.LOADING;
        final ImageIcon imageIcon = new ImageIcon(Objects.requireNonNull(IconTextField.class.getResource(icon.getFile())));
        spinnerLabel.setIcon(imageIcon);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.GrandExchange;
import com.flippingcopilot.controller.HighlightController;
import com.flippingcopilot.controller.PremiumInstanceController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.flipsdialog.FlipsDialogController;
import joptsimple.internal.Strings;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;

import static com.flippingcopilot.ui.UIUtilities.*;
import static com.flippingcopilot.util.Constants.MIN_GP_NEEDED_TO_FLIP;


@Singleton
@Slf4j
public class SuggestionPanel extends JPanel {

    // dependencies
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final AccountStatusManager accountStatusManager;
    public final PauseButton pauseButton;
    private final BlockButton blockButton;
    private final OsrsLoginManager osrsLoginManager;
    private final Client client;
    private final PausedManager pausedManager;
    private final GrandExchangeUncollectedManager uncollectedManager;
    private final ClientThread clientThread;
    private final HighlightController highlightController;
    private final ItemManager itemManager;
    private final GrandExchange grandExchange;
    private final PremiumInstanceController premiumInstanceController;
    private final FlipManager flipManager;
    private final CopilotLoginManager copilotLoginManager;
    private final FlipsDialogController flipsDialogController;


    private final JLabel suggestionText = new JLabel();
    private final JLabel suggestionIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png")));
    private final JPanel suggestionTextContainer = new JPanel();
    private final JLabel additionalInfoText = new JLabel();
    public final Spinner spinner = new Spinner();
    private JLabel skipButton;
    private final JPanel buttonContainer = new JPanel();
    private JLabel graphButton;
    private final JPanel suggestedActionPanel;
    private final PreferencesPanel preferencesPanel;
    private final JLayeredPane layeredPane = new JLayeredPane();
    private boolean isPreferencesPanelVisible = false;
    private final JLabel gearButton;
    private String innerSuggestionMessage;
    private String highlightedColor = "yellow";

    @Setter
    private String serverMessage = "";


    @Inject
    public SuggestionPanel(FlippingCopilotConfig config,
                           SuggestionManager suggestionManager,
                           AccountStatusManager accountStatusManager,
                           PauseButton pauseButton,
                           BlockButton blockButton,
                           PreferencesPanel preferencesPanel,
                           OsrsLoginManager osrsLoginManager,
                           Client client, PausedManager pausedManager,
                           GrandExchangeUncollectedManager uncollectedManager,
                           ClientThread clientThread,
                           HighlightController highlightController,
                           ItemManager itemManager,
                           GrandExchange grandExchange,  PremiumInstanceController premiumInstanceController, FlipManager flipManager, CopilotLoginManager copilotLoginManager, FlipsDialogController flipsDialogController) {
        this.preferencesPanel = preferencesPanel;
        this.config = config;
        this.suggestionManager = suggestionManager;
        this.accountStatusManager = accountStatusManager;
        this.pauseButton = pauseButton;
        this.blockButton = blockButton;
        this.osrsLoginManager = osrsLoginManager;
        this.client = client;
        this.pausedManager = pausedManager;
        this.uncollectedManager = uncollectedManager;
        this.clientThread = clientThread;
        this.highlightController = highlightController;
        this.itemManager = itemManager;
        this.grandExchange = grandExchange;
        this.premiumInstanceController = premiumInstanceController;
        this.flipManager = flipManager;
        this.copilotLoginManager = copilotLoginManager;
        this.flipsDialogController = flipsDialogController;

        layeredPane.setLayout(null);
        setPreferredSize(new Dimension(MainPanel.CONTENT_WIDTH, 150));
        suggestedActionPanel = new JPanel(new BorderLayout());
        suggestedActionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestedActionPanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 10, 5));
        suggestedActionPanel.setBounds(0, 0, MainPanel.CONTENT_WIDTH, 150);

        JPanel suggestionContainer = new JPanel(new BorderLayout());
        suggestionContainer.setOpaque(true);
        suggestionContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.setPreferredSize(new Dimension(MainPanel.CONTENT_WIDTH - 10, 85));
        suggestedActionPanel.add(suggestionContainer, BorderLayout.CENTER);

        // Center panel for main suggestion content (icon and text)
        JPanel suggestionMainPanel = new JPanel();
        suggestionMainPanel.setLayout(new CardLayout());
        suggestionMainPanel.setOpaque(true);
        suggestionMainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.add(suggestionMainPanel, BorderLayout.CENTER);

        suggestionTextContainer.setLayout(new BoxLayout(suggestionTextContainer, BoxLayout.X_AXIS));
        suggestionTextContainer.add(Box.createHorizontalGlue());
        suggestionTextContainer.add(suggestionIcon);
        suggestionTextContainer.add(suggestionText);
        suggestionTextContainer.add(Box.createHorizontalGlue());
        suggestionTextContainer.setOpaque(true);
        suggestionTextContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionIcon.setVisible(false);
        suggestionIcon.setOpaque(true);
        suggestionIcon.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionIcon.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));

        suggestionText.setHorizontalAlignment(SwingConstants.CENTER);
        suggestionText.setBorder(BorderFactory.createEmptyBorder(0, 3, 0, 3));
        suggestionMainPanel.add(suggestionTextContainer);

        suggestionMainPanel.add(spinner);

        // Add expected profit text to SOUTH of suggestionContainer
        additionalInfoText.setHorizontalAlignment(SwingConstants.CENTER);
        additionalInfoText.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        additionalInfoText.setText("");
        additionalInfoText.setBorder(BorderFactory.createEmptyBorder(0, 6, 8, 6)); // top, left, bottom, right
        suggestionContainer.add(additionalInfoText, BorderLayout.SOUTH);

        setupButtonContainer();
        suggestedActionPanel.add(buttonContainer, BorderLayout.SOUTH);

        layeredPane.add(suggestedActionPanel, JLayeredPane.DEFAULT_LAYER);
        this.preferencesPanel.setVisible(false);

        layeredPane.add(this.preferencesPanel, JLayeredPane.PALETTE_LAYER);

        // Create and add the gear button
        BufferedImage gearIcon = ImageUtil.loadImageResource(getClass(), "/preferences-icon.png");
        gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
        BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
        gearButton = buildButton(recoloredIcon, "Settings", () -> {});
        gearButton.setEnabled(true);
        gearButton.setFocusable(true);
        gearButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        gearButton.setOpaque(true);
        ImageIcon iconOff = new ImageIcon(recoloredIcon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(recoloredIcon, BUTTON_HOVER_LUMINANCE));
        gearButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                handleGearClick();
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                gearButton.setIcon(iconOn);
            }
            @Override
            public void mouseExited(MouseEvent e) {
                gearButton.setIcon(iconOff);
            }
        });
        gearButton.setOpaque(true);
        gearButton.setBounds(5, 5, 20, 20);

        layeredPane.add(gearButton, JLayeredPane.MODAL_LAYER);

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        preferencesPanel.setBounds(0, 0, MainPanel.CONTENT_WIDTH, 180);

        add(layeredPane);
    }

    private void handleGearClick() {
        isPreferencesPanelVisible = !isPreferencesPanelVisible;
        int newHeight = isPreferencesPanelVisible ? 180 : 150;
        layeredPane.setSize(MainPanel.CONTENT_WIDTH, newHeight);
        layeredPane.setPreferredSize(new Dimension(MainPanel.CONTENT_WIDTH, newHeight));
        setPreferredSize(new Dimension(MainPanel.CONTENT_WIDTH, newHeight));

        preferencesPanel.setVisible(isPreferencesPanelVisible);
        suggestedActionPanel.setVisible(!isPreferencesPanelVisible);

        refresh();
        layeredPane.revalidate();
        layeredPane.repaint();
    }

    private void setupButtonContainer() {
        buttonContainer.setLayout(new BorderLayout());
        buttonContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel centerPanel = new JPanel(new GridLayout(1, 5, 15, 0));
        centerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/graph.png");
        graphButton = buildButton(graphIcon, "Price graph", () -> {
            if(config.priceGraphWebsite().equals(FlippingCopilotConfig.PriceGraphWebsite.FLIPPING_COPILOT)) {
                Suggestion suggestion = suggestionManager.getSuggestion();
                if(suggestion != null && !suggestion.getType().equals("wait")) {
                    flipsDialogController.showPriceGraphTab(null, true);
                } else {
                    flipsDialogController.showPriceGraphTab(null, false);
                }
            } else {
                Suggestion suggestion = suggestionManager.getSuggestion();
                String url = config.priceGraphWebsite().getUrl(suggestion.getName(), suggestion.getItemId());
                LinkBrowser.browse(url);
            }
        });
        centerPanel.add(graphButton);

        JPanel emptyPanel = new JPanel();
        emptyPanel.setOpaque(false);
        centerPanel.add(emptyPanel);
        centerPanel.add(pauseButton);
        centerPanel.add(blockButton);

        BufferedImage skipIcon = ImageUtil.loadImageResource(getClass(), "/skip.png");
        skipButton = buildButton(skipIcon, "Skip suggestion", () -> {
            showLoading();
            Suggestion s = suggestionManager.getSuggestion();
            accountStatusManager.setSkipSuggestion(s != null ? s.getId() : -1);
            suggestionManager.setSuggestionNeeded(true);
        });
        centerPanel.add(skipButton);

        buttonContainer.add(centerPanel, BorderLayout.CENTER);
    }


    private void setItemIcon(int itemId) {
        AsyncBufferedImage image = itemManager.getImage(itemId);
        if (image != null) {
            image.addTo(suggestionIcon);
            suggestionIcon.setVisible(true);
        }
    }

    public void setAdditionalInfoText(String text) {
        additionalInfoText.setText("<html><center>" + text + "</center></html>");
    }

    public void updateSuggestion(Suggestion suggestion) {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String suggestionString = "<html><center>";
        suggestionTextContainer.setVisible(false);
        additionalInfoText.setText("");
        switch (suggestion.getType()) {
            case "wait":
                suggestionString += "Wait <br>";
                break;
            case "abort":
                suggestionString += "Abort offer for<br><FONT COLOR=white>" + suggestion.getName() + "<br></FONT>";
                setItemIcon(suggestion.getItemId());
                break;
            case "buy":
            case "sell":
                String capitalisedAction = suggestion.getType().equals("buy") ? "Buy" : "Sell";
                suggestionString += capitalisedAction +
                        " <FONT COLOR=" + highlightedColor + ">" + formatter.format(suggestion.getQuantity()) + "</FONT><br>" +
                        "<FONT COLOR=white>" + suggestion.getName() + "</FONT><br>" +
                        "for <FONT COLOR=" + highlightedColor + ">" + formatter.format(suggestion.getPrice()) + "</FONT> gp<br>";
                setItemIcon(suggestion.getItemId());
                break;
            default:
                suggestionString += "Error processing suggestion<br>";
        }
        String additionalInfoMessage = Strings.isNullOrEmpty(suggestion.getMessage()) ? "" : "<br>" + suggestion.getMessage();

        suggestionString += "</center><html>";
        innerSuggestionMessage = "";
        if(!suggestion.getType().equals("wait")) {
            setButtonsVisible(true);
        }
        suggestionText.setText(suggestionString);
        suggestionText.setMaximumSize(new Dimension(suggestionText.getPreferredSize().width, Integer.MAX_VALUE));
        if (suggestion.getType().equals("buy")) {
            setAdditionalInfoText(formatExpectedProfitAndDuration(suggestion.getExpectedProfit(), suggestion.getExpectedDuration()) + additionalInfoMessage);
        } else if (suggestion.getType().equals("sell")) {
            Transaction t = new Transaction();
            t.setItemId(suggestion.getItemId());
            t.setPrice(suggestion.getPrice());
            t.setQuantity(suggestion.getQuantity());
            t.setAmountSpent(suggestion.getPrice() * suggestion.getQuantity());
            t.setType(OfferStatus.SELL);
            Integer accountId = copilotLoginManager.getAccountId(osrsLoginManager.getLastDisplayName());
            String text = "";
            if (accountId != null) {
                Long profit = flipManager.estimateTransactionProfit(accountId, t);
                if (profit != null) {
                    text = formatSellProfitLossAndDuration((double) profit, suggestion.getExpectedDuration());
                }
            }
            setAdditionalInfoText(text + additionalInfoMessage);
        } else {
            setAdditionalInfoText(additionalInfoMessage);
        }

        suggestionTextContainer.setVisible(true);
        suggestionTextContainer.revalidate();
        suggestionTextContainer.repaint();
    }

    public void suggestCollect() {
        setMessage("Collect items");
        setButtonsVisible(false);
    }

    public void suggestAddGp() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        setMessage("Add " +
                "at least <FONT COLOR=" + highlightedColor + ">" + formatter.format(MIN_GP_NEEDED_TO_FLIP)
                + "</FONT> gp<br>to your inventory<br>"
                + "to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void suggestOpenGe() {
        setMessage("Open the Grand Exchange<br>"
                + "to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void setIsPausedMessage() {
        setMessage("Suggestions are paused");
        setButtonsVisible(false);
    }

    public void setMessage(String message) {
        additionalInfoText.setVisible(false);
        innerSuggestionMessage = message;
        setButtonsVisible(false);

        // Check if message contains "<manage>"
        String displayMessage = message;
        if (message != null && message.contains("<manage>")) {
            // Replace <manage> with a styled link
            displayMessage = message.replace("<manage>",
                    "<a href='#' style='text-decoration:underline'>manage</a>");

            // Add mouse listener if not already present
            boolean hasListener = false;
            for (MouseListener listener : suggestionText.getMouseListeners()) {
                if (listener instanceof ManageClickListener) {
                    hasListener = true;
                    break;
                }
            }

            if (!hasListener) {
                suggestionText.addMouseListener(new ManageClickListener());
                // Make the label show a hand cursor when hovering over it
                suggestionText.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
        } else {
            suggestionText.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
        }
        suggestionText.setText("<html><center>" + displayMessage + "<br>" + serverMessage + "</center></html>");
        suggestionText.setMaximumSize(new Dimension(suggestionText.getPreferredSize().width, Integer.MAX_VALUE));
        suggestionTextContainer.revalidate();
        suggestionTextContainer.repaint();
    }

    private class ManageClickListener extends MouseAdapter {
        @Override
        public void mouseClicked(MouseEvent e) {
            String text = suggestionText.getText();
            if (text.contains("manage")) {
                premiumInstanceController.loadAndOpenPremiumInstanceDialog();
            }
        }
    }

    public boolean isCollectItemsSuggested() {
        return suggestionText.isVisible() && "Collect items".equals(innerSuggestionMessage);
    }

    public void showLoading() {
        suggestionTextContainer.setVisible(false);
        setServerMessage("");
        spinner.show();
        setButtonsVisible(false);
        suggestionIcon.setVisible(false);
        additionalInfoText.setText("");
        additionalInfoText.setVisible(false);
        suggestionText.setText("");
    }

    public void hideLoading() {
        spinner.hide();
        suggestionTextContainer.setVisible(true);
        additionalInfoText.setVisible(true);
    }

    private void setButtonsVisible(boolean visible) {
        skipButton.setVisible(visible);
        blockButton.setVisible(visible);
        suggestionIcon.setVisible(visible);
    }

    public void displaySuggestion() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return;
        }
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if(accountStatus == null) {
            return;
        }
        setServerMessage(suggestion.getMessage());
        boolean collectNeeded = accountStatus.isCollectNeeded(suggestion);
        if(collectNeeded && !uncollectedManager.HasUncollected(osrsLoginManager.getAccountHash())) {
            log.warn("tick {} collect is suggested but there is nothing to collect! suggestion: {} {} {}", client.getTickCount(), suggestion.getType(), suggestion.getQuantity(), suggestion.getItemId());
        }
        if (collectNeeded) {
            suggestCollect();
        } else if(suggestion.getType().equals("wait") && !grandExchange.isOpen() && accountStatus.emptySlotExists()) {
            suggestOpenGe();
        } else if (suggestion.getType().equals("wait") && accountStatus.moreGpNeeded()) {
            suggestAddGp();
        }  else {
            updateSuggestion(suggestion);
        }
        highlightController.redraw();
    }

    public void refresh() {
        log.debug("refreshing suggestion panel {}", client.getGameState());
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        if(isPreferencesPanelVisible) {
            preferencesPanel.refresh();
            return;
        }
        if (pausedManager.isPaused()) {
            hideLoading();
            setIsPausedMessage();
            return;
        }

        String errorMessage = osrsLoginManager.getInvalidStateDisplayMessage();
        if (errorMessage != null) {
            hideLoading();
            setMessage(errorMessage);
            return;
        }

        if(suggestionManager.isSuggestionRequestInProgress()) {
            showLoading();
            return;
        }
        hideLoading();

        final HttpResponseException suggestionError = suggestionManager.getSuggestionError();
        if(suggestionError != null) {
            highlightController.redraw();
            setMessage("Error: " + suggestionError.getMessage());
            return;
        }

        if(!client.isClientThread()) {
            clientThread.invoke(this::displaySuggestion);
        } else {
            displaySuggestion();
        }
    }

    private String formatSellProfitLossAndDuration(Double expectedProfit, Double expectedDuration) {
        String formattedProfit = formatProfit(expectedProfit);
        Color color = config.profitAmountColor();
        if(expectedProfit < 0) {
            color = config.lossAmountColor();
        }
        String colorHex = String.format("#%06X", (0xFFFFFF & color.getRGB()));
        String text = "<b><font color='" + colorHex + "'>" + formattedProfit + "</font></b> profit";
        if (expectedDuration != null) {
            String formattedDuration = formatDuration(expectedDuration);
            text += " in <b>" + formattedDuration + "</b>";
        }
        return text;
    }

    private String formatExpectedProfitAndDuration(Double expectedProfit, Double expectedDuration) {
        if (expectedProfit == null || expectedDuration == null) {
            return "";
        }
        String formattedProfit = formatProfit(expectedProfit);
        String formattedDuration = formatDuration(expectedDuration);
        Color profitColor = config.profitAmountColor();

        String colorHex = String.format("#%06X", (0xFFFFFF & profitColor.getRGB()));
        return "<b><font color='" + colorHex + "'>" + formattedProfit + "</font></b> profit in <b>" + formattedDuration + "</b>";
    }

    private String formatProfit(double profit) {
        if (Math.abs(profit) >= 1_000_000) {
            return String.format("%.1fM", profit / 1_000_000).replace(".0", "");
        } else if (Math.abs(profit) >= 1_000) {
            return String.format("%.1fK", profit / 1_000).replace(".0", "");
        } else {
            return String.format("%.0f", profit);
        }
    }

    private String formatDuration(double durationSeconds) {
        int totalMinutes = (int) Math.round(durationSeconds / 60.0);
        // Round to nearest 5 minutes
        totalMinutes = Math.round(totalMinutes / 5.0f) * 5;
        totalMinutes = Math.max(totalMinutes, 5);
        if (totalMinutes < 60) {
            return totalMinutes + "min";
        } else {
            int hours = totalMinutes / 60;
            int minutes = totalMinutes % 60;
            if (minutes == 0) {
                return hours + "h";
            } else {
                return hours + "h " + minutes + "m";
            }
        }
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.PremiumInstanceStatus;
import com.flippingcopilot.model.SuggestionManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

@Slf4j
public class PremiumInstancePanel extends JPanel {

    private final CardLayout cardLayout;
    private final JPanel cardPanel;
    private final List<JComboBox<String>> instanceDropdowns;
    private final FlippingCopilotConfig config;
    private final ApiRequestHandler apiRequestHandler;
    private final SuggestionManager suggestionManager;

    public PremiumInstancePanel(FlippingCopilotConfig config, ApiRequestHandler apiRequestHandler, SuggestionManager suggestionManager) {
        this.config = config;
        this.apiRequestHandler = apiRequestHandler;
        this.suggestionManager = suggestionManager;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        cardLayout = new CardLayout();
        cardPanel = new JPanel(cardLayout);
        cardPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create loading panel
        JPanel loadingPanel = createLoadingPanel();
        cardPanel.add(loadingPanel, "loading");

        // Create error panel container (will be populated when error occurs)
        JPanel errorPanel = new JPanel(new BorderLayout());
        errorPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.add(errorPanel, "error");

        // Create management panel container (will be populated when data loads)
        JPanel managementPanel = new JPanel(new BorderLayout());
        managementPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.add(managementPanel, "management");

        add(cardPanel, BorderLayout.CENTER);

        instanceDropdowns = new ArrayList<>();
    }

    private JPanel createLoadingPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(0, 0, 10, 0);

        Spinner spinner = new Spinner();
        spinner.show();
        panel.add(spinner, gbc);

        gbc.gridy = 1;
        JLabel loadingLabel = new JLabel("Loading premium account data");
        loadingLabel.setForeground(Color.WHITE);
        panel.add(loadingLabel, gbc);

        return panel;
    }

    public void showLoading() {
        cardLayout.show(cardPanel, "loading");
    }

    public void showError(String errorMessage) {
        JPanel errorPanel = (JPanel) cardPanel.getComponent(1); // error panel
        errorPanel.removeAll();
        errorPanel.setLayout(new GridBagLayout());

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        JLabel errorLabel = new JLabel("<html><center>" + errorMessage + "</center></html>");
        errorLabel.setForeground(Color.RED);
        errorLabel.setHorizontalAlignment(SwingConstants.CENTER);
        errorPanel.add(errorLabel, gbc);

        cardLayout.show(cardPanel, "error");
    }

    public void showManagementView(PremiumInstanceStatus status) {
        JPanel managementPanel = (JPanel) cardPanel.getComponent(2); // management panel
        managementPanel.removeAll();
        managementPanel.setLayout(new BorderLayout());
        managementPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        managementPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create header panel for the count label
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new BoxLayout(headerPanel, BoxLayout.Y_AXIS));
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add premium instances count
        JLabel countLabel = new JLabel("You have " + status.getPremiumInstancesCount() + " premium accounts");
        countLabel.setFont(countLabel.getFont().deriveFont(Font.BOLD));
        countLabel.setForeground(Color.WHITE);
        countLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        headerPanel.add(countLabel);
        headerPanel.add(Box.createRigidArea(new Dimension(0, 15)));

        // Add header to the top of the management panel
        managementPanel.add(headerPanel, BorderLayout.NORTH);

        // Clear existing dropdowns
        instanceDropdowns.clear();

        // Create a panel for the scrollable content
        JPanel scrollContent = new JPanel();
        scrollContent.setLayout(new BoxLayout(scrollContent, BoxLayout.Y_AXIS));
        scrollContent.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add dropdowns for each instance
        for (int i = 0; i < status.getPremiumInstancesCount(); i++) {
            JPanel instancePanel = new JPanel();
            instancePanel.setLayout(new FlowLayout(FlowLayout.LEFT));
            instancePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            instancePanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 35));

            JLabel instanceLabel = new JLabel("Premium account " + (i + 1) + ":");
            instanceLabel.setForeground(Color.WHITE);
            instanceLabel.setPreferredSize(new Dimension(130, 25));
            instancePanel.add(instanceLabel);

            JComboBox<String> dropdown = new JComboBox<>();
            dropdown.setPreferredSize(new Dimension(200, 25));

            // Add current assignment if exists
            String currentAssignment = null;
            if (i < status.getCurrentlyAssignedDisplayNames().size()) {
                dropdown.addItem("Unassigned");
                currentAssignment = status.getCurrentlyAssignedDisplayNames().get(i);
                dropdown.addItem(currentAssignment);
                dropdown.setSelectedIndex(1);
            } else {
                dropdown.addItem("Unassigned");
            }

            // Add available names
            for (String availableName : status.getAvailableDisplayNames()) {
                if (!availableName.equals(currentAssignment)) {
                    dropdown.addItem(availableName);
                }
            }

            instancePanel.add(dropdown);
            instanceDropdowns.add(dropdown);

            scrollContent.add(instancePanel);
            scrollContent.add(Box.createRigidArea(new Dimension(0, 5)));
        }

        // Add vertical glue to push everything to the top
        scrollContent.add(Box.createVerticalGlue());

        // Create a scroll pane for the content
        JScrollPane scrollPane = new JScrollPane(scrollContent);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add the scroll pane to the center of the management panel
        managementPanel.add(scrollPane, BorderLayout.CENTER);

        // Add bottom panel with changes remaining and update button
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bottomPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));

        JLabel changesLabel = new JLabel("Changes remaining (re-charges 1 per day): " + status.getChangesRemaining());
        changesLabel.setForeground(config.lossAmountColor());
        changesLabel.setToolTipText("Remaining updates. This limit recharges by 1 every day up to a max of 12.");
        bottomPanel.add(changesLabel, BorderLayout.WEST);

        JButton updateButton = new JButton("Update");
        // Disable the update button if no changes remaining
        updateButton.setEnabled(status.getChangesRemaining() > 0);
        // Add tooltip to explain why button is disabled when changes = 0
        if (status.getChangesRemaining() <= 0) {
            updateButton.setToolTipText("No changes remaining. Wait for daily recharge.");
        }

        updateButton.addActionListener(e -> {
            this.showLoading();
            Consumer<PremiumInstanceStatus> c = (s) -> {
                SwingUtilities.invokeLater(() -> {  // Make sure UI updates happen on EDT
                    if (s.getLoadingError() != null && !s.getLoadingError().isEmpty()) {
                        this.showError(s.getLoadingError());
                    } else {
                        this.showManagementView(s);
                        suggestionManager.setSuggestionNeeded(true);
                    }
                });
            };
            List<String> desiredAssignedDisplayNames = new ArrayList<>();
            for (JComboBox<String> dropdown : instanceDropdowns) {
                String selectedName = (String) dropdown.getSelectedItem();
                if (selectedName != null && !selectedName.equals("Unassigned") && !desiredAssignedDisplayNames.contains(selectedName)) {
                    desiredAssignedDisplayNames.add(selectedName);
                }
            }
            apiRequestHandler.asyncUpdatePremiumInstances(c, desiredAssignedDisplayNames);
        });
        bottomPanel.add(updateButton, BorderLayout.EAST);

        // Add the bottom panel to the south of the management panel
        managementPanel.add(bottomPanel, BorderLayout.SOUTH);

        cardLayout.show(cardPanel, "management");
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.model.RiskLevel;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.event.ChangeEvent;
import java.awt.*;
import java.awt.event.*;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Singleton
public class ControlPanel extends JPanel
{
    private static final int MIN_MINUTES = 1;
    private static final int MAX_MINUTES = 24 * 60;     // 1440

    private static final int STEPS = 1000;              // internal slider resolution

    // Presets
    private static final int PRESET_5M  = 5;
    private static final int PRESET_30M = 30;
    private static final int PRESET_2H  = 2 * 60;
    private static final int PRESET_8H  = 8 * 60;

    private final SuggestionManager suggestionManager;
    private final SuggestionPreferencesManager preferencesManager;
    private final JPanel timeframePanel;
    private final JToggleButton btn5m;
    private final JToggleButton btn30m;
    private final JToggleButton btn2h;
    private final JToggleButton btn8h;
    private final JToggleButton btnCustom; // "..." button
    private final JToggleButton btnRiskLow;
    private final JToggleButton btnRiskMedium;
    private final JToggleButton btnRiskHigh;

    private boolean suppressTimeframeSliderEvents;
    private boolean customExplicitlySelected;

    private static final Color RISK_LOW_SELECTED_COLOR = ColorScheme.GRAND_EXCHANGE_PRICE;
    private static final Color RISK_HIGH_SELECTED_COLOR = Color.red;
    private static final String RISK_LOW_LABEL = "Low";
    private static final String RISK_MEDIUM_LABEL = "Med";
    private static final String RISK_HIGH_LABEL = "High";

    private final JSlider timeframeSlider;
    private final JLabel valueLabel; // fixed-size text showing selected time
    private final JTextField valueEditor; // temporary editor shown during inline edits
    private final JPanel customPanel; // contains only the slider row (no label)
    private final JPanel sliderRow;
    private boolean editingCustomValue;
    private int editingOriginalMinutes;

    // Sqrt domain precomputed
    private static final double SQRT_MIN = Math.sqrt(MIN_MINUTES);
    private static final double SQRT_MAX = Math.sqrt(MAX_MINUTES);
    private static final double SQRT_RANGE = SQRT_MAX - SQRT_MIN;
    private static final Pattern TIME_TOKEN_PATTERN = Pattern.compile("(\\d+(?:\\.\\d+)?)\\s*(h|hr|hrs|hour|hours|m|min|mins|minute|minutes)?", Pattern.CASE_INSENSITIVE);

    @Inject
    public ControlPanel(
            SuggestionManager suggestionManager,
            SuggestionPreferencesManager preferencesManager)
    {
        this.suggestionManager = suggestionManager;
        this.preferencesManager = preferencesManager;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        setBounds(0, 0, MainPanel.CONTENT_WIDTH, 200);

        // --- Timeframe buttons ---
        timeframePanel = new JPanel();
        timeframePanel.setLayout(new BoxLayout(timeframePanel, BoxLayout.Y_AXIS));
        timeframePanel.setOpaque(false);

        JLabel timeframeLabel = new JLabel("How often do you adjust offers?");
        timeframeLabel.setHorizontalAlignment(SwingConstants.LEFT);
        timeframeLabel.setMaximumSize(timeframeLabel.getPreferredSize());

        JPanel labelPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        labelPanel.setOpaque(false);
        labelPanel.add(timeframeLabel);

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(1, 5, 0, 0));
        buttonPanel.setOpaque(false);

        ButtonGroup timeframeButtonGroup = new ButtonGroup();

        btn5m     = createPresetButton("5m",   PRESET_5M,  suggestionManager);
        btn30m    = createPresetButton("30m",  PRESET_30M, suggestionManager);
        btn2h     = createPresetButton("2h",   PRESET_2H,  suggestionManager);
        btn8h     = createPresetButton("8h",   PRESET_8H,  suggestionManager);
        btnCustom = createCustomButton("...", suggestionManager);

        timeframeButtonGroup.add(btn5m);
        timeframeButtonGroup.add(btn30m);
        timeframeButtonGroup.add(btn2h);
        timeframeButtonGroup.add(btn8h);
        timeframeButtonGroup.add(btnCustom);

        buttonPanel.add(btn5m);
        buttonPanel.add(btn30m);
        buttonPanel.add(btn2h);
        buttonPanel.add(btn8h);
        buttonPanel.add(btnCustom);

        timeframePanel.add(labelPanel);
        timeframePanel.add(Box.createRigidArea(new Dimension(0, 3)));
        timeframePanel.add(buttonPanel);

        // --- Custom slider panel (hidden unless "..." selected) ---
        customPanel = new JPanel();
        customPanel.setLayout(new BoxLayout(customPanel, BoxLayout.Y_AXIS));
        customPanel.setOpaque(false);

        // small spacing above the slider row
        customPanel.add(Box.createRigidArea(new Dimension(0, 8)));

        int initMinutes = clampMinutes(preferencesManager.getTimeframe());
        customExplicitlySelected = !isPreset(initMinutes);
        timeframeSlider = new JSlider(JSlider.HORIZONTAL, 0, STEPS, minutesToPos(initMinutes));
        timeframeSlider.setOpaque(false);
        timeframeSlider.setPaintTicks(false);   // NO TICKS
        timeframeSlider.setPaintLabels(false);  // NO LABELS
        timeframeSlider.setSnapToTicks(false);

        // Stable slider height/width
        timeframeSlider.setPreferredSize(new Dimension(MainPanel.CONTENT_WIDTH - 100, 24));
        timeframeSlider.setMinimumSize(new Dimension(100, 24));
        timeframeSlider.setMaximumSize(new Dimension(Integer.MAX_VALUE, 24));

        valueLabel = new JLabel(formatMinutes(initMinutes), SwingConstants.RIGHT);
        valueLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        valueLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        valueLabel.setToolTipText("Click to enter a custom time interval");

        // Fixed label size based on widest expected text
        String widest = "24h 00m";
        FontMetrics fm = valueLabel.getFontMetrics(valueLabel.getFont());
        int labelWidth = fm.stringWidth(widest);
        int labelHeight = fm.getHeight();
        Dimension fixed = new Dimension(labelWidth, labelHeight);
        valueLabel.setMinimumSize(fixed);
        valueLabel.setPreferredSize(fixed);
        valueLabel.setMaximumSize(fixed);

        valueEditor = new JTextField();
        valueEditor.setHorizontalAlignment(JTextField.RIGHT);
        valueEditor.setMinimumSize(fixed);
        valueEditor.setPreferredSize(fixed);
        valueEditor.setMaximumSize(fixed);
        valueEditor.setBackground(ColorScheme.DARK_GRAY_COLOR);
        valueEditor.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        valueEditor.setCaretColor(ColorScheme.BRAND_ORANGE);
        valueEditor.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR),
                BorderFactory.createEmptyBorder(0, 4, 0, 4)));

        valueLabel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                if (!SwingUtilities.isLeftMouseButton(e) || e.getClickCount() != 1)
                {
                    return;
                }
                beginCustomTimeEditing();
            }
        });

        valueEditor.addActionListener(e -> commitCustomTime(true));
        valueEditor.addFocusListener(new FocusAdapter()
        {
            @Override
            public void focusLost(FocusEvent e)
            {
                if (!editingCustomValue)
                {
                    return;
                }
                if (!commitCustomTime(false))
                {
                    cancelCustomTimeEditing();
                }
            }
        });

        InputMap inputMap = valueEditor.getInputMap(JComponent.WHEN_FOCUSED);
        ActionMap actionMap = valueEditor.getActionMap();
        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), "cancel-edit");
        actionMap.put("cancel-edit", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                cancelCustomTimeEditing();
            }
        });

        sliderRow = new JPanel(new BorderLayout(8, 0));
        sliderRow.setOpaque(false);
        sliderRow.add(timeframeSlider, BorderLayout.CENTER);
        sliderRow.add(valueLabel, BorderLayout.EAST);

        timeframeSlider.addChangeListener((ChangeEvent e) -> {
            int minutesPreview = posToMinutes(timeframeSlider.getValue());
            updateValueLabel(minutesPreview);
            if (suppressTimeframeSliderEvents)
            {
                return;
            }
            if (!timeframeSlider.getValueIsAdjusting())
            {
                applyTimeframe(minutesPreview, suggestionManager, /*updateSlider*/ false, /*updateButtons*/ true);
                // Keep "..." selected for non-preset custom values
                if (!isPreset(minutesPreview)) {
                    btnCustom.setSelected(true);
                }
            }
        });

        customPanel.add(sliderRow);

        timeframePanel.add(customPanel);

        timeframePanel.add(Box.createRigidArea(new Dimension(0, 10)));

        JLabel riskLabel = new JLabel("Risk level: ");
        riskLabel.setHorizontalAlignment(SwingConstants.LEFT);
        riskLabel.setMaximumSize(riskLabel.getPreferredSize());

        JPanel riskButtonPanel = new JPanel();
        riskButtonPanel.setLayout(new GridLayout(1, 3, 0, 0));
        riskButtonPanel.setOpaque(false);

        ButtonGroup riskButtonGroup = new ButtonGroup();
        RiskLevel initialRiskLevel = preferencesManager.getRiskLevel();
        if (initialRiskLevel == null)
        {
            initialRiskLevel = RiskLevel.MEDIUM;
            preferencesManager.setRiskLevel(initialRiskLevel);
        }

        btnRiskLow = createRiskButton(RISK_LOW_LABEL, RiskLevel.LOW, suggestionManager);
        btnRiskMedium = createRiskButton(RISK_MEDIUM_LABEL, RiskLevel.MEDIUM, suggestionManager);
        btnRiskHigh = createRiskButton(RISK_HIGH_LABEL, RiskLevel.HIGH, suggestionManager);

        riskButtonGroup.add(btnRiskLow);
        riskButtonGroup.add(btnRiskMedium);
        riskButtonGroup.add(btnRiskHigh);

        riskButtonPanel.add(btnRiskLow);
        riskButtonPanel.add(btnRiskMedium);
        riskButtonPanel.add(btnRiskHigh);

        JPanel riskRow = new JPanel();
        riskRow.setLayout(new BoxLayout(riskRow, BoxLayout.X_AXIS));
        riskRow.setOpaque(false);
        riskRow.add(riskLabel);
        riskRow.add(Box.createRigidArea(new Dimension(10, 0)));
        riskRow.add(riskButtonPanel);
        riskRow.add(Box.createHorizontalGlue());

        timeframePanel.add(riskRow);

        updateRiskButtons(initialRiskLevel);
        add(timeframePanel);

        // Initial sync & visibility
        refresh();
        updateCustomVisibility();
    }

    // ---------- Mapping between slider position (0..STEPS) and minutes (1..1440) using t ----------
    private static int minutesToPos(int minutes)
    {
        int m = clampMinutes(minutes);
        double root = Math.sqrt(m);
        double t = (root - SQRT_MIN) / SQRT_RANGE; // 0..1 uniform in sqrt space
        int pos = (int) Math.round(t * STEPS);
        return Math.max(0, Math.min(STEPS, pos));
    }

    private static int posToMinutes(int pos)
    {
        int p = Math.max(0, Math.min(STEPS, pos));
        double t = (double) p / (double) STEPS;   // 0..1
        double root = SQRT_MIN + t * SQRT_RANGE;
        int m = (int) Math.round(root * root);
        return clampMinutes(m);
    }

    private static int clampMinutes(int m)
    {
        return Math.max(MIN_MINUTES, Math.min(MAX_MINUTES, m));
    }

    private static boolean isPreset(int minutes)
    {
        return minutes == PRESET_5M || minutes == PRESET_30M || minutes == PRESET_2H || minutes == PRESET_8H;
    }

    private String formatMinutes(int m)
    {
        if (m < 60) return m + "m";
        if (m % 60 == 0) return (m / 60) + "h";
        int mins = m % 60;
        String mm = mins < 10 ? ("0" + mins) : String.valueOf(mins);
        return (m / 60) + "h " + mm + "m";
    }

    private void updateValueLabel(int minutes)
    {
        valueLabel.setText(formatMinutes(minutes));
    }

    private void updateCustomVisibility()
    {
        boolean show = btnCustom.isSelected();
        customPanel.setVisible(show);
        customPanel.revalidate();
        customPanel.repaint();
        timeframePanel.revalidate();
        timeframePanel.repaint();
    }

    private void beginCustomTimeEditing()
    {
        if (editingCustomValue)
        {
            return;
        }

        editingCustomValue = true;
        editingOriginalMinutes = posToMinutes(timeframeSlider.getValue());

        sliderRow.remove(valueLabel);
        sliderRow.add(valueEditor, BorderLayout.EAST);
        sliderRow.revalidate();
        sliderRow.repaint();

        valueEditor.setText(formatMinutes(editingOriginalMinutes));
        valueEditor.selectAll();
        valueEditor.requestFocusInWindow();
    }

    private boolean commitCustomTime(boolean showError)
    {
        Integer minutes = parseCustomTimeMinutes(valueEditor.getText());
        if (minutes == null)
        {
            if (showError)
            {
                JOptionPane.showMessageDialog(this,
                        "Couldn't understand that time. Try 90m, 1h 30m, or 1:30.",
                        "Invalid custom time",
                        JOptionPane.ERROR_MESSAGE);
                valueEditor.requestFocusInWindow();
                valueEditor.selectAll();
            }
            return false;
        }

        if (minutes < MIN_MINUTES || minutes > MAX_MINUTES)
        {
            if (showError)
            {
                JOptionPane.showMessageDialog(this,
                        String.format(Locale.ROOT, "Time must be between %dm and %dh 00m.", MIN_MINUTES, MAX_MINUTES / 60),
                        "Invalid custom time",
                        JOptionPane.ERROR_MESSAGE);
                valueEditor.requestFocusInWindow();
                valueEditor.selectAll();
            }
            return false;
        }

        applyTimeframe(minutes, suggestionManager, /*updateSlider*/ true, /*updateButtons*/ true);
        restoreValueLabelComponent();
        return true;
    }

    private void cancelCustomTimeEditing()
    {
        if (!editingCustomValue)
        {
            return;
        }

        updateValueLabel(posToMinutes(timeframeSlider.getValue()));
        restoreValueLabelComponent();
    }

    private void restoreValueLabelComponent()
    {
        sliderRow.remove(valueEditor);
        sliderRow.add(valueLabel, BorderLayout.EAST);
        sliderRow.revalidate();
        sliderRow.repaint();
        editingCustomValue = false;
    }

    private Integer parseCustomTimeMinutes(String input)
    {
        if (input == null)
        {
            return null;
        }

        String trimmed = input.trim();
        if (trimmed.isEmpty())
        {
            return null;
        }

        String normalized = trimmed.toLowerCase(Locale.ROOT);

        if (normalized.contains(":"))
        {
            String[] parts = normalized.split(":");
            if (parts.length != 2)
            {
                return null;
            }

            try
            {
                int hours = Integer.parseInt(parts[0].trim());
                int minutes = Integer.parseInt(parts[1].trim());
                if (hours < 0 || minutes < 0 || minutes >= 60)
                {
                    return null;
                }
                return hours * 60 + minutes;
            }
            catch (NumberFormatException ex)
            {
                return null;
            }
        }

        Matcher matcher = TIME_TOKEN_PATTERN.matcher(normalized);
        int total = 0;
        int lastEnd = 0;
        boolean matched = false;

        while (matcher.find())
        {
            String between = normalized.substring(lastEnd, matcher.start());
            if (!between.trim().isEmpty())
            {
                return null;
            }

            String numberPart = matcher.group(1);
            String unit = matcher.group(2);

            double value;
            try
            {
                value = Double.parseDouble(numberPart);
            }
            catch (NumberFormatException ex)
            {
                return null;
            }

            if (unit == null || unit.toLowerCase(Locale.ROOT).startsWith("m"))
            {
                if (numberPart.contains("."))
                {
                    return null;
                }
                total += (int) value;
            }
            else
            {
                total += (int) Math.round(value * 60.0);
            }

            matched = true;
            lastEnd = matcher.end();
        }

        if (matched)
        {
            String trailing = normalized.substring(lastEnd).trim();
            if (!trailing.isEmpty())
            {
                return null;
            }
            return total > 0 ? total : null;
        }

        try
        {
            int minutes = Integer.parseInt(normalized);
            return minutes > 0 ? minutes : null;
        }
        catch (NumberFormatException ex)
        {
            return null;
        }
    }

    private void updateRiskButtons(RiskLevel level)
    {
        RiskLevel effective = level != null ? level : RiskLevel.MEDIUM;
        btnRiskLow.setSelected(effective == RiskLevel.LOW);
        btnRiskMedium.setSelected(effective == RiskLevel.MEDIUM);
        btnRiskHigh.setSelected(effective == RiskLevel.HIGH);
    }

    private void applyRiskButtonStyle(JToggleButton button, String label, RiskLevel level, boolean selected)
    {
        Color background;
        Color textColor;

        if (selected)
        {
            switch (level)
            {
                case LOW:
                    background = RISK_LOW_SELECTED_COLOR;
                    textColor = Color.BLACK;
                    break;
                case HIGH:
                    background = RISK_HIGH_SELECTED_COLOR;
                    textColor = Color.WHITE;
                    break;
                case MEDIUM:
                default:
                    background = ColorScheme.BRAND_ORANGE;
                    textColor = Color.BLACK;
                    break;
            }
        }
        else
        {
            background = ColorScheme.DARKER_GRAY_COLOR;
            textColor = ColorScheme.TEXT_COLOR;
        }

        button.setBackground(background);
        button.setText(String.format("<html><font color='%s'>%s</font></html>", toHtmlColor(textColor), label));
    }

    private static String toHtmlColor(Color color)
    {
        return String.format("#%02X%02X%02X", color.getRed(), color.getGreen(), color.getBlue());
    }

    // ---------- UI wiring ----------
    private void applyRiskLevel(RiskLevel level, SuggestionManager suggestionManager, boolean updateButtons)
    {
        RiskLevel effective = level != null ? level : RiskLevel.MEDIUM;
        preferencesManager.setRiskLevel(effective);
        suggestionManager.setSuggestionNeeded(true);

        if (updateButtons)
        {
            updateRiskButtons(effective);
        }
    }

    private void applyTimeframe(int minutes, SuggestionManager suggestionManager, boolean updateSlider, boolean updateButtons)
    {
        preferencesManager.setTimeframe(minutes);
        suggestionManager.setSuggestionNeeded(true);

        if (updateSlider)
        {
            try
            {
                suppressTimeframeSliderEvents = true;
                timeframeSlider.setValue(minutesToPos(minutes));
            }
            finally
            {
                suppressTimeframeSliderEvents = false;
            }
            updateValueLabel(minutes);
        }

        if (updateButtons)
        {
            boolean isPreset = isPreset(minutes);
            if (!isPreset)
            {
                customExplicitlySelected = true;
            }

            if (customExplicitlySelected)
            {
                btn5m.setSelected(false);
                btn30m.setSelected(false);
                btn2h.setSelected(false);
                btn8h.setSelected(false);
                btnCustom.setSelected(true);
            }
            else
            {
                boolean matched = false;
                btn5m.setSelected(matched = (minutes == PRESET_5M));
                if (!matched) btn30m.setSelected(matched = (minutes == PRESET_30M));
                if (!matched) btn2h.setSelected(matched = (minutes == PRESET_2H));
                if (!matched) btn8h.setSelected(matched = (minutes == PRESET_8H));
                btnCustom.setSelected(!matched);
                customExplicitlySelected = !matched;
            }
            updateCustomVisibility();
        }
    }

    private JToggleButton createPresetButton(String label, int value, SuggestionManager suggestionManager)
    {
        JToggleButton button = new JToggleButton();
        button.addActionListener(e -> {
            customExplicitlySelected = false;
            applyTimeframe(value, suggestionManager, /*updateSlider*/ true, /*updateButtons*/ true);
            updateCustomVisibility(); // hides slider
        });
        button.setMargin(new Insets(2, 4, 2, 4));
        button.setFocusPainted(false);
        button.setOpaque(true);
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setForeground(ColorScheme.TEXT_COLOR);

        button.setText("<html><font color='rgb(198, 198, 198)'>" + label + "</font></html>");

        button.addChangeListener(e2 -> {
            if (button.isSelected())
            {
                button.setBackground(ColorScheme.BRAND_ORANGE);
                button.setText("<html><font color='black'>" + label + "</font></html>");
            }
            else
            {
                button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                button.setText("<html><font color='rgb(198, 198, 198)'>" + label + "</font></html>");
            }
        });

        return button;
    }

    private JToggleButton createCustomButton(String label, SuggestionManager suggestionManager)
    {
        JToggleButton button = new JToggleButton();
        button.addActionListener(e -> {
            customExplicitlySelected = true;
            // Selecting "..." reveals the slider and shows current value
            int current = clampMinutes(preferencesManager.getTimeframe());
            suppressTimeframeSliderEvents = true;
            timeframeSlider.setValue(minutesToPos(current));
            suppressTimeframeSliderEvents = false;
            updateValueLabel(current);
            updateCustomVisibility(); // shows slider
        });
        button.setMargin(new Insets(2, 4, 2, 4));
        button.setFocusPainted(false);
        button.setOpaque(true);
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setForeground(ColorScheme.TEXT_COLOR);

        button.setText("<html><font color='rgb(198, 198, 198)'>" + label + "</font></html>");

        button.addChangeListener(e2 -> {
            if (button.isSelected())
            {
                button.setBackground(ColorScheme.BRAND_ORANGE);
                button.setText("<html><font color='black'>" + label + "</font></html>");
            }
            else
            {
                button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                button.setText("<html><font color='rgb(198, 198, 198)'>" + label + "</font></html>");
            }
        });

        return button;
    }

    private JToggleButton createRiskButton(String label, RiskLevel level, SuggestionManager suggestionManager)
    {
        JToggleButton button = new JToggleButton();
        button.addActionListener(e -> applyRiskLevel(level, suggestionManager, true));
        button.setMargin(new Insets(2, 4, 2, 4));
        button.setFocusPainted(false);
        button.setOpaque(true);
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        button.addChangeListener(e2 -> applyRiskButtonStyle(button, label, level, button.isSelected()));
        applyRiskButtonStyle(button, label, level, false);

        return button;
    }

    public void refresh()
    {
        if (!SwingUtilities.isEventDispatchThread())
        {
            SwingUtilities.invokeLater(this::refresh);
            return;
        }

        int tf = clampMinutes(preferencesManager.getTimeframe());

        if (!customExplicitlySelected && !isPreset(tf))
        {
            customExplicitlySelected = true;
        }

        if (customExplicitlySelected)
        {
            btn5m.setSelected(false);
            btn30m.setSelected(false);
            btn2h.setSelected(false);
            btn8h.setSelected(false);
            btnCustom.setSelected(true);
        }
        else
        {
            boolean matched = false;
            btn5m.setSelected(matched = (tf == PRESET_5M));
            if (!matched) btn30m.setSelected(matched = (tf == PRESET_30M));
            if (!matched) btn2h.setSelected(matched = (tf == PRESET_2H));
            if (!matched) btn8h.setSelected(matched = (tf == PRESET_8H));
            btnCustom.setSelected(!matched);
            customExplicitlySelected = !matched;
        }

        // Sync slider & label
        try
        {
            suppressTimeframeSliderEvents = true;
            timeframeSlider.setValue(minutesToPos(tf));
        }
        finally
        {
            suppressTimeframeSliderEvents = false;
        }
        updateValueLabel(tf);

        // Sync risk level buttons
        updateRiskButtons(preferencesManager.getRiskLevel());

        // Show/hide custom area
        updateCustomVisibility();
    }
}

package com.flippingcopilot.ui;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;

@Singleton
public class GeHistoryTransactionButton extends JButton {

    @Inject
    public GeHistoryTransactionButton() {
        super("Add GE history transactions");
        setupButton();
    }
    
    private void setupButton() {
        setFont(FontManager.getRunescapeBoldFont());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        setBorder(new EmptyBorder(8, 20, 8, 20));
        setOpaque(true);
        setFocusable(false);
        setVisible(false);
        
        // Add hover effect
        addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e) {
                setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
            }
            
            @Override
            public void mouseExited(java.awt.event.MouseEvent e) {
                setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });
    }
}
/*
 * Copyright (c) 2023, LlemonDuck <napkinorton@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import com.flippingcopilot.model.ItemIdName;
import org.apache.commons.text.similarity.JaroWinklerDistance;
import org.apache.commons.text.similarity.LongestCommonSubsequence;
import org.apache.commons.text.similarity.SimilarityScore;

import javax.inject.Singleton;
import java.util.function.ToDoubleFunction;

@Singleton
public class FuzzySearchScorer
{

	// can be swapped, but i found jaro-winkler to do well considering the variable length of inputs
	// whereas levenshtein biases toward strings of same len, regardless of overlap
	private final SimilarityScore<Double> baseAlgorithm = new JaroWinklerDistance();

	public Double score(String query, String itemName)
	{
		query = query.toLowerCase().replace('-', ' ');
		itemName = itemName.toLowerCase().replace('-', ' ');

		// we raise the score for longest substring of a word, scoring within [0,1]
		String[] queryWords = query.split(" ");
		String[] itemWords = itemName.split(" ");
		double lcsScore = 0.0;
		for (String queryWord : queryWords)
		{
			for (String itemWord : itemWords)
			{
				int lcsLen = new LongestCommonSubsequence().longestCommonSubsequence(queryWord, itemWord).length();
				lcsScore = Math.max(lcsScore, ((double) lcsLen) / queryWord.length());
			}
		}

		// and also raise the score for string "closeness", but strongly prefer high closeness, scoring within [-0.5,0.5]
		double proximityScore = Math.log10(10 * baseAlgorithm.apply(query, itemName)) - 0.5;

		// subtract 1.0 to filter out low-scoring results
		return lcsScore + proximityScore - 1.0;
	}

	public ToDoubleFunction<ItemIdName> comparator(String query)
	{
		// We do this so that for example the items "Anti-venom ..." are still at the top
		// when searching "anti venom"
		return item -> score(
			query.toLowerCase().replace('-', ' '),
			item.getName().toLowerCase().replace('-', ' ')
		);
	}

}

package com.flippingcopilot.ui;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import java.awt.*;

public class GpDropOverlay extends Overlay {
    private final OverlayManager overlayManager;
    private final long startTime;
    private final Point startPosition = new Point(); // Starting position of the text
    final TextComponent textComponent = new TextComponent();

    public GpDropOverlay(OverlayManager overlayManager, Client client, long profit, int slot) {
        this.overlayManager = overlayManager;
        this.startTime = System.currentTimeMillis();

        Widget slotWidget = client.getWidget(465, slot + 7);
        if (slotWidget == null) {
            return;
        }
        startPosition.x = slotWidget.getCanvasLocation().getX() + 35;
        startPosition.y = slotWidget.getCanvasLocation().getY() + 75;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        String absProfitText = UIUtilities.quantityToRSDecimalStack(Math.abs(profit), false);
        String profitText = (profit >= 0 ? "+ " : "- ") + absProfitText + " gp";
        textComponent.setText(profitText);
        textComponent.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 16f));
        if (profit < 0) {
            textComponent.setColor(Color.RED);
        } else {
            textComponent.setColor(Color.GREEN);
        }
        overlayManager.add(this);
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        long elapsed = System.currentTimeMillis() - startTime;
        if (elapsed > 3000) { // Display for 5 seconds
            overlayManager.remove(this);
            return null;
        }

        // Calculate the upward movement. Adjust the divisor to control the speed.
        int yOffset = (int) (elapsed / 50); // Moves up 1 pixel every 50ms

        // Ensure the text moves upwards by subtracting yOffset from the starting Y position
        Point currentPosition = new Point(startPosition.x, startPosition.y - yOffset);
        textComponent.setPosition(currentPosition);
        textComponent.render(graphics);

        return null;
    }
}
package com.flippingcopilot.ui.flipsdialog;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.function.Function;

public class AxisCalculator {

    public static final int DAY_SECONDS = 24*60*60;

    public static List<Tick> calculateYTicks(long minValue, long maxValue, int a) {
        long range = maxValue - minValue;
        long roughSpacing = range / a;
        long magnitude = 1;
        while (magnitude * 10 <= roughSpacing) {
            magnitude *= 10;
        }
        // Round to nearest 1, 2, 5, or 10 * magnitude
        long step;
        if (roughSpacing <= magnitude) {
            step = magnitude;
        } else if (roughSpacing <= 2 * magnitude) {
            step = 2 * magnitude;
        } else if (roughSpacing <= 5 * magnitude) {
            step = 5 * magnitude;
        } else {
            step = 10 * magnitude;
        }

        Function<Long, String> ff = formatFunc(range);

        List<Tick> ticks = new ArrayList<>();
        ticks.add(new Tick(0, "0"));
        long value = 0;
        while (minValue < value) {
            value -= step;
            ticks.add(0, new Tick(value, ff.apply(value)));
        }
        value = 0;
        while (maxValue > value) {
            value += step;
            ticks.add(new Tick(value, ff.apply(value)));
        }
        return ticks;
    }


    public static Function<Long, String> formatFunc(long range) {
        return (v) -> {
            String sign = v < 0 ? "-" : "";
            long absProfit = Math.abs(v);
            if (range >= 1_000_000_000) {
                return sign + String.format("%.1fB", absProfit / 1_000_000_000.0).replace(".0B", "B");
            } else if (range >= 1_000_000) {
                return sign + String.format("%.1fM", absProfit / 1_000_000.0).replace(".0M", "M");
            } else if (range >= 1_000) {
                return sign + String.format("%.1fK", absProfit / 1_000.0).replace(".0K", "K");
            } else {
                return sign + absProfit;
            }
        };
    }

    public static List<Tick> calculateXTicks(int minXValue, int maxXValue) {
        int rangeInDays = (maxXValue - minXValue) / DAY_SECONDS;
        int step = Math.max(rangeInDays / 10, 1)*DAY_SECONDS;
        SimpleDateFormat dateFormat = new SimpleDateFormat("MMM d");
        List<Tick> ticks = new ArrayList<>();
        int value = (minXValue / DAY_SECONDS) * DAY_SECONDS;
        while(value <= maxXValue) {
            if( value >= minXValue ) {
                ticks.add(new Tick(value, dateFormat.format(new Date(value * 1000L))));
            }
            value+= step;
        }
        return ticks;
    }
}

package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.FlipManager;
import com.flippingcopilot.model.FlipV2;
import com.flippingcopilot.model.IntervalTimeUnit;
import com.flippingcopilot.model.SortDirection;
import joptsimple.internal.Strings;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Named;
import java.io.FileWriter;
import java.io.IOException;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;
import java.util.function.Predicate;


@Slf4j
public class FlipFilterAndSort {

    public static final int DEFAULT_PAGE_SIZE = 50;

    // Sort comparators map
    private static final Map<String, Comparator<FlipV2>> SORT_COMPARATORS = new HashMap<>();

    static {
        // Last sell time - special handling for non-closed trades
        SORT_COMPARATORS.put("Last sell time", Comparator.comparing(FlipV2::lastTransactionTime).reversed());
        SORT_COMPARATORS.put("First buy time", Comparator.comparing(FlipV2::getOpenedTime));
        SORT_COMPARATORS.put("Account", Comparator.comparing(FlipV2::getAccountId));
        SORT_COMPARATORS.put("Item", Comparator.comparing(f -> f.getCachedItemName() != null ? f.getCachedItemName() : ""));
        SORT_COMPARATORS.put("Status", Comparator.comparing(FlipV2::getStatus));
        SORT_COMPARATORS.put("Bought", Comparator.comparing(FlipV2::getOpenedQuantity));
        SORT_COMPARATORS.put("Sold", Comparator.comparing(FlipV2::getClosedQuantity));
        SORT_COMPARATORS.put("Avg. buy price", Comparator.comparing(FlipV2::getSpent));
        SORT_COMPARATORS.put("Avg. sell price", Comparator.comparing(FlipV2::getReceivedPostTax));
        SORT_COMPARATORS.put("Tax", Comparator.comparing(FlipV2::getTaxPaid));
        SORT_COMPARATORS.put("Profit", Comparator.comparing(FlipV2::getProfit));
        SORT_COMPARATORS.put("Profit ea.", Comparator.comparing(f -> f.getClosedQuantity() > 0 ? f.getProfit() / f.getClosedQuantity() : 0L));
    }

    // dependencies
    private final FlipManager flipManager;
    private final Consumer<List<FlipV2>> flipsCallback;
    private final Consumer<Integer> totalPagesChangedCallback;
    private final Consumer<Boolean> slowLoadingCallback;
    private final ExecutorService executorService;
    private final CopilotLoginManager copilotLoginManager;
    private final ItemController itemController;

    // state
    private List<FlipV2> cachedFlips = new ArrayList<>();
    private Integer cachedAccountId = null;
    private int cachedIntervalStartTime = Integer.MIN_VALUE;
    private boolean cachedIncludeBuyingFlips = true;
    private Set<Integer> cachedFilteredItems = new HashSet<>();
    private SortDirection cachedSortDirection = SortDirection.DESC;
    private String cachedSortColumn = "";

    private int intervalStartTime = 1;
    private Integer accountId = null;
    private boolean includeBuyingFlips = true;
    @Getter
    private String sortColumn = "Last sell time";
    @Getter
    private SortDirection sortDirection = SortDirection.DESC;
    private Set<Integer> filteredItems = new HashSet<>();
    @Getter
    private int pageSize = DEFAULT_PAGE_SIZE;
    private int totalFlips = 1;
    private int page = 1;

    public FlipFilterAndSort(FlipManager flipManager,
                             Consumer<List<FlipV2>> flipsCallback,
                             Consumer<Integer> totalPagesChangedCallback,
                             Consumer<Boolean> slowLoadingCallback,
                             @Named("copilotExecutor") ExecutorService executorService,
                             CopilotLoginManager copilotLoginManager, ItemController itemController) {
        this.flipManager = flipManager;

        this.flipsCallback = flipsCallback;
        this.totalPagesChangedCallback = totalPagesChangedCallback;
        this.slowLoadingCallback = slowLoadingCallback;
        this.executorService = executorService;
        this.copilotLoginManager = copilotLoginManager;
        this.itemController = itemController;
    }

    public synchronized void setIncludeBuyingFlips(boolean b) {
        includeBuyingFlips = b;
        reloadFlips(true, false);
    }

    public synchronized void setInterval(IntervalTimeUnit timeUnit, Integer value) {
        switch (timeUnit) {
            case ALL:
                intervalStartTime = 1;
                break;
            case SESSION:
                // TODO: Get session start time from SessionManager
                intervalStartTime = (int) Instant.now().getEpochSecond() - 3600; // Default to 1 hour ago
                break;
            default:
                intervalStartTime = (int) (Instant.now().getEpochSecond() - (long) value * timeUnit.getSeconds());
        }
        reloadFlips(true, false);
    }

    public synchronized void setAccountId(Integer accountId) {
        if(!Objects.equals(accountId,this.accountId)) {
            this.accountId = accountId;
            reloadFlips(true, false);
        }
    }

    public synchronized Set<Integer> getFilteredItems() {
        return new HashSet<>(filteredItems);
    }

    public synchronized void setFilteredItems(Set<Integer> filteredItems) {
        if(!Objects.equals(filteredItems, this.filteredItems)) {
            this.filteredItems = filteredItems;
            reloadFlips(true, false);
        }
    }

    public synchronized void setPageSize(int newSize) {
        if(newSize != pageSize) {
            pageSize = newSize;
            reloadFlips(true, false);
        }
    }

    public synchronized void setSortColumn(String sortColumn) {
        if(!sortColumn.equals(this.sortColumn)) {
            this.sortColumn = sortColumn;
            reloadFlips(false, false);
        }
    }

    public synchronized void setSortDirection(SortDirection sortDirection) {
        if(!Objects.equals(sortDirection, this.sortDirection)) {
            this.sortDirection = sortDirection;
            reloadFlips(false, false);
        }
    }

    public synchronized void setPage(int page) {
        if(page != this.page) {
            this.page = page;
            reloadFlips(false, false);
        }
    }
    public void reloadFlips(boolean totalPagesMaybeChanged, boolean forceReload) {
        executorService.submit(() -> _reloadFlips(totalPagesMaybeChanged, forceReload));
    }

    private synchronized void _reloadFlips(boolean totalPagesMaybeChanged, boolean forceReload) {
        try {
            if (canUseFlipsManager()) {
                if (totalPagesMaybeChanged || forceReload) {
                    totalFlips = flipManager.calculateStats(intervalStartTime, accountId).flipsMade;
                    totalPagesChangedCallback.accept(1 + totalFlips / pageSize);
                }
                flipsCallback.accept(flipManager.getPageFlips(page, pageSize, intervalStartTime, accountId));
            } else {
                slowLoadingCallback.accept(true);
                boolean cachedFlipsOutOfDate = !Objects.equals(cachedAccountId, accountId) || !cachedFilteredItems.equals(filteredItems) || cachedIntervalStartTime != intervalStartTime || cachedIncludeBuyingFlips != includeBuyingFlips;
                boolean cachedSortOutOfDate = cachedFlipsOutOfDate || !cachedSortColumn.equals(sortColumn) || !cachedSortDirection.equals(sortDirection);
                log.debug("cachedFlipsOutOfDate={}, cachedSortOutOfDate={}", cachedFlipsOutOfDate, cachedSortOutOfDate);
                if (cachedFlipsOutOfDate || forceReload) {
                    log.debug("reloading cached flips");
                    cachedAccountId = accountId;
                    cachedFilteredItems.clear();
                    cachedFilteredItems.addAll(filteredItems);
                    cachedIntervalStartTime = intervalStartTime;
                    cachedIncludeBuyingFlips = includeBuyingFlips;
                    cachedFlips.clear();
                    Predicate<FlipV2> flipFilter = filteredItems.isEmpty() ? f -> true : f -> filteredItems.contains(f.getItemId());
                    flipManager.aggregateFlips(intervalStartTime, accountId, includeBuyingFlips, (f) -> {
                        if(flipFilter.test(f)) {
                            f.setCachedItemName(itemController.getItemName(f.getItemId()));
                            cachedFlips.add(f);
                        }
                    });
                    log.debug("loaded {} cached flips", cachedFlips.size());
                }

                if (totalPagesMaybeChanged || forceReload) {
                    log.debug("updating total pages");
                    int totalPages = 1 + cachedFlips.size() / pageSize;
                    totalPagesChangedCallback.accept(totalPages);
                    log.debug("updated total pages to {} cached flips", totalPages);
                }

                if (cachedSortOutOfDate || forceReload) {
                    log.debug("re-sorting cached flips");
                    cachedSortColumn = sortColumn;
                    cachedSortDirection = sortDirection;

                    // Apply sorting
                    Comparator<FlipV2> comparator = SORT_COMPARATORS.get(sortColumn);
                    if (comparator != null) {
                        if (sortDirection == SortDirection.ASC) {
                            comparator = comparator.reversed();
                        }
                        cachedFlips.sort(comparator);
                    }
                    log.debug("re-sorted flips");
                }
                int startIndex = (page - 1) * pageSize;
                int endIndex = Math.min(startIndex + pageSize, cachedFlips.size());
                slowLoadingCallback.accept(false);
                flipsCallback.accept(cachedFlips.subList(startIndex, endIndex));
                log.debug("_reloadFlips end");
            }
        } catch (Exception e) {
            log.warn("error filtering/sorting flips", e);
        }
    }

    private boolean canUseFlipsManager() {
        return !includeBuyingFlips && sortDirection == SortDirection.DESC && sortColumn.equals("Last sell time") && filteredItems.isEmpty();
    }

    public synchronized void writeCsvRecords(FileWriter writer) {
        try {
            writer.write(Strings.join(FlipsPanel.COLUMN_NAMES, ","));
        } catch (IOException e) {
            throw new RuntimeException("writing flips CSV header", e);
        }

        Consumer<FlipV2> c = f -> {
            try {
                writer.write("\n"+toCSVRow(f));
            } catch (IOException e) {
                throw new RuntimeException("writing flips CSV row", e);
            }
        };
        if (canUseFlipsManager()) {
            flipManager.aggregateFlips(intervalStartTime, accountId, includeBuyingFlips, c);
        } else {
            cachedFlips.forEach(c);
        }
    }

    private String toCSVRow(FlipV2 f) {
        Map<Integer, String> accountIdToDisplayName = copilotLoginManager.accountIDToDisplayNameMap();
        long profitPerItem = f.getClosedQuantity() > 0 ? f.getProfit() / f.getClosedQuantity() : 0L;

        return String.join(",",
                formatTimestampISO(f.getOpenedTime()),
                formatTimestampISO(f.getClosedTime()),
                escapeCSV(accountIdToDisplayName.getOrDefault(f.getAccountId(), "Display name not loaded")),
                escapeCSV(f.getCachedItemName()),
                f.getStatus().name(),
                String.valueOf(f.getOpenedQuantity()),
                String.valueOf(f.getClosedQuantity()),
                String.valueOf(f.getSpent() / f.getOpenedQuantity()),
                String.valueOf(f.getClosedQuantity() == 0 ? 0 : (f.getReceivedPostTax() + f.getTaxPaid()) / f.getClosedQuantity()),
                String.valueOf(f.getTaxPaid()),
                String.valueOf(f.getProfit()),
                String.valueOf(profitPerItem)
        );
    }

    public static String formatTimestampISO(int timestamp) {
        if (timestamp == 0) {
            return "";
        }
        return Instant.ofEpochSecond(timestamp).toString();
    }

    public static String escapeCSV(String value) {
        if (value == null) {
            return "";
        }
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.model.AckedTransaction;
import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.IntStream;
import java.util.stream.Stream;

@AllArgsConstructor
public class TransactionDataWrapper {

    // 1 million transactions would be ~56MB in memory. Average transactions per user as of Aug 2025 is ~5000
    private volatile byte[] data;

    public List<AckedTransaction> getPage(Set<Integer> filteredItems, Integer selectedAccount, int page, int pageSize) {
        int n = data.length / AckedTransaction.RAW_SIZE;
        int toSkip = pageSize*(page-1);
        int found = 0;
        List<AckedTransaction> pageTransactions = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            AckedTransaction t = atIndex(i);
            if((filteredItems.isEmpty() || filteredItems.contains(t.getItemId())) && (selectedAccount == null || selectedAccount.equals(t.getAccountId()))){
                if(found < toSkip) {
                    toSkip--;
                    found++;
                } else {
                    pageTransactions.add(t);
                    found++;
                    if (found == pageSize) {
                        return pageTransactions;
                    }
                }
            }
        }
        return pageTransactions;
    }

    public int totalRecords(Set<Integer> filteredItems, Integer selectedAccount) {
        int found =0;
        int n = data.length / AckedTransaction.RAW_SIZE;
        for(int i = 0; i < n; i++) {
            AckedTransaction t = atIndex(i);
            if((filteredItems.isEmpty() || filteredItems.contains(t.getItemId())) && (selectedAccount == null || selectedAccount.equals(t.getAccountId()))){
                found++;
            }
        }
        return found;
    }

    private AckedTransaction atIndex(int n) {
        byte[] record = new byte[AckedTransaction.RAW_SIZE];
        System.arraycopy(data, AckedTransaction.RAW_SIZE*n, record, 0, AckedTransaction.RAW_SIZE);
        return AckedTransaction.fromRaw(record);
    }

    public Stream<AckedTransaction> stream(Set<Integer> filteredItems, Integer selectedAccount) {
        int totalTransactions = (data.length) / AckedTransaction.RAW_SIZE;
        return IntStream.range(0, totalTransactions)
                .mapToObj(this::atIndex)
                .filter(t -> (filteredItems.isEmpty() || filteredItems.contains(t.getItemId()))
                        && (selectedAccount == null || selectedAccount.equals(t.getAccountId())));
    }


    public void deleteOne(Predicate<AckedTransaction> predicate) {
        int totalTransactions = (data.length) / AckedTransaction.RAW_SIZE;
        for (int i = 0; i < totalTransactions; i++) {
            AckedTransaction transaction = atIndex(i);
            if (predicate.test(transaction)) {
                byte[] newData = new byte[data.length - AckedTransaction.RAW_SIZE];
                System.arraycopy(data, 0, newData, 0, i * AckedTransaction.RAW_SIZE);
                int rightSide = (totalTransactions - i - 1) * AckedTransaction.RAW_SIZE;
                if (rightSide > 0) {
                    System.arraycopy(data, (i + 1) * AckedTransaction.RAW_SIZE, newData, i * AckedTransaction.RAW_SIZE, rightSide);
                }
                data = newData;
                break;
            }
        }
    }

    public void update(AckedTransaction t) {
        byte[] newRaw = t.toRaw();
        int totalTransactions = (data.length) / AckedTransaction.RAW_SIZE;
        for (int i = 0; i < totalTransactions; i++) {
            int o = i * AckedTransaction.RAW_SIZE;
            // Compare first 16 bytes to match by ID
            if (data[o] == newRaw[0] && data[o + 1] == newRaw[1] && data[o + 2] == newRaw[2] && data[o + 3] == newRaw[3] &&
                    data[o + 4] == newRaw[4] && data[o + 5] == newRaw[5] && data[o + 6] == newRaw[6] && data[o + 7] == newRaw[7] &&
                    data[o + 8] == newRaw[8] && data[o + 9] == newRaw[9] && data[o + 10] == newRaw[10] && data[o + 11] == newRaw[11] &&
                    data[o + 12] == newRaw[12] && data[o + 13] == newRaw[13] && data[o + 14] == newRaw[14] && data[o + 15] == newRaw[15]) {
                // Overwrite the entire transaction with new raw data
                System.arraycopy(newRaw, 0, data, o, AckedTransaction.RAW_SIZE);
                break;
            }
        }
    }
}

package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.Paginator;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.ItemSearchMultiSelect;
import com.flippingcopilot.util.GeTax;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;

import static com.flippingcopilot.ui.flipsdialog.FlipFilterAndSort.escapeCSV;
import static com.flippingcopilot.ui.flipsdialog.FlipFilterAndSort.formatTimestampISO;
import static com.flippingcopilot.util.DateUtil.formatEpoch;

@Slf4j
public class TransactionsPanel extends JPanel {

    private static final UUID ZERO_UUID = new UUID(0L, 0L);
    private static final Integer[] PAGE_SIZE_OPTIONS = {10, 25, 50, 100, 200, 500, 1000, 2000};
    private static final int DEFAULT_PAGE_SIZE = 200;

    private final String[] columnNames = {
            "Timestamp", "Account", "Side", "Item", "Quantity", "Paid/Received", "Tax", "Price ea.", "Part of Flip"
    };

    // dependencies
    private final CopilotLoginManager copilotLoginManager;
    private final ItemController itemController;
    private final ExecutorService executorService;
    private final ApiRequestHandler apiRequestHandler;
    private final FlipManager flipManager;

    // ui components
    private final DefaultTableModel tableModel;
    private final JTable table;
    private final Paginator paginatorPanel;
    private final Spinner spinner;
    private final JScrollPane scrollPane;
    private final JPanel spinnerOverlay;
    private final ItemSearchMultiSelect searchField;
    private final JComboBox<Integer> pageSizeComboBox;
    private final JLabel loadingText;
    private AccountDropdown accountDropdown;
    private JLabel errorLabel;
    private JButton downloadButton;

    // state
    private final AtomicBoolean loadTransactionsTriggered = new AtomicBoolean(false);
    private TransactionDataWrapper transactionDataWrapper;
    private volatile Set<Integer> filteredItems = new HashSet<>();
    private volatile int pageSize = DEFAULT_PAGE_SIZE;
    private volatile int totalPages = 1;
    private volatile int currentPage = 1;
    private volatile Integer selectedAccountId;
    private volatile List<AckedTransaction> currentTransactions = new ArrayList<>();

    public TransactionsPanel(CopilotLoginManager copilotLoginManager,
                             ItemController itemController,
                             @Named("copilotExecutor") ExecutorService executorService,
                             ApiRequestHandler apiRequestHandler,
                             FlippingCopilotConfig config,
                             FlipManager flipManager) {
        this.copilotLoginManager = copilotLoginManager;
        this.itemController = itemController;
        this.executorService = executorService;
        this.apiRequestHandler = apiRequestHandler;
        this.flipManager = flipManager;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        paginatorPanel = new Paginator((n) -> {
            if(n != currentPage) {
                currentPage = n;
                applyFilters(false);
            }
        });

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Create left panel with dropdowns
        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        searchField = new ItemSearchMultiSelect(
                () -> new HashSet<>(filteredItems),
                this.itemController::allItemIds,
                this.itemController::search,
                items -> {
                    if (!Objects.equals(items, this.filteredItems)) {
                        this.filteredItems = new HashSet<>(items);
                        currentPage = 1;
                        paginatorPanel.setPageNumber(1);
                        applyFilters(true);
                    }
                },
                "Items filter...",
                SwingUtilities.getWindowAncestor(this));
        searchField.setMinimumSize(new Dimension(300, 0));
        searchField.setToolTipText("Search by item name");

        // Account dropdown
        accountDropdown = new AccountDropdown(
                this.copilotLoginManager::displayNameToAccountIdMap,
                accountId -> {
                    if (!Objects.equals(accountId, this.selectedAccountId)) {
                        currentPage = 1;
                        paginatorPanel.setPageNumber(currentPage);
                        this.selectedAccountId = accountId;
                        applyFilters(true);
                    }
                },
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        accountDropdown.setPreferredSize(new Dimension(120, accountDropdown.getPreferredSize().height));
        accountDropdown.setToolTipText("Select account");
        accountDropdown.refresh();

        // Page size combo box
        pageSizeComboBox = new JComboBox<>(PAGE_SIZE_OPTIONS);
        pageSizeComboBox.setSelectedItem(pageSize);
        pageSizeComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizeComboBox.setFocusable(false);
        pageSizeComboBox.setToolTipText("Page size");
        pageSizeComboBox.addActionListener(e -> {
            int newPageSize = (Integer) pageSizeComboBox.getSelectedItem();
            if (newPageSize != this.pageSize) {
                this.pageSize = newPageSize;
                currentPage = 1;
                paginatorPanel.setPageNumber(1);
                applyFilters(true);
            }
        });

        leftPanel.add(searchField);
        leftPanel.add(Box.createRigidArea(new Dimension(3, 0)));
        leftPanel.add(accountDropdown);

        // Create right panel with download button
        JPanel rightPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 0, 0));
        rightPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        downloadButton = new JButton("Download");
        downloadButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        downloadButton.setFocusable(false);
        downloadButton.setToolTipText("Download transactions as CSV");
        downloadButton.addActionListener(e -> downloadTransactionsCSV());

        JButton refreshButton = new JButton("Refresh");
        refreshButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        refreshButton.setFocusable(false);
        refreshButton.setToolTipText("Refresh transactions");
        refreshButton.addActionListener(e -> {
            loadTransactionsTriggered.set(false);
            loadTransactionsIfNeeded();
        });

        rightPanel.add(refreshButton);
        rightPanel.add(Box.createRigidArea(new Dimension(5, 0)));
        rightPanel.add(downloadButton);

        topPanel.add(leftPanel, BorderLayout.WEST);
        topPanel.add(rightPanel, BorderLayout.EAST);
        add(topPanel, BorderLayout.NORTH);

        // Create table
        tableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        table = new JTable(tableModel);
        setupTable(config);

        // Create layered pane for spinner overlay
        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        layeredPane.setOpaque(true);

        // Create error label
        errorLabel = new JLabel("Error loading transactions from server", SwingConstants.CENTER);
        errorLabel.setFont(errorLabel.getFont().deriveFont(14f));
        errorLabel.setVisible(false);

        spinner = new Spinner();
        spinner.show();

        // Create spinner overlay with loading text
        spinnerOverlay = new JPanel(new GridBagLayout());
        spinnerOverlay.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spinnerOverlay.setOpaque(true);

        // Create a panel to hold the loading text and spinner horizontally
        JPanel loadingPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 0));
        loadingPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        loadingPanel.setOpaque(false);

        // Create loading text label
        loadingText = new JLabel("Downloading transactions..");
        loadingText.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        loadingText.setFont(loadingText.getFont().deriveFont(14f));

        // Add text and spinner to the loading panel
        loadingPanel.add(loadingText);
        loadingPanel.add(spinner);

        // Add the loading panel to the spinner overlay
        spinnerOverlay.add(loadingPanel);
        spinnerOverlay.setVisible(false); // Initially hidden until first access

        scrollPane = new JScrollPane(table);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);

        layeredPane.setLayout(new OverlayLayout(layeredPane));
        layeredPane.add(spinnerOverlay, JLayeredPane.MODAL_LAYER);
        layeredPane.add(errorLabel, JLayeredPane.PALETTE_LAYER);
        layeredPane.add(scrollPane, JLayeredPane.DEFAULT_LAYER);

        add(layeredPane, BorderLayout.CENTER);

        // Create bottom panel with pagination
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel pageSizePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        pageSizePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizePanel.setBorder(BorderFactory.createEmptyBorder(4, 0, 0, 0));
        JLabel pageSizeLabel = new JLabel("Page size:");
        pageSizeLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        pageSizePanel.add(pageSizeLabel);
        pageSizePanel.add(pageSizeComboBox);

        // Adjust paginator border to account for page size panel width
        paginatorPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createEmptyBorder(0, 0, 0, pageSizePanel.getPreferredSize().width),
                paginatorPanel.getBorder()));

        bottomPanel.add(pageSizePanel, BorderLayout.WEST);
        bottomPanel.add(paginatorPanel, BorderLayout.CENTER);

        add(bottomPanel, BorderLayout.SOUTH);
    }

    /**
     * Load transactions when the panel is first shown
     */
    public void loadTransactionsIfNeeded() {
        if (loadTransactionsTriggered.compareAndSet(false, true)) {
            loadTransactions();
        }
    }

    private void setupTable(FlippingCopilotConfig config) {
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        table.setSelectionBackground(ColorScheme.BRAND_ORANGE);
        table.setSelectionForeground(Color.WHITE);
        table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
        table.setRowHeight(25);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
        table.setFocusable(false);

        // Disable sorting
        table.setRowSorter(null);
        table.getTableHeader().setReorderingAllowed(false);

        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            private void showPopup(MouseEvent e) {
                int row = table.rowAtPoint(e.getPoint());
                if (row >= 0 && row < table.getRowCount()) {
                    table.setRowSelectionInterval(row, row);
                    showTransactionMenu(e, row);
                }
            }
        });

        // Setup renderers
        DefaultTableCellRenderer moneyRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    setText(FlipsPanel.GP_FORMAT.format(value));
                    setHorizontalAlignment(RIGHT);
                }
                return c;
            }
        };

        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        DefaultTableCellRenderer booleanRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Boolean) {
                    setText((Boolean) value ? "Yes" : "No");
                    setHorizontalAlignment(CENTER);
                }
                return c;
            }
        };

        // Apply renderers to columns
        table.getColumnModel().getColumn(1).setCellRenderer(centerRenderer); // Account
        table.getColumnModel().getColumn(2).setCellRenderer(centerRenderer); // Side
        table.getColumnModel().getColumn(4).setCellRenderer(centerRenderer); // Quantity
        table.getColumnModel().getColumn(5).setCellRenderer(moneyRenderer); // Paid/Received
        table.getColumnModel().getColumn(6).setCellRenderer(moneyRenderer); // Tax
        table.getColumnModel().getColumn(7).setCellRenderer(moneyRenderer); // Price ea.
        table.getColumnModel().getColumn(8).setCellRenderer(booleanRenderer); // Part of Flip
    }

    private void loadTransactions() {
        setSpinnerVisible(true);
        errorLabel.setVisible(false);
        apiRequestHandler.asyncLoadTransactionsData(
                transactionsData -> {
                    SwingUtilities.invokeLater(() -> {
                        setSpinnerVisible(false);
                        transactionDataWrapper = new TransactionDataWrapper(transactionsData);
                        applyFilters(true);
                    });
                },
                error -> {
                    SwingUtilities.invokeLater(() -> {
                        setSpinnerVisible(false);
                        errorLabel.setVisible(true);
                        log.error("Failed to load transactions: {}", error);
                    });
                }
        );
    }

    private void setSpinnerVisible(boolean visible) {
        if (visible) {
            spinnerOverlay.setVisible(true);
            table.setEnabled(false);
        } else {
            spinnerOverlay.setVisible(false);
            table.setEnabled(true);
        }
    }

    private void applyFilters(boolean updateTotalPages) {
        executorService.submit(() -> {
            synchronized (this) {
                try {
                    if (updateTotalPages) {
                        int n = transactionDataWrapper.totalRecords(filteredItems, selectedAccountId);
                        totalPages = (int) Math.ceil((double) n / (double) pageSize);
                        paginatorPanel.setTotalPagesWithoutEffect(totalPages);
                    }
                    List<AckedTransaction> txs = transactionDataWrapper.getPage(filteredItems, selectedAccountId, currentPage, pageSize);
                    SwingUtilities.invokeLater(() -> updateTable(txs));
                } catch (Exception e) {
                    errorLabel.setText("Error decoding transaction data.");
                    errorLabel.setVisible(true);
                    log.error("loading transaction page", e);
                }
            }
        });
    }

    private void updateTable(List<AckedTransaction> txs) {
        currentTransactions = txs;
        tableModel.setRowCount(0);
        Map<Integer, String> accountIdToDisplayName = copilotLoginManager.accountIDToDisplayNameMap();

        for (AckedTransaction tx : txs) {
            int absQuantity = Math.abs(tx.getQuantity());
            long paidReceived = Math.abs(tx.getAmountSpent());
            long priceEa = tx.getPrice();
            Object[] row = {
                    formatEpoch(tx.getTime()),
                    accountIdToDisplayName.getOrDefault(tx.getAccountId(), "Unknown"),
                    tx.getQuantity() > 0 ? "BUY" : "SELL",
                    itemController.getItemName(tx.getItemId()),
                    absQuantity,
                    paidReceived,
                    calculateTax(tx),
                    priceEa,
                    !ZERO_UUID.equals(tx.getClientFlipId()),
            };
            tableModel.addRow(row);
        }
    }

    private long calculateTax(AckedTransaction tx) {
        if (tx.getQuantity() < 0) {
            int pricePerItem = tx.getAmountSpent() / tx.getQuantity();
            int pricePostTax = GeTax.getPostTaxPrice(tx.getItemId(), pricePerItem);
            return (long)(pricePerItem - pricePostTax) * tx.getQuantity();
        }
        return 0;
    }

    private void showTransactionMenu(MouseEvent e, int row) {
        if (row >= currentTransactions.size()) {
            return;
        }
        AckedTransaction transaction = currentTransactions.get(row);
        JPopupMenu menu = new JPopupMenu();

        if (!ZERO_UUID.equals(transaction.getClientFlipId())) {
            JMenuItem orphanItem = new JMenuItem("Remove from flip");
            orphanItem.addActionListener(evt -> {
                int result = JOptionPane.showConfirmDialog(this,
                        "Are you sure you want to remove the transaction from its flip? The flip and any profit will also be updated. This operation cannot be undone.",
                        "Confirm Action",
                        JOptionPane.YES_NO_OPTION);
                if (result == JOptionPane.YES_OPTION) {
                    loadingText.setText("");
                    setSpinnerVisible(true);
                    log.info("orphaning transaction with ID: {}", transaction.getId());

                    BiConsumer<Integer, List<FlipV2>> onSuccess = (userId, flips) -> {
                        flipManager.mergeFlips(flips, userId);
                        setSpinnerVisible(false);
                        transaction.setClientFlipId(ZERO_UUID);
                        transactionDataWrapper.update(transaction);
                        applyFilters(false);
                    };

                    Runnable onFailure = () -> {
                        setSpinnerVisible(false);
                        JOptionPane.showMessageDialog(this,
                                "Failed to update transaction. Please try again.",
                                "Error",
                                JOptionPane.ERROR_MESSAGE);
                    };

                    apiRequestHandler.asyncOrphanTransaction(transaction, onSuccess, onFailure);
                }
            });
            menu.add(orphanItem);
        }
        JMenuItem deleteItem = new JMenuItem("Delete transaction");
        deleteItem.addActionListener(evt -> {
            int result = JOptionPane.showConfirmDialog(this,
                    "Are you sure you want to delete this transaction? Any flip it is part of will also be updated.",
                    "Confirm Action",
                    JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION) {
                loadingText.setText("");
                setSpinnerVisible(true);
                log.info("deleting transaction with ID: {}", transaction.getId());

                BiConsumer<Integer, List<FlipV2>> onSuccess = (userId, flips) -> {
                    flipManager.mergeFlips(flips, userId);
                    setSpinnerVisible(false);
                    transaction.setClientFlipId(ZERO_UUID);
                    transactionDataWrapper.deleteOne(i -> transaction.getId().equals(i.getId()));
                    applyFilters(false);
                };

                Runnable onFailure = () -> {
                    setSpinnerVisible(false);
                    JOptionPane.showMessageDialog(this,
                            "Failed to delete transaction. Please try again.",
                            "Error",
                            JOptionPane.ERROR_MESSAGE);
                };

                apiRequestHandler.asyncDeleteTransaction(transaction, onSuccess, onFailure);
            }
        });
        menu.add(deleteItem);
        menu.show(e.getComponent(), e.getX(), e.getY());
    }

    private void downloadTransactionsCSV() {
        if (transactionDataWrapper == null) {
            JOptionPane.showMessageDialog(this,
                    "No transaction data available to download.",
                    "Download Error",
                    JOptionPane.WARNING_MESSAGE);
            return;
        }

        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Save Transactions CSV");
        fileChooser.setSelectedFile(new File("transactions.csv"));

        if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            executorService.submit(() -> {
                try (FileWriter writer = new FileWriter(file)) {
                    writer.write(Strings.join(columnNames, ","));

                    Map<Integer, String> accountIdToDisplayName = copilotLoginManager.accountIDToDisplayNameMap();

                    // Use the stream method to write all matching transactions
                    transactionDataWrapper.stream(filteredItems, selectedAccountId)
                            .forEach(tx -> {
                                try {
                                    int absQuantity = Math.abs(tx.getQuantity());
                                    long paidReceived = Math.abs(tx.getAmountSpent());
                                    long priceEa = tx.getPrice();
                                    long tax = calculateTax(tx);
                                    String row = String.join(",",
                                            formatTimestampISO(tx.getTime()),
                                            escapeCSV(accountIdToDisplayName.getOrDefault(tx.getAccountId(), "Unknown")),
                                            tx.getQuantity() > 0 ? "BUY" : "SELL",
                                            escapeCSV(itemController.getItemName(tx.getItemId())),
                                            String.valueOf(absQuantity),
                                            String.valueOf(paidReceived),
                                            String.valueOf(tax),
                                            String.valueOf(priceEa),
                                            !ZERO_UUID.equals(tx.getClientFlipId()) ? "YES" : "NO"
                                    );
                                    writer.write( "\n"+ row);
                                } catch (IOException e) {
                                    throw new RuntimeException(e);
                                }
                            });

                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this,
                                "Transactions exported successfully to " + file.getName(),
                                "Export Complete",
                                JOptionPane.INFORMATION_MESSAGE);
                    });

                } catch (Exception e) {
                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this,
                                "Error exporting transactions: " + e.getMessage(),
                                "Export Error",
                                JOptionPane.ERROR_MESSAGE);
                    });
                    log.error("Error exporting transactions to CSV", e);
                }
            });
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import lombok.RequiredArgsConstructor;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.ZoneOffset;

@RequiredArgsConstructor
public class Datapoint {
    public final LocalDate t;
    public final long cumulativeProfit;
    public final long dailyProfit;
    public boolean isDailyProfitHovered;
    public boolean isCumulativeProfitHovered;

    public long timestamp()  {
        return t.toEpochSecond(LocalTime.MIN, ZoneOffset.UTC);
    }
}

package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.ui.graph.model.Bounds;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Path2D;
import java.time.LocalDate;
import java.util.*;
import java.util.List;

@Slf4j
public class ProfitGraphPanel extends JPanel {

    // Layout constants (base values that will be scaled)
    private static final int BASE_PADDING_LEFT = 65;
    private static final int BASE_PADDING_RIGHT = 30;
    private static final int BASE_PADDING_TOP = 40;
    private static final int BASE_PADDING_BOTTOM = 40;

    // Scaled layout values
    private final int PADDING_LEFT = BASE_PADDING_LEFT;
    private final int PADDING_RIGHT = BASE_PADDING_RIGHT;
    private final int PADDING_TOP = BASE_PADDING_TOP;
    private final int PADDING_BOTTOM = BASE_PADDING_BOTTOM;

    // Visual constants
    private static final Color BACKGROUND_COLOR = new Color(43, 43, 43);
    private static final Color PLOT_AREA_COLOR = new Color(51, 51, 51);
    private static final Color GRID_COLOR = new Color(85, 85, 85, 90);
    private static final Color AXIS_COLOR = new Color(150, 150, 150);
    private static final Color TEXT_COLOR = new Color(225, 225, 225);

    // Scaled strokes
    private final Stroke LINE_STROKE = new BasicStroke(2f);
    private final Stroke GRID_STROKE = new BasicStroke(
            1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{3f}, 0
    );
    private final Stroke AXIS_STROKE = new BasicStroke(1.0f);

    private final Color lossColor;
    private final Color profitColor;

    // Point size for data points
    private final int POINT_RADIUS = 3;

    // Calculated bounds
    private List<Datapoint> data;
    private long minYValue;
    private long maxYValue;
    private long minY2Value;
    private long maxY2Value;
    private int minXValue;
    private int maxXValue;
    private Rectangle upperPa;
    private Rectangle lowerPa;
    private Bounds lowerPlotBounds;
    private Bounds upperPlotBounds;
    

    public void setData(List<Datapoint> newData) {
        this.data = newData;
        minYValue = 0;
        maxYValue = 1000_000;
        minY2Value = 0;
        maxY2Value = 10_000;
        minXValue = Integer.MAX_VALUE;
        maxXValue = Integer.MIN_VALUE;
        for (Datapoint i : data) {
            if (i.cumulativeProfit < minYValue) {
                minYValue = i.cumulativeProfit;
            } else if (i.cumulativeProfit > maxYValue) {
                maxYValue = i.cumulativeProfit;
            }
            if (i.dailyProfit < minY2Value) {
                minY2Value = i.dailyProfit;
            } else if (i.dailyProfit > maxY2Value) {
                maxY2Value = i.dailyProfit;
            }
            if(i.timestamp() < minXValue) {
                minXValue = (int) i.timestamp();
            }
            if(i.timestamp() > maxXValue) {
                maxXValue = (int) i.timestamp();
            }
        }
        maxXValue += AxisCalculator.DAY_SECONDS / 2;
        minXValue -= AxisCalculator.DAY_SECONDS / 2;
    }

    public ProfitGraphPanel(Color profitColor, Color lossColor) {
        this.data = new ArrayList<>();
        this.profitColor = profitColor;
        this.lossColor = lossColor;

        setBackground(BACKGROUND_COLOR);
        setPreferredSize(new Dimension(600, 400));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        addMouseMotionListener(new MouseAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                Point p = e.getPoint();
                Datapoint winner = null;
                int winnerDist = Integer.MAX_VALUE;
                boolean rePaintNeeded = false;
                if(upperPlotBounds != null && upperPa != null && lowerPa != null && (upperPa.contains(p) || lowerPa.contains(p))){
                    // find the closest by x-axis only (could use binary search but not worth the hassle)
                    for (Datapoint dp : data) {
                        int dist = Math.abs(upperPlotBounds.toX(upperPa, dp.timestamp()) - p.x);
                        dp.isCumulativeProfitHovered = false;
                        if(dist < winnerDist) {
                            winnerDist = dist;
                            winner = dp;
                        }
                    }
                    for (Datapoint dp : data) {
                        boolean prevIsCumulativeProfitHovered = dp.isCumulativeProfitHovered;
                        boolean prevIsDailyProfitHovered = dp.isDailyProfitHovered;
                        dp.isCumulativeProfitHovered = (winner == dp) && (upperPa.contains(p));
                        dp.isDailyProfitHovered = (winner == dp) && (lowerPa.contains(p));
                        if (prevIsDailyProfitHovered != dp.isDailyProfitHovered || prevIsCumulativeProfitHovered != dp.isCumulativeProfitHovered) {
                            rePaintNeeded = true;
                        }
                    }

                } else {
                    for (Datapoint d : data) {
                        if (d.isDailyProfitHovered) {
                            d.isDailyProfitHovered = false;
                            rePaintNeeded = true;
                        }
                        if (d.isCumulativeProfitHovered) {
                            d.isCumulativeProfitHovered = false;
                            rePaintNeeded = true;
                        }
                    }
                }
                if(rePaintNeeded) {
                    repaint();
                }
            }
        });
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

        
        int width = getWidth();
        int height = getHeight();
        int paWidth = width - PADDING_LEFT - PADDING_RIGHT;
        int availablePaHeight = height -2*PADDING_TOP - PADDING_BOTTOM;
        int upperPaHeight = (int) (0.7*availablePaHeight);
        int lowerPaHeight = availablePaHeight - upperPaHeight;
        
        upperPa = new Rectangle(PADDING_LEFT, PADDING_TOP, paWidth, upperPaHeight);
        lowerPa = new Rectangle(PADDING_LEFT, PADDING_TOP + upperPaHeight+ PADDING_BOTTOM, paWidth, lowerPaHeight);
        
        
        g2.setColor(PLOT_AREA_COLOR);
        g2.fillRect(upperPa.x, upperPa.y, upperPa.width, upperPa.height);
        g2.fillRect(lowerPa.x, lowerPa.y, lowerPa.width, lowerPa.height);

        List<Tick> yTicks = AxisCalculator.calculateYTicks(minYValue, maxYValue, 11);
        upperPlotBounds = new Bounds();
        upperPlotBounds.yMin = yTicks.get(0).value;
        upperPlotBounds.yMax = yTicks.get(yTicks.size()-1).value;
        upperPlotBounds.xMin = minXValue;
        upperPlotBounds.xMax = maxXValue;
        List<Tick> xTicks = AxisCalculator.calculateXTicks(minXValue, maxXValue);

        drawGrid(g2, upperPa, xTicks, yTicks, upperPlotBounds);
        drawYAxisLabels(g2, upperPa, yTicks, upperPlotBounds);
        drawTitle(g2, upperPa, "Cumulative profit over time");

        if (!data.isEmpty()) {
            drawProfitLine(g2, upperPa, upperPlotBounds);
        }
        
        List<Tick> yTicks2 = AxisCalculator.calculateYTicks(minY2Value, maxY2Value,6);
        lowerPlotBounds = upperPlotBounds.copy();
        lowerPlotBounds.yMin = yTicks2.get(0).value;
        lowerPlotBounds.yMax = yTicks2.get(yTicks2.size()-1).value;

        drawGrid(g2, lowerPa, xTicks, yTicks2, lowerPlotBounds);
        drawXAxisLabels(g2, lowerPa, xTicks,  lowerPlotBounds);
        drawYAxisLabels(g2, lowerPa, yTicks2, lowerPlotBounds);
        drawTitle(g2, lowerPa, "Daily profit/loss");
        if (!data.isEmpty()) {
            drawDailyProfitBars(g2, lowerPlotBounds);
        }
    }

    private void drawTitle(Graphics2D g2, Rectangle pa, String text) {
        // Use a slightly larger font for the title
        g2.setFont(Font.getFont(Font.MONOSPACED));
        g2.setColor(TEXT_COLOR);
        FontMetrics fm = g2.getFontMetrics();
        int textWidth = fm.stringWidth(text);
        int x = pa.x + (pa.width - textWidth) / 2;
        int y = pa.y - 5;
        g2.drawString(text, x, y);
    }

    private void drawGrid(Graphics2D g2, Rectangle pa, List<Tick> xTicks, List<Tick> yTicks, Bounds bounds) {
        g2.setColor(GRID_COLOR);
        g2.setStroke(GRID_STROKE);
        for (Tick t : xTicks) {
            int x = bounds.toX(pa, (int) t.value);
            g2.drawLine(x, pa.y, x, pa.y + pa.height);
        }
        for (Tick t : yTicks) {
            int y = bounds.toY(pa, t.value);
            g2.drawLine(pa.x, y, pa.x + pa.width, y);
        }
        g2.setColor(AXIS_COLOR);
        g2.setStroke(AXIS_STROKE);
//        int y = bounds.toY(pa, 0);
//        g2.drawLine(pa.x, y, pa.x + pa.width, y);
        g2.drawLine(pa.x, pa.y, pa.x, pa.y + pa.height);
    }


    private void drawProfitLine(Graphics2D g2, Rectangle pa, Bounds bounds) {
        if (data.size() < 2) {
            // Just draw a point if we only have one data point
            if (data.size() == 1) {
                Datapoint point = data.get(0);
                int x = bounds.toX(pa, point.timestamp());
                int y = bounds.toY(pa, point.cumulativeProfit);

                g2.setColor(point.cumulativeProfit >= 0 ? profitColor : lossColor);
                g2.fillOval(x - POINT_RADIUS, y - POINT_RADIUS, POINT_RADIUS * 2, POINT_RADIUS * 2);
            }
            return;
        }

        g2.setStroke(LINE_STROKE);

        // Create the line path
        Path2D.Float path = new Path2D.Float();
        boolean started = false;

        for (int i = 0; i < data.size(); i++) {
            Datapoint point = data.get(i);
            int x = bounds.toX(pa, point.timestamp());
            int y = bounds.toY(pa, point.cumulativeProfit);

            if (!started) {
                path.moveTo(x, y);
                started = true;
            } else {
                // Draw segment with appropriate color
                Datapoint prevPoint = data.get(i - 1);
                int prevX = bounds.toX(pa, (int) prevPoint.timestamp());
                int prevY = bounds.toY(pa, prevPoint.cumulativeProfit);

                // Determine color based on whether we're above or below zero
                boolean currentPositive = point.cumulativeProfit >= 0;
                boolean prevPositive = prevPoint.cumulativeProfit >= 0;

                if (currentPositive == prevPositive) {
                    // Same sign, simple line
                    g2.setColor(currentPositive ? profitColor : lossColor);
                    g2.drawLine(prevX, prevY, x, y);
                } else {
                    // Crossing zero, need to interpolate
                    double ratio = Math.abs((double)prevPoint.cumulativeProfit) /
                            (Math.abs(prevPoint.cumulativeProfit) + Math.abs(point.cumulativeProfit));
                    int crossX = prevX + (int)((x - prevX) * ratio);
                    int crossY = bounds.toY(pa, 0);

                    // Draw first segment
                    g2.setColor(prevPositive ? profitColor : lossColor);
                    g2.drawLine(prevX, prevY, crossX, crossY);

                    // Draw second segment
                    g2.setColor(currentPositive ? profitColor : lossColor);
                    g2.drawLine(crossX, crossY, x, y);
                }

                path.lineTo(x, y);
            }
        }

        // Draw points
        Runnable drawToolTip = () -> {};
        g2.setStroke(AXIS_STROKE);
        for (Datapoint dp : data) {
            int x = bounds.toX(pa, dp.timestamp());
            int y = bounds.toY(pa, dp.cumulativeProfit);

            g2.setColor(dp.cumulativeProfit >= 0 ? profitColor : lossColor);
            g2.fillOval(x - POINT_RADIUS, y - POINT_RADIUS, POINT_RADIUS * 2, POINT_RADIUS * 2);
            if(dp.isCumulativeProfitHovered) {
                drawToolTip = () -> {
                    g2.setColor(Color.WHITE);
                    g2.drawOval(x - POINT_RADIUS, y - POINT_RADIUS, POINT_RADIUS * 2, POINT_RADIUS * 2);
                    Point p = new Point(bounds.toX(upperPa, dp.timestamp()), bounds.toY(upperPa, dp.cumulativeProfit));
                    drawToolTip(dp.t, dp.cumulativeProfit, g2, p);
                };
            }
        }
        drawToolTip.run(); // draw tool tip after so it's on top
    }


    private void drawXAxisLabels(Graphics2D g2, Rectangle pa, List<Tick> xTicks, Bounds bounds) {
        g2.setColor(TEXT_COLOR);
        FontMetrics fm = g2.getFontMetrics();
        for (Tick t : xTicks) {
            int x = bounds.toX(pa, (int) t.value);
            int labelWidth = fm.stringWidth(t.label);
            g2.drawString(t.label, x - labelWidth / 2,  pa.y + pa.height + 20);
        }
    }
    private void drawYAxisLabels(Graphics2D g2, Rectangle pa,  List<Tick> yTicks, Bounds bounds) {
        g2.setColor(TEXT_COLOR);
        FontMetrics boldFm = g2.getFontMetrics();
        for (Tick t : yTicks) {
            int y = bounds.toY(pa, t.value);
            int labelWidth = boldFm.stringWidth(t.label);
            g2.drawString(t.label, PADDING_LEFT - labelWidth - 10,
                    y + boldFm.getHeight() / 3);
        }
    }


    private void drawDailyProfitBars(Graphics2D g2,  Bounds bounds) {
        if (data.isEmpty()) {
            return;
        }
        Runnable drawToolTip = () -> {};
        for (Datapoint dp : data) {
            Color barColor = dp.dailyProfit >= 0 ? profitColor : lossColor;
            g2.setColor(new Color(barColor.getRed(), barColor.getGreen(), barColor.getBlue(), 180)); // 70% opacity
            Rectangle bar = profitBarRect(dp, bounds);
            g2.fillRect(bar.x, bar.y, bar.width, bar.height);
            g2.setColor(new Color(barColor.getRed(), barColor.getGreen(), barColor.getBlue()));
            g2.drawRect(bar.x, bar.y, bar.width, bar.height);
            if(dp.isDailyProfitHovered) {
                drawToolTip = () -> {
                    g2.setColor(Color.WHITE);
                    g2.drawRect(bar.x, bar.y, bar.width, bar.height);
                    Point p = new Point(bounds.toX(lowerPa, dp.timestamp()), bounds.toY(lowerPa, dp.dailyProfit));
                    drawToolTip(dp.t, dp.dailyProfit, g2, p);
                };
            }
        }
        drawToolTip.run(); // draw tool tip after so it's on top
    }

    private Rectangle profitBarRect(Datapoint dp,  Bounds bounds) {
        int x1 = bounds.toX(lowerPa, dp.timestamp()- AxisCalculator.DAY_SECONDS / 2);
        int x2 = bounds.toX(lowerPa, dp.timestamp() + AxisCalculator.DAY_SECONDS / 2);
        int y1 =  bounds.toY(lowerPa, dp.dailyProfit);
        int y2 = bounds.toY(lowerPa, 0);
        if (dp.dailyProfit >= 0) {
            return new Rectangle(x1, y1, x2-x1, y2-y1);
        } else {
            return new Rectangle(x1, y2, x2-x1, y1-y2);
        }
    }

    private void drawToolTip(LocalDate t, long v, Graphics2D g2, Point p) {
        // Use exact same constants as DatapointTooltip
        final Color TOOLTIP_BACKGROUND = new Color(43, 43, 43);
        final Color TOOLTIP_BORDER = new Color(150, 150, 150);
        final int TOOLTIP_PADDING = 8; // Don't scale - use exact value from DatapointTooltip

        // Prepare tooltip text
        String dailyProfitStr = String.format("%,d", v);
        String dateStr = t.format(java.time.format.DateTimeFormatter.ofPattern("d MMM yyyy"));

        FontMetrics fm = g2.getFontMetrics();

        int dateWidth = fm.stringWidth(dateStr);
        int profitWidth = fm.stringWidth(dailyProfitStr);
        int textWidth = Math.max(dateWidth, profitWidth);
        int textHeight = fm.getHeight() * 2; // Two lines of text

        int tooltipWidth = textWidth + TOOLTIP_PADDING * 2;
        int tooltipHeight = textHeight + TOOLTIP_PADDING * 2;

        int tooltipX = p.x;
        int tooltipY = p.y;

        if (tooltipX < lowerPa.x) {
            tooltipX = lowerPa.x + 5;
        } else if (tooltipX + tooltipWidth > lowerPa.x + lowerPa.width) {
            tooltipX = lowerPa.x + lowerPa.width - tooltipWidth - 5;
        }
        g2.setColor(TOOLTIP_BACKGROUND);
        g2.fillRoundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8, 8);

        g2.setColor(TOOLTIP_BORDER);
        g2.setStroke(new BasicStroke(1.0f));
        g2.drawRoundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8, 8);
        g2.setColor(TEXT_COLOR);
        int yPos = tooltipY + TOOLTIP_PADDING + fm.getAscent();
        g2.drawString(dailyProfitStr, tooltipX + TOOLTIP_PADDING, yPos);
        yPos += fm.getHeight();
        g2.drawString(dateStr, tooltipX + TOOLTIP_PADDING, yPos);
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Named;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;

@Slf4j
public class AccountsAggregateFilterSort {

    // dependencies
    private final FlipManager flipManager;
    private final CopilotLoginManager copilotLoginManager;
    private final Consumer<List<AccountAggregate>> aggregatesCallback;
    private final Consumer<Boolean> slowLoadingCallback;
    private final ExecutorService executorService;

    // state
    private int intervalStartTime = 1;
    private int cachedIntervalStartTime = Integer.MIN_VALUE;
    private final List<AccountAggregate> cachedAggregates =  new ArrayList<>();

    public AccountsAggregateFilterSort(FlipManager flipManager,
                                       CopilotLoginManager copilotLoginManager,
                                       Consumer<List<AccountAggregate>> aggregatesCallback,
                                       Consumer<Boolean> slowLoadingCallback,
                                       @Named("copilotExecutor") ExecutorService executorService) {
        this.flipManager = flipManager;
        this.copilotLoginManager = copilotLoginManager;
        this.aggregatesCallback = aggregatesCallback;
        this.slowLoadingCallback = slowLoadingCallback;
        this.executorService = executorService;
    }

    public synchronized void setInterval(IntervalTimeUnit timeUnit, Integer value) {
        switch (timeUnit) {
            case ALL:
                intervalStartTime = 1;
                break;
            case SESSION:
                // TODO: Get session start time from SessionManager
                intervalStartTime = (int) Instant.now().getEpochSecond() - 3600; // Default to 1 hour ago
                break;
            default:
                intervalStartTime = (int) (Instant.now().getEpochSecond() - (long) value * timeUnit.getSeconds());
        }
        reloadAggregates(false);
    }

    public void reloadAggregates(boolean forceReload) {
        executorService.submit(() -> _reloadAggregates(forceReload));
    }

    private synchronized void _reloadAggregates(boolean forceReload) {
        try {
            slowLoadingCallback.accept(true);

            if(forceReload || cachedIntervalStartTime != intervalStartTime) {
                log.debug("loading account aggregates");
                cachedAggregates.clear();
                Aggregator a = new Aggregator();
                copilotLoginManager.accountIDToDisplayNameMap().forEach(
                        (accountId, displayName)  -> a.accounts.put(accountId, new AccountAggregator(accountId))
                );
                flipManager.aggregateFlips(intervalStartTime, null, false, a);
                cachedIntervalStartTime = intervalStartTime;
                a.accounts.forEach((k, v) -> cachedAggregates.add(v.toAccountAggregate(copilotLoginManager.getDisplayName(k))));
                log.debug("loaded {} account aggregates", cachedAggregates.size());
            }
            // Final callback to indicate completion
            slowLoadingCallback.accept(false);
            aggregatesCallback.accept(cachedAggregates);
        } catch (Exception e) {
            log.warn("error loading account aggregates", e);
            slowLoadingCallback.accept(false);
        }
    }

    static class Aggregator implements Consumer<FlipV2> {
        final Map<Integer, AccountAggregator> accounts = new HashMap<>();

        public void accept(FlipV2 flip) {
            {
                AccountAggregator a = accounts.computeIfAbsent(flip.getAccountId(), AccountAggregator::new);
                long profit = flip.getProfit();
                a.totalProfit += profit;
                a.numberOfFlips++;
                if (profit < 0) {
                    a.biggestLoss = Math.min(a.biggestLoss, profit);
                } else {
                    a.biggestWin = Math.max(a.biggestWin, profit);
                }
            }
        }
    }

    @RequiredArgsConstructor
    static class AccountAggregator {
        final int accountId;
        long totalProfit = 0;
        long biggestLoss = Long.MAX_VALUE;
        long biggestWin = Long.MIN_VALUE;
        int numberOfFlips = 0;

        public AccountAggregate toAccountAggregate(String accountName) {
            return AccountAggregate.builder()
                    .accountId(accountId)
                    .accountName(accountName == null ? "Unknown" : accountName)
                    .numberOfFlips(numberOfFlips)
                    .biggestLoss(biggestLoss == Long.MAX_VALUE ? 0 : biggestLoss)
                    .biggestWin(biggestWin == Long.MIN_VALUE ? 0 : biggestWin)
                    .totalProfit(totalProfit)
                    .build();
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class Tick {
    public long value;
    public String label;
}

package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.components.IntervalDropdown;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import javax.swing.table.TableRowSorter;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.NumberFormat;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;

@Slf4j
public class AccountsAggregatePanel extends JPanel {

    private static final NumberFormat GP_FORMAT = NumberFormat.getNumberInstance(Locale.US);
    // dependencies
    private final CopilotLoginManager copilotLoginManager;
    private final ApiRequestHandler apiRequestHandler;
    private final FlipManager flipManager;
    private final ExecutorService executorService;

    // ui components
    private final DefaultTableModel tableModel;
    private final JTable table;
    private final Spinner spinner;
    private final JScrollPane scrollPane;
    private IntervalDropdown timeIntervalDropdown;

    // state
    private AccountsAggregateFilterSort sortAndFilter;
    private List<AccountAggregate> currentItems;

    private final String[] columnNames = {
            "Account", "Number of flips", "Biggest loss", "Biggest win", "Total profit"
    };
    private JPanel spinnerOverlay;

    public AccountsAggregatePanel(FlipManager flipsManager,
                                  CopilotLoginManager copilotLoginManager,
                                  @Named("copilotExecutor") ExecutorService executorService,
                                  FlippingCopilotConfig config, ApiRequestHandler apiRequestHandler, FlipManager flipManager) {
        this.copilotLoginManager = copilotLoginManager;
        this.apiRequestHandler = apiRequestHandler;
        this.flipManager = flipManager;
        this.executorService = executorService;

        // Initialize sort and filter
        sortAndFilter = new AccountsAggregateFilterSort(flipsManager, copilotLoginManager,
                this::showAggregates, this::setSpinnerVisible, executorService);

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Create top panel with all controls
        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        timeIntervalDropdown = new IntervalDropdown(sortAndFilter::setInterval, IntervalDropdown.ALL_TIME, false);
        timeIntervalDropdown.setPreferredSize(new Dimension(150, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setToolTipText("Select time interval");

        leftPanel.add(timeIntervalDropdown);

        topPanel.add(leftPanel, BorderLayout.WEST);
        add(topPanel, BorderLayout.NORTH);

        // Create table model
        tableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        // Create table
        table = new JTable(tableModel);
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        table.setSelectionBackground(ColorScheme.BRAND_ORANGE);
        table.setSelectionForeground(Color.WHITE);
        table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
        table.setRowHeight(25);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

        // Enable built-in table sorting
        TableRowSorter<DefaultTableModel> sorter = new TableRowSorter<>(tableModel);
        table.setRowSorter(sorter);
        table.getTableHeader().setReorderingAllowed(false);
        table.setFocusable(false);

        // Custom renderer for money columns
        DefaultTableCellRenderer moneyRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    setText(formatGp((Long) value));
                    setHorizontalAlignment(RIGHT);
                }
                return c;
            }
        };

        // Custom renderer for profit columns (with color)
        DefaultTableCellRenderer profitRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    long amount = (Long) value;
                    setText(formatGp(amount));
                    setHorizontalAlignment(RIGHT);

                    // Color profit/loss only if not selected
                    if (!isSelected) {
                        if (amount > 0) {
                            setForeground(config.profitAmountColor());
                        } else if (amount < 0) {
                            setForeground(config.lossAmountColor());
                        } else {
                            setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                        }
                    }
                }
                return c;
            }
        };

        // Center align for count column
        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        // Apply renderers
        table.getColumnModel().getColumn(1).setCellRenderer(centerRenderer); // Number of flips
        table.getColumnModel().getColumn(2).setCellRenderer(moneyRenderer); // Biggest loss
        table.getColumnModel().getColumn(3).setCellRenderer(moneyRenderer); // Biggest win
        table.getColumnModel().getColumn(4).setCellRenderer(profitRenderer); // Total profit (with color)
        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            private void showPopup(MouseEvent e) {
                int row = table.rowAtPoint(e.getPoint());
                if (row >= 0 && row < table.getRowCount()) {
                    table.setRowSelectionInterval(row, row);
                    showAccountMenu(e, row);
                }
            }
        });

        // Create layered pane for spinner overlay
        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        layeredPane.setOpaque(true);

        // Create spinner with semi-transparent background
        spinner = new Spinner();
        spinner.show();
        spinnerOverlay = new JPanel(new GridBagLayout());
        spinnerOverlay.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spinnerOverlay.setOpaque(true);
        spinnerOverlay.add(spinner);
        spinnerOverlay.setVisible(false); // Initially hidden

        scrollPane = new JScrollPane(table);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);

        layeredPane.setLayout(new OverlayLayout(layeredPane));
        layeredPane.add(spinnerOverlay, JLayeredPane.MODAL_LAYER);
        layeredPane.add(scrollPane, JLayeredPane.DEFAULT_LAYER);

        add(layeredPane, BorderLayout.CENTER);
    }

    private void setSpinnerVisible(boolean visible) {
        SwingUtilities.invokeLater(() -> {
            spinnerOverlay.setVisible(visible);
        });
    }

    private void showAggregates(List<AccountAggregate> aggregates) {
        SwingUtilities.invokeLater(() -> {
            currentItems = aggregates;
            tableModel.setRowCount(0);
            for (AccountAggregate aggregate : aggregates) {
                Object[] row = {
                        aggregate.getAccountName(),
                        aggregate.getNumberOfFlips(),
                        aggregate.getBiggestLoss(),
                        aggregate.getBiggestWin(),
                        aggregate.getTotalProfit(),
                };
                tableModel.addRow(row);
            }
            for (int i = 0; i < table.getColumnCount(); i++) {
                resizeColumnWidth(table, i);
            }
        });
    }

    private void resizeColumnWidth(JTable table, int column) {
        TableColumn tableColumn = table.getColumnModel().getColumn(column);
        int preferredWidth = tableColumn.getMinWidth();
        int maxWidth = tableColumn.getMaxWidth();

        // Check header width
        Component comp = table.getTableHeader().getDefaultRenderer()
                .getTableCellRendererComponent(table, tableColumn.getHeaderValue(), false, false, 0, column);
        preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);

        // Check cell widths
        for (int row = 0; row < table.getRowCount(); row++) {
            comp = table.getCellRenderer(row, column)
                    .getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);
            preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);
        }

        preferredWidth = Math.min(preferredWidth, maxWidth);
        tableColumn.setPreferredWidth(preferredWidth);
    }

    private void showAccountMenu(MouseEvent e, int row) {
        AccountAggregate a = currentItems.get(row);
        JPopupMenu menu = new JPopupMenu();
        JMenuItem deleteItem = new JMenuItem("Delete account");
        deleteItem.addActionListener(evt -> {
            int result = JOptionPane.showConfirmDialog(this,
                    "Are you sure you want to delete " + a.getAccountName() + "?",
                    "Confirm Delete",
                    JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION) {
                setSpinnerVisible(true);
                log.info("Deleting account: {}", a.getAccountId());
                Runnable onSuccess = () -> {
                    copilotLoginManager.removeAccount(a.getAccountId());
                    executorService.submit(() -> flipManager.deleteAccount(a.getAccountId()));
                    setSpinnerVisible(false);
                    sortAndFilter.reloadAggregates(true);
                };
                apiRequestHandler.asyncDeleteAccount(a.getAccountId(), onSuccess, () -> setSpinnerVisible(false));
            }
        });
        menu.add(deleteItem);
        menu.show(e.getComponent(), e.getX(), e.getY());
    }

    private String formatGp(long amount) {
        return GP_FORMAT.format(amount);
    }

    public void onTabShown() {
        sortAndFilter.reloadAggregates(true);
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.model.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Named;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;
import java.util.function.Predicate;

@Slf4j
public class ItemAggregateFilterSort {

    public static final int DEFAULT_PAGE_SIZE = 50;

    private static final Map<String, Comparator<ItemAggregate>> SORT_COMPARATORS = new HashMap<>();
    static {
        SORT_COMPARATORS.put("Item", Comparator.comparing(ItemAggregate::getItemName));
        SORT_COMPARATORS.put("Number of flips", Comparator.comparing(ItemAggregate::getNumberOfFlips));
        SORT_COMPARATORS.put("Biggest loss", Comparator.comparing(ItemAggregate::getBiggestLoss));
        SORT_COMPARATORS.put("Biggest win", Comparator.comparing(ItemAggregate::getBiggestWin));
        SORT_COMPARATORS.put("Total profit", Comparator.comparing(ItemAggregate::getTotalProfit));
        SORT_COMPARATORS.put("Avg profit", Comparator.comparing(ItemAggregate::getAvgProfit));
        SORT_COMPARATORS.put("Avg profit ea.", Comparator.comparing(ItemAggregate::getAvgProfitEa));
        SORT_COMPARATORS.put("Total quantity flipped", Comparator.comparing(ItemAggregate::getTotalQuantityFlipped));
    }

    // dependencies
    private final FlipManager flipManager;
    private final ItemController itemController;
    private final Consumer<List<ItemAggregate>> aggregatesCallback;
    private final Consumer<Integer> totalPagesChangedCallback;
    private final Consumer<Boolean> slowLoadingCallback;
    private final ExecutorService executorService;

    // state
    private List<ItemAggregate> cachedAggregates = new ArrayList<>();
    private Integer cachedAccountId = null;
    private int cachedIntervalStartTime = Integer.MIN_VALUE;
    private Set<Integer> cachedFilteredItems = new HashSet<>();
    private SortDirection cachedSortDirection = SortDirection.ASC;
    private String cachedSortColumn = "";

    private int intervalStartTime = 1;
    private Integer accountId = null;
    @Getter
    private String sortColumn = "Total profit";
    @Getter
    private SortDirection sortDirection = SortDirection.ASC;
    private Set<Integer> filteredItems = new HashSet<>();
    @Getter
    private int pageSize = DEFAULT_PAGE_SIZE;
    private int page = 1;

    public ItemAggregateFilterSort(FlipManager flipManager,
                                   ItemController itemController,
                                   Consumer<List<ItemAggregate>> aggregatesCallback,
                                   Consumer<Integer> totalPagesChangedCallback,
                                   Consumer<Boolean> slowLoadingCallback,
                                   @Named("copilotExecutor") ExecutorService executorService) {
        this.flipManager = flipManager;
        this.itemController = itemController;
        this.aggregatesCallback = aggregatesCallback;
        this.totalPagesChangedCallback = totalPagesChangedCallback;
        this.slowLoadingCallback = slowLoadingCallback;
        this.executorService = executorService;
    }

    public synchronized void setInterval(IntervalTimeUnit timeUnit, Integer value) {
        switch (timeUnit) {
            case ALL:
                intervalStartTime = 1;
                break;
            case SESSION:
                // TODO: Get session start time from SessionManager
                intervalStartTime = (int) Instant.now().getEpochSecond() - 3600; // Default to 1 hour ago
                break;
            default:
                intervalStartTime = (int) (Instant.now().getEpochSecond() - (long) value * timeUnit.getSeconds());
        }
        reloadAggregates(true);
    }

    public synchronized void setAccountId(Integer accountId) {
        if (!Objects.equals(accountId, this.accountId)) {
            this.accountId = accountId;
            reloadAggregates(true);
        }
    }

    public synchronized void setFilteredItems(Set<Integer> filteredItems) {
        if (!Objects.equals(filteredItems, this.filteredItems)) {
            this.filteredItems = filteredItems;
            reloadAggregates(true);
        }
    }
    public synchronized Set<Integer> getFilteredItems() {
        return new HashSet<>(filteredItems);
    }

    public synchronized void setPageSize(int newSize) {
        if (newSize != pageSize) {
            pageSize = newSize;
            reloadAggregates(true);
        }
    }

    public synchronized void setSortColumn(String sortColumn) {
        if (!sortColumn.equals(this.sortColumn)) {
            this.sortColumn = sortColumn;
            reloadAggregates(false);
        }
    }

    public synchronized void setSortDirection(SortDirection sortDirection) {
        if (!Objects.equals(sortDirection, this.sortDirection)) {
            this.sortDirection = sortDirection;
            reloadAggregates(false);
        }
    }

    public synchronized void setPage(int page) {
        if (page != this.page) {
            this.page = page;
            reloadAggregates(false);
        }
    }

    public void reloadAggregates(boolean totalPagesMaybeChanged) {
        executorService.submit(() -> _reloadAggregates(totalPagesMaybeChanged));
    }


    private synchronized void _reloadAggregates(boolean totalPagesMaybeChanged) {
        try {
            slowLoadingCallback.accept(true);

            boolean cachedAggregatesOutOfDate = !Objects.equals(cachedAccountId, accountId) ||
                    !cachedFilteredItems.equals(filteredItems) ||
                    cachedIntervalStartTime != intervalStartTime;
            boolean cachedSortOutOfDate = cachedAggregatesOutOfDate ||
                    !cachedSortColumn.equals(sortColumn) ||
                    !cachedSortDirection.equals(sortDirection);

            log.debug("cachedAggregatesOutOfDate={}, cachedSortOutOfDate={}", cachedAggregatesOutOfDate, cachedSortOutOfDate);

            if (cachedAggregatesOutOfDate) {
                log.debug("reloading cached item aggregates");
                cachedAccountId = accountId;
                cachedFilteredItems.clear();
                cachedFilteredItems.addAll(filteredItems);
                cachedIntervalStartTime = intervalStartTime;
                cachedAggregates.clear();
                Predicate<FlipV2> flipFilter = filteredItems.isEmpty() ? f -> true : f -> filteredItems.contains(f.getItemId());
                Aggregator a = new Aggregator(flipFilter);
                flipManager.aggregateFlips(intervalStartTime, cachedAccountId, false, a);
                cachedIntervalStartTime = intervalStartTime;
                a.items.forEach((k, v) -> cachedAggregates.add(v.toItemAggregate(itemController.getItemName(k))));
                log.debug("loaded {} cached item aggregates", cachedAggregates.size());
            }

            if (totalPagesMaybeChanged) {
                log.debug("updating total pages");
                int totalPages = 1 + cachedAggregates.size() / pageSize;
                totalPagesChangedCallback.accept(totalPages);
                log.debug("updated total pages to {}", totalPages);
            }

            if (cachedSortOutOfDate) {
                log.debug("re-sorting cached item aggregates");
                cachedSortColumn = sortColumn;
                cachedSortDirection = sortDirection;

                // Apply sorting
                Comparator<ItemAggregate> comparator = SORT_COMPARATORS.get(sortColumn);
                if (comparator != null) {
                    if (sortDirection == SortDirection.ASC) {
                        comparator = comparator.reversed();
                    }
                    cachedAggregates.sort(comparator);
                }
                log.debug("re-sorted item aggregates");
            }

            int startIndex = (page - 1) * pageSize;
            int endIndex = Math.min(startIndex + pageSize, cachedAggregates.size());
            slowLoadingCallback.accept(false);
            aggregatesCallback.accept(cachedAggregates.subList(startIndex, endIndex));
            log.debug("_reloadAggregates end");

        } catch (Exception e) {
            log.warn("error filtering/sorting item aggregates", e);
        }
    }

    @AllArgsConstructor
    static class Aggregator implements Consumer<FlipV2> {
        final Predicate<FlipV2> p;
        final Map<Integer,  ItemAggregator> items = new HashMap<>();

        public void accept(FlipV2 flip) {
            if(p.test(flip)) {
                ItemAggregator i = items.computeIfAbsent(flip.getItemId(), (k) -> new ItemAggregator());
                long profit = flip.getProfit();
                long quantitySold = flip.getClosedQuantity();
                i.totalProfit += profit;
                i.totalQuantitySold += quantitySold;
                i.numberOfFlips++;
                if (profit < 0) {
                    i.biggestLoss = Math.min(i.biggestLoss, profit);
                } else {
                    i.biggestWin = Math.max(i.biggestWin, profit);
                }
                i.quantityFlipped += flip.getClosedQuantity();
            }
        }
    }

    static class ItemAggregator {
        private long totalProfit = 0;
        private long totalQuantitySold = 0;
        private long biggestLoss = Long.MAX_VALUE;
        private long biggestWin = Long.MIN_VALUE;
        private int numberOfFlips = 0;
        private int quantityFlipped = 0;


        public ItemAggregate toItemAggregate(String itemName) {
            return ItemAggregate.builder()
                    .itemName(itemName)
                    .numberOfFlips(numberOfFlips)
                    .totalQuantityFlipped(quantityFlipped)
                    .biggestLoss(biggestLoss == Long.MAX_VALUE ? 0 : biggestLoss)
                    .biggestWin(biggestWin == Long.MIN_VALUE ? 0 : biggestWin)
                    .totalProfit(totalProfit)
                    .avgProfit(numberOfFlips == 0 ? 0 : totalProfit / numberOfFlips)
                    .avgProfitEa(totalQuantitySold == 0 ? 0 : totalProfit / totalQuantitySold)
                    .build();
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.model.FlipV2;
import com.flippingcopilot.model.VisualizeFlipResponse;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.graph.DataManager;
import com.flippingcopilot.ui.graph.FlipStatsPanel;
import com.flippingcopilot.ui.graph.GraphPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.util.function.Consumer;

@Slf4j
public class VisualizeFlipPanel extends JPanel {

    // Dependencies
    private final ItemController itemController;
    private final ApiRequestHandler apiRequestHandler;

    // UI Components
    private final JLabel errorLabel = new JLabel();
    private final GraphPanel graphPanel;
    private final FlipStatsPanel statsPanel;
    private final CardLayout contentCardLayout = new CardLayout();

    // State
    private volatile FlipV2 currentFlip;

    public VisualizeFlipPanel(ItemController itemController,
                              PriceGraphConfigManager configManager,
                              FlippingCopilotConfig copilotConfig,
                              ApiRequestHandler apiRequestHandler) {
        this.itemController = itemController;
        this.apiRequestHandler = apiRequestHandler;

        setLayout(contentCardLayout);
        setBackground(ColorScheme.DARK_GRAY_COLOR);


        graphPanel = new GraphPanel(configManager);
        statsPanel = new FlipStatsPanel(configManager, copilotConfig);
        statsPanel.setBackground(configManager.getConfig().backgroundColor);
        statsPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));


        add(buildLandingCard(), Cards.LANDING_CARD.name());
        add(buildLoadingCard(), Cards.LOADING_CARD.name());
        add(buildGraphCard(), Cards.GRAPH_CARD.name());
        add(buildErrorCard(), Cards.ERROR_CARD.name());


        errorLabel.setForeground(Color.RED);
        errorLabel.setFont(errorLabel.getFont().deriveFont(14f));
        errorLabel.setHorizontalAlignment(SwingConstants.CENTER);
        contentCardLayout.show(this, Cards.LANDING_CARD.name());
    }

    public void showFlipVisualization(FlipV2 flip) {
        if (flip == null) {
            return;
        }
        currentFlip = flip;
        contentCardLayout.show(this, Cards.LOADING_CARD.name());
        Consumer<VisualizeFlipResponse> onSuccess = (VisualizeFlipResponse d) -> {
            d.graphData.clearPredictionData();
            SwingUtilities.invokeLater(() -> {
                showGraphCard(new DataManager(d.getGraphData(), d), flip);
            });
        };
        Consumer<String> onFailure = (String errorMessage) -> {
            SwingUtilities.invokeLater(() -> showErrorCard(errorMessage));
        };
        apiRequestHandler.asyncGetVisualizeFlipData(flip.getId(), "FlipCopilot", onSuccess, onFailure);
    }

    private JPanel buildLandingCard() {
        JPanel landingCard = new JPanel(new GridBagLayout());
        landingCard.setBackground(ColorScheme.DARK_GRAY_COLOR);
        JLabel emptyLabel = new JLabel("Right click on a flip in the flips tab and select 'Visualize flip' option.");
        emptyLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        emptyLabel.setFont(emptyLabel.getFont().deriveFont(16f));
        landingCard.add(emptyLabel);
        return landingCard;
    }

    private JPanel buildLoadingCard() {
        JLabel loadingLabel = new JLabel("Loading price data...");
        Spinner spinner = new Spinner();
        loadingLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        loadingLabel.setFont(loadingLabel.getFont().deriveFont(14f));
        JPanel loadingPanel = new JPanel(new GridBagLayout());
        loadingPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);
        spinner.show();
        loadingPanel.add(spinner, gbc);
        gbc.gridy = 1;
        loadingPanel.add(loadingLabel, gbc);
        return loadingPanel;
    }

    private JPanel buildErrorCard() {
        JPanel errorPanel = new JPanel(new GridBagLayout());
        errorPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);
        errorPanel.add(errorLabel, gbc);
        gbc.gridy = 1;
        gbc.insets = new Insets(20, 10, 10, 10);
        JButton retryButton = new JButton("Retry");
        retryButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        retryButton.setFocusable(false);
        retryButton.addActionListener(e -> {
            if (currentFlip != null) {
                showFlipVisualization(currentFlip);
            }
        });
        errorPanel.add(retryButton, gbc);
        return errorPanel;
    }

    private void showErrorCard(String errorMessage) {
        errorLabel.setText("<html><center>" + errorMessage + "</center></html>");
        contentCardLayout.show(this, Cards.ERROR_CARD.name());
    }

    private void showGraphCard(DataManager dm, FlipV2 f) {
        graphPanel.setData(dm);
        contentCardLayout.show(this, Cards.GRAPH_CARD.name());
        statsPanel.populate(f, itemController);
    }

    private JSplitPane buildGraphCard() {
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, true);
        splitPane.setLeftComponent(graphPanel);
        splitPane.setRightComponent(statsPanel);
        splitPane.setResizeWeight(0.95); // Graph gets 75% of space
        splitPane.setDividerLocation(0.95);
        splitPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        return splitPane;
    }

    enum Cards {
        LANDING_CARD,
        GRAPH_CARD,
        LOADING_CARD,
        ERROR_CARD
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.Paginator;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.IntervalDropdown;
import com.flippingcopilot.ui.components.ItemSearchMultiSelect;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.NumberFormat;
import java.time.Instant;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import static com.flippingcopilot.util.DateUtil.formatEpoch;

@Slf4j
public class FlipsPanel extends JPanel {


    private static final Integer[] PAGE_SIZE_OPTIONS = {10, 25, 50, 100, 200, 500, 1000, 2000};
    public static final NumberFormat GP_FORMAT = NumberFormat.getNumberInstance(Locale.US);
    public static final String[] COLUMN_NAMES = {
            "First buy time", "Last sell time", "Account", "Item", "Status", "Bought", "Sold",
            "Avg. buy price", "Avg. sell price", "Tax", "Profit", "Profit ea."
    };

    // dependencies
    private final FlipManager flipsManager;
    private final CopilotLoginManager copilotLoginManager;
    private final ApiRequestHandler apiRequestHandler;

    // ui components
    private final DefaultTableModel tableModel;
    private final JTable table;
    private final Paginator paginatorPanel;
    private final Spinner spinner;
    private final JScrollPane scrollPane;
    private final JPanel spinnerOverlay;
    private final ItemSearchMultiSelect searchField;
    private final JCheckBox showOpeningFlipsCheckbox;
    private final Consumer<FlipV2> onVisualizeFlip;
    private IntervalDropdown timeIntervalDropdown;
    private AccountDropdown accountDropdown;
    private final JComboBox<Integer> pageSizeComboBox;

    // state
    private List<FlipV2> currentFlips = new ArrayList<>();
    public FlipFilterAndSort sortAndFilter;


    public FlipsPanel(FlipManager flipsManager,
                      ItemController itemController,
                      CopilotLoginManager copilotLoginManager,
                      @Named("copilotExecutor") ExecutorService executorService,
                      FlippingCopilotConfig config,
                      ApiRequestHandler apiRequestHandler,
                      Consumer<FlipV2> onVisualizeFlip) {
        this.onVisualizeFlip = onVisualizeFlip;
        this.copilotLoginManager = copilotLoginManager;
        this.apiRequestHandler = apiRequestHandler;

        // Initialize pagination first (before loadFlips is called)
        paginatorPanel = new Paginator((i) -> sortAndFilter.setPage(i));
        sortAndFilter = new FlipFilterAndSort(flipsManager, this::showFlips, paginatorPanel::setTotalPages, this::setSpinnerVisible, executorService, copilotLoginManager, itemController);
        this.flipsManager = flipsManager;
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        searchField = new ItemSearchMultiSelect(
                sortAndFilter::getFilteredItems,
                itemController::allItemIds,
                itemController::search,
                sortAndFilter::setFilteredItems,
                "Items filter...",
                SwingUtilities.getWindowAncestor(this));
        searchField.setMinimumSize(new Dimension(300, 0));
        searchField.setToolTipText("Search by item name");

        showOpeningFlipsCheckbox= new JCheckBox("Show buying flips", true);
        showOpeningFlipsCheckbox.setBackground(ColorScheme.DARK_GRAY_COLOR);
        showOpeningFlipsCheckbox.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        showOpeningFlipsCheckbox.setFocusable(false);
        showOpeningFlipsCheckbox.addActionListener(e -> sortAndFilter.setIncludeBuyingFlips(showOpeningFlipsCheckbox.isSelected()));

        pageSizeComboBox = new JComboBox<>(PAGE_SIZE_OPTIONS);
        pageSizeComboBox.setSelectedItem(sortAndFilter.getPageSize());
        pageSizeComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizeComboBox.setFocusable(false);
        pageSizeComboBox.setToolTipText("Page size");
        pageSizeComboBox.addActionListener(e -> sortAndFilter.setPageSize((Integer) pageSizeComboBox.getSelectedItem()));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        JButton downloadButton = createDownloadButton();
        buttonPanel.add(downloadButton);

        topPanel.add(leftPanel, BorderLayout.WEST);
        topPanel.add(buttonPanel, BorderLayout.EAST);
        add(topPanel, BorderLayout.NORTH);

        tableModel = new DefaultTableModel(COLUMN_NAMES, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        table = new JTable(tableModel);
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        table.setSelectionBackground(ColorScheme.BRAND_ORANGE);
        table.setSelectionForeground(Color.WHITE);
        table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
        table.setRowHeight(25);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

        // Disable default table sorting and set up custom header click handling
        table.setRowSorter(null);
        table.getTableHeader().setReorderingAllowed(false);
        table.setFocusable(false);


        // Add custom header click listener for sorting
        table.getTableHeader().addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                int columnIndex = table.getTableHeader().columnAtPoint(e.getPoint());
                if (columnIndex >= 0 && columnIndex < COLUMN_NAMES.length) {
                    String clickedColumn = COLUMN_NAMES[columnIndex];

                    // Toggle sort direction if clicking the same column, otherwise default to DESC
                    SortDirection newDirection = SortDirection.DESC;
                    if (clickedColumn.equals(sortAndFilter.getSortColumn())) {
                        newDirection = sortAndFilter.getSortDirection() == SortDirection.DESC ?
                                SortDirection.ASC : SortDirection.DESC;
                    }

                    sortAndFilter.setSortColumn(clickedColumn);
                    sortAndFilter.setSortDirection(newDirection);
                }
            }
        });

        table.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if (e.isPopupTrigger()) {
                    showPopup(e);
                }
            }

            private void showPopup(MouseEvent e) {
                int row = table.rowAtPoint(e.getPoint());
                if (row >= 0 && row < table.getRowCount()) {
                    table.setRowSelectionInterval(row, row);
                    showFlipMenu(e, row);
                }
            }
        });

        DefaultTableCellRenderer moneyRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    setText(GP_FORMAT.format((long) (Long) value));
                    setHorizontalAlignment(RIGHT);
                } else if (value instanceof String) {
                    setHorizontalAlignment(CENTER);
                }
                return c;
            }
        };

        DefaultTableCellRenderer profitRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    long amount = (Long) value;
                    setText(GP_FORMAT.format(amount));
                    setHorizontalAlignment(RIGHT);

                    // Color profit/loss only if not selected
                    if (!isSelected) {
                        if (amount > 0) {
                            setForeground(config.profitAmountColor());
                        } else if (amount < 0) {
                            setForeground(config.lossAmountColor());
                        } else {
                            setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                        }
                    }
                }
                return c;
            }
        };

        table.getColumnModel().getColumn(7).setCellRenderer(moneyRenderer); // Avg. buy price
        table.getColumnModel().getColumn(8).setCellRenderer(moneyRenderer); // Avg. sell price
        table.getColumnModel().getColumn(9).setCellRenderer(moneyRenderer); // Tax
        table.getColumnModel().getColumn(10).setCellRenderer(profitRenderer); // Profit (with color)
        table.getColumnModel().getColumn(11).setCellRenderer(moneyRenderer); // Profit ea.

        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);
        table.getColumnModel().getColumn(2).setCellRenderer(centerRenderer); // Account
        table.getColumnModel().getColumn(4).setCellRenderer(centerRenderer); // Status
        table.getColumnModel().getColumn(5).setCellRenderer(centerRenderer); // Bought
        table.getColumnModel().getColumn(6).setCellRenderer(centerRenderer); // Sold

        accountDropdown = new AccountDropdown(
                this.copilotLoginManager::displayNameToAccountIdMap,
                sortAndFilter::setAccountId,
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        accountDropdown.setPreferredSize(new Dimension(120, accountDropdown.getPreferredSize().height));
        accountDropdown.setToolTipText("Select account");

        timeIntervalDropdown = new IntervalDropdown(sortAndFilter::setInterval, IntervalDropdown.ALL_TIME, false);
        timeIntervalDropdown.setPreferredSize(new Dimension(150, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setToolTipText("Select time interval");


        leftPanel.add(searchField);
        leftPanel.add(Box.createRigidArea(new Dimension(3,0)));
        leftPanel.add(timeIntervalDropdown);
        leftPanel.add(Box.createRigidArea(new Dimension(3,0)));
        leftPanel.add(accountDropdown);
        leftPanel.add(Box.createRigidArea(new Dimension(3,0)));
        leftPanel.add(showOpeningFlipsCheckbox);

        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        layeredPane.setOpaque(true);

        spinner = new Spinner();
        spinner.show();
        spinnerOverlay = new JPanel(new GridBagLayout());
        spinnerOverlay.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spinnerOverlay.setOpaque(true);
        spinnerOverlay.add(spinner);
        spinnerOverlay.setVisible(false); // Initially hidden

        scrollPane = new JScrollPane(table);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);

        layeredPane.setLayout(new OverlayLayout(layeredPane));
        layeredPane.add(spinnerOverlay, JLayeredPane.MODAL_LAYER);
        layeredPane.add(scrollPane, JLayeredPane.DEFAULT_LAYER);

        add(layeredPane, BorderLayout.CENTER);

        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel pageSizePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        pageSizePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizePanel.setBorder(BorderFactory.createEmptyBorder(4,0, 0,0));
        JLabel pageSizeLabel = new JLabel("Page size:");
        pageSizePanel.add(pageSizeLabel);
        pageSizePanel.add(pageSizeComboBox);
        paginatorPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(0,0, 0,pageSizePanel.getPreferredSize().width ), paginatorPanel.getBorder()));
        bottomPanel.add(pageSizePanel, BorderLayout.WEST);
        bottomPanel.add(paginatorPanel, BorderLayout.CENTER);

        add(bottomPanel, BorderLayout.SOUTH);
    }

    private void setSpinnerVisible(boolean visible) {
        SwingUtilities.invokeLater(() -> {
            if (visible) {
                spinnerOverlay.setVisible(true);
                table.setEnabled(false);
            } else {
                spinnerOverlay.setVisible(false);
                table.setEnabled(true);
            }
        });
    }

    private JButton createDownloadButton() {
        JButton button = new JButton();
        button.setToolTipText("Download as CSV");
        button.setFocusable(false);
        button.setText("Download");
        button.addActionListener(e -> downloadAsCSV());
        return button;
    }

    private void showFlipMenu(MouseEvent e, int row) {
        FlipV2 flip = currentFlips.get(row);

        JPopupMenu menu = new JPopupMenu();
        JMenuItem visualizeFlip = new JMenuItem("Visualize flip");
        visualizeFlip.addActionListener(evt -> {
            onVisualizeFlip.accept(flip);
        });
        menu.add(visualizeFlip);
        
        JMenuItem deleteItem = new JMenuItem("Delete flip");
        deleteItem.addActionListener(evt -> {
            int result = JOptionPane.showConfirmDialog(this,
                    "Are you sure you want to delete this flip?",
                    "Confirm Delete",
                    JOptionPane.YES_NO_OPTION);
            if (result == JOptionPane.YES_OPTION) {
                setSpinnerVisible(true);
                log.info("deleting flip with ID: {}", flip.getId());
                Consumer<FlipV2> onSuccess = (f) -> {
                    flipsManager.mergeFlips(Collections.singletonList(f),copilotLoginManager.getCopilotUserId());
                    setSpinnerVisible(false);
                    sortAndFilter.reloadFlips(true, true);
                };
                apiRequestHandler.asyncDeleteFlip(flip, onSuccess, () -> setSpinnerVisible(false));
            }
        });
        menu.add(deleteItem);

        String displayName = copilotLoginManager.getDisplayName(flip.getAccountId());
        if (displayName != null && !FlipStatus.FINISHED.equals(flip.getStatus())) {
            JMenuItem missedSellTransaction = new JMenuItem("Add missed sell transaction");
            missedSellTransaction.addActionListener(evt -> {
                int qty = flip.getOpenedQuantity() - flip.getClosedQuantity();
                int suggestedPrice = (int) (flip.getAvgBuyPrice() * 1.02);

                JPanel dialogPanel = new JPanel(new GridBagLayout());
                GridBagConstraints gbc = new GridBagConstraints();
                gbc.insets = new Insets(5, 5, 5, 5);
                gbc.anchor = GridBagConstraints.WEST;
                gbc.gridx = 0; gbc.gridy = 0;
                dialogPanel.add(new JLabel("Item:"), gbc);
                gbc.gridx = 1;
                dialogPanel.add(new JLabel(flip.getCachedItemName()), gbc);
                gbc.gridx = 0; gbc.gridy = 1;
                dialogPanel.add(new JLabel("Quantity:"), gbc);
                gbc.gridx = 1;
                dialogPanel.add(new JLabel(String.valueOf(qty)), gbc);
                gbc.gridx = 0; gbc.gridy = 2;
                dialogPanel.add(new JLabel("Sell Price:"), gbc);
                gbc.gridx = 1;
                JTextField priceField = new JTextField(String.valueOf(suggestedPrice), 10);
                dialogPanel.add(priceField, gbc);

                int result = JOptionPane.showConfirmDialog(this,
                        dialogPanel,
                        "Add Missed Sell Transaction",
                        JOptionPane.YES_NO_OPTION,
                        JOptionPane.PLAIN_MESSAGE);

                if (result == JOptionPane.YES_OPTION) {
                    try {
                        int price = Integer.parseInt(priceField.getText().trim());
                        if (price <= 0) {
                            JOptionPane.showMessageDialog(this,
                                    "Price must be a positive number.",
                                    "Invalid Price",
                                    JOptionPane.ERROR_MESSAGE);
                            return;
                        }

                        setSpinnerVisible(true);
                        log.info("Adding missed sell transaction for flip with ID: {}", flip.getId());

                        Transaction t = new Transaction();
                        t.setId(UUID.randomUUID());
                        t.setType(OfferStatus.SELL);
                        t.setItemId(flip.getItemId());
                        t.setPrice(price);
                        t.setQuantity(qty);
                        t.setBoxId(0);
                        t.setAmountSpent(price * qty);
                        t.setTimestamp(Instant.now());
                        t.setCopilotPriceUsed(true);
                        t.setWasCopilotSuggestion(true);
                        t.setOfferTotalQuantity(qty);

                        BiConsumer<Integer, List<FlipV2>> onSuccess = (userId, flips) -> {
                            flipsManager.mergeFlips(flips, userId);
                            setSpinnerVisible(false);
                            sortAndFilter.reloadFlips(true, true);
                        };
                        Consumer<HttpResponseException> onFailure = (r) -> {
                            setSpinnerVisible(false);
                            JOptionPane.showMessageDialog(this,
                                    "Failed to add sell transaction. Please try again.",
                                    "Transaction Error",
                                    JOptionPane.ERROR_MESSAGE);
                        };
                        apiRequestHandler.sendTransactionsAsync(List.of(t), displayName, onSuccess, onFailure);

                    } catch (NumberFormatException ex) {
                        JOptionPane.showMessageDialog(this,
                                "Please enter a valid number for the price.",
                                "Invalid Price",
                                JOptionPane.ERROR_MESSAGE);
                    }
                }
            });
            menu.add(missedSellTransaction);
        }
        menu.show(e.getComponent(), e.getX(), e.getY());
    }

    private void downloadAsCSV() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setSelectedFile(new File("flips.csv"));
        if (fileChooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            try (FileWriter writer = new FileWriter(file)) {
                sortAndFilter.writeCsvRecords(writer);
                JOptionPane.showMessageDialog(this, "Flips exported successfully!",
                        "Export Complete", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                log.error("Error exporting flips", ex);
                JOptionPane.showMessageDialog(this, "Error exporting flips: " + ex.getMessage(),
                        "Export Error", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    private void showFlips(List<FlipV2> flips) {
        SwingUtilities.invokeLater(() -> {
            currentFlips = flips;
            tableModel.setRowCount(0);
            Map<Integer, String> accountIdToDisplayName = copilotLoginManager.accountIDToDisplayNameMap();
            for (FlipV2 flip : flips) {
                long profitPerItem = flip.getClosedQuantity() > 0 ? flip.getProfit() / flip.getClosedQuantity() : 0L;

                Object[] row = {
                        formatTimestamp(flip.getOpenedTime()),
                        formatTimestamp(flip.getClosedTime()),
                        accountIdToDisplayName.getOrDefault(flip.getAccountId(), "Display name not loaded"),
                        flip.getCachedItemName(),
                        flip.getStatus().name(),
                        flip.getOpenedQuantity(),
                        flip.getClosedQuantity(),
                        flip.getSpent() / flip.getOpenedQuantity(),
                        flip.getClosedQuantity() ==0 ? 0 : (flip.getReceivedPostTax() + flip.getTaxPaid()) / flip.getClosedQuantity(),
                        flip.getTaxPaid(),
                        flip.getProfit(),
                        profitPerItem
                };
                tableModel.addRow(row);
            }

            for (int i = 0; i < table.getColumnCount(); i++) {
                resizeColumnWidth(table, i);
            }
        });
    }

    private void resizeColumnWidth(JTable table, int column) {
        TableColumn tableColumn = table.getColumnModel().getColumn(column);
        int preferredWidth = tableColumn.getMinWidth();
        int maxWidth = tableColumn.getMaxWidth();
        Component comp = table.getTableHeader().getDefaultRenderer()
                .getTableCellRendererComponent(table, tableColumn.getHeaderValue(), false, false, 0, column);
        preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);
        for (int row = 0; row < table.getRowCount(); row++) {
            comp = table.getCellRenderer(row, column)
                    .getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);
            preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);
        }

        preferredWidth = Math.min(preferredWidth, maxWidth);
        tableColumn.setPreferredWidth(preferredWidth);
    }

    private String formatTimestamp(int epochSeconds) {
        if (epochSeconds == 0) {
            return "N/A";
        }
        return formatEpoch(epochSeconds);
    }

    public void onTabShown() {
        sortAndFilter.reloadFlips(true, true);
        accountDropdown.refresh();
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.model.FlipManager;
import com.flippingcopilot.model.ItemIdName;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.model.SessionManager;
import com.google.inject.name.Named;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@Singleton
public class FlipsDialogController {

    private final ItemController itemController;
    private final FlipManager flipsManager;
    private final ExecutorService executorService;
    private final SessionManager sessionManager;
    private final CopilotLoginManager copilotLoginManager;
    private final FlippingCopilotConfig config;
    private final ApiRequestHandler apiRequestHandler;
    private final PriceGraphConfigManager priceGraphConfigManager;
    private final OsrsLoginManager osrsLoginManager;

    public PriceGraphPanel priceGraphPanel;
    private JTabbedPane tabbedPane;
    private JDialog dialog;
    private FlipsPanel flipsPanel;

    @Inject
    public FlipsDialogController(
            @Named("copilotExecutor") ScheduledExecutorService executorService,
            ItemController itemController,
            FlipManager flipsManager,
            SessionManager sessionManager,
            CopilotLoginManager copilotLoginManager,
            FlippingCopilotConfig config,
            ApiRequestHandler apiRequestHandler,
            PriceGraphConfigManager priceGraphConfigManager, OsrsLoginManager osrsLoginManager) {
        this.itemController = itemController;
        this.flipsManager = flipsManager;
        this.executorService = executorService;
        this.sessionManager = sessionManager;
        this.copilotLoginManager = copilotLoginManager;
        this.config = config;
        this.apiRequestHandler = apiRequestHandler;
        this.priceGraphConfigManager = priceGraphConfigManager;
        this.osrsLoginManager = osrsLoginManager;
    }

    public void initDialog(Window windowAncestor) {
        SwingUtilities.invokeLater(() -> {
            tabbedPane = new JTabbedPane();
            tabbedPane.setBackground(ColorScheme.DARK_GRAY_COLOR);

            VisualizeFlipPanel visualizeFlipPanel = new VisualizeFlipPanel(
                    itemController,
                    priceGraphConfigManager,
                    config,
                    apiRequestHandler
            );
            flipsPanel = new FlipsPanel(flipsManager, itemController, copilotLoginManager,
                    executorService, config, apiRequestHandler, (f) -> {
                visualizeFlipPanel.showFlipVisualization(f);
                tabbedPane.setSelectedIndex(6);
            });
            ItemAggregatePanel itemsPanel = new ItemAggregatePanel(flipsManager, itemController,
                    copilotLoginManager, executorService, config);
            AccountsAggregatePanel accountsPanel = new AccountsAggregatePanel(flipsManager, copilotLoginManager,
                    executorService, config, apiRequestHandler, flipsManager);
            ProfitPanel profitPanel = new ProfitPanel(flipsManager, executorService, sessionManager,
                    copilotLoginManager, config);
            TransactionsPanel transactionsPanel = new TransactionsPanel(copilotLoginManager, itemController,
                    executorService, apiRequestHandler, config, flipsManager);
            priceGraphPanel = new PriceGraphPanel(
                    itemController,
                    priceGraphConfigManager,
                    config,
                    apiRequestHandler,
                    osrsLoginManager,
                    priceGraphConfigManager
            );
            tabbedPane.addTab("Flips", flipsPanel);
            tabbedPane.addTab("Items", itemsPanel);
            tabbedPane.addTab("Accounts", accountsPanel);
            tabbedPane.addTab("Profit graph", profitPanel);
            tabbedPane.addTab("Transactions", transactionsPanel);
            tabbedPane.addTab("Price graph", priceGraphPanel);
            tabbedPane.addTab("Visualize flip", visualizeFlipPanel);


            JDialog dialog = new JDialog(windowAncestor);
            dialog.setTitle("Flipping Copilot");
            dialog.setResizable(true);
            dialog.setMinimumSize(new Dimension(800, 600));


            tabbedPane.addChangeListener(e -> {
                int selectedIndex = tabbedPane.getSelectedIndex();
                switch (selectedIndex) {
                    case 0:
                        flipsPanel.onTabShown();
                        break;
                    case 1:
                        itemsPanel.onTabShown();
                        break;
                    case 2:
                        accountsPanel.onTabShown();
                        break;
                    case 3:
                        profitPanel.refreshGraph(true);
                    case 4:
                        transactionsPanel.loadTransactionsIfNeeded();
                        break;
                    case 5:
                        priceGraphPanel.onTabShown();
                        break;
                }
            });
            dialog.setContentPane(tabbedPane);

            GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
            Rectangle bounds = env.getMaximumWindowBounds(); // Excludes taskbar
            dialog.setSize(bounds.width, bounds.height);
            dialog.setLocation(bounds.x, bounds.y);

            this.dialog = dialog;
            dialog.setDefaultCloseOperation(WindowConstants.HIDE_ON_CLOSE);
            dialog.setModalityType(Dialog.ModalityType.MODELESS);
            dialog.setVisible(false);
        });
    }

    public void showPriceGraphTab(Integer openOnPriceGraphItemId, boolean suggestionPriceGraph) {
        tabbedPane.setSelectedIndex(5);
        if(openOnPriceGraphItemId != null) {
            priceGraphPanel.isShowingSuggestionPriceData = false;
            priceGraphPanel.searchBox.setItem(new ItemIdName(openOnPriceGraphItemId, itemController.getItemName(openOnPriceGraphItemId)));
        } else if (suggestionPriceGraph)  {
            priceGraphPanel.showSuggestionPriceGraph();
        } else {
            priceGraphPanel.showLandingCard();
        }
        dialog.setVisible(true);
    }


    public void showFlipsTab() {
        tabbedPane.setSelectedIndex(0);
        dialog.setVisible(true);
        flipsPanel.onTabShown();
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.FlipManager;
import com.flippingcopilot.model.FlipV2;
import com.flippingcopilot.model.SessionManager;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.IntervalDropdown;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import java.awt.*;
import java.time.*;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;

@Slf4j
public class ProfitPanel extends JPanel {

    // dependencies
    private final FlipManager flipManager;
    private final ExecutorService executorService;

    private final ProfitGraphPanel graphPanel;
    private final AccountDropdown accountDropdown;
    private final IntervalDropdown intervalDropdown;

    // State
    private int cachedIntervalStartTime = 1; // Default to ALL
    private Integer cachedAccountId = null;
    private List<Datapoint> cachedDatapoints = new ArrayList<>();

    public ProfitPanel(FlipManager flipManager,
                       @Named("copilotExecutor") ExecutorService executorService,
                       SessionManager sessionManager,
                       CopilotLoginManager copilotLoginManager,
                       FlippingCopilotConfig config) {
        this.flipManager = flipManager;
        this.executorService = executorService;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create top panel with controls
        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        // Create left panel with dropdowns
        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        intervalDropdown = new IntervalDropdown((units, value) -> refreshGraph(false), IntervalDropdown.ALL_TIME, false);
        intervalDropdown.setPreferredSize(new Dimension(150, intervalDropdown.getPreferredSize().height));
        intervalDropdown.setToolTipText("Select time interval");

        accountDropdown = new AccountDropdown(
                copilotLoginManager::displayNameToAccountIdMap,
                accountId -> refreshGraph(false),
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        accountDropdown.setPreferredSize(new Dimension(120, accountDropdown.getPreferredSize().height));
        accountDropdown.setToolTipText("Select account");
        accountDropdown.refresh();

        leftPanel.add(intervalDropdown);
        leftPanel.add(Box.createRigidArea(new Dimension(3, 0)));
        leftPanel.add(accountDropdown);

        topPanel.add(leftPanel, BorderLayout.WEST);
        add(topPanel, BorderLayout.NORTH);

        // Create a panel to hold both graphs
        JPanel graphsPanel = new JPanel();
        graphsPanel.setLayout(new BoxLayout(graphsPanel, BoxLayout.Y_AXIS));
        graphsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create graph panels
        graphPanel = new ProfitGraphPanel(config.profitAmountColor(), config.lossAmountColor());
        graphsPanel.add(graphPanel);

        // Add the graphs panel to a scroll pane in case they don't fit
        JScrollPane scrollPane = new JScrollPane(graphsPanel);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setBorder(null);
        scrollPane.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);

        add(scrollPane, BorderLayout.CENTER);
    }

    public void refreshGraph(boolean forceRecalculate) {
        executorService.submit(() -> {
            try {
                // not fully initialised
                if(accountDropdown == null || intervalDropdown == null) {
                    return;
                }
                accountDropdown.refresh();
                // Check if we need to regenerate the data
                Integer accountId = accountDropdown.getSelectedAccountId();
                int startTime = (int) IntervalDropdown.calculateStartTime(intervalDropdown.getSelectedIntervalTimeUnit(), intervalDropdown.getSelectedIntervalValue(), 0);
                boolean needsRegeneration = forceRecalculate || cachedDatapoints.isEmpty() ||
                        !Objects.equals(cachedAccountId, accountId) ||
                        cachedIntervalStartTime != startTime;

                if (needsRegeneration) {
                    log.debug("Regenerating profit data points");
                    ProfitAggregator aggregator = new ProfitAggregator();
                    cachedIntervalStartTime = startTime;
                    cachedAccountId = accountId;
                    flipManager.aggregateFlips(cachedIntervalStartTime, cachedAccountId, false, aggregator);
                    cachedDatapoints = aggregator.generateProfitDataPoints();
                    log.debug("Generated {} profit data points and {} daily profits", cachedDatapoints.size(), cachedDatapoints.size());
                }

                SwingUtilities.invokeLater(() -> {
                    graphPanel.setData(cachedDatapoints);
                    graphPanel.repaint();
                });
            } catch (Exception e) {
                log.error("Error refreshing profit graph", e);
            }
        });
    }

    @NoArgsConstructor
    private static class ProfitAggregator implements Consumer<FlipV2> {
        private final Map<LocalDate, Long> dailyProfits = new TreeMap<>();
        private final ZoneId zoneId = ZoneId.systemDefault();

        @Override
        public void accept(FlipV2 flip) {
            if (flip.getClosedQuantity() > 0) {
                LocalDate flipDate = LocalDate.ofInstant(Instant.ofEpochSecond(flip.getClosedTime()), zoneId);
                dailyProfits.merge(flipDate, flip.getProfit(), Long::sum);
            }
        }

        public List<Datapoint> generateProfitDataPoints() {
            List<Datapoint> dataPoints = new ArrayList<>();
            if (dailyProfits.isEmpty()) {
                dataPoints.add(new Datapoint(LocalDate.now(zoneId), 0L, 0L));
            }
            long cumulativeProfit = 0;
            for (Map.Entry<LocalDate, Long> entry : dailyProfits.entrySet()) {
                long dailyProfit = entry.getValue();
                cumulativeProfit += dailyProfit;
                dataPoints.add(new Datapoint(entry.getKey(), cumulativeProfit, dailyProfit));
            }
            return dataPoints;
        }
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.model.ItemPrice;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.UIUtilities;
import com.flippingcopilot.ui.components.ItemSearchBox;
import com.flippingcopilot.ui.components.TrackingCardLayout;
import com.flippingcopilot.ui.graph.ConfigPanel;
import com.flippingcopilot.ui.graph.DataManager;
import com.flippingcopilot.ui.graph.GraphPanel;
import com.flippingcopilot.ui.graph.StatsPanel;
import com.flippingcopilot.ui.graph.model.Data;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.function.Consumer;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;
import static com.flippingcopilot.ui.UIUtilities.buildButton;
import static org.apache.commons.lang3.ObjectUtils.firstNonNull;

@Slf4j
public class PriceGraphPanel extends JPanel {

    // Dependencies
    private final ItemController itemController;
    private final ApiRequestHandler apiRequestHandler;
    private final OsrsLoginManager osrsLoginManager;
    private final PriceGraphConfigManager priceGraphConfigManager;

    // UI Components
    public final ItemSearchBox searchBox;
    private final JPanel contentPanel;
    private final JLabel errorLabel = new JLabel();
    private final GraphPanel graphPanel;
    private final StatsPanel statsPanel;
    private final TrackingCardLayout contentCardLayout = new TrackingCardLayout();
    private final JButton showSuggestionButton;

    // State
    private volatile int currentItemId;

    // when isShowingSuggestionPriceData, the graph will auto update with the latest suggestion
    public volatile boolean isShowingSuggestionPriceData;
    public volatile Data suggestionPriceData;


    public PriceGraphPanel(ItemController itemController,
                           PriceGraphConfigManager configManager,
                           FlippingCopilotConfig copilotConfig,
                           ApiRequestHandler apiRequestHandler,
                           OsrsLoginManager osrsLoginManager, PriceGraphConfigManager priceGraphConfigManager) {
        this.itemController = itemController;
        this.apiRequestHandler = apiRequestHandler;
        this.osrsLoginManager = osrsLoginManager;
        this.priceGraphConfigManager = priceGraphConfigManager;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JPanel searchPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 0));
        searchPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel searchLabel = new JLabel("Search item:");
        searchLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        searchPanel.add(searchLabel);


        searchBox = new ItemSearchBox(
                (searchText, ignoredSet) -> itemController.search(searchText, itemController.allItemIds()),
                this::onItemSelected
        );
        searchBox.setPreferredSize(new Dimension(300, 30));
        searchPanel.add(searchBox);

        topPanel.add(searchPanel, BorderLayout.WEST);

        // Add the suggestion button to the right side
        JPanel rightPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 0));
        rightPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        showSuggestionButton = new JButton("Switch to suggested item");
        showSuggestionButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        showSuggestionButton.setFocusable(false);
        showSuggestionButton.setVisible(!isShowingSuggestionPriceData);
        showSuggestionButton.addActionListener(e -> {
            searchBox.clear();
            showSuggestionPriceGraph();
        });
        rightPanel.add(showSuggestionButton);

        contentPanel = new JPanel(contentCardLayout);

        try {
            BufferedImage gearIcon = ImageUtil.loadImageResource(getClass(), "/preferences-icon.png");
            gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
            BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
            JLabel gearButton = UIUtilities.buildButton(recoloredIcon, "Graph Settings", ()-> {
                if(contentCardLayout.getCurrentCard().equals(Cards.SETTINGS_CARD.name())) {
                    contentCardLayout.showPrevious(contentPanel);
                } else {
                    contentCardLayout.show(contentPanel, Cards.SETTINGS_CARD.name());
                }
            });
            rightPanel.add(gearButton, BorderLayout.EAST);
        } catch (Exception e) {
            log.error("error creating graph settings button", e);
        }

        topPanel.add(rightPanel, BorderLayout.EAST);

        add(topPanel, BorderLayout.NORTH);

        graphPanel = new GraphPanel(configManager);
        statsPanel = new StatsPanel(configManager, copilotConfig);
        statsPanel.setBackground(configManager.getConfig().backgroundColor);
        statsPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        contentPanel.add(buildLandingCard(), Cards.LANDING_CARD.name());
        contentPanel.add(buildLogIntoGameCard(), Cards.LOGIN_PROMPT.name());
        contentPanel.add(buildLoadingCard(), Cards.LOADING_CARD.name());
        contentPanel.add(buildGraphCard(), Cards.GRAPH_CARD.name());
        contentPanel.add(buildErrorCard(), Cards.ERROR_CARD.name());
        contentPanel.add(buildSettingsCard(), Cards.SETTINGS_CARD.name());


        errorLabel.setForeground(Color.RED);
        errorLabel.setFont(errorLabel.getFont().deriveFont(14f));
        errorLabel.setHorizontalAlignment(SwingConstants.CENTER);

        add(contentPanel, BorderLayout.CENTER);

        contentCardLayout.show(contentPanel, Cards.LANDING_CARD.name());
    }

    private JPanel buildSettingsCard() {
        JPanel settingsPanel = new ConfigPanel(priceGraphConfigManager, () -> {});
        return settingsPanel;
    }

    private void onItemSelected(Integer itemId) {
        if (itemId == null) {
            return;
        }
        if(osrsLoginManager.getPlayerDisplayName() == null) {
            contentCardLayout.show(contentPanel, Cards.LOGIN_PROMPT.name());
            return;
        }
        isShowingSuggestionPriceData = false;
        showSuggestionButton.setVisible(true);
        currentItemId = itemId;
        log.debug("Loading price graph for item: {}", itemId);
        contentCardLayout.show(contentPanel, Cards.LOADING_CARD.name());
        Consumer<ItemPrice> consumer = (ItemPrice itemPrice) -> {
            SwingUtilities.invokeLater(() -> {
                String errorMessage = firstNonNull(itemPrice.getMessage(), "");
                if (!errorMessage.isEmpty()) {
                    showErrorCard(errorMessage);
                } else {
                    showGraphCard(new DataManager(itemPrice.getGraphData(), null));
                }
            });
        };
        apiRequestHandler.asyncGetItemPriceWithGraphData(itemId, "FlipCopilot", consumer, true);
    }

    public void setLoadingCard() {
        contentCardLayout.show(contentPanel, Cards.LOADING_CARD.name());
    }

    public void setSuggestionPriceData(Data d) {
        suggestionPriceData = d;
        if (isShowingSuggestionPriceData) {
            DataManager dm = new DataManager(d, null);
            graphPanel.setData(dm);
            contentCardLayout.show(contentPanel, Cards.GRAPH_CARD.name());
            statsPanel.populate(dm, itemController);
        }
    }

    private JPanel buildLogIntoGameCard() {
        JPanel landingCard = new JPanel(new GridBagLayout());
        landingCard.setBackground(ColorScheme.DARK_GRAY_COLOR);
        JLabel emptyLabel = new JLabel("Log into game to use price graphs.");
        emptyLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        emptyLabel.setFont(emptyLabel.getFont().deriveFont(16f));
        landingCard.add(emptyLabel);
        return landingCard;
    }

    private JPanel buildLandingCard() {
        JPanel landingCard = new JPanel(new GridBagLayout());
        landingCard.setBackground(ColorScheme.DARK_GRAY_COLOR);
        JLabel emptyLabel = new JLabel("Search for an item to view its price graph");
        emptyLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        emptyLabel.setFont(emptyLabel.getFont().deriveFont(16f));
        landingCard.add(emptyLabel);
        return landingCard;
    }

    private JPanel buildLoadingCard() {
        JLabel loadingLabel = new JLabel("Loading price data...");
        Spinner spinner = new Spinner();
        loadingLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        loadingLabel.setFont(loadingLabel.getFont().deriveFont(14f));
        JPanel loadingPanel = new JPanel(new GridBagLayout());
        loadingPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);
        spinner.show();
        loadingPanel.add(spinner, gbc);
        gbc.gridy = 1;
        loadingPanel.add(loadingLabel, gbc);
        return loadingPanel;
    }

    private JPanel buildErrorCard() {
        JPanel errorPanel = new JPanel(new GridBagLayout());
        errorPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);
        errorPanel.add(errorLabel, gbc);
        gbc.gridy = 1;
        gbc.insets = new Insets(20, 10, 10, 10);
        JButton retryButton = new JButton("Retry");
        retryButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        retryButton.setFocusable(false);
        retryButton.addActionListener(e -> {
            if (currentItemId > 0) {
                onItemSelected(currentItemId);
            }
        });
        errorPanel.add(retryButton, gbc);
        return errorPanel;
    }

    private void showErrorCard(String errorMessage) {
        showSuggestionButton.setVisible(false);
        errorLabel.setText("<html><center>" + errorMessage + "</center></html>");
        contentCardLayout.show(contentPanel, Cards.ERROR_CARD.name());
    }

    private void showGraphCard(DataManager dm) {
        showSuggestionButton.setVisible(true);
        graphPanel.setData(dm);
        contentCardLayout.show(contentPanel, Cards.GRAPH_CARD.name());
        statsPanel.populate(dm, itemController);
    }

    public void showLandingCard() {
        showSuggestionButton.setVisible(false);
        if(osrsLoginManager.getPlayerDisplayName() == null) {
            contentCardLayout.show(contentPanel, Cards.LOGIN_PROMPT.name());
            return;
        }
        contentCardLayout.show(contentPanel, Cards.LANDING_CARD.name());
    }

    private JSplitPane buildGraphCard() {
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, true);
        splitPane.setLeftComponent(graphPanel);
        splitPane.setRightComponent(statsPanel);
        splitPane.setResizeWeight(0.95); // Graph gets 75% of space
        splitPane.setDividerLocation(0.95);
        splitPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        return splitPane;
    }

    public void onTabShown() {
        String currentCard = contentCardLayout.getCurrentCard();
        if(currentCard.equals(Cards.LANDING_CARD.name()) || currentCard.equals(Cards.LOGIN_PROMPT.name())) {
            showLandingCard();
        }
    }

    public void showSuggestionPriceGraph() {
        isShowingSuggestionPriceData = true;
        showSuggestionButton.setVisible(false);
        setLoadingCard();
        if (suggestionPriceData != null) {
            setSuggestionPriceData(suggestionPriceData);
        }
    }

    public void newSuggestedItemId(int itemId) {
        if(suggestionPriceData != null && suggestionPriceData.itemId != itemId) {
            suggestionPriceData = null;
            if(isShowingSuggestionPriceData) {
                showSuggestionPriceGraph();
            }
        }
    }

    enum Cards {
        LANDING_CARD,
        LOGIN_PROMPT,
        GRAPH_CARD,
        LOADING_CARD,
        ERROR_CARD,
        SETTINGS_CARD,
    }
}
package com.flippingcopilot.ui.flipsdialog;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.CopilotLoginManager;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.Paginator;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.components.AccountDropdown;
import com.flippingcopilot.ui.components.IntervalDropdown;
import com.flippingcopilot.ui.components.ItemSearchMultiSelect;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Named;
import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.NumberFormat;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;

@Slf4j
public class ItemAggregatePanel extends JPanel {

    private static final Integer[] PAGE_SIZE_OPTIONS = {10, 25, 50, 100, 200, 500, 1000, 2000};
    private static final NumberFormat GP_FORMAT = NumberFormat.getNumberInstance(Locale.US);

    // dependencies
    private final CopilotLoginManager copilotLoginManager;

    // ui components
    private final DefaultTableModel tableModel;
    private final JTable table;
    private final Paginator paginatorPanel;
    private final Spinner spinner;
    private final JScrollPane scrollPane;
    private ItemSearchMultiSelect searchField;
    private IntervalDropdown timeIntervalDropdown;
    private AccountDropdown accountDropdown;
    private JComboBox<Integer> pageSizeComboBox;

    // state
    private ItemAggregateFilterSort sortAndFilter;

    private final String[] columnNames = {
            "Item", "Number of flips", "Total quantity flipped", "Biggest loss", "Biggest win", "Total profit", "Avg profit", "Avg profit ea."
    };
    private JPanel spinnerOverlay;

    public ItemAggregatePanel(FlipManager flipsManager,
                              ItemController itemController,
                              CopilotLoginManager copilotLoginManager,
                              @Named("copilotExecutor") ExecutorService executorService,
                              FlippingCopilotConfig config) {
        this.copilotLoginManager = copilotLoginManager;
        setFocusable(true);

        paginatorPanel = new Paginator((i) -> sortAndFilter.setPage(i));
        sortAndFilter = new ItemAggregateFilterSort(flipsManager, itemController, this::showAggregates,
                paginatorPanel::setTotalPages, this::setSpinnerVisible, executorService);

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        JPanel leftPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        searchField = new ItemSearchMultiSelect(
                sortAndFilter::getFilteredItems,
                itemController::allItemIds,
                itemController::search,
                sortAndFilter::setFilteredItems,
                "Items filter...",
                SwingUtilities.getWindowAncestor(this));
        searchField.setMinimumSize(new Dimension(300, 0));
        searchField.setToolTipText("Search by item name");

        pageSizeComboBox = new JComboBox<>(PAGE_SIZE_OPTIONS);
        pageSizeComboBox.setSelectedItem(sortAndFilter.getPageSize());
        pageSizeComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizeComboBox.setFocusable(false);
        pageSizeComboBox.setToolTipText("Page size");
        pageSizeComboBox.addActionListener(e -> sortAndFilter.setPageSize((Integer) pageSizeComboBox.getSelectedItem()));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
        buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        topPanel.add(leftPanel, BorderLayout.WEST);
        topPanel.add(buttonPanel, BorderLayout.EAST);
        add(topPanel, BorderLayout.NORTH);

        tableModel = new DefaultTableModel(columnNames, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        table = new JTable(tableModel);
        table.setBackground(ColorScheme.DARK_GRAY_COLOR);
        table.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        table.setSelectionBackground(ColorScheme.BRAND_ORANGE);
        table.setSelectionForeground(Color.WHITE);
        table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
        table.setRowHeight(25);
        table.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);

        table.setRowSorter(null);
        table.getTableHeader().setReorderingAllowed(false);
        table.setFocusable(false);

        table.getTableHeader().addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                int columnIndex = table.getTableHeader().columnAtPoint(e.getPoint());
                if (columnIndex >= 0 && columnIndex < columnNames.length) {
                    String clickedColumn = columnNames[columnIndex];

                    SortDirection newDirection = SortDirection.DESC;
                    if (clickedColumn.equals(sortAndFilter.getSortColumn())) {
                        newDirection = sortAndFilter.getSortDirection() == SortDirection.DESC ?
                                SortDirection.ASC : SortDirection.DESC;
                    }

                    sortAndFilter.setSortColumn(clickedColumn);
                    sortAndFilter.setSortDirection(newDirection);
                }
            }
        });

        DefaultTableCellRenderer moneyRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    setText(formatGp((Long) value));
                    setHorizontalAlignment(RIGHT);
                }
                return c;
            }
        };

        DefaultTableCellRenderer profitRenderer = new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value,
                                                           boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                if (value instanceof Long) {
                    long amount = (Long) value;
                    setText(formatGp(amount));
                    setHorizontalAlignment(RIGHT);

                    // Color profit/loss only if not selected
                    if (!isSelected) {
                        if (amount > 0) {
                            setForeground(config.profitAmountColor());
                        } else if (amount < 0) {
                            setForeground(config.lossAmountColor());
                        } else {
                            setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                        }
                    }
                }
                return c;
            }
        };

        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(JLabel.CENTER);

        table.getColumnModel().getColumn(1).setCellRenderer(centerRenderer);
        table.getColumnModel().getColumn(2).setCellRenderer(moneyRenderer);
        table.getColumnModel().getColumn(3).setCellRenderer(moneyRenderer);
        table.getColumnModel().getColumn(4).setCellRenderer(profitRenderer);
        table.getColumnModel().getColumn(5).setCellRenderer(profitRenderer);
        table.getColumnModel().getColumn(6).setCellRenderer(profitRenderer);
        table.getColumnModel().getColumn(7).setCellRenderer(profitRenderer);

        setupDropdowns();

        leftPanel.add(searchField);
        leftPanel.add(Box.createRigidArea(new Dimension(3, 0)));
        leftPanel.add(timeIntervalDropdown);
        leftPanel.add(Box.createRigidArea(new Dimension(3, 0)));
        leftPanel.add(accountDropdown);

        JLayeredPane layeredPane = new JLayeredPane();
        layeredPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        layeredPane.setOpaque(true);

        spinner = new Spinner();
        spinner.show();
        spinnerOverlay = new JPanel(new GridBagLayout());
        spinnerOverlay.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spinnerOverlay.setOpaque(true);
        spinnerOverlay.add(spinner);
        spinnerOverlay.setVisible(false); // Initially hidden

        scrollPane = new JScrollPane(table);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);

        layeredPane.setLayout(new OverlayLayout(layeredPane));
        layeredPane.add(spinnerOverlay, JLayeredPane.MODAL_LAYER);
        layeredPane.add(scrollPane, JLayeredPane.DEFAULT_LAYER);

        add(layeredPane, BorderLayout.CENTER);

        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel pageSizePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        pageSizePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pageSizePanel.setBorder(BorderFactory.createEmptyBorder(4, 0, 0, 0));
        JLabel pageSizeLabel = new JLabel("Page size:");
        pageSizePanel.add(pageSizeLabel);
        pageSizePanel.add(pageSizeComboBox);
        paginatorPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createEmptyBorder(0, 0, 0, pageSizePanel.getPreferredSize().width),
                paginatorPanel.getBorder()));
        bottomPanel.add(pageSizePanel, BorderLayout.WEST);
        bottomPanel.add(paginatorPanel, BorderLayout.CENTER);

        add(bottomPanel, BorderLayout.SOUTH);
    }

    private void setSpinnerVisible(boolean visible) {
        SwingUtilities.invokeLater(() -> {
            if (visible) {
                spinnerOverlay.setVisible(true);
                table.setEnabled(false);
            } else {
                spinnerOverlay.setVisible(false);
                table.setEnabled(true);
            }
        });
    }

    private void setupDropdowns() {
        accountDropdown = new AccountDropdown(
                copilotLoginManager::displayNameToAccountIdMap,
                sortAndFilter::setAccountId,
                AccountDropdown.ALL_ACCOUNTS_DROPDOWN_OPTION
        );
        accountDropdown.setPreferredSize(new Dimension(120, accountDropdown.getPreferredSize().height));
        accountDropdown.setToolTipText("Select account");
        accountDropdown.refresh();

        timeIntervalDropdown = new IntervalDropdown(sortAndFilter::setInterval, IntervalDropdown.ALL_TIME, false);
        timeIntervalDropdown.setPreferredSize(new Dimension(150, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setToolTipText("Select time interval");
    }

    private void showAggregates(List<ItemAggregate> aggregates) {
        SwingUtilities.invokeLater(() -> {
            tableModel.setRowCount(0);
            for (ItemAggregate aggregate : aggregates) {
                Object[] row = {
                        aggregate.getItemName(),
                        aggregate.getNumberOfFlips(),
                        aggregate.getTotalQuantityFlipped(),
                        aggregate.getBiggestLoss(),
                        aggregate.getBiggestWin(),
                        aggregate.getTotalProfit(),
                        aggregate.getAvgProfit(),
                        aggregate.getAvgProfitEa()
                };
                tableModel.addRow(row);
            }

            for (int i = 0; i < table.getColumnCount(); i++) {
                resizeColumnWidth(table, i);
            }
        });
    }

    private void resizeColumnWidth(JTable table, int column) {
        TableColumn tableColumn = table.getColumnModel().getColumn(column);
        int preferredWidth = tableColumn.getMinWidth();
        int maxWidth = tableColumn.getMaxWidth();

        Component comp = table.getTableHeader().getDefaultRenderer()
                .getTableCellRendererComponent(table, tableColumn.getHeaderValue(), false, false, 0, column);
        preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);

        for (int row = 0; row < table.getRowCount(); row++) {
            comp = table.getCellRenderer(row, column)
                    .getTableCellRendererComponent(table, table.getValueAt(row, column), false, false, row, column);
            preferredWidth = Math.max(comp.getPreferredSize().width + 10, preferredWidth);
        }

        preferredWidth = Math.min(preferredWidth, maxWidth);
        tableColumn.setPreferredWidth(preferredWidth);
    }

    private String formatGp(long amount) {
        return GP_FORMAT.format(amount);
    }

    public void onTabShown() {
        sortAndFilter.reloadAggregates(true);
        accountDropdown.refresh();
    }
}
package com.flippingcopilot.ui.components;

import com.flippingcopilot.model.IntervalTimeUnit;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.plaf.basic.BasicComboBoxEditor;
import java.awt.*;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.function.BiConsumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class IntervalDropdown extends JComboBox<String> {

    public static final String SESSION = "Session";
    public static final String ALL_TIME = "All time";
    public static final String PICK_START_DATE = "Pick start date";
    private static final String[] TIME_INTERVAL_STRINGS = {
            "-1h (Past Hour)",
            "-4h (Past 4 Hours)",
            "-12h (Past 12 Hours)",
            "-1d (Past Day)",
            "-1w (Past Week)",
            "-1m (Past Month)",
            SESSION,
            ALL_TIME,
            PICK_START_DATE
    };

    private static final Pattern INTERVAL_PATTERN = Pattern.compile("^-?(\\d+(?:\\.\\d+)?)([hdwmy])[()\\w\\s]*");

    // state
    private final BiConsumer<IntervalTimeUnit, Integer> onIntervalChanged;
    @Getter
    private IntervalTimeUnit selectedIntervalTimeUnit = IntervalTimeUnit.ALL;
    @Getter
    private int selectedIntervalValue = -1;

    public IntervalDropdown(BiConsumer<IntervalTimeUnit, Integer> onIntervalChanged,
                            String initialValue,
                            boolean includeSessionOption) {
        super(Arrays.stream(TIME_INTERVAL_STRINGS).filter(i -> !i.equals(SESSION) || includeSessionOption).toArray(String[]::new));
        this.onIntervalChanged = onIntervalChanged;

        setEditable(true);
        setSelectedItem(initialValue);
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));
        setBorder(BorderFactory.createEmptyBorder());
        extractAndUpdateTimeInterval(initialValue);
        setEditor(new BasicComboBoxEditor());

        // Add action listener for selection changes and manual edits
        addActionListener(e -> {
            String value = (String) getSelectedItem();
            if (PICK_START_DATE.equals(value)) {
                showDatePicker();
            } else if (extractAndUpdateTimeInterval(value)) {
                onIntervalChanged.accept(selectedIntervalTimeUnit, selectedIntervalValue);
            }
        });
    }

    private void showDatePicker() {
        // Create a date spinner
        SpinnerDateModel dateModel = new SpinnerDateModel();
        JSpinner dateSpinner = new JSpinner(dateModel);
        JSpinner.DateEditor dateEditor = new JSpinner.DateEditor(dateSpinner, "yyyy-MM-dd");
        dateSpinner.setEditor(dateEditor);

        dateSpinner.setValue(new Date());
        int result = JOptionPane.showConfirmDialog(
                SwingUtilities.getWindowAncestor(this),
                dateSpinner,
                PICK_START_DATE,
                JOptionPane.OK_CANCEL_OPTION,
                JOptionPane.PLAIN_MESSAGE
        );

        if (result == JOptionPane.OK_OPTION) {
            Date selectedDate = (Date) dateSpinner.getValue();
            String intervalString = convertDateToIntervalString(selectedDate);
            setSelectedItem(intervalString);
            extractAndUpdateTimeInterval(intervalString);
            onIntervalChanged.accept(selectedIntervalTimeUnit, selectedIntervalValue);
        }
    }

    /**
     * Converts a selected date to an interval string like "3.5w" or "2d"
     */
    private String convertDateToIntervalString(Date selectedDate) {
        LocalDate selected = selectedDate.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        LocalDate today = LocalDate.now();

        long daysDiff = ChronoUnit.DAYS.between(selected, today);

        if (daysDiff < 0) {
            // Future date, return as days
            return Math.abs(daysDiff) + "d (Future)";
        }

        // Convert to appropriate unit
        if (daysDiff < 1) {
            // Less than a day, use hours
            long hoursDiff = ChronoUnit.HOURS.between(
                    selected.atStartOfDay(ZoneId.systemDefault()),
                    today.atStartOfDay(ZoneId.systemDefault())
            );
            return "-" + hoursDiff + "h";
        } else if (daysDiff < 7) {
            // Less than a week, use days
            return "-" + daysDiff + "d";
        } else if (daysDiff < 30) {
            // Less than a month, use weeks (with decimal)
            double weeks = daysDiff / 7.0;
            if (weeks == Math.floor(weeks)) {
                return "-" + (int)weeks + "w";
            } else {
                return String.format("-%.1fw", weeks);
            }
        } else if (daysDiff < 365) {
            // Less than a year, use months (approximation)
            double months = daysDiff / 30.0;
            if (months == Math.floor(months)) {
                return "-" + (int)months + "m";
            } else {
                return String.format("-%.1fm", months);
            }
        } else {
            // More than a year, use years
            double years = daysDiff / 365.0;
            if (years == Math.floor(years)) {
                return "-" + (int)years + "y";
            } else {
                return String.format("-%.1fy", years);
            }
        }
    }

    private boolean extractAndUpdateTimeInterval(String value) {
        if (value != null) {
            switch (value) {
                case "Session":
                    selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
                    selectedIntervalValue = -1;
                    return true;
                case ALL_TIME:
                    selectedIntervalTimeUnit = IntervalTimeUnit.ALL;
                    selectedIntervalValue = -1;
                    return true;
                case PICK_START_DATE:
                    // Don't update here, handled in action listener
                    return false;
                default:
                    Matcher matcher = INTERVAL_PATTERN.matcher(value);
                    if (matcher.matches()) {
                        String numberStr = matcher.group(1);
                        // Handle decimal values by rounding
                        double doubleValue = Double.parseDouble(numberStr);
                        selectedIntervalValue = (int) Math.round(doubleValue);
                        selectedIntervalTimeUnit = IntervalTimeUnit.fromString(matcher.group(2));
                        return true;
                    }
                    break;
            }
        }
        return false;
    }

    /**
     * Resets the dropdown to "Session" selection.
     */
    public void resetToSession() {
        setSelectedItem("Session");
        selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
        selectedIntervalValue = -1;
        onIntervalChanged.accept(selectedIntervalTimeUnit, selectedIntervalValue);
    }

    public static long calculateStartTime(IntervalTimeUnit selectedUnits, Integer selectedValue, Integer sessionStartTime) {
        switch (selectedUnits) {
            case ALL:
                return 1;
            case SESSION:
                return sessionStartTime;
            default:
                return Instant.now().getEpochSecond() - (long) selectedValue * selectedUnits.getSeconds();
        }
    }
}
package com.flippingcopilot.ui.components;
import com.google.common.base.MoreObjects;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.util.Map;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Supplier;

@Slf4j
public class AccountDropdown extends JComboBox<String> {

    public static final String ALL_ACCOUNTS_DROPDOWN_OPTION = "All accounts";

    // dependencies
    private final Supplier<Map<String, Integer>> accountsGetter;

    // state
    private Map<String, Integer> cachedAccounts;
    private volatile boolean refreshInProgress = false;

    public AccountDropdown(Supplier<Map<String, Integer>> accountsGetter, Consumer<Integer> onSelectedAccountChanged, String initialValue) {

        super();
        this.accountsGetter = accountsGetter;
        DefaultComboBoxModel<String> model = (DefaultComboBoxModel<String>) getModel();
        if(ALL_ACCOUNTS_DROPDOWN_OPTION.equals(initialValue)) {
            model.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
        } else {
            model.addElement(initialValue);
            model.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
        }
        setBorder(BorderFactory.createEmptyBorder());
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));
        setSelectedItem(initialValue);
        addItemListener(e -> {
            if (!refreshInProgress && e.getStateChange() == ItemEvent.SELECTED) {
                onSelectedAccountChanged.accept(getSelectedAccountId());
            }
        });
    }

    public Integer getSelectedAccountId() {
        String value = (String) getSelectedItem();
        if (value == null || ALL_ACCOUNTS_DROPDOWN_OPTION.equals(value) || cachedAccounts == null) {
            return null;
        }
        return cachedAccounts.getOrDefault(value, -1);
    }

    public void refresh() {
        Map<String, Integer> displayNameOptions = accountsGetter.get();
        if (!Objects.equals(displayNameOptions, cachedAccounts)) {
            String previousSelectedItem = (String) getSelectedItem();
            refreshAccountOptions();
            setSelectedItem(MoreObjects.firstNonNull(previousSelectedItem, ALL_ACCOUNTS_DROPDOWN_OPTION));
        }
    }

    public void refreshAccountOptions() {
        cachedAccounts = accountsGetter.get();
        refreshInProgress = true;
        DefaultComboBoxModel<String> model = (DefaultComboBoxModel<String>) getModel();
        model.removeAllElements();
        cachedAccounts.forEach((k, v) -> {
            model.addElement(k);
        });
        model.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
        setVisible(model.getSize() > 1);
        refreshInProgress = false;
    }


    public void setSelectedAccountId(Integer accountId) {
        if (accountId == null) {
            setSelectedItem(ALL_ACCOUNTS_DROPDOWN_OPTION);
        } else {
            if(cachedAccounts == null) {
                refreshAccountOptions();
            }
            for (Map.Entry<String, Integer> a : cachedAccounts.entrySet()) {
                if(a.getValue().equals(accountId)) {
                    setSelectedItem(a.getKey());
                }
            }
        }
    }
}
package com.flippingcopilot.ui.components;


import java.awt.CardLayout;
import java.awt.Container;
import java.util.LinkedList;


public class TrackingCardLayout extends CardLayout {

    private final LinkedList<String> cardHistory = new LinkedList<>();
    private static final int MAX_HISTORY_SIZE = 20;

    @Override
    public void show(Container parent, String name) {
        cardHistory.addFirst(name);
        if (cardHistory.size() > MAX_HISTORY_SIZE) {
            cardHistory.removeLast();
        }
        super.show(parent, name);
    }

    public void showPrevious(Container parent) {
        if (cardHistory.size() > 1) {
            cardHistory.removeFirst(); // Remove current card
            String previousCard = cardHistory.getFirst();
            super.show(parent, previousCard);
        }
    }

    public String getCurrentCard() {
        return cardHistory.isEmpty() ? null : cardHistory.getFirst();
    }
}

package com.flippingcopilot.ui.components;

import com.flippingcopilot.model.ItemIdName;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.BorderFactory;
import javax.swing.ComboBoxEditor;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JTextField;
import javax.swing.plaf.basic.BasicComboBoxEditor;
import java.awt.Color;
import java.awt.Component;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Consumer;

@Slf4j
public class ItemSearchBox extends JComboBox<ItemIdName> {
    
    private final BiFunction<String, Set<Integer>, List<ItemIdName>> searchFunction;
    private final Consumer<Integer> onItemSelected;
    private final JTextField editorField;
    private String lastSearchText = "";
    private int lastKeyPress;

    public ItemSearchBox(BiFunction<String, Set<Integer>, List<ItemIdName>> searchFunction,
                        Consumer<Integer> onItemSelected) {
        super();
        this.searchFunction = searchFunction;
        this.onItemSelected = onItemSelected;

        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        setMaximumRowCount(15);
        setEditable(true);

        ComboBoxEditor customEditor = new BasicComboBoxEditor() {
            @Override
            protected JTextField createEditorComponent() {
                JTextField field = new JTextField();
                field.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));
                field.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                field.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                return field;
            }
        };
        setEditor(customEditor);
        
        editorField = (JTextField) getEditor().getEditorComponent();
        editorField.setText("");
        editorField.setForeground(Color.GRAY);

        setRenderer(new DefaultListCellRenderer() {
            @Override
            public Component getListCellRendererComponent(JList<?> list, Object value,
                                                         int index, boolean isSelected, boolean cellHasFocus) {
                Component c = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                if (c instanceof JLabel && value instanceof ItemIdName) {
                    JLabel label = (JLabel) c;
                    ItemIdName item = (ItemIdName) value;
                    label.setText(item.name);
                    label.setBackground(isSelected ? ColorScheme.BRAND_ORANGE : ColorScheme.DARK_GRAY_COLOR);
                    label.setForeground(isSelected ? Color.WHITE : ColorScheme.LIGHT_GRAY_COLOR);
                    label.setBorder(BorderFactory.createEmptyBorder(2, 5, 2, 5));
                }
                return c;
            }
        });
        setupListeners();
    }
    
    private void setupListeners() {
        editorField.addFocusListener(new FocusAdapter() {
            @Override
            public void focusGained(FocusEvent e) {
                if (editorField.getText().isEmpty()) {
                    editorField.setText("");
                    editorField.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                }
            }
            
            @Override
            public void focusLost(FocusEvent e) {
                if (editorField.getText().isEmpty()) {
                    editorField.setForeground(Color.GRAY);
                }
            }
        });

        addActionListener(e -> {
            if (e.getSource() instanceof JComboBox && e.getModifiers() != 0) {
                onSelectedItem();
            }
        });

        editorField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
                    hidePopup();
                    editorField.transferFocus();
                } else if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    if (lastKeyPress == KeyEvent.VK_DOWN || lastKeyPress == KeyEvent.VK_UP || lastKeyPress == KeyEvent.VK_ENTER) {
                        onSelectedItem();
                    } else {
                        performSearch();
                    }
                    e.consume();
                } else if (e.getKeyCode() == KeyEvent.VK_DOWN) {
                    if (!isPopupVisible() && getItemCount() > 0) {
                        showPopup();
                    }
                }
                lastKeyPress = e.getKeyCode();
            }
        });

        editorField.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (editorField.getText().isEmpty()) {
                    editorField.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                }
            }
        });
    }

    private void onSelectedItem() {
        if(getSelectedItem() instanceof ItemIdName) {
            ItemIdName selected = (ItemIdName) getSelectedItem();
            log.debug("Item selected: {} (ID: {})", selected.name, selected.itemId);
            editorField.setText(selected.name);
            editorField.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            onItemSelected.accept(selected.itemId);
            hidePopup();
        }
    }

    public void setItem(ItemIdName i) {
        setSelectedItem(i);
        onSelectedItem();
    }
    
    private void performSearch() {
        String searchText = editorField.getText();
        lastSearchText = searchText;
        updateDropdown(searchFunction.apply(searchText, null));
    }
    
    private void updateDropdown(List<ItemIdName> searchResults) {
        removeAllItems();
        for (ItemIdName item : searchResults) {
            addItem(item);
        }
        if (!searchResults.isEmpty() && editorField.hasFocus()) {
            showPopup();
            if (!editorField.getText().equals(lastSearchText)) {
                editorField.setText(lastSearchText);
            }
        } else {
            hidePopup();
        }
    }

    @Override
    public boolean requestFocusInWindow() {
        return editorField.requestFocusInWindow();
    }

    public void clear() {
        editorField.setText("");
        editorField.setForeground(Color.GRAY);
    }
}
package com.flippingcopilot.ui.components;

import com.flippingcopilot.model.ItemIdName;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Supplier;

@Slf4j
public class ItemSearchMultiSelect extends JPanel {

    private static final int ITEM_HEIGHT = 20; // Fixed height for each item
    private static final int VISIBLE_ITEMS = 15; // Number of visible items at once


    private final String placeholderText;
    private final JTextField displayField;
    private final JWindow dropdownWindow;
    private final VirtualScrollPanel virtualScrollPanel;
    private final JScrollPane scrollPane;
    private final JPanel actionButtonsPanel;
    private final Supplier<Set<Integer>> allItemIdsSupplier;
    private final BiFunction<String, Set<Integer>, List<ItemIdName>> searchFunc;
    private final Consumer<Set<Integer>> onItemSelectionChanged;
    private final Supplier<Set<Integer>> selectedItemsGetter;
    private List<ItemIdName> currentSearchResults = new ArrayList<>();

    public ItemSearchMultiSelect(
            Supplier<Set<Integer>> selectedItemsGetter,
            Supplier<Set<Integer>> allItemIdsSupplier,
            BiFunction<String, Set<Integer>, List<ItemIdName>> searchFunc,
            Consumer<Set<Integer>> onItemSelectionChanged,
            String placeholderText,
            Window windowAncestor) {
        super();
        this.allItemIdsSupplier = allItemIdsSupplier;
        this.selectedItemsGetter = selectedItemsGetter;
        this.searchFunc = searchFunc;
        this.onItemSelectionChanged = onItemSelectionChanged;
        this.placeholderText = placeholderText;

        setLayout(new BorderLayout());

        // Create main display field with placeholder
        displayField = new JTextField(placeholderText);
        displayField.setPreferredSize(new Dimension(200, displayField.getPreferredSize().height));
        displayField.setForeground(Color.GRAY);
        displayField.setFocusable(true);
        displayField.setEditable(true);


        // Remove focus border
        displayField.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createLineBorder(ColorScheme.DARK_GRAY_COLOR), BorderFactory.createEmptyBorder(5, 5, 5, 5)));

        // Setup display field panel without border
        JPanel dropdownPanel = new JPanel(new BorderLayout());
        dropdownPanel.add(displayField, BorderLayout.CENTER);
        dropdownPanel.setBackground(displayField.getBackground());

        // Add the dropdown panel directly without label
        add(dropdownPanel, BorderLayout.CENTER);
        setOpaque(true);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        dropdownWindow = new JWindow(windowAncestor);
        dropdownWindow.setAlwaysOnTop(RuneLite.getInjector().getInstance(RuneLiteConfig.class).gameAlwaysOnTop());
        dropdownWindow.setFocusableWindowState(true);

        // Create action buttons panel (Select All / Unselect All)
        actionButtonsPanel = createActionButtonsPanel();

        // Use virtual scroll panel instead of regular panel
        virtualScrollPanel = new VirtualScrollPanel();
        scrollPane = new JScrollPane(virtualScrollPanel);
        scrollPane.setPreferredSize(new Dimension(300, ITEM_HEIGHT * VISIBLE_ITEMS));
        scrollPane.getVerticalScrollBar().setUnitIncrement(ITEM_HEIGHT);

        // Create dropdown content panel
        JPanel dropdownContent = new JPanel(new BorderLayout());
        dropdownContent.add(actionButtonsPanel, BorderLayout.NORTH);
        dropdownContent.add(scrollPane, BorderLayout.CENTER);
        dropdownContent.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));

        dropdownWindow.add(dropdownContent);
        setupListeners();
    }

    private JPanel createActionButtonsPanel() {
        JPanel panel = new JPanel(new GridLayout(1, 2, 0, 0)); // Use GridLayout for equal width buttons
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(null);

        JButton selectAllButton = new JButton("Select All");
        selectAllButton.setPreferredSize(new Dimension(0, ITEM_HEIGHT+5)); // Use ITEM_HEIGHT for button height
        selectAllButton.setFont(selectAllButton.getFont().deriveFont(Font.PLAIN, 14f));
        selectAllButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        selectAllButton.setForeground(Color.WHITE);
        selectAllButton.setBorder(BorderFactory.createRaisedBevelBorder());
        selectAllButton.setFocusPainted(false);

        JButton unselectAllButton = new JButton("Unselect All");
        unselectAllButton.setPreferredSize(new Dimension(0, ITEM_HEIGHT+5)); // Use ITEM_HEIGHT for button height
        unselectAllButton.setFont(unselectAllButton.getFont().deriveFont(Font.PLAIN, 14f));
        unselectAllButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        unselectAllButton.setForeground(Color.WHITE);
        unselectAllButton.setBorder(BorderFactory.createRaisedBevelBorder());
        unselectAllButton.setFocusPainted(false);

        selectAllButton.addActionListener(e -> selectAllItems());
        unselectAllButton.addActionListener(e -> unselectAllItems());

        panel.add(selectAllButton);
        panel.add(unselectAllButton);

        return panel;
    }

    private void selectAllItems() {
        Set<Integer> newState = allItemIdsSupplier.get();
        Set<Integer> selectedItems = selectedItemsGetter.get();
        if(!selectedItems.equals(newState)) {
            selectedItems.addAll(allItemIdsSupplier.get());
            onItemSelectionChanged.accept(new HashSet<>(selectedItems));
        }
        virtualScrollPanel.refreshItems();
    }

    private void unselectAllItems() {
        Set<Integer> selectedItems = selectedItemsGetter.get();
        if(!selectedItems.isEmpty()) {
            selectedItems.clear();
            onItemSelectionChanged.accept(new HashSet<>(selectedItems));
        }
        virtualScrollPanel.refreshItems();
    }

    private void updateDropdown(String searchText) {
        currentSearchResults = searchFunc.apply(searchText, selectedItemsGetter.get());

        SwingUtilities.invokeLater(() -> {
            log.debug("there are {} search results", currentSearchResults.size());

            // Update virtual scroll panel with new results
            virtualScrollPanel.setItems(currentSearchResults);

            // Calculate dimensions
            Point location = getLocationOnScreen();
            int actionButtonsHeight = actionButtonsPanel.getPreferredSize().height;
            int scrollBarHeight = scrollPane.getHorizontalScrollBar().getPreferredSize().height;
            int contentHeight = Math.min(currentSearchResults.size() * ITEM_HEIGHT, ITEM_HEIGHT * VISIBLE_ITEMS);

            int totalHeight = contentHeight + actionButtonsHeight + scrollBarHeight + 12; // 12 for border and padding

            // Update window
            dropdownWindow.setLocation(location.x, location.y + getHeight());
            dropdownWindow.setSize(getWidth(), totalHeight);
            dropdownWindow.setVisible(true);
        });
    }

    private void setupListeners() {
        displayField.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                log.debug("clicked");
                if (displayField.getText().equals(placeholderText)) {
                    displayField.setText("");
                }
                updateDropdown(displayField.getText());
            }
        });

        displayField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                log.debug("focus gained {}",e.getCause());
                if (displayField.getText().equals(placeholderText)) {
                    displayField.setText("");
                }

//                FocusEvent.Cause c = e.getCause();
//                if(FocusEvent.Cause.MOUSE_EVENT.equals(c)) {
//                    if (displayField.getText().equals(placeholderText)) {
//                        displayField.setText("");
//                        updateDropdown(displayField.getText());
//                    }
//                }
            }

            @Override
            public void focusLost(FocusEvent e) {
                log.debug("focus lost to {} setting text to {}", e.getOppositeComponent(), placeholderText);
                displayField.setText(placeholderText);
                displayField.setForeground(Color.GRAY);
                dropdownWindow.setVisible(false);
            }
        });

        displayField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    updateDropdown(displayField.getText());
                    e.consume();
                } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
                    // Allow escape key to close dropdown and remove focus
                    dropdownWindow.setVisible(false);
                    displayField.transferFocus();
                    e.consume();
                }
            }
        });

        dropdownWindow.addHierarchyListener(new HierarchyListener() {
            @Override
            public void hierarchyChanged(HierarchyEvent e) {
                log.debug("hierarchy changed {} {} {}", dropdownWindow.isVisible(), dropdownWindow.isShowing(), e);
                if(!displayField.hasFocus()) {
                    dropdownWindow.setVisible(false);
                }
            }
        });
    }

    /**
     * Virtual scrolling panel that only renders visible items
     */
    private class VirtualScrollPanel extends JPanel implements Scrollable {
        private List<ItemIdName> items = new ArrayList<>();
        private final Map<Integer, JPanel> panelCache = new HashMap<>();
        private int firstVisibleIndex = 0;
        private int lastVisibleIndex = 0;

        public VirtualScrollPanel() {
            setLayout(null); // Use absolute positioning
            setBackground(ColorScheme.DARK_GRAY_COLOR);

            // Add viewport change listener to handle scrolling
            addComponentListener(new ComponentAdapter() {
                @Override
                public void componentResized(ComponentEvent e) {
                    updateVisibleItems();
                }
            });
        }

        public void setItems(List<ItemIdName> items) {
            this.items = items;
            panelCache.clear(); // Clear cache when items change

            // Set preferred size based on total items
            setPreferredSize(new Dimension(getWidth(), items.size() * ITEM_HEIGHT));

            updateVisibleItems();
            revalidate();
            repaint();
        }

        public void refreshItems() {
            panelCache.clear(); // Clear cache to force recreation of panels with updated icons
            updateVisibleItems();
        }

        private void updateVisibleItems() {
            if (items.isEmpty()) {
                removeAll();
                return;
            }

            Rectangle viewRect = scrollPane.getViewport().getViewRect();
            firstVisibleIndex = Math.max(0, viewRect.y / ITEM_HEIGHT);
            lastVisibleIndex = Math.min(items.size() - 1,
                    (viewRect.y + viewRect.height) / ITEM_HEIGHT + 1);

            // Remove all components and add only visible ones
            removeAll();

            Set<Integer> selectedItems = selectedItemsGetter.get();
            for (int i = firstVisibleIndex; i <= lastVisibleIndex; i++) {
                JPanel itemPanel = getOrCreateItemPanel(i, selectedItems);
                itemPanel.setBounds(0, i * ITEM_HEIGHT, getWidth(), ITEM_HEIGHT);
                add(itemPanel);
            }

            revalidate();
            repaint();
        }

        private JPanel getOrCreateItemPanel(int index, Set<Integer> selectedItems) {
            if (index < 0 || index >= items.size()) {
                return new JPanel();
            }
            if (panelCache.containsKey(index)) {
                return panelCache.get(index);
            }
            ItemIdName item = items.get(index);
            JPanel panel = createItemPanel(item, selectedItems);
            panelCache.put(index, panel);
            return panel;
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);

            // Update visible items when painting
            updateVisibleItems();
        }

        // Scrollable interface methods
        @Override
        public Dimension getPreferredScrollableViewportSize() {
            return new Dimension(getWidth(), ITEM_HEIGHT * VISIBLE_ITEMS);
        }

        @Override
        public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
            return ITEM_HEIGHT;
        }

        @Override
        public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
            return ITEM_HEIGHT * VISIBLE_ITEMS;
        }

        @Override
        public boolean getScrollableTracksViewportWidth() {
            return true;
        }

        @Override
        public boolean getScrollableTracksViewportHeight() {
            return false;
        }
    }

    private JPanel createItemPanel(ItemIdName item, Set<Integer> selectedItems) {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(BorderFactory.createEmptyBorder(1, 2, 1, 2));
        panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, ITEM_HEIGHT));
        panel.setPreferredSize(new Dimension(panel.getPreferredSize().width, ITEM_HEIGHT));
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        panel.setOpaque(true);

        JLabel nameLabel = new JLabel(item.name);
        panel.add(nameLabel, BorderLayout.CENTER);

        JCheckBox checkBox = new JCheckBox();
        checkBox.setSelected(selectedItems.contains(item.itemId));
        checkBox.setBackground(ColorScheme.DARK_GRAY_COLOR);
        checkBox.setPreferredSize(new Dimension(20, 16));

        // Scale down the checkbox icon
        checkBox.setFont(checkBox.getFont().deriveFont(10f));
        checkBox.setMargin(new Insets(0, 0, 0, 0));

        Runnable onClick = () -> {
            if (selectedItems.contains(item.itemId)) {
                selectedItems.remove(item.itemId);
                checkBox.setSelected(false);
            } else {
                selectedItems.add(item.itemId);
                checkBox.setSelected(true);
            }
            onItemSelectionChanged.accept(new HashSet<>(selectedItems));
            panel.revalidate();
            panel.repaint();
        };

        checkBox.addActionListener(e -> onClick.run());

        panel.add(checkBox, BorderLayout.EAST);

        // Add hover effect - clicking anywhere on panel toggles checkbox
        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent ee) {
                onClick.run();
            }
        });

        return panel;
    }
}
package com.flippingcopilot.ui.graph;


import com.flippingcopilot.ui.graph.model.Bounds;
import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.YAxis;
import com.flippingcopilot.ui.graph.model.TimeAxis;

import java.time.Instant;
import java.time.ZoneId;
import java.time.ZoneOffset;

public class AxisCalculator {

    public static TimeAxis calculateTimeAxis(Bounds bounds, int localTimeOffsetSeconds) {

        int timeMin = bounds.xMin;
        int timeMax = bounds.xMax;
        int timeDelta = bounds.xDelta();

        if (timeDelta < Constants.DAY_SECONDS) {
            return calculateSubDayTimeAxis(timeMin, timeMax, timeDelta, localTimeOffsetSeconds);
        }

        int days = timeDelta / Constants.DAY_SECONDS;
        int daysStep = Math.max(1, days / 7);

        int maxDay = ((timeMax + localTimeOffsetSeconds) / Constants.DAY_SECONDS) * Constants.DAY_SECONDS - localTimeOffsetSeconds;
        int minDay = ((timeMin + localTimeOffsetSeconds) / Constants.DAY_SECONDS) * Constants.DAY_SECONDS - localTimeOffsetSeconds;
        int[] dayTicks = new int[]{};
        while (maxDay > timeMin) {
            dayTicks = append(dayTicks, maxDay);
            maxDay -= daysStep * Constants.DAY_SECONDS;
        }

        int[] timeTicks = new int[]{};
        if (daysStep == 1) {
            if (dayTicks.length < 5) {
                // add 06:00, 12:00, 18:00
                for (int d : preAppend(dayTicks, minDay)) {
                    int tick06 = d + 6 * 60 * 60;     // 06:00
                    int tick12 = d + 12 * 60 * 60;    // 12:00
                    int tick18 = d + 18 * 60 * 60;    // 18:00

                    if (tick06 < timeMax && tick06 > timeMin) {
                        timeTicks = append(timeTicks, tick06);
                    }
                    if (tick12 < timeMax && tick12 > timeMin) {
                        timeTicks = append(timeTicks, tick12);
                    }
                    if (tick18 < timeMax && tick18 > timeMin) {
                        timeTicks = append(timeTicks, tick18);
                    }
                }
            } else if (dayTicks.length < 10){
                // add only 12:00
                for (int d : preAppend(dayTicks, dayTicks[0] - Constants.DAY_SECONDS)) {
                    int tick12 = d + 12 * 60 * 60;    // 12:00
                    if (tick12 > timeMin && tick12 < timeMax) {
                        timeTicks = append(timeTicks, tick12);
                    }
                }
            }
        }

        return new TimeAxis(
                dayTicks,
                timeTicks,
                new int[]{}
        );
    }

    private static TimeAxis calculateSubDayTimeAxis(int timeMin, int timeMax, int timeDelta, int localTimeOffsetSeconds) {
        int[] ticks = new int[]{};
        int tickInterval;
        if (timeDelta < Constants.HOUR_SECONDS) {
            tickInterval = Constants.TEN_MIN_SECONDS;
        } else if (timeDelta < Constants.HOUR_SECONDS * 3) {
            tickInterval  = Constants.THIRTY_MIN_SECONDS;
        } else if (timeDelta < Constants.HOUR_SECONDS * 6) {
            tickInterval = Constants.HOUR_SECONDS;
        } else {
            tickInterval = Constants.HOUR_SECONDS*3;
        }

        int firstTick = ((timeMin+localTimeOffsetSeconds) / tickInterval) * tickInterval - localTimeOffsetSeconds;
        if (firstTick < (timeMin+localTimeOffsetSeconds)) {
            firstTick += tickInterval;
        }

        int currentTick = firstTick;
        while (currentTick <= timeMax) {
            ticks = append(ticks, currentTick);
            currentTick += tickInterval;
        }
        return new TimeAxis(
                new int[]{},
                ticks,
                ticks
        );
    }

    public static YAxis calculatePriceAxis(Bounds bounds) {
        int maxAllowableTicks = 18;
        int maxAllowableGridLines = 28;

        int priceRange = (int) bounds.yDelta();
        int priceMin = (int) bounds.yMin;
        int priceMax = (int) bounds.yMax;

        int magnitude = (int) Math.floor(Math.log10(priceRange));
        int[] possibleSteps = {1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500};

        int stepSize = 0;
        int numTicks = Integer.MAX_VALUE;

        for (int baseStep : possibleSteps) {
            int candidateStep = baseStep * (int) Math.pow(10, magnitude - 1);
            candidateStep = Math.max(1, candidateStep);

            int candidateTicks = priceRange / candidateStep + 1;

            if (candidateTicks <= maxAllowableTicks && candidateStep > 0) {
                stepSize = candidateStep;
                numTicks = candidateTicks;
                break;
            }
        }

        if (stepSize == 0) {
            stepSize = 500 * (int) Math.pow(10, magnitude - 1);
            numTicks = priceRange / stepSize + 1;
        }

        int startTick = (priceMin / stepSize) * stepSize;
        if (startTick < priceMin) {
            startTick += stepSize;
        }

        long[] tickPrices = new long[numTicks];
        int tickIndex = 0;

        for (int price = startTick; price <= priceMax && tickIndex < numTicks; price += stepSize) {
            tickPrices[tickIndex++] = price;
        }

        if (tickIndex < numTicks) {
            long[] resizedTicks = new long[tickIndex];
            System.arraycopy(tickPrices, 0, resizedTicks, 0, tickIndex);
            tickPrices = resizedTicks;
        }

        long[] gridOnlyPrices = new long[0];

        if (tickPrices.length > 1) {
            int gridStep = stepSize / 2;
            if (gridStep > 0 && (tickPrices.length * 2 - 1) <= maxAllowableGridLines) {
                gridOnlyPrices = new long[tickPrices.length - 1];

                for (int i = 0; i < tickPrices.length - 1; i++) {
                    gridOnlyPrices[i] = tickPrices[i] + gridStep;
                }
            }
        }

        return new YAxis(tickPrices, gridOnlyPrices);
    }

    public static YAxis calculateVolumeAxis(Bounds bounds) {
        int maxAllowableTicks = 8;
        int maxAllowableGridLines = 16;

        int volumeRange = (int) bounds.y2Delta();
        int volumeMin = (int) bounds.y2Min;
        int volumeMax = (int) bounds.y2Max;

        int magnitude = (int) Math.floor(Math.log10(volumeRange));
        int[] possibleSteps = {1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500};

        int stepSize = 0;
        int numTicks = Integer.MAX_VALUE;

        for (int baseStep : possibleSteps) {
            int candidateStep = baseStep * (int) Math.pow(10, magnitude - 1);
            candidateStep = Math.max(1, candidateStep);

            int candidateTicks = volumeRange / candidateStep + 1;

            if (candidateTicks <= maxAllowableTicks && candidateStep > 0) {
                stepSize = candidateStep;
                numTicks = candidateTicks;
                break;
            }
        }

        if (stepSize == 0) {
            stepSize = 500 * (int) Math.pow(10, magnitude - 1);
            numTicks = volumeRange / stepSize + 1;
        }

        int startTick = (volumeMin / stepSize) * stepSize;
        if (startTick < volumeMin) {
            startTick += stepSize;
        }

        long[] tickvolumes = new long[numTicks];
        int tickIndex = 0;

        for (int volume = startTick; volume <= volumeMax && tickIndex < numTicks; volume += stepSize) {
            tickvolumes[tickIndex++] = volume;
        }

        if (tickIndex < numTicks) {
            long[] resizedTicks = new long[tickIndex];
            System.arraycopy(tickvolumes, 0, resizedTicks, 0, tickIndex);
            tickvolumes = resizedTicks;
        }

        long[] gridOnlyvolumes = new long[0];

        if (tickvolumes.length > 1) {
            int gridStep = stepSize / 2;
            if (gridStep > 0 && (tickvolumes.length * 2 - 1) <= maxAllowableGridLines) {
                gridOnlyvolumes = new long[tickvolumes.length - 1];

                for (int i = 0; i < tickvolumes.length - 1; i++) {
                    gridOnlyvolumes[i] = tickvolumes[i] + gridStep;
                }
            }
        }

        return new YAxis(tickvolumes, gridOnlyvolumes);
    }


    public static int[] append(int[] arr, int v) {
        int[] result = new int[arr.length + 1];
        System.arraycopy(arr, 0, result, 0, arr.length);
        result[arr.length] = v;
        return result;
    }

    public static int[] preAppend(int[] arr, int v) {
        int[] result = new int[arr.length + 1];
        result[0] = v;
        System.arraycopy(arr, 0, result, 1, arr.length);
        return result;
    }

    public static int getLocalTimeOffsetSeconds() {
        ZoneOffset offset = ZoneId.systemDefault().getRules().getOffset(Instant.now());
        return offset.getTotalSeconds();
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.Bounds;
import com.flippingcopilot.ui.graph.model.Config;
import com.flippingcopilot.util.MathUtil;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.awt.geom.RoundRectangle2D;

@Slf4j
@Getter
public class ZoomHandler {

    private static final int MIN_TIME_DELTA = 60*60;
    private static final int MIN_PRICE_DELTA = 5;
    @Setter
    private Point selectionStart = null;
    @Setter
    private Point selectionEnd = null;
    private boolean isSelecting = false;

    private final Rectangle homeButtonRect = new Rectangle();
    private final Rectangle maxButtonRect = new Rectangle();
    private final Rectangle zoomInButtonRect = new Rectangle();
    private final Rectangle zoomOutButtonRect = new Rectangle();
    private final Rectangle weekButtonRect = new Rectangle();
    private final Rectangle monthButtonRect = new Rectangle();

    public Bounds maxViewBounds;
    public Bounds homeViewBounds;
    public Bounds weekViewBounds;
    public Bounds monthViewBounds;

    public void startSelection(Point point) {
        selectionStart = new Point(point);
        selectionEnd = null;
        isSelecting = true;
    }

    public void applySelection(Rectangle pa, Bounds bounds) {
        if (selectionStart == null || selectionEnd == null) return;

        int x1 = MathUtil.clamp(Math.min(selectionStart.x, selectionEnd.x), pa.x, pa.x+pa.width);
        int y1 = MathUtil.clamp(Math.min(selectionStart.y, selectionEnd.y), pa.y, pa.y+pa.height);
        int x2 = MathUtil.clamp(Math.max(selectionStart.x, selectionEnd.x), pa.x, pa.x+pa.width);
        int y2 = MathUtil.clamp(Math.max(selectionStart.y, selectionEnd.y), pa.y, pa.y+pa.height);


        int newTimeMin = bounds.xMin + (int)(((long)bounds.xDelta() * (long)(x1 - pa.x)) / ((long) pa.width));
        int newTimeMax = bounds.xMin + (int)(((long)bounds.xDelta() * (long)(x2 - pa.x)) / ((long) pa.width));

        int newPriceMax = (int) (bounds.yMax - ((bounds.yDelta() * (long)(y1 - pa.y)) / ((long) pa.height)));
        int newPriceMin = (int) (bounds.yMax - ((bounds.yDelta() * (long)(y2 - pa.y)) / ((long) pa.height)));

        if (newTimeMax - newTimeMin < MIN_TIME_DELTA) {
            log.debug("zoomed time delta {}s too small", newTimeMax - newTimeMin);
            cancelSelection();
            return;
        }

        if (newPriceMax - newPriceMin < MIN_PRICE_DELTA) {
            log.debug("zoomed price delta {}s too small", newPriceMax - newPriceMin);
            cancelSelection();
            return;
        }

        bounds.xMin = newTimeMin;
        bounds.xMax = newTimeMax;
        bounds.yMin = newPriceMin;
        bounds.yMax = newPriceMax;

        cancelSelection();
    }

    public void applyZoomIn(Bounds bounds) {
        bounds.xMin = Math.min(bounds.xMax - MIN_TIME_DELTA, bounds.xMin + (int) (bounds.xDelta()*0.2));

    }

    public void applyZoomOut( Bounds bounds) {
        int td = bounds.xDelta();
        bounds.xMin= Math.max(maxViewBounds.xMin, bounds.xMin- (int) (td*0.2));
        bounds.xMax = Math.min(maxViewBounds.xMax, bounds.xMax + (int) (td*0.2));
        int pd = (int) bounds.yDelta();
        bounds.yMin = Math.max(maxViewBounds.yMin, bounds.yMin - (int) (pd*0.1));
        bounds.yMax = Math.min(maxViewBounds.yMax, bounds.yMax + (int) (pd*0.1));
        bounds.y2Max = Math.min(maxViewBounds.y2Max, bounds.y2Max + (int) (pd*0.05));
    }

    public void applyHomeView(Bounds bounds) {
        bounds.xMin = homeViewBounds.xMin;
        bounds.xMax = homeViewBounds.xMax;
        bounds.yMin = homeViewBounds.yMin;
        bounds.yMax = homeViewBounds.yMax;
        bounds.y2Min = homeViewBounds.y2Min;
        bounds.y2Max = homeViewBounds.y2Max;;
    }

    public void applyMaxView(Bounds bounds) {
        bounds.xMin = maxViewBounds.xMin;
        bounds.xMax = maxViewBounds.xMax;
        bounds.yMin = maxViewBounds.yMin;
        bounds.yMax = maxViewBounds.yMax;
        bounds.y2Min = maxViewBounds.y2Min;
        bounds.y2Max = maxViewBounds.y2Max;;
    }

    public void applyWeekView(Bounds bounds) {
        bounds.xMin = weekViewBounds.xMin;
        bounds.xMax = weekViewBounds.xMax;
        bounds.yMin = weekViewBounds.yMin;
        bounds.yMax = weekViewBounds.yMax;
        bounds.y2Min = weekViewBounds.y2Min;
        bounds.y2Max = weekViewBounds.y2Max;
    }

    public void applyMonthView(Bounds bounds) {
        bounds.xMin = monthViewBounds.xMin;
        bounds.xMax = monthViewBounds.xMax;
        bounds.yMin = monthViewBounds.yMin;
        bounds.yMax = monthViewBounds.yMax;
        bounds.y2Min = monthViewBounds.y2Min;
        bounds.y2Max = monthViewBounds.y2Max;;
    }

    public void cancelSelection() {
        selectionStart = null;
        selectionEnd = null;
        isSelecting = false;
    }

    public void drawSelectionRectangle(Graphics2D g2d, Rectangle pa) {
        if (!isSelecting || selectionStart == null || selectionEnd == null) return;

        int x1 = MathUtil.clamp(Math.min(selectionStart.x, selectionEnd.x), pa.x, pa.x+pa.width);
        int y1 = MathUtil.clamp(Math.min(selectionStart.y, selectionEnd.y), pa.y, pa.y+pa.height);
        int x2 = MathUtil.clamp(Math.max(selectionStart.x, selectionEnd.x), pa.x, pa.x+pa.width);
        int y2 = MathUtil.clamp(Math.max(selectionStart.y, selectionEnd.y), pa.y, pa.y+pa.height);

        g2d.setColor(Config.SELECTION_COLOR);
        g2d.fillRect(x1, y1, x2-x1, y2 - y1);

        g2d.setColor(Config.SELECTION_BORDER_COLOR);
        g2d.setStroke(Config.SELECTION_STROKE);
        g2d.drawRect(x1, y1, x2-x1, y2 - y1);
    }

    public void drawButtons(Graphics2D g2d, Rectangle pa, Point p) {

        int x = pa.x + pa.width - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        int y = pa.y + Config.GRAPH_BUTTON_MARGIN;

        // Width for text buttons (Week and Month)
        int textButtonWidth = Config.GRAPH_BUTTON_SIZE * 2;

        homeButtonRect.setBounds(x,  y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);
        g2d.setColor(isOverHomeButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape homeButtonShape = new RoundRectangle2D.Float(
                x, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        g2d.fill(homeButtonShape);
        g2d.setColor(java.awt.Color.WHITE);
        g2d.setStroke(new java.awt.BasicStroke(1.5f));

        int margin = 4;
        int houseX = x + margin;
        int houseY = y + margin;
        int houseWidth = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int houseHeight = Config.GRAPH_BUTTON_SIZE - 2 * margin;

        // Roof
        int[] xPoints = {houseX, houseX + houseWidth / 2, houseX + houseWidth};
        int[] yPoints = {houseY + houseHeight / 2, houseY, houseY + houseHeight / 2};
        g2d.fillPolygon(xPoints, yPoints, 3);

        // House body
        g2d.fillRect(houseX + houseWidth / 5, houseY + houseHeight / 2,
                3 * houseWidth / 5, houseHeight / 2);

        // Draw max button
        int maxButtonX = x - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        maxButtonRect.setBounds(maxButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        g2d.setColor(isOverMaxButton(p)  ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape maxButtonShape = new RoundRectangle2D.Float(
                maxButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        g2d.fill(maxButtonShape);

        // Draw max icon (four outward arrows)
        g2d.setColor(java.awt.Color.WHITE);
        g2d.setStroke(new java.awt.BasicStroke(1.5f));

        int maxMargin = 7;
        int centerX = maxButtonX + Config.GRAPH_BUTTON_SIZE / 2;
        int centerY = y + Config.GRAPH_BUTTON_SIZE / 2;
        int arrowSize = Config.GRAPH_BUTTON_SIZE / 2 - maxMargin;

        // Draw a simple expand icon (four outward arrows)
        // Top-left arrow
        g2d.drawLine(centerX - 2, centerY - 2, centerX - arrowSize, centerY - arrowSize);
        g2d.drawLine(centerX - arrowSize, centerY - 2, centerX - arrowSize, centerY - arrowSize);
        g2d.drawLine(centerX - 2, centerY - arrowSize, centerX - arrowSize, centerY - arrowSize);

        // Top-right arrow
        g2d.drawLine(centerX + 2, centerY - 2, centerX + arrowSize, centerY - arrowSize);
        g2d.drawLine(centerX + arrowSize, centerY - 2, centerX + arrowSize, centerY - arrowSize);
        g2d.drawLine(centerX + 2, centerY - arrowSize, centerX + arrowSize, centerY - arrowSize);

        // Bottom-left arrow
        g2d.drawLine(centerX - 2, centerY + 2, centerX - arrowSize, centerY + arrowSize);
        g2d.drawLine(centerX - arrowSize, centerY + 2, centerX - arrowSize, centerY + arrowSize);
        g2d.drawLine(centerX - 2, centerY + arrowSize, centerX - arrowSize, centerY + arrowSize);

        // Bottom-right arrow
        g2d.drawLine(centerX + 2, centerY + 2, centerX + arrowSize, centerY + arrowSize);
        g2d.drawLine(centerX + arrowSize, centerY + 2, centerX + arrowSize, centerY + arrowSize);
        g2d.drawLine(centerX + 2, centerY + arrowSize, centerX + arrowSize, centerY + arrowSize);

        // Draw zoom in (+) button
        int zoomInButtonX = maxButtonX - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        zoomInButtonRect.setBounds(zoomInButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        g2d.setColor(isOverZoomInButton(p)  ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape zoomInButtonShape = new RoundRectangle2D.Float(
                zoomInButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        g2d.fill(zoomInButtonShape);

        // Draw + symbol
        g2d.setColor(java.awt.Color.WHITE);
        g2d.setStroke(new java.awt.BasicStroke(2.0f));

        int plusSize = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int plusX = zoomInButtonX + margin;
        int plusY = y + margin;

        // Horizontal line
        g2d.drawLine(
                plusX + plusSize / 4,
                plusY + plusSize / 2,
                plusX + 3 * plusSize / 4,
                plusY + plusSize / 2
        );

        // Vertical line
        g2d.drawLine(
                plusX + plusSize / 2,
                plusY + plusSize / 4,
                plusX + plusSize / 2,
                plusY + 3 * plusSize / 4
        );

        // Draw zoom out (-) button
        int zoomOutButtonX = zoomInButtonX - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        zoomOutButtonRect.setBounds(zoomOutButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        g2d.setColor(isOverZoomOutButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape zoomOutButtonShape = new RoundRectangle2D.Float(
                zoomOutButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        g2d.fill(zoomOutButtonShape);

        // Draw - symbol
        g2d.setColor(java.awt.Color.WHITE);
        g2d.setStroke(new java.awt.BasicStroke(2.0f));

        int minusSize = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int minusX = zoomOutButtonX + margin;
        int minusY = y + margin;

        // Horizontal line (minus symbol)
        g2d.drawLine(
                minusX + minusSize / 4,
                minusY + minusSize / 2,
                minusX + 3 * minusSize / 4,
                minusY + minusSize / 2
        );

        // Draw Week button (wider than the others)
        int weekButtonX = zoomOutButtonX - textButtonWidth - Config.GRAPH_BUTTON_MARGIN;
        weekButtonRect.setBounds(weekButtonX, y, textButtonWidth, Config.GRAPH_BUTTON_SIZE);

        g2d.setColor(isOverWeekButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape weekButtonShape = new RoundRectangle2D.Float(
                weekButtonX, y,
                textButtonWidth, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        g2d.fill(weekButtonShape);

        // Draw Week text
        g2d.setColor(java.awt.Color.WHITE);
        g2d.setFont(new Font("SansSerif", Font.PLAIN, 12));
        FontMetrics fm = g2d.getFontMetrics();
        String weekText = "Week";
        int textWidth = fm.stringWidth(weekText);
        int textHeight = fm.getHeight();
        g2d.drawString(weekText,
                weekButtonX + (textButtonWidth - textWidth) / 2,
                y + (Config.GRAPH_BUTTON_SIZE + textHeight) / 2 - 2);

        // Draw Month button (wider than the others)
        int monthButtonX = weekButtonX - textButtonWidth - Config.GRAPH_BUTTON_MARGIN;
        monthButtonRect.setBounds(monthButtonX, y, textButtonWidth, Config.GRAPH_BUTTON_SIZE);

        g2d.setColor(isOverMonthButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape monthButtonShape = new RoundRectangle2D.Float(
                monthButtonX, y,
                textButtonWidth, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        g2d.fill(monthButtonShape);

        // Draw Month text
        g2d.setColor(java.awt.Color.WHITE);
        // Use the same font as for the Week button - plain instead of bold
        String monthText = "Month";
        textWidth = fm.stringWidth(monthText);
        g2d.drawString(monthText,
                monthButtonX + (textButtonWidth - textWidth) / 2,
                y + (Config.GRAPH_BUTTON_SIZE + textHeight) / 2 - 2);
    }

    public boolean isOverHomeButton(Point point) {
        return homeButtonRect.contains(point);
    }

    public boolean isOverMaxButton(Point point) {
        return maxButtonRect.contains(point);
    }

    public boolean isOverZoomInButton(Point point) {
        return zoomInButtonRect.contains(point);
    }

    public boolean isOverZoomOutButton(Point point) {
        return zoomOutButtonRect.contains(point);
    }

    public boolean isOverWeekButton(Point point) {
        return weekButtonRect.contains(point);
    }

    public boolean isOverMonthButton(Point point) {
        return monthButtonRect.contains(point);
    }
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.Constants;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.text.NumberFormat;
import java.util.Date;

@Slf4j
public class StatsPanel extends JPanel {
    private final JTable statsTable;

    private final JLabel itemIcon = new JLabel();
    private final JLabel itemNameLabel = new JLabel();

    public StatsPanel(PriceGraphConfigManager configManager, FlippingCopilotConfig copilotConfig) {

        this.setLayout(new BorderLayout());

        JPanel iconPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        iconPanel.setBackground(configManager.getConfig().backgroundColor);
        iconPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 15, 0));
        itemIcon.setBorder(null);
        iconPanel.add(itemIcon);
        itemNameLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        itemNameLabel.setFont(itemNameLabel.getFont().deriveFont(Font.BOLD, 16f));
        iconPanel.add(itemNameLabel);


        this.add(iconPanel, BorderLayout.NORTH);

        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        model.addColumn("Statistic");
        model.addColumn("Value");
        model.addRow(new Object[]{"Daily Volume",""});
        model.addRow(new Object[]{"Last low time", ""});
        model.addRow(new Object[]{"Last low price", ""});
        model.addRow(new Object[]{"Last high time", ""});
        model.addRow(new Object[]{"Last high price", ""});
        model.addRow(new Object[]{"24h change", ""});
        model.addRow(new Object[]{"Week change", ""});

        statsTable = new JTable(model);
        statsTable.setRowHeight(26);
        statsTable.getTableHeader().setReorderingAllowed(false);
        statsTable.getTableHeader().setResizingAllowed(true);
        statsTable.setBackground(configManager.getConfig().backgroundColor);
        statsTable.setShowGrid(false);

        statsTable.getColumnModel().getColumn(0).setPreferredWidth(150);
        statsTable.getColumnModel().getColumn(1).setPreferredWidth(120);

        statsTable.setTableHeader(null);

        // Set custom cell renderer for value column to color the change percentages
        statsTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                // Apply color to the price change rows (24h change and week change)
                if (row == 5 || row == 6) { // Index of 24h change and week change rows
                    String valueStr = value.toString();
                    // Check if the percentage is negative (contains '-' character)
                    if (valueStr.contains("-")) {
                        c.setForeground(copilotConfig.lossAmountColor());
                    } else if (!valueStr.equals("0%")) {
                        c.setForeground(copilotConfig.profitAmountColor());
                    } else {
                        c.setForeground(table.getForeground());
                    }
                } else {
                    c.setForeground(table.getForeground());
                }

                return c;
            }
        });

        JScrollPane scrollPane = new JScrollPane(statsTable);
        scrollPane.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(1, 0, 0, 0, Color.GRAY),
                BorderFactory.createEmptyBorder(10,0,0,0)));

        scrollPane.setColumnHeaderView(null);

        this.add(scrollPane, BorderLayout.CENTER);
        this.setPreferredSize(new Dimension(280, 400));
    }

    public void populate(DataManager dataManager, ItemController itemController) {

        String itemName = itemController.getItemName(dataManager.data.itemId);
        if(!itemName.equals(itemNameLabel.getText())) {
            itemIcon.setVisible(false);
            itemController.loadImage(dataManager.data.itemId, (image) -> {
                if (image != null) {
                    image.addTo(itemIcon);
                    itemIcon.setVisible(true);
                }
            });
            itemNameLabel.setText(itemName);
        }

        DefaultTableModel model = (DefaultTableModel) statsTable.getModel();

        model.setValueAt(formatNumber((long) dataManager.data.dailyVolume), 0, 1);
        model.setValueAt(dataManager.lastLowTime > 0 ? Constants.SECOND_DATE_FORMAT.format(new Date(dataManager.lastLowTime* 1000L)) : "n/a", 1,1);
        model.setValueAt( dataManager.lastLowPrice > 0 ? formatNumber(dataManager.lastLowPrice) : "n/a", 2,1);
        model.setValueAt( dataManager.lastHighTime > 0 ? Constants.SECOND_DATE_FORMAT.format(new Date(dataManager.lastHighTime * 1000L)) : "n/a",3,1);
        model.setValueAt(dataManager.lastHighPrice > 0 ? formatNumber(dataManager.lastHighPrice) : "n/a",4,1);
        model.setValueAt(formatPercentage((float) dataManager.priceChange24H), 5,1);
        model.setValueAt(formatPercentage((float) dataManager.priceChangeWeek), 6,1);

//        // Copilot price and margin
//        model.addRow(new Object[]{"Copilot buy price", formatNumber(dataManager.data.buyPrice)});
//        model.addRow(new Object[]{"Copilot sell price", formatNumber(dataManager.data.sellPrice)});
//
//        model.addRow(new Object[]{"Margin", formatNumber(dataManager.margin)});
//        model.addRow(new Object[]{"Tax", formatNumber(dataManager.tax)});
//        model.addRow(new Object[]{"Profit", formatNumber(dataManager.profit)});
    }


    private String formatNumber(long number) {
        return NumberFormat.getNumberInstance().format(number);
    }

    private String formatPercentage(float value) {
        NumberFormat format = NumberFormat.getPercentInstance();
        format.setMaximumFractionDigits(2);
        return format.format(value);
    }
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.*;

import java.awt.*;
import java.awt.geom.Path2D;
import java.util.List;
import java.util.function.BiFunction;

public class RenderV2 {

    public void drawGrid(Graphics2D g2, Config config, Rectangle pa, Bounds bounds, BiFunction<Rectangle, Long, Integer> toY, TimeAxis xAxis, YAxis yAxis) {
        g2.setColor(config.gridColor);
        g2.setStroke(Config.NORMAL_STROKE);
        for (int t : xAxis.dateOnlyTickTimes) {
            int x = bounds.toX(pa,t);
            g2.drawLine(x, pa.y, x, pa.y + pa.height);
        }
        g2.setStroke(Config.GRID_STROKE);
        for (int t : xAxis.timeOnlyTickTimes) {
            int x = bounds.toX(pa,t);
            g2.drawLine(x, pa.y, x, pa.y + pa.height);
        }
        for (int t : xAxis.gridOnlyTickTimes) {
            int x = bounds.toX(pa,t);
            g2.drawLine(x, pa.y, x, pa.y + pa.height);
        }
        for (long p : yAxis.tickValues) {
            int y = toY.apply(pa,p);
            g2.drawLine(pa.x, y, pa.x+pa.width, y);
        }
        for (long p : yAxis.gridOnlyValues) {
            int y =toY.apply(pa,p);
            g2.drawLine(pa.x, y, pa.x + pa.width, y);
        }
    }

    public void drawAxes(Graphics2D g2, Config config,  Rectangle pa) {
        g2.setColor(config.axisColor);
        g2.setStroke(new BasicStroke(1.0f));
        g2.drawLine(pa.x,  pa.y + pa.height, pa.x + pa.width, pa.y + pa.height);
        g2.drawLine(pa.x, pa.y, pa.x, pa.y +pa.height);
    }

    public void drawXAxisLabels(Graphics2D g2, Config config, Rectangle pa, Bounds bounds, TimeAxis xAxis) {
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        g2.setColor(config.textColor);
        FontMetrics metrics = g2.getFontMetrics();

        java.text.SimpleDateFormat dateFormat = new java.text.SimpleDateFormat("d MMM");
        java.text.SimpleDateFormat timeFormat = new java.text.SimpleDateFormat("HH:mm");

        // Draw date labels (longer ticks)
        for (int time : xAxis.dateOnlyTickTimes) {
            int x = bounds.toX(pa,time);
            g2.drawLine(x, pa.y + pa.height,  x, pa.y + pa.height + Config.TICK_SIZE * 2);
            String label = dateFormat.format(new java.util.Date(time * 1000L));
            int labelWidth = metrics.stringWidth(label);
            g2.drawString(label,  x - labelWidth / 2, pa.y + pa.height + Config.TICK_SIZE * 2 + 9 + metrics.getHeight());
        }

        if (xAxis.dateOnlyTickTimes.length == 0 && xAxis.timeOnlyTickTimes.length > 0) {
            int x = pa.x + pa.width / 2;
            String label = dateFormat.format(new java.util.Date(bounds.xMid() * 1000L));
            int labelWidth = metrics.stringWidth(label);
            g2.drawString(label,  x - labelWidth / 2, pa.y + pa.height + Config.TICK_SIZE * 2 + 9 + metrics.getHeight());
        }

        // Draw time labels (shorter ticks)
        for (int time : xAxis.timeOnlyTickTimes) {
            int x = bounds.toX(pa,time);
            g2.drawLine(x, pa.y + pa.height, x, pa.y +  pa.height + Config.TICK_SIZE);
            String label = timeFormat.format(new java.util.Date(time * 1000L));
            int labelWidth = metrics.stringWidth(label);
            g2.drawString(label, x - labelWidth / 2, pa.y +  pa.height + Config.TICK_SIZE + metrics.getHeight());
        }
    }

    public void drawYAxisLabels(Graphics2D g2, Config config, Rectangle pa, BiFunction<Rectangle, Long, Integer> toY, YAxis yAxis, boolean skipLast) {
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        g2.setColor(config.textColor);
        FontMetrics metrics = g2.getFontMetrics();
        for (long v : yAxis.tickValues) {
            int y = toY.apply(pa, v);
            g2.drawLine(pa.x - Config.TICK_SIZE,y, pa.x, y);
            String label = com.flippingcopilot.ui.UIUtilities.quantityToRSDecimalStack(v, true);
            if(!skipLast || v != yAxis.tickValues[yAxis.tickValues.length-1]) {
                g2.drawString(label, pa.x - metrics.stringWidth(label) - Config.LABEL_PADDING, y + metrics.getHeight() / 3);
            }
        }
    }


    public void drawPredictionIQR(Graphics2D g2d,Config config, Rectangle pa,  Bounds bounds, int[] times, int[] lowerPrices, int[] upperPrices, boolean isLow) {
        if (times.length < 2) return;

        // Set appropriate color
        g2d.setColor(isLow ? config.lowShadeColor : config.highShadeColor);

        // Create path for shaded area with clipping
        Path2D path = new Path2D.Double();
        boolean started = false;

        // Start at the first point that's in range
        for (int i = 0; i < times.length; i++) {
            int time = times[i];
            if (time >= bounds.xMin && time <=bounds.xMax) {
                int x = bounds.toX(pa,time);
                int y = bounds.toY(pa,lowerPrices[i]);

                if (!started) {
                    path.moveTo(x, y);
                    started = true;
                } else {
                    path.lineTo(x, y);
                }
            }
        }

        // Draw the upper bound from right to left (for points in range)
        for (int i = times.length - 1; i >= 0; i--) {
            int time = times[i];
            if (time >= bounds.xMin && time <= bounds.xMax) {
                int x = bounds.toX(pa,time);
                int y = bounds.toY(pa,upperPrices[i]);
                path.lineTo(x, y);
            }
        }

        // Close the path if we drew anything
        if (started) {
            path.closePath();
            g2d.fill(path);
        }
    }

    public void drawLines(Graphics2D g2d,
                          Rectangle pa,
                          Bounds bounds,
                          List<Datapoint> datapoints,
                          Color color,
                          Stroke stroke) {
        if (datapoints.isEmpty()) return;

        g2d.setStroke(stroke);
        g2d.setColor(color);
        java.awt.Shape originalClip = g2d.getClip();
        g2d.setClip(pa.x, pa.y, pa.width, pa.height);

        java.awt.geom.Path2D.Float path = new java.awt.geom.Path2D.Float();

        // Start the path at the first point
        int x = bounds.toX(pa,datapoints.get(0).time);
        int y = bounds.toY(pa,datapoints.get(0).price);
        path.moveTo(x, y);

        for (Datapoint d : datapoints.subList(1, datapoints.size())) {
            x = bounds.toX(pa,d.time);
            y = bounds.toY(pa,d.price);
            path.lineTo(x, y);
        }

        g2d.draw(path);
        g2d.setClip(originalClip);
    }

    public void drawStartPoints(Graphics2D plotAreaG2,
                                Rectangle pa,
                                Bounds bounds, List<Datapoint> startPoints,
                                Color color,
                                int size
    ) {
        if (startPoints.isEmpty()) return;

        plotAreaG2.setColor(color);
        java.awt.Shape originalClip = plotAreaG2.getClip();
        plotAreaG2.setClip(pa.x, pa.y, pa.width, pa.height);

        for (Datapoint d : startPoints) {
            if (d.time < bounds.xMin || d.time > bounds.xMax) {
                continue;
            }
            int x = bounds.toX(pa,d.time);
            int y = bounds.toY(pa,d.price);

            Stroke originalStroke = plotAreaG2.getStroke();
            float strokeWidth = Math.max(1, size / 5);
            plotAreaG2.setStroke(new BasicStroke(strokeWidth));

            int halfSize = size / 2;
            plotAreaG2.drawLine(x - halfSize, y, x + halfSize, y);
            plotAreaG2.drawLine(x, y - halfSize, x, y + halfSize);
            plotAreaG2.drawLine(x - halfSize, y - halfSize, x + halfSize, y + halfSize);
            plotAreaG2.drawLine(x + halfSize, y - halfSize, x - halfSize, y + halfSize);
            plotAreaG2.setStroke(originalStroke);
        }
        plotAreaG2.setClip(originalClip); // restore original clip
    }

    public void drawPoints(Graphics2D g2d,
                            Rectangle pa,
                            Bounds bounds,
                            List<Datapoint> datapoints,
                            Color color,
                            int size
    ) {
        if (datapoints.isEmpty()) return;
        g2d.setColor(color);
        java.awt.Shape originalClip = g2d.getClip();
        g2d.setClip(pa.x, pa.y, pa.width, pa.height);

        // Draw each point as a filled oval
        for (Datapoint d : datapoints) {
            if (d.time < bounds.xMin || d.time > bounds.xMax) {
                continue;
            }
            int x = bounds.toX(pa,d.time);
            int y = bounds.toY(pa,d.price);
            int ovalX = x - size / 2;
            int ovalY = y - size / 2;
            if (d.type == Datapoint.Type.PREDICTION || d.type == Datapoint.Type.INSTA_SELL_BUY) {
                g2d.fillOval(ovalX, ovalY, size, size);
            } else {
                // rectangle for 5m/1h averages
                int timeDelta = d.type == Datapoint.Type.FIVE_MIN_AVERAGE ? Constants.FIVE_MIN_SECONDS : Constants.HOUR_SECONDS;
                int w = bounds.toW(pa, timeDelta);
                g2d.fillRect(x, y, w + size, size);
            }
        }
        g2d.setClip(originalClip); // restore original clip
    }

    public void drawLegend(Graphics2D g2, Config config, Rectangle pa, boolean addPredictionLabels) {
        int xMid = pa.x + pa.width / 2;
        g2.setFont(g2.getFont().deriveFont(Font.PLAIN, Config.FONT_SIZE));
        FontMetrics metrics = g2.getFontMetrics();

        // Legend item text labels
        String[] labels = addPredictionLabels
                ? new String[]{"Lows (insta-sell)", "Highs (insta-buy)", "Low prediction", "High prediction", "Low IQR", "High IQR"}
                : new String[]{"Lows (insta-sell)", "Highs (insta-buy)"};

        // Calculate legend position - above the plot area
        int legendY = pa.y / 2;
        int lineLength = 20;
        int itemHeight = 15;
        int itemPadding = 30; // Space between text end and next item start

        // Calculate widths for each legend item based on text length
        int[] itemWidths = new int[labels.length];
        int totalWidth = 0;

        for (int i = 0; i < labels.length; i++) {
            itemWidths[i] = lineLength + 5 + metrics.stringWidth(labels[i]);
            totalWidth += itemWidths[i];
        }

        totalWidth += itemPadding * (labels.length - 1);

        int legendStartX = xMid - totalWidth / 2;
        int currentX = legendStartX;

        // Low prices
        g2.setColor(config.lowColor);
        g2.setStroke(Config.NORMAL_STROKE);
        if (config.connectPoints) {
            g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        }
        g2.fillOval(currentX + lineLength / 2 - 2, legendY + itemHeight/2 - 2, 5, 5);
        g2.setColor(config.textColor);
        g2.drawString(labels[0], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        currentX += itemWidths[0] + itemPadding;

        // High prices
        g2.setColor(config.highColor);
        g2.setStroke(Config.NORMAL_STROKE);
        if (config.connectPoints) {
            g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        }
        g2.fillOval(currentX + lineLength / 2 - 2, legendY + itemHeight/2 - 2, 5, 5);
        g2.setColor(config.textColor);
        g2.drawString(labels[1], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        currentX += itemWidths[1] + itemPadding;

        if (addPredictionLabels) {
            // Low prediction
            g2.setColor(config.lowColor);
            g2.setStroke(Config.DOTTED_STROKE);
            g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
            g2.setColor(config.textColor);
            g2.drawString(labels[2], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
            currentX += itemWidths[2] + itemPadding;

            // High prediction
            g2.setColor(config.highColor);
            g2.setStroke(Config.DOTTED_STROKE);
            g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
            g2.setColor(config.textColor);
            g2.drawString(labels[3], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
            currentX += itemWidths[3] + itemPadding;

            // Low IQR
            g2.setColor(config.lowShadeColor);
            g2.fillRect(currentX, legendY + itemHeight/2 - 5, lineLength, 10);
            g2.setColor(config.textColor);
            g2.drawString(labels[4], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
            currentX += itemWidths[4] + itemPadding;

            // High IQR
            g2.setColor(config.highShadeColor);
            g2.fillRect(currentX, legendY + itemHeight/2 - 5, lineLength, 10);
            g2.setColor(config.textColor);
            g2.drawString(labels[5], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        }
    }

    public void drawVolumeBars(Graphics2D g2d, Config config, Rectangle pa, Bounds bounds, List<Datapoint> volumes, Datapoint hoveredPoint) {
        java.awt.Shape originalClip = g2d.getClip();
        g2d.setClip(pa.x, pa.y, pa.width, pa.height);
        Color high= new Color(config.highColor.getRed(), config.highColor.getGreen(), config.highColor.getBlue(), 128);
        Color low = new Color(config.lowColor.getRed(), config.lowColor.getGreen(), config.lowColor.getBlue(), 128);
        for (Datapoint v : volumes) {
            int x1 = bounds.toX(pa, v.time);
            int x2 = bounds.toX(pa, v.time + Constants.HOUR_SECONDS);
            int y1 = bounds.toY2(pa, v.highVolume + v.lowVolume);
            int y2 = bounds.toY2(pa, v.lowVolume);
            int y3 = bounds.toY2(pa, 0);
            g2d.setColor(high);
            g2d.fillRect(x1, y1, x2-x1, y2-y1);
            g2d.setColor(low);
            g2d.fillRect(x1, y2, x2-x1, y3-y2);
            if (hoveredPoint == v) {
                g2d.setColor(Color.WHITE);
                g2d.setStroke(Config.THICK_STROKE);
                g2d.drawRect(x1, y1, x2 - x1, y3 - y1);
            } else {
                g2d.setColor(Color.GRAY);
                g2d.setStroke(Config.THIN_STROKE);
                g2d.drawRect(x1, y1, x2 - x1, y3 - y1);
            }
        }
        g2d.setClip(originalClip); // restore original clip
    }

    public void drawTxsDatapoints(Graphics2D g2d,
                                  Rectangle pa,
                                  Bounds bounds,
                                  List<Datapoint> txDatapoints,
                                  Datapoint hoveredPoint,
                                  Config config) {
        if (txDatapoints == null || txDatapoints.isEmpty()) return;

        java.awt.Shape originalClip = g2d.getClip();
        g2d.setClip(pa.x, pa.y, pa.width, pa.height);

        int circleSize = 24;
        int radius = circleSize / 2;

        g2d.setFont(g2d.getFont().deriveFont(Font.BOLD, 14f));
        FontMetrics metrics = g2d.getFontMetrics();

        for (Datapoint d : txDatapoints) {
            if (d.time < bounds.xMin || d.time > bounds.xMax) {
                continue;
            }

            int x = bounds.toX(pa, d.time);
            int y = bounds.toY(pa, d.price);

            g2d.setColor(d.isLow ? config.lowColor : config.highColor);
            g2d.fillOval(x - radius, y - radius, circleSize, circleSize);

            g2d.setColor(hoveredPoint == d ? Color.BLACK : Color.WHITE);
            g2d.setStroke(new BasicStroke(2.0f));
            g2d.drawOval(x - radius, y - radius, circleSize, circleSize);

            String text = d.isLow ? "B" : "S";
            int textWidth = metrics.stringWidth(text);
            int textHeight = metrics.getAscent();

            g2d.setColor(Color.WHITE);
            g2d.drawString(text,
                    x - textWidth / 2,
                    y + textHeight / 3); // Adjust vertical centering
        }

        g2d.setClip(originalClip);
    }
}

package com.flippingcopilot.ui.graph;


@FunctionalInterface
public interface CoordinateConverter {
    int toValue(int coordinate);
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.Config;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class ConfigPanel extends JPanel {
    private final Map<String, Component> configComponents = new HashMap<>();
    private final Runnable onApplyCallback;
    private final PriceGraphConfigManager configManager;
    private final Config configInstance;

    public ConfigPanel(PriceGraphConfigManager configManager, Runnable callback) {
        this.configManager = configManager;
        this.configInstance = configManager.getConfig();
        this.onApplyCallback = callback;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel settingsPanel = new JPanel();
        settingsPanel.setLayout(new GridBagLayout());
        settingsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1.0;
        c.anchor = GridBagConstraints.NORTH;
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(5, 5, 5, 5);

        JLabel titleLabel = new JLabel("Graph Settings");
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 16f));
        titleLabel.setBorder(new EmptyBorder(0, 0, 15, 0));
        settingsPanel.add(titleLabel, c);
        c.gridy++;

        // boolean
        addBooleanSetting(settingsPanel, c, "connectPoints", configInstance.isConnectPoints());

        // colours
        addColorSetting(settingsPanel, c, "lowColor", configInstance.getLowColor());
        addColorSetting(settingsPanel, c, "highColor", configInstance.getHighColor());
        addColorSetting(settingsPanel, c, "lowShadeColor", configInstance.getLowShadeColor());
        addColorSetting(settingsPanel, c, "highShadeColor", configInstance.getHighShadeColor());
        addColorSetting(settingsPanel, c, "backgroundColor", configInstance.getBackgroundColor());
        addColorSetting(settingsPanel, c, "plotAreaColor", configInstance.getPlotAreaColor());
        addColorSetting(settingsPanel, c, "textColor", configInstance.getTextColor());
        addColorSetting(settingsPanel, c, "axisColor", configInstance.getAxisColor());
        addColorSetting(settingsPanel, c, "gridColor", configInstance.getGridColor());

        // Add a filler component to push everything to the top
        GridBagConstraints fillerConstraints = new GridBagConstraints();
        fillerConstraints.gridx = 0;
        fillerConstraints.gridy = c.gridy;
        fillerConstraints.gridwidth = GridBagConstraints.REMAINDER;
        fillerConstraints.fill = GridBagConstraints.BOTH;
        fillerConstraints.weightx = 1.0;
        fillerConstraints.weighty = 1.0;

        JPanel fillerPanel = new JPanel();
        fillerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        settingsPanel.add(fillerPanel, fillerConstraints);

        JScrollPane scrollPane = new JScrollPane(settingsPanel);
        scrollPane.setBorder(null);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JButton applyButton = new JButton("Apply");
        applyButton.setFocusPainted(false);
        applyButton.setBackground(ColorScheme.BRAND_ORANGE);
        applyButton.setForeground(Color.WHITE);
        applyButton.addActionListener(e -> {
            applySettings();
            if (onApplyCallback != null) {
                onApplyCallback.run();
            }
        });

        buttonPanel.add(applyButton);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void addBooleanSetting(JPanel panel, GridBagConstraints c, String name, boolean value) {
        JLabel label = new JLabel(formatFieldName(name));
        label.setForeground(Color.WHITE);
        panel.add(label, c);
        c.gridx = 1;

        JCheckBox checkBox = new JCheckBox();
        checkBox.setSelected(value);
        checkBox.setToolTipText(name);
        checkBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        configComponents.put(name, checkBox);
        panel.add(checkBox, c);

        c.gridx = 0;
        c.gridy++;
    }

    private void addColorSetting(JPanel panel, GridBagConstraints c, String name, Color value) {
        JLabel label = new JLabel(formatFieldName(name));
        label.setForeground(Color.WHITE);
        panel.add(label, c);
        c.gridx = 1;

        JPanel colorPanel = new JPanel();
        colorPanel.setBackground(value);
        colorPanel.setPreferredSize(new Dimension(30, 20));
        colorPanel.setBorder(BorderFactory.createLineBorder(Color.WHITE));

        JButton colorButton = new JButton("Choose...");
        colorButton.setToolTipText(name);
        colorButton.addActionListener(e -> {
            Color newColor = JColorChooser.showDialog(this, "Choose " + formatFieldName(name), colorPanel.getBackground());
            if (newColor != null) {
                colorPanel.setBackground(newColor);
            }
        });

        JPanel wrapper = new JPanel(new FlowLayout(FlowLayout.LEFT));
        wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        wrapper.add(colorPanel);
        wrapper.add(colorButton);

        configComponents.put(name, wrapper);
        panel.add(wrapper, c);

        c.gridx = 0;
        c.gridy++;
    }

    private String formatFieldName(String name) {
        StringBuilder result = new StringBuilder();
        for (char ch : name.toCharArray()) {
            if (Character.isUpperCase(ch)) {
                result.append(' ').append(Character.toLowerCase(ch));
            } else {
                result.append(ch);
            }
        }
        return result.toString().trim();
    }

    private Color extractColor(String key) {
        JPanel wrapper = (JPanel) configComponents.get(key);
        JPanel colorPanel = (JPanel) wrapper.getComponent(0);
        return colorPanel.getBackground();
    }

    private void applySettings() {
        try {
            // boolean
            JCheckBox connectPointsBox = (JCheckBox) configComponents.get("connectPoints");
            configInstance.setConnectPoints(connectPointsBox.isSelected());

            // colours
            configInstance.setLowColor(extractColor("lowColor"));
            configInstance.setHighColor(extractColor("highColor"));
            configInstance.setLowShadeColor(extractColor("lowShadeColor"));
            configInstance.setHighShadeColor(extractColor("highShadeColor"));
            configInstance.setBackgroundColor(extractColor("backgroundColor"));
            configInstance.setPlotAreaColor(extractColor("plotAreaColor"));
            configInstance.setTextColor(extractColor("textColor"));
            configInstance.setAxisColor(extractColor("axisColor"));
            configInstance.setGridColor(extractColor("gridColor"));

            configManager.setConfig(configInstance);
            log.debug("Applied and saved graph settings");
        } catch (Exception e) {
            log.error("Error applying settings", e);
            JOptionPane.showMessageDialog(this, "Error applying settings: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    public static JLabel buildButton(Image icon, String tooltip, Runnable onClick) {
        JLabel button = new JLabel(new ImageIcon(icon));
        button.setToolTipText(tooltip);
        button.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                onClick.run();
            }

            public void mouseEntered(java.awt.event.MouseEvent evt) {
                button.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
        });
        return button;
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.ItemController;
import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.model.FlipV2;
import com.flippingcopilot.ui.graph.model.Constants;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.text.NumberFormat;
import java.util.Date;

@Slf4j
public class FlipStatsPanel extends JPanel {
    private final JTable statsTable;
    private final JLabel itemIcon = new JLabel();
    private final JLabel itemNameLabel = new JLabel();
    private final FlippingCopilotConfig copilotConfig;

    public FlipStatsPanel(PriceGraphConfigManager configManager, FlippingCopilotConfig copilotConfig) {
        this.copilotConfig = copilotConfig;
        this.setLayout(new BorderLayout());

        JPanel iconPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        iconPanel.setBackground(configManager.getConfig().backgroundColor);
        iconPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 15, 0));
        itemIcon.setBorder(null);
        iconPanel.add(itemIcon);
        itemNameLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        itemNameLabel.setFont(itemNameLabel.getFont().deriveFont(Font.BOLD, 16f));
        iconPanel.add(itemNameLabel);

        this.add(iconPanel, BorderLayout.NORTH);

        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        model.addColumn("Statistic");
        model.addColumn("Value");
        model.addRow(new Object[]{"First buy time", ""});
        model.addRow(new Object[]{"Last sell time", ""});
        model.addRow(new Object[]{"Status", ""});
        model.addRow(new Object[]{"Bought", ""});
        model.addRow(new Object[]{"Sold", ""});
        model.addRow(new Object[]{"Avg. buy price", ""});
        model.addRow(new Object[]{"Avg. sell price", ""});
        model.addRow(new Object[]{"Tax", ""});
        model.addRow(new Object[]{"Profit", ""});
        model.addRow(new Object[]{"Profit ea.", ""});

        statsTable = new JTable(model);
        statsTable.setRowHeight(26);
        statsTable.getTableHeader().setReorderingAllowed(false);
        statsTable.getTableHeader().setResizingAllowed(true);
        statsTable.setBackground(configManager.getConfig().backgroundColor);
        statsTable.setShowGrid(false);

        statsTable.getColumnModel().getColumn(0).setPreferredWidth(150);
        statsTable.getColumnModel().getColumn(1).setPreferredWidth(120);

        statsTable.setTableHeader(null);

        // Set custom cell renderer for value column to color profit/loss
        statsTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                // Apply color to profit rows (Profit and Profit ea.)
                if (row == 9 || row == 10) { // Index of Profit and Profit ea. rows
                    String valueStr = value.toString();
                    // Remove formatting characters and check if negative
                    String numStr = valueStr.replace(",", "");
                    try {
                        long profitValue = Long.parseLong(numStr);
                        if (profitValue < 0) {
                            c.setForeground(copilotConfig.lossAmountColor());
                        } else if (profitValue > 0) {
                            c.setForeground(copilotConfig.profitAmountColor());
                        } else {
                            c.setForeground(table.getForeground());
                        }
                    } catch (NumberFormatException e) {
                        c.setForeground(table.getForeground());
                    }
                } else {
                    c.setForeground(table.getForeground());
                }

                return c;
            }
        });

        JScrollPane scrollPane = new JScrollPane(statsTable);
        scrollPane.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1, 0, 0, 0, Color.GRAY),
                BorderFactory.createEmptyBorder(10, 0, 0, 0)));

        scrollPane.setColumnHeaderView(null);

        this.add(scrollPane, BorderLayout.CENTER);
        this.setPreferredSize(new Dimension(280, 450));
    }

    public void populate(FlipV2 flip, ItemController itemController) {
        itemIcon.setVisible(false);

        itemController.loadImage(flip.getItemId(), (image) -> {
            if (image != null) {
                image.addTo(itemIcon);
                itemIcon.setVisible(true);
            }
        });

        itemNameLabel.setText(itemController.getItemName(flip.getItemId()));

        DefaultTableModel model = (DefaultTableModel) statsTable.getModel();

        long profitPerItem = flip.getClosedQuantity() > 0 ?
                flip.getProfit() / flip.getClosedQuantity() : 0L;

        model.setValueAt(formatTimestamp(flip.getOpenedTime()), 0, 1);
        model.setValueAt(formatTimestamp(flip.getClosedTime()), 1, 1);
        model.setValueAt(flip.getStatus().name(), 2, 1);
        model.setValueAt(formatNumber(flip.getOpenedQuantity()), 3, 1);
        model.setValueAt(formatNumber(flip.getClosedQuantity()), 4, 1);
        model.setValueAt(formatNumber(flip.getAvgBuyPrice()), 5, 1);
        model.setValueAt(formatNumber(flip.getAvgSellPrice()), 6, 1);
        model.setValueAt(formatNumber(flip.getTaxPaid()), 7, 1);
        model.setValueAt(formatNumber(flip.getProfit()), 8, 1);
        model.setValueAt(formatNumber(profitPerItem), 9, 1);
    }

    private String formatNumber(long number) {
        return NumberFormat.getNumberInstance().format(number);
    }

    private String formatTimestamp(int timestamp) {
        if (timestamp == 0) {
            return "n/a";
        }
        return Constants.SECOND_DATE_FORMAT.format(new Date(timestamp * 1000L));
    }
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.model.VisualizeFlipResponse;
import com.flippingcopilot.ui.graph.model.*;
import com.flippingcopilot.util.GeTax;
import lombok.Getter;

import java.awt.*;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;


@Getter
public class DataManager {

    public final List<Datapoint> highDatapoints = new ArrayList<>();
    public final List<Datapoint> lowDatapoints = new ArrayList<>();
    public final List<Datapoint> predictionLowDatapoints = new ArrayList<>();
    public final List<Datapoint> predictionHighDatapoints = new ArrayList<>();
    public final List<Datapoint> volumes = new ArrayList<>();

    public final List<Datapoint> flipEntryDatapoints = new ArrayList<>();
    public final List<Datapoint> flipCloseDatapoints = new ArrayList<>();
    public int minEntryTime;
    public int maxCloseTime;
    public Bounds maxBounds = new Bounds();

    public final Data data;
    private final VisualizeFlipResponse fpr;
    public double priceChange24H = 0;
    public double priceChangeWeek = 0;
    public int lastLowTime = 0;
    public int lastLowPrice = 0;
    public int lastHighTime = 0;
    public int lastHighPrice = 0;
    public long margin;
    public long tax;
    public long profit;

    public DataManager(Data data, VisualizeFlipResponse fpr) {
        this.data = data;
        this.fpr = fpr;
        processDatapoints();
        calculateStats();
    }

    public Datapoint findClosestPoint(Point mousePos, int hoverRadius, Rectangle pa, Bounds bounds) {
        if (mousePos == null) return null;

        Datapoint closest = null;
        double minDistance = hoverRadius*2;

        // prioritize hovering on the flip transaction datapoints
        for(List<Datapoint> datapoints : Arrays.asList(flipEntryDatapoints, flipCloseDatapoints)) {
            for (Datapoint d : datapoints) {
                Point hoverPosition = d.getHoverPosition(pa, bounds);
                double distance = mousePos.distance(hoverPosition);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = d;
                }
            }
        }
        if (closest != null) {
            return closest;
        }

        minDistance = hoverRadius;

        for(List<Datapoint> datapoints : Arrays.asList(highDatapoints, lowDatapoints, predictionLowDatapoints, predictionHighDatapoints)) {
            for (Datapoint d : datapoints) {
                Point hoverPosition = d.getHoverPosition(pa, bounds);
                double distance = mousePos.distance(hoverPosition);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = d;
                }
            }
        }
        return closest;
    }


    public Bounds calculateHomeBounds() {
        int xMax = flipCloseDatapoints.isEmpty() ? maxBounds.xMax : maxCloseTime;
        int xMin = flipEntryDatapoints.isEmpty() ? maxBounds.xMax - 4*Constants.DAY_SECONDS : minEntryTime;
        int range = xMax - xMin;
        if(!flipEntryDatapoints.isEmpty()) {
            xMin -= Math.max(range / 10, Constants.FIVE_MIN_SECONDS);
        }
        if(!flipCloseDatapoints.isEmpty()) {
            xMax += Math.max(range / 10, Constants.FIVE_MIN_SECONDS);
        }
        int finalXMax = xMax;
        int finalXMin = xMin;
        Bounds b = calculateBounds((p) -> p.time > finalXMin && p.time < finalXMax);
        b.xMax = xMax;
        b.xMin = xMin;
        return b;
    }

    public Bounds calculateWeekBounds() {
        Bounds b = calculateBounds((p) -> p.time > maxBounds.xMax - 7 * Constants.DAY_SECONDS);
        b.xMin= ((b.xMin) / Constants.HOUR_SECONDS) * Constants.HOUR_SECONDS;
        b.xMax = ((b.xMax) / Constants.HOUR_SECONDS) * Constants.HOUR_SECONDS + Constants.HOUR_SECONDS;
        return b;
    }

    public Bounds calculateMonthBounds() {
        Bounds b = calculateBounds((p) -> p.time > maxBounds.xMax - 30 * Constants.DAY_SECONDS);
        b.xMin= ((b.xMin) / Constants.HOUR_SECONDS) * Constants.HOUR_SECONDS;
        b.xMax = ((b.xMax) / Constants.HOUR_SECONDS) * Constants.HOUR_SECONDS + Constants.HOUR_SECONDS;
        return b;
    }


    public Bounds calculateBounds(Predicate<Datapoint> p) {
        Bounds b = new Bounds();

        b.xMin = Integer.MAX_VALUE;
        b.xMax = Integer.MIN_VALUE;
        b.yMax =  Integer.MIN_VALUE;
        b.yMin = Integer.MAX_VALUE;
        b.y2Min = 0;
        b.y2Max = 10;

        long yMean = 0;
        long n = 0;

        for(List<Datapoint> datapoints : Arrays.asList(highDatapoints, lowDatapoints, predictionLowDatapoints, predictionHighDatapoints, flipEntryDatapoints, flipCloseDatapoints)) {
            for (Datapoint d : datapoints) {
                if (p.test(d)) {
                    yMean = (n * yMean + (long) d.price) / (n+1);
                    n+=1;

                    b.xMin = Math.min(b.xMin, d.time);
                    b.xMax = Math.max(b.xMax, d.time);

                    // Update price bounds
                    b.yMin = Math.min(b.yMin, d.price);
                    b.yMax = Math.max(b.yMax, d.price);

                    // Check IQR bounds for prediction points
                    if (d.type == Datapoint.Type.PREDICTION) {
                        if (d.iqrLower != null) {
                            b.yMin = Math.min(b.yMin, d.iqrLower);
                        }
                        if (d.iqrUpper != null) {
                            b.yMax = Math.max(b.yMax, d.iqrUpper);
                        }
                    }
                }
            }
        }
        for (Datapoint d : volumes) {
            if (p.test(d)) {
                b.y2Max = Math.max(b.y2Max, d.highVolume + d.lowVolume);
            }
            d.time += Constants.HOUR_SECONDS;
            if (p.test(d)) {
                b.y2Max = Math.max(b.y2Max, d.highVolume + d.lowVolume);
            }
            d.time -= Constants.HOUR_SECONDS;
        }
        b.y2Max = (int) (1.1*b.y2Max);
        int pricePadding = (int) (0.03 * yMean);
        if (pricePadding < 1) pricePadding = 1;

        b.yMin = Math.max(0, b.yMin - pricePadding);
        b.yMax+= pricePadding;

        return b;
    }

    private void processDatapoints() {
        highDatapoints.clear();
        lowDatapoints.clear();
        predictionHighDatapoints.clear();
        predictionLowDatapoints.clear();
        volumes.clear();
        flipEntryDatapoints.clear();
        flipCloseDatapoints.clear();
        
        // here we combine the hour / 5min / latest wiki price data points into a continuous dataset where hour points 
        // transition into the 5min points that transition into the latest points. So we get increasingly finer granularity.
        // We truncate the points correctly at the boundaries to ensure no overlap.

        if (data.lowLatestTimes == null) {
            return;
        }

        for (int i = 0; i < data.lowLatestTimes.length; i++) {
            lowDatapoints.add(new Datapoint(data.lowLatestTimes[i], data.lowLatestPrices[i], true, Datapoint.Type.INSTA_SELL_BUY));
        }
        int fiveMinLowsCut;
        if (!lowDatapoints.isEmpty()) {
            fiveMinLowsCut = Constants.FIVE_MIN_SECONDS * (lowDatapoints.get(0).time / Constants.FIVE_MIN_SECONDS)  + Constants.FIVE_MIN_SECONDS;
            lowDatapoints.removeIf((i) -> i.time < fiveMinLowsCut);
        } else {
            fiveMinLowsCut = Integer.MAX_VALUE;
        }
        for (int i = data.low5mTimes.length-1; i >= 0; i--) {
            if (data.low5mTimes[i] < fiveMinLowsCut) {
                lowDatapoints.add(0, new Datapoint(data.low5mTimes[i], data.low5mPrices[i], true, Datapoint.Type.FIVE_MIN_AVERAGE));
            }
        }
        int oneHourLowsCut;
        if (!lowDatapoints.isEmpty()) {
            oneHourLowsCut = Constants.HOUR_SECONDS * (lowDatapoints.get(0).time / Constants.HOUR_SECONDS)  + Constants.HOUR_SECONDS;
            lowDatapoints.removeIf((i) -> i.time < oneHourLowsCut);
        } else {
            oneHourLowsCut = Integer.MAX_VALUE;
        }
        for (int i = data.low1hTimes.length-1; i >= 0; i--) {
            if (data.low1hTimes[i] < oneHourLowsCut) {
                lowDatapoints.add(0, new Datapoint(data.low1hTimes[i], data.low1hPrices[i], true, Datapoint.Type.HOUR_AVERAGE));
            }
        }

        for (int i = 0; i < data.highLatestTimes.length; i++) {
            highDatapoints.add(new Datapoint(data.highLatestTimes[i], data.highLatestPrices[i], false, Datapoint.Type.INSTA_SELL_BUY));
        }
        int fiveMinHighsCut;
        if (!highDatapoints.isEmpty()) {
            fiveMinHighsCut = Constants.FIVE_MIN_SECONDS * (highDatapoints.get(0).time / Constants.FIVE_MIN_SECONDS)  + Constants.FIVE_MIN_SECONDS;
            highDatapoints.removeIf((i) -> i.time < fiveMinHighsCut);
        } else {
            fiveMinHighsCut = Integer.MAX_VALUE;
        }
        for (int i = data.high5mTimes.length-1; i >= 0; i--) {
            if (data.high5mTimes[i] < fiveMinHighsCut) {
                highDatapoints.add(0, new Datapoint(data.high5mTimes[i], data.high5mPrices[i], false, Datapoint.Type.FIVE_MIN_AVERAGE));
            }
        }
        int oneHourHighsCut;
        if (!highDatapoints.isEmpty()) {
            oneHourHighsCut = Constants.HOUR_SECONDS * (highDatapoints.get(0).time / Constants.HOUR_SECONDS)  + Constants.HOUR_SECONDS;
            highDatapoints.removeIf((i) -> i.time < oneHourHighsCut);
        } else {
            oneHourHighsCut = Integer.MAX_VALUE;
        }
        for (int i = data.high1hTimes.length-1; i >= 0; i--) {
            if (data.high1hTimes[i] < oneHourHighsCut) {
                highDatapoints.add(0, new Datapoint(data.high1hTimes[i], data.high1hPrices[i], false, Datapoint.Type.HOUR_AVERAGE));
            }
        }


        if(data.predictionTimes != null) {
            for (int i = 0; i < data.predictionTimes.length; i++) {
                predictionLowDatapoints.add(new Datapoint(
                        data.predictionTimes[i],
                        data.predictionLowMeans[i],
                        data.predictionLowIQRLower[i],
                        data.predictionLowIQRUpper[i],
                        true
                ));
                predictionHighDatapoints.add(new Datapoint(
                        data.predictionTimes[i],
                        data.predictionHighMeans[i],
                        data.predictionHighIQRLower[i],
                        data.predictionHighIQRUpper[i],
                        false
                ));
            }
        }

        for (int i = data.volume1hLows.length-1; i >= 0; i--) {
            volumes.add(0, Datapoint.newVolumeDatapoint(data.volume1hTimes[i], data.volume1hLows[i], data.volume1hHighs[i]));
        }
        int current1hTime = data.volume1hTimes[data.volume1hTimes.length-1] + Constants.HOUR_SECONDS;
        int currentHourLowVolume = 0;
        int currentHoursHighVolume =0;
        for (int i = data.volume5mLows.length-1; i >= 0; i--) {
            if (data.volume5mTimes[i] >= current1hTime) {
                currentHourLowVolume += data.volume5mLows[i];
                currentHoursHighVolume += data.volume5mHighs[i];
            }
        }
        volumes.add(Datapoint.newVolumeDatapoint(current1hTime, currentHourLowVolume, currentHoursHighVolume));

        minEntryTime = Integer.MAX_VALUE;
        maxCloseTime = 0;
        if(fpr != null){
            if(fpr.buyTimes != null) {
                for (int i = 0; i < fpr.buyTimes.length; i++) {
                    flipEntryDatapoints.add(Datapoint.newBuyTx(
                            fpr.buyTimes[i],
                            fpr.buyPrices[i],
                            fpr.buyVolumes[i]
                    ));
                    minEntryTime = Math.min(fpr.buyTimes[i], minEntryTime);
                }
            }
            if(fpr.sellTimes != null) {
                for (int i = 0; i < fpr.sellTimes.length; i++) {
                    flipCloseDatapoints.add(Datapoint.newSellTx(
                            fpr.sellTimes[i],
                            fpr.sellPrices[i],
                            fpr.sellVolumes[i]
                    ));
                    maxCloseTime = Math.max(fpr.sellTimes[i], maxCloseTime);
                }
            }
        }

        maxBounds = calculateBounds((p) -> true);
        maxBounds.xMin= ((maxBounds.xMin) / Constants.HOUR_SECONDS) * Constants.HOUR_SECONDS;
        maxBounds.xMax = ((maxBounds.xMax) / Constants.HOUR_SECONDS) * Constants.HOUR_SECONDS + Constants.HOUR_SECONDS;
    }

    private void calculateStats() {
        int cut24h = (int) Instant.now().minus(Duration.ofDays(1)).getEpochSecond();
        int cutWeek = (int) Instant.now().minus(Duration.ofDays(7)).getEpochSecond();
        if (!lowDatapoints.isEmpty() && !highDatapoints.isEmpty()){
            double priceCurrent = (lowDatapoints.get(lowDatapoints.size()-1).price *0.5 + highDatapoints.get(highDatapoints.size()-1).price *0.5);
            double lowPrice24hAgo = lowDatapoints.stream().filter(i-> i.time > cut24h).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double highPrice24hAgo = highDatapoints.stream().filter(i-> i.time > cut24h).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double price24hAgo = lowPrice24hAgo*0.5 + highPrice24hAgo*0.5;
            if (price24hAgo > 0 ) {
                this.priceChange24H = (priceCurrent - price24hAgo) / price24hAgo;
            }
            double lowPriceWeekAgo = lowDatapoints.stream().filter(i-> i.time > cutWeek).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double highPriceWeekAgo = highDatapoints.stream().filter(i-> i.time > cutWeek).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double priceWeekAgo = lowPriceWeekAgo*0.5 + highPriceWeekAgo*0.5;
            if (priceWeekAgo > 0 ) {
                this.priceChangeWeek = (priceCurrent - priceWeekAgo) / priceWeekAgo;
            }
        }

        if(!highDatapoints.isEmpty()) {
            lastHighTime = highDatapoints.get(highDatapoints.size()-1).time;
            lastHighPrice = highDatapoints.get(highDatapoints.size()-1).price;
        }

        if(!lowDatapoints.isEmpty()) {
            lastLowTime = lowDatapoints.get(lowDatapoints.size()-1).time;
            lastLowPrice = lowDatapoints.get(lowDatapoints.size()-1).price;
        }

        margin = data.sellPrice - data.buyPrice;
        tax = data.sellPrice - GeTax.getPostTaxPrice(data.itemId, (int) data.sellPrice);
        profit = margin - tax;
    }

    public List<Datapoint> sellPriceDataPoint() {
        return Collections.singletonList(new Datapoint(
                (int) Instant.now().getEpochSecond(),
                (int) data.sellPrice,
                false,
                Datapoint.Type.PREDICTION
        ));
    }

    public List<Datapoint> buyPriceDataPoint() {
        return Collections.singletonList(new Datapoint(
                (int) Instant.now().getEpochSecond(),
                (int) data.buyPrice,
                true,
                Datapoint.Type.PREDICTION
        ));
    }

    public Datapoint closedVolumeBar(Point mousePosition, Rectangle pa, Bounds bounds) {
        Datapoint winner =  null;
        int winnerDist = Integer.MAX_VALUE;
        for (Datapoint v : volumes) {
            int dist = Math.abs(bounds.toX(pa, v.time + Constants.HOUR_SECONDS / 2) - mousePosition.x);
            if (dist < winnerDist) {
                winnerDist = dist;
                winner = v;
            }
        }
        return winner;
    }
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.manager.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class GraphPanel extends JPanel {

    private final PriceGraphConfigManager configManager;
    public DataManager dataManager;
    private final RenderV2 renderer;
    public final ZoomHandler zoomHandler;
    private final DatapointTooltip tooltip;

    public Bounds bounds;

    public Rectangle pricePa;
    public Rectangle volumePa;

    private Point mousePosition = new Point(0,0);
    private Datapoint hoveredPoint = null;

    public GraphPanel(PriceGraphConfigManager configManager) {

        this.configManager = configManager;
        this.renderer = new RenderV2();
        this.zoomHandler = new ZoomHandler();
        this.tooltip = new DatapointTooltip();

        setBackground(configManager.getConfig().backgroundColor);
        setPreferredSize(new Dimension(500, 300));
        setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));
        setupMouseListeners();
    }

    public void setData(DataManager dm) {
        int oldItemID = dataManager == null ? -1 : dataManager.data.itemId;
        dataManager = dm;
        zoomHandler.maxViewBounds = dataManager.maxBounds;
        zoomHandler.homeViewBounds = dataManager.calculateHomeBounds();
        zoomHandler.weekViewBounds = dataManager.calculateWeekBounds();
        zoomHandler.monthViewBounds = dataManager.calculateMonthBounds();
        if(oldItemID != dataManager.data.itemId) {
            bounds = zoomHandler.homeViewBounds.copy();
        }
        repaint();
    }


    private void setupMouseListeners() {
        MouseAdapter mouseAdapter = new MouseAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                if(dataManager == null){
                    return;
                }
                mousePosition = e.getPoint();
                if(pricePa.contains(mousePosition)) {
                    hoveredPoint = dataManager.findClosestPoint(mousePosition, Config.HOVER_RADIUS, pricePa, bounds);
                }else if(volumePa.contains(mousePosition)) {
                    hoveredPoint = dataManager.closedVolumeBar(mousePosition, volumePa, bounds);
                } else {
                    hoveredPoint = null;
                }
                repaint();
            }

            @Override
            public void mousePressed(MouseEvent e) {
                if(dataManager == null){
                    return;
                }
                mousePosition = e.getPoint();
                if (!pricePa.contains(mousePosition)) {
                    return;
                }

                if (zoomHandler.isOverHomeButton(mousePosition)) {
                    zoomHandler.applyHomeView(bounds);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverMaxButton(mousePosition)) {
                    zoomHandler.applyMaxView(bounds);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverZoomInButton(mousePosition)) {
                    zoomHandler.applyZoomIn(bounds);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverZoomOutButton(mousePosition)) {
                    zoomHandler.applyZoomOut(bounds);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverWeekButton(mousePosition)) {
                    zoomHandler.applyWeekView(bounds);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverMonthButton(mousePosition)) {
                    zoomHandler.applyMonthView(bounds);
                    repaint();
                    return;
                }

                zoomHandler.startSelection(mousePosition);
                hoveredPoint = null;
                setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
                repaint();
            }

            @Override
            public void mouseDragged(MouseEvent e) {
                if(dataManager == null){
                    return;
                }
                mousePosition = e.getPoint();
                if (zoomHandler.isSelecting()) {
                    zoomHandler.setSelectionEnd(mousePosition);
                    repaint();
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                if(dataManager == null){
                    return;
                }
                mousePosition = e.getPoint();
                if (zoomHandler.isSelecting()) {
                    setCursor(Cursor.getDefaultCursor());
                    zoomHandler.setSelectionEnd(mousePosition);
                    zoomHandler.applySelection(pricePa, bounds);
                    repaint();
                }
            }

            @Override
            public void mouseExited(MouseEvent e) {
                if(dataManager == null){
                    return;
                }
                mousePosition = e.getPoint();
                hoveredPoint = null;
                repaint();
            }
        };

        addMouseMotionListener(mouseAdapter);
        addMouseListener(mouseAdapter);
    }


    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);


        final int leftPadding = 80;
        final int topPadding = 50;
        final int rightPadding = 20;
        final int bottomPadding = 50;
        
        int w = getWidth() - leftPadding - rightPadding;
        int ah = getHeight() - topPadding - bottomPadding;
        int h1 = (int) (ah * 0.75);
        int h2 = ah - h1;
        
        pricePa = new Rectangle(leftPadding, topPadding, w, h1);
        volumePa = new Rectangle(leftPadding, topPadding+h1, w, h2);
        if(dataManager == null) {
            return;
        }
        Data data = dataManager.getData();
        if (data == null) return;
        Config config = configManager.getConfig();
        setBackground(config.backgroundColor);
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);

        // First draw the legend above the plot area
        renderer.drawLegend(g2d, config, pricePa, data.predictionTimes != null);

        // Draw the plot area background with dynamic padding
        g2d.setColor(config.plotAreaColor);
        g2d.fillRect(pricePa.x, pricePa.y, pricePa.width, pricePa.height);
        g2d.fillRect(volumePa.x, volumePa.y,  volumePa.width, volumePa.height);
        
        TimeAxis xAxis = AxisCalculator.calculateTimeAxis(bounds, AxisCalculator.getLocalTimeOffsetSeconds());
        YAxis yAxis = AxisCalculator.calculatePriceAxis(bounds);
        YAxis y2Axis = AxisCalculator.calculateVolumeAxis(bounds);

        renderer.drawGrid(g2d, config, pricePa, bounds, bounds::toY, xAxis, yAxis);
        renderer.drawGrid(g2d, config, volumePa, bounds, bounds:: toY2, xAxis, y2Axis);
        renderer.drawAxes(g2d, config, pricePa);
        renderer.drawYAxisLabels(g2d, config, pricePa, bounds::toY, yAxis, false);
        renderer.drawAxes(g2d, config, volumePa);
        renderer.drawYAxisLabels(g2d, config, volumePa, bounds::toY2, y2Axis, true);
        renderer.drawXAxisLabels(g2d, config, volumePa, bounds, xAxis);


        int pointSize = dynamicPointSize(Config.BASE_POINT_SIZE, bounds);
        renderer.drawPoints(g2d, pricePa, bounds, dataManager.lowDatapoints, config.lowColor, pointSize);
        renderer.drawPoints(g2d, pricePa, bounds, dataManager.highDatapoints, config.highColor, pointSize);
        if (config.connectPoints) {
            renderer.drawLines(g2d, pricePa, bounds, dataManager.lowDatapoints, config.lowColor, Config.NORMAL_STROKE);
            renderer.drawLines(g2d, pricePa, bounds, dataManager.highDatapoints, config.highColor, Config.NORMAL_STROKE);
        }
        renderer.drawStartPoints(g2d, pricePa, bounds, dataManager.buyPriceDataPoint(), Color.WHITE, pointSize);
        renderer.drawStartPoints(g2d, pricePa, bounds, dataManager.sellPriceDataPoint(), Color.WHITE, pointSize);

        renderer.drawLines(g2d, pricePa, bounds, dataManager.predictionLowDatapoints, config.lowColor, Config.DOTTED_STROKE);
        renderer.drawLines(g2d, pricePa, bounds, dataManager.predictionHighDatapoints, config.highColor, Config.DOTTED_STROKE);
        if(data.predictionTimes != null) {
            renderer.drawPredictionIQR(g2d, config, pricePa, bounds, data.predictionTimes, data.predictionLowIQRLower, data.predictionLowIQRUpper, true);
            renderer.drawPredictionIQR(g2d, config, pricePa, bounds, data.predictionTimes, data.predictionHighIQRLower, data.predictionHighIQRUpper, false);
        }
        zoomHandler.drawButtons(g2d, pricePa, mousePosition);
        zoomHandler.drawSelectionRectangle(g2d, pricePa);

        renderer.drawVolumeBars(g2d, config, volumePa, bounds, dataManager.volumes, hoveredPoint);


        if(!this.dataManager.flipEntryDatapoints.isEmpty()) {
            renderer.drawTxsDatapoints(g2d, pricePa, bounds, this.dataManager.flipEntryDatapoints, hoveredPoint, config);
        }

        if(!this.dataManager.flipCloseDatapoints.isEmpty()) {
            renderer.drawTxsDatapoints(g2d, pricePa, bounds, this.dataManager.flipCloseDatapoints, hoveredPoint, config);
        }

        // Draw tooltip for hovered point
        if (hoveredPoint != null) {
            if (hoveredPoint.type == Datapoint.Type.VOLUME_1H) {
                tooltip.drawVolume(g2d, config, volumePa, bounds, hoveredPoint);
            } else {
                tooltip.draw(g2d, config, pricePa, bounds, hoveredPoint);
            }
        }
    }

    private int dynamicPointSize(int baseSize, Bounds bounds) {
        int td = bounds.xMax - bounds.xMin;
        if (td < Constants.DAY_SECONDS) {
            return (int) ((float) baseSize * 1.25);
        } else if (td > Constants.DAY_SECONDS * 20) {
            return (int) ((float) baseSize * 0.5);
        } else if (td > Constants.DAY_SECONDS * 6) {
            return (int) ((float) baseSize * 0.75);
        }
        return baseSize;
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;

@Getter
@Setter
@NoArgsConstructor
public class Config {
    public static int LABEL_PADDING = 20;
    public static int TICK_SIZE = 5;
    public static int BASE_POINT_SIZE = 4;

    public static int GRAPH_BUTTON_SIZE = 24;
    public static int GRAPH_BUTTON_MARGIN = 5;

    public static int HOVER_RADIUS = 8; // Distance in pixels to detect hovering

    public static final Stroke THIN_STROKE = new BasicStroke(0.5f);
    public static final Stroke NORMAL_STROKE = new BasicStroke(1f);
    public static final Stroke THICK_STROKE = new BasicStroke(2f);
    public static final Stroke DOTTED_STROKE = new BasicStroke(
            1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{5}, 0
    );
    public static final Stroke GRID_STROKE = new BasicStroke(
            0.8f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{3}, 0
    );
    public static final Stroke SELECTION_STROKE = new BasicStroke(1.5f);

    public static float FONT_SIZE = 16f;

    public static Color TOOLTIP_BACKGROUND = new Color(20, 20, 20, 220);
    public static Color TOOLTIP_BORDER = new Color(100, 100, 100);
    public static Color SELECTION_COLOR = new Color(100, 100, 240, 80); // Color for zoom selection
    public static Color SELECTION_BORDER_COLOR = new Color(70, 70, 220);
    public static Color GRAPH_BUTTON_COLOR = new Color(150, 150, 150, 200);
    public static Color GRAPH_BUTTON_HOVER_COLOR = new Color(100,100,100);

    // configurable properties
    public boolean connectPoints = false;
    public Color lowColor = new Color(0, 153, 255);
    public Color highColor = new Color(255, 102, 0);
    public Color lowShadeColor = new Color(0, 153, 255, 60);
    public Color highShadeColor = new Color(255, 102, 0, 60);

    public Color backgroundColor = ColorScheme.DARKER_GRAY_COLOR.brighter();
    public Color plotAreaColor = new Color(51, 51, 51);
    public Color textColor = new Color(225, 225, 225);
    public Color axisColor = new Color(150, 150, 150);
    public Color gridColor = new Color(85, 85, 85, 90);
}
package com.flippingcopilot.ui.graph.model;

import lombok.Getter;
import lombok.Setter;

import java.awt.*;

@Getter
@Setter
public class Datapoint {

    public int time;
    public final int price;
    public final Type type;
    public final boolean isLow; // true if buy/low point, false if sell/high point

    // IQR values for prediction points
    public final Integer iqrLower;
    public final Integer iqrUpper;

    // volume
    public long lowVolume;
    public long highVolume;

    // tx
    public long qty;

    public Datapoint(int time, int price, boolean isLow, Type type) {
        this.time = time;
        this.price = price;
        this.isLow = isLow;
        this.type = type;
        this.iqrLower = null;
        this.iqrUpper = null;
    }

    public Datapoint(int time, int price, int iqrLower, int iqrUpper, boolean isLow) {
        this.time = time;
        this.price = price;
        this.isLow = isLow;
        this.type = Type.PREDICTION;
        this.iqrLower = iqrLower;
        this.iqrUpper = iqrUpper;
    }

    public static Datapoint newVolumeDatapoint(int time, long lowVolume, long highVolume) {
        Datapoint dp = new Datapoint(time, 0,false, Type.VOLUME_1H);
        dp.lowVolume = lowVolume;
        dp.highVolume = highVolume;
        return dp;
    }

    public Point getHoverPosition(Rectangle pa, Bounds bounds) {
        int x = bounds.toX(pa,time);
        int y = bounds.toY(pa, price);
        if (type == Type.FIVE_MIN_AVERAGE) {
            x += bounds.toW(pa,Constants.FIVE_MIN_SECONDS / 2);
        } else if (type == Type.HOUR_AVERAGE) {
            x += bounds.toW(pa,Constants.HOUR_SECONDS / 2);
        }
        return new Point(x, y);
    }

    public static Datapoint newBuyTx(int time, int price, long qty) {
        Datapoint dp = new Datapoint(time, price,true, Type.FLIP_TRANSACTION);
        dp.qty = qty;
        return dp;
    }

    public static Datapoint newSellTx(int time, int price, long qty) {
        Datapoint dp = new Datapoint(time, price,false, Type.FLIP_TRANSACTION);
        dp.qty = qty;
        return dp;
    }


    public enum Type {
        INSTA_SELL_BUY,
        FIVE_MIN_AVERAGE,
        HOUR_AVERAGE,
        PREDICTION,
        VOLUME_1H,
        FLIP_TRANSACTION
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

import java.awt.*;
import java.time.Instant;

@AllArgsConstructor
public class Bounds {
    public int xMin;
    public int xMax;
    public long yMin;
    public long yMax;
    public long y2Min;
    public long y2Max;

    public Bounds() {
        xMax = (int) Instant.now().getEpochSecond();
        xMin = xMax - 24*60*60*4;
        yMax = Integer.MAX_VALUE;
        yMin = 0;
    }

    public long y2Delta() {
        return y2Max - y2Min;
    }

    public long yDelta() {
        return yMax - yMin;
    }

    public int xDelta() {
        return xMax - xMin;
    }

    public int xMid() {
        return xMin + (xMax - xMin)/2;
    }

    public Bounds copy() {
        return new Bounds(xMin, xMax, yMin, yMax, y2Min, y2Max);
    }

    public Point toPoint(Rectangle pa, int xValue, long yValue) {
        return new Point(toX(pa, xValue), toY(pa, yValue));
    }

    public int toX(Rectangle pa, long xValue) {
        if (xDelta() == 0) return pa.width / 2 + pa.x;
        return pa.x + (int) (((xValue - xMin) * pa.width) / xDelta());
    }

    public int toY(Rectangle pa, long yValue) {
        if (yDelta() == 0) return pa.height / 2 + pa.y;
        return (pa.y + pa.height) - (int)((yValue - yMin) * pa.height / yDelta());
    }

    public int toW(Rectangle pa, long xDelta) {
        return (int) (xDelta * pa.width / xDelta());
    }

    public int toY2(Rectangle pa, long yValue) {
        if (y2Delta() == 0) return pa.height / 2 + pa.y;
        return (pa.y + pa.height) - (int)((yValue - y2Min) * pa.height / y2Delta());
    }
}

package com.flippingcopilot.ui.graph.model;

import java.text.SimpleDateFormat;

public class Constants {
    public static final int DAY_SECONDS = 86400;
    public static final int FIVE_MIN_SECONDS = 60*5;
    public static final int TEN_MIN_SECONDS = 60*10;
    public static final int THIRTY_MIN_SECONDS = 60*30;
    public static final int HOUR_SECONDS = 60*60;
    public static final SimpleDateFormat SECOND_DATE_FORMAT = new SimpleDateFormat("d MMM HH:mm:ss");
    public static final SimpleDateFormat MINUTE_DATE_FORMAT = new SimpleDateFormat("d MMM HH:mm");
    public static final SimpleDateFormat MINUTE_TIME_FORMAT = new SimpleDateFormat("HH:mm");
}

package com.flippingcopilot.ui.graph.model;

import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import java.nio.ByteBuffer;
import java.util.Random;

public class Data {

    @Getter
    public String loadingErrorMessage;

    @Getter
    public boolean fromWaitSuggestion;

    // 6 months 1h data
    @SerializedName("low_1h_times")
    public int[] low1hTimes;

    @SerializedName("low_1h_prices")
    public int[] low1hPrices;

    @SerializedName("high_1h_times")
    public int[] high1hTimes;

    @SerializedName("high_1h_prices")
    public int[] high1hPrices;

    // 1 month 5m data
    @SerializedName("low_5m_times")
    public int[] low5mTimes;

    @SerializedName("low_5m_prices")
    public int[] low5mPrices;

    @SerializedName("high_5m_times")
    public int[] high5mTimes;

    @SerializedName("high_5m_prices")
    public int[] high5mPrices;

    // several days latest data
    @SerializedName("low_latest_times")
    public int[] lowLatestTimes;

    @SerializedName("low_latest_prices")
    public int[] lowLatestPrices;

    @SerializedName("high_latest_times")
    public int[] highLatestTimes;

    @SerializedName("high_latest_prices")
    public int[] highLatestPrices;

    @SerializedName("prediction_times")
    public int[] predictionTimes;

    @SerializedName("prediction_low_means")
    public int[] predictionLowMeans;

    @SerializedName("prediction_low_iqr_upper")
    public int[] predictionLowIQRUpper;

    @SerializedName("prediction_low_iqr_lower")
    public int[] predictionLowIQRLower;

    @SerializedName("prediction_high_means")
    public int[] predictionHighMeans;

    @SerializedName("prediction_high_iqr_upper")
    public int[] predictionHighIQRUpper;

    @SerializedName("prediction_high_iqr_lower")
    public int[] predictionHighIQRLower;

    // the volumes are for UTC hour bins and the current time is assumed to be (predictionTimes[0] - 60) epoch seconds
    public int[] volume1hLows;
    public int[] volume1hHighs;
    public int[] volume1hTimes;

    public int[] volume5mLows;
    public int[] volume5mHighs;
    public int[] volume5mTimes;
    
    // stats
    @SerializedName("item_id")
    public int itemId;

    @SerializedName("name")
    public String name;

    @SerializedName("daily_volume")
    public double dailyVolume;

    @SerializedName("sell_price")
    public long sellPrice;
    @SerializedName("buy_price")
    public long buyPrice;


    public static Data fromMsgPack(ByteBuffer b) {
        Data d = new Data();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }
        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "l1ht":
                    d.low1hTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l1hp":
                    d.low1hPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h1ht":
                    d.high1hTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h1hp":
                    d.high1hPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l5mt":
                    d.low5mTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l5mp":
                    d.low5mPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h5mt":
                    d.high5mTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h5mp":
                    d.high5mPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "llt":
                    d.lowLatestTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "llp":
                    d.lowLatestPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "hlt":
                    d.highLatestTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "hlp":
                    d.highLatestPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "pt":
                    d.predictionTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "plm":
                    d.predictionLowMeans = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "pliu":
                    d.predictionLowIQRUpper = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "plil":
                    d.predictionLowIQRLower = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phm":
                    d.predictionHighMeans = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phiu":
                    d.predictionHighIQRUpper = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phil":
                    d.predictionHighIQRLower = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "id":
                    d.itemId =  (int) (long)MsgPackUtil.decodePrimitive(b);
                    break;
                case "n":
                    d.name = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "dv":
                    d.dailyVolume = (double) MsgPackUtil.decodePrimitive(b);
                    break;
                case "sp":
                    d.sellPrice = (long) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "bp":
                    d.buyPrice = (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "v1ht":
                    d.volume1hTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "v1hl":
                    d.volume1hLows = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "v1hh":
                    d.volume1hHighs = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "v5mt":
                    d.volume5mTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "v5ml":
                    d.volume5mLows = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "v5mh":
                    d.volume5mHighs = MsgPackUtil.decodeInt32Array(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }
        return d;
    }
    
    public void clearPredictionData() {
        predictionHighIQRLower = null;
        predictionHighIQRUpper = null;
        predictionHighMeans = null;
        predictionLowIQRLower = null;
        predictionLowIQRUpper = null;
        predictionLowMeans = null;
        predictionTimes = null;
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class YAxis {
    public long[] tickValues;
    public long[] gridOnlyValues;
}

package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class TimeAxis {
    public int[] dateOnlyTickTimes;
    public int[] timeOnlyTickTimes;
    public int[] gridOnlyTickTimes;
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.Bounds;
import com.flippingcopilot.ui.graph.model.Config;
import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.Datapoint;
import lombok.Getter;

import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Locale;

@Getter
public class DatapointTooltip {

    private int padding;

    public DatapointTooltip() {
        this.padding = 8; // Padding inside tooltip
    }

    public void draw(Graphics2D g2, Config config, Rectangle pa, Bounds paBounds, Datapoint point) {
        // Prepare tooltip text
        NumberFormat format = new DecimalFormat("#,###", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
        String priceStr = format.format(point.getPrice());

        final String typeText;
        final String timeText;
        switch (point.type) {
            case INSTA_SELL_BUY:
                typeText = point.isLow() ? "low (insta-sell)" : "high (insta-buy)";
                timeText = Constants.SECOND_DATE_FORMAT.format(new Date(point.getTime() * 1000L));
                break;
            case FIVE_MIN_AVERAGE:
                typeText = point.isLow() ? "low 5m average" : "high 5min average";
                timeText = Constants.MINUTE_DATE_FORMAT.format(new Date(point.getTime() * 1000L)) + " - " + Constants.MINUTE_DATE_FORMAT.format(new Date((point.getTime()+ Constants.FIVE_MIN_SECONDS) * 1000L));
                break;
            case HOUR_AVERAGE:
                typeText = point.isLow() ? "low 1h average" : "high 1h average";
                timeText = Constants.MINUTE_DATE_FORMAT.format(new Date(point.getTime() * 1000L)) + " - " + Constants.MINUTE_DATE_FORMAT.format(new Date((point.getTime()+ Constants.HOUR_SECONDS) * 1000L));
                break;
            case PREDICTION:
                typeText = point.isLow() ? "low prediction" : "high prediction";
                timeText = Constants.SECOND_DATE_FORMAT.format(new Date(point.getTime() * 1000L));
                break;
            case FLIP_TRANSACTION:
                String volumeStr = format.format(Math.abs(point.qty));
                typeText = point.isLow() ? "Buy " + volumeStr : "Sell "+ volumeStr;
                timeText = Constants.SECOND_DATE_FORMAT.format(new Date(point.getTime() * 1000L));
                break;
            default:
                throw new IllegalArgumentException("invalid point type: "+ point.type);
        }

        // Calculate tooltip dimensions
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        FontMetrics fm = g2.getFontMetrics();
        int typeTextWidth = fm.stringWidth(typeText);
        int timeTextWidth = fm.stringWidth(timeText);
        int priceStrWidth = fm.stringWidth(priceStr);
        int textWidth = Math.max(Math.max(typeTextWidth, timeTextWidth), priceStrWidth);
        int textHeight = fm.getHeight() * 3; // Three lines of text

        int tooltipWidth = textWidth + padding * 2;
        int tooltipHeight = textHeight + padding * 2;

        Point hoverPosition = point.getHoverPosition(pa, paBounds);

        // Position tooltip near point but ensure it stays within panel bounds
        int tooltipX = hoverPosition.x + 15;
        int tooltipY = hoverPosition.y - tooltipHeight - 5;

        // Adjust if tooltip would go off screen
        if (tooltipX + tooltipWidth > pa.width) {
            tooltipX = hoverPosition.x - tooltipWidth - 5;
        }
        if (tooltipY < 0) {
            tooltipY = hoverPosition.y + 15;
        }

        // Draw tooltip background
        g2.setColor(Config.TOOLTIP_BACKGROUND);
        g2.fillRoundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8, 8);

        // Draw tooltip border
        g2.setColor(Config.TOOLTIP_BORDER);
        g2.drawRoundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8, 8);

        // Draw tooltip text - first line (type text)
        g2.setColor(config.textColor);
        int yPos = tooltipY + padding + fm.getAscent();
        g2.drawString(typeText, tooltipX + padding, yPos);

        // Draw tooltip text - second line (time)
        yPos += fm.getHeight();
        g2.drawString(timeText, tooltipX + padding, yPos);

        // Draw tooltip text - third line (price)
        yPos += fm.getHeight();
        g2.drawString(priceStr, tooltipX + padding, yPos);

        // Highlight the hovered point
        if (point.type != Datapoint.Type.FLIP_TRANSACTION) {
            if (point.isLow()) {
                g2.setColor(config.lowColor);
            } else {
                g2.setColor(config.highColor);
            }

            // Draw larger point to highlight hover
            int highlightSize = 8;
            g2.fillOval(hoverPosition.x - highlightSize / 2,
                    hoverPosition.y - highlightSize / 2,
                    highlightSize, highlightSize);

            g2.setColor(Color.WHITE);
            g2.drawOval(hoverPosition.x - highlightSize / 2 - 1,
                    hoverPosition.y - highlightSize / 2 - 1,
                    highlightSize + 2, highlightSize + 2);
        }
    }

    public void drawVolume(Graphics2D g2d, Config config, Rectangle pa, Bounds bounds, Datapoint point) {
        NumberFormat format = new DecimalFormat("#,###", DecimalFormatSymbols.getInstance(Locale.ENGLISH));

        String headerLine = "1h volume";
        String timeLine = Constants.MINUTE_DATE_FORMAT.format(new Date(point.getTime() * 1000L)) + " - " + Constants.MINUTE_TIME_FORMAT.format(new Date((point.getTime()+ Constants.HOUR_SECONDS) * 1000L));
        String lowLine = "low (insta-sell): "+format.format(point.getLowVolume());
        String highLine = "high (insta-buy): "+format.format(point.getHighVolume());


        List<String> lines = Arrays.asList(headerLine, timeLine, lowLine, highLine);

        g2d.setFont(g2d.getFont().deriveFont(Config.FONT_SIZE));
        FontMetrics fm = g2d.getFontMetrics();
        int textWidth = lines.stream().mapToInt(fm::stringWidth).max().orElse(0);
        int textHeight = fm.getHeight() * 4;

        int y = bounds.toY2(pa, point.lowVolume + point.highVolume) - textHeight - 8 - 2*padding;
        
        int x = bounds.toX(pa, point.time + Constants.HOUR_SECONDS / 2) - textWidth / 2;
        
        if (x < pa.x) {
            x = pa.x + 2;
        } else if ( x + textWidth > pa.x + pa.width) {
            x -= (x + textWidth - pa.x - pa.width) -2;
        }

        g2d.setColor(Config.TOOLTIP_BACKGROUND);
        g2d.fillRoundRect(x, y, textWidth + 2*padding, textHeight + 2* padding, 8, 8);

        g2d.setColor(Config.TOOLTIP_BORDER);
        g2d.drawRoundRect(x, y, textWidth + 2*padding, textHeight + 2*padding, 8, 8);


        int yPos = y + fm.getHeight()+padding /2;
        g2d.setColor(config.textColor);
        for(String line : lines) {
            g2d.drawString(line, x + padding, yPos);
            yPos += fm.getHeight();
        }
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.FlipV2;
import net.runelite.client.ui.ColorScheme;

import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;

import static com.flippingcopilot.util.DateUtil.formatEpoch;

public class FlipPanel extends JPanel {

    public FlipPanel(FlipV2 flip, FlippingCopilotConfig config) {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel itemQuantity = new JLabel(String.format("%d x ", flip.getClosedQuantity()));
        itemQuantity.setForeground(Color.WHITE);

        JLabel itemNameLabel = new JLabel(UIUtilities.truncateString(flip.getCachedItemName(), 19));

        // Create a sub-panel for the left side
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        leftPanel.add(itemQuantity);
        leftPanel.add(itemNameLabel);

        JLabel profitLabel = new JLabel(UIUtilities.formatProfitWithoutGp(flip.getProfit()));
        profitLabel.setForeground(UIUtilities.getProfitColor(flip.getProfit(), config));

        // Add the sub-panel to the LINE_START position
        add(leftPanel, BorderLayout.LINE_START);
        add(profitLabel, BorderLayout.LINE_END);
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));

        String closeLabel = flip.getClosedQuantity() == flip.getOpenedQuantity() ? "Close time" : "Partial close time";

        String tooltipText = String.format("Opened time: %s\nAvg buy price: %s\n%s: %s\nAvg sell price: %s\nTax paid: %s\nProfit: %s",
                formatEpoch(flip.getOpenedTime()),
                UIUtilities.formatProfit(flip.getAvgBuyPrice()),
                closeLabel,
                formatEpoch(flip.getClosedTime()),
                UIUtilities.formatProfit(flip.getAvgSellPrice()),
                UIUtilities.formatProfit(flip.getTaxPaid()),
                UIUtilities.formatProfit(flip.getProfit()));
        setToolTipText(tooltipText);
    }
}
package com.flippingcopilot.ui;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class BlacklistIcons {

    public static ImageIcon createTickIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();

        g2d.setColor(new Color(40, 167, 69));
        g2d.setStroke(new BasicStroke(2));
        g2d.drawLine(3, 8, 7, 12);
        g2d.drawLine(7, 12, 13, 4);
        g2d.dispose();

        return new ImageIcon(image);
    }

    public static ImageIcon createXIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();

        g2d.setColor(new Color(220, 53, 69));
        g2d.setStroke(new BasicStroke(2));
        g2d.drawLine(4, 4, 12, 12);
        g2d.drawLine(4, 12, 12, 4);
        g2d.dispose();

        return new ImageIcon(image);
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.CopilotLoginController;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;


@Singleton
public class LoginPanel extends JPanel {
    private final static int PAGE_WIDTH = 225;

    private final CopilotLoginController copilotLoginController;

    private final JPanel loginContainer;
    private final JButton loginButton;
    private final JTextField emailTextField;
    private final JTextField passwordTextField;
    private final JLabel errorMessageLabel;

    public final Spinner spinner = new Spinner();

    @Inject
    public LoginPanel(CopilotLoginController copilotLoginController) {
        this.copilotLoginController = copilotLoginController;
        this.setLayout(new BorderLayout());
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.setSize(PAGE_WIDTH, 250);

        loginContainer = new JPanel();
        loginContainer.setLayout(new BoxLayout(loginContainer, BoxLayout.PAGE_AXIS));

        JPanel logoContainer = this.buildLogo();
        loginContainer.add(logoContainer, BorderLayout.CENTER);

        JPanel spinnerContainer = this.buildSpinner();
        loginContainer.add(spinnerContainer, BorderLayout.CENTER);

        JPanel errorContainer = this.buildErrorMessageLabel();
        errorMessageLabel = ((JLabel) errorContainer.getComponent(0));
        loginContainer.add(errorContainer, BorderLayout.CENTER);

        emailTextField = new JTextField();
        emailTextField.setSize(PAGE_WIDTH, 40);
        loginContainer.add(this.buildEmailInput(emailTextField), BorderLayout.CENTER);

        passwordTextField = new JPasswordField();
        passwordTextField.setSize(PAGE_WIDTH, 40);
        loginContainer.add(this.buildPasswordInput(passwordTextField), BorderLayout.CENTER);

        JPanel loginButtonContainer = this.buildLoginButton();
        loginButton = ((JButton) loginButtonContainer.getComponent(0));
        loginContainer.add(loginButtonContainer, BorderLayout.CENTER);

        JPanel createAccountLink = this.buildCreateAccountLink();
        loginContainer.add(createAccountLink, BorderLayout.CENTER);

        this.add(loginContainer, BorderLayout.NORTH);
    }

    public JPanel buildLogo() {
        JPanel container = new JPanel();
        ImageIcon icon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/logo.png"));
        Image resizedLogo = icon.getImage().getScaledInstance(50, 45, Image.SCALE_SMOOTH);
        JLabel logoLabel = new JLabel(new ImageIcon(resizedLogo));
        logoLabel.setSize(50, 45);
        container.add(logoLabel, BorderLayout.CENTER);
        container.setBorder(new EmptyBorder(10, 0, 10, 0));
        return container;
    }

    public JPanel buildSpinner() {
        JPanel container = new JPanel();
        container.add(spinner, BorderLayout.CENTER);
        return container;
    }

    public void startLoading() {
        spinner.show();
        loginButton.setEnabled(false);
        errorMessageLabel.setText("");
        errorMessageLabel.setVisible(false);
    }

    public void endLoading() {
        spinner.hide();
        loginButton.setEnabled(true);
    }

    public JPanel buildErrorMessageLabel() {
        JPanel container = new JPanel();
        JLabel errorLabel = new JLabel();
        errorLabel.setForeground(Color.RED);
        errorLabel.setHorizontalAlignment(SwingConstants.LEFT);
        errorLabel.setSize(PAGE_WIDTH, 40);
        errorLabel.setVisible(false);
        container.add(errorLabel);
        return container;
    }

    public JPanel buildEmailInput(JTextField textField) {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        JLabel emailLabel = new JLabel("Email address");
        container.add(emailLabel, BorderLayout.WEST);
        container.add(textField);
        return container;
    }

    public JPanel buildPasswordInput(JTextField textField) {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        JLabel passwordLabel = new JLabel("Password");
        container.add(passwordLabel);
        container.add(textField);
        return container;
    }

    public JPanel buildCreateAccountLink() {
        JPanel container = new JPanel();
        JLabel createAccountLabel = new JLabel("Don't have an account? Sign up.");
        createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        createAccountLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                LinkBrowser.browse("https://flippingcopilot.com/signup");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.BRAND_ORANGE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            }
        });
        container.add(createAccountLabel);
        return container;
    }

    public JPanel buildLoginButton() {
        JPanel container = new JPanel();
        JButton button = new JButton("Login");
        button.addActionListener((ActionEvent a) -> {
            copilotLoginController.onLoginPressed(emailTextField.getText(), passwordTextField.getText());
        });
        container.add(button);
        return container;
    }

    public void showLoginErrorMessage(String message) {
        errorMessageLabel.setText("<html><p>" + message + "</p></html>");
        errorMessageLabel.setVisible(true);
    }

    public void refresh() {

    }
}
package com.flippingcopilot.manager;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.ui.graph.model.Config;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.file.Files;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PriceGraphConfigManager {

    public static final String JSON_FILE = "price_graph_config.json";

    private final File file = new File(Persistance.COPILOT_DIR, JSON_FILE);

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    private Config cachedConfig;

    public synchronized Config getConfig() {
        if(cachedConfig != null) {
            return cachedConfig;
        }
        cachedConfig = load();
        return cachedConfig;
    }

    public synchronized void setConfig(Config config) {
        if (config == null) {
            return;
        }
        cachedConfig = config;
        saveAsync();
    }

    public void saveAsync() {
        executorService.submit(() -> {
            synchronized (file) {
                Config config = getConfig();
                try {
                    String json = gson.toJson(config);
                    Files.write(file.toPath(), json.getBytes());
                } catch (IOException e) {
                    log.warn("error saving graph config {}", e.getMessage(), e);
                }
            }
        });
    }

    public Config load() {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, Config.class);
        } catch (FileNotFoundException ignored) {
            return new Config();
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading saved graph config json file {}", file, e);
            return new Config();
        }
    }
}

package com.flippingcopilot.manager;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.model.LoginResponse;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CopilotLoginManager {

    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";

    private final File file = new File(Persistance.COPILOT_DIR, LOGIN_RESPONSE_JSON_FILE);

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    private LoginResponse cachedLoginResponse;
    private final ConcurrentMap<String,Integer> displayNameToAccountId = new ConcurrentHashMap<>();
    private final ConcurrentMap<Integer, String> accountIdToDisplayName = new ConcurrentHashMap<>();

    public synchronized void removeAccount(Integer accountId) {
        String displayName = accountIdToDisplayName.get(accountId);
        accountIdToDisplayName.remove(accountId);
        if(displayName != null){
            displayNameToAccountId.remove(displayName);
        }
    }
    public void addAccountIfMissing(Integer accountId, String displayName, int copilotUserId) {
        if(!accountIdToDisplayName.containsKey(accountId) && getCopilotUserId() == copilotUserId) {
            synchronized (this) {
                displayNameToAccountId.put(displayName, accountId);
                accountIdToDisplayName.put(accountId, displayName);
            }
        }
    }

    public synchronized Map<String, Integer> displayNameToAccountIdMap() {
        return new HashMap<>(displayNameToAccountId);
    }

    public synchronized Map<Integer, String> accountIDToDisplayNameMap() {
        return new HashMap<>(accountIdToDisplayName);
    }

    public synchronized Set<Integer> accountIds() {
        return new HashSet<>(accountIdToDisplayName.keySet());
    }

    public synchronized Integer getAccountId(String displayName) {
        if(displayName == null) {
            return null;
        }
        return displayNameToAccountId.getOrDefault(displayName, -1);
    }

    public synchronized String getDisplayName(Integer accountId) {
        if(accountId == null){
            return null;
        }
        return accountIdToDisplayName.getOrDefault(accountId, "Unknown");
    }

    public synchronized void setLoginResponse(LoginResponse loginResponse) {
        if (loginResponse == null) {
            return;
        }
        cachedLoginResponse = loginResponse;
        saveLoginResponseAsync();
    }

    public synchronized boolean isLoggedIn() {
        LoginResponse loginResponse = getLoginResponse();
        return loginResponse != null && !Strings.isNullOrEmpty(loginResponse.jwt);
    }

    public synchronized void reset() {
        cachedLoginResponse = null;
        displayNameToAccountId.clear();
        accountIdToDisplayName.clear();
        if (file.exists()) {
            if(!file.delete()) {
                log.warn("failed to delete login response file {}", file);
            }
        }
    }

    public synchronized int getCopilotUserId() {
        LoginResponse loginResponse = getLoginResponse();
        if (loginResponse != null) {
            return loginResponse.userId;
        }
        return -1;
    }

    public synchronized String getJwtToken() {
        if(!isLoggedIn()) {
            return null;
        }
        return getLoginResponse().getJwt();
    }

    private LoginResponse getLoginResponse() {
        if(cachedLoginResponse != null) {
            return cachedLoginResponse;
        }
        cachedLoginResponse = loadLoginResponse();
        return cachedLoginResponse;
    }

    private void saveLoginResponseAsync() {
        executorService.submit(() -> {
            synchronized (file) {
                LoginResponse loginResponse = getLoginResponse();
                if (loginResponse != null) {
                    try {
                        String json = gson.toJson(loginResponse);
                        Files.write(file.toPath(), json.getBytes());
                    } catch (IOException e) {
                        log.warn("error saving login response {}", e.getMessage(), e);
                    }
                }
            }
        });
    }

    private LoginResponse loadLoginResponse() {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, LoginResponse.class);
        } catch (FileNotFoundException ignored) {
            return null;
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading saved login json file {}", file, e);
            return null;
        }
    }
}

package com.flippingcopilot.manager;

import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;

@AllArgsConstructor
public class ReactiveStateImpl<T> implements ReactiveState<T> {

    private final List<Consumer<T>> listeners =  new ArrayList<>();
    private T state;

    @Override
    public Runnable registerListener(Consumer<T> onUpdate) {
        listeners.add(onUpdate);
        return () -> listeners.removeIf(i -> i.equals(onUpdate));
    }

    @Override
    public void applyUpdate(Function<T, Boolean> update) {
        if(update.apply(state)) {
            listeners.forEach(i -> i.accept(state));
        }
    }

    @Override
    public void set(T newState) {
        state = newState;
        listeners.forEach(i -> i.accept(state));
    }

    @Override
    public T get() {
        return state;
    }
}

package com.flippingcopilot.manager;

import java.util.function.Consumer;
import java.util.function.Function;

public interface ReactiveState<T> {
    Runnable registerListener(Consumer<T> onUpdate);
    void applyUpdate(Function<T, Boolean> update);
    T get();
    void set(T newValue);
}

package com.flippingcopilot.util;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class GeTaxTest {

    @Test
    public void postTaxPriceForExemptItemReturnsOriginalPrice() {
        int itemId = 13190;
        int price = 1000;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceNormalItem() {
        int itemId = 9999;
        int price = 1000;
        assertEquals(990, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceAboveCap() {
        int itemId = 9999;
        int price = 600000000;
        assertEquals(595000000, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceCheapItem() {
        int itemId = 13190;
        int price = 67;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }
}
//package com.flippingcopilot.controller;
//
//import net.runelite.api.GrandExchangeOffer;
//import net.runelite.api.GrandExchangeOfferState;
//import net.runelite.api.events.GrandExchangeOfferChanged;
//import org.junit.Test;
//
//import java.util.ArrayList;
//
//public class OfferEventFilterTest {
//
//    @Test
//    public void testShouldProcessOnLogin() {
//        OfferEventFilter filter = new OfferEventFilter();
//
//        ArrayList<GrandExchangeOfferChanged> events = new ArrayList<>();
//        ArrayList<Boolean> expectedReturnValues = new ArrayList<>();
//
//        events.add(mockOfferEvent(0, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(1, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(3, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(4, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(6, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//
//        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//
//        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//
//        for (int i = 0; i < events.size(); i++) {
//            assert filter.shouldProcess(events.get(i)) == expectedReturnValues.get(i);
//        }
//    }
//
//    @Test
//    public void testShouldProcessNewBuyOffer() {
//        OfferEventFilter filter = new OfferEventFilter();
//        GrandExchangeOfferChanged event1 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert filter.shouldProcess(event1);
//        GrandExchangeOfferChanged event2 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert !filter.shouldProcess(event2);
//    }
//
//    @Test
//    public void testLogoutLogin() {
//        OfferEventFilter filter = new OfferEventFilter();
//        GrandExchangeOfferChanged event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert filter.shouldProcess(event);
//
//
//        for (int i = 0; i < 8; i++) {
//            event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
//            assert !filter.shouldProcess(event);
//        }
//
//        for (int i = 0; i < 8; i++) {
//            if (i == 2) {
//                event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//                assert !filter.shouldProcess(event);
//            } else {
//                event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
//                assert filter.shouldProcess(event);
//            }
//        }
//
//        event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert !filter.shouldProcess(event);
//    }
//
//    static GrandExchangeOfferChanged mockOfferEvent(int slot, int itemId, int quantitySold, int totalQuantity,
//                                                    int price, int spent, GrandExchangeOfferState state) {
//        GrandExchangeOfferChanged event = new GrandExchangeOfferChanged();
//        event.setSlot(slot);
//        event.setOffer(new GrandExchangeOffer() {
//            @Override
//            public int getQuantitySold() {
//                return quantitySold;
//            }
//
//            @Override
//            public int getItemId() {
//                return itemId;
//            }
//
//            @Override
//            public int getTotalQuantity() {
//                return totalQuantity;
//            }
//
//            @Override
//            public int getPrice() {
//                return price;
//            }
//
//            @Override
//            public int getSpent() {
//                return spent;
//            }
//
//            @Override
//            public GrandExchangeOfferState getState() {
//                return state;
//            }
//        });
//        return event;
//    }
//
//
//}

package com.flippingcopilot.controller;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;


public class DoesNothingExecutorService implements ScheduledExecutorService {
    @Override
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public void shutdown() {

    }

    @Override
    public List<Runnable> shutdownNow() {
        return List.of();
    }

    @Override
    public boolean isShutdown() {
        return false;
    }

    @Override
    public boolean isTerminated() {
        return false;
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return false;
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return null;
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return null;
    }

    @Override
    public Future<?> submit(Runnable task) {
        return null;
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return null;
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return null;
    }

    @Override
    public void execute(Runnable command) {

    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import org.junit.Test;

public class TestSuggestionController {

    @Test
    public void testShouldNotifyOnWait() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null, null, null);
        Suggestion newSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 1, "", null, null, null);
        assert !SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnNewBuy() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null, null, null);
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "", null, null, null);
        assert SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnRepeatedBuy() {
        Suggestion oldSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 0, "", null, null, null);;
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "", null, null, null);
        assert !SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnAbort() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null, null, null);
        Suggestion newSuggestion = new Suggestion("abort", 0, 560, 200, 25000, "Death rune", 1, "", null, null, null);
        assert SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }
}

package com.flippingcopilot.model;

import org.junit.Test;


public class OfferListTest {
    @Test
    public void testIsEmptySlotNeededWithExistingOfferInSlot() {
        StatusOfferList offerList = new StatusOfferList();
        offerList.set(0, new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "", null, null, null);
        assert !offerList.isEmptySlotNeeded(suggestion, true);
    }

    @Test
    public void testIsEmptySlotNeededWithNoEmptySlots() {
        StatusOfferList offerList = new StatusOfferList();
        offerList.replaceAll(ignored -> new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "", null, null, null);
        assert offerList.isEmptySlotNeeded(suggestion, true);
    }

}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.DoesNothingExecutorService;
import okhttp3.OkHttpClient;
import org.junit.Assert;
import org.junit.Test;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlipPriceGraphControllerTest {

    private static final Integer ACCOUNT_ID_1 = 1;
    private static final Integer ACCOUNT_ID_2 = 2;
    private static final Integer ACCOUNT_ID_3 = 3;

    @Test
    public void testOneAccount() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 10_000, List.of(ACCOUNT_ID_1));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null);
        flipManager.setFlipsChangedCallback(() -> {});
        flipManager.mergeFlips(flips, 0);
        flipManager.setIntervalAccount(ACCOUNT_ID_1);


        verifyflipManagerStoredOrder(flipManager);

        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(FlipV2::getId));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        for (int time : testTimes) {
            flipManager.setIntervalStartTime(time);

            // check stats equal
            Stats stats1 = flipManager.getIntervalStats();
            Stats stats2 = expectedStats(flips, time, ACCOUNT_ID_1);
            Assert.assertEquals(stats1, stats2);

            // check all flips equal
            List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
            List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), ACCOUNT_ID_1);
            assertFlipListsEqual(allFlips1, allFlips2);

            // check paginated flips equal
            for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                int numPages = stats1.flipsMade / pageSize + 1;
                for(int page=1; page <= numPages; page++) {
                    List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, ACCOUNT_ID_1);
                    List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                    assertFlipListsEqual(pageFlips1, pageFlips2);
                }
            }
        }
    }

    @Test
    public void testMultipleAccounts() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 5_000, List.of(ACCOUNT_ID_1, ACCOUNT_ID_2, ACCOUNT_ID_3));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null);
        flipManager.setFlipsChangedCallback(() -> {});
        flipManager.mergeFlips(flips, 0);
        verifyflipManagerStoredOrder(flipManager);


        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(Comparator.comparing(FlipV2::getId).reversed()));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        flipManager.setIntervalAccount(null);
        List<FlipV2> flips1 = flipManager.getPageFlips(1, flips.size());
        assertFlipListsEqual(flips1, flips);

        for (Integer accountId : Arrays.asList(ACCOUNT_ID_1, ACCOUNT_ID_2, ACCOUNT_ID_3, null)) {
            flipManager.setIntervalAccount(accountId);
            for (int time : testTimes) {
                flipManager.setIntervalStartTime(time);

                // check stats equal
                Stats stats1 = flipManager.getIntervalStats();
                Stats stats2 = expectedStats(flips, time, accountId);
                Assert.assertEquals(stats1, stats2);

                // check all flips equal
                List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
                List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), accountId);
                assertFlipListsEqual(allFlips1, allFlips2);

                // check paginated flips equal
                for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                    int numPages = stats1.flipsMade / pageSize + 1;
                    for (int page = 1; page <= numPages; page++) {
                        List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                        List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, accountId);
                        assertFlipListsEqual(pageFlips1, pageFlips2);
                    }
                }
            }
        }
    }

    public void verifyflipManagerStoredOrder(FlipManager flipManager) {
        for (int i =0; i < flipManager.weeks.size(); i++) {
            Assert.assertTrue(flipManager.weeks.get(Math.max(i-1,0)).weekStart <= flipManager.weeks.get(i).weekStart);
            FlipManager.WeekAggregate w = flipManager.weeks.get(i);
            for (List<FlipV2> flips : w.accountIdToFlips.values()) {
                for (int ii =1; ii < flips.size(); ii++) {
                    Assert.assertTrue(flips.get(ii-1).getClosedTime() <= flips.get(ii).getClosedTime());
                }
            }
        }
    }

    private List<FlipV2> expectedPage(List<FlipV2> flips, int time, int pageNumber, int pageSize, Integer accountId) {
        int toSkip = (pageNumber - 1) * pageSize;
        List<FlipV2> page = new ArrayList<>();
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                if(toSkip > 0) {
                    toSkip -= 1;
                } else {
                    page.add(f);
                    if(page.size() == pageSize) {
                        break;
                    }
                }
            }
        }
        return page;
    }

    private void assertFlipListsEqual(List<FlipV2> f1, List<FlipV2> f2) {
        if(f1.size() != f2.size()) {
            Assert.fail("flips lists not equal length");
        }
        for (int i=0; i < f1.size(); i++) {
            FlipV2 flip1 = f1.get(i);
            FlipV2 flip2 = f2.get(i);
            if (!flip1.equals(flip2)) {
                Assert.fail("flips don't match at index " + i);
            }
        }
    }

    private Stats expectedStats(List<FlipV2> flips, int time, Integer accountId) {
        Stats stats = new Stats(0,0,0,0);
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                stats.flipsMade += 1;
                stats.gross += f.getSpent();
                stats.profit += f.getProfit();
            }
        }
        return stats;
    }

    private List<FlipV2> generateFlipsBetween(int start, int end, int number, List<Integer> accountIds) {
        List<FlipV2> flips = new ArrayList<>();
        for (int i =0; i< number; i++) {
            FlipV2 f = new FlipV2();
            f.setId(UUID.randomUUID());
            f.setAccountId(accountIds.get(new Random().nextInt(accountIds.size())));
            f.setStatus(FlipStatus.FINISHED);
            // leave a small percentage as open flips
            if(randomIntBetween(0, 1000) > 2) {
                f.setStatus(FlipStatus.SELLING);
                f.setClosedTime(randomIntBetween(start, end));
                f.setSpent(randomIntBetween(100, 1_000_000_000));
                f.setProfit(randomIntBetween(-2_000_000, 4_000_000));
                flips.add(f);
            }
        }
        return flips;
    }

    private int randomIntBetween(int min, int max) {
        return (int)(Math.random() * ((max - min) + 1)) + min;
    }
}
package com.flippingcopilot.model;

import org.junit.Test;

public class AccountStatusTest {

    @Test
    public void testMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        assert accountStatus.moreGpNeeded();
    }

    @Test
    public void testNoMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        accountStatus.getInventory().add(new RSItem(995, 2000));
        assert !accountStatus.moreGpNeeded();
    }
}

//package com.flippingcopilot.model;
//
//import org.junit.Test;
//
//import java.time.Instant;
//
//public class OfferTest {
//
//    @Test
//    public void testTransactionFromNewOffer() {
//        Offer oldOffer = Offer.getEmptyOffer(0);
//        Offer newOffer = new Offer(OfferStatus.BUY, 560, 100, 50, 1000,
//                10, 10, 0, 0, true, false);
//        Transaction expectedTransaction = new Transaction(null, OfferStatus.BUY, 560, 100, 10, 0, 1000, null,false, 0, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert expectedTransaction.equals(actualTransaction);
//    }
//
//    @Test
//    public void testTransactionFromProgressingSell() {
//        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 4000,
//                40, 0, 4000, 0, true, false);
//        Transaction expectedTransaction = new Transaction(null, OfferStatus.SELL, 560, 100, 30, 0, 3000, null,false, 0, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert expectedTransaction.equals(actualTransaction);
//    }
//
//    @Test
//    public void testNoTransaction() {
//        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert actualTransaction == null;
//    }
//}

package com.flippingcopilot.ui;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class UIUtilitiesTest {

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsGreaterThanStringLength() {
        String result = UIUtilities.truncateString("Hello", 10);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsLessThanStringLength() {
        String result = UIUtilities.truncateString("Hello, World!", 5);
        assertEquals("Hello...", result);
    }

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsEqualToStringLength() {
        String result = UIUtilities.truncateString("Hello", 5);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsEmptyString_whenInputStringIsEmpty() {
        String result = UIUtilities.truncateString("", 5);
        assertEquals("", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsZero() {
        String result = UIUtilities.truncateString("Hello, World!", 0);
        assertEquals("...", result);
    }
}
package com.flippingcopilot;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FlippingCopilotPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlippingCopilotPlugin.class);
		RuneLite.main(args);
	}
}
