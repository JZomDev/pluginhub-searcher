package com.flippingcopilot.util;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.List;

public class MsgPackUtil {

    private static final int EXT_INT32 = 41;

    public static Object decodePrimitive(ByteBuffer b) {
        int format = b.get() & 0xFF;
        int length;

        // Boolean cases
        if (format == 0xC2) {
            // false
            return false;
        } else if (format == 0xC3) {
            // true
            return true;
        }
        // Null case
        else if (format == 0xC0) {
            // nil (null)
            return null;
        }
        // String cases
        else if ((format & 0xE0) == 0xA0) {
            // fixstr: format stores length in lower 5 bits
            length = format & 0x1F;
            return getString(length, new byte[length], b);
        } else if (format == 0xD9) {
            // str 8: next byte is length
            length = b.get() & 0xFF;
            return getString(length, new byte[length], b);
        } else if (format == 0xDA) {
            // str 16: next 2 bytes are length
            length = b.getShort() & 0xFFFF;
            return getString(length, new byte[length], b);
        } else if (format == 0xDB) {
            // str 32: next 4 bytes are length
            length = b.getInt();
            return getString(length, new byte[length], b);
        }
        // Integer cases
        else if (format <= 0x7F) {
            // positive fixint
            return (long) format;
        } else if ((format & 0xE0) == 0xE0) {
            // negative fixint (0xE0-0xFF represents -32 to -1)
            return (long) (format - 256);
        } else if (format == 0xCC) {
            // uint 8
            return (long) (b.get() & 0xFF);
        } else if (format == 0xCD) {
            // uint 16
            return (long) (b.getShort() & 0xFFFF);
        } else if (format == 0xCE) {
            // uint 32
            return (long) (b.getInt() & 0xFFFFFFFFL);
        } else if (format == 0xCF) {
            // uint 64
            return b.getLong();
        } else if (format == 0xD0) {
            // int 8
            return (long) b.get();
        } else if (format == 0xD1) {
            // int 16
            return (long) b.getShort();
        } else if (format == 0xD2) {
            // int 32
            return (long) b.getInt();
        } else if (format == 0xD3) {
            // int 64
            return b.getLong();
        }
        // Double case
        else if (format == 0xCB) {
            // float 64
            return b.getDouble();
        } else {
            throw new IllegalArgumentException("Invalid primitive format: " + format);
        }
    }

    private static String getString(int length, byte[] length1, ByteBuffer b) {
        if (length == 0) {
            return "";
        }
        byte[] bytes = length1;
        b.get(bytes);
        return new String(bytes, StandardCharsets.UTF_8);
    }

    public static int[] decodeInt32Array(ByteBuffer b) {
        int format = b.get() & 0xFF;

        if (format == 0xC0) {
            // nil (null)
            return null;
        } else if (format == 0xC9) {
            // ext 32 - extension with 32-bit length
            int byteLength = b.getInt();
            int extType = b.get() & 0xFF;
            if (extType != EXT_INT32) {
                throw new IllegalArgumentException("Expected extension type " + EXT_INT32 + ", got: " + extType);
            }
            int arrayLength = byteLength / 4;
            int[] result = new int[arrayLength];
            for (int i = 0; i < arrayLength; i++) {
                result[i] = (b.get() & 0xff) | ((b.get() & 0xff) << 8) |
                        ((b.get() & 0xff) << 16) | ((b.get() & 0xff) << 24);
            }
            return result;
        } else {
            throw new IllegalArgumentException("Expected extension format 0xC9 or nil 0xC0, got: " + format);
        }
    }

    public static Integer decodeMapSize(ByteBuffer b) {
        int format = b.get() & 0xFF;
        if (format == 0xC0) {
            // nil (null) - return null Data object
            return null;
        } else if ((format & 0xF0) == 0x80) {
            // fixmap: format stores size in lower 4 bits
            return format & 0x0F;
        } else if (format == 0xDE) {
            // map 16: next 2 bytes are size
            return b.getShort() & 0xFFFF;
        } else if (format == 0xDF) {
            // map 32: next 4 bytes are size (you were missing this case!)
            return b.getInt();
        } else {
            throw new IllegalArgumentException("Invalid map format: " + format);
        }
    }
}
package com.flippingcopilot.util;

import java.util.Arrays;
import java.util.HashSet;

public class GeTax {
    private final static int MAX_PRICE_FOR_GE_TAX = 250000000;
    private final static int GE_TAX_CAP = 5000000;
    private final static double GE_TAX = 0.02;
    private final static HashSet<Integer> GE_TAX_EXEMPT_ITEMS = new HashSet<>(
            Arrays.asList(13190, 1755, 5325, 1785, 2347, 1733, 233, 5341, 8794, 5329, 5343, 1735, 952, 5331));

    public static int getPostTaxPrice(int itemId, int price) {
        if (GE_TAX_EXEMPT_ITEMS.contains(itemId)) {
            return price;
        }
        if (price >= MAX_PRICE_FOR_GE_TAX) {
            return price - GE_TAX_CAP;
        }
        int tax = (int)Math.floor(price * GE_TAX);
        return price - tax;
    }
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

public class AtomicReferenceUtils {
    public static <T> OrElse ifPresent(AtomicReference<T> ref, Consumer<? super T> action) {
        T value = ref.get();
        if (value != null) {
            action.accept(value);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    public static <T, E> OrElse ifBothPresent(AtomicReference<T> ref1, AtomicReference<E> ref2, BiConsumer<? super T,? super E> action) {
        T value1 = ref1.get();
        E value2 = ref2.get();
        if (value1 != null && value2 != null) {
            action.accept(value1, value2);
            return new OrElse(false);
        } else {
            return new OrElse(true);
        }
    }

    @AllArgsConstructor
    public static class OrElse {

        boolean shouldRun;

        public void orElse(Runnable r) {
            if(shouldRun) {
                r.run();
            }
        }
    }
}
package com.flippingcopilot.util;

public class Constants {
    public final static int MIN_GP_NEEDED_TO_FLIP = 1000;
    public final static int PLATINUM_TOKEN_VALUE = 1000;
}

package com.flippingcopilot.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class MutableReference<T> {
    private T value;
}

package com.flippingcopilot.controller;

import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class HighlightColorController {

    /*
    For the highlighted colors we oscillate the actual colors through different shades
     */

    // Color ranges for red highlight (R,G,B values)
    private static final int[] RED_START = {205, 0, 50};
    private static final int[] RED_END = {255, 50, 0};

    // Color ranges for blue highlight (R,G,B values)
    private static final int[] BLUE_START = {5, 153, 255};
    private static final int[] BLUE_END = {55, 205, 205};

    // Constants for controlling the drift
    private static final long CYCLE_DURATION = 600000; // 10 minutes for one complete cycle
    private static final int ALPHA = 79;

    public Color getRedColor() {
        double phase = calculatePhase();
        return interpolateColor(RED_START, RED_END, phase, ALPHA);
    }

    public Color getBlueColor() {
        double phase = calculatePhase();
        return interpolateColor(BLUE_START, BLUE_END, phase, ALPHA);
    }

    private double calculatePhase() {
        // Current time modulo cycle duration gives us position in the cycle
        long currentTime = System.currentTimeMillis();
        double cyclePosition = (currentTime % CYCLE_DURATION) / (double) CYCLE_DURATION;

        // Use absolute sine wave to create smooth back-and-forth oscillation
        return Math.abs(Math.sin(cyclePosition * Math.PI));
    }

    private Color interpolateColor(int[] start, int[] end, double phase, int alpha) {
        int red = interpolateComponent(start[0], end[0], phase);
        int green = interpolateComponent(start[1], end[1], phase);
        int blue = interpolateComponent(start[2], end[2], phase);

        return new Color(red, green, blue, alpha);
    }

    private int interpolateComponent(int start, int end, double phase) {
        return (int) Math.round(start + (end - start) * phase);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.LoginResponse;
import com.flippingcopilot.model.SessionData;
import com.flippingcopilot.model.Transaction;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.util.*;

@Slf4j
public class Persistance {
    public static Gson gson;
    public static final File PARENT_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "flipping-copilot");
    public static final String UN_ACKED_TRANSACTIONS_FILE_TEMPLATE = "%s_un_acked.jsonl";
    public static final String ALL_TRANSACTIONS_FILE_TEMPLATE = "%s_all_transactions.jsonl";
    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";
    public static File directory;

    public static void setUp(String directoryPath) throws IOException {
        directory = new File(directoryPath);
        createDirectory(directory);
        createRequiredFiles();
    }

    public static void setUp(Gson gson) throws IOException {
        Persistance.gson = gson;
        directory = PARENT_DIRECTORY;
        createDirectory(PARENT_DIRECTORY);
        createRequiredFiles();
    }

    private static void createRequiredFiles() throws IOException {
        generateFileIfDoesNotExist(LOGIN_RESPONSE_JSON_FILE);
    }

    private static void generateFileIfDoesNotExist(String filename) throws IOException {
        File file = new File(directory, filename);
        if (!file.exists()) {
            if (!file.createNewFile()) {
                log.info("Failed to generate file {}", file.getPath());
            }
        }
    }

    private static void createDirectory(File directory) throws IOException {
        if (!directory.exists()) {
            if (!directory.mkdir()) {
                throw new IOException("unable to create parent directory!");
            }
        }
    }

    public static LoginResponse loadLoginResponse() throws IOException {
        String jsonString = getFileContent(LOGIN_RESPONSE_JSON_FILE);
        return gson.fromJson(jsonString, LoginResponse.class);
    }

    public static void saveLoginResponse(LoginResponse loginResponse) {
        if (loginResponse == null) {
            return;
        }
        try {
            File file = new File(directory, LOGIN_RESPONSE_JSON_FILE);
            String json = gson.toJson(loginResponse);
            Files.write(file.toPath(), json.getBytes());
        } catch (IOException e) {
            log.warn("error saving login response {}", e.getMessage(), e);
        }
    }

    public static void deleteLoginResponse() {
        File file = new File(directory, LOGIN_RESPONSE_JSON_FILE);
        if (file.exists()) {
            file.delete();
        }
    }

    private static String getFileContent(String filename) throws IOException {
        Path filePath = Paths.get(directory.getAbsolutePath(), filename);
        byte[] fileBytes = Files.readAllBytes(filePath);
        return new String(fileBytes);
    }


    public static List<Transaction> loadUnAckedTransactions(String displayName) {
        List<Transaction> transactions = new ArrayList<>();
        File file = new File(PARENT_DIRECTORY, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        if (!file.exists()) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        }
        Set<UUID> added = new HashSet<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }
                try {
                    Transaction transaction = gson.fromJson(line, Transaction.class);
                    // there was previously a bug where the same transaction was being added many times to the list
                    // just clean things here to be safe
                    if (!added.contains(transaction.getId())) {
                        transactions.add(transaction);
                        added.add(transaction.getId());
                    }
                } catch (JsonSyntaxException e) {
                    log.warn("error deserializing transaction line '{}' file {}", line, file, e);
                }
            }
        } catch (FileNotFoundException e) {
            log.info("no existing un acked transactions file for {}", displayName);
            return new ArrayList<>();
        } catch (IOException e) {
            log.warn("error loading un acked transaction file {}", file, e);
            return new ArrayList<>();
        }
        log.info("loaded {} stored transactions for {}", transactions.size(), displayName);
        return transactions;
    }

    public static void storeUnAckedTransactions(List<Transaction> transactions, String displayName) {
        File unackedTransactionsFile = new File(PARENT_DIRECTORY, String.format(UN_ACKED_TRANSACTIONS_FILE_TEMPLATE, hashDisplayName(displayName)));
        try (BufferedWriter w = new BufferedWriter(new FileWriter(unackedTransactionsFile, false))) {
            for (Transaction transaction : transactions) {
                String json = gson.toJson(transaction);
                w.write(json);
                w.newLine();
            }
        } catch (IOException e) {
            log.warn("error storing un acked transactions to file {}", unackedTransactionsFile, e);
        }
    }

    public static String hashDisplayName(String displayName) {
        if(displayName == null) {
            return "null";
        }
        // we hash the display name just to ensure that it's a valid file name
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            byte[] hashBytes = digest.digest(displayName.getBytes(StandardCharsets.UTF_8));
            StringBuilder hexString = new StringBuilder();
            for (byte b : hashBytes) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 algorithm not available", e);
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Supplier;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
@Getter
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OfferHandler {

    private static final int GE_OFFER_INIT_STATE_CHILD_ID = 20;

    // dependencies
    private final Client client;
    private final ClientThread clientThread;
    private final SuggestionManager suggestionManager;
    private final ApiRequestHandler apiRequestHandler;
    private final OsrsLoginManager osrsLoginManager;
    private final OfferManager offerManager;
    private final HighlightController highlightController;
    private final LoginResponseManager loginResponseManager;

    // state
    private String viewedSlotPriceErrorText = null;

    public void fetchSlotItemPrice(boolean isViewingSlot, Supplier<OfferEditor> offerEditorSupplier) {
        if (isViewingSlot) {
            var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);
            offerManager.setViewedSlotItemId(currentItemId);
            if (currentItemId == -1 || currentItemId == 0) return;

            var suggestion = suggestionManager.getSuggestion();
            if (suggestion != null && suggestion.getItemId() == currentItemId &&
                    ((Objects.equals(suggestion.getType(), "sell") && isSelling()) ||
                            Objects.equals(suggestion.getType(), "buy") && isBuying())) {
                offerManager.setLastViewedSlotItemId(suggestion.getItemId());
                offerManager.setLastViewedSlotItemPrice(suggestion.getPrice());
                offerManager.setLastViewedSlotItemPrice((int) Instant.now().getEpochSecond());
                return;
            }

            if (!loginResponseManager.isLoggedIn()) {
                viewedSlotPriceErrorText = "Login to copilot to see item price.";
                return;
            }
            viewedSlotPriceErrorText = "Loading copilot item price..";
            Consumer<ItemPrice> itemPriceConsumer = (fetchedPrice) -> {
                clientThread.invoke(() -> {
                    if (fetchedPrice == null) {
                        viewedSlotPriceErrorText = "Unknown error";
                        return;
                    }

                    if (fetchedPrice.getMessage() != null && !fetchedPrice.getMessage().isEmpty()) {
                        viewedSlotPriceErrorText = fetchedPrice.getMessage();
                    } else {
                        viewedSlotPriceErrorText = null;
                    }
                    offerManager.setViewedSlotItemPrice(isSelling() ? fetchedPrice.getSellPrice() : fetchedPrice.getBuyPrice());
                    offerManager.setLastViewedSlotItemId(offerManager.getViewedSlotItemId());
                    offerManager.setLastViewedSlotItemPrice(offerManager.getViewedSlotItemPrice());
                    offerManager.setLastViewedSlotPriceTime((int) Instant.now().getEpochSecond());

                    highlightController.redraw();
                    log.debug("fetched item {} price: {}", offerManager.getViewedSlotItemId(), offerManager.getViewedSlotItemPrice());

                    // todo: Usage of OfferEditor is messy. It mutates a widget so we need to get the original instance
                    //  of it which is created downstream on some other event handler path. This is why we use a supplier
                    //  but probably it should be an injected class of some kind. We should clean this up in the future
                    //  but for now just need it to work as currently broken.

                    OfferEditor flippingWidget = offerEditorSupplier.get();
                    if (flippingWidget != null) {
                        flippingWidget.showPrice(offerManager.getViewedSlotItemPrice());
                    }
                });
            };


            apiRequestHandler.asyncGetItemPriceWithGraphData(currentItemId, osrsLoginManager.getPlayerDisplayName(), itemPriceConsumer, false);

        } else {
            offerManager.setViewedSlotItemPrice(-1);
            offerManager.setViewedSlotItemId(-1);
            viewedSlotPriceErrorText = null;
        }
        highlightController.redraw();
    }

    public boolean isSettingQuantity() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();
        return chatInputText.equals("How many do you wish to buy?") || chatInputText.equals("How many do you wish to sell?");
    }

    public boolean isSettingPrice() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();

        var offerTextWidget = getOfferTextWidget();
        if (offerTextWidget == null) return false;
        String offerText = offerTextWidget.getText();
        return chatInputText.equals("Set a price for each item:") && (offerText.equals("Buy offer") || offerText.equals("Sell offer"));
    }


    private Widget getChatboxTitleWidget() {
        return client.getWidget(ComponentID.CHATBOX_TITLE);
    }

    private Widget getOfferTextWidget() {
        var offerContainerWidget = client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER);
        if (offerContainerWidget == null) return null;
        return offerContainerWidget.getChild(GE_OFFER_INIT_STATE_CHILD_ID);
    }

    public boolean isSelling() {
        return client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 1;
    }

    public boolean isBuying() {
        return client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 0;
    }

    public String getOfferType() {
        if (isBuying()) {
            return "buy";
        } else if (isSelling()) {
            return "sell";
        } else {
            return null;
        }
    }

    public void setSuggestedAction(Suggestion suggestion) {
        var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);

        if (isSettingQuantity()) {
            if (suggestion == null || currentItemId != suggestion.getItemId()) {
                return;
            }
            setChatboxValue(suggestion.getQuantity());
        } else if (isSettingPrice()) {
            int price = -1;
            if (suggestion == null || currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(getOfferType())) {
                if (offerManager.getViewedSlotItemId() != currentItemId) {
                    return;
                }
                price = offerManager.getViewedSlotItemPrice();
            } else {
                price = suggestion.getPrice();
            }

            if (price == -1) return;

            setChatboxValue(price);
        }
    }

    public void setChatboxValue(int value) {
        var chatboxInputWidget = client.getWidget(ComponentID.CHATBOX_FULL_INPUT);
        if (chatboxInputWidget == null) return;
        chatboxInputWidget.setText(value + "*");
        client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(value));
    }
}

package com.flippingcopilot.controller;

import java.awt.event.ActionEvent;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.LoginPanel;
import com.flippingcopilot.ui.MainPanel;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class CopilotLoginController {

    // dependencies
    @Setter
    private LoginPanel loginPanel;
    @Setter
    private MainPanel mainPanel;
    private final ApiRequestHandler apiRequestHandler;
    private final FlipManager flipManager;
    private final HighlightController highlightController;
    private final LoginResponseManager loginResponseManager;
    private final SuggestionManager suggestionManager;
    private final OsrsLoginManager osrsLoginManager;
    private final SessionManager sessionManager;
    private final TransactionManger transactionManger;

    // state
    private String email;
    private String password;

    public void onLoginPressed(ActionEvent event) {
        Runnable loginCallback = () -> {
            if (loginResponseManager.isLoggedIn()) {
                flipManager.loadFlipsAsync();
                mainPanel.refresh();
                String displayName = osrsLoginManager.getPlayerDisplayName();
                if(displayName != null) {
                    flipManager.setIntervalDisplayName(displayName);
                    flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                    transactionManger.scheduleSyncIn(0, displayName);
                }
            } else {
                LoginResponse loginResponse = loginResponseManager.getLoginResponse();
                String message = loginResponse != null ? loginResponse.message : "Login failed";
                loginPanel.showLoginErrorMessage(message);
            };
            loginPanel.endLoading();
        };

        if (this.email == null || this.password == null) {
            return;
        }
        loginPanel.startLoading();
        apiRequestHandler.authenticate(this.email, this.password, loginCallback);
    }

    public void onLogout() {
        flipManager.reset();
        loginResponseManager.reset();
        suggestionManager.reset();
        highlightController.removeAll();
    }

    public void onEmailTextChanged(String newEmail) {
        this.email = newEmail;
    }

    public void onPasswordTextChanged(String newPassword) {
        this.password = newPassword;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GePreviousSearch {

    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final HighlightController highlightController;
    private final Client client;


    public void showSuggestedItemInSearch() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion != null && suggestion.getType().equals("buy")) {
            if (grandExchange.isPreviousSearchSet() && grandExchange.showLastSearchEnabled()) {
                setPreviousSearch(suggestion.getItemId(), suggestion.getName());
            } else {
                createPreviousSearchWidget(suggestion.getItemId(), suggestion.getName());
                createPreviousSearchItemNameWidget(suggestion.getName());
                createPreviousSearchItemWidget(suggestion.getItemId());
                createPreviousSearchTextWidget();
            }
            highlightController.redraw();
        }
    }

    private void setPreviousSearch(int itemId, String itemName) {
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget previousSearch = searchResults.getChild(0);
        previousSearch.setOnOpListener(754, itemId, 84);
        previousSearch.setOnKeyListener(754, itemId, -2147483640);
        previousSearch.setName("<col=ff9040>" + itemName + "</col>");
        Widget previousSearchText = searchResults.getChild(1);
        previousSearchText.setText("Copilot item:");
        Widget itemNameWidget = searchResults.getChild(2);
        itemNameWidget.setText(itemName);
        Widget item = searchResults.getChild(3);
        item.setItemId(itemId);
    }

    private void createPreviousSearchWidget(int itemId, String itemName) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.RECTANGLE);
        widget.setTextColor(0xFFFFFF);
        widget.setOpacity(255);
        widget.setName("<col=ff9040>" + itemName + "</col>");
        widget.setHasListener(true);
        widget.setFilled(true);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(256);
        widget.setOriginalHeight(32);
        widget.setOnOpListener(754, itemId, 84);
        widget.setOnKeyListener(754, itemId, -2147483640);
        widget.setHasListener(true);
        widget.setAction(0, "Select");
        // set opacity to 200 when mouse is hovering
        widget.setOnMouseOverListener((JavaScriptCallback) ev -> {
            widget.setOpacity(200);
        });
        // set opacity back to 255 when mouse is not hovering
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
            widget.setOpacity(255);
        });

        widget.revalidate();
    }

    private void createPreviousSearchItemNameWidget(String itemName) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText(itemName);
        widget.setFontId(495);
        widget.setOriginalX(254);
        widget.setOriginalY(0);
        widget.setOriginalWidth(116);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }

    private void createPreviousSearchItemWidget(int itemId) {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.GRAPHIC);
        widget.setItemId(itemId);
        widget.setItemQuantity(1);
        widget.setItemQuantityMode(0);
        widget.setRotationX(550);
        widget.setModelZoom(1031);
        widget.setBorderType(1);
        widget.setOriginalX(214);
        widget.setOriginalY(0);
        widget.setOriginalWidth(36);
        widget.setOriginalHeight(32);
        widget.revalidate();
    }

    private void createPreviousSearchTextWidget() {
        Widget parentWidget = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText("Copilot item:");
        widget.setFontId(495);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(95);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }
}

package com.flippingcopilot.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchange {

    private final static int CURRENTLY_OPEN_GE_SLOT_VARBIT_ID = 4439;
    final static int SHOW_LAST_SEARCHED_VARBIT_ID = 10295;

    private final Client client;

    boolean isHomeScreenOpen() {
        return isOpen() && !isSlotOpen();
    }

    boolean isSlotOpen() {
        return getOpenSlot() != -1;
    }

    boolean isCollectButtonVisible() {
        Widget w = client.getWidget(InterfaceID.GRAND_EXCHANGE, 6);
        if (w == null) {
            return false;
        }
        Widget[] children = w.getChildren();
        if(children == null) {
            return false;
        }
        return Arrays.stream(children).anyMatch(c -> !c.isHidden() && "Collect".equals(c.getText()));
    }

    int getOpenSlot() {
        return client.getVarbitValue(CURRENTLY_OPEN_GE_SLOT_VARBIT_ID) - 1;
    }

    Widget getSlotWidget(int slot) {
        return client.getWidget(465, 7 + slot);
    }

    Widget getBuyButton(int slot) {
        Widget slotWidget = getSlotWidget(slot);
        if (slotWidget == null) {
            return null;
        }
        return slotWidget.getChild(0);
    }

    Widget getCollectButton() {
        Widget topBar = client.getWidget(465, 6);
        if (topBar == null) {
            return null;
        }
        return topBar.getChild(2);
    }

    Widget getOfferContainerWidget() {
        return client.getWidget(465, 26);
    }

    Widget getOfferTypeWidget() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(20);
    }

    Widget getConfirmButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(58);
    }

    int getOfferQuantity() {
        return client.getVarbitValue(4396);
    }

    int getOfferPrice() {
        return client.getVarbitValue(4398);
    }

    public boolean isOpen() {
        return client.getWidget(InterfaceID.GRAND_EXCHANGE, 7) != null;
    }

    public boolean isPreviousSearchSet() {
        return client.getVarpValue(2674) != -1;
    }

    public boolean showLastSearchEnabled() {
        return client.getVarbitValue(SHOW_LAST_SEARCHED_VARBIT_ID) == 0;
    }

    public Widget getSetQuantityButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(51);
    }

    public Widget getSetPriceButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(54);
    }

    public Widget getSetQuantityAllButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(50);
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.ui.UIUtilities;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;


@ConfigGroup("flippingcopilot")
public interface FlippingCopilotConfig extends Config
{
    public enum PriceGraphWebsite
    {
        FLIPPING_COPILOT("Flipping Copilot"),
        OSRS_WIKI("OSRS Wiki"),
        GE_TRACKER("GE Tracker"),
        PLATINUM_TOKENS("PlatinumTokens"),
        GE_DATABASE("GE Database"),
        OSRS_CLOUD("Osrs.cloud"),
        OSRS_EXCHANGE("OSRS Exchange"),
        FLIPPING_GG("Flipping.gg");


        private final String name;
        PriceGraphWebsite(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name;
        }

        public String getUrl(String itemName, int itemId)
        {
            switch (this)
            {
                case OSRS_WIKI:
                    return "https://prices.runescape.wiki/osrs/item/" + itemId;
                case GE_TRACKER:
                    return "https://www.ge-tracker.com/item/" + itemId;
                case PLATINUM_TOKENS:
                    String platinumTokensFormattedName = itemName
                            .toLowerCase()
                            .replace("'", "")
                            .replace("(", " ")
                            .replace(")", "")
                            .replace("+", " plus")
                            .replace("  ", " ")
                            .replace(" ", "-");
                    return "https://platinumtokens.com/item/" + platinumTokensFormattedName;
                case GE_DATABASE:
                    return "https://secure.runescape.com/m=itemdb_oldschool/viewitem?obj=" + itemId;
                case OSRS_EXCHANGE:
                    String osrsExchangeFormattedName = itemName.toLowerCase().replace(' ','-');
                    return "https://www.osrs.exchange/item/"
                            + URLEncoder.encode(osrsExchangeFormattedName, StandardCharsets.UTF_8);
                case OSRS_CLOUD:
                    return "https://prices.osrs.cloud/item/" + itemId;
                case FLIPPING_GG:
                    return "https://www.flipping.gg/items/" + itemId;
                default:
                    return "";
            }
        }
    }


    @ConfigItem(
            keyName = "enableChatNotifications",
            name = "Enable chat notifications",
            description = "Show chat notifications for suggested action when the side panel is closed."
    )
    default boolean enableChatNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "enableTrayNotifications",
            name = "Enable tray notifications",
            description = "Show tray notifications for suggested action when runelite is out of focus."
    )
    default boolean enableTrayNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "profitAmountColor",
            name = "Flip tracker profit color",
            description = "The color of the profit amount text in the flip tracker"
    )
    default Color profitAmountColor() {
        return ColorScheme.GRAND_EXCHANGE_PRICE;
    }
    @ConfigItem(
            keyName = "lossAmountColor",
            name = "Flip tracker loss color",
            description = "The color of the loss amount text in the flip tracker"
    )
    default Color lossAmountColor() {
        return UIUtilities.OUTDATED_COLOR;
    }
    @ConfigItem(
            keyName = "chatTextColor",
            name = "Chat text color",
            description = "The color of the text for copilot messages in the chat."
    )
    default Color chatTextColor() {
        return new Color(0x0040FF);
    }
    @ConfigItem(
            keyName = "webhook",
            name = "Webhook URL",
            description = "The Discord Webhook URL for sending display name and profit."
    )
    String webhook();
    @ConfigItem(
            keyName = "priceGraphButton",
            name = "Graph button",
            description = "The page to open when the graph button is clicked."
    )
    default PriceGraphWebsite priceGraphWebsite()
    {
        return PriceGraphWebsite.FLIPPING_COPILOT;
    }
    @ConfigItem(
            keyName = "suggestionHighlights",
            name = "Highlight suggested actions",
            description = "Show highlight overlays on the GE interface for suggested actions."
    )
    default boolean suggestionHighlights()
    {
        return true;
    }
    @ConfigItem(
            keyName = "quickSetKeybind",
            name = "Price/quantity set keybind",
            description = "Keybind to quickly set the price or quantity of a GE offer to the suggested value"
    )
    default Keybind quickSetKeybind()
    {
        return new Keybind(KeyEvent.VK_E, 0);
    }

    @ConfigItem(
            keyName = "enabledPriceGraphMenuOpton",
            name = "Enable price graph menu option",
            description = "Adds a menu option to open copilot price graph on applicable right clicks."
    )
    default boolean priceGraphMenuOptionEnabled()
    {
        return true;
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GameUiChangesHandler {
    private static final int GE_HISTORY_TAB_WIDGET_ID = 149;

    // dependencies
    private final ClientThread clientThread;
    private final Client client;
    private final GePreviousSearch gePreviousSearch;
    private final HighlightController highlightController;
    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final OfferManager offerManager;
    private final OfferHandler offerHandler;

    // state
    boolean quantityOrPriceChatboxOpen;
    boolean itemSearchChatboxOpen = false;
    @Getter
    OfferEditor flippingWidget = null;

    public void onVarClientIntChanged(VarClientIntChanged event) {
        if (event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 14
                && client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS) != null) {
            itemSearchChatboxOpen = true;
            clientThread.invokeLater(gePreviousSearch::showSuggestedItemInSearch);
        }

        if (quantityOrPriceChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            quantityOrPriceChatboxOpen = false;
            return;
        }

        if (itemSearchChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            clientThread.invokeLater(highlightController::redraw);
            itemSearchChatboxOpen = false;
            return;
        }

        //Check that it was the chat input that got enabled.
        if (event.getIndex() != VarClientInt.INPUT_TYPE
                || client.getWidget(ComponentID.CHATBOX_TITLE) == null
                || client.getVarcIntValue(VarClientInt.INPUT_TYPE) != 7
                || client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) == null) {
            return;
        }
        quantityOrPriceChatboxOpen = true;

        clientThread.invokeLater(() ->
        {
            flippingWidget = new OfferEditor(offerManager, client.getWidget(ComponentID.CHATBOX_CONTAINER), offerHandler, client);
            Suggestion suggestion = suggestionManager.getSuggestion();
            if (suggestion != null) {
                flippingWidget.showSuggestion(suggestion);
            }
        });
    }

    public void onVarClientStrChanged(VarClientStrChanged event) {
        if (event.getIndex() == VarClientStr.INPUT_TEXT && itemSearchChatboxOpen) {
            clientThread.invokeLater(highlightController::redraw);
        }
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            suggestionManager.setSuggestionNeeded(true);
        }
        if (event.getGroupId() == 383
                || event.getGroupId() == InterfaceID.GRAND_EXCHANGE
                || event.getGroupId() == 213
                || event.getGroupId() == GE_HISTORY_TAB_WIDGET_ID) {
            clientThread.invokeLater(highlightController::redraw);
        }
    }

    public void onWidgetClosed(WidgetClosed event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            clientThread.invokeLater(highlightController::removeAll);
            suggestionManager.setSuggestionNeeded(true);
        }
    }

    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarpId() == 375
                || event.getVarpId() == CURRENT_GE_ITEM
                || event.getVarbitId() == 4396
                || event.getVarbitId() == 4398
                || event.getVarbitId() == 4439) {
            clientThread.invokeLater(highlightController::redraw);
        }

        if (event.getVarpId() == CURRENT_GE_ITEM) {
            clientThread.invokeLater(() -> offerHandler.fetchSlotItemPrice(event.getValue() > -1, this::getFlippingWidget));
        }
    }

    public void handleMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals("Confirm") && grandExchange.isSlotOpen()) {
            log.debug("offer confirmed tick {}", client.getTickCount());
            offerManager.setOfferJustPlaced(true);
            suggestionManager.setLastOfferSubmittedTick(client.getTickCount());
            suggestionManager.setSuggestionNeeded(true);
            Suggestion suggestion = suggestionManager.getSuggestion();
            if(suggestion != null) {
                suggestionManager.setSuggestionItemIdOnOfferSubmitted(suggestion.getItemId());
                suggestionManager.setSuggestionOfferStatusOnOfferSubmitted(suggestionOfferStatus(suggestion));
            } else {
                suggestionManager.setSuggestionItemIdOnOfferSubmitted(-1);
                suggestionManager.setSuggestionOfferStatusOnOfferSubmitted(null);
            }
        }
    }

    private OfferStatus suggestionOfferStatus(Suggestion suggestion) {
        if ("sell".equals(suggestion.getType())) {
            return OfferStatus.SELL;
        } else if ("buy".equals(suggestion.getType())) {
            return OfferStatus.BUY;
        } else {
            return null;
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.PremiumInstanceStatus;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.ui.PremiumInstancePanel;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.util.function.Consumer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PremiumInstanceController {

    private final ApiRequestHandler apiRequestHandler;
    private final FlippingCopilotConfig copilotConfig;
    private final SuggestionManager suggestionManager;
    private JDialog dialog;

    public void loadAndOpenPremiumInstanceDialog() {
        // Create the dialog
        if(dialog != null) {
            dialog.dispose();
        }
        dialog = new JDialog();
        dialog.setTitle("Premium accounts management");
        dialog.setModal(false);
        dialog.setSize(400, 300);
        dialog.setLocationRelativeTo(null);

        // Create the panel
        PremiumInstancePanel panel = new PremiumInstancePanel(copilotConfig, apiRequestHandler, suggestionManager);
        dialog.setContentPane(panel);

        // Show loading state
        panel.showLoading();
        Consumer<PremiumInstanceStatus> c = (status) -> {
            SwingUtilities.invokeLater(() -> {  // Make sure UI updates happen on EDT
                if (status.getLoadingError() != null && !status.getLoadingError().isEmpty()) {
                    panel.showError(status.getLoadingError());
                } else {
                    panel.showManagementView(status);
                }
            });
        };
        apiRequestHandler.asyncGetPremiumInstanceStatus(c);
        dialog.setVisible(true);
    }
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.WidgetHighlightOverlay;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.VarClientStr;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;
import static net.runelite.api.Varbits.GE_OFFER_CREATION_TYPE;


@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class HighlightController {

    // dependencies
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final GrandExchange grandExchange;
    private final AccountStatusManager accountStatusManager;
    private final Client client;
    private final OfferManager offerManager;
    private final OverlayManager overlayManager;
    private final HighlightColorController highlightColorController;

    // state
    private final ArrayList<WidgetHighlightOverlay> highlightOverlays = new ArrayList<>();

    public void redraw() {
        removeAll();
        if(!config.suggestionHighlights()) {
            return;
        }
        if (offerManager.isOfferJustPlaced()) {
            return;
        }
        if(suggestionManager.getSuggestionError() != null) {
            return;
        }
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return;
        }
        if (grandExchange.isHomeScreenOpen()) {
            drawHomeScreenHighLights(suggestion);
        } else if (grandExchange.isSlotOpen()) {
            drawOfferScreenHighlights(suggestion);
        }
    }

    private void drawHomeScreenHighLights(Suggestion suggestion) {
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (accountStatus.isCollectNeeded(suggestion)) {
            Widget collectButton = grandExchange.getCollectButton();
            if (collectButton != null) {
                add(collectButton, highlightColorController.getBlueColor(), new Rectangle(2, 1, 81, 18));
            }
        }
        else if (suggestion.getType().equals("abort")) {
            Widget slotWidget = grandExchange.getSlotWidget(suggestion.getBoxId());
            add(slotWidget, highlightColorController.getRedColor());
        }
        else if (suggestion.getType().equals("buy")) {
            int slotId = accountStatus.getOffers().findEmptySlot();
            if (slotId != -1) {
                Widget buyButton = grandExchange.getBuyButton(slotId);
                if (buyButton != null && !buyButton.isHidden()) {
                    add(buyButton, highlightColorController.getBlueColor(), new Rectangle(0, 0, 45, 44));
                }
            }
        }
        else if (suggestion.getType().equals("sell")) {
            Widget itemWidget = getInventoryItemWidget(suggestion.getItemId());
            if (itemWidget != null && !itemWidget.isHidden()) {
                add(itemWidget, highlightColorController.getBlueColor(), new Rectangle(0, 0, 34, 32));
            }
        }
    }

    private void drawOfferScreenHighlights(Suggestion suggestion) {
        Widget offerTypeWidget = grandExchange.getOfferTypeWidget();
        String offerType = client.getVarbitValue(GE_OFFER_CREATION_TYPE) == 1 ? "sell" : "buy";
        if (offerTypeWidget != null) {
            if (offerType.equals(suggestion.getType())) {
                if (client.getVarpValue(CURRENT_GE_ITEM) == suggestion.getItemId()) {
                    if (offerDetailsCorrect(suggestion)) {
                        highlightConfirm();
                    } else {
                        if (grandExchange.getOfferPrice() != suggestion.getPrice()) {
                            highlightPrice();
                        }
                        highlightQuantity(suggestion);
                    }
                } else if (client.getVarpValue(CURRENT_GE_ITEM ) == -1){
                    highlightItemInSearch(suggestion);
                }
            }
            // Check if unsuggested item/offer type is selected
            if (client.getVarpValue(CURRENT_GE_ITEM) != -1
                    && (client.getVarpValue(CURRENT_GE_ITEM) != suggestion.getItemId()
                        || !offerType.equals(suggestion.getType()))
                    && client.getVarpValue(CURRENT_GE_ITEM) == offerManager.getViewedSlotItemId()
                    && offerManager.getViewedSlotItemPrice() > 0) {
                if (grandExchange.getOfferPrice() == offerManager.getViewedSlotItemPrice()) {
                    highlightConfirm();
                } else {
                    highlightPrice();
                }
            }
        }
    }

    private void highlightItemInSearch(Suggestion suggestion) {
        if (!client.getVarcStrValue(VarClientStr.INPUT_TEXT).isEmpty()) {
            return;
        }
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        if (searchResults == null) {
            return;
        }
        for (Widget widget : searchResults.getDynamicChildren()) {
            if (widget.getName().equals("<col=ff9040>" + suggestion.getName() + "</col>")) {
                add(widget, highlightColorController.getBlueColor());
                return;
            }
        }
        Widget itemWidget = searchResults.getChild(3);
        if (itemWidget != null && itemWidget.getItemId() == suggestion.getItemId()) {
            add(itemWidget, highlightColorController.getBlueColor());
        }
    }

    private boolean offerDetailsCorrect(Suggestion suggestion) {
        return grandExchange.getOfferPrice() == suggestion.getPrice()
                && grandExchange.getOfferQuantity() == suggestion.getQuantity();
    }

    private void highlightPrice() {
        Widget setPriceButton = grandExchange.getSetPriceButton();
        if (setPriceButton != null) {
            add(setPriceButton, highlightColorController.getBlueColor(), new Rectangle(1, 6, 33, 23));
        }
    }

    private void highlightQuantity(Suggestion suggestion) {
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (grandExchange.getOfferQuantity() != suggestion.getQuantity()) {
            Widget setQuantityButton;
            if (accountStatus.getInventory().getTotalAmount(suggestion.getItemId()) == suggestion.getQuantity()) {
                setQuantityButton = grandExchange.getSetQuantityAllButton();
            } else {
                setQuantityButton = grandExchange.getSetQuantityButton();
            }
            if (setQuantityButton != null) {
                add(setQuantityButton, highlightColorController.getBlueColor(), new Rectangle(1, 6, 33, 23));
            }
        }
    }

    private void highlightConfirm() {
        Widget confirmButton = grandExchange.getConfirmButton();
        if (confirmButton != null) {
            add(confirmButton, highlightColorController.getBlueColor(), new Rectangle(1, 1, 150, 38));
        }
    }

    private void add(Widget widget, Color color, Rectangle adjustedBounds) {
        SwingUtilities.invokeLater(() -> {
            WidgetHighlightOverlay overlay = new WidgetHighlightOverlay(widget, color, adjustedBounds);
            highlightOverlays.add(overlay);
            overlayManager.add(overlay);
        });
    }

    private void add(Widget widget, Color color) {
        add(widget, color, new Rectangle(0, 0, widget.getWidth(), widget.getHeight()));
    }

    public void removeAll() {
        SwingUtilities.invokeLater(() -> {
            highlightOverlays.forEach(overlayManager::remove);
            highlightOverlays.clear();
        });
    }

    private Widget getInventoryItemWidget(int unnotedItemId) {
        // Inventory has a different widget if GE is open
        Widget inventory = client.getWidget(467, 0);
        if (inventory == null) {
            inventory = client.getWidget(149, 0);
            if (inventory == null) {
                return null;
            }
        }

        Widget notedWidget = null;
        Widget unnotedWidget = null;

        for (Widget widget : inventory.getDynamicChildren()) {
            int itemId = widget.getItemId();
            ItemComposition itemComposition = client.getItemDefinition(itemId);

            if (itemComposition.getNote() != -1) {
                if (itemComposition.getLinkedNoteId() == unnotedItemId) {
                    notedWidget = widget;
                }
            } else if (itemId == unnotedItemId) {
                unnotedWidget = widget;
            }
        }
        return notedWidget != null ? notedWidget : unnotedWidget;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.ui.MainPanel;
import com.flippingcopilot.ui.graph.PriceGraphController;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PriceGraphOpener {

    private final FlippingCopilotConfig config;
    private final Client client;
    private final ItemManager itemManager;
    private final PriceGraphController priceGraphController;


    public void injectCopilotPriceGraphMenuEntry(MenuEntryAdded event) {
        if(!config.priceGraphMenuOptionEnabled()) {
            return;
        }
        if (event.getOption().equals("View offer")) {
            long slotWidgetId = event.getActionParam1();
            client.getMenu()
                    .createMenuEntry(-1)
                    .setOption("Copilot price graph")
                    .onClick((MenuEntry e) -> {
                        GrandExchangeOffer[] offers = client.getGrandExchangeOffers();
                        for (int i = 0; i < offers.length; i++) {
                            Widget slotWidget = client.getWidget(465, 7 + i);
                            if (slotWidget != null && slotWidget.getId() == slotWidgetId) {
                                int itemId = offers[i].getItemId();
                                priceGraphController.setUserItemGraphData(null);
                                priceGraphController.loadAndAndShowPriceGraph(itemId);
                                log.debug("matched widget to slot {}, item {}", i, offers[i].getItemId());
                            }
                        }
                    });
        }
    }
}



package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.*;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
@PluginDescriptor(
		name = "Flipping Copilot",
		description = "Your AI assistant for trading"
)
public class FlippingCopilotPlugin extends Plugin {

	@Inject
	private FlippingCopilotConfig config;
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private ScheduledExecutorService executorService;
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private Gson gson;
	@Inject
	private GrandExchange grandExchange;
	@Inject
	private GrandExchangeCollectHandler grandExchangeCollectHandler;
	@Inject
	private GrandExchangeOfferEventHandler offerEventHandler;
	@Inject
	private ApiRequestHandler apiRequestHandler;
	@Inject
	private AccountStatusManager accountStatusManager;
	@Inject
	private SuggestionController suggestionController;
	@Inject
	private SuggestionManager suggestionManager;
	@Inject
	private WebHookController webHookController;
	@Inject
	private KeybindHandler keybindHandler;
	@Inject
	private CopilotLoginController copilotLoginController;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private LoginResponseManager loginResponseManager;
	@Inject
	private HighlightController highlightController;
	@Inject
	private GameUiChangesHandler gameUiChangesHandler;
	@Inject
	private OsrsLoginManager osrsLoginManager;
	@Inject
	private FlipManager flipManager;
	@Inject
	private SessionManager sessionManager;
	@Inject
	private GrandExchangeUncollectedManager grandExchangeUncollectedManager;
	@Inject
	private TransactionManger transactionManger;
	@Inject
	private OfferManager offerManager;
	@Inject
	private PriceGraphOpener priceGraphOpener;

	private MainPanel mainPanel;
	private StatsPanelV2 statsPanel;
	private NavigationButton navButton;

	@Override
	protected void startUp() throws Exception {
		Persistance.setUp(gson);

		// seems we need to delay instantiating the UI till here as otherwise the panels look different
		mainPanel = injector.getInstance(MainPanel.class);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon-small.png");
		navButton = NavigationButton.builder()
				.tooltip("Flipping Copilot")
				.icon(icon)
				.priority(3)
				.panel(mainPanel)
				.build();
		clientToolbar.addNavigation(navButton);

		copilotLoginController.setLoginPanel(mainPanel.loginPanel);
		copilotLoginController.setMainPanel(mainPanel);
		suggestionController.setCopilotPanel(mainPanel.copilotPanel);
		suggestionController.setMainPanel(mainPanel);
		suggestionController.setLoginPanel(mainPanel.loginPanel);
		suggestionController.setSuggestionPanel(mainPanel.copilotPanel.suggestionPanel);
		grandExchangeCollectHandler.setSuggestionPanel(mainPanel.copilotPanel.suggestionPanel);
		statsPanel = mainPanel.copilotPanel.statsPanel;

		mainPanel.refresh();
		if(loginResponseManager.isLoggedIn()) {
			flipManager.loadFlipsAsync();
		}
		if(osrsLoginManager.getInvalidStateDisplayMessage() == null) {
			flipManager.setIntervalDisplayName(osrsLoginManager.getPlayerDisplayName());
			flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
		}
		executorService.scheduleAtFixedRate(() ->
			clientThread.invoke(() -> {
				boolean loginValid = osrsLoginManager.isValidLoginState();
				if (loginValid) {
					AccountStatus accStatus = accountStatusManager.getAccountStatus();
					boolean isFlipping = accStatus != null && accStatus.currentlyFlipping();
					long cashStack = accStatus == null ? 0 : accStatus.currentCashStack();
					if(sessionManager.updateSessionStats(isFlipping, cashStack)) {
						mainPanel.copilotPanel.statsPanel.refresh(false, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
					}
				}
			})
		, 2000, 1000, TimeUnit.MILLISECONDS);
	}

	@Override
	protected void shutDown() throws Exception {
		offerManager.saveAll();
		highlightController.removeAll();
		clientToolbar.removeNavigation(navButton);
		if(loginResponseManager.isLoggedIn()) {
			String displayName = osrsLoginManager.getLastDisplayName();
			webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, displayName), sessionManager.getCachedSessionData(), displayName, false);
		}
		keybindHandler.unregister();
	}

	@Provides
	public FlippingCopilotConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(FlippingCopilotConfig.class);
	}

	//---------------------------- Event Handlers ----------------------------//
	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event) {
		offerEventHandler.onGrandExchangeOfferChanged(event);
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event) {
		if (event.getContainerId() == InventoryID.INVENTORY.getId() && grandExchange.isOpen()) {
			suggestionManager.setSuggestionNeeded(true);
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		suggestionController.onGameTick();
		offerEventHandler.onGameTick();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		int slot = grandExchange.getOpenSlot();
		grandExchangeCollectHandler.handleCollect(event, slot);
		gameUiChangesHandler.handleMenuOptionClicked(event);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		priceGraphOpener.injectCopilotPriceGraphMenuEntry(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		gameUiChangesHandler.onWidgetLoaded(event);
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		gameUiChangesHandler.onWidgetClosed(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		gameUiChangesHandler.onVarbitChanged(event);
	}

	@Subscribe
	public void onVarClientStrChanged(VarClientStrChanged event) {
		gameUiChangesHandler.onVarClientStrChanged(event);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		switch (event.getGameState())
		{
			case LOGIN_SCREEN:
				sessionManager.reset();
				suggestionManager.reset();
				osrsLoginManager.reset();
				accountStatusManager.reset();
				grandExchangeUncollectedManager.reset();
				statsPanel.refresh(true, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
				mainPanel.refresh();
				break;
			case LOGGING_IN:
			case HOPPING:
			case CONNECTION_LOST:
				osrsLoginManager.setLastLoginTick(client.getTickCount());
				break;
			case LOGGED_IN:
				// we want to update the flips panel on login but unfortunately the display name
				// is not available immediately so schedule what we need to do here for in the future
				// todo: move to just using the accountHash which is available immediately to simply things
				clientThread.invokeLater(() -> {
					if (client.getGameState() != GameState.LOGGED_IN) {
						return true;
					}
					final String name = osrsLoginManager.getPlayerDisplayName();
					if(name == null) {
						return false;
					}
					statsPanel.resetIntervalDropdownToSession();
					flipManager.setIntervalDisplayName(name);
					flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
					statsPanel.refresh(true, loginResponseManager.isLoggedIn()  && osrsLoginManager.isValidLoginState());
					mainPanel.refresh();
					if(loginResponseManager.isLoggedIn()) {
						transactionManger.scheduleSyncIn(0, name);
					}
					return true;
				});
		}
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event) {
		gameUiChangesHandler.onVarClientIntChanged(event);
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown clientShutdownEvent) {
		log.debug("client shutdown event received");
		offerManager.saveAll();
		if(loginResponseManager.isLoggedIn()) {
			String displayName = osrsLoginManager.getLastDisplayName();
			webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, displayName), sessionManager.getCachedSessionData(), displayName, false);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals("flippingcopilot")) {
			log.debug("copilot config changed event received");
			if (event.getKey().equals("profitAmountColor") || event.getKey().equals("lossAmountColor")) {
				mainPanel.copilotPanel.statsPanel.refresh(true, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
			}
			if (event.getKey().equals("suggestionHighlights")) {
				clientThread.invokeLater(() -> highlightController.redraw());
			}
		}
	}
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.GrandExchangeUncollectedManager;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.ui.SuggestionPanel;
import com.google.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchangeCollectHandler {

    // dependencies
    private final OsrsLoginManager osrsLoginManager;
    private final GrandExchangeUncollectedManager geUncollected;
    @Setter
    private SuggestionPanel suggestionPanel;

    public void handleCollect(MenuOptionClicked event, int slot) {
        String menuOption = event.getMenuOption();
        Widget widget = event.getWidget();
        if (widget != null) {
            handleCollectAll(menuOption, widget);
            handleCollectWithSlotOpen(menuOption, widget, slot);
            handleCollectionBoxCollectAll(menuOption, widget);
            handleCollectionBoxCollectItem(menuOption, widget);
        }
    }

    private void handleCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 30474246) {
            if (menuOption.equals("Collect to inventory")) {
                geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            } else if (menuOption.equals("Collect to bank")) {
                geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            }
            suggestionPanel.refresh();
        }
    }

    private void handleCollectWithSlotOpen(String menuOption, Widget widget, int slot) {
        if (widget.getId() == 30474264 ) {
            if (menuOption.contains("Collect")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            } else if (menuOption.contains("Bank")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            }
            suggestionPanel.refresh();
        }
    }

    private void handleCollectionBoxCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 26345476 && menuOption.equals("Collect to bank")) {
            geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionPanel.refresh();
            
        } else if (widget.getId() == 26345475 && menuOption.equals("Collect to inventory")) {
            geUncollected.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionPanel.refresh();
        }
    }

    private void handleCollectionBoxCollectItem(String menuOption, Widget widget) {
        int slot = widget.getId() - 26345477;
        if (slot >= 0 && slot <= 7) {
            if (menuOption.contains("Collect")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            } else if (menuOption.contains("Bank")) {
                geUncollected.clearSlotUncollected(osrsLoginManager.getAccountHash(), slot);
            }
            suggestionPanel.refresh();
        }
    }
}

package com.flippingcopilot.controller;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.GpDropOverlay;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import javax.inject.Inject;
import javax.inject.Singleton;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.client.ui.overlay.OverlayManager;

import static com.flippingcopilot.model.OsrsLoginManager.GE_LOGIN_BURST_WINDOW;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class GrandExchangeOfferEventHandler {

    // dependencies
    private final Client client;
    private final OfferManager offerPersistence;
    private final GrandExchange grandExchange;
    private final TransactionManger transactionManager;
    private final OsrsLoginManager osrsLoginManager;
    private final OverlayManager overlayManager;
    private final GrandExchangeUncollectedManager grandExchangeUncollectedManager;
    private final OfferManager offerManager;
    private final SuggestionManager suggestionManager;

    // state
    private final Queue<Transaction> transactionsToProcess = new ConcurrentLinkedQueue<>();

    public void onGameTick() {
        if(!transactionsToProcess.isEmpty()) {
            processTransactions();
        }
    }

    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerEvent) {
        final int slot = offerEvent.getSlot();
        final GrandExchangeOffer offer = offerEvent.getOffer();
        Long accountHash = client.getAccountHash();

        if (offer.getState() == GrandExchangeOfferState.EMPTY && client.getGameState() != GameState.LOGGED_IN) {
            // Trades are cleared by the client during LOGIN_SCREEN/HOPPING/LOGGING_IN, ignore those
            return;
        }

        log.debug("tick {} GE offer updated: state: {}, slot: {}, item: {}, qty: {}, lastLoginTick: {}", client.getTickCount(), offer.getState(), slot, offer.getItemId(), offer.getQuantitySold(), osrsLoginManager.getLastLoginTick());

        SavedOffer o = SavedOffer.fromGrandExchangeOffer(offer);

        SavedOffer prev = offerPersistence.loadOffer(accountHash, slot);

        if(Objects.equals(o, prev)) {
            log.debug("skipping duplicate offer event {}", o);
            return;
        }

        o.setCopilotPriceUsed(wasCopilotPriceUsed(o, prev));
        o.setWasCopilotSuggestion(wasCopilotSuggestion(o, prev));

        boolean consistent = isConsistent(prev, o);
        if(!consistent) {
            log.warn("offer on slot {} is inconsistent with previous saved offer", slot);
        }

        if(hasSlotBecomeFree(o, prev, consistent)) {
            suggestionManager.setSuggestionNeeded(true);
        }

        Transaction t = inferTransaction(slot, o, prev, consistent);
        if(t != null) {
            transactionsToProcess.add(t);
            processTransactions();
            suggestionManager.setSuggestionNeeded(true);
            log.debug("inferred transaction {}", t);
        }
        updateUncollected(accountHash, slot, o, prev, consistent);
        offerPersistence.saveOffer(accountHash, slot, o);
    }

    private boolean hasSlotBecomeFree(SavedOffer offer, SavedOffer prev, boolean consistent) {
        return offer.isFreeSlot() && (prev == null || !consistent || !prev.isFreeSlot());
    }

    private boolean wasCopilotPriceUsed(SavedOffer o, SavedOffer prev) {
        if(isNewOffer(prev, o)){
            return o.getItemId() == offerManager.getLastViewedSlotItemId() && o.getPrice() == offerManager.getLastViewedSlotItemPrice() && Instant.now().minusSeconds(30).getEpochSecond() < offerManager.getLastViewedSlotPriceTime();
        } else {
            return prev.isCopilotPriceUsed();
        }
    }

    private boolean wasCopilotSuggestion(SavedOffer o, SavedOffer prev) {
        if(isNewOffer(prev, o)){
            return o.getItemId() == suggestionManager.getSuggestionItemIdOnOfferSubmitted() && o.getOfferStatus().equals(suggestionManager.getSuggestionOfferStatusOnOfferSubmitted());
        } else {
            return prev.isWasCopilotSuggestion();
        }
    }

    private void updateUncollected(Long accountHash, int slot, SavedOffer o, SavedOffer prev, boolean consistent) {
        if(!consistent) {
            return;
        }
        int uncollectedGp = 0;
        int uncollectedItems = 0;
        switch (o.getState()) {
            case BUYING:
            case BOUGHT:
                uncollectedItems = isNewOffer(prev, o) ? o.getQuantitySold() : o.getQuantitySold() - prev.getQuantitySold();
                break;
            case SOLD:
            case SELLING:
                uncollectedGp = (isNewOffer(prev, o) ? o.getQuantitySold() : o.getQuantitySold() - prev.getQuantitySold()) * o.getPrice();
                break;
            case CANCELLED_BUY:
                uncollectedGp = (o.getTotalQuantity() - o.getQuantitySold()) * o.getPrice();
                break;
            case CANCELLED_SELL:
                uncollectedItems = o.getTotalQuantity() - o.getQuantitySold();
                break;
            case EMPTY:
                // if the slot is empty we want to ensure that the un collected manager doesn't think there is something to collect
                // this can happen due to race conditions between the collection and offer fills timing
                grandExchangeUncollectedManager.ensureSlotClear(accountHash, slot);
                suggestionManager.setSuggestionNeeded(true);
                return;
        }
        grandExchangeUncollectedManager.addUncollected(accountHash, slot, o.getItemId(), uncollectedItems, uncollectedGp);

    }

    private void processTransactions() {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        if(displayName != null) {
            Transaction transaction;
            while ((transaction = transactionsToProcess.poll()) != null) {
                long profit = transactionManager.addTransaction(transaction, displayName);
                if (grandExchange.isHomeScreenOpen() && profit != 0) {
                    new GpDropOverlay(overlayManager, client, profit, transaction.getBoxId());
                }
            }
        }
    }

    public Transaction inferTransaction(int slot, SavedOffer offer, SavedOffer prev, boolean consistent) {
        boolean login = client.getTickCount() <= osrsLoginManager.getLastLoginTick() + GE_LOGIN_BURST_WINDOW;
        boolean isNewOffer = isNewOffer(prev, offer);
        int quantityDiff = isNewOffer ? offer.getQuantitySold() : offer.getQuantitySold() - prev.getQuantitySold();
        int amountSpentDiff = isNewOffer ? offer.getSpent() : offer.getSpent() - prev.getSpent();
        if (quantityDiff > 0 && amountSpentDiff > 0) {
            Transaction t = new Transaction();
            t.setId(UUID.randomUUID());
            t.setType(offer.getOfferStatus());
            t.setItemId(offer.getItemId());
            t.setPrice(offer.getPrice());
            t.setQuantity(quantityDiff);
            t.setBoxId(slot);
            t.setAmountSpent(amountSpentDiff);
            t.setTimestamp(Instant.now());
            t.setCopilotPriceUsed(offer.isCopilotPriceUsed());
            t.setWasCopilotSuggestion(offer.isWasCopilotSuggestion());
            t.setOfferTotalQuantity(offer.getTotalQuantity());
            t.setLogin(login);
            t.setConsistent(consistent);
            return t;
        }
        return null;
    }

    private boolean isConsistent(SavedOffer prev, SavedOffer updated) {
        if(prev == null) {
            return false;
        }
        if(updated.getState() == GrandExchangeOfferState.EMPTY) {
            return true;
        }
        if(prev.getState() == GrandExchangeOfferState.EMPTY && !(updated.getState() == GrandExchangeOfferState.CANCELLED_BUY || updated.getState() == GrandExchangeOfferState.CANCELLED_SELL)) {
            return true;
        }
        return prev.getOfferStatus() == updated.getOfferStatus() ||
                prev.getItemId() == updated.getItemId()
                || prev.getPrice() == updated.getPrice()
                || prev.getTotalQuantity() == updated.getTotalQuantity();
    }

    private boolean isNewOffer(SavedOffer prev, SavedOffer updated) {
        if (prev == null) {
            return true;
        }
        return prev.getOfferStatus() != updated.getOfferStatus() ||
                prev.getItemId() != updated.getItemId()
                || prev.getPrice() != updated.getPrice()
                || prev.getTotalQuantity() != updated.getTotalQuantity()
                || prev.getQuantitySold() > updated.getQuantitySold()
                || prev.getSpent() > updated.getSpent();
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.*;
import com.flippingcopilot.ui.graph.PriceGraphController;
import com.flippingcopilot.ui.graph.model.Data;
import com.google.gson.Gson;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;

@Slf4j
@Getter
@Setter
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SuggestionController {

    // dependencies
    private final PausedManager pausedManager;
    private final Client client;
    private final Gson gson;
    private final OsrsLoginManager osrsLoginManager;
    private final HighlightController highlightController;
    private final GrandExchange grandExchange;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler apiRequestHandler;
    private final Notifier notifier;
    private final OfferManager offerManager;
    private final LoginResponseManager loginResponseManager;
    private final ClientThread clientThread;
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final AccountStatusManager accountStatusManager;
    private final GrandExchangeUncollectedManager uncollectedManager;
    private final PriceGraphController graphPriceGraphController;

    private MainPanel mainPanel;
    private LoginPanel loginPanel;
    private CopilotPanel copilotPanel;
    private SuggestionPanel suggestionPanel;

    public void togglePause() {
        if (pausedManager.isPaused()) {
            pausedManager.setPaused(false);
            suggestionManager.setSuggestionNeeded(true);
            suggestionPanel.refresh();
        } else {
            pausedManager.setPaused(true);
            highlightController.removeAll();
            suggestionPanel.refresh();
        }
    }

    void onGameTick() {
        if(suggestionManager.isSuggestionRequestInProgress() || suggestionManager.isGraphDataReadingInProgress()) {
            return;
        }
        // There is a race condition when the collect button is hit at the same time as offers fill.
        // In such a case we can end up with the uncollectedManager falsely thinking there is items to collect.
        // We identify if this has happened here by checking if the collect button is actually visible.
        if(isUncollectedOutOfSync()) {
            log.warn("uncollected is out of sync, it thinks there are items to collect but the GE is open and the Collect button not visible");
            uncollectedManager.clearAllUncollected(osrsLoginManager.getAccountHash());
            suggestionManager.setSuggestionNeeded(true);
        }
        // on initial login the state of the GE offers isn't correct we need to wait a couple ticks before requesting a suggestion
        if (osrsLoginManager.hasJustLoggedIn()) {
            return;
        }
        if ((suggestionManager.isSuggestionNeeded() || suggestionManager.suggestionOutOfDate()) && !(grandExchange.isSlotOpen() && !accountStatusManager.isSuggestionSkipped())) {
            getSuggestionAsync();
        }
    }

    private boolean isUncollectedOutOfSync() {
        if (client.getTickCount() <= uncollectedManager.getLastUncollectedAddedTick() + 2) {
            return false;
        }
        if(!grandExchange.isHomeScreenOpen() || grandExchange.isCollectButtonVisible()) {
            return false;
        }
        if(uncollectedManager.HasUncollected(osrsLoginManager.getAccountHash())) {
            return true;
        }
        if(suggestionPanel.isCollectItemsSuggested()) {
            return true;
        }
        return false;
    }

    public void getSuggestionAsync() {
        suggestionManager.setSuggestionNeeded(false);
        if (!loginResponseManager.isLoggedIn() || !osrsLoginManager.isValidLoginState()) {
            return;
        }
        if (suggestionManager.isSuggestionRequestInProgress()) {
            return;
        }
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if (accountStatus == null) {
            return;
        }
        suggestionManager.setSuggestionRequestInProgress(true);
        suggestionManager.setGraphDataReadingInProgress(true);
        Suggestion oldSuggestion = suggestionManager.getSuggestion();
        Consumer<Suggestion> suggestionConsumer = (newSuggestion) -> {
            suggestionManager.setSuggestion(newSuggestion);
            suggestionManager.setSuggestionError(null);
            suggestionManager.setSuggestionRequestInProgress(false);
            log.debug("Received suggestion: {}", newSuggestion.toString());
            accountStatusManager.resetSkipSuggestion();
            offerManager.setOfferJustPlaced(false);
            suggestionPanel.refresh();
            showNotifications(oldSuggestion, newSuggestion, accountStatus);
        };
        Consumer<Data> graphDataConsumer = (d) -> {
            graphPriceGraphController.setSuggestedItemGraphData(d);
            suggestionManager.setGraphDataReadingInProgress(false);
        };
        Consumer<HttpResponseException> onFailure = (e) -> {
            suggestionManager.setSuggestion(null);
            suggestionManager.setSuggestionError(e);
            suggestionManager.setSuggestionRequestInProgress(false);
            suggestionManager.setGraphDataReadingInProgress(false);
            if (e.getResponseCode() == 401) {
                loginResponseManager.reset();
                mainPanel.refresh();
                loginPanel.showLoginErrorMessage("Login timed out. Please log in again");
            } else {
                suggestionPanel.refresh();
            }
        };
        suggestionPanel.refresh();
        log.debug("tick {} getting suggestion", client.getTickCount());
        apiRequestHandler.getSuggestionAsync(accountStatus.toJson(gson, grandExchange.isOpen(), config.priceGraphWebsite() == FlippingCopilotConfig.PriceGraphWebsite.FLIPPING_COPILOT), suggestionConsumer, graphDataConsumer, onFailure);
    }


    void showNotifications(Suggestion oldSuggestion, Suggestion newSuggestion, AccountStatus accountStatus) {
        if (shouldNotify(newSuggestion, oldSuggestion)) {
            if (config.enableTrayNotifications()) {
                notifier.notify(newSuggestion.toMessage());
            }
            if (!copilotPanel.isShowing() && config.enableChatNotifications()) {
                showChatNotifications(newSuggestion, accountStatus);
            }
        }
    }

    static boolean shouldNotify(Suggestion newSuggestion, Suggestion oldSuggestion) {
        if (newSuggestion.getType().equals("wait")) {
            return false;
        }
        if (oldSuggestion != null && newSuggestion.equals(oldSuggestion)) {
            return false;
        }
        return true;
    }

    private void showChatNotifications(Suggestion newSuggestion, AccountStatus accountStatus) {
        if (accountStatus.isCollectNeeded(newSuggestion)) {
            clientThread.invokeLater(() -> showChatNotification("Flipping Copilot: Collect items"));
        }
        clientThread.invokeLater(() -> showChatNotification(newSuggestion.toMessage()));
    }

    private void showChatNotification(String message) {
        String chatMessage = new ChatMessageBuilder()
                .append(config.chatTextColor(), message)
                .build();
        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", chatMessage, "");
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.SuggestionManager;
import net.runelite.api.Client;
import net.runelite.api.VarClientInt;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.event.KeyEvent;


@Singleton
public class KeybindHandler {

    private final KeyManager keyManager;
    private final FlippingCopilotConfig config;
    private final ClientThread clientThread;
    private final SuggestionManager suggestionManager;
    private final Client client;
    private final GrandExchange grandExchange;
    private final OfferHandler offerHandler;


    @Inject
    public KeybindHandler(KeyManager keyManager, FlippingCopilotConfig config, ClientThread clientThread, SuggestionManager suggestionManager, Client client, GrandExchange grandExchange, OfferHandler offerHandler) {
        this.keyManager = keyManager;
        this.config = config;
        this.clientThread = clientThread;
        this.suggestionManager = suggestionManager;
        this.client = client;
        this.grandExchange = grandExchange;
        this.offerHandler = offerHandler;
        keyManager.registerKeyListener(offerEditorKeyListener());
    }

    public void unregister() {
        keyManager.unregisterKeyListener(offerEditorKeyListener());
    }


    private KeyListener offerEditorKeyListener() {
        return new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {
                // Prevent enter as a keybind as that will also submit the value
                if (e.getKeyCode() == KeyEvent.VK_ENTER) return;
                if (e.getKeyCode() !=config.quickSetKeybind().getKeyCode()) return;

               clientThread.invokeLater(this::handleKeybind);
            }

            @Override
            public void keyReleased(KeyEvent e) {

            }

            private void handleKeybind() {
                var suggestion = suggestionManager.getSuggestion();

                var inputType = client.getVarcIntValue(VarClientInt.INPUT_TYPE);

                var isPriceOrQuantityBoxOpen =client.getWidget(ComponentID.CHATBOX_TITLE) != null
                        && inputType == 7
                        &&client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) != null
                        &&grandExchange.isSlotOpen();

                if (isPriceOrQuantityBoxOpen) {
                   offerHandler.setSuggestedAction(suggestion);
                }
            }
        };
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.graph.model.Data;
import com.google.gson.*;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Type;
import java.net.URLEncoder;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class ApiRequestHandler {

    private static final String serverUrl = System.getenv("FLIPPING_COPILOT_HOST") != null ? System.getenv("FLIPPING_COPILOT_HOST")  : "https://api.flippingcopilot.com";
    public static final String DEFAULT_COPILOT_PRICE_ERROR_MESSAGE = "Unable to fetch price copilot price (possible server update)";
    public static final String DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE = "Error loading premium instance data (possible server update)";


    // dependencies
    private final OkHttpClient client;
    private final Gson gson;
    private final LoginResponseManager loginResponseManager;
    private final SuggestionPreferencesManager preferencesManager;
    private final ClientThread clientThread;

    // state
    private Instant lastDebugMessageSent = Instant.now();


    public void authenticate(String username, String password, Runnable callback) {
        Request request = new Request.Builder()
                .url(serverUrl + "/login")
                .addHeader("Authorization", Credentials.basic(username, password))
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), ""))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.run();
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        log.warn("login failed with http status code {}", response.code());
                    }
                    String body = response.body() == null ? "" : response.body().string();
                    LoginResponse loginResponse = gson.fromJson(body, LoginResponse.class);
                    loginResponseManager.setLoginResponse(loginResponse);
                } catch (IOException e) {
                    log.warn("error reading/decoding login response body", e);
                } catch (JsonParseException e) {
                    loginResponseManager.setLoginResponse(new LoginResponse(true, response.message(), null, -1));
                } finally {
                    callback.run();
                }
            }
        });
    }

    public void getSuggestionAsync(JsonObject status,
                                   Consumer<Suggestion> suggestionConsumer,
                                   Consumer<Data> graphDataConsumer,
                                   Consumer<HttpResponseException>  onFailure) {
        log.debug("sending status {}", status.toString());
        Request request = new Request.Builder()
                .url(serverUrl + "/suggestion")
                .addHeader("Authorization", "Bearer " + loginResponseManager.getJwtToken())
                .addHeader("Accept", "application/x-msgpack")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), status.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("call to get suggestion failed", e);
                clientThread.invoke(() -> onFailure.accept(new HttpResponseException(-1, "Unknown Error")));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        log.warn("get suggestion failed with http status code {}", response.code());
                        clientThread.invoke(() -> onFailure.accept(new HttpResponseException(response.code(), extractErrorMessage(response))));
                        return;
                    }
                    handleSuggestionResponse(response, suggestionConsumer, graphDataConsumer);
                } catch (Exception e) {
                    log.warn("error reading/parsing suggestion response body", e);
                    clientThread.invoke(() -> onFailure.accept(new HttpResponseException(-1, "Unknown Error")));
                }
            }
        });
    }

    private void handleSuggestionResponse(Response response, Consumer<Suggestion> suggestionConsumer, Consumer<Data> graphDataConsumer) throws IOException {
        if (response.body() == null) {
            throw new IOException("empty suggestion request response");
        }
        String contentType = response.header("Content-Type");
        Suggestion s;
        if (contentType != null && contentType.contains("application/x-msgpack")) {
            int contentLength = resolveContentLength(response);
            int suggestionContentLength = resolveSuggestionContentLength(response);
            int graphDataContentLength = contentLength - suggestionContentLength;
            log.debug("msgpack suggestion response size is: {}, suggestion size is {}", contentLength, suggestionContentLength);

            Data d = new Data();
            try(InputStream is = response.body().byteStream()) {
                // This is some bespoke handling to make the user experience better. We basically pack two different
                // objects in the response body. The suggestion (first object) and the graph data (second
                // object). The graph data can be a few kb, and we want the suggestion to be displayed
                // immediately, without having to wait for the graph data to be loaded.

                byte[] suggestionBytes = new byte[suggestionContentLength];
                int bytesRead = is.readNBytes(suggestionBytes, 0, suggestionContentLength);
                if (bytesRead != suggestionContentLength) {
                    throw new IOException("failed to read complete suggestion content: " + bytesRead + " of " + suggestionContentLength + " bytes");
                }
                s = Suggestion.fromMsgPack(ByteBuffer.wrap(suggestionBytes));
                log.debug("suggestion received");
                clientThread.invoke(() -> suggestionConsumer.accept(s));

                if (graphDataContentLength == 0) {
                    d.loadingErrorMessage = "No graph data loaded for this item.";
                } else {
                    try {
                        byte[] remainingBytes = is.readAllBytes();
                        if (graphDataContentLength != remainingBytes.length) {
                            log.error("the graph data bytes read {} doesn't match the expected bytes {}", bytesRead, graphDataContentLength);
                            d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                        } else {
                            try {
                                d = Data.fromMsgPack(ByteBuffer.wrap(remainingBytes));
                                log.debug("graph data received");
                            } catch (Exception e) {
                                log.error("error deserializing graph data", e);
                                d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                            }
                        }
                    } catch (IOException e) {
                        log.error("error on reading graph data bytes from the suggestion response", e);
                        d.loadingErrorMessage = "There was an issue loading the graph data for this item.";
                    }
                }
            }
            if (s != null && "wait".equals(s.getType())){
                d.fromWaitSuggestion = true;
            }
            Data finalD = d;
            clientThread.invoke(() -> graphDataConsumer.accept(finalD));
        } else {
            String body = response.body().string();
            log.debug("json suggestion response size is: {}", body.getBytes().length);
            s = gson.fromJson(body, Suggestion.class);
            clientThread.invoke(() -> suggestionConsumer.accept(s));
            Data d = new Data();
            d.loadingErrorMessage = "No graph data loaded for this item.";
            clientThread.invoke(() -> graphDataConsumer.accept(d));
        }
    }

    private int resolveContentLength(Response resp) throws IOException {
        try {
            String cl = resp.header("Content-Length");
            return Integer.parseInt(cl != null ? cl : "missing Content-Length header");
        } catch (NumberFormatException  e) {
            throw new IOException("Failed to parse response Content-Length", e);
        }
    }

    private int resolveSuggestionContentLength(Response resp) throws IOException {
        try {
            String cl = resp.header("X-Suggestion-Content-Length");
            return Integer.parseInt(cl != null ? cl : "missing Content-Length header");
        } catch (NumberFormatException  e) {
            throw new IOException("Failed to parse response Content-Length", e);
        }
    }

    public void sendTransactionsAsync(List<Transaction> transactions, String displayName, Consumer<List<FlipV2>> onSuccess, Consumer<HttpResponseException> onFailure) {
        log.debug("sending {} transactions for display name {}", transactions.size(), displayName);
        JsonArray body = new JsonArray();
        for (Transaction transaction : transactions) {
            body.add(transaction.toJsonObject());
        }
        String encodedDisplayName = URLEncoder.encode(displayName, StandardCharsets.UTF_8);
        Request request = new Request.Builder()
                .url(serverUrl + "/profit-tracking/client-transactions?display_name=" + encodedDisplayName)
                .addHeader("Authorization", "Bearer " + loginResponseManager.getJwtToken())
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("call to sync transactions failed", e);
                onFailure.accept(new HttpResponseException(-1, "Unknown Error"));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        String errorMessage = extractErrorMessage(response);
                        log.warn("call to sync transactions failed status code {}, error message {}", response.code(), errorMessage);
                        onFailure.accept(new HttpResponseException(response.code(), errorMessage));
                        return;
                    }
                    String body = response.body() == null ? "" : response.body().string();
                    List<FlipV2> changedFlips = gson.fromJson(body, new TypeToken<List<FlipV2>>(){}.getType());
                    onSuccess.accept(changedFlips);
                } catch (IOException | JsonParseException e) {
                    log.warn("error reading/parsing sync transactions response body", e);
                    onFailure.accept(new HttpResponseException(-1, "Unknown Error"));
                }
            }
        });
    }

    private String extractErrorMessage(Response response) {
        if (response.body() != null) {
            try {
                String bodyStr = response.body().string();
                JsonObject errorJson = gson.fromJson(bodyStr, JsonObject.class);
                if (errorJson.has("message")) {
                    return errorJson.get("message").getAsString();
                }
            } catch (JsonSyntaxException | IOException e) {
                log.warn("failed reading/parsing error message from http {} response body", response.code(), e);
            }
        }
        return "Unknown Error";
    }

    public void asyncGetItemPriceWithGraphData(int itemId, String displayName, Consumer<ItemPrice> consumer, boolean includeGraphData) {
        JsonObject body = new JsonObject();
        body.add("item_id", new JsonPrimitive(itemId));
        body.add("display_name", new JsonPrimitive(displayName));
        body.addProperty("f2p_only", preferencesManager.getPreferences().isF2pOnlyMode());
        body.addProperty("timeframe_minutes", preferencesManager.getTimeframe());
        body.addProperty("include_graph_data", includeGraphData);
        log.debug("requesting price graph data for item {}", itemId);
        Request request = new Request.Builder()
                .url(serverUrl +"/prices")
                .addHeader("Authorization", "Bearer " + loginResponseManager.getJwtToken())
                .addHeader("Accept", "application/x-msgpack")
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), body.toString()))
                .build();

        client.newBuilder()
                .callTimeout(30, TimeUnit.SECONDS) // Overall timeout
                .build()
                .newCall(request)
                .enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error fetching copilot price for item {}", itemId, e);
                ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                clientThread.invoke(() -> consumer.accept(ip));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        log.error("get copilot price for item {} failed with http status code {}", itemId, response.code());
                        ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                        clientThread.invoke(() -> consumer.accept(ip));
                    } else {
                        byte[] d = response.body().bytes();
                        ItemPrice ip = ItemPrice.fromMsgPack(ByteBuffer.wrap(d));
                        log.debug("price graph data received for item {}", itemId);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error fetching copilot price for item {}", itemId, e);
                    ItemPrice ip = new ItemPrice(0, 0, DEFAULT_COPILOT_PRICE_ERROR_MESSAGE, null);
                    clientThread.invoke(() -> consumer.accept(ip));
                }
            }
        });
    }


    public void asyncUpdatePremiumInstances(Consumer<PremiumInstanceStatus> consumer, List<String> displayNames) {
        JsonObject payload = new JsonObject();
        JsonArray arr = new JsonArray();
        displayNames.forEach(arr::add);
        payload.add("premium_display_names", arr);

        Request request = new Request.Builder()
                .url(serverUrl +"/premium-instances/update-assignments")
                .addHeader("Authorization", "Bearer " + loginResponseManager.getJwtToken())
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), payload.toString()))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error updating premium instance assignments", e);
                clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        log.error("update premium instances failed with http status code {}", response.code());
                        clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                    } else {
                        PremiumInstanceStatus ip = gson.fromJson(response.body().string(), PremiumInstanceStatus.class);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error updating premium instance assignments", e);
                    clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                }
            }
        });
    }

    public void asyncGetPremiumInstanceStatus(Consumer<PremiumInstanceStatus> consumer) {
        Request request = new Request.Builder()
                .url(serverUrl +"/premium-instances/status")
                .addHeader("Authorization", "Bearer " + loginResponseManager.getJwtToken())
                .get()
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.error("error fetching premium instance status", e);
                clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    if (!response.isSuccessful()) {
                        log.error("get premium instance status failed with http status code {}", response.code());
                        clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                    } else {
                        PremiumInstanceStatus ip = gson.fromJson(response.body().string(), PremiumInstanceStatus.class);
                        clientThread.invoke(() -> consumer.accept(ip));
                    }
                } catch (Exception e) {
                    log.error("error fetching premium instance status", e);
                    clientThread.invoke(() -> consumer.accept(PremiumInstanceStatus.ErrorInstance(DEFAULT_PREMIUM_INSTANCE_ERROR_MESSAGE)));
                }
            }
        });
    }

    public ItemPrice getItemPrice(int itemId, String displayName) {
        JsonObject respObj = null;
        try {
            JsonObject body = new JsonObject();
            body.add("item_id", new JsonPrimitive(itemId));
            body.add("display_name", new JsonPrimitive(displayName));
            body.addProperty("f2p_only", preferencesManager.getPreferences().isF2pOnlyMode());
            body.addProperty("timeframe_minutes", preferencesManager.getTimeframe());
            return doHttpRequest("POST", body, "/prices", ItemPrice.class);
        } catch (HttpResponseException e) {
            log.error("error fetching copilot price for item {}, resp code {}", itemId, e.getResponseCode(), e);
            return new ItemPrice(0, 0, "Unable to fetch price copilot price (possible server update)", null);
        }
    }

    public Map<String, Integer> loadUserDisplayNames() throws HttpResponseException {
        Type respType = new TypeToken<Map<String, Integer>>(){}.getType();
        Map<String, Integer> names = doHttpRequest("GET", null, "/profit-tracking/rs-account-names", respType);
        return names == null ? new HashMap<>() : names;
    }

    public List<FlipV2> LoadFlips() throws HttpResponseException {
        Type respType = new TypeToken<List<FlipV2>>(){}.getType();
        List<FlipV2> flips = doHttpRequest("GET", null, "/profit-tracking/client-flips", respType);
        return flips == null ? new ArrayList<>() : flips;
    }

    public <T> T doHttpRequest(String method, JsonElement bodyJson, String route, Type responseType) throws HttpResponseException {
        String jwtToken = loginResponseManager.getJwtToken();
        if (jwtToken == null) {
            throw new IllegalStateException("Not authenticated");
        }

        RequestBody body = bodyJson == null ? null : RequestBody.create(MediaType.get("application/json; charset=utf-8"), bodyJson.toString());
        Request request = new Request.Builder()
                .url(serverUrl + route)
                .addHeader("Authorization", "Bearer " + jwtToken)
                .method(method, body)
                .build();

        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                if (responseType == Void.class || response.body() == null) {
                    return null;
                }
                String responseBody = response.body().string();
                return gson.fromJson(responseBody, responseType);
            } else {
                throw new HttpResponseException(response.code(), extractErrorMessage(response));
            }
        } catch (JsonSyntaxException | IOException e) {
            throw new HttpResponseException(-1, "Unknown server error (possible system update)", e);
        }
    }

    public void sendDebugData(JsonObject bodyJson) {
        String jwtToken = loginResponseManager.getJwtToken();
        Instant now = Instant.now();
        if (now.minusSeconds(5).isBefore(lastDebugMessageSent)){
            // we don't want to spam
            return;
        }
        RequestBody body = RequestBody.create(MediaType.get("application/json; charset=utf-8"), bodyJson.toString());
        Request request = new Request.Builder()
                .url(serverUrl + "/debug-data")
                .addHeader("Authorization", "Bearer " + jwtToken)
                .method("POST", body)
                .build();
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
               log.debug("failed to send debug data", e);
            }
            @Override
            public void onResponse(Call call, Response response) {}
        });
        lastDebugMessageSent = Instant.now();
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.DiscordWebhookBody;
import com.flippingcopilot.model.SessionData;
import com.flippingcopilot.model.Stats;
import com.flippingcopilot.ui.UIUtilities;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.time.Instant;

import static com.flippingcopilot.ui.FlipPanel.formatEpoch;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class WebHookController {

    private final FlippingCopilotConfig config;
    private final OkHttpClient okHttpClient;

    private void sendWebHook(DiscordWebhookBody discordWebhookBody) {
        String configURL = config.webhook();
        if (Strings.isNullOrEmpty(configURL)) {return; }

        HttpUrl url = HttpUrl.parse(configURL);
        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(discordWebhookBody));
        buildRequestAndSend(url, requestBodyBuilder);
    }

    private void buildRequestAndSend(HttpUrl url, MultipartBody.Builder requestBodyBuilder) {
        RequestBody requestBody = requestBodyBuilder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
        sendRequest(request);
    }

    private void sendRequest(Request request) {
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Error on webhook", e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                response.close();
            }
        });
    }

    public void sendMessage(Stats stats, SessionData sd, String displayName, boolean sessionIsFinished) {
        if (stats.profit != 0 && displayName != null) {

            long seconds = sd.durationMillis / 1000;
            String beganAtText = formatEpoch(sd.startTime);
            String endedAtText = sessionIsFinished ? formatEpoch(Instant.now().getEpochSecond()) : "n/a";
            String durationText = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            String profitText = UIUtilities.formatProfit(stats.profit);
            String taxText = UIUtilities.formatProfit(stats.taxPaid);
            String roiText = String.format("%.3f%%", stats.calculateRoi() * 100);
            String cashStackText = UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp";

            String template = "%s, your session stats are:\n" +
                    "```" +
                    "Session began at:      %s\n" +
                    "Session ended at:      %s\n" +
                    "Active session time:   %s\n" +
                    "Flips made:            %d\n" +
                    "Profit:                %s\n" +
                    "Tax paid:              %s\n" +
                    "Roi:                   %s\n" +
                    "Avg wealth:            %s\n" +
                    "```";

            String discordMessage = String.format(template, displayName, beganAtText, endedAtText, durationText, stats.flipsMade, profitText, taxText, roiText, cashStackText);
            DiscordWebhookBody discordWebhookBody = new DiscordWebhookBody();
            discordWebhookBody.setContent(discordMessage);
            sendWebHook(discordWebhookBody);
        }
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.util.MutableReference;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class TransactionManger {

    // dependencies
    private final FlipManager flipManager;
    private final ScheduledExecutorService executorService;
    private final ApiRequestHandler api;
    private final LoginResponseManager loginResponseManager;
    private final OsrsLoginManager osrsLoginManager;

    // state
    private final ConcurrentMap<String, List<Transaction>> cachedUnAckedTransactions = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, AtomicBoolean> transactionSyncScheduled = new ConcurrentHashMap<>();

    public void syncUnAckedTransactions(String displayName) {

        long s = System.nanoTime();
        List<Transaction> toSend;
        synchronized (this) {
            toSend = new ArrayList<>(getUnAckedTransactions(displayName));
            if(toSend.isEmpty()) {
                transactionSyncScheduled.get(displayName).set(false);
                return;
            }
        }

        Consumer<List<FlipV2>> onSuccess = (flips) -> {
            for (FlipV2 f : flips) {
                log.debug("server updated flip for {} closed qty {}, profit {}", f.getItemName(), f.getClosedQuantity(), f.getProfit());
            }
            flipManager.mergeFlips(flips, displayName);
            log.info("sending {} transactions took {}ms", toSend.size(), (System.nanoTime() - s) / 1000_000);
            synchronized (this) {
                List<Transaction> unAckedTransactions  = getUnAckedTransactions(displayName);
                transactionSyncScheduled.get(displayName).set(false);
                toSend.forEach(unAckedTransactions::remove);
                if(!unAckedTransactions.isEmpty()) {
                    scheduleSyncIn(0, displayName);
                }
            }
        };

        Consumer<HttpResponseException> onFailure = (e) -> {
            synchronized (this) {
                transactionSyncScheduled.get(displayName).set(false);
            }
            String currentDisplayName = osrsLoginManager.getPlayerDisplayName();
            if (loginResponseManager.isLoggedIn() && (currentDisplayName == null || currentDisplayName.equals(displayName))) {
                log.warn("failed to send transactions to copilot server {}", e.getMessage(), e);
                scheduleSyncIn(10, displayName);
            }
        };
        api.sendTransactionsAsync(toSend, displayName, onSuccess, onFailure);
    }

    public long addTransaction(Transaction transaction, String displayName) {
        synchronized (this) {
            List<Transaction> unAckedTransactions = getUnAckedTransactions(displayName);
            unAckedTransactions.add(transaction);
            Persistance.storeUnAckedTransactions(unAckedTransactions, displayName);
        }
        MutableReference<Long> profit = new MutableReference<>(0L);
        if (OfferStatus.SELL.equals(transaction.getType())) {
            profit.setValue(flipManager.estimateTransactionProfit(displayName, transaction));
        }
        if (loginResponseManager.isLoggedIn()) {
            scheduleSyncIn(0, displayName);
        }
        return profit.getValue();
    }

    private List<Transaction> getUnAckedTransactions(String displayName) {
        return cachedUnAckedTransactions.computeIfAbsent(displayName, (k) -> Persistance.loadUnAckedTransactions(displayName));
    }

    public synchronized void scheduleSyncIn(int seconds, String displayName) {
        AtomicBoolean scheduled = transactionSyncScheduled.computeIfAbsent(displayName, k -> new AtomicBoolean(false));
        if(scheduled.compareAndSet(false, true)) {
            log.info("scheduling {} attempt to sync {} transactions in {}s", displayName, getUnAckedTransactions(displayName).size(), seconds);
            executorService.schedule(() ->  {
                this.syncUnAckedTransactions(displayName);
            }, seconds, TimeUnit.SECONDS);
        } else {
            log.debug("skipping scheduling sync as already scheduled");
        }
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.*;

import java.nio.ByteBuffer;
import java.text.NumberFormat;

@Getter
@AllArgsConstructor
@ToString
@NoArgsConstructor
public class Suggestion {
    private String type;
    @SerializedName("box_id")
    private int boxId;
    @SerializedName("item_id")
    private int itemId;
    private int price;
    private int quantity;
    private String name;
    @SerializedName("command_id")
    private int id;
    private String message;

    @SerializedName("graph_data")
    @Setter
    private Data graphData;


    public boolean equals(Suggestion other) {
        return this.type.equals(other.type)
                && this.boxId == other.boxId
                && this.itemId == other.itemId
                && this.name.equals(other.name);
    }

    public String toMessage() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String string = "Flipping Copilot: ";
        switch (type) {
            case "buy":
                string += String.format("Buy %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "sell":
                string += String.format("Sell %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "abort":
                string += "Abort " + name;
                break;
            case "wait":
                string += "Wait";
                break;
            default:
                string += "Unknown suggestion type";
                break;
        }
        return string;
    }

    public static Suggestion fromMsgPack(ByteBuffer b) {
        Suggestion s = new Suggestion();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }

        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "t":
                    s.type = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "b":
                    s.boxId = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "i":
                    s.itemId = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "p":
                    s.price = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "q":
                    s.quantity = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "n":
                    s.name = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "id":
                    s.id = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "m":
                    s.message = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "gd":
                    s.graphData = Data.fromMsgPack(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }

        return s;
    }
}



package com.flippingcopilot.model;
import com.flippingcopilot.util.Constants;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;


// note: we synchronize all public methods of this class as they read/modify its state and may
// be called by multiple threads at the same time

@Slf4j
@Data
public class AccountStatus {

    private StatusOfferList offers;
    private Inventory inventory;
    private Map<Integer, Long> uncollected;
    private boolean isMember = false;
    private int skipSuggestion = -1;
    private String displayName;
    private Long rsAccountHash;
    private Boolean suggestionsPaused;
    private boolean sellOnlyMode = false;
    private boolean f2pOnlyMode = false;
    private List<Integer> blockedItems;
    private int timeframe = 5; // Default to 5 minutes

    public AccountStatus() {
        offers = new StatusOfferList();
        inventory = new Inventory();
    }

    public synchronized boolean isCollectNeeded(Suggestion suggestion) {
        if (offers.isEmptySlotNeeded(suggestion)) {
            log.debug("collected needed isEmptySlotNeeded");
            return true;
        }
        if (!inventory.hasSufficientGp(suggestion)) {
            log.debug("collected needed hasSufficientGp");
            return true;
        }
        if (!inventory.hasSufficientItems(suggestion)) {
            log.debug("collected needed hasSufficientItems");
            return true;
        }
        return false;
    }

    public synchronized JsonObject toJson(Gson gson, boolean geOpen, boolean sendGraphData) {
        JsonObject statusJson = new JsonObject();
        statusJson.addProperty("timeframe", 5);
        statusJson.addProperty("display_name", displayName);
        statusJson.addProperty("sell_only", sellOnlyMode);
        statusJson.addProperty("f2p_only", f2pOnlyMode);
        statusJson.addProperty("is_member", isMember);
        statusJson.addProperty("skip_suggestion", skipSuggestion);
        statusJson.addProperty("send_graph_data", sendGraphData);
        statusJson.addProperty("timeframe", timeframe);
        if (suggestionsPaused != null) {
            statusJson.addProperty("suggestions_paused", suggestionsPaused);
        }
        JsonArray offersJsonArray = offers.toJson(gson);
        JsonArray itemsJsonArray = getItemsJson();
        statusJson.add("offers", offersJsonArray);
        statusJson.add("items", itemsJsonArray);
        JsonArray blockItemsArray = new JsonArray();
        if(blockedItems != null) {
            blockedItems.forEach(blockItemsArray::add);
        }
        statusJson.add("blocked_items", blockItemsArray);

        Set<String> requestedSuggestionTypes = new HashSet<>();
        if (!geOpen) {
            requestedSuggestionTypes.add("abort");
            requestedSuggestionTypes.add("sell");
        }
        if(sellOnlyMode) {
            requestedSuggestionTypes.clear();
            requestedSuggestionTypes.add("abort");
            requestedSuggestionTypes.add("sell");
        }
        if(!requestedSuggestionTypes.isEmpty()) {
           JsonArray rstArray = new JsonArray();
           requestedSuggestionTypes.forEach(rstArray::add);
           statusJson.add("requested_suggestion_types", rstArray);
        }
        return statusJson;
    }

    private JsonArray getItemsJson() {
        Map<Integer, Long> itemsAmount = getItemAmounts();
        JsonArray itemsJsonArray = new JsonArray();
        for(Map.Entry<Integer, Long> entry : itemsAmount.entrySet()) {
            JsonObject itemJson = new JsonObject();
            itemJson.addProperty("item_id", entry.getKey());
            itemJson.addProperty("amount", entry.getValue());
            itemsJsonArray.add(itemJson);
        }
        return itemsJsonArray;
    }

    private Map<Integer, Long> getItemAmounts() {
        Map<Integer, Long> itemsAmount = inventory.getItemAmounts();
        uncollected.forEach((key, value) -> itemsAmount.merge(key, value, Long::sum));
        itemsAmount.entrySet().removeIf(entry -> entry.getValue() == 0);
        return itemsAmount;
    }

    public synchronized boolean moreGpNeeded() {
        return offers.emptySlotExists() && getTotalGp() < Constants.MIN_GP_NEEDED_TO_FLIP;
    }

    public synchronized boolean emptySlotExists() {
        return offers.emptySlotExists();
    }

    private long getTotalGp() {
        return inventory.getTotalGp() + offers.getTotalGpToCollect();
    }

    public synchronized boolean currentlyFlipping() {
        return offers.stream().anyMatch(Offer::isActive);
    }

    public synchronized long currentCashStack() {
        // the cash stack is the gp in their inventory + the value on the market
        // todo: when a buy offer has fully finished its value will not count towards the cash stack
        //  size until they start selling it. We should probably track items that where recently bought
        //  and they should still count towards the cash stack size for some period of time
        return offers.getGpOnMarket() + inventory.getTotalGp();
    }
}

package com.flippingcopilot.model;

import lombok.Getter;

import java.io.IOException;

@Getter
public class HttpResponseException extends IOException {
    private final int responseCode;
    private final String responseMessage;

    public HttpResponseException(int responseCode, String message) {
        super(message);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }

    public HttpResponseException(int responseCode, String message, Throwable cause) {
        super(message, cause);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }
}
package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.ui.FuzzySearchScorer;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SuggestionPreferencesManager {

    private static final String SHARED_PREFERENCES_FILE = "shared_preferences.json";

    // dependencies
    private final Gson gson;
    private final FuzzySearchScorer fuzzySearchScorer;
    private final Client client;
    private final ItemManager itemManager;
    private final ScheduledExecutorService executorService;

    // state
    private SuggestionPreferences sharedPreferences;
    
    public synchronized SuggestionPreferences getPreferences() {
        if (sharedPreferences == null) {
            sharedPreferences = load();
        }
        return sharedPreferences;
    }

    public synchronized void setSellOnlyMode(boolean sellOnlyMode) {
        SuggestionPreferences preferences = getPreferences();
        preferences.setSellOnlyMode(sellOnlyMode);
        saveAsync();
        log.debug("Sell only mode is now: {}", sellOnlyMode);
    }

    public synchronized void setF2pOnlyMode(boolean f2pOnlyMode) {
        SuggestionPreferences preferences = getPreferences();
        preferences.setF2pOnlyMode(f2pOnlyMode);
        saveAsync();
        log.debug("F2p only mode is now: {}", f2pOnlyMode);
    }

    public synchronized void setTimeframe(int minutes) {
        SuggestionPreferences preferences = getPreferences();
        preferences.setTimeframe(minutes);
        saveAsync();
        log.debug("Timeframe is now: {} minutes", minutes);
    }

    public synchronized int getTimeframe() {
        return getPreferences().getTimeframe();
    }

    public synchronized void blockItem(int itemId) {
        SuggestionPreferences preferences = getPreferences();
        List<Integer> blockedList = preferences.getBlockedItemIds();
        if(blockedList == null) {
            blockedList = new ArrayList<>();
        }
        if(!blockedList.contains(itemId)) {
            blockedList.add(itemId);
        }
        preferences.setBlockedItemIds(blockedList);
        saveAsync();
        log.debug("blocked item {}", itemId);
    }

    public synchronized void unblockItem(int itemId) {
        SuggestionPreferences preferences = getPreferences();
        List<Integer> blockedList = preferences.getBlockedItemIds();
        if(blockedList == null) {
            blockedList = new ArrayList<>();
        }
        blockedList.removeIf(i -> i==itemId);
        preferences.setBlockedItemIds(blockedList);
        saveAsync();
        log.debug("unblocked item {}", itemId);
    }

    public List<Pair<Integer, String>> search(String input) {
        Set<Integer> blockedItems = new HashSet<>(blockedItems());
        if(input == null || input.isBlank()) {
            return IntStream.range(0, client.getItemCount())
                    .mapToObj(itemManager::getItemComposition)
                    .filter(item -> item.isTradeable() && item.getNote() == -1)
                    .sorted(Comparator.comparing((ItemComposition i) -> !blockedItems.contains(i.getId())).thenComparing(ItemComposition::getName))
                    .limit(250)
                    .map((i) -> Pair.of(i.getId(), trimName(i.getName())))
                    .collect(Collectors.toList());
        }

        ToDoubleFunction<ItemComposition> comparator = fuzzySearchScorer.comparator(input);
        return IntStream.range(0, client.getItemCount())
            .mapToObj(itemManager::getItemComposition)
            .filter(item -> item.isTradeable() && item.getNote() == -1)
            .filter(item -> comparator.applyAsDouble(item) > 0)
            .sorted(Comparator.comparing((ItemComposition i) -> !blockedItems.contains(i.getId())).thenComparing(Comparator.comparingDouble(comparator).reversed()
                    .thenComparing(ItemComposition::getName)))
            .limit(250)
            .map((i) -> Pair.of(i.getId(), trimName(i.getName())))
            .collect(Collectors.toList());
    }

    public List<Integer> blockedItems() {
        return getPreferences().getBlockedItemIds();
    }

    private String trimName(String name) {
        if(name.length() > 23) {
            return name.substring(0, 23) + "..";
        }
        return name;
    }

    private SuggestionPreferences load() {
        File file = getSharedFile();
        if (!file.exists()) {
            SuggestionPreferences merged = mergeExistingPreferences();
            sharedPreferences = merged;
            saveAsync();
            return merged;
        }
        
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, SuggestionPreferences.class);
        } catch (FileNotFoundException ignored) {
            return new SuggestionPreferences();
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading preferences json file {}", file, e);
            return new SuggestionPreferences();
        }
    }

    private SuggestionPreferences mergeExistingPreferences() {
        SuggestionPreferences mergedPreferences = new SuggestionPreferences();
        Set<Integer> mergedBlockedItems = new HashSet<>();

        File parentDir = Persistance.PARENT_DIRECTORY;
        if (!parentDir.exists()) {
            return mergedPreferences;
        }

        File[] files = parentDir.listFiles((dir, name) -> name.matches("acc_-?\\d+_preferences\\.json"));
        if (files != null) {
            for (File file : files) {
                try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                    SuggestionPreferences accountPrefs = gson.fromJson(reader, SuggestionPreferences.class);
                    if (accountPrefs != null && accountPrefs.getBlockedItemIds() != null) {
                        mergedBlockedItems.addAll(accountPrefs.getBlockedItemIds());
                    }
                } catch (Exception e) {
                    log.warn("Error reading preferences file {} during merge", file, e);
                }
            }
        }

        mergedPreferences.setBlockedItemIds(new ArrayList<>(mergedBlockedItems));
        log.info("Merged preferences from {} existing account files", files != null ? files.length : 0);
        return mergedPreferences;
    }

    private void saveAsync() {
        executorService.submit(() -> {
            File file = getSharedFile();
            synchronized (file) {
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(sharedPreferences);
                    writer.write(json);
                    writer.newLine();
                } catch (IOException e) {
                    log.warn("error saving preferences json file {}", file, e);
                }
            }
        });
    }

    private File getSharedFile() {
        return new File(Persistance.PARENT_DIRECTORY, SHARED_PREFERENCES_FILE);
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class SessionManager {

    public static final String SESSION_DATA_FILE_TEMPLATE = "%s_session_data.jsonl";

    private final OsrsLoginManager osrsLoginManager;
    private final ScheduledExecutorService executorService;
    private final Gson gson;

    private final Map<String, SessionData> cachedSessionData =  new HashMap<>();
    private final Map<String, File> displayNameToFile = new HashMap<>();

    private Instant lastSessionUpdateTime;

    public synchronized SessionData getCachedSessionData() {
        SessionData sd = getSessionData(osrsLoginManager.getPlayerDisplayName());
        return new SessionData(sd.startTime,  sd.durationMillis, sd.averageCash);
    }

    public synchronized void resetSession() {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        SessionData sd = getSessionData(displayName);
        sd.startTime = (int) Instant.now().getEpochSecond();
        sd.averageCash = 0;
        sd.durationMillis = 0;
        saveAsync(displayName);
    }

    public synchronized boolean updateSessionStats(boolean currentlyFlipping, long cashStack) {
        String displayName = osrsLoginManager.getPlayerDisplayName();
        if (!currentlyFlipping || displayName == null) {
            lastSessionUpdateTime = null;
            return false;
        } else if (lastSessionUpdateTime == null) {
            lastSessionUpdateTime = Instant.now();
            return false;
        } else {
            SessionData sd = getSessionData(displayName);
            Instant now = Instant.now();
            long duration = Duration.between(lastSessionUpdateTime, now).toMillis();
            long newAverageCashStack = (cashStack * duration + sd.durationMillis * sd.averageCash) / (sd.durationMillis + duration);
            sd.durationMillis = sd.durationMillis + duration;
            lastSessionUpdateTime = now;
            sd.averageCash = newAverageCashStack;
            saveAsync(displayName);
            return true;
        }
    }

    private void saveAsync(String displayName) {
        executorService.submit(() -> {
            File file = getFile(displayName);
            synchronized (file) {
                SessionData data = cachedSessionData.computeIfAbsent(displayName, this::load);
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(data);
                    writer.write(json);
                    writer.newLine();
                } catch (IOException e) {
                    log.warn("error storing session data to file {}", file, e);
                }
            }
        });
    }

     private SessionData load(String displayName) {
        File file = getFile(displayName);
        if (!file.exists()) {
            return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
        }
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            SessionData sd =  gson.fromJson(reader, SessionData.class);
            if (sd != null) {
                return sd;
            }
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading session data json file {}", file, e);
        }
        return new SessionData((int) Instant.now().getEpochSecond(), 0 ,0);
    }

    private File getFile(String displayName) {
        return displayNameToFile.computeIfAbsent(displayName,
                (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(SESSION_DATA_FILE_TEMPLATE, Persistance.hashDisplayName(displayName))));
    }

    private SessionData getSessionData(String displayName) {
         return cachedSessionData.computeIfAbsent(displayName, this::load);
    }

    public synchronized void reset() {
        lastSessionUpdateTime = null;
    }
}

package com.flippingcopilot.model;

import lombok.Getter;
import lombok.Setter;

import javax.inject.Singleton;
import java.time.Instant;

@Singleton
@Getter
@Setter
public class SuggestionManager {

    private volatile boolean suggestionNeeded;
    private volatile boolean suggestionRequestInProgress;
    private volatile boolean graphDataReadingInProgress;
    private Instant lastFailureAt;
    private HttpResponseException suggestionError;
    private Suggestion suggestion;
    private Instant suggestionReceivedAt;
    private int lastOfferSubmittedTick = -1;

    // these two variables get set based on the current suggestion when the confirm offer button is clicked.
    // this allows us to track on the subsequent offer events whether the offer originates from a copilot suggestion
    // this flag can then eventually be propagated onto each transaction and can be used by the server to
    // determine which items in the inventory were bought based upon copilot suggestions and which are not
    private int suggestionItemIdOnOfferSubmitted = -1;
    private OfferStatus suggestionOfferStatusOnOfferSubmitted = null;


    public void setSuggestion(Suggestion suggestion) {
        this.suggestion = suggestion;
        suggestionReceivedAt = Instant.now();
    }

    public void setSuggestionError(HttpResponseException error) {
        this.suggestionError = error;
        lastFailureAt= Instant.now();
    }

    public void reset() {
        suggestionNeeded = false;
        suggestion = null;
        suggestionReceivedAt = null;
        lastFailureAt = null;
        lastOfferSubmittedTick = -1;
        suggestionError = null;
        suggestionItemIdOnOfferSubmitted = -1;
        suggestionOfferStatusOnOfferSubmitted = null;
    }

    public boolean suggestionOutOfDate() {
        Instant tenSecondsAgo = Instant.now().minusSeconds(10L);
        if (suggestionReceivedAt == null || tenSecondsAgo.isAfter(suggestionReceivedAt)) {
            return lastFailureAt == null || tenSecondsAgo.isAfter(lastFailureAt);
        }
        return false;
    }
}

package com.flippingcopilot.model;

import net.runelite.api.*;
import net.runelite.api.ItemID;
import static com.flippingcopilot.util.Constants.PLATINUM_TOKEN_VALUE;

import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Collectors;


public class Inventory extends ArrayList<RSItem> {

    boolean hasSufficientGp(Suggestion suggestion) {
        return !suggestion.getType().equals("buy")
                || getTotalGp() >= (long) suggestion.getPrice() * suggestion.getQuantity();
    }

    boolean hasSufficientItems(Suggestion suggestion) {
        return !suggestion.getType().equals("sell")
                || getTotalAmount(suggestion.getItemId()) >= suggestion.getQuantity();
    }

    public long getTotalGp() {
        return getTotalAmount(ItemID.COINS_995) + PLATINUM_TOKEN_VALUE * getTotalAmount(ItemID.PLATINUM_TOKEN);
    }

    public long getTotalAmount(long itemId) {
        long amount = 0;
        for (RSItem item : this) {
            if (item.getId() == itemId) {
                amount += item.getAmount();
            }
        }
        return amount;
    }


    public static Inventory fromRunelite(ItemContainer inventory, Client client) {
        Inventory unnotedItems = new Inventory();
        Item[] items = inventory.getItems();
        for (Item item : items) {
            if (item.getId() == -1) {
                continue;
            }
            unnotedItems.add(RSItem.getUnnoted(item, client));
        }
        return unnotedItems;
    }

    Map<Integer, Long> getItemAmounts() {
        return stream().collect(Collectors.groupingBy(RSItem::getId,
                        Collectors.summingLong(RSItem::getAmount)));
    }

    public void mergeItem(RSItem i) {
        for(RSItem item : this) {
            if(item.id == i.id) {
                item.amount += i.amount;
                return;
            }
        }
        add(i);
    }

     public boolean missingJustCollected( Map<Integer, Long> inLimboItems) {
         for (Map.Entry<Integer, Long> entry : inLimboItems.entrySet()) {
             Integer itemId = entry.getKey();
             Long qty = entry.getValue();
             if (qty > 0) {
                 long inventoryQty = getTotalAmount(itemId);
                 if (inventoryQty < qty) {
                     return true;
                 }
             }
         }
         return false;
    }
}

package com.flippingcopilot.model;

import lombok.Data;

import java.util.ArrayList;
import java.util.List;

@Data
public class SuggestionPreferences {

    private boolean f2pOnlyMode = false;
    private boolean sellOnlyMode = false;
    private List<Integer> blockedItemIds = new ArrayList<>();
    private int timeframe = 5;
}

package com.flippingcopilot.model;

import com.flippingcopilot.util.GeTax;
import com.google.gson.annotations.SerializedName;
import lombok.Data;
import java.util.Comparator;
import java.util.UUID;

@Data
public class FlipV2 {

    public static UUID MAX_UUID = new UUID(-1L, -1L);
    public static UUID MIN_UUID = new UUID(0L, 0L);

    @SerializedName("id")
    private UUID id;

    @SerializedName("account_id")
    private int accountId;

    @SerializedName("item_id")
    private int itemId;

    @SerializedName("item_name")
    private String itemName;

    @SerializedName("opened_time")
    private int openedTime;

    @SerializedName("opened_quantity")
    private int openedQuantity;

    @SerializedName("spent")
    private long spent;

    @SerializedName("closed_time")
    private int closedTime;

    @SerializedName("closed_quantity")
    private int closedQuantity;

    @SerializedName("received_post_tax")
    private long receivedPostTax;

    @SerializedName("profit")
    private long profit;

    @SerializedName("tax_paid")
    private long taxPaid;

    @SerializedName("is_closed")
    private boolean isClosed;

    private String accountDisplayName;

    public long calculateProfit(Transaction transaction) {
        long amountToClose = Math.min(openedQuantity - closedQuantity, transaction.getQuantity());
        if(amountToClose <= 0 ){
            return 0;
        }
        long gpOut = (spent * amountToClose) / openedQuantity;
        int sellPrice  = transaction.getAmountSpent() / transaction.getQuantity();
        int sellPricePostTax = GeTax.getPostTaxPrice(transaction.getItemId(), sellPrice);
        long gpIn = amountToClose * sellPricePostTax;
        return gpIn - gpOut;
    }

    public long getAvgBuyPrice() {
        if (spent == 0) {
            return 0;
        }
        return spent / openedQuantity ;
    }

    public long getAvgSellPrice() {
        if (receivedPostTax == 0) {
            return 0;
        }
        return (receivedPostTax  + taxPaid) / closedQuantity;
    }
}

package com.flippingcopilot.model;

import lombok.Data;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;

import java.util.Objects;

@Data
public class SavedOffer
{
	private int itemId;
	private int quantitySold;
	private int totalQuantity;
	private int price;
	private int spent;
	private GrandExchangeOfferState state;
	private boolean copilotPriceUsed;
	private boolean wasCopilotSuggestion;


	public static SavedOffer fromGrandExchangeOffer(GrandExchangeOffer offer) {
		SavedOffer o =  new SavedOffer();
		o.setItemId(offer.getItemId());
		o.setQuantitySold(offer.getQuantitySold());
		o.setTotalQuantity(offer.getTotalQuantity());
		o.setPrice(offer.getPrice());
		o.setSpent(offer.getSpent());
		o.setState(offer.getState());
		return o;
	}

	public OfferStatus getOfferStatus() {
		switch (state) {
			case SELLING:
			case CANCELLED_SELL:
			case SOLD:
				return OfferStatus.SELL;
			case BUYING:
			case CANCELLED_BUY:
			case BOUGHT:
				return OfferStatus.BUY;
			default:
				return OfferStatus.EMPTY;
		}
	}

	public boolean isFreeSlot() {
		switch (state) {
			case CANCELLED_SELL:
			case CANCELLED_BUY:
			case EMPTY:
			case BOUGHT:
			case SOLD:
				return true;
			default:
				return false;
		}
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		SavedOffer that = (SavedOffer) o;
		return itemId == that.itemId && quantitySold == that.quantitySold && totalQuantity == that.totalQuantity && price == that.price && spent == that.spent && state == that.state;
	}

	@Override
	public int hashCode() {
		return Objects.hash(itemId, quantitySold, totalQuantity, price, spent, state, copilotPriceUsed);
	}
}

package com.flippingcopilot.model;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;

@Getter
@AllArgsConstructor
public class RSItem {
    int id;
    long amount;

    static RSItem getUnnoted(Item item, Client client) {
        int itemId = item.getId();
        ItemComposition itemComposition = client.getItemDefinition(itemId);
        if (itemComposition.getNote() != -1) {
            itemId = itemComposition.getLinkedNoteId();
        }
        return new RSItem(itemId, item.getQuantity());
    }
}
package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import net.runelite.api.GrandExchangeOfferState;

public enum OfferStatus {
    @SerializedName("sell")
    SELL,
    @SerializedName("buy")
    BUY,
    @SerializedName("empty")
    EMPTY;

    static OfferStatus fromRunelite(GrandExchangeOfferState state) {
        OfferStatus status;
        switch (state) {
            case SELLING:
            case CANCELLED_SELL:
            case SOLD:
                status = SELL;
                break;
            case BUYING:
            case CANCELLED_BUY:
            case BOUGHT:
                status = BUY;
                break;
            default:
                status = EMPTY;
        }
        return status;
    }
}

package com.flippingcopilot.model;

import com.google.gson.JsonObject;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.Instant;
import java.util.UUID;


@Getter
@AllArgsConstructor
@NoArgsConstructor
@Setter
public class Transaction {

    private UUID id;
    private OfferStatus type;
    private int itemId;
    private int price;
    private int quantity;
    private int boxId;
    private int amountSpent;
    private Instant timestamp;
    private boolean copilotPriceUsed;
    private boolean wasCopilotSuggestion;
    private int offerTotalQuantity;
    private boolean login;
    private boolean consistent;

    public boolean equals(Transaction other) {
        return this.type == other.type &&
                this.itemId == other.itemId &&
                this.price == other.price &&
                this.quantity == other.quantity &&
                this.boxId == other.boxId &&
                this.amountSpent == other.amountSpent;
    }

    public JsonObject toJsonObject() {
        JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty("id", id.toString());
        jsonObject.addProperty("item_id", itemId);
        jsonObject.addProperty("price", price);
        jsonObject.addProperty("quantity", type.equals(OfferStatus.BUY) ? quantity : -quantity);
        jsonObject.addProperty("box_id", boxId);
        jsonObject.addProperty("amount_spent", amountSpent);
        jsonObject.addProperty("time", timestamp.getEpochSecond());
        jsonObject.addProperty("copilot_price_used", copilotPriceUsed);
        jsonObject.addProperty("was_copilot_suggestion", wasCopilotSuggestion);
        jsonObject.addProperty("consistent_previous_offer", consistent);
        jsonObject.addProperty("login", login);
        return jsonObject;
    }

    @Override
    public String toString() {
        return String.format("%s %d %d on slot %d", type, quantity, itemId, boxId);
    }
}



package com.flippingcopilot.model;

import com.flippingcopilot.util.MutableReference;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemID;

import java.util.*;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @javax.inject.Inject)
public class GrandExchangeUncollectedManager {

    // dependencies
    private final Client client;

    // stated
    private int lastUncollectedAddedTick = -1;
    private int lastClearedTick = -1;
    private final Map<Integer, Long> lastClearedUncollected = new HashMap<>();
    private final List<Integer> lastClearedSlots = new ArrayList<>();
    // accountId -> [slot -> [itemID -> quantity]]
    private final Map<Long, Map<Integer, Map<Integer, Long>>> uncollected = new HashMap<>();

    public synchronized boolean HasUncollected(Long accountHash) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        MutableReference<Boolean> hasUncollected = new MutableReference<>(false);
        slotToUncollected.forEach((slot, itemToQty) -> {
            itemToQty.forEach((i, q) -> {
                if(q > 0) {
                    log.debug("{} slot {} item {} uncollected {}", accountHash, slot, i, q);
                    hasUncollected.setValue(true);
                }
            });
        });
        return hasUncollected.getValue();
    }

    public synchronized Map<Integer, Long> loadAllUncollected(Long accountHash) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        Map<Integer, Long> itemIdToQuantity = new HashMap<>();
        slotToUncollected.values().forEach(itemIdToQty -> itemIdToQty.forEach((k, v) -> itemIdToQuantity.merge(k, v, Long::sum)));
        return itemIdToQuantity;
    }

    public synchronized Map<Integer, Long> loadSlotUncollected(Long accountHash, Integer slot) {
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToUncollected.computeIfAbsent(slot, (k) -> new HashMap<>());
    }

    public synchronized void addUncollected(Long accountHash, Integer slot, int itemId, long quantity, long gp) {
        lastUncollectedAddedTick = client.getTickCount();
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        Map<Integer, Long> itemIdToQuantity = slotToUncollected.computeIfAbsent(slot, (k) -> new HashMap<>());
        if (!itemIdToQuantity.containsKey(itemId)) {
           // must be a new offer
           itemIdToQuantity.clear();
        }
        if(quantity > 0) {
            log.debug("tick {} added {} of item {} to uncollected", client.getTickCount(), itemId, quantity);
            itemIdToQuantity.merge(itemId, quantity, Long::sum);
        }
        if (gp > 0) {
            log.debug("tick {} added {} gp to uncollected", client.getTickCount(), gp);
            itemIdToQuantity.merge(ItemID.COINS_995, gp, Long::sum);
        }
    }

    public synchronized void ensureSlotClear(Long accountHash, int slot) {
        Map<Integer, Long> slotUncollected = loadSlotUncollected(accountHash, slot);
        slotUncollected.remove(slot);
    }

    public synchronized void clearSlotUncollected(Long accountHash, int slot) {
        Map<Integer, Long> slotUncollected = loadSlotUncollected(accountHash, slot);
        int tick = client.getTickCount();
        if(tick != lastClearedTick) {
            lastClearedUncollected.clear();
            lastClearedSlots.clear();
            lastClearedTick = tick;
        }
        lastClearedSlots.add(slot);
        slotUncollected.forEach((key, value) -> lastClearedUncollected.merge(key, value, Long::sum));
        Map<Integer, Map<Integer, Long>> slotToUncollected = this.uncollected.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        slotToUncollected.remove(slot);
    }

    public synchronized void clearAllUncollected(Long accountHash) {
        log.debug("tick {} clearAllUncollected", client.getTickCount());
        Map<Integer, Long> allUncollected = loadAllUncollected(accountHash);
        int tick = client.getTickCount();
        if(tick != lastClearedTick) {
            lastClearedUncollected.clear();
            lastClearedSlots.clear();
            lastClearedTick = tick;
        }
        lastClearedSlots.addAll(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7));
        allUncollected.forEach((key, value) -> {
            if(value > 0) {
                log.debug("tick {} cleared item {}, qty {}", client.getTickCount(), key, value);
                lastClearedUncollected.merge(key, value, Long::sum);
            }
        });
        uncollected.remove(accountHash);
    }

    public synchronized int getLastClearedTick() {
        return lastClearedTick;
    }

    public synchronized Map<Integer, Long> getLastClearedUncollected() {
        return lastClearedUncollected;
    }

    public synchronized List<Integer> getLastClearedSlots() {
        return lastClearedSlots;
    }

    public synchronized int getLastUncollectedAddedTick() {
        return lastUncollectedAddedTick;
    }

    public synchronized void reset() {
        lastClearedUncollected.clear();
        lastClearedTick = -1;
        lastUncollectedAddedTick = -1;
        uncollected.clear();
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.List;


@Getter
@Setter
@AllArgsConstructor
@ToString
@NoArgsConstructor
public class PremiumInstanceStatus {
    private String loadingError;
    @SerializedName("premium_instances_count")
    private int premiumInstancesCount;
    @SerializedName("changes_remaining")
    private int changesRemaining;
    @SerializedName("currently_assigned_display_names")
    private List<String> currentlyAssignedDisplayNames;
    @SerializedName("available_display_names")
    private List<String> availableDisplayNames;

    public static PremiumInstanceStatus ErrorInstance(String error) {
        PremiumInstanceStatus pi = new PremiumInstanceStatus();
        pi.setLoadingError(error);
        return pi;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.runelite.api.GrandExchangeOffer;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;


public class StatusOfferList extends ArrayList<Offer> {
    public static final int NUM_SLOTS = 8;

    public StatusOfferList() {
        super(NUM_SLOTS);
        for (int i = 0; i < NUM_SLOTS; i++) {
            add(Offer.getEmptyOffer(i));
        }
    }

    public static StatusOfferList fromRunelite(GrandExchangeOffer[] runeliteOffers) {
        StatusOfferList offers = new StatusOfferList();
        for (int i = 0; i < runeliteOffers.length; i++) {
            offers.set(i, Offer.fromRunelite(runeliteOffers[i], i));
        }
        return offers;
    }

    public boolean isEmptySlotNeeded(Suggestion suggestion) {
        return (suggestion.getType().equals("buy") || suggestion.getType().equals("sell"))
                && !emptySlotExists();
    }

    boolean emptySlotExists() {
        return stream().anyMatch(offer -> offer.getStatus() == OfferStatus.EMPTY);
    }

    public long getGpOnMarket() {
        return stream().mapToLong(Offer::cashStackGpValue).sum();
    }

    public long getTotalGpToCollect() {
        return stream().mapToLong(Offer::getGpToCollect).sum();
    }

    JsonArray toJson(Gson gson) {
        List<JsonObject> list = stream()
                .map(offer -> offer.toJson(gson))
                .collect(Collectors.toList());
        JsonArray jsonArray = new JsonArray();
        list.forEach(jsonArray::add);
        return jsonArray;
    }

    public int findEmptySlot() {
        for (int i = 0; i < NUM_SLOTS; i++) {
            if (get(i).getStatus() == OfferStatus.EMPTY) {
                return i;
            }
        }
        return -1;
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.nio.ByteBuffer;

@Getter
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class ItemPrice {
    @SerializedName("sell_price")
    private int sellPrice;
    @SerializedName("buy_price")
    private  int buyPrice;
    private  String message;
    @SerializedName("graph_data")
    private Data graphData;

    public static ItemPrice fromMsgPack(ByteBuffer b) {
        ItemPrice ip = new ItemPrice();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }
        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "sp":
                    ip.sellPrice = (int) (long)MsgPackUtil.decodePrimitive(b);
                    break;
                case "bp":
                    ip.buyPrice = (int) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "m":
                    ip.message = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "gd":
                    ip.graphData = Data.fromMsgPack(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }
        return ip;
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class LoginResponse {
    public boolean error;
    public String message;
    public String jwt;

    @SerializedName("user_id")
    public int userId;
}

package com.flippingcopilot.model;

import lombok.Getter;

@Getter
public enum IntervalTimeUnit {

    ALL(-1),
    SESSION(-1),
    HOUR(3600),
    DAY(86400),
    WEEK(604800),
    MONTH(2592000),
    YEAR(31536000);

    private final int seconds;;

    IntervalTimeUnit(int seconds) {
        this.seconds = seconds;
    }

    public static IntervalTimeUnit fromString(String str) {
        switch (str) {
            case "h":
                return IntervalTimeUnit.HOUR;
            case "d":
                return IntervalTimeUnit.DAY;
            case "w":
                return IntervalTimeUnit.WEEK;
            case "m":
                return IntervalTimeUnit.MONTH;
            case "y":
                return IntervalTimeUnit.YEAR;
            default:
                return IntervalTimeUnit.ALL;
        }
    }
}

package com.flippingcopilot.model;

import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.List;
import java.util.Map;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class AccountStatusManager {

    // dependencies
    private final Client client;
    private final OsrsLoginManager osrsLoginManager;
    private final GrandExchangeUncollectedManager geUncollected;
    private final SuggestionPreferencesManager suggestionPreferencesManager;
    private final PausedManager pausedManager;

    // state
    @Setter
    private int skipSuggestion = -1;

    public synchronized AccountStatus getAccountStatus() {
        Long accountHash =  osrsLoginManager.getAccountHash();
        ItemContainer itemContainer = client.getItemContainer(InventoryID.INVENTORY);
        if(itemContainer == null) {
            log.warn("unable to fetch inventory item container");
            return null;
        }
        Inventory inventory = Inventory.fromRunelite(itemContainer, client);
        Map<Integer, Long> u = geUncollected.loadAllUncollected(accountHash);

        GrandExchangeOffer[] geOffers = client.getGrandExchangeOffers();
        StatusOfferList offerList = StatusOfferList.fromRunelite(geOffers);

        AccountStatus status = new AccountStatus();
        status.setOffers(offerList);
        status.setInventory(inventory);
        status.setUncollected(u);
        status.setDisplayName(osrsLoginManager.getPlayerDisplayName());
        status.setRsAccountHash(accountHash);
        status.setSkipSuggestion(skipSuggestion);
        status.setSellOnlyMode(suggestionPreferencesManager.getPreferences().isSellOnlyMode());
        status.setF2pOnlyMode(suggestionPreferencesManager.getPreferences().isF2pOnlyMode());
        status.setMember(osrsLoginManager.isMembersWorld());
        status.setSuggestionsPaused(pausedManager.isPaused());
        status.setBlockedItems(suggestionPreferencesManager.blockedItems());
        status.setTimeframe(suggestionPreferencesManager.getTimeframe());

        Map<Integer, Long> inLimboItems = geUncollected.getLastClearedUncollected();
        List<Integer> clearedSlots = geUncollected.getLastClearedSlots();
        if (geUncollected.getLastClearedTick() == client.getTickCount()) {
            log.debug("tick {} in limbo items {}, cleared slots {}", client.getTickCount(), inLimboItems, clearedSlots);
            if(inventory.missingJustCollected(inLimboItems)) {
                inLimboItems.forEach((itemId, qty) -> {
                    if (qty > 0) {
                        log.debug("tick {} move in limbo item {}, qty {} to inventory", client.getTickCount(), itemId, qty);
                        inventory.mergeItem(new RSItem(itemId, qty));
                    }
                });
            }
            for (Integer slot : clearedSlots) {
                Offer o = offerList.get(slot);
                GrandExchangeOffer geOffer = geOffers[slot];
                if (!isActive(geOffer.getState()) && geOffer.getState() != GrandExchangeOfferState.EMPTY) {
                    log.debug("tick {} in-activate slot {} just collected setting to EMPTY", client.getTickCount(), slot);
                    o.setStatus(OfferStatus.EMPTY);
                }
            }
        }

        return status;
    }

    private boolean isActive(GrandExchangeOfferState state) {
        switch (state){
            case EMPTY:
            case CANCELLED_BUY:
            case CANCELLED_SELL:
            case BOUGHT:
            case SOLD:
                return false;
            default:
                return true;
        }
    }

    public boolean isSuggestionSkipped() {
        return skipSuggestion != -1;
    }

    public void resetSkipSuggestion() {
        skipSuggestion = -1;
    }

    public void reset() {
        skipSuggestion = -1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;


@Getter
@AllArgsConstructor
@EqualsAndHashCode
public class Offer {

    @Setter
    private OfferStatus status;

    @SerializedName("item_id")
    private int itemId;

    private int price;

    @SerializedName("amount_total")
    private int amountTotal;

    @SerializedName("amount_spent")
    private int amountSpent;

    @SerializedName("amount_traded")
    private int amountTraded;

    @SerializedName("items_to_collect")
    private int itemsToCollect;

    @SerializedName("gp_to_collect")
    private int gpToCollect;

    @SerializedName("box_id")
    private int boxId;

    private boolean active;

    @Setter
    @SerializedName("copilot_price_used")
    private boolean copilotPriceUsed;

    public static Offer getEmptyOffer(int slotId) {
        return new Offer(OfferStatus.EMPTY, 0, 0, 0, 0, 0, 0, 0, slotId, false, false);
    }


    public long cashStackGpValue() {
        if (status == OfferStatus.SELL) {
            return (long) (amountTotal - amountTraded) * price + gpToCollect;
        } else if (status == OfferStatus.BUY){
            // for a buy just take the full amount even if they have collected
            // we assume they won't start selling any collected items until their buy offer is finished
            return (long) amountTotal * price;
        } else {
            return 0;
        }
    }


    public static Offer fromRunelite(GrandExchangeOffer runeliteOffer, int slotId) {
        OfferStatus status = OfferStatus.fromRunelite(runeliteOffer.getState());
        boolean active = runeliteOffer.getState().equals(GrandExchangeOfferState.BUYING)
                || runeliteOffer.getState().equals(GrandExchangeOfferState.SELLING);
        return new Offer(status,
                runeliteOffer.getItemId(),
                runeliteOffer.getPrice(),
                runeliteOffer.getTotalQuantity(),
                runeliteOffer.getSpent(),
                runeliteOffer.getQuantitySold(),
                0,
                0,
                slotId,
                active,
                false);
    }


    JsonObject toJson(Gson gson) {
        JsonParser jsonParser = new JsonParser();
        return jsonParser.parse(gson.toJson(this)).getAsJsonObject();
    }

}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import joptsimple.internal.Strings;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.file.Files;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class LoginResponseManager {

    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";

    private final File file = new File(Persistance.PARENT_DIRECTORY, LOGIN_RESPONSE_JSON_FILE);

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    private LoginResponse cachedLoginResponse;

    public synchronized LoginResponse getLoginResponse() {
        if(cachedLoginResponse != null) {
            return cachedLoginResponse;
        }
        cachedLoginResponse = load();
        return cachedLoginResponse;
    }

    public synchronized void setLoginResponse(LoginResponse loginResponse) {
        if (loginResponse == null) {
            return;
        }
        cachedLoginResponse = loginResponse;
        saveAsync();
    }

    public boolean isLoggedIn() {
        LoginResponse loginResponse = getLoginResponse();
        return loginResponse != null && !loginResponse.error && !Strings.isNullOrEmpty(loginResponse.jwt);
    }

    public void reset() {
        cachedLoginResponse = null;
        if (file.exists()) {
            if(!file.delete()) {
                log.warn("failed to delete login response file {}", file);
            }
        }
    }

    public void saveAsync() {
        executorService.submit(() -> {
            synchronized (file) {
                LoginResponse loginResponse = getLoginResponse();
                if (loginResponse != null) {
                    try {
                        String json = gson.toJson(loginResponse);
                        Files.write(file.toPath(), json.getBytes());
                    } catch (IOException e) {
                        log.warn("error saving login response {}", e.getMessage(), e);
                    }
                }
            }
        });
    }

    public LoginResponse load() {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, LoginResponse.class);
        } catch (FileNotFoundException ignored) {
            return null;
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading saved login json file {}", file, e);
            return null;
        }
    }

    public String getJwtToken() {
        if(!isLoggedIn()) {
            return null;
        }
        return getLoginResponse().getJwt();
    }
}

package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class Stats {

    public long profit;
    public long gross;
    public long taxPaid;
    public int flipsMade;

    public float calculateRoi() {
        if (gross == 0){
            return 0;
        }
        return (float) (((double) profit) / ((double) gross));
    }

    public Stats copy() {
        return new Stats(profit, gross, taxPaid, flipsMade);
    }

    public void add(Stats s) {
        if(s != null) {
            profit += s.profit;
            gross += s.gross;
            taxPaid += s.taxPaid;
            flipsMade += s.flipsMade;
        }
    }

    public void addFlip(FlipV2 f) {
        profit += f.getProfit();
        gross += f.getSpent();
        taxPaid += f.getTaxPaid();
        flipsMade += 1;
    }

    public void subtractFlip(FlipV2 f) {
        profit -= f.getProfit();
        gross -= f.getSpent();
        taxPaid -= f.getTaxPaid();
        flipsMade -= 1;
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public class SessionData {

    @SerializedName("start_time")
    public int startTime;

    @SerializedName("duration_millis")
    public long durationMillis;

    @SerializedName("average_cash")
    public long averageCash;
}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.ApiRequestHandler;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * This class is essentially a cache of user flips that facilitates efficient access to the flips and statistics for
 * any time range and rs account(s) combination. Since after several years a (very) active user could have hundreds of
 * thousands of flips, it would be too slow to filter and re-calculate flips/statistics from scratch every time.
 * A bucketed aggregation strategy is used where we keep pre-computed weekly buckets of statistics and flips. For any
 * time range we can efficiently combine the weekly buckets and only have to re-calculate statistics for the partial
 * weeks on the boundaries of the time range. Have tested the UI experience with >100k flips.
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class FlipManager {

    private static final int WEEK_SECS = 7 * 24 * 60 * 60;

    // dependencies
    private final ApiRequestHandler api;
    private final ScheduledExecutorService executorService;
    private final OkHttpClient okHttpClient;

    @Setter
    private Runnable flipsChangedCallback = () -> {};

    // state
    private String intervalDisplayName;
    private int intervalStartTime;
    private Stats intervalStats = new Stats();

    final Map<String, Integer> displayNameToAccountId = new HashMap<>();
    final Map<Integer, Map<Integer, FlipV2>> lastOpenFLipByItemId = new HashMap<>();
    final Map<UUID, Integer> existingCloseTimes = new HashMap<>();
    final List<WeekAggregate> weeks = new ArrayList<>(365*5);

    private int resetSeq = 0;
    public volatile boolean flipsLoaded;

    public synchronized String getIntervalDisplayName() {
        return intervalDisplayName;
    }

    public synchronized List<String> getDisplayNameOptions() {
        return displayNameToAccountId.keySet().stream().sorted().collect(Collectors.toList());
    }

    public synchronized long estimateTransactionProfit(String displayName, Transaction t) {
        Integer accountId = displayNameToAccountId.get(displayName);
        if (accountId != null && lastOpenFLipByItemId.containsKey(accountId)) {
            FlipV2 flip = lastOpenFLipByItemId.get(accountId).get(t.getItemId());
            if(flip != null) {
                return flip.calculateProfit(t);
            }
        }
        return 0;
    }

    public synchronized void mergeFlips(List<FlipV2> flips, String displayName) {
        if(!flips.isEmpty() && displayName != null) {
            displayNameToAccountId.put(displayName, flips.get(0).getAccountId());
        }
        flips.forEach(this::mergeFlip_);
        flipsChangedCallback.run();
    }

    public synchronized Stats getIntervalStats() {
        return intervalStats.copy();
    }

    public synchronized Stats calculateStats(int startTime, String displayName) {
        if(displayName == null) {
            return calculateStatsAllAccounts(startTime);
        } else {
            return calculateStatsForAccount(startTime, displayNameToAccountId.getOrDefault(displayName, -1));
        }
    }

    public synchronized void setIntervalDisplayName(String displayName) {
        if (Objects.equals(displayName, intervalDisplayName)) {
            return;
        }
        if (displayName != null && !displayNameToAccountId.containsKey(displayName)) {
            displayNameToAccountId.put(displayName, -1);
        }
        intervalDisplayName = displayName;
        recalculateIntervalStats();
    }

    public synchronized void setIntervalStartTime(int startTime) {
        log.debug("time interval start set to: {}", Instant.ofEpochSecond(startTime));
        if (startTime == intervalStartTime) {
            return;
        }
        intervalStartTime = startTime;
        recalculateIntervalStats();
    }

    private void recalculateIntervalStats() {
        if(intervalDisplayName == null) {
            intervalStats = calculateStatsAllAccounts(intervalStartTime);
        } else {
            intervalStats = calculateStatsForAccount(intervalStartTime, displayNameToAccountId.getOrDefault(intervalDisplayName, -1));
        }
        log.debug("interval flips updated to {}, interval profit updated to {}", intervalStats.flipsMade, intervalStats.profit);
        flipsChangedCallback.run();
    }

    private Stats calculateStatsAllAccounts(int startTime) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfter(startTime, false)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).allStats);
        }
        return stats;
    }

    private Stats calculateStatsForAccount(int startTime, int accountId) {
        Stats stats = new Stats();
        WeekAggregate w = getOrInitWeek(startTime);
        for (FlipV2 f : w.flipsAfterForAccount(startTime, accountId)) {
            stats.addFlip(f);
        }
        for(int i=w.pos+1; i < weeks.size(); i++) {
            stats.add(weeks.get(i).accountIdToStats.get(accountId));
        }
        return stats;
    }

    public synchronized List<FlipV2> getPageFlips(int page, int pageSize) {
        Integer accountId = intervalDisplayName == null ? null : displayNameToAccountId.getOrDefault(intervalDisplayName, -1);
        if (Objects.equals(accountId,-1)) {
            return new ArrayList<>();
        }

        int toSkip = (page -1) * pageSize;
        WeekAggregate intervalWeek = getOrInitWeek(intervalStartTime);
        List<FlipV2> resultFlips = new ArrayList<>(pageSize);
        for(int i=weeks.size()-1; i >= intervalWeek.pos; i--) {
            if (weeks.get(i).weekEnd <= intervalStartTime || resultFlips.size() == pageSize) {
                break;
            }
            WeekAggregate w = weeks.get(i);
            List<FlipV2> weekFlips = accountId == null ? w.flipsAfter(intervalStartTime, true) : w.flipsAfterForAccount(intervalStartTime, accountId);
            int n = weekFlips.size();
            if (n > toSkip) {
                // note: weekFlips are ascending order but we return pages of descending order
                int end = n - toSkip;
                int start = Math.max(0, end - (pageSize - resultFlips.size()));
                for(int ii=end-1; ii >= start; ii--) {
                    resultFlips.add(weekFlips.get(ii));
                }
                toSkip = 0;
            } else {
                toSkip -= n;
            }
        }
        return resultFlips;
    }

    public void loadFlipsAsync() {
        executorService.execute(() -> this.loadFlips(resetSeq));
    }

    private void loadFlips(int seq) {
        // ScheduledExecutorService only has one thread, we don't really want to block it. Need to
        // refactor the API call to be async style but until then just run in okHttpClient's executor
        okHttpClient.dispatcher().executorService().submit(() -> {
            try {
                long s = System.nanoTime();
                Map<String, Integer> names = api.loadUserDisplayNames();
                synchronized (this) {
                    if (seq != resetSeq) {
                        return;
                    }
                    displayNameToAccountId.putAll(names);
                }
                log.debug("loading account names took {}ms", (System.nanoTime() - s) / 1000_000);
                s = System.nanoTime();
                List<FlipV2> flips = api.LoadFlips();
                log.debug("loading {} flips took {}ms", flips.size(), (System.nanoTime() - s) / 1000_000);
                s = System.nanoTime();
                synchronized (this) {
                    if (seq != resetSeq) {
                        return;
                    }
                    mergeFlips(flips, null);
                    log.debug("merging flips to took {}ms", (System.nanoTime() - s) / 1000_000);
                    flipsLoaded = true;
                }
                flipsChangedCallback.run();
            } catch (Exception e) {
                if (this.resetSeq == seq) {
                    log.warn("failed to load historical flips from server {} try again in 10s", e.getMessage(), e);
                    executorService.schedule(() -> this.loadFlips(seq), 10, TimeUnit.SECONDS);
                }
            }
        });
    }


    public synchronized void reset() {
        intervalDisplayName = null;
        intervalStartTime = 0;
        intervalStats = new Stats();
        displayNameToAccountId.clear();
        lastOpenFLipByItemId.clear();
        existingCloseTimes.clear();
        weeks.clear();
        flipsLoaded = false;
        resetSeq += 1;
    }

    private void mergeFlip_(FlipV2 flip) {
        Integer existingCloseTime = existingCloseTimes.get(flip.getId());
        Integer intervalAccountId = intervalDisplayName == null ? null : displayNameToAccountId.getOrDefault(intervalDisplayName, -1);

        if(existingCloseTime != null) {
            WeekAggregate wa = getOrInitWeek(existingCloseTime);
            FlipV2 removed = wa.removeFlip(flip.getId(), existingCloseTime, flip.getAccountId());
            if(removed.getClosedTime() >= intervalStartTime && (intervalAccountId == null || removed.getAccountId() == intervalAccountId)) {
                intervalStats.subtractFlip(removed);
            }
        }
        WeekAggregate wa = getOrInitWeek(flip.getClosedTime());
        wa.addFlip(flip);
        if(flip.getClosedTime() >= intervalStartTime && (intervalAccountId == null || flip.getAccountId() == intervalAccountId)) {
            intervalStats.addFlip(flip);
        }
        if(flip.getClosedQuantity() < flip.getOpenedQuantity()) {
            lastOpenFLipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).put(flip.getItemId(), flip);
        } else if (flip.isClosed()) {
            lastOpenFLipByItemId.computeIfAbsent(flip.getAccountId(), (k) -> new HashMap<>()).remove(flip.getItemId());
        }
        existingCloseTimes.put(flip.getId(), flip.getClosedTime());
    }

    private WeekAggregate getOrInitWeek(int closeTime) {
        int ws = closeTime - (closeTime % WEEK_SECS);
        int i = bisect(weeks.size(), (a) ->  Integer.compare(weeks.get(a).weekStart, ws));
        if (i >= 0){
            WeekAggregate w = weeks.get(i);
            w.pos = i;
            return w;
        }
        WeekAggregate wf = new WeekAggregate();
        wf.weekStart = ws;
        wf.weekEnd = ws + WEEK_SECS;
        wf.pos = -i-1;
        weeks.add(wf.pos, wf);
        return wf;
    }

    class WeekAggregate {

        int pos; // note: only correct when returned by getOrInitWeek
        int weekStart;
        int weekEnd;

        Stats allStats = new Stats();
        Map<Integer, Stats> accountIdToStats = new HashMap<>(20);
        Map<Integer, List<FlipV2>> accountIdToFlips = new HashMap<>(20);

        void addFlip(FlipV2 flip) {
            int accountId = flip.getAccountId();
            allStats.addFlip(flip);
            accountIdToStats.computeIfAbsent(accountId, (k) -> new Stats()).addFlip(flip);
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, flip.getId(), flip.getClosedTime()));
            flips.add(-i -1, flip);
        }

        FlipV2 removeFlip(UUID id, int closeTime, int accountId) {
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            int i = bisect(flips.size(), closedTimeCmp(flips, id, closeTime));
            FlipV2 flip = flips.get(i);
            allStats.subtractFlip(flip);
            flips.remove(i);
            accountIdToStats.get(accountId).subtractFlip(flip);
            return flip;
        }

        public List<FlipV2> flipsAfterForAccount(int time, int accountId) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> flips = accountIdToFlips.computeIfAbsent(accountId, (k) -> new ArrayList<>());
            if (time <= weekStart) {
                return flips;
            }
            int cut = -bisect(flips.size(), closedTimeCmp(flips, FlipV2.MAX_UUID, time)) - 1;
            return flips.subList(cut, flips.size());
        }

        public List<FlipV2> flipsAfter(int time, boolean requireSorted) {
            if (weekEnd <= time) {
                return Collections.emptyList();
            }
            List<FlipV2> combinedFlips = new ArrayList<>(allStats.flipsMade);
            accountIdToFlips.keySet().forEach(i -> combinedFlips.addAll(flipsAfterForAccount(time, i)));
            if (requireSorted) {
                combinedFlips.sort(Comparator.comparing(FlipV2::getClosedTime).thenComparing(FlipV2::getId));
            }
            return combinedFlips;
        }

        @Override
        public String toString() {
            return String.format("WeekAggregate[start=%s, flips=%d]", Instant.ofEpochSecond(weekStart), allStats.flipsMade);
        }
    }

    private Function<Integer, Integer> closedTimeCmp(List<FlipV2> flips, UUID id, int time) {
        return (a) -> {
            // sorts time ascending with id as tie-breaker
            int c = Integer.compare(flips.get(a).getClosedTime(), time);
            return c != 0 ? c : id.compareTo(flips.get(a).getId());
        };
    }

    private int bisect(int size, Function<Integer, Integer> cmpFunc) {
        int high = size -1;
        int low = 0;
        while (low <= high) {
            int mid = (low + high) >>> 1;
            int cmp = cmpFunc.apply(mid);
            if (cmp < 0)
                low = mid + 1;
            else if (cmp > 0)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found (low = insertion point)
    }
}

package com.flippingcopilot.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumSet;

@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OsrsLoginManager {

    public static final int GE_LOGIN_BURST_WINDOW = 2; // ticks

    public static String LOGIN_TO_GET_SUGGESTION_MESSAGE = "Log in to the game<br>to get a flip suggestion";
    private static final WorldType[] COPILOT_UNSUPPORTED_WORLDS = {WorldType.BETA_WORLD,
            WorldType.DEADMAN,
            WorldType.FRESH_START_WORLD,
            WorldType.NOSAVE_MODE,
            WorldType.PVP_ARENA,
            WorldType.SEASONAL,
            WorldType.QUEST_SPEEDRUNNING,
            WorldType.TOURNAMENT_WORLD};

    private final Client client;

    private String cachedDisplayName;
    private long lastAccountHash;

    @Getter
    @Setter
    private int lastLoginTick;

    private boolean lastIsIronman = false;

    public boolean isMembersWorld() {
        return client.getWorldType().contains(WorldType.MEMBERS);
    }

    public boolean isValidLoginState() {
        return getInvalidStateDisplayMessage() == null;
    }

    public String getInvalidStateDisplayMessage() {
        if (client.getGameState() != GameState.LOGGED_IN || getPlayerDisplayName() == null) {
            return LOGIN_TO_GET_SUGGESTION_MESSAGE;
        }

        EnumSet<WorldType> worldTypes  =  client.getWorldType();

        for (WorldType worldType : COPILOT_UNSUPPORTED_WORLDS) {
            if (worldTypes.contains(worldType)) {
                return worldType + " worlds<br>are not supported";
            }
        }
        if(client.isClientThread()) {
            lastIsIronman = client.getVarbitValue(Varbits.ACCOUNT_TYPE) != 0;
        }
        if (lastIsIronman) {
            return "Ironman accounts<br>are not supported";
        }
        return null;
    }

    // todo: inline this method
    public Long getAccountHash() {
        return client.getAccountHash();
    }

    public String getPlayerDisplayName() {
        long accountHash = client.getAccountHash();
        if(lastAccountHash == accountHash && cachedDisplayName != null) {
            return cachedDisplayName;
        }
        final Player player = client.getLocalPlayer();
        if (player != null) {
            final String name = player.getName();
            if (name != null && !name.isEmpty()) {
                lastAccountHash = accountHash;
                cachedDisplayName = name;
                return name;
            }
        }
        return null;
    }

    public String getLastDisplayName() {
        return cachedDisplayName != null ? cachedDisplayName : getPlayerDisplayName();
    }

    public void reset() {

    }

    public boolean hasJustLoggedIn() {
        return client.getTickCount() <= lastLoginTick + GE_LOGIN_BURST_WINDOW;
    }
}

package com.flippingcopilot.model;

import lombok.Data;

@Data
public class DiscordWebhookBody {
    private String content;
    private Embed embed;

    @Data
    static class Embed {
        final UrlEmbed image;
    }

    @Data
    static class UrlEmbed {
        final String url;
    }
}
package com.flippingcopilot.model;

import com.flippingcopilot.controller.Persistance;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OfferManager {

    private static final String OFFER_FILE_TEMPLATE = "acc_%d_%d.json";

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    @Getter
    @Setter
    private int lastViewedSlotItemId = -1;
    @Getter
    @Setter
    private int lastViewedSlotItemPrice = -1;
    @Getter
    @Setter
    private int lastViewedSlotPriceTime = 0;
    @Getter
    @Setter
    private int viewedSlotItemId = -1;
    @Getter
    @Setter
    private int viewedSlotItemPrice = -1;
    @Getter
    @Setter
    boolean offerJustPlaced = false;

    private final Map<Long, Map<Integer, SavedOffer>> cachedOffers = new HashMap<>();
    private final Map<Long, Map<Integer, File>> files = new HashMap<>();
    private final Map<Long, Map<Integer, SavedOffer>> lastSaved = new HashMap<>();

    public synchronized SavedOffer loadOffer(Long accountHash, Integer slot) {
        Map<Integer, SavedOffer> slotToOffer = cachedOffers.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToOffer.computeIfAbsent(slot, (k) -> {
            File file = getFile(accountHash, k);
            try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
                return gson.fromJson(reader, SavedOffer.class);
            } catch (FileNotFoundException ignored) {
                return null;
            } catch (JsonSyntaxException | JsonIOException | IOException e) {
                log.warn("error loading saved offer json file {}", file, e);
                return null;
            }
        });
    }

    public synchronized void saveOffer(Long accountHash, Integer slot, SavedOffer offer) {
        Map<Integer, SavedOffer> slotToOffer = cachedOffers.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        slotToOffer.put(slot, offer);
        saveAsync(accountHash, slot);
    }

    private void saveAsync(Long accountHash, Integer slot) {
        executorService.submit(() -> save(accountHash, slot));
    }

    public synchronized void saveAll() {
        for(Long accountHash: cachedOffers.keySet()) {
            for(Integer slot: cachedOffers.get(accountHash).keySet()) {
                save(accountHash, slot);
            }
        }
    }

    private void save(Long accountHash, Integer slot) {
        File file = getFile(accountHash,slot);
        synchronized (file) {
            SavedOffer offer = loadOffer(accountHash, slot);
            Map<Integer, SavedOffer> slotToLastSaved = lastSaved.computeIfAbsent(accountHash, (k)->new HashMap<>());
            SavedOffer lastSaved = slotToLastSaved.get(slot);
            if(!Objects.equals(offer, lastSaved)) {
                try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, false))) {
                    String json = gson.toJson(offer);
                    writer.write(json);
                    writer.newLine();
                    slotToLastSaved.put(slot, offer);
                } catch (IOException e) {
                    log.warn("error saving offer json file {}", file, e);
                    slotToLastSaved.put(slot, null);
                }
            }
        }
    }


    private File getFile(Long accountHash, Integer slot) {
        Map<Integer, File> slotToFile = files.computeIfAbsent(accountHash, (k) -> new HashMap<>());
        return slotToFile.computeIfAbsent(slot, (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(OFFER_FILE_TEMPLATE, accountHash, slot)));
    }
}

package com.flippingcopilot.model;


import com.flippingcopilot.controller.Persistance;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PausedManager {

    private static final String PAUSED_FILE_TEMPLATE = "acc_%d_paused.json";

    // dependencies
    private final OsrsLoginManager osrsLoginManager;
    private final ScheduledExecutorService executorService;

    // state
    private final Map<Long, Boolean> cachedPaused = new HashMap<>();
    private final Map<Long, File> accountHashToFile = new HashMap<>();

    public synchronized boolean isPaused() {
        Long accountHash = osrsLoginManager.getAccountHash();
        return cachedPaused.computeIfAbsent(accountHash, (k) -> {
            File file = getFile(k);
            try {
                String text = Files.readString(file.toPath(), StandardCharsets.UTF_8);
                return text.contains("true");
            } catch (NoSuchFileException e ){
                return false;
            } catch (JsonSyntaxException | JsonIOException | IOException e) {
                log.warn("error loading stored paused state file {}", file, e);
                return false;
            }
        });
    }

    public synchronized void setPaused(boolean isPaused) {
        Long accountHash = osrsLoginManager.getAccountHash();
        cachedPaused.put(accountHash, isPaused);
        saveAsync(accountHash);
    }

    private void saveAsync(Long accountHash) {
        executorService.submit(() -> {
            File file = getFile(accountHash);
            synchronized (file) {
                boolean isPaused = cachedPaused.getOrDefault(accountHash, false);
                String text = isPaused ? "{\"isPaused\":true}" : "{\"isPaused\":false}";
                try {
                    Files.write(file.toPath(), text.getBytes());
                } catch (IOException e) {
                    log.warn("error storing paused.json file {}", file, e);
                }
            }
        });
    }

    private File getFile(Long accountHash) {
        return accountHashToFile.computeIfAbsent(accountHash,
                (k) -> new File(Persistance.PARENT_DIRECTORY, String.format(PAUSED_FILE_TEMPLATE, accountHash)));
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.SuggestionController;
import com.flippingcopilot.model.PausedManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Singleton
public class PauseButton extends JButton {

    private final PausedManager pausedManager;

    private static final ImageIcon PLAY_ICON;
    private static final ImageIcon PAUSE_ICON;
    private static final ImageIcon PLAY_ICON_HOVER;
    private static final ImageIcon PAUSE_ICON_HOVER;

    static {
        var play = ImageUtil.loadImageResource(PauseButton.class, "/play.png");
        var pause = ImageUtil.loadImageResource(PauseButton.class, "/pause.png");
        PLAY_ICON = new ImageIcon(play);
        PAUSE_ICON = new ImageIcon(pause);
        PLAY_ICON_HOVER =  new ImageIcon(ImageUtil.luminanceScale(play, BUTTON_HOVER_LUMINANCE));
        PAUSE_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(pause, BUTTON_HOVER_LUMINANCE));
    }

    @Inject
    public PauseButton(PausedManager pausedManager,
                       SuggestionController suggestionController) {
        super(PAUSE_ICON);
        this.pausedManager = pausedManager;
        setToolTipText("Pause suggestions");
        addActionListener(e -> {
            suggestionController.togglePause();
            update();
        });

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(pausedManager.isPaused() ? PLAY_ICON_HOVER : PAUSE_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(pausedManager.isPaused() ? PLAY_ICON : PAUSE_ICON);
            }
        });

        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);
    }

    private void update() {
        boolean isPaused = pausedManager.isPaused();
        setIcon(isPaused ? PLAY_ICON : PAUSE_ICON);
        setToolTipText(isPaused ? "Unpause suggestions" :  "Pause suggestions");
    }
}

package com.flippingcopilot.ui;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;

@Singleton
public class CopilotPanel extends JPanel {

    public final SuggestionPanel suggestionPanel;
    public final StatsPanelV2 statsPanel;
    public final ControlPanel controlPanel;

    @Inject
    public CopilotPanel(SuggestionPanel suggestionPanel,
                        StatsPanelV2 statsPanel,
                        ControlPanel controlPanel) {
        this.statsPanel = statsPanel;
        this.suggestionPanel = suggestionPanel;
        this.controlPanel = controlPanel;
        
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        suggestionPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, suggestionPanel.getPreferredSize().height));
        suggestionPanel.setMinimumSize(new Dimension(Integer.MIN_VALUE, suggestionPanel.getPreferredSize().height));
        add(suggestionPanel);
        add(Box.createRigidArea(new Dimension(0, 5)));
        add(controlPanel);
        add(Box.createRigidArea(new Dimension(0, 5)));
        add(Box.createVerticalGlue());
        add(statsPanel);
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        suggestionPanel.refresh();
        controlPanel.refresh();
    }
}

/* Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * Copyright (c) 2024, Cillian Brewitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;

import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class WidgetHighlightOverlay extends Overlay
{
    private final Widget widget;
    private final Color color;
    private final Rectangle relativeBounds;

    public WidgetHighlightOverlay(final Widget widget, Color color, Rectangle relativeBounds)
    {
        this.widget = widget;
        this.color = color;
        this.relativeBounds = relativeBounds;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (widget == null)
        {
            return null;
        }

        Rectangle highlightBounds = widget.getBounds();

        if (highlightBounds == null)
        {
            return null;
        }

        highlightBounds.x += relativeBounds.x;
        highlightBounds.y += relativeBounds.y;
        highlightBounds.width = relativeBounds.width;
        highlightBounds.height = relativeBounds.height;

        drawHighlight(graphics, highlightBounds);
        return null;
    }

    private void drawHighlight(Graphics2D graphics, Rectangle bounds)
    {
        graphics.setColor(color);
        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import net.runelite.client.util.ImageUtil;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
@Singleton
public class BlockButton extends JButton
{
    private final SuggestionManager suggestionManager;
    private final SuggestionPreferencesManager preferencesManager;

    private static final ImageIcon BLOCK_ICON;
    private static final ImageIcon BLOCK_ICON_HOVER;

    static
    {
        var blockImg = ImageUtil.loadImageResource(BlockButton.class, "/block.png");
        BLOCK_ICON = new ImageIcon(blockImg);
        BLOCK_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(blockImg, BUTTON_HOVER_LUMINANCE));
    }

    @Inject
    public BlockButton(SuggestionManager suggestionManager, SuggestionPreferencesManager preferencesManager)
    {
        super(BLOCK_ICON);
        this.suggestionManager = suggestionManager;
        this.preferencesManager = preferencesManager;

        setToolTipText("Block this item");
        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);

        // Click action
        addActionListener(e -> confirmAndBlock());

        // Hover effects
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                setIcon(BLOCK_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                setIcon(BLOCK_ICON);
            }
        });
    }

    private void confirmAndBlock()
    {
        Suggestion s = suggestionManager.getSuggestion();
        if (s == null)
        {
            log.debug("No current suggestion to block.");
            return;
        }

        // Get item name or fallback text
        String itemName = s.getName() != null ? s.getName() : "this item";

        // Show a confirmation dialog
        int choice = JOptionPane.showConfirmDialog(
                this,
                "Do you want to block " + itemName + "?",
                "Confirm Block",
                JOptionPane.YES_NO_OPTION
        );

        // If user clicks YES, proceed with blocking
        if (choice == JOptionPane.YES_OPTION)
        {
            preferencesManager.blockItem(s.getItemId());
            log.debug("Blocked item with ID {} ({})", s.getItemId(), itemName);
            suggestionManager.setSuggestionNeeded(true);
        }
        else
        {
            log.debug("User canceled blocking for {}", itemName);
        }
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.PremiumInstanceController;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import com.flippingcopilot.model.SuggestionManager;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;

@Singleton
public class PreferencesPanel extends JPanel {

    private final SuggestionPreferencesManager preferencesManager;
    private final JPanel sellOnlyButton;
    private final PreferencesToggleButton sellOnlyModeToggleButton;
    private final JPanel f2pOnlyButton;
    private final PreferencesToggleButton f2pOnlyModeToggleButton;
    private final BlacklistDropdownPanel blacklistDropdownPanel;

    @Inject
    public PreferencesPanel(
            SuggestionManager suggestionManager,
            SuggestionPreferencesManager preferencesManager,
            BlacklistDropdownPanel blocklistDropdownPanel,
            PremiumInstanceController premiumInstanceController) {
        super();
        this.preferencesManager = preferencesManager;
        this.blacklistDropdownPanel = blocklistDropdownPanel;
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        setBounds(0, 0, 300, 150);

        JLabel preferencesTitle = new JLabel("Suggestion Settings");
        preferencesTitle.setForeground(Color.WHITE);
        preferencesTitle.setFont(preferencesTitle.getFont().deriveFont(Font.BOLD));
        preferencesTitle.setAlignmentX(Component.CENTER_ALIGNMENT);
        preferencesTitle.setMinimumSize(new Dimension(300, preferencesTitle.getPreferredSize().height));
        preferencesTitle.setMaximumSize(new Dimension(300, preferencesTitle.getPreferredSize().height));
        preferencesTitle.setHorizontalAlignment(SwingConstants.CENTER);
        add(preferencesTitle);
        add(Box.createRigidArea(new Dimension(0, 8)));
        add(this.blacklistDropdownPanel);

        sellOnlyModeToggleButton = new PreferencesToggleButton("Disable sell-only mode", "Enable sell-only mode");
        sellOnlyButton = new JPanel();
        sellOnlyButton.setLayout(new BorderLayout());
        sellOnlyButton.setOpaque(false);
        add(sellOnlyButton);
        JLabel buttonText = new JLabel("Sell-only mode");
        sellOnlyButton.add(buttonText, BorderLayout.LINE_START);
        sellOnlyButton.add(sellOnlyModeToggleButton, BorderLayout.LINE_END);
        sellOnlyModeToggleButton.addItemListener(i ->
        {
            preferencesManager.setSellOnlyMode(sellOnlyModeToggleButton.isSelected());
            suggestionManager.setSuggestionNeeded(true);
        });
        add(Box.createRigidArea(new Dimension(0, 3)));

        f2pOnlyModeToggleButton = new PreferencesToggleButton("Disable F2P-only mode",  "Enable F2P-only mode");
        f2pOnlyButton = new JPanel();
        f2pOnlyButton.setLayout(new BorderLayout());
        f2pOnlyButton.setOpaque(false);
        add(f2pOnlyButton);
        JLabel f2pOnlyButtonText = new JLabel("F2P-only mode");
        f2pOnlyButton.add(f2pOnlyButtonText, BorderLayout.LINE_START);
        f2pOnlyButton.add(f2pOnlyModeToggleButton, BorderLayout.LINE_END);
        f2pOnlyModeToggleButton.addItemListener(i ->
        {
            preferencesManager.setF2pOnlyMode(f2pOnlyModeToggleButton.isSelected());
            suggestionManager.setSuggestionNeeded(true);
        });

        // Premium instances panel - moved to the bottom
        add(Box.createRigidArea(new Dimension(0, 3)));
        JPanel premiumInstancesPanel = new JPanel();
        premiumInstancesPanel.setLayout(new BorderLayout());
        premiumInstancesPanel.setOpaque(false);
        JLabel premiumInstancesLabel = new JLabel("Premium accounts:");
        JButton manageButton = new JButton("manage");
        manageButton.addActionListener(e -> {
            premiumInstanceController.loadAndOpenPremiumInstanceDialog();
        });
        premiumInstancesPanel.add(premiumInstancesLabel, BorderLayout.LINE_START);
        premiumInstancesPanel.add(manageButton, BorderLayout.LINE_END);
        add(premiumInstancesPanel);
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }

        sellOnlyModeToggleButton.setSelected(preferencesManager.getPreferences().isSellOnlyMode());
        sellOnlyButton.setVisible(true);
        f2pOnlyModeToggleButton.setSelected(preferencesManager.getPreferences().isF2pOnlyMode());
        f2pOnlyButton.setVisible(true);
        blacklistDropdownPanel.setVisible(true);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.*;
import com.flippingcopilot.model.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;


import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicComboBoxEditor;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class StatsPanelV2 extends JPanel {


    public final BufferedImage TRASH_ICON = ImageUtil.loadImageResource(getClass(), "/trash.png");
    public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
    public final Icon OPEN_ICON = new ImageIcon(ARROW_ICON);
    public final Icon CLOSE_ICON = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(90)));

    private static final String ALL_ACCOUNTS_DROPDOWN_OPTION = "All accounts";
    private static final java.util.List<Integer> SESSION_STATS_INDS = Arrays.asList(3,4,5);
    private static final String[] TIME_INTERVAL_STRINGS = {
            "-1h (Past Hour)",
            "-4h (Past 4 Hours)",
            "-12h (Past 12 Hours)",
            "-1d (Past Day)",
            "-1w (Past Week)",
            "-1m (Past Month)",
            "Session",
            "All"};

    private static final Pattern INTERVAL_PATTERN = Pattern.compile("^-?(\\d+)([hdwmy])[()\\w\\s]*");

    // dependencies
    private final LoginResponseManager loginResponseManager;
    private final OsrsLoginManager osrsLoginManager;
    private final FlippingCopilotConfig config;
    private final FlipManager flipManager;
    private final SessionManager sessionManager;
    private final WebHookController webHookController;
    private final ClientThread clientThread;

    // state
    private JComboBox<String> timeIntervalDropdown;
    private final DefaultComboBoxModel<String> rsAccountDropdownModel = new DefaultComboBoxModel<>();
    private final JComboBox<String> rsAccountDropdown = new JComboBox<>(rsAccountDropdownModel);
    private final JButton sessionResetButton = new JButton("  Reset session ");
    private JPanel profitAndSubInfoPanel;
    private JPanel subInfoPanel;
    private final JPanel flipsPanel = new JPanel();
    private final JLabel totalProfitVal = new JLabel("0 gp");
    private final JLabel roiVal = new JLabel("-0.00%");
    private final JLabel flipsMadeVal = new JLabel("0");
    private final JLabel taxPaidVal = new JLabel("0 gp");
    private final JLabel sessionTimeVal = new JLabel("00:00:00");
    private final JLabel hourlyProfitVal = new JLabel("0 gp/hr");
    private final JLabel avgCashVal = new JLabel("0 gp");
    private final Paginator paginator;

    private IntervalTimeUnit selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
    private int selectedIntervalValue = -1;
    private volatile boolean lastValidState = false;

    @Inject
    public StatsPanelV2(LoginResponseManager loginResponseManager,
                        OsrsLoginManager osrsLoginManager,
                        FlippingCopilotConfig config,
                        FlipManager FlipManager,
                        SessionManager sessionManager,
                        WebHookController webHookController,
                        ClientThread clientThread) {
        this.loginResponseManager = loginResponseManager;
        this.osrsLoginManager = osrsLoginManager;
        this.sessionManager = sessionManager;
        this.webHookController = webHookController;
        this.config = config;
        this.flipManager = FlipManager;
        this.clientThread = clientThread;
        setLayout(new BorderLayout());

        setupTimeIntervalDropdown();
        setupProfitAndSubInfoPanel();
        setupSessionResetButton();

        flipsPanel.setLayout(new BoxLayout(flipsPanel, BoxLayout.Y_AXIS));
        flipsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        flipsPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

        JScrollPane scrollPane = new JScrollPane(flipsPanel);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

        // Create a main panel with vertical layout
        JPanel mainPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel timeIntervalDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        timeIntervalDropdownWrapper.setBorder(BorderFactory.createEmptyBorder()); // No border
        timeIntervalDropdownWrapper.add(timeIntervalDropdown, BorderLayout.CENTER);
        timeIntervalDropdownWrapper.add(sessionResetButton, BorderLayout.EAST);
        timeIntervalDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeIntervalDropdownWrapper.getPreferredSize().height));

        JPanel intervalRsAccountDropdownWrapper = new JPanel(new BorderLayout(0, 0));
        rsAccountDropdown.setBorder(BorderFactory.createEmptyBorder());
        rsAccountDropdown.setMaximumSize(new Dimension(Integer.MAX_VALUE, rsAccountDropdown.getPreferredSize().height));
        intervalRsAccountDropdownWrapper.add(timeIntervalDropdownWrapper, BorderLayout.NORTH);
        intervalRsAccountDropdownWrapper.add(rsAccountDropdown, BorderLayout.SOUTH);
        rsAccountDropdown.addActionListener(e -> {
            String value = (String) rsAccountDropdown.getSelectedItem();
            log.info("selected rs account is: {}", value);
            if(value != null) {
                if (ALL_ACCOUNTS_DROPDOWN_OPTION.equals(value)) {
                    flipManager.setIntervalDisplayName(null);
                } else {
                    flipManager.setIntervalDisplayName(value);
                }
            }
        });
        intervalRsAccountDropdownWrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, intervalRsAccountDropdownWrapper.getPreferredSize().height));

        mainPanel.add(intervalRsAccountDropdownWrapper);
        mainPanel.add(profitAndSubInfoPanel);
        mainPanel.add(scrollPane);

        add(mainPanel, BorderLayout.CENTER);

        paginator = new Paginator(() -> refresh(true, lastValidState));
        add(paginator, BorderLayout.SOUTH);

        flipManager.setFlipsChangedCallback(() -> refresh(true, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState()));
    }

    private void setupSessionResetButton() {
        sessionResetButton.setBorder(BorderFactory.createEmptyBorder());
        sessionResetButton.addActionListener((l) -> {
            JLabel resetIcon = new JLabel(new ImageIcon(TRASH_ICON));
            final int result = JOptionPane.showOptionDialog(resetIcon, "<html>Are you sure you want to reset the session?</html>",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");
            if (result == JOptionPane.YES_OPTION) {
                // send discord message before resetting session stats
                clientThread.invoke(() -> {
                    if (osrsLoginManager.isValidLoginState()) {
                        String displayName = osrsLoginManager.getPlayerDisplayName();
                        webHookController.sendMessage(flipManager.calculateStats(sessionManager.getCachedSessionData().startTime, displayName), sessionManager.getCachedSessionData(), displayName, true);
                        sessionManager.resetSession();
                        if (IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit)) {
                            flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                        }
                        refresh(true, loginResponseManager.isLoggedIn() && osrsLoginManager.isValidLoginState());
                    }
                });
            }
        });
    }

    public void resetIntervalDropdownToSession() {
        timeIntervalDropdown.setSelectedItem("Session");
        selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
        selectedIntervalValue = -1;
    }

    private boolean extractAndUpdateTimeInterval(String value) {
        if (value != null) {
            if ("Session".equals(value)) {
                selectedIntervalTimeUnit = IntervalTimeUnit.SESSION;
                selectedIntervalValue = -1;
                return true;
            } else if ("All".equals(value)) {
                selectedIntervalTimeUnit = IntervalTimeUnit.ALL;
                selectedIntervalValue = -1;
                return true;
            } else {
                Matcher matcher = INTERVAL_PATTERN.matcher(value);
                if (matcher.matches()) {
                    selectedIntervalValue = Integer.parseInt(matcher.group(1));
                    selectedIntervalTimeUnit = IntervalTimeUnit.fromString(matcher.group(2));
                    return true;
                }
            }
        }
        return false;
    }


    private void setupTimeIntervalDropdown() {
        timeIntervalDropdown = new JComboBox<>(TIME_INTERVAL_STRINGS);
        timeIntervalDropdown.setEditable(true);
        timeIntervalDropdown.setSelectedItem("Session");
        timeIntervalDropdown.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeIntervalDropdown.getPreferredSize().height));
        timeIntervalDropdown.setBorder(BorderFactory.createEmptyBorder());

        // Create a custom editor to handle both selection and manual input
        ComboBoxEditor editor = new BasicComboBoxEditor() {
            @Override
            public void setItem(Object item) {
                super.setItem(item);
                if (item != null) {
                    String value = item.toString();
                    if (extractAndUpdateTimeInterval(value)) {
                        updateFlipManagerAndStats();
                    }
                }
            }
        };
        timeIntervalDropdown.setEditor(editor);

        // Add action listener for selection changes and manual edits
        timeIntervalDropdown.addActionListener(e -> {
            String value = (String) timeIntervalDropdown.getSelectedItem();
            if (extractAndUpdateTimeInterval(value)) {
                updateFlipManagerAndStats();
            }
        });
    }

    private void updateFlipManagerAndStats() {
        log.debug("selection interval value updated to {} {}", selectedIntervalValue, selectedIntervalTimeUnit);
        switch (selectedIntervalTimeUnit) {
            case ALL:
                flipManager.setIntervalStartTime(1);
                break;
            case SESSION:
                flipManager.setIntervalStartTime(sessionManager.getCachedSessionData().startTime);
                break;
            default:
                int startTime = (int) Instant.now().getEpochSecond() - selectedIntervalValue * selectedIntervalTimeUnit.getSeconds();
                flipManager.setIntervalStartTime(startTime);
        }
    }

    private JPanel buildSubInfoPanelItem(String key, JLabel value, Color valueColor) {
        JPanel item = new JPanel(new BorderLayout());
        item.setBorder(new EmptyBorder(4, 2, 4, 2));
        item.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel keyLabel = new JLabel(key);
        keyLabel.setFont(FontManager.getRunescapeSmallFont());
        item.add(keyLabel, BorderLayout.WEST);
        value.setFont(FontManager.getRunescapeSmallFont());
        value.setForeground(valueColor);
        item.add(value, BorderLayout.EAST);
        item.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));
        return item;
    }

    private JPanel buildSubInfoPanel() {
        JPanel subInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        subInfoPanel.add(buildSubInfoPanelItem("ROI:", roiVal, UIUtilities.TOMATO));
        subInfoPanel.add(buildSubInfoPanelItem("Flips made:", flipsMadeVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Tax paid:", taxPaidVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.add(buildSubInfoPanelItem("Session time:", sessionTimeVal, ColorScheme.GRAND_EXCHANGE_ALCH));
        subInfoPanel.add(buildSubInfoPanelItem("Hourly profit:", hourlyProfitVal, Color.WHITE));
        subInfoPanel.add(buildSubInfoPanelItem("Avg wealth:", avgCashVal, ColorScheme.LIGHT_GRAY_COLOR));
        subInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        subInfoPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(0,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(2, 5, 5, 5)));
       return subInfoPanel;
    }

    private void setupProfitAndSubInfoPanel() {
        profitAndSubInfoPanel = UIUtilities.newVerticalBoxLayoutJPanel();
        profitAndSubInfoPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Create the header panel that can be clicked to expand/collapse sub info
        JPanel headerPanel = new JPanel(new BorderLayout());
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        headerPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1,0,1,0, ColorScheme.DARK_GRAY_COLOR),
                new EmptyBorder(5, 0, 5, 0)));

        final JLabel profitTitle = new JLabel("Profit: ");
        profitTitle.setFont(FontManager.getRunescapeBoldFont());

        totalProfitVal.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        totalProfitVal.setFont(FontManager.getRunescapeBoldFont().deriveFont(24f));
        totalProfitVal.setHorizontalAlignment(SwingConstants.CENTER);

        // Use a panel to stack the profitTitle and totalProfitVal vertically
        JPanel profitTextPanel = new JPanel();
        profitTextPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        profitTextPanel.add(profitTitle);
        profitTextPanel.add(Box.createRigidArea(new Dimension(5, 0))); // Spacing between title and value
        profitTextPanel.add(totalProfitVal);
        profitTextPanel.setBorder(BorderFactory.createEmptyBorder(2,4,2,4));

        // Arrow label
        JLabel arrowLabel = new JLabel(OPEN_ICON);
        arrowLabel.setHorizontalAlignment(SwingConstants.CENTER);
        arrowLabel.setVerticalAlignment(SwingConstants.CENTER);
        arrowLabel.setPreferredSize(new Dimension(16, 16)); // Adjust size as needed

        // Add components to headerPanel
        headerPanel.add(profitTextPanel, BorderLayout.CENTER);
        headerPanel.add(arrowLabel, BorderLayout.EAST);

        // Create the sub-info panel
        subInfoPanel = buildSubInfoPanel();

        headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 70));
        profitAndSubInfoPanel.add(headerPanel);
        profitAndSubInfoPanel.add(subInfoPanel);

        // Mouse listener to handle expand/collapse and hover effects
        MouseAdapter headerMouseListener = new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                boolean isExpanded = subInfoPanel.isVisible();
                if(!isExpanded && rsAccountDropdownModel.getSize() > 2) {
                    rsAccountDropdown.setVisible(true);
                } else if (isExpanded && rsAccountDropdownModel.getSize() > 2) {
                    rsAccountDropdown.setVisible(false);
                }
                subInfoPanel.setVisible(!isExpanded);
                arrowLabel.setIcon(isExpanded ? OPEN_ICON : CLOSE_ICON);
                log.debug("profit and sub info panel clicked");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.brighter());
                headerPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            }

            @Override
            public void mouseExited(MouseEvent e) {
                headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                profitTextPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                headerPanel.setCursor(Cursor.getDefaultCursor());
            }
        };

        // Add mouse listener to header components
        headerPanel.addMouseListener(headerMouseListener);
        totalProfitVal.addMouseListener(headerMouseListener);
        profitTitle.addMouseListener(headerMouseListener);

    }

    // called when:
    //
    // - time interval drop down changed (Swing EDT thread)
    // - session reset button pressed (Swing EDT thread)
    // - transaction processing downstream (ScheduledExecutorService)
    // - FlipTrackerV2 initialisation (ScheduledExecutorService)
    // - session stats updated (ScheduledExecutorService)
    // - plugin config changed (Client thread)
    // - page changed (Swing EDT thread)
    //

    public void refresh(boolean flipsMaybeChanged, boolean validLoginState) {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(() -> refresh(flipsMaybeChanged, validLoginState));
            return;
        }
        lastValidState = validLoginState;
        if (!validLoginState) {
            totalProfitVal.setText("0 gp");
            roiVal.setText("-0.00%");
            flipsMadeVal.setText("0");
            taxPaidVal.setText("0 gp");
            sessionTimeVal.setText("00:00:00");
            hourlyProfitVal.setText("0 gp/hr");
            avgCashVal.setText("0 gp");
            flipsPanel.removeAll();
            paginator.setTotalPages(1);
            boolean v = IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit);
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(v));
            rsAccountDropdownModel.removeAllElements();
            rsAccountDropdown.setVisible(false);
            return;
        }

        java.util.List<String> displayNameOptions = flipManager.getDisplayNameOptions();
        String selectedDisplayName = flipManager.getIntervalDisplayName();
        if (displayNameOptionsOutOfDate(displayNameOptions) || selectedDisplayNameOutOfDate(selectedDisplayName)) {
            rsAccountDropdownModel.removeAllElements();
            rsAccountDropdownModel.addAll(displayNameOptions);
            rsAccountDropdownModel.addElement(ALL_ACCOUNTS_DROPDOWN_OPTION);
            if (selectedDisplayName == null) {
                rsAccountDropdown.setSelectedItem(rsAccountDropdownModel.getElementAt(rsAccountDropdownModel.getSize()-1));
            } else {
                rsAccountDropdown.setSelectedItem(selectedDisplayName);
            }
            if(rsAccountDropdownModel.getSize() > 2) {
                rsAccountDropdown.setVisible(true);
            }
        }

        SessionData sd = sessionManager.getCachedSessionData();
        Stats stats = flipManager.getIntervalStats();
        paginator.setTotalPages(1 + stats.flipsMade / 50);
        long s = System.nanoTime();
        if (flipsMaybeChanged) {
            flipsPanel.removeAll();
            flipManager.getPageFlips(paginator.getPageNumber(), 50).forEach(f -> flipsPanel.add(new FlipPanel(f, config)));
            // labels displayed to the user
            roiVal.setText(String.format("%.3f%%", stats.calculateRoi() * 100));
            roiVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            flipsMadeVal.setText(String.format("%d", stats.flipsMade));
            taxPaidVal.setText(UIUtilities.formatProfit(stats.taxPaid));
            totalProfitVal.setText(UIUtilities.formatProfit(stats.profit));
            totalProfitVal.setForeground(UIUtilities.getProfitColor(stats.profit, config));
            log.debug("populating flips took {}ms", (System.nanoTime() - s) / 1000_000);
        }

        // 'Session time', 'Hourly profit' and 'Avg wealth' should only be set if 'Session' is select in the dropdown
        if (IntervalTimeUnit.SESSION.equals(selectedIntervalTimeUnit)) {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(true));
            long seconds = sd.durationMillis / 1000;
            float hoursFloat = (((float) seconds) / 3600.0f);
            long hourlyProfit = hoursFloat == 0 ? 0 : (long) (stats.profit / hoursFloat);
            String sessionTime = String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
            sessionTimeVal.setText(sessionTime);
            hourlyProfitVal.setText(UIUtilities.formatProfitWithoutGp(hourlyProfit) + " gp/hr");
            hourlyProfitVal.setForeground(UIUtilities.getProfitColor(hourlyProfit, config));
            avgCashVal.setText(UIUtilities.quantityToRSDecimalStack(Math.abs(sd.averageCash), false) + " gp");
        } else {
            SESSION_STATS_INDS.forEach(i -> subInfoPanel.getComponent(i).setVisible(false));
        }
    }

    private boolean selectedDisplayNameOutOfDate(String selectedDisplayName) {
        String oldSelectedDisplayName = (String) rsAccountDropdown.getSelectedItem();
        if (ALL_ACCOUNTS_DROPDOWN_OPTION.equals(oldSelectedDisplayName) && selectedDisplayName == null) {
            return false;
        }
        return !Objects.equals(oldSelectedDisplayName, selectedDisplayName);
    }

    private boolean displayNameOptionsOutOfDate(List<String> displayNameOptions) {
        if (displayNameOptions.size() + 1 != rsAccountDropdownModel.getSize()) {
            return true;
        }
        for(int i = 0; i< displayNameOptions.size(); i++) {
            if (!displayNameOptions.get(i).equals(rsAccountDropdownModel.getElementAt(i))) {
                return true;
            }
        }
        return false;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;

public class UIUtilities {
    public static final String discordIcon = "/discord.png";
    public static final String githubIcon = "/github.png";
    public static final String logoutIcon = "/logout.png";
    public static final String internetIcon = "/internet.png";
    public static final String graphIcon = "/graph.png";

    static final float BUTTON_HOVER_LUMINANCE = 0.65f;
    public static final Color OUTDATED_COLOR = new Color(250, 74, 75);
    public static final Color BLUE_HIGHLIGHT_COLOR =  new Color(27, 173, 255, 79);
    public static final Color RED_HIGHLIGHT_COLOR = new Color(255, 20, 20, 79);
    public static final Color TOMATO = new Color(255,99,71);
    public static final Color DARK_GRAY = new Color(27, 27, 27);

    private static final NumberFormat PRECISE_DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.###",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );
    private static final NumberFormat DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.#",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );

    public static synchronized String quantityToRSDecimalStack(long quantity, boolean precise)
    {
        if (Long.toString(quantity).length() <= 4)
        {
            return QuantityFormatter.formatNumber(quantity);
        }

        long power = (long) Math.log10(quantity);

        // Output thousandths for values above a million
        NumberFormat format = precise && power >= 6
                ? PRECISE_DECIMAL_FORMATTER
                : DECIMAL_FORMATTER;

        return format.format(quantity / Math.pow(10, (Long.divideUnsigned(power, 3)) * 3))
                + new String[] {"", "K", "M", "B", "T"}[(int) (power / 3)];
    }

    public static Color getProfitColor(long profit, FlippingCopilotConfig config) {
        if (profit > 0) {
            return config.profitAmountColor();
        } else if (profit < 0) {
            return config.lossAmountColor();
        } else {
            return Color.WHITE;
        }
    }

    public static String formatProfit(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true) + " gp";
    }

    public static String formatProfitWithoutGp(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true);
    }

    public static String truncateString(String string, int length) {
        if (string.length() > length) {
            return string.substring(0, length) + "...";
        }
        return string;
    }

    static JLabel buildButton(BufferedImage icon, String tooltip, Runnable onClick) {
        JLabel label = new JLabel();
        label.setToolTipText(tooltip);
        label.setHorizontalAlignment(JLabel.CENTER);
        ImageIcon iconOff = new ImageIcon(icon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(icon, BUTTON_HOVER_LUMINANCE));
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                try {
                    onClick.run();
                } catch (Exception error) {}
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                label.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setIcon(iconOff);
            }
        });
        label.setIcon(iconOff);
        return label;
    }

    static JLabel buildUriButton(BufferedImage icon, String tooltip, String uriString) {
        return buildButton(icon, tooltip, () -> {
            try {
                Desktop desktop = Desktop.getDesktop();
                URI uri = new URI(uriString);
                desktop.browse(uri);
            } catch (Exception error) {}
        });
    }

    public static JPanel newVerticalBoxLayoutJPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        return panel;
    }
}

package com.flippingcopilot.ui;


import java.awt.Dimension;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JToggleButton;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

class PreferencesToggleButton extends JToggleButton
{
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;
    private final String unSelectedToolTipText;
    private final String selectedToolTipText;


    public PreferencesToggleButton(String selectedToolTipText, String unSelectedToolTipText) {
        super(OFF_SWITCHER);
        setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        setPreferredSize(new Dimension(25, 25));
        addItemListener(l -> updateTooltip());
        updateTooltip();
        this.selectedToolTipText = selectedToolTipText;
        this.unSelectedToolTipText = unSelectedToolTipText;
    }

    static
    {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(CopilotPanel.class, "/switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    private void updateTooltip()
    {
        setToolTipText(isSelected() ? selectedToolTipText :  unSelectedToolTipText);
    }
}

package com.flippingcopilot.ui;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

@Slf4j
public class Paginator extends JPanel {

	public final BufferedImage ARROW_ICON = ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png");
	public final Icon ARROW_RIGHT = new ImageIcon(ARROW_ICON);
	public final Icon HIGHLIGHTED_ARROW_RIGHT = new ImageIcon(ImageUtil.luminanceScale(ARROW_ICON, BUTTON_HOVER_LUMINANCE));
	public final Icon ARROW_LEFT = new ImageIcon(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)));
	public final Icon HIGHLIGHTED_ARROW_LEFT = new ImageIcon(ImageUtil.luminanceScale(ImageUtil.rotateImage(ARROW_ICON, Math.toRadians(180)), BUTTON_HOVER_LUMINANCE));

	@Getter
	private int pageNumber = 1;
	@Getter
	private int totalPages = 1;
	private final JLabel statusText = new JLabel("Page 1 of 1", SwingUtilities.CENTER);
	private final JLabel arrowRight= new JLabel(ARROW_RIGHT);
	private final JLabel arrowLeft =  new JLabel(ARROW_LEFT);
	private final Runnable onPageChange;

	public Paginator(Runnable onPageChange) {
		this.onPageChange = onPageChange;
		this.statusText.setFont(FontManager.getRunescapeFont());
		this.arrowRight.setForeground(Color.blue);
		setLayout(new FlowLayout());
		add(arrowLeft);
		add(statusText);
		add(arrowRight);
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(3, 0, 0, 0));
		arrowLeft.addMouseListener(onDecreasePage());
		arrowRight.addMouseListener(onIncreasePage());
	}

	public void setTotalPages(int totalPages) {
		this.totalPages = totalPages;
		if(pageNumber > this.totalPages) {
			pageNumber = 1;
		}
		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	private MouseAdapter onIncreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber < totalPages) {
					pageNumber++;
					onPageChange.run();
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowRight.setIcon(HIGHLIGHTED_ARROW_RIGHT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowRight.setIcon(ARROW_RIGHT);
			}
		};
	}

	private MouseAdapter onDecreasePage() {
		return new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (pageNumber > 1) {
					pageNumber--;
					onPageChange.run();
					statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				arrowLeft.setIcon(HIGHLIGHTED_ARROW_LEFT);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				arrowLeft.setIcon(ARROW_LEFT);
			}
		};
	}
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.CopilotLoginController;
import com.flippingcopilot.model.LoginResponseManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;;

import static com.flippingcopilot.ui.UIUtilities.buildButton;

@Singleton
public class MainPanel extends PluginPanel {

    // dependencies
    public final LoginPanel loginPanel;
    public final CopilotPanel copilotPanel;
    private final LoginResponseManager loginResponseManager;
    private final CopilotLoginController copilotLoginController;

    private Boolean isLoggedInView;

    @Inject
    public MainPanel(CopilotPanel copilotPanel,
                     LoginPanel loginPanel,
                     LoginResponseManager loginResponseManager,
                     CopilotLoginController copilotLoginController) {
        super(false);
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(5, 6, 5, 6));
        this.loginResponseManager = loginResponseManager;
        this.copilotPanel = copilotPanel;
        this.loginPanel = loginPanel;
        this.copilotLoginController = copilotLoginController;
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        boolean shouldBeLoggedInView = loginResponseManager.isLoggedIn();
        if(shouldBeLoggedInView) {
            if (isLoggedInView == null || !isLoggedInView) {
                renderLoggedInView();
            }
            copilotPanel.refresh();
        } else {
            if (isLoggedInView == null || isLoggedInView) {
                renderLoggedOutView();
            }
            loginPanel.refresh();
            copilotPanel.suggestionPanel.refresh();
        }
    }

    public void renderLoggedOutView() {
        removeAll();
        add(constructTopBar(false), BorderLayout.NORTH);
        loginPanel.showLoginErrorMessage("");
        add(loginPanel, BorderLayout.CENTER);
        revalidate();
        isLoggedInView = false;
    }

    public void renderLoggedInView() {
        removeAll();
        add(constructTopBar(true), BorderLayout.NORTH);
        add(copilotPanel, BorderLayout.CENTER);
        revalidate();
        isLoggedInView = true;
    }

    private JPanel constructTopBar(boolean isLoggedIn) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setLayout(new BorderLayout());
        JPanel topBar = new JPanel();
        topBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int columns = isLoggedIn ? 4 : 3;
        topBar.setLayout(new GridLayout(1, columns));

        JLabel discord = buildTopBarUriButton(UIUtilities.discordIcon,
                "Flipping Copilot Discord",
                "https://discord.gg/UyQxA4QJAq");
        topBar.add(discord);

        JLabel website = buildTopBarUriButton(UIUtilities.internetIcon,
                "Flipping Copilot website",
                "https://flippingcopilot.com");
        topBar.add(website);

        if (isLoggedIn) {
            BufferedImage icon = ImageUtil.loadImageResource(getClass(), UIUtilities.logoutIcon);
            JLabel logout = buildButton(icon, "Log out", () -> {
                copilotLoginController.onLogout();
                renderLoggedOutView();
            });
            topBar.add(logout);
        }

        container.add(topBar);
        container.setBorder(new EmptyBorder(3, 0, 10, 0));
        return container;
    }

    private JLabel buildTopBarUriButton(String iconPath, String tooltip, String uriString) {
        BufferedImage icon = ImageUtil.loadImageResource(getClass(), iconPath);
        return buildButton(icon, tooltip, () -> {
            LinkBrowser.browse(uriString);
        });
    }

}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.OfferHandler;
import com.flippingcopilot.model.OfferManager;
import com.flippingcopilot.model.Suggestion;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.widgets.*;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class OfferEditor {
    private final OfferManager offerManager;
    private final OfferHandler offerHandler;
    private final Client client;

    private Widget text;
    private Widget priceGraphText;
    private static final int MOUSE_OFF_TEXT_COLOR = 0x0040FF;
    private static final int MOUSE_OFF_ERROR_TEXT_COLOR = 0xAA2222;

    public OfferEditor(OfferManager offerManager, Widget parent, OfferHandler offerHandler, Client client) {
        this.offerManager = offerManager;
        this.offerHandler = offerHandler;
        this.client = client;
        if (parent == null) {
            return;
        }

        text = parent.createChild(-1, WidgetType.TEXT);
        prepareTextWidget(text, WidgetTextAlignment.LEFT, WidgetPositionMode.ABSOLUTE_TOP, 40, 10);
    }

    private void prepareTextWidget(Widget widget, int xAlignment, int yMode, int yOffset, int xOffset) {
        widget.setTextColor(MOUSE_OFF_TEXT_COLOR);
        widget.setFontId(FontID.VERDANA_11_BOLD);
        widget.setYPositionMode(yMode);
        widget.setOriginalX(xOffset);
        widget.setOriginalY(yOffset);
        widget.setOriginalHeight(20);
        widget.setXTextAlignment(xAlignment);
        widget.setWidthMode(WidgetSizeMode.MINUS);
        widget.revalidate();
    }

    public void showSuggestion(Suggestion suggestion) {
        var currentItemId = client.getVarpValue(CURRENT_GE_ITEM);
        if (offerHandler.isSettingQuantity()) {
            if (currentItemId != suggestion.getItemId()) {
                return;
            }
            if (!suggestion.getType().equals(offerHandler.getOfferType())) {
                return;
            }

            shiftChatboxWidgetsDown();
            showQuantity(suggestion.getQuantity());
        } else if (offerHandler.isSettingPrice()) {
            if (currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(offerHandler.getOfferType())) {
                int price = offerManager.getViewedSlotItemPrice();
                if (offerHandler.getViewedSlotPriceErrorText() != null && price <= 0) {
                    shiftChatboxWidgetsDown();
                    setErrorText(offerHandler.getViewedSlotPriceErrorText());
                    return;
                }

                if (offerManager.getViewedSlotItemId() == currentItemId) {
                    shiftChatboxWidgetsDown();
                    if (offerHandler.getViewedSlotPriceErrorText() != null) {
                        showPriceWithWarning(price, offerHandler.getViewedSlotPriceErrorText());
                    } else {
                        showPrice(price);
                    }
                }
            } else {
                shiftChatboxWidgetsDown();
                showPrice(suggestion.getPrice());
            }
        }
    }

    private void showQuantity(int quantity) {
        text.setText("set to Copilot quantity: " + quantity);
        text.setAction(1, "Set quantity");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(quantity);
        });
    }

    public void showPrice(int price) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp");
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(price);
        });
    }

    private void showPriceWithWarning(int price, String warning) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp. " + warning);
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            offerHandler.setChatboxValue(price);
        });
    }

    private void setHoverListeners(Widget widget) {
        widget.setHasListener(true);
        widget.setOnMouseRepeatListener((JavaScriptCallback) ev -> widget.setTextColor(0xFFFFFF));
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> widget.setTextColor(MOUSE_OFF_TEXT_COLOR));
    }

    private void setErrorText(String message) {
        text.setText(message);
        text.setTextColor(MOUSE_OFF_ERROR_TEXT_COLOR);
        text.revalidate();
    }

    private void shiftChatboxWidgetsDown() {
        Widget chatboxTitle = client.getWidget(ComponentID.CHATBOX_TITLE);
        if (chatboxTitle != null) {
            chatboxTitle.setOriginalY(chatboxTitle.getOriginalY() + 7);
            chatboxTitle.revalidate();
        }
    }
}
package com.flippingcopilot.ui;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

@Getter
public class Spinner extends JPanel {
    private final JLabel spinnerLabel = new JLabel();

    public Spinner() {
        setLayout(new GridBagLayout());
        setOpaque(false);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = GridBagConstraints.REMAINDER;
        gbc.gridy = GridBagConstraints.REMAINDER;
        gbc.weightx = 1;
        gbc.weighty = 1;
        gbc.anchor = GridBagConstraints.CENTER;

        spinnerLabel.setPreferredSize(new Dimension(30, 30));
        add(spinnerLabel, gbc);
        setUpIcon();
        hide();
    }

    public void show() {
        spinnerLabel.setVisible(true);
    }

    public void hide() {
        spinnerLabel.setVisible(false);
    }

    private void setUpIcon() {
        IconTextField.Icon icon = IconTextField.Icon.LOADING;
        final ImageIcon imageIcon = new ImageIcon(Objects.requireNonNull(IconTextField.class.getResource(icon.getFile())));
        spinnerLabel.setIcon(imageIcon);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.GrandExchange;
import com.flippingcopilot.controller.HighlightController;
import com.flippingcopilot.controller.PremiumInstanceController;
import com.flippingcopilot.model.*;
import com.flippingcopilot.ui.graph.PriceGraphController;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;

import static com.flippingcopilot.ui.UIUtilities.*;
import static com.flippingcopilot.util.Constants.MIN_GP_NEEDED_TO_FLIP;


@Singleton
@Slf4j
public class SuggestionPanel extends JPanel {

    // dependencies
    private final FlippingCopilotConfig config;
    private final SuggestionManager suggestionManager;
    private final AccountStatusManager accountStatusManager;
    public final PauseButton pauseButton;
    private final BlockButton blockButton;
    private final OsrsLoginManager osrsLoginManager;
    private final Client client;
    private final PausedManager pausedManager;
    private final GrandExchangeUncollectedManager uncollectedManager;
    private final ClientThread clientThread;
    private final HighlightController highlightController;
    private final ItemManager itemManager;
    private final GrandExchange grandExchange;
    private final PriceGraphController priceGraphController;
    private final PremiumInstanceController premiumInstanceController;

    private final JLabel suggestionText = new JLabel();
    private final JLabel suggestionIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png")));
    private final JPanel suggestionTextContainer = new JPanel();
    public final Spinner spinner = new Spinner();
    private JLabel skipButton;
    private final JPanel buttonContainer = new JPanel();
    private JLabel graphButton;
    private final JPanel suggestedActionPanel;
    private final PreferencesPanel preferencesPanel;
    private final JLayeredPane layeredPane = new JLayeredPane();
    private boolean isPreferencesPanelVisible = false;
    private final JLabel gearButton;
    private String innerSuggestionMessage;
    private String highlightedColor = "yellow";

    @Setter
    private String serverMessage = "";


    @Inject
    public SuggestionPanel(FlippingCopilotConfig config,
                           SuggestionManager suggestionManager,
                           AccountStatusManager accountStatusManager,
                           PauseButton pauseButton,
                           BlockButton blockButton,
                           PreferencesPanel preferencesPanel,
                           OsrsLoginManager osrsLoginManager,
                           Client client, PausedManager pausedManager,
                           GrandExchangeUncollectedManager uncollectedManager,
                           ClientThread clientThread,
                           HighlightController highlightController,
                           ItemManager itemManager,
                           GrandExchange grandExchange, PriceGraphController priceGraphController, PremiumInstanceController premiumInstanceController) {
        this.preferencesPanel = preferencesPanel;
        this.config = config;
        this.suggestionManager = suggestionManager;
        this.accountStatusManager = accountStatusManager;
        this.pauseButton = pauseButton;
        this.blockButton = blockButton;
        this.osrsLoginManager = osrsLoginManager;
        this.client = client;
        this.pausedManager = pausedManager;
        this.uncollectedManager = uncollectedManager;
        this.clientThread = clientThread;
        this.highlightController = highlightController;
        this.itemManager = itemManager;
        this.grandExchange = grandExchange;
        this.priceGraphController = priceGraphController;
        this.premiumInstanceController = premiumInstanceController;

        // Create the layered pane first
        layeredPane.setLayout(null);  // LayeredPane needs null layout

        // Create a main panel that will hold all the regular components
        suggestedActionPanel = new JPanel(new BorderLayout());
        suggestedActionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestedActionPanel.setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        suggestedActionPanel.setBounds(0, 0, 300, 150);  // Set appropriate size
        JLabel title = new JLabel("<html><center> <FONT COLOR=white><b>Suggested Action:" +
                "</b></FONT></center></html>");
        title.setHorizontalAlignment(SwingConstants.CENTER);
        suggestedActionPanel.add(title, BorderLayout.NORTH);

        JPanel suggestionContainer = new JPanel();
        suggestionContainer.setLayout(new CardLayout());
        suggestionContainer.setOpaque(true);
        suggestionContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.setPreferredSize(new Dimension(0, 85));
        suggestedActionPanel.add(suggestionContainer, BorderLayout.CENTER);

        suggestionTextContainer.setLayout(new BoxLayout(suggestionTextContainer, BoxLayout.X_AXIS));
        suggestionTextContainer.add(Box.createHorizontalGlue());
        suggestionTextContainer.add(suggestionIcon);
        suggestionTextContainer.add(suggestionText);
        suggestionTextContainer.add(Box.createHorizontalGlue());
        suggestionTextContainer.setOpaque(true);
        suggestionTextContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionIcon.setVisible(false);
        suggestionIcon.setOpaque(true);
        suggestionIcon.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionIcon.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));

        suggestionText.setHorizontalAlignment(SwingConstants.CENTER);
        suggestionText.setBorder(BorderFactory.createEmptyBorder(0, 6, 0, 6));
        suggestionContainer.add(suggestionTextContainer);

        suggestionContainer.add(spinner);
        setupButtonContainer();
        suggestedActionPanel.add(buttonContainer, BorderLayout.SOUTH);


        layeredPane.add(suggestedActionPanel, JLayeredPane.DEFAULT_LAYER);

        // Build the suggestion preferences panel:
        this.preferencesPanel.setVisible(false);
        layeredPane.add(this.preferencesPanel, JLayeredPane.DEFAULT_LAYER);

        // Create and add the gear button
        BufferedImage gearIcon = ImageUtil.loadImageResource(getClass(), "/preferences-icon.png");
        gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
        BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
        gearButton = buildButton(recoloredIcon, "Settings", () -> {});
        gearButton.setEnabled(true);
        gearButton.setFocusable(true);
        gearButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        gearButton.setOpaque(true);
        ImageIcon iconOff = new ImageIcon(recoloredIcon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(recoloredIcon, BUTTON_HOVER_LUMINANCE));
        // Replace the existing gear button MouseAdapter with this implementation
        gearButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (!SwingUtilities.isEventDispatchThread()) {
                    SwingUtilities.invokeLater(() -> handleGearClick());
                    return;
                }
                handleGearClick();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                gearButton.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                gearButton.setIcon(iconOff);
            }
        });
        gearButton.setOpaque(true);
        gearButton.setBounds(5, 5, 20, 20);
        layeredPane.add(gearButton, JLayeredPane.PALETTE_LAYER);

        // Set up the main panel
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setPreferredSize(new Dimension(0, 150));

        add(layeredPane);

        // Add a component listener to handle resizing
        addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                preferencesPanel.setBounds(0, 0, getWidth(), getHeight());
                suggestedActionPanel.setBounds(0, 0, getWidth(), getHeight());
                layeredPane.setPreferredSize(new Dimension(getWidth(), getHeight()));
            }
        });
    }

    // Add this as a private method in the class
    private void handleGearClick() {
//        Data data = getPriceData();
//
//        Manager.showPriceGraph(graphButton, data);


        isPreferencesPanelVisible = !isPreferencesPanelVisible;
        preferencesPanel.setVisible(isPreferencesPanelVisible);
        suggestedActionPanel.setVisible(!isPreferencesPanelVisible);
        refresh();
        layeredPane.revalidate();
        layeredPane.repaint();
    }

    private void setupButtonContainer() {
        buttonContainer.setLayout(new BorderLayout());
        buttonContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    
        JPanel centerPanel = new JPanel(new GridLayout(1, 5, 15, 0));
        centerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    
        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/graph.png");
        graphButton = buildButton(graphIcon, "Price graph", () -> {
            if(config.priceGraphWebsite().equals(FlippingCopilotConfig.PriceGraphWebsite.FLIPPING_COPILOT)) {
                Suggestion suggestion = suggestionManager.getSuggestion();
                priceGraphController.showPriceGraph( suggestion.getName(),true);
            } else {
                Suggestion suggestion = suggestionManager.getSuggestion();
                String url = config.priceGraphWebsite().getUrl(suggestion.getName(), suggestion.getItemId());
                LinkBrowser.browse(url);
            }
        });
        centerPanel.add(graphButton);
    
        JPanel emptyPanel = new JPanel();
        emptyPanel.setOpaque(false);
        centerPanel.add(emptyPanel);
        centerPanel.add(pauseButton);
        centerPanel.add(blockButton);
    
        BufferedImage skipIcon = ImageUtil.loadImageResource(getClass(), "/skip.png");
        skipButton = buildButton(skipIcon, "Skip suggestion", () -> {
            showLoading();
            Suggestion s = suggestionManager.getSuggestion();
            accountStatusManager.setSkipSuggestion(s != null ? s.getId() : -1);
            suggestionManager.setSuggestionNeeded(true);
        });
        centerPanel.add(skipButton);
        
        buttonContainer.add(centerPanel, BorderLayout.CENTER);
    }


    private void setItemIcon(int itemId) {
        AsyncBufferedImage image = itemManager.getImage(itemId);
        if (image != null) {
            image.addTo(suggestionIcon);
            suggestionIcon.setVisible(true);
        }
    }


    public void updateSuggestion(Suggestion suggestion) {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String suggestionString = "<html><center>";
        suggestionTextContainer.setVisible(false);

        switch (suggestion.getType()) {
            case "wait":
                suggestionString += "Wait <br>";
                break;
            case "abort":
                suggestionString += "Abort offer for<br><FONT COLOR=white>" + suggestion.getName() + "<br></FONT>";
                setItemIcon(suggestion.getItemId());
                break;
            case "buy":
            case "sell":
                String capitalisedAction = suggestion.getType().equals("buy") ? "Buy" : "Sell";
                suggestionString += capitalisedAction +
                        " <FONT COLOR=" + highlightedColor + ">" + formatter.format(suggestion.getQuantity()) + "</FONT><br>" +
                        "<FONT COLOR=white>" + suggestion.getName() + "</FONT><br>" +
                        "for <FONT COLOR=" + highlightedColor + ">" + formatter.format(suggestion.getPrice()) + "</FONT> gp<br>";
                setItemIcon(suggestion.getItemId());
                break;
            default:
                suggestionString += "Error processing suggestion<br>";
        }
        suggestionString += suggestion.getMessage();
        suggestionString += "</center><html>";
        innerSuggestionMessage = "";
        if(!suggestion.getType().equals("wait")) {
            setButtonsVisible(true);
        }
        suggestionText.setText(suggestionString);
        suggestionText.setMaximumSize(new Dimension(suggestionText.getPreferredSize().width, Integer.MAX_VALUE));
        suggestionTextContainer.setVisible(true);
        suggestionTextContainer.revalidate();
        suggestionTextContainer.repaint();
    }

    public void suggestCollect() {
        setMessage("Collect items");
        setButtonsVisible(false);
    }

    public void suggestAddGp() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        setMessage("Add " +
                "at least <FONT COLOR=" + highlightedColor + ">" + formatter.format(MIN_GP_NEEDED_TO_FLIP)
                               + "</FONT> gp<br>to your inventory<br>"
                               + "to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void suggestOpenGe() {
        setMessage("Open the Grand Exchange<br>"
                + "to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void setIsPausedMessage() {
        setMessage("Suggestions are paused");
        setButtonsVisible(false);
    }

    public void setMessage(String message) {
        innerSuggestionMessage = message;
        setButtonsVisible(false);

        // Check if message contains "<manage>"
        String displayMessage = message;
        if (message != null && message.contains("<manage>")) {
            // Replace <manage> with a styled link
            displayMessage = message.replace("<manage>",
                    "<a href='#' style='text-decoration:underline'>manage</a>");

            // Add mouse listener if not already present
            boolean hasListener = false;
            for (MouseListener listener : suggestionText.getMouseListeners()) {
                if (listener instanceof ManageClickListener) {
                    hasListener = true;
                    break;
                }
            }

            if (!hasListener) {
                suggestionText.addMouseListener(new ManageClickListener());
                // Make the label show a hand cursor when hovering over it
                suggestionText.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
        } else {
            suggestionText.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
        }
        suggestionText.setText("<html><center>" + displayMessage + "<br>" + serverMessage + "</center></html>");
        suggestionText.setMaximumSize(new Dimension(suggestionText.getPreferredSize().width, Integer.MAX_VALUE));
        suggestionTextContainer.revalidate();
        suggestionTextContainer.repaint();
    }

    private class ManageClickListener extends MouseAdapter {
        @Override
        public void mouseClicked(MouseEvent e) {
            String text = suggestionText.getText();
            if (text.contains("manage")) {
                premiumInstanceController.loadAndOpenPremiumInstanceDialog();
            }
        }
    }

    public boolean isCollectItemsSuggested() {
        return suggestionText.isVisible() && "Collect items".equals(innerSuggestionMessage);
    }

    public void showLoading() {
        suggestionTextContainer.setVisible(false);
        setServerMessage("");
        spinner.show();
        setButtonsVisible(false);
        suggestionIcon.setVisible(false);
        suggestionText.setText("");
    }

    public void hideLoading() {
        spinner.hide();
        suggestionTextContainer.setVisible(true);
    }

    private void setButtonsVisible(boolean visible) {
        skipButton.setVisible(visible);
        blockButton.setVisible(visible);
        graphButton.setVisible(visible);
        suggestionIcon.setVisible(visible);
    }

    public void displaySuggestion() {
        Suggestion suggestion = suggestionManager.getSuggestion();
        if (suggestion == null) {
            return;
        }
        AccountStatus accountStatus = accountStatusManager.getAccountStatus();
        if(accountStatus == null) {
            return;
        }
        setServerMessage(suggestion.getMessage());
        boolean collectNeeded = accountStatus.isCollectNeeded(suggestion);
        if(collectNeeded && !uncollectedManager.HasUncollected(osrsLoginManager.getAccountHash())) {
            log.warn("tick {} collect is suggested but there is nothing to collect! suggestion: {} {} {}", client.getTickCount(), suggestion.getType(), suggestion.getQuantity(), suggestion.getItemId());
        }
        if (collectNeeded) {
            suggestCollect();
        } else if(suggestion.getType().equals("wait") && !grandExchange.isOpen() && accountStatus.emptySlotExists()) {
            suggestOpenGe();
        }else if (suggestion.getType().equals("wait") && accountStatus.moreGpNeeded()) {
            suggestAddGp();
        }  else {
            updateSuggestion(suggestion);
        }
        highlightController.redraw();
    }

    public void refresh() {
        log.debug("refreshing suggestion panel {}", client.getGameState());
        if(!SwingUtilities.isEventDispatchThread()) {
            // we always execute this in the Swing EDT thread
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        if(isPreferencesPanelVisible) {
            preferencesPanel.refresh();
        }
        if (pausedManager.isPaused()) {
            setIsPausedMessage();
            hideLoading();
            return;
        }

        String errorMessage = osrsLoginManager.getInvalidStateDisplayMessage();
        if (errorMessage != null) {
            setMessage(errorMessage);
            hideLoading();
        }

        if(suggestionManager.isSuggestionRequestInProgress()) {
            showLoading();
            return;
        }
        hideLoading();

        final HttpResponseException suggestionError = suggestionManager.getSuggestionError();
        if(suggestionError != null) {
            highlightController.redraw();
            setMessage("Error: " + suggestionError.getMessage());
            return;
        }

        if(!client.isClientThread()) {
            clientThread.invoke(this::displaySuggestion);
        } else {
            displaySuggestion();
        }
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.PremiumInstanceStatus;
import com.flippingcopilot.model.SuggestionManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

@Slf4j
public class PremiumInstancePanel extends JPanel {

    private final CardLayout cardLayout;
    private final JPanel cardPanel;
    private final List<JComboBox<String>> instanceDropdowns;
    private final FlippingCopilotConfig config;
    private final ApiRequestHandler apiRequestHandler;
    private final SuggestionManager suggestionManager;

    public PremiumInstancePanel(FlippingCopilotConfig config, ApiRequestHandler apiRequestHandler, SuggestionManager suggestionManager) {
        this.config = config;
        this.apiRequestHandler = apiRequestHandler;
        this.suggestionManager = suggestionManager;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        cardLayout = new CardLayout();
        cardPanel = new JPanel(cardLayout);
        cardPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create loading panel
        JPanel loadingPanel = createLoadingPanel();
        cardPanel.add(loadingPanel, "loading");

        // Create error panel container (will be populated when error occurs)
        JPanel errorPanel = new JPanel(new BorderLayout());
        errorPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.add(errorPanel, "error");

        // Create management panel container (will be populated when data loads)
        JPanel managementPanel = new JPanel(new BorderLayout());
        managementPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.add(managementPanel, "management");

        add(cardPanel, BorderLayout.CENTER);

        instanceDropdowns = new ArrayList<>();
    }

    private JPanel createLoadingPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(0, 0, 10, 0);

        Spinner spinner = new Spinner();
        spinner.show();
        panel.add(spinner, gbc);

        gbc.gridy = 1;
        JLabel loadingLabel = new JLabel("Loading premium account data");
        loadingLabel.setForeground(Color.WHITE);
        panel.add(loadingLabel, gbc);

        return panel;
    }

    public void showLoading() {
        cardLayout.show(cardPanel, "loading");
    }

    public void showError(String errorMessage) {
        JPanel errorPanel = (JPanel) cardPanel.getComponent(1); // error panel
        errorPanel.removeAll();
        errorPanel.setLayout(new GridBagLayout());

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        JLabel errorLabel = new JLabel("<html><center>" + errorMessage + "</center></html>");
        errorLabel.setForeground(Color.RED);
        errorLabel.setHorizontalAlignment(SwingConstants.CENTER);
        errorPanel.add(errorLabel, gbc);

        cardLayout.show(cardPanel, "error");
    }

    public void showManagementView(PremiumInstanceStatus status) {
        JPanel managementPanel = (JPanel) cardPanel.getComponent(2); // management panel
        managementPanel.removeAll();
        managementPanel.setLayout(new BorderLayout());
        managementPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        managementPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Create header panel for the count label
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new BoxLayout(headerPanel, BoxLayout.Y_AXIS));
        headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add premium instances count
        JLabel countLabel = new JLabel("You have " + status.getPremiumInstancesCount() + " premium accounts");
        countLabel.setFont(countLabel.getFont().deriveFont(Font.BOLD));
        countLabel.setForeground(Color.WHITE);
        countLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        headerPanel.add(countLabel);
        headerPanel.add(Box.createRigidArea(new Dimension(0, 15)));

        // Add header to the top of the management panel
        managementPanel.add(headerPanel, BorderLayout.NORTH);

        // Clear existing dropdowns
        instanceDropdowns.clear();

        // Create a panel for the scrollable content
        JPanel scrollContent = new JPanel();
        scrollContent.setLayout(new BoxLayout(scrollContent, BoxLayout.Y_AXIS));
        scrollContent.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add dropdowns for each instance
        for (int i = 0; i < status.getPremiumInstancesCount(); i++) {
            JPanel instancePanel = new JPanel();
            instancePanel.setLayout(new FlowLayout(FlowLayout.LEFT));
            instancePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            instancePanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 35));

            JLabel instanceLabel = new JLabel("Premium account " + (i + 1) + ":");
            instanceLabel.setForeground(Color.WHITE);
            instanceLabel.setPreferredSize(new Dimension(130, 25));
            instancePanel.add(instanceLabel);

            JComboBox<String> dropdown = new JComboBox<>();
            dropdown.setPreferredSize(new Dimension(200, 25));

            // Add current assignment if exists
            String currentAssignment = null;
            if (i < status.getCurrentlyAssignedDisplayNames().size()) {
                dropdown.addItem("Unassigned");
                currentAssignment = status.getCurrentlyAssignedDisplayNames().get(i);
                dropdown.addItem(currentAssignment);
                dropdown.setSelectedIndex(1);
            } else {
                dropdown.addItem("Unassigned");
            }

            // Add available names
            for (String availableName : status.getAvailableDisplayNames()) {
                if (!availableName.equals(currentAssignment)) {
                    dropdown.addItem(availableName);
                }
            }

            instancePanel.add(dropdown);
            instanceDropdowns.add(dropdown);

            scrollContent.add(instancePanel);
            scrollContent.add(Box.createRigidArea(new Dimension(0, 5)));
        }

        // Add vertical glue to push everything to the top
        scrollContent.add(Box.createVerticalGlue());

        // Create a scroll pane for the content
        JScrollPane scrollPane = new JScrollPane(scrollContent);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getViewport().setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Add the scroll pane to the center of the management panel
        managementPanel.add(scrollPane, BorderLayout.CENTER);

        // Add bottom panel with changes remaining and update button
        JPanel bottomPanel = new JPanel(new BorderLayout());
        bottomPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        bottomPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));

        JLabel changesLabel = new JLabel("Changes remaining (re-charges 1 per day): " + status.getChangesRemaining());
        changesLabel.setForeground(config.lossAmountColor());
        changesLabel.setToolTipText("Remaining updates. This limit recharges by 1 every day up to a max of 12.");
        bottomPanel.add(changesLabel, BorderLayout.WEST);

        JButton updateButton = new JButton("Update");
        // Disable the update button if no changes remaining
        updateButton.setEnabled(status.getChangesRemaining() > 0);
        // Add tooltip to explain why button is disabled when changes = 0
        if (status.getChangesRemaining() <= 0) {
            updateButton.setToolTipText("No changes remaining. Wait for daily recharge.");
        }

        updateButton.addActionListener(e -> {
            this.showLoading();
            Consumer<PremiumInstanceStatus> c = (s) -> {
                SwingUtilities.invokeLater(() -> {  // Make sure UI updates happen on EDT
                    if (s.getLoadingError() != null && !s.getLoadingError().isEmpty()) {
                        this.showError(s.getLoadingError());
                    } else {
                        this.showManagementView(s);
                        suggestionManager.setSuggestionNeeded(true);
                    }
                });
            };
            List<String> desiredAssignedDisplayNames = new ArrayList<>();
            for (JComboBox<String> dropdown : instanceDropdowns) {
                String selectedName = (String) dropdown.getSelectedItem();
                if (selectedName != null && !selectedName.equals("Unassigned") && !desiredAssignedDisplayNames.contains(selectedName)) {
                    desiredAssignedDisplayNames.add(selectedName);
                }
            }
            apiRequestHandler.asyncUpdatePremiumInstances(c, desiredAssignedDisplayNames);
        });
        bottomPanel.add(updateButton, BorderLayout.EAST);

        // Add the bottom panel to the south of the management panel
        managementPanel.add(bottomPanel, BorderLayout.SOUTH);

        cardLayout.show(cardPanel, "management");
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.model.SuggestionManager;
import com.flippingcopilot.model.SuggestionPreferencesManager;
import net.runelite.client.ui.ColorScheme;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;

@Singleton
public class ControlPanel extends JPanel {

    private final SuggestionPreferencesManager preferencesManager;
    private final JPanel timeframePanel;
    private final JToggleButton btn5m;
    private final JToggleButton btn30m;
    private final JToggleButton btn2h;
    private final JToggleButton btn8h;

    @Inject
    public ControlPanel(
            SuggestionManager suggestionManager,
            SuggestionPreferencesManager preferencesManager) {
        this.preferencesManager = preferencesManager;
        
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        setBounds(0, 0, 300, 150);

        // Add timeframe buttons
        timeframePanel = new JPanel();
        timeframePanel.setLayout(new BoxLayout(timeframePanel, BoxLayout.Y_AXIS));
        timeframePanel.setOpaque(false);
        JLabel timeframeLabel = new JLabel("How often do you check offers?");
        timeframeLabel.setHorizontalAlignment(SwingConstants.LEFT);
        timeframeLabel.setMaximumSize(timeframeLabel.getPreferredSize());
        JPanel labelPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
        labelPanel.setOpaque(false);
        labelPanel.add(timeframeLabel);
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(1, 4, 0, 0));
        buttonPanel.setOpaque(false);
        ButtonGroup timeframeButtonGroup = new ButtonGroup();
        btn5m = createTimeframeButton("5m", 5, suggestionManager);
        btn30m = createTimeframeButton("30m", 30, suggestionManager);
        btn2h = createTimeframeButton("2h", 120, suggestionManager);
        btn8h = createTimeframeButton("8h", 480, suggestionManager);
        timeframeButtonGroup.add(btn5m);
        timeframeButtonGroup.add(btn30m);
        timeframeButtonGroup.add(btn2h);
        timeframeButtonGroup.add(btn8h);
        buttonPanel.add(btn5m);
        buttonPanel.add(btn30m);
        buttonPanel.add(btn2h);
        buttonPanel.add(btn8h);
        timeframePanel.add(labelPanel);
        timeframePanel.add(Box.createRigidArea(new Dimension(0, 3)));
        timeframePanel.add(buttonPanel);
        add(timeframePanel);
    }

    private JToggleButton createTimeframeButton(String label, int value, SuggestionManager suggestionManager) {
        JToggleButton button = new JToggleButton();
        button.addActionListener(e -> {
            preferencesManager.setTimeframe(value);
            suggestionManager.setSuggestionNeeded(true);
        });
        button.setMargin(new Insets(2, 4, 2, 4));
        button.setFocusPainted(false);
        button.setOpaque(true);
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setForeground(ColorScheme.TEXT_COLOR);

        // Set initial text as white
        button.setText("<html><font color='rgb(198, 198, 198)'>" + label + "</font></html>");

        // Change color and text when selected/unselected
        button.addChangeListener(e -> {
            if (button.isSelected()) {
                button.setBackground(ColorScheme.BRAND_ORANGE);
                button.setText("<html><font color='black'>" + label + "</font></html>");
            } else {
                button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                button.setText("<html><font color='rgb(198, 198, 198)'>" + label + "</font></html>");
            }
        });

        return button;
    }

    public void refresh() {
        if(!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(this::refresh);
            return;
        }
        
        int tf = preferencesManager.getTimeframe();
        btn5m.setSelected(tf == 5);
        btn30m.setSelected(tf == 30);
        btn2h.setSelected(tf == 120);
        btn8h.setSelected(tf == 480);
    }
} 
/*
 * Copyright (c) 2023, LlemonDuck <napkinorton@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import net.runelite.api.ItemComposition;
import org.apache.commons.text.similarity.JaroWinklerDistance;
import org.apache.commons.text.similarity.LongestCommonSubsequence;
import org.apache.commons.text.similarity.SimilarityScore;

import javax.inject.Singleton;
import java.util.function.ToDoubleFunction;

@Singleton
public class FuzzySearchScorer
{

	// can be swapped, but i found jaro-winkler to do well considering the variable length of inputs
	// whereas levenshtein biases toward strings of same len, regardless of overlap
	private final SimilarityScore<Double> baseAlgorithm = new JaroWinklerDistance();

	public Double score(String query, String itemName)
	{
		query = query.toLowerCase().replace('-', ' ');
		itemName = itemName.toLowerCase().replace('-', ' ');

		// we raise the score for longest substring of a word, scoring within [0,1]
		String[] queryWords = query.split(" ");
		String[] itemWords = itemName.split(" ");
		double lcsScore = 0.0;
		for (String queryWord : queryWords)
		{
			for (String itemWord : itemWords)
			{
				int lcsLen = new LongestCommonSubsequence().longestCommonSubsequence(queryWord, itemWord).length();
				lcsScore = Math.max(lcsScore, ((double) lcsLen) / queryWord.length());
			}
		}

		// and also raise the score for string "closeness", but strongly prefer high closeness, scoring within [-0.5,0.5]
		double proximityScore = Math.log10(10 * baseAlgorithm.apply(query, itemName)) - 0.5;

		// subtract 1.0 to filter out low-scoring results
		return lcsScore + proximityScore - 1.0;
	}

	public ToDoubleFunction<ItemComposition> comparator(String query)
	{
		// We do this so that for example the items "Anti-venom ..." are still at the top
		// when searching "anti venom"
		return item -> score(
			query.toLowerCase().replace('-', ' '),
			item.getName().toLowerCase().replace('-', ' ')
		);
	}

}

package com.flippingcopilot.ui;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import java.awt.*;

public class GpDropOverlay extends Overlay {
    private final OverlayManager overlayManager;
    private final long startTime;
    private final Point startPosition = new Point(); // Starting position of the text
    final TextComponent textComponent = new TextComponent();

    public GpDropOverlay(OverlayManager overlayManager, Client client, long profit, int slot) {
        this.overlayManager = overlayManager;
        this.startTime = System.currentTimeMillis();

        Widget slotWidget = client.getWidget(465, slot + 7);
        if (slotWidget == null) {
            return;
        }
        startPosition.x = slotWidget.getCanvasLocation().getX() + 35;
        startPosition.y = slotWidget.getCanvasLocation().getY() + 75;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        String absProfitText = UIUtilities.quantityToRSDecimalStack(Math.abs(profit), false);
        String profitText = (profit >= 0 ? "+ " : "- ") + absProfitText + " gp";
        textComponent.setText(profitText);
        textComponent.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 16f));
        if (profit < 0) {
            textComponent.setColor(Color.RED);
        } else {
            textComponent.setColor(Color.GREEN);
        }
        overlayManager.add(this);
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        long elapsed = System.currentTimeMillis() - startTime;
        if (elapsed > 3000) { // Display for 5 seconds
            overlayManager.remove(this);
            return null;
        }

        // Calculate the upward movement. Adjust the divisor to control the speed.
        int yOffset = (int) (elapsed / 50); // Moves up 1 pixel every 50ms

        // Ensure the text moves upwards by subtracting yOffset from the starting Y position
        Point currentPosition = new Point(startPosition.x, startPosition.y - yOffset);
        textComponent.setPosition(currentPosition);
        textComponent.render(graphics);

        return null;
    }
}
package com.flippingcopilot.ui.graph;


import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.PriceAxis;
import com.flippingcopilot.ui.graph.model.TimeAxis;

import java.time.Instant;
import java.time.ZoneId;
import java.time.ZoneOffset;

public class AxisCalculator {

    public static TimeAxis calculateTimeAxis(PlotArea pa, int localTimeOffsetSeconds) {

        int timeMin = pa.bounds.xMin;
        int timeMax = pa.bounds.xMax;

        int days = pa.bounds.xDelta() / Constants.DAY_SECONDS;
        int daysStep = Math.max(1, days / 7);

        int maxDay = ((timeMax + localTimeOffsetSeconds) / Constants.DAY_SECONDS) * Constants.DAY_SECONDS - localTimeOffsetSeconds;
        int minDay = ((timeMin + localTimeOffsetSeconds) / Constants.DAY_SECONDS) * Constants.DAY_SECONDS - localTimeOffsetSeconds;
        int[] dayTicks = new int[]{};
        while (maxDay > timeMin) {
            dayTicks = append(dayTicks, maxDay);
            maxDay -= daysStep * Constants.DAY_SECONDS;
        }

        int[] timeTicks = new int[]{};
        if (daysStep == 1) {
            if (dayTicks.length < 5) {
                // add 06:00, 12:00, 18:00
                for (int d : preAppend(dayTicks, minDay)) {
                    int tick06 = d + 6 * 60 * 60;     // 06:00
                    int tick12 = d + 12 * 60 * 60;    // 12:00
                    int tick18 = d + 18 * 60 * 60;    // 18:00

                    if (tick06 < timeMax && tick06 > timeMin) {
                        timeTicks = append(timeTicks, tick06);
                    }
                    if (tick12 < timeMax && tick12 > timeMin) {
                        timeTicks = append(timeTicks, tick12);
                    }
                    if (tick18 < timeMax && tick18 > timeMin) {
                        timeTicks = append(timeTicks, tick18);
                    }
                }
            } else if (dayTicks.length < 10){
                // add only 12:00
                for (int d : preAppend(dayTicks, dayTicks[0] - Constants.DAY_SECONDS)) {
                    int tick12 = d + 12 * 60 * 60;    // 12:00
                    if (tick12 > timeMin && tick12 < timeMax) {
                        timeTicks = append(timeTicks, tick12);
                    }
                }
            }
        }

        return new TimeAxis(
                dayTicks,
                timeTicks,
                new int[]{}
        );
    }

    public static PriceAxis calculatePriceAxis(PlotArea pa) {
        int maxAllowableTicks = 18;
        int maxAllowableGridLines = 28;

        int priceRange = pa.bounds.yDelta();
        int priceMin = pa.bounds.yMin;
        int priceMax = pa.bounds.yMax;

        int magnitude = (int) Math.floor(Math.log10(priceRange));
        int[] possibleSteps = {1, 2, 5, 10, 20, 25, 50, 100, 200, 250, 500};

        int stepSize = 0;
        int numTicks = Integer.MAX_VALUE;

        for (int baseStep : possibleSteps) {
            int candidateStep = baseStep * (int) Math.pow(10, magnitude - 1);
            candidateStep = Math.max(1, candidateStep);

            int candidateTicks = priceRange / candidateStep + 1;

            if (candidateTicks <= maxAllowableTicks && candidateStep > 0) {
                stepSize = candidateStep;
                numTicks = candidateTicks;
                break;
            }
        }

        if (stepSize == 0) {
            stepSize = 500 * (int) Math.pow(10, magnitude - 1);
            numTicks = priceRange / stepSize + 1;
        }

        int startTick = (priceMin / stepSize) * stepSize;
        if (startTick < priceMin) {
            startTick += stepSize;
        }

        int[] tickPrices = new int[numTicks];
        int tickIndex = 0;

        for (int price = startTick; price <= priceMax && tickIndex < numTicks; price += stepSize) {
            tickPrices[tickIndex++] = price;
        }

        if (tickIndex < numTicks) {
            int[] resizedTicks = new int[tickIndex];
            System.arraycopy(tickPrices, 0, resizedTicks, 0, tickIndex);
            tickPrices = resizedTicks;
        }

        int[] gridOnlyPrices = new int[0];

        if (tickPrices.length > 1) {
            int gridStep = stepSize / 2;
            if (gridStep > 0 && (tickPrices.length * 2 - 1) <= maxAllowableGridLines) {
                gridOnlyPrices = new int[tickPrices.length - 1];

                for (int i = 0; i < tickPrices.length - 1; i++) {
                    gridOnlyPrices[i] = tickPrices[i] + gridStep;
                }
            }
        }

        return new PriceAxis(tickPrices, gridOnlyPrices);
    }


    public static int[] append(int[] arr, int v) {
        int[] result = new int[arr.length + 1];
        System.arraycopy(arr, 0, result, 0, arr.length);
        result[arr.length] = v;
        return result;
    }

    public static int[] preAppend(int[] arr, int v) {
        int[] result = new int[arr.length + 1];
        result[0] = v;
        System.arraycopy(arr, 0, result, 1, arr.length);
        return result;
    }

    public static int getLocalTimeOffsetSeconds() {
        ZoneOffset offset = ZoneId.systemDefault().getRules().getOffset(Instant.now());
        return offset.getTotalSeconds();
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.Bounds;
import com.flippingcopilot.ui.graph.model.Config;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.awt.geom.RoundRectangle2D;

@Slf4j
@Getter
public class ZoomHandler {

    private static final int MIN_TIME_DELTA = 60*60;
    private static final int MIN_PRICE_DELTA = 5;
    @Setter
    private Point selectionStart = null;
    @Setter
    private Point selectionEnd = null;
    private boolean isSelecting = false;

    private final Rectangle homeButtonRect = new Rectangle();
    private final Rectangle maxButtonRect = new Rectangle();
    private final Rectangle zoomInButtonRect = new Rectangle();
    private final Rectangle zoomOutButtonRect = new Rectangle();
    private final Rectangle weekButtonRect = new Rectangle();
    private final Rectangle monthButtonRect = new Rectangle();

    public Bounds maxViewBounds;
    public Bounds homeViewBounds;
    public Bounds weekViewBounds;
    public Bounds monthViewBounds;

    public void startSelection(Point point) {
        selectionStart = new Point(point);
        selectionEnd = null;
        isSelecting = true;
    }

    public void applySelection(PlotArea pa) {
        if (selectionStart == null || selectionEnd == null) return;

        int selectionX1 = Math.max(Math.min(selectionStart.x, selectionEnd.x), 0);
        int selectionX2 = Math.min(Math.max(selectionStart.x, selectionEnd.x), pa.w);

        int selectionY1 = Math.max(Math.min(selectionStart.y, selectionEnd.y), 0);
        int selectionY2 = Math.min(Math.max(selectionStart.y, selectionEnd.y), pa.h);

        int newTimeMin = pa.bounds.xMin + (int)(((long)pa.bounds.xDelta() * (long)(selectionX1)) / pa.w);
        int newTimeMax = pa.bounds.xMin + (int)(((long)pa.bounds.xDelta() * (long)(selectionX2)) / pa.w);

        int newPriceMax = pa.bounds.yMax - (int)(((long)pa.bounds.yDelta() * (long)(selectionY1)) / pa.h);
        int newPriceMin = pa.bounds.yMax - (int)(((long)pa.bounds.yDelta() * (long)(selectionY2)) / pa.h);

        if (newTimeMax - newTimeMin < MIN_TIME_DELTA) {
            log.debug("zoomed time delta {}s too small", newTimeMax - newTimeMin);
            cancelSelection();
            return;
        }

        if (newPriceMax - newPriceMin < MIN_PRICE_DELTA) {
            log.debug("zoomed price delta {}s too small", newPriceMax - newPriceMin);
            cancelSelection();
            return;
        }

        pa.bounds = new Bounds(newTimeMin, newTimeMax, newPriceMin, newPriceMax);

        cancelSelection();
    }

    public void applyZoomIn(PlotArea pa) {
        pa.bounds.xMin = Math.min(pa.bounds.xMax - MIN_TIME_DELTA, pa.bounds.xMin + (int) (pa.bounds.xDelta()*0.2));

    }

    public void applyZoomOut(PlotArea pa) {
        int td = pa.bounds.xDelta();
        pa.bounds.xMin= Math.max(maxViewBounds.xMin, pa.bounds.xMin- (int) (td*0.2));
        pa.bounds.xMax = Math.min(maxViewBounds.xMax, pa.bounds.xMax + (int) (td*0.2));
        int pd = pa.bounds.yDelta();
        pa.bounds.yMin = Math.max(maxViewBounds.yMin, pa.bounds.yMin - (int) (pd*0.1));
        pa.bounds.yMax = Math.min(maxViewBounds.yMax, pa.bounds.yMax + (int) (pd*0.1));
    }

    public void applyHomeView(PlotArea pa) {
        pa.bounds = homeViewBounds.copy();
    }

    public void applyMaxView(PlotArea pa) {
        pa.bounds = maxViewBounds.copy();
    }

    public void applyWeekView(PlotArea pa) {
        pa.bounds = weekViewBounds.copy();
    }

    public void applyMonthView(PlotArea pa) {
        pa.bounds = monthViewBounds.copy();
    }

    public void cancelSelection() {
        selectionStart = null;
        selectionEnd = null;
        isSelecting = false;
    }

    public void drawSelectionRectangle(Graphics2D plotAreaG2) {
        if (!isSelecting || selectionStart == null || selectionEnd == null) return;

        int x = Math.min(selectionStart.x, selectionEnd.x);
        int y = Math.min(selectionStart.y, selectionEnd.y);
        int width = Math.abs(selectionEnd.x - selectionStart.x);
        int height = Math.abs(selectionEnd.y - selectionStart.y);

        plotAreaG2.setColor(Config.SELECTION_COLOR);
        plotAreaG2.fillRect(x, y, width, height);

        plotAreaG2.setColor(Config.SELECTION_BORDER_COLOR);
        plotAreaG2.setStroke(Config.SELECTION_STROKE);
        plotAreaG2.drawRect(x, y, width, height);
    }

    public void drawButtons(Graphics2D plotAreaG2, PlotArea pa, Point p) {

        int x = pa.w - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        int y = Config.GRAPH_BUTTON_MARGIN;

        // Width for text buttons (Week and Month)
        int textButtonWidth = Config.GRAPH_BUTTON_SIZE * 2;

        // Draw home button
        homeButtonRect.setBounds(x, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverHomeButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape homeButtonShape = new RoundRectangle2D.Float(
                x, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(homeButtonShape);
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setStroke(new java.awt.BasicStroke(1.5f));

        int margin = 4;
        int houseX = x + margin;
        int houseY = y + margin;
        int houseWidth = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int houseHeight = Config.GRAPH_BUTTON_SIZE - 2 * margin;

        // Roof
        int[] xPoints = {houseX, houseX + houseWidth / 2, houseX + houseWidth};
        int[] yPoints = {houseY + houseHeight / 2, houseY, houseY + houseHeight / 2};
        plotAreaG2.fillPolygon(xPoints, yPoints, 3);

        // House body
        plotAreaG2.fillRect(houseX + houseWidth / 5, houseY + houseHeight / 2,
                3 * houseWidth / 5, houseHeight / 2);

        // Draw max button
        int maxButtonX = x - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        maxButtonRect.setBounds(maxButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverMaxButton(p)  ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape maxButtonShape = new RoundRectangle2D.Float(
                maxButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(maxButtonShape);

        // Draw max icon (four outward arrows)
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setStroke(new java.awt.BasicStroke(1.5f));

        int maxMargin = 7;
        int centerX = maxButtonX + Config.GRAPH_BUTTON_SIZE / 2;
        int centerY = y + Config.GRAPH_BUTTON_SIZE / 2;
        int arrowSize = Config.GRAPH_BUTTON_SIZE / 2 - maxMargin;

        // Draw a simple expand icon (four outward arrows)
        // Top-left arrow
        plotAreaG2.drawLine(centerX - 2, centerY - 2, centerX - arrowSize, centerY - arrowSize);
        plotAreaG2.drawLine(centerX - arrowSize, centerY - 2, centerX - arrowSize, centerY - arrowSize);
        plotAreaG2.drawLine(centerX - 2, centerY - arrowSize, centerX - arrowSize, centerY - arrowSize);

        // Top-right arrow
        plotAreaG2.drawLine(centerX + 2, centerY - 2, centerX + arrowSize, centerY - arrowSize);
        plotAreaG2.drawLine(centerX + arrowSize, centerY - 2, centerX + arrowSize, centerY - arrowSize);
        plotAreaG2.drawLine(centerX + 2, centerY - arrowSize, centerX + arrowSize, centerY - arrowSize);

        // Bottom-left arrow
        plotAreaG2.drawLine(centerX - 2, centerY + 2, centerX - arrowSize, centerY + arrowSize);
        plotAreaG2.drawLine(centerX - arrowSize, centerY + 2, centerX - arrowSize, centerY + arrowSize);
        plotAreaG2.drawLine(centerX - 2, centerY + arrowSize, centerX - arrowSize, centerY + arrowSize);

        // Bottom-right arrow
        plotAreaG2.drawLine(centerX + 2, centerY + 2, centerX + arrowSize, centerY + arrowSize);
        plotAreaG2.drawLine(centerX + arrowSize, centerY + 2, centerX + arrowSize, centerY + arrowSize);
        plotAreaG2.drawLine(centerX + 2, centerY + arrowSize, centerX + arrowSize, centerY + arrowSize);

        // Draw zoom in (+) button
        int zoomInButtonX = maxButtonX - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        zoomInButtonRect.setBounds(zoomInButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverZoomInButton(p)  ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape zoomInButtonShape = new RoundRectangle2D.Float(
                zoomInButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(zoomInButtonShape);

        // Draw + symbol
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setStroke(new java.awt.BasicStroke(2.0f));

        int plusSize = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int plusX = zoomInButtonX + margin;
        int plusY = y + margin;

        // Horizontal line
        plotAreaG2.drawLine(
                plusX + plusSize / 4,
                plusY + plusSize / 2,
                plusX + 3 * plusSize / 4,
                plusY + plusSize / 2
        );

        // Vertical line
        plotAreaG2.drawLine(
                plusX + plusSize / 2,
                plusY + plusSize / 4,
                plusX + plusSize / 2,
                plusY + 3 * plusSize / 4
        );

        // Draw zoom out (-) button
        int zoomOutButtonX = zoomInButtonX - Config.GRAPH_BUTTON_SIZE - Config.GRAPH_BUTTON_MARGIN;
        zoomOutButtonRect.setBounds(zoomOutButtonX, y, Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverZoomOutButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape zoomOutButtonShape = new RoundRectangle2D.Float(
                zoomOutButtonX, y,
                Config.GRAPH_BUTTON_SIZE, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(zoomOutButtonShape);

        // Draw - symbol
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setStroke(new java.awt.BasicStroke(2.0f));

        int minusSize = Config.GRAPH_BUTTON_SIZE - 2 * margin;
        int minusX = zoomOutButtonX + margin;
        int minusY = y + margin;

        // Horizontal line (minus symbol)
        plotAreaG2.drawLine(
                minusX + minusSize / 4,
                minusY + minusSize / 2,
                minusX + 3 * minusSize / 4,
                minusY + minusSize / 2
        );

        // Draw Week button (wider than the others)
        int weekButtonX = zoomOutButtonX - textButtonWidth - Config.GRAPH_BUTTON_MARGIN;
        weekButtonRect.setBounds(weekButtonX, y, textButtonWidth, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverWeekButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape weekButtonShape = new RoundRectangle2D.Float(
                weekButtonX, y,
                textButtonWidth, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(weekButtonShape);

        // Draw Week text
        plotAreaG2.setColor(java.awt.Color.WHITE);
        plotAreaG2.setFont(new Font("SansSerif", Font.PLAIN, 12));
        FontMetrics fm = plotAreaG2.getFontMetrics();
        String weekText = "Week";
        int textWidth = fm.stringWidth(weekText);
        int textHeight = fm.getHeight();
        plotAreaG2.drawString(weekText,
                weekButtonX + (textButtonWidth - textWidth) / 2,
                y + (Config.GRAPH_BUTTON_SIZE + textHeight) / 2 - 2);

        // Draw Month button (wider than the others)
        int monthButtonX = weekButtonX - textButtonWidth - Config.GRAPH_BUTTON_MARGIN;
        monthButtonRect.setBounds(monthButtonX, y, textButtonWidth, Config.GRAPH_BUTTON_SIZE);

        plotAreaG2.setColor(isOverMonthButton(p) ? Config.GRAPH_BUTTON_HOVER_COLOR : Config.GRAPH_BUTTON_COLOR);
        Shape monthButtonShape = new RoundRectangle2D.Float(
                monthButtonX, y,
                textButtonWidth, Config.GRAPH_BUTTON_SIZE,
                6, 6
        );
        plotAreaG2.fill(monthButtonShape);

        // Draw Month text
        plotAreaG2.setColor(java.awt.Color.WHITE);
        // Use the same font as for the Week button - plain instead of bold
        String monthText = "Month";
        textWidth = fm.stringWidth(monthText);
        plotAreaG2.drawString(monthText,
                monthButtonX + (textButtonWidth - textWidth) / 2,
                y + (Config.GRAPH_BUTTON_SIZE + textHeight) / 2 - 2);
    }

    public boolean isOverHomeButton(Point point) {
        return homeButtonRect.contains(point);
    }

    public boolean isOverMaxButton(Point point) {
        return maxButtonRect.contains(point);
    }

    public boolean isOverZoomInButton(Point point) {
        return zoomInButtonRect.contains(point);
    }

    public boolean isOverZoomOutButton(Point point) {
        return zoomOutButtonRect.contains(point);
    }

    public boolean isOverWeekButton(Point point) {
        return weekButtonRect.contains(point);
    }

    public boolean isOverMonthButton(Point point) {
        return monthButtonRect.contains(point);
    }
}
package com.flippingcopilot.ui.graph;
import com.flippingcopilot.ui.graph.model.Bounds;
import lombok.NoArgsConstructor;

import java.awt.*;

@NoArgsConstructor
public class PlotArea {

    // this is the padding between the plot area and the edge of the panel
    public final int leftPadding = 80;
    public final int topPadding = 100;
    public final int rightPadding = 20;
    public final int bottomPadding = 50;

    public int w;
    public int h;

    public Bounds bounds;

    public int timeDeltaToXDelta(int d) {
        return  (int)((long)w * (long)d / (long) bounds.xDelta());
    }
    public int priceDeltaToYDelta(int d) {
        return  (int)((long)h * (long)d / (long) bounds.yDelta());
    }

    public int timeToX(int t) {
        return  (int)(((long)w * (long)(t - bounds.xMin)) / bounds.xDelta());
    }

    public int priceToY(int p) {
        return (int)(((long)h * (long)(bounds.yMax - p)) / bounds.yDelta());
    }

    public Point relativePoint(Point p) {
        return new Point( p.x - leftPadding, p.y - topPadding);
    }

    public boolean pointInPlotArea(Point p) {
        return p.x <= w && p.y <= h;
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.manger.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.Config;
import com.flippingcopilot.ui.graph.model.Constants;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.border.MatteBorder;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.text.NumberFormat;
import java.util.Date;

@Slf4j
public class StatsPanel extends JPanel {
    private final DataManager dataManager;
    private final JTable statsTable;

    public StatsPanel(DataManager dataManager, PriceGraphConfigManager configManager, FlippingCopilotConfig copilotConfig) {
        this.dataManager = dataManager;
        this.setLayout(new BorderLayout());

        // Create table model with two columns and no row editing
        DefaultTableModel model = new DefaultTableModel() {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        model.addColumn("Statistic");
        model.addColumn("Value");

        statsTable = new JTable(model);
        statsTable.setFillsViewportHeight(true);
        statsTable.setRowHeight(24);
        statsTable.getTableHeader().setReorderingAllowed(false);
        statsTable.getTableHeader().setResizingAllowed(true);
        statsTable.setBackground(configManager.getConfig().backgroundColor);

        statsTable.setShowGrid(false);
        statsTable.setIntercellSpacing(new Dimension(0, 0));

        statsTable.getColumnModel().getColumn(0).setPreferredWidth(150);
        statsTable.getColumnModel().getColumn(1).setPreferredWidth(120);

        statsTable.setTableHeader(null);

        // Set custom cell renderer for value column to color the change percentages
        statsTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

                // Apply color to the price change rows (24h change and week change)
                if (row == 5 || row == 6) { // Index of 24h change and week change rows
                    String valueStr = value.toString();
                    // Check if the percentage is negative (contains '-' character)
                    if (valueStr.contains("-")) {
                        c.setForeground(copilotConfig.lossAmountColor());
                    } else if (!valueStr.equals("0%")) {
                        c.setForeground(copilotConfig.profitAmountColor());
                    } else {
                        c.setForeground(table.getForeground());
                    }
                } else {
                    c.setForeground(table.getForeground());
                }

                return c;
            }
        });

        statsTable.setBorder(new MatteBorder(1, 0, 0, 0, Color.GRAY));
        JScrollPane scrollPane = new JScrollPane(statsTable);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());

        scrollPane.setColumnHeaderView(null);

        this.add(scrollPane, BorderLayout.CENTER);

        populateTable();
        this.setPreferredSize(new Dimension(280, 400));
    }

    /**
     * Populates the stats table with data
     */
    private void populateTable() {
        DefaultTableModel model = (DefaultTableModel) statsTable.getModel();

        // Daily volume
        model.addRow(new Object[]{"Daily Volume", formatNumber((long) dataManager.data.dailyVolume)});

        // Last Instabuy (show even if zero)
        model.addRow(new Object[]{"Last low time", dataManager.lastLowTime > 0 ? Constants.SECOND_DATE_FORMAT.format(new Date(dataManager.lastLowTime* 1000L)) : "n/a"});
        model.addRow(new Object[]{"Last low price", dataManager.lastLowPrice > 0 ? formatNumber(dataManager.lastLowPrice) : "n/a"});

        // Last Instasell (show even if zero)
        model.addRow(new Object[]{"Last high time", dataManager.lastHighTime > 0 ? Constants.SECOND_DATE_FORMAT.format(new Date(dataManager.lastHighTime * 1000L)) : "n/a"});
        model.addRow(new Object[]{"Last high price", dataManager.lastHighPrice > 0 ? formatNumber(dataManager.lastHighPrice) : "n/a"});

        // Price changes
        model.addRow(new Object[]{"24h change", formatPercentage((float) dataManager.priceChange24H)});
        model.addRow(new Object[]{"Week change", formatPercentage((float) dataManager.priceChangeWeek)});
//
//        // Copilot price and margin
//        model.addRow(new Object[]{"Copilot buy price", formatNumber(dataManager.data.buyPrice)});
//        model.addRow(new Object[]{"Copilot sell price", formatNumber(dataManager.data.sellPrice)});
//
//        model.addRow(new Object[]{"Margin", formatNumber(dataManager.margin)});
//        model.addRow(new Object[]{"Tax", formatNumber(dataManager.tax)});
//        model.addRow(new Object[]{"Profit", formatNumber(dataManager.profit)});
    }


    private String formatNumber(long number) {
        return NumberFormat.getNumberInstance().format(number);
    }

    private String formatPercentage(float value) {
        NumberFormat format = NumberFormat.getPercentInstance();
        format.setMaximumFractionDigits(2);
        return format.format(value);
    }
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.*;

import java.awt.*;
import java.awt.geom.Path2D;
import java.util.List;

public class RenderV2 {

    public void drawGrid(Graphics2D plotAreaG2,Config config,  PlotArea pa, TimeAxis xAxis, PriceAxis yAxis) {
        plotAreaG2.setColor(config.gridColor);
        plotAreaG2.setStroke(Config.GRID_STROKE);
        for (int t : xAxis.dateOnlyTickTimes) {
            Stroke originalStroke = plotAreaG2.getStroke();
            int x = pa.timeToX(t);
            plotAreaG2.setStroke(new BasicStroke(1.0f));
            plotAreaG2.drawLine(x, 0, x, pa.h);
            plotAreaG2.setStroke(originalStroke);
        }
        for (int t : xAxis.timeOnlyTickTimes) {
            int x = pa.timeToX(t);
            plotAreaG2.drawLine(x, 0, x, pa.h);
        }
        for (int t : xAxis.gridOnlyTickTimes) {
            int x = pa.timeToX(t);
            plotAreaG2.drawLine(x, 0, x, pa.h);
        }
        for (int p : yAxis.tickPrices) {
            int y = pa.priceToY(p);
            plotAreaG2.drawLine(0, y, pa.w, y);
        }
        for (int p : yAxis.gridOnlyPrices) {
            int y = pa.priceToY(p);
            plotAreaG2.drawLine(0, y, pa.w, y);
        }
    }

    public void drawAxes(Graphics2D g2, Config config,  PlotArea pa, TimeAxis xAxis, PriceAxis yAxis) {
        g2.setColor(config.axisColor);
        g2.setStroke(new BasicStroke(1.0f));
        g2.drawLine(pa.leftPadding,  pa.topPadding + pa.h, pa.leftPadding + pa.w, pa.topPadding + pa.h);
        g2.drawLine(pa.leftPadding, pa.topPadding, pa.leftPadding, pa.topPadding +pa.h);
        drawXAxisLabels(g2,config, pa, xAxis);
        drawYAxisLabels(g2, config,pa, yAxis);
    }

    public void drawXAxisLabels(Graphics2D g2, Config config, PlotArea pa, TimeAxis xAxis) {
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        g2.setColor(config.textColor);
        FontMetrics metrics = g2.getFontMetrics();

        java.text.SimpleDateFormat dateFormat = new java.text.SimpleDateFormat("d MMM");
        java.text.SimpleDateFormat timeFormat = new java.text.SimpleDateFormat("HH:mm");

        // Draw date labels (longer ticks)
        for (int time : xAxis.dateOnlyTickTimes) {
            int x = pa.timeToX(time);
            g2.drawLine(pa.leftPadding + x, pa.topPadding + pa.h, pa.leftPadding + x, pa.topPadding + pa.h + Config.TICK_SIZE * 2);
            String label = dateFormat.format(new java.util.Date(time * 1000L));
            int labelWidth = metrics.stringWidth(label);
            g2.drawString(label, pa.leftPadding + x - labelWidth / 2, pa.topPadding + pa.h + Config.TICK_SIZE * 2 + 9 + metrics.getHeight());
        }

        // Draw time labels (shorter ticks)
        for (int time : xAxis.timeOnlyTickTimes) {
            int x = pa.timeToX(time);

            g2.drawLine(pa.leftPadding +x, pa.topPadding + pa.h, pa.leftPadding +x, pa.topPadding +  pa.h + Config.TICK_SIZE);

            String label = timeFormat.format(new java.util.Date(time * 1000L));
            int labelWidth = metrics.stringWidth(label);
            g2.drawString(label, pa.leftPadding + x - labelWidth / 2, pa.topPadding +  pa.h + Config.TICK_SIZE + metrics.getHeight());
        }
    }

    public void drawYAxisLabels(Graphics2D g2, Config config, PlotArea pa, PriceAxis yAxis) {
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        g2.setColor(config.textColor);
        FontMetrics metrics = g2.getFontMetrics();
        for (int price : yAxis.tickPrices) {
            int y = pa.priceToY(price);
            g2.drawLine(pa.leftPadding - Config.TICK_SIZE,pa.topPadding + y, pa.leftPadding, pa.topPadding+ y);

            // Format and draw the price label
            String label = com.flippingcopilot.ui.UIUtilities.quantityToRSDecimalStack(price, true);
            g2.drawString(label,
                    pa.leftPadding - metrics.stringWidth(label) - Config.LABEL_PADDING,
                    pa.topPadding + y + metrics.getHeight() / 3);
        }
    }


    public void drawPredictionIQR(Graphics2D plotAreaG2, Config config, PlotArea pa, int[] times, int[] lowerPrices, int[] upperPrices, boolean isLow) {
        if (times.length < 2) return;

        // Set appropriate color
        plotAreaG2.setColor(isLow ? config.lowShadeColor : config.highShadeColor);

        // Create path for shaded area with clipping
        Path2D path = new Path2D.Double();
        boolean started = false;

        // Start at the first point that's in range
        for (int i = 0; i < times.length; i++) {
            int time = times[i];
            if (time >= pa.bounds.xMin && time <=pa.bounds.xMax) {
                int x = pa.timeToX(time);
                int y = pa.priceToY(lowerPrices[i]);

                if (!started) {
                    path.moveTo(x, y);
                    started = true;
                } else {
                    path.lineTo(x, y);
                }
            }
        }

        // Draw the upper bound from right to left (for points in range)
        for (int i = times.length - 1; i >= 0; i--) {
            int time = times[i];
            if (time >= pa.bounds.xMin && time <= pa.bounds.xMax) {
                int x = pa.timeToX(time);
                int y = pa.priceToY(upperPrices[i]);
                path.lineTo(x, y);
            }
        }

        // Close the path if we drew anything
        if (started) {
            path.closePath();
            plotAreaG2.fill(path);
        }
    }

    public void drawLines(Graphics2D plotAreaG2,
                          PlotArea pa,
                          List<Datapoint> datapoints,
                          Color color,
                          Stroke stroke) {
        if (datapoints.isEmpty()) return;

        // Set the specified stroke and color
        plotAreaG2.setStroke(stroke);
        plotAreaG2.setColor(color);

        // Create a clip rectangle matching the plot area bounds
        java.awt.Shape originalClip = plotAreaG2.getClip();
        plotAreaG2.setClip(0, 0, pa.w, pa.h);

        // Create path for line segments
        java.awt.geom.Path2D.Float path = new java.awt.geom.Path2D.Float();

        // Start the path at the first point
        int x = pa.timeToX(datapoints.get(0).time);
        int y = pa.priceToY(datapoints.get(0).price);
        path.moveTo(x, y);

        for (Datapoint d : datapoints.subList(1, datapoints.size())) {
            x = pa.timeToX(d.time);
            y = pa.priceToY(d.price);
            path.lineTo(x, y);
        }

        plotAreaG2.draw(path);
        plotAreaG2.setClip(originalClip);
    }

    public void drawStartPoints(Graphics2D plotAreaG2,
                                PlotArea pa,
                                List<Datapoint> startPoints,
                                Color color,
                                int size
    ) {
        if (startPoints.isEmpty()) return;

        // Save original color
        Color originalColor = plotAreaG2.getColor();

        // Set the specified color
        plotAreaG2.setColor(color);

        // Create a clip rectangle matching the plot area bounds
        java.awt.Shape originalClip = plotAreaG2.getClip();
        plotAreaG2.setClip(0, 0, pa.w, pa.h);

        // Draw each start point as a filled oval
        for (Datapoint d : startPoints) {
            if (d.time < pa.bounds.xMin || d.time > pa.bounds.xMax) {
                continue;
            }

            // Get current point coordinates
            int x = pa.timeToX(d.time);
            int y = pa.priceToY(d.price);

            // Draw an asterisk (*) at the point
            // Save the original stroke
            Stroke originalStroke = plotAreaG2.getStroke();

            // Set stroke based on size
            float strokeWidth = Math.max(1, size / 5);
            plotAreaG2.setStroke(new BasicStroke(strokeWidth));

            // Draw the lines of the asterisk (*)
            int halfSize = size / 2;

            // Horizontal line
            plotAreaG2.drawLine(x - halfSize, y, x + halfSize, y);

            // Vertical line
            plotAreaG2.drawLine(x, y - halfSize, x, y + halfSize);

            // Diagonal line from top-left to bottom-right
            plotAreaG2.drawLine(x - halfSize, y - halfSize, x + halfSize, y + halfSize);

            // Diagonal line from top-right to bottom-left
            plotAreaG2.drawLine(x + halfSize, y - halfSize, x - halfSize, y + halfSize);

            // Restore the original stroke
            plotAreaG2.setStroke(originalStroke);
        }

        // Restore original clip and color
        plotAreaG2.setClip(originalClip);
        plotAreaG2.setColor(originalColor);
    }

    public void drawPoints(Graphics2D plotAreaG2,
                            PlotArea pa,
                            List<Datapoint> datapoints,
                            Color color,
                            int size
    ) {
        if (datapoints.isEmpty()) return;

        // Save original color
        Color originalColor = plotAreaG2.getColor();

        // Set the specified color
        plotAreaG2.setColor(color);

        // Create a clip rectangle matching the plot area bounds
        java.awt.Shape originalClip = plotAreaG2.getClip();
        plotAreaG2.setClip(0, 0, pa.w, pa.h);

        // Draw each point as a filled oval
        for (Datapoint d : datapoints) {
            if (d.time < pa.bounds.xMin || d.time > pa.bounds.xMax) {
                continue;
            }

            // Get current point coordinates
            int x = pa.timeToX(d.time);
            int y = pa.priceToY(d.price);

            // Calculate the top-left corner for the oval (centered on x,y)
            int ovalX = x - size / 2;
            int ovalY = y - size / 2;

            if (d.type == Datapoint.Type.PREDICTION || d.type == Datapoint.Type.INSTA_SELL_BUY) {
                // filled oval for latest price points
                plotAreaG2.fillOval(ovalX, ovalY, size, size);
            } else {
                // rectangle for 5m/1h averages
                int timeDelta = d.type == Datapoint.Type.FIVE_MIN_AVERAGE ? Constants.FIVE_MIN_SECONDS : Constants.HOUR_SECONDS;
                int w = pa.timeDeltaToXDelta(timeDelta);
                plotAreaG2.fillRect(x, y, w + size, size);
            }
        }

        // Restore original clip and color
        plotAreaG2.setClip(originalClip);
        plotAreaG2.setColor(originalColor);
    }

    public void drawLegend(Graphics2D g2, Config config, PlotArea pa) {
        int xMid = pa.leftPadding + pa.w / 2;
        g2.setFont(g2.getFont().deriveFont(Font.PLAIN, Config.FONT_SIZE));
        FontMetrics metrics = g2.getFontMetrics();

        // Legend item text labels - now with additional entries
        String[] labels = {"Lows (insta-sell)", "Highs (insta-buy)", "Low prediction", "High prediction"};
        String[] labels2 = {"Low IQR", "High IQR"};  // New line for IQR entries

        // Calculate legend position - now above the plot area
        int legendY = pa.topPadding / 2; // Half the padding from the top
        int lineLength = 20;
        int itemHeight = 15;
        int itemPadding = 30; // Space between text end and next item start
        int lineSpacing = 20; // Space between first and second row

        // Calculate widths for each legend item based on text length
        int[] itemWidths = new int[labels.length];
        int totalWidth = 0;

        for (int i = 0; i < labels.length; i++) {
            itemWidths[i] = lineLength + 5 + metrics.stringWidth(labels[i]);
            totalWidth += itemWidths[i];
        }

        // Add padding between items to total width
        totalWidth += itemPadding * (labels.length - 1);

        // Calculate starting X position to center the legend
        int legendStartX = xMid - totalWidth / 2;
        int currentX = legendStartX;

        // First row of legend items

        // Low prices
        g2.setColor(config.lowColor);
        g2.setStroke(Config.NORMAL_STROKE);
        if (config.connectPoints) {
            g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        }
        g2.fillOval(currentX + lineLength / 2 - 2, legendY + itemHeight/2 - 2, 5, 5);
        g2.setColor(config.textColor);
        g2.drawString(labels[0], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        currentX += itemWidths[0] + itemPadding;

        // High prices
        g2.setColor(config.highColor);
        g2.setStroke(Config.NORMAL_STROKE);
        if (config.connectPoints) {
            g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        }
        g2.fillOval(currentX + lineLength / 2 - 2, legendY + itemHeight/2 - 2, 5, 5);
        g2.setColor(config.textColor);
        g2.drawString(labels[1], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        currentX += itemWidths[1] + itemPadding;

        // Low prediction mean
        g2.setColor(config.lowColor);
        g2.setStroke(Config.DOTTED_STROKE);
        g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        g2.setColor(config.textColor);
        g2.drawString(labels[2], currentX + lineLength + 5, legendY + itemHeight/2 + 4);
        currentX += itemWidths[2] + itemPadding;

        // High prediction mean
        g2.setColor(config.highColor);
        g2.setStroke(Config.DOTTED_STROKE);
        g2.drawLine(currentX, legendY + itemHeight/2, currentX + lineLength, legendY + itemHeight/2);
        g2.setColor(config.textColor);
        g2.drawString(labels[3], currentX + lineLength + 5, legendY + itemHeight/2 + 4);

        // Second row with IQR entries
        // Calculate widths for second row items
        int[] itemWidths2 = new int[labels2.length];
        int totalWidth2 = 0;

        for (int i = 0; i < labels2.length; i++) {
            itemWidths2[i] = lineLength + 5 + metrics.stringWidth(labels2[i]);
            totalWidth2 += itemWidths2[i];
        }

        // Add padding between items to total width for second row
        totalWidth2 += itemPadding * (labels2.length - 1);

        // Calculate starting X position to center the second row
        int legendStartX2 = xMid - totalWidth2 / 2;
        int currentX2 = legendStartX2;
        int legendY2 = legendY + itemHeight + 13; // Position for second row

        // Low IQR
        g2.setColor(config.lowShadeColor);
        // Draw a small filled rectangle to represent the shaded area
        g2.fillRect(currentX2, legendY2 + itemHeight/2 - 5, lineLength, 10);
        g2.setColor(config.textColor);
        g2.drawString(labels2[0], currentX2 + lineLength + 5, legendY2 + itemHeight/2 + 4);
        currentX2 += itemWidths2[0] + itemPadding;

        // High IQR
        g2.setColor(config.highShadeColor);
        // Draw a small filled rectangle to represent the shaded area
        g2.fillRect(currentX2, legendY2 + itemHeight/2 - 5, lineLength, 10);
        g2.setColor(config.textColor);
        g2.drawString(labels2[1], currentX2 + lineLength + 5, legendY2 + itemHeight/2 + 4);
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.controller.ApiRequestHandler;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.manger.PriceGraphConfigManager;
import com.flippingcopilot.model.ItemPrice;
import com.flippingcopilot.model.OsrsLoginManager;
import com.flippingcopilot.ui.Spinner;
import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.Data;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.function.Consumer;

import static com.google.common.base.MoreObjects.firstNonNull;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PriceGraphController {

    private final JLabel itemIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(getClass(),"/small_open_arrow.png")));

    // dependencies
    private final PriceGraphConfigManager configManager;
    private final FlippingCopilotConfig copilotConfig;
    private final ApiRequestHandler apiRequestHandler;
    private final OsrsLoginManager osrsLoginManager;
    private final ItemManager itemManager;

    // state
    private GraphPanel graphPanel;
    private JDialog currentDialog = null;
    private JPanel mainPanel = null;
    private View currentView = null;
    private boolean currentIsSuggestedItem = false;

    private Point lastDialogPosition = null;
    private Dimension lastDialogSize = null;

    @Getter
    private Data suggestedItemGraphData;

    @Getter
    private Data userItemGraphData;


    private void clear() {
        currentDialog = null;
        mainPanel = null;
        currentView = null;
        graphPanel = null;
    }

    // Custom setters to handle data updates
    public void setSuggestedItemGraphData(Data data) {
        SwingUtilities.invokeLater(() -> {
            if (currentDialog != null && data.isFromWaitSuggestion()) {
                // do nothing if it was a wait suggestion
                return;
            }
            this.suggestedItemGraphData = data;
            if (currentDialog != null && currentIsSuggestedItem) {
                updateUIAfterDataChange(data);
            }
        });
    }

    public void setUserItemGraphData(Data data) {
        SwingUtilities.invokeLater(() -> {
            this.userItemGraphData = data;
            if (currentDialog != null && !currentIsSuggestedItem) {
                updateUIAfterDataChange(data);
            } else {
                log.debug("discarding price graph data for user selected item {}", data != null ? data.name : "null");
            }
        });
    }

    private void updateUIAfterDataChange(Data data) {
        if (currentDialog != null && mainPanel != null) {
            if (data != null && data.getLoadingErrorMessage() != null && !data.getLoadingErrorMessage().isEmpty()) {
                showErrorView(data.getLoadingErrorMessage());
            } else if (data != null) {
                showGraphView(data.name, data);
            }
        } else {
            log.debug("dialog or main panel null");
        }
    }

    public void loadAndAndShowPriceGraph(int itemId) {
        Consumer<ItemPrice> consumer = (ItemPrice i) -> {
            Data d = firstNonNull(i.getGraphData(), new Data());
            d.loadingErrorMessage = i.getMessage();
            setUserItemGraphData(d);
        };
        ItemComposition item = itemManager.getItemComposition(itemId);
        apiRequestHandler.asyncGetItemPriceWithGraphData(itemId, osrsLoginManager.getPlayerDisplayName(), consumer, true);
        showPriceGraph(item.getName(), false);
    }

    public void showPriceGraph(String itemName, boolean isSuggestedItem) {
        if(!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(() -> showPriceGraph(itemName, isSuggestedItem));
            return;
        }
        try {
            log.debug("Showing price graph panel for item: " + itemName);
            this.currentIsSuggestedItem = isSuggestedItem;

            // If there's already a dialog showing, dispose it
            if (currentDialog != null) {
                lastDialogPosition = currentDialog.getLocation();
                lastDialogSize = currentDialog.getSize();
                log.debug("Disposing existing dialog");
                currentDialog.dispose();
            }
            clear();


            // Create new dialog with decorations for moving and resizing
            JDialog dialog = new JDialog();
            dialog.setUndecorated(false); // Keep window decorations to allow resizing
            dialog.setTitle(itemName + " statistics");
            dialog.setResizable(true); // Allow resizing

            // Set minimum size to prevent making the graph too small
            dialog.setMinimumSize(new Dimension(500, 250));

            // Create main panel to contain the components
            mainPanel = new JPanel(new BorderLayout());
            mainPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            Data currentData = isSuggestedItem ? suggestedItemGraphData : userItemGraphData;

            if (currentData == null) {
                showLoadingView(itemName);
            } else if (currentData.getLoadingErrorMessage() != null && !currentData.getLoadingErrorMessage().isEmpty()) {
                showErrorView(currentData.getLoadingErrorMessage());
            } else {
                showGraphView(itemName, currentData);
            }

            dialog.setContentPane(mainPanel);
            if (lastDialogSize != null && lastDialogPosition != null) {
                dialog.setSize(lastDialogSize);
                dialog.setLocation(lastDialogPosition);
            } else {
                Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
                dialog.setSize(screenSize.width, screenSize.height);
                dialog.setLocation(0, 0);
            }

            // Make the dialog modal so it stays on top but doesn't block
            dialog.setModalityType(Dialog.ModalityType.MODELESS);

            dialog.addComponentListener(new ComponentAdapter() {
                @Override
                public void componentResized(ComponentEvent e) {
                    if (!View.SETTINGS.equals(currentView) && mainPanel.getComponentCount() > 0) {
                        Component comp = mainPanel.getComponent(0);
                        if (comp instanceof JSplitPane) {
                            JSplitPane splitPane = (JSplitPane) comp;
                            Component leftComp = splitPane.getLeftComponent();
                            if (leftComp instanceof GraphPanel) {
                                ((GraphPanel) leftComp).repaint();
                            }
                        }
                    }
                }
            });

            dialog.addWindowListener(new WindowAdapter() {
                @Override
                public void windowClosing(WindowEvent e) {
                    lastDialogPosition = dialog.getLocation();
                    lastDialogSize = dialog.getSize();
                    log.debug("Saved dialog position: {} and size: {}", lastDialogPosition, lastDialogSize);
                }
            });


            // Store the current dialog reference
            currentDialog = dialog;

            // Set default close operation
            dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

            // Make dialog visible
            dialog.setVisible(true);
            log.debug("Price graph panel shown successfully");
        } catch (Exception e) {
            log.error("Error showing price graph panel: {}", e.getMessage(), e);
        }
    }

    private void showLoadingView(String itemName) {
        currentView = View.LOADING;
        mainPanel.removeAll();

        // Create loading panel
        JPanel loadingPanel = new JPanel(new GridBagLayout());
        loadingPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        // Add spinner
        Spinner spinner = new Spinner();
        spinner.show();
        loadingPanel.add(spinner, gbc);

        // Add loading text
        gbc.gridy = 1;
        JLabel loadingLabel = new JLabel("Loading price data for " + itemName + "...");
        loadingLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        loadingLabel.setFont(loadingLabel.getFont().deriveFont(Font.BOLD, 14f));
        loadingPanel.add(loadingLabel, gbc);

        mainPanel.add(loadingPanel, BorderLayout.CENTER);
        mainPanel.revalidate();
        mainPanel.repaint();
    }

    private void showErrorView(String errorMessage) {
        currentView = View.ERROR;
        mainPanel.removeAll();

        // Create error panel
        JPanel errorPanel = new JPanel(new GridBagLayout());
        errorPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(10, 10, 10, 10);

        // Add error icon (optional - you could add a red X icon here)
        JLabel errorIcon = new JLabel("⚠");
        errorIcon.setForeground(Color.RED);
        errorIcon.setFont(errorIcon.getFont().deriveFont(Font.BOLD, 24f));
        errorPanel.add(errorIcon, gbc);

        // Add error message
        gbc.gridy = 1;
        JLabel errorLabel = new JLabel("<html><center>" + errorMessage + "</center></html>");
        errorLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        errorLabel.setFont(errorLabel.getFont().deriveFont(14f));
        errorLabel.setHorizontalAlignment(SwingConstants.CENTER);
        errorPanel.add(errorLabel, gbc);

        // Add close button
        gbc.gridy = 2;
        gbc.insets = new Insets(20, 10, 10, 10);
        JButton closeButton = new JButton("Close");
        closeButton.addActionListener(e -> {
            if (currentDialog != null) {
                currentDialog.dispose();
            }
        });
        closeButton.addActionListener(e -> {
            if (currentDialog != null) {
                lastDialogPosition = currentDialog.getLocation();
                lastDialogSize = currentDialog.getSize();
                log.debug("Saved dialog position and size on error close");
                currentDialog.dispose();
            }
        });
        errorPanel.add(closeButton, gbc);

        mainPanel.add(errorPanel, BorderLayout.CENTER);
        mainPanel.revalidate();
        mainPanel.repaint();
    }

    private void showGraphView(String itemName, Data data) {
        if (mainPanel == null) {
            log.error("Cannot show graph view, main panel or data is null");
            return;
        }
        if(graphPanel != null && graphPanel.itemName.equals(itemName) && View.GRAPH.equals(currentView)) {
            // if it's the same item just update the data and repaint
            DataManager dm = new DataManager(data);
            graphPanel.dataManager = dm;
            graphPanel.zoomHandler.maxViewBounds = dm.calculateBounds((p) -> true);
            graphPanel.zoomHandler.homeViewBounds = dm.calculateBounds((p) -> p.time > graphPanel.zoomHandler.maxViewBounds.xMax - 4 * Constants.DAY_SECONDS);
            graphPanel.zoomHandler.weekViewBounds = dm.calculateBounds((p) -> p.time > graphPanel.zoomHandler.maxViewBounds.xMax - 7 * Constants.DAY_SECONDS);
            graphPanel.zoomHandler.monthViewBounds = dm.calculateBounds((p) -> p.time > graphPanel.zoomHandler.maxViewBounds.xMax - 30 * Constants.DAY_SECONDS);
            graphPanel.repaint();
            return;
        }

        currentView = View.GRAPH;
        // Clear the main panel
        setItemIcon(data.itemId);
        mainPanel.removeAll();
        DataManager dm = new DataManager(data);
        graphPanel = new GraphPanel(dm, configManager);

        // Create settings button with gear icon
        JPanel statsHeaderPanel = new JPanel(new BorderLayout());
        statsHeaderPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        try {
            BufferedImage gearIcon = ImageUtil.loadImageResource(PriceGraphController.class, "/preferences-icon.png");
            gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
            BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
            JLabel settingsButton = ConfigPanel.buildButton(recoloredIcon, "Settings", () -> {
                showSettingsView(itemName, data);
            });
            statsHeaderPanel.add(settingsButton, BorderLayout.EAST);
            statsHeaderPanel.setBackground(configManager.getConfig().backgroundColor);
        } catch (Exception e) {
            log.error("Error creating settings button", e);
            // Fallback to text button if icon loading fails
            JButton settingsButton = new JButton("Settings");
            settingsButton.addActionListener(e1 -> {
                showSettingsView(itemName, data);
            });
            statsHeaderPanel.add(settingsButton, BorderLayout.EAST);
        }

        // Create the stats panel
        StatsPanel statsPanel = new StatsPanel(dm, configManager, copilotConfig);
        statsPanel.setBackground(configManager.getConfig().backgroundColor);

        // Create a panel to contain both the item icon and stats panel
        JPanel statsContentPanel = new JPanel();
        statsContentPanel.setLayout(new BoxLayout(statsContentPanel, BoxLayout.Y_AXIS));
        statsContentPanel.setBackground(configManager.getConfig().backgroundColor);
        statsContentPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 10));

        // Create an icon panel with no bottom margin
        JPanel iconPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        iconPanel.setBackground(configManager.getConfig().backgroundColor);
        iconPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 15, 0)); // Only top and left padding

        // Add icon and name
        itemIcon.setBorder(null); // Remove any border from the icon
        iconPanel.add(itemIcon);

        JLabel itemNameLabel = new JLabel(itemName);
        itemNameLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        itemNameLabel.setFont(itemNameLabel.getFont().deriveFont(Font.BOLD, 16f));
        iconPanel.add(itemNameLabel);

        // Add the icon panel to the content panel
        statsContentPanel.add(iconPanel);
        statsPanel.setBorder(null);
        statsContentPanel.add(statsPanel);

        JPanel statsContainer = new JPanel(new BorderLayout(0, 0));
        statsContainer.add(statsHeaderPanel, BorderLayout.NORTH);
        statsContainer.add(statsContentPanel, BorderLayout.CENTER);

        // Create split pane with graph on left and stats container on right
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, true);
        splitPane.setLeftComponent(graphPanel);
        splitPane.setRightComponent(statsContainer);
        splitPane.setResizeWeight(1.0); // Graph gets all extra space
        splitPane.setDividerLocation(0.75); // Initial position of divider at 75%

        graphPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        statsContainer.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));

        mainPanel.add(splitPane, BorderLayout.CENTER);

        if (currentDialog != null && itemName != null) {
            currentDialog.setTitle(itemName + " statistics");
        }

        mainPanel.revalidate();
        mainPanel.repaint();
    }

    private  void showSettingsView(String itemName, Data data) {
        if (mainPanel == null) {
            log.error("Cannot show settings view, main panel is null");
            return;
        }
        currentView = View.SETTINGS;

        mainPanel.removeAll();

        // Create the top panel for back button
        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

        try {
            BufferedImage gearIcon = ImageUtil.loadImageResource(PriceGraphController.class, "/preferences-icon.png");
            gearIcon = ImageUtil.resizeImage(gearIcon, 20, 20);
            BufferedImage recoloredIcon = ImageUtil.recolorImage(gearIcon, ColorScheme.LIGHT_GRAY_COLOR);
            JLabel backButton = ConfigPanel.buildButton(recoloredIcon, "Back to Graph", () -> {
                showGraphView(itemName, data);
            });
            topPanel.setBackground(configManager.getConfig().backgroundColor);
            topPanel.add(backButton, BorderLayout.EAST);
        } catch (Exception e) {
            log.error("Error creating back button", e);
        }

        ConfigPanel configPanel = new ConfigPanel(configManager, () -> showGraphView(itemName, data));

        mainPanel.add(topPanel, BorderLayout.NORTH);
        mainPanel.add(configPanel, BorderLayout.CENTER);

        if (currentDialog != null) {
            currentDialog.setTitle("Graph Settings");
        }

        mainPanel.revalidate();
        mainPanel.repaint();
    }


    private void setItemIcon(int itemId) {
        itemIcon.setVisible(false);
        AsyncBufferedImage image = itemManager.getImage(itemId);
        if (image != null) {
            image.addTo(itemIcon);
            itemIcon.setVisible(true);
        }
    }

    public static enum View {
        GRAPH,
        SETTINGS,
        LOADING,
        ERROR
    }
}
package com.flippingcopilot.ui.graph;


@FunctionalInterface
public interface CoordinateConverter {
    int toValue(int coordinate);
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.manger.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.Config;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class ConfigPanel extends JPanel {
    private final Map<String, Component> configComponents = new HashMap<>();
    private final Runnable onApplyCallback;
    private final PriceGraphConfigManager configManager;
    private final Config configInstance;

    public ConfigPanel(PriceGraphConfigManager configManager, Runnable callback) {
        this.configManager = configManager;
        this.configInstance = configManager.getConfig();
        this.onApplyCallback = callback;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel settingsPanel = new JPanel();
        settingsPanel.setLayout(new GridBagLayout());
        settingsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1.0;
        c.anchor = GridBagConstraints.NORTH;
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(5, 5, 5, 5);

        JLabel titleLabel = new JLabel("Graph Settings");
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 16f));
        titleLabel.setBorder(new EmptyBorder(0, 0, 15, 0));
        settingsPanel.add(titleLabel, c);
        c.gridy++;

        // boolean
        addBooleanSetting(settingsPanel, c, "connectPoints", configInstance.isConnectPoints());

        // colours
        addColorSetting(settingsPanel, c, "lowColor", configInstance.getLowColor());
        addColorSetting(settingsPanel, c, "highColor", configInstance.getHighColor());
        addColorSetting(settingsPanel, c, "lowShadeColor", configInstance.getLowShadeColor());
        addColorSetting(settingsPanel, c, "highShadeColor", configInstance.getHighShadeColor());
        addColorSetting(settingsPanel, c, "backgroundColor", configInstance.getBackgroundColor());
        addColorSetting(settingsPanel, c, "plotAreaColor", configInstance.getPlotAreaColor());
        addColorSetting(settingsPanel, c, "textColor", configInstance.getTextColor());
        addColorSetting(settingsPanel, c, "axisColor", configInstance.getAxisColor());
        addColorSetting(settingsPanel, c, "gridColor", configInstance.getGridColor());

        // Add a filler component to push everything to the top
        GridBagConstraints fillerConstraints = new GridBagConstraints();
        fillerConstraints.gridx = 0;
        fillerConstraints.gridy = c.gridy;
        fillerConstraints.gridwidth = GridBagConstraints.REMAINDER;
        fillerConstraints.fill = GridBagConstraints.BOTH;
        fillerConstraints.weightx = 1.0;
        fillerConstraints.weighty = 1.0;

        JPanel fillerPanel = new JPanel();
        fillerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        settingsPanel.add(fillerPanel, fillerConstraints);

        JScrollPane scrollPane = new JScrollPane(settingsPanel);
        scrollPane.setBorder(null);
        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        buttonPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JButton applyButton = new JButton("Apply");
        applyButton.setFocusPainted(false);
        applyButton.setBackground(ColorScheme.BRAND_ORANGE);
        applyButton.setForeground(Color.WHITE);
        applyButton.addActionListener(e -> {
            applySettings();
            if (onApplyCallback != null) {
                onApplyCallback.run();
            }
        });

        buttonPanel.add(applyButton);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void addBooleanSetting(JPanel panel, GridBagConstraints c, String name, boolean value) {
        JLabel label = new JLabel(formatFieldName(name));
        label.setForeground(Color.WHITE);
        panel.add(label, c);
        c.gridx = 1;

        JCheckBox checkBox = new JCheckBox();
        checkBox.setSelected(value);
        checkBox.setToolTipText(name);
        checkBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        configComponents.put(name, checkBox);
        panel.add(checkBox, c);

        c.gridx = 0;
        c.gridy++;
    }

    private void addColorSetting(JPanel panel, GridBagConstraints c, String name, Color value) {
        JLabel label = new JLabel(formatFieldName(name));
        label.setForeground(Color.WHITE);
        panel.add(label, c);
        c.gridx = 1;

        JPanel colorPanel = new JPanel();
        colorPanel.setBackground(value);
        colorPanel.setPreferredSize(new Dimension(30, 20));
        colorPanel.setBorder(BorderFactory.createLineBorder(Color.WHITE));

        JButton colorButton = new JButton("Choose...");
        colorButton.setToolTipText(name);
        colorButton.addActionListener(e -> {
            Color newColor = JColorChooser.showDialog(this, "Choose " + formatFieldName(name), colorPanel.getBackground());
            if (newColor != null) {
                colorPanel.setBackground(newColor);
            }
        });

        JPanel wrapper = new JPanel(new FlowLayout(FlowLayout.LEFT));
        wrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        wrapper.add(colorPanel);
        wrapper.add(colorButton);

        configComponents.put(name, wrapper);
        panel.add(wrapper, c);

        c.gridx = 0;
        c.gridy++;
    }

    private String formatFieldName(String name) {
        StringBuilder result = new StringBuilder();
        for (char ch : name.toCharArray()) {
            if (Character.isUpperCase(ch)) {
                result.append(' ').append(Character.toLowerCase(ch));
            } else {
                result.append(ch);
            }
        }
        return result.toString().trim();
    }

    private Color extractColor(String key) {
        JPanel wrapper = (JPanel) configComponents.get(key);
        JPanel colorPanel = (JPanel) wrapper.getComponent(0);
        return colorPanel.getBackground();
    }

    private void applySettings() {
        try {
            // boolean
            JCheckBox connectPointsBox = (JCheckBox) configComponents.get("connectPoints");
            configInstance.setConnectPoints(connectPointsBox.isSelected());

            // colours
            configInstance.setLowColor(extractColor("lowColor"));
            configInstance.setHighColor(extractColor("highColor"));
            configInstance.setLowShadeColor(extractColor("lowShadeColor"));
            configInstance.setHighShadeColor(extractColor("highShadeColor"));
            configInstance.setBackgroundColor(extractColor("backgroundColor"));
            configInstance.setPlotAreaColor(extractColor("plotAreaColor"));
            configInstance.setTextColor(extractColor("textColor"));
            configInstance.setAxisColor(extractColor("axisColor"));
            configInstance.setGridColor(extractColor("gridColor"));

            configManager.setConfig(configInstance);
            log.debug("Applied and saved graph settings");
        } catch (Exception e) {
            log.error("Error applying settings", e);
            JOptionPane.showMessageDialog(this, "Error applying settings: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    public static JLabel buildButton(Image icon, String tooltip, Runnable onClick) {
        JLabel button = new JLabel(new ImageIcon(icon));
        button.setToolTipText(tooltip);
        button.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                onClick.run();
            }

            public void mouseEntered(java.awt.event.MouseEvent evt) {
                button.setCursor(new Cursor(Cursor.HAND_CURSOR));
            }
        });
        return button;
    }
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.graph.model.Bounds;
import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.Data;
import com.flippingcopilot.ui.graph.model.Datapoint;
import com.flippingcopilot.util.GeTax;
import lombok.Getter;

import java.awt.*;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;


@Getter
public class DataManager {

    public final List<Datapoint> highDatapoints = new ArrayList<>();
    public final List<Datapoint> lowDatapoints = new ArrayList<>();
    public final List<Datapoint> predictionLowDatapoints = new ArrayList<>();
    public final List<Datapoint> predictionHighDatapoints = new ArrayList<>();

    public final Data data;
    public double priceChange24H = 0;
    public double priceChangeWeek = 0;
    public int lastLowTime = 0;
    public int lastLowPrice = 0;
    public int lastHighTime = 0;
    public int lastHighPrice = 0;
    public long margin;
    public long tax;
    public long profit;


    public DataManager(Data data) {
        this.data = data;
        processDatapoints();
        calculateStats();
    }

    public Datapoint findClosestPoint(Point mousePos, int hoverRadius, PlotArea pa) {
        if (mousePos == null) return null;

        Datapoint closest = null;
        double minDistance = hoverRadius;

        for(List<Datapoint> datapoints : Arrays.asList(highDatapoints, lowDatapoints, predictionLowDatapoints, predictionHighDatapoints)) {
            for (Datapoint d : datapoints) {
                Point hoverPosition = d.getHoverPosition(pa);
                double distance = mousePos.distance(hoverPosition);
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = d;
                }
            }
        }
        return closest;
    }


    public Bounds calculateBounds(Predicate<Datapoint> p) {
        Bounds b = new Bounds();

        b.xMin = Integer.MAX_VALUE;
        b.xMax = Integer.MIN_VALUE;
        b.yMax =  Integer.MIN_VALUE;
        b.yMin = Integer.MAX_VALUE;

        long yMean = 0;
        long n = 0;

        for(List<Datapoint> datapoints : Arrays.asList(highDatapoints, lowDatapoints, predictionLowDatapoints, predictionHighDatapoints)) {
            for (Datapoint d : datapoints) {
                if (p.test(d)) {
                    yMean = (n * yMean + (long) d.price) / (n+1);
                    n+=1;

                    b.xMin = Math.min(b.xMin, d.time);
                    b.xMax = Math.max(b.xMax, d.time);

                    // Update price bounds
                    b.yMin = Math.min(b.yMin, d.price);
                    b.yMax = Math.max(b.yMax, d.price);

                    // Check IQR bounds for prediction points
                    if (d.type == Datapoint.Type.PREDICTION) {
                        if (d.iqrLower != null) {
                            b.yMin = Math.min(b.yMin, d.iqrLower);
                        }
                        if (d.iqrUpper != null) {
                            b.yMax = Math.max(b.yMax, d.iqrUpper);
                        }
                    }
                }
            }
        }
        int pricePadding = (int) (0.03 * yMean);
        if (pricePadding < 1) pricePadding = 1;

        b.yMin = Math.max(0, b.yMin - pricePadding);
        b.yMax+= pricePadding;

        return b;
    }

    private void processDatapoints() {
        highDatapoints.clear();
        lowDatapoints.clear();
        predictionHighDatapoints.clear();
        predictionLowDatapoints.clear();
        
        // here we combine the hour / 5min / latest wiki price data points into a continuous dataset where hour points 
        // transition into the 5min points that transition into the latest points. So we get increasingly finer granularity.
        // We truncate the points correctly at the boundaries to ensure no overlap.

        for (int i = 0; i < data.lowLatestTimes.length; i++) {
            lowDatapoints.add(new Datapoint(data.lowLatestTimes[i], data.lowLatestPrices[i], true, Datapoint.Type.INSTA_SELL_BUY));
        }
        int fiveMinLowsCut;
        if (!lowDatapoints.isEmpty()) {
            fiveMinLowsCut = Constants.FIVE_MIN_SECONDS * (lowDatapoints.get(0).time / Constants.FIVE_MIN_SECONDS)  + Constants.FIVE_MIN_SECONDS;
            lowDatapoints.removeIf((i) -> i.time < fiveMinLowsCut);
        } else {
            fiveMinLowsCut = Integer.MAX_VALUE;
        }
        for (int i = data.low5mTimes.length-1; i >= 0; i--) {
            if (data.low5mTimes[i] < fiveMinLowsCut) {
                lowDatapoints.add(0, new Datapoint(data.low5mTimes[i], data.low5mPrices[i], true, Datapoint.Type.FIVE_MIN_AVERAGE));
            }
        }
        int oneHourLowsCut;
        if (!lowDatapoints.isEmpty()) {
            oneHourLowsCut = Constants.HOUR_SECONDS * (lowDatapoints.get(0).time / Constants.HOUR_SECONDS)  + Constants.HOUR_SECONDS;
            lowDatapoints.removeIf((i) -> i.time < oneHourLowsCut);
        } else {
            oneHourLowsCut = Integer.MAX_VALUE;
        }
        for (int i = data.low1hTimes.length-1; i >= 0; i--) {
            if (data.low1hTimes[i] < oneHourLowsCut) {
                lowDatapoints.add(0, new Datapoint(data.low1hTimes[i], data.low1hPrices[i], true, Datapoint.Type.HOUR_AVERAGE));
            }
        }

        for (int i = 0; i < data.highLatestTimes.length; i++) {
            highDatapoints.add(new Datapoint(data.highLatestTimes[i], data.highLatestPrices[i], false, Datapoint.Type.INSTA_SELL_BUY));
        }
        int fiveMinHighsCut;
        if (!highDatapoints.isEmpty()) {
            fiveMinHighsCut = Constants.FIVE_MIN_SECONDS * (highDatapoints.get(0).time / Constants.FIVE_MIN_SECONDS)  + Constants.FIVE_MIN_SECONDS;
            highDatapoints.removeIf((i) -> i.time < fiveMinHighsCut);
        } else {
            fiveMinHighsCut = Integer.MAX_VALUE;
        }
        for (int i = data.high5mTimes.length-1; i >= 0; i--) {
            if (data.high5mTimes[i] < fiveMinHighsCut) {
                highDatapoints.add(0, new Datapoint(data.high5mTimes[i], data.high5mPrices[i], false, Datapoint.Type.FIVE_MIN_AVERAGE));
            }
        }
        int oneHourHighsCut;
        if (!highDatapoints.isEmpty()) {
            oneHourHighsCut = Constants.HOUR_SECONDS * (highDatapoints.get(0).time / Constants.HOUR_SECONDS)  + Constants.HOUR_SECONDS;
            highDatapoints.removeIf((i) -> i.time < oneHourHighsCut);
        } else {
            oneHourHighsCut = Integer.MAX_VALUE;
        }
        for (int i = data.high1hTimes.length-1; i >= 0; i--) {
            if (data.high1hTimes[i] < oneHourHighsCut) {
                highDatapoints.add(0, new Datapoint(data.high1hTimes[i], data.high1hPrices[i], false, Datapoint.Type.HOUR_AVERAGE));
            }
        }
        
        // add the prediction data points
        for (int i = 0; i < data.predictionTimes.length; i++) {
            predictionLowDatapoints.add(new Datapoint(
                    data.predictionTimes[i],
                    data.predictionLowMeans[i],
                    data.predictionLowIQRLower[i],
                    data.predictionLowIQRUpper[i],
                    true
            ));
            predictionHighDatapoints.add(new Datapoint(
                    data.predictionTimes[i],
                    data.predictionHighMeans[i],
                    data.predictionHighIQRLower[i],
                    data.predictionHighIQRUpper[i],
                    false
            ));
        }
    }

    private void calculateStats() {
        int cut24h = (int) Instant.now().minus(Duration.ofDays(1)).getEpochSecond();
        int cutWeek = (int) Instant.now().minus(Duration.ofDays(7)).getEpochSecond();
        if (!lowDatapoints.isEmpty() && !highDatapoints.isEmpty()){
            double priceCurrent = (lowDatapoints.get(lowDatapoints.size()-1).price *0.5 + highDatapoints.get(highDatapoints.size()-1).price *0.5);
            double lowPrice24hAgo = lowDatapoints.stream().filter(i-> i.time > cut24h).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double highPrice24hAgo = highDatapoints.stream().filter(i-> i.time > cut24h).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double price24hAgo = lowPrice24hAgo*0.5 + highPrice24hAgo*0.5;
            if (price24hAgo > 0 ) {
                this.priceChange24H = (priceCurrent - price24hAgo) / price24hAgo;
            }
            double lowPriceWeekAgo = lowDatapoints.stream().filter(i-> i.time > cutWeek).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double highPriceWeekAgo = highDatapoints.stream().filter(i-> i.time > cutWeek).findFirst().map(i -> (double) i.price).orElse(priceCurrent);
            double priceWeekAgo = lowPriceWeekAgo*0.5 + highPriceWeekAgo*0.5;
            if (priceWeekAgo > 0 ) {
                this.priceChangeWeek = (priceCurrent - priceWeekAgo) / priceWeekAgo;
            }
        }

        if(!highDatapoints.isEmpty()) {
            lastHighTime = highDatapoints.get(highDatapoints.size()-1).time;
            lastHighPrice = highDatapoints.get(highDatapoints.size()-1).price;
        }

        if(!lowDatapoints.isEmpty()) {
            lastLowTime = lowDatapoints.get(lowDatapoints.size()-1).time;
            lastLowPrice = lowDatapoints.get(lowDatapoints.size()-1).price;
        }

        margin = data.sellPrice - data.buyPrice;
        tax = data.sellPrice - GeTax.getPostTaxPrice(data.itemId, (int) data.sellPrice);
        profit = margin - tax;
    }

    public List<Datapoint> sellPriceDataPoint() {
        return Collections.singletonList(new Datapoint(
                (int) Instant.now().getEpochSecond(),
                (int) data.sellPrice,
                false,
                Datapoint.Type.PREDICTION
        ));
    }

    public List<Datapoint> buyPriceDataPoint() {
        return Collections.singletonList(new Datapoint(
                (int) Instant.now().getEpochSecond(),
                (int) data.buyPrice,
                true,
                Datapoint.Type.PREDICTION
        ));
    }
}
package com.flippingcopilot.ui.graph;

import com.flippingcopilot.manger.PriceGraphConfigManager;
import com.flippingcopilot.ui.graph.model.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class GraphPanel extends JPanel {
    public final String itemName;

    // Component references
    private final PriceGraphConfigManager configManager;
    public DataManager dataManager;
    private final RenderV2 renderer;
    public final ZoomHandler zoomHandler;
    private final DatapointTooltip tooltip;
    public final PlotArea pa;

    // For point hovering
    private Point mousePosition = new Point(0,0);
    private Datapoint hoveredPoint = null;

    public GraphPanel(DataManager dm, PriceGraphConfigManager configManager) {
        this.itemName = dm.data.name;

        // Initialize components
        this.dataManager = dm;
        this.configManager = configManager;
        this.renderer = new RenderV2();
        this.zoomHandler = new ZoomHandler();
        this.tooltip = new DatapointTooltip();

        // Set up panel
        setBackground(configManager.getConfig().backgroundColor);
        setPreferredSize(new Dimension(500, 300));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        this.pa = new PlotArea();
        zoomHandler.maxViewBounds = dataManager.calculateBounds((p) -> true);
        zoomHandler.homeViewBounds = dataManager.calculateBounds((p) -> p.time > zoomHandler.maxViewBounds.xMax - 4 * Constants.DAY_SECONDS);
        zoomHandler.weekViewBounds = dataManager.calculateBounds((p) -> p.time > zoomHandler.maxViewBounds.xMax - 7 * Constants.DAY_SECONDS);
        zoomHandler.monthViewBounds = dataManager.calculateBounds((p) -> p.time > zoomHandler.maxViewBounds.xMax - 30 * Constants.DAY_SECONDS);
        pa.bounds = zoomHandler.homeViewBounds.copy();
        setupMouseListeners();
    }


    private void setupMouseListeners() {
        MouseAdapter mouseAdapter = new MouseAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                mousePosition = e.getPoint();
                hoveredPoint = dataManager.findClosestPoint(pa.relativePoint(e.getPoint()), Config.HOVER_RADIUS, pa);
                repaint();
            }

            @Override
            public void mousePressed(MouseEvent e) {
                mousePosition = e.getPoint();
                Point plotPoint = pa.relativePoint(mousePosition);
                if (!pa.pointInPlotArea(plotPoint)) {
                    return;
                }

                if (zoomHandler.isOverHomeButton(plotPoint)) {
                    zoomHandler.applyHomeView(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverMaxButton(plotPoint)) {
                    zoomHandler.applyMaxView(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverZoomInButton(plotPoint)) {
                    zoomHandler.applyZoomIn(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverZoomOutButton(plotPoint)) {
                    zoomHandler.applyZoomOut(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverWeekButton(plotPoint)) {
                    zoomHandler.applyWeekView(pa);
                    repaint();
                    return;
                }
                if (zoomHandler.isOverMonthButton(plotPoint)) {
                    zoomHandler.applyMonthView(pa);
                    repaint();
                    return;
                }

                zoomHandler.startSelection(plotPoint);
                hoveredPoint = null;
                setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
                repaint();
            }

            @Override
            public void mouseDragged(MouseEvent e) {
                mousePosition = e.getPoint();
                if (zoomHandler.isSelecting()) {
                    zoomHandler.setSelectionEnd(pa.relativePoint(mousePosition));
                    repaint();
                }
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                mousePosition = e.getPoint();
                if (zoomHandler.isSelecting()) {
                    setCursor(Cursor.getDefaultCursor());
                    zoomHandler.setSelectionEnd(pa.relativePoint(mousePosition));
                    zoomHandler.applySelection(pa);
                    repaint();
                }
            }

            @Override
            public void mouseExited(MouseEvent e) {
                mousePosition = e.getPoint();
                hoveredPoint = null;
                repaint();
            }
        };

        addMouseMotionListener(mouseAdapter);
        addMouseListener(mouseAdapter);
    }


    @Override
    protected void paintComponent(Graphics g) {

        super.paintComponent(g);
        pa.w = getWidth() - pa.leftPadding - pa.rightPadding;
        pa.h = getHeight() - pa.topPadding - pa.bottomPadding;


        Data data = dataManager.getData();
        if (data == null) return;
        Config config = configManager.getConfig();
        setBackground(config.backgroundColor);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);

        Graphics2D plotAreaG2 = (Graphics2D) g2.create(pa.leftPadding, pa.topPadding, pa.w, pa.h);

        // First draw the legend above the plot area
        renderer.drawLegend(g2, config, pa);

        // Draw the plot area background with dynamic padding
        plotAreaG2.setColor(config.plotAreaColor);
        plotAreaG2.fillRect(0,0, pa.w, pa.h);

        TimeAxis xAxis = AxisCalculator.calculateTimeAxis(pa, AxisCalculator.getLocalTimeOffsetSeconds());
        PriceAxis yAxis = AxisCalculator.calculatePriceAxis(pa);
        renderer.drawGrid(plotAreaG2, config, pa, xAxis, yAxis);
        renderer.drawAxes(g2, config, pa, xAxis, yAxis);


        int pointSize = dynamicPointSize(Config.BASE_POINT_SIZE, pa);
        renderer.drawPoints(plotAreaG2, pa, dataManager.lowDatapoints, config.lowColor, pointSize);
        renderer.drawPoints(plotAreaG2, pa, dataManager.highDatapoints, config.highColor, pointSize);
        if (config.connectPoints) {
            renderer.drawLines(plotAreaG2, pa, dataManager.lowDatapoints, config.lowColor, Config.NORMAL_STROKE);
            renderer.drawLines(plotAreaG2, pa, dataManager.highDatapoints, config.highColor, Config.NORMAL_STROKE);
        }
        renderer.drawStartPoints(plotAreaG2, pa, dataManager.buyPriceDataPoint(), Color.WHITE, pointSize);
        renderer.drawStartPoints(plotAreaG2, pa, dataManager.sellPriceDataPoint(), Color.WHITE, pointSize);

        renderer.drawLines(plotAreaG2, pa, dataManager.predictionLowDatapoints, config.lowColor, Config.DOTTED_STROKE);
        renderer.drawLines(plotAreaG2, pa, dataManager.predictionHighDatapoints, config.highColor, Config.DOTTED_STROKE);
        renderer.drawPredictionIQR(plotAreaG2, config, pa, data.predictionTimes, data.predictionLowIQRLower, data.predictionLowIQRUpper, true);
        renderer.drawPredictionIQR(plotAreaG2, config, pa, data.predictionTimes, data.predictionHighIQRLower, data.predictionHighIQRUpper, false);
        zoomHandler.drawButtons(plotAreaG2, pa, pa.relativePoint(mousePosition));
        zoomHandler.drawSelectionRectangle(plotAreaG2);

        // Draw tooltip for hovered point
        if (hoveredPoint != null) {
            tooltip.draw(plotAreaG2, config, pa, hoveredPoint);
        }
    }

    private int dynamicPointSize(int baseSize, PlotArea pa) {
        int td = pa.bounds.xMax - pa.bounds.xMin;
        if (td < Constants.DAY_SECONDS) {
            return (int) ((float) baseSize * 1.25);
        } else if (td > Constants.DAY_SECONDS * 20) {
            return (int) ((float) baseSize * 0.5);
        } else if (td > Constants.DAY_SECONDS * 6) {
            return (int) ((float) baseSize * 0.75);
        }
        return baseSize;
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;

@Getter
@Setter
@NoArgsConstructor
public class Config {
    public static int LABEL_PADDING = 20;
    public static int TICK_SIZE = 5;
    public static int BASE_POINT_SIZE = 4;

    public static int GRAPH_BUTTON_SIZE = 24;
    public static int GRAPH_BUTTON_MARGIN = 5;

    public static int HOVER_RADIUS = 8; // Distance in pixels to detect hovering

    public static final Stroke NORMAL_STROKE = new BasicStroke(1f);
    public static final Stroke DOTTED_STROKE = new BasicStroke(
            1.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{5}, 0
    );
    public static final Stroke GRID_STROKE = new BasicStroke(
            0.8f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{3}, 0
    );
    public static final Stroke SELECTION_STROKE = new BasicStroke(1.5f);

    public static float FONT_SIZE = 16f;

    public static Color TOOLTIP_BACKGROUND = new Color(20, 20, 20, 220);
    public static Color TOOLTIP_BORDER = new Color(100, 100, 100);
    public static Color SELECTION_COLOR = new Color(100, 100, 240, 80); // Color for zoom selection
    public static Color SELECTION_BORDER_COLOR = new Color(70, 70, 220);
    public static Color GRAPH_BUTTON_COLOR = new Color(150, 150, 150, 200);
    public static Color GRAPH_BUTTON_HOVER_COLOR = new Color(100,100,100);

    // configurable properties
    public boolean connectPoints = false;
    public Color lowColor = new Color(0, 153, 255);
    public Color highColor = new Color(255, 102, 0);
    public Color lowShadeColor = new Color(0, 153, 255, 60);
    public Color highShadeColor = new Color(255, 102, 0, 60);

    public Color backgroundColor = ColorScheme.DARKER_GRAY_COLOR.brighter();
    public Color plotAreaColor = new Color(51, 51, 51);
    public Color textColor = new Color(225, 225, 225);
    public Color axisColor = new Color(150, 150, 150);
    public Color gridColor = new Color(85, 85, 85, 90);
}
package com.flippingcopilot.ui.graph.model;

import com.flippingcopilot.ui.graph.PlotArea;
import lombok.Getter;
import lombok.Setter;

import java.awt.Point;

@Getter
@Setter
public class Datapoint {

    public final int time;
    public final int price;
    public final Type type;
    public final boolean isLow; // true if buy/low point, false if sell/high point

    // IQR values for prediction points
    public final Integer iqrLower;
    public final Integer iqrUpper;

    public Datapoint(int time, int price, boolean isLow, Type type) {
        this.time = time;
        this.price = price;
        this.isLow = isLow;
        this.type = type;
        this.iqrLower = null;
        this.iqrUpper = null;
    }

    public Datapoint(int time, int price, int iqrLower, int iqrUpper, boolean isLow) {
        this.time = time;
        this.price = price;
        this.isLow = isLow;
        this.type = Type.PREDICTION;
        this.iqrLower = iqrLower;
        this.iqrUpper = iqrUpper;
    }

    public Point getHoverPosition(PlotArea pa) {
        int x = pa.timeToX(time);
        int y = pa.priceToY(price);
        if (type == Type.FIVE_MIN_AVERAGE) {
            x += pa.timeDeltaToXDelta(Constants.FIVE_MIN_SECONDS / 2);
        } else if (type == Type.HOUR_AVERAGE) {
            x += pa.timeDeltaToXDelta(Constants.HOUR_SECONDS / 2);
        }
        return new Point(x, y);
    }

    public enum Type {
        INSTA_SELL_BUY,
        FIVE_MIN_AVERAGE,
        HOUR_AVERAGE,
        PREDICTION,
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class PriceAxis {
    public int[] tickPrices;
    public int[] gridOnlyPrices;
}

package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

import java.time.Instant;

@AllArgsConstructor
public class Bounds {
    public int xMin;
    public int xMax;
    public int yMin;
    public int yMax;

    public Bounds() {
        xMax = (int) Instant.now().getEpochSecond();
        xMin = xMax - 24*60*60*4;
        yMax = Integer.MAX_VALUE;
        yMin = 0;
    }

    public int yDelta() {
        return yMax - yMin;
    }

    public int xDelta() {
        return xMax - xMin;
    }

    public Bounds copy() {
        return new Bounds(xMin, xMax, yMin, yMax);
    }
}

package com.flippingcopilot.ui.graph.model;

import java.text.SimpleDateFormat;

public class Constants {
    public static final int DAY_SECONDS = 86400;
    public static final int FIVE_MIN_SECONDS = 60*5;
    public static final int HOUR_SECONDS = 60*60;
    public static final SimpleDateFormat SECOND_DATE_FORMAT = new SimpleDateFormat("d MMM HH:mm:ss");
    public static final SimpleDateFormat MINUTE_DATE_FORMAT = new SimpleDateFormat("d MMM HH:mm");
}

package com.flippingcopilot.ui.graph.model;

import com.flippingcopilot.util.MsgPackUtil;
import com.google.gson.annotations.SerializedName;
import lombok.Getter;
import java.nio.ByteBuffer;

public class Data {

    @Getter
    public String loadingErrorMessage;

    @Getter
    public boolean fromWaitSuggestion;

    // 6 months 1h data
    @SerializedName("low_1h_times")
    public int[] low1hTimes;

    @SerializedName("low_1h_prices")
    public int[] low1hPrices;

    @SerializedName("high_1h_times")
    public int[] high1hTimes;

    @SerializedName("high_1h_prices")
    public int[] high1hPrices;

    // 1 month 5m data
    @SerializedName("low_5m_times")
    public int[] low5mTimes;

    @SerializedName("low_5m_prices")
    public int[] low5mPrices;

    @SerializedName("high_5m_times")
    public int[] high5mTimes;

    @SerializedName("high_5m_prices")
    public int[] high5mPrices;

    // several days latest data
    @SerializedName("low_latest_times")
    public int[] lowLatestTimes;

    @SerializedName("low_latest_prices")
    public int[] lowLatestPrices;

    @SerializedName("high_latest_times")
    public int[] highLatestTimes;

    @SerializedName("high_latest_prices")
    public int[] highLatestPrices;

    @SerializedName("prediction_times")
    public int[] predictionTimes;

    @SerializedName("prediction_low_means")
    public int[] predictionLowMeans;

    @SerializedName("prediction_low_iqr_upper")
    public int[] predictionLowIQRUpper;

    @SerializedName("prediction_low_iqr_lower")
    public int[] predictionLowIQRLower;

    @SerializedName("prediction_high_means")
    public int[] predictionHighMeans;

    @SerializedName("prediction_high_iqr_upper")
    public int[] predictionHighIQRUpper;

    @SerializedName("prediction_high_iqr_lower")
    public int[] predictionHighIQRLower;

    // stats
    @SerializedName("item_id")
    public int itemId;

    @SerializedName("name")
    public String name;

    @SerializedName("daily_volume")
    public double dailyVolume;

    @SerializedName("sell_price")
    public long sellPrice;
    @SerializedName("buy_price")
    public long buyPrice;


    public static Data fromMsgPack(ByteBuffer b) {
        Data d = new Data();
        Integer mapSize = MsgPackUtil.decodeMapSize(b);
        if(mapSize == null) {
            return null;
        }
        for (int i = 0; i < mapSize; i++) {
            String key = (String) MsgPackUtil.decodePrimitive(b);
            switch (key) {
                case "l1ht":
                    d.low1hTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l1hp":
                    d.low1hPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h1ht":
                    d.high1hTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h1hp":
                    d.high1hPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l5mt":
                    d.low5mTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "l5mp":
                    d.low5mPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h5mt":
                    d.high5mTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "h5mp":
                    d.high5mPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "llt":
                    d.lowLatestTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "llp":
                    d.lowLatestPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "hlt":
                    d.highLatestTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "hlp":
                    d.highLatestPrices = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "pt":
                    d.predictionTimes = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "plm":
                    d.predictionLowMeans = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "pliu":
                    d.predictionLowIQRUpper = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "plil":
                    d.predictionLowIQRLower = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phm":
                    d.predictionHighMeans = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phiu":
                    d.predictionHighIQRUpper = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "phil":
                    d.predictionHighIQRLower = MsgPackUtil.decodeInt32Array(b);
                    break;
                case "id":
                    d.itemId =  (int) (long)MsgPackUtil.decodePrimitive(b);
                    break;
                case "n":
                    d.name = (String) MsgPackUtil.decodePrimitive(b);
                    break;
                case "dv":
                    d.dailyVolume = (double) MsgPackUtil.decodePrimitive(b);
                    break;
                case "sp":
                    d.sellPrice = (long) (long) MsgPackUtil.decodePrimitive(b);
                    break;
                case "bp":
                    d.buyPrice = (long) MsgPackUtil.decodePrimitive(b);
                    break;
                default:
                    // discard value for unrecognised key
                    MsgPackUtil.decodePrimitive(b);
            }
        }

        return d;
    }
}
package com.flippingcopilot.ui.graph.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class TimeAxis {
    public int[] dateOnlyTickTimes;
    public int[] timeOnlyTickTimes;
    public int[] gridOnlyTickTimes;
}

package com.flippingcopilot.ui.graph;

import com.flippingcopilot.ui.UIUtilities;
import com.flippingcopilot.ui.graph.model.Config;
import com.flippingcopilot.ui.graph.model.Constants;
import com.flippingcopilot.ui.graph.model.Datapoint;
import lombok.Getter;

import java.awt.*;
import java.util.Date;

@Getter
public class DatapointTooltip {

    private Rectangle bounds;
    private int padding;

    public DatapointTooltip() {
        this.bounds = new Rectangle();
        this.padding = 8; // Padding inside tooltip
    }

    public void draw(Graphics2D g2, Config config, PlotArea pa, Datapoint point) {
        // Prepare tooltip text
        String priceStr = UIUtilities.quantityToRSDecimalStack(point.getPrice(), true);

        final String typeText;
        final String timeText;
        switch (point.type) {
            case INSTA_SELL_BUY:
                typeText = point.isLow() ? "low (insta-sell)" : "high (insta-buy)";
                timeText = Constants.SECOND_DATE_FORMAT.format(new Date(point.getTime() * 1000L));
                break;
            case FIVE_MIN_AVERAGE:
                typeText = point.isLow() ? "low 5m average" : "high 5min average";
                timeText = Constants.MINUTE_DATE_FORMAT.format(new Date(point.getTime() * 1000L)) + " - " + Constants.MINUTE_DATE_FORMAT.format(new Date((point.getTime()+ Constants.FIVE_MIN_SECONDS) * 1000L));
                break;
            case HOUR_AVERAGE:
                typeText = point.isLow() ? "low 1h average" : "high 1h average";
                timeText = Constants.MINUTE_DATE_FORMAT.format(new Date(point.getTime() * 1000L)) + " - " + Constants.MINUTE_DATE_FORMAT.format(new Date((point.getTime()+ Constants.HOUR_SECONDS) * 1000L));
                break;
            case PREDICTION:
                typeText = point.isLow() ? "low prediction" : "high prediction";
                timeText = Constants.SECOND_DATE_FORMAT.format(new Date(point.getTime() * 1000L));
                break;
            default:
                throw new IllegalArgumentException("invalid point type: "+ point.type);
        }

        // Calculate tooltip dimensions
        g2.setFont(g2.getFont().deriveFont(Config.FONT_SIZE));
        FontMetrics fm = g2.getFontMetrics();
        int typeTextWidth = fm.stringWidth(typeText);
        int timeTextWidth = fm.stringWidth(timeText);
        int priceStrWidth = fm.stringWidth(priceStr);
        int textWidth = Math.max(Math.max(typeTextWidth, timeTextWidth), priceStrWidth);
        int textHeight = fm.getHeight() * 3; // Three lines of text

        int tooltipWidth = textWidth + padding * 2;
        int tooltipHeight = textHeight + padding * 2;

        Point hoverPosition = point.getHoverPosition(pa);

        // Position tooltip near point but ensure it stays within panel bounds
        int tooltipX = hoverPosition.x + 15;
        int tooltipY = hoverPosition.y - tooltipHeight - 5;

        // Adjust if tooltip would go off screen
        if (tooltipX + tooltipWidth > pa.w) {
            tooltipX = hoverPosition.x - tooltipWidth - 5;
        }
        if (tooltipY < 0) {
            tooltipY = hoverPosition.y + 15;
        }

        // Update bounds for later hit testing if needed
        bounds.setBounds(tooltipX, tooltipY, tooltipWidth, tooltipHeight);

        // Draw tooltip background
        g2.setColor(Config.TOOLTIP_BACKGROUND);
        g2.fillRoundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8, 8);

        // Draw tooltip border
        g2.setColor(Config.TOOLTIP_BORDER);
        g2.drawRoundRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight, 8, 8);

        // Draw tooltip text - first line (type text)
        g2.setColor(config.textColor);
        int yPos = tooltipY + padding + fm.getAscent();
        g2.drawString(typeText, tooltipX + padding, yPos);

        // Draw tooltip text - second line (time)
        yPos += fm.getHeight();
        g2.drawString(timeText, tooltipX + padding, yPos);

        // Draw tooltip text - third line (price)
        yPos += fm.getHeight();
        g2.drawString(priceStr, tooltipX + padding, yPos);

        // Highlight the hovered point
        if (point.isLow()) {
            g2.setColor(config.lowColor);
        } else {
            g2.setColor(config.highColor);
        }

        // Draw larger point to highlight hover

        int highlightSize = 8;
        g2.fillOval(hoverPosition.x - highlightSize / 2,
                hoverPosition.y - highlightSize / 2,
                highlightSize, highlightSize);

        g2.setColor(Color.WHITE);
        g2.drawOval(hoverPosition.x - highlightSize / 2 - 1,
                hoverPosition.y - highlightSize / 2 - 1,
                highlightSize + 2, highlightSize + 2);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.FlipV2;
import net.runelite.client.ui.ColorScheme;

import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;

public class FlipPanel extends JPanel {

    public FlipPanel(FlipV2 flip, FlippingCopilotConfig config) {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel itemQuantity = new JLabel(String.format("%d x ", flip.getClosedQuantity()));
        itemQuantity.setForeground(Color.WHITE);

        JLabel itemNameLabel = new JLabel(UIUtilities.truncateString(flip.getItemName(), 20));

        // Create a sub-panel for the left side
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        leftPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        leftPanel.add(itemQuantity);
        leftPanel.add(itemNameLabel);

        JLabel profitLabel = new JLabel(UIUtilities.formatProfitWithoutGp(flip.getProfit()));
        profitLabel.setForeground(UIUtilities.getProfitColor(flip.getProfit(), config));

        // Add the sub-panel to the LINE_START position
        add(leftPanel, BorderLayout.LINE_START);
        add(profitLabel, BorderLayout.LINE_END);
        setMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));

        String closeLabel = flip.getClosedQuantity() == flip.getOpenedQuantity() ? "Close time" : "Partial close time";

        String tooltipText = String.format("Opened time: %s\nAvg buy price: %s\n%s: %s\nAvg sell price: %s\nTax paid: %s\nProfit: %s",
                formatEpoch(flip.getOpenedTime()),
                UIUtilities.formatProfit(flip.getAvgBuyPrice()),
                closeLabel,
                formatEpoch(flip.getClosedTime()),
                UIUtilities.formatProfit(flip.getAvgSellPrice()),
                UIUtilities.formatProfit(flip.getTaxPaid()),
                UIUtilities.formatProfit(flip.getProfit()));
        setToolTipText(tooltipText);
    }

    public static String formatEpoch(long epochSeconds) {
        Instant instant = Instant.ofEpochSecond(epochSeconds);
        DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM)
                .withZone(ZoneId.systemDefault());
        return formatter.format(instant);
    }
}
package com.flippingcopilot.ui;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class BlacklistIcons {

    public static ImageIcon createTickIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();

        g2d.setColor(new Color(40, 167, 69));
        g2d.setStroke(new BasicStroke(2));
        g2d.drawLine(3, 8, 7, 12);
        g2d.drawLine(7, 12, 13, 4);
        g2d.dispose();

        return new ImageIcon(image);
    }

    public static ImageIcon createXIcon() {
        int size = 16;
        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = image.createGraphics();

        g2d.setColor(new Color(220, 53, 69));
        g2d.setStroke(new BasicStroke(2));
        g2d.drawLine(4, 4, 12, 12);
        g2d.drawLine(4, 12, 12, 4);
        g2d.dispose();

        return new ImageIcon(image);
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.model.SuggestionPreferencesManager;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import org.apache.commons.lang3.tuple.Pair;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;

@Slf4j
@Singleton
public class BlacklistDropdownPanel extends JPanel {
    private final SuggestionPreferencesManager preferencesManager;
    private final JTextField displayField;
    private final JWindow dropdownWindow;
    private final JPanel resultsPanel;
    private final JScrollPane scrollPane;
    private final JTextField searchField;
    private final ClientThread clientThread;

    @Inject
    public BlacklistDropdownPanel(SuggestionPreferencesManager preferencesManager, ClientThread clientThread) {
        super();
        this.preferencesManager = preferencesManager;
        this.clientThread = clientThread;

        setLayout(new BorderLayout());

        // Create main display field with placeholder
        displayField = new JTextField("Search an item...");
        displayField.setEditable(true);
        displayField.setPreferredSize(new Dimension(12, displayField.getPreferredSize().height));
        displayField.setForeground(Color.GRAY);

        // Create label
        JLabel label = new JLabel("Blocklist:");
        label.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 5));
        label.setOpaque(true);
        label.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        // Setup display field panel
        JPanel dropdownPanel = new JPanel(new BorderLayout());
        dropdownPanel.add(displayField, BorderLayout.CENTER);
        dropdownPanel.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));

        // Create container panel
        JPanel containerPanel = new JPanel(new BorderLayout(5, 0));
        containerPanel.add(label, BorderLayout.WEST);
        containerPanel.add(dropdownPanel, BorderLayout.CENTER);
        containerPanel.setOpaque(true);
        containerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        add(containerPanel, BorderLayout.CENTER);

        // Setup dropdown components
        dropdownWindow = new JWindow();
        searchField = new JTextField();
        resultsPanel = new JPanel();
        resultsPanel.setLayout(new BoxLayout(resultsPanel, BoxLayout.Y_AXIS));

        scrollPane = new JScrollPane(resultsPanel);
        scrollPane.setPreferredSize(new Dimension(300, 400));

        // Create dropdown content panel
        JPanel dropdownContent = new JPanel(new BorderLayout());
        dropdownContent.add(searchField, BorderLayout.NORTH);
        dropdownContent.add(scrollPane, BorderLayout.CENTER);
        dropdownContent.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY));

        dropdownWindow.add(dropdownContent);

        setupListeners();
    }

    private void updateDropdown(String searchText) {
        clientThread.invoke(() -> {
            // Get fresh data
            List<Pair<Integer, String>> searchResults = preferencesManager.search(searchText);
            Set<Integer> blockedItems = new HashSet<>(preferencesManager.blockedItems());

            SwingUtilities.invokeLater(() -> {

                // Update results panel
                resultsPanel.removeAll();
                for (Pair<Integer, String> item : searchResults) {
                    resultsPanel.add(createItemPanel(item, blockedItems));
                }
                // Calculate dimensions
                Point location = getLocationOnScreen();
                int searchHeight = searchField.getPreferredSize().height;
                int scrollBarHeight = scrollPane.getHorizontalScrollBar().getPreferredSize().height;
                int contentHeight = Arrays.stream(resultsPanel.getComponents())
                        .mapToInt(comp -> comp.getPreferredSize().height)
                        .sum();

                int totalHeight = Math.min(
                        contentHeight + searchHeight + scrollBarHeight + 12, // 12 for border and padding
                        400 // Maximum height
                );

                // Update window
                dropdownWindow.setLocation(location.x, location.y + getHeight());
                dropdownWindow.setSize(getWidth(), totalHeight);
                dropdownWindow.setVisible(true);

                // Update UI
                resultsPanel.revalidate();
                resultsPanel.repaint();
                searchField.setText(searchText);
            });
        });
    }

    private void setupListeners() {

        displayField.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                log.debug("mouse clicked");
                updateDropdown(displayField.getText());
            }
        });

        displayField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
                if (displayField.getText().equals("Search an item...")) {
                    displayField.setText("");
                    updateDropdown(displayField.getText());
                }
            }

            @Override
            public void focusLost(FocusEvent e) {
                log.debug("focus lost");
                displayField.setText("Search an item...");
                displayField.setForeground(Color.GRAY);
                dropdownWindow.setVisible(false);
            }
        });

        // Display field key listener
        displayField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_ENTER) {
                    updateDropdown(displayField.getText());
                    e.consume();
                }
            }
        });
    }

    private JPanel createItemPanel(Pair<Integer, String> item, Set<Integer> blockedItemIds) {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBorder(BorderFactory.createEmptyBorder(1, 2, 1, 2));

        JLabel nameLabel = new JLabel(item.getValue());
        panel.add(nameLabel, BorderLayout.CENTER);

        JButton toggleButton = new JButton(blockedItemIds.contains(item.getKey()) ? BlacklistIcons.createXIcon() : BlacklistIcons.createTickIcon());
        toggleButton.setBorderPainted(false);
        toggleButton.setContentAreaFilled(false);
        toggleButton.setPreferredSize(new Dimension(16, 16));

         Runnable onClick = () -> {
            if (blockedItemIds.contains(item.getKey())) {
                preferencesManager.unblockItem(item.getKey());
                blockedItemIds.remove(item.getKey());
                toggleButton.setIcon(BlacklistIcons.createTickIcon());
            } else {
                preferencesManager.blockItem(item.getKey());
                blockedItemIds.add(item.getKey());
                toggleButton.setIcon(BlacklistIcons.createXIcon());
            }
            panel.revalidate();
            panel.repaint();
        };

        toggleButton.addActionListener(e -> onClick.run());

        panel.add(toggleButton, BorderLayout.EAST);

        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent ee) {
                onClick.run();
            }
        });
        return panel;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.CopilotLoginController;
import net.runelite.client.input.KeyListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;


@Singleton
public class LoginPanel extends JPanel {
    private final static int PAGE_WIDTH = 225;

    private final CopilotLoginController copilotLoginController;

    private JPanel loginContainer;
    private JButton loginButton;
    private JTextField emailTextField;
    private JTextField passwordTextField;
    private JLabel errorMessageLabel;

    public final Spinner spinner = new Spinner();

    @Inject
    public LoginPanel(CopilotLoginController copilotLoginController) {
        this.copilotLoginController = copilotLoginController;
        this.setLayout(new BorderLayout());
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.setSize(PAGE_WIDTH, 250);

        loginContainer = new JPanel();
        loginContainer.setLayout(new BoxLayout(loginContainer, BoxLayout.PAGE_AXIS));

        this.createLogo();
        this.createSpinner();
        this.createErrorMessageLabel();
        this.createEmailInput();
        this.createPasswordInput();
        this.createLoginButton();
        this.createCreateAccountLink();

        this.add(loginContainer, BorderLayout.NORTH);
    }

    public void createLogo() {
        JPanel container = new JPanel();
        ImageIcon icon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/logo.png"));
        Image resizedLogo = icon.getImage().getScaledInstance(50, 45, Image.SCALE_SMOOTH);
        JLabel logoLabel = new JLabel(new ImageIcon(resizedLogo));
        logoLabel.setSize(50, 45);
        container.add(logoLabel, BorderLayout.CENTER);
        container.setBorder(new EmptyBorder(10, 0, 10, 0));
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createSpinner() {
        JPanel container = new JPanel();
        container.add(spinner, BorderLayout.CENTER);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void startLoading() {
        spinner.show();
        loginButton.setEnabled(false);
        errorMessageLabel.setText("");
        errorMessageLabel.setVisible(false);
    }

    public void endLoading() {
        spinner.hide();
        loginButton.setEnabled(true);
    }

    public void createErrorMessageLabel() {
        JPanel container = new JPanel();
        errorMessageLabel = new JLabel();
        errorMessageLabel.setForeground(Color.RED);
        errorMessageLabel.setHorizontalAlignment(SwingConstants.LEFT);
        errorMessageLabel.setSize(PAGE_WIDTH, 40);
        errorMessageLabel.setVisible(false);
        container.add(errorMessageLabel); // Add the error message label under the logo
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createEmailInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        emailTextField = new JTextField();
        emailTextField.setSize(PAGE_WIDTH, 40);
        emailTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                copilotLoginController.onEmailTextChanged(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        emailTextField.addActionListener(copilotLoginController::onLoginPressed);
        JLabel emailLabel = new JLabel("Email address");
        container.add(emailLabel, BorderLayout.WEST);
        container.add(emailTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createPasswordInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        passwordTextField = new JPasswordField();
        passwordTextField.setSize(PAGE_WIDTH, 40);
        passwordTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                copilotLoginController.onPasswordTextChanged(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        passwordTextField.addActionListener(copilotLoginController::onLoginPressed);
        JLabel passwordLabel = new JLabel("Password");
        container.add(passwordLabel);
        container.add(passwordTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createCreateAccountLink() {
        JPanel container = new JPanel();
        JLabel createAccountLabel = new JLabel("Don't have an account? Sign up.");
        createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        createAccountLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                LinkBrowser.browse("https://flippingcopilot.com/signup");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.BRAND_ORANGE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            }
        });
        container.add(createAccountLabel);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createLoginButton() {
        JPanel container = new JPanel();
        loginButton = new JButton("Login");
        loginButton.addActionListener(copilotLoginController::onLoginPressed);
        container.add(loginButton);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void showLoginErrorMessage(String message) {
        errorMessageLabel.setText("<html><p>" + message + "</p></html>");
        errorMessageLabel.setVisible(true);
    }

    public void refresh() {

    }
}

package com.flippingcopilot.manger;

import com.flippingcopilot.controller.Persistance;
import com.flippingcopilot.ui.graph.model.Config;
import com.google.gson.Gson;
import com.google.gson.JsonIOException;
import com.google.gson.JsonSyntaxException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.nio.file.Files;
import java.util.concurrent.ScheduledExecutorService;


@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PriceGraphConfigManager {

    public static final String JSON_FILE = "price_graph_config.json";

    private final File file = new File(Persistance.PARENT_DIRECTORY, JSON_FILE);

    // dependencies
    private final Gson gson;
    private final ScheduledExecutorService executorService;

    // state
    private Config cachedConfig;

    public synchronized Config getConfig() {
        if(cachedConfig != null) {
            return cachedConfig;
        }
        cachedConfig = load();
        return cachedConfig;
    }

    public synchronized void setConfig(Config config) {
        if (config == null) {
            return;
        }
        cachedConfig = config;
        saveAsync();
    }

    public void saveAsync() {
        executorService.submit(() -> {
            synchronized (file) {
                Config config = getConfig();
                try {
                    String json = gson.toJson(config);
                    Files.write(file.toPath(), json.getBytes());
                } catch (IOException e) {
                    log.warn("error saving graph config {}", e.getMessage(), e);
                }
            }
        });
    }

    public Config load() {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            return gson.fromJson(reader, Config.class);
        } catch (FileNotFoundException ignored) {
            return new Config();
        } catch (JsonSyntaxException | JsonIOException | IOException e) {
            log.warn("error loading saved graph config json file {}", file, e);
            return new Config();
        }
    }
}

package com.flippingcopilot.util;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class GeTaxTest {

    @Test
    public void postTaxPriceForExemptItemReturnsOriginalPrice() {
        int itemId = 13190;
        int price = 1000;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceNormalItem() {
        int itemId = 9999;
        int price = 1000;
        assertEquals(990, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceAboveCap() {
        int itemId = 9999;
        int price = 600000000;
        assertEquals(595000000, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceCheapItem() {
        int itemId = 13190;
        int price = 67;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }
}
//package com.flippingcopilot.controller;
//
//import net.runelite.api.GrandExchangeOffer;
//import net.runelite.api.GrandExchangeOfferState;
//import net.runelite.api.events.GrandExchangeOfferChanged;
//import org.junit.Test;
//
//import java.util.ArrayList;
//
//public class OfferEventFilterTest {
//
//    @Test
//    public void testShouldProcessOnLogin() {
//        OfferEventFilter filter = new OfferEventFilter();
//
//        ArrayList<GrandExchangeOfferChanged> events = new ArrayList<>();
//        ArrayList<Boolean> expectedReturnValues = new ArrayList<>();
//
//        events.add(mockOfferEvent(0, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(1, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(3, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(4, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(6, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(false);
//
//        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(true);
//        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
//        expectedReturnValues.add(true);
//
//        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
//        expectedReturnValues.add(false);
//
//        for (int i = 0; i < events.size(); i++) {
//            assert filter.shouldProcess(events.get(i)) == expectedReturnValues.get(i);
//        }
//    }
//
//    @Test
//    public void testShouldProcessNewBuyOffer() {
//        OfferEventFilter filter = new OfferEventFilter();
//        GrandExchangeOfferChanged event1 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert filter.shouldProcess(event1);
//        GrandExchangeOfferChanged event2 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert !filter.shouldProcess(event2);
//    }
//
//    @Test
//    public void testLogoutLogin() {
//        OfferEventFilter filter = new OfferEventFilter();
//        GrandExchangeOfferChanged event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert filter.shouldProcess(event);
//
//
//        for (int i = 0; i < 8; i++) {
//            event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
//            assert !filter.shouldProcess(event);
//        }
//
//        for (int i = 0; i < 8; i++) {
//            if (i == 2) {
//                event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//                assert !filter.shouldProcess(event);
//            } else {
//                event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
//                assert filter.shouldProcess(event);
//            }
//        }
//
//        event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
//        assert !filter.shouldProcess(event);
//    }
//
//    static GrandExchangeOfferChanged mockOfferEvent(int slot, int itemId, int quantitySold, int totalQuantity,
//                                                    int price, int spent, GrandExchangeOfferState state) {
//        GrandExchangeOfferChanged event = new GrandExchangeOfferChanged();
//        event.setSlot(slot);
//        event.setOffer(new GrandExchangeOffer() {
//            @Override
//            public int getQuantitySold() {
//                return quantitySold;
//            }
//
//            @Override
//            public int getItemId() {
//                return itemId;
//            }
//
//            @Override
//            public int getTotalQuantity() {
//                return totalQuantity;
//            }
//
//            @Override
//            public int getPrice() {
//                return price;
//            }
//
//            @Override
//            public int getSpent() {
//                return spent;
//            }
//
//            @Override
//            public GrandExchangeOfferState getState() {
//                return state;
//            }
//        });
//        return event;
//    }
//
//
//}

package com.flippingcopilot.controller;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;


public class DoesNothingExecutorService implements ScheduledExecutorService {
    @Override
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        return null;
    }

    @Override
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        return null;
    }

    @Override
    public void shutdown() {

    }

    @Override
    public List<Runnable> shutdownNow() {
        return List.of();
    }

    @Override
    public boolean isShutdown() {
        return false;
    }

    @Override
    public boolean isTerminated() {
        return false;
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return false;
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return null;
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return null;
    }

    @Override
    public Future<?> submit(Runnable task) {
        return null;
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return List.of();
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return null;
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return null;
    }

    @Override
    public void execute(Runnable command) {

    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import org.junit.Test;

public class TestSuggestionController {

    @Test
    public void testShouldNotifyOnWait() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null);
        Suggestion newSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 1, "", null);
        assert !SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnNewBuy() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null);
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "", null);
        assert SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnRepeatedBuy() {
        Suggestion oldSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 0, "", null);;
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "", null);
        assert !SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnAbort() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "", null);
        Suggestion newSuggestion = new Suggestion("abort", 0, 560, 200, 25000, "Death rune", 1, "", null);
        assert SuggestionController.shouldNotify(newSuggestion, oldSuggestion);
    }
}

package com.flippingcopilot.model;

import org.junit.Test;


public class OfferListTest {
    @Test
    public void testIsEmptySlotNeededWithExistingOfferInSlot() {
        StatusOfferList offerList = new StatusOfferList();
        offerList.set(0, new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "", null);
        assert !offerList.isEmptySlotNeeded(suggestion);
    }

    @Test
    public void testIsEmptySlotNeededWithNoEmptySlots() {
        StatusOfferList offerList = new StatusOfferList();
        offerList.replaceAll(ignored -> new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "", null);
        assert offerList.isEmptySlotNeeded(suggestion);
    }

}

package com.flippingcopilot.model;

import com.flippingcopilot.controller.DoesNothingExecutorService;
import okhttp3.OkHttpClient;
import org.junit.Assert;
import org.junit.Test;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FlipPriceGraphControllerTest {

    private static final String DISPLAY_NAME_1 = "Acc 1";
    private static final String DISPLAY_NAME_2 = "Acc 2";
    private static final String DISPLAY_NAME_3 = "Acc 3";
    private final Map<String, Integer> displayNameToAccountId = Map.of(DISPLAY_NAME_1, 0, DISPLAY_NAME_2, 1, DISPLAY_NAME_3, 2);

    @Test
    public void testOneAccount() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 10_000, List.of(0));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null, new DoesNothingExecutorService(), new OkHttpClient.Builder().build());
        flipManager.setFlipsChangedCallback(() -> {});
        flipManager.displayNameToAccountId.putAll(displayNameToAccountId);
        flipManager.mergeFlips(flips, null);
        flipManager.setIntervalDisplayName(DISPLAY_NAME_1);


        verifyflipManagerStoredOrder(flipManager);

        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(FlipV2::getId));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        for (int time : testTimes) {
            flipManager.setIntervalStartTime(time);

            // check stats equal
            Stats stats1 = flipManager.getIntervalStats();
            Stats stats2 = expectedStats(flips, time, DISPLAY_NAME_1);
            Assert.assertEquals(stats1, stats2);

            // check all flips equal
            List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
            List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), DISPLAY_NAME_1);
            assertFlipListsEqual(allFlips1, allFlips2);

            // check paginated flips equal
            for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                int numPages = stats1.flipsMade / pageSize + 1;
                for(int page=1; page <= numPages; page++) {
                    List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, DISPLAY_NAME_1);
                    List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                    assertFlipListsEqual(pageFlips1, pageFlips2);
                }
            }
        }
    }

    @Test
    public void testMultipleAccounts() {

        // generate 6 months or random flips
        int now = (int) Instant.now().getEpochSecond();
        int sixMonthsAgo = (int) Instant.now().minus(365/ 2, ChronoUnit.DAYS).getEpochSecond();
        List<FlipV2> flips = generateFlipsBetween(sixMonthsAgo, now, 5_000, List.of(0, 1, 2));

        // create and populate the flip cache
        FlipManager flipManager = new FlipManager(null, new DoesNothingExecutorService(), new OkHttpClient.Builder().build());
        flipManager.setFlipsChangedCallback(() -> {});
        flipManager.displayNameToAccountId.putAll(displayNameToAccountId);
        flipManager.mergeFlips(flips, null);
        verifyflipManagerStoredOrder(flipManager);


        flips.sort(Comparator.comparing(FlipV2::getClosedTime).reversed().thenComparing(Comparator.comparing(FlipV2::getId).reversed()));

        // create list of test interval start times
        List<Integer> testTimes = Stream.generate(()-> randomIntBetween(sixMonthsAgo, now)).limit(100).collect(Collectors.toList());
        testTimes.add(0, 0); // add 0 which is ALL

        flipManager.setIntervalDisplayName(null);
        List<FlipV2> flips1 = flipManager.getPageFlips(1, flips.size());
        assertFlipListsEqual(flips1, flips);

        for (String name : Arrays.asList(DISPLAY_NAME_1, DISPLAY_NAME_2, DISPLAY_NAME_3, null)) {
            flipManager.setIntervalDisplayName(name);
            for (int time : testTimes) {
                flipManager.setIntervalStartTime(time);

                // check stats equal
                Stats stats1 = flipManager.getIntervalStats();
                Stats stats2 = expectedStats(flips, time, name);
                Assert.assertEquals(stats1, stats2);

                // check all flips equal
                List<FlipV2> allFlips1 = flipManager.getPageFlips(1, flips.size());
                List<FlipV2> allFlips2 = expectedPage(flips, time, 1, flips.size(), name);
                assertFlipListsEqual(allFlips1, allFlips2);

                // check paginated flips equal
                for (int pageSize : Arrays.asList(3, 20, 33, 50, 100)) {
                    int numPages = stats1.flipsMade / pageSize + 1;
                    for (int page = 1; page <= numPages; page++) {
                        List<FlipV2> pageFlips1 = flipManager.getPageFlips(page, pageSize);
                        List<FlipV2> pageFlips2 = expectedPage(flips, time, page, pageSize, name);
                        assertFlipListsEqual(pageFlips1, pageFlips2);
                    }
                }
            }
        }
    }

    public void verifyflipManagerStoredOrder(FlipManager flipManager) {
        for (int i =0; i < flipManager.weeks.size(); i++) {
            Assert.assertTrue(flipManager.weeks.get(Math.max(i-1,0)).weekStart <= flipManager.weeks.get(i).weekStart);
            FlipManager.WeekAggregate w = flipManager.weeks.get(i);
            for (List<FlipV2> flips : w.accountIdToFlips.values()) {
                for (int ii =1; ii < flips.size(); ii++) {
                    Assert.assertTrue(flips.get(ii-1).getClosedTime() <= flips.get(ii).getClosedTime());
                }
            }
        }
    }

    private List<FlipV2> expectedPage(List<FlipV2> flips, int time, int pageNumber, int pageSize, String displayName) {
        Integer accountId = displayName == null ? null : displayNameToAccountId.getOrDefault(displayName, -1);
        int toSkip = (pageNumber - 1) * pageSize;
        List<FlipV2> page = new ArrayList<>();
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                if(toSkip > 0) {
                    toSkip -= 1;
                } else {
                    page.add(f);
                    if(page.size() == pageSize) {
                        break;
                    }
                }
            }
        }
        return page;
    }

    private void assertFlipListsEqual(List<FlipV2> f1, List<FlipV2> f2) {
        if(f1.size() != f2.size()) {
            Assert.fail("flips lists not equal length");
        }
        for (int i=0; i < f1.size(); i++) {
            FlipV2 flip1 = f1.get(i);
            FlipV2 flip2 = f2.get(i);
            if (!flip1.equals(flip2)) {
                Assert.fail("flips don't match at index " + i);
            }
        }
    }

    private Stats expectedStats(List<FlipV2> flips, int time, String displayName) {
        Integer accountId = displayName == null ? null : displayNameToAccountId.getOrDefault(displayName, -1);
        Stats stats = new Stats(0,0,0,0);
        for(FlipV2 f : flips) {
            if(f.getClosedTime() > time && (accountId == null || accountId == f.getAccountId())) {
                stats.flipsMade += 1;
                stats.gross += f.getSpent();
                stats.profit += f.getProfit();
            }
        }
        return stats;
    }

    private List<FlipV2> generateFlipsBetween(int start, int end, int number, List<Integer> accountIds) {
        List<FlipV2> flips = new ArrayList<>();
        for (int i =0; i< number; i++) {
            FlipV2 f = new FlipV2();
            f.setId(UUID.randomUUID());
            f.setAccountId(accountIds.get(new Random().nextInt(accountIds.size())));
            // leave a small percentage as open flips
            if(randomIntBetween(0, 1000) > 2) {
                f.setClosedTime(randomIntBetween(start, end));
                f.setSpent(randomIntBetween(100, 1_000_000_000));
                f.setProfit(randomIntBetween(-2_000_000, 4_000_000));
                flips.add(f);
            }
        }
        return flips;
    }

    private int randomIntBetween(int min, int max) {
        return (int)(Math.random() * ((max - min) + 1)) + min;
    }
}
package com.flippingcopilot.model;

import org.junit.Test;

public class AccountStatusTest {

    @Test
    public void testMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        assert accountStatus.moreGpNeeded();
    }

    @Test
    public void testNoMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        accountStatus.getInventory().add(new RSItem(995, 2000));
        assert !accountStatus.moreGpNeeded();
    }
}

//package com.flippingcopilot.model;
//
//import org.junit.Test;
//
//import java.time.Instant;
//
//public class OfferTest {
//
//    @Test
//    public void testTransactionFromNewOffer() {
//        Offer oldOffer = Offer.getEmptyOffer(0);
//        Offer newOffer = new Offer(OfferStatus.BUY, 560, 100, 50, 1000,
//                10, 10, 0, 0, true, false);
//        Transaction expectedTransaction = new Transaction(null, OfferStatus.BUY, 560, 100, 10, 0, 1000, null,false, 0, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert expectedTransaction.equals(actualTransaction);
//    }
//
//    @Test
//    public void testTransactionFromProgressingSell() {
//        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 4000,
//                40, 0, 4000, 0, true, false);
//        Transaction expectedTransaction = new Transaction(null, OfferStatus.SELL, 560, 100, 30, 0, 3000, null,false, 0, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert expectedTransaction.equals(actualTransaction);
//    }
//
//    @Test
//    public void testNoTransaction() {
//        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
//                10, 0, 1000, 0, true, false);
//        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
//        assert actualTransaction == null;
//    }
//}

package com.flippingcopilot.ui;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class UIUtilitiesTest {

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsGreaterThanStringLength() {
        String result = UIUtilities.truncateString("Hello", 10);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsLessThanStringLength() {
        String result = UIUtilities.truncateString("Hello, World!", 5);
        assertEquals("Hello...", result);
    }

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsEqualToStringLength() {
        String result = UIUtilities.truncateString("Hello", 5);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsEmptyString_whenInputStringIsEmpty() {
        String result = UIUtilities.truncateString("", 5);
        assertEquals("", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsZero() {
        String result = UIUtilities.truncateString("Hello, World!", 0);
        assertEquals("...", result);
    }
}
package com.flippingcopilot;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FlippingCopilotPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlippingCopilotPlugin.class);
		RuneLite.main(args);
	}
}
