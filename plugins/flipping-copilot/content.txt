package com.flippingcopilot.util;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class GeTaxTest {

    @Test
    public void postTaxPriceForExemptItemReturnsOriginalPrice() {
        int itemId = 13190;
        int price = 1000;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceNormalItem() {
        int itemId = 9999;
        int price = 1000;
        assertEquals(990, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceAboveCap() {
        int itemId = 9999;
        int price = 600000000;
        assertEquals(595000000, GeTax.getPostTaxPrice(itemId, price));
    }

    @Test
    public void postTaxPriceCheapItem() {
        int itemId = 13190;
        int price = 67;
        assertEquals(price, GeTax.getPostTaxPrice(itemId, price));
    }
}
package com.flippingcopilot;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FlippingCopilotPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlippingCopilotPlugin.class);
		RuneLite.main(args);
	}
}
package com.flippingcopilot.controller;

import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;
import org.junit.Test;

import java.util.ArrayList;

public class OfferEventFilterTest {

    @Test
    public void testShouldProcessOnLogin() {
        OfferEventFilter filter = new OfferEventFilter();

        ArrayList<GrandExchangeOfferChanged> events = new ArrayList<>();
        ArrayList<Boolean> expectedReturnValues = new ArrayList<>();

        events.add(mockOfferEvent(0, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(1, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(3, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(4, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(6, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(false);

        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(2, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(5, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(true);
        events.add(mockOfferEvent(7, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY));
        expectedReturnValues.add(true);

        events.add(mockOfferEvent(0, 6924, 12, 35, 3749999, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(1, 10034, 0, 125726, 1312, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(3, 4207, 0, 439, 390000, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(4, 6737, 0, 15, 2552692, 0, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);
        events.add(mockOfferEvent(6, 6916, 35, 49, 3320102, 35*3320102, GrandExchangeOfferState.SELLING));
        expectedReturnValues.add(false);

        for (int i = 0; i < events.size(); i++) {
            assert filter.shouldProcess(events.get(i)) == expectedReturnValues.get(i);
        }
    }

    @Test
    public void testShouldProcessNewBuyOffer() {
        OfferEventFilter filter = new OfferEventFilter();
        GrandExchangeOfferChanged event1 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
        assert filter.shouldProcess(event1);
        GrandExchangeOfferChanged event2 = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
        assert !filter.shouldProcess(event2);
    }

    @Test
    public void testLogoutLogin() {
        OfferEventFilter filter = new OfferEventFilter();
        GrandExchangeOfferChanged event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
        assert filter.shouldProcess(event);

        filter.onLogout();

        for (int i = 0; i < 8; i++) {
            event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
            assert !filter.shouldProcess(event);
        }

        for (int i = 0; i < 8; i++) {
            if (i == 2) {
                event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
                assert !filter.shouldProcess(event);
            } else {
                event = mockOfferEvent(i, 0, 0, 0, 0, 0, GrandExchangeOfferState.EMPTY);
                assert filter.shouldProcess(event);
            }
        }

        event = mockOfferEvent(2, 379, 0, 223, 207, 0, GrandExchangeOfferState.BUYING);
        assert !filter.shouldProcess(event);
    }

    static GrandExchangeOfferChanged mockOfferEvent(int slot, int itemId, int quantitySold, int totalQuantity,
                                                    int price, int spent, GrandExchangeOfferState state) {
        GrandExchangeOfferChanged event = new GrandExchangeOfferChanged();
        event.setSlot(slot);
        event.setOffer(new GrandExchangeOffer() {
            @Override
            public int getQuantitySold() {
                return quantitySold;
            }

            @Override
            public int getItemId() {
                return itemId;
            }

            @Override
            public int getTotalQuantity() {
                return totalQuantity;
            }

            @Override
            public int getPrice() {
                return price;
            }

            @Override
            public int getSpent() {
                return spent;
            }

            @Override
            public GrandExchangeOfferState getState() {
                return state;
            }
        });
        return event;
    }


}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import org.junit.Test;

public class TestSuggestionHandler {

    @Test
    public void testShouldNotifyOnWait() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 1, "");
        assert !SuggestionHandler.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnNewBuy() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "");
        assert SuggestionHandler.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnRepeatedBuy() {
        Suggestion oldSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 0, "");;
        Suggestion newSuggestion = new Suggestion("buy", 0, 560, 200, 25000, "Death rune", 1, "");
        assert !SuggestionHandler.shouldNotify(newSuggestion, oldSuggestion);
    }

    @Test
    public void testShouldNotifyOnAbort() {
        Suggestion oldSuggestion = new Suggestion("wait", 0, 0, 0, 0, "", 0, "");
        Suggestion newSuggestion = new Suggestion("abort", 0, 560, 200, 25000, "Death rune", 1, "");
        assert SuggestionHandler.shouldNotify(newSuggestion, oldSuggestion);
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.OfferStatus;
import com.flippingcopilot.model.Transaction;
import org.junit.Test;

import java.time.Instant;

import static org.junit.Assert.assertEquals;

public class FlipTrackerTest {

    @Test
    public void addTransaction_newFlip_addsToActiveFlips() {
        FlipTracker flipTracker = new FlipTracker();
        Transaction transaction = new Transaction(OfferStatus.BUY, 1, 1000, 10, 0, 10000, Instant.now());
        flipTracker.addTransaction(transaction);

        assertEquals(1, flipTracker.getActiveFlips().size());
    }

    @Test
    public void addTransaction_completedFlip_movesToCompletedFlips() {
        FlipTracker flipTracker = new FlipTracker();
        Transaction buyTransaction = new Transaction(OfferStatus.BUY, 1, 1000, 10, 0, 10000, Instant.now());
        Transaction sellTransaction = new Transaction(OfferStatus.SELL, 1, 2000, 10, 0, 20000, Instant.now());
        flipTracker.addTransaction(buyTransaction);
        flipTracker.addTransaction(sellTransaction);

        assertEquals(0, flipTracker.getActiveFlips().size());
        assertEquals(1, flipTracker.getCompletedFlips().size());
    }

    @Test
    public void getProfit_noFlips_returnsZero() {
        FlipTracker flipTracker = new FlipTracker();
        assertEquals(0, flipTracker.getProfit());
    }

    @Test
    public void getProfit_withCompletedFlips_returnsCorrectProfit() {
        FlipTracker flipTracker = new FlipTracker();
        Transaction buyTransaction = new Transaction(OfferStatus.BUY, 1, 1000, 10, 0, 10000, Instant.now());
        Transaction sellTransaction = new Transaction(OfferStatus.SELL, 1, 2000, 10, 0, 20000, Instant.now());
        flipTracker.addTransaction(buyTransaction);
        flipTracker.addTransaction(sellTransaction);

        assertEquals(9800, flipTracker.getProfit());
    }
}

package com.flippingcopilot.model;

import org.junit.Test;

public class FlipTest {

    @Test
    public void testAddBuyTransaction() {
        Flip flip = new Flip(560);
        Transaction transaction = new Transaction(OfferStatus.BUY, 560, 100, 10, 0, 1000, null);
        flip.add(transaction);
        assert flip.getProfit() == 0;
        assert !flip.isCompleted();
    }

    @Test
    public void testAddSellTransaction() {
        Flip flip = new Flip(560);
        Transaction transaction = new Transaction(OfferStatus.SELL, 560, 100, 10, 0, 1000, null);
        flip.add(transaction);
        assert flip.getProfit() == 0;
        assert flip.isCompleted();
    }

    @Test
    public void testSimpleFlip() {
        Flip flip = new Flip(560);
        Transaction transaction1 = new Transaction(OfferStatus.BUY, 560, 100, 10, 0, 1000, null);
        Transaction transaction2 = new Transaction(OfferStatus.SELL, 560, 110, 10, 0, 1100, null);
        flip.add(transaction1);
        flip.add(transaction2);
        assert flip.getProfit() == 90;
        assert flip.isCompleted();
    }

    @Test
    public void partialFlip() {
        Flip flip = new Flip(560);
        Transaction transaction1 = new Transaction(OfferStatus.BUY, 560, 100, 10, 0, 1000, null);
        Transaction transaction2 = new Transaction(OfferStatus.SELL, 560, 110, 5, 0, 550, null);
        flip.add(transaction1);
        flip.add(transaction2);
        assert flip.getProfit() == 45;
        assert !flip.isCompleted();
    }

    @Test
    public void testSoldTooMany() {
        Flip flip = new Flip(560);
        Transaction transaction1 = new Transaction(OfferStatus.BUY, 560, 100, 10, 0, 1000, null);
        Transaction transaction2 = new Transaction(OfferStatus.SELL, 560, 110, 20, 0, 2200, null);
        flip.add(transaction1);
        flip.add(transaction2);
        assert flip.getProfit() == 90;
        assert flip.isCompleted();
    }

}

package com.flippingcopilot.model;

import org.junit.Test;

import java.time.Instant;

public class OfferTest {

    @Test
    public void testTransactionFromNewOffer() {
        Offer oldOffer = Offer.getEmptyOffer(0);
        Offer newOffer = new Offer(OfferStatus.BUY, 560, 100, 50, 1000,
                10, 10, 0, 0, true, false);
        Transaction expectedTransaction = new Transaction(OfferStatus.BUY, 560, 100, 10, 0, 1000, null);
        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
        assert expectedTransaction.equals(actualTransaction);
    }

    @Test
    public void testTransactionFromProgressingSell() {
        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
                10, 0, 1000, 0, true, false);
        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 4000,
                40, 0, 4000, 0, true, false);
        Transaction expectedTransaction = new Transaction(OfferStatus.SELL, 560, 100, 30, 0, 3000, null);
        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
        assert expectedTransaction.equals(actualTransaction);
    }

    @Test
    public void testNoTransaction() {
        Offer oldOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
                10, 0, 1000, 0, true, false);
        Offer newOffer = new Offer(OfferStatus.SELL, 560, 100, 50, 1000,
                10, 0, 1000, 0, true, false);
        Transaction actualTransaction = newOffer.getTransaction(oldOffer);
        assert actualTransaction == null;
    }
}

package com.flippingcopilot.model;

import org.junit.Test;


public class OfferListTest {
    @Test
    public void testIsEmptySlotNeededWithExistingOfferInSlot() {
        OfferList offerList = new OfferList();
        offerList.set(0, new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "");
        assert !offerList.isEmptySlotNeeded(suggestion);
    }

    @Test
    public void testIsEmptySlotNeededWithNoEmptySlots() {
        OfferList offerList = new OfferList();
        offerList.replaceAll(ignored -> new Offer(OfferStatus.BUY, 565, 200, 10, 0, 0, 0, 0, 0, false, false));
        Suggestion suggestion = new Suggestion("buy", 0, 560, 200, 10, "Death rune", 0, "");
        assert offerList.isEmptySlotNeeded(suggestion);
    }

}

package com.flippingcopilot.model;

import org.junit.Test;

public class AccountStatusTest {

    @Test
    public void testMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        assert accountStatus.moreGpNeeded();
    }

    @Test
    public void testNoMoreGpNeeded() {
        AccountStatus accountStatus = new AccountStatus();
        accountStatus.getInventory().add(new RSItem(995, 2000));
        assert !accountStatus.moreGpNeeded();
    }
}

package com.flippingcopilot.ui;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class UIUtilitiesTest {

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsGreaterThanStringLength() {
        String result = UIUtilities.truncateString("Hello", 10);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsLessThanStringLength() {
        String result = UIUtilities.truncateString("Hello, World!", 5);
        assertEquals("Hello...", result);
    }

    @Test
    public void truncateString_returnsOriginalString_whenLengthIsEqualToStringLength() {
        String result = UIUtilities.truncateString("Hello", 5);
        assertEquals("Hello", result);
    }

    @Test
    public void truncateString_returnsEmptyString_whenInputStringIsEmpty() {
        String result = UIUtilities.truncateString("", 5);
        assertEquals("", result);
    }

    @Test
    public void truncateString_returnsTruncatedString_whenLengthIsZero() {
        String result = UIUtilities.truncateString("Hello, World!", 0);
        assertEquals("...", result);
    }
}
package com.flippingcopilot.util;

public class Constants {
    public final static int MIN_GP_NEEDED_TO_FLIP = 1000;
    public final static int PLATINUM_TOKEN_VALUE = 1000;
}

package com.flippingcopilot.util;

import java.util.Arrays;
import java.util.HashSet;

public class GeTax {
    private final static int MAX_PRICE_FOR_GE_TAX = 500000000;
    private final static int GE_TAX_CAP = 5000000;
    private final static double GE_TAX = 0.01;
    private final static HashSet<Integer> GE_TAX_EXEMPT_ITEMS = new HashSet<>(
            Arrays.asList(13190, 1755, 5325, 1785, 2347, 1733, 233, 5341, 8794, 5329, 5343, 1735, 952, 5331));

    public static int getPostTaxPrice(int itemId, int price) {
        if (GE_TAX_EXEMPT_ITEMS.contains(itemId)) {
            return price;
        }
        if (price >= MAX_PRICE_FOR_GE_TAX) {
            return price - GE_TAX_CAP;
        }
        int tax = (int)Math.floor(price * GE_TAX);
        return price - tax;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.ui.UIUtilities;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;
import java.awt.event.KeyEvent;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;


@ConfigGroup("flippingcopilot")
public interface FlippingCopilotConfig extends Config
{
    public enum PriceGraphWebsite
    {
        OSRS_WIKI("OSRS Wiki"),
        GE_TRACKER("GE Tracker"),
        PLATINUM_TOKENS("PlatinumTokens"),
        GE_DATABASE("GE Database"),
        OSRS_CLOUD("Osrs.cloud"),
        OSRS_EXCHANGE("OSRS Exchange");

        private final String name;
        PriceGraphWebsite(String name)
        {
            this.name = name;
        }

        @Override
        public String toString()
        {
            return name;
        }

        public String getUrl(String itemName, int itemId)
        {
            switch (this)
            {
                case OSRS_WIKI:
                    return "https://prices.runescape.wiki/osrs/item/" + itemId;
                case GE_TRACKER:
                    return "https://www.ge-tracker.com/item/" + itemId;
                case PLATINUM_TOKENS:
                    String platinumTokensFormattedName = itemName
                            .toLowerCase()
                            .replace("'", "")
                            .replace("(", " ")
                            .replace(")", "")
                            .replace("+", " plus")
                            .replace("  ", " ")
                            .replace(" ", "-");
                    return "https://platinumtokens.com/item/" + platinumTokensFormattedName;
                case GE_DATABASE:
                    return "https://secure.runescape.com/m=itemdb_oldschool/viewitem?obj=" + itemId;
                case OSRS_EXCHANGE:
                    String osrsExchangeFormattedName = itemName.toLowerCase().replace(' ','-');
                    return "https://www.osrs.exchange/item/"
                            + URLEncoder.encode(osrsExchangeFormattedName, StandardCharsets.UTF_8);
                case OSRS_CLOUD:
                    return "https://prices.osrs.cloud/item/" + itemId;
                default:
                    return "";
            }
        }
    }


    @ConfigItem(
            keyName = "enableChatNotifications",
            name = "Enable chat notifications",
            description = "Show chat notifications for suggested action when the side panel is closed."
    )
    default boolean enableChatNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "enableTrayNotifications",
            name = "Enable tray notifications",
            description = "Show tray notifications for suggested action when runelite is out of focus."
    )
    default boolean enableTrayNotifications()
    {
        return true;
    }
    @ConfigItem(
            keyName = "profitAmountColor",
            name = "Flip tracker profit color",
            description = "The color of the profit amount text in the flip tracker"
    )
    default Color profitAmountColor() {
        return ColorScheme.GRAND_EXCHANGE_PRICE;
    }
    @ConfigItem(
            keyName = "lossAmountColor",
            name = "Flip tracker loss color",
            description = "The color of the loss amount text in the flip tracker"
    )
    default Color lossAmountColor() {
        return UIUtilities.OUTDATED_COLOR;
    }
    @ConfigItem(
            keyName = "webhook",
            name = "Webhook URL",
            description = "The Discord Webhook URL for sending display name and profit."
    )
    String webhook();
    @ConfigItem(
            keyName = "priceGraphWebsite",
            name = "Graph button site",
            description = "The website to open when the graph button is clicked."
    )
    default PriceGraphWebsite priceGraphWebsite()
    {
        return PriceGraphWebsite.OSRS_WIKI;
    }
    @ConfigItem(
            keyName = "suggestionHighlights",
            name = "Highlight suggested actions",
            description = "Show highlight overlays on the GE interface for suggested actions."
    )
    default boolean suggestionHighlights()
    {
        return true;
    }
    @ConfigItem(
            keyName = "quickSetKeybind",
            name = "Price/quantity set keybind",
            description = "Keybind to quickly set the price or quantity of a GE offer to the suggested value"
    )
    default Keybind quickSetKeybind()
    {
        return new Keybind(KeyEvent.VK_E, 0);
    }
}
package com.flippingcopilot.controller;

import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;

public class SlotOfferEventFilter {
    private GrandExchangeOfferChanged slotPreviousEvent;
    private boolean emptyLoginEventReceived = false;

    boolean shouldProcess(GrandExchangeOfferChanged event) {
        boolean shouldProcess = false;
        boolean isEmpty = event.getOffer().getState().equals(GrandExchangeOfferState.EMPTY);
        boolean isEmptyLoginEvent = !emptyLoginEventReceived && isEmpty;

        if (!isEmptyLoginEvent && (slotPreviousEvent == null || !eventsEqual(slotPreviousEvent, event))) {
            shouldProcess = true;
            slotPreviousEvent = event;
        }
        emptyLoginEventReceived = true;
        return shouldProcess;
    }

    private static boolean eventsEqual(GrandExchangeOfferChanged event1, GrandExchangeOfferChanged event2) {
        GrandExchangeOffer offer1 = event1.getOffer();
        GrandExchangeOffer offer2 = event2.getOffer();
        return offer1.getItemId() == offer2.getItemId()
                && offer1.getQuantitySold() == offer2.getQuantitySold()
                && offer1.getTotalQuantity() == offer2.getTotalQuantity()
                && offer1.getPrice() == offer2.getPrice()
                && offer1.getSpent() == offer2.getSpent()
                && offer1.getState() == offer2.getState();
    }

    void onLogout() {
        emptyLoginEventReceived = false;
    }
    void setToLoggedIn() {
        emptyLoginEventReceived = true;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.*;
import com.google.gson.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import java.io.IOException;
import java.util.function.Consumer;

@Slf4j
public class ApiRequestHandler {

    private static final String serverUrl = System.getenv("FLIPPING_COPILOT_HOST") != null ? System.getenv("FLIPPING_COPILOT_HOST")  : "https://api.flippingcopilot.com/";
    private final OkHttpClient client;
    private final Gson gson;
    private String jwtToken = null;
    @Getter
    private LoginResponse loginResponse;

    public ApiRequestHandler(Gson gson, OkHttpClient client) {
        this.gson = gson;
        this.client = client;
    }

    public void onLogout() {
        jwtToken = null;
        loginResponse = null;
    }

    public void setLoginResponse(LoginResponse loginResponse) {
        this.loginResponse = loginResponse;
        this.jwtToken = loginResponse.jwt;
    }

    public void authenticate(String username, String password, Consumer<LoginResponse> callback) {
        Request request = new Request.Builder()
                .url(serverUrl + "/login")
                .addHeader("Authorization", Credentials.basic(username, password))
                .post(RequestBody.create(MediaType.get("application/json; charset=utf-8"), ""))
                .build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callback.accept(null);
            }
            @Override
            public void onResponse(Call call, Response response) {
                // todo: this response can be a non 200 in which case we deserialize a null jwt
                handleLoginResponse(response, callback);
            }
        });
    }

    private void handleLoginResponse(Response response, Consumer<LoginResponse> callback) {
        try {
            JsonObject responseJson = gson.fromJson(response.body().string(), JsonObject.class);
            loginResponse = gson.fromJson(responseJson, LoginResponse.class);
            if (response.isSuccessful()) {
                jwtToken = responseJson.get("jwt").getAsString();
            }
            callback.accept(loginResponse);
        } catch (IOException e) {
            callback.accept(null);
        }
        catch (JsonParseException e) {
            loginResponse = new LoginResponse(true, response.message(), null, -1);
            callback.accept(loginResponse);
        }
    }

    public Suggestion getSuggestion(AccountStatus accountStatus) throws IOException {
        JsonObject status = accountStatus.toJson(gson);
        JsonObject suggestionJson = postJson(status, "/suggestion");
        return Suggestion.fromJson(suggestionJson, gson);
    }

    public ItemPrice getItemPrice(int itemId, String displayName) {
        JsonObject respObj = null;
        try {
            JsonObject body = new JsonObject();
            body.add("item_id", new JsonPrimitive(itemId));
            body.add("display_name", new JsonPrimitive(displayName));
            respObj = postJson(body, "/prices");
            return ItemPrice.fromJson(respObj, gson);
        } catch (HttpResponseException e) {
            log.error("error fetching copilot price for item " + itemId, e);
            return new ItemPrice(0, 0, "Unable to fetch price copilot price (possible server update)");
        } catch (JsonSyntaxException e) {
            log.error("unable to parse prices response object: " + gson.toJson(respObj), e);
            return new ItemPrice(0, 0, "Unable to fetch price copilot price (possible server update)");
        }
    }

    private JsonObject postJson(JsonObject json, String route) throws HttpResponseException {
        if (jwtToken == null) {
            throw new IllegalStateException("Not authenticated");
        }

        RequestBody body = RequestBody.create(MediaType.get("application/json; charset=utf-8"), json.toString());
        Request request = new Request.Builder()
                .url(serverUrl + route)
                .addHeader("Authorization", "Bearer " + jwtToken)
                .post(body)
                .build();
        String responseBody = null;
        try (Response response = client.newCall(request).execute()) {
            responseBody = response.body().string();
            JsonObject responseJson = gson.fromJson(responseBody, JsonObject.class);
            if (!response.isSuccessful()) {
                throw new HttpResponseException(response.code(), responseJson.get("message").getAsString());
            }
            return responseJson;
        } catch (HttpResponseException e) {
            throw e;
        } catch (JsonParseException e) {
            log.error("Error occurred while parsing JSON response: " + e.getMessage());
            log.error("Response body: " + responseBody);
            throw new HttpResponseException(-1, "Unknown server error (possible system update)");
        } catch (IOException e) {
            log.error("Error occurred while posting json: ", e);
            throw new HttpResponseException(-1, "Unknown server error (possible system update)");
        }
    }

}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.HttpResponseException;
import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.ui.SuggestionPanel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatMessageBuilder;

import java.awt.*;
import java.io.IOException;
import java.util.Timer;
import java.util.TimerTask;

@Slf4j
@Getter
@Setter
public class SuggestionHandler {
    private Timer timer;
    private boolean suggestionNeeded;
    private Suggestion currentSuggestion;
    private FlippingCopilotPlugin plugin;
    private SuggestionPanel suggestionPanel;
    private boolean collectNeeded;

    private boolean isPaused = false;

    public SuggestionHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        this.suggestionPanel = plugin.mainPanel.copilotPanel.suggestionPanel;
        suggestionNeeded = false;
        collectNeeded = false;
        resetTimer();
    }

    public void togglePause() {
        if (isPaused) {
            unpause();
        } else {
            pause();
        }
    }

    public void pause() {
        isPaused = true;
        suggestionPanel.setIsPausedMessage();
        currentSuggestion = null;
        plugin.highlightController.removeAll();
        plugin.accountStatus.setSuggestionsPaused(true);
    }

    public void unpause() {
        isPaused = false;
        suggestionNeeded = true;
        if (!plugin.osrsLoginHandler.isLoggedIn()) {
            suggestionPanel.suggestLogin();
        }
        plugin.accountStatus.setSuggestionsPaused(false);
    }

    public void resetTimer() {
        if (timer != null) {
            timer.cancel();
        }
        timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                suggestionNeeded = true;
            }
        }, 10000);
    }

    public void skipCurrentSuggestion() {
        if (currentSuggestion != null) {
            plugin.accountStatus.setSkipSuggestion(currentSuggestion.getId());
        }
        suggestionNeeded = true;
    }

    void onGameTick() {
        if (suggestionNeeded && !(plugin.grandExchange.isSlotOpen() && !plugin.accountStatus.isSuggestionSkipped())) {
            getSuggestionAsync();
        }
    }

    public void getSuggestionAsync() {
        suggestionNeeded = false;
        plugin.executorService.execute(this::getSuggestion);
    }

    private void getSuggestion() {
        if (!plugin.osrsLoginHandler.isLoggedIn() || !plugin.copilotLoginController.isLoggedIn()) {
            return;
        }
        suggestionPanel.showLoading();
        try {
            log.debug("Getting suggestion");
            Suggestion oldSuggestion = currentSuggestion;
            currentSuggestion = plugin.apiRequestHandler.getSuggestion(plugin.accountStatus);

            // We moved isPaused check to here so the client would still send suggestion requests to the server
            // This way the server would still know about the offers to keep the server accurate
            if (isPaused) {
                suggestionPanel.setIsPausedMessage();
                return;
            }

            log.debug("Received suggestion: {}", currentSuggestion.toString());
            plugin.accountStatus.resetSkipSuggestion();
            plugin.gameUiChangesHandler.offerJustPlaced = false;
            displaySuggestion();
            showNotifications(oldSuggestion);
        } catch (HttpResponseException e) {
            handleHttpException(e);
        } catch (IOException e) {
            log.error("Error occurred while getting suggestion: ", e);
            suggestionPanel.setMessage(e.getMessage());
        } finally {
            resetTimer();
            suggestionPanel.hideLoading();
        }
    }

    void displaySuggestion() {
        if (plugin.osrsLoginHandler.isInvalidState()) {
            return;
        }
        suggestionPanel.setServerMessage(currentSuggestion.getMessage());
        collectNeeded = false;
        if (plugin.accountStatus.isCollectNeeded(currentSuggestion)) {
            collectNeeded = true;
            suggestionPanel.suggestCollect();
        } else if (currentSuggestion.getType().equals("wait") && plugin.accountStatus.moreGpNeeded()) {
            suggestionPanel.suggestAddGp();
        } else {
            suggestionPanel.updateSuggestion(currentSuggestion);
        }
        plugin.clientThread.invokeLater(() -> plugin.highlightController.redraw());
    }

    void showNotifications(Suggestion oldSuggestion) {
        if (shouldNotify(currentSuggestion, oldSuggestion)) {
            if (plugin.config.enableTrayNotifications()) {
                plugin.notifier.notify(currentSuggestion.toMessage());
            }
            if (!plugin.mainPanel.copilotPanel.isShowing() && plugin.config.enableChatNotifications()) {
                showChatNotifications();
            }
        }
    }

    static boolean shouldNotify(Suggestion newSuggestion, Suggestion oldSuggestion) {
        if (newSuggestion.getType().equals("wait")) {
            return false;
        }
        if (oldSuggestion != null && newSuggestion.equals(oldSuggestion)) {
            return false;
        }
        return true;
    }

    private void showChatNotifications() {
        if (plugin.accountStatus.isCollectNeeded(currentSuggestion)) {
            plugin.clientThread.invokeLater(() -> showChatNotification("Flipping Copilot: Collect items"));
        }
        plugin.clientThread.invokeLater(() -> showChatNotification(currentSuggestion.toMessage()));
    }

    private void showChatNotification(String message) {
        String chatMessage = new ChatMessageBuilder()
                .append(new Color(0x0040FF), message)
                .build();
        plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", chatMessage, "");
    }

    private void handleHttpException(HttpResponseException e) {
        if (e.getResponseCode() == 401) {
            plugin.copilotLoginController.onLogout();
            plugin.mainPanel.renderLoggedOutView();
            plugin.mainPanel.loginPanel.showLoginErrorMessage("Login timed out. Please log in again");
        } else {
            log.error("Error occurred while getting suggestion: ", e);
            suggestionPanel.setMessage("Error: " + e.getMessage());
        }
    }
}

package com.flippingcopilot.controller;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.WorldType;
import net.runelite.api.events.GameStateChanged;

@Slf4j
public class OsrsLoginHandler {
    private boolean previouslyLoggedIn;
    @Getter
    private String currentDisplayName;
    @Getter
    private String previousDisplayName;
    private final FlippingCopilotPlugin plugin;
    private final WorldType[] unSupportedWorlds = {WorldType.BETA_WORLD,
                                                    WorldType.DEADMAN,
                                                    WorldType.FRESH_START_WORLD,
                                                    WorldType.NOSAVE_MODE,
                                                    WorldType.PVP_ARENA,
                                                    WorldType.SEASONAL,
                                                    WorldType.QUEST_SPEEDRUNNING,
                                                    WorldType.TOURNAMENT_WORLD};

    @Getter
    private boolean invalidState = true;

    OsrsLoginHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        previouslyLoggedIn = false;
        currentDisplayName = null;
    }

    boolean isLoggedIn() {
        return currentDisplayName != null;
    }


    void init() {
        if (plugin.client.getGameState() == GameState.LOGGED_IN) {
            onLoggedInGameState();
            plugin.offerEventFilter.setToLoggedIn();
            plugin.accountStatus.setOffers(plugin.client.getGrandExchangeOffers());
        }
    }

    void handleGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGGED_IN) {
            onLoggedInGameState();
        } else if (event.getGameState() == GameState.LOGIN_SCREEN && previouslyLoggedIn) {
            //this randomly fired at night hours after i had logged off...so i'm adding this guard here.
            if (currentDisplayName != null && plugin.client.getGameState() != GameState.LOGGED_IN) {
                handleLogout();
            }
        }
    }

    private void onLoggedInGameState() {
        //keep scheduling this task until it returns true (when we have access to a display name)
        plugin.clientThread.invokeLater(() ->
        {
            //we return true in this case as something went wrong and somehow the state isn't logged in, so we don't
            //want to keep scheduling this task.
            if (plugin.client.getGameState() != GameState.LOGGED_IN) {
                return true;
            }

            final Player player = plugin.client.getLocalPlayer();

            //player is null, so we can't get the display name so, return false, which will schedule
            //the task on the client thread again.
            if (player == null) {
                return false;
            }

            final String name = player.getName();

            if (name == null) {
                return false;
            }

            if (name.equals("")) {
                return false;
            }
            previouslyLoggedIn = true;

            handleLogin(name);
            return true;
        });
    }

    public void handleLogin(String displayName) {
        for (WorldType worldType : unSupportedWorlds) {
            if (plugin.client.getWorldType().contains(worldType)) {
                log.info("World is a {}", worldType);
                plugin.mainPanel.copilotPanel.suggestionPanel.setMessage(worldType + " worlds<br>are not supported");
                invalidState = true;
                return;
            }
        }

        if (plugin.client.getAccountType().isIronman()) {
            log.info("account is an ironman");
            plugin.mainPanel.copilotPanel.suggestionPanel.setMessage("Ironman accounts<br>are not supported");
            invalidState = true;
            return;
        }

        plugin.accountStatus.setMember(plugin.client.getWorldType().contains(WorldType.MEMBERS));
        plugin.accountStatus.setDisplayName(displayName);
        currentDisplayName = displayName;
        if (previousDisplayName != null && !previousDisplayName.equals(displayName)) {
            plugin.flipTracker = new FlipTracker();
            plugin.mainPanel.copilotPanel.statsPanel.updateFlips(plugin.flipTracker, plugin.client);
        }
        previousDisplayName = displayName;
        invalidState = false;
    }
    public void handleLogout() {
        log.info("{} is logging out", currentDisplayName);
        currentDisplayName = null;
        plugin.offerEventFilter.onLogout();
        plugin.mainPanel.copilotPanel.suggestionPanel.suggestLogin();
    }

}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.AccountStatus;
import com.flippingcopilot.model.LoginResponse;
import com.flippingcopilot.model.Transaction;
import com.flippingcopilot.ui.GePreviousSearch;
import com.flippingcopilot.ui.GpDropOverlay;
import com.flippingcopilot.ui.MainPanel;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import okhttp3.*;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@PluginDescriptor(
		name = "Flipping Copilot",
		description = "Your AI assistant for trading"
)
public class FlippingCopilotPlugin extends Plugin {
	@Inject
	@Getter
	public Client client;
	@Inject
	@Getter
	ClientThread clientThread;
	@Inject
	public KeyManager keyManager;
	@Inject
	public FlippingCopilotConfig config;
	@Inject
	ScheduledExecutorService executorService;
	@Inject
	ClientToolbar clientToolbar;
	@Inject
	Notifier notifier;
	@Inject
	public OverlayManager overlayManager;
	@Inject
	public Gson gson;
	@Inject
	public OkHttpClient okHttpClient;
	public ApiRequestHandler apiRequestHandler;
	NavigationButton navButton;
	public AccountStatus accountStatus;
	public SuggestionHandler suggestionHandler;
	public GrandExchange grandExchange;
	public OsrsLoginHandler osrsLoginHandler;

	GameUiChangesHandler gameUiChangesHandler;
	GrandExchangeCollectHandler grandExchangeCollectHandler;
	OfferEventFilter offerEventFilter;
	FlipTracker flipTracker;
	MainPanel mainPanel;
	public CopilotLoginController copilotLoginController;
	WebHookController webHookController;
	public HighlightController highlightController;
	GePreviousSearch gePreviousSearch;
	KeybindHandler keybindHandler;
	public OfferHandler offerHandler;

	@Override
	protected void startUp() throws Exception {
		Persistance.setUp(gson);
		flipTracker = new FlipTracker();
		apiRequestHandler = new ApiRequestHandler(gson, okHttpClient);
		mainPanel = new MainPanel(config);
		suggestionHandler = new SuggestionHandler(this);
		accountStatus = new AccountStatus();
		grandExchange = new GrandExchange(client);
		grandExchangeCollectHandler = new GrandExchangeCollectHandler(accountStatus, suggestionHandler);
		offerEventFilter = new OfferEventFilter();
		osrsLoginHandler = new OsrsLoginHandler(this);
		gameUiChangesHandler = new GameUiChangesHandler(this);
		copilotLoginController = new CopilotLoginController(() -> mainPanel.renderLoggedInView(), this);
		webHookController = new WebHookController(this);
		highlightController = new HighlightController(this);
		gePreviousSearch = new GePreviousSearch(this);
		keybindHandler = new KeybindHandler(this);
		offerHandler = new OfferHandler(this);
		mainPanel.init(this);
		setUpNavButton();
		setUpLogin();
		osrsLoginHandler.init();
	}

	private void setUpNavButton() {
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon-small.png");
		navButton = NavigationButton.builder()
				.tooltip("Flipping Copilot")
				.icon(icon)
				.priority(3)
				.panel(mainPanel)
				.build();
		clientToolbar.addNavigation(navButton);
	}

	private void setUpLogin() throws IOException {
		LoginResponse loginResponse = Persistance.loadLoginResponse();
		boolean isLoggedIn = loginResponse != null && !loginResponse.error && loginResponse.jwt != null;
		if (isLoggedIn) {
			apiRequestHandler.setLoginResponse(loginResponse);
			mainPanel.renderLoggedInView();
			copilotLoginController.setLoggedIn(true);
		}
	}

	@Override
	protected void shutDown() throws Exception {
		highlightController.removeAll();
		clientToolbar.removeNavigation(navButton);
		Persistance.saveLoginResponse(apiRequestHandler.getLoginResponse());
		webHookController.sendMessage();
		keybindHandler.unregister();
	}

	@Provides
	FlippingCopilotConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(FlippingCopilotConfig.class);
	}

	private void processTransaction(Transaction transaction) {
		long transactionProfit = flipTracker.addTransaction(transaction);
		if (transactionProfit != 0) {
			mainPanel.copilotPanel.statsPanel.updateFlips(flipTracker, client);
			if (grandExchange.isHomeScreenOpen()) {
				new GpDropOverlay(this, transactionProfit, transaction.getBoxId());
			}
		}
	}

	//---------------------------- Event Handlers ----------------------------//

	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event) {
		if (offerEventFilter.shouldProcess(event)) {
			Transaction transaction = accountStatus.updateOffers(event);
			if(transaction != null) {
				processTransaction(transaction);
			}
			suggestionHandler.setSuggestionNeeded(true);
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event) {
		if (event.getContainerId() == InventoryID.INVENTORY.getId()) {
			accountStatus.handleInventoryChanged(event, client);
			suggestionHandler.setSuggestionNeeded(true);
		}
	}
	@Subscribe
	public void onGameTick(GameTick event) {
		suggestionHandler.onGameTick();
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		int slot = grandExchange.getOpenSlot();
		grandExchangeCollectHandler.handleCollect(event, slot);
		gameUiChangesHandler.handleMenuOptionClicked(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		gameUiChangesHandler.onWidgetLoaded(event);
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event) {
		gameUiChangesHandler.onWidgetClosed(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		gameUiChangesHandler.onVarbitChanged(event);
	}

	@Subscribe
	public void onVarClientStrChanged(VarClientStrChanged event) {
		gameUiChangesHandler.onVarClientStrChanged(event);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		osrsLoginHandler.handleGameStateChanged(event);
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event) {
		gameUiChangesHandler.onVarClientIntChanged(event);
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown clientShutdownEvent) {
		webHookController.sendMessage();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals("flippingcopilot")) {
			if (event.getKey().equals("profitAmountColor") || event.getKey().equals("lossAmountColor")) {
				mainPanel.copilotPanel.statsPanel.updateFlips(flipTracker, client);
			}
			if (event.getKey().equals("suggestionHighlights")) {
				clientThread.invokeLater(() -> highlightController.redraw());
			}
		}
	}
}
package com.flippingcopilot.controller;

import com.flippingcopilot.model.Flip;
import com.flippingcopilot.model.Transaction;
import lombok.Getter;

import java.util.ArrayList;
import java.util.HashMap;

@Getter
public class FlipTracker {
    private final HashMap<Integer, Flip> activeFlips = new HashMap<>();
    private final ArrayList<Flip> completedFlips = new ArrayList<>();

    public long addTransaction(Transaction transaction) {
        int itemId = transaction.getItemId();
        if (!activeFlips.containsKey(itemId)) {
            activeFlips.put(itemId, new Flip(itemId));
        }
        Flip flip = activeFlips.get(itemId);
        long profit = flip.add(transaction);
        if (flip.isCompleted()) {
            archive(flip);
        }
        return profit;
    }

    private void archive(Flip flip) {
        if (flip.getQuantityFlipped() > 0) {
            completedFlips.add(flip);
        }
        activeFlips.remove(flip.getItemId());
    }

    public long getProfit() {
        return getFlips().stream()
                .mapToLong(Flip::getProfit)
                .sum();
    }

    public ArrayList<Flip> getFlips() {
        ArrayList<Flip> allFlips = new ArrayList<>(completedFlips);
        allFlips.addAll(activeFlips.values());
        allFlips.sort((f1, f2) -> Long.compare(f2.getLastTransactionTimestamp().toEpochMilli(),
                f1.getLastTransactionTimestamp().toEpochMilli()));
        allFlips.removeIf(flip -> flip.getProfit() == 0);
        return allFlips;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.AccountStatus;
import lombok.AllArgsConstructor;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;


@AllArgsConstructor
public class GrandExchangeCollectHandler {
    AccountStatus accountStatus;
    SuggestionHandler suggestionHandler;

    void handleCollect(MenuOptionClicked event, int slot) {
        String menuOption = event.getMenuOption();
        Widget widget = event.getWidget();

        if (widget != null) {
            handleCollectAll(menuOption, widget);
            handleCollectWithSlotOpen(menuOption, widget, slot);
            handleCollectionBoxCollectAll(menuOption, widget);
            handleCollectionBoxCollectItem(menuOption, widget);
        }
    }

    private void handleCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 30474246) {
            if (menuOption.equals("Collect to inventory")) {
                accountStatus.moveAllCollectablesToInventory();
            } else if (menuOption.equals("Collect to bank")) {
                accountStatus.removeCollectables();
            }
            else {
                return;
            }
            suggestionHandler.displaySuggestion();
        }
    }

    private void handleCollectWithSlotOpen(String menuOption, Widget widget, int slot) {
        if (widget.getId() == 30474264 ) {
            if (menuOption.contains("Collect")) {
                accountStatus.moveCollectedItemToInventory(slot, widget.getItemId());
            } else if (menuOption.contains("Bank")) {
                accountStatus.removeCollectedItem(slot, widget.getItemId());
            } else {
                return;
            }
            suggestionHandler.displaySuggestion();
        }
    }

    private void handleCollectionBoxCollectAll(String menuOption, Widget widget) {
        if (widget.getId() == 26345476 && menuOption.equals("Collect to bank")) {
            accountStatus.removeCollectables();
        } else if (widget.getId() == 26345475 && menuOption.equals("Collect to inventory")) {
            accountStatus.moveAllCollectablesToInventory();
        } else {
            return;
        }
        suggestionHandler.displaySuggestion();
    }

    private void handleCollectionBoxCollectItem(String menuOption, Widget widget) {
        int slot = widget.getId() - 26345477;
        if (slot >= 0 && slot <= 7) {
            if (menuOption.contains("Collect")) {
                accountStatus.moveCollectedItemToInventory(slot, widget.getItemId());
            } else if (menuOption.contains("Bank")) {
                accountStatus.removeCollectedItem(slot, widget.getItemId());
            } else {
                return;
            }
            suggestionHandler.displaySuggestion();
        }
    }

}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;

import java.util.Objects;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class OfferHandler {

    private static final int GE_OFFER_INIT_STATE_CHILD_ID = 20;

    private FlippingCopilotPlugin plugin;

    @Getter
    private int viewedSlotItemId = -1;
    @Getter
    private int viewedSlotItemPrice = -1;
    @Getter
    private String viewedSlotPriceErrorText = null;

    public OfferHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
    }

    public void fetchSlotItemPrice(boolean isViewingSlot) {
        if (isViewingSlot) {
            var currentItemId = plugin.client.getVarpValue(CURRENT_GE_ITEM);
            viewedSlotItemId = currentItemId;
            if (currentItemId == -1) return;

            var suggestion = plugin.suggestionHandler.getCurrentSuggestion();
            if (suggestion != null && suggestion.getItemId() == currentItemId &&
                    ((Objects.equals(suggestion.getType(), "sell") && isSelling()) ||
                            Objects.equals(suggestion.getType(), "buy") && isBuying())) {
                return;
            }

            var fetchedPrice = plugin.apiRequestHandler.getItemPrice(currentItemId, plugin.osrsLoginHandler.getCurrentDisplayName());

            if (fetchedPrice == null) {
                viewedSlotPriceErrorText = "Unknown error";
                return;
            }

            if (fetchedPrice.getMessage() != null && !fetchedPrice.getMessage().isEmpty()) {
                viewedSlotPriceErrorText = fetchedPrice.getMessage();
            } else {
                viewedSlotPriceErrorText = null;
            }
            viewedSlotItemPrice = isSelling() ? fetchedPrice.getSellPrice() : fetchedPrice.getBuyPrice();
            log.info("Fetched price: " + viewedSlotItemPrice);
        } else {
            viewedSlotItemPrice = -1;
            viewedSlotItemId = -1;
            viewedSlotPriceErrorText = null;
        }
    }

    public boolean isSettingQuantity() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();
        return chatInputText.equals("How many do you wish to buy?") || chatInputText.equals("How many do you wish to sell?");
    }

    public boolean isSettingPrice() {
        var chatboxTitleWidget = getChatboxTitleWidget();
        if (chatboxTitleWidget == null) return false;
        String chatInputText = chatboxTitleWidget.getText();

        var offerTextWidget = getOfferTextWidget();
        if (offerTextWidget == null) return false;
        String offerText = offerTextWidget.getText();
        return chatInputText.equals("Set a price for each item:") && (offerText.equals("Buy offer") || offerText.equals("Sell offer"));
    }


    private Widget getChatboxTitleWidget() {
        return plugin.client.getWidget(ComponentID.CHATBOX_TITLE);
    }

    private Widget getOfferTextWidget() {
        var offerContainerWidget = plugin.client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER);
        if (offerContainerWidget == null) return null;
        return offerContainerWidget.getChild(GE_OFFER_INIT_STATE_CHILD_ID);
    }

    public boolean isSelling() {
        return plugin.client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 1;
    }

    public boolean isBuying() {
        return plugin.client.getVarbitValue(Varbits.GE_OFFER_CREATION_TYPE) == 0;
    }

    public String getOfferType() {
        if (isBuying()) {
            return "buy";
        } else if (isSelling()) {
            return "sell";
        } else {
            return null;
        }
    }

    public void setSuggestedAction(Suggestion suggestion) {
        var currentItemId = plugin.client.getVarpValue(CURRENT_GE_ITEM);

        if (isSettingQuantity()) {
            if (suggestion == null || currentItemId != suggestion.getItemId()) {
                return;
            }
            setChatboxValue(suggestion.getQuantity());
        } else if (isSettingPrice()) {
            int price = -1;
            if (suggestion == null || currentItemId != suggestion.getItemId()) {
                if (viewedSlotItemId != currentItemId) {
                    return;
                }
                price = viewedSlotItemPrice;
            } else {
                price = suggestion.getPrice();
            }

            if (price == -1) return;

            setChatboxValue(price);
        }
    }

    public void setChatboxValue(int value) {
        var chatboxInputWidget = plugin.client.getWidget(ComponentID.CHATBOX_FULL_INPUT);
        if (chatboxInputWidget == null) return;
        chatboxInputWidget.setText(value + "*");
        plugin.client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(value));
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.ui.WidgetHighlightOverlay;
import net.runelite.api.ItemComposition;
import net.runelite.api.VarClientStr;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;

import java.awt.*;
import java.util.ArrayList;

import static com.flippingcopilot.ui.UIUtilities.BLUE_HIGHLIGHT_COLOR;
import static com.flippingcopilot.ui.UIUtilities.RED_HIGHLIGHT_COLOR;
import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;
import static net.runelite.api.Varbits.GE_OFFER_CREATION_TYPE;

public class HighlightController {
    FlippingCopilotPlugin plugin;
    private final ArrayList<WidgetHighlightOverlay> highlightOverlays = new ArrayList<>();

    public HighlightController(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
    }

    public void redraw() {
        removeAll();
        if(!plugin.config.suggestionHighlights()) {
            return;
        }
        if (plugin.gameUiChangesHandler.isOfferJustPlaced()) {
            return;
        }
        Suggestion suggestion = plugin.suggestionHandler.getCurrentSuggestion();
        if (suggestion == null) {
            return;
        }
        if (plugin.grandExchange.isHomeScreenOpen()) {
            drawHomeScreenHighLights(suggestion);
        } else if (plugin.grandExchange.isSlotOpen()) {
            drawOfferScreenHighlights(suggestion);
        }
    }

    private void drawHomeScreenHighLights(Suggestion suggestion) {
        if (plugin.suggestionHandler.isCollectNeeded()) {
            Widget collectButton = plugin.grandExchange.getCollectButton();
            if (collectButton != null) {
                add(collectButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(2, 1, 81, 18));
            }
        }
        else if (suggestion.getType().equals("abort")) {
            Widget slotWidget = plugin.grandExchange.getSlotWidget(suggestion.getBoxId());
            add(slotWidget, RED_HIGHLIGHT_COLOR);
        }
        else if (suggestion.getType().equals("buy")) {
            int slotId = plugin.accountStatus.getOffers().findEmptySlot();
            if (slotId != -1) {
                Widget buyButton = plugin.grandExchange.getBuyButton(slotId);
                if (buyButton != null && !buyButton.isHidden()) {
                    add(buyButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(0, 0, 45, 44));
                }
            }
        }
        else if (suggestion.getType().equals("sell")) {
            Widget itemWidget = getInventoryItemWidget(suggestion.getItemId());
            if (itemWidget != null && !itemWidget.isHidden()) {
                add(itemWidget, BLUE_HIGHLIGHT_COLOR, new Rectangle(0, 0, 34, 32));
            }
        }
    }

    private void drawOfferScreenHighlights(Suggestion suggestion) {
        Widget offerTypeWidget = plugin.grandExchange.getOfferTypeWidget();
        String offerType = plugin.client.getVarbitValue(GE_OFFER_CREATION_TYPE) == 1 ? "sell" : "buy";
        if (offerTypeWidget != null && offerType.equals(suggestion.getType())) {
            if (plugin.client.getVarpValue(CURRENT_GE_ITEM) == suggestion.getItemId()) {
                if (offerDetailsCorrect(suggestion)) {
                    Widget confirmButton = plugin.grandExchange.getConfirmButton();
                    if (confirmButton != null) {
                        add(confirmButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(1, 1, 150, 38));
                    }
                } else {
                    highlightPrice(suggestion);
                    highlightQuantity(suggestion);
                }
            }
            else {
                highlightItemInSearch(suggestion);
            }
        }
    }

    private void highlightItemInSearch(Suggestion suggestion) {
        if (!plugin.client.getVarcStrValue(VarClientStr.INPUT_TEXT).isEmpty()) {
            return;
        }
        Widget searchResults = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        if (searchResults == null) {
            return;
        }
        for (Widget widget : searchResults.getDynamicChildren()) {
            if (widget.getName().equals("<col=ff9040>" + suggestion.getName() + "</col>")) {
                add(widget, BLUE_HIGHLIGHT_COLOR);
                return;
            }
        }
        Widget itemWidget = searchResults.getChild(3);
        if (itemWidget != null && itemWidget.getItemId() == suggestion.getItemId()) {
            add(itemWidget, BLUE_HIGHLIGHT_COLOR);
        }
    }

    private boolean offerDetailsCorrect(Suggestion suggestion) {
        return plugin.grandExchange.getOfferPrice() == suggestion.getPrice()
                && plugin.grandExchange.getOfferQuantity() == suggestion.getQuantity();
    }

    private void highlightPrice(Suggestion suggestion) {
        if (plugin.grandExchange.getOfferPrice() != suggestion.getPrice()) {
            Widget setPriceButton = plugin.grandExchange.getSetPriceButton();
            if (setPriceButton != null) {
                add(setPriceButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(1, 6, 33, 23));
            }
        }
    }

    private void highlightQuantity(Suggestion suggestion) {
        if (plugin.grandExchange.getOfferQuantity() != suggestion.getQuantity()) {
            Widget setQuantityButton;
            if (plugin.accountStatus.getInventory().getTotalAmount(suggestion.getItemId()) == suggestion.getQuantity()) {
                setQuantityButton = plugin.grandExchange.getSetQuantityAllButton();
            } else {
                setQuantityButton = plugin.grandExchange.getSetQuantityButton();
            }
            if (setQuantityButton != null) {
                add(setQuantityButton, BLUE_HIGHLIGHT_COLOR, new Rectangle(1, 6, 33, 23));
            }
        }
    }

    private void add(Widget widget, Color color, Rectangle adjustedBounds) {
        WidgetHighlightOverlay overlay = new WidgetHighlightOverlay(widget, color, adjustedBounds);
        highlightOverlays.add(overlay);
        plugin.overlayManager.add(overlay);
    }

    private void add(Widget widget, Color color) {
        add(widget, color, new Rectangle(0, 0, widget.getWidth(), widget.getHeight()));
    }

    public void removeAll() {
        highlightOverlays.forEach(plugin.overlayManager::remove);
        highlightOverlays.clear();
    }

    private Widget getInventoryItemWidget(int unnotedItemId) {
        // Inventory has a different widget if GE is open
        Widget inventory = plugin.getClient().getWidget(467, 0);
        if (inventory == null) {
            inventory = plugin.getClient().getWidget(149, 0);
            if (inventory == null) {
                return null;
            }
        }

        Widget notedWidget = null;
        Widget unnotedWidget = null;

        for (Widget widget : inventory.getDynamicChildren()) {
            int itemId = widget.getItemId();
            ItemComposition itemComposition = plugin.client.getItemDefinition(itemId);

            if (itemComposition.getNote() != -1) {
                if (itemComposition.getLinkedNoteId() == unnotedItemId) {
                    notedWidget = widget;
                }
            } else if (itemId == unnotedItemId) {
                unnotedWidget = widget;
            }
        }
        return notedWidget != null ? notedWidget : unnotedWidget;
    }
}

package com.flippingcopilot.controller;

import net.runelite.api.VarClientInt;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.input.KeyListener;

import java.awt.event.KeyEvent;

public class KeybindHandler {

    FlippingCopilotPlugin plugin;

    public KeybindHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        plugin.keyManager.registerKeyListener(offerEditorKeyListener());

    }

    public void unregister() {
        plugin.keyManager.unregisterKeyListener(offerEditorKeyListener());
    }


    private KeyListener offerEditorKeyListener() {
        return new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {
                // Prevent enter as a keybind as that will also submit the value
                if (e.getKeyCode() == KeyEvent.VK_ENTER) return;
                if (e.getKeyCode() != plugin.config.quickSetKeybind().getKeyCode()) return;

                plugin.getClientThread().invokeLater(this::handleKeybind);
            }

            @Override
            public void keyReleased(KeyEvent e) {

            }

            private void handleKeybind() {
                var suggestion = plugin.suggestionHandler.getCurrentSuggestion();

                var inputType = plugin.client.getVarcIntValue(VarClientInt.INPUT_TYPE);

                var isPriceOrQuantityBoxOpen = plugin.client.getWidget(ComponentID.CHATBOX_TITLE) != null
                        && inputType == 7
                        && plugin.client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) != null
                        && plugin.grandExchange.isSlotOpen();

                if (isPriceOrQuantityBoxOpen) {
                    plugin.offerHandler.setSuggestedAction(suggestion);
                }
            }
        };
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.Suggestion;
import com.flippingcopilot.ui.OfferEditor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class GameUiChangesHandler {
    private static final int GE_HISTORY_TAB_WIDGET_ID = 149;
    private final FlippingCopilotPlugin plugin;
    boolean quantityOrPriceChatboxOpen;
    boolean itemSearchChatboxOpen = false;
    @Getter
    boolean offerJustPlaced = false;
    GameUiChangesHandler(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
    }

    public void onVarClientIntChanged(VarClientIntChanged event) {
        Client client = plugin.getClient();

        if (event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 14
                && client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS) != null) {
            itemSearchChatboxOpen = true;
            plugin.getClientThread().invokeLater(plugin.gePreviousSearch::showSuggestedItemInSearch);
        }

        if (quantityOrPriceChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            quantityOrPriceChatboxOpen = false;
            return;
        }

        if (itemSearchChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            plugin.getClientThread().invokeLater(plugin.highlightController::redraw);
            itemSearchChatboxOpen = false;
            return;
        }

        //Check that it was the chat input that got enabled.
        if (event.getIndex() != VarClientInt.INPUT_TYPE
                || client.getWidget(ComponentID.CHATBOX_TITLE) == null
                || client.getVarcIntValue(VarClientInt.INPUT_TYPE) != 7
                || client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) == null) {
            return;
        }
        quantityOrPriceChatboxOpen = true;

        plugin.getClientThread().invokeLater(() ->
        {
            OfferEditor flippingWidget = new OfferEditor(client.getWidget(ComponentID.CHATBOX_CONTAINER), plugin);
            Suggestion suggestion = plugin.suggestionHandler.getCurrentSuggestion();
            flippingWidget.showSuggestion(suggestion);
        });
    }

    public void onVarClientStrChanged(VarClientStrChanged event) {
        if (event.getIndex() == VarClientStr.INPUT_TEXT && itemSearchChatboxOpen) {
            plugin.getClientThread().invokeLater(plugin.highlightController::redraw);
        }
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == 383
                || event.getGroupId() == InterfaceID.GRAND_EXCHANGE
                || event.getGroupId() == 213
                || event.getGroupId() == GE_HISTORY_TAB_WIDGET_ID) {
            plugin.getClientThread().invokeLater(plugin.highlightController::redraw);
        }
    }

    public void onWidgetClosed(WidgetClosed event) {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE) {
            plugin.getClientThread().invokeLater(plugin.highlightController::removeAll);
        }
    }

    public void onVarbitChanged(VarbitChanged event) {
        if (event.getVarpId() == 375
                || event.getVarpId() == CURRENT_GE_ITEM
                || event.getVarbitId() == 4396
                || event.getVarbitId() == 4398
                || event.getVarbitId() == 4439) {
            plugin.getClientThread().invokeLater(plugin.highlightController::redraw);
        }

        if (event.getVarpId() == CURRENT_GE_ITEM) {
            plugin.getClientThread().invokeLater(() -> plugin.offerHandler.fetchSlotItemPrice(event.getValue() > -1));
        }
    }

    public void handleMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals("Confirm") && plugin.grandExchange.isSlotOpen()) {
            offerJustPlaced = true;
        }
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.DiscordWebhookBody;
import com.flippingcopilot.ui.UIUtilities;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import java.io.IOException;

import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
public class WebHookController {

    private final FlippingCopilotPlugin plugin;

    public WebHookController(FlippingCopilotPlugin plugin)
    {
        this.plugin = plugin;
    }

    private void sendWebHook(DiscordWebhookBody discordWebhookBody)
    {
        String configURL = plugin.config.webhook();
        if (Strings.isNullOrEmpty(configURL)) {return; }

        HttpUrl url = HttpUrl.parse(configURL);
        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(discordWebhookBody));
        buildRequestAndSend(url, requestBodyBuilder);
    }

    private void buildRequestAndSend(HttpUrl url, MultipartBody.Builder requestBodyBuilder)
    {
        RequestBody requestBody = requestBodyBuilder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
        sendRequest(request);
    }

    private void sendRequest(Request request)
    {
        plugin.okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.debug("Error on webhook", e);
            }

            @Override
            public void onResponse(Call call, Response response) {
                response.close();
            }
        });
    }
    void sendMessage()
    {
        long profit = plugin.flipTracker.getProfit();
        String displayName = plugin.osrsLoginHandler.getPreviousDisplayName();
        if (profit != 0 && displayName != null) {
            String profitText = UIUtilities.formatProfit(profit);
            profitText = (displayName + ", your Session Profit is " + profitText);
            DiscordWebhookBody discordWebhookBody = new DiscordWebhookBody();
            discordWebhookBody.setContent(profitText);
            sendWebHook(discordWebhookBody);
        }
    }
}

package com.flippingcopilot.controller;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

public class GrandExchange {
    private final Client client;
    private final static int CURRENTLY_OPEN_GE_SLOT_VARBIT_ID = 4439;
    final static int SHOW_LAST_SEARCHED_VARBIT_ID = 10295;

    GrandExchange(Client client) {
        this.client = client;
    }

    boolean isHomeScreenOpen() {
        return isOpen() && !isSlotOpen();
    }

    boolean isSlotOpen() {
        return getOpenSlot() != -1;
    }

    boolean isOpen() {
        return client.getWidget(465, 7) != null;
    }

    int getOpenSlot() {
        return client.getVarbitValue(CURRENTLY_OPEN_GE_SLOT_VARBIT_ID) - 1;
    }

    Widget getSlotWidget(int slot) {
        return client.getWidget(465, 7 + slot);
    }

    Widget getBuyButton(int slot) {
        Widget slotWidget = getSlotWidget(slot);
        if (slotWidget == null) {
            return null;
        }
        return slotWidget.getChild(0);
    }

    Widget getCollectButton() {
        Widget topBar = client.getWidget(465, 6);
        if (topBar == null) {
            return null;
        }
        return topBar.getChild(1);
    }

    Widget getOfferContainerWidget() {
        return client.getWidget(465, 25);
    }

    Widget getOfferTypeWidget() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(20);
    }

    Widget getConfirmButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(58);
    }

    int getOfferQuantity() {
        return client.getVarbitValue(4396);
    }

    int getOfferPrice() {
        return client.getVarbitValue(4398);
    }

    public boolean isPreviousSearchSet() {
        return client.getVarpValue(2674) != -1;
    }

    public boolean showLastSearchEnabled() {
        return client.getVarbitValue(SHOW_LAST_SEARCHED_VARBIT_ID) == 0;
    }

    public Widget getSetQuantityButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(51);
    }

    public Widget getSetPriceButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(54);
    }

    public Widget getSetQuantityAllButton() {
        Widget offerContainer = getOfferContainerWidget();
        if (offerContainer == null) {
            return null;
        }
        return offerContainer.getChild(50);
    }
}

package com.flippingcopilot.controller;

import java.io.IOException;
import java.util.function.Consumer;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;

import com.flippingcopilot.ui.LoginPanel;
import com.flippingcopilot.model.LoginResponse;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.swing.JOptionPane;

@Slf4j
public class CopilotLoginController {
    @Getter
    LoginPanel panel;
    private String email;
    private String password;
    private final Runnable changeToLoggedInViewRunnable;
    private final ApiRequestHandler apiRequestHandler;
    private final FlippingCopilotPlugin plugin;
    @Setter
    @Getter
    private boolean loggedIn = false;


    public CopilotLoginController(Runnable changeToLoggedInViewRunnable, FlippingCopilotPlugin plugin) {
        this.changeToLoggedInViewRunnable = changeToLoggedInViewRunnable;
        Consumer<String> onEmailTextChangedListener = this::onEmailTextChanged;
        Consumer<String> onPasswordTextChangedListener = this::onPasswordTextChanged;
        ActionListener onLoginPressedListener = this::onLoginPressed;
        this.panel = new LoginPanel(
                onEmailTextChangedListener,
                onPasswordTextChangedListener,
                onLoginPressedListener
        );
        this.plugin = plugin;
        this.apiRequestHandler = plugin.apiRequestHandler;
    }

    public void onLoginPressed(ActionEvent event) {
        Consumer<LoginResponse> loginCallback = loginResponse -> {
            if (loginResponse != null && !loginResponse.error) {
                changeToLoggedInViewRunnable.run();
                loggedIn = true;
                if (plugin.osrsLoginHandler.isLoggedIn()) {
                    plugin.suggestionHandler.setSuggestionNeeded(true);
                }
            } else {
                String message = "Login failed";
                if(loginResponse != null) {
                    message = loginResponse.message;
                }
                panel.showLoginErrorMessage(message);
            }
            try {
                Persistance.saveLoginResponse(loginResponse);
            } catch (IOException e) {
                log.error("Failed to save login response");
            }
            panel.endLoading();
        };

        if (this.email == null || this.password == null) {
            return;
        }
        panel.startLoading();
        apiRequestHandler.authenticate(this.email, this.password, loginCallback);
    }

    public void onLogout() {
        loggedIn = false;
        apiRequestHandler.onLogout();
        Persistance.deleteLoginResponse();
        plugin.suggestionHandler.setCurrentSuggestion(null);
        plugin.highlightController.removeAll();
    }

    public void onEmailTextChanged(String newEmail) {
        this.email = newEmail;
    }

    public void onPasswordTextChanged(String newPassword) {
        this.password = newPassword;
    }
}

package com.flippingcopilot.controller;

import com.flippingcopilot.model.LoginResponse;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Slf4j
public class Persistance {
    public static Gson gson;
    public static final File PARENT_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "flipping-copilot");
    public static final String LOGIN_RESPONSE_JSON_FILE = "login-response.json";
    public static File directory;

    public static void setUp(String directoryPath) throws IOException {
        directory = new File(directoryPath);
        createDirectory(directory);
        createRequiredFiles();
    }

    public static void setUp(Gson gson) throws IOException {
        Persistance.gson = gson;
        directory = PARENT_DIRECTORY;
        createDirectory(PARENT_DIRECTORY);
        createRequiredFiles();
    }

    private static void createRequiredFiles() throws IOException {
        generateFileIfDoesNotExist(LOGIN_RESPONSE_JSON_FILE);
    }

    private static void generateFileIfDoesNotExist(String filename) throws IOException {
        File file = new File(directory, filename);
        if (!file.exists()) {
            if (!file.createNewFile()) {
                log.info("Failed to generate file {}", file.getPath());
            }
        }
    }

    private static void createDirectory(File directory) throws IOException {
        if (!directory.exists()) {
            if (!directory.mkdir()) {
                throw new IOException("unable to create parent directory!");
            }
        }
    }

    public static LoginResponse loadLoginResponse() throws IOException {
        String jsonString = getFileContent(LOGIN_RESPONSE_JSON_FILE);
        return gson.fromJson(jsonString, LoginResponse.class);
    }

    public static void saveLoginResponse(LoginResponse loginResponse) throws IOException {
        if (loginResponse == null) {
            return;
        }

        File file = new File(directory, LOGIN_RESPONSE_JSON_FILE);
        String json = gson.toJson(loginResponse);
        Files.write(file.toPath(), json.getBytes());
    }

    public static void deleteLoginResponse() {
        File file = new File(directory, LOGIN_RESPONSE_JSON_FILE);
        if (file.exists()) {
            file.delete();
        }
    }

    private static String getFileContent(String filename) throws IOException {
        Path filePath = Paths.get(directory.getAbsolutePath(), filename);
        byte[] fileBytes = Files.readAllBytes(filePath);
        return new String(fileBytes);
    }
}

package com.flippingcopilot.controller;
import com.flippingcopilot.model.OfferList;
import net.runelite.api.events.GrandExchangeOfferChanged;


public class OfferEventFilter {
    private final SlotOfferEventFilter[] slotOfferEventFilters;

    public OfferEventFilter() {
        slotOfferEventFilters = new SlotOfferEventFilter[OfferList.NUM_SLOTS];
        for(int i = 0; i < OfferList.NUM_SLOTS; i++) {
            slotOfferEventFilters[i] = new SlotOfferEventFilter();
        }
    }

    boolean shouldProcess(GrandExchangeOfferChanged event) {
        return slotOfferEventFilters[event.getSlot()].shouldProcess(event);
    }

    void onLogout() {
        for(SlotOfferEventFilter slotOfferEventFilter : slotOfferEventFilters) {
            slotOfferEventFilter.onLogout();
        }
    }

    void setToLoggedIn() {
        for(SlotOfferEventFilter slotOfferEventFilter : slotOfferEventFilters) {
            slotOfferEventFilter.setToLoggedIn();
        }
    }
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class LoginResponse {
    public boolean error;
    public String message;
    public String jwt;

    @SerializedName("user_id")
    public int userId;
}

package com.flippingcopilot.model;

import com.google.gson.annotations.SerializedName;
import net.runelite.api.GrandExchangeOfferState;

public enum OfferStatus {
    @SerializedName("sell")
    SELL,
    @SerializedName("buy")
    BUY,
    @SerializedName("empty")
    EMPTY;

    static OfferStatus fromRunelite(GrandExchangeOfferState state) {
        OfferStatus status;
        switch (state) {
            case SELLING:
            case CANCELLED_SELL:
            case SOLD:
                status = SELL;
                break;
            case BUYING:
            case CANCELLED_BUY:
            case BOUGHT:
                status = BUY;
                break;
            default:
                status = EMPTY;
        }
        return status;
    }
}

package com.flippingcopilot.model;

import lombok.Getter;

import java.io.IOException;

@Getter
public class HttpResponseException extends IOException {
    private final int responseCode;
    private final String responseMessage;

    public HttpResponseException(int responseCode, String message) {
        super(message);
        this.responseCode = responseCode;
        this.responseMessage = message;
    }

}
package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

@Getter
@AllArgsConstructor
@ToString
public class ItemPrice {
    @SerializedName("sell_price")
    private final int sellPrice;

    @SerializedName("buy_price")
    private final int buyPrice;
    private final String message;

    public static ItemPrice fromJson(JsonObject json, Gson gson) {
        return gson.fromJson(json, ItemPrice.class);
    }
}

package com.flippingcopilot.model;

import lombok.Data;

@Data
public class DiscordWebhookBody {
    private String content;
    private Embed embed;

    @Data
    static class Embed {
        final UrlEmbed image;
    }

    @Data
    static class UrlEmbed {
        final String url;
    }
}
package com.flippingcopilot.model;

import com.flippingcopilot.util.GeTax;
import lombok.Getter;

import java.lang.Math;
import java.time.Instant;


public class Flip {
    @Getter
    private final int itemId;
    private long gpSent;
    private long gpReceived;
    private int itemsReceived;
    private int itemsSent;
    @Getter
    private boolean completed;
    @Getter
    private Instant lastTransactionTimestamp = Instant.now();


    public Flip(int itemId) {
        this.itemId = itemId;
        this.completed = false;
    }

    public long getProfit() {
        long quantity = getQuantityFlipped();
        if (quantity == 0) {
            return 0;
        }
        // use average cost pooling
        long cost = quantity * gpSent / itemsReceived;
        long revenue = quantity * gpReceived / itemsSent;
        return revenue - cost;
    }

    public int getQuantityFlipped() {
        return Math.min(itemsSent, itemsReceived);
    }

    public long add(Transaction transaction) {
        assert transaction.getItemId() == itemId;
        assert !completed;
        lastTransactionTimestamp = transaction.getTimestamp();
        long profit = 0;
        if(transaction.getType() == OfferStatus.BUY) {
            addBuyTransaction(transaction);
        } else {
            long profitBefore = getProfit();
            addSellTransaction(transaction);
            profit = getProfit() - profitBefore;

        }
        if(itemsSent >= itemsReceived) {
            completed = true;
        }
        return profit;
    }

    private void addBuyTransaction(Transaction transaction) {
        gpSent += transaction.getAmountSpent();
        itemsReceived += transaction.getQuantity();
    }

    private void addSellTransaction(Transaction transaction) {
        int price = transaction.getAmountSpent() / transaction.getQuantity();
        int postTaxPrice = GeTax.getPostTaxPrice(itemId, price);
        gpReceived += (long) postTaxPrice * transaction.getQuantity();
        itemsSent += transaction.getQuantity();
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.events.GrandExchangeOfferChanged;
import static net.runelite.api.ItemID.COINS_995;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;


public class OfferList extends ArrayList<Offer> {
    public static final int NUM_SLOTS = 8;

    public OfferList() {
        super(NUM_SLOTS);
        for (int i = 0; i < NUM_SLOTS; i++) {
            add(Offer.getEmptyOffer(i));
        }
    }

    public Transaction update(GrandExchangeOfferChanged event) {
        Offer oldOffer = get(event.getSlot());
        Offer newOffer = oldOffer.getUpdatedOffer(event);
        set(event.getSlot(), newOffer);
        return newOffer.getTransaction(oldOffer);
    }

    public static OfferList fromRunelite(GrandExchangeOffer[] runeliteOffers) {
        OfferList offers = new OfferList();
        for (int i = 0; i < runeliteOffers.length; i++) {
            offers.set(i, Offer.fromRunelite(runeliteOffers[i], i));
        }
        return offers;
    }

    public boolean missingUncollectedItems() {
        return stream().anyMatch(Offer::missingUncollectedItems);
    }

    public boolean isEmptySlotNeeded(Suggestion suggestion) {
        return (suggestion.getType().equals("buy") || suggestion.getType().equals("sell"))
                && !emptySlotExists();
    }

    boolean emptySlotExists() {
        return stream().anyMatch(offer -> offer.getStatus() == OfferStatus.EMPTY);
    }

    void removeCollectables() {
        forEach(Offer::removeCollectables);
    }

    Map<Integer, Long> getUncollectedItemAmounts() {
        Map<Integer, Long> itemsAmount = getUncollectedTradeablesAmounts();
        long totalGpToCollect = getTotalGpToCollect();
        itemsAmount.merge(COINS_995, totalGpToCollect, Long::sum);
        itemsAmount.entrySet().removeIf(entry -> entry.getValue() == 0);
        return itemsAmount;
    }

    public long getTotalGpToCollect() {
        return stream().mapToLong(Offer::getGpToCollect).sum();
    }

    private Map<Integer, Long> getUncollectedTradeablesAmounts() {
        return stream().collect(Collectors.groupingBy(Offer::getItemId,
                        Collectors.summingLong(Offer::getItemsToCollect)));
    }

    JsonArray toJson(Gson gson) {
        List<JsonObject> list = stream()
                .map(offer -> offer.toJson(gson))
                .collect(Collectors.toList());
        JsonArray jsonArray = new JsonArray();
        list.forEach(jsonArray::add);
        return jsonArray;
    }

    public int findEmptySlot() {
        for (int i = 0; i < NUM_SLOTS; i++) {
            if (get(i).getStatus() == OfferStatus.EMPTY) {
                return i;
            }
        }
        return -1;
    }
}

package com.flippingcopilot.model;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;

@Getter
@AllArgsConstructor
public class RSItem {
    int id;
    long amount;

    static RSItem getUnnoted(Item item, Client client) {
        int itemId = item.getId();
        ItemComposition itemComposition = client.getItemDefinition(itemId);
        if (itemComposition.getNote() != -1) {
            itemId = itemComposition.getLinkedNoteId();
        }
        return new RSItem(itemId, item.getQuantity());
    }
}
package com.flippingcopilot.model;

import net.runelite.api.*;
import net.runelite.api.ItemID;
import static com.flippingcopilot.util.Constants.PLATINUM_TOKEN_VALUE;

import java.util.ArrayList;
import java.util.Map;
import java.util.stream.Collectors;


public class Inventory extends ArrayList<RSItem> {
    boolean hasSufficientGp(Suggestion suggestion) {
        return !suggestion.getType().equals("buy")
                || getTotalGp() >= (long) suggestion.getPrice() * suggestion.getQuantity();
    }

    boolean hasSufficientItems(Suggestion suggestion) {
        return !suggestion.getType().equals("sell")
                || getTotalAmount(suggestion.getItemId()) >= suggestion.getQuantity();
    }

    long getTotalGp() {
        return getTotalAmount(ItemID.COINS_995) + PLATINUM_TOKEN_VALUE * getTotalAmount(ItemID.PLATINUM_TOKEN);
    }

    public long getTotalAmount(long itemId) {
        long amount = 0;
        for (RSItem item : this) {
            if (item.getId() == itemId) {
                amount += item.getAmount();
            }
        }
        return amount;
    }


    static Inventory fromRunelite(ItemContainer inventory, Client client) {
        Inventory unnotedItems = new Inventory();
        Item[] items = inventory.getItems();
        for (Item item : items) {
            if (item.getId() == -1) {
                continue;
            }
            unnotedItems.add(RSItem.getUnnoted(item, client));
        }
        return unnotedItems;
    }

    Map<Integer, Long> getItemAmounts() {
        return stream().collect(Collectors.groupingBy(RSItem::getId,
                        Collectors.summingLong(RSItem::getAmount)));
    }

    static Inventory fromItemAmounts(Map<Integer, Long> itemAmounts) {
        Inventory inventory = new Inventory();
        for (Map.Entry<Integer, Long> entry : itemAmounts.entrySet()) {
            inventory.add(new RSItem(entry.getKey(), entry.getValue()));
        }
        return inventory;
    }

}

package com.flippingcopilot.model;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.time.Instant;


@Getter
@AllArgsConstructor
public class Transaction {
    private OfferStatus type;
    private int itemId;
    private int price;
    private int quantity;
    private int boxId;
    private int amountSpent;
    private Instant timestamp;

    public boolean equals(Transaction other) {
        return this.type == other.type &&
                this.itemId == other.itemId &&
                this.price == other.price &&
                this.quantity == other.quantity &&
                this.boxId == other.boxId &&
                this.amountSpent == other.amountSpent;
    }
}

package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

import java.text.NumberFormat;

@Getter
@AllArgsConstructor
@ToString
public class Suggestion {
    private final String type;

    @SerializedName("box_id")
    private final int boxId;

    @SerializedName("item_id")
    private final int itemId;

    private final int price;

    private final int quantity;

    private final String name;

    @SerializedName("command_id")
    private final int id;

    private final String message;

    public static Suggestion fromJson(JsonObject json, Gson gson) {
        return gson.fromJson(json, Suggestion.class);
    }

    public boolean equals(Suggestion other) {
        return this.type.equals(other.type)
                && this.boxId == other.boxId
                && this.itemId == other.itemId
                && this.name.equals(other.name);
    }

    public String toMessage() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String string = "Flipping Copilot: ";
        switch (type) {
            case "buy":
                string += String.format("Buy %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "sell":
                string += String.format("Sell %s %s for %s gp",
                        formatter.format(quantity), name, formatter.format(price));
                break;
            case "abort":
                string += "Abort " + name;
                break;
            case "wait":
                string += "Wait";
                break;
            default:
                string += "Unknown suggestion type";
                break;
        }
        return string;
    }
}



package com.flippingcopilot.model;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;

import java.time.Instant;

import static net.runelite.api.ItemID.COINS_995;

@Getter
@AllArgsConstructor
@EqualsAndHashCode
public class Offer {
    private OfferStatus status;

    @SerializedName("item_id")
    private int itemId;

    private int price;

    @SerializedName("amount_total")
    private int amountTotal;

    @SerializedName("amount_spent")
    private int amountSpent;

    @SerializedName("amount_traded")
    private int amountTraded;

    @SerializedName("items_to_collect")
    private int itemsToCollect;

    @SerializedName("gp_to_collect")
    private int gpToCollect;

    @SerializedName("box_id")
    private int boxId;

    private boolean active;

    @SerializedName("copilot_price_used")
    private boolean copilotPriceUsed;

    public static Offer getEmptyOffer(int slotId) {
        return new Offer(OfferStatus.EMPTY, 0, 0, 0, 0, 0, 0, 0, slotId, false, false);
    }

    void removeCollectables() {
        itemsToCollect = 0;
        gpToCollect = 0;
    }

    RSItem removeCollectedItem(int itemId) {
        int amountCollected;
        if (itemId == COINS_995) {
            amountCollected = gpToCollect;
            gpToCollect = 0;
        } else {
            amountCollected = itemsToCollect;
            itemsToCollect = 0;
        }
        return new RSItem(itemId, amountCollected);
    }

    Offer getUpdatedOffer(GrandExchangeOfferChanged event) {
        Offer newOffer = Offer.fromRuneliteEvent(event);
        if (isSameOffer(newOffer)) {
            newOffer.addUncollectedItems(this);
            if (active) {
                newOffer.addUncollectedItemsOnAbort(event);
            }
        }
        return newOffer;
    }

    private void addUncollectedItems(Offer oldOffer) {
        itemsToCollect = oldOffer.itemsToCollect;
        gpToCollect = oldOffer.gpToCollect;
        if (status == OfferStatus.BUY) {
            itemsToCollect += amountTraded - oldOffer.amountTraded;
        } else if (status == OfferStatus.SELL) {
            gpToCollect += amountSpent - oldOffer.amountSpent;
        }
    }

    public void addUncollectedItemsOnAbort(GrandExchangeOfferChanged event) {
        GrandExchangeOffer runeliteOffer = event.getOffer();
        if (runeliteOffer.getState().equals(GrandExchangeOfferState.CANCELLED_BUY)) {
            gpToCollect += (amountTotal - amountTraded) * price;
        } else if (runeliteOffer.getState().equals(GrandExchangeOfferState.CANCELLED_SELL)) {
            itemsToCollect += amountTotal - amountTraded;
        }
    }
    public static Offer fromRuneliteEvent(GrandExchangeOfferChanged event) {
        GrandExchangeOffer runeliteOffer = event.getOffer();
        return fromRunelite(runeliteOffer, event.getSlot());
    }

    public static Offer fromRunelite(GrandExchangeOffer runeliteOffer, int slotId) {
        OfferStatus status = OfferStatus.fromRunelite(runeliteOffer.getState());
        boolean active = runeliteOffer.getState().equals(GrandExchangeOfferState.BUYING)
                || runeliteOffer.getState().equals(GrandExchangeOfferState.SELLING);
        return new Offer(status,
                runeliteOffer.getItemId(),
                runeliteOffer.getPrice(),
                runeliteOffer.getTotalQuantity(),
                runeliteOffer.getSpent(),
                runeliteOffer.getQuantitySold(),
                0,
                0,
                slotId,
                active,
                false);
    }

    public Transaction getTransaction(Offer oldOffer) {
        boolean isNewOffer = status != oldOffer.status
                || itemId != oldOffer.itemId
                || price != oldOffer.price
                || amountTotal != oldOffer.amountTotal
                || boxId != oldOffer.boxId;
        int quantityDiff = isNewOffer ? amountTraded : amountTraded - oldOffer.amountTraded;
        int amountSpentDiff = isNewOffer ? amountSpent : amountSpent - oldOffer.amountSpent;
        if (quantityDiff > 0 && amountSpentDiff > 0) {
            return new Transaction(status, itemId, price, quantityDiff, boxId, amountSpentDiff, Instant.now());
        }
        return null;
    }

    public boolean missingUncollectedItems() {
        return !active && status != OfferStatus.EMPTY && (gpToCollect == 0 && itemsToCollect == 0);
    }

    JsonObject toJson(Gson gson) {
        JsonParser jsonParser = new JsonParser();
        return jsonParser.parse(gson.toJson(this)).getAsJsonObject();
    }

    private boolean isSameOffer(Offer newOffer) {
        return status == newOffer.status
                && itemId == newOffer.itemId
                && price == newOffer.price
                && amountTotal == newOffer.amountTotal
                && amountSpent <= newOffer.amountSpent
                && amountTraded <= newOffer.amountTraded
                && boxId == newOffer.boxId;
    }
}

package com.flippingcopilot.model;

import com.flippingcopilot.util.Constants;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.InventoryID;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.api.events.ItemContainerChanged;

import java.util.List;
import java.util.Map;

@Getter
public class AccountStatus {
    private OfferList offers;
    private Inventory inventory;
    @Setter private boolean sellOnlyMode = false;
    @Setter private boolean isMember = false;
    @Setter private int skipSuggestion = -1;
    @Setter private String displayName;
    @Setter private Boolean suggestionsPaused;
    public AccountStatus() {
        offers = new OfferList();
        inventory = new Inventory();
    }

    public void resetSkipSuggestion() {
        skipSuggestion = -1;
    }

    public boolean isSuggestionSkipped() {
        return skipSuggestion != -1;
    }

    public Transaction updateOffers(GrandExchangeOfferChanged event) {
        return offers.update(event);
    }

    public void setOffers(GrandExchangeOffer[] runeliteOffers) {
        offers = OfferList.fromRunelite(runeliteOffers);
    }

    public void handleInventoryChanged(ItemContainerChanged event, Client client) {
        if (event.getContainerId() == InventoryID.INVENTORY.getId()) {
            inventory = Inventory.fromRunelite(event.getItemContainer(), client);
        }
    }

    public boolean isCollectNeeded(Suggestion suggestion) {
        return offers.isEmptySlotNeeded(suggestion)
                || !inventory.hasSufficientGp(suggestion)
                || !inventory.hasSufficientItems(suggestion)
                || offers.missingUncollectedItems();
    }

    public void moveAllCollectablesToInventory() {
        Map<Integer, Long> uncollectedItemAmounts = offers.getUncollectedItemAmounts();
        List<RSItem> uncollectedItems = Inventory.fromItemAmounts(uncollectedItemAmounts);
        inventory.addAll(uncollectedItems);
        removeCollectables();
    }

    public void removeCollectables() {
        offers.removeCollectables();
    }

    public JsonObject toJson(Gson gson) {
        JsonObject statusJson = new JsonObject();
        statusJson.addProperty("display_name", displayName);
        statusJson.addProperty("sell_only", sellOnlyMode);
        statusJson.addProperty("is_member", isMember);
        statusJson.addProperty("skip_suggestion", skipSuggestion);
        if (suggestionsPaused != null) {
            statusJson.addProperty("suggestions_paused", suggestionsPaused);
        }
        JsonArray offersJsonArray = offers.toJson(gson);
        JsonArray itemsJsonArray = getItemsJson();
        statusJson.add("offers", offersJsonArray);
        statusJson.add("items", itemsJsonArray);
        return statusJson;
    }

    JsonArray getItemsJson() {
        Map<Integer, Long> itemsAmount = getItemAmounts();
        JsonArray itemsJsonArray = new JsonArray();
        for(Map.Entry<Integer, Long> entry : itemsAmount.entrySet()) {
            JsonObject itemJson = new JsonObject();
            itemJson.addProperty("item_id", entry.getKey());
            itemJson.addProperty("amount", entry.getValue());
            itemsJsonArray.add(itemJson);
        }
        return itemsJsonArray;
    }

    Map<Integer, Long> getItemAmounts() {
        Map<Integer, Long> itemsAmount = inventory.getItemAmounts();
        Map<Integer, Long> uncollectedItemAmounts = offers.getUncollectedItemAmounts();
        uncollectedItemAmounts.forEach((key, value) -> itemsAmount.merge(key, value, Long::sum));
        itemsAmount.entrySet().removeIf(entry -> entry.getValue() == 0);
        return itemsAmount;
    }

    public void moveCollectedItemToInventory(int slot, int itemId) {
        RSItem collectedItem = offers.get(slot).removeCollectedItem(itemId);
        inventory.add(collectedItem);
    }

    public void removeCollectedItem(int slot, int itemId) {
        offers.get(slot).removeCollectedItem(itemId);
    }

    public boolean moreGpNeeded() {
        return offers.emptySlotExists() && getTotalGp() < Constants.MIN_GP_NEEDED_TO_FLIP;
    }

    private long getTotalGp() {
        return inventory.getTotalGp() + offers.getTotalGpToCollect();
    }
}

package com.flippingcopilot.ui;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import java.awt.*;
import java.util.Objects;

@Getter
public class Spinner extends JPanel {
    private final JLabel spinnerLabel = new JLabel();

    public Spinner() {
        setLayout(new GridBagLayout());
        setOpaque(false);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = GridBagConstraints.REMAINDER;
        gbc.gridy = GridBagConstraints.REMAINDER;
        gbc.weightx = 1;
        gbc.weighty = 1;
        gbc.anchor = GridBagConstraints.CENTER;

        spinnerLabel.setPreferredSize(new Dimension(30, 30));
        add(spinnerLabel, gbc);
        setUpIcon();
        hide();
    }

    public void show() {
        spinnerLabel.setVisible(true);
    }

    public void hide() {
        spinnerLabel.setVisible(false);
    }

    private void setUpIcon() {
        IconTextField.Icon icon = IconTextField.Icon.LOADING;
        final ImageIcon imageIcon = new ImageIcon(Objects.requireNonNull(IconTextField.class.getResource(icon.getFile())));
        spinnerLabel.setIcon(imageIcon);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

public class FlipPanel extends JPanel {

    public FlipPanel(String itemName, long profit, FlippingCopilotConfig config) {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        JLabel itemNameLabel = new JLabel(UIUtilities.truncateString(itemName, 22));
        JLabel profitLabel = new JLabel(UIUtilities.formatProfit(profit));
        profitLabel.setForeground(UIUtilities.getProfitColor(profit, config));

        add(itemNameLabel, BorderLayout.LINE_START);
        add(profitLabel, BorderLayout.LINE_END);
    }
}
package com.flippingcopilot.ui;

import net.runelite.client.input.KeyListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.net.URI;
import java.util.function.Consumer;

public class LoginPanel extends JPanel {
    private final static int PAGE_WIDTH = 225;

    JPanel loginContainer;

    private JButton loginButton;
    private JTextField emailTextField;
    private JTextField passwordTextField;
    private JLabel errorMessageLabel;

    public Spinner spinner;

    Consumer<String> onEmailTextChangedListener;
    Consumer<String> onPasswordTextChangedListener;
    ActionListener onLoginPressedListener;

    public LoginPanel(
        Consumer<String> onEmailTextChangedListener,
        Consumer<String> onPasswordTextChangedListener,
        ActionListener onLoginPressedListener
    ) {
        this.setLayout(new BorderLayout());
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.setSize(PAGE_WIDTH, 250);

        this.onEmailTextChangedListener = onEmailTextChangedListener;
        this.onPasswordTextChangedListener = onPasswordTextChangedListener;
        this.onLoginPressedListener = onLoginPressedListener;

        loginContainer = new JPanel();
        loginContainer.setLayout(new BoxLayout(loginContainer, BoxLayout.PAGE_AXIS));

        this.createLogo();
        this.createSpinner();
        this.createErrorMessageLabel();
        this.createEmailInput();
        this.createPasswordInput();
        this.createLoginButton();
        this.createCreateAccountLink();

        this.add(loginContainer, BorderLayout.NORTH);
    }

    public void createLogo() {
        JPanel container = new JPanel();
        ImageIcon icon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/logo.png"));
        Image resizedLogo = icon.getImage().getScaledInstance(50, 45, Image.SCALE_SMOOTH);
        JLabel logoLabel = new JLabel(new ImageIcon(resizedLogo));
        logoLabel.setSize(50, 45);
        container.add(logoLabel, BorderLayout.CENTER);
        container.setBorder(new EmptyBorder(10, 0, 10, 0));
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createSpinner() {
        JPanel container = new JPanel();
        spinner = new Spinner();
        container.add(spinner, BorderLayout.CENTER);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void startLoading() {
        spinner.show();
        loginButton.setEnabled(false);
        errorMessageLabel.setText("");
        errorMessageLabel.setVisible(false);
    }

    public void endLoading() {
        spinner.hide();
        loginButton.setEnabled(true);
    }

    public void createErrorMessageLabel() {
        JPanel container = new JPanel();
        errorMessageLabel = new JLabel();
        errorMessageLabel.setForeground(Color.RED);
        errorMessageLabel.setHorizontalAlignment(SwingConstants.LEFT);
        errorMessageLabel.setSize(PAGE_WIDTH, 40);
        errorMessageLabel.setVisible(false);
        container.add(errorMessageLabel); // Add the error message label under the logo
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createEmailInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        emailTextField = new JTextField();
        emailTextField.setSize(PAGE_WIDTH, 40);
        emailTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                onEmailTextChangedListener.accept(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        emailTextField.addActionListener(e -> onLoginPressedListener.actionPerformed(e));
        JLabel emailLabel = new JLabel("Email address");
        container.add(emailLabel, BorderLayout.WEST);
        container.add(emailTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createPasswordInput() {
        JPanel container = new JPanel(new GridLayout(2, 1));
        container.setBorder(new EmptyBorder(0, 0, 10, 0));
        passwordTextField = new JPasswordField();
        passwordTextField.setSize(PAGE_WIDTH, 40);
        passwordTextField.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent event) {
            }

            @Override
            public void keyReleased(KeyEvent event) {
                JTextField textField = (JTextField) event.getSource();
                String text = textField.getText();
                onPasswordTextChangedListener.accept(text);
            }

            @Override
            public void keyPressed(KeyEvent event) {
            }
        });
        passwordTextField.addActionListener(e -> onLoginPressedListener.actionPerformed(e));
        JLabel passwordLabel = new JLabel("Password");
        container.add(passwordLabel);
        container.add(passwordTextField);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createCreateAccountLink() {
        JPanel container = new JPanel();
        JLabel createAccountLabel = new JLabel("Don't have an account? Sign up.");
        createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        createAccountLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                LinkBrowser.browse("https://flippingcopilot.com/signup");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.BRAND_ORANGE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                createAccountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            }
        });
        container.add(createAccountLabel);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void createLoginButton() {
        JPanel container = new JPanel();
        loginButton = new JButton("Login");
        loginButton.addActionListener(this.onLoginPressedListener);
        container.add(loginButton);
        loginContainer.add(container, BorderLayout.CENTER);
    }

    public void showLoginErrorMessage(String message) {
        errorMessageLabel.setText("<html><p>" + message + "</p></html>");
        errorMessageLabel.setVisible(true);
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import java.awt.*;

public class GpDropOverlay extends Overlay {
    private final OverlayManager overlayManager;
    private final long profit;
    private final long startTime;
    private final Point startPosition = new Point(); // Starting position of the text
    final TextComponent textComponent = new TextComponent();

    public GpDropOverlay(FlippingCopilotPlugin plugin, long profit, int slot) {
        this.profit = profit;
        this.overlayManager = plugin.overlayManager;
        this.startTime = System.currentTimeMillis();

        Widget slotWidget =  plugin.client.getWidget(465, slot + 7);
        if (slotWidget == null) {
            return;
        }
        startPosition.x = slotWidget.getCanvasLocation().getX() + 35;
        startPosition.y = slotWidget.getCanvasLocation().getY() + 75;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        String absProfitText = UIUtilities.quantityToRSDecimalStack(Math.abs(profit), false);
        String profitText = (profit >= 0 ? "+ " : "- ") + absProfitText + " gp";
        textComponent.setText(profitText);
        textComponent.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 16f));
        if (profit < 0) {
            textComponent.setColor(Color.RED);
        } else {
            textComponent.setColor(Color.GREEN);
        }

        plugin.overlayManager.add(this);
    }


    @Override
    public Dimension render(Graphics2D graphics) {
        long elapsed = System.currentTimeMillis() - startTime;
        if (elapsed > 3000) { // Display for 5 seconds
            overlayManager.remove(this);
            return null;
        }

        // Calculate the upward movement. Adjust the divisor to control the speed.
        int yOffset = (int) (elapsed / 50); // Moves up 1 pixel every 50ms

        // Ensure the text moves upwards by subtracting yOffset from the starting Y position
        Point currentPosition = new Point(startPosition.x, startPosition.y - yOffset);
        textComponent.setPosition(currentPosition);
        textComponent.render(graphics);

        return null;
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import static com.flippingcopilot.ui.UIUtilities.BUTTON_HOVER_LUMINANCE;

class PauseButton extends JButton
{
    private final FlippingCopilotPlugin plugin;

    private static final ImageIcon PLAY_ICON;
    private static final ImageIcon PAUSE_ICON;
    private static final ImageIcon PLAY_ICON_HOVER;
    private static final ImageIcon PAUSE_ICON_HOVER;

    static {
        var play = ImageUtil.loadImageResource(PauseButton.class, "/play.png");
        var pause = ImageUtil.loadImageResource(PauseButton.class, "/pause.png");
        PLAY_ICON = new ImageIcon(play);
        PAUSE_ICON = new ImageIcon(pause);
        PLAY_ICON_HOVER =  new ImageIcon(ImageUtil.luminanceScale(play, BUTTON_HOVER_LUMINANCE));
        PAUSE_ICON_HOVER = new ImageIcon(ImageUtil.luminanceScale(pause, BUTTON_HOVER_LUMINANCE));
    }

    public PauseButton(FlippingCopilotPlugin plugin) {
        super(PAUSE_ICON);
        this.plugin = plugin;
        setToolTipText("Pause suggestions");
        addActionListener(e -> {
            plugin.suggestionHandler.togglePause();
            update();
        });

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(plugin.suggestionHandler.isPaused() ? PLAY_ICON_HOVER : PAUSE_ICON_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(plugin.suggestionHandler.isPaused() ? PLAY_ICON : PAUSE_ICON);
            }
        });

        setFocusPainted(false);
        setBorderPainted(false);
        setContentAreaFilled(false);
    }

    private void update()
    {
        setIcon(plugin.suggestionHandler.isPaused() ? PLAY_ICON : PAUSE_ICON);
        setToolTipText(plugin.suggestionHandler.isPaused() ? "Unpause suggestions" :  "Pause suggestions");
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

@Slf4j
public class ControlPanel extends JPanel {
    SellOnlyModeToggleButton sellOnlyModeToggleButton = new SellOnlyModeToggleButton();
    public ControlPanel() {
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setLayout(new BorderLayout(3, 0));
        setBorder(BorderFactory.createEmptyBorder(5, 50, 5, 50));

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new BorderLayout());
        buttonPanel.setOpaque(false);
        add(buttonPanel, BorderLayout.CENTER);

        JLabel buttonText = new JLabel("Sell-only Mode");
        buttonPanel.add(buttonText, BorderLayout.LINE_START);
        buttonPanel.add(sellOnlyModeToggleButton, BorderLayout.LINE_END);
    }

    public void init(FlippingCopilotPlugin plugin) {
        sellOnlyModeToggleButton.addItemListener(i ->
        {
            plugin.accountStatus.setSellOnlyMode(sellOnlyModeToggleButton.isSelected());
            plugin.suggestionHandler.setSuggestionNeeded(true);
            log.debug("Sell only mode is now: {}", plugin.accountStatus.isSellOnlyMode());
        });
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.FlippingCopilotPlugin;
import com.flippingcopilot.model.Suggestion;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;

import static com.flippingcopilot.ui.UIUtilities.*;
import static com.flippingcopilot.util.Constants.MIN_GP_NEEDED_TO_FLIP;

public class SuggestionPanel extends JPanel {
    private FlippingCopilotPlugin plugin;
    private final JLabel suggestionText = new JLabel();
    public final Spinner spinner = new Spinner();
    private JLabel skipButton;
    private final JPanel buttonContainer = new JPanel();
    private JLabel graphButton;
    private FlippingCopilotConfig config;

    @Setter
    private String serverMessage = "";

    public SuggestionPanel(FlippingCopilotConfig config) {
        this.config = config;
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
        setPreferredSize(new Dimension(0, 150));

        JLabel title = new JLabel("<html><center> <FONT COLOR=white><b>Suggested Action:" +
                "</b></FONT></center></html>");
        title.setHorizontalAlignment(SwingConstants.CENTER);
        add(title, BorderLayout.NORTH);

        JPanel suggestionContainer = new JPanel();
        suggestionContainer.setLayout(new CardLayout());
        suggestionContainer.setOpaque(true);
        suggestionContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.setPreferredSize(new Dimension(0, 85));
        add(suggestionContainer, BorderLayout.CENTER);

        suggestionText.setHorizontalAlignment(SwingConstants.CENTER);
        suggestionText.setOpaque(true);
        suggestionText.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        suggestionContainer.add(suggestionText);
        suggestionContainer.add(spinner);
        setupButtonContainer();
        suggestLogin();
    }

    public void init(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        setupPauseButton();
    }

    private void setupButtonContainer() {
        buttonContainer.setLayout(new BorderLayout());
        buttonContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        //buttonContainer.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));
        add(buttonContainer, BorderLayout.SOUTH);
        setupGraphButton();
        setupSkipButton();
    }

    private void setupGraphButton() {
        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/graph.png");
        graphButton = buildButton(graphIcon, "Price graph", () -> {
            Suggestion suggestion = plugin.suggestionHandler.getCurrentSuggestion();
            String url = config.priceGraphWebsite().getUrl(suggestion.getName(), suggestion.getItemId());
            LinkBrowser.browse(url);
        });
        buttonContainer.add(graphButton, BorderLayout.WEST);
    }


    private void setupSkipButton() {
        BufferedImage graphIcon = ImageUtil.loadImageResource(getClass(), "/skip.png");
        skipButton = buildButton(graphIcon, "Skip suggestion", () -> {
            showLoading();
            plugin.suggestionHandler.skipCurrentSuggestion();
        });
        buttonContainer.add(skipButton, BorderLayout.EAST);
    }

    private void setupPauseButton() {
        PauseButton pauseButton = new PauseButton(plugin);
        Box box = Box.createHorizontalBox();
        box.add(Box.createHorizontalGlue());
        box.add(pauseButton);
        box.add(Box.createHorizontalGlue());
        buttonContainer.add(box, BorderLayout.CENTER);
    }


    public void updateSuggestion(Suggestion suggestion) {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        String suggestionString = "<html><center>";

        switch (suggestion.getType()) {
            case "wait":
                suggestionString += "Wait <br>";
                break;
            case "abort":
                suggestionString += "Abort offer for<br><FONT COLOR=white>" + suggestion.getName() + "<br></FONT>";
                break;
            case "buy":
            case "sell":
                String capitalisedAction = suggestion.getType().equals("buy") ? "Buy" : "Sell";
                suggestionString += capitalisedAction +
                        " <FONT COLOR=yellow>" + formatter.format(suggestion.getQuantity()) + "</FONT><br>" +
                        "<FONT COLOR=white>" + suggestion.getName() + "</FONT><br>" +
                        "for <FONT COLOR=yellow>" + formatter.format(suggestion.getPrice()) + "</FONT> gp<br>";
                break;
            default:
                suggestionString += "Error processing suggestion<br>";
        }
        suggestionString += suggestion.getMessage();
        suggestionString += "</center><html>";
        suggestionText.setText(suggestionString);
        suggestionText.setVisible(true);
        if(!suggestion.getType().equals("wait")) {
            setButtonsVisible(true);
        }
    }

    public void suggestCollect() {
        setMessage("Collect items");
        setButtonsVisible(false);
    }

    public void suggestAddGp() {
        NumberFormat formatter = NumberFormat.getNumberInstance();
        setMessage("Add at least <FONT COLOR=yellow>" + formatter.format(MIN_GP_NEEDED_TO_FLIP)
                               + "</FONT> gp<br>to your inventory<br>"
                               + "to get a flip suggestion");
    }

    public void suggestLogin() {
        setMessage("Log in to the game<br>to get a flip suggestion");
        setButtonsVisible(false);
    }

    public void setIsPausedMessage() {
        setMessage("Suggestions are paused");
        setButtonsVisible(false);
    }

    public void showConnectionError() {
        setMessage("Failed to connect to server");
        setButtonsVisible(false);
    }

    public void setMessage(String message) {
        suggestionText.setText("<html><center>" + message +  "<br>" + serverMessage + "</center><html>");
        setButtonsVisible(false);
    }

    public void showLoading() {
        suggestionText.setVisible(false);
        setServerMessage("");
        spinner.show();
        setButtonsVisible(false);
    }

    public void hideLoading() {
        spinner.hide();
        suggestionText.setVisible(true);
    }

    private void setButtonsVisible(boolean visible) {
        skipButton.setVisible(visible);
        graphButton.setVisible(visible);
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import com.flippingcopilot.model.Suggestion;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

public class GePreviousSearch {
    FlippingCopilotPlugin plugin;

    public GePreviousSearch(FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
    }

    public void showSuggestedItemInSearch() {
        Suggestion suggestion = plugin.suggestionHandler.getCurrentSuggestion();

        if (suggestion != null && suggestion.getType().equals("buy")) {
            if (plugin.grandExchange.isPreviousSearchSet() && plugin.grandExchange.showLastSearchEnabled()) {
                setPreviousSearch(suggestion.getItemId(), suggestion.getName());
            } else {
                createPreviousSearchWidget(suggestion.getItemId(), suggestion.getName());
                createPreviousSearchItemNameWidget(suggestion.getName());
                createPreviousSearchItemWidget(suggestion.getItemId());
                createPreviousSearchTextWidget();
            }
            plugin.highlightController.redraw();
        }
    }

    private void setPreviousSearch(int itemId, String itemName) {
        Client client = plugin.getClient();
        Widget searchResults = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget previousSearch = searchResults.getChild(0);
        previousSearch.setOnOpListener(754, itemId, 84);
        previousSearch.setOnKeyListener(754, itemId, -2147483640);
        previousSearch.setName("<col=ff9040>" + itemName + "</col>");
        Widget previousSearchText = searchResults.getChild(1);
        previousSearchText.setText("Copilot item:");
        Widget itemNameWidget = searchResults.getChild(2);
        itemNameWidget.setText(itemName);
        Widget item = searchResults.getChild(3);
        item.setItemId(itemId);
    }

    private void createPreviousSearchWidget(int itemId, String itemName) {
        Widget parentWidget = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.RECTANGLE);
        widget.setTextColor(0xFFFFFF);
        widget.setOpacity(255);
        widget.setName("<col=ff9040>" + itemName + "</col>");
        widget.setHasListener(true);
        widget.setFilled(true);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(256);
        widget.setOriginalHeight(32);
        widget.setOnOpListener(754, itemId, 84);
        widget.setOnKeyListener(754, itemId, -2147483640);
        widget.setHasListener(true);
        widget.setAction(0, "Select");
        // set opacity to 200 when mouse is hovering
        widget.setOnMouseOverListener((JavaScriptCallback) ev -> {
            widget.setOpacity(200);
        });
        // set opacity back to 255 when mouse is not hovering
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
            widget.setOpacity(255);
        });

        widget.revalidate();
    }

    private void createPreviousSearchItemNameWidget(String itemName) {
        Widget parentWidget = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText(itemName);
        widget.setFontId(495);
        widget.setOriginalX(254);
        widget.setOriginalY(0);
        widget.setOriginalWidth(116);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }

    private void createPreviousSearchItemWidget(int itemId) {
        Widget parentWidget = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.GRAPHIC);
        widget.setItemId(itemId);
        widget.setItemQuantity(1);
        widget.setItemQuantityMode(0);
        widget.setRotationX(550);
        widget.setModelZoom(1031);
        widget.setBorderType(1);
        widget.setOriginalX(214);
        widget.setOriginalY(0);
        widget.setOriginalWidth(36);
        widget.setOriginalHeight(32);
        widget.revalidate();
    }

    private void createPreviousSearchTextWidget() {
        Widget parentWidget = plugin.client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        Widget widget = parentWidget.createChild(WidgetType.TEXT);
        widget.setText("Copilot item:");
        widget.setFontId(495);
        widget.setOriginalX(114);
        widget.setOriginalY(0);
        widget.setOriginalWidth(95);
        widget.setOriginalHeight(32);
        widget.setYTextAlignment(1);
        widget.revalidate();
    }
}

package com.flippingcopilot.ui;


import java.awt.Dimension;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JToggleButton;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

class SellOnlyModeToggleButton extends JToggleButton
{
    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;

    static
    {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(CopilotPanel.class, "/switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    public SellOnlyModeToggleButton()
    {
        super(OFF_SWITCHER);
        setSelectedIcon(ON_SWITCHER);
        SwingUtil.removeButtonDecorations(this);
        setPreferredSize(new Dimension(25, 25));
        addItemListener(l -> updateTooltip());
        updateTooltip();
    }

    private void updateTooltip()
    {
        setToolTipText(isSelected() ? "Disable sell-only mode" :  "Enable sell-only mode");
    }
}

/* Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * Copyright (c) 2024, Cillian Brewitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingcopilot.ui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;

import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class WidgetHighlightOverlay extends Overlay
{
    private final Widget widget;
    private final Color color;
    private final Rectangle relativeBounds;

    @Inject
    public WidgetHighlightOverlay(final Widget widget, Color color, Rectangle relativeBounds)
    {
        this.widget = widget;
        this.color = color;
        this.relativeBounds = relativeBounds;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(PRIORITY_HIGH);
        setMovable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (widget == null)
        {
            return null;
        }

        Rectangle highlightBounds = widget.getBounds();

        if (highlightBounds == null)
        {
            return null;
        }

        highlightBounds.x += relativeBounds.x;
        highlightBounds.y += relativeBounds.y;
        highlightBounds.width = relativeBounds.width;
        highlightBounds.height = relativeBounds.height;

        drawHighlight(graphics, highlightBounds);
        return null;
    }

    private void drawHighlight(Graphics2D graphics, Rectangle bounds)
    {
        graphics.setColor(color);
        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlipTracker;
import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.model.Flip;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;
import java.util.Collection;

import static com.flippingcopilot.ui.UIUtilities.getProfitColor;


public class StatsPanel extends JPanel {
    private final JLabel profitText = new JLabel();
    private final JPanel flipLogPanel = new JPanel();
    private final FlippingCopilotConfig config;

    public StatsPanel(FlippingCopilotConfig config) {
        this.config = config;
        setLayout(new BorderLayout(3, 0));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setupTotalProfit();
        setupFlipLog();
    }

    void setupTotalProfit() {
        JLabel profitTitle = new JLabel("<html><b>Session Profit:<b></html>");
        profitTitle.setHorizontalAlignment(SwingConstants.CENTER);
        profitTitle.setForeground(Color.WHITE);

        profitText.setHorizontalAlignment(SwingConstants.CENTER);
        profitText.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        profitText.setFont(FontManager.getRunescapeBoldFont());

        add(profitTitle, BorderLayout.NORTH);
        add(profitText, BorderLayout.CENTER);
        updateProfitText(0);
    }

    public void updateFlips(FlipTracker flipTracker, Client client) {
        updateProfitText(flipTracker.getProfit());
        refreshFlipLog(flipTracker.getFlips(), client);
    }

    private void updateProfitText(long profit) {
        profitText.setText(((profit >= 0) ? "" : "-")
                + UIUtilities.quantityToRSDecimalStack(Math.abs(profit), true) + " gp");
        profitText.setToolTipText("Total Profit: " + QuantityFormatter.formatNumber(profit) + " gp");
        profitText.setForeground(getProfitColor(profit, config));
    }

    private void setupFlipLog() {
        flipLogPanel.setLayout(new BoxLayout(flipLogPanel, BoxLayout.Y_AXIS));
        flipLogPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        add(flipLogPanel, BorderLayout.SOUTH);

    }

    private void refreshFlipLog(Collection<Flip> flips, Client client) {
        flipLogPanel.removeAll();
        for (Flip flip : flips) {
            String itemName = client.getItemDefinition(flip.getItemId()).getName();
            FlipPanel flipPanel = new FlipPanel(itemName, flip.getProfit(), config);
            flipLogPanel.add(flipPanel);
        }
        flipLogPanel.revalidate();
        flipLogPanel.repaint();
    }


}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.FlippingCopilotPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;

import static com.flippingcopilot.ui.UIUtilities.buildButton;

public class MainPanel extends PluginPanel {
    public LoginPanel loginPanel;
    public CopilotPanel copilotPanel;
    public Runnable onCopilotLogout;

    public MainPanel(FlippingCopilotConfig config) {
        setLayout(new BorderLayout());
        copilotPanel = new CopilotPanel(config);
    }

    public void init(FlippingCopilotPlugin plugin) {
        copilotPanel.init(plugin);
        this.loginPanel = plugin.copilotLoginController.getPanel();
        this.onCopilotLogout = plugin.copilotLoginController::onLogout;
        renderLoggedOutView();
    }

    public void renderLoggedOutView() {
        removeAll();
        add(constructTopBar(false), BorderLayout.NORTH);
        loginPanel.showLoginErrorMessage("");
        add(loginPanel);
        revalidate();
    }

    public void renderLoggedInView() {
        removeAll();
        add(constructTopBar(true), BorderLayout.NORTH);
        add(copilotPanel);
        revalidate();
    }

    private JPanel constructTopBar(boolean isLoggedIn) {
        JPanel container = new JPanel();
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);
        container.setLayout(new BorderLayout());
        container.setBorder(new EmptyBorder(0, 0, 5, 0));
        JPanel topBar = new JPanel();
        topBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int columns = isLoggedIn ? 4 : 3;
        topBar.setLayout(new GridLayout(1, columns));

        JLabel github = buildTopBarUriButton(UIUtilities.githubIcon,
                "Flipping Copilot Github",
                "https://github.com/cbrewitt/flipping-copilot");
        topBar.add(github);

        JLabel discord = buildTopBarUriButton(UIUtilities.discordIcon,
                "Flipping Copilot Discord",
                "https://discord.gg/UyQxA4QJAq");
        topBar.add(discord);

        JLabel website = buildTopBarUriButton(UIUtilities.internetIcon,
                "Flipping Copilot website",
                "https://flippingcopilot.com");
        topBar.add(website);

        if (isLoggedIn) {
            BufferedImage icon = ImageUtil.loadImageResource(getClass(), UIUtilities.logoutIcon);
            JLabel logout = buildButton(icon, "Log out", () -> {
                onCopilotLogout.run();
                renderLoggedOutView();
            });
            topBar.add(logout);
        }

        container.add(topBar);
        container.setBorder(new EmptyBorder(3, 0, 10, 0));
        return container;
    }

    private JLabel buildTopBarUriButton(String iconPath, String tooltip, String uriString) {
        BufferedImage icon = ImageUtil.loadImageResource(getClass(), iconPath);
        return buildButton(icon, tooltip, () -> {
            LinkBrowser.browse(uriString);
        });
    }

}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotPlugin;
import com.flippingcopilot.model.Suggestion;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.FontID;
import net.runelite.api.widgets.*;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

@Slf4j
public class OfferEditor {
    private FlippingCopilotPlugin plugin;
    private Widget text;
    private static final int MOUSE_OFF_TEXT_COLOR = 0x0040FF;
    private static final int MOUSE_OFF_ERROR_TEXT_COLOR = 0xAA2222;

    public OfferEditor(Widget parent, FlippingCopilotPlugin plugin) {
        this.plugin = plugin;
        if (parent == null) {
            return;
        }

        text = parent.createChild(-1, WidgetType.TEXT);
        prepareTextWidget(text, WidgetTextAlignment.LEFT, WidgetPositionMode.ABSOLUTE_TOP, 40, 10);
    }

    private void prepareTextWidget(Widget widget, int xAlignment, int yMode, int yOffset, int xOffset) {
        widget.setTextColor(MOUSE_OFF_TEXT_COLOR);
        widget.setFontId(FontID.VERDANA_11_BOLD);
        widget.setYPositionMode(yMode);
        widget.setOriginalX(xOffset);
        widget.setOriginalY(yOffset);
        widget.setOriginalHeight(20);
        widget.setXTextAlignment(xAlignment);
        widget.setWidthMode(WidgetSizeMode.MINUS);
        widget.revalidate();
    }

    public void showSuggestion(Suggestion suggestion) {
        var currentItemId = plugin.client.getVarpValue(CURRENT_GE_ITEM);
        if (plugin.offerHandler.isSettingQuantity()) {
            if (currentItemId != suggestion.getItemId()) {
                return;
            }
            if (!suggestion.getType().equals(plugin.offerHandler.getOfferType())) {
                return;
            }

            shiftChatboxWidgetsDown();
            showQuantity(suggestion.getQuantity());
        } else if (plugin.offerHandler.isSettingPrice()) {
            if (currentItemId != suggestion.getItemId()
                    || !suggestion.getType().equals(plugin.offerHandler.getOfferType())) {
                int price = plugin.offerHandler.getViewedSlotItemPrice();
                if (plugin.offerHandler.getViewedSlotPriceErrorText() != null && price <= 0) {
                    shiftChatboxWidgetsDown();
                    setErrorText(plugin.offerHandler.getViewedSlotPriceErrorText());
                    return;
                }

                if (plugin.offerHandler.getViewedSlotItemId() == currentItemId) {
                    shiftChatboxWidgetsDown();
                    if (plugin.offerHandler.getViewedSlotPriceErrorText() != null) {
                        showPriceWithWarning(price, plugin.offerHandler.getViewedSlotPriceErrorText());
                    } else {
                        showPrice(price);
                    }
                }
            } else {
                shiftChatboxWidgetsDown();
                showPrice(suggestion.getPrice());
            }
        }
    }

    private void showQuantity(int quantity) {
        text.setText("set to Copilot quantity: " + quantity);
        text.setAction(1, "Set quantity");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            plugin.offerHandler.setChatboxValue(quantity);
        });
    }

    private void showPrice(int price) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp");
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            plugin.offerHandler.setChatboxValue(price);
        });
    }

    private void showPriceWithWarning(int price, String warning) {
        text.setText("set to Copilot price: " + String.format("%,d", price) + " gp. " + warning);
        text.setAction(0, "Set price");
        setHoverListeners(text);
        text.setOnOpListener((JavaScriptCallback) ev ->
        {
            plugin.offerHandler.setChatboxValue(price);
        });
    }

    private void setHoverListeners(Widget widget) {
        widget.setHasListener(true);
        widget.setOnMouseRepeatListener((JavaScriptCallback) ev -> widget.setTextColor(0xFFFFFF));
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> widget.setTextColor(MOUSE_OFF_TEXT_COLOR));
    }

    private void setErrorText(String message) {
        text.setText(message);
        text.setTextColor(MOUSE_OFF_ERROR_TEXT_COLOR);
        text.revalidate();
    }

    private void shiftChatboxWidgetsDown() {
        Widget chatboxTitle = plugin.client.getWidget(ComponentID.CHATBOX_TITLE);
        if (chatboxTitle != null) {
            chatboxTitle.setOriginalY(chatboxTitle.getOriginalY() + 7);
            chatboxTitle.revalidate();
        }
    }
}
package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;

public class UIUtilities {
    public static final String discordIcon = "/discord.png";
    public static final String githubIcon = "/github.png";
    public static final String logoutIcon = "/logout.png";
    public static final String internetIcon = "/internet.png";
    public static final String graphIcon = "/graph.png";

    static final float BUTTON_HOVER_LUMINANCE = 0.65f;
    public static final Color OUTDATED_COLOR = new Color(250, 74, 75);
    public static final Color BLUE_HIGHLIGHT_COLOR =  new Color(27, 173, 255, 79);
    public static final Color RED_HIGHLIGHT_COLOR = new Color(255, 20, 20, 79);

    private static final NumberFormat PRECISE_DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.###",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );
    private static final NumberFormat DECIMAL_FORMATTER = new DecimalFormat(
            "#,###.#",
            DecimalFormatSymbols.getInstance(Locale.ENGLISH)
    );

    public static synchronized String quantityToRSDecimalStack(long quantity, boolean precise)
    {
        if (Long.toString(quantity).length() <= 4)
        {
            return QuantityFormatter.formatNumber(quantity);
        }

        long power = (long) Math.log10(quantity);

        // Output thousandths for values above a million
        NumberFormat format = precise && power >= 6
                ? PRECISE_DECIMAL_FORMATTER
                : DECIMAL_FORMATTER;

        return format.format(quantity / Math.pow(10, (Long.divideUnsigned(power, 3)) * 3))
                + new String[] {"", "K", "M", "B", "T"}[(int) (power / 3)];
    }

    public static Color getProfitColor(long profit, FlippingCopilotConfig config) {
        if (profit > 0) {
            return config.profitAmountColor();
        } else if (profit < 0) {
            return config.lossAmountColor();
        } else {
            return Color.WHITE;
        }
    }

    public static String formatProfit(long profit) {
        return (profit >= 0 ? "" : "-") + quantityToRSDecimalStack(Math.abs(profit), true) + " gp";
    }

    public static String truncateString(String string, int length) {
        if (string.length() > length) {
            return string.substring(0, length) + "...";
        }
        return string;
    }

    static JLabel buildButton(BufferedImage icon, String tooltip, Runnable onClick) {
        JLabel label = new JLabel();
        label.setToolTipText(tooltip);
        label.setHorizontalAlignment(JLabel.CENTER);
        ImageIcon iconOff = new ImageIcon(icon);
        ImageIcon iconOn = new ImageIcon(ImageUtil.luminanceScale(icon, BUTTON_HOVER_LUMINANCE));
        label.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                try {
                    onClick.run();
                } catch (Exception error) {}
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                label.setIcon(iconOn);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                label.setIcon(iconOff);
            }
        });
        label.setIcon(iconOff);
        return label;
    }

    static JLabel buildUriButton(BufferedImage icon, String tooltip, String uriString) {
        return buildButton(icon, tooltip, () -> {
            try {
                Desktop desktop = Desktop.getDesktop();
                URI uri = new URI(uriString);
                desktop.browse(uri);
            } catch (Exception error) {}
        });
    }
}

package com.flippingcopilot.ui;

import com.flippingcopilot.controller.FlippingCopilotConfig;
import com.flippingcopilot.controller.FlippingCopilotPlugin;
import javax.swing.*;
import java.awt.*;


public class CopilotPanel extends JPanel {
    public final SuggestionPanel suggestionPanel;
    private final ControlPanel controlPanel;
    public final StatsPanel statsPanel;


public CopilotPanel(FlippingCopilotConfig config) {
    setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
    suggestionPanel = new SuggestionPanel(config);
    controlPanel = new ControlPanel();
    statsPanel = new StatsPanel(config);
    add(suggestionPanel);
    add(Box.createRigidArea(new Dimension(0, 5)));
    add(controlPanel);
    add(Box.createRigidArea(new Dimension(0, 5)));
    add(statsPanel);
}
    public void init(FlippingCopilotPlugin plugin) {
        controlPanel.init(plugin);
        suggestionPanel.init(plugin);
    }
}

