package com.runeprofile.utils;

import java.text.ParseException;
import java.text.SimpleDateFormat;

public class DateHeader {

	private static SimpleDateFormat headerFormat;
	private static SimpleDateFormat stringFormat;

	public static String getDateString(String dateString) {
		if (headerFormat == null) {
			headerFormat = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz");
		}

		if (stringFormat == null) {
			stringFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
		}

		try {
			return stringFormat.format(headerFormat.parse(dateString));
		} catch (ParseException e) {
			return "Failed to parse";
		}
	}
}

package com.runeprofile.utils;

import net.runelite.api.Client;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class AccountHash {
    public static String getHashed(Client client) {
        long accountHashLong = client.getAccountHash();

        if (accountHashLong == -1) {
            return null;
        }

        String accountHashString = String.valueOf(accountHashLong);

        MessageDigest digest;

        try {
            digest = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }

        byte[] hash = digest.digest(accountHashString.getBytes(StandardCharsets.UTF_8));

        return Base64.getEncoder().encodeToString(hash);
    }
}

package com.runeprofile;

import com.runeprofile.panels.InvalidPanel;
import com.runeprofile.panels.MainPanel;
import com.runeprofile.panels.misc.HeaderPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import java.awt.*;

@Slf4j
public class RuneProfilePanel extends PluginPanel {
	private final RuneProfilePlugin runeProfilePlugin;

	@Getter
	private MainPanel mainPanel;
	private InvalidPanel invalidPanel;

	public RuneProfilePanel(RuneProfilePlugin runeProfilePlugin) {
		super(false);
		setLayout(new BorderLayout());

		this.runeProfilePlugin = runeProfilePlugin;

		add(new HeaderPanel(), BorderLayout.NORTH);
		loadInvalidState();
	}

	public void loadValidState() {
		SwingUtilities.invokeLater(() -> {
			if (invalidPanel != null) {
				remove(invalidPanel);
			}

			mainPanel = new MainPanel(runeProfilePlugin);

			add(mainPanel, BorderLayout.CENTER);
			revalidate();
			repaint();
		});
	}

	public void loadInvalidState() {
		SwingUtilities.invokeLater(() -> {
			if (mainPanel != null) {
				remove(mainPanel);
			}

			if (invalidPanel == null) {
				invalidPanel = new InvalidPanel();
			}

			invalidPanel.setHintText("Login to use this plugin.");
			add(invalidPanel, BorderLayout.CENTER);
			revalidate();
			repaint();
		});
	}

	public void loadInvalidRequestState() {
		SwingUtilities.invokeLater(() -> {
			if (mainPanel != null) {
				remove(mainPanel);
			}

			if (invalidPanel == null) {
				invalidPanel = new InvalidPanel();
			}

			invalidPanel.setHintText("Invalid world/mode.");
			add(invalidPanel, BorderLayout.CENTER);
			revalidate();
			repaint();
		});
	}
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class AchievementDiaryTierData {
    private final int areaId;
    private final int tierIndex;
    private final int completedCount;
}

package com.runeprofile.data;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;

@Getter
@RequiredArgsConstructor
public enum CombatAchievementTier {
    EASY(1, VarbitID.CA_TOTAL_TASKS_COMPLETED_EASY),
    MEDIUM(2, VarbitID.CA_TOTAL_TASKS_COMPLETED_MEDIUM),
    HARD(3, VarbitID.CA_TOTAL_TASKS_COMPLETED_HARD),
    ELITE(4, VarbitID.CA_TOTAL_TASKS_COMPLETED_ELITE),
    MASTER(5, VarbitID.CA_TOTAL_TASKS_COMPLETED_MASTER),
    GRANDMASTER(6, VarbitID.CA_TOTAL_TASKS_COMPLETED_GRANDMASTER);

    private final int id;
    private final int varbit;

    public int getCompletedCount(Client client) {
        // https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cca_tasks_completed_tier%5D.cs2
        client.runScript(4784, id);
        return client.getIntStack()[0];
    }
}

package com.runeprofile.data;

import lombok.Data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Data
public class PlayerData {
    String id;
    String username;
    Integer accountType;

    // skill name -> xp
    Map<String, Integer> skills = new HashMap<>();

    // quest id -> quest state
    Map<Integer, Integer> quests = new HashMap<>();

    // tier id -> completed count
    Map<Integer, Integer> combatAchievementTiers = new HashMap<>();

    List<AchievementDiaryTierData> achievementDiaryTiers = new ArrayList<>();

    // item id -> quantity
    Map<Integer, Integer> items = new HashMap<>();
}

package com.runeprofile.data;


import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Getter
public class PlayerModelData {
	private final String accountHash;
	private final byte[] model;
}

package com.runeprofile.data;

import lombok.Data;

import java.util.List;

@Data
public class CollectionLogPage {
    private final String name;
    private final List<CollectionLogItem> items;
}

package com.runeprofile.data;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum AchievementDiary {
    KARAMJA(0),
    ARDOUGNE(1),
    FALADOR(2),
    FREMENNIK(3),
    KANDARIN(4),
    DESERT(5),
    LUMBRIDGE(6),
    MORYTANIA(7),
    VARROCK(8),
    WILDERNESS(9),
    WESTERN_PROVINCES(10),
    KOUREND(11);

    private final int id;

    public int[] getTiersCompletedCount(Client client) {
        // https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cdiary_completion_info%5D.cs2
        client.runScript(2200, id);
        int[] stack = client.getIntStack();

        int easy = stack[0];
        int medium = stack[3];
        int hard = stack[6];
        int elite = stack[9];

        return new int[]{easy, medium, hard, elite};
    }
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class CollectionLogItem {
    private final int id;
    private final int quantity;
}
package com.runeprofile.panels.home;

import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class HomePanel extends JPanel {

    private final Border buttonBorder;

    public HomePanel(RuneProfilePlugin plugin) {
        buttonBorder = new EmptyBorder(8, 16, 8, 16);

        setLayout(new BorderLayout());
        JPanel wrapper = new JPanel(new GridLayout(0, 1, 0, 6));

        // Update Model
        JLabel updatedModelLabel = createUpdateLabel(RuneProfileConfig.MODEL_UPDATE_DATE);
        JButton updateModelButton = createUpdateButton(
                "Update Model",
                updatedModelLabel,
                plugin::updateModelAsync
        );

        wrapper.add(updatedModelLabel);
        wrapper.add(updateModelButton);


        // Open Profile
        JButton openProfileButton = new JButton("Open Profile");
        openProfileButton.setBorder(buttonBorder);
        openProfileButton.addActionListener(e -> {
            String username = RuneProfilePlugin.getClient().getLocalPlayer().getName();
            LinkBrowser.browse("https://runeprofile.com/" + username);
        });

        wrapper.add(openProfileButton);

        if (plugin.isDeveloperMode()) {
            // DEV ONLY - generate hiscores icons
            JButton generateHiscoreIcons = new JButton("DEV: Hiscores Icons");
            generateHiscoreIcons.setBorder(buttonBorder);
            generateHiscoreIcons.addActionListener(e -> {
                plugin.DEV_generateHiscoreIconsJson();
            });
            wrapper.add(generateHiscoreIcons);
        }

        add(wrapper, BorderLayout.NORTH);
    }

    private JLabel createUpdateLabel(String configKey) {
        String lastUpdatedDate = RuneProfilePlugin.getConfigManager().getRSProfileConfiguration(RuneProfileConfig.CONFIG_GROUP, configKey);
        JLabel label = new JLabel((lastUpdatedDate != null) ? "Last update: " + lastUpdatedDate : "Last update: Never");
        label.setFont(FontManager.getRunescapeSmallFont());
        return label;
    }

    private JButton createUpdateButton(String buttonText, JLabel statusLabel, SupplierWithException<CompletableFuture<String>, Exception> updateAction) {
        JButton button = new JButton(buttonText);
        button.setBorder(buttonBorder);
        button.addActionListener((event) -> {
            button.setEnabled(false);
            statusLabel.setText("Last update: Updating...");
            new SwingWorker<String, Void>() {
                @Override
                protected String doInBackground() throws Exception {
                    try {
                        return updateAction.get().get();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return "Update interrupted";
                    } catch (IOException e) {
                        log.debug(Arrays.toString(e.getStackTrace()));
                        log.error("Failed to update: {}", e.toString());
                        return "Failed to update";
                    }
                }

                @Override
                protected void done() {
                    try {
                        String lastUpdated = get();
                        statusLabel.setText("Last update: " + lastUpdated);
                    } catch (Exception e) {
                        log.debug(Arrays.toString(e.getStackTrace()));
                        log.error("Failed to update: {}", e.toString());
                        statusLabel.setText("Last update: Failed");
                    } finally {
                        button.setEnabled(true);
                    }
                }
            }.execute();
        });
        return button;
    }
}

@FunctionalInterface
interface SupplierWithException<T, E extends Exception> {
    T get() throws E;
}
package com.runeprofile.panels.misc;

import com.runeprofile.Icon;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class HeaderPanel extends JPanel {
    private static final int iconSize = 16;
    private final JPanel buttonsContainer;

    public HeaderPanel() {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));

        JLabel title = new JLabel("RuneProfile");
        title.setForeground(Color.WHITE);
        title.setFont(FontManager.getRunescapeBoldFont());

        buttonsContainer = new JPanel();
        buttonsContainer.setLayout(new GridLayout(1, 2, 4, 0));

        addHeaderButton(Icon.DISCORD.getIcon(iconSize, iconSize), "Join the Discord", "https://discord.com/invite/6XgBcePAfj");
        addHeaderButton(Icon.WEB.getIcon(iconSize, iconSize), "Visit the website.", "https://runeprofile.com");
        addHeaderButton(Icon.GITHUB.getIcon(iconSize, iconSize), "Report issues or contribute.", "https://github.com/ReinhardtR/runeprofile");

        add(title, BorderLayout.WEST);
        add(buttonsContainer, BorderLayout.EAST);
    }

    private void addHeaderButton(ImageIcon icon, String tooltip, String url) {
        JButton button = new JButton();
        SwingUtil.removeButtonDecorations(button);

        button.setIcon(icon);
        button.setToolTipText(tooltip);
        button.addActionListener(e -> LinkBrowser.browse(url));

        button.setUI(new BasicButtonUI());
        button.setBackground(ColorScheme.DARK_GRAY_COLOR);
        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });

        buttonsContainer.add(button);
    }
}

package com.runeprofile.panels;

import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.panels.home.HomePanel;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class MainPanel extends JPanel {

    public MainPanel(RuneProfilePlugin runeProfilePlugin) {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        HomePanel homePanel = new HomePanel(runeProfilePlugin);
        homePanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        add(homePanel, BorderLayout.NORTH);

        JPanel display = new JPanel();
        display.setLayout(new BoxLayout(display, BoxLayout.Y_AXIS));
        display.setBorder(new EmptyBorder(10, 10, 8, 10));

        add(display, BorderLayout.CENTER);
    }
}
package com.runeprofile.panels;

import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class InvalidPanel extends JPanel {
	private final JLabel hintText = new JLabel();

	public InvalidPanel() {
		setBorder(new EmptyBorder(50, 10, 0, 10));
		setLayout(new BorderLayout());

		JPanel wrapper = new JPanel(new BorderLayout());

		JLabel titleText = new JLabel("RuneProfile");
		titleText.setFont(FontManager.getRunescapeFont());
		titleText.setForeground(Color.WHITE);
		titleText.setHorizontalAlignment(SwingConstants.CENTER);
		wrapper.add(titleText, BorderLayout.NORTH);

		hintText.setFont(FontManager.getRunescapeSmallFont());
		hintText.setForeground(Color.GRAY);
		hintText.setHorizontalAlignment(SwingConstants.CENTER);
		wrapper.add(hintText, BorderLayout.CENTER);

		add(wrapper, BorderLayout.NORTH);
	}

	public void setHintText(String text) {
		SwingUtilities.invokeLater(() -> hintText.setText(text));
	}
}

/*
 *
 *  * Copyright (c) 2021, Senmori
 *  * All rights reserved.
 *  *
 *  * Redistribution and use in source and binary forms, with or without
 *  * modification, are permitted provided that the following conditions are met:
 *  *
 *  * 1. Redistributions of source code must retain the above copyright notice, this
 *  *    list of conditions and the following disclaimer.
 *  * 2. Redistributions in binary form must reproduce the above copyright notice,
 *  *    this list of conditions and the following disclaimer in the documentation
 *  *    and/or other materials provided with the distribution.
 *  *
 *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package com.runeprofile;

import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.image.BufferedImage;

public enum Icon {
    LOGO("/logo.png"),

    WEB("/web.png"),
    DISCORD("/discord.png"),
    GITHUB("/github.png");

    private final String file;

    Icon(String file) {
        this.file = file;
    }

    public BufferedImage getImage() {
        return ImageUtil.loadImageResource(RuneProfilePlugin.class, file);
    }

    public ImageIcon getIcon(int width, int height) {
        return new ImageIcon(ImageUtil.resizeImage(getImage(), width, height));
    }
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.runeprofile.ui;

import com.google.inject.Inject;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Component;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import static java.lang.Math.round;

@Slf4j
public class SyncButtonManager {
    private static final int COLLECTION_LOG_SETUP = 7797;
    private static final int[] SPRITE_IDS_INACTIVE = {
            SpriteID.DIALOG_BACKGROUND,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT,
            SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT,
            SpriteID.EQUIPMENT_BUTTON_EDGE_TOP,
            SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT,
            SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM,
    };

    private static final int[] SPRITE_IDS_ACTIVE = {
            SpriteID.RESIZEABLE_MODE_SIDE_PANEL_BACKGROUND,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED,
    };

    private static final int FONT_COLOUR_INACTIVE = 0xd6d6d6;
    private static final int FONT_COLOUR_ACTIVE = 0xffffff;
    private static final int CLOSE_BUTTON_OFFSET = 28;
    private static final int BUTTON_WIDTH = 95;
    private static final int BUTTON_OFFSET = CLOSE_BUTTON_OFFSET + 5;
    private int lastAttemptedUpdate = -1;

    private final Client client;
    private final ClientThread clientThread;
    private final EventBus eventBus;

    @Inject
    private SyncButtonManager(
            Client client,
            ClientThread clientThread,
            EventBus eventBus
    ) {
        this.client = client;
        this.clientThread = clientThread;
        this.eventBus = eventBus;
    }

    public void startUp() {
        eventBus.register(this);
        clientThread.invokeLater(() -> tryAddButton(this::onButtonClick));
    }

    public void shutDown() {
        eventBus.unregister(this);
        clientThread.invokeLater(this::removeButton);
    }

    @Getter
    @RequiredArgsConstructor
    enum Screen {
        // First number is col log container (inner) and second is search button id
        COLLECTION_LOG(40697944, 40697932, 40697943);

        @Getter(onMethod_ = @Component)
        private final int parentId;

        @Getter(onMethod_ = @Component)
        private final int searchButtonId;

        @Getter(onMethod_ = @Component)
        private final int collectionLogContainer;
    }

    void tryAddButton(Runnable onClick) {
        for (Screen screen : Screen.values()) {
            addButton(screen, onClick);
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP) {
            clientThread.invokeLater(() -> {
                removeButton();
                addButton(Screen.COLLECTION_LOG, this::onButtonClick);
            });
        }
    }

    void onButtonClick() {
        if (lastAttemptedUpdate != -1 && lastAttemptedUpdate + 50 > client.getTickCount()) {
            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Last update within 30 seconds. You can update again in " + round((lastAttemptedUpdate + 50 - client.getTickCount()) * 0.6) + " seconds.", "RuneProfile");
            return;
        }
        lastAttemptedUpdate = client.getTickCount();

        client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
        client.runScript(2240);
        client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Updating your profile...", "RuneProfile");
    }

    void addButton(Screen screen, Runnable onClick) {
        Widget parent = client.getWidget(screen.getParentId());
        Widget searchButton = client.getWidget(screen.getSearchButtonId());
        Widget collectionLogContainer = client.getWidget(screen.getCollectionLogContainer());
        Widget[] containerChildren;
        Widget draggableTopbar;
        if (parent == null || searchButton == null || collectionLogContainer == null ||
                (containerChildren = collectionLogContainer.getChildren()) == null ||
                (draggableTopbar = containerChildren[0]) == null) {
            return;
        }

        final int w = BUTTON_WIDTH;
        final int h = searchButton.getOriginalHeight();
        final int x = BUTTON_OFFSET;
        final int y = searchButton.getOriginalY();
        final int cornerDim = 9;

        final Widget[] spriteWidgets = new Widget[10];

        spriteWidgets[0] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[0])
                .setPos(x, y)
                .setSize(w, h)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setYPositionMode(searchButton.getYPositionMode());

        spriteWidgets[1] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[1])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y);
        spriteWidgets[2] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[2])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y);
        spriteWidgets[3] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[3])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y + h - cornerDim);
        spriteWidgets[4] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[4])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y + h - cornerDim);
        // Left and right edges
        int sideWidth = 9;
        int sideHeight = 4;
        spriteWidgets[5] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[5])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x + (w - sideWidth), y + cornerDim);
        spriteWidgets[7] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[7])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x, y + cornerDim);

        // Top and bottom edges
        int topWidth = 77;
        int topHeight = 9;
        spriteWidgets[6] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[6])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y);
        spriteWidgets[8] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[8])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y + h - topHeight);
        // Refresh icon
        spriteWidgets[9] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SpriteID.CHATBOX_TRANSPARENT_SCROLLBAR_ARROW_UP)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(13, 16)
                .setOpacity(80)
                .setPos(x + 10, y + 3);


        for (int i = 0; i < 10; i++) {
            spriteWidgets[i].revalidate();
        }

        final Widget text = parent.createChild(-1, WidgetType.TEXT)
                .setText("RuneProfile")
                .setTextColor(FONT_COLOUR_INACTIVE)
                .setFontId(FontID.PLAIN_11)
                .setTextShadowed(true)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setXTextAlignment(WidgetTextAlignment.LEFT)
                .setYTextAlignment(WidgetTextAlignment.CENTER)
                .setPos(x - 10, y + 1)
                .setSize(w, h)
                .setYPositionMode(searchButton.getYPositionMode());
        text.revalidate();

        // We'll give the text layer the listeners since it covers the whole area
        text.setHasListener(true);
        text.setOnMouseOverListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++) {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_ACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_ACTIVE);
        });
        text.setOnMouseLeaveListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++) {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_INACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_INACTIVE);
        });

        // Register a click listener
        text.setAction(0, "Update your RuneProfile");
        text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());


        // Shrink the top bar to avoid overlapping the new button
        draggableTopbar.setOriginalWidth(draggableTopbar.getOriginalWidth() - (w + (x - CLOSE_BUTTON_OFFSET)));
        draggableTopbar.revalidate();

        // recompute locations / sizes on parent
        parent.revalidate();
    }

    void removeButton() {
        for (Screen screen : Screen.values()) {
            Widget parent = client.getWidget(screen.getParentId());
            if (parent != null) {
                parent.deleteAllChildren();
                parent.revalidate();
            }
        }
    }
}
package com.runeprofile;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("runeprofile")
public interface RuneProfileConfig extends Config {
    String CONFIG_GROUP = "runeprofile";

    String MODEL_UPDATE_DATE = "model_update_date"; // The last time the model was updated.

    @ConfigItem(keyName = "update_on_logout", name = "Update on logout", description = "Automatically update your RuneProfile on logout. (Excluding model and Collection Log)")
    default boolean updateOnLogout() {
        return true;
    }
}

package com.runeprofile;

import com.google.gson.Gson;
import com.google.inject.Provides;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;

import com.runeprofile.data.*;
import com.runeprofile.modelexporter.PlayerModelExporter;
import com.runeprofile.ui.SyncButtonManager;
import com.runeprofile.utils.AccountHash;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.util.Text;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Named;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
        name = "RuneProfile",
        description = "Share your achievements on RuneProfile.com",
        tags = {"runeprofile", "rune", "profile", "collection"}
)
public class RuneProfilePlugin extends Plugin {
    private static RuneProfilePlugin instance;

    @Inject
    private Client client;

    @Inject
    private RuneProfileConfig config;

    @Inject
    private RuneProfileApiClient runeProfileApiClient;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private ChatCommandManager chatCommandManager;

    @Inject
    private Gson gson;

    @Inject
    @Named("developerMode")
    @Getter
    private boolean developerMode;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    private RuneProfilePanel runeProfilePanel;
    private NavigationButton navigationButton;

    @Inject
    private SyncButtonManager syncButtonManager;

    // collection log
    private final Map<Integer, Integer> playerItems = new HashMap<>();
    private int tickCollectionLogScriptFired = -1;
    private final Map<Integer, Integer> loadedItemIcons = new HashMap<>();
    private final String COLLECTION_LOG_COMMAND = "!log";
    private final Pattern COLLECTION_LOG_COMMAND_PATTERN = Pattern.compile("^(" + COLLECTION_LOG_COMMAND + ")\\s+([a-zA-Z]+(?: [a-zA-Z]+)*)$", Pattern.CASE_INSENSITIVE);

    public static Client getClient() {
        return instance.client;
    }

    public static ConfigManager getConfigManager() {
        return instance.configManager;
    }

    @Provides
    RuneProfileConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(RuneProfileConfig.class);
    }

    @Override
    protected void startUp() {
        instance = this;

        this.runeProfilePanel = new RuneProfilePanel(this);
        final BufferedImage toolbarIcon = Icon.LOGO.getImage();

        navigationButton = NavigationButton.builder()
                .tooltip("RuneProfile")
                .icon(toolbarIcon)
                .panel(runeProfilePanel)
                .priority(3)
                .build();

        clientToolbar.addNavigation(navigationButton);

        syncButtonManager.startUp();
        chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeLogCommand);

        GameState state = client.getGameState();
        updatePanelState(state);
    }

    @Override
    protected void shutDown() {
        clientToolbar.removeNavigation(navigationButton);
        syncButtonManager.shutDown();
        chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
    }

    @Subscribe
    private void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState state = gameStateChanged.getGameState();

        updatePanelState(state);

        // clear player state
        switch (state) {
            case HOPPING:
            case LOGGING_IN:
            case CONNECTION_LOST:
                playerItems.clear();
                break;
        }

        if (state == GameState.LOGIN_SCREEN) {
            // update on logout
            if (config.updateOnLogout() && client.getLocalPlayer() != null) {
                new Thread(this::updateProfileAsync).start();
            }
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        int tick = client.getTickCount();
        boolean hasClogScriptFired = tickCollectionLogScriptFired != -1;
        boolean hasBufferPassed = tickCollectionLogScriptFired + 2 < tick;
        if (hasClogScriptFired && hasBufferPassed) {
            tickCollectionLogScriptFired = -1;
            scheduledExecutorService.execute(this::updateProfileAsync);
        }
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();

            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int quantity = (int) args[2];

            playerItems.put(itemId, quantity);
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired postFired) {
        syncButtonManager.onScriptPostFired(postFired);
    }

    private void updatePanelState(GameState state) {
        if (state == GameState.LOGGED_IN) {
            if (!isValidProfileType()) {
                runeProfilePanel.loadInvalidRequestState();
            } else {
                runeProfilePanel.loadValidState();
            }
        } else {
            runeProfilePanel.loadInvalidState();
        }
    }

    private void executeLogCommand(ChatMessage chatMessage, String message) {
        log.debug("Executing log command: {}", message);
        Matcher commandMatcher = COLLECTION_LOG_COMMAND_PATTERN.matcher(message);
        if (!commandMatcher.matches()) {
            log.debug("Invalid command format");
            return;
        }

        String pageName = commandMatcher.group(2);
        if (pageName == null || pageName.isEmpty()) {
            log.debug("Invalid page name");
            return;
        }

        String senderName = chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT)
                ? client.getLocalPlayer().getName()
                : Text.sanitize(chatMessage.getName());

        runeProfileApiClient.getCollectionLogPage(senderName, pageName).thenAccept((page) -> {
            clientThread.invokeLater(() -> {
                if (page == null) {
                    updateChatMessage(chatMessage, "Failed to load collection log page");
                    return;
                }

                loadPageIcons(page);

                List<CollectionLogItem> items = page.getItems();
                StringBuilder itemBuilder = new StringBuilder();
                for (CollectionLogItem item : items) {
                    if (item.getQuantity() < 1) continue;

                    String itemString = "<img=" + loadedItemIcons.get(item.getId()) + ">";
                    if (item.getQuantity() > 1) {
                        itemString += "x" + item.getQuantity();
                    }
                    itemString += "  ";
                    itemBuilder.append(itemString);
                }

                int obtainedItemsCount = (int) items.stream().filter(item -> item.getQuantity() > 0).count();
                int totalItemsCount = items.size();

                final String replacementMessage = page.getName() + " " + "(" + obtainedItemsCount + "/" + totalItemsCount + ")" + " : " + itemBuilder.toString();
                updateChatMessage(chatMessage, replacementMessage);
            });
        });
    }


    public void updateProfileAsync() {
        log.debug("Executing update profile method");

        isValidRequest();

        getPlayerDataAsync().thenCompose((data) -> runeProfileApiClient.updateProfileAsync(data))
                .handle((dateString, ex) -> {
                    if (ex != null) {
                        log.error("Error updating profile", ex);
                        clientThread.invokeLater(() -> {
                            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Failed to update your profile.", "RuneProfile");
                        });

                        throw new RuntimeException(ex);
                    }

                    clientThread.invokeLater(() -> {
                        client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Your profile has been updated!", "RuneProfile");
                    });

                    return dateString;
                });
    }

    public CompletableFuture<String> updateModelAsync() throws IllegalStateException {
        isValidRequest();

        CompletableFuture<PlayerModelData> dataFuture = new CompletableFuture<>();

        clientThread.invokeLater(() -> {
            String accountHash = AccountHash.getHashed(client);

            Player player = client.getLocalPlayer();
            Model model = player.getModel();

            byte[] modelBytes = null;
            try {
                modelBytes = PlayerModelExporter.export(model);
            } catch (IOException e) {
                dataFuture.completeExceptionally(e);
            }

            dataFuture.complete(new PlayerModelData(accountHash, modelBytes));
        });

        return dataFuture.thenCompose((data) -> runeProfileApiClient.updateModelAsync(data)
                .handle((dateString, ex) -> {
                    if (ex != null) {
                        log.error("Error updating model", ex);
                        throw new RuntimeException(ex);
                    }

                    configManager.setRSProfileConfiguration(
                            RuneProfileConfig.CONFIG_GROUP,
                            RuneProfileConfig.MODEL_UPDATE_DATE,
                            dateString
                    );

                    return dateString;
                }));
    }

    private CompletableFuture<PlayerData> getPlayerDataAsync() {
        CompletableFuture<PlayerData> playerDataFuture = new CompletableFuture<>();
        clientThread.invokeLater(() -> {
            PlayerData playerData = new PlayerData();

            // general
            playerData.setId(AccountHash.getHashed(client));
            playerData.setUsername(client.getLocalPlayer().getName());
            playerData.setAccountType(client.getVarbitValue(VarbitID.IRONMAN));

            // skills
            for (Skill skill : Skill.values()) {
                String name = skill.getName();
                int xp = client.getSkillExperience(skill);
                playerData.getSkills().put(name, xp);
            }

            // quests
            for (Quest quest : Quest.values()) {
                int id = quest.getId();
                QuestState stateEnum = quest.getState(client);
                int state = 0;
                if (stateEnum == QuestState.IN_PROGRESS) {
                    state = 1;
                } else if (stateEnum == QuestState.FINISHED) {
                    state = 2;
                }
                playerData.getQuests().put(id, state);
            }

            // combat achievement tiers
            for (CombatAchievementTier tier : CombatAchievementTier.values()) {
                int id = tier.getId();
                int completedCount = tier.getCompletedCount(client);
                playerData.getCombatAchievementTiers().put(id, completedCount);
            }

            // achievement diary tiers
            for (AchievementDiary diary : AchievementDiary.values()) {
                int areaId = diary.getId();
                int[] completedCounts = diary.getTiersCompletedCount(client);
                for (int tierIndex = 0; tierIndex < completedCounts.length; tierIndex++) {
                    int completedCount = completedCounts[tierIndex];
                    playerData.getAchievementDiaryTiers().add(new AchievementDiaryTierData(areaId, tierIndex, completedCount));
                }
            }

            // items
            playerData.setItems(playerItems);

            playerDataFuture.complete(playerData);
        });
        return playerDataFuture;
    }

    private void isValidRequest() throws IllegalStateException {
        log.debug("Validating request");
        if (!isValidProfileType()) {
            clientThread.invokeLater(() -> {
                log.debug("Invalid profile type");
                client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Invalid profile type. Please hop to a standard world.", "RuneProfile");
            });
            throw new IllegalStateException("Invalid profile type");
        }

        long accountHash = client.getAccountHash();

        if (accountHash == -1) {
            log.debug("Failed to get account hash");
            throw new IllegalStateException("Failed to get AccountHash");
        }

        Player player = client.getLocalPlayer();

        if (player == null || player.getName() == null) {
            log.debug("Failed to get player");
            throw new IllegalStateException("Failed to get Player");
        }
    }

    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    private boolean isValidProfileType() {
        RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
        return profileType.equals(RuneScapeProfileType.STANDARD);
    }

    private void updateChatMessage(ChatMessage chatMessage, String message) {
        log.debug("Updating chat message: {}", message);
        chatMessage.getMessageNode().setValue(message);
        client.runScript(ScriptID.BUILD_CHATBOX);
    }

    private void loadPageIcons(CollectionLogPage page) {
        List<CollectionLogItem> itemsToLoad = page.getItems()
                .stream()
                .filter(item -> !loadedItemIcons.containsKey(item.getId()))
                .collect(Collectors.toList());

        final IndexedSprite[] modIcons = client.getModIcons();

        final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + itemsToLoad.size());
        int modIconIdx = modIcons.length;

        for (int i = 0; i < itemsToLoad.size(); i++) {
            final CollectionLogItem item = itemsToLoad.get(i);
            final ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
            final BufferedImage image = ImageUtil.resizeImage(itemManager.getImage(itemComposition.getId()), 18, 16);
            final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);
            final int spriteIndex = modIconIdx + i;

            newModIcons[spriteIndex] = sprite;
            loadedItemIcons.put(item.getId(), spriteIndex);
        }

        client.setModIcons(newModIcons);
    }

    public void DEV_generateHiscoreIconsJson() {
        clientThread.invokeLater(() -> {
            Map<String, String> icons = new HashMap<>();
            for (HiscoreSkill skill : HiscoreSkill.values()) {
                String key = skill.getName();
                int spriteId = skill.getSpriteId();

                if (spriteId == -1) {
                    continue;
                }

                final BufferedImage sprite = spriteManager.getSprite(spriteId, 0);

                if (sprite == null) {
                    log.debug("Failed to load icon for = {}", key);
                    continue;
                }

                try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                    ImageIO.write(sprite, "png", baos);
                    byte[] imageBytes = baos.toByteArray();
                    String base64Image = Base64.getEncoder().encodeToString(imageBytes);
                    icons.put(key, base64Image);
                } catch (IOException e) {
                    log.debug("Failed to encode icon for = {}", key);
                }
            }

            String outputFileName = "hiscore-icons.json";
            File outputFile = new File(outputFileName);
            try (FileWriter writer = new FileWriter(outputFile)) {
                gson.toJson(icons, writer); // Serialize the map to JSON and write to the file
                log.debug("Successfully generated hiscore icons in file = {}", outputFileName);
            } catch (IOException e) {
                log.debug("Failed to write hiscore icons file");
            }
        });
    }
}

/*
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import java.awt.*;

// Originally from RuneLite cache
// Additions made for calculating average of 3 colors
public final class JagexColor
{
	public static final double BRIGHTNESS_MAX = .6;
	public static final double BRIGHTNESS_HIGH = .7;
	public static final double BRIGHTNESS_LOW = .8;
	public static final double BRIGHTNESS_MIN = .9;

	private static final double HUE_OFFSET = (.5 / 64.D);
	private static final double SATURATION_OFFSET = (.5 / 8.D);

	private JagexColor()
	{
	}

	// take 3 Jagex HSL colors and make a single RGB color to represent them
	public static Color HSLtoRGBAvg(int hsl1, int hsl2, int hsl3)
	{
		Color c1 = new Color(HSLtoRGB((short) hsl1, BRIGHTNESS_MIN));
		Color c2 = new Color(HSLtoRGB((short) hsl2, BRIGHTNESS_MIN));
		Color c3 = new Color(HSLtoRGB((short) hsl3, BRIGHTNESS_MIN));

		// compute color average using squares
		// uses squared approach from https://sighack.com/post/averaging-rgb-colors-the-right-way
		int r = c1.getRed()*c1.getRed() + c2.getRed()*c2.getRed() + c3.getRed()*c3.getRed();
		int g = c1.getGreen()*c1.getGreen() + c2.getGreen()*c2.getGreen() + c3.getGreen()*c3.getGreen();
		int b = c1.getBlue()*c1.getBlue() + c2.getBlue()*c2.getBlue() + c3.getBlue()*c3.getBlue();

		r = (int) Math.round(Math.sqrt((double) r / 3.0d));
		g = (int) Math.round(Math.sqrt((double) g / 3.0d));
		b = (int) Math.round(Math.sqrt((double) b / 3.0d));

		return new Color(r, g, b);
	}

	public static short packHSL(int hue, int saturation, int luminance)
	{
		return (short) ((short) (hue & 63) << 10
				| (short) (saturation & 7) << 7
				| (short) (luminance & 127));
	}

	public static int unpackHue(short hsl)
	{
		return hsl >> 10 & 63;
	}

	public static int unpackSaturation(short hsl)
	{
		return hsl >> 7 & 7;
	}

	public static int unpackLuminance(short hsl)
	{
		return hsl & 127;
	}

	public static String formatHSL(short hsl)
	{
		return String.format("%02Xh%Xs%02Xl", unpackHue(hsl), unpackSaturation(hsl), unpackLuminance(hsl));
	}

	public static int HSLtoRGB(short hsl, double brightness)
	{
		double hue = (double) unpackHue(hsl) / 64.D + HUE_OFFSET;
		double saturation = (double) unpackSaturation(hsl) / 8.D + SATURATION_OFFSET;
		double luminance = (double) unpackLuminance(hsl) / 128.D;

		// This is just a standard hsl to rgb transform
		// the only difference is the offsets above and the brightness transform below
		double chroma = (1.D - Math.abs((2.D * luminance) - 1.D)) * saturation;
		double x = chroma * (1 - Math.abs(((hue * 6.D) % 2.D) - 1.D));
		double lightness = luminance - (chroma / 2);

		double r = lightness, g = lightness, b = lightness;
		switch ((int) (hue * 6.D))
		{
			case 0:
				r += chroma;
				g += x;
				break;
			case 1:
				g += chroma;
				r += x;
				break;
			case 2:
				g += chroma;
				b += x;
				break;
			case 3:
				b += chroma;
				g += x;
				break;
			case 4:
				b += chroma;
				r += x;
				break;
			default:
				r += chroma;
				b += x;
				break;
		}

		int rgb = ((int) (r * 256.0D) << 16)
				| ((int) (g * 256.0D) << 8)
				| (int) (b * 256.0D);

		rgb = adjustForBrightness(rgb, brightness);

		if (rgb == 0)
		{
			rgb = 1;
		}
		return rgb;
	}

	public static int adjustForBrightness(int rgb, double brightness)
	{
		double r = (double) (rgb >> 16) / 256.0D;
		double g = (double) (rgb >> 8 & 255) / 256.0D;
		double b = (double) (rgb & 255) / 256.0D;

		r = Math.pow(r, brightness);
		g = Math.pow(g, brightness);
		b = Math.pow(b, brightness);

		return ((int) (r * 256.0D) << 16)
				| ((int) (g * 256.0D) << 8)
				| (int) (b * 256.0D);
	}

	public static int[] createPalette(double brightness)
	{
		int[] colorPalette = new int[65536];
		for (int i = 0; i < colorPalette.length; i++)
		{
			colorPalette[i] = HSLtoRGB((short) i, brightness);
		}
		return colorPalette;
	}
}
/*
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import com.runeprofile.RuneProfilePlugin;
import net.runelite.api.Client;

import java.awt.Color;
import java.util.HashMap;
import java.util.Map;

public class TextureColor
{
    private static final Map<Integer, Color> colorCache = new HashMap<>();

    // get single average color from Jagex texture id
    public static Color getColor(int textureId)
    {
        if (colorCache.containsKey(textureId))
            return colorCache.get(textureId);

        Client client = RuneProfilePlugin.getClient();
        if (client == null)
            return new Color(255, 255, 255);
        int[] pixels = client.getTextureProvider().load(textureId);

        int r = 0;
        int g = 0;
        int b = 0;
        int n = 0;
        for (int pixel : pixels)
        {
            // skip transparent (black)
            if (pixel == 0)
                continue;

            Color c = new Color(pixel);
            r += c.getRed();
            g += c.getGreen();
            b += c.getBlue();
            n++;
        }

        Color c = new Color(r/n, g/n, b/n);
        colorCache.put(textureId, c);
        return c;
    }

}
/*
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import net.runelite.api.Model;

import java.awt.Color;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class PlayerModelExporter
{
	private final static int[] colorPalette = JagexColor.createPalette(JagexColor.BRIGHTNESS_MIN);

	public static byte[] export(Model m) throws IOException
	{
		List<Vertex> vertices = new ArrayList<>();
		for (int fi=0; fi < m.getFaceCount(); fi++)
		{
			// determine vertex colors (textured or colored?)
			Color vc1;
			Color vc2;
			Color vc3;
			int textureId = -1;
			if (m.getFaceTextures() != null)
				textureId = m.getFaceTextures()[fi];
			if (textureId != -1)
			{
				// get average color of texture
				vc1 = TextureColor.getColor(textureId);
				vc2 = vc1;
				vc3 = vc1;
			}
			else
			{
				if (m.getFaceColors3()[fi] == -1)
				{
					// face should be shaded flat
					int colorIndex = m.getFaceColors1()[fi];
					int rgbColor = colorPalette[colorIndex];
					vc1 = vc2 = vc3 = new Color(rgbColor);
				} else {
					// get color for each vertex
					vc1 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors1()[fi], JagexColor.BRIGHTNESS_MIN));
					vc2 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors2()[fi], JagexColor.BRIGHTNESS_MIN));
					vc3 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors3()[fi], JagexColor.BRIGHTNESS_MIN));
				}
			}

			int vi1 = m.getFaceIndices1()[fi];
			int vi2 = m.getFaceIndices2()[fi];
			int vi3 = m.getFaceIndices3()[fi];

			int vx1 = (int) m.getVerticesX()[vi1];
			int vx2 = (int) m.getVerticesX()[vi2];
			int vx3 = (int) m.getVerticesX()[vi3];
			int vy1 = (int) -m.getVerticesY()[vi1];
			int vy2 = (int) -m.getVerticesY()[vi2];
			int vy3 = (int) -m.getVerticesY()[vi3];
			int vz1 = (int) m.getVerticesZ()[vi1];
			int vz2 = (int) m.getVerticesZ()[vi2];
			int vz3 = (int) m.getVerticesZ()[vi3];

			vertices.add(new Vertex(vx1, vy1, vz1, vc1.getRed(), vc1.getGreen(), vc1.getBlue()));
			vertices.add(new Vertex(vx2, vy2, vz2, vc2.getRed(), vc2.getGreen(), vc2.getBlue()));
			vertices.add(new Vertex(vx3, vy3, vz3, vc3.getRed(), vc3.getGreen(), vc3.getBlue()));
		}

		ByteArrayOutputStream ply = new ByteArrayOutputStream();
		PrintWriter plyHeader = new PrintWriter(ply);
		plyHeader.println("ply");
		plyHeader.println("format binary_little_endian 1.0");
		plyHeader.println("element vertex " + vertices.size());
		plyHeader.println("property int16 x");
		plyHeader.println("property int16 y");
		plyHeader.println("property int16 z");
		plyHeader.println("property uint8 red");
		plyHeader.println("property uint8 green");
		plyHeader.println("property uint8 blue");
		plyHeader.println("element face " + m.getFaceCount());
		plyHeader.println("property list uint8 int16 vertex_indices");
		plyHeader.println("end_header");
		plyHeader.flush();

		ByteArrayOutputStream w = new ByteArrayOutputStream();

		for (Vertex v: vertices)
		{
			// Y and Z axes are flipped
			w.write(le(v.x));
			w.write(le(v.z));
			w.write(le(v.y));
			w.write((byte) v.r);
			w.write((byte) v.g);
			w.write((byte) v.b);
		}

		for (int i=0; i < m.getFaceCount(); ++i)
		{
			int vi = i*3;
			w.write((byte) 3);
			w.write(le(vi));
			w.write(le(vi+1));
			w.write(le(vi+2));
		}

		w.flush();
		ply.write(w.toByteArray());
		return ply.toByteArray();
	}

	// int to little endian byte array
	private static byte[] le(int n)
	{
		byte[] b = new byte[2];
		b[0] = (byte) n;
		b[1] = (byte) (n >> 8);
		return b;
	}

	private static class Vertex
	{
		public int x, y, z;
		public int r, g, b;

		public Vertex(int x, int y, int z, int r, int g, int b)
		{
			this.x = x;
			this.y = y;
			this.z = z;
			this.r = r;
			this.g = g;
			this.b = b;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			Vertex vertex = (Vertex) o;
			return x == vertex.x && y == vertex.y && z == vertex.z && r == vertex.r && g == vertex.g && b == vertex.b;
		}

		@Override
		public int hashCode() {
			return Objects.hash(x, y, z, r, g, b);
		}
	}

}
package com.runeprofile;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.runeprofile.data.CollectionLogPage;
import com.runeprofile.data.PlayerData;
import com.runeprofile.data.PlayerModelData;
import com.runeprofile.utils.DateHeader;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLiteProperties;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

@Slf4j
@RequiredArgsConstructor
public class RuneProfileApiClient {
    private static final MediaType JSON_MEDIA_TYPE = Objects.requireNonNull(MediaType.parse("application/json; charset=utf-8"));

    @Inject
    private OkHttpClient okHttpClient;

    private final String userAgent;

    // increment when making breaking changes to how the plugin users the API
    private static final String version = "2.0.0";

    private final HttpUrl baseUrl;

    @Inject
    private Gson gson;

    @Inject
    public RuneProfileApiClient() {
        boolean isDevMode = false;

        String runeliteVersion = RuneLiteProperties.getVersion();
        userAgent = "RuneLite:" + runeliteVersion + "," + "Client:" + version;

        //noinspection ConstantValue
        baseUrl = isDevMode
                ? new HttpUrl.Builder().scheme("http").host("localhost").port(8787).build()
                : new HttpUrl.Builder().scheme("https").host("api.runeprofile.com").build();
    }

    private HttpUrl buildApiUrl(String... pathSegments) {
        HttpUrl.Builder urlBuilder = baseUrl.newBuilder();
        for (String segment : pathSegments) {
            urlBuilder.addPathSegment(segment);
        }
        return urlBuilder.build();
    }

    private RequestBody createJsonBody(JsonObject jsonObject) {
        return RequestBody.create(JSON_MEDIA_TYPE, jsonObject.toString());
    }

    private Request.Builder buildApiRequest(HttpUrl url, Consumer<Request.Builder> methodSetter) {
        Request.Builder builder = new Request.Builder()
                .url(url)
                .header("Content-Type", "application/json")
                .header("User-Agent", userAgent);
        methodSetter.accept(builder);
        return builder;
    }

    private CompletableFuture<Response> executeHttpRequestAsync(OkHttpClient client, Request request) {
        CompletableFuture<Response> future = new CompletableFuture<>();
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Async API request failed.", e);
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) {
                future.complete(response);
            }
        });
        return future;
    }

    public CompletableFuture<Response> postHttpRequestAsync(HttpUrl url, String data) {
        RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, data);
        Request request = buildApiRequest(url, builder -> builder.post(body)).build();
        log.debug("Sending json request to = {}, data = {}", url.toString(), data);
        return executeHttpRequestAsync(okHttpClient, request);
    }

    public CompletableFuture<Response> postHttpRequestAsync(HttpUrl url, MultipartBody data) {
        Request request = buildApiRequest(url, builder -> builder.post(data)).build();
        log.debug("Sending form data request to = {}, data = {}", url.toString(), data);
        return executeHttpRequestAsync(okHttpClient, request);
    }

    public CompletableFuture<Response> getHttpRequestAsync(HttpUrl url) {
        Request request = buildApiRequest(url, Request.Builder::get)
                .build();
        return executeHttpRequestAsync(okHttpClient, request);
    }

    public CompletableFuture<Response> deleteHttpRequestAsync(HttpUrl url) {
        Request request = buildApiRequest(url, Request.Builder::delete)
                .build();
        return executeHttpRequestAsync(okHttpClient, request);
    }

    public CompletableFuture<String> updateProfileAsync(PlayerData data) {
        HttpUrl url = buildApiUrl("profiles");
        return postHttpRequestAsync(url, gson.toJson(data)).thenApplyAsync(this::getResponseDateString);
    }

    public CompletableFuture<String> updateModelAsync(PlayerModelData data) {
        HttpUrl url = buildApiUrl("profiles", "models");

        RequestBody file = RequestBody.create(MediaType.parse("model/ply"), data.getModel());
        MultipartBody body = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("accountId", data.getAccountHash())
                .addFormDataPart("model", "model.ply", file)
                .build();

        return postHttpRequestAsync(url, body).thenApplyAsync(this::getResponseDateString);
    }

    public CompletableFuture<CollectionLogPage> getCollectionLogPage(String username, String page) {
        HttpUrl url = buildApiUrl("profiles", username, "collection-log", page);

        return getHttpRequestAsync(url).thenApplyAsync((response -> {
            if (response.isSuccessful()) {
                try (Response res = response) {
                    ResponseBody body = res.body();
                    if (body == null) {
                        log.warn("Async API request failed with code: {}", response.code());
                        return null;
                    }
                    return gson.fromJson(body.string(), CollectionLogPage.class);
                } catch (IOException e) {
                    log.warn("Async API request failed with code: {}", response.code());
                    log.error("Error reading response body", e);
                    return null;
                }
            } else {
                log.warn("Async API request failed with code: {}", response.code());
                return null;
            }
        }));
    }

    public String getResponseDateString(Response response) {
        try (Response res = response) {
            if (response.isSuccessful()) {
                String date = res.header("Date");
                return DateHeader.getDateString(date);
            } else {
                log.warn("Async API request failed with code: {}", response.code());
                return "Failed";
            }
        }
    }
}

package com.runeprofile;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RuneProfilePluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(RuneProfilePlugin.class);
		RuneLite.main(args);
	}
}
