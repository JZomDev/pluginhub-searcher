package com.runeprofile.utils;


import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;

import javax.annotation.Nullable;

public class ItemUtils {
    public static final String ITEM_CACHE_BASE_URL = "https://static.runelite.net/cache/item/";

    public static final int VALUABLE_DROP_THRESHOLD = 1_000_000;

    @Getter
    @RequiredArgsConstructor
    public enum ClanBroadcastValue {
        BELLATOR_VESTIGE(28279, 5_000_000),
        MAGUS_VESTIGE(28281, 5_000_000),
        VENATOR_VESTIGE(28283, 5_000_000),
        ULTOR_VESTIGE(28285, 5_000_000),

        NOXIOUS_POINT(29790, 10_000_000),
        NOXIOUS_BLADE(29792, 10_000_000),
        NOXIOUS_POMMEL(29794, 10_000_000),
        ARAXYTE_FANG(29799, 50_000_000),

        MOKHAIOTL_CLOTH(31109, 75_000_000);

        private final int itemId;
        private final int value;

        public static @Nullable ClanBroadcastValue getByItemId(int itemId) {
            for (ClanBroadcastValue value : ClanBroadcastValue.values()) {
                if (value.getItemId() == itemId) {
                    return value;
                }
            }
            return null;
        }
    }

    public static int getUnnotedItemId(@NonNull ItemComposition comp) {
        return isItemNoted(comp) ? comp.getLinkedNoteId() : comp.getId();
    }

    public static int getPerceivedItemValue(@NonNull ItemManager itemManager, int itemId) {
        ClanBroadcastValue clanBroadcastValue = ClanBroadcastValue.getByItemId(itemId);
        if (clanBroadcastValue != null) {
            return clanBroadcastValue.getValue();
        }
        return itemManager.getItemPriceWithSource(itemId, true);
    }

    public static boolean isItemNoted(@NonNull ItemComposition item) {
        return item.getNote() != -1;
    }
}

/* BSD 2-Clause License

Copyright (c) 2022, Jake Barter
All rights reserved.

Copyright (c) 2022, pajlads

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

package com.runeprofile.utils;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;

/**
 * This thread-safe singleton holds a mapping of item names to their item id, using the RuneLite API.
 * <p>
 * Unlike {@link net.runelite.client.game.ItemManager#search(String)}, this mapping supports untradable items.
 */
@Slf4j
@Singleton
public class ItemSearcher {
    private final Map<String, Integer> itemIdByName = Collections.synchronizedMap(new HashMap<>(16384));
    private @Inject OkHttpClient httpClient;
    private @Inject Gson gson;

    /**
     * @param name the exact in-game name of an item
     * @return the id associated with the item name, or null if not found
     */
    @Nullable
    public Integer findItemId(@NonNull String name) {
        return itemIdByName.get(name);
    }

    /**
     * Begins the initialization process for {@link #itemIdByName}
     * by querying item names and noted item ids from the RuneLite API,
     * before passing them to {@link #populate(Map, Set)}
     *
     * @implNote This operation does not block the current thread,
     * by utilizing OkHttp's thread pool and Java's Fork-Join common pool.
     */
    @Inject
    void init() {
        queryNamesById()
                .thenAcceptBothAsync(
                        queryNotedItemIds().exceptionally(e -> {
                            log.error("Failed to read noted items", e);
                            return Collections.emptySet();
                        }),
                        this::populate
                )
                .exceptionally(e -> {
                    log.error("Failed to read item names", e);
                    return null;
                });
    }

    /**
     * Populates {@link #itemIdByName} with the inverted mappings of {@code namesById},
     * while skipping noted items specified in {@code notedIds}.
     *
     * @param namesById a mapping of item id's to the corresponding in-game name
     * @param notedIds  the id's of noted items
     * @implNote When multiple non-noted item id's have the same in-game name, only the earliest id is saved
     */
    void populate(@NonNull Map<Integer, String> namesById, @NonNull Set<Integer> notedIds) {
        namesById.forEach((id, name) -> {
            if (!notedIds.contains(id))
                itemIdByName.putIfAbsent(name, id);
        });

        log.debug("Completed initialization of item cache with {} entries", itemIdByName.size());
    }

    /**
     * @return a mapping of item ids to their in-game names, provided by the RuneLite API
     */
    private CompletableFuture<Map<Integer, String>> queryNamesById() {
        return queryCache("names.json", new TypeToken<Map<Integer, String>>() {
        });
    }

    /**
     * @return a set of id's of noted items, provided by the RuneLite API
     */
    private CompletableFuture<Set<Integer>> queryNotedItemIds() {
        return queryCache("notes.json", new TypeToken<Map<Integer, Integer>>() {
        })
                .thenApply(Map::keySet);
    }

    /**
     * @param fileName the name of the file to query from RuneLite's cache
     * @param type     a type token that indicates how the json response should be parsed
     * @return the transformed cache response, wrapped in a future
     */
    private <T> CompletableFuture<T> queryCache(@NonNull String fileName, @NonNull TypeToken<T> type) {
        return Utils.readJson(httpClient, gson, ItemUtils.ITEM_CACHE_BASE_URL + fileName, type);
    }
}
/*
 * Copyright (c) 2018, John Pettenger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.utils;

import com.google.common.collect.EvictingQueue;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;

import com.google.inject.Inject;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.clan.ClanID;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;

@Slf4j
@Singleton
public class UsernameAutocompleter implements KeyListener {
    /**
     * Non-breaking space character.
     */
    private static final String NBSP = Character.toString((char) 160);

    /**
     * Character class for characters that cannot be in an RSN.
     */
    private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

    private static final int MAX_SEARCH_HISTORY = 25;

    private final Client client;

    private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

    /**
     * The name currently being autocompleted.
     */
    private String autocompleteName;

    /**
     * Pattern for the name currently being autocompleted.
     */
    private Pattern autocompleteNamePattern;

    @Inject
    private UsernameAutocompleter(Client client) {
        this.client = client;
    }

    @Override
    public void keyPressed(KeyEvent e) {

    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void keyTyped(KeyEvent e) {
        final JTextComponent input = (JTextComponent) e.getSource();
        final String inputText = input.getText();

        // Only autocomplete if the selection end is at the end of the text.
        if (input.getSelectionEnd() != inputText.length()) {
            return;
        }

        // Character to be inserted at the selection start.
        final String charToInsert = Character.toString(e.getKeyChar());

        // Don't attempt to autocomplete if the name is invalid.
        // This condition is also true when the user presses a key like backspace.
        if (INVALID_CHARS.matcher(charToInsert).find()
                || INVALID_CHARS.matcher(inputText).find()) {
            return;
        }

        // Check if we are already autocompleting.
        if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches()) {
            if (isExpectedNext(input, charToInsert)) {
                try {
                    // Insert the character and move the selection.
                    final int insertIndex = input.getSelectionStart();
                    Document doc = input.getDocument();
                    doc.remove(insertIndex, 1);
                    doc.insertString(insertIndex, charToInsert, null);
                    input.select(insertIndex + 1, input.getSelectionEnd());
                } catch (BadLocationException ex) {
                    log.warn("Could not insert character.", ex);
                }

                // Prevent default behavior.
                e.consume();
            } else // Character to insert does not match current autocompletion. Look for another name.
            {
                newAutocomplete(e);
            }
        } else // Search for a name to autocomplete
        {
            newAutocomplete(e);
        }
    }

    private void newAutocomplete(KeyEvent e) {
        final JTextComponent input = (JTextComponent) e.getSource();
        final String inputText = input.getText();
        final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

        if (findAutocompleteName(nameStart)) {
            // Assert this.autocompleteName != null
            final String name = this.autocompleteName;
            SwingUtilities.invokeLater(() ->
            {
                try {
                    input.getDocument().insertString(
                            nameStart.length(),
                            name.substring(nameStart.length()),
                            null);
                    input.select(nameStart.length(), name.length());
                } catch (BadLocationException ex) {
                    log.warn("Could not autocomplete name.", ex);
                }
            });
        }
    }

    private boolean findAutocompleteName(String nameStart) {
        final Pattern pattern;
        Optional<String> autocompleteName;

        // Pattern to match names that start with nameStart.
        // Allows spaces to be represented as common whitespaces, underscores,
        // hyphens, or non-breaking spaces.
        // Matching non-breaking spaces is necessary because the API
        // returns non-breaking spaces when a name has whitespace.
        pattern = Pattern.compile(
                "(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

        // Search all previous successful queries
        autocompleteName = searchHistory.stream()
                .filter(n -> pattern.matcher(n).matches())
                .findFirst();

        // Search friends if previous searches weren't matched
        if (!autocompleteName.isPresent()) {
            NameableContainer<Friend> friendContainer = client.getFriendContainer();
            if (friendContainer != null) {
                autocompleteName = Arrays.stream(friendContainer.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search friends chat if a friend wasn't found
        if (!autocompleteName.isPresent()) {
            final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
            if (friendsChatManager != null) {
                autocompleteName = Arrays.stream(friendsChatManager.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search clans
        if (!autocompleteName.isPresent()) {
            final ClanSettings[] clanSettings = {
                    client.getClanSettings(ClanID.CLAN),
                    client.getClanSettings(ClanID.GROUP_IRONMAN),
                    client.getGuestClanSettings()
            };
            autocompleteName = Arrays.stream(clanSettings)
                    .filter(Objects::nonNull)
                    .flatMap(cs -> cs.getMembers().stream())
                    .map(ClanMember::getName)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        // Search cached players if a friend wasn't found
        if (!autocompleteName.isPresent()) {
            WorldView wv = client.getTopLevelWorldView();
            autocompleteName = wv.players().stream()
                    .filter(Objects::nonNull)
                    .map(Player::getName)
                    .filter(Objects::nonNull)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        if (autocompleteName.isPresent()) {
            this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
            this.autocompleteNamePattern = Pattern.compile(
                    "(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
        } else {
            this.autocompleteName = null;
            this.autocompleteNamePattern = null;
        }

        return autocompleteName.isPresent();
    }

    void addToSearchHistory(@NonNull String name) {
        if (!searchHistory.contains(name)) {
            searchHistory.offer(name);
        }
    }

    private boolean isExpectedNext(JTextComponent input, String nextChar) {
        String expected;
        if (input.getSelectionStart() < input.getSelectionEnd()) {
            try {
                expected = input.getText(input.getSelectionStart(), 1);
            } catch (BadLocationException ex) {
                log.warn("Could not get first character from input selection.", ex);
                return false;
            }
        } else {
            expected = "";
        }
        return nextChar.equalsIgnoreCase(expected);
    }
}
package com.runeprofile.utils;

@FunctionalInterface
public interface SupplierWithException<T, E extends Exception> {
    T get() throws E;
}

package com.runeprofile.utils;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.NonNull;
import lombok.experimental.UtilityClass;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;
import okhttp3.*;

import java.io.IOException;
import java.io.Reader;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;

@UtilityClass
public class Utils {
    // Code from: DinkPlugin
    // Repository: https://github.com/pajlads/DinkPlugin
    // License: BSD 2-Clause License
    public <T> CompletableFuture<T> readJson(@NonNull OkHttpClient httpClient, @NonNull Gson gson, @NonNull String url, @NonNull TypeToken<T> type) {
        return readUrl(httpClient, url, reader -> gson.fromJson(reader, type.getType()));
    }

    // Code from: DinkPlugin
    // Repository: https://github.com/pajlads/DinkPlugin
    // License: BSD 2-Clause License
    public <T> CompletableFuture<T> readUrl(@NonNull OkHttpClient httpClient, @NonNull String url, @NonNull Function<Reader, T> transformer) {
        CompletableFuture<T> future = new CompletableFuture<>();
        Request request = new Request.Builder().url(url).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) {
                assert response.body() != null;
                try (Reader reader = response.body().charStream()) {
                    future.complete(transformer.apply(reader));
                } catch (Exception e) {
                    future.completeExceptionally(e);
                } finally {
                    response.close();
                }
            }
        });
        return future;
    }

    // Code from: DinkPlugin
    // Repository: https://github.com/pajlads/DinkPlugin
    // License: BSD 2-Clause License
    public String sanitize(String str) {
        if (str == null || str.isEmpty()) return "";
        return Text.removeTags(str.replace("<br>", "\n")).replace('\u00A0', ' ').trim();
    }

    public void openProfileInBrowser(String username) {
        String url = "https://www.runeprofile.com/" + username.replace(" ", "%20");
        LinkBrowser.browse(url);
    }

    public String getApiErrorMessage(Throwable ex, String defaultMessage) {
        String result = defaultMessage;

        if (ex instanceof RuneProfileApiException) {
            result = ex.getMessage();
        } else if (ex.getCause() instanceof RuneProfileApiException) {
            result = ex.getCause().getMessage();
        }

        return result;
    }
}

/*
 *
 *  * Copyright (c) 2021, Senmori
 *  * All rights reserved.
 *  *
 *  * Redistribution and use in source and binary forms, with or without
 *  * modification, are permitted provided that the following conditions are met:
 *  *
 *  * 1. Redistributions of source code must retain the above copyright notice, this
 *  *    list of conditions and the following disclaimer.
 *  * 2. Redistributions in binary form must reproduce the above copyright notice,
 *  *    this list of conditions and the following disclaimer in the documentation
 *  *    and/or other materials provided with the distribution.
 *  *
 *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 *  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package com.runeprofile.utils;

import com.runeprofile.RuneProfilePlugin;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.image.BufferedImage;

public enum Icon {
    LOGO("/logo.png"),

    WEB("/web.png"),
    DISCORD("/discord.png"),
    GITHUB("/github.png");

    private final String file;

    Icon(String file) {
        this.file = file;
    }

    public BufferedImage getImage() {
        return ImageUtil.loadImageResource(RuneProfilePlugin.class, file);
    }

    public ImageIcon getIcon(int width, int height) {
        return new ImageIcon(ImageUtil.resizeImage(getImage(), width, height));
    }
}
package com.runeprofile.utils;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.client.config.RuneScapeProfileType;


@Slf4j
public class PlayerState {
    public static boolean isValidPlayerState(Client client) {
        GameState gameState = client.getGameState();
        if (gameState != GameState.LOGGED_IN) {
            log.debug("Invalid game state: {}", gameState);
            return false;
        }

        long accountHash = client.getAccountHash();
        if (accountHash == -1) {
            log.debug("Invalid account hash: {}", accountHash);
            return false;
        }

        Player player = client.getLocalPlayer();
        if (player == null || player.getName() == null) {
            log.debug("Invalid player");
            return false;
        }

        // first layer of world type validation
        RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
        boolean isValidProfileType = profileType.equals(RuneScapeProfileType.STANDARD);
        if (!isValidProfileType) {
            log.debug("Invalid profile type: {}", profileType);
            return false;
        }

        return true;
    }
}

package com.runeprofile.utils;

import lombok.Getter;

@Getter
public class RuneProfileApiException extends RuntimeException {
    public RuneProfileApiException(String message) {
        super(message);
    }
}
package com.runeprofile.utils;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

@Slf4j
public class DevTools {
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private Gson gson;

    public void generateHiscoreIconsJson() {
        clientThread.invokeLater(() -> {
            Map<String, String> icons = new HashMap<>();
            for (HiscoreSkill skill : HiscoreSkill.values()) {
                String key = skill.getName();
                int spriteId = skill.getSpriteId();
                if (spriteId == -1) {
                    continue;
                }

                final BufferedImage sprite = spriteManager.getSprite(spriteId, 0);
                writeBase64Sprite(sprite, key, icons);
            }

            DEV_writeJsonFile("hiscore-icons.json", icons);
        });
    }


    public void generateClanRankIconsJson() {
        clientThread.invokeLater(() -> {
            Map<String, String> icons = new HashMap<>();

            final EnumComposition clanIcons = client.getEnum(EnumID.CLAN_RANK_GRAPHIC);

            for (int i = 0; i < clanIcons.size(); i++) {
                final int key = clanIcons.getKeys()[i];
                final BufferedImage sprite = spriteManager.getSprite(clanIcons.getIntValue(key), 0);
                writeBase64Sprite(sprite, Integer.toString(key), icons);
            }

            DEV_writeJsonFile("clan-rank-icons.json", icons);
        });
    }

    private void writeBase64Sprite(BufferedImage sprite, String key, Map<String, String> icons) {
        if (sprite == null) {
            log.debug("Failed to load icon for = {}", key);
            return;
        }

        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            synchronized (ImageIO.class) {
                ImageIO.write(sprite, "png", baos);
            }
            byte[] imageBytes = baos.toByteArray();
            String base64Image = Base64.getEncoder().encodeToString(imageBytes);
            icons.put(key, base64Image);
        } catch (IOException e) {
            log.debug("Failed to encode icon for = {}", key);
        }
    }


    private void DEV_writeJsonFile(String fileName, Object data) {
        try (FileWriter writer = new FileWriter(fileName)) {
            gson.toJson(data, writer);
            log.debug("Successfully wrote JSON to file = {}", fileName);
        } catch (IOException e) {
            log.debug("Failed to write JSON to file");
        }
    }
}

package com.runeprofile.utils;

import net.runelite.api.Client;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class AccountHash {
    public static String getHashed(Client client) {
        long accountHashLong = client.getAccountHash();

        if (accountHashLong == -1) {
            return null;
        }

        String accountHashString = String.valueOf(accountHashLong);

        MessageDigest digest;

        try {
            digest = MessageDigest.getInstance("SHA-1");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }

        byte[] hash = digest.digest(accountHashString.getBytes(StandardCharsets.UTF_8));

        return Base64.getEncoder().encodeToString(hash);
    }
}

package com.runeprofile;

import com.runeprofile.panels.InvalidPanel;
import com.runeprofile.panels.LayoutPluginPanel;
import com.runeprofile.panels.HeaderPanel;
import com.runeprofile.utils.Icon;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

@Slf4j
public class RuneProfilePanel extends PluginPanel {
    private final EventBus eventBus;
    private final Client client;
    private final ClientToolbar clientToolbar;
    private final RuneProfileConfig config;
    private final NavigationButton navigationButton;
    private final InvalidPanel invalidPanel;
    private final LayoutPluginPanel layoutPluginPanel;

    @Inject
    public RuneProfilePanel(EventBus eventBus, Client client, ClientToolbar clientToolbar, RuneProfileConfig config, HeaderPanel headerPanel, InvalidPanel invalidPanel, LayoutPluginPanel layoutPluginPanel) {
        super(false);
        setLayout(new BorderLayout());

        this.eventBus = eventBus;
        this.client = client;
        this.clientToolbar = clientToolbar;
        this.config = config;
        this.invalidPanel = invalidPanel;
        this.layoutPluginPanel = layoutPluginPanel;

        add(headerPanel, BorderLayout.NORTH);
        loadLoginState();

        final BufferedImage toolbarIcon = Icon.LOGO.getImage();
        navigationButton = NavigationButton.builder()
                .tooltip("RuneProfile")
                .icon(toolbarIcon)
                .panel(this)
                .priority(4)
                .build();
    }

    public void startUp() {
        eventBus.register(this);

        updateState(client.getGameState());

        if (config.showSidePanel()) {
            clientToolbar.addNavigation(navigationButton);
        }
    }

    public void shutDown() {
        eventBus.unregister(this);

        clientToolbar.removeNavigation(navigationButton);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(RuneProfilePlugin.CONFIG_GROUP)) return;

        if (config.showSidePanel()) {
            clientToolbar.addNavigation(navigationButton);
        } else {
            clientToolbar.removeNavigation(navigationButton);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        updateState(event.getGameState());
    }

    private void updateState(GameState state) {
        if (state == GameState.LOGGED_IN) {
            RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
            if (profileType != RuneScapeProfileType.STANDARD) {
                loadInvalidPlayerState();
            } else {
                loadValidState();
            }
        } else {
            loadLoginState();
        }
    }

    private void loadValidState() {
        SwingUtilities.invokeLater(() -> {
            if (invalidPanel != null) {
                remove(invalidPanel);
            }

            add(layoutPluginPanel, BorderLayout.CENTER);
            revalidate();
            repaint();
        });
    }

    private void loadLoginState() {
        SwingUtilities.invokeLater(() -> {
            if (layoutPluginPanel != null) {
                remove(layoutPluginPanel);
            }

            invalidPanel.setHintText("Login to use this plugin.");
            add(invalidPanel, BorderLayout.CENTER);
            revalidate();
            repaint();
        });
    }

    private void loadInvalidPlayerState() {
        SwingUtilities.invokeLater(() -> {
            if (layoutPluginPanel != null) {
                remove(layoutPluginPanel);
            }

            invalidPanel.setHintText("Invalid world/mode.");
            add(invalidPanel, BorderLayout.CENTER);
            revalidate();
            repaint();
        });
    }
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class AchievementDiaryTierData {
    private final int areaId;
    private final int tierIndex;
    private final int completedCount;
}

package com.runeprofile.data;

import com.runeprofile.data.activities.ActivityData;
import com.runeprofile.data.activities.Activity;
import lombok.Data;

import java.util.List;

@Data
public class AddActivities {
    private final String id;
    private final List<? extends Activity<? extends ActivityData>> activities;
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class PlayerClanData {
    private final String name;
    private final int rank;
    private final int icon;
    private final String title;
}

package com.runeprofile.data;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;

@Getter
@RequiredArgsConstructor
public enum CombatAchievementTier {
    EASY(1, VarbitID.CA_TOTAL_TASKS_COMPLETED_EASY),
    MEDIUM(2, VarbitID.CA_TOTAL_TASKS_COMPLETED_MEDIUM),
    HARD(3, VarbitID.CA_TOTAL_TASKS_COMPLETED_HARD),
    ELITE(4, VarbitID.CA_TOTAL_TASKS_COMPLETED_ELITE),
    MASTER(5, VarbitID.CA_TOTAL_TASKS_COMPLETED_MASTER),
    GRANDMASTER(6, VarbitID.CA_TOTAL_TASKS_COMPLETED_GRANDMASTER);

    private final int id;
    private final int varbit;

    public int getCompletedCount(Client client) {
        // https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cca_tasks_completed_tier%5D.cs2
        client.runScript(4784, id);
        return client.getIntStack()[0];
    }
}

package com.runeprofile.data;

import lombok.Data;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Data
public class PlayerData {
    private String id;
    private String username;
    private Integer accountType;

    @Nullable
    private PlayerClanData clan;

    // skill name -> xp
    private Map<String, Integer> skills = new HashMap<>();

    // quest id -> quest state
    private Map<Integer, Integer> quests = new HashMap<>();

    // tier id -> completed count
    private Map<Integer, Integer> combatAchievementTiers = new HashMap<>();

    private List<AchievementDiaryTierData> achievementDiaryTiers = new ArrayList<>();

    // item id -> quantity
    private Map<Integer, Integer> items = new HashMap<>();
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class DefaultClogPageData {
    // account id
    private final String id;
    // clog page name
    private final String page;
}

package com.runeprofile.data;


import lombok.Getter;
import lombok.RequiredArgsConstructor;

import javax.annotation.Nullable;

@RequiredArgsConstructor
@Getter
public class PlayerModelData {
    private final String accountHash;
    private final byte[] model;
    @Nullable
    private final byte[] petModel;
}

package com.runeprofile.data;

import lombok.Data;

import java.util.List;

@Data
public class CollectionLogPage {
    private final String name;
    private final List<CollectionLogItem> items;
}

package com.runeprofile.data;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum AchievementDiary {
    KARAMJA(0),
    ARDOUGNE(1),
    FALADOR(2),
    FREMENNIK(3),
    KANDARIN(4),
    DESERT(5),
    LUMBRIDGE(6),
    MORYTANIA(7),
    VARROCK(8),
    WILDERNESS(9),
    WESTERN_PROVINCES(10),
    KOUREND(11);

    private final int id;

    public int[] getTiersCompletedCount(Client client) {
        // https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cdiary_completion_info%5D.cs2
        client.runScript(2200, id);
        int[] stack = client.getIntStack();

        int easy = stack[0];
        int medium = stack[3];
        int hard = stack[6];
        int elite = stack[9];

        return new int[]{easy, medium, hard, elite};
    }
}

package com.runeprofile.data;

import lombok.Data;

@Data
public class CollectionLogItem {
    private final int id;
    private final int quantity;
}
package com.runeprofile.data;

import lombok.Data;


@Data
public class ProfileSearchResult {
    private final String username;
}

package com.runeprofile.data.activities;

public interface ActivityData {
}

package com.runeprofile.data.activities;

import lombok.Getter;

@Getter
public abstract class Activity<T extends ActivityData> {
    private final String type;
    private final T data;

    protected Activity(String type, T data) {
        this.type = type;
        this.data = data;
    }
}

package com.runeprofile.data.activities;

import lombok.Getter;

@Getter
public class ValuableDropActivity extends Activity<ValuableDropActivity.Data> {
    public ValuableDropActivity(ValuableDropActivity.Data data) {
        super("valuable_drop", data);
    }

    @lombok.Data
    public static class Data implements ActivityData {
        private final int itemId;
        private final int value;
    }
}

package com.runeprofile.autosync;

import com.runeprofile.RuneProfilePlugin;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.events.*;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@Singleton
public class CollectionLogWidgetSubscriber {
    @Inject
    private EventBus eventBus;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    @Inject
    private Client client;

    @Inject
    private PlayerDataService playerDataService;

    @Inject
    private RuneProfilePlugin plugin;

    @Setter
    private boolean isManualSync = false;

    private boolean isAutoClogRetrieval = false;

    private int tickCollectionLogScriptFired = -1;

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    public void reset() {
        isAutoClogRetrieval = false;
        isManualSync = false;
        tickCollectionLogScriptFired = -1;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.HOPPING && gameState != GameState.LOGGED_IN) {
            reset();
        }
    }

    // Code from: WikiSync
    // Repository: https://github.com/weirdgloop/WikiSync
    // License: BSD 2-Clause License
    @Subscribe
    public void onGameTick(GameTick gameTick) {
        int tick = client.getTickCount();
        boolean hasClogScriptFired = tickCollectionLogScriptFired != -1;
        boolean hasBufferPassed = tickCollectionLogScriptFired + 2 < tick;
        if (hasClogScriptFired && hasBufferPassed) {
            tickCollectionLogScriptFired = -1;
            log.debug("Clog items script has fired, is manual sync: {}", isManualSync);
            if (isManualSync) {
                scheduledExecutorService.execute(() -> plugin.updateProfileAsync(false));
                isManualSync = false;
            }
            isAutoClogRetrieval = false;
        }
    }

    // Code from: WikiSync
    // Repository: https://github.com/weirdgloop/WikiSync
    // License: BSD 2-Clause License
    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();

            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int quantity = (int) args[2];

            playerDataService.storeItem(itemId, quantity);
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        final int COLLECTION_LOG_SETUP = 7797;
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP) {
            // disallow updating from the adventure log, to avoid players updating their profile
            // while viewing other players collection logs using the POH adventure log.
            boolean isOpenedFromAdventureLog = client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
            if (isOpenedFromAdventureLog) {
                playerDataService.clearItems();
                return;
            }

            if (isAutoClogRetrieval) {
                return;
            }

            isAutoClogRetrieval = true;
            client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
            client.runScript(2240);
        }
    }

    // fail-safe to clear stored items if the collection log is opened from the adventure log
    @Subscribe
    public void onVarbitChanged(VarbitChanged varbitChanged) {
        if (varbitChanged.getVarbitId() == VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) {
            boolean isOpenedFromAdventureLog = client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
            if (isOpenedFromAdventureLog) {
                log.debug("Collection log opened from adventure log, clearing stored items to avoid incorrect updates.");
                playerDataService.clearItems();
            }
        }
    }
}

package com.runeprofile.autosync;

import com.runeprofile.RuneProfileConfig;
import com.runeprofile.utils.ItemSearcher;
import com.runeprofile.utils.PlayerState;
import com.runeprofile.utils.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class CollectionNotificationSubscriber {
    @Inject
    private EventBus eventBus;

    @Inject
    private Client client;

    @Inject
    private RuneProfileConfig config;

    @Inject
    private AutoSyncScheduler autoSyncScheduler;

    @Inject
    private PlayerDataService playerDataService;

    @Inject
    private ItemSearcher itemSearcher;

    private static final Pattern NEW_ITEM_REGEX = Pattern.compile("New item added to your collection log: (?<itemName>(.*))");
    private static final int POPUP_PREFIX_LENGTH = "New item:".length();

    private final AtomicBoolean popupStarted = new AtomicBoolean(false);

    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    private boolean isEnabled() {
        return config.autosyncProfile() && PlayerState.isValidPlayerState(client);
    }

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    public void reset() {
        popupStarted.set(false);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.HOPPING && gameState != GameState.LOGGED_IN) {
            reset();
        }
    }

    // Code from: DinkPlugin
    // Repository: https://github.com/pajlads/DinkPlugin
    // License: BSD 2-Clause License
    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE || client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM) != 1 || !isEnabled()) {
            return;
        }

        Matcher matcher = NEW_ITEM_REGEX.matcher(chatMessage.getMessage());
        if (matcher.find()) {
            String itemName = matcher.group("itemName");
            handleAutosync(itemName);
            log.debug("Chat message found for new item: {}", itemName);
        }
    }

    // Code from: DinkPlugin
    // Repository: https://github.com/pajlads/DinkPlugin
    // License: BSD 2-Clause License
    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        final int scriptId = event.getScriptId();
        if (scriptId == ScriptID.NOTIFICATION_START) {
            popupStarted.set(true);
        } else if (scriptId == ScriptID.NOTIFICATION_DELAY) {
            String topText = client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT);
            if (popupStarted.getAndSet(false) && "Collection log".equalsIgnoreCase(topText) && isEnabled()) {
                String bottomText = Utils.sanitize(client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT));
                String itemName = bottomText.substring(POPUP_PREFIX_LENGTH).trim();
                handleAutosync(itemName);
                log.debug("Script fired for new item: {}", itemName);
            }
        }
    }

    private void handleAutosync(String itemName) {
        Integer itemId = itemSearcher.findItemId(itemName);
        if (itemId == null) {
            log.debug("Failed to find item ID for: {}", itemName);
            return;
        }
        playerDataService.storeItem(itemId, 1);
        autoSyncScheduler.startRapidSync();
    }
}

package com.runeprofile.autosync;

import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Singleton
public class AutoSyncScheduler {
    @Inject
    private EventBus eventBus;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    @Inject
    private Client client;

    @Inject
    private RuneProfilePlugin plugin;

    @Inject
    private RuneProfileConfig config;

    // A reference to the pending auto-sync task
    private ScheduledFuture<?> autoSyncFuture;

    // Prevent multiple sync executions from overlapping
    private final AtomicBoolean isSyncing = new AtomicBoolean(false);

    private static final int RAPID_SYNC_SECONDS = 3;
    private static final int AUTO_SYNC_MINUTES = 60;

    public boolean isEnabled() {
        return config.autosyncProfile();
    }

    public void startUp() {
        eventBus.register(this);
        if (isEnabled()) {
            resetAutoSyncTimer();
        }
    }

    public void shutDown() {
        eventBus.unregister(this);
        cancelScheduledSync();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(RuneProfilePlugin.CONFIG_GROUP)) return;

        if (isEnabled()) {
            resetAutoSyncTimer();
        } else {
            cancelScheduledSync();
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (!isEnabled()) return;

        if (event.getGameState() != GameState.LOGGED_IN) {
            log.debug("Player not logged in, cancelling scheduled sync.");
            cancelScheduledSync();
        } else if (event.getGameState() == GameState.LOGGED_IN) {
            log.debug("Player logged in, resetting auto-sync timer.");
            resetAutoSyncTimer();
        }
    }

    /**
     * Called when a rapid sync is requested.
     * Cancels any existing scheduled sync and schedules a sync after 3 seconds.
     */
    public synchronized void startRapidSync() {
        log.debug("Starting rapid sync...");
        cancelScheduledSync();
        // Schedule a sync in 3 seconds, then resume normal cycle
        autoSyncFuture = scheduledExecutorService.schedule(() -> {
            performSync();
            scheduleNextSync();
        }, RAPID_SYNC_SECONDS, TimeUnit.SECONDS);
    }

    /**
     * Resets the auto-sync cycle.
     */
    public synchronized void resetAutoSyncTimer() {
        if (!isEnabled()) {
            log.debug("Auto-sync is disabled; ignoring reset request.");
            return;
        }

        scheduleNextSync();
    }

    /**
     * Schedules the next sync after the specified delay.
     */
    private synchronized void scheduleNextSync() {
        log.debug("Next sync scheduled in {} minutes", AUTO_SYNC_MINUTES);
        cancelScheduledSync();
        autoSyncFuture = scheduledExecutorService.schedule(() -> {
            performSync();
            scheduleNextSync();
        }, AutoSyncScheduler.AUTO_SYNC_MINUTES, TimeUnit.MINUTES);
    }

    private synchronized void cancelScheduledSync() {
        if (autoSyncFuture != null) {
            autoSyncFuture.cancel(false);
            autoSyncFuture = null;
        }
    }

    /**
     * Performs the actual sync, ensuring only one sync runs at a time.
     */
    private void performSync() {
        if (!isSyncing.compareAndSet(false, true)) {
            log.debug("Sync already in progress, skipping...");
            return;
        }

        log.debug("Syncing profile...");
        try {
            plugin.updateProfileAsync(true);
        } finally {
            isSyncing.set(false);
        }
    }
}
package com.runeprofile.autosync;

import com.runeprofile.RuneProfileConfig;
import com.runeprofile.data.*;
import com.runeprofile.modelexporter.ModelExporter;
import com.runeprofile.utils.AccountHash;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Singleton
public class PlayerDataService {
    @Inject
    private EventBus eventBus;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private RuneProfileConfig config;

    // Clog items are not available through the client API, so we store them manually on clog open or item collection.
    // See: CollectionLogWidgetSubscriber and CollectionNotificationSubscriber
    private final Map<Integer, Integer> clogItems = new HashMap<>();

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    public void reset() {
        clearItems();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.LOGGED_IN) {
            log.debug("Game state changed to {}, resetting player data service", gameState);
            reset();
        }
    }

    public void storeItem(int itemId, int quantity) {
        if (quantity <= 0) return;
        clogItems.put(itemId, quantity);
    }

    public void clearItems() {
        clogItems.clear();
    }

    public CompletableFuture<String> getAccountIdAsync() {
        CompletableFuture<String> accountIdFuture = new CompletableFuture<>();
        clientThread.invokeLater(() -> {
            String accountId = AccountHash.getHashed(client);
            accountIdFuture.complete(accountId);
        });
        return accountIdFuture;
    }

    public CompletableFuture<PlayerData> getPlayerDataAsync() {
        CompletableFuture<PlayerData> playerDataFuture = new CompletableFuture<>();
        clientThread.invokeLater(() -> {
            PlayerData playerData = new PlayerData();

            Player player = client.getLocalPlayer();
            String username = player.getName();

            // general
            playerData.setId(AccountHash.getHashed(client));
            playerData.setUsername(username);
            playerData.setAccountType(client.getVarbitValue(VarbitID.IRONMAN));

            // clan
            playerData.setClan(getPlayerClanData(player));

            // skills
            for (Skill skill : Skill.values()) {
                String name = skill.getName();
                int xp = client.getSkillExperience(skill);
                playerData.getSkills().put(name, xp);
            }

            // quests
            for (Quest quest : Quest.values()) {
                int id = quest.getId();
                QuestState stateEnum = quest.getState(client);
                int state = 0;
                if (stateEnum == QuestState.IN_PROGRESS) {
                    state = 1;
                } else if (stateEnum == QuestState.FINISHED) {
                    state = 2;
                }
                playerData.getQuests().put(id, state);
            }

            // combat achievement tiers
            for (CombatAchievementTier tier : CombatAchievementTier.values()) {
                int id = tier.getId();
                int completedCount = tier.getCompletedCount(client);
                playerData.getCombatAchievementTiers().put(id, completedCount);
            }

            // achievement diary tiers
            for (AchievementDiary diary : AchievementDiary.values()) {
                int areaId = diary.getId();
                int[] completedCounts = diary.getTiersCompletedCount(client);
                for (int tierIndex = 0; tierIndex < completedCounts.length; tierIndex++) {
                    int completedCount = completedCounts[tierIndex];
                    playerData.getAchievementDiaryTiers().add(new AchievementDiaryTierData(areaId, tierIndex, completedCount));
                }
            }

            // items
            playerData.setItems(clogItems);

            log.debug("Player Data: {}", playerData);
            playerDataFuture.complete(playerData);
        });
        return playerDataFuture;
    }

    public PlayerClanData getPlayerClanData(Player player) {
        if (!config.includeClanData()) return new PlayerClanData("", -1, -1, "");

        ClanSettings clanSettings = client.getClanSettings();
        if (clanSettings == null) return new PlayerClanData("", -1, -1, ""); // not in a clan

        ClanMember member = clanSettings.findMember(player.getName());
        if (member == null) return null;

        ClanRank rank = member.getRank();
        if (rank == null) return null;

        ClanTitle title = clanSettings.titleForRank(rank);
        if (title == null) return null;

        return new PlayerClanData(clanSettings.getName(), rank.getRank(), title.getId(), title.getName());
    }

    public CompletableFuture<PlayerModelData> getPlayerModelDataAsync() {
        CompletableFuture<PlayerModelData> dataFuture = new CompletableFuture<>();
        clientThread.invokeLater(() -> {
            String accountHash = AccountHash.getHashed(client);

            Player player = client.getLocalPlayer();
            Model model = player.getModel();

            byte[] modelBytes = null;
            try {
                modelBytes = ModelExporter.toBytes(client, model);
            } catch (IOException e) {
                dataFuture.completeExceptionally(e);
                return;
            }

            NPC pet = client.getFollower();
            Model petModel = pet != null ? pet.getModel() : null;

            byte[] petModelBytes = null;
            if (petModel != null) {
                try {
                    petModelBytes = ModelExporter.toBytes(client, petModel);
                } catch (IOException e) {
                    dataFuture.completeExceptionally(e);
                    return;
                }
            }

            dataFuture.complete(new PlayerModelData(accountHash, modelBytes, petModelBytes));
        });
        return dataFuture;
    }
}

package com.runeprofile.autosync;

import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.data.activities.ValuableDropActivity;
import com.runeprofile.utils.ItemUtils;
import com.runeprofile.utils.PlayerState;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.http.api.loottracker.LootRecordType;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@Singleton
public class ValuableDropSubscriber {
    @Inject
    private EventBus eventBus;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private RuneProfilePlugin plugin;

    @Inject
    private RuneProfileConfig config;

    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    private boolean isEnabled() {
        return config.autosyncProfile() && config.trackValuableDrops() && PlayerState.isValidPlayerState(client);
    }

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    @Subscribe
    public void onLootReceived(LootReceived event) {
        if (!isEnabled() || event.getType() == LootRecordType.PLAYER) {
            return;
        }

        handleItemsReceived(event.getItems());
    }

    private void handleItemsReceived(Collection<ItemStack> items) {
        List<ValuableDropActivity> valuableDrops = new ArrayList<>();

        for (ItemStack itemStack : items) {
            ItemComposition item = itemManager.getItemComposition(itemStack.getId());
            int itemId = ItemUtils.getUnnotedItemId(item);
            int value = ItemUtils.getPerceivedItemValue(itemManager, itemId);

            if (value >= ItemUtils.VALUABLE_DROP_THRESHOLD) {
                for (int i = 0; i < itemStack.getQuantity(); i++) {
                    log.debug("Valuable drop detected: {} (ID: {}, Value: {})", item.getName(), itemId, value);
                    // Add each item as a separate drop
                    valuableDrops.add(new ValuableDropActivity(new ValuableDropActivity.Data(itemId, value)));
                }
            }
        }

        if (valuableDrops.isEmpty()) {
            return;
        }

        scheduledExecutorService.execute(() -> plugin.addActivitiesAsync(valuableDrops));
    }
}

package com.runeprofile.panels;

import com.runeprofile.utils.Icon;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class HeaderPanel extends JPanel {
    private static final int iconSize = 16;
    private final JPanel buttonsContainer;

    public HeaderPanel() {
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 10, 10, 10));

        JLabel title = new JLabel("RuneProfile");
        title.setForeground(Color.WHITE);
        title.setFont(FontManager.getRunescapeBoldFont());

        buttonsContainer = new JPanel();
        buttonsContainer.setLayout(new GridLayout(1, 2, 4, 0));

        addHeaderButton(Icon.DISCORD.getIcon(iconSize, iconSize), "Join the Discord", "https://discord.com/invite/6XgBcePAfj");
        addHeaderButton(Icon.WEB.getIcon(iconSize, iconSize), "Visit the website.", "https://runeprofile.com");
        addHeaderButton(Icon.GITHUB.getIcon(iconSize, iconSize), "Report issues or contribute.", "https://github.com/ReinhardtR/runeprofile");

        add(title, BorderLayout.WEST);
        add(buttonsContainer, BorderLayout.EAST);
    }

    private void addHeaderButton(ImageIcon icon, String tooltip, String url) {
        JButton button = new JButton();
        SwingUtil.removeButtonDecorations(button);

        button.setIcon(icon);
        button.setToolTipText(tooltip);
        button.addActionListener(e -> LinkBrowser.browse(url));

        button.setUI(new BasicButtonUI());
        button.setBackground(ColorScheme.DARK_GRAY_COLOR);
        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }
        });

        buttonsContainer.add(button);
    }
}

package com.runeprofile.panels;

import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.utils.DevTools;
import com.runeprofile.utils.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;

@Slf4j
public class MainButtonsPanel extends JPanel {
    @Inject
    public MainButtonsPanel(RuneProfilePlugin plugin, Client client, DevTools devTools) {
        setLayout(new BorderLayout());
        JPanel wrapper = new JPanel(new GridLayout(0, 1, 0, 6));

        // Update Model
        JButton updateModelButton = createButton("Update Player Model");
        updateModelButton.addActionListener((e) -> plugin.updateModelAsync());
        wrapper.add(updateModelButton);

        // Open Profile
        JButton openProfileButton = createButton("Open Profile");
        openProfileButton.addActionListener(e -> {
            String username = client.getLocalPlayer().getName();
            if (username == null) return;
            Utils.openProfileInBrowser(username);
        });

        wrapper.add(openProfileButton);

        if (plugin.isDeveloperMode()) {
            // DEV ONLY - generate hiscores icons
            JButton generateHiscoreIcons = createButton("DEV: Hiscores Icons");
            generateHiscoreIcons.addActionListener(e -> {
                devTools.generateHiscoreIconsJson();
            });
            wrapper.add(generateHiscoreIcons);

            // DEV ONLY - generate clan rank icons
            JButton generateClanRankIcons = createButton("DEV: Clan Rank Icons");
            generateClanRankIcons.addActionListener(e -> {
                devTools.generateClanRankIconsJson();
            });
            wrapper.add(generateClanRankIcons);
        }

        add(wrapper, BorderLayout.NORTH);
    }

    private JButton createButton(String text) {
        JButton button = new JButton(text);
        button.setPreferredSize(new Dimension(button.getPreferredSize().width, 30));
        return button;
    }
}


package com.runeprofile.panels;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class LayoutPluginPanel extends JPanel {
    @Inject
    public LayoutPluginPanel(MainButtonsPanel mainButtonsPanel, SearchPanel searchPanel) {
        setLayout(new BorderLayout());

        // Main content panel with vertical (flex-column-like) layout
        JPanel contentPanel = new JPanel();
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.setBorder(new EmptyBorder(10, 10, 10, 10)); // padding around entire content

        // Create and add components
        mainButtonsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(mainButtonsPanel);
        mainButtonsPanel.setMaximumSize(new Dimension(Short.MAX_VALUE, mainButtonsPanel.getPreferredSize().height)); // Limit vertical growth

        contentPanel.add(Box.createVerticalStrut(32)); // spacing between components

        searchPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
        contentPanel.add(searchPanel);
        searchPanel.setMaximumSize(new Dimension(Short.MAX_VALUE, searchPanel.getPreferredSize().height)); // Limit initial vertical growth

        contentPanel.add(Box.createVerticalGlue());

        JScrollPane scrollPane = new JScrollPane(contentPanel);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        add(scrollPane, BorderLayout.CENTER);
    }
}
package com.runeprofile.panels;

import com.runeprofile.RuneProfileApiClient;
import com.runeprofile.data.ProfileSearchResult;
import com.runeprofile.utils.RuneProfileApiException;
import com.runeprofile.utils.UsernameAutocompleter;
import com.runeprofile.utils.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Arrays;
import java.util.List;

@Slf4j
public class SearchPanel extends JPanel {
    private final JPanel resultsPanel;
    private final IconTextField searchField;

    @Inject
    public SearchPanel(RuneProfileApiClient runeProfileApiClient, UsernameAutocompleter usernameAutocompleter) {
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        JLabel title = new JLabel("Search profiles");
        title.setAlignmentX(Component.LEFT_ALIGNMENT);
        add(title);

        searchField = new IconTextField();
        searchField.setIcon(IconTextField.Icon.SEARCH);
        searchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchField.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        searchField.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        searchField.setMinimumSize(new Dimension(0, 30));
        searchField.setAlignmentX(Component.LEFT_ALIGNMENT);
        searchField.setAlignmentY(Component.TOP_ALIGNMENT);

        add(Box.createVerticalStrut(5));
        add(searchField);
        add(Box.createVerticalStrut(5));

        resultsPanel = new JPanel();
        resultsPanel.setLayout(new BoxLayout(resultsPanel, BoxLayout.Y_AXIS));
        resultsPanel.setAlignmentY(Component.TOP_ALIGNMENT);
        resultsPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

        searchField.addKeyListener(usernameAutocompleter);
        searchField.addKeyListener(new KeyAdapter() {
            @Override
            public void keyTyped(KeyEvent e) {
                String query = Text.sanitize(searchField.getText());
                if (query.isEmpty()) resultsPanel.removeAll();
            }
        });
        searchField.addClearListener(resultsPanel::removeAll);
        searchField.addActionListener(
                (e) -> {
                    String query = Text.sanitize(searchField.getText());
                    if (query.isEmpty()) resultsPanel.removeAll();

                    if (!query.isEmpty()) {
                        runeProfileApiClient.searchProfiles(query).whenComplete((results, ex) -> {
                            if (ex != null) {
                                log.error("Error searching profiles: ", ex);

                                if (ex instanceof RuneProfileApiException) {
                                    updateErrors("Error: " + ex.getMessage());
                                } else {
                                    updateErrors("An unexpected error occurred.");
                                }

                                return;
                            }
                            updateResults(Arrays.asList(results));
                        });
                    }
                }
        );

        add(resultsPanel);
    }

    private void updateErrors(String errorMessage) {
        resultsPanel.removeAll();
        JLabel errorLabel = new JLabel(errorMessage);
        errorLabel.setForeground(Color.RED);
        resultsPanel.add(errorLabel);
        resultsPanel.revalidate();
        resultsPanel.repaint();
    }

    private void updateResults(List<ProfileSearchResult> results) {
        resultsPanel.removeAll();

        if (results.isEmpty()) {
            JLabel noResults = new JLabel("No results found.");
            noResults.setForeground(Color.LIGHT_GRAY);
            resultsPanel.add(noResults);
        } else {
            for (int i = 0; i < results.size(); i++) {
                JButton resultButton = getResultButton(results, i);
                resultsPanel.add(resultButton);
            }
        }

        resultsPanel.revalidate();
        resultsPanel.repaint();
    }

    private JButton getResultButton(List<ProfileSearchResult> results, int i) {
        ProfileSearchResult result = results.get(i);

        JButton resultButton = new JButton(result.getUsername());
        int buttonHeight = 30;
        resultButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, buttonHeight));
        resultButton.setPreferredSize(new Dimension(resultsPanel.getWidth(), buttonHeight));
        resultButton.setMinimumSize(new Dimension(0, buttonHeight));
        resultButton.setAlignmentX(Component.LEFT_ALIGNMENT);
        resultButton.setToolTipText("Open in browser");

        resultButton.addActionListener((e) -> Utils.openProfileInBrowser(result.getUsername()));
        return resultButton;
    }
}

package com.runeprofile.panels;

import net.runelite.client.ui.FontManager;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class InvalidPanel extends JPanel {
    private final JLabel hintText = new JLabel();

    public InvalidPanel() {
        setBorder(new EmptyBorder(50, 10, 0, 10));
        setLayout(new BorderLayout());

        JPanel wrapper = new JPanel(new BorderLayout());

        JLabel titleText = new JLabel("RuneProfile");
        titleText.setFont(FontManager.getRunescapeFont());
        titleText.setForeground(Color.WHITE);
        titleText.setHorizontalAlignment(SwingConstants.CENTER);
        wrapper.add(titleText, BorderLayout.NORTH);

        hintText.setFont(FontManager.getRunescapeSmallFont());
        hintText.setForeground(Color.GRAY);
        hintText.setHorizontalAlignment(SwingConstants.CENTER);
        wrapper.add(hintText, BorderLayout.CENTER);

        add(wrapper, BorderLayout.NORTH);
    }

    public void setHintText(String text) {
        SwingUtilities.invokeLater(() -> hintText.setText(text));
    }
}

package com.runeprofile.ui;

import com.runeprofile.RuneProfileApiClient;
import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.data.CollectionLogItem;
import com.runeprofile.data.CollectionLogPage;
import com.runeprofile.utils.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
public class CollectionLogCommand {
    @Inject
    private EventBus eventBus;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ChatCommandManager chatCommandManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private RuneProfileConfig config;

    @Inject
    private RuneProfileApiClient runeProfileApiClient;

    private final Map<Integer, Integer> loadedItemIcons = new HashMap<>();
    private final String COLLECTION_LOG_COMMAND = "!log";
    private final Pattern COLLECTION_LOG_COMMAND_PATTERN = Pattern.compile("^(" + COLLECTION_LOG_COMMAND + ")\\s+([a-zA-Z]+(?: [a-zA-Z]+)*)$", Pattern.CASE_INSENSITIVE);

    public void startUp() {
        eventBus.register(this);

        if (config.enableLogCommand()) {
            chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeLogCommand);
        }
    }

    public void shutDown() {
        eventBus.unregister(this);

        chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(RuneProfilePlugin.CONFIG_GROUP)) return;

        if (config.enableLogCommand()) {
            chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeLogCommand);
        } else {
            chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
        }
    }

    private void executeLogCommand(ChatMessage chatMessage, String message) {
        log.debug("Executing log command: {}", message);
        Matcher commandMatcher = COLLECTION_LOG_COMMAND_PATTERN.matcher(message);
        if (!commandMatcher.matches()) {
            log.debug("Invalid command format");
            return;
        }

        String pageName = commandMatcher.group(2);
        if (pageName == null || pageName.isEmpty()) {
            log.debug("Invalid page name");
            return;
        }

        String senderName = chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT)
                ? client.getLocalPlayer().getName()
                : Text.sanitize(chatMessage.getName());

        runeProfileApiClient.getCollectionLogPage(senderName, pageName).whenComplete((page, ex) -> {
            clientThread.invokeLater(() -> {
                if (ex != null) {
                    final String errorMessage = Utils.getApiErrorMessage(ex, "Failed to load collection log page.");
                    updateChatMessage(chatMessage, errorMessage);
                    return;
                }

                loadPageIcons(page);

                List<CollectionLogItem> items = page.getItems();
                StringBuilder itemBuilder = new StringBuilder();
                for (CollectionLogItem item : items) {
                    if (item.getQuantity() < 1) continue;

                    String itemString = "<img=" + loadedItemIcons.get(item.getId()) + ">";

                    if (config.enableExtendedItemNames()) {
                        String itemName = itemManager.getItemComposition(item.getId()).getName();
                        itemString += " " + itemName + " ";
                    }

                    if (item.getQuantity() > 1) {
                        itemString += "x" + item.getQuantity();
                    }
                    itemString += "  ";
                    itemBuilder.append(itemString);
                }

                int obtainedItemsCount = (int) items.stream().filter(item -> item.getQuantity() > 0).count();
                int totalItemsCount = items.size();

                final String replacementMessage = page.getName() + " " + "(" + obtainedItemsCount + "/" + totalItemsCount + ")" + " : " + itemBuilder;
                updateChatMessage(chatMessage, replacementMessage);
            });
        });
    }

    private void loadPageIcons(CollectionLogPage page) {
        List<CollectionLogItem> itemsToLoad = page.getItems()
                .stream()
                .filter(item -> !loadedItemIcons.containsKey(item.getId()))
                .collect(Collectors.toList());

        final IndexedSprite[] modIcons = client.getModIcons();

        final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + itemsToLoad.size());
        int modIconIdx = modIcons.length;

        for (int i = 0; i < itemsToLoad.size(); i++) {
            final CollectionLogItem item = itemsToLoad.get(i);
            final ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
            final BufferedImage image = ImageUtil.resizeImage(itemManager.getImage(itemComposition.getId()), 18, 16);
            final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);
            final int spriteIndex = modIconIdx + i;

            newModIcons[spriteIndex] = sprite;
            loadedItemIcons.put(item.getId(), spriteIndex);
        }

        client.setModIcons(newModIcons);
    }

    private void updateChatMessage(ChatMessage chatMessage, String message) {
        chatMessage.getMessageNode().setRuneLiteFormatMessage(message);
        client.runScript(ScriptID.BUILD_CHATBOX);
    }
}

package com.runeprofile.ui;

import com.runeprofile.RuneProfileApiClient;
import com.runeprofile.data.DefaultClogPageData;
import com.runeprofile.utils.AccountHash;
import com.runeprofile.utils.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Singleton
public class CollectionLogPageMenuOption {
    @Inject
    private EventBus eventBus;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private RuneProfileApiClient runeProfileApiClient;

    private static final List<Integer> collectionLogPageIds = Arrays.asList(40697867, 40697871, 40697888, 40697883, 40697890);

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    @Subscribe
    @SuppressWarnings("unused")
    public void onMenuEntryAdded(MenuEntryAdded event) {
        boolean isCollectionLogPageList = collectionLogPageIds.stream()
                .anyMatch(id -> id == event.getActionParam1());

        if (!isCollectionLogPageList) {
            return;
        }

        String target = event.getTarget();
        if (target.isEmpty()) {
            return;
        }

        String pageName = Utils.sanitize(target);

        client.getMenu().createMenuEntry(-2)
                .setTarget(target)
                .setOption("RuneProfile Default")
                .setType(MenuAction.RUNELITE)
                .setIdentifier(event.getIdentifier())
                .onClick(e -> setDefaultPage(pageName));

    }

    private void setDefaultPage(String pageName) {
        CompletableFuture<DefaultClogPageData> dataFuture = new CompletableFuture<>();

        clientThread.invokeLater(() -> {
            dataFuture.complete(
                    new DefaultClogPageData(
                            AccountHash.getHashed(client),
                            pageName
                    )
            );
        });

        dataFuture.thenCompose(runeProfileApiClient::setDefaultClogPage).whenComplete((result, ex) -> {
            clientThread.invokeLater(() -> {
                String message = ex != null
                        ? Utils.getApiErrorMessage(ex, "Failed to set default collection log page.")
                        : "Default collection log page set to: " + pageName;

                client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", message, "RuneProfile");
            });
        });
    }
}

package com.runeprofile.ui;

import com.google.inject.Inject;
import com.runeprofile.RuneProfileConfig;
import com.runeprofile.RuneProfilePlugin;
import com.runeprofile.autosync.CollectionLogWidgetSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import java.util.*;
import java.util.concurrent.ScheduledExecutorService;

import static java.lang.Math.round;

@Slf4j
public class ManualUpdateButtonManager {
    private static final int DRAW_BURGER_MENU = 7812;
    private static final int FONT_COLOR = 0xFF981F;
    private static final int FONT_COLOR_ACTIVE = 0xFFFFFF;
    private static final String BUTTON_TEXT = "RuneProfile";

    private final Client client;
    private final EventBus eventBus;
    private final ScheduledExecutorService scheduledExecutorService;
    private final RuneProfilePlugin plugin;
    private final RuneProfileConfig config;
    private final CollectionLogWidgetSubscriber collectionLogWidgetSubscriber;

    private int baseMenuHeight = -1;
    private int lastAttemptedUpdate = -1;

    @Inject
    private ManualUpdateButtonManager(
            Client client,
            EventBus eventBus,
            ScheduledExecutorService scheduledExecutorService,
            RuneProfilePlugin plugin,
            RuneProfileConfig config,
            CollectionLogWidgetSubscriber collectionLogWidgetSubscriber
    ) {
        this.client = client;
        this.eventBus = eventBus;
        this.scheduledExecutorService = scheduledExecutorService;
        this.plugin = plugin;
        this.config = config;
        this.collectionLogWidgetSubscriber = collectionLogWidgetSubscriber;
    }

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        if (!config.showClogSyncButton() || event.getScriptId() != DRAW_BURGER_MENU) {
            return;
        }

        Object[] args = event.getScriptEvent().getArguments();
        int menuId = (int) args[3];

        try {
            log.debug("Adding RuneProfile button to menu with ID: {}", menuId);
            addButton(menuId, this::onButtonClick);
        } catch (Exception e) {
            log.debug("Failed to add RuneProfile button to menu: {}", e.getMessage());
        }
    }

    private void onButtonClick() {
        if (lastAttemptedUpdate != -1 && lastAttemptedUpdate + 50 > client.getTickCount()) {
            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Last update within 30 seconds. You can update again in " + round((lastAttemptedUpdate + 50 - client.getTickCount()) * 0.6) + " seconds.", "RuneProfile");
            return;
        }
        lastAttemptedUpdate = client.getTickCount();

        // if there is no items in the collection log, we can't offload the update to the collection log widget subscriber
        // since the script 4100 is never fired.
        int collectionCount = client.getVarpValue(VarPlayerID.COLLECTION_COUNT);
        if (collectionCount == 0) {
            scheduledExecutorService.execute(() -> plugin.updateProfileAsync(false));
        } else {
            collectionLogWidgetSubscriber.setManualSync(true);
            client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
            client.runScript(2240);

            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Updating your profile...", "RuneProfile");
        }
    }

    private void addButton(int menuId, Runnable onClick) throws NullPointerException, NoSuchElementException {
        // disallow updating from the adventure log, to avoid players updating their profile
        // while viewing other players collection logs using the POH adventure log.
        boolean isOpenedFromAdventureLog = client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
        if (isOpenedFromAdventureLog) return;

        Widget menu = Objects.requireNonNull(client.getWidget(menuId));
        Widget[] menuChildren = Objects.requireNonNull(menu.getChildren());

        if (baseMenuHeight == -1) {
            baseMenuHeight = menu.getOriginalHeight();
        }

        List<Widget> reversedMenuChildren = new ArrayList<>(Arrays.asList(menuChildren));
        Collections.reverse(reversedMenuChildren);
        Widget lastRectangle = reversedMenuChildren.stream()
                .filter(w -> w.getType() == WidgetType.RECTANGLE)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("No RECTANGLE widget found in menu"));
        Widget lastText = reversedMenuChildren.stream()
                .filter(w -> w.getType() == WidgetType.TEXT)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("No TEXT widget found in menu"));

        final int buttonHeight = lastRectangle.getHeight();
        final int buttonY = lastRectangle.getOriginalY() + buttonHeight;

        final boolean existingButton = Arrays.stream(menuChildren)
                .anyMatch(w -> w.getText().equals(BUTTON_TEXT));

        if (!existingButton) {
            final Widget background = menu.createChild(WidgetType.RECTANGLE)
                    .setOriginalWidth(lastRectangle.getOriginalWidth())
                    .setOriginalHeight(lastRectangle.getOriginalHeight())
                    .setOriginalX(lastRectangle.getOriginalX())
                    .setOriginalY(buttonY)
                    .setOpacity(lastRectangle.getOpacity())
                    .setFilled(lastRectangle.isFilled());
            background.revalidate();

            final Widget text = menu.createChild(WidgetType.TEXT)
                    .setText(BUTTON_TEXT)
                    .setTextColor(FONT_COLOR)
                    .setFontId(lastText.getFontId())
                    .setTextShadowed(lastText.getTextShadowed())
                    .setOriginalWidth(lastText.getOriginalWidth())
                    .setOriginalHeight(lastText.getOriginalHeight())
                    .setOriginalX(lastText.getOriginalX())
                    .setOriginalY(buttonY)
                    .setXTextAlignment(lastText.getXTextAlignment())
                    .setYTextAlignment(lastText.getYTextAlignment());
            text.setHasListener(true);
            text.setOnMouseOverListener((JavaScriptCallback) ev -> text.setTextColor(FONT_COLOR_ACTIVE));
            text.setOnMouseLeaveListener((JavaScriptCallback) ev -> text.setTextColor(FONT_COLOR));
            text.setAction(0, "Update your RuneProfile");
            text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());
            text.revalidate();
        }

        if (menu.getOriginalHeight() <= baseMenuHeight) {
            menu.setOriginalHeight((menu.getOriginalHeight() + buttonHeight));
        }

        menu.revalidate();
        for (Widget child : menuChildren) {
            child.revalidate();
        }
    }
}
package com.runeprofile.ui;

import com.google.common.collect.ImmutableList;
import com.runeprofile.RuneProfileConfig;
import com.runeprofile.utils.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;

@Slf4j
public class ChatPlayerMenuOption {
    @Inject
    private EventBus eventBus;

    @Inject
    private Client client;

    @Inject
    private RuneProfileConfig config;

    // menu option
    private static final String KICK_OPTION = "Kick";
    private static final ImmutableList<String> AFTER_OPTIONS = ImmutableList.of("Message", "Add ignore", "Remove friend", "Delete", KICK_OPTION);

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        if (!config.showMenuLookupOption()) return;

        int groupId = WidgetUtil.componentToInterface(event.getActionParam1());
        String option = event.getOption();

        if (!AFTER_OPTIONS.contains(option)
                // prevent duplicate menu options in friends list
                || (option.equals("Delete") && groupId != InterfaceID.IGNORE)) {
            return;
        }

        boolean addMenuLookup = (groupId == InterfaceID.FRIENDS
                || groupId == InterfaceID.CHATCHANNEL_CURRENT
                || groupId == InterfaceID.CLANS_SIDEPANEL
                || groupId == InterfaceID.CLANS_GUEST_SIDEPANEL
                // prevent from adding for Kick option (interferes with the raiding party one)
                || groupId == InterfaceID.CHATBOX && !KICK_OPTION.equals(option)
                || groupId == InterfaceID.RAIDS_SIDEPANEL
                || groupId == InterfaceID.PM_CHAT
                || groupId == InterfaceID.IGNORE);

        if (addMenuLookup) {
            String username = Text.toJagexName(Text.removeTags(event.getTarget()));

            client.getMenu().createMenuEntry(-2)
                    .setTarget(event.getTarget())
                    .setOption("RuneProfile")
                    .setType(MenuAction.RUNELITE)
                    .setIdentifier(event.getIdentifier())
                    .onClick(e -> Utils.openProfileInBrowser(username));
        }
    }
}

package com.runeprofile;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(RuneProfilePlugin.CONFIG_GROUP)
public interface RuneProfileConfig extends Config {
    @ConfigItem(
            keyName = "update_on_logout", // config option was previously used only for update on logout
            name = "Auto-sync Profile",
            description = "Automatically updates your RuneProfile for you.",
            position = 1
    )
    default boolean autosyncProfile() {
        return true;
    }

    @ConfigItem(
            keyName = "track_valuable_drops",
            name = "Track Valuable Drops",
            description = "Adds valuable drops to your RuneProfile activities. (Requires auto-sync to be enabled)",
            position = 2
    )
    default boolean trackValuableDrops() {
        return true;
    }

    @ConfigItem(
            keyName = "include_clan_data",
            name = "Include Clan in Profile",
            description = "Include your clan on your RuneProfile.",
            position = 3
    )
    default boolean includeClanData() {
        return true;
    }

    @ConfigItem(
            keyName = "log_command",
            name = "Enable !log command",
            description = "Enables the !log command in the game chat.",
            position = 4
    )
    default boolean enableLogCommand() {
        return true;
    }

    @ConfigItem(
            keyName = "enableExtendedItemNames",
            name = "Show item names for !log",
            description = "Show item names next to their icons in the collection log command.",
            position = 5
    )
    default boolean enableExtendedItemNames()
    {
        return false;
    }

    @ConfigItem(
            keyName = "show_clog_sync_button",
            name = "Enable RuneProfile Sync button",
            description = "Shows the RuneProfile button in the Collection Log menu.",
            position = 6
    )
    default boolean showClogSyncButton() {
        return true;
    }

    @ConfigItem(
            keyName = "menu_lookup_option",
            name = "Chat menu option",
            description = "Add RuneProfile option to chat menus",
            position = 7
    )
    default boolean showMenuLookupOption() {
        return false;
    }

    @ConfigItem(
            keyName = "show_side_panel",
            name = "Show the RuneProfile side panel",
            description = "Adds RuneProfile to the RuneLite plugin side bar.",
            position = 7
    )
    default boolean showSidePanel() {
        return true;
    }
}

package com.runeprofile;

import com.google.inject.Provides;

import com.runeprofile.autosync.*;
import com.runeprofile.data.AddActivities;
import com.runeprofile.data.activities.Activity;
import com.runeprofile.data.activities.ActivityData;
import com.runeprofile.ui.ChatPlayerMenuOption;
import com.runeprofile.ui.CollectionLogCommand;
import com.runeprofile.ui.CollectionLogPageMenuOption;
import com.runeprofile.ui.ManualUpdateButtonManager;
import com.runeprofile.utils.PlayerState;
import com.runeprofile.utils.RuneProfileApiException;
import com.runeprofile.utils.Utils;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

import javax.inject.Inject;
import javax.inject.Named;
import java.util.List;

@Slf4j
@PluginDescriptor(
        name = "RuneProfile"
)
public class RuneProfilePlugin extends Plugin {
    public static final String CONFIG_GROUP = "runeprofile";

    @Inject
    @Named("developerMode")
    @Getter
    private boolean developerMode;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private RuneProfileApiClient runeProfileApiClient;

    @Inject
    private PlayerDataService playerDataService;

    @Inject
    private AutoSyncScheduler autoSyncScheduler;

    @Inject
    private CollectionLogWidgetSubscriber collectionLogWidgetSubscriber;

    @Inject
    private CollectionNotificationSubscriber collectionNotificationSubscriber;

    @Inject
    private ValuableDropSubscriber valuableDropSubscriber;

    @Inject
    private ManualUpdateButtonManager manualUpdateButtonManager;

    @Inject
    private CollectionLogPageMenuOption collectionLogPageMenuOption;

    @Inject
    private ChatPlayerMenuOption chatPlayerMenuOption;

    @Inject
    private CollectionLogCommand collectionLogCommand;

    private RuneProfilePanel runeProfilePanel;

    @Provides
    RuneProfileConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(RuneProfileConfig.class);
    }

    @Override
    protected void startUp() {
        this.runeProfilePanel = injector.getInstance(RuneProfilePanel.class);
        runeProfilePanel.startUp();

        playerDataService.startUp();

        autoSyncScheduler.startUp();
        valuableDropSubscriber.startUp();
        collectionLogWidgetSubscriber.startUp();
        collectionNotificationSubscriber.startUp();

        manualUpdateButtonManager.startUp();
        collectionLogPageMenuOption.startUp();
        chatPlayerMenuOption.startUp();
        collectionLogCommand.startUp();
    }

    @Override
    protected void shutDown() {
        runeProfilePanel.shutDown();

        playerDataService.shutDown();

        autoSyncScheduler.shutDown();
        valuableDropSubscriber.shutDown();
        collectionLogWidgetSubscriber.shutDown();
        collectionNotificationSubscriber.shutDown();

        manualUpdateButtonManager.shutDown();
        collectionLogPageMenuOption.shutDown();
        chatPlayerMenuOption.shutDown();
        collectionLogCommand.shutDown();
    }

    public void updateProfileAsync(boolean isAutoSync) {
        if (!PlayerState.isValidPlayerState(client)) {
            if (!isAutoSync) {
                clientThread.invokeLater(() -> {
                    client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "You are not allowed to update your profile on this world.", "RuneProfile");
                });
            }

            throw new IllegalStateException("Invalid player state");
        }

        if (!isAutoSync) {
            // If this is a manual sync, reset the auto-sync timer
            autoSyncScheduler.resetAutoSyncTimer();
        }

        playerDataService.getPlayerDataAsync().thenCompose((data) -> {
                    // sanity check: a player reported syncs going through on invalid worlds
                    if (!PlayerState.isValidPlayerState(client)) {
                        throw new IllegalStateException("Invalid player state after fetching player data");
                    }
                    return runeProfileApiClient.updateProfileAsync(data);
                })
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        log.error("Error updating profile", ex);

                        final String errorMessage = Utils.getApiErrorMessage(ex, "Failed to update your profile.");

                        if (!isAutoSync) {
                            clientThread.invokeLater(() -> {
                                client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", errorMessage, "RuneProfile");
                            });
                        }

                        throw new RuneProfileApiException(errorMessage);
                    }

                    if (!isAutoSync) {
                        clientThread.invokeLater(() -> {
                            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Your profile has been updated!", "RuneProfile");
                        });
                    }

                    playerDataService.reset();
                });
    }

    public void updateModelAsync() {
        if (!PlayerState.isValidPlayerState(client)) {
            throw new IllegalStateException("Invalid player state");
        }

        playerDataService.getPlayerModelDataAsync().thenCompose((data) -> runeProfileApiClient.updateModelAsync(data)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        log.error("Error updating model", ex);

                        final String errorMessage = Utils.getApiErrorMessage(ex, "Failed to update your player model.");

                        clientThread.invokeLater(() -> {
                            client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", errorMessage, "RuneProfile");
                        });

                        throw new RuneProfileApiException(errorMessage);
                    }

                    clientThread.invokeLater(() -> {
                        client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", "Your player model has been updated!", "RuneProfile");
                    });
                }));
    }

    public void addActivitiesAsync(List<? extends Activity<? extends ActivityData>> activities) {
        if (!PlayerState.isValidPlayerState(client)) {
            throw new IllegalStateException("Invalid player state");
        }

        playerDataService.getAccountIdAsync().thenCompose((accountId) -> runeProfileApiClient.addActivities(new AddActivities(accountId, activities))).whenComplete((result, ex) -> {
            if (ex != null) {
                log.error("Error adding activities", ex);

                final String errorMessage = Utils.getApiErrorMessage(ex, "Failed to add activities.");

                clientThread.invokeLater(() -> {
                    client.addChatMessage(ChatMessageType.CONSOLE, "RuneProfile", errorMessage, "RuneProfile");
                });

                throw new RuneProfileApiException(errorMessage);
            }
        });
    }

}

/*
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import java.awt.*;

// Originally from RuneLite cache
// Additions made for calculating average of 3 colors
public final class JagexColor
{
	public static final double BRIGHTNESS_MAX = .6;
	public static final double BRIGHTNESS_HIGH = .7;
	public static final double BRIGHTNESS_LOW = .8;
	public static final double BRIGHTNESS_MIN = .9;

	private static final double HUE_OFFSET = (.5 / 64.D);
	private static final double SATURATION_OFFSET = (.5 / 8.D);

	private JagexColor()
	{
	}

	// take 3 Jagex HSL colors and make a single RGB color to represent them
	public static Color HSLtoRGBAvg(int hsl1, int hsl2, int hsl3)
	{
		Color c1 = new Color(HSLtoRGB((short) hsl1, BRIGHTNESS_MIN));
		Color c2 = new Color(HSLtoRGB((short) hsl2, BRIGHTNESS_MIN));
		Color c3 = new Color(HSLtoRGB((short) hsl3, BRIGHTNESS_MIN));

		// compute color average using squares
		// uses squared approach from https://sighack.com/post/averaging-rgb-colors-the-right-way
		int r = c1.getRed()*c1.getRed() + c2.getRed()*c2.getRed() + c3.getRed()*c3.getRed();
		int g = c1.getGreen()*c1.getGreen() + c2.getGreen()*c2.getGreen() + c3.getGreen()*c3.getGreen();
		int b = c1.getBlue()*c1.getBlue() + c2.getBlue()*c2.getBlue() + c3.getBlue()*c3.getBlue();

		r = (int) Math.round(Math.sqrt((double) r / 3.0d));
		g = (int) Math.round(Math.sqrt((double) g / 3.0d));
		b = (int) Math.round(Math.sqrt((double) b / 3.0d));

		return new Color(r, g, b);
	}

	public static short packHSL(int hue, int saturation, int luminance)
	{
		return (short) ((short) (hue & 63) << 10
				| (short) (saturation & 7) << 7
				| (short) (luminance & 127));
	}

	public static int unpackHue(short hsl)
	{
		return hsl >> 10 & 63;
	}

	public static int unpackSaturation(short hsl)
	{
		return hsl >> 7 & 7;
	}

	public static int unpackLuminance(short hsl)
	{
		return hsl & 127;
	}

	public static String formatHSL(short hsl)
	{
		return String.format("%02Xh%Xs%02Xl", unpackHue(hsl), unpackSaturation(hsl), unpackLuminance(hsl));
	}

	public static int HSLtoRGB(short hsl, double brightness)
	{
		double hue = (double) unpackHue(hsl) / 64.D + HUE_OFFSET;
		double saturation = (double) unpackSaturation(hsl) / 8.D + SATURATION_OFFSET;
		double luminance = (double) unpackLuminance(hsl) / 128.D;

		// This is just a standard hsl to rgb transform
		// the only difference is the offsets above and the brightness transform below
		double chroma = (1.D - Math.abs((2.D * luminance) - 1.D)) * saturation;
		double x = chroma * (1 - Math.abs(((hue * 6.D) % 2.D) - 1.D));
		double lightness = luminance - (chroma / 2);

		double r = lightness, g = lightness, b = lightness;
		switch ((int) (hue * 6.D))
		{
			case 0:
				r += chroma;
				g += x;
				break;
			case 1:
				g += chroma;
				r += x;
				break;
			case 2:
				g += chroma;
				b += x;
				break;
			case 3:
				b += chroma;
				g += x;
				break;
			case 4:
				b += chroma;
				r += x;
				break;
			default:
				r += chroma;
				b += x;
				break;
		}

		int rgb = ((int) (r * 256.0D) << 16)
				| ((int) (g * 256.0D) << 8)
				| (int) (b * 256.0D);

		rgb = adjustForBrightness(rgb, brightness);

		if (rgb == 0)
		{
			rgb = 1;
		}
		return rgb;
	}

	public static int adjustForBrightness(int rgb, double brightness)
	{
		double r = (double) (rgb >> 16) / 256.0D;
		double g = (double) (rgb >> 8 & 255) / 256.0D;
		double b = (double) (rgb & 255) / 256.0D;

		r = Math.pow(r, brightness);
		g = Math.pow(g, brightness);
		b = Math.pow(b, brightness);

		return ((int) (r * 256.0D) << 16)
				| ((int) (g * 256.0D) << 8)
				| (int) (b * 256.0D);
	}

	public static int[] createPalette(double brightness)
	{
		int[] colorPalette = new int[65536];
		for (int i = 0; i < colorPalette.length; i++)
		{
			colorPalette[i] = HSLtoRGB((short) i, brightness);
		}
		return colorPalette;
	}
}
/*
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import lombok.NonNull;
import net.runelite.api.Client;

import java.awt.Color;
import java.util.HashMap;
import java.util.Map;

public class TextureColor {
    private static final Map<Integer, Color> colorCache = new HashMap<>();

    // get single average color from Jagex texture id
    public static Color getColor(@NonNull Client client, int textureId) {
        if (colorCache.containsKey(textureId))
            return colorCache.get(textureId);

        int[] pixels = client.getTextureProvider().load(textureId);

        int r = 0;
        int g = 0;
        int b = 0;
        int n = 0;
        for (int pixel : pixels) {
            // skip transparent (black)
            if (pixel == 0)
                continue;

            Color c = new Color(pixel);
            r += c.getRed();
            g += c.getGreen();
            b += c.getBlue();
            n++;
        }

        Color c = new Color(r / n, g / n, b / n);
        colorCache.put(textureId, c);
        return c;
    }

}
/*
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.runeprofile.modelexporter;

import lombok.NonNull;
import net.runelite.api.Client;
import net.runelite.api.Model;

import java.awt.Color;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class ModelExporter {
    private final static int[] colorPalette = JagexColor.createPalette(JagexColor.BRIGHTNESS_MIN);

    public static byte[] toBytes(@NonNull Client client, Model m) throws IOException {
        List<Vertex> vertices = new ArrayList<>();
        for (int fi = 0; fi < m.getFaceCount(); fi++) {
            // determine vertex colors (textured or colored?)
            Color vc1;
            Color vc2;
            Color vc3;
            int textureId = -1;
            if (m.getFaceTextures() != null)
                textureId = m.getFaceTextures()[fi];
            if (textureId != -1) {
                // get average color of texture
                vc1 = TextureColor.getColor(client, textureId);
                vc2 = vc1;
                vc3 = vc1;
            } else {
                if (m.getFaceColors3()[fi] == -1) {
                    // face should be shaded flat
                    int colorIndex = m.getFaceColors1()[fi];
                    int rgbColor = colorPalette[colorIndex];
                    vc1 = vc2 = vc3 = new Color(rgbColor);
                } else {
                    // get color for each vertex
                    vc1 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors1()[fi], JagexColor.BRIGHTNESS_MIN));
                    vc2 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors2()[fi], JagexColor.BRIGHTNESS_MIN));
                    vc3 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors3()[fi], JagexColor.BRIGHTNESS_MIN));
                }
            }

            int vi1 = m.getFaceIndices1()[fi];
            int vi2 = m.getFaceIndices2()[fi];
            int vi3 = m.getFaceIndices3()[fi];

            int vx1 = (int) m.getVerticesX()[vi1];
            int vx2 = (int) m.getVerticesX()[vi2];
            int vx3 = (int) m.getVerticesX()[vi3];
            int vy1 = (int) -m.getVerticesY()[vi1];
            int vy2 = (int) -m.getVerticesY()[vi2];
            int vy3 = (int) -m.getVerticesY()[vi3];
            int vz1 = (int) m.getVerticesZ()[vi1];
            int vz2 = (int) m.getVerticesZ()[vi2];
            int vz3 = (int) m.getVerticesZ()[vi3];

            vertices.add(new Vertex(vx1, vy1, vz1, vc1.getRed(), vc1.getGreen(), vc1.getBlue()));
            vertices.add(new Vertex(vx2, vy2, vz2, vc2.getRed(), vc2.getGreen(), vc2.getBlue()));
            vertices.add(new Vertex(vx3, vy3, vz3, vc3.getRed(), vc3.getGreen(), vc3.getBlue()));
        }

        ByteArrayOutputStream ply = new ByteArrayOutputStream();
        PrintWriter plyHeader = new PrintWriter(ply);
        plyHeader.println("ply");
        plyHeader.println("format binary_little_endian 1.0");
        plyHeader.println("element vertex " + vertices.size());
        plyHeader.println("property int16 x");
        plyHeader.println("property int16 y");
        plyHeader.println("property int16 z");
        plyHeader.println("property uint8 red");
        plyHeader.println("property uint8 green");
        plyHeader.println("property uint8 blue");
        plyHeader.println("element face " + m.getFaceCount());
        plyHeader.println("property list uint8 int16 vertex_indices");
        plyHeader.println("end_header");
        plyHeader.flush();

        ByteArrayOutputStream w = new ByteArrayOutputStream();

        for (Vertex v : vertices) {
            // Y and Z axes are flipped
            w.write(le(v.x));
            w.write(le(v.z));
            w.write(le(v.y));
            w.write((byte) v.r);
            w.write((byte) v.g);
            w.write((byte) v.b);
        }

        for (int i = 0; i < m.getFaceCount(); ++i) {
            int vi = i * 3;
            w.write((byte) 3);
            w.write(le(vi));
            w.write(le(vi + 1));
            w.write(le(vi + 2));
        }

        w.flush();
        ply.write(w.toByteArray());
        return ply.toByteArray();
    }

    // int to little endian byte array
    private static byte[] le(int n) {
        byte[] b = new byte[2];
        b[0] = (byte) n;
        b[1] = (byte) (n >> 8);
        return b;
    }

    private static class Vertex {
        public int x, y, z;
        public int r, g, b;

        public Vertex(int x, int y, int z, int r, int g, int b) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.r = r;
            this.g = g;
            this.b = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Vertex vertex = (Vertex) o;
            return x == vertex.x && y == vertex.y && z == vertex.z && r == vertex.r && g == vertex.g && b == vertex.b;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y, z, r, g, b);
        }
    }

}
package com.runeprofile;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.runeprofile.data.*;
import com.runeprofile.utils.RuneProfileApiException;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLiteProperties;
import okhttp3.*;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

@Slf4j
public class RuneProfileApiClient {
    private static final MediaType JSON_MEDIA_TYPE = Objects.requireNonNull(MediaType.parse("application/json; charset=utf-8"));

    @Inject
    private OkHttpClient okHttpClient;

    private final String userAgent;

    // increment when making breaking changes to how the plugin users the API
    private static final String version = "2.0.0";

    private final HttpUrl baseUrl;

    @Inject
    private Gson gson;

    @Inject
    public RuneProfileApiClient() {
        boolean isDevMode = false;

        String runeliteVersion = RuneLiteProperties.getVersion();
        userAgent = "RuneLite:" + runeliteVersion + "," + "Client:" + version;

        //noinspection ConstantValue
        baseUrl = isDevMode
                ? new HttpUrl.Builder().scheme("http").host("localhost").port(8787).build()
                : new HttpUrl.Builder().scheme("https").host("api.runeprofile.com").build();
    }

    private HttpUrl buildApiUrl(String... pathSegments) {
        HttpUrl.Builder urlBuilder = baseUrl.newBuilder();
        for (String segment : pathSegments) {
            urlBuilder.addPathSegment(segment);
        }
        return urlBuilder.build();
    }

    private RequestBody createJsonBody(JsonObject jsonObject) {
        return RequestBody.create(JSON_MEDIA_TYPE, jsonObject.toString());
    }

    private Request.Builder buildApiRequest(HttpUrl url, Consumer<Request.Builder> methodSetter) {
        Request.Builder builder = new Request.Builder()
                .url(url)
                .header("Content-Type", "application/json")
                .header("User-Agent", userAgent);
        methodSetter.accept(builder);
        return builder;
    }

    private CompletableFuture<Response> executeHttpRequestAsync(OkHttpClient client, Request request) {
        CompletableFuture<Response> future = new CompletableFuture<>();
        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.error("Async API request failed.", e);
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) {
                future.complete(response);
            }
        });
        return future;
    }

    private CompletableFuture<Response> postHttpRequestAsync(HttpUrl url, String data) {
        RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, data);
        Request request = buildApiRequest(url, builder -> builder.post(body)).build();
        log.debug("Sending json request to = {}, data = {}", url.toString(), data);
        return executeHttpRequestAsync(okHttpClient, request);
    }

    private CompletableFuture<Response> postHttpRequestAsync(HttpUrl url, MultipartBody data) {
        Request request = buildApiRequest(url, builder -> builder.post(data)).build();
        log.debug("Sending form data request to = {}, data = {}", url.toString(), data);
        return executeHttpRequestAsync(okHttpClient, request);
    }

    private CompletableFuture<Response> getHttpRequestAsync(HttpUrl url) {
        Request request = buildApiRequest(url, Request.Builder::get)
                .build();
        return executeHttpRequestAsync(okHttpClient, request);
    }

    private CompletableFuture<Response> deleteHttpRequestAsync(HttpUrl url) {
        Request request = buildApiRequest(url, Request.Builder::delete)
                .build();
        return executeHttpRequestAsync(okHttpClient, request);
    }

    private <T> T handleResponse(Response response, @Nullable Class<T> clazz) {
        try (Response res = response) {
            ResponseBody body = res.body();

            if (body == null) {
                throw new RuneProfileApiException("Response body is null");
            }

            String bodyString = body.string();

            if (!response.isSuccessful()) {
                JsonObject json = gson.fromJson(bodyString, JsonObject.class);
                throw new RuneProfileApiException(json.get("message").getAsString());
            }

            if (clazz == null) {
                return null;
            }

            return gson.fromJson(bodyString, clazz);
        } catch (IOException e) {
            throw new RuneProfileApiException("Error reading response body");
        }
    }

    public CompletableFuture<Void> updateProfileAsync(PlayerData data) {
        HttpUrl url = buildApiUrl("profiles");
        return postHttpRequestAsync(url, gson.toJson(data))
                .thenApply((response) -> handleResponse(response, null));
    }

    public CompletableFuture<Void> updateModelAsync(PlayerModelData data) {
        HttpUrl url = buildApiUrl("profiles", "models");

        RequestBody modelFile = RequestBody.create(MediaType.parse("model/ply"), data.getModel());

        MultipartBody.Builder bodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("accountId", data.getAccountHash())
                .addFormDataPart("model", "model.ply", modelFile);

        @Nullable
        byte[] petModel = data.getPetModel();
        if (petModel != null) {
            RequestBody petFile = RequestBody.create(MediaType.parse("model/ply"), petModel);
            bodyBuilder.addFormDataPart("petModel", "pet.ply", petFile);
        }

        MultipartBody body = bodyBuilder.build();

        return postHttpRequestAsync(url, body)
                .thenApplyAsync((response -> handleResponse(response, null)));
    }

    public CompletableFuture<CollectionLogPage> getCollectionLogPage(String username, String page) {
        HttpUrl url = buildApiUrl("profiles", username, "collection-log", page);
        return getHttpRequestAsync(url)
                .thenApplyAsync((response -> handleResponse(response, CollectionLogPage.class)));
    }

    public CompletableFuture<ProfileSearchResult[]> searchProfiles(String query) {
        HttpUrl url = buildApiUrl("profiles")
                .newBuilder()
                .addQueryParameter("q", query)
                .build();
        return getHttpRequestAsync(url)
                .thenApplyAsync((response -> handleResponse(response, ProfileSearchResult[].class)));
    }

    public CompletableFuture<Void> setDefaultClogPage(DefaultClogPageData data) {
        HttpUrl url = buildApiUrl("profiles", "set-default-clog-page");
        return postHttpRequestAsync(url, gson.toJson(data))
                .thenApplyAsync((response) -> handleResponse(response, null));
    }

    public CompletableFuture<Void> addActivities(AddActivities data) {
        HttpUrl url = buildApiUrl("profiles", "activities");
        return postHttpRequestAsync(url, gson.toJson(data))
                .thenApplyAsync((response) -> handleResponse(response, null));
    }
}

package com.runeprofile;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RuneProfilePluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(RuneProfilePlugin.class);
		RuneLite.main(args);
	}
}
